--[[
███████╗██╗░░██╗███████╗░█████╗░██╗░░██╗░█████╗░░█████╗░██╗░░██╗░░░░█████╗░░█████╗░
██╔════╝╚██╗██╔╝██╔════╝██╔══██╗██║░░██║██╔══██╗██╔══██╗██║░██╔╝░░░██╔══██╗██╔══██╗
█████╗░░░╚███╔╝░█████╗░░██║░░╚═╝███████║███████║██║░░╚═╝█████═╝░░░░██║░░╚═╝██║░░╚═╝
██╔══╝░░░██╔██╗░██╔══╝░░██║░░██╗██╔══██║██╔══██║██║░░██╗██╔═██╗░░░░██║░░██╗██║░░██╗
███████╗██╔╝╚██╗███████╗╚█████╔╝██║░░██║██║░░██║╚█████╔╝██║░╚██╗██╗╚█████╔╝╚█████╔╝
╚══════╝╚═╝░░╚═╝╚══════╝░╚════╝░╚═╝░░╚═╝╚═╝░░╚═╝░╚════╝░╚═╝░░╚═╝╚═╝░╚════╝░░╚════╝░

HOSTNAME: Age of Clones | Clone Wars Roleplay | Eigener Spielmodus
IP: 94.199.215.95:27015
GAMEMODE: starwarsrp
MAP: rp_venator_extensive_v1_4
MAXPLAYERS: 128
ALL SERVER NETS: Undo_Undone, Undo_AddUndo, Undo_FireUndo, properties, drive_base, drive_noclip, editvariable, player_default, PlayerKilledNPC, NPCKilledNPC, PlayerKilled, PlayerKilledSelf, PlayerKilledByPlayer, DeathNoticeEvent, NetWrapperVar, NetWrapperRequest, NetWrapperClear, ArcCW_UC_CustColor, arccw_grenade_autoreload, arccw_grenade_hit, arccw_grenade_arcslow, arccw_grenade_loader, arccw_slidepos, arccw_colorindex, arccw_asktoattach, arccw_asktodetach, arccw_asktodrop, arccw_quicknade, arccw_npcgivereturn, arccw_rqwpnnet, arccw_sendconvar, arccw_applypreset, arccw_ttt_bodyattinfo, arccw_togglenum, arrcwstattracksend, Aura_LVS_Radar_Check_Friendly, LOUNGE_CHAT.Typing, LOUNGE_CHAT.TTTRadio, LOUNGE_CHAT.SendChat, FIRE_SendTruckModelCL, FIRE_CreateFireTruck, FIRE_RemoveFireTruck, FSpectate, FSpectateTarget, express_receivers_made, GMaps_POIResult, GMaps_POIDelete, GMaps_POI, GMaps_Nav, GMaps_Arrive, GAS.InitPostEntityNetworking, gmodadminsuite:offline_player_data_country_code, gmodadminsuite:teams:GetIdentifiers, gmodadminsuite:afk:InitPostEntity, gmodadminsuite:SetModuleEnabled, gmodadminsuite:logging:NetworkConfig, gmodadminsuite:logging:LiveLogs, gmodadminsuite:logging:LiveLog, gmodadminsuite:logging:LiveLogAntispam, gmodadminsuite:logging:ViewScene, gmodadminsuite:secondaryusergroups:GiveUsergroup, gmodadminsuite:secondaryusergroups:RevokeUsergroup, gmodadminsuite:secondaryusergroups:UsergroupGiven, gmodadminsuite:secondaryusergroups:UsergroupRevoked, gmodadminsuite:secondaryusergroups:SyncUsergroups, gmodadminsuite:secondaryusergroups:SyncAllUsergroups, gmodadminsuite:secondaryusergroups:GetAllData, gmodadminsuite:commands:ACTION_COMMANDS_MENU, gmodadminsuite:commands:ACTION_WEBSITE, gmodadminsuite:commands:ACTION_LUA_FUNCTION, gmodadminsuite:commands:ACTION_GAS_MODULE, gmodadminsuite:commands:NewCommand, gmodadminsuite:commands:DeleteCommand, gmodadminsuite:playerdatabase:GetPage, gmodadminsuite:menu_open, gmodadminsuite:send_server_data, gmodadminsuite:getmymodules, lscs_admin_setconvar, lscs_craft_saber, lscs_inventory_refresh, lvs_admin_setconvar, lvs_toggle_mouseaim, NetStreamRequest, NetStreamDownload, OpenPermissions.OpenMenu, OpenPermissions.NoPermissions, OpenPermissions.SavePermissions, OpenPermissions.PermissionsRegistry, OpenPermissions.NotAnAddon, SAM.NetStreamDS.Sending, JoeBase_AdminMenu, JoeBase_Refreshdata, AOCRP.SpawnNPC, SitAnywhere, Cuffs_GagPlayer, Cuffs_BlindPlayer, Cuffs_FreePlayer, Cuffs_DragPlayer, Cuffs_TiePlayers, Cuffs_UntiePlayers, TurretBlockAttackToggle, Venator_Ext_BorderNet, Venator_Ext_ColorNet, DSEnterCannon, DSLeaveCannon, Venator_Ext_AlarmNet, cl_anticrash_ChatPrint, cl_anticrash_ConsolePrint, sv_anticrash_RemoveEntitiesFrom, sv_anticrash_FreezeEntitiesFrom, sv_anticrash_SetCanSpawnGlobal, sv_anticrash_GlobalCleanup, sv_anticrash_TriggerAntiLagMeasures, AdvDupe2_ReportClass, AdvDupe2_ReportModel, AdvDupe2Notify, AdvDupe2_RemoveGhosts, AdvDupe2_ResetDupeInfo, AdvDupe2_StartGhosting, AdvDupe2_InitProgressBar, AdvDupe2_DrawSelectBox, AdvDupe2_RemoveSelectBox, AdvDupe2_UpdateProgressBar, AdvDupe2_RemoveProgressBar, AdvDupe2_ResetOffsets, AdvDupe2_SetDupeInfo, AdvDupe2_ReceiveFile, AdvDupe2_CanAutoSave, AdvDupe2_SendGhosts, AdvDupe2_AddGhost, JoeFort_UpdateTime, JoeFort_updatedata, JoeFort_updateresourcepool, XEON.Error, XEON.ReloadMap, GModSave, player_sandbox, drive_sandbox, player_aocrp, AOCRP.Kick, AOCRP.Voice, AOCRP.ReloadEvents, AOCRP.Unit.ReloadUnitData, AOCRP.Unit.RecieveInvite, AOCRP.UnitMgmt.AcceptInvite, AOCRP.UnitMgmt.Invite, entaction, AOCRP.Squad.Squadbefehl, AOCRP.Squad.SetSquad, AOCRP.Squad.SetSquadPos, AOCRP.Squad.SetSquadTeam, AOCRP.Squad.CreateMarker, AOCRP.Squad.MapCreateMarker, AOCRP.Ribbons.ReloadData, AOCRP.Ribbons.RequestData, AOCRP.Ribbons.SendData, AOCRP.Ribbons.SetActive, AOCRP.Ribbons.Save, AOCRP.QIM.CuffWeps, AOCRP_QIM_Vehicle_SetSkin, AOCRP_QIM_Vehicle_SetLock, AOCRP_QIM_Vehicle_SetAnfrage, AOCRP.API.RecieveSharedKey, AOCRP.Player.DisconnectSave, pp_info_send, AOCRP.Closet.Model, AOCRP.Closet.Skin, AOCRP.Closet.Bodygroup, AOCRP.Closet.Save, AOCRP.Medic.SendTasks, AOCRP.Medic.OpenDeathMenu, AOCRP_DoLeichensack, AOCRP.Medic.CallMedic, AOCRP.Medic.GiveUp, AOCRP.Medic.GiveUpMoney, AOCRP.Medic.StartMedicChat, AOCRP.Medic.SendMedicChat, AOCRP.Medic.RecieveMedicChat, AOCRP.Medic.EndChat, AOCRP.Medic.RequestEndChat, AOCRP.HUD.CutScene, AOCRP.HUD.CutSceneNew, AOCRP.HUD.Notification, AOCRP.HUD.SmallNotify, AOCRP.HUD.SmallNotifyWithTItle, AOCRP.GTM.ReloadPurchaseData, AOCRP.GTM.RecieveCloneID, AOCRP.GTM.RequestCloneID, AOCRP.GTM.RequestZivName, AOCRP.GTM.RecieveZivName, AOCRP.GTM.OpenItem, AOCRP.GTM.PlayerBuy, AOCRP.GTM.PlayerSell, AOCRP.GTM.PlayerApply, AOCRP.Gear.ReloadGears, AOCRP.Gear.CreateGear, AOCRP.Gear.UpdateGear, AOCRP.Gear.DeleteGear, sendWHData, sendWholeWHData, applyWepHolsterData, reloadWH, deleteWHData, reloadWholeWH, resetWHDataToDefault, resetWholeWHDataToDefault, WepHolsters_Settings, AOCRP.Waffenkiste.Action, AOCRP.VoiceDistance.Change, AOCRP.VoiceDistance.ChangeAnswer, AOCRP.SoundWithDistance, AOCRP.Music.Play, AOCRP.Music.Stop, AOCRP.Music.ChangeVolume, AOCRP.EventServerConnect, AOCRP.HauptServerConnect, AOCRP.Comlink.SetActiveChannel, AOCRP.Comlink.ComlinkSetInactive, AOCRP.Comlink.MuteChannel, AOCRP.Comlink.MuteData, AOCRP.Comlink.Calling.SetPartner, AOCRP.Comlink.Calling.RequestCall, AOCRP.Comlink.Calling.Dial, AOCRP.Comlink.Calling.ShowDial, AOCRP.Comlink.Calling.AcceptCall, AOCRP.Comlink.Calling.InACall, AOCRP.Comlink.Calling.DenyCall, AOCRP.Comlink.Calling.Hangup, AOCRP.Comlink.Calling.AbortDial, AOCRP.Comlink.Calling.RemoveWindows, AOCRP.Comlink.Calling.EndCallForcefully, AOCRP.Chat.ChatPrint, AOCRP.CharSys.OpenCharMenu, AOCRP.CharSys.OpenNewCharMenu, AOCRP.CharSys.OpenNewCharMenuError, AOCRP.CharSys.CreateNewCharRequest, AOCRP.CharSys.DeleteCharRequest, AOCRP.CharSys.ChooseCharacter, AOCRP.QuickSalute, AOCRP.EventCal.Add, AOCRP.Ability.LoadData, AOCRP.Ability.Run, AOCRP.Ability.Select, AOCRP.Ability.Buy, wOS.PES.SnoozeEvent, wOS.PES.Music, wOS.PES.Sound, wOS.PES.Sync.Setting, wOS.PES.Sync.Settings, AOCRP.Animation.DoWOS, COMMANDPAD_EntityInteractionOpen, AI_FLAMETHROWER_SHOOT, ClimbRoll, gmodadminsuite:gas_log_scanner:Init, AOCRPNextbots.SpawnDispenser, AOCRPNextbots.Spawn, ReceiveDupe, ArmDupe, CopiedDupe, DrawNoCollide, RmvPropsSQL, realistic_hook BreakFree, KeypadCracker_Hold, KeypadCracker_Sparks, nav_editor_mode, AOCRP_Fahrzeugspawner, AOCRP_Fahrzeugspawner_Spawn, AOCRP.Terminal.PlanetAssocChange, AOCRP.Terminal.ATCGlobal, AOCRP.Terminal.SetCurrentMenu, AOCRP.Terminal.ATCEntNotify, AOCRP.Terminal.ATCResetAnfrage, AOCRP.Terminal.ATCEntStatus, AOCRP.Terminal.SetTarget, AOCRP.Terminal.FireAtTarget, AOCRP_WAFFENKISTE, AOCRP_WAFFENKISTE_ARC, AOCRP_WAFFENKISTE_GIVE, AOCRP_WAFFENKISTE_TAKE, AOCRP_WAFFENKONSOLE, AOCRP_WAFFENKONSOLE_SELECT, SummeNextbots.Auqa.SpecialAbility, SetPlayersVisible, lvs_doorhandler_interact, C4_Convars_Change, textscreens_download, GPart.Restart, GPart.NotifyDead, SSE_ClientInteraction, SSE_InvalidateUseConfirm, SSE_Board_SetPage, SSE_BROADCAST_PlaySound, SSE_Closet_SetModel, SSE_Closet_SetSkin, SSE_Closet_SetBodygroup, SSE_WEAPONCONSOLE_SELECT, SSE_DataPad, SSE_RecieveDatapad_Data, SSE_RedownloadLightmaps, SSE_TELEPORTER_TELEPORT, SSE_TrainingRoomBoard_SaveData, SSE_TrainingRoomBoard_GiveUp, SSE_TRAININGROOM_CONTROL_SETOWNER, SSE_VehicleSpawn, SSE_VehicleSpawn_Spawn, SSE_WeaponBox_GIVE, SSE_WeaponBox_TAKE, worldspawn, player_manager, vgui_screen, simple_bot, weapon_citizensuitcase, weapon_citizenpackage, weapon_alyxgun, item_healthvial, item_healthkit, item_battery, weapon_tripmine, weapon_snark, monster_snark, scene_manager, weapon_crowbar_hl1, weaponbox, ammo_buckshot, ammo_rpgclip, ammo_357, ammo_argrenades, ammo_mp5grenades, ammo_9mmbox, ammo_9mmar, ammo_mp5clip, ammo_9mmclip, ammo_glockclip, ammo_gaussclip, ammo_egonclip, ammo_crossbow, weapon_oldmanharpoon, entityflame, weapon_stunstick, weapon_smg1, grenade_ar2, weapon_slam, npc_tripmine, npc_satchel, weapon_shotgun, weapon_rpg, rpg_missile, weapon_pistol, weapon_physcannon, weapon_frag, npc_grenade_frag, weapon_crowbar, weapon_crossbow, crossbow_bolt, weapon_ar2, prop_combine_ball, env_entity_dissolver, weapon_357, weapon_shotgun_hl1, weapon_satchel, weapon_rpg_hl1, weapon_mp5_hl1, weapon_hornetgun, weapon_handgrenade, weapon_glock_hl1, weapon_gauss, weapon_egon, weapon_crossbow_hl1, crossbow_bolt_hl1, weapon_357_hl1, weapon_physgun, weapon_swep, func_door, trigger_multiple, prop_vehicle_prisoner_pod, prop_dynamic, func_movelinear, env_smokestack, game_ui, env_steam, func_tracktrain, func_brush, func_physbox, env_bubbles, trigger_teleport, npc_launcher, func_monitor, trigger_physics_trap, func_illusionary, item_ammo_crate, point_camera, game_text, light_dynamic, trigger_hurt, sent_point, lua_run, env_fog_controller, env_sun, func_rotating, env_citadel_energy_core, func_breakable, env_flare, _firesmoke, phys_bone_follower, grenade_homer, XEON.Auth, sent_anim, aoc_sicherheitslevel, Models/effects/vol_light001, aoc_fahrzeugspawner, aoc_fahrzeugmarker, aoc_unitmarker, aoc_waffenschrank, models/lordtrilobite/imp_metalwall1_mat, bodyman_closet, aoc_ausbildung_boden, models/lordtrilobite/imp_floor2_mat, pp_prop_effect, aoc_ammobox, sammyservers_textscreen, joefort_ressource_1000, joefort_ressource_250, models/lordtrilobite/glass_clear_mat, models/lordtrilobite/imp_metalwall2_mat, aoc_medicbox, prop_physics, aoc_training, lvs_vehicle_repair, models/lordtrilobite/imp_floor1_mat, ace/sw/holobarrier, models/lordtrilobite/imp_metalceiling1_mat, aoc_jailmarker, aoc_ausbildung_tafel, models/debug/debugwhite, ace/sw/hologram, aoc_keypad, aoc_waffenkiste, models/props_combine/stasisshield_sheet, aoc_gearmarker, prop_animatable, aoc_terminal, aoc_waffenabgabe, aoc_textscreen, sse_lightswitch, phoenix_s
LUA TOTAL: 2392
--]]
--Stealed clientside server code by exechack.cc
--Hostname: Age of Clones | Clone Wars Roleplay | Eigener Spielmodus - Part 1/12 - 06/04/2025


--PATH lua/autorun/aoc_501st.lua:
player_manager.AddValidModel( "GTM Test", 		"models/starwars/grady/aoc/501st/tc/501st_trooper_test.mdl" );
list.Set( "PlayerOptionsModel", "GTM Test", 	"models/starwars/grady/aoc/501st/tc/501st_trooper_test.mdl" );
--lua/arccw/shared/sh_0_uc.lua:
hook.Add("Initialize", "ArcCW_Plinking", function()
    game.AddAmmoType({
        name = "plinking",
    })

    if CLIENT then
        language.Add("plinking_ammo", "Plinking Ammo")
    end
end)

sound.Add({
    name = "DB_ADD",
    channel = CHAN_AUTO,
    volume = 1.0,
    level = 100,
    sound = {"^arccw_uc/common/db_add_1.ogg", "^arccw_uc/common/db_add_2.ogg", "^arccw_uc/common/db_add_3.ogg"}
})

CreateConVar("arccw_uc_infiniteubwammo", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Infinite underbarrel weapon ammo.")
CreateConVar("arccw_uc_apobjmult", 3, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Damage multiplier against vehicles and objects.")

game.AddParticles("particles/muzzleflash_dragonsbreath.pcf")
PrecacheParticleSystem("muzzleflash_dragonbreath")
game.AddParticles("particles/uo_explosions_fas2.pcf")
PrecacheParticleSystem("explosion_HE_m79_fas2")
PrecacheParticleSystem("explosion_he_grenade_fas2")
PrecacheParticleSystem("explosion_HE_claymore_fas2")
PrecacheParticleSystem("explosion_grenade_fas2")
ArcCW.UC = {}

ArcCW.UC.BodyDamageMults = {
    [HITGROUP_HEAD] = 3.5,
    [HITGROUP_CHEST] = 1.15,
    [HITGROUP_STOMACH] = 1,
    [HITGROUP_LEFTARM] = 0.85,
    [HITGROUP_RIGHTARM] = 0.85,
    [HITGROUP_LEFTLEG] = 0.5,
    [HITGROUP_RIGHTLEG] = 0.5,
}

ArcCW.UC.BodyDamageMults_Shotgun = {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_STOMACH] = 1,
    [HITGROUP_LEFTARM] = 0.85,
    [HITGROUP_RIGHTARM] = 0.85,
    [HITGROUP_LEFTLEG] = 0.5,
    [HITGROUP_RIGHTLEG] = 0.5,
}

ArcCW.UC.RifleAmmoTypes = {
    ["smg1"] = true,
    ["ar2"] = true,
    ["SniperPenetratedRound"] = true
}

ArcCW.UC.PistolAmmoTypes = {
    ["pistol"] = true,
    ["357"] = true,
    ["plinking"] = true
}


local common = ")^/arccw_uc/common/"
ArcCW.UC.DrawSounds = {
    {s = common .. "raise.ogg", t = 0},
    {s = common .. "shoulder.ogg", t = 0.15},
    {s = common .. "rattle.ogg", t = 0.2},
}

ArcCW.UC.HolsterSounds = {
    {s = common .. "rattle.ogg", t = 0},
    {s = common .. "cloth_6.ogg", t = 0.2},
}

ArcCW.UC.SubsonicThreshold = 340

-- Refer to http://www.ballisticsbytheinch.com/ for muzzle velocity per barrel length if possible
ArcCW.UC.StdDmg = {
    -- Pistol/plinking calibers
    ["22lr"] = {
        max = 12,
        min = 7,
        pen = 3,
        vel = 330
    },
    ["9mm"] = {
        max = 30,
        min = 17,
        pen = 6,
        vel = 380
    },
    ["10mm"] = {
        max = 35,
        min = 20,
        pen = 8,
        vel = 400
    },
    ["380acp"] = {
        max = 30,
        min = 15,
        pen = 3,
        vel = 390
    },
    ["40sw"] = {
        max = 30,
        min = 23,
        pen = 8,
        vel = 340
    },
    ["45acp"] = {
        max = 45,
        min = 15,
        pen = 9,
        vel = 250
    },
    ["357sig"] = {
        max = 33,
        min = 17,
        pen = 6,
        vel = 440
    },
    -- Magnum calibers
    ["357"] = {
        max = 60,
        min = 20,
        pen = 9,
        vel = 430
    },
    ["44"] = {
        max = 75,
        min = 16,
        pen = 10,
        vel = 360
    },
    ["50ae"] = {
        max = 80,
        min = 12,
        pen = 12,
        vel = 450
    },
    ["50beo"] = {
        max = 80,
        min = 20,
        pen = 12,
        vel = 540
    },
    -- Carbine/rifle calibers
    ["57fn"] = {
        max = 28,
        min = 20,
        pen = 15,
        vel = 910
    }, -- 5.7x28mm FN
    ["556"] = {
        max = 34,
        min = 20,
        pen = 14,
        vel = 910
    },
    ["300blk"] = {
        max = 40,
        min = 15,
        pen = 10,
        vel = 310
    },
    ["545"] = {
        max = 40,
        min = 20,
        pen = 12,
        vel = 880
    },
    ["762_39"] = {
        max = 50,
        min = 25,
        pen = 16,
        vel = 730
    }, -- 7.62x39, not 7.62x51 NATO
    ["762_51"] = {
        max = 65,
        min = 35,
        pen = 20,
        vel = 850
    }, -- 7.62x51 NATO
    ["366"] = {
        max = 60,
        min = 30,
        pen = 18,
        vel = 600
    }, -- .366 TKM
    -- Shotgun calibers
    ["12g_p"] = {
        max = 20,
        min = 13,
        pen = 2,
        num = 8,
        vel = 400
    }, -- Pump
    ["12g_s"] = {
        max = 18,
        min = 10,
        pen = 2,
        num = 8,
        vel = 400
    }, -- Semi
    ["410b"] = {
        max = 18,
        min = 5,
        pen = 2,
        vel = 400
    },
    -- Sniper calibers
    ["338"] = {
        max = 85,
        min = 160,
        pen = 36,
        vel = 1000
    },
    ["300"] = {
        max = 44,
        min = 85,
        pen = 24,
        vel = 950
    },
    ["50bmg"] = {
        max = 104,
        min = 180,
        pen = 46,
        vel = 920
    },
}

function ArcCW.UC.CalConv(from, to, stat)
    return math.Round(ArcCW.UC.StdDmg[to][stat] / ArcCW.UC.StdDmg[from][stat], 2)
end

ArcCW.UC.ADSReload = function(wep)
    if IsValid(wep) and wep.ArcCW then
        local vm = wep:GetOwner():GetViewModel()

        local delta = 1-wep:GetSightDelta()

        local bipoded = wep:GetInBipod()
        wep.ADSBipodAnims = math.Approach(wep.ADSBipodAnims or 0, bipoded and 1 or 0, FrameTime() / 0.5)

        vm:SetPoseParameter("sights", Lerp( math.ease.InOutCubic(math.max(delta, wep.ADSBipodAnims)), 0, 1)) -- thanks fesiug
    end
end

-- right forward up
local traces1 = {
    {
        Distance = Vector(0, 0, 1024),
        Influence = 1,
    }, -- Up

}

local traces2 = {
    {
        Distance = Vector(0, 0, 1024),
        Influence = 1,
    }, -- Up
    {
        Distance = Vector(768, 768, 0),
        Influence = 0.5,
    }, -- Right
    {
        Distance = Vector(-768, 768, 0),
        Influence = 0.5,
    }, -- Left

}

local traces3 = {
    {
        Distance = Vector(0, 0, 1024),
        Influence = 0,
    }, -- Up
    {
        Distance = Vector(0, 768, 768),
        Influence = 1,
    }, -- Up Forward
    {
        Distance = Vector(0, -768, 768),
        Influence = 1,
    }, -- Up Back
    {
        Distance = Vector(0, 768, 0),
        Influence = 0.5,
    }, -- Forward
    {
        Distance = Vector(768, 768, 0),
        Influence = 0.5,
    }, -- Right
    {
        Distance = Vector(-768, 768, 0),
        Influence = 0.5,
    }, -- Left

}

local traces4 = {
    {
        Distance = Vector(0, 0, 1024),
        Influence = 0.5,
    }, -- Up
    {
        Distance = Vector(0, 768, 768),
        Influence = 1,
    }, -- Up Forward
    {
        Distance = Vector(0, -768, 768),
        Influence = 1,
    }, -- Up Back
    {
        Distance = Vector(0, 768, 0),
        Influence = 0.5,
    }, -- Forward
    {
        Distance = Vector(0, -1024, 0),
        Influence = 0.5,
    }, -- Back
    {
        Distance = Vector(768, 768, 0),
        Influence = 0.5,
    }, -- Right
    {
        Distance = Vector(-768, 768, 0),
        Influence = 0.5,
    }, -- Left
    {
        Distance = Vector(-768, -768, 0),
        Influence = 0.5,
    }, -- Left Back
    {
        Distance = Vector(768, -768, 0),
        Influence = 0.5,
    }, -- Right Back

}

-- Halve the magnification because
-- real people have like 180 degrees of vision AND
-- it's too high to be useful and
-- games like to make it shorter why shouldn't we
function UC_HalfScope( num )
    local result = num
    result = num - 1
    result = result / 2
    result = result + 1

    -- print( num .. "x turned into " .. result .. "x" )
    return result
end

local tracebase = {
    start = 0,
    endpos = 0,
    filter = NULL,
}

local choice = {
    [1] = traces1,
    [2] = traces2,
    [3] = traces3,
    [4] = traces4,
}

if game.SinglePlayer() and SERVER then
    util.AddNetworkString("ArcCW_UC_InnyOuty")
elseif game.SinglePlayer() and CLIENT then
    net.Receive("ArcCW_UC_InnyOuty", function(len, ply)
        local ent = net.ReadEntity()
        if IsValid(ent) then
            ArcCW.UC.InnyOuty(ent)
        end
    end)
end

ArcCW.UC.InnyOuty = function(wep)
    if wep:GetBuff_Override("UC_NoInnyOuty") then return end

    local dist = wep:GetBuff_Hook("Hook_GetDistantShootSound")
    if dist == false then return end

    if game.SinglePlayer() and SERVER then
        net.Start("ArcCW_UC_InnyOuty")
        net.WriteEntity(wep)
        net.Send(Entity(1))
    elseif CLIENT and (wep:GetOwner() == LocalPlayer() or game.SinglePlayer()) then
        if wep.DistantShootSoundOutdoors and wep.DistantShootSoundIndoors then
            local dso = wep.DistantShootSoundOutdoors
            local dsi = wep.DistantShootSoundIndoors
            local dsov = wep.DistantShootSoundOutdoorsVolume
            local dsiv = wep.DistantShootSoundIndoorsVolume

            if wep:GetBuff_Override("Silencer") then
                if wep:GetBuff("PhysBulletMuzzleVelocity") < ArcCW.UC.SubsonicThreshold then--if wep:CheckFlags(nil, {"powder_subsonic"}) or wep:CheckFlags(nil, {"cal_subsonic"}) then
                    return -- no tail
                else
                    dso = wep.DistantShootSoundOutdoorsSilenced
                    dsi = wep.DistantShootSoundIndoorsSilenced
                end
            end

            dso = wep:GetBuff_Hook("Hook_GetDistantShootSoundOutdoors", dso)
            dsi = wep:GetBuff_Hook("Hook_GetDistantShootSoundIndoors", dsi)
            local vol = 0
            local wo = wep:GetOwner()
            if !IsValid(wo) then return end
            local wop = wo:EyePos()
            local woa = Angle(0, wo:EyeAngles().y, 0)
            local t_influ = 0
            local option = GetConVar("arccw_uc_disttrace"):GetInt()
            local fps = 1 / RealFrameTime()

            if wep:GetOwner() ~= LocalPlayer() then
                option = choice[1]
            elseif option > 0 then
                option = choice[option]
            else
                if fps > 100 then
                    option = 4
                elseif fps > 40 then
                    option = 3
                else
                    option = 2
                end

                if GetConVar("developer"):GetInt() > 1 then
                    print("perf" .. option)
                end

                option = choice[option]
            end

            for _, tin in ipairs(option) do
                tracebase.start = wop
                offset = Vector()
                --if !tin.AngleUp then--_ != 1 then
                offset = offset + (tin.Distance.x * woa:Right())
                offset = offset + (tin.Distance.y * woa:Forward())
                offset = offset + (tin.Distance.z * woa:Up())
                --end
                tracebase.endpos = wop + offset
                tracebase.filter = wo
                t_influ = t_influ + (tin.Influence or 1)
                local result = util.TraceLine(tracebase)
                if GetConVar("developer"):GetInt() > 2 then
                    debugoverlay.Line(wop - (vector_up * 4), result.HitPos - (vector_up * 4), 1, Color((_ / 4) * 255, 0, (1 - (_ / 4)) * 255))
                    debugoverlay.Text(result.HitPos - (vector_up * 4), math.Round((result.HitSky and 1 or result.Fraction) * 100) .. "%", 1)
                end
                vol = vol + (result.HitSky and 1 or result.Fraction) * tin.Influence
            end

            vol = vol / t_influ

            if GetConVar("developer"):GetInt() > 1 then
                print(vol)
            end

            if dso then
                for _, snd in ipairs(dso) do
                    wep:StopSound(snd)
                end

                if math.max(0.15, vol) ~= 0.15 then
                    wep:EmitSound(dso[math.random(1, #dso)], 75, 100, vol * dsov or 1, CHAN_VOICE2)
                end
            end

            if dsi then
                for _, snd in ipairs(dsi) do
                    wep:StopSound(snd)
                end

                if math.min(0.85, vol) ~= 0.85 then
                    wep:EmitSound(dsi[math.random(1, #dsi)], 75, 100, (1 - vol) * dsiv or 1, CHAN_STREAM)
                end
            end
        end
    end
end

ArcCW.UC.CustColorUpdateInterval = 5

if CLIENT then
    CreateClientConVar("arccw_uc_disttrace", 0, true, false, "Mode for traces", 0, 4)
    CreateClientConVar("arccw_uc_custcolor_enable", 255, true, true, "1 for custom colors, 0 for playermodel color", 0, 1)
    CreateClientConVar("arccw_uc_custcolor_1_r", 255, true, true, "Main color R", 0, 255)
    CreateClientConVar("arccw_uc_custcolor_1_g", 255, true, true, "Main color G", 0, 255)
    CreateClientConVar("arccw_uc_custcolor_1_b", 255, true, true, "Main color B", 0, 255)
    CreateClientConVar("arccw_uc_custcolor_2_r", 255, true, true, "Second color R", 0, 255)
    CreateClientConVar("arccw_uc_custcolor_2_g", 255, true, true, "Second color G", 0, 255)
    CreateClientConVar("arccw_uc_custcolor_2_b", 255, true, true, "Second color B", 0, 255)

    -- CreateClientConVar("arccw_uc_menu", 1, true, false, "Cool menu!", 0, 1)

    -- These convars are already known serverside; this only serves to tell the server it's time to update our colors to other clients.
    if not game.SinglePlayer() then
        local t = "ArcCW_UC_UpdateColor"
        local custcolorcallback = function(cvar, old, new)
            if timer.Exists(t) then
                timer.Adjust(t, ArcCW.UC.CustColorUpdateInterval)
            else
                timer.Create(t, ArcCW.UC.CustColorUpdateInterval, 1, function()
                    net.Start("ArcCW_UC_CustColor")
                    net.SendToServer()
                end)
            end
        end
        cvars.AddChangeCallback("arccw_uc_custcolor_enable", custcolorcallback)
        cvars.AddChangeCallback("arccw_uc_custcolor_1_r", custcolorcallback)
        cvars.AddChangeCallback("arccw_uc_custcolor_1_g", custcolorcallback)
        cvars.AddChangeCallback("arccw_uc_custcolor_1_b", custcolorcallback)
        cvars.AddChangeCallback("arccw_uc_custcolor_2_r", custcolorcallback)
        cvars.AddChangeCallback("arccw_uc_custcolor_2_g", custcolorcallback)
        cvars.AddChangeCallback("arccw_uc_custcolor_2_b", custcolorcallback)
    end

    matproxy.Add({
        name = "UC_ShellColor",
        init = function(self, mat, values)
            --self.envMin = values.min
            --self.envMax = values.max
            self.col = Vector()
        end,
        bind = function(self, mat, ent)
            local swent = ent

            if IsValid(swent) then
                local herg = color_white
                local r = 255
                local g = 255
                local b = 255

                if swent:IsWeapon() and swent.ArcCW then
                    herg = swent:GetBuff_Override("Override_UC_ShellColor") or swent.UC_ShellColor or herg
                    r = herg.r or 255
                    g = herg.g or 255
                    b = herg.b or 255
                elseif IsValid(swent:GetOwner()) and IsValid(swent:GetOwner():GetActiveWeapon()) and swent:GetOwner():GetActiveWeapon().ArcCW then
                    swent = swent:GetOwner():GetActiveWeapon()
                    herg = swent:GetBuff_Override("Override_UC_ShellColor") or swent.UC_ShellColor or herg
                    r = herg.r or 255
                    g = herg.g or 255
                    b = herg.b or 255
                elseif swent then
                    herg = swent.UC_ShellColor or herg
                    r = herg.r or 255
                    g = herg.g or 255
                    b = herg.b or 255
                end

                self.col.x = r / 255
                self.col.y = g / 255
                self.col.z = b / 255
                mat:SetVector("$color2", self.col)
            end
        end
    })

    local function proxystuff(digit)
        return {
            name = "UC_Weapon_Color" .. digit,
            init = function(self, mat, values)
                self.ResultTo = values.resultvar
            end,
            bind = function(self, mat, ent)
                local owner = ent:GetOwner()

                if IsValid(ent) and ent.ArcCW and IsValid(owner) and owner:IsPlayer() then
                    local net_color = owner["UC_CustColor" .. digit]
                    if (owner == LocalPlayer() and owner:GetInfoNum("arccw_uc_custcolor_enable", 0) == 1) or (owner.UC_CustEnable and net_color) then -- ply.UC_CustEnable
                        if net_color then
                            mat:SetVector(self.ResultTo, Vector(net_color.r, net_color.g, net_color.b) / 230)
                        else
                            mat:SetVector(self.ResultTo, Vector(owner:GetInfoNum("arccw_uc_custcolor_" .. digit .. "_r", 255), owner:GetInfoNum("arccw_uc_custcolor_" .. digit .. "_g", 255), owner:GetInfoNum("arccw_uc_custcolor_" .. digit .. "_b", 255)) / 230)
                        end
                    else
                        mat:SetVector(self.ResultTo, owner:GetPlayerColor() * 0.9)
                    end
                    -- else
                    -- mat:SetVector(self.ResultTo, Vector(0.8, 0.8, 0.8))
                end
            end
        }
    end

    matproxy.Add(proxystuff(1))
    matproxy.Add(proxystuff(2))

    net.Receive("ArcCW_UC_CustColor", function()
        local ply = net.ReadEntity()
        ply.UC_CustEnable = net.ReadBool()
        if ply.UC_CustEnable then
            ply.UC_Weapon_Color1 = net.ReadColor(false)
            ply.UC_Weapon_Color2 = net.ReadColor(false)
        end
    end)

    local function menu_uc(panel)
        panel:AddControl("header", {
            description = "This menu contains options for configuring Urban Coalition weapons and items."
        })

        local combobox = panel:ComboBox("Trace count", "arccw_uc_disttrace") --vgui.Create( "DComboBox", panel )
        combobox:SetSortItems(false)
        combobox:AddChoice("Automatic", 0)
        combobox:AddChoice("1-way (performance, not recommended)", 1)
        combobox:AddChoice("3-way (default)", 2)
        combobox:AddChoice("6-way (expensive)", 3)
        combobox:AddChoice("9-way (absurd)", 4)
        panel:ControlHelp("How accurate should the weapon tail calculation be for when used outdoors or indoors?")

        panel:AddControl("header", {
            description = "________________"
        })

        -- idk write better   Write something about list of guns that supports it or something
        panel:AddControl("checkbox", {
            label = "Use defined colors for customisation",
            command = "arccw_uc_custcolor_enable"
        })
        panel:ControlHelp("will use playermodel color if off")
    
        panel:AddControl("checkbox", {
            label = "Infinite Underbarrel Ammo",
            command = "arccw_uc_infiniteubwammo"
        })
        panel:ControlHelp("Infinite ammo for Urban Coalition underbarrel weapons.")
    
        panel:AddControl("slider", {
            label = "AP Damage Mult",
            command = "arccw_uc_apobjmult",
            min = 1,
            max = 10,
        })
        panel:ControlHelp("Multiplier for damage dealt to objects while using 'Armor-piercing' rounds.")

        panel:AddControl("color", {
            label = "Primary Color",
            red = "arccw_uc_custcolor_1_r",
            green = "arccw_uc_custcolor_1_g",
            blue = "arccw_uc_custcolor_1_b"
        })

        panel:AddControl("color", {
            label = "Secondary Color",
            red = "arccw_uc_custcolor_2_r",
            green = "arccw_uc_custcolor_2_g",
            blue = "arccw_uc_custcolor_2_b"
        })

        panel:AddControl("header", {
            description = "________________"
        })
        panel:AddControl("header", {
            description = "Asset precaching"
        })

        panel:AddControl("button", {
            label = "Clientside Asset Cache",
            command = "arccw_uc_cache_client"
        })
        panel:ControlHelp("Begin a clientside caching of all Urban Coalition assets.")
        panel:AddControl("slider", {
            label = "Attempts per second",
            command = "arccw_uc_cache_client_persecond",
            min = 10,
            max = 60,
        })

        panel:AddControl("button", {
            label = "Serverside Asset Cache",
            command = "arccw_uc_cache_server"
        })
        panel:ControlHelp("Command the server to do a caching of all Urban Coalition assets.")
    end

    hook.Add("PopulateToolMenu", "ARCCW_UC_MenuOptions", function()
        spawnmenu.AddToolMenuOption("Options", "ArcCW", "ArcCW_UC", "Urban Coalition", "", "", menu_uc)
    end)

elseif SERVER then

    util.AddNetworkString("ArcCW_UC_CustColor")

    net.Receive("ArcCW_UC_CustColor", function(len, ply)
        if (ply.UC_LastColorUpdate or 0) + ArcCW.UC.CustColorUpdateInterval > CurTime() then return end
        ply.UC_LastColorUpdate = CurTime()
        net.Start("ArcCW_UC_CustColor")
            local enabled = tobool(ply:GetInfoNum("arccw_uc_custcolor_enable", 0))
            net.WriteBool(enabled)
            if enabled then
                net.WriteColor(Color(ply:GetInfoNum("arccw_uc_custcolor_1_r", 255), ply:GetInfoNum("arccw_uc_custcolor_1_g", 255), ply:GetInfoNum("arccw_uc_custcolor_1_b", 255)), false)
                net.WriteColor(Color(ply:GetInfoNum("arccw_uc_custcolor_2_r", 255), ply:GetInfoNum("arccw_uc_custcolor_2_g", 255), ply:GetInfoNum("arccw_uc_custcolor_2_b", 255)), false)
            end
        net.SendOmit(ply)
    end)
end

hook.Add("ArcCW_InitBulletProfiles", "UrbanCoalition", function()
    ArcCW:AddBulletProfile("uc_tracer_g", {
        color = Color(100, 255, 100),
        size = 1.5,
        size_min = 2,
        tail_length = 0.05,
    })

    ArcCW:AddBulletProfile("uc_tracer_r", {
        color = Color(255, 100, 100),
        size = 1.5,
        size_min = 2,
        tail_length = 0.05,
    })

    ArcCW:AddBulletProfile("uc_tracer_w", {
        color = Color(255, 255, 255),
        size = 1.5,
        size_min = 2,
        tail_length = 0.05,
    })

    ArcCW:AddBulletProfile("uc_plinking", {
        color = Color(255, 255, 255, 200),
        size = 0.5,
        size_min = 0.25,
        tail_length = 0.03,
    })

    ArcCW:AddBulletProfile("uc_api", {
        color = Color(255, 175, 100),
        size = 1,
        size_min = 1,
        tail_length = 0.05,
    })

    ArcCW:AddBulletProfile("uc_dragon", {
        color = Color(255, 220, 175),
        sprite_head = false,
        sprite_tail = false,

        DrawBullet = function(bulinfo, bullet)

            if CurTime() - bullet.StartTime <= 0.05 then return end
            local a = bullet.PosStart and Lerp((bullet.PosStart - bullet.Pos):LengthSqr() / 40000, 0, 1) or 0
            if a == 0 then return end

            -- Do not try to keep emitting while time is frozen (singleplayer pause)
            if bullet.LastTick and bullet.LastTick == CurTime() then return end
            bullet.LastTick = CurTime()

            local emitter = ParticleEmitter(bullet.Pos)
            if not IsValid(emitter) then return end

            local vec = bullet.Vel * engine.TickInterval()
            local count = math.ceil(vec:Length() / 12)

            local count2 = math.ceil(math.sqrt(count) / 3 * a)
            for j = 1, count2 do
                local p = bullet.Pos - vec * (j / count2) + VectorRand() * math.Clamp((CurTime() - bullet.StartTime) / 0.5, 0, 8)

                local spark = emitter:Add("effects/spark", p)
                spark:SetVelocity(VectorRand() * 100 + vec * 0.75)
                spark:SetGravity(Vector(math.Rand(-10, 10), math.Rand(-10, 10), -75))
                spark:SetDieTime(math.Rand(0.15, 0.2))
                spark:SetStartAlpha(255)
                spark:SetEndAlpha(0)
                spark:SetStartSize(math.Rand(3, 6))
                spark:SetEndSize(0)
                spark:SetRoll(math.Rand(-180, 180))
                spark:SetRollDelta(math.Rand(-0.2, 0.2))
                spark:SetColor(255, 220, 175)
                spark:SetAirResistance(50)
                spark:SetLighting(false)
                spark:SetCollide(true)
                spark:SetBounce(0.8)
            end

            emitter:Finish()
            bullet.RenderTick = (bullet.RenderTick or 0) + 1
        end,

        PhysBulletHit = function(bulinfo, bullet, tr)
            if not CLIENT then return end

            local emitter = ParticleEmitter(bullet.Pos)
            if not IsValid(emitter) then return end

            local dir = bullet.Vel:GetNormalized()
            local reflect = dir:Dot(tr.HitNormal) * 2 * tr.HitNormal  - dir
            local vec = (reflect + VectorRand() * 0.1):GetNormalized()

            for i = 1, math.random(16, 32) do
                local ember = emitter:Add("effects/spark", tr.HitPos + VectorRand() * 4)
                ember:SetVelocity(VectorRand() * 100 - vec * math.Rand(100, 500) + Vector(0, 0, math.Rand(75, 150)))
                ember:SetGravity(Vector(0, 0, -600))
                ember:SetDieTime(math.Rand(0.6, 1.2))
                ember:SetStartAlpha(255)
                ember:SetEndAlpha(0)
                ember:SetStartSize(math.Rand(3, 6))
                ember:SetEndSize(0)
                ember:SetRoll(math.Rand(-180, 180))
                ember:SetRollDelta(math.Rand(-0.2, 0.2))
                ember:SetColor(255, 220, 175)
                ember:SetAirResistance(80)
                ember:SetLighting(false)
                ember:SetCollide(true)
                ember:SetBounce(0.5)
            end

            emitter:Finish()
        end
    })
end)

local paths = {
    "sound/weapons/arccw/",
    "sound/weapons/arccw_ud/",
    "sound/weapons/arccw_ur/",
    "sound/weapons/arccw_uo/",
    "sound/weapons/arccw_uc_ar57/",
    "sound/weapons/arccw_uc_galil/",
    "sound/weapons/arccw_uc_lynx/",
    "sound/weapons/arccw_uc_usp/",
    "sound/arccw_uc/",
    "sound/weapons/arccw/",
    "models/weapons/arccw/",
    "models/items/arccw/",

    "models/uc/",
    "sound/uc/",
}

if CLIENT then
    local procedure = {
        ["sound"] = function(asset)
            asset = string.Replace( asset, "sound\\", "" )
            asset = string.Replace( asset, "sound/", "" )
            if !IsValid(LocalPlayer()) then
                print("LocalPlayer is NULL! You're too early!!")
            else
                LocalPlayer():EmitSound( asset, 75, 100, 0.01, CHAN_WEAPON )
            end
        end,
        ["model"] = function(asset)
            local cmdl = ClientsideModel( asset )
            cmdl:Remove()
        end,
    }

    local cooltable = {}
    function fukc()
        local function recurse( path, dir )
            local files, directories = file.Find( path .. (dir and (dir .. "/") or "") .. "*", "GAME" )
            for i, fie in ipairs(files) do
                local fiex = string.GetExtensionFromFilename(fie)
                if fiex == "ogg" or fiex == "wav" or fiex == "mp3" or fiex == "mdl" then
                    table.insert( cooltable, path .. (dir and (dir .. "/") or "") .. fie )
                end
            end
            for i, dir in ipairs(directories) do
                recurse( path, dir )
            end
        end

        cooltable = {}

        UC_Precache = true
        UC_PrecachePer = 0
        UC_PrecachePeh = 0
        UC_PrecacheCur = "..."
        for i, path in ipairs(paths) do
            recurse( path )
        end

        -- PrintTable(cooltable)

        for i, fie in ipairs(cooltable) do
            timer.Simple(i / GetConVar("arccw_uc_cache_client_persecond"):GetFloat(), function()
                UC_PrecachePer = i
                UC_PrecachePeh = #cooltable
                UC_PrecacheCur = fie
                local fiex = string.GetExtensionFromFilename(fie)
                if fiex == "ogg" or fiex == "wav" or fiex == "mp3" then
                    procedure["sound"](fie)
                elseif fiex == "mdl" then
                    procedure["model"](fie)
                elseif fiex == "phy" or fiex == "vvd" or fiex == "vtx" then
                    -- ignore these
                else
                    print("Unknown what to do with " .. fie .. "!")
                end
                if i == #cooltable then UC_Precache = false end
            end)
        end
    end

    hook.Add("HUDPaint", "UC_Precache", function()
        if UC_Precache then
            local i_1 = UC_PrecachePer or 1
            local i_2 = UC_PrecachePeh or 1
            local i_per = i_1 / i_2
            local i_cur = UC_PrecacheCur or "..."
            surface.SetDrawColor(255, 255, 255, 255)
            local ss = ScreenScale(1) * GetConVar("arccw_hud_size"):GetFloat()
            local bx, by = (ss * 150), (ss * 10)

            -- Bar
            surface.DrawOutlinedRect( ( ScrW() / 2 ) - ( bx / 2 ), ( ScrH() * 0.7 ) - ( by / 2 ), bx, by, 2 )
            surface.DrawRect( ( ScrW() / 2 ) - ( bx / 2 ), ( ScrH() * 0.7 ) - ( by / 2 ), bx * i_per, by )

            -- Top left
            draw.SimpleText( "CACHING:", "ArcCW_12", ( ScrW() / 2 ) - ( bx / 2 ), ( ScrH() * 0.7 ) - ( by / 2 ) - (ss*1), color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM )

            -- Bottom right
            draw.SimpleText( math.Round(i_per * 100) .. "%", "ArcCW_12", ( ScrW() / 2 ) + ( bx / 2 ), ( ScrH() * 0.7 ) + ( by / 2 ) - (ss*1), color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP )

            -- Top right
            draw.SimpleText( i_1 .. "/" .. i_2, "ArcCW_8", ( ScrW() / 2 ) + ( bx / 2 ), ( ScrH() * 0.7 ) - ( by / 2 ) - (ss*1), color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM )

            -- Bottom left
            draw.SimpleText( i_cur, "ArcCW_6", ( ScrW() / 2 ) - ( bx / 2 ), ( ScrH() * 0.7 ) + ( by / 2 ) + (ss*1), color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
        end
    end)
    CreateClientConVar("arccw_uc_cache_client_persecond", 60, true, false)
    concommand.Add( "arccw_uc_cache_client", function()
        fukc()
    end)
end

if SERVER then
    local procedure = {
        ["sound"] = function(asset)
            local cmdl = ents.Create( "prop_dynamic" )
            asset = string.Replace( asset, "sound\\", "" )
            asset = string.Replace( asset, "sound/", "" )
            cmdl:EmitSound( asset, 75, 100, 0.4, CHAN_WEAPON )
            cmdl:Remove()
        end,
        ["model"] = function(asset)
            local cmdl = ents.Create( "prop_dynamic" )
            -- print(cmdl)
            cmdl:SetModel(asset)
            cmdl:Spawn()
            cmdl:Remove()
        end,
    }
    local cooltable = {}
    function fukc_server()
        local function recurse( path, dir )
            local files, directories = file.Find( path .. (dir and (dir .. "/") or "") .. "*", "GAME" )
            for i, fie in ipairs(files) do
                local fiex = string.GetExtensionFromFilename(fie)
                if fiex == "ogg" or fiex == "wav" or fiex == "mp3" or fiex == "mdl" then
                    table.insert( cooltable, path .. (dir and (dir .. "/") or "") .. fie )
                end
            end
            for i, dir in ipairs(directories) do
                recurse( path, dir )
            end
        end

        cooltable = {}

        UC_Precache = true
        UC_PrecachePer = 0
        UC_PrecachePeh = 0
        UC_PrecacheCur = "..."
        for i, path in ipairs(paths) do
            recurse( path )
        end

        -- PrintTable(cooltable)

        for i, fie in ipairs(cooltable) do
            timer.Simple(i / (1 / 20), function()
                -- print(fie)
                UC_PrecachePer = i
                UC_PrecachePeh = #cooltable
                UC_PrecacheCur = fie
                local fiex = string.GetExtensionFromFilename(fie)
                if fiex == "ogg" or fiex == "wav" or fiex == "mp3" then
                    procedure["sound"](fie)
                elseif fiex == "mdl" then
                    procedure["model"](fie)
                elseif fiex == "phy" or fiex == "vvd" or fiex == "vtx" then
                    -- ignore these
                else
                    print("Unknown what to do with " .. fie .. "!")
                end
                if i == #cooltable then UC_Precache = false end
            end)
        end
    end

    concommand.Add( "arccw_uc_cache_server", function()
        print("hi")
        fukc_server()
    end, nil, "command server to cache")
end
--addons/arccw_weapons/lua/arccw/shared/attachments/a280cfe_barrel_short.lua:
att.PrintName = "Shortbarrel"
att.Description = "Offers superior handling at the cost of performance."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "cfe_barrel"
att.ActivateElements = {"a280cfe_barrel_short"}

att.Mult_Range = 0.75
att.Mult_Recoil = 1.25
att.Mult_SightTime = 0.8
att.Mult_AccuracyMOA = 2

att.Mult_ShootPitch = 1.1
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_destabilization_mod.lua:
att.PrintName = "Destablized Mod"
att.Icon = Material("entities/acwatt_go_ammo_blanks.png", "mips smooth")
att.Description = "Destablized rounds"
att.Desc_Pros = {
}
att.Desc_Cons = {
}

att.AutoStats = true
att.Slot = "ammo"
att.Reload = 1
att.Mult_DamageMin = 0.3
att.Mult_Recoil = 1.15
att.Mult_SightTime = 1
att.Mult_RPM = 2

att.NotForNPCs = true
att.Mult_Damage = 0.6
att.Mult_MuzzleVelocity = 1

att.Override_Tracer = "tfa_tracer_green" -- tracer effect name
att.Override_MuzzleEffect = "wpn_muzzleflash_dc17_green"
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_gl_dioxis.lua:
att.PrintName = "Dioxis Grenade Launcher"
att.Icon = Material("interfaz/iconos/kraken/jedi shad serenity/656834804_3939926757.png")
att.Description = "Throwable grenade with dioxis capacity."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.AutoStats = true
att.Slot = "ammo_rocket"

att.SortOrder = 1738
att.Override_ShootEntity = "tfa_battlefront_ent_nade_poison"
att.Mult_SightTime = 1.25
att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_masita_high.lua:
att.PrintName = "Increased Load"

att.SortOrder = 19
att.Icon = Material("interfaz/armas/sw_powercell1.png", "smooth mips")
att.Description = "Ammunition loaded with a higher amount of tibanna, slightly increasing ballistic performance."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ammo_masita"

att.AutoStats = true

att.Mult_Recoil = 1.15
att.Mult_Range = 1.2

att.Mult_ShootVol = 1.15
att.Mult_RPM = 1.04
--att.Mult_ShootPitch = 0.95 please don't

att.Mult_MalfunctionMean = 0.85
att.Mult_PhysBulletMuzzleVelocity = 1.1
--addons/arccw_weapons/lua/arccw/shared/attachments/arccw_apex_proscreen_alt.lua:
att.PrintName = "Pro Screen (Alt)"
att.AbbrevName = "Pro Screen (Alt)"
att.Icon = Material("entities/arccw_proscreen.png", "mips")
att.Description = "Adds a small screen (Pistol size) to the side of the weapon, showing how many player kills you have achieved with this weapon."
att.SortOrder = 1.05


att.Model = "models/weapons/attachments/pro_screen_2.mdl"
att.ModelScale = Vector(1, 1, 1)
att.ModelOffset  = Vector(0, 0, 0)
att.Slot = {"charm", "killcounter"}

att.ToggleLockDefault = true 
att.ToggleStats = {
    {
        PrintName = "Global weapon",
        AutoStatName = "Global weapon",
        GivesFlags = {"st_global"}
    },
    {
        PrintName = "Local weapon",
        AutoStatName = "Local",
        GivesFlags = {"st_local"}
    },
}


-- att.Ignore = true -- WIP

att.Hook_Think = function(wep) 
    -- why there s no hook for att equip?? if it ever going to happen copy function to it from deploy
    if SERVER or !wep:GetOwner():IsPlayer() then return end

    if !wep.FileKillsTable then -- same as below but here 
        wep.FileKillsTable = util.JSONToTable(file.Read("arccw_stattrack.json", "DATA") or "") or {}
        wep.FileKills = wep.FileKillsTable[wep:GetClass()] or 0

        wep:SetNWInt("STFileKills", wep.FileKills)

        net.Start("arrcwstattracksend")
        net.WriteUInt(wep.FileKills, 20)
        net.SendToServer()
    end
end

att.Hook_OnDeploy = function(wep) 
    if SERVER or !wep:GetOwner():IsPlayer() then return end
    -- load from file
    wep.FileKillsTable = util.JSONToTable(file.Read("arccw_stattrack.json", "DATA") or "") or {}
    wep.FileKills = wep.FileKillsTable[wep:GetClass()] or 0

    wep:SetNWInt("STFileKills", wep.FileKills)

    net.Start("arrcwstattracksend")
    net.WriteUInt(wep.FileKills, 20)
    net.SendToServer()

    -- wep:SetNWInt("STFileKills", wep.FileKills)
end

att.Hook_OnHolster = function(wep) 
    if CLIENT or !wep:GetOwner():IsPlayer() then return end
    -- save in file
    net.Start("arrcwstattracksave")
    net.WriteEntity(wep)
    net.Send(wep:GetOwner())
    

    -- local curtable = {[wep:GetClass()] = wep:GetNWInt("STFileKills") or 777}

    -- local content = util.TableToJSON(table.Merge(wep.FileKillsTable or {}, curtable))

    -- file.Write("arccw_stattrack.json", content)
    -- print("hi!!")
end
--lua/arccw/shared/attachments/arccw_tracker.lua:
att.PrintName = "Ghosts Tracker (RDS)"
att.Icon = Material("entities/arccw_tracker.png", "mips smooth")
att.Description = "Advanced targeting sight highlights and tracks enemies."

att.SortOrder = 1

att.Desc_Pros = {
    "autostat.holosight",
	"+ Thermal vision"
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/weapons/arccw/scifi/optic_tracker.mdl"

att.AdditionalSights = {
    {
        Pos = Vector(-0.018321, 10, -1.33),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        Thermal = true,
		ThermalScopeColor = Color(255, 165, 0),
        ThermalHighlightColor = Color(255, 165, 0),
        ThermalScopeSimple = false,
        ThermalNoCC = true,
    }
}

att.Holosight = true
att.HolosightReticle = Material("hud/holosight/arccw_tracker.png", "mips smooth")
att.HolosightNoFlare = true
att.HolosightSize = 5.5
att.HolosightBone = "holosight"
att.HolosightPiece = "models/weapons/arccw/scifi/optic_tracker_hsp.mdl"

att.HolosightMagnification = 1.1
att.HolosightBlackbox = false

att.HolosightConstDist = 42

att.Mult_SightTime = 1.4
--addons/arccw_weapons/lua/arccw/shared/attachments/btrs_41_bipod.lua:
att.PrintName = "Integral Bipod"
att.Description = "Bring down the bipod, making handling clunkier."

att.SortOrder = 1

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "btrs_41_bipod"

att.Free = true

att.Mult_SightTime = 1.15

att.Bipod = true
att.Mult_BipodRecoil = 0.45
att.Mult_BipodDispersion = 0.5
--addons/arccw_weapons/lua/arccw/shared/attachments/dc17m_mag_drum.lua:
att.PrintName = "DC-17M Drum Magazine"
att.SortOrder = 100
att.Icon = Material("entities/drummag.png")
att.Description = "Special magazine designed for the DC-17m Modular."
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Slot = "17m_mag"
att.ActivateElements = {"17m_mag_drum"}

att.AutoStats = true
att.HideIfBlocked = true
att.Override_ClipSize = 200

att.Mult_SightTime = 1.05
att.Mult_Sway = 1
att.Mult_SpeedMult = 0.85
att.Mult_ShootSpeedMult = 0.90
att.Mult_DrawTime = 1.15
att.Mult_HolsterTime = 1.15
att.Mult_HipDispersion = 2

--addons/arccw_weapons/lua/arccw/shared/attachments/dc17m_mag_extended.lua:
att.PrintName = "DC-17M Extended Magazine"
att.SortOrder = 100
att.Icon = Material("entities/magext.png")
att.Description = "Special magazine designed for the DC-17m Modular."
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Slot = "17m_mag"
att.ActivateElements = {"17m_mag_extended"}

att.AutoStats = true
att.HideIfBlocked = true
att.Override_ClipSize = 150

att.Mult_SightTime = 1.05
att.Mult_Sway = 1.4
att.Mult_SpeedMult = 0.90
att.Mult_ShootSpeedMult = 0.95
att.Mult_DrawTime = 1.10
att.Mult_HolsterTime = 1.10
att.Mult_HipDispersion = 1.4
--addons/arccw_weapons/lua/arccw/shared/attachments/optic_dc15a_scope.lua:
att.PrintName = "DC15a Magnifying Optic"
att.Icon = Material("entities/dlt19x_icon.png")
att.Description = "High-magnification sniper rifle scope for long range combat."

att.SortOrder = 9

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/atts/scope.mdl"
att.ModelOffset = Vector(0, 0, -0)
att.AdditionalSights = {
    {
        Pos = Vector(0, 9, -1.68),
        Ang = Angle(0, 0, 0),
        Magnification = 1.5,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 10,
        ZoomSound = "weapons/arccw/fiveseven/fiveseven_slideback.wav",
        IgnoreExtra = true
    }
}

att.ScopeGlint = false

att.Holosight = true
att.HolosightReticle = Material("scope/star_ret.png", "smooth")
att.HolosightNoFlare = true
att.HolosightSize = 12
att.HolosightBone = "holosight"
att.HolosightPiece = "models/atts/scope_hsp.mdl"
att.Colorable = false

att.HolosightMagnification = 0
att.HolosightBlackbox = true

att.HolosightConstDist = 64

att.HolosightMagnificationMin = 2
att.HolosightMagnificationMax = 3
att.HoloSightColorable = false

att.Mult_SightTime = 1.35
att.Mult_SightedSpeedMult = 0.8
att.Mult_SpeedMult = 0.9
--addons/arccw_weapons/lua/arccw/shared/attachments/perk_masita_support.lua:
att.PrintName = "Combat Support"
att.Icon = Material("interfaz/iconos/kraken/jedi guns saboteur/2340717062_2624499759.png")
att.Description = "You're a Combat Support, everything you do will award you ammo, along other benefits for your group."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "perk"

att.NotForNPC = true
att.MagExtender = true

att.Hook_BulletHit = function(wep, data)
    if CLIENT then return end
        local ent = data.tr.Entity

        if ent then
            if math.Rand(0, 100) > 25 then return end
            if ent.Health and ent:Health() > 0 then
                wep.Owner:GiveAmmo(2, wep.Primary.Ammo, true)
             end
         end
         if wep.Owner:IsPlayer() and data.tr.Entity and data.tr.HitGroup == HITGROUP_HEAD then
            wep:SetClip1(wep:Clip1() + 1)
            wep.Owner:GiveAmmo(1, wep.Primary.Ammo, true)
         end
end

--addons/arccw_weapons/lua/arccw/shared/attachments/perk_sledge.lua:
att.PrintName = "Sledge"

att.Icon = Material("interfaz/iconos/kraken/jedi guns dirty fighting/4248266477_2454428744.png")
att.Description = "With the proper technique and upper body strength, you can more quickly and effectively use your weapon as a melee."
att.Desc_Pros = {
    "More Melee Damage and less time to do a new attack."
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true
att.Mult_MeleeDamage = 1.35
att.Mult_MeleeTime = .67

att.NotForNPCs = true
--addons/arccw_weapons/lua/arccw/shared/attachments/perk_westernboi.lua:
att.PrintName = "Western Boi"

att.Icon = Material("interfaz/iconos/kraken/jedi juns sharpshooter/1833947853_761929952.png")
att.Description = "Like the fastest guns in the Tatooine Old West, you can draw, aim, and shoot in the blink of an eye.\n\nTexas Red had not cleared leather 'fore a bullet fairly ripped, and the Ranger's aim was deadly with the big iron on his hip."
att.Desc_Pros = {
    "Takes out your gun faster and less time to aim."
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true
att.SortOrder = 5
att.Mult_DrawTime = 0.5
att.Mult_SightTime = 0.85

att.NotForNPCs = true
--addons/arccw_weapons/lua/arccw/shared/attachments/sw_grip_e11.lua:
att.PrintName = "SW-E11 Grip"
att.AbbrevName = "E11 Grip"
att.SortOrder = 100
att.Icon = nil
att.Description = "Better control."
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "e11_grip"

att.Model = "models/arccw/sw_battlefront/props/e11_grip/e11_grip.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(-90, 0, 0)
att.ModelOffset = Vector(0.5, -3, -0.1)
att.ModelScale = Vector(1, 1, 1)

att.AutoStats = true

att.HideIfBlocked = true

att.Mult_SightTime = 0.95
att.Mult_Sway = 0.85
att.Mult_SpeedMult = 0.95

att.Mult_DrawTime = 0.85
att.Mult_HolsterTime = 0.9

att.Mult_HipDispersion = 0.85

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--addons/arccw_weapons/lua/arccw/shared/attachments/sw_mag_dc17m_60mag.lua:
att.PrintName = "SW-Extended Magazine"
att.AbbrevName = "60-Round Mag"
att.SortOrder = 100
att.Icon = nil
att.Description = "Extended magazine, ideal for additional fire support. Slight Bulky construction and additional ammo capacity increases weight, making the weapon difficult to handle"
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "dc17m_ext"

att.Model = "models/arccw/cs574/dc17m/dc17m_magext.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(0, 0, 90)
att.ModelOffset = Vector(-0.5, -6.5, -3)
att.ModelScale = Vector(1, 1, 1)

att.AutoStats = true

att.HideIfBlocked = true

att.Override_ClipSize = 60

att.Mult_SightTime = 1.05
att.Mult_Sway = 2.1

att.Mult_SpeedMult = 0.95
att.Mult_ShootSpeedMult = 0.95

att.Mult_DrawTime = 1.25
att.Mult_HolsterTime = 1.25

att.Mult_HipDispersion = 1.3

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--lua/arccw/shared/attachments/uc_choke_wide.lua:
att.PrintName = "Wide Choke"

att.Icon = nil -- Material("entities/att/acwatt_lowpolysaiga12extmag.png", "smooth mips")
att.Description = "A loose choke that widens pellet spread, potentailly making targets easier to hit."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"choke","muzzle"}
att.AutoStats = true

att.Hook_Compatible = function(wep)
    if !wep:GetIsShotgun() then
        return false
    end
end

att.Mult_Recoil = 0.75
att.Mult_AccuracyMOA = 1.25
--lua/arccw/shared/attachments/uc_fg_deeprifling.lua:
att.PrintName = "Deep Rifling"

att.Icon = Material("entities/att/arccw_uc_deeprifling.png", "mips smooth")
att.Description = "A custom tailored rifling scheme allows bullets to strike with greater impact, penetrating deeper."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_fg"
att.AutoStats = true
att.SortOrder = 1

att.Hook_Compatible = function(wep)
    if wep:GetIsShotgun() then
        return false
    end
end

att.Mult_Penetration = 1.25

att.AttachSound = "arccw_uc/common/gunsmith/internal_modification.ogg"
--lua/arccw/shared/attachments/uc_fg_lubedparts.lua:
att.PrintName = "UD-40 Coating"

att.Icon = Material("entities/att/arccw_uc_lubedparts.png", "mips smooth")
att.Description = "Liberal use of a special lubricant greatly reduces the likelihood of jams and other malfuntions."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_fg"
att.AutoStats = true
att.SortOrder = 3

att.HideIfBlocked = true

att.Mult_MalfunctionMean = 2

--[[]
att.Hook_Compatible = function(wep)
    if wep:GetIsManualAction() then
        return false
    end
end
]]

att.AttachSound = "arccw_uc/common/gunsmith/internal_modification.ogg"

att.GivesFlags = {"technician"}
att.ExcludeFlags = {"lubedparts"}

--lua/arccw/shared/attachments/uc_fg_underwater.lua:
att.PrintName = "Sealed Bolt"

att.Icon = Material("entities/att/acwatt_uc_sealedbolt.png", "smooth mips")
att.Description = "Watertight modifications that allow the weapon to fire underwater."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"uc_fg", "uc_fg_singleshot"}
att.AutoStats = true
att.SortOrder = 3

att.Override_CanFireUnderwater = true

att.Hook_AddShootSound = function(wep)
    if wep:GetOwner():WaterLevel() >= 3 then
        wep:MyEmitSound("weapons/underwater_explode" .. math.random(3, 4) .. ".wav", 70, math.random(60, 80), 0.5, CHAN_AUTO)
    end
end

att.Hook_PreDoEffects = function(wep)
    if wep:GetOwner():WaterLevel() >= 3 then
        return true
    end
end

att.M_Hook_Mult_ShootPitch = function(wep, data)
    if wep:GetOwner():WaterLevel() >= 3 then
        data.mult = data.mult * 0.6
    end
end

att.AttachSound = "arccw_uc/common/gunsmith/internal_modification.ogg"
--lua/arccw/shared/attachments/uc_muzzle_supp_masada.lua:
att.PrintName = "Magpul PTS AAC Masada Suppressor"
att.AbbrevName = "Masada Suppressor"
att.Icon = Material("entities/att/acwatt_uc_muzzle_supp_masada.png", "mips smooth")
att.Description = "Traps propellant gas from the muzzle, reducing visual and audible report.\nReduces recoil by providing extra room for gas expansion."
att.Desc_Neutrals = {"uc.supptail"}

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/weapons/arccw/atts/uc_magpul_masada.mdl"
att.ModelOffset = Vector(2.65, 0, 0)
att.ModelScale = Vector(1.15, 1.15, 1.15)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = true
att.Override_MuzzleEffect = "muzzleflash_suppressed"
att.IsMuzzleDevice = true

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 0.75
att.Mult_Recoil = .9

att.Add_BarrelLength = 5
att.Mult_SightTime = 1.1
att.Mult_Sway = 1.15

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"

att.Hook_GetDistantShootSound = function(wep, distancesound)
    if wep:GetBuff("PhysBulletMuzzleVelocity") < ArcCW.UC.SubsonicThreshold then
        return false
    end
end
--lua/arccw/shared/attachments/uc_optic_sureshot.lua:
att.PrintName = "Sightmark Sure Shot Reflex Sight (RDS)"
att.AbbrevName = "Sure Shot (RDS)"
att.Icon = Material("entities/att/acwatt_uc_optic_sureshot.png", "mips smooth")
att.Description = "Improves sighted visibility with a red-dot targeting reticle, while adding minimal extra weight."

att.SortOrder = 1

att.Desc_Pros = {
    "autostat.holosight",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = {"optic"}

att.Model = "models/weapons/arccw/atts/uc_sureshot.mdl"

att.ModelOffset = Vector(0,0,.2)
att.ModelScale = Vector(1.1,1.1,1.1)

att.AdditionalSights = {
    {
        Pos = Vector(0, 9, -1.7),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ScrollFunc = ArcCW.SCROLL_NONE
    }
}

att.Holosight = true
att.HolosightReticle = Material("hud/reticles/uc_reddot.png", "mips smooth")
att.HolosightPiece = "models/weapons/arccw/atts/uc_sureshot_hsp.mdl"
att.HolosightNoFlare = false
att.HolosightSize = 1.5
att.HolosightBone = "holosight"
att.Colorable = true

att.Mult_SightedSpeedMult = .9
--lua/arccw/shared/attachments/uc_tac_anpeq16a_tan.lua:
att.PrintName = "Insight Technologies MIPIM AN/PEQ-16A (Tan)"
att.AbbrevName = "AN/PEQ-16A (Tan)"
att.Icon = Material("entities/att/acwatt_uc_tac_anpeq16a_tan.png", "mips smooth")
att.Description = "Low-profile flashlight and laser module for rifles. The laser increases accuracy without the use of sights.\nThe laser and flashlight can be toggled individually.\nThis unit is cosmetically colored tan."
att.Desc_Pros = {
    "uc.light"
}
att.Desc_Cons = {
    "con.light"
}
att.Desc_Neutrals = {}
att.AutoStats = true

att.Slot = {"tac"}
att.SortOrder = 20+2

att.Model = "models/weapons/arccw/atts/uc_anpeq16a.mdl"
att.ModelOffset = Vector(0, 0.1, 0.25)
att.OffsetAng = Angle(0, 0,180)
att.ModelScale = Vector(1.2, 1.2, 1.2)
att.Laser = false
att.LaserStrength = 2 / 5
att.LaserBone = "laser"

att.ColorOptionsTable = {Color(255, 0, 0, 150)}

att.Mult_SightTime = 1.05
att.Mult_SightedSpeedMult = 0.95
att.Mult_MoveSpeed = 1

att.Flashlight = false
att.FlashlightFOV = 50
att.FlashlightFarZ = 512 -- how far it goes
att.FlashlightNearZ = 1 -- how far away it starts
att.FlashlightAttenuationType = ArcCW.FLASH_ATT_LINEAR -- LINEAR, CONSTANT, QUADRATIC are available
att.FlashlightColor = Color(255, 235, 229)
att.FlashlightTexture = "effects/flashlight001"
att.FlashlightBrightness = 2
att.FlashlightBone = "laser"

att.ToggleStats = {
    {
        PrintName = "Laser",
        Laser = true,
        Mult_HipDispersion = 0.8,
        Mult_MoveDispersion = 0.8
    },
    {
        PrintName = "Both",
        Laser = true,
        Flashlight = true,
        Mult_HipDispersion = 0.8,
        Mult_MoveDispersion = 0.8
    },
    {
        PrintName = "Light",
        Flashlight = true,
    },
    {
        PrintName = "Off",
    }
}
--lua/arccw/shared/attachments/uc_tac_anpeq2.lua:
att.PrintName = "Insight Technologies ATPIAL AN/PEQ-2"
att.AbbrevName = "AN/PEQ-2"
att.Icon = Material("entities/att/acwatt_uc_tac_anpeq2.png", "mips smooth")
att.Description = "Large flashlight and laser module for rifles, with a stronger, more effective laser that also aids target acquisition.\nThe laser and flashlight can be toggled individually."
att.Desc_Pros = {
    "uc.light"
}
att.Desc_Cons = {
    "con.light"
}
att.Desc_Neutrals = {}
att.AutoStats = true

att.Slot = {"tac"}
att.SortOrder = 20+3

att.Model = "models/weapons/arccw/atts/uc_anpeq2.mdl"
att.ModelOffset = Vector(0, 0.01, 0.35)
att.OffsetAng = Angle(0, 0,180)
att.ModelScale = Vector(1.2, 1.2, 1.2)
att.ModelSkin = 1

att.Laser = false
att.LaserStrength = 3.5 / 5
att.LaserBone = "laser"

att.ColorOptionsTable = {Color(255, 0, 0, 150)}

att.Mult_SightTime = 1.1
att.Mult_SightedSpeedMult = 0.9
att.Mult_MoveSpeed = 1

att.Flashlight = false
att.FlashlightFOV = 50
att.FlashlightFarZ = 512 -- how far it goes
att.FlashlightNearZ = 1 -- how far away it starts
att.FlashlightAttenuationType = ArcCW.FLASH_ATT_LINEAR -- LINEAR, CONSTANT, QUADRATIC are available
att.FlashlightColor = Color(255, 235, 229)
att.FlashlightTexture = "effects/flashlight001"
att.FlashlightBrightness = 2
att.FlashlightBone = "laser"

att.ToggleStats = {
    {
        PrintName = "Laser",
        Laser = true,
        Mult_HipDispersion = 0.7,
        Mult_MoveDispersion = 0.8,
        Mult_SightTime = .9,
        Mult_SightedSpeedMult = .75
    },
    {
        PrintName = "Both",
        Laser = true,
        Flashlight = true,
        Mult_HipDispersion = 0.7,
        Mult_MoveDispersion = 0.8,
        Mult_SightTime = .9,
        Mult_SightedSpeedMult = .75
    },
    {
        PrintName = "Light",
        Flashlight = true,
    },
    {
        PrintName = "Off",
    }
}
--lua/arccw/shared/attachments/uc_tp_sway.lua:
att.PrintName = "Nerves of Steel"

att.Icon = Material("entities/att/arccw_uc_tp_nerves_of_steel.png", "smooth mips")
att.Description = "A series of carefully honed concentration and nerve techniques, plus a good helping of Diazepam, reduce hand jitter while aiming."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_tp"

att.AutoStats = true
att.SortOrder = 11

att.Mult_Sway = .5

att.NotForNPCs = true
--lua/arccw/shared/attachments/uc_ubgl_gp25.lua:
att.PrintName = "GP-25 Underbarrel Grenade Launcher"
att.AbbrevName = "GP-25 Grenade Launcher"
att.Icon = Material("entities/att/acwatt_uc_ubgl_gp25.png", "mips smooth")
att.Description = "Single-shot long-barreled underbarrel grenade launcher designed for the AK. The VOG-25 caseless projectiles can be reloaded faster, but hold less propellant and explosive yield."

att.SortOrder = -100000

att.AutoStats = true
att.Desc_Pros = {
}
att.Slot = "uc_ubgl"
att.ExcludeFlags = {"uc_noubgl"}

att.LHIK = true

att.ModelOffset = Vector(0.2, 0, -1.2)
att.Model = "models/weapons/arccw/atts/uc_ubgl_gp25_2.mdl"

att.SelectUBGLSound =  ""
att.ExitUBGLSound = ""

att.UBGL = true

att.UBGL_PrintName = "UBGL"
att.UBGL_Automatic = false
att.UBGL_MuzzleEffect = "muzzleflash_m79"
att.UBGL_Ammo = "smg1_grenade"
att.UBGL_RPM = 120
att.UBGL_Recoil = 2
att.UBGL_Capacity = 1

att.LHIK_GunDriver = 2
att.LHIK_CamDriver = nil--3

local pretty = GetConVar("arccw_uc_infiniteubwammo")

att.Hook_ModifyAttBodygroups = function(wep, data)
    if wep:GetBuff_Override("UC_UseClassicGP25Mount") then
        data.element.Model:SetBodygroup(1, 1)
    end
end

local function Ammo(wep)
    return (pretty:GetBool() and 9999 or wep:GetOwner():GetAmmoCount("smg1_grenade"))
end

att.Hook_LHIK_TranslateAnimation = function(wep, key)
    if key == "idle" then
        if wep:GetInUBGL() then
            return "idle_armed"
        else
            return "idle"
        end
    end
end

att.Hook_ShouldNotSight = function(wep)
    if wep:GetInUBGL() then
        return true
    end
end

att.Hook_OnSelectUBGL = function(wep)
    wep:SetNextSecondaryFire(CurTime() + 0.7)
    if (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoLHIKAnimation("to_armed", 0.7)
        wep:PlaySoundTable({
            {s = "arccw_uc/common/rattle_b2i_rifle.ogg", t = 0},
            {s = "arccw_uc/common/raise.ogg", t = 0.2},
            {s = "arccw_uc/common/grab.ogg", t = 0.5},
        })
    end
end

att.Hook_OnDeselectUBGL = function(wep)
    wep:SetNextSecondaryFire(CurTime() + 0.7)
    if (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoLHIKAnimation("to_idle", 0.7)
        wep:PlaySoundTable({
            {s = "arccw_uc/common/rattle_b2i_rifle.ogg", t = 0},
            {s = "arccw_uc/common/shoulder.ogg", t = 0.4},
        })
    end
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    local owner = wep:GetOwner()
    local class = wep:GetBuff_Override("UBGL_Entity") or "arccw_uc_40mm_he"

    local vel, dmg = 2500, 130

    -- hacky
    if class == "arccw_uc_40mm_he" then
        vel = vel * 0.85
        dmg = dmg * 0.75
    --elseif class == "arccw_uc_40mm_stun" then
    --    dmg = dmg * 0.6
    --elseif class == "arccw_uc_40mm_incendiary" then
    --    vel = vel * 0.75
    end

    local proj = wep:FireRocket(class, vel)
    if SERVER then
        proj.Damage = dmg -- lower than the m79 (200) for balance reasons
    end
    wep:MyEmitSound(")^/arccw_uc/common/40mm/fire-0" .. math.random(1, 6) .. ".ogg", 100, 100, 1, CHAN_WEAPON)
    wep:MyEmitSound(")^/arccw_uc/common/40mm/fire-dist-0" .. math.random(1, 6) .. ".ogg", 149, 100, 0.5, CHAN_BODY)
    wep:MyEmitSound(")^/arccw_uc/common/40mm/mech-0" .. math.random(1, 6) .. ".ogg", 149, 100, 0.5, CHAN_AUTO)

    if game.SinglePlayer() and SERVER or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoEffects()
        wep:DoLHIKAnimation("fire")
    end
    wep:SetClip2(wep:Clip2() - 1)
    wep:DoEffects()
end

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end
    if Ammo(wep) <= 0 then return end

    wep:SetNextSecondaryFire(CurTime() + 2.75)

    local holy = (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted())
    if holy then
        wep:DoLHIKAnimation("reload", 2.75)
        wep:PlaySoundTable({
            {s = { "arccw_uc/common/rattle1.ogg", "arccw_uc/common/rattle2.ogg", "arccw_uc/common/rattle3.ogg" }, t = 0},
            {s = "arccw_uc/common/magpouch_replace_small.ogg", t = 0.2},
            {s = "arccw_uc/common/40mm/203insert.ogg", t = 1.0},
            {s = "arccw_uc/common/shoulder.ogg", t = 1.3},
            {s = "arccw_uc/common/shoulder.ogg", t = 1.9},
        })
    end

    local reserve = Ammo(wep)
    reserve = reserve + wep:Clip2()
    local clip = 1
    local load = math.Clamp(clip, 0, reserve)
    if (!pretty:GetBool()) then
        wep:GetOwner():RemoveAmmo(1, "smg1_grenade")
    end
    wep:SetClip2(load)
end

att.Mult_SightTime = 1.2
att.Mult_SpeedMult = 0.9
att.Mult_SightedSpeedMult = 0.85

att.ToggleLockDefault = true
att.ToggleStats = {
    {
        PrintName = "Caseless",
        UBGL_Entity = "arccw_uc_40mm_he"
    },
    {
        PrintName = "Stun",
        UBGL_Entity = "arccw_uc_40mm_flash"
    },
    {
        PrintName = "Incendiary",
        UBGL_Entity = "arccw_uc_40mm_incendiary"
    },
}
--addons/arccw_weapons/lua/arccw/shared/attachments/wepcamo_tiger.lua:
att.PrintName = "Tiger"
att.Description = "Unleash the Tiger."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Slot = "rep_vibrocamo"
att.Free = true

att.ActivateElements = {"wepcamo-tiger"}

att.SortOrder = 2 *-1
--addons/arccw_base_modified/lua/arccw/shared/sh_quicknade.lua:
-- ArcCW.QuickNadeTable = {
--     ["frag"] = {
--         ShortName = "FRAG",
--         ThrowEntity = "arccw_proj_frag",
--         ViewModel = "models/weapons/cstrike/c_eq_fraggrenade.mdl"
--     }
-- }

-- if CLIENT then

-- function ArcCW:QuickNade(index)
--     if !ArcCW.QuickNadeTable[index] then return end

--     local wpn = LocalPlayer():GetActiveWeapon()

--     if !wpn.ArcCW then return end
-- end

-- end
--addons/arccw_base_modified/lua/arccw/client/cl_vrmod.lua:
local function addmenu()
    if !vrmod then return end

    vrmod.AddInGameMenuItem("ArcCW Customize", 3, 1, function()
        local wep = LocalPlayer():GetActiveWeapon()

        if !IsValid(wep) or !wep.ArcCW then return end

        wep:ToggleCustomizeHUD(!IsValid(ArcCW.InvHUD))
    end)
end

hook.Add("VRMod_Start", "ArcCW", addmenu)
--addons/arccw_weapons/lua/autorun/autorun_explosiveeffects.lua:
game.AddParticles( "particles/astw2_halo_flamethrower.pcf" )
-- game.AddParticles( "particles/gravity_hammer_fx.pcf" )
game.AddParticles( "particles/iv04_halo_reach_gravity_hammer_effects.pcf" )
game.AddParticles( "particles/iv04_halo_reach_explosions.pcf" )
game.AddParticles( "particles/astw2_halo_pack_muzzle_effects.pcf" )
game.AddParticles( "particles/astw2_halo_pack_muzzle_effects2.pcf" )
game.AddParticles( "particles/astw2_halo_pack_muzzle_effects_human_spv3.pcf" )
game.AddParticles( "particles/astw2_halo_pack_muzzle_effects_covie_spv3.pcf" )
game.AddParticles( "particles/astw2_halo_pack_weapon_projectiles.pcf" )
game.AddParticles( "particles/astw2_gravity_hammer_fx.pcf" )
game.AddParticles( "particles/astw2_halo_pack_explosions.pcf" )
game.AddParticles( "particles/simfphys_halo_muzzle_effects.pcf" )
game.AddParticles( "particles/astw2_halo_4_forerunner_fx.pcf" )
game.AddParticles( "particles/astw2_halo_3_equipment_fx.pcf" )
game.AddParticles( "particles/astw2_halo_3_equipment_explosion_fx.pcf" )

--CASING EFFECTS
PrecacheParticleSystem( "astw2_halo_ce_casing_pistol" )
PrecacheParticleSystem( "astw2_halo_ce_casing_rifle" )
PrecacheParticleSystem( "astw2_halo_ce_casing_sniper" )
PrecacheParticleSystem( "astw2_halo_ce_casing_shotgun" )

--EQUIPMENT STUFF
PrecacheParticleSystem( "astw2_halo_3_bubbleshield_fx" )
PrecacheParticleSystem( "astw2_halo_3_power_drain_fx" )
PrecacheParticleSystem( "astw2_halo_3_power_drain_explosion_fx" )
PrecacheParticleSystem( "astw2_halo_3_deployable_cover_shield_deplete_fx" )
PrecacheParticleSystem( "astw2_halo_3_deployable_cover_impact_fx" )
PrecacheParticleSystem( "astw2_halo_3_deployable_cover_explosion_fx" )
PrecacheParticleSystem( "astw2_halo_3_deployable_shield_depleted_fx" )
PrecacheParticleSystem( "astw2_halo_3_invincibility_fx" )
PrecacheParticleSystem( "astw2_halo_3_invincibility_pickup_fx" )
PrecacheParticleSystem( "astw2_halo_3_invincibility_pickup_fx_flare" )
PrecacheParticleSystem( "astw2_halo_3_invincibility_pickup_fx_vapor" )
PrecacheParticleSystem( "astw2_halo_3_invisibility_pickup_fx" )
PrecacheParticleSystem( "astw2_halo_3_invisibility_pickup_fx_flare" )
PrecacheParticleSystem( "astw2_halo_3_invisibility_pickup_fx_vapor" )
PrecacheParticleSystem( "astw2_halo_3_gravlift_fx" )
PrecacheParticleSystem( "astw2_halo_3_superflare_fx" )
PrecacheParticleSystem( "astw2_halo_3_regenerator_fx" )
PrecacheParticleSystem( "astw2_halo_3_regenerator_explosion_fx" )
PrecacheParticleSystem( "astw2_halo_3_flamethrower_pilot_fx" )
PrecacheParticleSystem( "astw2_halo_3_hammer_fx" )
PrecacheParticleSystem( "astw2_halo_3_hammer_fx_current" )
PrecacheParticleSystem( "astw2_halo_3_sword_fx" )

--Projectile Effects
PrecacheParticleSystem( "astw2_halo_ce_plasma_grenade_trail" )
PrecacheParticleSystem( "astw2_halo_ce_rocket_launcher_trail" )
PrecacheParticleSystem( "astw2_halo_ce_fuel_rod_trail" )
PrecacheParticleSystem( "astw2_halo_2_sentinel_beam_tracer" )
PrecacheParticleSystem( "astw2_halo_2_sentinel_beam_blue_tracer" )
PrecacheParticleSystem( "astw2_halo_2_needler_trail" )
PrecacheParticleSystem( "astw2_halo_2_enforcer_needler_trail" )
PrecacheParticleSystem( "astw2_halo_2_brute_plasma_rifle_trail" )
PrecacheParticleSystem( "astw2_halo_2_fuel_rod_projectile_trail" )
PrecacheParticleSystem( "astw2_halo_2_plasma_grenade_trail" )
PrecacheParticleSystem( "astw2_halo_2_plasma_rifle_trail" )
PrecacheParticleSystem( "astw2_halo_2_plasma_pistol_trail" )
PrecacheParticleSystem( "astw2_halo_3_brute_plasma_rifle_trail" )
PrecacheParticleSystem( "astw2_halo_3_plasma_grenade_trail" )
PrecacheParticleSystem( "astw2_halo_3_plasma_rifle_trail" )
PrecacheParticleSystem( "astw2_halo_3_plasma_pistol_trail" )
PrecacheParticleSystem( "astw2_halo_3_plasma_pistol_overcharge_trail" )
PrecacheParticleSystem( "astw2_halo_3_needler_trail" )
PrecacheParticleSystem( "astw2_halo_3_frag_grenade_trail" )
PrecacheParticleSystem( "astw2_halo_3_rocket_launcher_trail" )
PrecacheParticleSystem( "astw2_halo_3_spiker_trail" )
PrecacheParticleSystem( "astw2_halo_3_flood_ranged_form_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_brute_plasma_rifle_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_brute_plasma_pistol_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_plasma_rifle_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_plasma_pistol_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_plasma_pistol_overcharge_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_brute_plasma_pistol_overcharge_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_shredder_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_spiker_trail" )
PrecacheParticleSystem( "astw2_halo_reach_concussion_round_trail" )
PrecacheParticleSystem( "astw2_halo_reach_grenade_launcher_trail" )
PrecacheParticleSystem( "astw2_halo_3_nuke_launcher_trail" )
PrecacheParticleSystem( "astw2_halo_aerial_dark_projectile_trail" )
PrecacheParticleSystem( "astw2_halo_phantom_projectile_fx" )
PrecacheParticleSystem( "astw2_halo_2_impact_brute_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_2_impact_carbine" )
PrecacheParticleSystem( "astw2_halo_2_impact_needler" )
PrecacheParticleSystem( "astw2_halo_2_impact_plasma_rifle" )
--Misc Effects
PrecacheParticleSystem( "flame_halo_3" )
PrecacheParticleSystem( "astw2_halo_3_gravity_hammer_fx" )
--Explosion Effects
PrecacheParticleSystem( "halo_reach_explosion_unsc" )
PrecacheParticleSystem( "halo_reach_explosion_covenant" )
PrecacheParticleSystem( "halo_reach_gravity_hammer_smash" )
PrecacheParticleSystem( "astw2_halo_2_brute_shot_explosion" )
PrecacheParticleSystem( "astw2_halo_2_frag_explosion" )
PrecacheParticleSystem( "astw2_halo_2_mortar_explosion" )
PrecacheParticleSystem( "astw2_halo_2_rocket_explosion" )
PrecacheParticleSystem( "astw2_halo_2_overcharge_impact" )
PrecacheParticleSystem( "astw2_halo_2_fuel_rod_explosion" )
PrecacheParticleSystem( "astw2_halo_2_needler_explosion" )
PrecacheParticleSystem( "astw2_halo_2_plasma_explosion" )
PrecacheParticleSystem( "astw2_halo_3_brute_shot_explosion" )
PrecacheParticleSystem( "astw2_halo_3_firebomb_explosion" )
PrecacheParticleSystem( "astw2_halo_3_frag_explosion" )
PrecacheParticleSystem( "astw2_halo_3_overcharge_impact" )
PrecacheParticleSystem( "astw2_halo_3_fuel_rod_explosion" )
PrecacheParticleSystem( "astw2_halo_3_needler_explosion" )
PrecacheParticleSystem( "astw2_halo_3_plasma_explosion" )
PrecacheParticleSystem( "astw2_halo_3_rocket_explosion" )
PrecacheParticleSystem( "astw2_halo_3_spike_grenade_explosion" )
PrecacheParticleSystem( "astw2_halo_3_hunter_projectile_impact" )
PrecacheParticleSystem( "astw2_halo_spv3_hunter_projectile_impact" )
PrecacheParticleSystem( "astw2_halo_ce_sml_explosion" )
PrecacheParticleSystem( "astw2_halo_ce_frag_explosion" )
PrecacheParticleSystem( "astw2_halo_ce_needler_explosion" )
PrecacheParticleSystem( "astw2_halo_ce_plasma_explosion" )
PrecacheParticleSystem( "astw2_halo_reach_concussion_rifle_explosion" )
PrecacheParticleSystem( "astw2_halo_reach_fuel_rod_explosion" )
PrecacheParticleSystem( "astw2_halo_reach_needler_explosion" )
PrecacheParticleSystem( "astw2_halo_reach_plasma_explosion" )
PrecacheParticleSystem( "astw2_halo_custom_mac_explosion" )
PrecacheParticleSystem( "astw2_halo_custom_nuke_explosion_XXL" )
PrecacheParticleSystem( "astw2_halo_custom_nuke_explosion_huge" )
PrecacheParticleSystem( "astw2_halo_phantom_projectile_impact_fx" )
PrecacheParticleSystem( "astw2_halo_2_sentinel_impact_blue" )
PrecacheParticleSystem( "astw2_halo_2_sentinel_impact_red" )
--Muzzle Effects
PrecacheParticleSystem( "astw2_halo_aerial_muzzle_dark_carbine" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_turret_covenant" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_beam_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_brute_plasma_pistol" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_brute_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_brute_shot" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_carbine" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_focus_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_fuel_rod" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_mauler" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_needler" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_particle_carbine" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_plasma_pistol" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_shredder" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_spiker" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_assault_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_battle_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_DMR" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_magnum" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_shotgun" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_SMG" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_SMG_specops" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_sniper_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_sniper_rifle_specops" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_gravity_wrench_charge" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_assault_rifle" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_pistol" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_shotgun" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_sniper_rifle" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_fuel_rod" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_plasma_pistol" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_needler" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_battle_rifle" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_SMG" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_sniper_rifle" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_shotgun" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_rocket_launcher" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_magnum" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_brute_shot" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_carbine" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_beam_rifle" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_brute_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_fuel_rod" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_plasma_pistol" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_needler" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_sentinel_beam_red" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_sentinel_beam_blue" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_assault_rifle" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_battle_rifle" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_hunter_cannon_charge" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_magnum" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_magnum_ODST" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_SMG" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_SMG_ODST" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_rocket_launcher" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_sniper_rifle" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_shotgun" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_machine_gun_turret" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_missile_pod" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_spartan_laser" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_spartan_laser_charge" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_carbine" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_brute_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_plasma_turret" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_fuel_rod" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_plasma_pistol" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_needler" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_spiker" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_brute_shot" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_mauler" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_mauler_flare" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_nuke_flare" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_laser_painter_flare" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_laser_painter_blue_flare" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_beam_rifle" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_warthog_chaingun" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_warthog_gauss_cannon" )
PrecacheParticleSystem( "astw2_halo_4_muzzle_forerunner_aiming_beam" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_assault_rifle" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_DMR" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_magnum" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_sniper_rifle" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_plasma_repeater" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_plasma_pistol" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_focus_rifle" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_concussion_rifle" )
PrecacheParticleSystem( "astw2_halo_reach_focus_rifle_impact" )
PrecacheParticleSystem( "astw2_halo_3_sentinel_impact_blue" )
PrecacheParticleSystem( "astw2_halo_3_sentinel_impact_red" )
PrecacheParticleSystem( "astw2_halo_3_laser_beam_blue" )
PrecacheParticleSystem( "astw2_halo_3_laser_beam_red" )
PrecacheParticleSystem( "astw2_halo_3_laser_beam_monitor" )
PrecacheParticleSystem( "simphys_halo_warthog_gauss_muzzle" )
--Decal Effects
game.AddDecal( "astw2_halo_reach_impact_nuke_explosion", "effects/halo_reach/impact_nuke_explosion" )
game.AddDecal( "astw2_halo_reach_impact_soft_terrain_explosion", "effects/halo_reach/impact_soft_terrain_explosion" )
game.AddDecal( "astw2_halo_reach_impact_hard", "effects/halo_reach/impact_hard" )
game.AddDecal( "astw2_halo_reach_impact_hard_medium", "effects/halo_reach/impact_hard_medium" )
game.AddDecal( "astw2_halo_3_sword_impact_medium", "effects/halo3/sword_impact_medium" )
game.AddDecal( "astw2_halo_3_impact_gauss", "effects/halo3/blast_scorch_ring" )
game.AddDecal( "astw2_halo_3_plasma_impact_medium_blue", "effects/halo3/plasma_impact_medium_blue" )
game.AddDecal( "astw2_halo_3_plasma_impact_medium_blue_sentinel", "effects/halo3/plasma_impact_medium_blue_sentinel" )
game.AddDecal( "astw2_halo_3_plasma_impact_medium_red", "effects/halo3/plasma_impact_medium_red" )
game.AddDecal( "astw2_halo_3_plasma_impact_medium_red_laser", "effects/halo3/plasma_impact_medium_red_laser" )
game.AddDecal( "astw2_halo_3_plasma_impact_medium_green", "effects/halo3/plasma_impact_medium_green" )
game.AddDecal( "astw2_halo_3_plasma_impact_medium_green_carbine", "effects/halo3/plasma_impact_medium_green_carbine" )
game.AddDecal( "astw2_halo_3_plasma_impact_large_purple", "effects/halo3/plasma_impact_large_purple" )
game.AddDecal( "astw2_halo_3_plasma_impact_large_green", "effects/halo3/plasma_impact_large_green" )
game.AddDecal( "astw2_halo_3_napalm_splat_large", "effects/halo3/napalm_splat_large1" )
game.AddDecal( "astw2_halo_3_blast_scorch_large", "effects/halo3/blast_scorch_large" )
game.AddDecal( "astw2_halo_2_phantom_plasma_burn", "effects/halo2/phantom_plasma_burn" )
game.AddDecal( "astw2_halo_2_plasma_burn_inner_glow", "effects/halo2/plasma_burn_inner_glow" )
game.AddDecal( "astw2_halo_2_plasma_blue_fizzle", "effects/halo2/plasma_blue_fizzle" )
game.AddDecal( "astw2_halo_2_plasma_blue_glow", "effects/halo2/plasma_blue_glow" )
game.AddDecal( "astw2_halo_2_plasma_burn_inner_glow_brute", "effects/halo2/plasma_burn_inner_glow_brute" )
game.AddDecal( "astw2_halo_2_plasma_red_glow", "effects/halo2/plasma_red_glow" )
game.AddDecal( "astw2_halo_2_plasma_red_fizzle", "effects/halo2/plasma_red_fizzle" )
game.AddDecal( "astw2_halo_2_plasma_explosion_glow_inner", "effects/halo2/plasma_explosion_glow_inner" )
game.AddDecal( "astw2_halo_2_plasma_beam_rifle_glow", "effects/halo2/beam_rifle_glow" )
game.AddDecal( "astw2_halo_2_plasma_green_inner_glow", "effects/halo2/plasma_green_inner_glow" )
game.AddDecal( "astw2_halo_2_plasma_green_glow", "effects/halo2/plasma_green_glow" )
game.AddDecal( "astw2_halo_2_plasma_green_fizzle", "effects/halo2/plasma_green_fizzle" )
game.AddDecal( "astw2_halo_2_default_scorch", "effects/halo2/default_scorch" )
game.AddDecal( "astw2_halo_2_default_blast", "effects/halo2/default_blast" ) 
game.AddParticles( "particles/swbf/astw2_swbf_explosions.pcf" )
game.AddParticles( "particles/swbf/astw2_star_wars_battlefront_muzzle_effects.pcf" )
game.AddParticles( "particles/swbf/astw2_swbf_flamethrower.pcf" )
game.AddParticles( "particles/swbf/astw2_swbf_rocket_fx.pcf" )
game.AddParticles( "particles/swbf/astw2_swbf_impact_fx.pcf" )
game.AddParticles( "particles/swbf/astw2_swbf_pickup_effects.pcf" )
game.AddParticles( "particles/swbf/swbf_commandpost_fx.pcf" )
PrecacheParticleSystem( "astw2_swbf_explosion_cis_launcher" )
PrecacheParticleSystem( "astw2_swbf_explosion_cis_rocket" )
PrecacheParticleSystem( "astw2_swbf_explosion_cis_wristrocket" )
PrecacheParticleSystem( "astw2_swbf_explosion_concussion_grenade" )
PrecacheParticleSystem( "astw2_swbf_explosion_emp" )
PrecacheParticleSystem( "astw2_swbf_explosion_imp_launcher" )
PrecacheParticleSystem( "astw2_swbf_explosion_imp_rocket" )
PrecacheParticleSystem( "astw2_swbf_explosion_reb_rocket" )
PrecacheParticleSystem( "astw2_swbf_explosion_rep_rocket" )
PrecacheParticleSystem( "astw2_swbf_explosion_thermal_detonator" )
PrecacheParticleSystem( "astw2_swbf_explosion_thermal_detonator2" )
PrecacheParticleSystem( "astw2_swbf_explosion_rep_emp_rocket" )
PrecacheParticleSystem( "astw2_swbf_explosion_death_droid" )
PrecacheParticleSystem( "astw2_swbf_muzzle_tor_rifle" )
PrecacheParticleSystem( "astw2_swbf_muzzle_sth_rifle" )
PrecacheParticleSystem( "astw2_swbf_muzzle_cis_blaster" )
PrecacheParticleSystem( "astw2_swbf_muzzle_cis_pistol" )
PrecacheParticleSystem( "astw2_swbf_muzzle_cis_sniper" )
PrecacheParticleSystem( "astw2_swbf_muzzle_cis_bulldog" )
PrecacheParticleSystem( "astw2_swbf_muzzle_imp_blaster" )
PrecacheParticleSystem( "astw2_swbf_muzzle_imp_pistol" )
PrecacheParticleSystem( "astw2_swbf_muzzle_imp_shotgun" )
PrecacheParticleSystem( "astw2_swbf_muzzle_imp_sniper" )
PrecacheParticleSystem( "astw2_swbf_muzzle_reb_blaster" )
PrecacheParticleSystem( "astw2_swbf_muzzle_reb_pistol" )
PrecacheParticleSystem( "astw2_swbf_muzzle_reb_sniper" )
PrecacheParticleSystem( "astw2_swbf_muzzle_reb_shotgun" )
PrecacheParticleSystem( "astw2_swbf_muzzle_reb_bowcaster" )
PrecacheParticleSystem( "astw2_swbf_muzzle_rep_blaster" )
PrecacheParticleSystem( "astw2_swbf_muzzle_rep_pistol" )
PrecacheParticleSystem( "astw2_swbf_muzzle_rep_sniper" )
PrecacheParticleSystem( "astw2_swbf_muzzle_tus_rifle" )
PrecacheParticleSystem( "astw2_swbf_flamethrower_fx" )
PrecacheParticleSystem( "astw2_swbf_rocket_fx_generic" )
PrecacheParticleSystem( "astw2_swbf_rocket_fx_all" )
PrecacheParticleSystem( "astw2_swbf_rocket_fx_cis" )
PrecacheParticleSystem( "astw2_swbf_rocket_fx_imp" )
PrecacheParticleSystem( "astw2_swbf_rocket_fx_rep" )
PrecacheParticleSystem( "astw2_swbf_blaster_bolt_impact" )
PrecacheParticleSystem( "astw2_swbf_blaster_bolt_impact_yellow" )
PrecacheParticleSystem( "astw2_swbf_blaster_bolt_impact_heavy" )
PrecacheParticleSystem( "astw2_swbf_pickup_ammo" )
PrecacheParticleSystem( "astw2_swbf_pickup_bacta" )
PrecacheParticleSystem( "astw2_swbf_pickup_dual" )
PrecacheParticleSystem( "astw2_swbf_pickup_energy" )
PrecacheParticleSystem( "astw2_swbf_pickup_rage" )
PrecacheParticleSystem( "astw2_swbf_pickup_rally" )
PrecacheParticleSystem( "swbf_command_post_ally" )
PrecacheParticleSystem( "swbf_command_post_friendly" )
PrecacheParticleSystem( "swbf_command_post_enemy" )
PrecacheParticleSystem( "swbf_command_post_neutral" )
PrecacheParticleSystem( "swbf_command_post_unoccupied" )



--addons/sh_lounge_chatbox/lua/chatbox/sh_obj_player_extend.lua:
local meta = FindMetaTable("Player")

-- who overrides this?
meta.IsTyping = meta.OldIsTyping or meta.IsTyping

function meta:IsTyping()
	return self:GetNWBool("LOUNGE_CHAT.Typing")
end
--addons/weapons_other/lua/autorun/autorunandresource.lua:
CreateConVar( "sk_massif_bite_damage", "50", { FCVAR_SERVER_CAN_EXECUTE }, "Set the Bite Damage for a single Bite" ) 
CreateConVar( "sk_massif_bite_random_damage", "10", { FCVAR_SERVER_CAN_EXECUTE }, "Set the random Damage amount for bites (+/- this amount possible [50+/-10 by default]" ) 
CreateConVar( "sk_massif_bite_self_damage", "0", { FCVAR_SERVER_CAN_EXECUTE }, "Can Massif bite itself? 0=no//1=yes" ) 
CreateConVar( "sk_massif_bite_range", "100", { FCVAR_SERVER_CAN_EXECUTE }, "Range for Massif-Bite's (Default = 100)" ) 

resource.AddFile( "weapons/massif/bellenneu.wav" ) 
resource.AddFile( "weapons/massif/bite.wav" ) 
resource.AddFile( "weapons/massif/knurrenneu.mp3" ) 
resource.AddFile( "materials/entities/massif_swep.png" )

--addons/gm_climbswep/lua/autorun/cl_roll.lua:
local curPitch = 0
local deg = 0
local inRoll = false

local function rollTo()

	deg = net.ReadInt(16)
	inRoll = true
	curPitch = deg-360

end
net.Receive("ClimbRoll", rollTo)

--[[ hook.Add("CalcView", "ClimbRollEffect", function(ply, pos, ang, fov)
	
	if (!inRoll) then return; end
	
	local view = GAMEMODE:CalcView(ply, pos, ang, fov)
	curPitch = math.Approach(curPitch, deg, FrameTime() * 625)
	if curPitch == deg then inRoll = false; end
	view.angles.p = curPitch
	return view
	
end)
 ]]

--lua/autorun/embo.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "Embo",		"models/player/tiki/embo.mdl" )

--addons/aocrp_map/lua/gmaps/cl_dpoiinfo.lua:

local PNL = {}

AccessorFunc(PNL,"POI","POI")

function PNL:Init()
	
	self:SetSize(gmaps.Config.POIInfoWidth,gmaps.Config.POIInfoWidth/1.6)
	InstallBlur(self)
	
	self:DockPadding(10,5,10,10)
	
	self.Title = vgui.Create("DLabel",self)
	self.Title:Dock(TOP)
	self.Title:SetFont("gmaps_FrameTitle")
	self.Title:SetExpensiveShadow(2,Color(0,0,0,210))
	
	self.Descr = vgui.Create("DLabel",self)
	self.Descr:Dock(FILL)
	self.Descr:SetFont("gmaps_Details")
	self.Descr:SetExpensiveShadow(1,Color(0,0,0,210))
	
	self.Nav = vgui.Create("DButton",self)
	self.Nav:Dock(BOTTOM)
	self.Nav:SetText("Navigate")
	self.Nav:DockMargin(0,5,0,0)
	function self.Nav.DoClick(this)		
		self:GetParent():ResetCamera(.7,true)
		gmaps.NavigateTo(self:GetPOI().pos)
		self:Remove()
	end
	self.Nav:SetVisible(gmaps.CanNavigate())
	
	self.Delete = vgui.Create("DButton",self)
	self.Delete:Dock(BOTTOM)
	self.Delete:SetText("Delete")
	function self.Delete.DoClick(this)
		self.Delete:SetVisible(false)
		self.Nav:SetVisible(false)
		
		self.Confirm:SetVisible(true)
	end
	self.Delete:SetVisible(false)
	
	self.Confirm = vgui.Create("DPanel",self)
	self.Confirm:Dock(BOTTOM)
	self.Confirm:DockPadding(0,0,0,0)
	self.Confirm:SetVisible(false)
	self.Confirm:SetTall(self.Delete:GetTall() + self.Nav:GetTall() + 5)
	function self.Confirm:Paint() end
	
	self.Yes = vgui.Create("DButton",self.Confirm)
	self.Yes:SetWide(self:GetWide()/2-12)
	self.Yes:SetPos(0,self.Confirm:GetTall()-self.Yes:GetTall())
	self.Yes:SetText("Yes")
	function self.Yes.DoClick()
		self:DeletePOI()
	end
	
	self.No = vgui.Create("DButton",self.Confirm)
	self.No:SetWide(self:GetWide()/2-11)
	self.No:SetPos(self:GetWide()-20-self.No:GetWide(),self.Confirm:GetTall()-self.No:GetTall())
	self.No:SetText("No")
	function self.No.DoClick()
		self.Confirm:SetVisible(false)
		self.Nav:SetVisible(gmaps.CanNavigate())
		self.Delete:SetVisible(true)
	end
	
	self.CLabel = vgui.Create("DLabel",self.Confirm)
	self.CLabel:SetExpensiveShadow(1,Color(0,0,0,200))
	self.CLabel:SetText("Are you sure?")
	self.CLabel:SetFont("gmaps_Details")
	self.CLabel:SetContentAlignment(8)
	self.CLabel:Dock(TOP)
	
	self:MoveToBack()
	
end

function PNL:DeletePOI()
	gmaps.DeletePOI(self:GetPOI().id)
	self:Remove()
end

function PNL:Think()
	local x,y = self:GetParent():WorldToXY(self:GetPOI().pos)
	self:SetPos(x-self:GetWide()/2,y+2)
	-- self:SetPos(math.Clamp(x-self:GetWide()/2,0,self:GetParent():GetWide()-self:GetWide()),math.Clamp(y+2,0,self:GetParent():GetTall()-self:GetTall()))
end

function PNL:SetPOI(poi)
	self.POI = poi
	
	self.Title:SetText(poi.name)
	self.Title:SizeToContentsY()
	self.Title:SetContentAlignment(8)
	self.Title:SetTextColor(poi.color)
	
	self.Descr:SetText(poi.desc)
	self.Descr:SetWrap(true)
	self.Descr:SetContentAlignment(7)
	-- self.Descr:SetTextColor(poi.color)
	
	self.Delete:SetVisible(!poi.hardcoded and (poi.owner==LocalPlayer() or LocalPlayer():GMapsPermission("DeleteOtherPOI")))
	
	
end

vgui.Register("DPOIInfo",PNL,"DPanel")
--addons/billy_gas/lua/gmodadminsuite/sh_networking.lua:
if (SERVER) then AddCSLuaFile() end

GAS.Networking = {}

function GAS:netInit(msg)
	util.AddNetworkString("gmodadminsuite:" .. msg)
end
function GAS:netStart(msg)
	xpcall(net.Start, function(err)
		if (err:find("Calling net.Start with unpooled message name!")) then
			if (CLIENT) then
				GAS:chatPrint("Unpooled message name: gmodadminsuite:" .. msg, GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
				GAS:chatPrint("This error usually occurs because some serverside code has not loaded. This is probably a failure with the DRM, please read your whole server's console!", GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
			else
				GAS:print("Unpooled message name: gmodadminsuite:" .. msg, GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
				GAS:print("This error usually occurs because some serverside code has not loaded. This is probably a failure with the DRM, please read your whole server's console!", GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
			end
			debug.Trace()
		else
			error("Error with starting net message: gmodadminsuite:" .. msg)
			debug.Trace()
		end
	end, "gmodadminsuite:" .. msg)
end
function GAS:netReceive(msg, func)
	if (CLIENT) then
		net.Receive("gmodadminsuite:" .. msg, func)
	else
		net.Receive("gmodadminsuite:" .. msg, function(l, ply)
			func(ply, l)
		end)
	end
end
function GAS:netQuickie(msg, ply)
	GAS:netStart(msg)
	if (CLIENT) then
		net.SendToServer()
	else
		net.Send(ply)
	end
end

if (CLIENT) then
	GAS.Networking.Transactions = {}
	function GAS:StartNetworkTransaction(msg, sender_function, callback)
		if (not GAS.Networking.Transactions[msg]) then
			GAS.Networking.Transactions[msg] = {
				id = 0
			}
		end

		local transaction = GAS.Networking.Transactions[msg]
		transaction.id = transaction.id + 1
		transaction.callback = callback

		local my_id = transaction.id
		GAS:netReceive(msg, function(l)
			local transaction_id = net.ReadUInt(16)
			if (my_id ~= transaction_id) then return end
			if (transaction.callback) then
				transaction.callback(true, l)
			end
		end)

		GAS:netStart(msg)
			net.WriteUInt(transaction.id, 16)
			if (sender_function) then
				sender_function(transaction.id)
			end
		net.SendToServer()

		return transaction.id
	end

	function GAS:CancelNetworkTransaction(msg, transaction_id)
		if (GAS.Networking.Transactions[msg] and GAS.Networking.Transactions[msg].id == transaction_id) then
			GAS.Networking.Transactions[msg].callback = nil
		end
	end

	GAS:netReceive("transaction_no_data", function()
		local msg = net.ReadString()
		local transaction_id = net.ReadUInt(16)
		local transaction = GAS.Networking.Transactions[msg]
		if (transaction and transaction.callback and transaction.id == transaction_id) then
			transaction.callback(false)
		end
	end)
else
	GAS:netInit("transaction_no_data")
	function GAS:ReceiveNetworkTransaction(msg, sender_function)
		GAS:netReceive(msg, function(ply, l)
			sender_function(net.ReadUInt(16), ply, l)
		end)
	end
	function GAS:TransactionNoData(msg, transaction_id, ply)
		GAS:netStart("transaction_no_data")
			net.WriteString(msg)
			net.WriteUInt(transaction_id, 16)
		net.Send(ply)
	end
end

function GAS:WritePackedString(str)
	if #str > 1024 then
		local compressed = util.Compress(str)
		net.WriteBool(true)
		net.WriteUInt(#compressed, 32)
		net.WriteData(compressed, #compressed)
	else
		net.WriteBool(false)
		net.WriteString(str)
	end
end
function GAS:ReadUnpackedString(str)
	if net.ReadBool() then
		return net.ReadData(net.ReadUInt(32))
	else
		return net.ReadString()
	end
end
--addons/billy_gas/lua/gmodadminsuite/modules/commands/lang/english.lua:
return {
	Name = "English",
	Flag = "flags16/gb.png",
	Phrases = function() return {

		module_name = "Command Manager",

		no_permission = "Sorry, you don't have permission to use this command.",
		commands = "Commands",
		command = "Command",
		action = "Action",
		help = "Help",
		new_command = "+ New command",
		wiki = "Wiki",
		run_command = "Run Command",
		edit_command = "Edit Command",
		form_help = "Help text... (optional)",
		form_help_tip = "This is the text that will be shown in the commands menu in the \"help\" column.",
		select_action = "Select action...",
		hide_in_chat = "Hide in chat?",
		hide_in_chat_tip = "If checked, the command will not show up in chat when somebody types it.",
		finished = "Finished",
		commands_case_insensitive = "All commands are case insensitive.",
		ok = "OK",
		cannot_create_command = "Cannot create command!",
		cancel = "Cancel",
		delete_command = "Delete Command",
		copy_command = "Copy Command",
		permissions = "Permissions",
		permissions_editor = "Open Permissions Editor",
		permissions_tip = "Allows you to whitelist and blacklist usergroups and teams/jobs.",
		can_access_command = "Can access command",
		teams = "Teams",
		usergroups = "Usergroups",
		anyone_can_access = "Anyone can access this command",
		whitelisted_only = "Only whitelisted can access this command",
		non_blacklisted_only = "Only non-blacklisted can access this command",
		whitelisted_and_blacklisted = "Only whitelisted (except blacklisted) can access this command",
		custom_usergroup = "+ Custom Usergroup",
		custom_usergroup_text = "Enter usergroup",
		custom_usergroup_placeholder = "Usergroup...",
		reason_usergroup_blacklisted = "Your usergroup is blacklisted from this command.",
		reason_usergroup_not_whitelisted = "Your usergroup is not whitelisted to this command.",
		reason_team_blacklisted = "Your team is blacklisted from this command.",
		reason_team_not_whitelisted = "Your team is not whitelisted to this command.",
		saved_exclamation = "Saved!",
		set_position = "Set position",
		position_set = "Position set!",
		set_position_instruction = "Go to the desired position and face in the desired direction",
		set_position_instruction_2 = "When finished, unpin the menu and the position and angle will then be saved",

		action_open_commands_menu = "Open commands menu",
		action_command = "Run console command",
		action_chat = "Say chat message",
		action_website = "Open website",
		action_lua_function_sv = "Serverside Lua Function",
		action_lua_function_cl = "Clientside Lua Function",
		action_gas_module = "Open GAS Module",
		action_teleport = "Teleport",

		form_action_command = "Console command to run",
		form_action_chat = "Chat message to say",
		form_action_website = "Website to open",
		form_action_lua_function_sv = "Lua function to run\nserverside",
		form_action_lua_function_cl = "Lua function to run\nclientside",
		form_action_gas_module = "GAS module to open",
		form_action_teleport = "Teleport",

		error_command_exists = "A command with this name already exists!",
		error_no_command = "You have not entered the command.",
		error_no_command_execute = "You have not entered the command to execute.",
		error_no_action = "You have not selected an action for this command.",
		error_invalid_website = "The website you have entered is not a valid URL.",
		error_no_lua_function = "You have not selected a Lua function to execute.",
		error_no_gas_module = "You have not selected a GAS module to open.",
		error_no_position_set = "You did not set a position and angle for this teleport.",

} end }
--addons/billy_gas_logging/lua/gmodadminsuite/modules/logging/lang/english.lua:
return {
	Name = "English",
	Flag = "flags16/gb.png",
	Phrases = function() return {

		module_name = "Billy's Logs",

		--####################### UI PHRASES #######################--

		no_data                     = "No data",
		add_to_evidence_box         = "Add to Evidence Box",
		livelogs_show_logs_for      = "Show Logs For",
		background_color            = "Background Color",
		health_abbrieviated         = "%d HP",
		livelogs                    = "Live Logs",
		exit_deep_storage           = "Exit Deep Storage",
		log_formatting              = "Log Formatting",
		strings                     = "Strings",
		when                        = "When",
		copy_log                    = "Copy Log",
		evidence_box                = "Evidence Box",
		livelogs_position_x         = "X Position (pixels)",
		width                       = "Width",
		color                       = "Color",
		help                        = "Help",
		apply_filter                = "Apply Filter",
		live_log_antispam           = "< discarded live log for antispam >",
		settings                    = "Settings",
		loading_ellipsis            = "Loading...",
		livelogs_enabled            = "Enable Live Logs",
		armor_abbrieviated          = "%d ARM",
		deep_storage                = "Deep Storage",
		all_logs                    = "All Logs",
		logs                        = "Logs",
		padding                     = "Padding (pixels)",
		livelogs_position_y         = "Y Position (pixels)",
		livelogs_rows_help          = "What is the maximum amount of logs that should be displayed?",
		livelogs_rows               = "Rows (Log Amount)",
		livelogs_color_help         = "Should logs be displayed in color?",
		export_to_clipboard         = "Export to clipboard",
		players                     = "Players",
		script_page                 = "Script Page",
		wiki                        = "Wiki",
		module                      = "Module",
		modules                     = "Modules",
		localization                = "Localization",
		view_deep_storage           = "View Deep Storage",
		copied                      = "Copied!",
		operator                    = "Operator",
		log                         = "Log",
		reset_to_defaults           = "Reset to Defaults",
		livelogs_show_logs_for_help = "How many seconds should logs be shown for?\nSet to 0 for forever.",
		advanced_search             = "Advanced Search",
		quick_search                = "Quick Search",
		quick_search_ellipsis       = "Quick Search...",
		entities                    = "Entities",
		tutorial                    = "Tutorial",
		clear_filters               = "Clear Filters",
		clear_filter                = "Clear Filter",
		manual_steamid_ellipsis     = "Manual SteamID...",
		no_results_found            = "No results found",
		add_player                  = "+ Add Player",
		add_module                  = "+ Add Module",
		add_entity                  = "+ Add Entity",
		add_string                  = "+ Add String",
		modules_search_tooltip      = "What module(s) do you want to include? (leave blank for any module)",
		players_search_tooltip      = "What player(s) are you looking for? (leave blank for any player)",
		entities_search_tooltip     = "What entities(s) are you looking for? (SWEPs, SENTs, vehicles, props, classes, etc.)",
		strings_search_tooltip      = "Is there any specific text that you are looking for?",
		class_name_ellipsis         = "Class name...",
		add_string_popup_title      = "Add String",
		add_string_popup_text       = "Enter the text you're trying to find.",
		text_ellipsis               = "Text...",
		click_to_focus              = "Click to focus",
		right_click_to_focus        = "Right click to focus",
		highlight_color             = "Highlight Color",
		weapon_color                = "Weapon Color",
		money_color                 = "Money Color",
		vehicle_color               = "Vehicle Color",
		entity_color                = "Entity Color",
		health_color                = "Health Color",
		armor_color                 = "Armor Color",
		usergroup_color             = "Usergroup Color",
		unavailable_color           = "Unavailable/Unknown Color",
		learn_more                  = "Learn more",
		player_combats              = "Player Combats",
		took_damage                 = "[took %d dmg]",
		open_pvp_event_report       = "Open PvP Event Report",
		remove                      = "Remove",
		greedy                      = "Greedy",
		greedy_tip                  = "If your search is greedy, it will attempt to match as many logs as possible. If it's not greedy, it will attempt to match as little logs as possible.",
		log_colouring               = "Log Coloring",
		done_exclamation            = "Done!",
		module_settings             = "Module Settings",
		storage_settings            = "Storage Settings",
		third_party_addons          = "Third Party Addons",
		pvp_settings                = "PvP Logging Settings",
		live_logs_settings          = "Live Logs Settings",
		logging_settings            = "Logging Settings",
		enabled_modules             = "Enabled Modules",
		permissions                 = "Permissions",
		gamemode_modules            = "Gamemode Modules",
		saved_exclamation           = "Saved!",
		save_settings               = "Save Settings",
		weapon_class                = "Weapon class",
		enter_weapon_class          = "Enter the class name of the weapon.\nDon't know it? Open your spawn menu, right click a weapon and click \"Copy to clipboard\"",
		save                        = "Save",
		add_new                     = "+ Add New",
		enabled                     = "Enabled",
		website                     = "Website",
		name                        = "Name",
		usergroups                  = "Usergroups",
		everyone                    = "Everyone",
		all_modules                 = "All modules",
		all_teams                   = "All teams",
		add_usergroup               = "Add Usergroup",
		cl_sv_tooltip               = [[cl represents the time taken for your computer to request logs, receive them, process them and display them
		
		sv represents the time taken for the server to retrieve logs from memory/the database, process them and then send them to you

		Servers using MySQL will see a higher sv value due to the latency between the MySQL server and Garry's Mod]],
		deep_storage_help           = [[Deep Storage is a bLogs feature that improves performance by storing logs from previous server sessions separately from the current session's.

		After clicking "View Deep Storage", you will only see logs from previous server sessions.
		You can view the current session's logs by clicking the button below again or reopening the menu.

		NOTE: Damage logs are not included in deep storage and are deleted on every restart to save disk space]],

		damage = "Damage",

		class_type_other = "Other",
		class_type_player = "Player",
		class_type_team = "Team",
		class_type_weapon = "Weapon",
		class_type_vehicle = "Vehicle",
		class_type_damage = "Damage Type",
		class_type_usergroup = "Usergroup",
		class_type_prop = "Prop",
		class_type_ragdoll = "Ragdoll",
		class_type_country = "Country",
		class_type_ammo = "Ammo",
		class_type_role = "Role",
		class_type_entity = "Entity",
		class_selector = "Class Selector",
		custom_class = "Custom Class",
		class_type = "Class Type",
		value = "Value",
		search = "Search",
		check_all = "Check All",
		uncheck_all = "Uncheck All",
		general = "General",
		class_search_title = "Class Search",
		class_search_text = "Enter the name or part of a name of the class that you're looking for (case insensitive)",
		view_logs = "View Logs",
		open_menu = "Open Menu",
		licensed_to = "Licensed to %s",

		pvp_event_report = "PvP Event Report",
		victim = "Victim",
		instigator = "Instigator",
		victim_tag_tip = "This is the person who the instigator started the combat against",
		instigator_tag_tip = "This is the person who started the combat",
		victim_abbr = "V",
		instigator_abbr = "I",
		time = "Time",
		linked_events = "Linked Events",

		deleted_team = "(DELETED TEAM)",

		unknown = "Unknown",
		cancel = "Cancel",

		deep_storage_advanced_search_warning = "WARNING: Advanced Search actually searches Deep Storage internally for performance reasons, which means recently created logs will not be found by Advanced Search for a short period of time.",

		--####################### SETTINGS #######################--

		Player_RecordTeam = "Show player team in logs",
		Player_RecordUsergroup = "Show player usergroup in logs",
		Player_RecordHealth = "Show player health in logs",
		Player_RecordArmor = "Show player armor in logs",
		Player_RecordWeapon = "Show player weapon in logs",
		Player_RecordWeapon_DoNotRecord = "Player weapon filter",
		Player_RecordWeapon_DoNotRecord_help = "If you want to show player weapons in the logs, use this option to filter weapons you don't want to see (such as physgun, toolgun, etc.)",

		OverrideMoneyFormat = "Override default money formatting",
		OverrideMoneyFormat_help = "When this is off, the gamemode's money formatting will be used.\nWhen this is on, you can use the option below to make your own money format.",
		MoneyFormat = "Money Format",
		MoneyFormat_help = "Enter how you want money to appear, and insert \"%s\" (without quotes) where you want the number of money to appear.",

		DeepStorageEnabled = "Deep Storage enabled",
		DeepStorageEnabled_help = "Disabling Deep Storage can significantly improve performance on servers that are not using MySQL.",

		DeepStorageCommitOnShutdown = "Commit Deep Storage on server shutdown",
		DeepStorageCommitOnShutdown_help = "If enabled, any deep storage logs that haven't been committed to the database will be committed on server shutdown/map change, but this can cause that operation to hang",

		DeepStorageCommitPeriod = "Deep storage commit period",
		DeepStorageCommitPeriod_help = "How often (in seconds) should deep storage logs be committed to the database? This setting does nothing without MySQL.",

		DeepStorageTooOld = "Max age of deep storage logs",
		DeepStorageTooOld_help = "How many days old can a log in deep storage be before it is deleted? (saves disk space)\nSet to 0 to never delete logs in deep storage.",

		LiveLogsEnabled = "Live Logs Enabled",
		LiveLogsEnabled_help = "Live logs can be a performance hit for large servers; you can disable the feature completely here.",
		LiveLogsIn10Seconds = "Max live logs in 10 seconds",
		LiveLogsIn10Seconds_help = "How many live logs can be sent before additional logs are blocked for antispam?",
		NotifyLiveLogsAntispam = "Notify antispam",
		NotifyLiveLogsAntispam_help = "Should users be notified that a live log has been discarded for antispam?",

		TimeBetweenPvPEvents = "Time between PvP events",
		TimeBetweenPvPEvents_help = "When players start combat, it creates a \"PvP event\", when no further combat has occured in a certain amount of seconds, the PvP event is treated as finished and committed to the logs. How many seconds should bLogs wait before doing this?",
		NonPvPWeapons = "PvP weapons filter",
		NonPvPWeapons_help = "What weapons shouldn't be treated as PvP weapons?",

		server_restart_required = "NOTE: Changes to these settings will apply after a server restart.",

		gamemode_modules_tip = [[bLogs supports a plethora of gamemodes.
		However, sometimes bLogs may have trouble detecting whether you are running a certain gamemode.
		In this screen, you can force bLogs to think that you are running a certain gamemode.

		Unchecked = Default behaviour
		Checked = Forced on
		Crossed = Forced off

		Please note that some gamemodes DERIVE from Sandbox, this means they use Sandbox's spawn menu, toolgun, etc.
		For gamemodes like DarkRP which derive from Sandbox, it is recommended that you leave Sandbox to its default detection.]],

		third_party_addons_tip = [[bLogs supports a plethora of third party addons.
		However, sometimes bLogs may have trouble detecting whether you have a certain third party addon installed.
		In this screen, you can force bLogs to think that you have certain third party addons installed.

		Unchecked = Default behaviour
		Checked = Forced on
		Crossed = Forced off]],

		edit_discord_webhooks = "Edit Discord Webhooks",
		webhook_name = "Webhook Name",
		webhook_name_tip = "Enter the name of your webhook.\nThis is just an identifier for the webhook, you'll enter the URL in the next screen.",
		webhook = "Webhook",
		webhook_url = "Webhook URL",
		webhook_url_tip = "Copy the URL of your Discord webhook and paste it here.",
		copy_webhook = "Copy Webhook",

		can_access_module = "Can Access Module",
		can_access_all_modules = "Can Access ALL Modules",
		all_usergroups = "All usergroups",
		all_jobs_in_category = "All jobs in category",
		all_teams_in_category = "All teams in category",
		teams = "Teams",
		permissions_tip = "Unchecked = Inherits from \"%s\"\nChecked = Allowed to use module\nCrossed = Forbidden to use module",
		all_modules_tip = "Permissions are inherited from this section unless overrided.",

		wipes_and_resets = "Wipes & Resets", -- wipes as in data wipes
		disable_buttons = "Disable Buttons",
		enable_buttons = "Enable Buttons",
		wipe_deepstorage = "Wipe Deep Storage",
		wipe_session = "Wipe Session Logs",
		wipe_all_logs = "Wipe All Logs",
		reset_config = "Reset config",

		vehicle_driver = "Driver:",
		data = "Data",
		weapons = "Weapons",
		props = "Props",
		ragdolls = "Ragdolls",
		money = "Money",
		countries = "Countries",
		ammo = "Ammo",
		roles = "Roles",
		vehicles = "Vehicles",

		flag_ongoing = "Ongoing Event",
		flag_finished = "Event Finished",
		flag_superadmin = "Involves Superadmin",
		flag_admin = "Involves Admin",
		flag_friendly_fire = "Friendly Fire",
		flag_law_enforcement = "Involves Law Enforcement",
		flag_instigator_death = "Instigator Died",
		flag_victim_death = "Victim Died",
		flag_vehicle = "Involves Vehicle(s)",
		flag_world = "Involves the Map",
		flag_props = "Involves Props",
		flag_team_switched = "Team Switch Occured",
		flag_disconnect = "Player Disconnected During Combat",
		flag_linked = "Linked to Other PvP Events",

		event_start = "Event Start",
		event_end = "Event End",

		dead_tag = "[DEAD]",

		DmgTooltip_Victim = "% of total PvP event damage VICTIM was responsible for",
		DmgTooltip_Instigator = "% of total PvP event damage INSTIGATOR was responsible for",
		DmgTooltip_Other = "% of total PvP event damage which is miscellaneous",

		--####################### LOG PHRASES #######################--
		Logs = {
			round_start     = "ROUND START",
			round_preparing = "PREPARING ROUND",
			round_end       = "ROUND ENDED",

			connected                                      = "{1} connected",
			connected_from_country                         = "{1} connected from {2}",
			finished_connecting                            = "{1} finished connecting",
			respawned                                      = "{1} respawned",
			disconnected                                   = "{1} disconnected ({2})",
			picked_up_weapon                               = "{1} picked up weapon {2}",
			picked_up_item                                 = "{1} picked up item {2}",
			prop_killed_self                               = "{1} killed themselves with their prop {2}",
			prop_killed_other                              = "{1} was killed by prop created by {2} ({3})",
			prop_killed_world                              = "{1} was killed by world prop {2}",
			prop_damaged_self                              = "{1} damaged themselves for {2} damage with their prop {3}",
			prop_damaged_other                             = "{1} was damaged by prop created by {2} for {3} damage ({4})",
			prop_damaged_world                             = "{1} was damaged by world prop {2} for {3} damage",
			toolgun_used_their_ent                         = "{1} used tool {2} on their {3}",
			toolgun_used_other_ent                         = "{1} used tool {2} on {3} created by {4}",
			toolgun_used_world_ent                         = "{1} used tool {2} on {3}",
			spawned_effect                                 = "{1} spawned effect {2}",
			spawned_npc                                    = "{1} spawned NPC {2}",
			spawned_prop                                   = "{1} spawned prop {2}",
			spawned_ragdoll                                = "{1} spawned ragdoll {2}",
			spawned_sent                                   = "{1} spawned SENT {2}",
			spawned_swep                                   = "{1} spawned SWEP {2}",
			spawned_vehicle                                = "{1} spawned vehicle {2}",
			steam_name_changed                             = "{1} changed their Steam name from {2} to {3}",
			weapon_switched                                = "{1} switched weapons from {2} to {3}",
 
			murder_loot                                    = "{1} picked up loot",
 
			cinema_video_queued                            = "[{1}] {2} queued [{3}] \"{4}\" {5}",
 
			ttt_win_traitor                                = "Traitors win!",
			ttt_win_innocent                               = "Innocent win!",
			ttt_win_timelimit                              = "Innocent win - time limit reached!",
			ttt_bought                                     = "{1} bought {2}",
			ttt_karma                                      = "{1} was KICKED for low karma",
			ttt_foundbody                                  = "{1} found the body of {2}",
			ttt_founddna                                   = "{1} found the DNA of {2} on their {3}",
			ttt_founddna_corpse                            = "{1} found the DNA of {2} on their corpse",
 
			darkrp_agenda_updated                          = "{1} updated the {2} agenda to: {3}",
			darkrp_agenda_removed                          = "{1} removed the {2}",
			darkrp_arrest                                  = "{1} arrested {2}",
			darkrp_unarrest                                = "{1} released {2}",
			darkrp_batteringram_owned_success              = "{1} battering rammed the {2} of {3}",
			darkrp_batteringram_owned_door_success         = "{1} battering rammed the door of {2}",
			darkrp_batteringram_success                    = "{1} battering rammed an unowned {2}",
			darkrp_batteringram_door_success               = "{1} battering rammed an unowned door",
			darkrp_batteringram_owned_failed               = "{1} failed to battering ram the {2} of {3}",
			darkrp_batteringram_owned_door_failed          = "{1} failed to battering ram the door of {2}",
			darkrp_batteringram_failed                     = "{1} failed to battering ram an unowned {2}",
			darkrp_batteringram_door_failed                = "{1} failed to battering ram an unowned door",
			darkrp_cheque_dropped                          = "{1} dropped a cheque of {2} for {3}",
			darkrp_cheque_picked_up                        = "{1} cashed a cheque of {2} from {3}",
			darkrp_cheque_tore_up                          = "{1} tore up a cheque of {2} meant for {3}",
			darkrp_demoted                                 = "{1} demoted {2} for {3}",
			darkrp_demoted_afk                             = "{1} was demoted for being AFK",
			darkrp_door_sold                               = "{1} sold a door",
			darkrp_door_bought                             = "{1} bought a door",
			darkrp_money_dropped                           = "{1} dropped {2}",
			darkrp_money_picked_up                         = "{1} picked up {2}",
			darkrp_money_picked_up_owned                   = "{1} picked up {2} dropped by {3}",
			darkrp_hit_accepted                            = "{1} accepted a hit on {2} requested by {3}",
			darkrp_hit_completed                           = "{1} completed a hit on {2} which was requested by {3}",
			darkrp_hit_failed                              = "{1} failed a hit on {2} because {3}",
			darkrp_hit_requested                           = "{1} requested a hit on {2} through {3} for {4}",
			darkrp_job_changed                             = "{1} changed from {2} to {3}",
			darkrp_law_added                               = "{1} added law: {2}",
			darkrp_law_removed                             = "{1} removed law: {2}",
			darkrp_purchase                                = "{1} purchased {2} for {3}",
			darkrp_purchase_ammo                           = "{1} purchased {2} ammo for {3}",
			darkrp_purchase_shipment                       = "{1} purchased a shipment of x{2} {3} for {4}",
			darkrp_purchase_food                           = "{1} purchased food {2} for {3}",
			darkrp_weapons_checked                         = "{1} checked the weapons of {2}",
			darkrp_weapons_confiscated                     = "{1} confiscated the weapons of {2}",
			darkrp_weapons_returned                        = "{1} returned the confiscated weapons of {2}",
			darkrp_filed_warant                            = "{1} filed a warrant on {2} for: {3}",
			darkrp_warrant_cancelled                       = "{1} cancelled a warrant on {2}",
			darkrp_set_wanted                              = "{1} set {2} as wanted for {3}",
			darkrp_cancelled_wanted                        = "{1} cancelled the wanted status of {2}",
			darkrp_auto_cancelled_wanted                   = "{1} lost their wanted status",
			darkrp_starved                                 = "{1} starved",
			darkrp_pocket_added                            = "{1} put {2} in their pocket",
			darkrp_pocket_dropped                          = "{1} dropped {2} from their pocket",
			darkrp_rpname_change                           = "{1} changed their RP name from {2} to {3}",
			darkrp_started_lockpick_owned_entity           = "{1} started lockpicking {2} owned by {3}",
			darkrp_started_lockpick_unowned_entity         = "{1} started lockpicking unowned {2}",
			darkrp_started_lockpick_owned_door             = "{1} started lockpicking a door owned by {2}",
			darkrp_started_lockpick_unowned_door           = "{1} started lockpicking an unowned door",
			darkrp_started_lockpick_own_entity             = "{1} started lockpicking their {2}",
			darkrp_started_lockpick_own_door               = "{1} started lockpicking one of their doors",
			darkrp_successfully_lockpicked_owned_entity    = "{1} successfully lockpicked {2} owned by {3}",
			darkrp_successfully_lockpicked_unowned_entity  = "{1} successfully lockpicked unowned {2}",
			darkrp_successfully_lockpicked_owned_door      = "{1} successfully lockpicked a door owned by {2}",
			darkrp_successfully_lockpicked_unowned_door    = "{1} successfully lockpicked an unowned door",
			darkrp_successfully_lockpicked_own_entity      = "{1} successfully lockpicked their {2}",
			darkrp_successfully_lockpicked_own_door        = "{1} successfully lockpicked one of their doors",
			darkrp_failed_lockpick_owned_entity            = "{1} failed to lockpick {2} owned by {3}",
			darkrp_failed_lockpick_unowned_entity          = "{1} failed to lockpick unowned {2}",
			darkrp_failed_lockpick_owned_door              = "{1} failed to lockpick a door owned by {2}",
			darkrp_failed_lockpick_unowned_door            = "{1} failed to lockpick an unowned door",
			darkrp_failed_lockpick_own_entity              = "{1} failed to lockpick their {2}",
			darkrp_failed_lockpick_own_door                = "{1} failed to lockpick one of their doors",
			darkrp_changed_job                             = "{1} changed job from {2} to {3}",
			darkrp_added_law                               = "{1} added law: {2}",
			darkrp_removed_law                             = "{1} removed law: {2}",
			darkrp_sold_door                               = "{1} sold a door",
			darkrp_bought_door                             = "{1} bought a door",
			darkrp_dropped_money                           = "{1} dropped {2}",
			darkrp_picked_up_money                         = "{1} picked up {2}",
			darkrp_picked_up_money_dropped_by              = "{1} picked up {2} which was dropped by {3}",
			darkrp_gave_money                              = "{1} gave {2} to {3}",
			darkrp_afk_demoted                             = "{1} was demoted for being AFK",
			darkrp_lottery_started                         = "{1} started a lottery with an entry price of {2}",
			darkrp_lottery_ended                           = "{1} won {2} from the lottery!",
			darkrp_lottery_fail                            = "The lottery failed to find a winner",
 
			pvp_instigator_killed_noweapon                 = "{1} {2} finished combat and KILLED {3} {4} after {5}", -- after X seconds/minutes/hours
			pvp_instigator_killed_weapon                   = "{1} {2} finished combat using {3} and KILLED {4} {5} after {6}",
			pvp_instigator_killed_weapons                  = "{1} {2} finished combat using multiple weapons and KILLED {3} {4} after {5}",
			pvp_victim_killed_noweapon                     = "{1} {2} finished combat and GOT KILLED BY {3} {4} after {5}",
			pvp_victim_killed_weapon                       = "{1} {2} finished combat using {3} and GOT KILLED BY {4} {5} after {6}",
			pvp_victim_killed_weapons                      = "{1} {2} finished combat using multiple weapons and GOT KILLED BY {3} {4} after {5}",
			pvp_combat_noweapon                            = "{1} {2} finished combat with {3} {4} after {5}",
			pvp_combat_weapon                              = "{1} {2} finished combat using {3} with {4} {5} after {6}",
			pvp_combat_weapons                             = "{1} {2} finished combat using multiple weapons with {3} {4} after {5}",
			pvp_log_noweapon                               = "{1} hit {2} for {3} damage",
			pvp_log_weapon                                 = "{1} hit {2} for {3} damage using a {4}",
			pvp_killed                                     = "{1} killed {2}",
			pvp_vehicle_owned_killed                       = "{1} was hit & killed by {2} with no driver but owned by {3}",
			pvp_vehicle_owned_damaged                      = "{1} was hit for {2} damage by {3} with no driver but owned by {4}",
			pvp_vehicle_killed                             = "{1} was hit & killed by {2} with no driver and owned by nobody",
			pvp_vehicle_damaged                            = "{1} was hit for {2} damage by {3} with no driver and owned by nobody",
			pvp_killed_self                                = "{1} killed themselves",
			pvp_damaged_self                               = "{1} damaged themselves for {2} damage",
 
			changed_team                                   = "{1} changed team from {2} to {3}",
			command_used                                   = "{1}: {2}",
			warned_reason                                  = "{1} was warned by {2} for {3}",
			warned_noreason                                = "{1} was warned by {2}",
			warned_kicked                                  = "{1} was KICKED for breaching the active warning threshold",
			warned_banned                                  = "{1} was BANNED for breaching the active warning threshold",
			handcuffed                                     = "{1} handcuffed {2}",
			handcuffs_broken_by                            = "{1} broke {2} out of handcuffs",
			handcuffs_broken                               = "{1} broke out of their handcuffs",
			npc_health_bought                              = "{1} bought health from an NPC for {2}",
			npc_armor_bought                               = "{1} bought armor from an NPC for {2}",
			pac_outfit                                     = "{1} switched to PAC outfit {2}",
			party_chat                                     = "{1} ({2}): {3}",
			party_created                                  = "{1} created party {2}",
			party_join                                     = "{1} joined party {2}",
			party_join_request                             = "{1} requested to join party {2}",
			party_invite                                   = "{1} invited {2} to party {3}",
			party_leave                                    = "{1} left party {2}",
			party_kick                                     = "{1} kicked {2} from party {3}",
			party_disbanded                                = "{1} disbanded party {2}",
			party_abandoned                                = "{1} left the server and abandoned their party {2}",
			spraymesh                                      = "{1} used their spray {2}",
			starwarsvehicle_damage_owned_weapon            = "{1} damaged Star Wars vehicle {2} owned by {3} for {4} damage with {5}",
			starwarsvehicle_damage_owned                   = "{1} damaged Star Wars vehicle {2} owned by {3} for {4} damage",
			starwarsvehicle_damage_weapon                  = "{1} damaged Star Wars vehicle {2} for {3} damage with {4}",
			starwarsvehicle_damage                         = "{1} damaged Star Wars vehicle {2} for {3} damage",
			wac_damage_owned_weapon                        = "{1} damaged WAC aircraft {2} owned by {3} for {4} damage with {5}",
			wac_damage_owned                               = "{1} damaged WAC aircraft {2} owned by {3} for {4} damage",
			wac_damage_weapon                              = "{1} damaged WAC aircraft {2} for {3} damage with {4}",
			wac_damage                                     = "{1} damaged WAC aircraft {2} for {3} damage",
			wyozi_cinema_queued                            = "{1} requested video {2} ➞ {3} at cinema {4}",
			wyozi_dj_queued                                = "{1} queued {2} ➞ {3} on channel {4}",
			wyozi_dj_channel_rename                        = "{1} renamed a channel to {2}",
 
			bwhitelist_whitelist_enabled_by                = "{1} enabled the whitelist for {2}",
			bwhitelist_whitelist_enabled                   = "The whitelist for {1} was enabled",
			bwhitelist_whitelist_disabled_by               = "{1} disabled the whitelist for {2}",
			bwhitelist_whitelist_disabled                  = "The whitelist for {1} was disabled",
 
			bwhitelist_blacklist_enabled_by                = "{1} enabled the blacklist for {2}",
			bwhitelist_blacklist_enabled                   = "The blacklist for {1} was enabled",
			bwhitelist_blacklist_disabled_by               = "{1} disabled the blacklist for {2}",
			bwhitelist_blacklist_disabled                  = "The blacklist for {1} was disabled",
 
			bwhitelist_added_to_whitelist_by               = "{1} was added to the whitelist for {2} by {3}",
			bwhitelist_added_to_whitelist                  = "{1} was added to the whitelist for {2}",
			bwhitelist_removed_from_whitelist_by           = "{1} was removed from the whitelist for {2} by {3}",
			bwhitelist_removed_from_whitelist              = "{1} was removed from the whitelist for {2}",
			bwhitelist_added_to_blacklist_by               = "{1} was added to the blacklist for {2} by {3}",
			bwhitelist_added_to_blacklist                  = "{1} was added to the blacklist for {2}",
			bwhitelist_removed_from_blacklist_by           = "{1} was removed from the blacklist for {2} by {3}",
			bwhitelist_removed_from_blacklist              = "{1} was removed from the blacklist for {2}",
 
			bwhitelist_added_to_whitelist_by_usergroup     = "Usergroup {1} was added to the whitelist for {2} by {3}",
			bwhitelist_added_to_whitelist_usergroup        = "Usergroup {1} was added to the whitelist for {2}",
			bwhitelist_removed_from_whitelist_by_usergroup = "Usergroup {1} was removed from the whitelist for {2} by {3}",
			bwhitelist_removed_from_whitelist_usergroup    = "Usergroup {1} was removed from the whitelist for {2}",
			bwhitelist_added_to_blacklist_by_usergroup     = "Usergroup {1} was added to the blacklist for {2} by {3}",
			bwhitelist_added_to_blacklist_usergroup        = "Usergroup {1} was added to the blacklist for {2}",
			bwhitelist_removed_from_blacklist_by_usergroup = "Usergroup {1} was removed from the blacklist for {2} by {3}",
			bwhitelist_removed_from_blacklist_usergroup    = "Usergroup {1} was removed from the blacklist for {2}",
 
			bwhitelist_added_to_whitelist_by_luafunc       = "Lua function {1} was added to the whitelist for {2} by {3}",
			bwhitelist_added_to_whitelist_luafunc          = "Lua function {1} was added to the whitelist for {2}",
			bwhitelist_removed_from_whitelist_by_luafunc   = "Lua function {1} was removed from the whitelist for {2} by {3}",
			bwhitelist_removed_from_whitelist_luafunc      = "Lua function {1} was removed from the whitelist for {2}",
			bwhitelist_added_to_blacklist_by_luafunc       = "Lua function {1} was added to the blacklist for {2} by {3}",
			bwhitelist_added_to_blacklist_luafunc          = "Lua function {1} was added to the blacklist for {2}",
			bwhitelist_removed_from_blacklist_by_luafunc   = "Lua function {1} was removed from the blacklist for {2} by {3}",
			bwhitelist_removed_from_blacklist_luafunc      = "Lua function {1} was removed from the blacklist for {2}",

			pvp_combat_begin = "{1} instigated combat against {2}",
			pvp_combat_end   = "The combat instigated by {1} against {2} has ended",

			pvp_player_damage_weapon = "{1} damaged {2} with a {3}",
			pvp_player_damage = "{1} damaged {2}",
			pvp_misc_dmg = "{1} was damaged by {2}",
			pvp_fall_damage = "{1} took fall damage",
			pvp_world_crush_damage = "{1} was crushed against the world",
			pvp_world_damage = "{1} was damaged by the world",
			pvp_prop_self_damage = "{1} damaged themself with prop {2}",
			pvp_prop_damage = "{1} was damaged by prop {2} created by {3}",
			pvp_world_prop_damage = "{1} was damaged by world prop {2}",
			pvp_dmg_self = "{1} damaged themself",
			pvp_vehicle_damage = "{1} was damaged by vehicle {2} driven by {3}",
			pvp_driverless_vehicle_damage = "{1} was damaged by vehicle {2} driven by no one",
			pvp_vehicle_damage_self = "{1} was damaged by crashing their vehicle {2}",

			pvp_player_silent_death = "{1} was silently killed",
			pvp_death_propkill_self = "{1} propkilled themself with {2}",
			pvp_death_propkill_world = "{1} was propkilled by world prop {2}",
			pvp_death_propkill = "{1} was propkilled by {2} using prop {3}",
			pvp_death_player = "{1} was killed by {2}",
			pvp_death_player_weapon = "{1} was killed by {2} with a {3}",
			pvp_death_world = "{1} was killed by the world",
			pvp_death = "{1} was killed",
			
			pvp_misc_dmg_prop = "{1} took {2} from world prop {3}",
			pvp_misc_dmg_attacker = "{1} took {2} from {3}",
			pvp_misc_dmg_other = "{1} took {2}",

			steamfam = "{1} is Steam Family sharing with {2}",
		},

		pvp_dmgtype_generic = "%u damage",
		pvp_dmgtype_burn = "%u burn damage",
		pvp_dmgtype_crush = "%u crush damage",
		pvp_dmgtype_fall = "%u fall damage",
		pvp_dmgtype_bullet = "%u bullet damage",
		pvp_dmgtype_slash = "%u slash damage",
		pvp_dmgtype_vehicle = "%u vehicle damage",
		pvp_dmgtype_blast = "%u explosion damage",
		pvp_dmgtype_club = "%u club damage",
		pvp_dmgtype_shock = "%u electric shock damage",
		pvp_dmgtype_sonic = "%u sonic damage",
		pvp_dmgtype_energybeam = "%u laser damage",
		pvp_dmgtype_drown = "%u drowning damage",
		pvp_dmgtype_nervegas = "%u neurotoxin damage",
		pvp_dmgtype_poison = "%u poison damage",
		pvp_dmgtype_radiation = "%u radiation damage",
		pvp_dmgtype_acid = "%u chemical damage",
		pvp_dmgtype_gravgun = "%u gravity gun damage",
		pvp_dmgtype_plasma = "%u plasma damage",
		pvp_dmgtype_airboat = "%u airboat gun damage",
		pvp_dmgtype_buckshot = "%u buckshot bullet damage",
		pvp_dmgtype_sniper = "%u sniper bullet damage",

} end }
--addons/billy_gas/lua/gmodadminsuite/modules/playerdatabase/_gas_info.lua:
return {
	Name = "Player Database",
	Category = GAS.MODULE_CATEGORY_PLAYER_MANAGEMENT,
	Icon = "icon16/database.png"
}
--lua/autorun/kiwi2.lua:
player_manager.AddValidModel( "Kiwi2", "models/TSBB/Animals/Kiwi2.mdl")
list.Set( "PlayerOptionsModel", "Kiwi2", "models/TSBB/Animals/Kiwi2.mdl")

--addons/weapon_jedi/lua/autorun/lscs_best_regards_from_luna.lua:
--[[

heavily modified version of GVP's Lightsaber System for public use

please dont reupload, dont resell

best regards luna

]]--

LSCS = istable( LSCS ) and LSCS or { Hilt = {}, Blade = {}, Stance = {}, Force = {},BulletTracerDeflectable = {} }

LSCS.VERSION = 168
LSCS.VERSION_GITHUB = 0
LSCS.VERSION_TYPE = ".GIT"

function LSCS:GetVersion()
	return LSCS.VERSION
end

function LSCS:CheckUpdates()
	http.Fetch("https://raw.githubusercontent.com/Blu-x92/lscs_public/main/lua/autorun/lscs_best_regards_from_luna.lua", function(contents,size) 
		local Entry = string.match( contents, "LSCS.VERSION%s=%s%d+" )

		if Entry then
			LSCS.VERSION_GITHUB = tonumber( string.match( Entry , "%d+" ) ) or 0
		end

		if LSCS.VERSION_GITHUB == 0 then
			print("[LSCS] latest version could not be detected, You have Version: "..LSCS:GetVersion())
		else
			if  LSCS:GetVersion() >= LSCS.VERSION_GITHUB then
				print("[LSCS] is up to date, Version: "..LSCS:GetVersion())
			else
				print("[LSCS] a newer version is available! Version: "..LSCS.VERSION_GITHUB..", You have Version: "..LSCS:GetVersion())
				print("[LSCS] get the latest version at https://github.com/Blu-x92/LUNA_SWORD_COMBAT_SYSTEM")

				if CLIENT then 
					timer.Simple(18, function() 
						chat.AddText( Color( 255, 0, 0 ), "[LSCS] a newer version is available!" )
					end)
				end
			end
		end
	end)
end

AddCSLuaFile("lscs/init.lua")
include("lscs/init.lua")

if SERVER then
	resource.AddWorkshop("2837856621")
end

hook.Add( "InitPostEntity", "!!!lscscheckupdates", function()
	timer.Simple(20, function() LSCS:CheckUpdates() end)
end)

LSCS:Reload()

--addons/weapon_jedi/lua/lscs/autorun/lscs_crafting.lua:

local meta = FindMetaTable( "Player" )

if SERVER then
	util.AddNetworkString( "lscs_craft_saber" )

	function meta:lscsCraftSaber( dont_mess_with_pickup_notifications )
		local HiltR, HiltL = self:lscsGetHilt()
		local BladeR, BladeL = self:lscsGetBlade()

		-- allow updating but don't allow spawning if the gamemode forbids it
		local SWEP = self:GetWeapon( "weapon_lscs" )
		local OldBP

		if IsValid( SWEP ) then
			OldBP = SWEP:GetBlockPoints()
		else
			if hook.Run( "PlayerGiveSWEP", self, "weapon_lscs", weapons.Get( "weapon_lscs" ) ) == false then
				self:ChatPrint("[LSCS] - You don't have permission to spawn this SWEP.")

				return
			end
		end

		self:StripWeapon( "weapon_lscs" )

		if not dont_mess_with_pickup_notifications then self:SetSuppressPickupNotices( true ) end
		self:Give("weapon_lscs")
		if not dont_mess_with_pickup_notifications then self:SetSuppressPickupNotices( false) end

		self:SelectWeapon( "weapon_lscs" )

		self:EmitSound("lscs/equip.mp3")

		local weapon = self:GetWeapon( "weapon_lscs" )

		if IsValid( weapon ) then
			weapon:SetHiltR( HiltR or "" )
			weapon:SetHiltL( HiltL or "" )

			if HiltR and HiltR ~= "" then
				weapon:SetBladeR( BladeR or "" )
			end
			if HiltL and HiltL ~= "" then
				weapon:SetBladeL( BladeL or "" )
			end

			if OldBP then weapon:SetBlockPoints( OldBP ) end
		end

		hook.Run( "LSCS:OnPlayerCraftedSaber", self, weapon )
	end

	net.Receive( "lscs_craft_saber", function( len, ply )
		ply:lscsCraftSaber()
	end )
else
	function meta:lscsCraftSaber()
		net.Start( "lscs_craft_saber" )
		net.SendToServer()
	end
end

--addons/weapon_jedi/lua/lscs/combos/ataru.lua:
COMBO.id = "ataru"
COMBO.PrintName = "Form IV | Ataru"
COMBO.Author = "Deltaa"
COMBO.Description = "Weg des Fledermaus-Falken"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "lscs_ataru"

COMBO.DamageMultiplier = 1
COMBO.MaxBlockPoints = 125

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "h_c3_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.25, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "pure_b_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.4,
	 },
	["BACKFLIP"] = {
		AttackAnim = "r_c6_t1",
		BeginAttack = function( weapon, ply )  
			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 25 )
			ply:lscsSuppressFalldamage(CurTime() + 5)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.8,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "phalanx_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime(), 0.3, Vector(100,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["+45+"] = {
		AttackAnim = "ryoku_b_left_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["W_S_"] = {
		AttackAnim = "ryoku_b_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.7, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1,
	},
	["__S_"] = {
		AttackAnim = "r_left_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "ryoku_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 1,
	},
	["___D"] = {
		AttackAnim = "ryoku_b_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 1.2,
	},
	["_AS_"] = {
		AttackAnim = "vanguard_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.6,
	},
	["W___"] = {
		AttackAnim = "ryoku_r_c4_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.7,
	},
}
--addons/weapon_jedi/lua/lscs/content/lscs_forcepowers.lua:
-- Force Leap
--
local force = {}
force.PrintName = "Machtsprung"
force.Author = "Blu-x92 / Luna"
force.Description = "Springe mit Hilfe der Macht"
force.id = "leap"
force.OnClk =  function(ply, TIME)
	if not ply._lscsAssistedJump then return end

	if ply:OnGround() then
		ply._lscsCanForceJump = true
		ply._lscsPlayedJumpSound = false
		ply._lscsJumpForceTaken = nil
	end

	local JUMP = ply:KeyDown(IN_JUMP) and not ply:InVehicle()

	if JUMP then
		local wep = ply:GetActiveWeapon()
		if IsValid(wep) and wep.LSCS then
			if wep:IsComboActive() then JUMP = false end
		end
	end

	if JUMP ~= ply._lscsOldJump then
		ply._lscsOldJump = JUMP
		if JUMP then
			ply._lscsJumpTime = TIME + 0.1
		else
			if not ply:OnGround() then
				ply._lscsCanForceJump = false
			end
		end
	end

	if JUMP and ply:lscsGetForce() > 0 and (ply._lscsJumpForceTaken or 0) < 35 and ply._lscsCanForceJump and (ply._lscsJumpTime or 0) < TIME and not ply:OnGround() then
		ply:lscsSuppressFalldamage( TIME + 5 )
		ply:SetVelocity(Vector(0, 0, 100) + Angle(0, ply:EyeAngles().y, 0):Forward() * 25)
		ply:lscsTakeForce(0.1)
		ply._lscsJumpForceTaken = ply._lscsJumpForceTaken and ply._lscsJumpForceTaken + 2.5 or 0

		if not ply._lscsPlayedJumpSound then
			ply._lscsPlayedJumpSound = true

			net.Start("lscs_start_jump")
			net.Send(ply)

			ply:EmitSound("lscs/force/jump.mp3")
		end
	end
end
force.Equip = function( ply ) ply._lscsAssistedJump = true end
force.UnEquip = function( ply ) ply._lscsAssistedJump = false end
force.StartUse = function( ply )
	if ply._lscsForceJumpTime then
		ply._lscsForceJumpTime = nil
	else
		if ply:InVehicle() then return end

		ply._lscsForceJumpTime = CurTime() + 2
	end
end
force.StopUse = function( ply )
	ply._lscsForceJumpTime = nil
end
LSCS:RegisterForce( force )


-- Lichtschwertwurf
--
local force = {}
force.PrintName = "Lichtschwertwurf"
force.Author = "Blu-x92 / Luna"
force.Description = "Wirf dein Lichtschwert"
force.id = "throw"
force.StartUse = function( ply )
	if ply:InVehicle() then return end

	local CurSWEP = ply:GetActiveWeapon()
	local SWEP = ply:GetWeapon( "weapon_lscs" )

	if IsValid(CurSWEP) then
		if CurSWEP.LSCS then
			SWEP = CurSWEP
		end
	end

	if not IsValid( SWEP ) then return end
	if SWEP:IsBrokenSaber() then return end

	if (ply._lscsNextThrow or 0) > CurTime() then return end

	ply._lscsNextThrow = CurTime() + 1

	if IsValid( ply._lscsThrownSaber ) then
		if not ply._lscsThrownSaber.Returning then
			ply._lscsThrownSaber:ResetProgress()
			ply._lscsThrownSaber.Returning = true
		end
	else
		if ply:lscsGetForce() < 10 then return end

		if ply:GetActiveWeapon() ~= SWEP then
			ply:SelectWeapon( "weapon_lscs" )
		end

		LSCS:PlayVCDSequence( ply, "zombie_attack_02", 0.3 )

		local proj = ents.Create("lscs_projectile")
		proj:SetPos( ply:GetShootPos() - Vector(0,0,20) )
		proj:SetSWEP( SWEP )
		proj:Spawn()
		proj:Activate()

		ply:EmitSound("npc/zombie/claw_miss1.wav")

		SWEP:SetHoldType( "magic" )

		ply._lscsThrownSaber = proj
	end
end
force.StopUse = function( ply )
	if IsValid( ply._lscsThrownSaber ) then
		ply._lscsThrownSaber:ResetProgress()
		ply._lscsThrownSaber.Returning = true
	end
end
LSCS:RegisterForce( force )

-- Machtschub
--
local force = {}
force.PrintName = "Machtschub"
force.Author = "Blu-x92 / Luna"
force.Description = "Push things around"
force.id = "push"
force.StartUse = function( ply )
	if ply:lscsGetForce() < 20 then return end

	local Time = CurTime()

	local CanPush = (ply._lscsNextForce or 0) < Time
	if not CanPush then return end

	ply._lscsNextForce = Time + 1

	ply:EmitSound("lscs/force/push.mp3")
	ply:lscsTakeForce(20)

	local AimVector = ply:GetAimVector()
	local MyPos = ply:GetShootPos()

	LSCS:PlayVCDSequence(ply, "wos_cast_lightning_armed")

	local effectdata = EffectData()
	effectdata:SetOrigin(MyPos)
	effectdata:SetNormal(AimVector)
	effectdata:SetEntity(ply)
	util.Effect("force_push", effectdata, true, true)

	for _, Ent in pairs(ents.FindInSphere(MyPos, 800)) do
		local Sub = (Ent.GetShootPos and Ent:GetShootPos() or Ent:GetPos()) - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg(math.acos(math.Clamp( AimVector:Dot( ToTarget), -1, 1))) < 30 then
			local Dist = Sub:Length()

			if IsValid(Ent) and Dist < 800 then
				local Vel = Sub:GetNormalized() * 1250 + Vector(0,0,50)

				LSCS:ForceApply(Ent, Vel, ply)
			end
		end
	end
end
LSCS:RegisterForce(force)

-- Machtzug
--
local force = {}
force.PrintName = "Machtzug"
force.Author = "Blu-x92 / Luna"
force.Description = "Pull things towards yourself"
force.id = "pull"
force.StartUse = function( ply )
	if ply:lscsGetForce() < 20 then return end

	local Time = CurTime()

	local CanPush = (ply._lscsNextForce or 0) < Time

	if not CanPush then return end

	ply._lscsNextForce = Time + 1

	ply:EmitSound("lscs/force/pull.mp3")
	ply:lscsTakeForce( 20 )

	local AimVector = ply:GetAimVector()
	local MyPos = ply:GetShootPos()

	LSCS:PlayVCDSequence( ply, "gesture_becon", 0.8 )

	local effectdata = EffectData()
		effectdata:SetOrigin( MyPos )
		effectdata:SetNormal( AimVector )
		effectdata:SetEntity( ply )
	util.Effect( "force_pull", effectdata, true, true )

	for _, Ent in pairs(ents.FindInSphere(MyPos, 800)) do
		local Sub = (Ent.GetShootPos and Ent:GetShootPos() or Ent:GetPos()) - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg(math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 20 then
			local Dist = Sub:Length()

			if IsValid( Ent ) and Dist < 800 then
				local Vel = -Sub:GetNormalized() * 1250 + Vector(0,0,50)

				LSCS:ForceApply(Ent, Vel, ply)
			end
		end
	end
end
LSCS:RegisterForce( force )


-- Machtsicht
--
local force = {}
force.PrintName = "Machtsicht"
force.Author = "Blu-x92 / Luna"
force.Description = "Augmented Vision. See through the lies of the Jedi and through walls"
force.id = "sight"
force.OnClk =  function( ply, TIME )
	if not ply:GetNWBool( "_lscsForceSense", false ) then return end

	if not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
		ply:SetNWBool( "_lscsForceSense", false )
		return
	end

	ply:lscsTakeForce()

	if (ply._lscsSenseTime or 0) < TIME then
		ply:SetNWBool( "_lscsForceSense", false )
	end
end
force.UnEquip = function( ply ) ply:SetNWBool( "_lscsForceSense", false ) end
force.StartUse = function( ply )
	local Time = CurTime()

	local CanDo = (ply._lscsNextForce or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 1

	if ply:GetNWBool( "_lscsForceSense", false ) then
		ply:SetNWBool( "_lscsForceSense", false )
	else
		if ply:lscsGetForce() >= 30 then
			ply:SetNWBool( "_lscsForceSense", true )
			ply._lscsSenseTime = CurTime() + 20

			ply:lscsTakeForce( 30 )
			ply:EmitSound("lscs/force/sense.mp3")
		end
	end

end
LSCS:RegisterForce( force )


-- Machtheilung
--
local force = {}
force.PrintName = "Heal"
force.Author = "Blu-x92 / Luna"
force.Description = "Heal yourself using the Force"
force.id = "heal"
force.StartUse = function( ply )
	local Time = CurTime()

	local CanDo = (ply._lscsNextForce or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 2

	local available = ply:lscsGetForce()
	local need = ply:GetMaxHealth() - ply:Health()

	if need > 0 and available >= 5 then
		local take = math.min( need, available, 25 )

		ply:lscsTakeForce( take )
		ply:SetHealth( math.min(ply:Health() + take ) )

		ply:EmitSound("lscs/force/heal.mp3")

		local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		util.Effect( "force_heal", effectdata, true, true )
	end
end
LSCS:RegisterForce( force )

-- Replenish
--
local force = {}
force.PrintName = "Replenish"
force.Author = "Blu-x92 / Luna"
force.Description = "A Dark Side ability that regains Force from Health"
force.id = "replenish"
force.StartUse = function( ply )
	local Time = CurTime()

	if (ply._lscsNextForceReplenish or 0) > Time then return end

	ply._lscsNextForceReplenish = Time + 2

	local available = math.max( ply:Health() - 1, 0 )

	local need = ply:lscsGetMaxForce() - ply:lscsGetForce()

	if available > 1 then
		if need > 0 then
			local take = math.min( need, available, 50 )

			ply:SetHealth( ply:Health() - take )
			ply:lscsSetForce( math.min(ply:lscsGetForce() + take, ply:lscsGetMaxForce()) )

			ply:EmitSound("lscs/force/replenish.mp3")

			local effectdata = EffectData()
				effectdata:SetOrigin( ply:GetPos() )
				effectdata:SetEntity( ply )
			util.Effect( "force_replenish", effectdata, true, true )
		end
	else
		if need > 0 then
			ply:EmitSound("lscs/force/replenish.mp3")

			local d = DamageInfo()
			d:SetDamage( 1 )
			d:SetAttacker( ply )
			d:SetDamageType( DMG_DROWN ) 
			d:SetDamagePosition( ply:GetShootPos() )
			ply:TakeDamageInfo( d )
		end
	end
end
LSCS:RegisterForce( force )

-- Immunity
--
local force = {}
force.PrintName = "Immunity"
force.Author = "Blu-x92 / Luna"
force.Description = "Incoming Force Power attacks are absorbed and regain Force Points. Also gives a permanent immunity against incoming Force Powers as long your own Force Points are above 50% even when this Power is not activated. Only the weak minded don't learn this ability."
force.id = "immunity"
force.OnClk =  function( ply, TIME )
	if not ply:GetNWBool( "_lscsForceProtect", false ) then return end

	if not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
		ply:SetNWBool( "_lscsForceProtect", false )
		return
	end

	local effectdata = EffectData()
		effectdata:SetOrigin( ply:GetPos() )
		effectdata:SetEntity( ply )
	util.Effect( "force_block_active", effectdata, true, true )

	ply:lscsTakeForce()

	if (ply._lscsBlockTime or 0) < TIME then
		ply:SetNWBool( "_lscsForceProtect", false )
	end
end
force.Equip = function(ply) ply._lscsForceResistant = true end
force.UnEquip = function(ply) ply._lscsForceResistant = nil ply:GetNWBool( "_lscsForceProtect", false ) end
force.StartUse = function(ply)
	local Time = CurTime()

	local CanDo = (ply._lscsNextForce or 0) < Time
	if not CanDo then return end

	ply._lscsNextForce = Time + 1

	if ply:GetNWBool( "_lscsForceProtect", false ) then
		ply:SetNWBool( "_lscsForceProtect", false )
	else
		if ply:lscsGetForce() < 20 then return end

		ply:SetNWBool( "_lscsForceProtect", true )
		ply._lscsBlockTime = CurTime() + 20

		ply:EmitSound("lscs/force/protect.mp3")

		ply:lscsTakeForce( 20 )
	end
end
LSCS:RegisterForce( force )

local function ForceFry( ply, TIME )
	local effectdata = EffectData()
		effectdata:SetOrigin( ply:GetPos() )
		effectdata:SetEntity( ply )
	util.Effect( "force_lightning", effectdata, true, true )

	local MyPos = ply:GetShootPos()
	local AimVector = ply:GetAimVector()
	local Force = AimVector * 100

	for _, victim in pairs( ents.FindInSphere( MyPos, 1000 ) ) do
		local TargetPos = victim.GetShootPos and victim:GetShootPos() or victim:GetPos()
		local Sub = TargetPos - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 14 then
			if util.TraceLine( {start = MyPos,endpos = victim:LocalToWorld( victim:OBBCenter() ),mask = MASK_SHOT,filter = ply,} ).Entity ~= victim then continue end

			local Dist = Sub:Length()

			if IsValid( victim ) and Dist < 1000 then
				if victim:IsPlayer() then
					if hook.Run( "LSCS:PlayerCanManipulate", ply, victim, true ) then continue end
				end

				if victim:GetClass() == "prop_ragdoll" then
					victim:Fire("StartRagdollBoogie")

					if (victim._lscsBoogieTime or 0) < TIME then
						victim._lscsBoogieTime = TIME + 6

						for i = 1, 70 do
							if math.random(1,5) == 1 then continue end

							timer.Simple( i * 0.1, function()
								if not IsValid( victim ) then return end

								local effect = EffectData()
								effect:SetEntity( victim )
								effect:SetMagnitude(30)
								effect:SetScale(30)
								effect:SetRadius(30)
								util.Effect("TeslaHitBoxes", effect)
								victim:EmitSound("Weapon_StunStick.Activate")
							end )
						end
					end
				end

				local DMGtrace = util.TraceHull( {
					start = MyPos,
					endpos = MyPos + AimVector * 1000,
					filter = ply,
					mins = Vector( -20, -20, -20 ),
					maxs = Vector( 20, 20, 20 ),
					mask = MASK_SHOT_HULL,
					filter = function( ent ) return ent == victim end
				} )

				local DmgSub = TargetPos - DMGtrace.HitPos
				local DmgPos = DMGtrace.HitPos + DmgSub:GetNormalized() * math.min(DmgSub:Length(),20) + VectorRand(-5,5)

				local dmginfo = DamageInfo()
				dmginfo:SetDamage( 5 )
				dmginfo:SetAttacker( ply )
				dmginfo:SetInflictor( ply ) 
				dmginfo:SetDamageType( bit.bor( DMG_SHOCK, DMG_BULLET ) )
				dmginfo:SetDamagePosition( DmgPos )
				dmginfo:SetDamageForce( Force ) 
				victim:TakeDamageInfo( dmginfo )
			end
		end
	end
end

-- Force Lightning
--
local force = {}
force.PrintName = "Machtblitze"
force.Author = "Blu-x92 / Luna"
force.Description = "A Dark Side ability that fires Lightning Bolts out of your Hand"
force.id = "lightning"
force.OnClk =  function(ply, TIME)
	if not ply._lscsLightningTime then return end

	ply:lscsTakeForce( 1 )

	ForceFry( ply, TIME )

	if ply._lscsLightningStartTime < TIME then
		LSCS:PlayVCDSequence(ply, "wos_cast_lightning_armed")
	end

	if ply._lscsLightningTime < TIME or ply:lscsGetForce() <= 0 or not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
		ply._lscsLightningTime = nil
		ply._lscsLightningStartTime = nil
	end
end
force.Equip = function( ply ) end
force.UnEquip = function( ply ) end
force.StartUse = function( ply )
	local Time = CurTime()

	if (ply._lscsLightningTime or 0) > Time then
		ply._lscsLightningTime = nil
		ply._lscsLightningStartTime = nil

		return
	end

	if ply:lscsGetForce() < 10 then return end

	local CanDo = (ply._lscsNextForce or 0) < Time and (ply._lscsLightningTime or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 2

	ply:EmitSound("lscs/force/lightning.mp3")

	ply:lscsTakeForce(5)

	ForceFry(ply, Time)

	if not ply._lscsLightningTime then
		ply._lscsLightningTime = CurTime() + 5
		ply._lscsLightningStartTime = CurTime() + 0.15
	end
end
force.StopUse = function( ply )
	ply._lscsLightningTime = nil
end
LSCS:RegisterForce( force )


-- Rock Throw
--
local force = {}
force.PrintName = "Steinschlag"
force.Author = "Deltaa"
force.Description = "Steine sind der Weg zu wahrer Größe"
force.id = "rockthrow"
force.StartUse = function(ply)
    if ply:lscsGetForce() < 50 then return end
    if ply._lscsNextForce and ply._lscsNextForce > CurTime() then return end

    ply:lscsTakeForce(50)
    ply._lscsNextForce = CurTime() + 5

    local rockModel = "models/props_junk/rock001a.mdl"
    local rockSpeed = 10000 -- Erhöhte Geschwindigkeit der geworfenen Steine
    local rockDamage = 100 -- Schaden verursacht durch die Steine
    local rockCount = 20 -- Anzahl der zu erstellenden Steine
    local rockSpread = 100 -- Streuung der Steine um den Spieler herum
    local rockHoverTime = 1.9 -- Zeit, die die Steine in der Luft verharren, bevor sie geworfen werden

    LSCS:PlayVCDSequence(ply, "wos_jedi_forceblast")

    -- Erstellen und Platzieren der Steine um den Spieler herum
    for i = 1, rockCount do
        local rock = ents.Create("prop_physics")
        rock:SetModel(rockModel)

        -- Berechnen einer zufälligen Position über dem Boden um den Spieler herum
        local plyPos = ply:GetPos()
        local plyEyePos = ply:EyePos()
        local plyForward = ply:GetForward()
        local trace = util.TraceLine({
            start = plyEyePos,
            endpos = plyEyePos + plyForward * 100, -- Verlängere den Trace vorwärts
            filter = function(ent) return ent ~= ply end -- Schließe den Spieler als Filter aus
        })
        local groundPos = trace.HitPos + Vector(0, 0, 40) -- Erhöhe die Z-Komponente, um sicherzustellen, dass die Steine über dem Boden spawnen
        local randomOffset = Vector(math.random(-rockSpread, rockSpread), math.random(-rockSpread, rockSpread), math.random(-rockSpread, rockSpread)) -- Zufällige Verschiebung in alle Richtungen
        rock:SetPos(groundPos + randomOffset)
        rock:SetModelScale(math.random(1, 3))
        rock:Spawn()

        -- Setzen der Geschwindigkeit der Steine in Richtung der Blickrichtung des Spielers
        local phys = rock:GetPhysicsObject()
        if IsValid(phys) then
            phys:EnableMotion(false) -- Deaktivieren der Bewegung, damit die Steine kurz in der Luft schweben
            timer.Simple(rockHoverTime, function()
                phys:EnableMotion(true) -- Aktivieren der Bewegung nach der Schwebephase
                local rockVelocity = plyForward * rockSpeed
                phys:SetVelocity(rockVelocity)

                local weaponPos = ply:GetShootPos()
                local bulletDirection = rockVelocity:GetNormalized() -- Verwenden Sie die Richtung der Steine für die Bullets
                local bulletSpeed = rockVelocity:Length() -- Verwenden Sie die Geschwindigkeit der Steine für die Bullets
                local spread = 0
                local MAX_TRACE_LENGTH = 10000
                
                -- Feuern der Bullets mit den gleichen Parametern wie die Steine
                rock:FireBullets({
                    Num = 1,
                    Src = weaponPos,
                    Dir = bulletDirection,
                    Spread = Vector(spread, spread, 0),
                    Distance = MAX_TRACE_LENGTH,
                    Damage = 1000,
                    DamageType = DMG_CRUSH,
                    Attacker = ply,
                    Tracer = 1,
                    Force = 1,
                    IgnoreEntity = ply,
                    Callback = function(attacker, tr, dmgInfo)
                        if tr.Entity:IsPlayer() then
                            return {damage = false}
                        end
                    end
                })
            end)
        end

        -- Hinzufügen der Kollisionsabfrage für die Steine
        rock:AddCallback("PhysicsCollide", function(ent, data)
            local hitEntity = data.HitEntity

            -- Überprüfen, ob die Steine mit einer gültigen Entität kollidiert sind
            if IsValid(hitEntity) then
                if hitEntity:IsPlayer() and hitEntity ~= ply then
                    -- Anwenden von Schaden auf die getroffene Entität
                    local dmgInfo = DamageInfo()
                    dmgInfo:SetDamage(rockDamage)
                    dmgInfo:SetAttacker(ply)
                    dmgInfo:SetInflictor(rock)
                    dmgInfo:SetDamageType(DMG_CRUSH)
                    hitEntity:TakeDamageInfo(dmgInfo)
                elseif hitEntity:IsNPC() or hitEntity:IsNextBot() then
                    hitEntity:TakeDamage(1000)
                end
            end

            rock:EmitSound("physics/concrete/boulder_impact_hard" .. math.random(1,4) .. ".wav")

            -- Entfernen der Steine nach der Kollision
            SafeRemoveEntityDelayed(rock, 1)
        end)
    end
end
LSCS:RegisterForce(force)

-- Machtgeschwindigkeit
--
local force = {}
force.PrintName = "Machtgeschwindigkeit"
force.Author = "Deltaa"
force.Description = "Die Macht ist schnell"
force.id = "sprint"
force.StartUse = function(ply)
    if ply:lscsGetForce() < 10 then return end
    if ply._lscsNextForce and ply._lscsNextForce > CurTime() then return end
    if ply.ForceSpeed then return end

    ply:lscsTakeForce(10)
    ply._lscsNextForce = CurTime() + 1

    local normalRun = ply:GetRunSpeed()
    local newRun = ply:GetRunSpeed() + ply:GetRunSpeed()

    ply:EmitSound("lscs/force/jump.mp3")
    ply:SetRunSpeed(newRun)
    ply.ForceSpeed = true

    timer.Simple(20, function() 
        if IsValid(ply) then
            ply:SetRunSpeed(normalRun)
            ply.ForceSpeed = false
        end
    end )
end
LSCS:RegisterForce(force)

-- Macht-Öffnung
--
local force = {}
force.PrintName = "Macht-Öffnung"
force.Author = "Deltaa"
force.Description = "Die Macht öffnet Türen"
force.id = "breach"
force.StartUse = function(ply)
    if ply:lscsGetForce() < 10 then return end

    ply:lscsTakeForce(10)
    ply._lscsNextForce = CurTime() + 1

    -- Valid door entity classes to look for
    local doors = {
        ["prop_door_rotating"] = true,
        ["func_door"] = true,
        ["func_door_rotating"] = true,
    }

    local door = ply:GetEyeTrace().Entity
    if not IsValid(door) or not doors[door:GetClass()] then return end

    local size = door:OBBMaxs() - door:OBBMins()
    if size.x > 300 or size.y > 150 or size.z > 300 then return end

    ply:EmitSound("lscs/force/jump.mp3")
    LSCS:PlayVCDSequence(ply, "wos_jedi_mindtrick")

    timer.Simple(1, function()
        if IsValid(door) then
            door:Fire("Unlock")
            door:Fire("Toggle")
        end

        if IsValid(ply) then
            LSCS:PlayVCDSequence(ply, "idle")
        end
    end)
end
LSCS:RegisterForce(force)

-- Geistestrick
--
local force = {}
force.PrintName = "Geistestrick"
force.Author = "Deltaa"
force.Description = "Die Macht manipuliert den Geist"
force.id = "mindtrick"
force.StartUse = function(ply)
    if ply:lscsGetForce() < 10 then return end

    local target = ply:GetEyeTrace().Entity
    if not IsValid(target) or not (target:IsPlayer() or target:IsNPC() or target:IsNextBot()) then return end
    print(target:Health() >= 250 and not target:GetUnitID() == 10)
    if target:IsPlayer() and target:Health() >= 250 and target:GetUnitID() != 10 then
        AOCRP.HUD:Notify(ply, "Du kannst diesen Spieler nicht beeinflussen!", 2)
        return
    end

    ply:lscsTakeForce(10)
    ply._lscsNextForce = CurTime() + 1

    ply:EmitSound("lscs/force/jump.mp3")
    LSCS:PlayVCDSequence(ply, "wos_jedi_mindtrick")

    timer.Simple(1, function()
        if IsValid(ply) and IsValid(target) and ply:IsPlayer() then
            AOCRP.HUD:Notify(target, "Du tust nun alles, was er sagt!", 5)
            AOCRP.HUD:Notify(target, "Du wurdest von " .. ply:Nick() .. " beeinflusst.", 5)
        end
    end)

    timer.Simple(1, function()
        if IsValid(ply) then
            LSCS:PlayVCDSequence(ply, "idle")
        end
    end)
end
LSCS:RegisterForce(force)

-- Force Lightning
--
local force = {}
force.PrintName = "Machtwürgen"
force.Author = "Deltaa"
force.Description = "I choke you bitch"
force.id = "choke"
force.OnClk =  function(ply, TIME)
    if not ply._lscsIsChoking then return end

    local target = ply._lscsChokeTarget

    -- Checks the conditions for the force choke
	if ply:lscsGetForce() < 10 or not IsValid(target) or not target:Alive() or not ply:IsOnGround() or not ply:Alive() then
        if IsValid(target) then
            LSCS:PlayVCDSequence(target, "idle")
            target._lscsChokedNextAnim = nil
            target:Freeze(false)
        end

        if ply._lscsChokeSound then
            ply._lscsChokeSound:Stop()
        end

        ply._lscsChokeTarget = nil
        ply._lscsChokeNextAnim = nil

        LSCS:PlayVCDSequence(ply, "idle")

        ply._lscsIsChoking = nil

        return
	end

    -- Takes 1/10 force
    ply:lscsTakeForce(.1)

    -- Animation stuff
    if ply._lscsChokeNextAnim and ply._lscsChokeNextAnim <= CurTime() then
        LSCS:PlayVCDSequence(ply, "wos_cast_choke_armed")
        ply._lscsChokeNextAnim = CurTime() + 3
    end

    -- Target stuff
    local target = ply._lscsChokeTarget
    if target._lscsChokedNextAnim <= CurTime() then
        target._lscsChokedNextAnim = CurTime() + 3
        LSCS:PlayVCDSequence(ply._lscsChokeTarget, "wos_force_choke")
    end

    if ply:KeyPressed(IN_ATTACK) then
        local damage = DamageInfo()
        damage:SetDamage(target:GetMaxHealth() * 0.25)
        damage:SetAttacker(ply)
        damage:SetDamageType(DMG_CRUSH)
        target:TakeDamageInfo(damage)
    end
end
force.StartUse = function(ply)
	local Time = CurTime()

	if ply:lscsGetForce() < 10 then return end

    local target = ply:GetEyeTrace().Entity
    if not IsValid(target) or not target:IsPlayer() or not target:Alive() or not target:IsOnGround() then return end
    if ply:GetPos():DistToSqr(target:GetPos()) > 50000 then return end

    ply._lscsIsChoking = true
    ply._lscsChokeTarget = target
	ply._lscsNextForce = Time + 2

    -- Handling the Animations of the player
    LSCS:PlayVCDSequence(ply, "wos_cast_choke_armed")
    ply._lscsChokeNextAnim = CurTime() + 3

    target._lscsChokedNextAnim = CurTime() + 3
    LSCS:PlayVCDSequence(target, "wos_force_choke")
    timer.Simple(0, function()
        target:Freeze(true)
    end)

    -- Emits the sound of the force choke
    ply:EmitSound("lscs/choke_start.wav")
    ply._lscsChokeSound = CreateSound(ply, "lscs/choke_gagging.wav")
    ply._lscsChokeSound:Play()

    -- Takes the force from the player
	ply:lscsTakeForce(5)
end
force.StopUse = function(ply)
    LSCS:PlayVCDSequence(ply, "idle")

    if IsValid(ply._lscsChokeTarget) then
        LSCS:PlayVCDSequence(ply._lscsChokeTarget, "idle")
        ply._lscsChokeTarget._lscsChokedNextAnim = nil
        ply._lscsChokeTarget:Freeze(false)
    end

    ply._lscsIsChoking = nil
    ply._lscsChokeTarget = nil
	ply._lscsChokeTime = nil

    if ply._lscsChokeSound then
        ply._lscsChokeSound:Stop()
    end
end
LSCS:RegisterForce(force)

if SERVER then
	hook.Add( "LSCS:PlayerCanManipulate", "!!!lscs_forceblocking", function( ply, target_ent, ignore_passive )
		if not target_ent.IsPlayer or not target_ent:IsPlayer() then return end

		if target_ent:GetNWBool( "_lscsForceProtect", false ) then
			target_ent:lscsSetForce( math.min(target_ent:lscsGetForce() + 15, target_ent:lscsGetMaxForce()) )

			local effectdata = EffectData()
				effectdata:SetOrigin( target_ent:GetPos() )
				effectdata:SetEntity( target_ent )
			util.Effect( "force_block", effectdata, true, true )

			target_ent:EmitSound("lscs/force/block.mp3")
			LSCS:PlayVCDSequence( target_ent, "walk_magic" )

			return true
		end

		if ignore_passive then return end

		if target_ent._lscsForceResistant and target_ent:lscsGetForce() > 50 then
			LSCS:PlayVCDSequence( target_ent, "walk_magic" )

			return true
		end
	end )
else
	local zoom_mat = Material( "vgui/zoom" )
	local warp = Material("effects/tp_eyefx/tpeye3")

	hook.Add( "HUDPaint", "!lscs_senseoverlay", function()
		local ply = LocalPlayer()

		if not ply:GetNWBool( "_lscsForceSense", false ) then return end

		local X = ScrW()
		local Y = ScrH()

		surface.SetDrawColor( Color(255,255,255,255) )
		surface.SetMaterial( zoom_mat ) 
		surface.DrawTexturedRectRotated( X + X * 0.5, Y * 0.5, X, Y, 0 )
		surface.DrawTexturedRectRotated( X + X * 0.5, Y + Y * 0.5, Y, X, 270 )
		surface.DrawTexturedRectRotated( X * 0.5, Y * 0.5, Y, X, 90 )
		surface.DrawTexturedRectRotated( X * 0.5, Y + Y * 0.5, X, Y, 180 )
	
		surface.SetMaterial( warp ) 
		surface.DrawTexturedRect( 0, 0, X, Y )
	end )

	hook.Add( "HUDPaint", "!lscs_protectoverlay", function()
		local ply = LocalPlayer()

		if not ply:GetNWBool( "_lscsForceProtect", false ) then return end

		local X = ScrW()
		local Y = ScrH()
	
		surface.SetDrawColor(0, 127, 255, 25)
		surface.DrawRect( 0, 0, X, Y )
	end )

	
	local function StencilMagic( renderfunction, Col )
		render.SetStencilWriteMask( 0xFF )
		render.SetStencilTestMask( 0xFF )
		render.ClearStencil()

		render.SetStencilEnable( true )
		render.SetStencilReferenceValue( 1 )
		render.SetStencilCompareFunction( STENCIL_ALWAYS )
		render.SetStencilPassOperation( STENCILOPERATION_REPLACE )
		render.SetStencilZFailOperation( STENCILOPERATION_REPLACE )

		renderfunction()

		render.SetStencilCompareFunction( STENCIL_EQUAL )
		render.ClearBuffersObeyStencil(Col.r, Col.g, Col.b, Col.a , false)

		render.SetStencilEnable( false )
	end

	hook.Add("PostDrawOpaqueRenderables", "!!!!lscs_playertrackerwallhack", function( bDrawingDepth, bDrawingSkybox, isDraw3DSkybox )
		if isDraw3DSkybox then return end

		local ply = LocalPlayer()

		if not ply:GetNWBool( "_lscsForceSense", false ) then return end

		local ply = LocalPlayer()

		StencilMagic( 
			function()
				for _, ent in pairs( ents.GetAll() ) do
					if ent == ply then continue end

					if not ent.IsNPC or not ent.IsNextBot or not ent.IsPlayer then continue end

					if not ent:IsNPC() and not ent:IsNextBot() and not ent:IsPlayer() then continue end

					if ent.Alive and not ent:Alive() then continue end -- doesnt do shit on npc's ...
					if ent.Health and ent:Health() <= 0 then continue end -- doesnt do shit on npc's ...
					if ent.GetMoveType and ent:GetMoveType() == MOVETYPE_NONE then continue end -- this works for npc's

					ent:DrawModel()
				end
			end,
			Color(255,200,0,255)
		)
	end)
end

-- Entwaffnen
--
local force = {}
force.PrintName = "Macht-Entwaffnen"
force.Author = "Deltaa"
force.Description = "Lass fallen!"
force.id = "unarm"
force.StartUse = function(ply)
    if ply:lscsGetForce() < 10 then return end
    
    local trace = ply:GetEyeTrace()
    local target = trace.Entity

    if IsValid(target) and target:IsPlayer() and IsValid(target:GetActiveWeapon()) then
        local weapon = target:GetActiveWeapon()
        if not string.find(weapon.Base, "arccw") then return end

        LSCS:PlayVCDSequence(ply, "gesture_becon", 0.8)
        ply:EmitSound("lscs/force/jump.mp3")

        target:SetEyeAngles((ply:GetPos() - target:GetPos()):Angle())
        target:DropWeapon(weapon)

        local forceDir = ply:GetPos() - weapon:GetPos()
        forceDir:Normalize()
        local forceStrength = 300
        local forceVector = forceDir * forceStrength
        weapon:GetPhysicsObject():ApplyForceCenter(forceVector)

        ply:lscsTakeForce(10)
    end
end
LSCS:RegisterForce(force)

-- Whirlwind
--
local force = {}
force.PrintName = "Machtheben"
force.Author = "Memeti"
force.Description = "Hoch die Hände!"
force.id = "whirlwind"
force.OnClk =  function(ply, TIME)
    if not IsValid(ply.WindTarget) then return end
    if ply.WindTarget:IsPlayer() and not ply.WindTarget:Alive() then
        ply.WindTarget:Freeze(false)
        ply.WindTarget = nil

        LSCS:PlayVCDSequence(ply, "idle")
        ply._nextWhirlwindAnim = nil

        return
    end

    local vec = (ply:EyePos() + ply:GetAimVector()*ply.WindDistance) - ply.WindTarget:GetPos()
    local vec2 = (ply:EyePos() + ply:GetAimVector()*2*ply.WindDistance) - ply.WindTarget:GetPos()

    if ply.WindTarget:IsPlayer() or ply.WindTarget:IsNPC() then
        ply.WindTarget:SetLocalVelocity(vec * 10)
    else
        local phys = ply.WindTarget:GetPhysicsObject()
        phys:SetVelocity(vec * 10)
    end

    if ply._nextWhirlwindAnim and ply._nextWhirlwindAnim <= CurTime() then
        LSCS:PlayVCDSequence(ply, "wos_cast_lightning_armed")
        ply._nextWhirlwindAnim = CurTime() + 0.1
    end

    ply:lscsTakeForce(1)

    if ply:lscsGetForce() < 1 or not ply:Alive() then
        local ed = EffectData()
        ed:SetOrigin(ply.WindTarget:GetPos() + Vector(0, 0, 36))
        ed:SetRadius(128)
        util.Effect("rb655_force_repulse_out", ed, true, true)

        LSCS:PlayVCDSequence(ply, "idle")
        ply._nextWhirlwindAnim = nil

        ply.WindTarget:EmitSound("lightsaber/force_repulse.wav")
        ply.WindTarget = nil
    end
end
force.StartUse = function( ply )
    if ply:lscsGetForce() < 1 then return end
    if IsValid(ply.WindTarget) then return end

    local tr = util.TraceLine(util.GetPlayerTrace(ply))
    local dist = tr.HitPos:Distance(ply:GetPos())
    if not tr.Entity then return end
    if tr.LVS then return end

    if string.match(tr.Entity:GetClass(), "_pod") then return end
    if dist >= 400 then return end

    LSCS:PlayVCDSequence(ply, "wos_cast_lightning_armed")
    ply._nextWhirlwindAnim = CurTime() + 0.1

    ply.WindTarget = tr.Entity
    ply.WindDistance = dist

    return true
end
force.StopUse = function(ply)
    if not IsValid(ply.WindTarget) then return end

    local ed = EffectData()
    ed:SetOrigin(ply.WindTarget:GetPos() + Vector(0, 0, 36))
    ed:SetRadius(128)
    util.Effect("rb655_force_repulse_out", ed, true, true)

    if ply:Alive() then
        LSCS:PlayVCDSequence(ply, "idle")
    end
    ply._nextWhirlwindAnim = nil

    ply.WindTarget:EmitSound("lightsaber/force_repulse.wav")
    ply.WindTarget = nil
end
LSCS:RegisterForce(force)


-- Machttritt
--
local force = {}
force.PrintName = "Machttritt"
force.Author = "Deltaa"
force.Description = "Kick in your ass"
force.id = "kick"
force.StartUse = function( ply )
	if ply:lscsGetForce() < 10 then return end

	local Time = CurTime()

	local CanPush = (ply._lscsNextForce or 0) < Time
	if not CanPush then return end

	ply._lscsNextForce = Time + 1
    
    local target = ply:GetEyeTrace().Entity
    if not IsValid(target) and not target:IsPlayer() and not target:IsNPC() and not target:IsNextBot() then return end
    if ply:GetPos():DistToSqr(target:GetPos()) >= 10000 then return end

	ply:lscsTakeForce(20)

	local AimVector = ply:GetAimVector()
	local MyPos = ply:GetShootPos()

	LSCS:PlayVCDSequence(ply, "wos_bs_shared_kick")

    timer.Simple(0.5, function()
        if not IsValid(target) then return end

        ply:EmitSound("physics/body/body_medium_impact_hard1.wav")

        if target:IsPlayer() then
            target:SetVelocity(ply:GetForward() * 2500)

            timer.Simple(0.1, function()
                if not IsValid(target) then return end

                local ed = EffectData()
                ed:SetOrigin(target:GetPos() + Vector(0, 0, 36))
                ed:SetRadius(128)
                util.Effect("rb655_force_repulse_out", ed, true, true)

                target:EmitSound("lscs/force/jump.mp3")
                LSCS:PlayVCDSequence(target, "wos_bs_shared_falling")
            end)

            timer.Simple(0.4, function()
                if not IsValid(target) then return end
                LSCS:PlayVCDSequence(target, "idle")
            end)
        else
            target:TakeDamage(500)
        end
    end)
end
LSCS:RegisterForce(force)
--addons/lvs_base/lua/autorun/lvs_init.lua:

LVS = istable( LVS ) and LVS or {}

LVS.VERSION = 316
LVS.VERSION_GITHUB = 0
LVS.VERSION_TYPE = ".WS"
LVS.VERSION_ADDONS_OUTDATED = false

LVS.KEYS_CATEGORIES = {}
LVS.KEYS_REGISTERED = {}
LVS.pSwitchKeys = {[KEY_1] = 1,[KEY_2] = 2,[KEY_3] = 3,[KEY_4] = 4,[KEY_5] = 5,[KEY_6] = 6,[KEY_7] = 7,[KEY_8] = 8,[KEY_9] = 9,[KEY_0] = 10}
LVS.pSwitchKeysInv = {[1] = KEY_1,[2] = KEY_2,[3] = KEY_3,[4] = KEY_4,[5] = KEY_5,[6] = KEY_6,[7] = KEY_7,[8] = KEY_8,[9] = KEY_9,[10] = KEY_0}

LVS.ThemeColor = Color(127,0,0,255)

LVS.WHEEL_BRAKE = 1
LVS.WHEEL_STEER_NONE = 2
LVS.WHEEL_STEER_FRONT = 3
LVS.WHEEL_STEER_REAR = 4

LVS.WEAPONS = {
	["DEFAULT"] = {
		Icon = Material("lvs/weapons/bullet.png"),
		Ammo = 9999,
		Delay = 0,
		HeatRateUp = 0.2,
		HeatRateDown = 0.25,
		Attack = function( ent ) end,
		StartAttack = function( ent ) end,
		FinishAttack = function( ent ) end,
		OnSelect = function( ent, old ) end,
		OnDeselect = function( ent, new ) end,
		OnThink = function( ent, active ) end,
		OnOverheat = function( ent ) end,
		OnRemove = function( ent ) end,
		OnReload = function( ent ) end,
	},
}

function LVS:GetVersion()
	return LVS.VERSION
end

function LVS:AddKey(name, category, printname, cmd, default)
	local data = {
		printname = printname,
		id = name,
		category = category,
		cmd = cmd,
	}

	if not LVS.KEYS_CATEGORIES[ category ] then
		LVS.KEYS_CATEGORIES[ category ] = {}
	end

	if SERVER then
		table.insert( LVS.KEYS_REGISTERED, data )
	else
		if default then
			if isstring( default ) then
				local Key = input.LookupBinding( default )

				if Key then
					default = input.GetKeyCode( Key )
				else
					default = 0
				end
			end
		else
			default = 0
		end

		data.default = default

		table.insert( LVS.KEYS_REGISTERED, data )

		CreateClientConVar( cmd, default, true, true )
	end
end

function LVS:CheckUpdates()
	http.Fetch("https://raw.githubusercontent.com/SpaxscE/lvs_base/main/lua/autorun/lvs_init.lua", function(contents,size) 
		local Entry = string.match( contents, "LVS.VERSION%s=%s%d+" )

		if Entry then
			LVS.VERSION_GITHUB = tonumber( string.match( Entry , "%d+" ) ) or 0
		else
			LVS.VERSION_GITHUB = 0
		end

		if LVS.VERSION_GITHUB == 0 then
			print("[LVS] - Framework: latest version could not be detected, You have Version: "..LVS:GetVersion())
		else
			if LVS:GetVersion() >= LVS.VERSION_GITHUB then
				print("[LVS] - Framework is up to date, Version: "..LVS:GetVersion())
			else
				print("[LVS] - Framework: a newer version is available! Version: "..LVS.VERSION_GITHUB..", You have Version: "..LVS:GetVersion())

				if LVS.VERSION_TYPE == ".GIT" then
					print("[LVS] - Framework: get the latest version at https://github.com/SpaxscE/lvs_base")
				else
					print("[LVS] - Framework: restart your game/server to get the latest version!")
				end

				if CLIENT then 
					timer.Simple(18, function() 
						chat.AddText( Color( 255, 0, 0 ), "[LVS] - Framework: a newer version is available!" )
					end)
				end
			end
		end

		local Delay = 0
		local addons = file.Find( "data_static/lvs/*", "GAME" )

		for _, addonFile in pairs( addons ) do
			local addonInfo = file.Read( "data_static/lvs/"..addonFile, "GAME" )

			if not addonInfo then continue end

			local data = string.Explode( "\n", addonInfo )

			local wsid = string.Replace( addonFile, ".txt", "" )
			local addon_name = wsid
			local addon_url
			local addon_version

			for _, entry in pairs( data ) do
				if string.StartsWith( entry, "url=" ) then
					addon_url = string.Replace( entry, "url=", "" )
				end

				if string.StartsWith( entry, "version=" ) then
					addon_version = string.Replace( entry, "version=", "" )
				end

				if string.StartsWith( entry, "name=" ) then
					addon_name = string.Replace( entry, "name=", "" )
				end
			end

			if not addon_url or not addon_version then continue end

			addon_version = tonumber( addon_version )

			Delay = Delay + 1.5

			timer.Simple( Delay, function()
				http.Fetch(addon_url, function(con,_) 
					local addon_entry = string.match( con, "version=%d+" )

					local addon_version_git = 0

					if addon_entry then
						addon_version_git = tonumber( string.match( addon_entry, "%d+" ) ) or 0
					end

					local wsurl = "https://steamcommunity.com/sharedfiles/filedetails/?id="..wsid

					if addon_version_git == 0 then
						print("[LVS] latest version of "..addon_name.." ( "..wsurl.." ) could not be detected, You have Version: "..addon_version)
					else
						if addon_version_git > addon_version then
							print("[LVS] - "..addon_name.." ( "..wsurl.." ) is out of date!")

							if CLIENT then 
								timer.Simple(18, function() 
									chat.AddText( Color( 255, 0, 0 ),"[LVS] - "..addon_name.." is out of date!" )
								end)
							end

							LVS.VERSION_ADDONS_OUTDATED = true

						else
							print("[LVS] - "..addon_name.." is up to date, Version: "..addon_version)
						end
					end
				end)
			end )
		end
	end)
end

function LVS:GetWeaponPreset( name )
	if not LVS.WEAPONS[ name ] then return table.Copy( LVS.WEAPONS["DEFAULT"] ) end

	return table.Copy( LVS.WEAPONS[ name ] )
end

function LVS:AddWeaponPreset( name, data )
	if not isstring( name ) or not istable( data ) then return end

	LVS.WEAPONS[ name ] = data
end

function LVS:GetVehicleTypes()
	local VehicleTypes = {}

	for s, v in pairs( scripted_ents.GetList() ) do
		if not v.t or not isfunction( v.t.GetVehicleType ) then continue end

		local vehicletype = v.t:GetVehicleType()

		if not isstring( vehicletype ) or string.StartsWith( vehicletype, "LBase" ) or table.HasValue( VehicleTypes, vehicletype ) then continue end

		table.insert( VehicleTypes, vehicletype )
	end

	return VehicleTypes
end

AddCSLuaFile("lvs_framework/init.lua")
include("lvs_framework/init.lua")
--addons/lvs_base/lua/lvs_framework/autorun/cl_camera.lua:

function LVS:CalcView( vehicle, ply, pos, angles, fov, pod )
	local view = {}
	view.origin = pos
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	if not pod:GetThirdPersonMode() then return view end

	local mn = vehicle:OBBMins()
	local mx = vehicle:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local TargetOrigin = view.origin + ( view.angles:Forward() * -radius ) + view.angles:Up() * radius * pod:GetCameraHeight()
	local WallOffset = 4

	local tr = util.TraceHull( {
		start = view.origin,
		endpos = TargetOrigin,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.origin = tr.HitPos
	view.drawviewer = true

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

hook.Add( "CalcView", "!!!!LVS_calcview", function(ply, pos, angles, fov)
	if ply:GetViewEntity() ~= ply then return end

	local pod = ply:GetVehicle()
	local vehicle = ply:lvsGetVehicle()

	if not IsValid( pod ) or not IsValid( vehicle ) then return end

	local newfov = vehicle:LVSCalcFov( fov, ply )

	local base = pod:lvsGetWeapon()

	if IsValid( base ) then
		local weapon = base:GetActiveWeapon()

		if weapon and weapon.CalcView then
			return ply:lvsSetView( weapon.CalcView( base, ply, pos, angles, newfov, pod ) )
		else
			return ply:lvsSetView( vehicle:LVSCalcView( ply, pos, angles, newfov, pod ) )
		end
	else
		local weapon = vehicle:GetActiveWeapon()

		if weapon and weapon.CalcView then
			return ply:lvsSetView( weapon.CalcView( vehicle, ply, pos, angles, newfov, pod ) )
		else
			return ply:lvsSetView( vehicle:LVSCalcView( ply, pos, angles, newfov, pod ) )
		end
	end
end )

--addons/lvs_base/lua/lvs_framework/autorun/lvs_convar.lua:
-- 2022 and i still havent bothered creating a system that does this automatically

LVS.cVar_FreezeTeams = CreateConVar( "lvs_freeze_teams", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"enable/disable auto ai-team switching" )
LVS.FreezeTeams = LVS.cVar_FreezeTeams and LVS.cVar_FreezeTeams:GetBool() or false
cvars.AddChangeCallback( "lvs_freeze_teams", function( convar, oldValue, newValue ) 
	LVS.FreezeTeams = tonumber( newValue ) ~=0
end, "lvs_freezeteams_callback" )

LVS.cVar_TeamPassenger = CreateConVar( "lvs_teampassenger", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"only allow players of matching ai-team to enter the vehicle? 1 = team only, 0 = everyone can enter" )
LVS.TeamPassenger = LVS.cVar_TeamPassenger and LVS.cVar_TeamPassenger:GetBool() or false
cvars.AddChangeCallback( "lvs_teampassenger", function( convar, oldValue, newValue ) 
	LVS.TeamPassenger = tonumber( newValue ) ~= 0
end, "lvs_teampassenger_callback" )

LVS.cVar_PlayerDefaultTeam = CreateConVar( "lvs_default_teams", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"set default player ai-team" )
LVS.PlayerDefaultTeam = LVS.cVar_PlayerDefaultTeam and LVS.cVar_PlayerDefaultTeam:GetInt() or 0
cvars.AddChangeCallback( "lvs_default_teams", function( convar, oldValue, newValue ) 
	LVS.PlayerDefaultTeam = math.Round( tonumber( newValue ), 0 )
end, "lvs_defaultteam_callback" )

LVS.cVar_IgnoreNPCs = CreateConVar( "lvs_ai_ignorenpcs", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"should LVS-AI ignore NPCs?" )
LVS.IgnoreNPCs = LVS.cVar_IgnoreNPCs and LVS.cVar_IgnoreNPCs:GetBool() or false
cvars.AddChangeCallback( "lvs_ai_ignoreplayers", function( convar, oldValue, newValue ) 
	LVS.IgnorePlayers = tonumber( newValue ) ~=0
end)

LVS.cVar_playerignore = CreateConVar( "lvs_ai_ignoreplayers", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"should LVS-AI ignore Players?" )
LVS.IgnorePlayers = LVS.cVar_playerignore and LVS.cVar_playerignore:GetBool() or false
cvars.AddChangeCallback( "lvs_ai_ignorenpcs", function( convar, oldValue, newValue ) 
	LVS.IgnoreNPCs = tonumber( newValue ) ~=0
end)

if SERVER then
	util.AddNetworkString( "lvs_admin_setconvar" )

	net.Receive( "lvs_admin_setconvar", function( length, ply )
		if not IsValid( ply ) or not ply:IsSuperAdmin() then return end

		local ConVar = net.ReadString()
		local Value = tonumber( net.ReadString() )

		RunConsoleCommand( ConVar, Value ) 
	end)

	return
end

CreateClientConVar( "lvs_mouseaim", 0, true, true)
CreateClientConVar( "lvs_mouseaim_type", 0, true, false)
CreateClientConVar( "lvs_edit_hud", 1, true, false)
CreateClientConVar( "lvs_sensitivity_x", 1, true, true)
CreateClientConVar( "lvs_sensitivity_y", 1, true, true)
CreateClientConVar( "lvs_return_delta", 2, true, true)

LVS.cvarCamFocus = CreateClientConVar( "lvs_camerafocus", 0, true, false)

local cvarVolume = CreateClientConVar( "lvs_volume", 0.5, true, false)
LVS.EngineVolume = cvarVolume and cvarVolume:GetFloat() or 0.5
cvars.AddChangeCallback( "lvs_volume", function( convar, oldValue, newValue ) 
	LVS.EngineVolume = math.Clamp( tonumber( newValue ), 0, 1 )
end)

local cvarTrail = CreateClientConVar( "lvs_show_traileffects", 1, true, false)
LVS.ShowTraileffects = cvarTrail and cvarTrail:GetBool() or true
cvars.AddChangeCallback( "lvs_show_traileffects", function( convar, oldValue, newValue ) 
	LVS.ShowTraileffects = tonumber( newValue ) ~=0
end)

local cvarEffects = CreateClientConVar( "lvs_show_effects", 1, true, false)
LVS.ShowEffects = cvarEffects and cvarEffects:GetBool() or true
cvars.AddChangeCallback( "lvs_show_effects", function( convar, oldValue, newValue ) 
	LVS.ShowEffects = tonumber( newValue ) ~=0
end)

local cvarPhysEffects = CreateClientConVar( "lvs_show_physicseffects", 1, true, false)
LVS.ShowPhysicsEffects = cvarPhysEffects and cvarPhysEffects:GetBool() or true
cvars.AddChangeCallback( "lvs_show_physicseffects", function( convar, oldValue, newValue ) 
	LVS.ShowPhysicsEffects = tonumber( newValue ) ~=0
end)

local cvarShowIdent = CreateClientConVar( "lvs_show_identifier", 1, true, false)
LVS.ShowIdent = cvarShowIdent and cvarShowIdent:GetBool() or true
cvars.AddChangeCallback( "lvs_show_identifier", function( convar, oldValue, newValue ) 
	LVS.ShowIdent = tonumber( newValue ) ~=0
end)

local cvarHitMarker = CreateClientConVar( "lvs_hitmarker", 1, true, false)
LVS.ShowHitMarker = cvarHitMarker and cvarHitMarker:GetBool() or false
cvars.AddChangeCallback( "lvs_hitmarker", function( convar, oldValue, newValue ) 
	LVS.ShowHitMarker = tonumber( newValue ) ~=0
end)

local cvarAntiAlias = GetConVar( "mat_antialias" )
LVS.AntiAliasingEnabled = cvarAntiAlias and (cvarAntiAlias:GetInt() > 3) or false
cvars.AddChangeCallback( "mat_antialias", function( convar, oldValue, newValue ) 
	LVS.AntiAliasingEnabled = tonumber( newValue ) > 3
end)

local cvarBulletSFX = CreateClientConVar( "lvs_bullet_nearmiss", 1, true, false)
LVS.EnableBulletNearmiss = cvarBulletSFX and cvarBulletSFX:GetBool() or true
cvars.AddChangeCallback( "lvs_bullet_nearmiss", function( convar, oldValue, newValue ) 
	LVS.EnableBulletNearmiss = tonumber( newValue ) ~=0
end)

local cvarDev = GetConVar( "developer" )
LVS.DeveloperEnabled = cvarDev and (cvarDev:GetInt() >= 1) or false
cvars.AddChangeCallback( "developer", function( convar, oldValue, newValue )
	LVS.DeveloperEnabled = (tonumber( newValue ) or 0) >= 1
end)

cvars.AddChangeCallback( "lvs_mouseaim", function( convar, oldValue, newValue )
	LocalPlayer():lvsBuildControls()

	net.Start("lvs_toggle_mouseaim")
	net.SendToServer()
end)

--addons/gm_express/lua/autorun/netstream.lua:
--A net extension which allows sending large streams of data without overflowing the reliable channel
--Keep it in lua/autorun so it will be shared between addons
AddCSLuaFile()

net.Stream = {}
net.Stream.ReadStreamQueues = {}            --This holds a read stream for each player, or one read stream for the server if running on the CLIENT
net.Stream.WriteStreams = {}            --This holds the write streams
net.Stream.SendSize = 20000            --This is the maximum size of each stream to send
net.Stream.Timeout = 30            --How long the data should exist in the store without being used before being destroyed
net.Stream.MaxServerReadStreams = 128  --The maximum number of keep-alives to have queued. This should prevent naughty players from flooding the network with keep-alive messages.
net.Stream.MaxServerChunks = 3200 --Maximum number of pieces the stream can send to the server. 64 MB
net.Stream.MaxTries = 3 --Maximum times the client may retry downloading the whole data
net.Stream.MaxKeepalive = 15 --Maximum times the client may request data stay live

net.Stream.ReadStream = {}
--Send the data sender a request for data
function net.Stream.ReadStream:Request()
	if self.downloads == net.Stream.MaxTries * self.numchunks then self:Remove() return end
	self.downloads = self.downloads + 1
	-- print("Requesting",self.identifier,false,false,#self.chunks)

	net.Start("NetStreamRequest")
	net.WriteUInt(self.identifier, 32)
	net.WriteBit(false)
	net.WriteBit(false)
	net.WriteUInt(#self.chunks, 32)
	if CLIENT then net.SendToServer() else net.Send(self.player) end

	timer.Create("NetStreamReadTimeout" .. self.identifier, net.Stream.Timeout/2, 1, function() self:Request() end)
end

--Received data so process it
function net.Stream.ReadStream:Read(size)
	timer.Remove("NetStreamReadTimeout" .. self.identifier)

	local progress = net.ReadUInt(32)
	if self.chunks[progress] then return end

	local crc = net.ReadString()
	local data = net.ReadData(size)

	if crc == util.CRC(data) then
		self.chunks[progress] = data
	else
		pac.Message("net.Stream.ReadStream:Read(): hash received and hash of chunk do not match match")
	end

	if #self.chunks == self.numchunks then
		self.returndata = table.concat(self.chunks)

		if self.compressed then
			self.returndata = util.Decompress(self.returndata)

			if not self.returndata then
				pac.Message("net.Stream.ReadStream:Read(): Failed to decompress data")
			end
		end

		self:Remove()
	else
		self:Request()
	end
end

--Gets the download progress
function net.Stream.ReadStream:GetProgress()
	return #self.chunks/self.numchunks
end

--Pop the queue and start the next task
function net.Stream.ReadStream:Remove()
	local ok, err = xpcall(self.callback, debug.traceback, self.returndata)
	if not ok then ErrorNoHalt(err) end

	net.Start("NetStreamRequest")
	net.WriteUInt(self.identifier, 32)
	net.WriteBit(false)
	net.WriteBit(true)
	if CLIENT then net.SendToServer() else net.Send(self.player) end

	timer.Remove("NetStreamReadTimeout" .. self.identifier)
	timer.Remove("NetStreamKeepAlive" .. self.identifier)

	if self == self.queue[1] then
		table.remove(self.queue, 1)
		local nextInQueue = self.queue[1]
		if nextInQueue then
			timer.Remove("NetStreamKeepAlive" .. nextInQueue.identifier)
			nextInQueue:Request()
		else
			net.Stream.ReadStreamQueues[self.player] = nil
		end
	else
		for k, v in ipairs(self.queue) do
			if v == self then
				table.remove(self.queue, k)
				break
			end
		end
	end
end

net.Stream.ReadStream.__index = net.Stream.ReadStream

net.Stream.WriteStream = {}

-- The player wants some data
function net.Stream.WriteStream:Write(ply)
	local progress = net.ReadUInt(32)+1
	local chunk = self.chunks[progress]
	if chunk then
		self.clients[ply].progress = progress
		net.Start("NetStreamDownload")
		net.WriteUInt(#chunk.data, 32)
		net.WriteUInt(progress, 32)
		net.WriteString(chunk.crc)
		net.WriteData(chunk.data, #chunk.data)
		if CLIENT then net.SendToServer() else net.Send(ply) end
	end
end

-- The player notified us they finished downloading or cancelled
function net.Stream.WriteStream:Finished(ply)
	self.clients[ply].finished = true

	if self.callback then
		local ok, err = xpcall(self.callback, debug.traceback, ply)
		if not ok then ErrorNoHalt(err) end
	end
end

-- Get player's download progress
function net.Stream.WriteStream:GetProgress(ply)
	return self.clients[ply].progress / #self.chunks
end

-- If the stream owner cancels it, notify everyone who is subscribed
function net.Stream.WriteStream:Remove()
	local sendTo = {}
	for ply, client in pairs(self.clients) do
		if not client.finished then
			client.finished = true
			if ply:IsValid() then sendTo[#sendTo+1] = ply end
		end
	end

	net.Start("NetStreamDownload")
	net.WriteUInt(0, 32)
	net.WriteUInt(self.identifier, 32)
	if SERVER then net.Send(sendTo) else net.SendToServer() end
	net.Stream.WriteStreams[self.identifier] = nil
end

net.Stream.WriteStream.__index = net.Stream.WriteStream

--Store the data and write the file info so receivers can request it.
local identifier = 1

function net.WriteStream(data, callback, dontcompress)
	if not isstring(data) then
		error("bad argument #1 to 'WriteStream' (string expected, got " .. type(data) .. ")", 2)
	end

	if callback ~= nil and not isfunction(callback) then
		error("bad argument #2 to 'WriteStream' (function expected, got " .. type(callback) .. ")", 2)
	end

	local compressed = not dontcompress
	if compressed then
		data = util.Compress(data) or ""
	end

	if #data == 0 then
		net.WriteUInt(0, 32)
		return
	end

	local numchunks = math.ceil(#data / net.Stream.SendSize)
	if CLIENT and numchunks > net.Stream.MaxServerChunks then
		ErrorNoHalt("net.WriteStream request is too large! ", #data/1048576, "MiB")
		net.WriteUInt(0, 32)
		return
	end

	local chunks = {}
	for i=1, numchunks do
		local datachunk = string.sub(data, (i - 1) * net.Stream.SendSize + 1, i * net.Stream.SendSize)
		chunks[i] = {
			data = datachunk,
			crc = util.CRC(datachunk),
		}
	end

	local startid = identifier
	while net.Stream.WriteStreams[identifier] do
		identifier = identifier % 1024 + 1
		if identifier == startid then
			ErrorNoHalt("Netstream is full of WriteStreams!\n" .. debug.traceback() .. "\n")
			net.WriteUInt(0, 32)
			return
		end
	end

	local stream = {
		identifier = identifier,
		chunks = chunks,
		compressed = compressed,
		numchunks = numchunks,
		callback = callback,
		clients = setmetatable({},{__index = function(t,k)
			local r = {
				finished = false,
				downloads = 0,
				keepalives = 0,
				progress = 0,
			} t[k]=r return r
		end})
	}

	setmetatable(stream, net.Stream.WriteStream)

	net.Stream.WriteStreams[identifier] = stream
	timer.Create("NetStreamWriteTimeout" .. identifier, net.Stream.Timeout, 1, function() stream:Remove() end)

	net.WriteUInt(numchunks, 32)
	net.WriteUInt(identifier, 32)
	net.WriteBool(compressed)

	return stream
end

--If the receiver is a player then add it to a queue.
--If the receiver is the server then add it to a queue for each individual player
function net.ReadStream(ply, callback)
	if CLIENT then
		ply = NULL
	else
		if type(ply) ~= "Player" then
			error("bad argument #1 to 'ReadStream' (Player expected, got " .. type(ply) .. ")", 2)
		elseif not ply:IsValid() then
			error("bad argument #1 to 'ReadStream' (Tried to use a NULL entity!)", 2)
		end
	end

	if not isfunction(callback) then
		error("bad argument #2 to 'ReadStream' (function expected, got " .. type(callback) .. ")", 2)
	end

	local queue = net.Stream.ReadStreamQueues[ply]
	if queue then
		if SERVER and #queue == net.Stream.MaxServerReadStreams then
			ErrorNoHalt("Receiving too many ReadStream requests from ", ply)
			return
		end
	else
		queue = {} net.Stream.ReadStreamQueues[ply] = queue
	end

	local numchunks = net.ReadUInt(32)

	if numchunks == nil then
		return
	elseif numchunks == 0 then
		local ok, err = xpcall(callback, debug.traceback, "")
		if not ok then ErrorNoHalt(err) end
		return
	end

	if SERVER and numchunks > net.Stream.MaxServerChunks then
		ErrorNoHalt("ReadStream requests from ", ply, " is too large! ", numchunks * net.Stream.SendSize / 1048576, "MiB")
		return
	end

	local identifier = net.ReadUInt(32)
	local compressed = net.ReadBool()
	--print("Got info", numchunks, identifier, compressed)

	for _, v in ipairs(queue) do
		if v.identifier == identifier then
			ErrorNoHalt("Tried to start a new ReadStream for an already existing stream!\n" .. debug.traceback() .. "\n")
			return
		end
	end

	local stream = {
		identifier = identifier,
		chunks = {},
		compressed = compressed,
		numchunks = numchunks,
		callback = callback,
		queue = queue,
		player = ply,
		downloads = 0
	}

	setmetatable(stream, net.Stream.ReadStream)

	queue[#queue + 1] = stream
	if #queue > 1 then
		timer.Create("NetStreamKeepAlive" .. identifier, net.Stream.Timeout / 2, 0, function()
			net.Start("NetStreamRequest")
			net.WriteUInt(identifier, 32)
			net.WriteBit(true)
			if CLIENT then net.SendToServer() else net.Send(ply) end
		end)
	else
		stream:Request()
	end

	return stream
end

if SERVER then

	util.AddNetworkString("NetStreamRequest")
	util.AddNetworkString("NetStreamDownload")

end

--Stream data is requested
net.Receive("NetStreamRequest", function(len, ply)

	local identifier = net.ReadUInt(32)
	local stream = net.Stream.WriteStreams[identifier]

	if stream then
		ply = ply or NULL
		local client = stream.clients[ply]

		if not client.finished then
			local keepalive = net.ReadBit() == 1
			if keepalive then
				if client.keepalives < net.Stream.MaxKeepalive then
					client.keepalives = client.keepalives + 1
					timer.Adjust("NetStreamWriteTimeout" .. identifier, net.Stream.Timeout, 1)
				end
			else
				local completed = net.ReadBit() == 1
				if completed then
					stream:Finished(ply)
				else
					if client.downloads < net.Stream.MaxTries * #stream.chunks then
						client.downloads = client.downloads + 1
						stream:Write(ply)
						timer.Adjust("NetStreamWriteTimeout" .. identifier, net.Stream.Timeout, 1)
					else
						client.finished = true
					end
				end
			end
		end
	end

end)

--Download the stream data
net.Receive("NetStreamDownload", function(len, ply)

	ply = ply or NULL
	local queue = net.Stream.ReadStreamQueues[ply]
	if queue then
		local size = net.ReadUInt(32)
		if size > 0 then
			queue[1]:Read(size)
		else
			local id = net.ReadUInt(32)
			for k, v in ipairs(queue) do
				if v.identifier == id then
					v:Remove()
					break
				end
			end
		end
	end

end)

--lua/autorun/otter.lua:
player_manager.AddValidModel( "Otter", "models/TSBB/Animals/Otter.mdl")
list.Set( "PlayerOptionsModel", "Otter", "models/TSBB/Animals/Otter.mdl")
player_manager.AddValidModel( "Otter2", "models/TSBB/Animals/Otter2.mdl")
list.Set( "PlayerOptionsModel", "Otter2", "models/TSBB/Animals/Otter2.mdl")

--addons/admin_sam/lua/sam/libs/sh_pon.lua:
if SAM_LOADED then return end

--[[

DEVELOPMENTAL VERSION;

VERSION 1.2.2
Copyright thelastpenguin™

	You may use this for any purpose as long as:
	-	You don't remove this copyright notice.
	-	You don't claim this to be your own.
	-	You properly credit the author, thelastpenguin™, if you publish your work based on (and/or using) this.

	If you modify the code for any purpose, the above still applies to the modified code.

	The author is not held responsible for any damages incured from the use of pon, you use it at your own risk.

DATA TYPES SUPPORTED:
 - tables  -		 k,v - pointers
 - strings -		 k,v - pointers
 - numbers -		k,v
 - booleans-		 k,v

 - Vectors -		 k,v
 - Angles  -		k,v
 - Entities-		 k,v
 - Players -		 k,v

CHANGE LOG
V 1.1.0
 - Added Vehicle, NPC, NextBot, Player, Weapon
V 1.2.0
 - Added custom handling for k,v tables without any array component.
V 1.2.1
 - fixed deserialization bug.

THANKS TO...
 - VERCAS for the inspiration.
]]
local pon = {}
sam.pon = pon

do
	local type = sam.type
	local IsColor = IsColor
	local tonumber = tonumber
	local format = string.format
	local encode = {}
	local cacheSize = 0

	encode['table'] = function(self, tbl, output, cache)
		if cache[tbl] then
			output[#output + 1] = format('(%x)', cache[tbl])

			return
		else
			cacheSize = cacheSize + 1
			cache[tbl] = cacheSize
		end

		local first = next(tbl, nil)
		local predictedNumeric = 1

		-- starts with a numeric dealio
		if first == 1 then
			output[#output + 1] = '{'

			for k, v in next, tbl do
				if k == predictedNumeric then
					predictedNumeric = predictedNumeric + 1
					local tv = type(v)

					if tv == 'string' then
						local pid = cache[v]

						if pid then
							output[#output + 1] = format('(%x)', pid)
						else
							cacheSize = cacheSize + 1
							cache[v] = cacheSize
							self.string(self, v, output, cache)
						end
					elseif IsColor(v) then
						self.Color(self, v, output, cache)
					else
						self[tv](self, v, output, cache)
					end
				else
					break
				end
			end

			predictedNumeric = predictedNumeric - 1
		else
			predictedNumeric = nil
		end

		if predictedNumeric == nil then
			output[#output + 1] = '[' -- no array component
		else
			output[#output + 1] = '~' -- array component came first so shit needs to happen
		end

		for k, v in next, tbl, predictedNumeric do
			local tk, tv = type(k), type(v)
			if not self[tk] or not self[tv] then continue end

			-- WRITE KEY
			if tk == 'string' then
				local pid = cache[k]

				if pid then
					output[#output + 1] = format('(%x)', pid)
				else
					cacheSize = cacheSize + 1
					cache[k] = cacheSize
					self.string(self, k, output, cache)
				end
			elseif IsColor(v) then
				self.Color(self, v, output, cache)
			else
				self[tk](self, k, output, cache)
			end

			-- WRITE VALUE
			if tv == 'string' then
				local pid = cache[v]

				if pid then
					output[#output + 1] = format('(%x)', pid)
				else
					cacheSize = cacheSize + 1
					cache[v] = cacheSize
					self.string(self, v, output, cache)
				end
			elseif IsColor(v) then
				self.Color(self, v, output, cache)
			else
				self[tv](self, v, output, cache)
			end
		end

		output[#output + 1] = '}'
	end

	--	ENCODE STRING
	local gsub = string.gsub

	encode['string'] = function(self, str, output)
		--if tryCache(str, output then return end
		local estr, count = gsub(str, ';', "\\;")

		if count == 0 then
			output[#output + 1] = '\'' .. str .. ';'
		else
			output[#output + 1] = '"' .. estr .. '";'
		end
	end

	--	ENCODE NUMBER
	encode['number'] = function(self, num, output)
		if num % 1 == 0 then
			if num < 0 then
				output[#output + 1] = format('x%x;', -num)
			else
				output[#output + 1] = format('X%x;', num)
			end
		else
			output[#output + 1] = tonumber(num) .. ';'
		end
	end

	--	ENCODE BOOLEAN
	encode['boolean'] = function(self, val, output)
		output[#output + 1] = val and 't' or 'f'
	end

	--	ENCODE VECTOR
	encode['Vector'] = function(self, val, output)
		output[#output + 1] = ('v' .. val.x .. ',' .. val.y) .. (',' .. val.z .. ';')
	end

	--	ENCODE ANGLE
	encode['Angle'] = function(self, val, output)
		output[#output + 1] = ('a' .. val.p .. ',' .. val.y) .. (',' .. val.r .. ';')
	end

	encode['Entity'] = function(self, val, output)
		output[#output + 1] = 'E' .. (IsValid(val) and (val:EntIndex() .. ';') or '#')
	end

	encode['Player'] = encode['Entity']
	encode['Vehicle'] = encode['Entity']
	encode['Weapon'] = encode['Entity']
	encode['NPC'] = encode['Entity']
	encode['NextBot'] = encode['Entity']
	encode['PhysObj'] = encode['Entity']

	encode['Color'] = function(self, val, output)
		output[#output + 1] = ('C' .. val.r .. ',' .. val.g .. ',' .. val.b) .. (',' .. val.a .. ';')
	end

	encode['console'] = function(self, val, output)
		output[#output + 1] = 's'
	end

	encode['nil'] = function(self, val, output)
		output[#output + 1] = '?'
	end

	encode.__index = function(key)
		ErrorNoHalt('Type: ' .. key .. ' can not be encoded. Encoded as as pass-over value.')

		return encode['nil']
	end

	do
		local concat = table.concat

		function pon.encode(tbl)
			local output = {nil, nil, nil, nil, nil, nil, nil, nil}
			cacheSize = 0
			encode['table'](encode, tbl, output, {})

			return concat(output)
		end
	end
end

do
	local tonumber = tonumber
	local find, sub, gsub, Explode = string.find, string.sub, string.gsub, string.Explode
	local Vector, Angle, Entity = Vector, Angle, Entity
	local decode = {}

	decode['{'] = function(self, index, str, cache)
		local cur = {}
		cache[#cache + 1] = cur
		local k, v, tk, tv = 1, nil, nil, nil

		while (true) do
			tv = sub(str, index, index)

			if not tv or tv == '~' then
				index = index + 1
				break
			end

			if tv == '}' then return index + 1, cur end
			-- READ THE VALUE
			index = index + 1
			index, v = self[tv](self, index, str, cache)
			cur[k] = v
			k = k + 1
		end

		while (true) do
			tk = sub(str, index, index)

			if not tk or tk == '}' then
				index = index + 1
				break
			end

			-- READ THE KEY
			index = index + 1
			index, k = self[tk](self, index, str, cache)
			-- READ THE VALUE
			tv = sub(str, index, index)
			index = index + 1
			index, v = self[tv](self, index, str, cache)
			cur[k] = v
		end

		return index, cur
	end

	decode['['] = function(self, index, str, cache)
		local cur = {}
		cache[#cache + 1] = cur
		local k, v, tk, tv = 1, nil, nil, nil

		while (true) do
			tk = sub(str, index, index)

			if not tk or tk == '}' then
				index = index + 1
				break
			end

			-- READ THE KEY
			index = index + 1
			index, k = self[tk](self, index, str, cache)
			if not k then continue end
			-- READ THE VALUE
			tv = sub(str, index, index)
			index = index + 1

			if not self[tv] then
				print('did not find type: ' .. tv)
			end

			index, v = self[tv](self, index, str, cache)
			cur[k] = v
		end

		return index, cur
	end

	-- STRING
	decode['"'] = function(self, index, str, cache)
		local finish = find(str, '";', index, true)
		local res = gsub(sub(str, index, finish - 1), '\\;', ';')
		index = finish + 2
		cache[#cache + 1] = res

		return index, res
	end

	-- STRING NO ESCAPING NEEDED
	decode['\''] = function(self, index, str, cache)
		local finish = find(str, ';', index, true)
		local res = sub(str, index, finish - 1)
		index = finish + 1
		cache[#cache + 1] = res

		return index, res
	end

	-- NUMBER
	decode['n'] = function(self, index, str)
		index = index - 1
		local finish = find(str, ';', index, true)
		local num = tonumber(sub(str, index, finish - 1))
		index = finish + 1

		return index, num
	end

	decode['0'] = decode['n']
	decode['1'] = decode['n']
	decode['2'] = decode['n']
	decode['3'] = decode['n']
	decode['4'] = decode['n']
	decode['5'] = decode['n']
	decode['6'] = decode['n']
	decode['7'] = decode['n']
	decode['8'] = decode['n']
	decode['9'] = decode['n']
	decode['-'] = decode['n']

	-- positive hex
	decode['X'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local num = tonumber(sub(str, index, finish - 1), 16)
		index = finish + 1

		return index, num
	end

	-- negative hex
	decode['x'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local num = -tonumber(sub(str, index, finish - 1), 16)
		index = finish + 1

		return index, num
	end

	-- POINTER
	decode['('] = function(self, index, str, cache)
		local finish = find(str, ')', index, true)
		local num = tonumber(sub(str, index, finish - 1), 16)
		index = finish + 1

		return index, cache[num]
	end

	-- BOOLEAN. ONE DATA TYPE FOR YES, ANOTHER FOR NO.
	decode['t'] = function(self, index) return index, true end
	decode['f'] = function(self, index) return index, false end

	-- VECTOR
	decode['v'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local vecStr = sub(str, index, finish - 1)
		index = finish + 1 -- update the index.
		local segs = Explode(',', vecStr, false)

		return index, Vector(tonumber(segs[1]), tonumber(segs[2]), tonumber(segs[3]))
	end

	-- ANGLE
	decode['a'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local angStr = sub(str, index, finish - 1)
		index = finish + 1 -- update the index.
		local segs = Explode(',', angStr, false)

		return index, Angle(tonumber(segs[1]), tonumber(segs[2]), tonumber(segs[3]))
	end

	-- ENTITY
	decode['E'] = function(self, index, str)
		if str[index] == '#' then
			index = index + 1

			return index, NULL
		else
			local finish = find(str, ';', index, true)
			local num = tonumber(sub(str, index, finish - 1))
			index = finish + 1

			return index, Entity(num)
		end
	end

	-- COLOR
	decode['C'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local colStr = sub(str, index, finish - 1)
		index = finish + 1 -- update the index.
		local segs = Explode(',', colStr, false)

		return index, Color(segs[1], segs[2], segs[3], segs[4])
	end

	-- PLAYER
	decode['P'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local num = tonumber(sub(str, index, finish - 1))
		index = finish + 1

		return index, Entity(num) or NULL
	end

	-- NIL
	decode['?'] = function(self, index) return index + 1, nil end
	-- SAM CONSOLE
	decode['s'] = function(self, index) return index, sam.console end

	function pon.decode(data)
		local _, res = decode[sub(data, 1, 1)](decode, 2, data, {})

		return res
	end
end
--addons/admin_sam/lua/sam/sh_colors.lua:
if SAM_LOADED then return end

local colors = {
	Red   = Color(244, 67, 54),
	Blue  = Color(13, 130, 223),
	Green = Color(0, 230, 64),
	White = Color(236, 240, 241),
	Black = Color(10, 10, 10)
}

function sam.get_color(name)
	return colors[name]
end

function sam.add_color(name, color)
	if isstring(name) and IsColor(color) then
		colors[name] = color
	end
end
--addons/admin_sam/lua/sam/command/arguments/length.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

local get_length = function(arg, input)
	if (input == "" or input == nil) and arg.optional then
		if arg.default ~= nil then
			return arg.default
		end

		return ""
	end

	return sam.parse_length(input)
end

command.new_argument("length")
	:OnExecute(function(arg, input, ply, _, result, i)
		local length = get_length(arg, input)
		if length == "" then
			result[i] = nil
		elseif not length then
			ply:sam_send_message("invalid", {
				S = "length", S_2 = input
			})
			return false
		else
			if arg.min and length ~= 0 then
				length = math.max(length, arg.min)
			end

			if arg.max then
				if length == 0 then
					length = arg.max
				else
					length = math.min(length, arg.max)
				end
			end

			result[i] = length
		end
	end)

	:Menu(function(set_result, body, buttons, argument)
		local length_input = buttons:Add("SAM.TextEntry")
		length_input:SetTall(25)

		length_input:SetCheck(function(new_limit)
			new_limit = get_length(argument, new_limit) or nil
			set_result(new_limit)
			return new_limit or false
		end)

		local hint = argument.hint or "length"
		if argument.default then
			hint = hint .. " = " .. tostring(argument.default)
		end

		length_input:SetPlaceholder(hint)
		return length_input
	end)
:End()
--addons/admin_sam/lua/sam/sh_restrictions.lua:
--[[ if SAM_LOADED then return end

local loaded = false
local load_restrictions = function()
	local sam = sam
	local config = sam.config
	local hook = hook
	local SERVER = SERVER

	if CLIENT then
		local add_setting = function(body, title, key)
			local setting = body:Add("SAM.LabelPanel")
			setting:Dock(TOP)
			setting:SetLabel(title)

			local enable = setting:Add("SAM.ToggleButton")
			enable:SetConfig(key, true)

			return setting
		end

		config.add_menu_setting("Restrictions", function(body)
			local setting = body:Add("SAM.LabelPanel")
			setting:Dock(TOP)
			setting:DockMargin(8, 6, 8, 0)
			setting:SetLabel("Restrictions (Check these settings in ranks' permissions)")

			local setting_body = body:Add("Panel")
			setting_body:Dock(TOP)
			setting_body:DockMargin(8, 6, 8, 0)
			setting_body:DockPadding(8, 0, 8, 0)

			add_setting(setting_body, "Tool (Eg. using button tool)", "Restrictions.Tool")
			add_setting(setting_body, "Spawning (Eg. spawning props)", "Restrictions.Spawning")
			add_setting(setting_body, "Limits (Eg. how many props can you spawn)", "Restrictions.Limits")

			function setting_body:PerformLayout()
				setting_body:SizeToChildren(false, true)
			end
		end)
	end

	local tools = weapons.GetStored("gmod_tool")
	if sam.istable(tools) then
		if config.get("Restrictions.Tool", true) then
			for k, v in pairs(tools.Tool) do
				sam.permissions.add(v.Mode, "Tools - " .. (v.Category or "Other"), "user")
			end

			hook.Add("CanTool", "SAM.Module.Restrictions", function(ply, _, tool)
				if not ply:HasPermission(tool) then
					if CLIENT and sam.player.check_cooldown(ply, "ToolNoPermission", 0.1) then
						ply:sam_send_message("You don't have permission to use this tool.")
					end
					return false
				end
			end)
		else
			for k, v in pairs(tools.Tool) do
				sam.permissions.remove(v.Mode)
			end

			hook.Remove("CanTool", "SAM.Module.Restrictions")
		end
	end

	sam.permissions.add("admin_weapons", "Spawning", "superadmin")

	local function no_permission(ply, name)
		ply:sam_play_sound("buttons/button10.wav")
		ply:sam_send_message("You don't have permission to spawn {S Blue}.", {
			S = name
		})
	end

	local spawning = {
		PlayerSpawnProp = {
			name = "props",
			permission = "user",
			call_gm = true,
		},
		PlayerGiveSWEP = {
			name = "give_weapons",
			cb = function(_, ply, _, wep)
				if wep.sam_AdminOnly and not ply:HasPermission("admin_weapons") then
					no_permission(ply, "admin weapons")
					return false
				end
				return true
			end,
			hook = sam.hook_first,
		},
		PlayerSpawnSWEP = {
			name = "spawn_weapons",
			cb = function(_, ply, _, wep)
				if wep.sam_AdminOnly and not ply:HasPermission("admin_weapons") then
					no_permission(ply, "admin weapons")
					return false
				end
				return true
			end,
			hook = sam.hook_first,
		},
		-- PlayerSpawnSENT = {
		-- 	name = "entities",
		-- 	check_limit = "sents"
		-- },
		PlayerSpawnNPC = {
			name = "npcs",
			check_limit = "npcs",
		},
		PlayerSpawnVehicle = {
			name = "vehicles",
			check_limit = "vehicles",
		},
		PlayerSpawnRagdoll = {
			name = "ragdolls",
			permission = "user",
		}
	}

	local override_lists = {
		"Weapon",
		-- "SpawnableEntities"
	}

	local function LimitReachedProcess(ply, str)
		if not IsValid(ply) then return true end
		return ply:CheckLimit(str)
	end

	local GAMEMODE = GAMEMODE
	if config.get("Restrictions.Spawning", true) then
		for k, v in pairs(spawning) do
			local name = v
			local permission = "superadmin"
			local check
			local check_limit
			local hook = sam.hook_last
			if istable(v) then
				name = v.name
				permission = v.permission or permission
				if v.call_gm then
					check = GAMEMODE[k]
				elseif v.cb then
					check = v.cb
				end
				hook = v.hook or hook
				check_limit = v.check_limit
			end

			sam.permissions.add(name, "Spawning", permission)

			if SERVER then
				hook(k, "SAM.Spawning." .. k .. name, function(ply, ...)
					if not ply:HasPermission(name) then
						no_permission(ply, name)
						return false
					end

					if check_limit then
						return LimitReachedProcess(ply, check_limit)
					end

					if check then
						return check(GAMEMODE, ply, ...)
					end

					return true
				end)
			end
		end

		for i = 1, #override_lists do
			for k, v in pairs(list.GetForEdit(override_lists[i])) do
				v.sam_AdminOnly = v.sam_AdminOnly or v.AdminOnly
				v.AdminOnly = false
			end
		end
	else
		sam.permissions.add("admin_weapons")

		for k, v in pairs(spawning) do
			sam.permissions.remove(istable(v) and v.name or v)

			if SERVER then
				hook.Remove(k, "SAM.Spawning." .. k)
			end
		end

		for i = 1, #override_lists do
			for k, v in pairs(list.GetForEdit(override_lists[i])) do
				if v.sam_AdminOnly then
					v.AdminOnly = v.sam_AdminOnly
				end
			end
		end
	end

	local PLAYER = FindMetaTable("Player")
	if config.get("Restrictions.Limits", true) then
		local get_limit = sam.ranks.get_limit
		function PLAYER:GetLimit(limit_type)
			return get_limit(self:sam_getrank(), limit_type)
		end

		sam.hook_first("PlayerCheckLimit", "SAM.PlayerCheckLimit", function(ply, limit_type, count)
			local ply_limit = ply:GetLimit(limit_type)
			if ply_limit < 0 then return true end

			if count > ply_limit - 1 then
				return false
			end

			return true
		end)

		sam.limit_types = {}
		for _, limit_type in SortedPairs(cleanup.GetTable(), true) do
			local cvar = GetConVar("sbox_max" .. limit_type)
			if cvar then
				table.insert(sam.limit_types, limit_type)
			end
		end
	else
		sam.limit_types = nil
		PLAYER.GetLimit = nil
		hook.Remove("PlayerCheckLimit", "SAM.PlayerCheckLimit")
	end

	if not loaded then
		loaded = true
		hook.Call("SAM.LoadedRestrictions")
	end
end

timer.Simple(5, function()
	if GAMEMODE.IsSandboxDerived then
		sam.config.hook({"Restrictions.Tool", "Restrictions.Spawning", "Restrictions.Limits"}, load_restrictions)
	end
end) ]]
--addons/admin_sam_sui/lua/sui/vgui/sui_label_panel.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local LABEL_FONT = SUI.CreateFont("LabelPanel", "Roboto", 18)

local PANEL = {}

local add = function(s, c)
	if IsValid(s.pnl) then
		s.pnl:Remove()
	end

	local pnl = vgui.Create(c, s)
	s.pnl = pnl

	return pnl
end

function PANEL:Init()
	self.title = ""

	local label = self:Add(NAME .. ".Label")
	label:Dock(LEFT)
	self.label = label

	self:SetFont(LABEL_FONT)

	self:Dock(TOP)
	self:InvalidateLayout(true)
	self.Add = add
end

function PANEL:SetPanel(pnl)
	if IsValid(self.pnl) then
		self.pnl:Remove()
	end

	pnl:SetParent(self)
	self.pnl = pnl
end

function PANEL:SetLabel(lbl)
	self.title = lbl
	self:InvalidateLayout(true)
end

function PANEL:SetFont(font)
	self.font = font
	self.label:SetFont(font)
end

function PANEL:PerformLayout(w, h)
	local label = self.label
	local pnl = self.pnl

	local pnl_w, pnl_h = 0, 0
	if pnl then
		pnl_w, pnl_h = pnl:GetSize()
	end

	label:SetWide(w - pnl_w - 4)
	label:SetText(sui.wrap_text(self.title, self.font, w - pnl_w - 4))

	local _, _h = label:GetTextSize()
	self:SetTall(math.max(_h, pnl_h))

	if pnl then
		pnl:SetPos(w - pnl_w, h / 2 - pnl_h / 2)
	end
end

sui.register("LabelPanel", PANEL, "PANEL")
--addons/admin_sam_sui/lua/sui/vgui/sui_panel.lua:
local PANEL = {}

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()
end

sui.register("Panel", PANEL, "Panel")
--addons/weapon_joe_fort/lua/autorun/sh_joefort.lua:
JoeFort = JoeFort or {}
/*

JoeFort:AddEnt("Barrier","Barriers",{
    classname = string,
    model = string,
    health = int,
    buildtime = int,
    neededresources = int,
    CanSpawn = function(ply, wep)

    end,
    OnSpawn = function(ply,ent)

    end,
    OnDamaged = function(ent, spawner, attacker)

    end,
    OnDestroyed = function(ent, spawner, attacker)

    end,
    OnRepaired = function(spawner, repairer, ent)

    end,
    OnRemoved = function(spawner, remover, ent)

    end,
    OnBuildEntitySpawned = function(spawner, ent)
    
    end,
})

*/

JoeFort.structs = {}
function JoeFort:AddEnt(name,category,data)
    if not name or not category or not data then return end
    if not data.classname or not data.model then return end
    JoeFort.structs[category] = JoeFort.structs[category] or {}

    data.name = name
    data.health = data.health or 100
    data.buildtime = data.buildtime or 10
    data.neededresources = data.neededresources or 25

    table.insert(JoeFort.structs[category], data)
end

function JoeFort:GetRessourcePool()
    return JoeFort.Ressources or 0
end

if file.Exists("sh_fort_config.lua", "LUA") then
    if SERVER then
        include("sh_fort_config.lua")
        AddCSLuaFile("sh_fort_config.lua")
    elseif CLIENT then
        include("sh_fort_config.lua")
    end
end

JoeFort.configoverride = true 
JoeFort.Ressources = 2500

JoeFort:AddEnt("Zivile Barrikade","Barrikaden",{
    classname = "", 
    model = "models/reizer_props/srsp/sci_fi/reinforced_barrier_02/reinforced_barrier_02.mdl", 
    health = 2500, 
    buildtime = 30,
    neededresources = 100, 
})

JoeFort:AddEnt("Schwere Barrikade","Barrikaden",{
    classname = "", 
    model = "models/lordtrilobite/starwars/props/imp_landingpad_wall.mdl", 
    health = 1200, 
    buildtime = 20, 
    neededresources = 100,
})

JoeFort:AddEnt("Beton Barrikade Klein","Barrikaden",{
    classname = "", 
    model = "models/fortifications/concrete_barrier_01.mdl", 
    health = 750, 
    buildtime = 18, 
    neededresources = 40,
})

JoeFort:AddEnt("Beton Barrikade Gross","Barrikaden",{
    classname = "", 
    model = "models/fortifications/concrete_barrier_02.mdl", 
    health = 950, 
    buildtime = 25, 
    neededresources = 55,
})

JoeFort:AddEnt("Mitlere Barrikade","Barrikaden",{
    classname = "", 
    model = "models/fortifications/metal_barrier_02.mdl", 
    health = 1750, 
    buildtime = 25, 
    neededresources = 130,
})

JoeFort:AddEnt("Große Barrikade","Barrikaden",{
    classname = "", 
    model = "models/fortifications/metal_barrier_04.mdl", 
    health = 2200, 
    buildtime = 45, 
    neededresources = 150,
})

JoeFort:AddEnt("Barrikade Republik","Barrikaden",{
    classname = "", 
    model = "models/fisher/barrier/barrierrep.mdl", 
    health = 1000, 
    buildtime = 30, 
    neededresources = 60,
})

JoeFort:AddEnt("Leichte Strahlenbarriere","Barrikaden",{
    classname = "", 
    model = "models/props_combine/combine_barricade_short01a.mdl", 
    health = 600, 
    buildtime = 12, 
    neededresources = 35,
})

JoeFort:AddEnt("Großer Zaun","Zäune",{
    classname = "", 
    model = "models/props_c17/fence03a.mdl", 
    health = 50, 
    buildtime = 5, 
    neededresources = 20,
})

JoeFort:AddEnt("Mittlerer Zaun","Zäune",{
    classname = "", 
    model = "models/props_c17/fence02a.mdl", 
    health = 50, 
    buildtime = 5, 
    neededresources = 15,
})

JoeFort:AddEnt("Kleiner Zaun","Zäune",{
    classname = "models/props_c17/fence02b.mdl", 
    model = "", 
    health = 50, 
    buildtime = 5, 
    neededresources = 10,
})

JoeFort:AddEnt("Zauntor","Zäune",{
    classname = "", 
    model = "models/props_wasteland/interior_fence002e.mdl", 
    health = 50, 
    buildtime = 5, 
    neededresources = 10,
})

JoeFort:AddEnt("Metall Barriere","Zäune",{
    classname = "", 
    model = "models/fortifications/metal_barrier.mdl", 
    health = 3500, 
    buildtime = 35, 
    neededresources = 50,
})

JoeFort:AddEnt("Pylone","Absperrungen",{
    classname = "", 
    model = "models/props_junk/TrafficCone001a.mdl", 
    health = 50, 
    buildtime = 2, 
    neededresources = 4,
    OnSpawn = function(ply,ent)
        ent:GetPhysicsObject():EnableMotion(true)
    end,
})

JoeFort:AddEnt("Kleine Absperrung","Absperrungen",{
    classname = "", 
    model = "models/props_wasteland/barricade001a.mdl", 
    health = 30, 
    buildtime = 3, 
    neededresources = 8,
})

JoeFort:AddEnt("Große Absperrung","Absperrungen",{
    classname = "", 
    model = "models/props_wasteland/barricade002a.mdl", 
    health = 30, 
    buildtime = 5, 
    neededresources = 10,
})

JoeFort:AddEnt("Zelt Groß","Ausrüstung Groß",{
    classname = "", 
    model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/republic/rep_tent_large.mdl", 
    health = 800, 
    buildtime = 30, 
    neededresources = 100,
})

JoeFort:AddEnt("Zelt Mittel","Ausrüstung Groß",{
    classname = "", 
    model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/republic/rep_tent_leanto.mdl", 
    health = 600, 
    buildtime = 20, 
    neededresources = 50,
})

JoeFort:AddEnt("Zelt Klein","Ausrüstung Groß",{
    classname = "", 
    model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/republic/rep_tent_medium.mdl", 
    health = 500, 
    buildtime = 10, 
    neededresources = 25,
})

JoeFort:AddEnt("Comandoposten","Ausrüstung Groß",{
    classname = "", 
    model = "models/fisher/command/command.mdl", 
    health = 2500, 
    buildtime = 100, 
    neededresources = 250,
})

JoeFort:AddEnt("Funkantenne","Ausrüstung Groß",{
    classname = "", 
    model = "models/reizer_props/alysseum_project/antennas/antenna_01/antenna_01.mdl", 
    health = 100, 
    buildtime = 100, 
    neededresources = 150,
})

JoeFort:AddEnt("Komandotisch","Ausrüstung Groß",{
    classname = "", 
    model = "models/reizer_props/srsp/sci_fi/command_table_02/command_table_02.mdl", 
    health = 1500, 
    buildtime = 100, 
    neededresources = 150,
})

JoeFort:AddEnt("Munitionsbox","Kampf",{
    classname = "aoc_ammobox", 
    model = "models/reizer_props/srsp/sci_fi/crate_01/crate_01.mdl", 
    health = 1200, 
    buildtime = 20, 
    neededresources = 100,
    OnSpawn = function(ply,ent)
        ent:GetPhysicsObject():EnableMotion(true)
    end,
})

JoeFort:AddEnt("Sanitätsbox","Kampf",{
    classname = "aoc_medicbox", 
    model = "models/reizer_props/srsp/sci_fi/crate_03/crate_03.mdl", 
    health = 1200, 
    buildtime = 20, 
    neededresources = 100,
    OnSpawn = function(ply,ent)
        ent:GetPhysicsObject():EnableMotion(true)
    end,
})

JoeFort:AddEnt("E-Web","Kampf",{
    classname = "turret_eweb", 
    model = "models/macieg/swrp/nohy.mdl", 
    health = 1800, 
    buildtime = 0, 
    neededresources = 0,
})

JoeFort:AddEnt("E-Web-Munnition","Kampf",{
    classname = "turret_eweb_ammo", 
    model = "models/macieg/swrp/battery.mdl", 
    health = 1200, 
    buildtime = 20, 
    neededresources = 35,
    OnSpawn = function(ply,ent)
        ent:GetPhysicsObject():EnableMotion(true)
    end,
})

JoeFort:AddEnt("AA-Turret","Kampf",{
    classname = "lvs_turret_aa", 
    model = "models/swbf3/turrets/rep_anti-airturret.mdl", 
    health = 0, 
    buildtime = 100, 
    neededresources = 400,
    OnSpawn = function(ply,ent)
		local vehicle = ents.Create( "lvs_turret_aa" )
		vehicle:SetPos(ent:GetPos())
		vehicle:SetAngles( ent:GetAngles() )
		vehicle:Spawn()
		vehicle:Activate()

        ent:Remove()
    end,
})

JoeFort:AddEnt("AV-Turret","Kampf",{
    classname = "lvs_turret_av", 
    model = "models/swbf3/turrets/rep_anti-vehicleturret.mdl", 
    health = 0, 
    buildtime = 100, 
    neededresources = 400,
    OnSpawn = function(ply,ent)
		local vehicle = ents.Create( "lvs_turret_av" )
		vehicle:SetPos(ent:GetPos())
		vehicle:SetAngles( ent:GetAngles() )
		vehicle:Spawn()
		vehicle:Activate()

        ent:Remove()
    end,
})

JoeFort:AddEnt("Mine","Kampf",{
    classname = "combine_mine", 
    model = "models/props_combine/combine_mine01.mdl", 
    health = 80, 
    buildtime = 10, 
    neededresources = 0,
})

JoeFort:AddEnt("Absaugung","Ausrüstung Klein",{
    classname = "", 
    model = "models/reizer_props/alysseum_project/misc_stuff/air_vent_01/air_vent_01.mdl", 
    health = 500, 
    buildtime = 15, 
    neededresources = 175,
})

JoeFort:AddEnt("Generator","Ausrüstung Klein",{
    classname = "", 
    model = "models/lt_c/sci_fi/generator_portable.mdl", 
    health = 500, 
    buildtime = 15, 
    neededresources = 250,
    OnSpawn = function(ply,ent)
        ent:GetPhysicsObject():EnableMotion(true)
    end,
})

JoeFort:AddEnt("Stuhl","Ausrüstung Klein",{
    classname = "", 
    model = "models/lordtrilobite/starwars/props/imp_chair01.mdl", 
    health = 500, 
    buildtime = 5, 
    neededresources = 25,
})

JoeFort:AddEnt("Holoprojektor","Ausrüstung Klein",{
    classname = "", 
    model = "models/lordtrilobite/starwars/props/imp_holoprojector.mdl", 
    health = 500, 
    buildtime = 15, 
    neededresources = 100,
})

JoeFort:AddEnt("Leiter","Ausrüstung Klein",{
    classname = "", 
    model = "models/reizer_props/alysseum_project/watch_towers/watch_tower_ladder/watch_tower_ladder.mdl", 
    health = 5000, 
    buildtime = 25, 
    neededresources = 100,
})

JoeFort:AddEnt("Holz","Sonstiges",{
    classname = "", 
    model = "models/props_phx/construct/wood/wood_boardx2.mdl", 
    health = 150, 
    buildtime = 2, 
    neededresources = 10,
    OnSpawn = function(ply,ent)
        ent:GetPhysicsObject():EnableMotion(true)
    end,
})

JoeFort:AddEnt("Stahlplatte","Sonstiges",{
    classname = "", 
    model = "models/props_phx/construct/metal_plate2x2.mdl", 
    health = 1000, 
    buildtime = 15, 
    neededresources = 50,
    OnSpawn = function(ply,ent)
        ent:GetPhysicsObject():EnableMotion(true)
    end,
})

JoeFort:AddEnt("Stahlträger","Sonstiges",{
    classname = "", 
    model = "models/mechanics/solid_steel/i_beam_16.mdl", 
    health = 800, 
    buildtime = 10, 
    neededresources = 10,
    OnSpawn = function(ply,ent)
        ent:GetPhysicsObject():EnableMotion(true)
    end,
})

JoeFort:AddEnt("Große Kiste","Sonstiges",{
    classname = "", 
    model = "models/fortifications/imp_crate_modern.mdl", 
    health = 600, 
    buildtime = 25, 
    neededresources = 100,
    OnSpawn = function(ply,ent)
        ent:GetPhysicsObject():EnableMotion(true)
    end,
})

JoeFort:AddEnt("Kleine Kiste","Sonstiges",{
    classname = "", 
    model = "models/kingpommes/starwars/misc/imp_crate_single_closed.mdl", 
    health = 500, 
    buildtime = 10, 
    neededresources = 20,
    OnSpawn = function(ply,ent)
        ent:GetPhysicsObject():EnableMotion(true)
    end,
})

JoeFort:AddEnt("Lange Kiste","Sonstiges",{
    classname = "", 
    model = "models/lordtrilobite/starwars/props/kyber_crate_phys.mdl", 
    health = 500, 
    buildtime = 10, 
    neededresources = 35,
    OnSpawn = function(ply,ent)
        ent:GetPhysicsObject():EnableMotion(true)
    end,
})

JoeFort:AddEnt("Republic Logo","Sonstiges",{
    classname = "", 
    model = "models/ethereal-republic-symbol/ethereal-republic-symbol.mdl", 
    health = 600, 
    buildtime = 25, 
    neededresources = 100,
})

--addons/aocrp_pixelui/lua/pixelui/elements/cl_scrollpanel.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

AccessorFunc(PANEL, "Padding",   "Padding")
AccessorFunc(PANEL, "Canvas", "Canvas")
AccessorFunc(PANEL, "ScrollbarLeft", "ScrollbarLeftSide")
AccessorFunc(PANEL, "BarDockShouldOffset", "BarDockShouldOffset", FORCE_BOOL)

function PANEL:Init()
    self.Canvas = vgui.Create("Panel", self)
    self.Canvas.OnMousePressed = function(s, code) s:GetParent():OnMousePressed(code) end
    self.Canvas:SetMouseInputEnabled(true)
    self.Canvas.PerformLayout = function(pnl)
        self:PerformLayout()
        self:InvalidateParent()
    end

    self.VBar = vgui.Create("PIXEL.Scrollbar", self)
    self.VBar:Dock(RIGHT)

    self:SetPadding(0)
    self:SetMouseInputEnabled(true)

    self:SetPaintBackgroundEnabled(false)
    self:SetPaintBorderEnabled(false)

    self.ScrollDelta = 0
    self.ScrollReturnWait = 0

    self:SetBarDockShouldOffset(true)
    self.VBar:SetWide(PIXEL.Scale(8))

    self.Canvas.PerformLayout = function(s, w, h)
        self:LayoutContent(w, h)
    end
end

function PANEL:AddItem(pnl)
    pnl:SetParent(self:GetCanvas())
end

function PANEL:OnChildAdded(child)
    self:AddItem(child)
end

function PANEL:SizeToContents()
    self:SetSize(self.Canvas:GetSize())
end

function PANEL:GetVBar()
    return self.VBar
end

function PANEL:GetCanvas()
    return self.Canvas
end

function PANEL:InnerWidth()
    return self:GetCanvas():GetWide()
end

function PANEL:Rebuild()
    self:GetCanvas():SizeToChildren(false, true)

    if self.m_bNoSizing and self:GetCanvas():GetTall() < self:GetTall() then
        self:GetCanvas():SetPos(0, (self:GetTall() - self:GetCanvas():GetTall()) * 0.5)
    end
end

function PANEL:Think()
    if not self.lastThink then self.lastThink = CurTime() end
    local elapsed = CurTime() - self.lastThink
    self.lastThink = CurTime()

    if self.ScrollDelta > 0 then
        self.VBar:OnMouseWheeled(self.ScrollDelta / 1)

        if self.VBar.Scroll >= 0 then
            self.ScrollDelta = self.ScrollDelta - 10 * elapsed
        end
        if self.ScrollDelta < 0 then self.ScrollDelta = 0 end
    elseif self.ScrollDelta < 0 then
        self.VBar:OnMouseWheeled(self.ScrollDelta / 1)

        if self.VBar.Scroll <= self.VBar.CanvasSize then
            self.ScrollDelta = self.ScrollDelta + 10 * elapsed
        end
        if self.ScrollDelta > 0 then self.ScrollDelta = 0 end
    end

    if self.ScrollReturnWait >= 1 then
        if self.VBar.Scroll < 0 then
            if self.VBar.Scroll <= -75 and self.ScrollDelta > 0 then self.ScrollDelta = self.ScrollDelta / 2 end

            self.ScrollDelta = self.ScrollDelta + (self.VBar.Scroll / 1500 - 0.01) * 100 * elapsed

        elseif self.VBar.Scroll > self.VBar.CanvasSize then
            if self.VBar.Scroll >= self.VBar.CanvasSize + 75 and self.ScrollDelta < 0 then self.ScrollDelta = self.ScrollDelta / 2 end

            self.ScrollDelta = self.ScrollDelta + ((self.VBar.Scroll - self.VBar.CanvasSize) / 1500 + 0.01) * 100 * elapsed
        end
    else
        self.ScrollReturnWait = self.ScrollReturnWait + 10 * elapsed
    end
end

function PANEL:OnMouseWheeled(delta)
    if (delta > 0 and self.VBar.Scroll <= self.VBar.CanvasSize * 0.005) or
            (delta < 0 and self.VBar.Scroll >= self.VBar.CanvasSize * 0.995) then
        self.ScrollDelta = self.ScrollDelta + delta / 10
        return
    end

    self.ScrollDelta = delta / 2
    self.ScrollReturnWait = 0
end

function PANEL:OnVScroll(iOffset)
    self.Canvas:SetPos(0, iOffset)
end

function PANEL:ScrollToChild(panel)
    self:PerformLayout()

    local y = select(2, self.Canvas:GetChildPosition(panel)) + select(2, panel:GetSize()) * 0.5;
    y = y - self:GetTall() * 0.5;

    self.VBar:AnimateTo(y, 0.5, 0, 0.5);
end

function PANEL:LayoutContent(w, h) end

function PANEL:PerformLayout(w, h)
    if self:GetScrollbarLeftSide() then
        self.VBar:Dock(LEFT)
    else
        self.VBar:Dock(RIGHT)
    end

    local wide = self:GetWide()
    local xPos = 0
    local yPos = 0

    self:Rebuild()

    self.VBar:SetUp(self:GetTall(), self.Canvas:GetTall())
    yPos = self.VBar:GetOffset()

    if self.VBar.Enabled or not self:GetBarDockShouldOffset() then
        wide = wide - self.VBar:GetWide()

        if self:GetScrollbarLeftSide() then
            xPos = self.VBar:GetWide()
        end
    end

    self.Canvas:SetPos(xPos, yPos)
    self.Canvas:SetWide(wide)

    self:Rebuild()
end

function PANEL:Clear()
    return self.Canvas:Clear()
end

function PANEL:Paint(w, h) end

vgui.Register("PIXEL.ScrollPanel", PANEL, "DPanel")

--addons/aocrp_pixelui/lua/pixelui/libraries/cl_ui3d2d.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local ui3d2d = ui3d2d or {}
PIXEL.UI.UI3D2D = ui3d2d

do --Input handling
    local getRenderTarget, cursorVisible = render.GetRenderTarget, vgui.CursorVisible
    local isMouseDown, isKeyDown = input.IsMouseDown, input.IsKeyDown

    local inputEnabled, isPressing, isPressed

    hook.Add("PreRender", "PIXEL.UI.UI3D2D.InputHandler", function() --Check the input state before rendering UIs
        if getRenderTarget() then inputEnabled = false return end
        if cursorVisible() then inputEnabled = false return end

        inputEnabled = true

        local wasPressing = isPressing
        isPressing = isMouseDown(MOUSE_LEFT) or isKeyDown(KEY_E)
        isPressed = not wasPressing and isPressing
    end)

    function ui3d2d.isPressing() --Returns true if an input is being held
        return inputEnabled and isPressing
    end

    function ui3d2d.isPressed() --Returns true if an input was pressed this frame
        return inputEnabled and isPressed
    end
end

do --Rendering context creation and mouse position getters
    local localPlayer

    hook.Add("PreRender", "PIXEL.UI.UI3D2D.GetLocalPlayer", function() --Keep getting the local player until it's available
        localPlayer = LocalPlayer()
        if IsValid(localPlayer) then hook.Remove("PreRender", "PIXEL.UI.UI3D2D.GetLocalPlayer") end
    end)

    local traceLine = util.TraceLine

    local baseQuery = {filter = {}}

    local function isObstructed(eyePos, hitPos, ignoredEntity) --Check if the cursor trace is obstructed by another ent
        local query = baseQuery
        query.start = eyePos
        query.endpos = hitPos
        query.filter[1] = localPlayer
        query.filter[2] = ignoredEntity

        return traceLine(query).Hit
    end

    local mouseX, mouseY
    local hoveredSomething = false

    do
        local start3d2d = cam.Start3D2D
        local isCursorVisible, isHoveringWorld = vgui.CursorVisible, vgui.IsHoveringWorld
        local screenToVector, mousePos = gui.ScreenToVector, gui.MousePos
        local intersectRayWithPlane = util.IntersectRayWithPlane

        local isRendering

        function ui3d2d.startDraw(pos, angles, scale, ignoredEntity) --Starts a new 3d2d ui rendering context
            local eyePos = localPlayer:EyePos()
            if eyePos:DistToSqr(pos) > 400000 then return end

            local eyePosToUi = pos - eyePos

            do --Only draw the UI if the player is in front of it
                local normal = angles:Up()
                local dot = eyePosToUi:Dot(normal)

                if dot >= 0 then return end
            end

            isRendering = true
            mouseX, mouseY = nil, nil

            start3d2d(pos, angles, scale)

            local cursorVisible, hoveringWorld = isCursorVisible(), isHoveringWorld()
            if not hoveringWorld and cursorVisible then return true end

            local eyeNormal
            do
                if cursorVisible and hoveringWorld then
                    eyeNormal = screenToVector(mousePos())
                else
                    eyeNormal = localPlayer:GetEyeTrace().Normal
                end
            end

            local hitPos = intersectRayWithPlane(eyePos, eyeNormal, pos, angles:Up())
            if not hitPos then return true end

            if isObstructed(eyePos, hitPos, ignoredEntity) then return true end

            local diff = pos - hitPos
            mouseX = diff:Dot(-angles:Forward()) / scale
            mouseY = diff:Dot(-angles:Right()) / scale

            hoveredSomething = nil
            return true
        end

        local end3d2d = cam.End3D2D

        function ui3d2d.endDraw() --Safely ends the 3d2d ui rendering context
            if not isRendering then print("[ui3d2d] Attempted to end a non-existant 3d2d ui rendering context.") return end
            isRendering = false
            end3d2d()
        end
    end

    function ui3d2d.getCursorPos() --Returns the current 3d2d cursor position
        return mouseX, mouseY
    end

    function ui3d2d.isHovering(x, y, w, h, preventCursorChange) --Returns whether the cursor is within a specified area
        local mx, my = mouseX, mouseY
        local hovering = mx and my and mx >= x and mx <= (x + w) and my >= y and my <= (y + h)
        if not preventCursorChange and hovering then hoveredSomething = true end
        return hovering
    end

    local cursorMat
    local cursorHoverMat
    PIXEL.GetImgur("ZcfUhAr", function(mat) cursorMat = mat end)
    PIXEL.GetImgur("xo6gm7z", function(mat) cursorHoverMat = mat end)

    function ui3d2d.drawCursor(x, y, w, h, size)
        size = size or 20

        local mx, my = ui3d2d.getCursorPos()
        if not (mx and my) then return end

        surface.SetDrawColor(255, 255, 255)
        surface.SetMaterial(hoveredSomething and cursorHoverMat or cursorMat)
        surface.DrawTexturedRect(hoveredSomething and (mx - size / 3.75) or mx, my, size, size)
    end
end

do --3d2d VGUI Drawing
    local insert = table.insert

    local function getParents(panel)
        local parents = {}
        local parent = panel:GetParent()

        while parent do
            insert(parents, parent)
            parent = parent:GetParent()
        end

        return parents
    end

    local ipairs = ipairs

    local function absolutePanelPos(panel)
        local x, y = panel:GetPos()
        local parents = getParents(panel)

        for _, parent in ipairs(parents) do
            local parentX, parentY = parent:GetPos()
            x = x + parentX
            y = y + parentY
        end

        return x, y
    end

    local function pointInsidePanel(panel, x, y)
        local absoluteX, absoluteY = absolutePanelPos(panel)
        local width, height = panel:GetSize()

        return panel:IsVisible() and x >= absoluteX and y >= absoluteY and x <= absoluteX + width and y <= absoluteY + height
    end

    local pairs = pairs
    local reverseTable = table.Reverse

    local function checkHover(panel, x, y, found, hoveredPanel)
        local validChild = false
        for _, child in pairs(reverseTable(panel:GetChildren())) do
            if not child:IsMouseInputEnabled() then continue end

            if checkHover(child, x, y, found or validChild) then validChild = true end
        end

        if not panel.isUi3d2dSetup then
            panel.IsHovered = function(s)
                return s.Hovered
            end

            panel:SetPaintedManually(true)
            panel.isUi3d2dSetup = true
        end

        if found then
            if panel.Hovered then
                panel.Hovered = false
                if panel.OnCursorExited then panel:OnCursorExited() end
            end
        else
            if not validChild and pointInsidePanel(panel, x, y) then
                panel.Hovered = true

                if panel.OnMousePressed then
                    local key = input.IsKeyDown(KEY_LSHIFT) and MOUSE_RIGHT or MOUSE_LEFT

                    if panel.OnMousePressed and ui3d2d.isPressed() then
                        panel:OnMousePressed(key)
                    end

                    if panel.OnMouseReleased and not ui3d2d.isPressing() then
                        panel:OnMouseReleased(key)
                    end
                elseif panel.DoClick and ui3d2d.isPressed() then
                    panel:DoClick()
                end

                if panel.OnCursorEntered then panel:OnCursorEntered() end

                return true
            else
                panel.Hovered = false
                if panel.OnCursorExited then panel:OnCursorExited() end
            end
        end
    end

    local oldMouseX, oldMouseY = gui.MouseX, gui.MouseY

    function ui3d2d.drawVgui(panel, pos, angles, scale, ignoredEntity)
        if not (IsValid(panel) and ui3d2d.startDraw(pos, angles, scale, ignoredEntity)) then return end

        do
            local cursorX, cursorY = ui3d2d.getCursorPos()
            cursorX, cursorY = cursorX or -1, cursorY or -1

            function gui.MouseX()
                return cursorX
            end

            function gui.MouseY()
                return cursorY
            end

            checkHover(panel, cursorX, cursorY)
        end

        panel:PaintManual()

        gui.MouseX, gui.MouseY = oldMouseX, oldMouseY

        ui3d2d.endDraw()
    end
end

hook.Run("PIXEL.UI.UI3D2D.FullyLoaded")

--addons/aocrp_pixelui/lua/pixelui/menus/cl_string_request_popup.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

AccessorFunc(PANEL, "Text", "Text", FORCE_STRING)
AccessorFunc(PANEL, "ButtonText", "ButtonText", FORCE_STRING)

PIXEL.RegisterFont("UI.Message", "Open Sans SemiBold", 18)

function PANEL:Init()
    self:SetDraggable(true)
    self:SetSizable(true)

    self:SetMinWidth(PIXEL.Scale(240))
    self:SetMinHeight(PIXEL.Scale(80))

    self.Message = vgui.Create("PIXEL.Label", self)
    self.Message:SetTextAlign(TEXT_ALIGN_CENTER)
    self.Message:SetFont("UI.Message")

    self.TextEntry = vgui.Create("PIXEL.TextEntry", self)

    self.BottomPanel = vgui.Create("Panel", self)
    self.ButtonHolder = vgui.Create("Panel", self.BottomPanel)

    self.Buttons = {}
end

function PANEL:AddOption(name, callback)
    local btn = vgui.Create("PIXEL.TextButton", self.ButtonHolder)
    btn:SetText(name)
    btn.DoClick = function()
        self:Close(true)
        callback(self.TextEntry:GetValue())
    end
    table.insert(self.Buttons, btn)
end

function PANEL:LayoutContent(w, h)
    self.Message:SetSize(self.Message:CalculateSize())
    self.Message:Dock(TOP)
    self.Message:DockMargin(0, 0, 0, PIXEL.Scale(8))

    self.TextEntry:SetTall(PIXEL.Scale(32))
    self.TextEntry:Dock(TOP)
    self.TextEntry:DockMargin(0, 0, 0, PIXEL.Scale(10))

    for k,v in ipairs(self.Buttons) do
        v:SizeToText()
        v:Dock(LEFT)
        v:DockMargin(PIXEL.Scale(4), 0, PIXEL.Scale(4), 0)
    end

    self.ButtonHolder:SizeToChildren(true)

    local firstBtn = self.Buttons[1]

    self.BottomPanel:Dock(TOP)
    self.BottomPanel:SetTall(firstBtn:GetTall())
    self.ButtonHolder:SetTall(firstBtn:GetTall())

    self.ButtonHolder:CenterHorizontal()

    if self.ButtonHolder:GetWide() < firstBtn:GetWide() then
        self.ButtonHolder:SetWide(firstBtn:GetWide())
    end

    if self:GetWide() < PIXEL.Scale(240) then
        self:SetWide(240)
        self:Center()
    end

    if self.HasSized and self.HasSized > 1 then return end
    self.HasSized = (self.HasSized or 0) + 1

    self:SizeToChildren(true, true)
    self:Center()
end

function PANEL:SetText(text) self.Message:SetText(text) end
function PANEL:GetText(text) return self.Message:GetText() end

function PANEL:SetPlaceholderText(text) self.TextEntry:SetPlaceholderText(text) end
function PANEL:GetPlaceholderText(text) return self.TextEntry:GetPlaceholderText() end

vgui.Register("PIXEL.StringRequest", PANEL, "PIXEL.Frame")

PIXEL.UI.Overrides.Derma_StringRequest = PIXEL.UI.Overrides.Derma_StringRequest or Derma_StringRequest

Derma_StringRequest = PIXEL.UI.CreateToggleableOverride(PIXEL.UI.Overrides.Derma_StringRequest, function(title, text, placeholderText, enterCallback, cancelCallback, buttonText, cancelText)
    cancelCallback = cancelCallback or function() end
    buttonText = buttonText or "OK"
    cancelText = cancelText or "Cancel"

    local msg = vgui.Create("PIXEL.StringRequest")
    msg:SetTitle(title)
    msg:SetText(text)

    msg:SetPlaceholderText(placeholderText)

    msg:AddOption(buttonText, enterCallback)
    msg:AddOption(cancelText, cancelCallback)

    msg.CloseButton.DoClick = function(s)
        cancelCallback(msg.TextEntry:GetValue())
        msg:Close()
    end

    msg:MakePopup()
    msg:DoModal()

    return msg
end, PIXEL.UI.ShouldOverrideDermaPopups)
--addons/tools/lua/textscreens_config.lua:
textscreenFonts = {}

local function addFont(font, t)
	if CLIENT then
		t.size = 100
		surface.CreateFont(font, t)
		t.size = 50
		surface.CreateFont(font .. "_MENU", t)
	end

	table.insert(textscreenFonts, font)
end

--[[
---------------------------------------------------------------------------
Custom fonts - requires server restart to take affect -- "Screens_" will be removed from the font name in spawnmenu
---------------------------------------------------------------------------
--]]

-- AOCRP Fonts
addFont("AOCRP Standard", {
	font = "Agency FB",
	weight = 10,
	antialias = false,
	outline = false
})
addFont("AOCRP Standard Dick", {
	font = "Agency FB",
	weight = 1000,
	antialias = false,
	outline = false
})

addFont("AOCRP Standard Outlined", {
	font = "Agency FB",
	weight = 10,
	antialias = false,
	outline = true
})
addFont("AOCRP Standard Dick Outlined", {
	font = "Agency FB",
	weight = 1000,
	antialias = false,
	outline = true
})


addFont("AOCRP Aurebesh", {
	font = "Aurebesh",
	weight = 10,
	antialias = false,
	outline = false
})

addFont("AOCRP Aurebesh Dick", {
	font = "Aurebesh",
	weight = 1000,
	antialias = false,
	outline = false
})

addFont("AOCRP Aurebesh Outlined", {
	font = "Aurebesh",
	weight = 10,
	antialias = false,
	outline = true
})

addFont("AOCRP Aurebesh Dick Outlined", {
	font = "Aurebesh",
	weight = 1000,
	antialias = false,
	outline = true
})


-- Default textscreens font
--[[ addFont("Coolvetica outlined", {
	font = "coolvetica",
	weight = 400,
	antialias = false,
	outline = true
}) ]]

--[[ addFont("Coolvetica", {
	font = "coolvetica",
	weight = 400,
	antialias = false,
	outline = false
})

-- Trebuchet
addFont("Screens_Trebuchet outlined", {
	font = "Trebuchet MS",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Screens_Trebuchet", {
	font = "Trebuchet MS",
	weight = 400,
	antialias = false,
	outline = false
})

-- Arial
addFont("Screens_Arial outlined", {
	font = "Arial",
	weight = 600,
	antialias = false,
	outline = true
})

addFont("Screens_Arial", {
	font = "Arial",
	weight = 600,
	antialias = false,
	outline = false
})

-- Roboto Bk
addFont("Screens_Roboto outlined", {
	font = "Roboto Bk",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Screens_Roboto", {
	font = "Roboto Bk",
	weight = 400,
	antialias = false,
	outline = false
})

-- Helvetica
addFont("Screens_Helvetica outlined", {
	font = "Helvetica",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Screens_Helvetica", {
	font = "Helvetica",
	weight = 400,
	antialias = false,
	outline = false
})

-- akbar
addFont("Screens_Akbar outlined", {
	font = "akbar",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Screens_Akbar", {
	font = "akbar",
	weight = 400,
	antialias = false,
	outline = false
})

-- csd
addFont("Screens_csd outlined", {
	font = "csd",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Screens_csd", {
	font = "csd",
	weight = 400,
	antialias = false,
	outline = false
})
 ]]
if CLIENT then

	local function addFonts(path)
		local files, folders = file.Find("resource/fonts/" .. path .. "*", "MOD")

		for k, v in ipairs(files) do
			if string.GetExtensionFromFilename(v) == "ttf" then
				local font = string.StripExtension(v)
				if table.HasValue(textscreenFonts, "Screens_" .. font) then continue end
print("-- "  .. font .. "\n" .. [[
addFont("Screens_ ]] .. font .. [[", {
	font = font,
	weight = 400,
	antialias = false,
	outline = true
})
				]])
			end
		end

		for k, v in ipairs(folders) do
			addFonts(path .. v .. "/")
		end
	end

	concommand.Add("get_fonts", function(ply)
		addFonts("")
	end)

end

--lua/wos/anim_extension/holdtypes/a_combo2.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "a_combo2"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "pose_ducking_01"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_fist"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "a_combo2" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "a_combo2" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--lua/wos/anim_extension/holdtypes/g_rollback.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "g_rollback"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "rollback" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "rollback" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "wos_judge_a_idle"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--addons/z_anticrash_v1.4.6/lua/z_anticrash/shared/sh_utils.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

SH_ANTICRASH.UTILS = {}
SH_ANTICRASH.UTILS.LOG = {}
SH_ANTICRASH.UTILS.TIME = {}
SH_ANTICRASH.UTILS.MATERIAL = {}
SH_ANTICRASH.UTILS.IsDedicated = game.IsDedicated()

// Time
function SH_ANTICRASH.UTILS.TIME.Format( seconds )

	seconds = seconds or 0
	local hours = math.floor(seconds / 3600)
	local minutes = math.floor((seconds / 60) % 60)
	seconds = seconds % 60
	
	return string.format("%02i:%02i:%02i", hours, minutes, seconds)
	
end

// Material validation
function SH_ANTICRASH.UTILS.MATERIAL.ForceValid( material )

	local mats = list.Get( "RopeMaterials" )
	local isValidMat = table.HasValue(mats, material)
	
	if !isValidMat then		
		-- Default to cable 
		material = "cable/cable2"
	end
	
	return material

end

// Logging
local packedMSGFormat = {
	[1] = SH_ANTICRASH.VARS.COLOR.RED,
	[2] = "[Anti-Crash] ",
	[3] = color_white,
}

local function UnpackMSG(str,hasNL)
	
	local packedMSG = table.Copy(packedMSGFormat)
	packedMSG[4] = str..(hasNL and '\n' or '')
	
	return unpack(packedMSG)

end

function SH_ANTICRASH.UTILS.LOG.Print(str)
	
	if SERVER then
	
		SH_ANTICRASH.UTILS.LOG.ConsolePrintAdmins(str)
		
	else
	
		SH_ANTICRASH.UTILS.LOG.ConsolePrint(str)
		
	end
	
end

function SH_ANTICRASH.UTILS.LOG.PlyPrint(ply,str)
	SH_ANTICRASH.UTILS.LOG.Print(SH_ANTICRASH.UTILS.LOG.GetPlayerFormat(ply)..' '..str)
end

function SH_ANTICRASH.UTILS.LOG.GetPlayerFormat(ply)
	
	if IsValid(ply) then
	
		local steamID = ply:SteamID() or "STEAM_0:0:0"
		local nick = ply:Nick() or "ERROR"
	
		return "<"..steamID.."> "..nick	
	
	end
	
	return "Console"
	
end

function SH_ANTICRASH.UTILS.LOG.GetNick(ply)
	
	if IsValid(ply) then
		return ply:Nick()
	else
		return "Console"
	end

end

function SH_ANTICRASH.GetNeighboringEnts(ent)
	
	local neighbours = {}

	if IsValid(ent) then
	
		local offsetVector = SH_ANTICRASH.VARS.NEIGHBOUROFFSETVECTOR
		local worldMins = LocalToWorld(ent:OBBMins()-offsetVector, Angle(0,0,0), ent:GetPos(), ent:GetAngles())
		local worldMaxs = LocalToWorld(ent:OBBMaxs()+offsetVector, Angle(0,0,0), ent:GetPos(), ent:GetAngles())
		
		neighbours = ents.FindInBox( worldMins, worldMaxs )
		
	end
	
	return neighbours
	
end

-- Cheecky way to make our hook the first
function SH_ANTICRASH.PrioritizedAddHook(hookName, identifier, prioritizedFunc)

	hook.Add( "PostGamemodeLoaded", "z_anticrash_prioritizeHook_"..hookName, function()

		-- Shitty workaround to avoid conflicts
		timer.Simple(10, function()
			local prioritizedHookName = "z_anticrash_prioritized_"..hookName
			local hooks = hook.GetTable()[hookName] or {}
			
			-- Remove all hooks & add to alternate hook
			for name, func in pairs(hooks) do
				hook.Add(prioritizedHookName, name, func)
				hook.Remove(hookName, name)
			end
			
			-- Create delegator that calls prioritized func first
			local function DelegateFunc(...)
				local funcRes = prioritizedFunc(...)
				
				if funcRes == nil then
					funcRes = hook.Run(prioritizedHookName, ...)
				end
				
				return funcRes
				
			end

			-- Hook delegator
			hook.Add(hookName, identifier, DelegateFunc)
			
			-- Make sure future hooks run under the delegator
			local __oldHookAdd = hook.Add
			
			function hook.Add(name, id, func)
			
				if name == hookName then
					__oldHookAdd(prioritizedHookName, id, func)
				else
					__oldHookAdd(name, id, func)
				end
			
			end
		
		end)
	
	end)

end

function SH_ANTICRASH.CanFreeze(ent)

	-- Check for vehicles
	if SH_ANTICRASH.SETTINGS.FREEZEVEHICLES and !ent:IsVehicle() then
		return false
	end
	
	local class = ent:GetClass()
	
	-- Check entity freeze blacklist
	if SH_ANTICRASH.SETTINGS.FREEZEBLACKLIST[class] then
		return false
	end
	
	-- Freeze blacklist REG
	for freezeI=1, #SH_ANTICRASH.SETTINGS.FREEZEBLACKLISTREG do
		
		-- Check if class is in the blacklist
		if string.StartWith(class, SH_ANTICRASH.SETTINGS.FREEZEBLACKLISTREG[freezeI]) then
			return false
		end
	
	end
	
	return true

end

if CLIENT then

	local function ConsolePrint(len, ply)
	
		local str = isstring(len) and len or net.ReadString()
		local hidePrefix = net.ReadBool()
		
		-- Check for translation formats
		str = SH_ANTICRASH.Format(str)
		
		if !hidePrefix then
			MsgC(UnpackMSG(str,true))
		else
			print(str)
		end
	
	end
	net.Receive("cl_anticrash_ConsolePrint",ConsolePrint)

	local function ChatPrint(len, ply)
		
		local str = isstring(len) and len or net.ReadString()
		
		-- Check for translation formats
		str = SH_ANTICRASH.Format(str)
		
		chat.AddText(UnpackMSG(str))
	
	end
	net.Receive("cl_anticrash_ChatPrint",ChatPrint)
	
	function SH_ANTICRASH.UTILS.LOG.ChatPrint(str)
		ChatPrint(str)
	end
	
	function SH_ANTICRASH.UTILS.LOG.ConsolePrint(str)
		ConsolePrint(str)
	end

end


if SERVER then
	
	util.AddNetworkString("cl_anticrash_ChatPrint")
	function SH_ANTICRASH.UTILS.LOG.ChatPrint(ply,str)
	
		net.Start("cl_anticrash_ChatPrint")
			net.WriteString(str)
		net.Send(ply)
		
	end
	
	function SH_ANTICRASH.UTILS.LOG.ChatPrintAll(str)
		
		local plys = player.GetAll()
		
		for i=1, #plys do
			SH_ANTICRASH.UTILS.LOG.ChatPrint(plys[i],str)
		end
		
	end
	
	util.AddNetworkString("cl_anticrash_ConsolePrint")
	function SH_ANTICRASH.UTILS.LOG.ConsolePrint(ply,str,hidePrefix)
	
		if ply ~= NULL and ply:IsPlayer() then
	
			net.Start("cl_anticrash_ConsolePrint")
				net.WriteString(str)
				net.WriteBool(hidePrefix)
			net.Send(ply)
			
		else
			SH_ANTICRASH.UTILS.LOG.ServerPrint(str,hidePrefix)
		end
		
	end
	
	function SH_ANTICRASH.UTILS.LOG.ServerPrint(str,hidePrefix)
	
		-- Server console
		local formattedStr = SH_ANTICRASH.Format(str)
	
		if SH_ANTICRASH.UTILS.IsDedicated then
			
			if !hidePrefix then
				MsgC(UnpackMSG(formattedStr,true))
			else
				print(formattedStr)
			end
			
		end
		
		SV_ANTICRASH.Log(formattedStr)
		
	end
	
	function SH_ANTICRASH.UTILS.LOG.ConsolePrintAdmins(str)
		
		-- Server Console
		SH_ANTICRASH.UTILS.LOG.ServerPrint(str)
		
		-- Admins
		for k, ply in pairs(player.GetAll()) do
		
			if SH_ANTICRASH.HasAccess(ply) then
				SH_ANTICRASH.UTILS.LOG.ConsolePrint(ply,str)
			end
		
		end
		
	end
	
	function SH_ANTICRASH.UTILS.LOG.PlyConsolePrintAdmins(ply,str)
		SH_ANTICRASH.UTILS.LOG.ConsolePrintAdmins(SH_ANTICRASH.UTILS.LOG.GetPlayerFormat(ply)..' '..str)
	end
	
end
--addons/z_anticrash_v1.4.6/lua/z_anticrash/languages/en.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

local en = {
	
	-- Stats
	lag = "LAG",
	collisions = "COLLISIONS",
	props = "PROPS",
	propsFrozen = "FROZEN PROPS",
	npcs = "NPCS",
	vehicles = "VEHICLES",
	players = "PLAYERS",
	uptime = "UPTIME",
	entities = "ENTITIES",
	spawned = "SPAWNED",
	fps = "FPS",
	tickrate = "TICKRATE",
	toggleOverlay = "Toggle Stats Overlay",
	runAntiLagMeasures = "RUN ANTI-LAG MEASURES",
	startingUp = "Server started up!",
	shuttingDown = "Server shutting down!",
	
	-- Users
	search = "Search",
	constraints = "CONSTRAINTS",
	showEntities = "Show Entities",
	hideEntities = "Hide Entities",
	resetMap = "Reset Map",
	freezeEntities = "Freeze Entities",
	removeEntities = "Remove Entities",
	
	-- Global
	noCollideEntities = "No-Collide Entities",
	
	-- Lag
	heavyLag = "Heavy lag detected!",
	lagIsStuck = "Warning: lag is stuck!",
	crashPrevented = "Server crash prevented!",
	cleaningMap = "+ Cleaning map...",
	removingEnts = "+ Removing %s entities",
	revertChanges = "+ Removing %s entities created in the last %s minutes",
	freezeingEnts = "+ Freezing %s entities",
	noCollidingEnts = "+ No Colliding %s entities",
	offenderWarning = "%s has suspicious entity count (%s) preceding the lag!",
	freezingAllEntities = "Froze all entities (%s)",
	
	-- Dupes
	dupesNotEnabled = "Dupes are not enabled on this server!",
	advDupesNotEnabled = "Advanced Dupes are not enabled on this server!",
	dupeExceedsSize = "That dupe exceeds the max size limit! (size:%s, max:%s)",
	dupeExceedsRopeLimit = "That dupe exceeds the max rope limit! (amount:%s, max:%s)",
	dupeInformation = "%s spawning dupe containing %s entities and %s constraints",
	
	-- Notifications
	triggeredAntiLagMeasures = "triggered anti-lag measures!",
	ranAntilagMeasures = "ran anti-lag measures!",
	hasNoEntities = "has no entities!",
	youRemovedFrom = "You removed %s entities from %s!",
	removedYourObjects = "removed your spawned objects!",
	youFrozeFrom = "You froze %s entities from %s!",
	frozeYourObjects = "froze your spawned objects!",
	enabledSpawnAbility = "re-enabled your ability to spawn objects!",
	disabledSpawnAbility = "disabled your ability to spawn objects!",
	youEnabledSpawnAbility = "You enabled %s's ability to spawn objects!",
	youDisabledSpawnAbility = "You disabled %s's ability to spawn objects!",
	
	resetTheMap = "reset the map!",
	noEntNameFound = "No %s found!",
	noEntitiesFound = "No entities found!",
	noUnfrozenEntsFound = "No unfrozen entities found!",
	noUnCollidedEntsFound = "No un-collided entities found!",
	freezeAllEnts = "%s froze all %s! (%s)",
	noCollideAllEnts = "%s no-collided all %s! (%s)",
	removedAllEntName = "%s removed all %s! (%s)",
	entitiesLowCase = "entities",
	removingOutOfBounds = "Removing out of bounds %s",
	
	-- Console Log
	removedEntitiesFrom = "%s removed %s entities from %s!",
	frozeEntitiesFrom = "%s froze %s entities from %s!",
	enabledSpawningCapabilities = "%s re-enabled spawning capabilities for %s!",
	disabledSpawningCapabilities = "%s disabled spawning capabilities for %s!",
	removingHighCollision = "Removing high collision %s (%s) from %s!",
	
	-- Exploits
	chatClearKick = "%s has been kicked for using the ChatClear exploit!",
}

return en
--addons/z_anticrash_v1.4.6/lua/z_anticrash/client/cl_dupe.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]


local function CanArmDupe(ply)
	
	-- Prevent dupes from being downloaded if disabled
	if !SH_ANTICRASH.SETTINGS.DUPES.ENABLE then
		return false
	end

end
hook.Add("CanArmDupe","cl_anticrash_CanArmDupe",CanArmDupe)

/*
-- local __oldOpenDupe = engine.OpenDupe
__oldOpenDupe = __oldOpenDupe or engine.OpenDupe

engine.OpenDupe = function(dupeName)
	
	local compressedDupe = __oldOpenDupe(dupeName)
	
	-- Default dupe error handling
	if ( !compressedDupe ) then
		MsgN( "Error loading dupe.. (", dupeName, ")" )
		return
	end

	if ( #compressedDupe > 64000 && !game.SinglePlayer() ) then
		LocalPlayer():ChatPrint( "That dupe is too large to spawn in multiplayer!" )
		return
	end
	
	local uncompressedDupe = util.Decompress( compressedDupe.data, 5242880 )
	
	if ( !uncompressedDupe ) then
		MsgN( "Couldn't decompress dupe!" )
		return
	end
	
	-- Check dupe data
	local dupe = util.JSONToTable( uncompressedDupe )
	PrintTable(dupe)
	
	-- Allow dupe to be spawned
	return compressedDupe

end
*/
--addons/z_anticrash_v1.4.6/lua/z_anticrash/client/cl_graphdata.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

CL_ANTICRASH.GRAPH = {}

CL_ANTICRASH.GRAPH.COL = {
	PLAYERS = SH_ANTICRASH.VARS.COLOR.DARKGREY,
	UPTIME = SH_ANTICRASH.VARS.COLOR.DARKGREY,
	ENTITIES = SH_ANTICRASH.VARS.COLOR.DARKGREY,
	SPAWNED = SH_ANTICRASH.VARS.COLOR.DARKGREY,
	FPS = SH_ANTICRASH.VARS.COLOR.DARKGREY,
	TICKRATE = SH_ANTICRASH.VARS.COLOR.DARKGREY,
	ZLAG = SH_ANTICRASH.VARS.COLOR.RED,
	PROPS = SH_ANTICRASH.VARS.COLOR.BLUE,
	FROZENPROPS = SH_ANTICRASH.VARS.COLOR.LIGHTBLUE,
	COLLISIONS = SH_ANTICRASH.VARS.COLOR.ORANGE,
	NPCS = SH_ANTICRASH.VARS.COLOR.LIGHTYELLOW,
	VEHICLES = SH_ANTICRASH.VARS.COLOR.GREEN,
}

CL_ANTICRASH.GRAPH.INFO = {}
CL_ANTICRASH.GRAPH.INFO.PLAYERS = { cur = 0, max = game.MaxPlayers(), noDraw = true }
CL_ANTICRASH.GRAPH.INFO.UPTIME = { cur = 0, noDraw = true }
CL_ANTICRASH.GRAPH.INFO.ENTITIES = { cur = 0, noDraw = true }
CL_ANTICRASH.GRAPH.INFO.SPAWNED = { cur = 0, noDraw = true }
CL_ANTICRASH.GRAPH.INFO.FPS = { cur = 0, noDraw = true }
CL_ANTICRASH.GRAPH.INFO.TICKRATE = { cur = 0, noDraw = true }

CL_ANTICRASH.GRAPH.INFO.ZLAG = { cur = 0, max = SH_ANTICRASH.SETTINGS.LAG.Delay }
CL_ANTICRASH.GRAPH.INFO.PROPS = { cur = 0, max = 0 }
CL_ANTICRASH.GRAPH.INFO.FROZENPROPS = { cur = 0, noDraw = true }
CL_ANTICRASH.GRAPH.INFO.COLLISIONS = { cur = 0, max = 9999 }
CL_ANTICRASH.GRAPH.INFO.NPCS = { cur = 0, max = SH_ANTICRASH.SETTINGS.GRAPH.SCALE.MAXNPCS }
CL_ANTICRASH.GRAPH.INFO.VEHICLES = { cur = 0, max = SH_ANTICRASH.SETTINGS.GRAPH.SCALE.MAXVEHICLES }


CL_ANTICRASH.GRAPH.POINTS = {}
local function GraphPointUpdate()
	
	local points = {}
		
	for k, v in pairs(CL_ANTICRASH.GRAPH.INFO) do
	
		if v.noDraw then continue end
		
		CL_ANTICRASH.GRAPH.POINTS[k] = CL_ANTICRASH.GRAPH.POINTS[k] or {}
		
		table.insert(CL_ANTICRASH.GRAPH.POINTS[k], 1, {
			cur = v.cur,
			max = v.max
		})
		
		if #CL_ANTICRASH.GRAPH.POINTS[k] > SH_ANTICRASH.SETTINGS.GRAPH.TIMEWINDOW+2 then
			table.remove( CL_ANTICRASH.GRAPH.POINTS[k], SH_ANTICRASH.SETTINGS.GRAPH.TIMEWINDOW+3 )
		end
		
	end
	
end

local nextUpdate = 0
local function GraphInfoUpdate()

	if !SH_ANTICRASH.HasAccess("stats") then return end

	if !CL_ANTICRASH.MenuIsOpen() and !CL_ANTICRASH.OverlayIsOpen() and !SH_ANTICRASH.SETTINGS.GRAPH.ALWAYSUPDATE then return end
	
	if nextUpdate < CurTime() then
	 
		-- Players 
		CL_ANTICRASH.GRAPH.INFO.PLAYERS.cur = player.GetCount()
		
		-- Uptime
		CL_ANTICRASH.GRAPH.INFO.UPTIME.cur = SH_ANTICRASH.UTILS.TIME.Format(CurTime())
		
		-- Fps
		CL_ANTICRASH.GRAPH.INFO.FPS.cur = math.floor(1/RealFrameTime())
	
		-- Tickrate
		CL_ANTICRASH.GRAPH.INFO.TICKRATE.cur = math.floor(1/engine.ServerFrameTime()) -- engine.TickInterval()
		
		-- Lag
		CL_ANTICRASH.GRAPH.INFO.ZLAG.cur = GetGlobalFloat("z_anticrash_Lag")
		
		-- Spawned
		CL_ANTICRASH.GRAPH.INFO.SPAWNED.cur = GetGlobalInt("z_anticrash_Spawned")
		
		local entCount, propCount, npcCount, vehicleCount = 0, 0, 0, 0
		
		local entTbl = ents.GetAll()
		
		for i=1, #entTbl do
			
			local ent = entTbl[i]
			
			entCount = entCount + 1
		
			if string.StartWith(ent:GetClass(),"prop_") then
				
				propCount = propCount + 1
				
			end
			
			if ent:IsNPC() or ent:IsNextBot() then
			
				npcCount = npcCount + 1
				
			elseif ent:IsVehicle() and ent:GetClass() ~= "prop_vehicle_prisoner_pod" then
			
				-- Only driving vehicles
				if ent.GetDriver and ent:GetDriver() ~= NULL then
			
					vehicleCount = vehicleCount + 1
					
				end

			end
		
		end
		
		-- Entities
		CL_ANTICRASH.GRAPH.INFO.ENTITIES.cur = entCount
		
		-- Props
		CL_ANTICRASH.GRAPH.INFO.PROPS.cur = propCount
		local maxPropCount = SH_ANTICRASH.SETTINGS.GRAPH.SCALE.MAXPROPS
		
		if maxPropCount == -1 then
		
			local maxPropsPerPlayerConvar = GetConVar("sbox_maxprops")
			maxPropCount = CL_ANTICRASH.GRAPH.INFO.PLAYERS.cur * maxPropsPerPlayerConvar:GetInt()
			
		end
		
		CL_ANTICRASH.GRAPH.INFO.PROPS.max = maxPropCount
		
		-- Freeze count
		CL_ANTICRASH.GRAPH.INFO.FROZENPROPS.cur = GetGlobalInt("z_anticrash_FreezeCount")
		
		-- Collision count
		CL_ANTICRASH.GRAPH.INFO.COLLISIONS.cur = GetGlobalInt("z_anticrash_CollisionCount")
		CL_ANTICRASH.GRAPH.INFO.COLLISIONS.max = propCount * 8
		
		-- NPC Count
		CL_ANTICRASH.GRAPH.INFO.NPCS.cur = npcCount
		
		-- Vehicle Count
		CL_ANTICRASH.GRAPH.INFO.VEHICLES.cur = vehicleCount
		
		-- Update data points
		GraphPointUpdate()
		
		nextUpdate = CurTime() + SH_ANTICRASH.SETTINGS.GRAPH.UPDATEDELAY

	end

end
hook.Add("Think","cl_anticrash_GraphInfoUpdate",GraphInfoUpdate)

--addons/z_anticrash_v1.4.6/lua/z_anticrash/client/cl_meta.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

local Panel = FindMetaTable('Panel')

function Panel:GetBottomY()
	
	local x,y,w,h = self:GetBounds()
	
	return y+h
	
end

function Panel:GetRightX()
	
	local x,y,w,h = self:GetBounds()
	
	return x+w
	
end
--addons/z_anticrash_v1.4.6/lua/z_anticrash/panels/p_global.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

local PANEL = {}
local scrW,scrH = ScrW(),ScrH()

function PANEL:Init(realInit)

	if !realInit then return end

	CL_ANTICRASH.SkinScrollPanel(self)
	
	local pWide, pTall = self:GetSize()
	local offset = 10
	local buttonW = pWide-(offset*2)
	local buttonH = 28
	
	-- Prevent overlapping scroll items
	local _, selfY = self:GetPos()
	self:SetPos(0,selfY+offset)
	self:SetSize(pWide,(pTall-offset*2))
	
	-- Vision Button
	local hasGlobalVision = CL_ANTICRASH.ENTVISION.GetGlobalVision()
	
	local function entVisionBtnText()
		return hasGlobalVision and SH_ANTICRASH.Translate("hideEntities") or SH_ANTICRASH.Translate("showEntities")
	end
	
	local entityVisionBtn = CL_ANTICRASH.CreateColorSwitchButton(offset, 0, buttonW, buttonH, entVisionBtnText(), "z_anticrash_global_btn", SH_ANTICRASH.VARS.COLOR.DARKPURPLE, SH_ANTICRASH.VARS.COLOR.CONTRASTFUCHSIA, hasGlobalVision, self, function(self)
		
		CL_ANTICRASH.ENTVISION.SetGlobalVision(!hasGlobalVision)
		CL_ANTICRASH.PlaySound("togglePress")
		
		hasGlobalVision = !hasGlobalVision
		self.__isSelected = hasGlobalVision
		self:SetText(entVisionBtnText())
		
	end)
	
	-- Separation Line
	local dividerH = 4
	local dividerPnl = CL_ANTICRASH.CreateDividerLine(offset,entityVisionBtn:GetBottomY()+offset, buttonW, dividerH, SH_ANTICRASH.VARS.COLOR.LESSDARKY, self)
	
	-- Cleanup Buttons
	local nextY = dividerPnl:GetBottomY()+offset
	local cleanupTypes = SH_ANTICRASH.VARS.CLEANUP.TYPES
	
	for i=1, #cleanupTypes do
	
		if i==5 then
		
			local dividerPnl = CL_ANTICRASH.CreateDividerLine(offset,nextY, buttonW, dividerH, SH_ANTICRASH.VARS.COLOR.LESSDARKY, self)
			nextY = dividerPnl:GetBottomY()+offset
			
		end
		
		local cleanupType, cleanupStr, isDefault = cleanupTypes[i].type, cleanupTypes[i].name, cleanupTypes[i].isDefault
		local cleanupCol = SH_ANTICRASH.VARS.CLEANUP.COLORS[i]
		
		if !isDefault then
			cleanupStr = SH_ANTICRASH.Translate(cleanupStr)
		end

		local cleanupBtn = CL_ANTICRASH.CreateButtonColorFade(offset, nextY, buttonW, buttonH, cleanupStr, "z_anticrash_global_btn", cleanupCol, color_white, self, function()
			
			local delay = cleanupStr == "Reset Map" and 0.1 or 0
			
			timer.Simple(delay,function()
				CL_ANTICRASH.PlaySound("gmodPress")
			end)
			
			net.Start("sv_anticrash_GlobalCleanup")
				net.WriteString(cleanupType)
			net.SendToServer()
			
		end)
		
		nextY = cleanupBtn:GetBottomY()+offset
	
	end

end
vgui.Register('p_anticrash_global',PANEL,'DScrollPanel')
--addons/z_anticrash_v1.4.6/lua/z_anticrash/panels/p_menu.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER]]

local PANEL = {}
local scrW,scrH = ScrW(),ScrH()

local menuW, menuH = 500,700
local menuAnimSpeed = 0.2
local titleBarH = 35

local catBtnSize,catBtnOffset = 64,15
local catBtnAnimTimeShow, catBtnAnimTimeGrow = 0.3, 0.05
local circleTexID = surface.GetTextureID("z_anticrash/vgui/circle")
local closeBtnIcon = "z_anticrash/vgui/cross"

local categoryBtns = {
	{"stats","p_anticrash_stats","z_anticrash/icons/eye",60},
	{"users","p_anticrash_users","z_anticrash/icons/user",52},
	{"global","p_anticrash_global","z_anticrash/icons/group",48},
}

local catPosY = 0
local activeCategoryName = nil
local activeCategory = nil

local function CreateCategoryButton(i,parent,menuPanel,name,panel,icon,iconSize)

	if !SH_ANTICRASH.HasAccess(name) then return end
	
	if !activeCategoryName then
		activeCategoryName = name
	end
	
	local iconTexID = surface.GetTextureID(icon)
	local finishedAnimation, finishedLoadingAnimation = false, false
	
	-- Rounded Image Button
	local catBtn = vgui.Create( "DButton", parent )
	catBtn:SetPos(0,catPosY)
	catBtn.__x = 0
	catBtn.__y = catPosY
	
	catBtn:SetText("")
	catBtn:SetZPos(-1)
	catBtn:SetSize(catBtnSize+catBtnOffset,catBtnSize+catBtnOffset)
	catBtn.__realSize = catBtnSize
	
	catBtn.Paint = function(self, w, h)
	
		local wide = self:GetWide()
		local circleX, circleY = wide/2-catBtn.__realSize/2, wide/2-catBtn.__realSize/2
		local iconX, iconY = wide/2-iconSize/2, wide/2-iconSize/2
	
		-- Circle bg
		surface.SetDrawColor( SH_ANTICRASH.VARS.COLOR.DARKY )
		surface.SetTexture( circleTexID )
		surface.DrawTexturedRect(circleX, circleY, catBtn.__realSize, catBtn.__realSize )
		
		-- Circle FG
		surface.SetDrawColor( ColorAlpha(color_white, self.__bgAlpha) )
		surface.SetTexture( circleTexID )
		surface.DrawTexturedRect(circleX, circleY, catBtn.__realSize, catBtn.__realSize )
	
		-- Icon
		surface.SetDrawColor( color_white )
		surface.SetTexture( iconTexID )
		surface.DrawTexturedRect(iconX, iconY, iconSize, iconSize )
		
	end
	
	catBtn.__bgAlpha = 0
	local nextThink, fadeSpeed = 0, 10
	catBtn.Think = function(self, w, h)
		
		if nextThink < CurTime() then
	
			-- alpha fade
			if self.__cursorIn or (name == activeCategoryName and finishedLoadingAnimation) then
			
				self.__bgAlpha = math.Approach(self.__bgAlpha, 255, fadeSpeed)
				
			else
				self.__bgAlpha = math.Approach(self.__bgAlpha, 0, fadeSpeed)
			end
			
			-- size
			if self.__cursorIn then
				self.__realSize = math.Approach(self.__realSize, catBtnSize*1.1, 2)
			else
				self.__realSize = math.Approach(self.__realSize, catBtnSize, 2)
			end
			
			-- Limit to 30FPS
			nextThink = CurTime() + 0.033
			
		end
	
	end
	
	catBtn.DoClick = function(self,force)
		
		-- No action if trying to reopen the same catetgory
		if activeCategoryName == name and !force then 
			return
		end
		
		-- Play sound
		if !force then
			CL_ANTICRASH.PlaySound("catPress")
		end
		
		-- Remove prev created cat
		if activeCategory ~= nil then
			activeCategory:Remove()
		end
		
		activeCategoryName = name
		
		local menuPanelW,menuPanelH = menuPanel:GetSize()
		
		activeCategory = vgui.Create(panel,menuPanel)
		
		if activeCategory ~= nil then
			activeCategory:SetPos(0,titleBarH)
			activeCategory:SetSize(menuPanelW,menuPanelH-titleBarH)
			activeCategory:Init(true)
		else
			error("Panel <"..panel.."> does not exist!")
		end
		
	end
	
	if name == activeCategoryName then
		catBtn:DoClick(true)
	end
	
	-- Grow btn
	catBtn.OnCursorEntered = function(self)
		self.__cursorIn = true
	end

	catBtn.OnCursorExited = function(self)
		self.__cursorIn = false
	end
	
	-- Button animation
	local animDelay = catBtnAnimTimeShow*(i-1)
	catBtn:SetPos(catBtnSize+catBtnOffset, catPosY)
	catBtn:SetAlpha(0)
	
	timer.Simple(menuAnimSpeed,function()
		
		if IsValid(catBtn) then
			catBtn:SetAlpha(255)
			catBtn:MoveTo( catBtn.__x, catBtn.__y, catBtnAnimTimeShow, animDelay, -1, function()
				finishedAnimation = true
				finishedLoadingAnimation = true
			end)
		end
		
	end)
	
	catPosY = catPosY + catBtnSize + 10
	
end

function PANEL:Init()
	
	self:SetTitle("")
	self:ShowCloseButton(false)
	self:SetDraggable(true)
	self:SetSize(menuW+catBtnSize+catBtnOffset,menuH)
	self:Center()
	self.Paint = function() end
	
	-- animate alpha
	self:SetAlpha(0)
	self:AlphaTo(255, menuAnimSpeed)
	
	self:MoveToFront()
	self:MakePopup()
	
	local menuPanel = vgui.Create("DPanel",self)
	menuPanel:SetPos(catBtnSize+catBtnOffset)
	menuPanel:SetSize(menuW, menuH)
	
	-- Title
	local titleLbl = CL_ANTICRASH.CreateLbl(0, 5, "Anti-Crash", "z_anticrash_menu_title", ColorAlpha(SH_ANTICRASH.VARS.COLOR.RED,200), menuPanel)
	titleLbl:CenterHorizontal()
	
	-- Close btn
	local closeBtn = vgui.Create( "DImageButton", menuPanel )
	closeBtn:SetPos( menuW-28, 8 )
	closeBtn:SetSize( 20, 20 )
	closeBtn:SetColor(Color(255,255,255,200))
	closeBtn:SetImage( closeBtnIcon )	
	closeBtn.DoClick = function()
		CL_ANTICRASH.ToggleMenu(true)
	end
	
	-- Categories
	catPosY = 40
	
	for i=1, #categoryBtns do
		
		local cat = categoryBtns[i]
	
		CreateCategoryButton(i,self,menuPanel,cat[1],cat[2],cat[3],cat[4])
		
	end
	
	menuPanel.Paint = function(self, w, h)
	
		-- Menu bg
		surface.SetDrawColor(SH_ANTICRASH.VARS.COLOR.DARK)
		surface.DrawRect(0,titleBarH,w,h)
		
		-- Title bar bg
		surface.SetDrawColor(SH_ANTICRASH.VARS.COLOR.LIGHTDARK)
		surface.DrawRect(0,0,w,titleBarH)
		
	end
	
end
vgui.Register("p_anticrash_menu",PANEL,"DFrame")

--addons/tools_advdupe/lua/advdupe2/cl_ghost.lua:
function AdvDupe2.LoadGhosts(dupe, info, moreinfo, name, preview)
	AdvDupe2.RemoveGhosts()
	AdvDupe2.Ghosting = true
	AdvDupe2.GhostToSpawn = {}
	local count = 0
	local time, desc, date, creator

	if(info.ad1) then
		local z = dupe.HeadEnt.Z
		local Pos, Ang

		time    = moreinfo.Time    or ""
		desc    = info.Description or ""
		date    = info.Date        or ""
		creator = info.Creator     or ""

		AdvDupe2.HeadEnt = dupe.HeadEnt.Index
		AdvDupe2.HeadPos = dupe.HeadEnt.Pos
		AdvDupe2.HeadZPos = z
		AdvDupe2.HeadPos.Z = AdvDupe2.HeadPos.Z + z

		for k, v in pairs(dupe.Entities) do
			if(v.SavedParentIdx) then
				if(not v.BuildDupeInfo) then v.BuildDupeInfo = {} end
				v.BuildDupeInfo.DupeParentID = v.SavedParentIdx
				Pos = v.LocalPos
				Ang = v.LocalAngle
			else
				Pos, Ang = nil, nil
			end

			for i, p in pairs(v.PhysicsObjects) do
				p.Pos        = Pos or p.LocalPos
				p.Pos.Z      = p.Pos.Z - z
				p.Angle      = Ang or p.LocalAngle
				p.LocalPos   = nil
				p.LocalAngle = nil
			end

			v.LocalPos = nil
			v.LocalAngle = nil
			AdvDupe2.GhostToSpawn[count] =
			{
				Model          = v.Model,
				PhysicsObjects = v.PhysicsObjects
			}

			if(AdvDupe2.HeadEnt == k) then
				AdvDupe2.HeadEnt = count
			end

			count = count + 1
		end

		AdvDupe2.HeadOffset = AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt].PhysicsObjects[0].Pos
		AdvDupe2.HeadAngle  = AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt].PhysicsObjects[0].Angle
	else
		time    = info.time        or ""
		desc    = dupe.Description or ""
		date    = info.date        or ""
		creator = info.name        or ""

		AdvDupe2.HeadEnt    = dupe.HeadEnt.Index
		AdvDupe2.HeadZPos   = dupe.HeadEnt.Z
		AdvDupe2.HeadPos    = dupe.HeadEnt.Pos
		AdvDupe2.HeadOffset = dupe.Entities[AdvDupe2.HeadEnt].PhysicsObjects[0].Pos
		AdvDupe2.HeadAngle  = dupe.Entities[AdvDupe2.HeadEnt].PhysicsObjects[0].Angle

		for k, v in pairs(dupe.Entities) do
			AdvDupe2.GhostToSpawn[count] =
			{
				Model          = v.Model,
				PhysicsObjects = v.PhysicsObjects
			}

			if(AdvDupe2.HeadEnt == k) then
				AdvDupe2.HeadEnt = count
			end

			count = count + 1
		end
	end

	if(not preview) then
		AdvDupe2.Info.File:SetText("File: "..name)
		AdvDupe2.Info.Creator:SetText("Creator: "..creator)
		AdvDupe2.Info.Date:SetText("Date: "..date)
		AdvDupe2.Info.Time:SetText("Time: "..time)
		AdvDupe2.Info.Size:SetText("Size: "..string.NiceSize(tonumber(info.size) or 0))
		AdvDupe2.Info.Desc:SetText("Desc: "..(desc or ""))
		AdvDupe2.Info.Entities:SetText("Entities: "..table.Count(dupe.Entities))
		AdvDupe2.Info.Constraints:SetText("Constraints: "..table.Count(dupe.Constraints))
	end

	AdvDupe2.StartGhosting()
	AdvDupe2.Preview = preview
end

function AdvDupe2.RemoveGhosts()
	if(AdvDupe2.Ghosting) then
		hook.Remove("Tick", "AdvDupe2_SpawnGhosts")
		AdvDupe2.Ghosting = false

		if(not AdvDupe2.BusyBar) then
			AdvDupe2.RemoveProgressBar()
		end
	end

	if(AdvDupe2.GhostEntities) then
		for k, v in pairs(AdvDupe2.GhostEntities) do
			if(IsValid(v))then
				v:Remove()
			end
		end
	end

	if(IsValid(AdvDupe2.HeadGhost))then
		AdvDupe2.HeadGhost:Remove()
	end

	AdvDupe2.CurrentGhost  = 1
	AdvDupe2.HeadGhost     = nil
	AdvDupe2.GhostEntities = nil
	AdvDupe2.Preview       = false
end

--Creates a ghost from the given entity's table
local function MakeGhostsFromTable(EntTable)

	if(not EntTable) then return end
	if(not EntTable.Model or EntTable.Model:sub(-4,-1) ~= ".mdl") then
		EntTable.Model = "models/error.mdl"
	end

	local GhostEntity = ClientsideModel(EntTable.Model, RENDERGROUP_TRANSLUCENT)

	-- If there are too many entities we might not spawn..
	if not IsValid(GhostEntity) then
		AdvDupe2.RemoveGhosts()
		AdvDupe2.Notify("Too many entities to spawn ghosts!", NOTIFY_ERROR)
		return
	end

	GhostEntity:SetRenderMode( RENDERMODE_TRANSALPHA )	--Was broken, making ghosts invisible
	GhostEntity:SetColor( Color(255, 255, 255, 150) )
	GhostEntity.Phys = EntTable.PhysicsObjects[0]

	if util.IsValidRagdoll(EntTable.Model) then
		local ref, parents, angs = {}, {}, {}

		GhostEntity:SetupBones()
		for k, v in pairs(EntTable.PhysicsObjects) do
			local bone = GhostEntity:TranslatePhysBoneToBone(k)
			local bonp = GhostEntity:GetBoneParent(bone)
			if bonp == -1 then
				ref[bone] = GhostEntity:GetBoneMatrix(bone):GetInverseTR()
			else
				bonp = GhostEntity:TranslatePhysBoneToBone(GhostEntity:TranslateBoneToPhysBone(bonp))
				parents[bone] = bonp
				ref[bone] = GhostEntity:GetBoneMatrix(bone):GetInverseTR() * GhostEntity:GetBoneMatrix(bonp)
			end

			local m = Matrix() m:SetAngles(v.Angle)
			angs[bone] = m
		end

		for bone, ang in pairs( angs ) do
			if parents[bone] and angs[parents[bone]] then
				local localrotation = angs[parents[bone]]:GetInverseTR() * ang
				local m = ref[bone] * localrotation
				GhostEntity:ManipulateBoneAngles(bone, m:GetAngles())
			else
				local pos = GhostEntity:GetBonePosition(bone)
				GhostEntity:ManipulateBonePosition(bone, -pos)
				GhostEntity:ManipulateBoneAngles(bone, ref[bone]:GetAngles())
			end
		end
	end

	return GhostEntity
end

local function SpawnGhosts()

	if AdvDupe2.CurrentGhost == AdvDupe2.HeadEnt then AdvDupe2.CurrentGhost = AdvDupe2.CurrentGhost + 1 end

	local g = AdvDupe2.GhostToSpawn[AdvDupe2.CurrentGhost]
	if g and AdvDupe2.CurrentGhost / AdvDupe2.TotalGhosts * 100 <= GetConVar("advdupe2_limit_ghost"):GetFloat() then
		AdvDupe2.GhostEntities[AdvDupe2.CurrentGhost] = MakeGhostsFromTable(g)
		if(not AdvDupe2.BusyBar) then
			AdvDupe2.ProgressBar.Percent = AdvDupe2.CurrentGhost / AdvDupe2.TotalGhosts * 100
		end

		AdvDupe2.CurrentGhost = AdvDupe2.CurrentGhost + 1
		AdvDupe2.UpdateGhosts(true)
	else
		AdvDupe2.Ghosting = false
		hook.Remove("Tick", "AdvDupe2_SpawnGhosts")

		if(not AdvDupe2.BusyBar) then
			AdvDupe2.RemoveProgressBar()
		end
	end
end

net.Receive("AdvDupe2_SendGhosts", 	function(len, ply, len2)
	AdvDupe2.RemoveGhosts()
	AdvDupe2.GhostToSpawn = {}
	AdvDupe2.HeadEnt  = net.ReadInt(16)
	AdvDupe2.HeadZPos = net.ReadFloat()
	AdvDupe2.HeadPos  = net.ReadVector()

	local cache = {}
	for i = 1, net.ReadInt(16) do
		cache[i] = net.ReadString()
	end

	for i = 1, net.ReadInt(16) do
		AdvDupe2.GhostToSpawn[i] =
		{
			Model = cache[net.ReadInt(16)],
			PhysicsObjects = {}
		}

		for k = 0, net.ReadInt(8) do
			AdvDupe2.GhostToSpawn[i].PhysicsObjects[k] =
			{
				Angle = net.ReadAngle(),
				Pos   = net.ReadVector()
			}
		end
	end

	AdvDupe2.CurrentGhost  = 1
	AdvDupe2.GhostEntities = {}
	AdvDupe2.HeadGhost     = MakeGhostsFromTable(AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt])
	AdvDupe2.HeadOffset    = AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt].PhysicsObjects[0].Pos
	AdvDupe2.HeadAngle     = AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt].PhysicsObjects[0].Angle
	AdvDupe2.GhostEntities[AdvDupe2.HeadEnt] = AdvDupe2.HeadGhost
	AdvDupe2.TotalGhosts   = #AdvDupe2.GhostToSpawn

	if(AdvDupe2.TotalGhosts > 1) then
		AdvDupe2.Ghosting = true

		if(not AdvDupe2.BusyBar) then
			AdvDupe2.InitProgressBar("Ghosting: ")
			AdvDupe2.BusyBar = false
		end

		hook.Add("Tick", "AdvDupe2_SpawnGhosts", SpawnGhosts)
	else
		AdvDupe2.Ghosting = false
	end
end)

net.Receive("AdvDupe2_AddGhost", function(len, ply, len2)
	local ghost = {Model = net.ReadString(), PhysicsObjects = {}}
	for k = 0, net.ReadInt(8) do
		ghost.PhysicsObjects[k] = {Angle = net.ReadAngle(), Pos = net.ReadVector()}
	end

	AdvDupe2.GhostEntities[AdvDupe2.CurrentGhost] = MakeGhostsFromTable(ghost)
	AdvDupe2.CurrentGhost = AdvDupe2.CurrentGhost + 1
end)

function AdvDupe2.StartGhosting()
	AdvDupe2.RemoveGhosts()
	if(not AdvDupe2.GhostToSpawn) then return end
	AdvDupe2.CurrentGhost  = 1
	AdvDupe2.GhostEntities = {}
	AdvDupe2.Ghosting      = true
	AdvDupe2.HeadGhost     = MakeGhostsFromTable(AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt])
	AdvDupe2.GhostEntities[AdvDupe2.HeadEnt] = AdvDupe2.HeadGhost
	AdvDupe2.TotalGhosts   = #AdvDupe2.GhostToSpawn

	if AdvDupe2.TotalGhosts > 1 then
		if not AdvDupe2.BusyBar then
			AdvDupe2.InitProgressBar("Ghosting: ")
			AdvDupe2.BusyBar = false
		end
		hook.Add("Tick", "AdvDupe2_SpawnGhosts", SpawnGhosts)
	else
		AdvDupe2.Ghosting = false
	end
end
net.Receive("AdvDupe2_StartGhosting", function()
	AdvDupe2.StartGhosting()
end)

net.Receive("AdvDupe2_RemoveGhosts", AdvDupe2.RemoveGhosts)

--Update the ghost's postion and angles based on where the player is looking and the offsets
local Lheadpos, Lheadang = Vector(), Angle()
function AdvDupe2.UpdateGhosts(force)
	if not IsValid(AdvDupe2.HeadGhost) then
		AdvDupe2.RemoveGhosts()
		AdvDupe2.Notify("Invalid ghost parent!", NOTIFY_ERROR)
		return
	end

	local trace = LocalPlayer():GetEyeTrace()
	if (not trace.Hit) then return end

	local originpos, originang, headpos, headang
	local worigin = GetConVar("advdupe2_offset_world"):GetBool()
	if(GetConVar("advdupe2_original_origin"):GetBool())then
		originang  = Angle()
		originpos  = Vector(AdvDupe2.HeadPos)
		headpos = AdvDupe2.HeadPos + AdvDupe2.HeadOffset
		headang = AdvDupe2.HeadAngle
	else
		local hangle = worigin and Angle(0,0,0) or AdvDupe2.HeadAngle
		local pz = math.Clamp(AdvDupe2.HeadZPos + GetConVar("advdupe2_offset_z"):GetFloat() or 0, -16000, 16000)
		local ap = math.Clamp(GetConVar("advdupe2_offset_pitch"):GetFloat() or 0, -180, 180)
		local ay = math.Clamp(GetConVar("advdupe2_offset_yaw"  ):GetFloat() or 0, -180, 180)
		local ar = math.Clamp(GetConVar("advdupe2_offset_roll" ):GetFloat() or 0, -180, 180)
		originang = Angle(ap, ay, ar)
		originpos = Vector(trace.HitPos); originpos.z = originpos.z + pz
		headpos, headang = LocalToWorld(AdvDupe2.HeadOffset, hangle, originpos, originang)
	end

	if math.abs(Lheadpos.x - headpos.x) > 0.01 or
	   math.abs(Lheadpos.y - headpos.y) > 0.01 or
	   math.abs(Lheadpos.z - headpos.z) > 0.01 or
	   math.abs(Lheadang.p - headang.p) > 0.01 or
	   math.abs(Lheadang.y - headang.y) > 0.01 or
	   math.abs(Lheadang.r - headang.r) > 0.01 or force then

		Lheadpos = headpos
		Lheadang = headang

		AdvDupe2.HeadGhost:SetPos(headpos)
		AdvDupe2.HeadGhost:SetAngles(headang)

		for k, ghost in ipairs(AdvDupe2.GhostEntities) do
			local phys = ghost.Phys
			local pos, ang = LocalToWorld(phys.Pos, phys.Angle, originpos, originang)
			ghost:SetPos(pos)
			ghost:SetAngles(ang)
		end

	end
end

--addons/weapon_joe_fort/lua/autorun/client/cl_joefort.lua:
JoeFort = JoeFort or {}
/*
JoeFort
JoeFort.structs
*/

surface.CreateFont( "JoeFort30", {
	font = "Exo 2", 
	extended = false,
	size = 30,
} )

surface.CreateFont( "JoeFort40", {
	font = "Exo 2", 
	extended = false,
	size = 40,
} )

surface.CreateFont( "JoeFort50", {
	font = "Exo 2", 
	extended = false,
	size = 50,
} )

surface.CreateFont( "JoeFortclose", {
	font = "Arial", 
	extended = false,
	size = 50,
} )

local col1 = Color(134, 235, 255,255)
local col2 = Color(9, 125, 168, 100)
local col4 = Color(255, 0, 0, 255)

local frame
function JoeFort:OpenFortMenu(wep)
    if IsValid(frame) then frame:Remove() end
    frame = vgui.Create("DFrame")
    frame:SetSize(500, 700)
    frame:Center()
    frame:ShowCloseButton(false)
    frame:SetTitle("")
    frame:MakePopup()
    frame.Paint = function(s,w,h)
        surface.SetDrawColor(col2)
        surface.DrawRect(0, 0, w, h)
        surface.SetDrawColor(col1)
        surface.DrawOutlinedRect(0, 0, w, h, 3)

        surface.SetDrawColor(col2)
        surface.DrawRect(50, 25, 400, 50)
        surface.SetDrawColor(col1)
        surface.DrawOutlinedRect(50, 25, 400, 50, 3)
        draw.SimpleText("Structures:", "JoeFort50", 250, 22.5, col1, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

        surface.SetDrawColor(col2)
        surface.DrawRect(3, 647, 494, 50)
        surface.SetDrawColor(col1)
        surface.DrawRect(3, 644, 494, 3)
        draw.SimpleText("Current Resources: " .. JoeFort.Ressources, "JoeFort40", 250, 650, col1, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
    end

    local clsbtn = vgui.Create("DButton", frame)
    clsbtn:SetSize(25, 25)
    clsbtn:SetPos(467,8)
    clsbtn:SetText("")
    clsbtn.DoClick = function()
        frame:Remove()
    end
    clsbtn.Paint = function(s,w,h)
        draw.SimpleText("X", "DermaLarge", 12.5, 12.5, col4, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    local dlist = vgui.Create("DScrollPanel", frame)
    dlist:SetSize(500, 540)
    dlist:GetVBar():SetSize(0,0)
    dlist:SetPos(0,100)
    dlist.Paint = function(s,w,h)
    end

    surface.SetFont("JoeFort30")
    for category,data in pairs(JoeFort.structs) do
        local sizex = surface.GetTextSize(category) + 50
        local cat = vgui.Create("DButton", dlist)
        cat:SetSize(sizex , 50)
        cat:Dock(TOP)
        cat:SetText("")
        local dist = (500 - sizex ) * 0.5
        cat:DockMargin(dist, 0, dist, 20)
        cat.Paint = function(s,w,h)
            if s:IsHovered() then
                surface.SetDrawColor(col1)
            else
                surface.SetDrawColor(col2)
            end
            surface.DrawRect(0, 0, w, h)
            surface.SetDrawColor(col1)
            surface.DrawOutlinedRect(0, 0, sizex, h, 3)
            draw.SimpleText(category, "JoeFort30", sizex * 0.5, 25, s:IsHovered() and col2 or col1, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
        cat.DoClick = function()
            if not IsValid(wep) or wep:GetClass() != "fort_datapad" then return end
            surface.PlaySound("buttons/button17.wav")
            wep.selectcat = category 
            wep.selectnum = 1
            wep.selectmdl = JoeFort.structs[category][1].model

            net.Start("JoeFort_updatedata")
            net.WriteEntity(wep)
            net.WriteString(category)
            net.SendToServer()
            frame:Remove()
        end
    end

end


function JoeFort:OpenAdminFortMenu()
    if IsValid(frame) then frame:Remove() end
    frame = vgui.Create("DFrame")
    frame:SetSize(400, 200)
    frame:Center()
    frame:ShowCloseButton(false)
    frame:SetTitle("")
    frame:MakePopup()
    frame.Paint = function(s,w,h)
        surface.SetDrawColor(col2)
        surface.DrawRect(0, 0, w, h)
        surface.SetDrawColor(col1)
        surface.DrawOutlinedRect(0, 0, w, h, 3)

        draw.SimpleText("Current Resources: " .. JoeFort.Ressources, "JoeFort30", 20, 10, col1, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
    end

    local text = vgui.Create("DTextEntry", frame)
    text:SetSize(100, 40)
    text:SetPos(150,60)
    text:SetFont("JoeFort30")
    text:SetNumeric(true)
    text.Paint = function(s,w,h)
        surface.SetDrawColor(col2)
        surface.DrawRect(0, 0, w, h)
        surface.SetDrawColor(col1)
        surface.DrawOutlinedRect(0, 0, w, h, 3)
        s:DrawTextEntryText(col1, col2, col2)
    end

    local clsbtn = vgui.Create("DButton", frame)
    clsbtn:SetSize(25, 25)
    clsbtn:SetPos(367,8)
    clsbtn:SetText("")
    clsbtn.DoClick = function()
        frame:Remove()
    end
    clsbtn.Paint = function(s,w,h)
        draw.SimpleText("X", "DermaLarge", 12.5, 12.5, col4, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    local btn = vgui.Create("DButton", frame)
    btn:SetSize(100, 40)
    btn:SetPos(150,120)
    btn:SetText("")
    btn.DoClick = function()
        local val = text:GetValue()
        if not val or val == "" then return end
        val = tonumber(val)
        if val == 0 then return end
        
        net.Start("JoeFort_updateresourcepool")
        net.WriteInt(val, 32)
        net.SendToServer()
        
        frame:Remove()
    end
    btn.Paint = function(s,w,h)
        if s:IsHovered() then
            surface.SetDrawColor(col1)
        else
            surface.SetDrawColor(col2)
        end
        surface.DrawRect(0, 0, w, h)
        surface.SetDrawColor(col1)
        surface.DrawOutlinedRect(0, 0, w, h, 3)
        draw.SimpleText("SEND", "JoeFort30", w * 0.5, h * 0.5, s:IsHovered() and col2 or col1, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

    end
end

net.Receive("JoeFort_updateresourcepool", function()
    JoeFort.Ressources = net.ReadInt(32)
end)

net.Receive("JoeFort_UpdateTime", function()
    local ent = net.ReadEntity()
    local int = net.ReadInt(32)
    if not IsValid(ent) then return end
    ent.buildtime = int
end)

--addons/wos-passiveevent-ageo/lua/wos/pes/vars/boolean.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Boolean"

VAR.IsValid = function(varTable, value)
    if not isbool(value) then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local button = vgui.Create("DButton")
    button.Pressed = value

    local activeText = varTable.ActiveText or "Yes"
    local inactiveText = varTable.InactiveText or "No"

    button:SetText(button.Pressed and activeText or inactiveText)
    button.DoClick = function(pan)
        button.Pressed = not button.Pressed
        pan:SetText(button.Pressed and activeText or inactiveText)
    end

    return button
end

VAR.GetValue = function(button)
    return button.Pressed
end


return VAR
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/bounds.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--



local VAR = {}
VAR.Name = "Bounds"
VAR.DirtyValidate = true
VAR.UseTool = true

VAR.ToolTips = {
    { text = "Add the position you are AIMING AT as a boundary point", key = "gui/lmb.png", },
    { text = "Add your current EYE position as a boundary point", key = "gui/lmb.png", key2 = "gui/e.png", },
    { text = "Add your current STANDING position as a boundary point", key = "gui/lmb.png", key2 = "icon16/control_fastforward.png", },
    { text = "Remove the last added position from the boundary points", key = "gui/rmb.png", },
}

VAR.IsValid = function(varTable, value)
    if table.Count(value) < 1 then return false end

    for index, vec in ipairs(value) do
        if not isvector( vec ) then
            return false
        end
    end

    return true
end



VAR.DermaElement = function(varTable, value)
    if not istable(value) then value = {} end
    local dermaElement = vgui.Create("DPanel")
    dermaElement.Corners = value.Corners or {}

    local heightSelector = vgui.Create("DNumberWang", dermaElement)
    heightSelector:DockMargin(6,2,6,2)
    heightSelector:SetTall(30)
    heightSelector:Dock(LEFT)
    heightSelector:SetDecimals(0)
    heightSelector:SetMin( minCount or 1 )
    heightSelector:SetMax( maxCount or math.huge )
    heightSelector:SetValue(value.Height or 200)
    dermaElement.HeightSelector = heightSelector

    function dermaElement:PerformLayout(ww, hh)
        heightSelector:SetWide(ww * 0.25)
    end
    function dermaElement:Paint(ww, hh)
        draw.SimpleText("Height", nil, ww * 0.45, hh * 0.5, Color(0,0,0), TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

        draw.SimpleText("|", nil, ww * 0.5, hh * 0.5, Color(0,0,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

        draw.SimpleText("Corners: " .. #(dermaElement.Corners), nil, ww * 0.55, hh * 0.5, Color(0,0,0), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    return dermaElement
end

VAR.GetValue = function(dermaElement)
    -- Return Debug Format Template
    local value = {
        Corners = dermaElement.Corners or {},
        Height = math.floor(dermaElement.HeightSelector:GetValue()),
    }

    -- Prepare values for more effiecient use.
    value.PreparedBorderValues = {}
    for i, borderPoint in pairs(value.Corners) do
        value.PreparedBorderValues[i] = {
            v = borderPoint
        }
    end

    local j = table.Count(value.Corners)
    for i=1, table.Count(value.Corners) do
        local borderI = value.PreparedBorderValues[i].v
        local borderJ = value.PreparedBorderValues[j].v

        if borderJ.y == borderI.y then
            value.PreparedBorderValues[i].c = borderI.x
            value.PreparedBorderValues[i].m = 0
        else
            value.PreparedBorderValues[i].c = borderI.x - (borderI.y * borderJ.x) / (borderJ.y - borderI.y) + (borderI.y * borderI.x) / (borderJ.y - borderI.y)
            value.PreparedBorderValues[i].m = (borderJ.x - borderI.x) / (borderJ.y - borderI.y);
        end

        j = i
    end

    return value
end

VAR.PrimaryAttack = function(wep, ply, dermaElement)
    local pos =  ply:GetEyeTrace().HitPos
    if ply:KeyDown( IN_SPEED ) then
        pos = ply:GetPos()
    elseif ply:KeyDown( IN_USE ) then
        pos = ply:EyePos()
    end
    local allowed = hook.Call( "wOS.CombatSim.CanPlaceEntity", nil, wep, ply, pos )
    if isbool( allowed ) and allowed == false then return end
    table.insert(dermaElement.Corners, pos )
end

VAR.SecondaryAttack = function(wep, ply, dermaElement)
    dermaElement.Corners[#(dermaElement.Corners)] = nil
end

VAR.OnStart = function(node, varData, var)

end

VAR.OnEnd = function(node, varData, var)

end

local function DrawBorders(points, height, color)
	local prev = nil
	local prevtop = nil
	local first = nil
	local firsttop = nil

	for _, vec in pairs(points) do
		if not first then first = vec end

		local top = Vector(vec.x, vec.y, first.z + height)
		vec.z = first.z
		if not firsttop then firsttop = top end

		render.DrawLine(vec, top, color, false)

		if prev then
			render.DrawLine(vec, prev, color, false)
		end

		if prevtop then
			render.DrawLine(top, prevtop, color, false)
		end

		prevtop = top
		prev = vec
	end

	if prev and first then
		render.DrawLine(prev, first, color, false)
	end
	if prevtop and firsttop then
		render.DrawLine(prevtop, firsttop, color, false)
	end
end

VAR.Draw3D = function(wep, ply, element)
    DrawBorders(element.Corners, element.HeightSelector:GetValue(), Color(255, 255, 255))
end

return VAR

--addons/wos-passiveevent-ageo/lua/wos/pes/vars/tvector.lua:
--[[-------------------------------------------------------------------]]--[[
                            
Copyright wiltOS Technologies LLC, 2021

Contact: www.wiltostech.com
    
----------------------------------------]]--


local VAR = {}

VAR.Name = "TableVector"
VAR.UseTool = true
VAR.DirtyValidate = true

VAR.ToolTips = {
    { text = "Add the position you are AIMING AT to the list", key = "gui/lmb.png", },
    { text = "Add your current EYE position to the list", key = "gui/lmb.png", key2 = "gui/e.png", },
    { text = "Add your current STANDING position to the list", key = "gui/lmb.png", key2 = "icon16/control_fastforward.png", },
    { text = "Remove the last added position from the list", key = "gui/rmb.png", },
}

VAR.IsValid = function(varTable, value)
    if not istable( value ) then return false end
    if table.Count(value) == 0 then return false end

    for index, vec in ipairs(value) do
        if not isvector( vec ) then
            return false
        end
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local panel = vgui.Create("DPanel")
    panel:SetTall( 180 )
    panel.Values = value

    function panel:Paint(ww, hh) end

    local listView = vgui.Create("DListView", panel)
    listView:Dock( FILL )
    listView:AddColumn("Vector")
    listView.RefreshList = function( pan )
        pan:Clear()
        if not panel.Values or #panel.Values < 1 then
            pan:AddLine( "Vector needs to be set!" )
            return
        end

        for id, vec in pairs( panel.Values or {} ) do
            local line = pan:AddLine( vec )
            line.ID = id
        end
        
    end

    listView.OnRowRightClick = function( pan, id, line )
        table.remove( panel.Values, line.ID )
        pan:RefreshList()
    end

    listView:RefreshList()
    panel.RefreshList = function() listView:RefreshList() end

    return panel
end

VAR.GetValue = function(panel)
    return panel.Values || {}
end

VAR.PrimaryAttack = function(wep, ply, panel)
    local pos =  ply:GetEyeTrace().HitPos
    if ply:KeyDown( IN_SPEED ) then
        pos = ply:GetPos()
    elseif ply:KeyDown( IN_USE ) then
        pos = ply:EyePos()
    end
    local allowed = hook.Call( "wOS.CombatSim.CanPlaceEntity", nil, wep, ply, pos )
    if isbool( allowed ) and allowed == false then return end
    panel.Values = panel.Values || {}
    panel.Values[#panel.Values + 1] = pos
    panel:RefreshList()
end

VAR.SecondaryAttack = function(wep, ply, panel)
    panel.Values = panel.Values || {}
    panel.Values[#panel.Values] = nil
end

VAR.OnStart = function(node, value, var)

    local val  = {}

    for index, vec in ipairs(value) do
        if !isvector(vec) then

            vec = Vector(vec)
            if vec then
                val[index] = vec
                continue
            end
        end
        val[index] = vec
    end
    node:SetVar(var.Name, val)
end

VAR.Draw3D = function(wep, ply, element)
    local tVec = element.Values || {}
    for index, vec in ipairs(tVec) do
        if not isvector(vec) then continue end

        local top = Vector(vec.x, vec.y, vec.z + 200)
        render.DrawLine(vec, top, Color(255, 255, 255), false)
    end
end


return VAR

--addons/wos-passiveevent-ageo/lua/wos/pes/core/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































wOS = wOS || {}
wOS.PES = wOS.PES || {}
wOS.PES.Triggers = wOS.PES.Triggers || {}
wOS.PES.Triggers.Data = wOS.PES.Triggers.Data || {}
wOS.PES.Nodes = wOS.PES.Nodes || {}
wOS.PES.Nodes.Data = wOS.PES.Nodes.Data || {}

if wOS.PES.GetActiveMenu then return end

surface.CreateFont( "wOS.PES.NodeText", {
	font = "Arial",
	extended = true,
	size = 25*(ScrH()/1200),
	weight = 1300,
} )

surface.CreateFont( "wOS.PES.CategoryText", {
	font = "Arial",
	extended = true,
	size = 20*(ScrH()/1200),
	weight = 1300,
} )

local nodeMenu
local mainMenu
local missionMenu

local currentPanel

local editingNode
local editingVar

function wOS.PES:GetEditingVar()
    return editingVar
end

function wOS.PES:SetEditingVar(node, varTable)
    local parent = self:GetNodeMenu()
    if not parent then return end
    editingVar = node.varDerma[varTable.Name]
    editingNode = node
    parent:Hide()
end

function wOS.PES:SetActiveMenu( pan )
    currentPanel = pan
end

function wOS.PES:GetActiveMenu()
    return currentPanel
end

function wOS.PES:SetNodeMenu( pan )
    nodeMenu = pan
end

function wOS.PES:GetNodeMenu()
    return nodeMenu
end

function wOS.PES:IsEditingVar()
    local curr_pan = self:GetActiveMenu()
    local nmenu = self:GetNodeMenu()
    local evar = self:GetEditingVar()
    return IsValid( evar ) and IsValid( nmenu ) and curr_pan == nmenu
end

// The entry point into the menus
function wOS.PES:OpenMenu()
    if self:IsEditingVar() then
        local element = wOS.PES:GetEditingVar()
        local varTable = element.varTable
        local varType = wOS.PES.Vars:Get(varTable.Type)
        if varType then
            local value = varType.GetValue(element)
            if value != nil then
                editingNode:SetVar(varTable.Name, value)
            end
        end
    end

    local cur_pan = self:GetActiveMenu()
    if IsValid(cur_pan) then
        if cur_pan.menu then
            if not cur_pan.menu.CreationType or cur_pan.menu.CreationType == WOS_PES.CREATOR.EVENT then 
                cur_pan:Show()
                return
            end
        end
        cur_pan:Remove()
    end

    wOS.PES:OpenMainMenu()
end

// This is the first menu that is shown or the fallback
function wOS.PES:OpenMainMenu()
    if IsValid(mainMenu) then
        mainMenu:Show()
    else
        local pnl = vgui.Create("DFrame")
        pnl:SetTitle( "PES Toolgun" )
        pnl:SetSize(256,512)
        pnl:Center()
        pnl:MakePopup()
        pnl:SetDraggable(false)

        local startMission = vgui.Create("DButton", pnl)
        startMission:SetHeight(128)
        startMission:SetText("Start Event")
        startMission:Dock(TOP)
        startMission:DockPadding(0,3,0,0)
        startMission.DoClick = function()
            mainMenu:Hide()
            wOS.PES:OpenMissionMenu()
        end

        local makeEvent = vgui.Create("DButton", pnl)
        makeEvent:SetHeight(128)
        makeEvent:Dock(TOP)
        makeEvent:DockPadding(0,3,0,3)
        makeEvent:SetText("List Events")

        makeEvent.DoClick = function()
            mainMenu:Hide()
            wOS.PES:OpenNodeMenu()
        end

		local adminMenu = vgui.Create("DButton", pnl)
		adminMenu:SetHeight(128)
		adminMenu:Dock(TOP)
		adminMenu:DockPadding(0,3,0,3)
		adminMenu:SetText("Admin Menu")

		adminMenu.DoClick = function()
			wOS.PES:OpenAdminList()
		end

        mainMenu = pnl
    end

    self:SetActiveMenu( mainMenu )
end

local makeEventButton = function(name, parent)

    local info = vgui.Create("DButton", parent)
    info:SetText(name)
    info:Dock(TOP)
    info:DockMargin(0, 0, 0, 10)

    info.Think = function( pan )
		if name == "+" then return end
        if not IsValid(parent) then return end
        if not parent.MissionName then return end
        if parent.MissionName[name] then return end
        pan:Remove()
    end

    info.DoClick = function( pan )
       parent.EventName = name
    end

    return info
end

// This is the admin selection menu
function wOS.PES:OpenAdminList()
    local cur_pan = self:GetActiveMenu()
	if IsValid(cur_pan) then
		cur_pan:Remove()
	end

	local pnl = vgui.Create("DFrame")
	pnl:SetTitle( "PES Toolgun" )
	local size = ScrH()*(512/1080)
	pnl:SetSize(size/2, size)
	pnl:Center()
	pnl:MakePopup()
    pnl:SetDraggable(false)
	
	self:SetActiveMenu( pnl )

    local startMission = vgui.Create("DButton", pnl)
    startMission:SetHeight(128)
    startMission:SetText("PES Admin Settings")
    startMission:Dock(TOP)
    startMission:DockPadding(0,3,0,0)
    startMission.DoClick = function()
        pnl:Hide()
        self:SetActiveMenu( self:OpenAdminSettings() )
    end

    local makeEvent = vgui.Create("DButton", pnl)
    makeEvent:SetHeight(128)
    makeEvent:Dock(TOP)
    makeEvent:DockPadding(0,3,0,3)
    makeEvent:SetText("List Scheduled Events")

    makeEvent.DoClick = function()
        pnl:Hide()
        self:SetActiveMenu( self:OpenScheduledMenu() )
    end

    local adminMenu = vgui.Create("DButton", pnl)
    adminMenu:SetHeight(128)
    adminMenu:Dock(TOP)
    adminMenu:DockPadding(0,3,0,3)
    adminMenu:SetText("Event Viewer")

    adminMenu.DoClick = function()
        wOS.PES.RequestOpenAdminPreMenu()
    end

end

function wOS.PES:OpenAdminActiveList( events )

    local cur_pan = self:GetActiveMenu()
	if IsValid(cur_pan) then
		cur_pan:Remove()
	end

    local bw, bh = ScrW()*0.27, ScrH()*0.25

	local base = vgui.Create("DFrame")
	base:SetSize( bw, bh )
	base:Center()
	base:MakePopup()
	base:SetDraggable(false)
	base:SetTitle("")
	base:ShowCloseButton(false)
	base.Paint = function(self, w, h)
		surface.SetDrawColor(35.5,35.5,35.5)
		surface.DrawRect(0,0, w, h)

        draw.SimpleText("Currently Running Events", "wOS.PES.NodeText", w*0.02, h*0.04, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end

	local close = vgui.Create("DButton", base)
	close:SetSize(bh*0.08,bh*0.08)
	close:SetPos(bw - bh*0.087, 0)
	close:SetText("")
	close.Paint = function(self, w, h)
		local col = Color(255, 255, 255, (self.Hovered and 255) or 150)
        surface.SetDrawColor(col)
		surface.DrawLine(0,0, w, h)
		surface.DrawLine(w,0, 0, h)
    end
	close.DoClick = function() base:Remove() end

	self:SetActiveMenu( base )

    local tabsheet = vgui.Create( "DPropertySheet", base )
    tabsheet:Dock( FILL )

    local manual_sheet = vgui.Create( "DScrollPanel", tabsheet )
    //manual_sheet.Paint = function( self, w, h ) draw.RoundedBox( 4, 0, 0, w, h, Color( 0, 128, 255, self:GetAlpha() ) ) end 
    tabsheet:AddSheet( "Manual Events", manual_sheet, "icon16/joystick.png" )

    local random_sheet = vgui.Create( "DScrollPanel", tabsheet )
    //random_sheet.Paint = function( self, w, h ) draw.RoundedBox( 4, 0, 0, w, h, Color( 255, 128, 0, self:GetAlpha() ) ) end 
    tabsheet:AddSheet( "Random Events", random_sheet, "icon16/arrow_switch.png" )

    local sched_sheet = vgui.Create( "DScrollPanel", tabsheet )
    //sched_sheet.Paint = function( self, w, h ) draw.RoundedBox( 4, 0, 0, w, h, Color( 0, 128, 255, self:GetAlpha() ) ) end 
    tabsheet:AddSheet( "Scheduled Events", sched_sheet, "icon16/clock.png" )

    local sim_sheet = vgui.Create( "DScrollPanel", tabsheet )
    //sim_sheet.Paint = function( self, w, h ) draw.RoundedBox( 4, 0, 0, w, h, Color( 255, 128, 0, self:GetAlpha() ) ) end 
    tabsheet:AddSheet( "Simulations", sim_sheet, "icon16/computer.png" )

    for id, dat in pairs( events ) do
        local name = dat[1]
        local etype = dat[2]
        local sim = dat[3]

        if sim then
            sim = sim .. " - "
        else
            sim = ""
        end

        local ebutton = vgui.Create( "DButton" )
        ebutton.ID = id 
        ebutton.Name = sim .. name
        ebutton.Type = etype
        ebutton:SetText( ebutton.Name )
        -- ebutton.Paint = function( pan, ww, hh )

        -- end
        ebutton.DoClick = function( pan )
            wOS.PES.RequestOpenAdminViewer( pan.ID )
        end

        if etype == WOS_PES.EVENT.MANUAL then
            manual_sheet:AddItem( ebutton )
        elseif etype == WOS_PES.EVENT.RANDOM then
            random_sheet:AddItem( ebutton )
        elseif etype == WOS_PES.EVENT.SCHEDULED then
            sched_sheet:AddItem( ebutton )
        elseif etype == WOS_PES.EVENT.SIMULATION then
            sim_sheet:AddItem( ebutton )
        else
            ebutton:Remove()
            continue
        end
        ebutton:Dock( TOP )
        ebutton:DockMargin( 0, 0, 0, 5 )
    end

    -- local dum_sheet = vgui.Create( "DScrollPanel", tabsheet )
    -- dum_sheet.Paint = function( self, w, h ) draw.RoundedBox( 4, 0, 0, w, h, Color( 0, 128, 255, self:GetAlpha() ) ) end 
    -- tabsheet:AddSheet( "Quests", dum_sheet, "icon16/wand.png" )
end

// Admin viewer of current event
function wOS.PES:OpenAdminEventViewer( id, nodes )
    local cur_pan = self:GetActiveMenu()
	if IsValid(cur_pan) then
		cur_pan:Remove()
	end

	local base = vgui.Create("DFrame")
	base:SetSize(ScrW(), ScrH())
	base:Center()
	base:MakePopup()
	base:SetDraggable(false)
	base:SetTitle("")
	base:ShowCloseButton(false)
	base.Paint = function(self, w, h)
		surface.SetDrawColor(35.5,35.5,35.5)
		surface.DrawRect(0,0, w, h)
	end
	local close = vgui.Create("DButton", base)
	close:SetSize(20,20)
	close:SetPos(ScrW()-20, 0)
	close:SetText("")
	close.Paint = function(self, w, h)
		local col = Color(255, 255, 255, (self.Hovered and 255) or 150)
        surface.SetDrawColor(col)
		surface.DrawLine(0,0, w, h)
		surface.DrawLine(w,0, 0, h)
    end
	close.DoClick = function() base:Remove() end

	local mini = vgui.Create("DButton", base)
	mini:SetSize(20,20)
	mini:SetPos(ScrW()-45, 0)
	mini:SetText("")
	mini.Paint = function(self, w, h)
		local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

		surface.SetDrawColor(col)
		surface.DrawLine(0,h/2, w, h/2)
	end
	mini.DoClick = function() base:Hide() end


	base.menu = vgui.Create("WOS_PES_ViewNodeBG", base)
    local menu = base.menu
    
	menu:Dock(FILL)
    menu:DockMargin(0,0,0,0)
    

	local but = vgui.Create("DButton", base)
	but:SetPos(base:GetWide() - 100, 60)
	but:SetSize(90, 40)
	but:SetText("Stop Current Event")
	but.DoClick = function()
		wOS.PES.RequestStop( id )
        close:DoClick()
	end

	for index, data in ipairs(nodes) do
		local button = menu:AddNode( id )
		button.Links = data.Links
		button.Active = data.Active
		button.Type = data.Type
		button:SetPos(data.Pos.x, data.Pos.y)
		button:SetText("")
        button.TextName = data.Name

	    button:FormLinks()
	end

	self:SetActiveMenu( base )

    // Added some cleansing to the timer so we don't have it residually there
    // Also forced it to close the menu through the close button if the case of no data
	timer.Create("wOS.PES.Admin.Sync", 1, 0, function()

        local cur_pan = wOS.PES:GetActiveMenu()
        if !IsValid(cur_pan) then timer.Destroy( "wOS.PES.Admin.Sync") return end
        if !cur_pan.menu then timer.Destroy( "wOS.PES.Admin.Sync") return end
        if not cur_pan.menu.CreationType then timer.Destroy( "wOS.PES.Admin.Sync") return end 
        if cur_pan.menu.CreationType != WOS_PES.CREATOR.EVENT then timer.Destroy( "wOS.PES.Admin.Sync") return end

        wOS.PES.RequestAdminSync(id, function(len)
            local nodes = net.ReadActivePESEvent()
            if #nodes <= 0 then
                for index, node in pairs(menu.Nodes) do
                    node:Remove()
                end
                timer.Destroy( "wOS.PES.Admin.Sync") 
                close:DoClick()
                return 
            end
            if not menu then return end
            if not menu.Nodes then return end
            for index, data in pairs(nodes) do
                if not IsValid(menu.Nodes[index]) then continue end
                menu.Nodes[index].Active = data.Active
            end
        end)
	end)
end

// Build editor menu
function wOS.PES:OpenNodeMenu( event, dirty, force_reset )
	local nMenu = wOS.PES:GetNodeMenu()
    if IsValid(nMenu) then
        if not event and not force_reset then
            nMenu:Show()
            self:SetActiveMenu( nMenu )
            return
        else
            nMenu:Remove()
        end
    end

    local base = vgui.Create("DFrame")
    base:SetSize(ScrW(), ScrH())
    base:Center()
    base:MakePopup()
    base:SetDraggable(false)
    base:SetTitle("")
    base:ShowCloseButton(false)
    base:SetZPos( 5 )
    base.Paint = function(self, w, h)
        surface.SetDrawColor(35.5, 35.5, 35.5)
        surface.DrawRect(0,0, w, h)
    end

    local close = vgui.Create("DButton", base)
    close:SetSize(20,20)
    close:SetPos(ScrW()-20, 0)
    close:SetText("")
    close:SetZPos( 10 )
    close.Paint = function(self, w, h)
        local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

        surface.SetDrawColor(col)
        surface.DrawLine(0,0, w, h)
        surface.DrawLine(w,0, 0, h)
    end
    close.DoClick = function() hook.Call( "wOS.PES.OnCreatorClose", nil, WOS_PES.CREATOR.EVENT ) base:Remove() end

    local mini = vgui.Create("DButton", base)
    mini:SetSize(20,20)
    mini:SetPos(ScrW()-45, 0)
    mini:SetText("")
    mini:SetZPos( 10 )
    mini.Paint = function(self, w, h)
        local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

        surface.SetDrawColor(col)
        surface.DrawLine(0,h/2, w, h/2)
    end
    mini.DoClick = function() base:Hide() end

    local scroll = vgui.Create("DScrollPanel", base)
    scroll:SetWide(100)
    scroll:SetTall( base:GetTall() )
    scroll:Dock(LEFT)
    scroll:DockPadding(5,5,5,5)
	scroll:DockMargin(16,16,16,16)
    scroll:SetZPos( 10 )
    scroll.Paint = function( pan, ww, hh )
		draw.RoundedBox(4, 0, 0, ww, hh, Color(0, 0, 0, 150))
		draw.RoundedBox(4, 4, 4, ww-8, hh-8, Color(36,36,36))
		draw.RoundedBox(4, 4, 4, ww-8, hh-8, Color(255,255,255,100))
    end
    base.scroll = scroll

	local menu = vgui.Create("WOS_PES_NodeBG", base)
	menu:Dock(FILL)
	menu:DockMargin(0,0,0,0)
	base.menu = menu

    if not event then
	    local start = menu:CreateStartNode()
    else
        menu.Importable = event.Importable
        menu.Name = event.Name
        menu.Description = event.Description
        menu.random = event.random
        menu.DirtyNodes = dirty

        for index, node in pairs(event.Nodes) do
            
            local pNode
            if index == 1 then
                pNode = menu:CreateStartNode()
            else
                pNode = menu:AddNode()
                pNode.Type = node.Type
            end

            pNode:SetPos(node.Pos.x, node.Pos.y )
            
            if pNode.Type != node.Type then continue end
            pNode:SetVars(node._vars, dirty)
		    pNode:SetDisableVars(node._toggles, dirty)
        end

        for index, node in pairs(event.Nodes) do
            if node.Triggers then
                for triggerName, panelTable in pairs(node.Triggers) do
                    for _, otherID in pairs(panelTable) do
                        local pnl, oPnl = menu.Nodes[index], menu.Nodes[otherID]
                        menu:MakeLink(pnl, oPnl, triggerName)
                    end
                end
            end
        end

        for _, node in pairs(menu.Nodes) do
            node:CreateLinks()
        end
    end

    local info = vgui.Create("DButton", base.scroll)
    info:SetText("Event Manager")
    info:Dock(TOP)
    info:DockMargin(0, 0, 0, 10)
    info.DoClick = function()
        wOS.PES.GetImportableEvents( function( events )
            local menu = base.menu
            if not menu then return end
            local tot = {}
            for _, data in pairs( events ) do
                data.Category = data.Category or "Event"
                table.insert( tot, data )
            end
            wOS.PES.GetImportableSimulations( function( sims )
                for _, data in pairs( sims ) do
                    data.Category = data.Category or "Simulation"
                    data.IsSimulation = true
                    data.Settings = nil
                    table.insert( tot, data )
                end
                menu:OpenEventSelector( tot )
            end )
        end, true )
    end

    if event then
        local delin = vgui.Create("DButton", base.scroll)
        delin:SetText("Delete Event")
        delin:Dock(TOP)
        delin:DockMargin( 0, 0, 0, 10 )
        delin.DoClick = function()
            menu:OpenEventDeleter()
        end
    end

    self:SetNodeMenu( base )
    self:SetActiveMenu( base )
end
// Starting an event
function wOS.PES:OpenMissionMenu()
    if IsValid(missionMenu) then
        missionMenu:Show()
        missionMenu:RequestUpdate()
    else
        local hh = ScrH() * 0.4

        local base = vgui.Create("DFrame")
        base:SetTitle( "Mission Menu" )
        base:SetSize(200 + 100, hh)
        base:Center()
        base:MakePopup()
        base:SetDraggable(false)

		base.Paint = function(self, w, h)
			surface.SetDrawColor(0,0,0)
			surface.DrawRect(0,0, w,h)
			if base.scroll and base.scroll.EventName then
				draw.SimpleText(base.scroll.EventName, "DermaDefault", w * 0.3, 10 )
			end
		end

        local scrollpanel = vgui.Create("DScrollPanel", base)
        scrollpanel:SetSize(180, hh - 30)
        scrollpanel:SetPos(10, 30)
        wOS.PES.RequestEventList(function(missionNames)
            base.scroll.MissionName = {}
            for index, name in pairs(missionNames) do
                makeEventButton(name, base.scroll)
                base.scroll.MissionName[name] = true
            end
        end)

		-- instant

		local button = vgui.Create("DButton", base)
		button:SetText("Start Now")
		button:SetSize(80, 30)
		button:SetPos(210, 30)
		button.DoClick = function()
			if base.scroll.EventName then
				wOS.PES.RequestEventStart(base.scroll.EventName)
			end
		end

		local timeStart = vgui.Create("DButton", base)
		timeStart:SetPos(210, 110)
		timeStart:SetSize(80, 30)
		timeStart:SetText("Schedule Later")

		timeStart.DoClick = function()
			if not base.scroll.EventName then return end
			local pnl = vgui.Create("DFrame")
			pnl:SetSize(ScrW()*0.5, ScrH() * 0.5)
			pnl:Center()
			pnl:MakePopup()
            pnl:SetTitle( "Event Scheduler" )
			pnl.Think = function( pan )
				pan:MoveToFront()
			end

			local calendar = vgui.Create("wOSCalendar", pnl)
			calendar:Dock(FILL)

			local confirm = vgui.Create("DButton", pnl)
			confirm:Dock(BOTTOM)
			confirm:DockMargin(5,5,5,5)
			confirm:SetTall(40)
			confirm:SetText("Start Event")
			confirm.DoClick = function( pan )
				wOS.PES.RequestEventStartTime(base.scroll.EventName, calendar:GetTime() )
				base:Remove()
				pan:Remove()
			end
		end

        base.scroll = scrollpanel
        missionMenu = base

        function missionMenu:RequestUpdate()
            wOS.PES.RequestEventList(function(missionNames)
                local oldTable = table.Copy(missionMenu.scroll.MissionName)

                local newTable = {}

                for index, name in pairs(missionNames) do
                    if !oldTable[name] then
                        makeEventButton(name, missionMenu.scroll)
                    end
                    newTable[name] = true
                end
                missionMenu.scroll.MissionName = newTable
            end)
        end
    end
end


// Helper functions
local function charWrap(text, pxWidth)
    local total = 0

    text = text:gsub(".", function(char)
        total = total + surface.GetTextSize(char)

        if total >= pxWidth then
            total = 0
            return "\n" .. char
        end

        return char
    end)

    return text, total
end

function wOS.PES.WrapText(text, font, pxWidth)
    local total = 0

    surface.SetFont(font)

    local spaceSize = surface.GetTextSize(' ')
    text = text:gsub("(%s?[%S]+)", function(word)
            local char = string.sub(word, 1, 1)
            if char == "\n" or char == "\t" then
                total = 0
            end

            local wordlen = surface.GetTextSize(word)
            total = total + wordlen

            if wordlen >= pxWidth then
                local splitWord, splitPoint = charWrap(word, pxWidth - (total - wordlen))
                total = splitPoint
                return splitWord
            elseif total < pxWidth then
                return word
            end

            if char == ' ' then
                total = wordlen - spaceSize
                return '\n' .. string.sub(word, 2)
            end

            total = wordlen
            return '\n' .. word
        end)

    return text
end


hook.Add("PostDrawOpaqueRenderables", "wOS.CombatSim.EditingVar", function()
	local ply = LocalPlayer()

	local wep = ply:GetActiveWeapon()
    if not IsValid( wep ) then return end
	if wep:GetClass() != "wos_pes_tool" and wep:GetClass() != "wos_simulation_tool" then return end

    if not wOS.PES:IsEditingVar() then return end
    
    local element = wOS.PES:GetEditingVar()

    local varTable = element.varTable
    local varType = wOS.PES.Vars:Get(varTable.Type)
    if varType and varType.Draw3D then
        varType.Draw3D(wep, wep.Owner, element)
    end
end)
--addons/wos-passiveevent-ageo/lua/wos/pes/core/sh_net.lua:


function net.WriteActivePESEvent(event)
	if table.IsEmpty(event) then
		net.WriteUInt(0, 1)
	else
		net.WriteUInt(1, 1)
		net.WriteTable(event) // For now this is what we will go with but should optimise further than this
	end
end

// This exists because we want to be consistent under the hood, for when we optimise this packet
function net.ReadActivePESEvent() 
	local valid = net.ReadUInt(1)
	if valid == 1 then
		return net.ReadTable()
	else
		return {}
	end
end

function net.WritePESEventHeader(event, dirty)
	net.WriteString(event.Name)
	net.WriteString(event.Description or "No description available")
	net.WriteUInt(#event.Nodes, 32)
	net.WriteDouble(event.random or 0)
	net.WriteBool( event.Importable )
	net.WriteBool( dirty or false )
end

function net.ReadPESEventHeader()
	local event = {}
	event.Name = net.ReadString()
	event.Description = net.ReadString()
	event.NodeCount = net.ReadUInt(32)
	event.random = net.ReadDouble()
	event.Importable = net.ReadBool()
	event.Dirty = net.ReadBool()

	return event
end

function net.WriteCSSSimulationHeader( simdata, dirty )

	net.WriteTable( simdata.Settings )
	net.WriteBool( simdata.Importable )

end


function net.ReadCSSSimulationHeader()
	local sim = {}
	sim.Settings = net.ReadTable()
	sim.Importable = net.ReadBool()
	sim.Event = {}
	sim.Dirty = true
	
	return sim
end 

//////////////////////////////////////////////////////////////////////
--addons/billy_gas/lua/vgui/bvgui/categories.lua:
--/// bVGUI.Categories ///--

local PANEL = {}

function PANEL:Init()
	self.Categories = {}
	self.Items = {}

	self:Dock(LEFT)

	self.CategoriesContainer = vgui.Create("bVGUI.ScrollPanel", self)
	self.CategoriesContainer:Dock(FILL)

	self.DrawBackground = true
end

function PANEL:SetDrawBackground(draw_background)
	self.DrawBackground = draw_background
end

function PANEL:Paint(w,h)
	if (self.DrawBackground) then
		surface.SetDrawColor(bVGUI.COLOR_SLATE)
		surface.DrawRect(0,0,w,h)
	end

	self:LoadingPaint(w,h)
end

function PANEL:AddCategory(category_name, category_col)
	local this = self

	local category = vgui.Create("bVGUI.CategoriesCategory", self.CategoriesContainer)
	self.Categories[category_name] = category
	category:SetColor(category_col)
	category:SetText(category_name)
	category.ExistingItems = {}

	function category:AddItem(item_name, func, col, icon)
		if (category.ExistingItems[item_name]) then return end
		category.ExistingItems[item_name] = true
		local item = vgui.Create("bVGUI.CategoriesItem", self.ItemsContainer)
		table.insert(this.Items, item)
		item.ItemFunction = func
		item.Category = category
		item:SetText(item_name)
		if (col) then
			item:SetColor(col)
		else
			item:SetColor(category_col)
		end
		if (icon) then
			item:SetIcon(icon)
		end
		self.ItemsContainer:SizeToChildren(false, true)
		self.ItemsContainer:InvalidateParent(true)

		return item
	end

	function category:AddPlayer(ply, func, col, icon)
		local item = category:AddItem(ply:SteamID(), func, col, icon)
		if (not item) then return end
		item:SetAccountID(ply:AccountID())
	end

	function category:AddSteamID(steamid, func, col, icon)
		local item = category:AddItem(steamid, func, col, icon)
		if (not item) then return end
		print("deprecated AddSteamID", steamid)
		debug.Trace()
		item:SetAccountID(GAS:SteamIDToAccountID(steamid))
	end

	function category:AddAccountID(account_id, func, col, icon)
		local item = category:AddItem(GAS:AccountIDToSteamID(account_id), func, col, icon)
		if (not item) then return end
		item:SetAccountID(account_id)
	end

	function category:Clear()
		self.ExistingItems = {}
		local new_items = {}
		for i,v in pairs(this.Items) do
			if (v.Category == self) then
				v:Remove()
			else
				table.insert(new_items, v)
			end
		end
		this.Items = new_items
	end

	return category
end

function PANEL:RemoveItem(item)
	local item_category = item.Category

	item_category.ExistingItems[item.ItemName] = nil
	for i,v in ipairs(self.Items) do
		if (v == item) then
			table.remove(self.Items, i)
			break
		end
	end
	item:Remove()

	timer.Simple(0, function()
		if (item_category.Collapsed) then
			item_category.ItemsContainer:Stop()
			local y = 0
			for _,v in ipairs(item_category.ItemsContainer:GetChildren()) do
				y = y + v:GetTall()
			end
			item_category.ItemsContainer:SizeTo(item_category.ItemsContainer:GetWide(), y, 0.5)
		end
	end)
end

function PANEL:Clear()
	for _,v in ipairs(self.Items) do
		v:Remove()
	end
	for _,v in pairs(self.Categories) do
		v:Remove()
	end
	self.Categories = {}
	self.Items = {}
	self.CategoriesContainer:SetTall(0)
	self:InvalidateLayout(true)
	self.CategoriesContainer:InvalidateLayout(true)
end

function PANEL:EnableSearchBar(search_phrase)
	self.SearchBarContainer = vgui.Create("bVGUI.BlankPanel", self)
	self.SearchBarContainer:Dock(BOTTOM)
	self.SearchBarContainer:DockPadding(5,5,5,5)
	self.SearchBarContainer:SetTall(32)
	function self.SearchBarContainer:Paint(w,h)
		surface.SetDrawColor(bVGUI.COLOR_SLATE)
		surface.DrawRect(0,0,w,h)
	end

	self.SearchBarContainer.SearchBar = vgui.Create("bVGUI.TextEntry", self.SearchBarContainer)
	self.SearchBarContainer.SearchBar:Dock(FILL)
	self.SearchBarContainer.SearchBar:SetPlaceholderText(search_phrase or "Search...")
	function self.SearchBarContainer.SearchBar:OnChange()
		local search_text = self:GetText():lower()
		if (#search_text == 0) then
			for _,v in ipairs(self:GetParent():GetParent().Items) do
				v:SetVisible(true)
			end
		else
			for _,v in ipairs(self:GetParent():GetParent().Items) do
				if (v:GetText():lower():find(search_text,1,true)) then
					v:SetVisible(true)
				else
					v:SetVisible(false)
				end
			end
		end
		for _,v in pairs(self:GetParent():GetParent().Categories) do
			v.ItemsContainer:InvalidateLayout(true)
			v.ItemsContainer:SizeToChildren(false, true)
			v.ItemsContainer:InvalidateParent(true)
		end
	end
end

function PANEL:AddItem(item_name, func, col, icon)
	local item = vgui.Create("bVGUI.CategoriesItem", self)
	table.insert(self.Items, item)
	item.ItemFunction = func
	item.Category = category
	item:SetText(item_name)
	if (col) then
		item:SetColor(col)
	else
		item:SetColor(category_col)
	end
	if (icon) then
		item:SetIcon(icon)
	end

	return item
end

function PANEL:ClearActive()
	for _,v in ipairs(self.Items) do
		v:SetActive(false)
	end
end

derma.DefineControl("bVGUI.Categories", nil, PANEL, "bVGUI.LoadingPanel")

--/// bVGUI.CategoriesCategory ///--

local PANEL = {}

function PANEL:Init()
	self:SetTall(35)
	self:Dock(TOP)

	self.Collapsed = true
	self:SetCursor("up")

	self.CategoryColor = Color(0,0,0)
	self.CategoryName = ""

	self.CategoryNameLabel = vgui.Create("DLabel", self)
	self.CategoryNameLabel:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.CategoryNameLabel:SetText("")

	self.ItemsContainer = vgui.Create("DPanel", self:GetParent())
	self.ItemsContainer:SetTall(0)
	self.ItemsContainer:Dock(TOP)
	self.ItemsContainer.Category = self
	function self.ItemsContainer:Paint(w,h)
		surface.SetDrawColor(255,255,255,200)
		surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT_LARGE)
		surface.DrawTexturedRect(0,0,w,h)
	end
end

function PANEL:Paint(w,h)
	surface.SetDrawColor(self.CategoryColor)
	surface.DrawRect(0,0,w,h)

	surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT)
	surface.DrawTexturedRect(0,0,w,h)
end

function PANEL:SetColor(col)
	self.CategoryColor = col
	
	if (bVGUI.ColorShouldUseBlackText(col)) then
		self.CategoryNameLabel:SetTextColor(bVGUI.COLOR_BLACK)
	else
		self.CategoryNameLabel:SetTextColor(bVGUI.COLOR_WHITE)
	end
end
function PANEL:SetText(text)
	self.CategoryName = text
	self.CategoryNameLabel:SetText(self.CategoryName)
	self.CategoryNameLabel:SizeToContentsY()
	self.CategoryNameLabel:SetWide(self:GetParent():GetWide() - 5 - 10 - 10)
	self.CategoryNameLabel:CenterVertical()
	self.CategoryNameLabel:AlignLeft(5 + 10)
end
function PANEL:GetText()
	return self.CategoryName
end

function PANEL:OnMouseReleased(m)
	if (m ~= MOUSE_LEFT) then return end
	if (self.Collapsed) then
		self.Collapsed = not self.Collapsed
		self:SetCursor("hand")
		self.ItemsContainer:Stop()
		self.ItemsContainer:SizeTo(self.ItemsContainer:GetWide(), 0, 0.5)
	else
		self.Collapsed = not self.Collapsed
		self:SetCursor("up")
		self.ItemsContainer:Stop()
		local y = 0
		for _,v in ipairs(self.ItemsContainer:GetChildren()) do
			y = y + v:GetTall()
		end
		self.ItemsContainer:SizeTo(self.ItemsContainer:GetWide(), y, 0.5)
	end
end

function PANEL:PerformLayout()
	self.CategoryNameLabel:SizeToContentsY()
	self.CategoryNameLabel:SetWide(self:GetParent():GetWide() - 5 - 10 - 10)
	self.CategoryNameLabel:CenterVertical()
	self.CategoryNameLabel:AlignLeft(5 + 10)
end

derma.DefineControl("bVGUI.CategoriesCategory", nil, PANEL, "DPanel")

--/// bVGUI.CategoriesItem ///--

local PANEL = {}

function PANEL:Init()
	self:SetCursor("hand")
	self:SetTall(35)
	self:Dock(TOP)
	self:InvalidateParent(true)

	self.ItemName = ""
	self.ItemColor = bVGUI.COLOR_BLACK
	self.ItemColorDark = bVGUI.COLOR_BLACK

	self.ItemNameLabel = vgui.Create("DLabel", self)
	self.ItemNameLabel:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.ItemNameLabel:SetText("")
	self.ItemNameLabel:SetTextColor(bVGUI.COLOR_WHITE)

	self.CurrentBarX = 0
	self.Ceil = false
	self.AnimTime = CurTime()
end

function PANEL:SetIcon(path)
	self.Icon = vgui.Create("DImage", self)
	self.Icon:SetImage(path)
	self.Icon:SetSize(16, 16)
	self.Icon:AlignLeft(5 + 10)
	self.Icon:CenterVertical()

	self.ItemNameLabel:AlignLeft(5 + 10 + 16 + 5)
end

function PANEL:Paint(w,h)
	if (self:IsActive()) then
		self.CurrentBarX = Lerp(FrameTime() * 10, self.CurrentBarX, w)
	else
		self.CurrentBarX = Lerp(FrameTime() * 10, self.CurrentBarX, 5)
	end

	surface.SetDrawColor(self.ItemColor)
	surface.DrawRect(0, 0, 5, h)
	if (self.Ceil) then
		surface.SetDrawColor(self.ItemColorDark)
		surface.DrawRect(5, 0, math.ceil(self.CurrentBarX) - 5, h)
	else
		surface.SetDrawColor(self.ItemColorDark)
		surface.DrawRect(5, 0, math.floor(self.CurrentBarX) - 5, h)
	end
end

function PANEL:SetColor(col)
	self.ItemColor = col
	self.ItemColorDark = bVGUI.DarkenColor(self.ItemColor, 0.35)
end
function PANEL:SetText(text)
	self.ItemName = text
	self.ItemNameLabel:SetText(self.ItemName)
	self.ItemNameLabel:SizeToContentsY()
	self.ItemNameLabel:SetWide(self:GetParent():GetWide() - 5 - 10 - 10)
	self.ItemNameLabel:CenterVertical()
	self.ItemNameLabel:AlignLeft(5 + 10)
end
function PANEL:GetText()
	return self.ItemName
end

function PANEL:GetCategories()
	if (self:GetParent().Items) then
		return self:GetParent()
	elseif (self:GetParent():GetParent():GetParent():GetParent().Items) then
		return self:GetParent():GetParent():GetParent():GetParent()
	end
end

function PANEL:UpdateActiveState(active, forced_active)
	for _,v in pairs(self:GetCategories().Items) do
		v.Active = false
		v.AnimTime = CurTime()
		v.Ceil = false
	end
	self.AnimTime = CurTime()
	self.Active = active or false
	self.ForcedActive = forced_active or false
	self.Ceil = active or forced_active or false
end

function PANEL:IsActive()
	return self.Active or self.ForcedActive or false
end

function PANEL:SetForcedActive(forced_active)
	self:UpdateActiveState(self.Active, forced_active)
end

function PANEL:SetActive(active)
	self:UpdateActiveState(active, self.ForcedActive)
end

function PANEL:OnMouseReleased(m)
	if (m == MOUSE_LEFT) then
		self:SetActive(true)
		if (self.ItemFunction) then
			if (self.AccountID) then
				self.ItemFunction(self.AccountID)
			else
				self.ItemFunction()
			end
		end
	elseif (m == MOUSE_RIGHT and self.AccountID) then
		bVGUI.PlayerTooltip.Focus()
	end
end

function PANEL:PerformLayout()
	self.ItemNameLabel:SizeToContentsY()
	self.ItemNameLabel:CenterVertical()

	local item_name_label_left = 5 + 10
	local item_name_label_wide = self:GetParent():GetWide() - 5 - 10 - 10
	if (IsValid(self.AvatarImage)) then
		self.AvatarImage:AlignLeft(5)
		self.AvatarImage:CenterVertical()
		item_name_label_left = item_name_label_left + 35
		item_name_label_wide = item_name_label_wide - 35
	end
	if (IsValid(self.Icon)) then
		item_name_label_left = item_name_label_left + 16 + 10
		item_name_label_wide = item_name_label_wide - (16 + 10)
	end
	self.ItemNameLabel:AlignLeft(item_name_label_left)
	self.ItemNameLabel:SetWide(item_name_label_wide)
end

function PANEL:SetAccountID(account_id)
	self.AccountID = account_id
	self.AvatarImage = vgui.Create("AvatarImage", self)
	self.AvatarImage:SetSize(35,35)
	self.AvatarImage:SetSteamID(GAS:AccountIDToSteamID64(account_id), 32)
	self.AvatarImage:SetMouseInputEnabled(false)
	local this = self
	GAS.OfflinePlayerData:AccountID(account_id, function(success, data)
		if (not success) then
			this:SetText(GAS:AccountIDToSteamID(account_id))
		else
			this:SetText(data.nick)
		end
	end)
end

function PANEL:SetSteamID64(steamid64)
	print("SetSteamID64 deprecated", steamid64)
	return self:SetAccountID(GAS:SteamID64ToAccountID(steamid64))
end

function PANEL:OnCursorEntered()
	if (self.AccountID) then
		bVGUI.PlayerTooltip.Create({
			account_id = self.AccountID,
			focustip = bVGUI.L("right_click_to_focus"),
			copiedphrase = bVGUI.L("copied"),
			creator = self
		})
	end
end
function PANEL:OnCursorExited()
	if (self.AccountID) then
		bVGUI.PlayerTooltip.Close()
	end
end

derma.DefineControl("bVGUI.CategoriesItem", nil, PANEL, "DPanel")
--addons/billy_gas/lua/vgui/bvgui/loadingpanel.lua:
local PANEL = {}

function PANEL:Init()
	self.LoadingPaint = self.Paint
end

function PANEL:Paint(w,h)
	if (not self.EndTime or SysTime() >= self.EndTime) then
		self.EndTime = SysTime() + 2
	end
	self.Rotation = ((self.EndTime - SysTime()) / 2) * 360

	if (self.Loading == true) then
		local size = 24
		surface.SetDrawColor(bVGUI.COLOR_WHITE)
		surface.SetMaterial(bVGUI.MATERIAL_LOADING_ICON)
		surface.DrawTexturedRectRotated(w / 2, h / 2, size, size, math.Round(self.Rotation))
	end
end

function PANEL:SetLoading(is_loading)
	self.Loading = is_loading
end
function PANEL:GetLoading()
	return self.Loading
end

derma.DefineControl("bVGUI.LoadingPanel", nil, PANEL, "DPanel")
derma.DefineControl("bVGUI.LoadingScrollPanel", nil, table.Copy(PANEL), "bVGUI.ScrollPanel")
--addons/billy_gas/lua/vgui/bvgui/numberwang.lua:
local PANEL = {}

function PANEL:Init()
	self.NumberWang = vgui.Create("DNumberWang", self)
	self.NumberWang:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
end

function PANEL:CorrectSizing()
	local y = 0
	y = y + self.NumberWang:GetTall()
	if (IsValid(self.Label)) then
		y = y + 10 + self.Label:GetTall()
		self.NumberWang:AlignTop(10 + self.Label:GetTall())
	end
	if (IsValid(self.HelpLabel)) then
		y = y + 10 + self.HelpLabel:GetTall()
		self.HelpLabel:AlignTop(10 + self.Label:GetTall() + self.NumberWang:GetTall() + 10)
	end
	self:SetTall(y)
end

function PANEL:SetText(text)
	self.Label = vgui.Create("DLabel", self)
	self.Label:SetContentAlignment(4)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetText(text)
	self.Label:SizeToContents()

	self:CorrectSizing()
end

function PANEL:SetHelpText(text)
	self.HelpLabel = vgui.Create("DLabel", self)
	self.HelpLabel:SetTextColor(Color(200,200,200))
	self.HelpLabel:SetAutoStretchVertical(true)
	self.HelpLabel:SetWrap(true)
	self.HelpLabel:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
	self.HelpLabel:SetText(text)
	local this = self
	function self.HelpLabel:PerformLayout()
		this:CorrectSizing()
	end
	self:CorrectSizing()
end

function PANEL:PerformLayout()
	if (IsValid(self.HelpLabel)) then
		self.HelpLabel:SetWide(self:GetWide() - 10)
	end
end

derma.DefineControl("bVGUI.NumberWang", nil, PANEL, "bVGUI.BlankPanel")
--addons/billy_gas/lua/vgui/bvgui/pagination.lua:
local PANEL = {}

local page_btn_font = bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14)
local page_btn_width = 23
local page_btn_padding = 15
local inactive_page_textcolor = Color(175,175,175)

local next_btn_mat = Material("vgui/bvgui/right-arrow.png", "smooth")
local prev_btn_mat = Material("vgui/bvgui/left-arrow.png", "smooth")

function PANEL:LoadingDebounce()
	if (IsValid(self.LoadingPanel)) then
		if (self.LoadingPanel:GetLoading() == true) then
			return true
		end
	end
	return false
end
function PANEL:SetLoadingPanel(loading_panel)
	self.LoadingPanel = loading_panel
end

function PANEL:Init()
	local pagination = self

	self.CurrentPage = 1
	self.Pages = 0

	self.Previous = vgui.Create("bVGUI.BlankPanel", self)
	self.Previous:SetMouseInputEnabled(true)
	self.Previous:SetCursor("hand")
	self.Previous:Dock(LEFT)
	self.Previous.Old_OnMouseReleased = self.Previous.OnMouseReleased
	function self.Previous:OnMouseReleased(m)
		if (self:GetParent().LoadingPanel and self:GetParent():LoadingDebounce() == true) then return end
		if (pagination:GetPage() ~= 1) then
			pagination:SetPage(pagination:GetPage() - 1)
			if (pagination.OnPageSelected) then
				pagination:OnPageSelected(pagination:GetPage())
			end
		end
		if (self.Old_OnMouseReleased) then
			self:Old_OnMouseReleased(m)
		end
	end
	self.Previous.Btn = vgui.Create("DImage", self.Previous)
	self.Previous.Btn:SetSize(16,16)
	self.Previous.Btn:SetMaterial(prev_btn_mat)
	function self.Previous:PerformLayout()
		self.Btn:Center()
	end

	self.PagesContainer = vgui.Create("bVGUI.BlankPanel", self)
	self.PagesContainer:SetMouseInputEnabled(true)
	self.PagesContainer:SetCursor("hand")
	function self.PagesContainer:OnMouseReleased()
		if (self:GetParent().LoadingPanel and self:GetParent():LoadingDebounce() == true) then return end
		if (self.HoveredButton and self.HoveredButton > 0 and (self:GetParent().Infinite == true or self.HoveredButton <= math.min(9, self:GetParent():GetPages()))) then
			if self:GetParent().MovingTo == self.HoveredButton then return end
			self:GetParent().MovingTo = self.HoveredButton
			if (pagination.DrawPages[self.HoveredButton] == "∞") then
				return
			elseif (pagination.DrawPages[self.HoveredButton] == "..") then
				if (self.HoveredButton == #pagination.DrawPages - 1) then
					if (self:GetParent().Infinite) then
						self:GetParent().Next:OnMouseReleased(MOUSE_LEFT)
						return
					else
						pagination:SetPage(pagination.DrawPages[self.HoveredButton - 1] + 1)
					end
				elseif (self.HoveredButton == 2) then
					if (self:GetParent().Infinite) then
						self:GetParent().Previous:OnMouseReleased(MOUSE_LEFT)
						return
					else
						pagination:SetPage(pagination.DrawPages[self.HoveredButton + 1] - 1)
					end
				end
			else
				pagination:SetPage(pagination.DrawPages[self.HoveredButton])
			end
			if (pagination.OnPageSelected) then
				pagination:OnPageSelected(pagination:GetPage())
			end
		end
	end

	self.Next = vgui.Create("bVGUI.BlankPanel", self)
	self.Next:SetMouseInputEnabled(true)
	self.Next:SetCursor("hand")
	self.Next:Dock(RIGHT)
	self.Next.Old_OnMouseReleased = self.Next.OnMouseReleased
	function self.Next:OnMouseReleased(m)
		if (self:GetParent().LoadingPanel and self:GetParent():LoadingDebounce() == true) then return end
		if (self:GetParent().Infinite or pagination:GetPage() < pagination:GetPages()) then
			pagination:SetPage(pagination:GetPage() + 1)
			if (pagination.OnPageSelected) then
				pagination:OnPageSelected(pagination:GetPage())
			end
		end
		if (self.Old_OnMouseReleased) then
			self:Old_OnMouseReleased(m)
		end
	end
	self.Next.Btn = vgui.Create("DImage", self.Next)
	self.Next.Btn:SetSize(16,16)
	self.Next.Btn:SetMaterial(next_btn_mat)
	function self.Next:PerformLayout()
		self.Btn:Center()
	end

	local page_poly = {
		{x = 0, y = 0},
		{x = 0, y = 0},
		{x = 0, y = 0},
		{x = 0, y = 0}
	}
	local hover_poly = {
		{x = 0, y = 0},
		{x = 0, y = 0},
		{x = 0, y = 0},
		{x = 0, y = 0}
	}
	function self.PagesContainer:Paint(w,h)
		local pages = pagination.Pages
		local current_page = pagination.CurrentPage
		if (pages == 0) then return end

		local infinite_controlled_pages = pages
		if (self:GetParent().Infinite) then infinite_controlled_pages = current_page + 2 end

		for i=0,math.min(infinite_controlled_pages, 9) do
			surface.SetDrawColor(40, 40, 40)
			surface.DrawLine((i * page_btn_width) + (i * page_btn_padding), h, ((i + 1) * page_btn_width) + (i * page_btn_padding), 0)
		end

		self.RhombusLerp:DoLerp()

		draw.NoTexture()

		local position = self.RhombusLerp:GetValue()

		page_poly[1].x = position + page_btn_width
		--page_poly[1].y = 0

		page_poly[2].x = position + page_btn_width + page_btn_padding + page_btn_width + 1
		--page_poly[2].y = 0

		page_poly[3].x = position + page_btn_width + page_btn_padding + 1
		page_poly[3].y = h

		page_poly[4].x = position
		page_poly[4].y = h

		surface.SetDrawColor(27, 127, 249)
		surface.DrawPoly(page_poly)

		if (self:IsHovered()) then
			-- please, a moment of silence for the amount of hours this took
			local x,y = self:ScreenToLocal(gui.MousePos())
			local rel_x = (x / (page_btn_width + page_btn_padding) % 1) * (page_btn_width + page_btn_padding)
			local rhombus_midpoint = h * (1 - (rel_x / page_btn_width))
			local hovered_position = x / (page_btn_width + page_btn_padding)
			if (rel_x < page_btn_width) then
				if (rhombus_midpoint < y) then
					hovered_position = math.floor(hovered_position + 1)
				else
					hovered_position = math.floor(hovered_position)
				end
			else
				hovered_position = math.ceil(hovered_position)
			end
			self.HoveredButton = hovered_position
			if (hovered_position > 0 and hovered_position <= math.min(9, infinite_controlled_pages)) then
				hovered_position = (hovered_position - 1) * (page_btn_width + page_btn_padding)

				hover_poly[1].x = hovered_position + page_btn_width
				--hover_poly[1].y = 0

				hover_poly[2].x = hovered_position + page_btn_width + page_btn_padding + page_btn_width + 1
				--hover_poly[2].y = 0

				hover_poly[3].x = hovered_position + page_btn_width + page_btn_padding + 1
				hover_poly[3].y = h

				hover_poly[4].x = hovered_position
				hover_poly[4].y = h

				surface.SetDrawColor(27, 127, 249, 100)
				surface.DrawPoly(hover_poly)
			end
		end

		for i,v in ipairs(self:GetParent().DrawPages) do
			if (v == current_page or (i == self.HoveredButton and self:IsHovered())) then
				draw.SimpleText(v, page_btn_font, ((page_btn_width + page_btn_padding) * i) - (page_btn_padding / 2), h / 2, bVGUI.COLOR_WHITE, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			else
				draw.SimpleText(v, page_btn_font, ((page_btn_width + page_btn_padding) * i) - (page_btn_padding / 2), h / 2, inactive_page_textcolor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			end
		end
	end
end

function PANEL:UpdatePageButtons()
	self.DrawPages = {}

	local all_pages = self:GetPages()
	if (self.Infinite) then all_pages = "∞" end
	local current_page = self:GetPage()

	if (current_page < 8) then
		local _all_pages = all_pages
		if (self.Infinite) then _all_pages = current_page end
		for i=1,math.min(_all_pages, 7) do
			table.insert(self.DrawPages, i)
		end
		table.insert(self.DrawPages, "..")
		table.insert(self.DrawPages, all_pages)
	elseif (self.Infinite ~= true and current_page >= (all_pages - 6)) then
		table.insert(self.DrawPages, 1)
		table.insert(self.DrawPages, "..")
		for i=all_pages - 6, all_pages do
			table.insert(self.DrawPages, i)
		end
	elseif (self.Infinite) then
		table.insert(self.DrawPages, 1)
		table.insert(self.DrawPages, "..")
		for i=current_page - 4, current_page do
			table.insert(self.DrawPages, i)
		end
		table.insert(self.DrawPages, "..")
		table.insert(self.DrawPages, all_pages)
	elseif (current_page <= 12) then
		table.insert(self.DrawPages, 1)
		table.insert(self.DrawPages, "..")
		for i=8,12 do
			table.insert(self.DrawPages, i)
		end
		table.insert(self.DrawPages, "..")
		table.insert(self.DrawPages, all_pages)
	else
		table.insert(self.DrawPages, 1)
		table.insert(self.DrawPages, "..")
		table.insert(self.DrawPages, current_page - 2)
		table.insert(self.DrawPages, current_page - 1)
		table.insert(self.DrawPages, current_page)
		table.insert(self.DrawPages, current_page + 1)
		table.insert(self.DrawPages, current_page + 2)
		table.insert(self.DrawPages, "..")
		table.insert(self.DrawPages, all_pages)
	end
	for i,v in ipairs(self.DrawPages) do
		if (v == current_page) then
			local rhombus_pos = (i - 1) * (page_btn_width + page_btn_padding)
			if (not self.PagesContainer.RhombusLerp) then
				self.PagesContainer.RhombusLerp = bVGUI.Lerp(rhombus_pos, rhombus_pos, .5)
			else
				self.PagesContainer.RhombusLerp:SetTo(rhombus_pos)
			end
			break
		end
	end
	if (self.Infinite) then all_pages = current_page + 2 end
	self.PagesContainer:SetWide(((math.min(all_pages, 9) + 1) * page_btn_width) + (math.min(all_pages, 9) * page_btn_padding))
end

function PANEL:SetPage(page)
	if (page == "∞") then return end
	self.CurrentPage = page
	self:UpdatePageButtons()
end
function PANEL:GetPage()
	return self.CurrentPage
end

function PANEL:SetPages(pages)
	self.Pages = pages
	self.CurrentPage = math.min(self.CurrentPage, pages)
	self:UpdatePageButtons()
end
function PANEL:GetPages()
	return self.Pages
end

function PANEL:SetInfinite(infinite)
	self.Infinite = infinite
	self:UpdatePageButtons()
end

function PANEL:PerformLayout()
	self.PagesContainer:SetTall(self:GetTall())
	self.PagesContainer:CenterHorizontal()
	self.Previous:SetSize(self:GetTall(), self:GetTall())
	self.Next:SetSize(self:GetTall(), self:GetTall())
end

derma.DefineControl("bVGUI.Pagination", nil, PANEL, "bVGUI.BlankPanel")
--addons/billy_gas/lua/vgui/bvgui/scrollpanel.lua:
local PANEL = {}

function PANEL:Init()
	self.CurrentOffset = 0
	self.TargetOffset = 0
	self.StartTime = 0
	self.EndTime = 0

	self.VBar:SetHideButtons(true)
	self.VBar:SetWide(5)
	self.VBar:DockMargin(0,0,0,0)

	function self.VBar:Paint() end
	function self.VBar.btnGrip:Paint(w,h)
		surface.SetDrawColor(150,150,150,100)
		surface.DrawRect(0,0,w,h)
	end

	self.VBar.CurrentY = 0
	self.VBar.TargetY = 0
	function self.VBar:PerformLayout()

		local Wide = self:GetWide()
		local BtnHeight = Wide
		if ( self:GetHideButtons() ) then BtnHeight = 0 end
		local Scroll = self:GetScroll() / self.CanvasSize
		local BarSize = math.max( self:BarScale() * ( self:GetTall() - ( BtnHeight * 2 ) ), 10 )
		local Track = self:GetTall() - ( BtnHeight * 2 ) - BarSize
		Track = Track + 1

		Scroll = Scroll * Track

		self.TargetY = BtnHeight + Scroll
		self.btnGrip:SetSize( Wide, BarSize )

		if ( BtnHeight > 0 ) then
			self.btnUp:SetPos( 0, 0, Wide, Wide )
			self.btnUp:SetSize( Wide, BtnHeight )

			self.btnDown:SetPos( 0, self:GetTall() - BtnHeight )
			self.btnDown:SetSize( Wide, BtnHeight )
			
			self.btnUp:SetVisible( true )
			self.btnDown:SetVisible( true )
		else
			self.btnUp:SetVisible( false )
			self.btnDown:SetVisible( false )
			self.btnDown:SetSize( Wide, BtnHeight )
			self.btnUp:SetSize( Wide, BtnHeight )
		end

	end

	function self.VBar:Think()
		self.CurrentY = Lerp(FrameTime() * 10, self.CurrentY, self.TargetY)
		self.btnGrip:SetPos(0, math.Round(self.CurrentY))
	end

	self.pnlCanvas.CurrentOffset = 0
	self.pnlCanvas.TargetOffset = 0
	function self.pnlCanvas:Think()
		self.CurrentOffset = Lerp(FrameTime() * 10, self.CurrentOffset, self.TargetOffset)
		self:SetPos(0, math.Round(self.CurrentOffset))
	end
end

function PANEL:OnVScroll(offset)
	self.pnlCanvas.TargetOffset = offset
end

function PANEL:PerformLayoutInternal()

	local Tall = self.pnlCanvas:GetTall()
	local Wide = self:GetWide()
	local YPos = 0

	self:Rebuild()

	self.VBar:SetUp( self:GetTall(), self.pnlCanvas:GetTall() )
	YPos = self.VBar:GetOffset()

	if ( self.VBar.Enabled ) then Wide = Wide - self.VBar:GetWide() end

	self.pnlCanvas:SetPos( 0, YPos )
	self.pnlCanvas:SetWide( Wide )

	self:Rebuild()

	if ( Tall != self.pnlCanvas:GetTall() ) then
		self.VBar:SetScroll( self.VBar:GetScroll() ) -- Make sure we are not too far down!
	end

end

derma.DefineControl("bVGUI.ScrollPanel", nil, PANEL, "DScrollPanel")
--addons/billy_gas_logging/lua/vgui/gas_logging_advanced_search_item.lua:
local function L(phrase, ...)
	if (#({...}) == 0) then
		return GAS:Phrase(phrase, "logging")
	else
		return GAS:PhraseFormat(phrase, "logging", ...)
	end
end

local PANEL = {}

function PANEL:Init()
	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")
	self:Dock(TOP)
	self:SetTall(32 + 3 + 3)
	self:DockPadding(3,3,3,3)
	self:DockMargin(0,0,0,5)

	self.Color = Color(255,255,255)

	self.Label = vgui.Create("DLabel", self)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
	self.Label:Dock(FILL)
	self.Label:SetContentAlignment(5)
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:DockMargin(5,0,5,0)
end

function PANEL:SetAccountID(account_id)
	local steamid64 = GAS:AccountIDToSteamID64(account_id)

	self.AccountID = account_id

	self.AvatarImage = vgui.Create("AvatarImage", self)
	self.AvatarImage:SetMouseInputEnabled(false)
	self.AvatarImage:Dock(LEFT)
	self.AvatarImage:SetSize(32,32)
	self.AvatarImage:SetSteamID(steamid64, 32)
	self.Label:SetContentAlignment(4)

	self:UpdateTooltip()
end

function PANEL:SetColor(col)
	self.Color = col
end

function PANEL:SetTextColor(col)
	self.Label:SetTextColor(col)
	self:UpdateTooltip()
end

function PANEL:SetValue(val)
	self.Value = val
	self.Label:SetText(val)
	self:UpdateTooltip()
end

function PANEL:SetText(text)
	self.Label:SetText(text)
	self:UpdateTooltip()
end

function PANEL:GetValue()
	return self.Value
end

function PANEL:UpdateTooltip()
	if (self.AccountID ~= nil) then
		bVGUI.UnattachTooltip(self)
		bVGUI.PlayerTooltip.Attach(self, {
			account_id = self.AccountID,
			creator = self,
			focustip = L"right_click_to_focus",
		})
	else
		bVGUI.AttachTooltip(self, {
			Text = self.Label:GetText(),
			TextColor = self.Label:GetTextColor()
		})
	end
end

function PANEL:OnMouseReleased(m)
	if (m == MOUSE_LEFT) then
		GAS:PlaySound("delete")
		self:GetParent():RemoveItem(self)
	elseif (m == MOUSE_RIGHT and self.AccountID ~= nil) then
		bVGUI.PlayerTooltip.Focus()
	end
end

function PANEL:Paint(w,h)
	surface.SetDrawColor(bVGUI.COLOR_DARK_GREY)
	surface.DrawRect(0,0,w,h)

	surface.SetDrawColor(self.Color)
	for i=0,2 do
		surface.DrawOutlinedRect(i,i,w - (i * 2),h - (i * 2))
	end
end

derma.DefineControl("GAS.Logging.AdvancedSearchItem", nil, PANEL, "bVGUI.BlankPanel")
--addons/billy_gas_logging/lua/vgui/gas_logging_damagelog.lua:
local function L(phrase, ...)
	if (#({...}) == 0) then
		return GAS:Phrase(phrase, "logging")
	else
		return GAS:PhraseFormat(phrase, "logging", ...)
	end
end

surface.CreateFont("gas_logging_damagelog_pct", {
	size = 24,
	font = "Circular Std Medium",
	bold = true,
})

surface.CreateFont("gas_logging_damagelog_delay", {
	size = 12,
	font = "Circular Std Medium"
})

local module_icon_cache = {}
local module_noicon = Material("icon16/page_white_text.png")
local function GetModuleIcon(module_id)
	if (module_icon_cache[module_id]) then
		return module_icon_cache[module_id]
	else
		local module_data = GAS.Logging.IndexedModules[module_id]
		if (module_data.Icon ~= nil) then
			local mat = Material(module_data.Icon)
			module_icon_cache[module_id] = mat
			return mat
		else
			return module_noicon
		end
	end
end

GAS_Logging_PvPEventReports = {}

local PANEL = {}

function PANEL:DoClick()
	local this = self

	GAS:PlaySound("popup")
	if (IsValid(GAS_Logging_PvPEventReports[self.data[GAS.Logging.PvP_EVENT_ID]])) then
		GAS_Logging_PvPEventReports[self.data[GAS.Logging.PvP_EVENT_ID]]:MakePopup()
		GAS_Logging_PvPEventReports[self.data[GAS.Logging.PvP_EVENT_ID]]:Center()
	else
		local total_time = this.data[GAS.Logging.PvP_LAST_UPDATED] - this.data[GAS.Logging.PvP_PRECISE_CREATION_TIME]

		local pvp_event_report = vgui.Create("bVGUI.Frame")
		pvp_event_report.data = self.data

		GAS_Logging_PvPEventReports[self.data[GAS.Logging.PvP_EVENT_ID]] = pvp_event_report

		pvp_event_report:SetSize(800,500)
		pvp_event_report:SetMinimumSize(pvp_event_report:GetSize())
		pvp_event_report:SetTitle(L"pvp_event_report")
		pvp_event_report:MakePopup()
		pvp_event_report:Center()
		function pvp_event_report:OnClose()
			GAS.Logging.Scenes:ClearScene(pvp_event_report.data[GAS.Logging.PvP_COMBAT_SCENE])
			if (IsValid(this) and this.DeleteMeOnClose) then
				this:Remove()
			end
		end

		local info_container = vgui.Create("bVGUI.BlankPanel", pvp_event_report)
		info_container:Dock(FILL)

		local scene_container = vgui.Create("bVGUI.BlankPanel", pvp_event_report)
		scene_container:Dock(LEFT)
		scene_container:SetWide(200)

			local scene_beginning = vgui.Create("bVGUI.RenderScene", scene_container)
			scene_beginning:SetLabel(L"event_start")
			function scene_beginning:OnStartRender()
				GAS.Logging.Scenes:ViewScene(pvp_event_report.data[GAS.Logging.PvP_COMBAT_SCENE], true, function(pos, ang)
					if (not IsValid(self)) then return end
					if (self.SetDefaultPositioning) then return end
					self.SetDefaultPositioning = true
					self:SetOrigin(pos)
					self:SetAngle(ang)
				end)
			end
			function scene_beginning:OnEndRender()
				GAS.Logging.Scenes:ClearScene(pvp_event_report.data[GAS.Logging.PvP_COMBAT_SCENE], true)
			end

			local scene_end = vgui.Create("bVGUI.RenderScene", scene_container)
			scene_end:SetCanRender(not self.data[GAS.Logging.PvP_ONGOING])
			scene_end:SetLabel(L"event_end")
			function scene_end:OnStartRender()
				GAS.Logging.Scenes:ViewScene(pvp_event_report.data[GAS.Logging.PvP_COMBAT_SCENE], false, function(pos, ang)
					if (not IsValid(self)) then return end
					if (self.SetDefaultPositioning) then return end
					self.SetDefaultPositioning = true
					self:SetOrigin(pos)
					self:SetAngle(ang)
				end)
			end
			function scene_end:OnEndRender()
				GAS.Logging.Scenes:ClearScene(pvp_event_report.data[GAS.Logging.PvP_COMBAT_SCENE], false)
			end

			function scene_container:PerformLayout(w,_h)
				local h = _h + 5
				scene_beginning:SetSize(w,h/2)
				scene_end:SetSize(w,h/2)
				scene_end:AlignTop((h/2)-5)
			end

		local timeline = vgui.Create("bVGUI.BlankPanel", info_container)
		timeline:SetMouseInputEnabled(true)
		timeline:Dock(TOP)
		timeline:SetTall(70)
		timeline.Scale = math.max(1, total_time * 1.25)
		timeline.BlipOffset = 0
		timeline.DmgEventBlips = {}
		function timeline:OnMouseWheeled(delta)
			local scale_change = timeline.Scale
			if (delta == 1) then
				timeline.Scale = timeline.Scale * 2
			elseif (delta == -1) then
				timeline.Scale = timeline.Scale / 2
			end
			local max_scale = math.max(4, total_time * 1.25)

			timeline.Scale = math.Clamp(timeline.Scale, 0.25, max_scale)

			local x,y = timeline:ScreenToLocal(gui.MousePos())
			if (timeline.Scale >= max_scale) then
				timeline.BlipOffset = 0
			end

			timeline:RefreshBlips()
			timeline:RefreshDelayMarkup()
		end

		local blip_size = 7.5
		function timeline:RefreshBlips()
			local w,h = self:GetSize()

			local y_offset = 14 + 10

			timeline.DmgEventBlips = {}
			for i,log in ipairs(pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS]) do
				if (type(log[1]) == "table") then continue end

				local place = (log[1] / total_time) * (w * (total_time / timeline.Scale)) - timeline.BlipOffset

				local blip = {
					{x = place, y = y_offset},
					{x = place + blip_size, y = blip_size + y_offset},
					{x = place, y = (blip_size * 2) + y_offset},
					{x = place - blip_size, y = blip_size + y_offset},
				}
				if (log[3] == pvp_event_report.data[GAS.Logging.PvP_VICTIM] and log[4] == pvp_event_report.data[GAS.Logging.PvP_INSTIGATOR]) then
					timeline.DmgEventBlips[i] = {true, blip}
				elseif (log[3] == pvp_event_report.data[GAS.Logging.PvP_INSTIGATOR] and log[4] == pvp_event_report.data[GAS.Logging.PvP_VICTIM]) then
					timeline.DmgEventBlips[i] = {false, blip}
				else
					timeline.DmgEventBlips[i] = {nil, blip}
				end
			end
		end
		timeline:RefreshBlips()

		function timeline:RefreshDelayMarkup()
			local x,y = self:ScreenToLocal(gui.MousePos())
			local w,h = self:GetSize()
			if (x >= 0) then
				self.DelayMarkup = markup.Parse("<font=gas_logging_damagelog_delay>+" .. math.Round((x / (w * (total_time / self.Scale))) * total_time, 2) .. "s</font>")
			else
				self.DelayMarkup = markup.Parse("<font=gas_logging_damagelog_delay>+0s</font>")
			end
		end

		function timeline:PerformLayout()
			timeline:RefreshBlips()
		end

		local pvp_event = vgui.Create("GAS.Logging.DamageLog", info_container)
		pvp_event:Dock(TOP)
		pvp_event:Setup(self.data, false)

		local tabs = vgui.Create("bVGUI.Tabs", info_container)
		tabs:Dock(TOP)
		tabs:SetTall(40)

		local logs_tab_content, logs_tab = tabs:AddTab(L"logs", Color(216,76,76))
			
			local log_tbl = vgui.Create("bVGUI.Table", logs_tab_content)
			log_tbl:Dock(FILL)
			log_tbl:AddColumn(L"log", bVGUI.TABLE_COLUMN_GROW)
			log_tbl:AddColumn(L"instigator_abbr", bVGUI.TABLE_COLUMN_SHRINK, TEXT_ALIGN_CENTER)
			log_tbl:AddColumn(L"victim_abbr", bVGUI.TABLE_COLUMN_SHRINK, TEXT_ALIGN_CENTER)
			log_tbl:AddColumn(L"time", bVGUI.TABLE_COLUMN_SHRINK, TEXT_ALIGN_CENTER)
			for i,log in ipairs(this.data[GAS.Logging.PvP_EVENT_LOGS]) do
				if (type(log[1]) == "table") then
					local row = log_tbl:AddRow(GAS.Logging:FormatMarkupLog(log, nil, nil, this.data[GAS.Logging.PvP_VICTIM], this.data[GAS.Logging.PvP_INSTIGATOR]), "-", "-", "+" .. math.Round(this.data[GAS.Logging.PvP_EVENT_LOGS_CHRONOLOGY][i], 2) .. "s")
					local icon = GetModuleIcon(log[2])
					row:SetMaterial(icon)
				else
					local instigator_dmg = "-"
					local victim_dmg = "-"
					if (log[3] == this.data[GAS.Logging.PvP_VICTIM]) then
						victim_dmg = "<color=0,255,0>" .. math.Round(log[6], 2) .. "</color>"
					elseif (log[3] == this.data[GAS.Logging.PvP_INSTIGATOR]) then
						instigator_dmg = "<color=255,0,0>" .. math.Round(log[6], 2) .. "</color>"
					end
					log_tbl:AddRow(GAS.Logging:FormatMarkupLogCustom(GAS:Phrase(log[2], "logging", "Logs"), log[5], nil, nil, this.data[GAS.Logging.PvP_VICTIM], this.data[GAS.Logging.PvP_INSTIGATOR]), instigator_dmg, victim_dmg, "+" .. math.Round(log[1], 2) .. "s")
				end
			end

		local weapons_tab_content, weapons_tab = tabs:AddTab(L"weapons", Color(76,76,216))

			local weapons_grid = vgui.Create("bVGUI.Grid", weapons_tab_content)
			weapons_grid:Dock(FILL)
			weapons_grid:SetPadding(10,10)

			local merged_weps = {}
			for weapon_class, dmg in pairs(pvp_event_report.data[GAS.Logging.PvP_INSTIGATOR_WEPS]) do
				merged_weps[weapon_class] = merged_weps[weapon_class] or {0,0}
				merged_weps[weapon_class][1] = merged_weps[weapon_class][1] + dmg
			end
			for weapon_class, dmg in pairs(pvp_event_report.data[GAS.Logging.PvP_VICTIM_WEPS]) do
				merged_weps[weapon_class] = merged_weps[weapon_class] or {0,0}
				merged_weps[weapon_class][2] = merged_weps[weapon_class][2] + dmg
			end

			for weapon_class, dmgs in pairs(merged_weps) do
				local ent_display = vgui.Create("GAS.Logging.EntityDisplay", weapons_grid)
				ent_display:SetWeapon(weapon_class)
				ent_display:SetDrawOnTop(false)
				ent_display.Think = nil
				weapons_grid:AddToGrid(ent_display)
			end

		local linked_events_tab_content, linked_events_tab = tabs:AddTab(L"linked_events", Color(216,76,76))



		local log_tbl_highlights = {}
		local timeline_hover_last_prev_frame
		local timeline_hover_exact_prev_frame
		function timeline:Paint(w,h)
			local x,y = self:ScreenToLocal(gui.MousePos())
			local target_time_point = (x / (w * (total_time / self.Scale))) * total_time
			local target_time_point_rnd = math.Round(target_time_point, 2)

			if (x ~= self.StoreX) then
				self.StoreX = x
				timeline:RefreshDelayMarkup()
			end

			surface.SetDrawColor(26,26,26)
			surface.DrawRect(0,0,w,h)

			surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT_LARGE)
			surface.DrawTexturedRect(0,0,w,h)

			surface.SetDrawColor(50, 50, 50)
			local spacing = w / self.Scale
			for i=1,self.Scale do
				surface.DrawLine((i - 1) * spacing,0,(i - 1) * spacing,h)
			end
			if (self.Scale < 5) then
				local spacing = w / math.floor(self.Scale / .25)
				for i=1,math.floor(self.Scale / .25) do
					if ((i - 1) % 4 == 0) then continue end
					if ((i - 1) % 2 == 0) then
						surface.SetDrawColor(37, 37, 37)
					else
						surface.SetDrawColor(30, 30, 30)
					end
					surface.DrawLine((i - 1) * spacing,0,(i - 1) * spacing,h)
				end
			end

			surface.SetDrawColor(181,39,39)
			surface.DrawRect(0,0,w,14)

			surface.SetDrawColor(181,39,39)
			surface.DrawRect(0,0,w * (total_time / self.Scale),14)

			if (self.DelayMarkupW ~= nil and x >= 0 and x <= w) then
				surface.SetDrawColor(0,0,0,200)
				surface.DrawRect(x - ((self.DelayMarkupW + 15) / 2),0,self.DelayMarkupW + 15,14)
			end

			local timeline_hover_exact
			local timeline_hover_last = target_time_point > total_time
			if (timeline_hover_last) then
				for k,v in pairs(log_tbl_highlights) do
					if (k ~= #pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS]) then
						log_tbl_highlights = {}
						break
					end
				end
				log_tbl_highlights[#pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS]] = true
			elseif (timeline_hover_last_prev_frame ~= timeline_hover_last) then
				log_tbl_highlights[#pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS]] = nil
			end
			timeline_hover_last_prev_frame = timeline_hover_last

			for i,log in ipairs(pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS]) do
				local time_point
				if (type(log[1]) == "table") then
					-- event log
					time_point = pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS_CHRONOLOGY][i]

					local icon = GetModuleIcon(log[2])
					surface.SetDrawColor(255,255,255)
					surface.SetMaterial(icon)
					surface.DrawTexturedRect((time_point / total_time) * (w * (total_time / self.Scale)) - (16 / 2) - timeline.BlipOffset, h - 16 - 10, 16, 16)
				else
					-- damage log
					local poly = timeline.DmgEventBlips[i]
					draw.NoTexture()
					if (poly[1] == true) then
						surface.SetDrawColor(215,50,50,200)
					elseif (poly[1] == false) then
						surface.SetDrawColor(50,215,50,200)
					else
						surface.SetDrawColor(50,50,215,200)
					end
					surface.DrawPoly(poly[2])

					time_point = log[1]
				end

				if (not timeline_hover_last) then
					local time_point_rnd = math.Round(time_point, 2)
					if (timeline_hover_exact ~= nil) then
						log_tbl_highlights[i] = (time_point_rnd == timeline_hover_exact) or nil
					elseif (time_point_rnd == target_time_point_rnd) then
						timeline_hover_exact = target_time_point_rnd
						log_tbl_highlights[i] = true
					else
						if (i ~= 1 and target_time_point < time_point) then
							local prev = pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS][i - 1]
							local prev_time_point = prev[1]
							if (type(prev[1]) == "table") then
								prev_time_point = pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS_CHRONOLOGY][i - 1]
							end
							if (target_time_point > prev_time_point) then
								local median = (prev_time_point + time_point) / 2
								if (target_time_point > median) then
									log_tbl_highlights[i] = true
									log_tbl_highlights[i - 1] = nil
								else
									log_tbl_highlights[i] = nil
									log_tbl_highlights[i - 1] = true
								end
							else
								log_tbl_highlights[i] = nil
							end
						elseif (i ~= #pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS] and target_time_point > time_point) then
							local next = pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS][i + 1]
							local next_time_point = next[1]
							if (type(next[1]) == "table") then
								next_time_point = pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS_CHRONOLOGY][i + 1]
							end
							if (target_time_point < next_time_point) then
								local median = (next_time_point + time_point) / 2
								if (target_time_point > median) then
									log_tbl_highlights[i] = nil
									log_tbl_highlights[i + 1] = true
								else
									log_tbl_highlights[i] = true
									log_tbl_highlights[i + 1] = nil
								end
							else
								log_tbl_highlights[i] = nil
							end
						end
					end
				end
			end

			if (x >= 0 and x <= w) then
				surface.SetDrawColor(100,100,100)
				surface.DrawLine(x,14,x,h)

				if (self.DelayMarkup) then
					self.DelayMarkup:Draw(x, 7, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					self.DelayMarkupW = self.DelayMarkup:GetWidth()
				end
			elseif (next(log_tbl_highlights) ~= nil) then
				log_tbl_highlights = {}
			end

			for i,row in ipairs(log_tbl.Rows) do
				row.Highlight = log_tbl_highlights[i] == true
				if (row.Highlight and pvp_event_report:HasFocus() and (not IsValid(vgui.GetHoveredPanel()) or not log_tbl:IsOurChild(vgui.GetHoveredPanel()))) then
					if (self.ScrollToChild_Prev ~= row) then
						self.ScrollToChild_Prev = row
						log_tbl.RowContainer:ScrollToChild(row)
					end
				end
			end
		end

		pvp_event_report:EnableUserResize()
	end
end
function PANEL:OnMousePressed(m)
	self._pressed = m
end
function PANEL:OnMouseReleased(m)
	if (self._pressed == m) then
		if (m == MOUSE_LEFT and self.DoClick) then
			self:DoClick()
		end
		self._pressed = nil
	end
end

function PANEL:Init()
	self:SetMouseInputEnabled(true)

	self:SetTall(95)

	self.InstigatorAvatar = vgui.Create("AvatarImage", self)
	self.InstigatorAvatar:SetSize(48,48)
	self.InstigatorAvatar:SetCursor("hand")
	self.InstigatorAvatar:SetMouseInputEnabled(true)
	function self.InstigatorAvatar:OnMouseReleased(m) if m ~= MOUSE_LEFT then return else bVGUI.PlayerTooltip.Focus() end end

	self.InstigatorDead = vgui.Create("DLabel", self)
	self.InstigatorDead:SetTextColor(Color(255,0,0))
	self.InstigatorDead:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.InstigatorDead:SetContentAlignment(4)
	self.InstigatorDead:SetText("")
	self.InstigatorDead:SetWide(0)

	self.InstigatorTag = vgui.Create("DLabel", self)
	self.InstigatorTag:SetTextColor(Color(255,0,0))
	self.InstigatorTag:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.InstigatorTag:SetText("[" .. string.upper(L"instigator") .. "]")
	self.InstigatorTag:SetContentAlignment(4)
	self.InstigatorTag:SizeToContents()
	bVGUI.AttachTooltip(self.InstigatorTag, {
		Text = L"instigator_tag_tip",
	})

	self.InstigatorName = vgui.Create("DLabel", self)
	self.InstigatorName:SetTextColor(bVGUI.COLOR_WHITE)
	self.InstigatorName:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.InstigatorName:SetText("")
	self.InstigatorName:SetContentAlignment(4)
	self.InstigatorName:SetCursor("hand")
	self.InstigatorName:SetMouseInputEnabled(true)
	function self.InstigatorName:DoClick() bVGUI.PlayerTooltip.Focus() end

	self.InstigatorPrimaryWep = vgui.Create("DLabel", self)
	self.InstigatorPrimaryWep:SetTextColor(GAS.Logging.LogFormattingSettings.Colors.Weapon)
	self.InstigatorPrimaryWep:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.InstigatorPrimaryWep:SetText("")
	self.InstigatorPrimaryWep:SetContentAlignment(4)
	self.InstigatorPrimaryWep:SetMouseInputEnabled(true)

	self.VictimAvatar = vgui.Create("AvatarImage", self)
	self.VictimAvatar:SetSize(48,48)
	self.VictimAvatar:SetCursor("hand")
	self.VictimAvatar:SetMouseInputEnabled(true)
	function self.VictimAvatar:OnMouseReleased(m) if m ~= MOUSE_LEFT then return else bVGUI.PlayerTooltip.Focus() end end

	self.VictimDead = vgui.Create("DLabel", self)
	self.VictimDead:SetTextColor(Color(255,0,0))
	self.VictimDead:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.VictimDead:SetContentAlignment(4)
	self.VictimDead:SetText("")
	self.VictimDead:SetWide(0)

	self.VictimTag = vgui.Create("DLabel", self)
	self.VictimTag:SetTextColor(Color(0,255,0))
	self.VictimTag:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.VictimTag:SetText("[" .. string.upper(L"victim") .. "]")
	self.VictimTag:SetContentAlignment(6)
	self.VictimTag:SizeToContents()
	bVGUI.AttachTooltip(self.VictimTag, {
		Text = L"victim_tag_tip",
	})

	self.VictimName = vgui.Create("DLabel", self)
	self.VictimName:SetTextColor(bVGUI.COLOR_WHITE)
	self.VictimName:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.VictimName:SetText("")
	self.VictimName:SetContentAlignment(6)
	self.VictimName:SetCursor("hand")
	self.VictimName:SetMouseInputEnabled(true)
	function self.VictimName:DoClick() bVGUI.PlayerTooltip.Focus() end

	self.VictimPrimaryWep = vgui.Create("DLabel", self)
	self.VictimPrimaryWep:SetTextColor(GAS.Logging.LogFormattingSettings.Colors.Weapon)
	self.VictimPrimaryWep:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.VictimPrimaryWep:SetText("")
	self.VictimPrimaryWep:SetContentAlignment(6)
	self.VictimPrimaryWep:SetMouseInputEnabled(true)

	self.FlagMetadata = {
		{GAS.Logging.PvP_FLAG_ONGOING, L"flag_ongoing", "icon16/lightbulb.png"},
		{GAS.Logging.PvP_FLAG_FINISHED, L"flag_finished", "icon16/lightbulb_off.png"},
		{GAS.Logging.PvP_FLAG_SUPERADMIN, L"flag_superadmin", "icon16/shield_add.png"},
		{GAS.Logging.PvP_FLAG_ADMIN, L"flag_admin", "icon16/shield.png"},
		{GAS.Logging.PvP_FLAG_FRIENDLYFIRE, L"flag_friendly_fire", "icon16/emoticon_unhappy.png"},
		{GAS.Logging.PvP_FLAG_LAWENFORCEMENT, L"flag_law_enforcement", "icon16/bell.png"},
		{GAS.Logging.PvP_FLAG_INSTIGATOR_DEATH, L"flag_instigator_death", "icon16/status_busy.png"},
		{GAS.Logging.PvP_FLAG_VICTIM_DEATH, L"flag_victim_death", "icon16/status_offline.png"},
		{GAS.Logging.PvP_FLAG_VEHICLE, L"flag_vehicle", "icon16/car.png"},
		{GAS.Logging.PvP_FLAG_WORLD, L"flag_world", "icon16/world.png"},
		{GAS.Logging.PvP_FLAG_PROPS, L"flag_props", "icon16/bricks.png"},
		{GAS.Logging.PvP_FLAG_TEAM_SWITCHED, L"flag_team_switched", "icon16/arrow_refresh.png"},
		{GAS.Logging.PvP_FLAG_DISCONNECT, L"flag_disconnect", "icon16/disconnect.png"},
		{GAS.Logging.PvP_FLAG_LINKED, L"flag_linked", "icon16/link.png"},
	}

	self.LogTypeMetadata = {
		[GAS.Logging.PvP_LOG_TYPE_CHAT] = {L"log_type_chat", "icon16/user_comment.png"},
		[GAS.Logging.PvP_LOG_TYPE_CHAT_TEAM] = {L"log_type_team_chat", "icon16/group.png"},
		[GAS.Logging.PvP_LOG_TYPE_WEAPON_PICKUP] = {L"log_type_weapon_pickup", "icon16/bomb.png"},
		[GAS.Logging.PvP_LOG_TYPE_WEAPON_DROPPED] = {L"log_type_weapon_drop", "icon16/arrow_down.png"},
		[GAS.Logging.PvP_LOG_TYPE_ITEM_PICKUP] = {L"log_type_item_pickup", "icon16/coins.png"},
		[GAS.Logging.PvP_LOG_TYPE_SPAWNMENU] = {L"log_type_spawnmenu", "icon16/bricks.png"},
		[GAS.Logging.PvP_LOG_TYPE_DARKRP_PURCHASE] = {L"log_type_darkrp_purchase", "icon16/money_add.png"},
		[GAS.Logging.PvP_LOG_TYPE_DISCONNECT] = {L"log_type_disconnect", "icon16/disconnect.png"},
		[GAS.Logging.PvP_LOG_TYPE_WEAPON_SWITCHED] = {L"log_type_weapon_switched", "icon16/arrow_switch.png"},
		[GAS.Logging.PvP_LOG_TYPE_TEAM_SWITCH] = {L"log_type_team_switched", "icon16/arrow_refresh.png"},
		[GAS.Logging.PVP_LOG_TYPE_SILENT_DEATH] = {L"log_type_silent_death", "icon16/status_offline.png"},
		[GAS.Logging.PvP_LOG_TYPE_DEATH_WORLD] = {L"log_type_death_world", "icon16/world.png"},
		[GAS.Logging.PvP_LOG_TYPE_DEATH_PLAYER_WEP] = {L"log_type_death_player_wep", "icon16/wand.png"},
		[GAS.Logging.PvP_LOG_TYPE_DEATH_PLAYER] = {L"log_type_death_player", "icon16/status_offline.png"},
		[GAS.Logging.PvP_LOG_TYPE_DEATH_ENT] = {L"log_type_death_ent", "icon16/status_offline.png"},
		[GAS.Logging.PvP_LOG_TYPE_DEATH] = {L"log_type_death", "icon16/status_offline.png"},
		[GAS.Logging.PvP_LOG_TYPE_DEATH_PROPKILL_SELF] = {L"log_type_propkill_self", "icon16/box.png"},
		[GAS.Logging.PvP_LOG_TYPE_DEATH_PROPKILL] = {L"log_type_propkill", "icon16/brick_go.png"},
	}

	self.FlagContainer = vgui.Create("bVGUI.BlankPanel", self)
	self.FlagContainer:Dock(RIGHT)
	self.FlagContainer:DockMargin(0,10,10 + 6,10 + 14)
	self.FlagContainer:SetWide(16)
	function self.FlagContainer:PerformLayout(w)
		self.Content:SetWide(w)
		self.Content:AlignRight(0)
		self.Content:CenterVertical()
	end

	self.FlagContainer.Content = vgui.Create("bVGUI.BlankPanel", self.FlagContainer)
	self.FlagContainer.Content:SetTall((3 * (16 + 5)) - 5)

	self.Timestamp = vgui.Create("DLabel", self)
	self.Timestamp:SetTextColor(bVGUI.COLOR_WHITE)
	self.Timestamp:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.Timestamp:SetText("")
	self.Timestamp:SetContentAlignment(4)
	self.Timestamp:SetMouseInputEnabled(true)
end

function PANEL:Setup(data, allow_click)
	if (allow_click == false) then
		self.DoClick = nil
	else
		self:SetCursor("hand")
	end

	self.data = data

	if (self.data[GAS.Logging.PvP_FLAGS][GAS.Logging.PvP_FLAG_INSTIGATOR_DEATH]) then
		self.InstigatorDead:SetText(L"dead_tag")
		self.InstigatorDead:SizeToContents()
	end
	if (self.data[GAS.Logging.PvP_FLAGS][GAS.Logging.PvP_FLAG_VICTIM_DEATH]) then
		self.VictimDead:SetText(L"dead_tag")
		self.VictimDead:SizeToContents()
	end

	self.Timestamp:SetText(GAS:SimplifyTimestamp(self.data[GAS.Logging.PvP_CREATION_TIMESTAMP]))
	self.Timestamp:SizeToContents()
	bVGUI.AttachTooltip(self.Timestamp, {
		Text = GAS:FormatFullTimestamp(self.data[GAS.Logging.PvP_CREATION_TIMESTAMP])
	})

	self.InstigatorAvatar:SetSteamID(GAS:AccountIDToSteamID64(data[GAS.Logging.PvP_INSTIGATOR]), 48)
	self.VictimAvatar:SetSteamID(GAS:AccountIDToSteamID64(data[GAS.Logging.PvP_VICTIM]), 48)

	local instigator = player.GetByAccountID(data[GAS.Logging.PvP_INSTIGATOR])
	if (IsValid(instigator)) then
		self.InstigatorName:SetText(instigator:Nick())
	else
		self.InstigatorName:SetText(data[GAS.Logging.PvP_INSTIGATOR_NICK])
	end
	self.InstigatorName:SizeToContents()

	bVGUI.PlayerTooltip.Attach(self.InstigatorAvatar, {
		account_id = data[GAS.Logging.PvP_INSTIGATOR],
		focustip = L"click_to_focus",
	})

	bVGUI.PlayerTooltip.Attach(self.InstigatorName, {
		account_id = data[GAS.Logging.PvP_INSTIGATOR],
		focustip = L"click_to_focus",
	})

	local instigator_primary_wep = table.GetWinningKey(data[GAS.Logging.PvP_INSTIGATOR_WEPS])
	if (instigator_primary_wep ~= nil) then
		self.InstigatorPrimaryWep:SetText(instigator_primary_wep)
		self.InstigatorPrimaryWep:SizeToContents()

		GAS_Logging_DisplayEntity(function(pnl)
			pnl:SetWeapon(instigator_primary_wep)
		end, self.InstigatorPrimaryWep, true)
	end

	local victim = player.GetByAccountID(data[GAS.Logging.PvP_VICTIM])
	if (IsValid(victim)) then
		self.VictimName:SetText(victim:Nick())
	else
		self.VictimName:SetText(data[GAS.Logging.PvP_VICTIM_NICK])
	end
	self.VictimName:SizeToContents()

	bVGUI.PlayerTooltip.Attach(self.VictimAvatar, {
		account_id = data[GAS.Logging.PvP_VICTIM],
		focustip = L"click_to_focus",
	})

	bVGUI.PlayerTooltip.Attach(self.VictimName, {
		account_id = data[GAS.Logging.PvP_VICTIM],
		focustip = L"click_to_focus",
	})

	local victim_primary_wep = table.GetWinningKey(data[GAS.Logging.PvP_VICTIM_WEPS])
	if (victim_primary_wep ~= nil) then
		self.VictimPrimaryWep:SetText(victim_primary_wep)
		self.VictimPrimaryWep:SizeToContents()

		GAS_Logging_DisplayEntity(function(pnl)
			pnl:SetWeapon(victim_primary_wep)
		end, self.VictimPrimaryWep, true)
	end

	local column = 1
	local count = 0
	for i,v in ipairs(self.FlagMetadata) do
		if (data[GAS.Logging.PvP_FLAGS][v[1]] == true) then
			count = count + 1
			if (count % 3 == 0) then
				column = column + 1
			end
		end
	end
	if (count % 3 == 0) then column = column - 1 end
	self.FlagContainer:SetWide((column * (16 + 5)) - 5)
	if (column == 1) then
		self.FlagContainer.Content:SetTall((count * (16 + 5)) - 5)
	else
		self.FlagContainer.Content:SetTall((3 * (16 + 5)) - 5)
	end
	self.FlagContainer.Content:SetWide((column * (16 + 5)) - 5)
	self.FlagContainer.Content:AlignRight(0)
	self.FlagContainer.Content:CenterVertical()

	local column = 1
	local count = 0
	for i,v in ipairs(self.FlagMetadata) do
		if (data[GAS.Logging.PvP_FLAGS][v[1]] == true) then
			local flag_icon = vgui.Create("DImage", self.FlagContainer.Content)
			flag_icon:SetSize(16,16)
			flag_icon:AlignTop((count % 3) * (16 + 5))
			flag_icon:AlignRight((column - 1) * (16 + 5))
			flag_icon:SetImage(v[3])
			bVGUI.AttachTooltip(flag_icon, {
				Text = v[2]
			})
			count = count + 1
			if (count % 3 == 0) then
				column = column + 1
			end
		end
	end

	self:InvalidateLayout(true)
end

function PANEL:PerformLayout(w,h)
	self.InstigatorAvatar:AlignLeft(10)
	self.InstigatorAvatar:AlignBottom(10 + 14)

	self.VictimAvatar:AlignRight(10 + self.FlagContainer:GetWide() + 10 + 6)
	self.VictimAvatar:AlignBottom(10 + 14)

	self.InstigatorDead:AlignTop(5)
	self.InstigatorDead:AlignLeft(10)

	local instigator_death_margin, victim_death_margin = 0,0
	if (self.InstigatorDead:GetWide() > 0) then
		instigator_death_margin = self.InstigatorDead:GetWide() + 5
	end
	if (self.VictimDead:GetWide() > 0) then
		victim_death_margin = self.VictimDead:GetWide() + 5
	end

	self.InstigatorTag:AlignTop(5)
	self.InstigatorTag:AlignLeft(10 + instigator_death_margin)

	self.InstigatorName:AlignTop(5)
	self.InstigatorName:AlignLeft(10 + instigator_death_margin + self.InstigatorTag:GetWide() + 5)

	self.InstigatorPrimaryWep:AlignTop(5)
	self.InstigatorPrimaryWep:AlignLeft(10 + instigator_death_margin + self.InstigatorTag:GetWide() + 5 + self.InstigatorName:GetWide() + 5)

	self.VictimDead:AlignTop(5)
	self.VictimDead:AlignRight(10 + self.FlagContainer:GetWide() + 10 + 6)

	self.VictimTag:AlignTop(5)
	self.VictimTag:AlignRight(10 + self.FlagContainer:GetWide() + 10 + victim_death_margin + 6)

	self.VictimName:AlignTop(5)
	self.VictimName:AlignRight(10 + self.FlagContainer:GetWide() + 10 + victim_death_margin + self.VictimTag:GetWide() + 5 + 6)

	self.VictimPrimaryWep:AlignTop(5)
	self.VictimPrimaryWep:AlignRight(10 + self.FlagContainer:GetWide() + 10 + self.VictimTag:GetWide() + 5 + self.VictimName:GetWide() + 5 + victim_death_margin + 6)

	self.Timestamp:AlignLeft(10)
	self.Timestamp:AlignBottom(5)

	self.vgui_InstigatorFrac = self.data[GAS.Logging.PvP_INSTIGATOR_DMG_GVN] / self.data[GAS.Logging.PvP_TOTAL_DMG]
	self.vgui_VictimFrac     = self.data[GAS.Logging.PvP_VICTIM_DMG_GVN] / self.data[GAS.Logging.PvP_TOTAL_DMG]
	self.vgui_OtherFrac      = (self.data[GAS.Logging.PvP_TOTAL_DMG] - self.data[GAS.Logging.PvP_INSTIGATOR_DMG_GVN] - self.data[GAS.Logging.PvP_VICTIM_DMG_GVN]) / self.data[GAS.Logging.PvP_TOTAL_DMG]
	if (self.data[GAS.Logging.PvP_TOTAL_DMG] == 0) then self.vgui_OtherFrac = 1 self.vgui_VictimFrac = 0 self.vgui_InstigatorFrac = 0 end

	self.vgui_InstigatorWidth = (w - 6 - 10 - self.FlagContainer:GetWide() - 10 - 48 - 10 - 10 - 48 - 10) * self.vgui_InstigatorFrac
	self.vgui_VictimWidth     = (w - 6 - 10 - self.FlagContainer:GetWide() - 10 - 48 - 10 - 10 - 48 - 10) * self.vgui_VictimFrac
	self.vgui_OtherWidth      = (w - 6 - 10 - self.FlagContainer:GetWide() - 10 - 48 - 10 - 10 - 48 - 10) * self.vgui_OtherFrac
end

function PANEL:OnCursorMoved(x,y)
	local w,h = self:GetSize()
	if (y >= (h - 10 - 48) and y <= h - 10 and x >= 10 + 48 + 10 and x <= w - 6 - 10 - self.FlagContainer:GetWide() - 10 - 48 - 10) then
		local relative_x = x - 10 - 48 - 10
		local DmgTooltip = self.DmgTooltip
		if (relative_x <= self.vgui_InstigatorWidth) then
			self.DmgTooltip = 1
		elseif (relative_x <= self.vgui_InstigatorWidth + self.vgui_OtherWidth) then
			self.DmgTooltip = 2
		else
			self.DmgTooltip = 3
		end
		if (DmgTooltip ~= self.DmgTooltip) then
			bVGUI.DestroyTooltip()
			local tt = {
				VGUI_Element = self,
			}
			if (self.DmgTooltip == 1) then
				tt.Text = math.Round(self.vgui_InstigatorFrac * 100, 2) .. L"DmgTooltip_Instigator"
				tt.TextColor = Color(216,76,76)
			elseif (self.DmgTooltip == 2) then
				tt.Text = math.Round(self.vgui_OtherFrac * 100, 2) .. L"DmgTooltip_Other"
				tt.TextColor = Color(74,126,214)
			else
				tt.Text = math.Round(self.vgui_VictimFrac * 100, 2) .. L"DmgTooltip_Victim"
				tt.TextColor = Color(76,216,76)
			end
			bVGUI.CreateTooltip(tt)
		end
	else
		self.DmgTooltip = nil
		bVGUI.DestroyTooltip()
	end
end

local stripes = Material("gmodadminsuite/stripes4.png")
function PANEL:Paint(w,h)
	if (self.RowIndex ~= nil and self.RowIndex % 2 ~= 0) then
		surface.SetDrawColor(255,255,255,75)
	else
		surface.SetDrawColor(255,255,255,200)
	end
	surface.SetMaterial(stripes)
	surface.DrawTexturedRect(0,0,w,h)

	surface.SetDrawColor(198,19,19)
	surface.DrawRect(48 + 10 + 10, h - 10 - 48 - 14, self.vgui_InstigatorWidth, 48)

	surface.SetDrawColor(19,198,19)
	surface.DrawRect(w - 6 - 10 - self.FlagContainer:GetWide() - 10 - 48 - 10 - self.vgui_VictimWidth, h - 10 - 48 - 14, self.vgui_VictimWidth, 48)

	surface.SetDrawColor(32,32,173)
	surface.DrawRect(48 + 10 + 10 + self.vgui_InstigatorWidth, h - 10 - 48 - 14, self.vgui_OtherWidth, 48)

	surface.SetDrawColor(255,255,255,255)
	surface.SetMaterial(bVGUI.MATERIAL_GRADIENT)
	surface.DrawTexturedRect(10 + 48 + 10,h - 10 - 48 - 14,w - 6 - 10 - self.FlagContainer:GetWide() - 10 - 48 - 10 - 48 - 10 - 10,48)

	if (self.vgui_InstigatorWidth >= 50) then
		draw.SimpleText(math.Round(self.vgui_InstigatorFrac * 100) .. "%", "gas_logging_damagelog_pct", 10 + 48 + 10 + (self.vgui_InstigatorWidth / 2), h - 10 - (48 / 2) - 14, bVGUI.COLOR_WHITE,TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)
	end
	if (self.vgui_VictimWidth >= 50) then
		draw.SimpleText(math.Round(self.vgui_VictimFrac * 100) .. "%", "gas_logging_damagelog_pct", w - 6 - 10 - self.FlagContainer:GetWide() - 10 - 48 - 10 - (self.vgui_VictimWidth / 2), h - 10 - (48 / 2) - 14, bVGUI.COLOR_WHITE,TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)
	end
	if (self.vgui_OtherWidth >= 50) then
		draw.SimpleText(math.Round(self.vgui_OtherFrac * 100) .. "%", "gas_logging_damagelog_pct", 10 + 48 + 10 + self.vgui_InstigatorWidth + (self.vgui_OtherWidth / 2), h - 10 - (48 / 2) - 14, bVGUI.COLOR_WHITE,TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)
	end
end

derma.DefineControl("GAS.Logging.DamageLog", nil, PANEL, "bVGUI.BlankPanel")
--addons/billy_gas/lua/vgui/openpermissions_checkbox.lua:
local PANEL = {}

function PANEL:Init()
	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")
	self:SetSize(16,16)

	self.Crossable = false
	self.Checked = false
end

function PANEL:SetCrossable(crossable)
	self.Crossable = crossable == true
	if (crossable) then
		self.Checked = 0
	else
		self.Checked = false
	end
end
function PANEL:IsCrossable()
	return self.Crossable
end

function PANEL:DoClick()
	self:SetAmbigious(false)
	if (self.Crossable) then
		self.Checked = self.Checked + 1
		if (self.Checked == 3) then
			self.Checked = 0
		end
	else
		self.Checked = not self.Checked
	end
	if (self.OnChange) then
		self:OnChange()
	end
end
function PANEL:DoRightClick()
	if (self.Crossable) then
		self:SetAmbigious(false)
		self.Checked = self.Checked - 1
		if (self.Checked == -1) then
			self.Checked = 2
		end
		if (self.OnChange) then
			self:OnChange()
		end
	end
end

function PANEL:OnMousePressed(m)
	if (m == MOUSE_LEFT) then
		self.Debounce_LEFT = true
	elseif (m == MOUSE_RIGHT) then
		self.Debounce_RIGHT = true
	end
end
function PANEL:OnMouseReleased(m)
	if (m == MOUSE_LEFT) then
		if (self.Debounce_LEFT) then
			self:DoClick()
		end
		self.Debounce_LEFT = nil
	elseif (m == MOUSE_RIGHT) then
		if (self.Debounce_RIGHT) then
			self:DoRightClick()
		end
		self.Debounce_RIGHT = nil
	end
end

function PANEL:GetChecked()
	return self.Checked
end
function PANEL:SetChecked(checked)
	self:SetAmbigious(false)
	self.Checked = checked
end

function PANEL:SetAmbigious(ambigious)
	self.Ambigious = ambigious
end
function PANEL:IsAmbigious()
	return self.Ambigious
end

local mat_checked = Material("openpermissions/checked.vtf")
local mat_crossed = Material("openpermissions/crossed.vtf")
local darker_soft_green = Color(52,145,52)
function PANEL:Paint(w,h)
	surface.SetDrawColor(OpenPermissions.COLOR_WHITE)
	surface.DrawRect(0,0,w,h)

	if (self.Crossable and self.Ambigious) then
		surface.SetDrawColor(OpenPermissions.COLOR_BLACK)
	elseif (self.Checked == true or self.Checked == 1) then
		surface.SetDrawColor(darker_soft_green)
	elseif (self.Checked == 2) then
		surface.SetDrawColor(OpenPermissions.COLOR_SOFT_RED)
	else
		surface.SetDrawColor(OpenPermissions.COLOR_BLACK)
	end
	surface.DrawOutlinedRect(0,0,w,h)

	if (self.Crossable and self.Ambigious) then
		surface.SetDrawColor(OpenPermissions.COLOR_SOFT_GREEN)
		surface.DrawRect(3,3,w - 6, h - 6)
	elseif (self.Checked == true or self.Checked == 1) then
		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(mat_checked)
		surface.DrawTexturedRect(0,0,w,h)
	elseif (self.Checked == 2) then
		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(mat_crossed)
		surface.DrawTexturedRect(0,0,w,h)
	end
end

derma.DefineControl("OpenPermissions.Checkbox", nil, PANEL, "DPanel")
--addons/billy_gas/lua/vgui/openpermissions_horizontaldivider.lua:
local PANEL = {}

function PANEL:SetRightWidth(width)
	self.InitialRightWidth = width

	local oldpaint = self.Paint
	self.Paint = function(self, w, h)
		self:SetLeftWidth(w - self.InitialRightWidth)
		self.Paint = oldpaint
	end
end

function PANEL:BalanceWidths()
	local oldpaint = self.Paint
	self.Paint = function(self, w, h)
		self:SetLeftWidth((w - self:GetDividerWidth()) / 2)
		self.Paint = oldpaint
	end
end

derma.DefineControl("OpenPermissions.HorizontalDivider", nil, PANEL, "DHorizontalDivider")
--addons/billy_gas/lua/vgui/openpermissions_tooltip.lua:
local bg_color = Color(43,48,58,255)

local PANEL = {}

function PANEL:Init()
	self:SetDrawOnTop(true)

	self.Label = vgui.Create("DLabel", self)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.Label:SetText("Tooltip")
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetContentAlignment(5)
	self.Label:SetWrap(true)

	self.Arrow = {
		{x = 0, y = 0},
		{x = 0, y = 0},
		{x = 0, y = 0}
	}
end

function PANEL:Paint(w,h)
	draw.RoundedBox(4, 0, 0, w, h, self.BackgroundColor or bg_color)
	surface.DisableClipping(true)

	surface.SetDrawColor(self.BackgroundColor or bg_color)
	draw.NoTexture()

	self.Arrow[1].x = w / 2 - 7
	self.Arrow[1].y = h

	self.Arrow[2].x = w / 2 + 7
	self.Arrow[2].y = h

	self.Arrow[3].x = w / 2
	self.Arrow[3].y = h + 7

	surface.DrawPoly(self.Arrow)

	surface.DisableClipping(false)
end

function PANEL:Think()
	local x,y = self.Label:GetSize()
	self:SetSize(x + 15, y + 7)
	self.Label:Center()
	local x,y = gui.MousePos()
	self:SetPos(x - self:GetWide() / 2, y - self:GetTall() - 14 - 5)

	if (not system.HasFocus()) then
		self:Remove()
	elseif (self.VGUI_Element) then
		if (not IsValid(self.VGUI_Element)) then
			self:Remove()
		elseif (vgui.GetHoveredPanel() ~= self.VGUI_Element) then
			if (self.HoverFrameNumber) then
				if (FrameNumber() > self.HoverFrameNumber) then
					self:Remove()
				end
			else
				self.HoverFrameNumber = FrameNumber() + 1
			end
		end
	end
end

function PANEL:SetText(text)
	self.Label:SetText(text)
	self.Label:SetWrap(false)
	self.Label:SizeToContentsX()
	if (self.Label:GetWide() >= 200) then
		self.Label:SetWide(200)
		self.Label:SetWrap(true)
		self.Label:SetAutoStretchVertical(true)
	end
end

derma.DefineControl("OpenPermissions.Tooltip", nil, PANEL, "DPanel")
--addons/tools/lua/vgui/stackercontrolpresets.lua:
--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

local PANEL = {}

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
--	PANEL:OpenPresetEditor()
--
--]]--
function PANEL:OpenPresetEditor()
	if ( not self.m_strPreset ) then return end
	self.Window = vgui.Create( "StackerPresetEditor" )
	self.Window:MakePopup()
	self.Window:Center()
	self.Window:SetType( self.m_strPreset )
	self.Window:SetConVars( self.ConVars )
	self.Window:SetPresetControl( self )
end

vgui.Register( "StackerControlPresets", PANEL, "ControlPresets" )
--gamemodes/starwarsrp/gamemode/shared.lua:
AOCRP = AOCRP or {}
AOCRP.NotFirstTimeLoad = AOCRP.NotFirstTimeLoad or true

AddCSLuaFile("config.lua")
include("config.lua")

AddCSLuaFile("player_class/player_aocrp.lua")
include("player_class/player_aocrp.lua")


AOCRP.Perm = AOCRP.Perm or {}

function AOCRP.Perm:AddPermission(name, cat)
    if !cat then 
        cat = "AOCRP"
    else
        cat = "AOCRP - " .. cat
    end 
     
    sam.permissions.add(name, cat, "superadmin")
end

function AOCRP.Perm:HasPermission(ply, perm)
    return ply:HasPermission(perm)      
end

    -- Spawning
    local subcategory = "Spawning"
    AOCRP.Perm:AddPermission("NPC", subcategory)
    AOCRP.Perm:AddPermission("Prop", subcategory)
    AOCRP.Perm:AddPermission("Ragdoll", subcategory)
    AOCRP.Perm:AddPermission("Effect", subcategory)
    AOCRP.Perm:AddPermission("SENT", subcategory)
    AOCRP.Perm:AddPermission("Vehicle", subcategory)
    AOCRP.Perm:AddPermission("SWEP", subcategory)

    local subcategory = "Sanbox"
    AOCRP.Perm:AddPermission("DeathLog", subcategory)
    AOCRP.Perm:AddPermission("QMenu", subcategory)
    AOCRP.Perm:AddPermission("CMenu", subcategory)
    AOCRP.Perm:AddPermission("Properties", subcategory)

    local subcategory = "Sonstiges"
    AOCRP.Perm:AddPermission("PermaProps", subcategory)

--[[ 
if AOCRP.NotFirstTimeLoad then
    print("****** Reloading Age of Clones Roleplay Gamemode *******")
    print("###> Verison : " .. AOCRP.Config.Version )
    print("###> Made by: Lt.Sammy & Jimmy")
    print("*******************************************************")
else
    print("******* Loading Age of Clones Roleplay Gamemode *******")
    print("###> Verison : " .. AOCRP.Config.Version )
    print("###> Made by: Lt.Sammy & Jimmy")
    print("*******************************************************") 
end ]]


function GM:ShowHelp( ply ) 
end
function GM:ShowTeam( ply ) 
end
function GM:ShowSpare1( ply ) 
end
function GM:ShowSpare2( ply ) 
end



local function MuteToolGun()
	local toolgun = weapons.GetStored("gmod_tool")

	if not istable(toolgun) then return end

    function toolgun:DoShootEffect(hitpos, hitnorm, ent, physbone, predicted)

		self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)
		self:GetOwner():SetAnimation(PLAYER_ATTACK1)

		return
    end
end

function GM:InitPostEntity()
    MuteToolGun()
end

function GM:PreCleanupMap()
    print("[AOCRP] Map Cleanup called.")
end

function GM:PlayerFootstep( ply, pos, foot, sound, volume, rf )
    if ply:Crouching() then
        return true 
    end
    return 
end

function AOCRP:Kick(player,message)
    if SERVER then
        player:Kick(message)
    end
    if CLIENT then
        net.Start("AOCRP.Kick")
        net.WriteString(message)
        net.SendToServer()    
    end
end

if SERVER then
    util.AddNetworkString("AOCRP.Kick")

    net.Receive("AOCRP.Kick", function(len, ply)
        local message = net.ReadString()
        AOCRP:Kick(ply,message)
    end)    
end



hook.Add("EntityEmitSound", "AOC.MuteToolgunSound", function(data)
    local MuteSoundNames = {"Airboat.FireGunRevDown"} -- Mute toolgun
    local MuteSoundPaths = {}
    
    if table.HasValue(MuteSoundNames, data.OriginalSoundName) then
        return false
    end
    if table.HasValue(MuteSoundPaths,data.SoundName) then
        return false
    end
end)
--gamemodes/starwarsrp/gamemode/modules/ribbons/sh_ribbons.lua:
AOCRP.Ribbons = AOCRP.Ribbons or {}


function AOCRP.Ribbons:Exists(ribbonid)
    if AOCRP.Ribbons.Data[ribbonid] then
        return true
    end
    return false
end

function AOCRP.Ribbons:GetRibbon(ribbonid)
    return AOCRP.Ribbons.Data[ribbonid]
end

function AOCRP.Ribbons:PlayerGetRibbon(ply,slot)
    return ply:GetNetVar("AOCRP.Ribbons."..slot, 0)
end



function AOCRP.Ribbons:PlayerGetActiveRibbons(ply)
    local ribbons = {}
    
    if ply:GetNetVar("AOCRP.Ribbons.1", 0) != 0 then
        table.insert(ribbons, ply:GetNetVar("AOCRP.Ribbons.1", 0) )
    end
    if ply:GetNetVar("AOCRP.Ribbons.2", 0) != 0 then
        table.insert(ribbons, ply:GetNetVar("AOCRP.Ribbons.2", 0) )
    end
    if ply:GetNetVar("AOCRP.Ribbons.3", 0) != 0 then
        table.insert(ribbons, ply:GetNetVar("AOCRP.Ribbons.3", 0) )
    end

    return ribbons
end

function AOCRP.Ribbons:RibbonActive(ply, ribbon)
    return table.HasValue(AOCRP.Ribbons:PlayerGetActiveRibbons(ply), ribbon)
end



function AOCRP.Ribbons:RealodRibbonData()

    if CLIENT then
        AOCRP.ClientLoad:AddLoad("getribbons", "Lade Ribbons", function(data) 
        
            AOCRP.Ribbons = AOCRP.Ribbons or {}
            AOCRP.Ribbons.Data = {}
            for k, v in pairs(data) do 
                AOCRP.Ribbons.Data[v.ribbonid] = v
            end 
        
        end)
        AOCRP.ClientLoad:StartLoad()
    end
    if SERVER then
        net.Start("AOCRP.Ribbons.ReloadData")
        net.Broadcast()

        AOCRP.ServerLoad:AddLoad("Ribbons", "ribbons", function(data) 
            if istable(data) then
                AOCRP.Ribbons = AOCRP.Ribbons or {}
                AOCRP.Ribbons.Data = {}
                for k, v in pairs(data) do 
                    AOCRP.Ribbons.Data[v.ribbonid] = v
                end 
            end
        end)
        AOCRP.ServerLoad:StartLoad()
    end
end

if SERVER then
    
    util.AddNetworkString("AOCRP.Ribbons.ReloadData")

end

if CLIENT then
    
    net.Receive( "AOCRP.Ribbons.ReloadData", function( len, ply )
        AOCRP.Ribbons:RealodRibbonData()
    end)
end

--gamemodes/starwarsrp/gamemode/modules/gui/cl_escapemenu.lua:
local MenuGradient = Material( "html/img/gradient.png", "nocull smooth" )


PIXEL.RegisterFont("AOCRP_EscapeMenuButton", "Agency FB", 50, 100)

--[[ hook.Add('PreRender', 'AOCRP_EscapeMenuBtnHook', function()
  
     if AOCRP_SUPRESS_ESCAPE_MENU then
        gui.HideGameUI()
    else
        if input.IsKeyDown(KEY_ESCAPE) and gui.IsGameUIVisible() then
            if ValidPanel(AOCEscape_BaseFrame) then
                gui.HideGameUI()
                AOCEscape_BaseFrame:Remove()
            else
                gui.HideGameUI()
                AOCRP_OpenEscapeMenu()
            end
        end
    end 
end) ]]

hook.Add( "OnPauseMenuShow", "DisableMenu", function()
    if !ValidPanel(AOCEscape_BaseFrame) then
	    AOCRP_OpenEscapeMenu()
    else 
        AOCEscape_BaseFrame:Remove()
    end
	return false
end )


local function AOCRP_Disconecct()

    --AOCDerma:CreateLoadingScreen("Speichere Spielerdaten")

    net.Start("AOCRP.Player.DisconnectSave")
    net.SendToServer()

    LocalPlayer():ConCommand("disconnect")

--[[     timer.Simple(5, function() 
        LocalPlayer():ConCommand("disconnect")
    end) ]]
end



function AOCRP_OpenEscapeMenu()
        if ValidPanel(AOCEscape_BaseFrame) then AOCEscape_BaseFrame:Remove() end
        AOCEscape_BaseFrame = vgui.Create("DFrame")
        AOCEscape_BaseFrame:SetSize(ScrW(), ScrH())
        AOCEscape_BaseFrame:Center()
        AOCEscape_BaseFrame:SetTitle("")
        AOCEscape_BaseFrame:SetDraggable(false)
        AOCEscape_BaseFrame:ShowCloseButton(false)
        function AOCEscape_BaseFrame:Paint(w,h)
              PIXEL.DrawBlur(self, 0, 0, w, h)
            surface.SetMaterial( MenuGradient )
            surface.SetDrawColor( 255, 255, 255, 255 )
            surface.DrawTexturedRect( 0, 0, ScrW()*0.6, ScrH() )
        end
        AOCEscape_BaseFrame:MakePopup()

        AOCEscape_BaseFrame.Logo = vgui.Create("DPanel", AOCEscape_BaseFrame)

        AOCEscape_BaseFrame.Logo:SetPos(AOCH(70),-AOCH(120))
         AOCEscape_BaseFrame.Logo:SetSize(AOCH(450), AOCH(450))
        function AOCEscape_BaseFrame.Logo:Paint(w,h)
	        PIXEL.DrawImgur(0, 0, w, h, AOCRP.Config.Logo, Color(255,255,255,255) )
        end
-- Altes Logo für nach Silvester/Jubiläum: 4qCpQT8

        AOCEscape_BaseFrame.MenuPanel = vgui.Create("DPanel", AOCEscape_BaseFrame)
        AOCEscape_BaseFrame.MenuPanel:SetPos(AOCH(70),AOCH(200))
        AOCEscape_BaseFrame.MenuPanel:SetSize(AOCH(450), AOCH(850))
        function AOCEscape_BaseFrame.MenuPanel:Paint(w,h)
            --draw.RoundedBox(0, 0, 0, w, h, Color(255,0,0,100))
        end

        --Optix_Menu:LoadMenu(AOCEscape_BaseFrame.MenuPanel)
        local firstbtn = AOCRPEscButton(AOCEscape_BaseFrame.MenuPanel, "Weiterspielen", function() AOCEscape_BaseFrame:Remove() end, "top")
        firstbtn:DockMargin(0,AOCH(10),0,0)
        firstbtn:Dock(TOP)
        

        local firstbtn = AOCRPEscButton(AOCEscape_BaseFrame.MenuPanel, "Charaktermenü", function() AOCEscape_BaseFrame:Remove() LocalPlayer():ConCommand("aocrp_charmenu") end)
        firstbtn:DockMargin(0,AOCH(23),0,0)
        firstbtn:Dock(TOP)
        

        local firstbtn = AOCRPEscButton(AOCEscape_BaseFrame.MenuPanel, "Mein Charakter", function() AOCEscape_BaseFrame:Remove()  LocalPlayer():ConCommand("aocrp_mychar") end)
        --firstbtn:DockMargin(0,AOCH(10),0,0)
        firstbtn:Dock(TOP)
        


        

                local firstbtn = AOCRPEscButton(AOCEscape_BaseFrame.MenuPanel, "Galactic Trade Market", function() AOCEscape_BaseFrame:Remove() AOCRP.GTM:OpenMenu() end)
        --firstbtn:DockMargin(0,AOCH(10),0,0)
        firstbtn:Dock(TOP)
        

                local firstbtn = AOCRPEscButton(AOCEscape_BaseFrame.MenuPanel, "AOC:RP Einstellungen", function() AOCEscape_BaseFrame:Remove()  AOCRP.PlayerSettings:OpenMenu() end)
        --firstbtn:DockMargin(0,AOCH(10),0,0)
        firstbtn:Dock(TOP)
        

                local firstbtn = AOCRPEscButton(AOCEscape_BaseFrame.MenuPanel, "Discord", function() AOCEscape_BaseFrame:Remove() gui.OpenURL("https://discord.gg/ageofclones") end)
        --firstbtn:DockMargin(0,AOCH(10),0,0)
        firstbtn:Dock(TOP)
        

                local firstbtn = AOCRPEscButton(AOCEscape_BaseFrame.MenuPanel, "AOC:RP Content", function()  AOCEscape_BaseFrame:Remove() gui.OpenURL("https://steamcommunity.com/sharedfiles/filedetails/?id=2957600901") end)
        --firstbtn:DockMargin(0,AOCH(10),0,0)
        firstbtn:Dock(TOP)
        

                local firstbtn = AOCRPEscButton(AOCEscape_BaseFrame.MenuPanel, "Spieleinstellungen", function() 
                    AOCEscape_BaseFrame:Remove()         
                    gui.ActivateGameUI()
                    RunConsoleCommand("gamemenucommand", "openoptionsdialog") 
                end)
        --firstbtn:DockMargin(0,AOCH(10),0,0)
        firstbtn:Dock(TOP)

                local firstbtn = AOCRPEscButton(AOCEscape_BaseFrame.MenuPanel, "Spiel beenden", function() RunConsoleCommand("gamemenucommand", "Quit") end)
        --firstbtn:DockMargin(0,AOCH(10),0,0)
        firstbtn:Dock(TOP) 
        firstbtn.akzent = Color(196,0,0)
        firstbtn.akzenthover = Color(255,0,0)


        

        local lastbtn = AOCRPEscButton(AOCEscape_BaseFrame.MenuPanel, "Server verlassen", function()  RunConsoleCommand("gamemenucommand", "Disconnect")  end, "bottom")
        lastbtn.akzent = Color(196,0,0)
        lastbtn.akzenthover = Color(255,0,0)
        lastbtn:Dock(BOTTOM)
end

function AOCRPEscButton(panel, text, func, special)
    local DButton = vgui.Create("DButton",panel)

    DButton:SetText("")
    DButton:SetTall(AOCH(80))

    DButton.btncolor = Color(0,0,0,210)
    DButton.akzent = Color(200,200,200,210)
    DButton.akzenthover = Color(255,255,255,210)
    DButton.textcolor = Color(200,200,200,255)
    DButton.textcolorhover = Color(255,255,255,255)

    DButton.akcl = DButton.akzent
    DButton.txtcl = DButton.textcolor

    function DButton:Paint(w,h)

        if self:IsHovered() then
            self.akcl = self.akzenthover
            self.txtcl = self.textcolorhover
        else
            self.akcl = self.akzent
            self.txtcl = self.textcolor
        end
        
        if special == "top" then
        draw.RoundedBox(0, AOCW(8), AOCH(8), w-AOCW(20), AOCH(5), DButton.akcl)
        end
        if special == "bottom" then
        draw.RoundedBox(0, AOCW(8), h-AOCH(8), w-AOCW(20), AOCH(5), DButton.akcl)
        end   
        draw.RoundedBox(0, AOCW(8), AOCH(12), AOCW(5), h-AOCH(20), DButton.akcl)
        draw.DrawText(text,PIXEL.UI.RegisteredFonts["AOCRP_EscapeMenuButton"],AOCW(30),AOCH(15),self.txtcl, TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT)
    end
    function DButton:OnCursorEntered()
        surface.PlaySound("everfall/miscellaneous/ux/navigation/navigation_slider_02.mp3")
    end
    function DButton:DoClickInternal()
        surface.PlaySound("everfall/miscellaneous/ux/navigation/navigation_activate_01.mp3")
	end

    function DButton:DoClick()
        func()
    end
    return DButton
end


concommand.Add( "cesc", function( ply, cmd, args )
    AOCRP_OpenEscapeMenu()
end )




--gamemodes/starwarsrp/gamemode/modules/datapad/sh_datapad.lua:
if SERVER then return end


AOCRP.Datapad = AOCRP.Datapad or {}
AOCRP.Datapad.Apps = AOCRP.Datapad.Apps or {}


AOCDerma:RegisterFont("FunkLog_Title", "Agency FB", 50, 1)

AOCRP.Datapad.Apps["chromium"] = {
    title = "! Du hast kein Chromium !",
    canOpen = function(ply) return !AOCRP:HasChromium() end,
    onOpen = function(frame) 
        local html = vgui.Create("DHTML", frame)
        html:Dock(TOP)
        html:OpenURL("https://forum.212th.de/lexicon/index.php?entry/118-guide-chromium-beta/#tab_cd72f9df4c41cae41a719ef5bd7e123780a3eff8")
        html:SetTall(frame:GetTall())

    end,

}



AOCRP.Datapad.Apps["galaxymap"] = {
    title = "Galaxiskarte",
    canOpen = function(ply) return AOCRP:HasChromium() end,
    onOpen = function(frame) 
        local html = vgui.Create("DHTML", frame)
        html:Dock(TOP)
        html:OpenURL("https://hbernberg.carto.com/builder/6650a85d-b115-4680-ab97-721bf8a41a90/embed/")
        html:SetTall(frame:GetTall())

    end,

}




AOCRP.Datapad.Games = {
    {
        name = "Norman the Necromancer",
        image = "entities/ofmg_games/norman-the-necromancer.jpg",
        url = "https://js13kgames.com/games/norman-the-necromancer/index.html"
    },
    {
        name = "Steer Clear",
        image = "entities/ofmg_games/steer-clear.jpg",
        url = "https://js13kgames.com/games/steer-clear/index.html"
    },
    {
        name = "Spaceship Repair Factory",
        image = "entities/ofmg_games/spaceship-repair-factory.jpg",
        url = "https://js13kgames.com/games/spaceship-repair-factory/index.html"
    },
    {
        name = "Zigzagoon Overdrive Tower Defense",
        image = "entities/ofmg_games/zigzagoon-overdrive-tower-defense.jpg",
        url = "https://js13kgames.com/games/zigzagoon-overdrive-tower-defense/index.html"
    },
    {
        name = "Spaceship Wars 13k",
        image = "entities/ofmg_games/spaceship-wars-13k.jpg",
        url = "https://js13kgames.com/games/spaceship-wars-13k/index.html"
    },
    {
        name = "Keep Your Space",
        image = "entities/ofmg_games/keep-your-space.jpg",
        url = "https://js13kgames.com/games/keep-your-space/index.html"
    },
    {
        name = "Temporal Tift",
        image = "entities/ofmg_games/temporal-rift.jpg",
        url = "https://js13kgames.com/games/temporal-rift/index.html"
    },
    {
        name = "I've been Ghosting",
        image = "entities/ofmg_games/ive-been-ghosting.jpg",
        url = "https://js13kgames.com/games/ive-been-ghosting/index.html"
    },
    {
        name = "Moto X3M",
        image = "entities/ofmg_games/motox3m.png",
        url = "https://shadowgmes.github.io/gfiles/motox3m/"
    },
    {
        name = "Doom",
        image = "entities/ofmg_games/doom.png",
        url = "https://shadowgmes.github.io/gfiles/doom/"
    },
    {
        name = "Poom",
        image = "entities/ofmg_games/poom.png",
        url = "https://shadowgmes.github.io/gfiles/poom/"
    },
    {
        name = "Waterworks",
        image = "entities/ofmg_games/waterworks.png",
        url = "https://shadowgmes.github.io/gfiles/waterworks/"
    },
    {
        name = "Hextris",
        image = "entities/ofmg_games/hextris.png",
        url = "https://shadowgmes.github.io/gfiles/hextris/"
    },
    {
        name = "Friday Night Funkin",
        image = "entities/ofmg_games/fnf-week7.png",
        url = "https://shadowgmes.github.io/gfiles/fnf-week7/"
    },
    {
        name = "Tetris",
        image = "entities/ofmg_games/tetris.png",
        url = "https://shadowgmes.github.io/gfiles/tetris/"
    },
    {
        name = "Doodle Jump",
        image = "entities/ofmg_games/doodle-jump.png",
        url = "https://shadowgmes.github.io/gfiles/doodle-jump/"
    },
    {
        name = "0hn0",
        image = "entities/ofmg_games/0hn0.png",
        url = "https://shadowgmes.github.io/gfiles/0hn0/"
    },
    {
        name = "0hn1",
        image = "entities/ofmg_games/0hn1.png",
        url = "https://shadowgmes.github.io/gfiles/0hh1/"
    },
    {
        name = "Blue",
        image = "entities/ofmg_games/blue.png",
        url = "https://shadowgmes.github.io/gfiles/blue/"
    },
    {
        name = "Chess",
        image = "entities/ofmg_games/chess.png",
        url = "https://shadowgmes.github.io/gfiles/chess/"
    },
    {
        name = "Pac Man",
        image = "entities/ofmg_games/pac-man.png",
        url = "https://shadowgmes.github.io/gfiles/pac-man/"
    },
    {
        name = "Tiny Fishing",
        image = "entities/ofmg_games/tinyfishing.png",
        url = "https://shadowgmes.github.io/gfiles/tinyfishing/"
    },
    {
        name = "Very Normal Shooter",
        image = "entities/ofmg_games/verynormalshooter.png",
        url = "https://shadowgmes.github.io/gfiles/verynormalshooter/"
    },
    {
        name = "Wordle",
        image = "entities/ofmg_games/wordle.png",
        url = "https://shadowgmes.github.io/gfiles/wordle/"
    },
    {
        name = "Sandboxels",
        image = "entities/ofmg_games/sandboxels.png",
        url = "https://shadowgmes.github.io/gfiles/sandboxels/"
    },
    {
        name = "CSGO Clicker",
        image = "entities/ofmg_games/csgoclicker.png",
        url = "https://shadowgmes.github.io/gfiles/csgo-clicker/"
    },
    {
        name = "Incremancer",
        image = "entities/ofmg_games/incremancer.png",
        url = "https://shadowgmes.github.io/gfiles/incremancer/"
    },
    {
        name = "Space Company",
        image = "entities/ofmg_games/SpaceCompany.png",
        url = "https://sparticle999.github.io/SpaceCompany/"
    },
    {
        name = "Sleeping Beauty",
        image = "entities/ofmg_games/sleeping-beauty.png",
        url = "https://ondras.github.io/sleeping-beauty/"
    },
    {
        name = "Tetris",
        image = "entities/ofmg_games/tetris2.png",
        url = "https://ytiurin.github.io/tetris/"
    },
    {
        name = "Minesweeper",
        image = "entities/ofmg_games/minesweeper2.png",
        url = "https://russo97.github.io/Minesweeper/"
    },
    {
        name = "Archery World Tour",
        image = "entities/ofmg_games/archery-world-tour.jpg",
        url = "https://play.famobi.com/archery-world-tour"
    },
    {
        name = "Table Tennis World Tour",
        image = "entities/ofmg_games/table-tennis-world-tour.jpg",
        url = "https://play.famobi.com/table-tennis-world-tour"
    },
    {
        name = "Om Nom Bubbles",
        image = "entities/ofmg_games/om-nom-bubbles.jpg",
        url = "https://play.famobi.com/wrapper/om-nom-bubbles"
    },
    {
        name = "Biker Street",
        image = "entities/ofmg_games/biker-street.jpg",
        url = "https://play.famobi.com/wrapper/biker-street"
    },
    {
        name = "Gold Miner Tom",
        image = "entities/ofmg_games/gold-miner-tom.jpg",
        url = "https://play.famobi.com/wrapper/gold-miner-tom"
    },
}


function AOCRP.Datapad:AddGamesButton(pnl, search)


    for k, v in ipairs(AOCRP.Datapad.Games) do


        if string.find(v.name, search) then 
                local btn = AOCDerma:Button(pnl, v.name, function() 
                    AOCRP.Datapad.MainFrame.OpenGame = k 
                    AOCRP.Datapad.MainFrame.ContentPanel:Clear() 
                    local html = vgui.Create("DHTML", AOCRP.Datapad.MainFrame.ContentPanel)
                    html:Dock(TOP)
                    html:SetTall(AOCRP.Datapad.MainFrame.ContentPanel:GetTall())
                    html:OpenURL(v.url)

                end, "b")
                btn:Dock(TOP)
                btn:DockMargin(0,0,AOCW(10),AOCH(10))
                btn.Game = k

                function btn:PaintOver(w,h)
                    if self.Game == AOCRP.Datapad.MainFrame.OpenGame then
                        self.akzent = Color(0,200,0)
                        self.akzenthover = Color(0,255,0)
                    else
                        self.akzent = Color(200,200,200)
                        self.akzenthover = Color(255,255,255)       
                    end
                end
        end
    end   
end
function AOCRP.Datapad:GamesReplaceAppPanel()
    self.MainFrame.MenuPanel:Clear()

    local btn = AOCDerma:Button(self.MainFrame.MenuPanel, "Zurück", function() 
        AOCRP.Datapad:DataPadFrame()

    end, "b")
    btn:Dock(BOTTOM)
    btn:DockMargin(0,AOCH(30),AOCW(10),AOCH(10))
    btn.akzent = Color(200,0,0)
    btn.akzenthover = Color(255,0,0)


    local searchEntry = AOCDerma:TextEntry(self.MainFrame.MenuPanel," Spiel suchen...")
    searchEntry:Dock(TOP)
    searchEntry:SetTall(AOCH(50))
    searchEntry:DockMargin(0,0,AOCW(10),AOCH(10))
    searchEntry:SetUpdateOnType( true )
    function searchEntry:OnValueChange(txt) 
         AOCRP.Datapad.MainFrame.AppPanel:Clear()
        
        AOCRP.Datapad:AddGamesButton(AOCRP.Datapad.MainFrame.AppPanel, txt)
    end

    self.MainFrame.AppPanel = AOCDerma:ScrollBar(self.MainFrame.MenuPanel)
    self.MainFrame.AppPanel:Dock(FILL)

    AOCRP.Datapad:AddGamesButton(AOCRP.Datapad.MainFrame.AppPanel, "")
end


AOCRP.Datapad.Apps["spiele"] = {
    title = "Spiele",
    canOpen = function(ply) return AOCRP:HasChromium() end,
    onOpen = function(frame) 

        AOCRP.Datapad:GamesReplaceAppPanel()


    end,

}

AOCRP.Datapad.Apps["sektorkarte"] = {
    title = "Sektorkarte",
    canOpen = function(ply) return true end,
    onOpen = function(frame) 
        local map = vgui.Create("DMap",frame )
        map:Dock(TOP)
        map:SetTall(frame:GetTall())
    end,


}

AOCRP.Datapad.Apps["regelungsgesetz"] = {
    title = "Regelungsgesetz",
    canOpen = function(ply) return true end,
    onOpen = function(frame) 
        local html = vgui.Create("DHTML", frame)
        html:Dock(TOP)
        html:OpenURL("https://forum.212th.de/lexicon/index.php?entry/170-regelungsgesetz/")
        html:SetTall(frame:GetTall())

    end,


}

AOCRP.Datapad.Apps["Strafgesetz"] = {
    title = "Strafgesetz",
    canOpen = function(ply) return true end,
    onOpen = function(frame) 
        local html = vgui.Create("DHTML", frame)
        html:Dock(TOP)
        html:OpenURL("https://forum.212th.de/lexicon/index.php?entry/169-strafgesetz/")
        html:SetTall(frame:GetTall())

    end,


}

local validUnits = {3,4,5,6,7,8,9,15}
AOCRP.Datapad.Apps["unitmanagement"] = {
    title = "Meine Einheit",
    canOpen = function(ply) return table.HasValue(validUnits, ply:GetUnitID())  end,
    onOpen = function(frame) 
       AOCRP.UnitMgmt:Datapad(LocalPlayer():GetUnitID())
    end,
}




local function EasyLabel(frame, text) 

    local loading = Label(text, frame)
    loading:Dock(TOP)
    loading:SetFont(AOCDerma:Font("FunkLog_Title"))
    loading:SetTextColor(Color(255,255,255))
    loading:SizeToContents()
    return loading
end 



local function eventFormatTime(unixTime)
    local formattedTime = os.date("%d.%m %H:%M", unixTime)
    return formattedTime
end

PIXEL.RegisterFont("AOCRP.ScoreBoard.EventType", "Agency FB", 30, 10)
PIXEL.RegisterFont("AOCRP.ScoreBoard.EventTitle", "Agency FB", 40, 1000)
PIXEL.RegisterFont("AOCRP.ScoreBoard.EventDesc", "Agency FB", 20, 10)
PIXEL.RegisterFont("AOCRP.ScoreBoard.EventTime", "Agency FB", 25, 10)




local function EventPanel(pnl, eventData)
    local eve = vgui.Create("DPanel", pnl)
    eve:Dock(TOP)
    eve:SetTall(AOCH(95))
    eve:DockMargin(0,0,0,AOCH(10))

    local ShowEventID = false 
    if table.HasValue(AOCRP.Config.Team, LocalPlayer():GetUserGroup()) then
        ShowEventID = true
    end

    function eve:Paint(w,h)

        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,100))
        draw.RoundedBox(0,0,h-1,w,1,Color(255,255,255))

        if ShowEventID then
            draw.DrawText(eventFormatTime(eventData.unix) .. " - " .. string.upper(eventData.type) .. " #"..eventData.id,PIXEL.UI.RegisteredFonts["AOCRP.ScoreBoard.EventTime"],w/2,AOCH(5),Color(255,255,255), TEXT_ALIGN_CENTER)
        else 
            draw.DrawText(eventFormatTime(eventData.unix) .. " - " .. string.upper(eventData.type),PIXEL.UI.RegisteredFonts["AOCRP.ScoreBoard.EventTime"],w/2,AOCH(5),Color(255,255,255), TEXT_ALIGN_CENTER)
        end

        draw.DrawText(string.upper(eventData.name),PIXEL.UI.RegisteredFonts["AOCRP.ScoreBoard.EventTitle"],w/2,AOCH(30),Color(255,255,255), TEXT_ALIGN_CENTER)
        draw.DrawText(eventData.description,PIXEL.UI.RegisteredFonts["AOCRP.ScoreBoard.EventDesc"],w/2,AOCH(65),Color(255,255,255), TEXT_ALIGN_CENTER) 

    end
end

--[[ AOCRP.Datapad.Apps["termine"] = {
    title = "Termine",
    canOpen = function(ply) return true end,
    onOpen = function(frame) 
        AOCRP.API:Request("getfutureevents", function(data) 
            if data then 
                for k, v in pairs(data) do
                    EventPanel(frame, v)
                end

                
                if table.IsEmpty( data ) then
                    EasyLabel(frame, "Es stehen keine Termine an.") 
                end
            else
                EasyLabel(frame, "Fehler beim Laden der Termine") 
            end

        end, {})
    end,
} ]]


function AOCRP.Datapad:PlayerInteractError(text,cloneid)
    self.MainFrame.ContentPanel:Clear() 

    local label = Label(text, self.MainFrame.ContentPanel)
    label:Dock(TOP)
    label:SetFont(AOCDerma:Font("FunkLog_Title"))
    label:SetTextColor(Color(255,255,255))
    label:SizeToContents()

    local btn = AOCDerma:Button(self.MainFrame.ContentPanel, "Schade", function() 
        AOCRP.Datapad:OpenPlayerInteract(cloneid)
    end, "bc")
    btn:Dock(TOP)
    btn:DockMargin(0,AOCH(50), 0, 0)

end 

AOCDerma:RegisterFont("PlayerAkte_Small", "Agency FB", 25, 1)
AOCDerma:RegisterFont("PlayerAkte_Title", "Agency FB", 50, 1)
AOCDerma:RegisterFont("PlayerAkte_Title_big", "Agency FB", 55, 1000)
AOCDerma:RegisterFont("PlayerAkte_RandomAurebesh", "Aurebesh", 20, 1)
function AOCRP.Datapad:OpenPlayerInteract(cloneid)

    self.MainFrame.ContentPanel:Clear() 

    local label = Label("REPUBLIKANISCHE DATENBANK - ID: "..cloneid, self.MainFrame.ContentPanel)
    label:Dock(TOP)
    label:SetFont(AOCDerma:Font("FunkLog_Title"))
    label:SetTextColor(Color(255,255,255))
    label:SizeToContents()


    local loading = Label("Kein Eintrag gefunden...", self.MainFrame.ContentPanel)
    loading:Dock(TOP)
    loading:SetFont(AOCDerma:Font("FunkLog_Title"))
    loading:SetTextColor(Color(255,255,255))
    loading:SizeToContents()

 

    AOCRP.API:Request("getpersonalaktedata", function(data)


        if #data["chars"] < 1 then return end 
        
        self.MainFrame.ContentPanel:Clear() 
     

        local firstData = data["chars"][1]
        local fortbildungData = data["fortbildung"]


        local infoPanel = vgui.Create("DPanel",self.MainFrame.ContentPanel)
        infoPanel:Dock(TOP)
        infoPanel:SetTall(AOCH(400))
        
        function infoPanel:Paint(w,h) 


            draw.DrawText("REPUBLIKANISCHE AKTE", AOCDerma:Font("PlayerAkte_Title_big"), w/2, 0, Color(255,255,255), TEXT_ALIGN_CENTER)
            draw.DrawText(cloneid, AOCDerma:Font("PlayerAkte_Title"), w/2, AOCH(50), Color(255,255,255), TEXT_ALIGN_CENTER)
            draw.DrawText('"'..firstData.name..'"', AOCDerma:Font("PlayerAkte_Title"), w/2, AOCH(100), Color(255,255,255), TEXT_ALIGN_CENTER)

            draw.RoundedBox(0,0,AOCH(170),w,1,Color(255,255,255))

            draw.DrawText(AOCRP.Unit:GetRankName(firstData.rankid, firstData.unitid), AOCDerma:Font("PlayerAkte_Title"), w*0.25, AOCH(175), Color(255,255,255), TEXT_ALIGN_CENTER)
            draw.DrawText(AOCRP.Units[tonumber(firstData.unitid)].name, AOCDerma:Font("PlayerAkte_Title"), w*0.75, AOCH(175), Color(255,255,255), TEXT_ALIGN_CENTER)

            draw.DrawText("Letzte Scanaktivität", AOCDerma:Font("PlayerAkte_Small"), w/2, AOCH(240), Color(255,255,255), TEXT_ALIGN_CENTER)
            draw.DrawText(firstData.lastjoin, AOCDerma:Font("PlayerAkte_Title"), w/2, AOCH(260), Color(255,255,255), TEXT_ALIGN_CENTER)

            draw.DrawText("DIR FEHLT DER AUREBESH FONT WENN DU DAS HIER LESEN KANNST ODER DU BIST EIN NERD", AOCDerma:Font("PlayerAkte_RandomAurebesh"), w/2, AOCH(320), Color(255,255,255), TEXT_ALIGN_CENTER)
            draw.DrawText("LANG LEBE DAS IMPERIUM OH WARTE MAL ICH MEINE VIVA LA REVOULUTION", AOCDerma:Font("PlayerAkte_RandomAurebesh"), w/2, AOCH(340), Color(255,255,255), TEXT_ALIGN_CENTER)
            draw.DrawText("ICH BIN EIN BERLINER ODER SPANDAUER ACH EGAL FICK RINO UND TOM JIMMY IST COOL", AOCDerma:Font("PlayerAkte_RandomAurebesh"), w/2, AOCH(360), Color(255,255,255), TEXT_ALIGN_CENTER)


        end

    
            local btn = AOCDerma:Button(self.MainFrame.ContentPanel, "Personalverwaltung", function() 
            
                
                    local Menu = DermaMenu()

                    local SubMenu = Menu:AddSubMenu( "Fortbildung geben" )

                    for k, v in pairs(AOCRP.Config.Fortbildungen) do
                        if LocalPlayer():GetRankID() < v.rank then continue end 
                        if !table.HasValue(v.unit, LocalPlayer():GetUnitID()) then continue end
                        SubMenu:AddOption( v.name ):SetIcon( "icon16/group.png" )
                    end

                    if LocalPlayer():GetRankID() > 15 then
                        local SubMenu = Menu:AddSubMenu( "Fortbildung nehmen" )

                        for k, v in pairs(fortbildungData) do 
                            if AOCRP.Config.Fortbildungen[v.fid] then
                                SubMenu:AddOption( AOCRP.Config.Fortbildungen[v.fid].name ):SetIcon( "icon16/cross.png" )
                            end
                        end 
                    end 

                    Menu:AddSpacer()
                    Menu:AddSpacer()

                    if firstData.unitid == LocalPlayer():GetUnitID() then
                        Menu:AddOption( "Befördern" )
                        Menu:AddOption( "Degradieren" )
                        -- Add a simple option.
                        Menu:AddSpacer()
                        Menu:AddSpacer()

                        Menu:AddOption( "Aus der Einheit entfernen" )
                    end
                    Menu:Open()
             
                    --AOCRP.Datapad:PlayerInteractError("Zugriff zur Personalverwaltung für "..cloneid.." nicht gestattet.",cloneid)
            
            
            end, "bc")
            btn:Dock(TOP)
            btn:DockMargin(0,AOCH(5), 0, 0)


        local btn = AOCDerma:Button(self.MainFrame.ContentPanel, "Strafeinträge", function() end, "bc")
        btn:Dock(TOP)
        btn:DockMargin(0,AOCH(5), 0, 0)

        local btn = AOCDerma:Button(self.MainFrame.ContentPanel, "Medizinische Einträge", function() end, "bc")
        btn:Dock(TOP)
        btn:DockMargin(0,AOCH(5), 0, 0)

        local btn = AOCDerma:Button(self.MainFrame.ContentPanel, "Personalprotokoll", function() end, "bc")
        btn:Dock(TOP)
        btn:DockMargin(0,AOCH(5), 0, 0)

        local btn = AOCDerma:Button(self.MainFrame.ContentPanel, "Fortbildungen", function() 
            textpanel:SetValue("Auszug aus der Fortbildungsdatenbank: \n")
            for k, v in pairs(fortbildungData) do 
                if AOCRP.Config.Fortbildungen[v.fid] then
                    textpanel:SetValue(textpanel:GetValue() .. " " .. AOCRP.Config.Fortbildungen[v.fid].name .. " - > ".. v.entrydate .. " - " .. v.givertext.."\n")
                end
            end 
            
        end, "bc")
        btn:Dock(TOP)
        btn:DockMargin(0,AOCH(5), 0, 0)



        textpanel = vgui.Create("DTextEntry",self.MainFrame.ContentPanel)
        textpanel:Dock(TOP)
        textpanel:SetTall(AOCH(300))
        textpanel:SetMultiline(true)
        textpanel:SetFont(AOCDerma:Font("DataPad_Notizen"))
        --headerPanel:SetEditable(false)
        textpanel:SetPaintBackground(false)
        textpanel:SetTextColor(Color(255,255,255))
        textpanel:SetVerticalScrollbarEnabled(true)


--[[ 
        local lbl = EasyLabel(self.MainFrame.ContentPanel, "Rufname: "..firstData.name) 
        local lbl = EasyLabel(self.MainFrame.ContentPanel, "Rang: "..AOCRP.Ranks[tonumber(firstData.rankid)].name) 
        local lbl = EasyLabel(self.MainFrame.ContentPanel, "Ausrüstung: "..AOCRP.Gears[tonumber(firstData.gearid)].name) 
        local lbl = EasyLabel(self.MainFrame.ContentPanel, "Einheit: "..AOCRP.Units[tonumber(firstData.unitid)].name) 
        local lbl = EasyLabel(self.MainFrame.ContentPanel, "Letzte Aktivität: "..firstData.lastjoin) 

        local lbl = EasyLabel(self.MainFrame.ContentPanel, "Fortbildungen:") 



 
        if #fortbildungData > 0 then 
            fortbildungspanel = vgui.Create("DTextEntry",self.MainFrame.ContentPanel)
            fortbildungspanel:Dock(TOP)
            fortbildungspanel:SetTall(AOCH(200))
            fortbildungspanel:SetMultiline(true)
            fortbildungspanel:SetFont(AOCDerma:Font("DataPad_Notizen"))
            --headerPanel:SetEditable(false)
            fortbildungspanel:SetPaintBackground(false)
            fortbildungspanel:SetTextColor(Color(255,255,255))
            fortbildungspanel:SetVerticalScrollbarEnabled(true)
            for k, v in pairs(fortbildungData) do 
                PrintTable(v)
                if AOCRP.Config.Fortbildungen[v.fid] then
                    print("ADDED")
                    fortbildungspanel:SetValue(fortbildungspanel:GetValue() .. " " .. AOCRP.Config.Fortbildungen[v.fid].name .. " - > ".. v.entrydate .. " - " .. v.givertext.."\n")
                end
            end 
        end ]]

        loading:Remove()
    
    
    end, {["cloneid"] = cloneid}, function(err) print(err) end)

end 
--AOCRP.Datapad:OpenPlayerInteract(275555)


AOCRP.Datapad.Apps["playerinteract"] = {
    title = "Gescannte ID öffnen",
    canOpen = function(ply) return IsValid(AOCRP.Datapad.MainFrame.Entity) and AOCRP.Datapad.MainFrame.Entity:IsPlayer()  end,
    onOpen = function(frame) 
        
        AOCRP.Datapad:OpenPlayerInteract(AOCRP.Datapad.MainFrame.Entity:GetCloneID())
    end,


    limitedToConsoleFlag = "",

}

AOCRP.Datapad.Apps["personendatenbank"] = {
    title = "Personendatenbank",
    canOpen = function(ply) return true end,
    onOpen = function(frame) 
        

        local label = Label("Suche in der Personendatenbank", frame)
        label:Dock(TOP)
        label:SetFont(AOCDerma:Font("FunkLog_Title"))
        label:SetTextColor(Color(255,255,255))
        label:SizeToContents()

        local textentry = AOCDerma:TextEntry(frame,"Klon-ID")
        textentry:SetTall(AOCH(60))
        textentry:Dock(TOP)

        local suche = AOCDerma:Button(frame, "Suchen", function() 
            
            if !textentry:GetValue() then return end 
            if string.len(textentry:GetValue()) < 6 then return end 
            if !isnumber(tonumber(textentry:GetValue())) then return end

            frame:Clear()
            AOCRP.Datapad:OpenPlayerInteract(tonumber(textentry:GetValue()))
        
        end, "b")
        suche:Dock(TOP)

        --AOCRP.Datapad:OpenPlayerInteract(AOCRP.Datapad.MainFrame.Entity:GetCloneID())
    end,


    limitedToConsoleFlag = "",

}

--[[ AOCDerma:RegisterFont("FunkLog_Message", "Agency FB", 25, 10)

AOCDerma:RegisterFont("FunkLog_Title", "Agency FB", 50, 1000)



AOCRP.Datapad.Apps["personalfunk"] = {
    title = "Persönliches Funklogbuch",
    canOpen = function(ply) return true end,
    onOpen = function(frame) 

        local label = Label("Persönliche Funksprüche des heutigen Tages", frame)
        label:Dock(TOP)
        label:SetFont(AOCDerma:Font("FunkLog_Title"))
        label:SetTextColor(Color(255,255,255))
        label:SizeToContents()

        local headerPanel = vgui.Create("DTextEntry",frame)
        headerPanel:Dock(FILL)
        headerPanel:SetMultiline(true)
        headerPanel:SetFont(AOCDerma:Font("FunkLog_Message"))
        --headerPanel:SetEditable(false)
        headerPanel:SetPaintBackground(false)
        headerPanel:SetTextColor(Color(255,255,255))
        headerPanel:SetVerticalScrollbarEnabled(true)


        AOCRP.API:Request("getfunklogpersonaltoday", function(data) 

            if istable(data) then
                if #data > 0 then
                    for k, v in pairs(data) do

                        headerPanel:SetValue(headerPanel:GetValue() .. "\n".. "["..v.id.."] ("..v.timestamp..") - *"..v.fromstring.." an "..v.targetstring.."* "..v.msg)
                        --AppList:AddLine( v.id, v.timestamp, v.fromstring, v.targetstring, v.msg)

                    end
                end
            end

        end, { ["cloneid"] = LocalPlayer():GetCloneID() }, function(err) print(err) end)   

    end,


    limitedToConsoleFlag = "",

} ]]



AOCDerma:RegisterFont("DataPad_Notizen", "Agency FB", 30, 10)

AOCRP.Datapad.Apps["notizbuch"] = {
    title = "Notizen",
    canOpen = function(ply) return true end,
    onOpen = function(frame) 


        local sheet = vgui.Create( "DPropertySheet", frame )
        sheet:Dock( TOP )
        sheet:SetTall(frame:GetTall())
        function sheet:Paint(w,h)
        end

        local newFile = vgui.Create( "DPanel", sheet )
        newFile:SetPaintBackground(false)
            newFile_headerPanel = vgui.Create("DTextEntry",newFile)
            newFile_headerPanel:Dock(FILL)
            newFile_headerPanel:SetMultiline(true)
            newFile_headerPanel:SetFont(AOCDerma:Font("DataPad_Notizen"))
            --headerPanel:SetEditable(false)
            newFile_headerPanel:SetPaintBackground(false)
            newFile_headerPanel:SetTextColor(Color(255,255,255))
            newFile_headerPanel:SetVerticalScrollbarEnabled(true)

        local newFileTab = sheet:AddSheet( "Neue Notiz", newFile, "icon16/page_add.png" )
        

        function sheet:AddFile(v)
            local panel1 = vgui.Create( "DPanel", sheet )
            panel1:SetPaintBackground(false)
                panel1.headerPanel = vgui.Create("DTextEntry",panel1)
                panel1.headerPanel:Dock(FILL)
                panel1.headerPanel:SetMultiline(true)
                panel1.headerPanel:SetFont(AOCDerma:Font("DataPad_Notizen"))
                --headerPanel:SetEditable(false)
                panel1.headerPanel:SetPaintBackground(false)
                panel1.headerPanel:SetTextColor(Color(255,255,255))
                panel1.headerPanel:SetVerticalScrollbarEnabled(true)
                
                panel1.RelatedFile = v
                
            sheet:AddSheet(v, panel1, "icon16/page_edit.png" )
        end

        local files, directories = file.Find( "aoc_notizen/*", "DATA" )
        for k, v in pairs(files) do
            sheet:AddFile(v)
        end



        local buttonPnl = vgui.Create("DPanel",frame)
        buttonPnl:Dock(BOTTOM)
        buttonPnl:SetTall(AOCH(60))
        buttonPnl:SetPaintBackground(false)




        saveBtn = AOCDerma:Button(buttonPnl, "Neue Notiz speichern", function() 
        
            if !file.Exists("aoc_notizen","DATA") then file.CreateDir("aoc_notizen") end


            if saveBtn.SaveFile then
                file.Write(saveBtn.SaveFile, saveBtn.ReadPanel:GetValue())
            else
                AOCDerma:Derma_RequestString( "Notiz speichern", "Name der neuen Notiz", "Speichern", function(text) 
                    file.Write("aoc_notizen/"..text..".txt",newFile_headerPanel:GetValue())

                    sheet:AddFile(text..".txt")
                    sheet:SwitchToName(text..".txt")
                    newFile_headerPanel:SetValue("")
                end )   
            end

        
        
        end, "b")
        saveBtn:Dock(RIGHT)

        
        deleteBtn = AOCDerma:Button(buttonPnl, "Löschen", function() 
        
            if saveBtn.SaveFile then
                file.Delete(saveBtn.SaveFile, "DATA") 
                if deleteBtn.ClosePanel then
                    sheet:CloseTab(deleteBtn.ClosePanel, true)
                    sheet:SwitchToName("Neue Notiz")
                end
            end

        
        end, "b")
        deleteBtn:Dock(LEFT)

        deleteBtn:SetVisible(false)

        function sheet:OnActiveTabChanged(old, new)
            local pnl = new:GetPanel()
            if IsValid(pnl.headerPanel) then
                pnl.headerPanel:SetValue(file.Read("aoc_notizen/"..pnl.RelatedFile,"DATA"))
                saveBtn.SaveFile = "aoc_notizen/"..pnl.RelatedFile
                saveBtn:SetNewText("Speichern: " ..pnl.RelatedFile)
                saveBtn.ReadPanel = pnl.headerPanel
                deleteBtn.ClosePanel = new
                deleteBtn:SetVisible(true)
            else
                saveBtn.SaveFile = nil
                saveBtn:SetNewText("Neue Notiz speichern")
                deleteBtn:SetVisible(false)
            end
            
        end
        
    end,


    limitedToConsoleFlag = "",

}



function AOCRP.Datapad:AddAppButtons(pnl, search)



    for k, v in pairs(AOCRP.Datapad.Apps) do

        if !v.canOpen(LocalPlayer()) then continue end 

        if string.find(v.title, search) then 
                local btn = AOCDerma:Button(pnl, v.title, function() 
                    AOCRP.Datapad.MainFrame.OpenApp = k 
                    AOCRP.Datapad.MainFrame.ContentPanel:Clear() 
                    v.onOpen(AOCRP.Datapad.MainFrame.ContentPanel) 
                end, "b")
                btn:Dock(TOP)
                btn:DockMargin(0,0,AOCW(10),AOCH(10))
                btn.App = k

                function btn:PaintOver(w,h)
                    if self.App == AOCRP.Datapad.MainFrame.OpenApp then
                        self.akzent = Color(0,200,0)
                        self.akzenthover = Color(0,255,0)
                    else
                        self.akzent = Color(200,200,200)
                        self.akzenthover = Color(255,255,255)       
                    end
                end
        end
    end   
end



function AOCRP.Datapad:DataPadFrame(ent)

    if self.MainFrame then self.MainFrame:Remove() end 

    self.MainFrame = AOCDerma:DataPad()

    self.MainFrame.MenuPanel = vgui.Create("DPanel", self.MainFrame)
    self.MainFrame.MenuPanel:Dock(LEFT)
 
    if IsValid(ent) then
        self.MainFrame.Entity = ent
    end
   

    self.MainFrame.MenuPanel:SetWide(AOCW(400))
    self.MainFrame.MenuPanel:DockMargin(AOCW(80),AOCH(60),0,AOCH(60))
    function self.MainFrame.MenuPanel:Paint(w,h)
        draw.RoundedBox(0,w-AOCW(2),0,AOCW(2),h,Color(255,255,255))
    end

    self.MainFrame.ContentPanel = AOCDerma:ScrollBar(self.MainFrame) 
    self.MainFrame.ContentPanel:Dock(FILL)

    self.MainFrame.ContentPanel:DockMargin(AOCW(10),AOCH(60),AOCW(140),AOCH(60))
    function self.MainFrame.ContentPanel:Paint(w,h)
        --draw.RoundedBox(0,w-AOCW(2),0,AOCW(2),h,Color(255,255,255))
    end


    local searchEntry = AOCDerma:TextEntry(self.MainFrame.MenuPanel," Applikation suchen...")
    searchEntry:Dock(TOP)
    searchEntry:SetTall(AOCH(50))
    searchEntry:DockMargin(0,0,AOCW(10),AOCH(10))
    searchEntry:SetUpdateOnType( true )
    function searchEntry:OnValueChange(txt) 
         AOCRP.Datapad.MainFrame.AppPanel:Clear()
        
        AOCRP.Datapad:AddAppButtons(AOCRP.Datapad.MainFrame.AppPanel, txt)
    end

    self.MainFrame.AppPanel = AOCDerma:ScrollBar(self.MainFrame.MenuPanel)
    self.MainFrame.AppPanel:Dock(FILL)



    AOCRP.Datapad:AddAppButtons(self.MainFrame.AppPanel, "")

end




--gamemodes/starwarsrp/gamemode/modules/comlink/sh_textfunk.lua:
--


AOCRP.Comlink = AOCRP.Comlink or {}
AOCRP.Comlink.TxtFunk = AOCRP.Comlink.TxtFunk or {}

if CLIENT then
    PIXEL.RegisterFont("AOCRP_DComboBox_Text", "Agency FB", 40, 100)


    function AOCRP.Comlink.TxtFunk:OpenTextFunk()

        if ValidPanel(self.FRAME) then self.FRAME:Remove() end
        self.FRAME = AOCDerma:DefaultFrame()
        self.FRAME:SetSize(AOCW(700),AOCH(1000))
        self.FRAME:Center()
        self.FRAME:SetNewTitle("Schriftfunk")
        self.FRAME:SetSizable(false)
        self.FRAME:SetDraggable(false)

        local menu = vgui.Create("DComboBox", self.FRAME)
        menu:Dock(TOP)
        menu:SetValue( "Optionen" )
        menu:AddChoice( "option A" )
        menu:AddChoice( "option B" )
        menu:AddChoice( "option C" )

        function menu:Paint(w,h)
            draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))
        end

        menu:SetTall(AOCH(50))
        menu:SetFont(PIXEL.UI.RegisteredFonts["AOCRP_DComboBox_Text"])
        menu:SetTextColor(Color(255,255,255))

        function menu:OnMenuOpened(dropdown)

            function dropdown:Paint(w,h)
                draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))
            end
        end
    end

    --AOCRP.Comlink.TxtFunk:OpenTextFunk()

end
--gamemodes/starwarsrp/gamemode/modules/anim/sh_animations.lua:
AOCRP.Animation = AOCRP.Animation or {}




if SERVER then
  
  util.AddNetworkString("AOCRP.QuickSalute")

  net.Receive( "AOCRP.QuickSalute", function( len, ply )
    if ( IsValid( ply ) and ply:IsPlayer() ) then
      ply:SelectWeapon("aoc_animationswep")
      ply:SetNetVar("AOCRP.Animation.Current", "salute")
    end
  end )

end


if CLIENT then


  function AOCRP.Animation:QuickSalute()

    net.Start("AOCRP.QuickSalute")
    net.SendToServer()
  end


end









AOCRP.Animation.FreeAnims = {}


AOCRP.Animation.FreeAnims["armevers"] = {
  name = "Arme verschränken",
  bones = {
  ["ValveBiped.Bip01_R_Forearm"] = {
  ang = Angle(-44, -107, 16)
  },
  ["ValveBiped.Bip01_R_UpperArm"] = {
  ang = Angle(20, -57, -6)
  },
  ["ValveBiped.Bip01_L_UpperArm"] = {
  ang = Angle(-29, -59, 1)
  },
  ["ValveBiped.Bip01_R_Thigh"] = {
  ang = Angle(4.7, -6, -0.5)
  },
  ["ValveBiped.Bip01_L_Thigh"] = {
  ang = Angle(-7.7, -0.21, 0.4)
  },
  ["ValveBiped.Bip01_L_Forearm"] = {
  ang = Angle(51, -120, -19)
  },
  ["ValveBiped.Bip01_R_Hand"] = {
  ang = Angle(14.4, -33.4, -7.3)
  },
  ["ValveBiped.Bip01_L_Hand"] = {
  ang = Angle(26, 32, -15)
  }
  }
}

AOCRP.Animation.FreeAnims["salute"] = {
    name = "Salutieren",
    bones = {
      ["ValveBiped.Bip01_R_UpperArm"] = {
      ang = Angle(80, -95, -77.5)
      },
      ["ValveBiped.Bip01_R_Forearm"] = {
      ang = Angle(35, -125, -5)
      }
    }
}
AOCRP.Animation.FreeAnims["surrender"] = {
    name = "Ergeben",
    bones = {
      ["ValveBiped.Bip01_L_Forearm"] = {
      ang = Angle(25, -65, 25)
      },
      ["ValveBiped.Bip01_R_Forearm"] = {
      ang = Angle(-25, -65, -25)
      },
      ["ValveBiped.Bip01_L_UpperArm"] = {
      ang = Angle(-70, -180, 70)
      },
      ["ValveBiped.Bip01_R_UpperArm"] = {
      ang = Angle(70, -180, -70)
      }
    }
}


AOCRP.Animation.FreeAnims["haltung"] = {
    name = "Haltung annehmen",
    bones = {
      ["ValveBiped.Bip01_R_UpperArm"] = {
      ang = Angle(3.8, 15.4, 2.7)
      },
      ["ValveBiped.Bip01_R_Forearm"] = {
      ang = Angle(-63.7, 1.8, -85)
      },
      ["ValveBiped.Bip01_L_UpperArm"] = {
      ang = Angle(3.8, 15, 2.7)
      },
      ["ValveBiped.Bip01_L_Forearm"] = {
      ang = Angle(53.7, -30, 31.5)
      },
      ["ValveBiped.Bip01_R_Thigh"] = {
      ang = Angle(4.8, 0, 0)
      },
      ["ValveBiped.Bip01_L_Thigh"] = {
      ang = Angle(-8.9, 0, 0)
      }
    }
}

AOCRP.Animation.FreeAnims["handheben"] = {
    name = "Hand heben",
    bones = {
      ["ValveBiped.Bip01_L_Forearm"] = {
      ang = Angle(25, -65, 25)
      },
      ["ValveBiped.Bip01_L_UpperArm"] = {
      ang = Angle(-70, -180, 70)
      }
    }
}


AOCRP.Animation.FreeAnims["middle"] = {
    name = "Mittelfinger",
    gtmitem = "animation_middlefinger",
    bones = {
    ['ValveBiped.Bip01_R_UpperArm'] = {
    ang = Angle(15,-55,-0) },
    ['ValveBiped.Bip01_R_Forearm'] = {
    ang = Angle(0,-55,-0) },
    ['ValveBiped.Bip01_R_Hand'] = {
    ang = Angle(20,20,90) },
    ['ValveBiped.Bip01_R_Finger1'] = {
    ang = Angle(20,-40,-0) },
    ['ValveBiped.Bip01_R_Finger3'] = {
    ang = Angle(0,-30,0) },
    ['ValveBiped.Bip01_R_Finger4'] = {
    ang = Angle(-10,-40,0) },
    ['ValveBiped.Bip01_R_Finger11'] = {
    ang = Angle(-0,-70,-0) },
    ['ValveBiped.Bip01_R_Finger31'] = {
    ang = Angle(-0,-70,-0) },
    ['ValveBiped.Bip01_R_Finger41'] = {
    ang = Angle(-0,-70,-0) },
    ['ValveBiped.Bip01_R_Finger12'] = {
    ang = Angle(-0,-70,-0) },
    ['ValveBiped.Bip01_R_Finger32'] = {
    ang = Angle(-0,-70,-0) },
    ['ValveBiped.Bip01_R_Finger42'] = {
    ang = Angle(-0,-70,-0) },

    }
}



AOCRP.Animation.FreeAnims["handreichen"] = {
    name = "Hand geben",
    bones = {
    ['ValveBiped.Bip01_R_UpperArm'] = {
    ang = Angle(20,-68,-63) },
    ['ValveBiped.Bip01_R_Forearm'] = {
    ang = Angle(13,0,65) },
    }
}


AOCRP.Animation.FreeAnims["flugzeug"] = {
    name = "Flugzeug",
    gtmitem = "animation_flugzeug",
    bones = {
    ['ValveBiped.Bip01_R_UpperArm'] = {
    ang = Angle(80,0,0) },
    ['ValveBiped.Bip01_L_UpperArm'] = {
    ang = Angle(-80,0,0) },
    }
}


AOCRP.Animation.FreeAnims["comlink"] = {
    name = "Comlink",
    bones =  {
      ["ValveBiped.Bip01_R_UpperArm"] = {
        ang = Angle(33, -103, 2),
        pos = nil
      },
      ["ValveBiped.Bip01_R_Forearm"] = {
        ang = Angle(-90, -31, -42),
        pos = nil
      },
      ["ValveBiped.Bip01_R_Hand"] = {
        ang = Angle(0, 0, -15),
        pos = nil
      }
    }
}



AOCRP.Animation.FreeAnims["f_Burpee"] = {
    name = "Burpee",
    wosAnim = "f_Burpee",
    --gtmitem = "f_Burpee",
}
AOCRP.Animation.FreeAnims["f_Disagree"] = {
  name = "Ablehnen",
  wosAnim = "f_Disagree",
  gtmitem = "f_Disagree",
  price = 20000,
  vipfree = true,
}
AOCRP.Animation.FreeAnims["f_ArmWave"] = {
  name = "Armwave",
  wosAnim = "f_ArmWave",
  gtmitem = "f_ArmWave",
  price = 900000,
  vipfree = false,
}
AOCRP.Animation.FreeAnims["f_BandOfTheFort"] = {
  name = "Band of the Fort",
  wosAnim = "f_BandOfTheFort",
  gtmitem = "f_BandOfTheFort",
  price = 500000,
  vipfree = false, 
}
AOCRP.Animation.FreeAnims["f_Break_Dance_v2"] = {
  name = "Breakdance",
  wosAnim = "f_Break_Dance_v2",
  gtmitem = "f_Break_Dance_v2",
  price = 500000,
  vipfree = false,
}

AOCRP.Animation.FreeAnims["f_Cry"] = {
  name = "Weinen",
  wosAnim = "f_Cry",
  gtmitem = "f_Cry",
  price = 30000,
  vipfree = true,
}

AOCRP.Animation.FreeAnims["f_JumpingJack"] = {
  name = "Hampelmänner",
  wosAnim = "f_JumpingJack",
}
AOCRP.Animation.FreeAnims["f_TimetravelBackflip"] = {
  name = "Timetravelbackflip",
  wosAnim = "f_TimetravelBackflip",
  gtmitem = "f_TimetravelBackflip",
  price = 900000,
  vipfree = false,
}

AOCRP.Animation.FreeAnims["f_Salute"] = {
  name = "Salutieren (kurz)",
  wosAnim = "f_Salute",
}
AOCRP.Animation.FreeAnims["f_ThumbsUp"] = {
  name = "Daumen hoch",
  wosAnim = "f_ThumbsUp",
  gtmitem = "f_ThumbsUp",
  price = 20000,
  vipfree = true,
}
AOCRP.Animation.FreeAnims["f_ThumbsDown"] = {
  name = "Daumen runter",
  wosAnim = "f_ThumbsDown",
  gtmitem = "f_ThumbsDown",
  price = 20000,
  vipfree = true,
}
AOCRP.Animation.FreeAnims["f_Salt"] = {
  name = "Salz",
  wosAnim = "f_Salt",
  gtmitem = "f_Salt",
  price = 50000,
  vipfree = true,
}
AOCRP.Animation.FreeAnims["f_Bring_It_On"] = {
  name = "Bring it On",
  wosAnim = "f_Bring_It_On",
  gtmitem = "f_Bring_It_On",
  price = 50000,
  vipfree = true,
}
AOCRP.Animation.FreeAnims["f_Celebration"] = {
  name = "Jubel",
  wosAnim = "f_Celebration",
  gtmitem = "f_Celebration",
  price = 200000,
  vipfree = false,
}

AOCRP.Animation.FreeAnims["f_Cartwheel"] = {
  name = "Radschlag",
  wosAnim = "f_Cartwheel",
  gtmitem = "f_Cartwheel",
  price = 90000,
  vipfree = false,
}

AOCRP.Animation.FreeAnims["f_Loser_Dance"] = {
  name = "Looser Dance",
  wosAnim = "f_Loser_Dance",
  gtmitem = "f_Loser_Dance",
  price = 400000,
  vipfree = false,
}

AOCRP.Animation.FreeAnims["f_IDontKnow"] = {
  name = "Dont know",
  wosAnim = "f_IDontKnow",
  gtmitem = "f_IDontKnow",
  price = 20000,
  vipfree = true,
}
AOCRP.Animation.FreeAnims["f_Confused"] = {
  name = "Verwirrt",
  wosAnim = "f_Confused",
  gtmitem = "f_Confused",
  price = 20000,
  vipfree = true,
}
AOCRP.Animation.FreeAnims["f_I_Break_You"] = {
  name = "Break you",
  wosAnim = "f_I_Break_You",
  gtmitem = "f_I_Break_You",
  price = 40000,
  vipfree = true,
}
AOCRP.Animation.FreeAnims["f_FlossDance"] = {
  name = "Floss Dance",
  wosAnim = "f_FlossDance",
  gtmitem = "f_FlossDance",
  price = 700000,
  vipfree = false,
}
AOCRP.Animation.FreeAnims["f_Acrobatic_Superhero"] = {
  name = "Superhero",
  wosAnim = "f_Acrobatic_Superhero",
  gtmitem = "f_Acrobatic_Superhero",
  price = 900000,
  vipfree = false,
}
AOCRP.Animation.FreeAnims["f_Flex"] = {
  name = "Flex",
  wosAnim = "f_Flex",
  gtmitem = "f_Flex",
  price = 50000,
  vipfree = true,
}
AOCRP.Animation.FreeAnims["f_Flex_02"] = {
  name = "Flex 2",
  wosAnim = "f_Flex_02",
  gtmitem = "f_Flex_02",
  price = 50000,
  vipfree = true,
}
AOCRP.Animation.FreeAnims["f_FlippnSexy"] = {
  name = "Flippn Sexy",
  wosAnim = "f_FlippnSexy",
  gtmitem = "f_FlippnSexy",
  price = 200000,
  vipfree = false,
}
AOCRP.Animation.FreeAnims["f_Facepalm"] = {
  name = "Facepalm",
  wosAnim = "f_Facepalm",
  gtmitem = "f_Facepalm",
  price = 50000,
  vipfree = true,
}
AOCRP.Animation.FreeAnims["f_Heelclick"] = {
  name = "Heelclick",
  wosAnim = "f_Heelclick",
  gtmitem = "f_Heelclick",
  price = 150000,
  vipfree = false,
}
AOCRP.Animation.FreeAnims["f_RedCard"] = {
  name = "Rote Karte",
  wosAnim = "f_RedCard",
  gtmitem = "f_RedCard",
  price = 20000,
  vipfree = true,
}
AOCRP.Animation.FreeAnims["f_RespectThePeace"] = {
  name = "Peace",
  wosAnim = "f_RespectThePeace",
  gtmitem = "f_RespectThePeace",
  price = 50000,
  vipfree = true,
}
AOCRP.Animation.FreeAnims["f_RageQuit"] = {
  name = "Ragequit",
  wosAnim = "f_RageQuit",
  gtmitem = "f_RageQuit",
  price = 100000,
  vipfree = false,
}

for k, v in pairs(AOCRP.Animation.FreeAnims) do
        
  if v.wosAnim and v.gtmitem then 
      AOCRP.GTM.Items[v.gtmitem] = {
          name = v.name,
          desc = "Neue Animationsbase",
          price = v.price,
          category = "Animationen",
          apply = false,
          permanent = true,
          canSell = true,
          canBuy = true,
          vipFree = v.vipfree,
          vipOnly =  false,
          limitFunc = function(ply) return true end,
          applyFunc = function(ply) end,
          iconFunc = function(panel) AOCRP.GTM:DoWOSPreview(panel,v.wosAnim) end,
          previewFunc = function(panel) AOCRP.GTM:DoWOSPreview(panel,v.wosAnim) end,
      } 
  end 
end

--addons/wos-passiveevent-ageo/lua/wos/pes/addons/snooze-randomevents/cl_core.lua:

local addon = {}

surface.CreateFont( "wOS.PES.SnoozeText", {
	font = "Arial",
	extended = false,
	size = ScreenScale(8),
	weight = 1300,
} )


net.Receive("wOS.PES.SnoozeEvent", function(len)
	local name = net.ReadString()
	local time = net.ReadFloat() + CurTime()
	local id = net.ReadFloat()

	addon.OpenSnoozeMenu( name, time, id )

end)

addon.OpenSnoozeMenu = function( name, time, id )
	local w, h = ScrW(), ScrH()
	local txtConfig = (wOS.PES.Config and wOS.PES.Config.SnoozeText)

	if !txtConfig then
		ErrorNoHalt("Looks like your PES Config is broken wOS.PES.Config.SnoozeText was not found")
		return
	end

	if istable(txtConfig) then
		txtConfig = txtConfig[math.random(#txtConfig)]
	end

	txtConfig = string.Replace(txtConfig, "[[name]]", name)

	local bool = hook.Call("wOS.PES.SnoozeButton", nil, name, time, id) -- Something else overrides are render

	if bool then return end

	local dframe = vgui.Create("DFrame")

	local size = 0.27*h

	dframe:SetSize(size, size)
	dframe:SetPos(0, h*0.5 - size*0.5 )
	dframe:MakePopup()
	dframe:ShowCloseButton(false)
	dframe:SetDraggable(false)
	dframe:SetTitle("")
	dframe.Paint = function(self, ww, hh)
		if time < CurTime() then self:Remove() return end

		surface.SetDrawColor(0,0,0)
		surface.DrawRect(0, 0, ww, hh)

		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect(0, 0, ww, hh)

		local word = wOS.PES.WrapText( string.Replace(txtConfig, "[[time]]", string.FormattedTime(time - CurTime(), "%02i:%02i:%02i") ), "wOS.PES.SnoozeText", ww*0.94 )

		draw.DrawText( word, "wOS.PES.SnoozeText", ww*0.02, ww*0.02, color_white, TEXT_ALIGN_LEFT ) 
	end

	local yes = vgui.Create("DButton", dframe)
	yes:SetPos(size*0.2, size*0.92)
	yes:SetSize(size*0.3, size*0.08)
	yes:SetText("Yes")
	yes.DoClick = function()
		dframe:Remove()
		net.Start("wOS.PES.SnoozeEvent")
			net.WriteFloat(id)
		net.SendToServer()
	end

	local no = vgui.Create("DButton", dframe)
	no:SetPos(size*0.5, size*0.92)
	no:SetSize(size*0.3, size*0.08)
	no:SetText("No")
	no.DoClick = function()
		dframe:Remove()
	end
end

function TESTTHISDRIVE( name, time, id )
	addon.OpenSnoozeMenu( name, time, id )
end
--addons/wos-passiveevent-ageo/lua/wos/pes/core/sh_var_mount.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--
























































































































































wOS = wOS or {}
wOS.PES = wOS.PES or {}
wOS.PES.Vars = wOS.PES.Vars || {}
wOS.PES.Vars.Data = wOS.PES.Vars.Data || {}


function wOS.PES.Vars:Autoloader()
    for _,source in pairs( file.Find( "wos/pes/vars/*", "LUA"), true ) do

        local lua = "wos/pes/vars/" .. source
        if SERVER then AddCSLuaFile(lua) end
		local varData = include(lua)

        if !varData then
            print("ERROR: " .. source .. " this variable is invalid")
            continue
        end

        varData.ToolTips = varData.ToolTips or {}
        local default_hint = {
            key = "gui/r.png",
            text = "Return to the Node Layout Menu",
        }
        table.insert( varData.ToolTips, 1, default_hint )

        self.Data[varData.Name] = varData
    end
end

function wOS.PES.Vars:GetAll()
    return wOS.PES.Vars.Data
end

function wOS.PES.Vars:Get(name)
    if not name then return end
    return self.Data[name]
end

wOS.PES.Vars:Autoloader()
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/boolean.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Boolean"

VAR.IsValid = function(varTable, value)
    if not isbool(value) then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local button = vgui.Create("DButton")
    button.Pressed = value

    local activeText = varTable.ActiveText or "Yes"
    local inactiveText = varTable.InactiveText or "No"

    button:SetText(button.Pressed and activeText or inactiveText)
    button.DoClick = function(pan)
        button.Pressed = not button.Pressed
        pan:SetText(button.Pressed and activeText or inactiveText)
    end

    return button
end

VAR.GetValue = function(button)
    return button.Pressed
end


return VAR
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/entity.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--



local VAR = {}

VAR.Name = "Entity"
VAR.DirtyValidate = true
VAR.UseTool = true

VAR.ToolTips = {
    { text = "Select the entity to be saved", key = "gui/lmb.png", },
}

VAR.IsValid = function(varTable, value)
    -- TODO


    if #varTable == 0 then
        return false
    end


    return true
end

VAR.DermaElement = function(varTable, varData)
    if !varData then varData = {} end
    local element = vgui.Create("DModelPanel")

    return element -- make multiple of these through a base panel
end

VAR.GetValue = function(dermaElement)
    if dermaElement.Data then
        local ent = dermaElement.Data
        --if IsValid(ent) then dermaElement:SetEntity(ent) end
        return dermaElement.Data
    end
end

VAR.PrimaryAttack = function(wep, ply, dermaElement)
    dermaElement.Data = dermaElement.Data

    local ent = ply:GetEyeTrace().Entity
    if IsValid(ent) then
        local allowed = hook.Call( "wOS.CombatSim.CanPlaceEntity", nil, wep, ply, ent:GetPos() )
        if isbool( allowed ) and allowed == false then return end
        dermaElement.Data = {
            Model = ent:GetModel(),
            Position = ent:GetPos(),
            Angle = ent:GetAngles(),
            Class = ent:GetClass(),
            // read var data
            // read bodygroup
            // read pose
        }
    end
end
 
VAR.OnStart = function(node, varData, var)
    if varData != {} then return end
    local entData = varData

    local ent = wOS.PES:SpawnEntity(entData)
    
    if not ent then return end 

    if not istable( ent ) then
        node:SetVar(var.Name, ent)
        return
    end

    -- // This enforces the first entry without having to hunt for it
    -- for _, entity in pairs( ent ) do
    --     node:SetVar( var.Name, entity )
    --     return
    -- end

end

VAR.OnEnd = function(node, varData, var)
    if not node:ShouldCleanAll() then return end
    if IsValid(varData) then
        varData:Remove()
    end
end

VAR.Draw3D = function(wep, ply, element)
    local ent = element.Values
    if ent then
        if not isvector(ent.Position) then return end

        local vec = ent.Position

        local top = Vector(vec.x, vec.y, vec.z + 200)
        render.DrawLine(vec, top, Color(255, 255, 255), false)
    end
end

return VAR

--addons/wos-passiveevent-ageo/lua/wos/pes/vars/int.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Int"

VAR.IsValid = function(varTable, value)
    if not isnumber(value) then
        return false
    end
    return true
end

VAR.DermaElement = function(varTable, value)
    local numberWang = vgui.Create("DNumberWang")
    numberWang:SetDecimals(0)

    if isnumber(varTable.Min) then
        numberWang:SetMin(varTable.Min)
    else
         numberWang:SetMin( 0 )
    end

    if isnumber(varTable.Max) then
        numberWang:SetMax(varTable.Max)
    else
        numberWang:SetMax( math.huge )
    end

    if isnumber(value) then
        numberWang:SetValue(value)
    else
        numberWang:SetValue(varTable.Default)
    end

    return numberWang
end

VAR.GetValue = function(numberWang)
    return numberWang:GetValue()
end

return VAR

--addons/wos-passiveevent-ageo/lua/wos/pes/vars/multi_select.lua:

local VAR = {}

VAR.Name = "Multi Select"

VAR.IsValid = function(varTable, value)
	if (value == nil) then return false end
	if (type(value) != "table") then return false end

	return true
end

VAR.GetValue = function(dermaElement)

	local lines = dermaElement:GetSelected()

	local value = {}

	for k, v in pairs(lines) do
		local a = dermaElement.varTable.Values[v:GetColumnText(1)]
		value[k] = a  
	end

	return value
end

VAR.DermaElement = function(varTable, value)
	value = value or {}

	local bgPanel = vgui.Create("DListView")
	bgPanel.varTable = varTable
	bgPanel:AddColumn("Name")
	bgPanel.Values = value

	for k, v in pairs(varTable.Values) do
		local pnl = bgPanel:AddLine(k)
		
		if value[k] then
			bgPanel:SelectItem(pnl)
		end
	end
		
	bgPanel:SetTall(300)
	
	return bgPanel
end

return VAR

--addons/wos-passiveevent-ageo/lua/wos/css/vgui/wos_css_nodebackground.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































local PANEL = {}

local bgMaterial = Material("wos/pes/bg.png", "noclamp smooth")
local borderBlack = Color(0, 0, 0, 150)
local bgBlack = Color(36,36,36) -- annoyingly 1 rgb off when actual rendering from the png WHY SOURCE WHYYYYY
local bgLighter = Color(255,255,255,100)
local bgWhite = Color(200,200,200)

PANEL.CreationType = WOS_PES.CREATOR.SIMULATION

PANEL.BaseSettings = {
    ["Time Limit"] =  {
        Type = WOS_CSS.CONFIG.NUMBER,
        MinCount = 0,
        Default = 60,
    },
    ["Maximum Players"] = {
        Type = WOS_CSS.CONFIG.NUMBER,
        MinCount = 1,
        Default = 4,
    },
    ["Prevent Damage from Outside"] = {
        Type = WOS_CSS.CONFIG.BOOL,
        Default = true,
    },
    ["Enable Lives"] = {
        Type = WOS_CSS.CONFIG.BOOL,
        Default = false,
    },
    ["Player Lives"] = {
        Type = WOS_CSS.CONFIG.NUMBER,
        MinCount = 0,
        Default = 0,
    },
    ["Share Lives"] = {
        Type = WOS_CSS.CONFIG.BOOL,
        Default = true,
    },
    ["Respawn Time"] = {
        Type = WOS_CSS.CONFIG.NUMBER,
        MinCount = 0,
        Default = 0,
    },
}

PANEL.GameSettings = {
    ["Time Limit"] = 60,
    ["Maximum Players"] = 4,
    ["Prevent Damage from Outside"] = true,
    ["Enable Lives"] = false,
    ["Player Lives"] = 0,
    ["Share Lives"] = true,
    ["Respawn Time"] = 0
}

function PANEL:Init()

end

function PANEL:CreateStartNode()
    local start = self:AddNode("Player Spawn", true)
    start.Type = "Simulation Player Spawn"
    start:CreateLinks()
    start:SetMainLink(false)
    start:SetAsStart( true )
    start:RecalculateDirty()

    start.DeleteButton:Remove()
    return start
end

function PANEL:CreateSaveBox( event_tbl )
    local dummy_frame = vgui.Create( "DFrame" )
    dummy_frame:SetSize( ScrW(), ScrH() )
    dummy_frame:SetTitle( "" )
    dummy_frame:ShowCloseButton( false )
    dummy_frame:SetDraggable( false )
    dummy_frame.Paint = function( pan, ww, hh )
        draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
    end
    dummy_frame:MakePopup()

    local dframe = vgui.Create("DFrame", dummy_frame)
    dframe:MakePopup()
    dframe:SetSize(300, 300)
    dframe:SetTitle( "" )
    dframe.Think = function( pan )
        pan:MoveToFront()
    end
    dframe:Center()

    dummy_frame.Think = function( pan ) 
        if not IsValid( dframe ) then
            pan:Remove()
        end
    end

    local textentry = vgui.Create("DTextEntry", dframe)
    textentry:SetSize(280, 20)
    textentry:SetPos(10, 30)
    textentry:SetPlaceholderText("Simulation Name")
    if self.Name != "" then
        textentry:SetText(self.Name)
    end

    local descriptentry = vgui.Create("DTextEntry", dframe)
    descriptentry:SetSize(280, 20)
    descriptentry:SetPos(10, 60)
    descriptentry:SetText( "No description available" )
    descriptentry:SetPlaceholderText("Simulation Description")
    if self.Description then
        descriptentry:SetText(self.Description)
    end

    local importbut = vgui.Create("DCheckBoxLabel", dframe)
    importbut:SetSize(20,20)
    importbut:SetPos(10, 90)
    importbut:SetText("Allow for import/export")
    importbut:SetChecked( self.Importable )

    local urlbut = vgui.Create("DCheckBoxLabel", dframe)
    urlbut:SetSize(20,20)
    urlbut:SetPos(10, 250)
    urlbut:SetText("Export to URL on Confirm")
    urlbut:SetChecked( false )

    local but = vgui.Create("DButton", dframe)
    but:SetSize(60, 20)
    but:SetText("Confirm")
    but:SetPos(225, 270)
    but.DoClick =  function()
        event_tbl.Name = textentry:GetText()
        if #event_tbl.Name < 1 then
            notification.AddLegacy( "[wOS-PES] Can not leave simulation name blank!", NOTIFY_ERROR, 3 )
            return
        end
        event_tbl.Description = descriptentry:GetText()
        event_tbl.Importable = importbut:GetChecked()
        event_tbl.Settings = self:GetGameSettings()
        event_tbl.Export = urlbut:GetChecked()
        dummy_frame:Remove()
        wOS.PES.NetworkSimulation(event_tbl)
        wOS.PES:GetActiveMenu():Remove()
        wOS.CombatSim:OpenToolMenu()
    end

    urlbut.OnChange = function(self, val)
        if val then
            but:SetText("Confirm and Export")
            but:SetSize(120, 20)
            but:SetPos(165, 270)            
        else
            but:SetText("Confirm")
            but:SetSize(60, 20)
            but:SetPos(225, 270)
        end
    end

end

function PANEL:AddToolBox( tools )
    local gsetting = vgui.Create("DButton", tools)
    gsetting:SetSize(60, 60)
    gsetting:Dock(BOTTOM)
    gsetting:DockMargin(6,5,6,5)
    gsetting:SetText("Game\nSettings")
	gsetting.Paint = function(self, w, h)
		draw.RoundedBox(4, 0, 0, w, h, borderBlack)
		draw.RoundedBox(4, 4, 4, w-8, h-8, bgWhite)
		if self.Hovered then
			draw.RoundedBox(4, 4, 4, w-8, h-8, bgLighter)
		end
	end
    gsetting.DoClick = function( pan )
        local frame = wOS.CombatSim:OpenToolSettingsMenu( self:GetBaseSettings(), self:GetGameSettings() )

        local dummy_frame = vgui.Create( "DFrame", self )
        dummy_frame:SetSize( ScrW(), ScrH() )
        dummy_frame:SetTitle( "" )
        dummy_frame:SetDraggable( false )
        dummy_frame:ShowCloseButton( false )
        dummy_frame.Paint = function( pan, ww, hh )
            draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
            if not IsValid( frame ) then pan:Remove() return end
            frame:MoveToFront()
        end
        dummy_frame:MakePopup()
        frame:SetParent( dummy_frame )
    end
end

function PANEL:SetDefaultSettings()

end

function PANEL:SetupTool()
   net.Start( "wOS.CSS.ToolEditVar" )
   net.SendToServer()
end

function PANEL:GetBaseSettings()
    return self.BaseSettings
end

function PANEL:SaveGameSettings( settings )
    self.GameSettings = settings
end

function PANEL:GetGameSettings()
    return self.GameSettings or {}
end

vgui.Register( "WOS_CSS_NodeBG", PANEL, "WOS_PES_NodeBG" )
--addons/arccw_weapons/lua/weapons/aocrp_dp23.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Eingestellte Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "DP-23"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "High tech Blaster shotgun, built for piercing the enemy defenses."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/v_dp23_v2.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_dp23_v2.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(10, 0, -4),
    ang = Angle(165, 180, 0),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.IconOverride = "materials/entities/rw_sw_dp23.png"
SWEP.NoHideLeftHandInCustomization = true
SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 20
SWEP.RangeMin = 50
SWEP.DamageMin = 10
SWEP.Range = 200
SWEP.Penetration = 1
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 8

SWEP.Recoil = 1.5
SWEP.RecoilSide = 0.6
SWEP.RecoilPunch = 0.8
SWEP.RecoilRise = 1

SWEP.Delay = 60 / 135
SWEP.Num = 5
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 50 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 450 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 100

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(0, 0, 255)



----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100


SWEP.DistantShootSound = "dc15a/SW02_Weapons_Blasters_Shared_Corebass_Tight_Close_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "dp23/dp23.wav"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-2.81, -7, 1.4),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1.5, -2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(0.2, -1, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

-- SWEP.DefaultElements = {"", ""}

-- SWEP.AttachmentElements = {
--     ["dc15a"] = {
--         VMElements = {
--             {
--                 Model = "models/arccw/sw_battlefront/weapons/new/DC15A_Rifle.mdl", -- using the model-edit i made in like 2 mins lol
--                 Bone = "v_dlt19_reference001",
--                 Scale = Vector(1.2, 1.2, 1.2),
--                 Offset = {
--                     pos = Vector(.7, -0.3, 0.5),
--                     ang = Angle(0,-90, 0)
--                 },
--             }
--         },
--     },
--     ["muzzle"] = {
--          VMElements = {
--             {
--                 Model = "models/hunter/plates/plate.mdl",
--                 Bone = "dlt19_sight",
--                 Scale = Vector(0, 0, 0),                
--                 Offset = {
--                     pos = Vector(-0.5, 4, 27 ),
--                     ang = Angle(-90, 180, 0)
--                 },
--                 IsMuzzleDevice = true
--             }
--         },
--         WMElements = {
--             {
--                 Model = "models/arccw/sw_battlefront/weapons/new/dc15a_rifle.mdl",
--                 Bone = "ValveBiped.Bip01_R_Hand",
--                 Scale = Vector(1.1, 1.1, 1.1),
--                 Offset = {
--                     pos = Vector(3.75, 2.5, -1.5),
--                     ang = Angle(-15, 0, 180)
--                 }
--             },
--             {
--                 Model = "models/hunter/plates/plate.mdl",
--                 Bone = "ValveBiped.Bip01_R_Hand",
--                 Scale = Vector(0, 0, 0),
--                 Offset = {
--                     pos = Vector(3500, 0, -1100),
--                     ang = Angle(-15, 0, 180)
--                 },
--                 IsMuzzleDevice = true
--             },
--         }, -- change the world model to something else. Please make sure it's compatible with the last one.
--     }
-- }
-- WMOverride = "models/arccw/sw_battlefront/weapons/new/dc15a_rifle.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        -- WMScale = Vector(111, 111, 111),
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.04, -0.7, 0.15),
            vang = Angle(90, 0, -90),
            wpos = Vector(3, 1, -3.8),
            wang = Angle(-15, 0, 180)
        },
    },
    {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"foregrip"},
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0., 1.65, 6.5),
            vang = Angle(90, 0, -90),
            wang = Angle(165, 180, 0),
        },
        SlideAmount = {
            vmin = Vector(-0, 2.2, 6),
            vmax = Vector(-0, 2.2, 12),
            wmin = Vector(12.2, 1, -3), 
            wmax = Vector(18, 1, -4.35) -- how far this attachment can slide in both directions.
        },    
    },          
    {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol","tac"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.65, 0.85, 11),
            vang = Angle(90, 0, -0),
            wpos = Vector(20, 1.8, -6.5),
            wang = Angle(-15, 0, -90)
        },
    },
    {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle","dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.04, 0.84, 15.4),
            vang = Angle(90, 0, -90),
            wpos = Vector(23.1, 1, -7.4),
            wang = Angle(-15, 0, -90)
        },
    },    
    {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 0.8, 5.9),
            vang = Angle(90, 0, -90),
            wpos = Vector(10, 1.8, -4),
            wang = Angle(-10 , 0, 180)
        },
    },    
    {
        PrintName = "Killcounter", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"killcounter"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 1, 3),
            vang = Angle(90, 0, -90),
            wpos = Vector(675, 90, -400),
            wang = Angle(-15 , 0, 180)
        },
    },   
    {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },       
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3,
        LHIK = true,
        LHIKOut = 0.6,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "reloads/heavy.wav", t = 4 / 30}, --s sound file
        },
    },

}


-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Damage = 50
SWEP.DamageMin = 20
SWEP.RangeMin = 50
SWEP.Range = 200
SWEP.Delay = 60 / 135
SWEP.Primary.ClipSize = 8
SWEP.Category = 'REP'
--addons/arccw_weapons/lua/weapons/aocrp_dp24.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Eingestellte Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "DP-24"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "A carbine variant of the DP-23, built for CQB enviroments. Lightweight operations."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_e11.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_dp24.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 500
SWEP.DamageMin = 15
SWEP.Range = 1344
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.18

SWEP.Delay = 60 / 425
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2
    },
    {
        Mode = 1
    },
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.52 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(0, 0, 255)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/dc15.wav"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-2.94, -10, 4),
    Ang = Angle(0, 0, 0),
     Magnification = 1.1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_05.mp3",
     ViewModelFOV = 55,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(4, -3, -2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -4, -4.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.DefaultElements = {"dp24", "muzzle"}

SWEP.AttachmentElements = {
    ["dp24"] = {
        VMElements = {
            {
                Model = "models/arccw/cs574/weapons/dp24.mdl",
                Bone = "v_e11_reference001",
                Scale = Vector(1.2, 1.2, 1.2),
                Offset = {
                    pos = Vector(-1, -2, -0.4),
                    ang = Angle(0,-90, 0)
                }
            }
        }
    },
    ["muzzle"] = {
         VMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "e11_sight",
                Scale = Vector(0, 0, 0),                
                Offset = {
                    pos = Vector(-0.8, 4, 12),
                    ang = Angle(90, 0, 0)
                },
                IsMuzzleDevice = true
            }
        },
        WMElements = {
            {
                Model = "models/arccw/cs574/weapons/dp24.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(300, 30, -1.5),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(2600, 0, -700),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },            
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}

WMOverride = "models/arccw/cs574/weapons/dp24.mdl"
--SWEP.Attachments 
SWEP.Attachments = {
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.2, 1.1, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(600, 25, -425),
            wang = Angle(-15, 0, 180)
        },
    },  
    {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1.35, 2.5, 15),
            vang = Angle(90, 0, 0),
            wpos = Vector(2200, 120, -700),
            wang = Angle(-15, 0, -90)
        },
    },    
    {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, 3, 15),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
        vmin = Vector(-0.2, 4, 10),
        vmax = Vector(-0.2, 4, 16),
        wmin = Vector(1600, 00, -480), 
        wmax = Vector(1600, 00, -480) -- how far this attachment can slide in both directions.
        },          
    },
    {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.2, 2.4, 23),
            vang = Angle(90, 0, -90),
            wpos = Vector(2730, 30, -880),
            wang = Angle(-15, 0, -90)
        },
    },       
    {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 2.5, 7),
            vang = Angle(90, 0, -90),
            wpos = Vector(900, 150, -400),
            wang = Angle(0 , 0, 180)
        },
    },          
    {
        PrintName = "Killcounter", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"killcounter"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1.3, 2.5, 12),
            vang = Angle(90, 0, -90),
            wpos = Vector(1400, 150, -500),
            wang = Angle(-15 , 0, 180)
        },
    },     
}   

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1, 
        SoundTable = {
            {s = "ArcCW_dp24.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dp24.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "w/rifles.wav"
    }),
}



-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Damage = 30
SWEP.DamageMin = 15
SWEP.RangeMin = 500
SWEP.Range = 1344
SWEP.Delay = 60 / 425
SWEP.Primary.ClipSize = 40
SWEP.Category = 'REP'
--addons/arccw_base_modified/lua/weapons/arccw_base/sh_deploy.lua:
local ang0 = Angle(0, 0, 0)
local dev_alwaysready = ArcCW.ConVars["dev_alwaysready"]

function SWEP:Deploy()
    if !IsValid(self:GetOwner()) or self:GetOwner():IsNPC() then
        return
    end

    if self.UnReady then
        local sp = game.SinglePlayer()

        if sp then
            if SERVER then
                self:CallOnClient("LoadPreset", "autosave")
            else
                self:LoadPreset("autosave")
            end
        else
            if SERVER then
                -- the server... can't get the client's attachments in time.
                -- can make it so client has to do a thing and tell the server it's ready,
                -- and that's probably what i'll do later.
            else
                self:LoadPreset("standard")
            end
        end
    end

    self:InitTimers()

    self:SetShouldHoldType()

    self:SetReloading(false)
    self:SetPriorityAnim(false)
    self:SetInUBGL(false)
    self:SetMagUpCount(0)
    self:SetMagUpIn(0)
    self:SetShotgunReloading(0)
    self:SetHolster_Time(0)
    self:SetHolster_Entity(NULL)

    self:SetFreeAimAngle(ang0)
    self:SetLastAimAngle(ang0)

    self.LHIKAnimation = nil
    self.CrosshairDelta = 0

    self:SetBurstCount(0)

    self:WepSwitchCleanup()
    if game.SinglePlayer() then self:CallOnClient("WepSwitchCleanup") end

    if !self:GetOwner():InVehicle() then -- Don't play anim if in vehicle. This can be caused by HL2 level changes
        local prd = false

        local r_anim = self:SelectAnimation("ready")
        local d_anim = self:SelectAnimation("draw")

        if (CLIENT and !game.SinglePlayer() and LocalPlayer():IsListenServerHost()) then
            self.ReadySoundTableHack = true
        end

        if self.Animations[r_anim] and ( dev_alwaysready:GetBool() or self.UnReady ) then
            self:PlayAnimation(r_anim, 1, true, 0, false)
            prd = self.Animations[r_anim].ProcDraw

            self:SetPriorityAnim(CurTime() + self:GetAnimKeyTime(r_anim, true))

            if CLIENT then
                self:SetTimer(self:GetAnimKeyTime(r_anim, true), function() self.UnReady = false end, "UnReady")
            end
        elseif self.Animations[d_anim] then
            self:PlayAnimation(d_anim, self:GetBuff_Mult("Mult_DrawTime"), true, 0, false)
            prd = self.Animations[d_anim].ProcDraw

            self:SetPriorityAnim(CurTime() + self:GetAnimKeyTime(d_anim, true) * self:GetBuff_Mult("Mult_DrawTime"))
        end

        if prd or (!self.Animations[r_anim] and !self.Animations[d_anim]) then
            self:ProceduralDraw()
        end
    end

    self:SetState(ArcCW.STATE_DISABLE)

    if (SERVER or game.SinglePlayer()) and self.UnReady then
        if SERVER then
            self:InitialDefaultClip()
        end
        self.UnReady = false
    end

    if self:GetBuff_Override("Override_AutoReload", self.AutoReload) then
        self:RestoreAmmo()
    end

    timer.Simple(0, function()
        if IsValid(self) then self:SetupModel(false) end
    end)

    if SERVER then
        self:SetupShields()
        -- Networking the weapon at this time is too early - entity is not yet valid on client
        -- Also not a good idea because networking many weapons will cause mass lag (e.g. TTT round setup)
        -- Instead, make client send a request when it is valid there
        --self:NetworkWeapon()
        self:GetOwner():SetSaveValue("m_flNextAttack", 0) -- the magic fix-it-all solution for custom deploy problems including sounds
    elseif CLIENT and !self.CertainAboutAtts and !self.AttReqSent and IsValid(self:GetOwner()) then
        -- If client is aware of this weapon and it's not on the ground, ask for attachment info
        -- If it is not on a player, delay networking until it is rendered (in cl_viewmodel)
        -- print(self, "network weapon from sh_deploy")
        self.AttReqSent = true
        net.Start("arccw_rqwpnnet")
            net.WriteEntity(self)
        net.SendToServer()
    end

    -- self:RefreshBGs()

    self:GetBuff_Hook("Hook_OnDeploy")

    return true
end

function SWEP:ResetCheckpoints()
    self.CheckpointAnimation = nil

    if game.SinglePlayer() and SERVER then
        net.Start("arccw_sp_checkpoints")
        net.Broadcast()
    end
end

function SWEP:InitialDefaultClip()
    if !self.Primary.Ammo then return end
    if engine.ActiveGamemode() == "darkrp" then return end -- DarkRP is god's second biggest mistake after gmod

    if self:GetOwner() and self:GetOwner():IsPlayer() then
        if self:HasBottomlessClip() then
            self:SetClip1(0)
        end
        if self.ForceDefaultAmmo then
            self:GetOwner():GiveAmmo(self.ForceDefaultAmmo, self.Primary.Ammo)
        elseif engine.ActiveGamemode() != "terrortown" then
            self:GetOwner():GiveAmmo(self:GetCapacity() * ArcCW.ConVars["mult_defaultammo"]:GetInt(), self.Primary.Ammo)
        end
    end
end

function SWEP:Initialize()
    if SERVER and game.SinglePlayer() and IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() then
        self:CallOnClient("Initialize")
    end

    if CLIENT then
        local class = self:GetClass()

        if self.KillIconAlias then
            killicon.AddAlias(class, self.KillIconAlias)
            class = self.KillIconAlias
        end

        local path = "arccw/weaponicons/" .. class
        local mat = Material(path)

        if !mat:IsError() then

            local tex = mat:GetTexture("$basetexture")
            if tex then
                local texpath = tex:GetName()
                killicon.Add(class, texpath, Color(255, 255, 255))
                self.WepSelectIcon = surface.GetTextureID(texpath)

                if self.ShootEntity then
                killicon.Add(self.ShootEntity, texpath, Color(255, 255, 255))
                end
            end
        end

        -- Check for incompatibile addons once
        if LocalPlayer().ArcCW_IncompatibilityCheck != true and game.SinglePlayer() then
            LocalPlayer().ArcCW_IncompatibilityCheck = true

            local incompatList = {}
            local addons = engine.GetAddons()
            for _, addon in pairs(addons) do
                if ArcCW.IncompatibleAddons[tostring(addon.wsid)] and addon.mounted then
                    incompatList[tostring(addon.wsid)] = addon
                end
            end

            local predrawvmhooks = hook.GetTable().PreDrawViewModel
            if predrawvmhooks and (predrawvmhooks.DisplayDistancePlaneLS or predrawvmhooks.DisplayDistancePlane) then -- vtools lua breaks arccw with stupid return in vm hook, ya dont need it if you going to play with guns
                hook.Remove("PreDrawViewModel", "DisplayDistancePlane")
                hook.Remove("PreDrawViewModel", "DisplayDistancePlaneLS")
                incompatList["DisplayDistancePlane"] = {
                    title = "Light Sprayer / Scenic Dispenser tool",
                    wsid = "DisplayDistancePlane",
                    nourl = true,
                }
            end
            local shouldDo = true
            -- If never show again is on, verify we have no new addons
            if file.Exists("arccw_incompatible.txt", "DATA") then
                shouldDo = false
                local oldTbl = util.JSONToTable(file.Read("arccw_incompatible.txt"))
                for id, addon in pairs(incompatList) do
                    if !oldTbl[id] then shouldDo = true break end
                end
                if shouldDo then file.Delete("arccw_incompatible.txt") end
            end
            if shouldDo and !table.IsEmpty(incompatList) then
                ArcCW.MakeIncompatibleWindow(incompatList)
            elseif !table.IsEmpty(incompatList) then
                print("ArcCW ignored " .. table.Count(incompatList) .. " incompatible addons. If things break, it's your fault.")
            end
        end
    end

    if ArcCW.ConVars["equipmentsingleton"]:GetBool() and self.Throwing then
        self.Singleton = true
        self.Primary.ClipSize = -1
        self.Primary.Ammo = ""
    end

    self:SetState(0)
    self:SetClip2(0)
    self:SetLastLoad(self:Clip1())

    self.Attachments["BaseClass"] = nil

    if !self:GetOwner():IsNPC() then
        self:SetHoldType(self.HoldtypeActive)
    end

    local og = weapons.Get(self:GetClass())

    self.RegularClipSize = og.Primary.ClipSize

    self.OldPrintName = self.PrintName

    self:InitTimers()

    if engine.ActiveGamemode() == "terrortown" then
        self:TTT_Init()
    end

    hook.Run("ArcCW_WeaponInit", self)

    if (!IsValid(self:GetOwner()) or self:GetOwner():IsNPC()) and self:IsValid() and self.NPC_Initialize then
        self:NPC_Initialize()
    else
        self:AdjustAtts()
        self:RefreshBGs()
    end
end

function SWEP:Holster(wep)
    if !IsFirstTimePredicted() then return end
    if self:GetOwner():IsNPC() then return end

    if CLIENT and self:GetOwner() == LocalPlayer() and ArcCW.InvHUD then ArcCW.InvHUD:Remove() end

    if self:GetBurstCount() > 0 and self:Clip1() > self:GetBuff("AmmoPerShot") then return false end

    if CLIENT and LocalPlayer() != self:GetOwner() then
        return
    end

    if self:GetGrenadePrimed() then
        self:GrenadeDrop(true)
    end

    self:WepSwitchCleanup()
    if game.SinglePlayer() then self:CallOnClient("WepSwitchCleanup") end

    if wep == self then self:Deploy() return false end
    if self:GetHolster_Time() > CurTime() then return false end

    self.UnReady = false

    -- Props deploy to NULL, finish holster on NULL too
    if (self:GetHolster_Time() != 0 and self:GetHolster_Time() <= CurTime()) or !IsValid(wep) then
        self:SetHolster_Time(0)
        self:SetHolster_Entity(NULL)
        self:FinishHolster()
        self:GetBuff_Hook("Hook_OnHolsterEnd")
        return true
    else
        self:SetHolster_Entity(wep)

        if self:GetGrenadePrimed() then
            self:Throw()
        end

        self.Sighted = false
        self.Sprinted = false
        self:SetShotgunReloading(0)
        self:SetMagUpCount(0)
        self:SetMagUpIn(0)

        local time = 0.25
        local anim = self:SelectAnimation("holster")
        if anim then
            local prd = self.Animations[anim].ProcHolster
            time = self:GetAnimKeyTime(anim)
            if prd then
                self:ProceduralHolster()
                time = 0.25
            end
            self:PlayAnimation(anim, self:GetBuff_Mult("Mult_DrawTime"), true, nil, nil, nil, true)
            self:SetHolster_Time(CurTime() + time * self:GetBuff_Mult("Mult_DrawTime"))
        else
            self:ProceduralHolster()
            self:SetHolster_Time(CurTime() + time * self:GetBuff_Mult("Mult_DrawTime"))
        end
        self:SetPriorityAnim(CurTime() + time * self:GetBuff_Mult("Mult_DrawTime"))
        self:SetWeaponOpDelay(CurTime() + time * self:GetBuff_Mult("Mult_DrawTime"))

        self:GetBuff_Hook("Hook_OnHolster")
    end
end

function SWEP:FinishHolster()
    self:KillTimers()

    if CLIENT then
        self:KillFlashlights()
    else
        if self:GetBuff_Override("UBGL_UnloadOnDequip") then
            local clip = self:Clip2()

            local ammo = self:GetBuff_Override("UBGL_Ammo") or "smg1_grenade"

            if IsValid(self:GetOwner()) then
                self:GetOwner():GiveAmmo(clip, ammo, true)
            end

            self:SetClip2(0)
        end

        self:KillShields()

        local vm = self:GetOwner():GetViewModel()
        if IsValid(vm) then
            for i = 0, vm:GetNumBodyGroups() do
                vm:SetBodygroup(i, 0)
            end
            vm:SetSkin(0)
            vm:SetPlaybackRate(1)
        end

        if self.Disposable and self:Clip1() == 0 and self:Ammo1() == 0 then
            self:GetOwner():StripWeapon(self:GetClass())
        end
    end
end

-- doesn't work if they dont call in prediction blah blah

function SWEP:ProceduralDraw()
    if SERVER and self:GetOwner():IsValid() then
        self:CallOnClient("ProceduralDraw")
    end

    self.InProcDraw = true
    self.ProcDrawTime = CurTime()
end

function SWEP:ProceduralHolster()
    if SERVER and self:GetOwner():IsValid() then
        self:CallOnClient("ProceduralHolster")
    end

    self.InProcHolster = true
    self.ProcHolsterTime = CurTime()
end

function SWEP:WepSwitchCleanup()
    -- table.Empty(self.EventTable)
    self.InProcDraw = false
    self.InProcHolster = false
end

function SWEP:ProceduralBash()
    if game.SinglePlayer() and self:GetOwner():IsValid() then
        self:CallOnClient("ProceduralBash")
    end

    local mult = self:GetBuff_Mult("Mult_MeleeTime")
    local mt = self.MeleeTime * mult

    self.InProcBash = true
    self.ProcBashTime = CurTime()
    self:SetTimer(mt, function()
        self.InProcBash = false
    end)
end

--addons/arccw_base_modified/lua/weapons/arccw_base/sh_firing.lua:
function SWEP:CanPrimaryAttack()
    local owner = self:GetOwner()

    -- Should we not fire? But first.
    if self:GetBuff_Hook("Hook_ShouldNotFireFirst") then return end

    -- We're holstering
    if IsValid(self:GetHolster_Entity()) then return end
    if self:GetHolster_Time() > 0 then return end

    -- Disabled (currently used only by deploy)
    if self:GetState() == ArcCW.STATE_DISABLE then return end

    -- Coostimzing
    if self:GetState() == ArcCW.STATE_CUSTOMIZE then
        if CLIENT and ArcCW.Inv_Hidden then
            ArcCW.Inv_Hidden = false
            gui.EnableScreenClicker(true)
        elseif game.SinglePlayer() then
            -- Kind of ugly hack: in SP this is only called serverside so we ask client to do the same check
            self:CallOnClient("CanPrimaryAttack")
        end
        return
    end

    -- A priority animation is playing (reloading, cycling, firemode etc)
    if self:GetPriorityAnim() then return end

    -- Inoperable, but internally (burst resetting for example)
    if self:GetWeaponOpDelay() > CurTime() then return end

    -- Safety's on, dipshit
    if self:GetCurrentFiremode().Mode == 0 then
        self:ChangeFiremode(false)
        self:SetNextPrimaryFire(CurTime())
        self.Primary.Automatic = false
        return
    end

    -- If we are an NPC, do our own little methods
    if owner:IsNPC() then self:NPC_Shoot() return end

    -- If we are in a UBGL, shoot the UBGL, not the gun
    if self:GetInUBGL() then self:ShootUBGL() return end

    -- Too early, come back later.
    if self:GetNextPrimaryFire() >= CurTime() then return end

    -- Gun is locked from heat.
    if self:GetHeatLocked() then return end

    -- Attempting a bash
    if self:GetState() != ArcCW.STATE_SIGHTS and owner:KeyDown(IN_USE) or self.PrimaryBash then self:Bash() return end

    -- Throwing weapon
    if self.Throwing then self:PreThrow() return end

    -- Too close to a wall
    if self:BarrelHitWall() > 0 then return end

    -- Can't shoot while sprinting
    if self:GetNWState() == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint() then return end

    -- Maximum burst shots
    if (self:GetBurstCount() or 0) >= self:GetBurstLength() then return end

    -- We need to cycle
    if self:GetNeedCycle() then return end

    -- If we have a trigger delay, make sure its progress is done
    if self:GetBuff_Override("Override_TriggerDelay", self.TriggerDelay) and ((!self:GetBuff_Override("Override_TriggerCharge", self.TriggerCharge) and self:GetTriggerDelta() < 1)
            or (self:GetBuff_Override("Override_TriggerCharge", self.TriggerCharge) and self:IsTriggerHeld())) then
        return
    end

    -- Should we not fire?
    if self:GetBuff_Hook("Hook_ShouldNotFire") then return end

    -- We made it
    return true
end

function SWEP:TakePrimaryAmmo(num)
    if self:HasBottomlessClip() or self:Clip1() <= 0 then
        if self:Ammo1() <= 0 then return end
        if self:HasInfiniteAmmo() then return end
        self:GetOwner():RemoveAmmo(num, self:GetPrimaryAmmoType())
    return end
    self:SetClip1(self:Clip1() - num)
end

function SWEP:ApplyRandomSpread(dir, spread)
    local radius = math.Rand(0, 1)
    local theta = math.Rand(0, math.rad(360))
    local bulletang = dir:Angle()
    local forward, right, up = bulletang:Forward(), bulletang:Right(), bulletang:Up()
    local x = radius * math.sin(theta)
    local y = radius * math.cos(theta)

    dir:Set(dir + right * spread * x + up * spread * y)
end

function SWEP:PrimaryAttack()
    local owner = self:GetOwner()

    self.Primary.Automatic = true

    if !self:CanPrimaryAttack() then return end

    local clip = self:Clip1()
    local aps = self:GetBuff("AmmoPerShot")

    if self:HasBottomlessClip() then
        clip = self:Ammo1()
        if self:HasInfiniteAmmo() then
            clip = math.huge
        end
    end

    if clip < aps then
        self:SetBurstCount(0)
        self:DryFire()

        self.Primary.Automatic = false

        return
    end

    local dir = (owner:EyeAngles() + self:GetFreeAimOffset()):Forward() --owner:GetAimVector()
    local src = self:GetShootSrc()

    if bit.band(util.PointContents(src), CONTENTS_WATER) == CONTENTS_WATER and !(self.CanFireUnderwater or self:GetBuff_Override("Override_CanFireUnderwater")) then
        self:DryFire()
        return
    end

    if self:GetMalfunctionJam() then
        self:DryFire()
        return
    end

    -- Try malfunctioning
    local mal = self:DoMalfunction(false)
    if mal == true then
        local anim = "fire_jammed"
        self:PlayAnimation(anim, 1, true, 0, true)
        return
    end

    self:GetBuff_Hook("Hook_PreFireBullets")

    local desync = ArcCW.ConVars["desync"]:GetBool()
    local desyncnum = (desync and math.random()) or 0
    math.randomseed(math.Round(util.SharedRandom(self:GetBurstCount(), -1337, 1337, !game.SinglePlayer() and self:GetOwner():GetCurrentCommand():CommandNumber() or CurTime()) * (self:EntIndex() % 30241)) + desyncnum)

    self.Primary.Automatic = true

    local spread = ArcCW.MOAToAcc * self:GetBuff("AccuracyMOA")
    local disp = self:GetDispersion() * ArcCW.MOAToAcc / 10

    --dir:Rotate(Angle(0, ArcCW.StrafeTilt(self), 0))
    --dir = dir + VectorRand() * disp

    self:ApplyRandomSpread(dir, disp)

    if (CLIENT or game.SinglePlayer()) and ArcCW.ConVars["dev_shootinfo"]:GetInt() >= 3 and disp > 0 then
        local dev_tr = util.TraceLine({
            start = src,
            endpos = src + owner:GetAimVector() * 33000,
            mask = MASK_SHOT,
            filter = {self, self:GetOwner()}
        })
        local dist = (dev_tr.HitPos - src):Length()
        local r = dist / (1 / math.tan(disp)) -- had to google "trig cheat sheet to figure this one out"
        local a = owner:GetAimVector():Angle()
        local r_sqrt = r / math.sqrt(2)
        debugoverlay.Line(dev_tr.HitPos - a:Up() * r, dev_tr.HitPos + a:Up() * r, 5, color_white, true)
        debugoverlay.Line(dev_tr.HitPos - a:Right() * r, dev_tr.HitPos + a:Right() * r, 5, color_white, true)
        debugoverlay.Line(dev_tr.HitPos - a:Right() * r_sqrt - a:Up() * r_sqrt, dev_tr.HitPos + a:Right() * r_sqrt + a:Up() * r_sqrt, 5, color_white, true)
        debugoverlay.Line(dev_tr.HitPos - a:Right() * r_sqrt + a:Up() * r_sqrt, dev_tr.HitPos + a:Right() * r_sqrt - a:Up() * r_sqrt, 5, color_white, true)
        debugoverlay.Text(dev_tr.HitPos, math.Round(self:GetDispersion(), 1) .. "MOA (" .. math.Round(disp, 3) .. "°)", 5)
    end

    local delay = self:GetFiringDelay()

    local curtime = CurTime()
    local curatt = self:GetNextPrimaryFire()
    local diff = curtime - curatt

    if diff > engine.TickInterval() or diff < 0 then
        curatt = curtime
    end

    self:SetNextPrimaryFire(curatt + delay)
    self:SetNextPrimaryFireSlowdown(curatt + delay) -- shadow for ONLY fire time

    local num = self:GetBuff("Num")

    num = num + self:GetBuff_Add("Add_Num")

    local tracer = self:GetBuff_Override("Override_Tracer", self.Tracer)
    local tracernum = self:GetBuff_Override("Override_TracerNum", self.TracerNum)
    local lastout = self:GetBuff_Override("Override_TracerFinalMag", self.TracerFinalMag)
    if lastout >= clip then
        tracernum = 1
        tracer = self:GetBuff_Override("Override_TracerFinal", self.TracerFinal) or self:GetBuff_Override("Override_Tracer", self.Tracer)
    end
    local dmgtable = self.BodyDamageMults
    dmgtable = self:GetBuff_Override("Override_BodyDamageMults") or dmgtable

    -- drive by is cool
    src = ArcCW:GetVehicleFireTrace(self:GetOwner(), src, dir) or src

    local bullet      = {}
    bullet.Attacker   = owner
    bullet.Dir        = dir
    bullet.Src        = src
    bullet.Spread     = Vector(0, 0, 0) --Vector(spread, spread, spread)
    bullet.Damage     = 0
    bullet.Num        = num

    local sglove = math.ceil(num / 3)
    bullet.Force      = self:GetBuff("Force", true) or math.Clamp( ( (50 / sglove) / ( (self:GetBuff("Damage") + self:GetBuff("DamageMin")) / (self:GetBuff("Num") * 2) ) ) * sglove, 1, 3 )
                        -- Overperforming weapons get the jerf, underperforming gets boost
    bullet.Distance   = self:GetBuff("Distance", true) or 33300
    -- Setting AmmoType makes the engine look for the tracer effect on the ammo instead of TracerName!
    --bullet.AmmoType   = self.Primary.Ammo
    bullet.HullSize   = self:GetBuff("HullSize")
    bullet.Tracer     = tracernum or 0
    bullet.TracerName = tracer
    bullet.Weapon     = self
    bullet.Callback = function(att, tr, dmg)
        ArcCW:BulletCallback(att, tr, dmg, self)
    end

    local shootent = self:GetBuff("ShootEntity", true) --self:GetBuff_Override("Override_ShootEntity", self.ShootEntity)
    local shpatt   = self:GetBuff_Override("Override_ShotgunSpreadPattern", self.ShotgunSpreadPattern)
    local shpattov = self:GetBuff_Override("Override_ShotgunSpreadPatternOverrun", self.ShotgunSpreadPatternOverrun)

    local extraspread = AngleRand() * self:GetDispersion() * ArcCW.MOAToAcc / 10

    local projectiledata = {}

    if shpatt or shpattov or shootent then
        if shootent then
            projectiledata.ent = shootent
            projectiledata.vel = self:GetBuff("MuzzleVelocity")
        end

        bullet = self:GetBuff_Hook("Hook_FireBullets", bullet)

        if !bullet then return end

        local doent = shootent and num or bullet.Num
        local minnum = shootent and 1 or 0

        if doent > minnum then
            for n = 1, bullet.Num do
                bullet.Num = 1

                local dispers = self:GetBuff_Override("Override_ShotgunSpreadDispersion", self.ShotgunSpreadDispersion)
                local offset  = self:GetShotgunSpreadOffset(n)
                local calcoff = dispers and (offset * self:GetDispersion() * ArcCW.MOAToAcc / 10) or offset

                local ang = owner:EyeAngles() + self:GetFreeAimOffset()
                local ang2 = Angle(ang)
                ang2:RotateAroundAxis(ang:Right(), -1 * calcoff.p)
                ang2:RotateAroundAxis(ang:Up(), calcoff.y)
                ang2:RotateAroundAxis(ang:Forward(), calcoff.r)

                if !self:GetBuff_Override("Override_NoRandSpread", self.NoRandSpread) then -- Needs testing
                    ang2 = ang2 + AngleRand() * spread / 5
                end

                if shootent then
                    projectiledata.ang = ang2

                    self:DoPrimaryFire(true, projectiledata)
                else
                    bullet.Dir = ang2:Forward()

                    self:DoPrimaryFire(false, bullet)
                end
            end
        elseif shootent then
            local ang = owner:EyeAngles() + self:GetFreeAimOffset()

            if !self:GetBuff_Override("Override_NoRandSpread", self.NoRandSpread) then
               -- ang = (dir + VectorRand() * spread / 5):Angle()

                local newdir = Vector(dir)
                self:ApplyRandomSpread(newdir, spread / 5)
                ang = newdir:Angle()
            end

            projectiledata.ang = ang

            self:DoPrimaryFire(true, projectiledata)
        end
    else
        if !bullet then return end

        for n = 1, bullet.Num do
            bullet.Num = 1
            local dirry = Vector(dir.x, dir.y, dir.z)
            math.randomseed(math.Round(util.SharedRandom(n, -1337, 1337, !game.SinglePlayer() and self:GetOwner():GetCurrentCommand():CommandNumber() or CurTime()) * (self:EntIndex() % 30241)) + desyncnum)
            if !self:GetBuff_Override("Override_NoRandSpread", self.NoRandSpread) then
                self:ApplyRandomSpread(dirry, spread)
                bullet.Dir = dirry
            end
            bullet = self:GetBuff_Hook("Hook_FireBullets", bullet) or bullet

            self:DoPrimaryFire(false, bullet)
        end
    end

    self:DoRecoil()

    self:SetNthShot(self:GetNthShot() + 1)

    owner:DoAnimationEvent(self:GetBuff_Override("Override_AnimShoot") or self.AnimShoot)

    local shouldsupp = SERVER and !game.SinglePlayer()

    if shouldsupp then SuppressHostEvents(owner) end

    self:DoEffects()

    self:SetBurstCount(self:GetBurstCount() + 1)

    self:TakePrimaryAmmo(aps)

    self:DoShootSound()
    self:DoPrimaryAnim()

    if self:GetCurrentFiremode().Mode < 0 and self:GetBurstCount() == self:GetBurstLength() then
        local postburst = (self:GetCurrentFiremode().PostBurstDelay or 0)
        self:SetWeaponOpDelay(CurTime() + postburst * self:GetBuff_Mult("Mult_PostBurstDelay") + self:GetBuff_Add("Add_PostBurstDelay"))
    end

    if (self:GetIsManualAction()) and !(self.NoLastCycle and self:Clip1() == 0) then
        local fireanim = self:GetBuff_Hook("Hook_SelectFireAnimation") or self:SelectAnimation("fire")
        local firedelay = self.Animations[fireanim].MinProgress or 0
        self:SetNeedCycle(true)
        self:SetWeaponOpDelay(CurTime() + (firedelay * self:GetBuff_Mult("Mult_CycleTime")))
        self:SetNextPrimaryFire(CurTime() + 0.1)
    end

    self:ApplyAttachmentShootDamage()

    self:AddHeat(self:GetBuff("HeatGain"))

    mal = self:DoMalfunction(true)
    if mal == true then
        local anim = "fire_jammed"
        self:PlayAnimation(anim, 1, true, 0, true)
    end

    if self:GetCurrentFiremode().Mode == 1 then
        self.LastTriggerTime = -1 -- Cannot fire again until trigger released
        self.LastTriggerDuration = 0
    end

    self:GetBuff_Hook("Hook_PostFireBullets")

    if shouldsupp then SuppressHostEvents(nil) end
end

function SWEP:TryBustDoor(ent, dmg)
    ArcCW.TryBustDoor(ent, dmg)
end

function SWEP:DoShootSound(sndoverride, dsndoverride, voloverride, pitchoverride)
    local fsound = self.ShootSound
    local suppressed = self:GetBuff_Override("Silencer")

    if suppressed then
        fsound = self.ShootSoundSilenced
    end

    local firstsound = self.FirstShootSound

    if self:GetBurstCount() == 1 and firstsound then
        fsound = firstsound

        local firstsil = self.FirstShootSoundSilenced

        if suppressed then
            fsound = firstsil and firstsil or self.ShootSoundSilenced
        end
    end

    local lastsound = self.LastShootSound

    local clip = self:Clip1()

    if clip == 1 and lastsound then
        fsound = lastsound

        local lastsil = self.LastShootSoundSilenced

        if suppressed then
            fsound = lastsil and lastsil or self.ShootSoundSilenced
        end
    end

    fsound = self:GetBuff_Hook("Hook_GetShootSound", fsound)

    local distancesound = self.DistantShootSound

    if suppressed then
        distancesound = self.DistantShootSoundSilenced
    end

    distancesound = self:GetBuff_Hook("Hook_GetDistantShootSound", distancesound)

    local spv = self.ShootPitchVariation
    local volume = self.ShootVol
    local pitch  = self.ShootPitch * math.Rand(1 - spv, 1 + spv) * self:GetBuff_Mult("Mult_ShootPitch")

    local v = ArcCW.ConVars["weakensounds"]:GetFloat()

    volume = volume - v

    volume = volume * self:GetBuff_Mult("Mult_ShootVol")

    volume = math.Clamp(volume, 51, 149)
    pitch  = math.Clamp(pitch, 0, 255)

    if    sndoverride        then    fsound    = sndoverride end
    if    dsndoverride    then    distancesound = dsndoverride end
    if    voloverride        then    volume    = voloverride end
    if    pitchoverride    then    pitch    = pitchoverride end

    if distancesound then self:MyEmitSound(distancesound, 149, pitch, 0.5, CHAN_WEAPON + 1) end

    if fsound then self:MyEmitSound(fsound, volume, pitch, 1, CHAN_WEAPON) end

    local data = {
        sound   = fsound,
        volume  = volume,
        pitch   = pitch,
    }

    self:GetBuff_Hook("Hook_AddShootSound", data)
end

function SWEP:GetMuzzleVelocity()
    local vel = self:GetBuff_Override("Override_PhysBulletMuzzleVelocity", self.PhysBulletMuzzleVelocity)

    if !vel then
        vel = self:GetBuff("Range") * 3.5

        if self:GetBuff("DamageMin") > self:GetBuff("Damage") then
            vel = vel * 2
        end
        vel = math.Clamp(vel, 200, 1000)
    end

    vel = vel / ArcCW.HUToM

    vel = vel * self:GetBuff_Mult("Mult_PhysBulletMuzzleVelocity")

    vel = vel * ArcCW.ConVars["bullet_velocity"]:GetFloat()

    return vel
end

function SWEP:DoPrimaryFire(isent, data)
    local clip = self:Clip1()
    if self:HasBottomlessClip() then
        if !self:GetOwner():IsPlayer() then
            clip = math.huge
        else
            clip = self:Ammo1()
        end
    end
    local owner = self:GetOwner()

    local shouldphysical = ArcCW.ConVars["bullet_enable"]:GetBool()

    if self.AlwaysPhysBullet or self:GetBuff_Override("Override_AlwaysPhysBullet") then
        shouldphysical = true
    end

    if self.NeverPhysBullet or self:GetBuff_Override("Override_NeverPhysBullet") then
        shouldphysical = false
    end

    if isent then
        self:FireRocket(data.ent, data.vel, data.ang, self.PhysBulletDontInheritPlayerVelocity)
    else
        -- if !game.SinglePlayer() and !IsFirstTimePredicted() then return end
        if !IsFirstTimePredicted() then return end

        if shouldphysical then
            local tracernum = data.Tracer or 1
            local phystracer = self:GetBuff_Override("Override_PhysTracerProfile", self.PhysTracerProfile)
            local lastout = self:GetBuff_Override("Override_TracerFinalMag", self.TracerFinalMag)
            if lastout >= self:Clip1() then
                phystracer = self:GetBuff_Override("Override_PhysTracerProfileFinal", self.PhysTracerProfileFinal) or phystracer
            elseif tracernum == 0 or clip % tracernum != 0 then
                phystracer = 7
            end

            local vel = self:GetMuzzleVelocity()

            vel = vel * data.Dir:GetNormalized()

            ArcCW:ShootPhysBullet(self, data.Src, vel, phystracer or 0)
        else
            owner:FireBullets(data, true)
        end
    end
end

function SWEP:DoPrimaryAnim()
    local anim = "fire"

    local inbipod = self:InBipod()
    local iron    = self:GetState() == ArcCW.STATE_SIGHTS

    -- Needs testing
    if inbipod then
        anim = self:SelectAnimation("fire_bipod") or self:SelectAnimation("fire") or anim
    else
        anim = self:SelectAnimation("fire") or anim
    end

    if (self.ProceduralIronFire and iron) or (self.ProceduralRegularFire and !iron) then anim = nil end

    anim = self:GetBuff_Hook("Hook_SelectFireAnimation", anim) or anim

    local time = self:GetBuff_Mult("Mult_FireAnimTime", anim) or 1

    if anim then self:PlayAnimation(anim, time, true, 0, false) end
end

function SWEP:DoPenetration(tr, penleft, alreadypenned)
    local bullet = {
        Damage = self:GetDamage((tr.HitPos - tr.StartPos):Length() * ArcCW.HUToM),
        DamageType = self:GetBuff_Override("Override_DamageType") or self.DamageType,
        Weapon = self,
        Penetration = self:GetBuff("Penetration"),
        Attacker = self:GetOwner(),
        Travelled = (tr.HitPos - tr.StartPos):Length()
    }

    ArcCW:DoPenetration(tr, bullet.Damage, bullet, penleft, false, alreadypenned)
end

function SWEP:GetFiringDelay()
    local delay = (self.Delay * (1 / self:GetBuff_Mult("Mult_RPM")))
    delay = self:GetBuff_Hook("Hook_ModifyRPM", delay) or delay

    return delay
end

function SWEP:GetShootSrc()
    local owner = self:GetOwner()

    if !IsValid(owner) then return self:GetPos() end
    if owner:IsNPC() then return owner:GetShootPos() end

    local dir    = owner:EyeAngles()
    local offset = Vector(0, 0, 0)

    if self:GetOwner():Crouching() then
        offset = self:GetBuff_Override("Override_BarrelOffsetCrouch") or self.BarrelOffsetCrouch or offset
    end

    if self:GetNWState() == ArcCW.STATE_SIGHTS then
        offset = LerpVector(self:GetNWSightDelta(), offset, self:GetBuff_Override("Override_BarrelOffsetSighted", self.BarrelOffsetSighted) or offset)
    else
        offset = LerpVector(1 - self:GetNWSightDelta(), offset, self:GetBuff_Override("Override_BarrelOffsetHip", self.BarrelOffsetHip) or offset)
    end

    local src = owner:EyePos()


    src = src + dir:Right()   * offset[1]
    src = src + dir:Forward() * offset[2]
    src = src + dir:Up()      * offset[3]

    return src
end

function SWEP:GetShotgunSpreadOffset(num)
    local rotate = Angle()
    local spreadpt = self:GetBuff_Override("Override_ShotgunSpreadPattern") or self.ShotgunSpreadPattern or {}
    local spreadov = self:GetBuff_Override("Override_ShotgunSpreadPatternOverrun") or self.ShotgunSpreadPatternOverrun or { Angle() }

    if istable(spreadpt) and istable(spreadov) then
        spreadpt["BaseClass"] = nil
        spreadov["BaseClass"] = nil

        if num > #spreadpt then
            if spo then
                num = num - #spreadpt
                num = math.fmod(num, #spreadov) + 1
                rotate = spreadov[num]
            else
                num = math.fmod(num, #spreadpt) + 1
                rotate = spreadpt[num]
            end
        else
            rotate = spreadpt[num]
        end
    end

    local rottoang = {}
    rottoang.num = num
    rottoang.ang = rotate

    rotate = self:GetBuff_Hook("Hook_ShotgunSpreadOffset", rottoang).ang

    return rotate or Angle()
end

function SWEP:GetDispersion()
    local owner = self:GetOwner()

    if vrmod and vrmod.IsPlayerInVR(owner) then return 0 end

    local hipdisp = self:GetBuff("HipDispersion")
    local sights  = self:GetState() == ArcCW.STATE_SIGHTS

    local hip = hipdisp

    local sightdisp = self:GetBuff("SightsDispersion")
    if sights then hip = Lerp(self:GetNWSightDelta(), sightdisp, hipdisp) end

    local speed = owner:GetAbsVelocity():Length()
    local maxspeed = owner:GetWalkSpeed() * self:GetBuff("SpeedMult")
    if sights then maxspeed = maxspeed * self:GetBuff("SightedSpeedMult") end
    speed = math.Clamp(speed / maxspeed, 0, 2)

    if owner:OnGround() or owner:WaterLevel() > 0 and owner:GetMoveType() != MOVETYPE_NOCLIP then
        hip = hip + speed * self:GetBuff("MoveDispersion")
    elseif owner:GetMoveType() != MOVETYPE_NOCLIP then
        hip = hip + math.max(speed * self:GetBuff("MoveDispersion"), self:GetBuff("JumpDispersion"))
    end

    if self:InBipod() then hip = hip * (self.BipodDispersion * self:GetBuff_Mult("Mult_BipodDispersion")) end

    if ArcCW.ConVars["mult_crouchdisp"]:GetFloat() != 1 and owner:OnGround() and owner:Crouching() then
        hip = hip * ArcCW.ConVars["mult_crouchdisp"]:GetFloat()
    end

    if ArcCW.ConVars["freeaim"]:GetInt() == 1 and !sights then
        hip = hip ^ 0.9
    end

    --local t = hook.Run("ArcCW_ModDispersion", self, {dispersion = hip})
    --hip = t and t.dispersion or hip
    hip = self:GetBuff_Hook("Hook_ModDispersion", hip) or hip

    return hip
end

function SWEP:DoShellEject(atti)
    local eff = self:GetBuff_Override("Override_ShellEffect") or self.ShellEffect or "arccw_shelleffect"

    if eff == "NONE" then return end

    local owner = self:GetOwner()

    if !IsValid(owner) then return end

    local vm = self

    if !owner:IsNPC() then owner:GetViewModel() end

    local att = vm:GetAttachment(atti or self:GetBuff_Override("Override_CaseEffectAttachment") or self.CaseEffectAttachment or 2)

    if !att then return end

    local pos, ang = att.Pos, att.Ang

    if pos and ang and self.ShellEjectPosCorrection then
        local up = ang:Up()
        local right = ang:Right()
        local forward = ang:Forward()
        pos = pos + up * self.ShellEjectPosCorrection.z + right * self.ShellEjectPosCorrection.x + forward * self.ShellEjectPosCorrection.y
    end

    local ed = EffectData()
    ed:SetOrigin(pos)
    ed:SetAngles(ang)
    ed:SetAttachment(atti or self:GetBuff_Override("Override_CaseEffectAttachment") or self.CaseEffectAttachment or 2)
    ed:SetScale(1)
    ed:SetEntity(self)
    ed:SetNormal(ang:Forward())
    ed:SetMagnitude(100)

    local efov = {}
    efov.eff = eff
    efov.fx  = ed

    if self:GetBuff_Hook("Hook_PreDoEffects", efov) == true then return end

    util.Effect(eff, ed)
end

function SWEP:DoEffects(att)
    if !game.SinglePlayer() and !IsFirstTimePredicted() then return end

    local ed = EffectData()
    ed:SetStart(self:GetShootSrc())
    ed:SetOrigin(self:GetShootSrc())
    ed:SetScale(1)
    ed:SetEntity(self)
    ed:SetAttachment(att or self:GetBuff_Override("Override_MuzzleEffectAttachment") or self.MuzzleEffectAttachment or 1)

    local efov = {}
    efov.eff = "arccw_muzzleeffect"
    efov.fx  = ed

    if self:GetBuff_Hook("Hook_PreDoEffects", efov) == true then return end

    util.Effect("arccw_muzzleeffect", ed)
end

function SWEP:DryFire()

    if self.Animations.fire_dry then
        return self:PlayAnimation("fire_dry", 1, true, 0, true)
    end
    self:MyEmitSound(self.ShootDrySound or "weapons/arccw/dryfire.wav", 75, 100, 1, CHAN_ITEM)
    self:SetNextPrimaryFire(CurTime() + 0.25)
end

function SWEP:DoRecoil()
    local single = game.SinglePlayer()

    if !single and !IsFirstTimePredicted() then return end

    if single and self:GetOwner():IsValid() and SERVER then self:CallOnClient("DoRecoil") end

    -- math.randomseed(self:GetBurstLength() + (self.Recoil * 409) + (self.RecoilSide * 519))

    local rec = {
        Recoil = 1,
        RecoilSide = 1,
        VisualRecoilMul = 1
    }
    rec = self:GetBuff_Hook("Hook_ModifyRecoil", rec) or rec

    local recoil = rec.Recoil
    local side   = rec.RecoilSide
    local visual = rec.VisualRecoilMul

    local rmul = (recoil or 1) * self:GetBuff_Mult("Mult_Recoil")
    local recv = (visual or 1) * self:GetBuff_Mult("Mult_VisualRecoilMult")
    local recs = (side or 1)   * self:GetBuff_Mult("Mult_RecoilSide")

    -- local rrange = math.Rand(-recs, recs) * self.RecoilSide

    -- local irec = math.Rand(rrange - 1, rrange + 1)
    -- local recu = math.Rand(0.5, 1)

    local irec = math.Rand(-1, 1)
    local recu = 1

    if self:InBipod() then
        local b = self.BipodRecoil * self:GetBuff_Mult("Mult_BipodRecoil")

        rmul = rmul * b
        recs = recs * b
        recv = recv * b
    end

    local recoiltbl = self:GetBuff_Override("Override_ShotRecoilTable") or self.ShotRecoilTable

    if recoiltbl and recoiltbl[self:GetBurstCount()] then rmul = rmul * recoiltbl[self:GetBurstCount()] end

    if ArcCW.ConVars["mult_crouchrecoil"]:GetFloat() != 1 and self:GetOwner():OnGround() and self:GetOwner():Crouching() then
        rmul = rmul * ArcCW.ConVars["mult_crouchrecoil"]:GetFloat()
    end

    local punch = Angle()

    punch = punch + (self:GetBuff_Override("Override_RecoilDirection", self.RecoilDirection) * math.max(self.Recoil, 0.25) * recu * recv * rmul)
    punch = punch + (self:GetBuff_Override("Override_RecoilDirectionSide", self.RecoilDirectionSide) * math.max(self.RecoilSide, 0.25) * irec * recv * rmul)
    punch = punch + Angle(0, 0, 90) * math.Rand(-1, 1) * math.Clamp(self.Recoil, 0.25, 1) * recv * rmul * 0.01
    punch = punch * (self.RecoilPunch or 1) * self:GetBuff_Mult("Mult_RecoilPunch")

    self:SetFreeAimAngle(self:GetFreeAimAngle() - punch)

    if CLIENT then self:OurViewPunch(punch) end

    if CLIENT or single then
        recv = recv * self.VisualRecoilMult

        self.RecoilAmount     = self.RecoilAmount + (self.Recoil * rmul * recu)
        self.RecoilAmountSide = self.RecoilAmountSide + (self.RecoilSide * irec * recs * rmul)
        self.RecoilPunchBack  = math.Clamp(self.RecoilAmount * recv * 5, 1, 5)

        if self.MaxRecoilBlowback > 0 then
            self.RecoilPunchBack = math.Clamp(self.RecoilPunchBack, 0, self.MaxRecoilBlowback)
        end

        self.RecoilPunchSide = self.RecoilSide * 0.1 * irec * recv * rmul
        self.RecoilPunchUp   = self.RecoilRise * 0.1 * recu
    end

    -- math.randomseed(CurTime() + (self:EntIndex() * 3))
end

function SWEP:GetBurstLength()
    local clip = self:Clip1()
    if self:HasBottomlessClip() then
        clip = self:Ammo1()
        if self:HasInfiniteAmmo() then
            clip = math.huge
        end
    end
    --if clip == 0 then return 1 end

    local len = self:GetCurrentFiremode().Mode

    if !len then return self:GetBurstCount() + 10 end

    local hookedlen = self:GetBuff_Hook("Hook_GetBurstLength", len)

    if len == 1 then return 1 end
    if len >= 2 then return self:GetBurstCount() + 10 end

    if hookedlen != len then return hookedlen end

    if len < 0 then return -len end

    return self:GetBurstCount() + 10
end

function SWEP:FireAnimationEvent(pos, ang, event, options)
    return true
end

function SWEP:IsRampupWeapon()
    local ovr = self:GetBuff_Override("Override_IsRampupWeapon")
    if ovr != nil then return ovr end
    return self:GetBuff("Damage") < self:GetBuff("DamageMin")
end

function SWEP:GetMinMaxRange()
    local decrease = !self:IsRampupWeapon()

    local min = self:GetBuff_Override("Override_RangeMin", self.RangeMin or 0)
    local max = self:GetBuff_Override("Override_Range", self.Range)
    local min_add = self:GetBuff_Add("Add_RangeMin")
    local max_add = self:GetBuff_Add("Add_Range")
    local min_mult = self:GetBuff_Mult("Mult_RangeMin")
    local max_mult = self:GetBuff_Mult("Mult_Range")

    if decrease then
        -- MinRange is also affected by Mult_Range, this is intentional
        local total_min = math.max((min + min_add) * min_mult * max_mult, 0)
        return total_min, math.max((max + max_add) * max_mult, total_min)
    else
        -- For "rampup weapons" (dmgmin > dmg), range buffs *decrease* range, as it ramps up damage quicker
        -- After all, +Range is supposed to be a positive buff no matter the kind of gun
        local total_min = math.max((min - min_add) / min_mult / max_mult, 0)
        return total_min, math.max((max - max_add) / max_mult, total_min)
    end
end

function SWEP:GetRangeFraction(range)
    local min, max = self:GetMinMaxRange()
    if range < min then
        return 0
    else
        return math.Clamp((range - min) / (max - min), 0, 1)
    end
end

function SWEP:GetDamage(range, pellet)
    local ovr = self:GetBuff_Override("Override_Num")
    local add = self:GetBuff_Add("Add_Num")
    local mul = self:GetBuff_Mult("Mult_Num")

    local num = self.Num
    local nbr = (ovr or num) * mul + add
    local factor = 1

    -- Total damage should be unchanged regardless of whether the weapon originally fired 1 pellet or > 1
    -- If pellet is set, we return per-pellet damage instead of total damage
    if pellet and num == 1 then
        factor = 1 / ((ovr or 1) * mul + add)
    elseif num != nbr then
        factor = num / nbr
    end

    --factor = ((pellet and num == 1) and (1 / ((ovr or 1) + add))) or ((num != nbr) and (num / nbr)) or 1

    if !pellet then factor = factor * nbr end

    local dmgmax = self:GetBuff("Damage") * factor
    local dmgmin = self:GetBuff("DamageMin") * factor
    local delta = self:GetRangeFraction(range)

    local lerped = Lerp(delta, dmgmax, dmgmin)

    return lerped
end

function SWEP:SecondaryAttack()
    return self.Melee2 and self:Bash(true)
end

function SWEP:CanShootWhileSprint()
    return ArcCW.ConVars["mult_shootwhilesprinting"]:GetBool() or self:GetBuff_Override("Override_ShootWhileSprint", self.ShootWhileSprint)
end

--addons/arccw_weapons/lua/weapons/arccw_dc15a_v2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "Meeks"}
SWEP.PrintName = "DC-15A"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "High tech DC-15A Blaster Rifle, preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/dc15a_rifle_meeks.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_dc15a_rifle.mdl"
SWEP.ViewModelFOV = 65
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(10, 0, -4),
    ang = Angle(165, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.IconOverride = "materials/entities/rw_sw_dc15a.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 45
SWEP.RangeMin = 190
SWEP.DamageMin = 27
SWEP.Range = 550
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.29
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.22

SWEP.Delay = 60 / 320
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },            
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 400 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100


SWEP.DistantShootSound = "dc15a/SW02_Weapons_Blasters_Shared_Corebass_Tight_Close_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "dc15a/SW02_Weapons_Blasters_DC15_Laser_Close_VAR_03 4 1 0.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-2.82, -12, 1.3),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1.5, -4, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(0.2, -1, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"", ""}

-- SWEP.AttachmentElements = {
--     ["dc15a"] = {
--         VMElements = {
--             {
--                 Model = "models/arccw/sw_battlefront/weapons/new/DC15A_Rifle.mdl", -- using the model-edit i made in like 2 mins lol
--                 Bone = "v_dlt19_reference001",
--                 Scale = Vector(1.2, 1.2, 1.2),
--                 Offset = {
--                     pos = Vector(.7, -0.3, 0.5),
--                     ang = Angle(0,-90, 0)
--                 },
--             }
--         },
--     },
--     ["muzzle"] = {
--          VMElements = {
--             {
--                 Model = "models/hunter/plates/plate.mdl",
--                 Bone = "dlt19_sight",
--                 Scale = Vector(0, 0, 0),                
--                 Offset = {
--                     pos = Vector(-0.5, 4, 27 ),
--                     ang = Angle(-90, 180, 0)
--                 },
--                 IsMuzzleDevice = true
--             }
--         },
--         WMElements = {
--             {
--                 Model = "models/arccw/sw_battlefront/weapons/new/dc15a_rifle.mdl",
--                 Bone = "ValveBiped.Bip01_R_Hand",
--                 Scale = Vector(1.1, 1.1, 1.1),
--                 Offset = {
--                     pos = Vector(3.75, 2.5, -1.5),
--                     ang = Angle(-15, 0, 180)
--                 }
--             },
--             {
--                 Model = "models/hunter/plates/plate.mdl",
--                 Bone = "ValveBiped.Bip01_R_Hand",
--                 Scale = Vector(0, 0, 0),
--                 Offset = {
--                     pos = Vector(3500, 0, -1100),
--                     ang = Angle(-15, 0, 180)
--                 },
--                 IsMuzzleDevice = true
--             },
--         }, -- change the world model to something else. Please make sure it's compatible with the last one.
--     }
-- }
-- WMOverride = "models/arccw/sw_battlefront/weapons/new/dc15a_rifle.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        -- WMScale = Vector(111, 111, 111),
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, -0, -0.15),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 0.4, -4.8),
            wang = Angle(-15, 0, 180)
        },
    },
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"foregrip"},
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.2, 2.25, 15.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(20, 0.4, -5.9),
            wang = Angle(165, 180, 0),
        },
    },          
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol","tac"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0., 2, 22),
            vang = Angle(90, 0, -90),
            wpos = Vector(32, 0.4, -10),
            wang = Angle(-15, 0, -180)
        },
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle","dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0, 0.9, 27.1),
            vang = Angle(90, 0, -90),
            wpos = Vector(33, 0.45, -11),
            wang = Angle(-15, 0, 180)
        },
    },    
    [5] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"dc15a_magazine_75", "dc15a_magazine_100"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0, 1.68, -0.8),
            vang = Angle(0, -1.75, -2.5),
            wpos = Vector(8, 2, -3.8),
            wang = Angle(-15, 90, -90)
        },
    },         
    [6] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.75, 1, 7.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(12, 1.2, -5.5),
            wang = Angle(-10 , 0, 180)
        },
    },    
    [9] = {
        PrintName = "Killcounter", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"killcounter"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.8, 1, 4),
            vang = Angle(90, 0, -90),
            wpos = Vector(675, 90, -400),
            wang = Angle(-15 , 0, 180)
        },
    },   
    [10] = {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },    
    [11] = {
        PrintName = "Internal Modifications", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "uc_fg",
    },   
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3,
        LHIK = true,
        LHIKOut = 0.6,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "reloads/heavy.wav", t = 4 / 30}, --s sound file
        },
    },

}
--addons/arccw_weapons/lua/weapons/arccw_dual_westar34.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "[P] Dual Westar 34"
SWEP.Trivia_Class = " Galactic Dual Blaster Pistol"
SWEP.Trivia_Desc = " Dual Blaster pistols for shooting enviroments"
SWEP.Trivia_Manufacturer = "Drearian Defense Conglomerate"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel = "models/arccw/weapons/synbf3/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dual_westar34.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 135
SWEP.DamageMin = 17
SWEP.Range = 345
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 16*2

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 0.6
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 290
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 460 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/westar34.wav"

SWEP.MuzzleFlashColor = Color(250, 0, 0, 50)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)

SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)
SWEP.DrawCrosshair = true

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"w34", "w34+"}

SWEP.AttachmentElements = {
    ["w34"] = {
        VMElements = {
            {
                Model = "models/arccw/cs574/weapons/westar34.mdl",
                Bone = "LeftHand_1stP",
                Scale = Vector(0.8, 0.8, 0.8),
                Offset = {
                    pos = Vector(6, 1, -1.5),
                    ang = Angle(-05, -2, 90)
                }
            }
        },
    },
    ["w34+"] = {
         VMElements = {
            {
                Model = "models/arccw/cs574/weapons/westar34.mdl",
                Bone = "RightHand_1stP",
                Scale = Vector(0.8, 0.8, 0.8),                
                Offset = {
                    pos = Vector(-6, -1, 1.5),
                    ang = Angle(0, 178, 90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/arccw/cs574/weapons/westar34.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.9, 0.9, 0.9),
                Offset = {
                    pos = Vector(80, 15, -10),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/cs574/weapons/westar34.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(0.9, 0.9, 0.9),
                Offset = {
                    pos = Vector(-20, 230, -55),
                    ang = Angle(180, -180, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/cs574/weapons/westar34.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
--    [1] = {
--        PrintName = "Tactical", -- print name
--        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
--        Slot = {"tactical","tac_pistol"},
--        VMScale = Vector(0.8, 0.8, 0.8),
--        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
--        Offset = {
--            vpos = Vector(-8, -3.7, 1.3),
 --           vang = Angle(170, 0, 0),
--        },
--    },    
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    }
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_lw", "shoot_rw"},
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_e5bx.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Droidenwaffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "E-5 BX"
SWEP.Trivia_Class = "CIS Blaster Carbine"
SWEP.Trivia_Desc = "High tech compact CIS E-5 Blaster Carbine."
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_e11.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_e5.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 44
SWEP.RangeMin = 175
SWEP.DamageMin = 24
SWEP.Range = 435
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 320
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },    
}

SWEP.AccuracyMOA = 0.4 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 390 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/e5.wav"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false

SWEP.MuzzleFlashColor = Color(255, 0, 0)

SWEP.IronSightStruct = {
    Pos = Vector(-2.87, -8, .7),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 65,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(2.9, -4, .5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, -10, 0)
SWEP.SprintAng = Angle(-10, 40, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(12.824, -8, -3.897)
SWEP.CustomizeAng = Angle(10.149, 34.547, 0)

SWEP.DefaultElements = {"e5bx", "muzzle"}

SWEP.AttachmentElements = {
    ["e5bx"] = {
        VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "v_e11_reference001",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-0.95, 0.899, -3.5),
                    ang = Angle(0, -90, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "e11_sight",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-0.5, 4, 11),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
       },
        WMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(450, 60, 200),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(2000, 0, -900),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}

WMOverride = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl"
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.24, -1.5, 3),
            vang = Angle(90, 0, -90),
            wpos = Vector(400, 55, -740),
            wang = Angle(-15, 0, 180)
        },
    },    
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, 3, 10),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
            vmin = Vector(-0, 2.5, 10),
            vmax = Vector(-0, 2.5, 12),
            wmin = Vector(1000, 60, -450), 
            wmax = Vector(1000, 60, -450) -- how far this attachment can slide in both directions.
            },
    },
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 1.5, 11),
            vang = Angle(90, 0, 0),
            wpos = Vector(1200, 130, -750),
            wang = Angle(-15, 0, -90)
        },
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.1, 0.6, 17),
            vang = Angle(90, 0, -90),
            wpos = Vector(1640, 60, -860),
            wang = Angle(-15, 0, -90)
        },
    },
    [5] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 2.1, -0.5),
            vang = Angle(0, 0, 0),
        },
    },        
    [6] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1.9, 1, 3),
            vang = Angle(90, 0, -90),
            wpos = Vector(400, 220, -500),
            wang = Angle(-10 , 0, 180)
        },
    },          
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.2,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15s.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}


-- AOCRP WAFFENSTATS arccw_e5bx - 02.06.2024
SWEP.Damage = 25
SWEP.DamageMin = 15
SWEP.RangeMin = 600
SWEP.Range = 1444
SWEP.Delay = 60 / 380
SWEP.Primary.ClipSize = 40
SWEP.Category = 'KUS'
--addons/arccw_weapons/lua/weapons/arccw_ib94.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "[P] IB-94"
SWEP.Trivia_Class = "Galactic Blaster Pistol"
SWEP.Trivia_Desc = "A Blaster pistol for shooting enviroments"
SWEP.Trivia_Manufacturer = "Forged Armory"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_ib94.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 28
SWEP.RangeMin = 125
SWEP.DamageMin = 14
SWEP.Range = 330
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(255, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(250, 0, 0)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/ib94.wav"
SWEP.IronSightStruct = {
    Pos = Vector(-3.799, -8, 1.85),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, -4, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -10,-20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(20.824, -16, 4.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"ib94"}

SWEP.AttachmentElements = {
    ["ib94"] = {
        VMElements = {
            {
                Model = "models/arccw/cs574/weapons/dc92.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-0.25, -4, -0.38),
                    ang = Angle(0, 90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/cs574/weapons/dc92.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(80, 20, -15.3),
                    ang = Angle(-15, 0, 180)
                }
            }
        },
    },
}
WMOverride = "models/arccw/cs574/weapons/dc92.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "swoptic_module",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.14, -2.4, 2.9),
            vang = Angle(0, 180, 0),
            wpos = Vector(70, 20, -50),
            wang = Angle(-15, 90, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment",
        VMScale = Vector(0.8, 0.8, 0.8), -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(9, 9, 9),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, -8, 1.45),
            vang = Angle(0, 90, 0),
            wpos = Vector(115, 20, -56),
            wang = Angle(-15, 0, 180)
        },
    },    
    [5] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(8, 8, 8),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.35, 0.9, 4),
            vang = Angle(90, 0, -90),
            wpos = Vector(60, 22, -35),
            wang = Angle(-10, 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
 --       Time = 3.35,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_k23.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "K-23 'Relby'"
SWEP.Trivia_Class = "Galactic Blaster Pistol"
SWEP.Trivia_Desc = "A Blaster pistol for shooting enviroments"
SWEP.Trivia_Manufacturer = "Forged Armory"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_relbyk23.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 95
SWEP.DamageMin = 14
SWEP.Range = 290
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(255, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 240
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(250, 0, 0)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/dpst.wav"
SWEP.IronSightStruct = {
    Pos = Vector(-3.7, -8, 2.2),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterpistol_04.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, -4, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -10,-20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(20.824, -16, 4.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"k23"}

SWEP.AttachmentElements = {
    ["k23"] = {
        VMElements = {
            {
                Model = "models/arccw/hauptmann/star wars/weapons/relby_k23.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-0.1, -5, -04.85),
                    ang = Angle(0, 90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/hauptmann/star wars/weapons/relby_k23.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(100, 10, 20.3),
                    ang = Angle(-15, 0, 180)
                }
            }
        },
    },
}
WMOverride = "models/arccw/hauptmann/star wars/weapons/relby_k23.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "swoptic_module",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, -2.4, 2.9),
            vang = Angle(0, 180, 0),
            wpos = Vector(70, 11, -50),
            wang = Angle(-15, 90, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment",
        VMScale = Vector(0.8, 0.8, 0.8), -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(9, 9, 9),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, -8, 1.45),
            vang = Angle(0, 90, 0),
            wpos = Vector(115, 12, -56),
            wang = Angle(-15, 0, 180)
        },
    },
    [3] = {
        PrintName = "Muzzle", -- print name
        WMScale = Vector(9, 9, 9),
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.25, 0.3, 13),
            vang = Angle(90, 0, -90),
            wpos = Vector(165, 12, -74),
            wang = Angle(-15, 0, 180)
        },
    },        
    [4] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [5] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [6] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(8, 8, 8),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.8, 0.4, 4),
            vang = Angle(90, 0, -90),
            wpos = Vector(60, 22, -35),
            wang = Angle(-10, 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
 --       Time = 3.35,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_meeks_z6.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Z-6"
SWEP.Trivia_Class = "Rotary Blaster Cannon"
SWEP.Trivia_Desc = "A powerful chain gun."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Heavy Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/starwars/grady/props/weapons/z6-rotatory-blaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_t21.mdl"
SWEP.ViewModelFOV = 60
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_z6.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 25
SWEP.RangeMin = 120
SWEP.DamageMin = 11
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 150

SWEP.Recoil = 0.28
SWEP.RecoilSide = 0.25
SWEP.RecoilPunch = 2
SWEP.VisualRecoilMult = 0
SWEP.RecoilRise = 0.34

SWEP.Hook_ModifyRPM = function(wep, delay)
    return delay / Lerp(wep:GetBurstCount() / 15, 1, 3)
end

SWEP.Delay = 60 / 330
SWEP.Num = 1

SWEP.BobMult = 1

SWEP.TriggerDelay = true

SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 2,
        Mult_RPM = 2800 / 2400,
        PrintName = "2800RPM"
    },
    {
        Mode = 0
    }
}

SWEP.AccuracyMOA = 0.55 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 330 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.Bipod_Integral = true -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 0.8 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 0.5 -- Bipod recoil for Integral bipods

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(0, 0, 255)

SWEP.SpeedMult = 0.5
SWEP.SightedSpeedMult = 0.8
SWEP.SightTime = 1

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.02

SWEP.ShootSound = "weapons/z6/SW02_Blasters_Z6RotaryBlaster_Laser_Close_VAR_01.wav"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.IronSightStruct = {
    Pos = Vector(0, -12, -4),
    Ang = Angle(0, 0, 0),
    Magnification = 1,
    SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_05.mp3",
    CrosshairInSights = true
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "crossbow"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, -0, -3)
SWEP.ActiveAng = Angle(0, 2, 0)

SWEP.SprintPos = Vector(5, -30, -20)
SWEP.SprintAng = Angle(40, 0, -10)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -4, -4.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)


SWEP.DefaultElements = {"nil"}
SWEP.AttachmentElements = {
    ["nil"] = {
         VMElements = {},
        WMElements = {
            {
                Model = "models/starwars/grady/props/weapons/z6-rotatory-blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-2000, 1000, -800),
                    ang = Angle(-10, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(4500, 0, -900),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },            
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}

WMOverride = "models/starwars/grady/props/weapons/z6-rotatory-blaster.mdl"

SWEP.Jamming = true
SWEP.HeatGain = 0.95 -- heat gained per shot
SWEP.HeatCapacity = 75 -- rounds that can be fired non-stop before the gun jams, playing the "fix" animation
SWEP.HeatDissipation = 10 -- rounds' worth of heat lost per second
SWEP.HeatLockout = true -- overheating means you cannot fire until heat has been fully depleted
SWEP.HeatDelayTime = 0.5

--SWEP.Attachments 
SWEP.Attachments = {                 
    [1] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [2] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },          
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"fire_1","fire_2", "fire_3"},
        Time = 0.4
    },
    ["draw"] = {
        Source = "draw",
        Time = 1.6,
        SoundTable = {
            {
                s = "draw/blasters_deathray_foley_undeploy_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 200, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/blasters_deathray_foley_undeploy_var_02.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["trigger"] = {
        Source = {"fire_2"},
        SoundTable = {
        {s = "weapons/z6/SW02_Blasters_Z6RotaryBlaster_Start_Short_VAR_01.ogg", v = 75,t = 0 / 30, c = CHAN_ITEM},
        },
        Time = 0.9,
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.54,
        SoundTable = {
            {s = "weapons/z6/blasters_deathray_foley_undeploy_var_03.mp3", t = 0},
            {s = "weapons/z6/overheat_overheated_var_01.mp3", t = 1} --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_z6.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/heavy.wav"
    }),


sound.Add({
    name =          "ArcCW_z6.reload1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/z6/SW02_Blasters_Z6RotaryBlaster_Stop_03.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_nt242.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "NT-242"
SWEP.Trivia_Class = "Galactic Heavy Sniper Blaster "
SWEP.Trivia_Desc = "preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "The Bounty Hunter's Guild"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_dlt19.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_dlt19.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_nt242.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 190
SWEP.RangeMin = 465
SWEP.DamageMin = 65
SWEP.Range = 950
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_purple"
SWEP.TracerCol = Color(148, 0, 211)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 3

SWEP.Recoil = 0.54
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.22

SWEP.Delay = 60 / 210
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 0
    },      
}

SWEP.AccuracyMOA = 0.52 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50
SWEP.SightsDispersion = 0

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/nt242.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false

SWEP.MuzzleFlashColor = Color(148, 0, 211)

SWEP.IronSightStruct = {
    Pos = Vector(-2.92, -8, 1.23),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_05.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1, 0, -2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(0.2, -1, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"nt242"}

SWEP.AttachmentElements = {
    ["nt242"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/NT242_Longblaster_Base.mdl", -- using the model-edit i made in like 2 mins lol
                Bone = "v_dlt19_reference001",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(0.7, 1, 0),
                    ang = Angle(0,-90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/NT242_Longblaster_Base.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(3.75, 2.5, -1.5),
                    ang = Angle(-15, 0, 180)
                }
            }
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}
WMOverride = "models/arccw/sw_battlefront/weapons/NT242_Longblaster_Base.mdl"
--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.25, -0.5, -2),
            vang = Angle(90, 0, -90),
            wpos = Vector(300, 0, -590),
            wang = Angle(-15, 0, 180)
        },
    },
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.1, 3, 8),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
        vmin = Vector(-0.1, 3, 10),
        vmax = Vector(-0.1, 3, 7),
        wmin = Vector(1600, 0, -580), 
        wmax = Vector(1600, 0, -580) -- how far this attachment can slide in both directions.
        },         
    },          
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 3, 14),
            vang = Angle(90, 0, -90),
            wpos = Vector(2000, 0, -700),
            wang = Angle(-15, 0, -180)
        },
    },     
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 1.5, 29),
            vang = Angle(90, 0, -90),
        },
    },    
    [5] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, 2.3, -3),
            vang = Angle(0, 0, 0),
        },
    },         
    [6] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 2, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(900, 70, -470),
            wang = Angle(-10 , 0, 180)
        },
    },          
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
    },
    ["holster"] = {
        Source = "holster",
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15a.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/heavy.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_relbyv10.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Relby-v10"
SWEP.Trivia_Class = "Galactic Blaster Rifle"
SWEP.Trivia_Desc = "general allround usage."
SWEP.Trivia_Manufacturer = "Forged Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_dlt19.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_dlt19.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_relbyv10.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 45
SWEP.RangeMin = 80
SWEP.DamageMin = 24
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 0.54
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.22

SWEP.Delay = 60 / 210
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },             
}

SWEP.AccuracyMOA = 0.52 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50
SWEP.SightsDispersion = 0

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/relbyv10.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false

SWEP.MuzzleFlashColor = Color(250, 25, 0)

SWEP.IronSightStruct = {
    Pos = Vector(-3.65, -3, 1.35),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_05.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1, -4, -2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(2, -5, 1)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"relbyv10"}

SWEP.AttachmentElements = {
    ["relbyv10"] = {
        VMElements = {
            {
                Model = "models/arccw/hauptmann/star wars/weapons/relby_v10.mdl", -- using the model-edit i made in like 2 mins lol
                Bone = "v_dlt19_reference001",
                Scale = Vector(1.4, 1.4, 1.4),
                Offset = {
                    pos = Vector(0, 04, -07),
                    ang = Angle(0,-90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/hauptmann/star wars/weapons/relby_v10.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(800, 50, 400),
                    ang = Angle(-15, 0, 180)
                }
            }
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}
WMOverride = "models/arccw/hauptmann/star wars/weapons/relby_v10.mdl"
--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.5, -0.2, -4.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(390, 50, -460),
            wang = Angle(-15, 0, 180)
        },
    },
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.1, 3, 5),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
        vmin = Vector(-0.1, 3, 3),
        vmax = Vector(-0.1, 3, 6),
        wmin = Vector(1400, 40, -520), 
        wmax = Vector(1400, 40, -520) -- how far this attachment can slide in both directions.
        },         
    },          
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 3, 15),
            vang = Angle(90, 0, -90),
            wpos = Vector(2300, 50, -750),
            wang = Angle(-15, 0, -180)
        },
    },     
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        WMScale = Vector(111, 111, 111),
        Slot = {"muzzle","dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.3, 1.7, 20.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(2520, 50, -920),
            wang = Angle(-15, 0, -90)
        },
    },    
    [5] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, 2.3, -3),
            vang = Angle(0, 0, 0),
        },
    },         
    [6] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 2, 8),
            vang = Angle(90, 0, -90),
            wpos = Vector(900, 70, -470),
            wang = Angle(-10 , 0, 180)
        },
    },          
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15a.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/heavy.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_sops_dc19.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-19"
SWEP.Trivia_Class = "Blaster Stealth Carabine"
SWEP.Trivia_Desc = "The DC-19 'Stealth' carbine was a blaster carbine in BlasTech Industries' DC-15 blaster line. The DC-19 was equipped with a sound suppressor unit for silent operations and an optional stealth function, which used a refined tibanna gas mixture that made the DC-19's plasma bolts invisible to the naked eye. However, the tibanna mixture was highly expensive, had to be reloaded after ten shots, and needed to be cooled down after each shot to prevent damage to the carbine's dampeners. The DC-19 was used almost exclusively by clone shadow troopers in the Grand Army of the Republic during the Clone Wars and for a short time afterward, when the clone shadow troopers became part of the Imperial Army."
SWEP.IconOverride = "entities/sopsmisc/dc19.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/arccw/kraken/sops-v2/c_dc19.mdl"
SWEP.WorldModel = "models/arccw/kraken/sops-v2/w_dc19.mdl"
SWEP.ViewModelFOV = 58
SWEP.WorldModelOffset = {
    pos = Vector(-9, 3.5, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.6,
    [HITGROUP_CHEST] = 1.2,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 68
SWEP.RangeMin = 202
SWEP.DamageMin = 28
SWEP.Range = 402
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET

SWEP.MuzzleVelocity = 900

SWEP.AlwaysPhysBullet = true
SWEP.PhysTracerProfile = 0
SWEP.PhysBulletDontInheritPlayerVelocity = true

SWEP.PhysTracerProfile = 1

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50

SWEP.Recoil = 0.89
SWEP.RecoilSide = 0.12
SWEP.RecoilRise = 0.12
SWEP.Delay = 60 / 255

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.1
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 60

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/dc19.wav"
SWEP.ShootSound = "sops-v2/weapons/dc19.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = nil

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.837, 0.619, 1.656),
    Ang = Angle(0, 0, 0),
     Magnification = 1.3,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1

SWEP.ActivePos = Vector(0, 2, 2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)
-- Attachments 
SWEP.Attachments = {
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC15",
        Offset = {
            vpos = Vector(0, -1.6, -0.5),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC15", 
        Offset = {
            vpos = Vector(0.8, -0.5, 10),
            vang = Angle(90, 0, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.1, -0.442, 11.638),
            vang = Angle(90, 0, -90),

        },
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.9, -0.7, 5.7),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.8, -0.2, -5),
            vang = Angle(90, 0, -90),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "neutral",
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3",
                p = 100, 
                v = 75, 
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "dc15s_1", t = 1.68 / 60},
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_manualcooling_var_02.mp3", t = 0.1},
        },
    },

sound.Add({
    name =          "dc15s_1",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armasclasicas/wpn_empire_medreload.wav"
    }),

}


-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Damage = 50
SWEP.DamageMin = 28
SWEP.RangeMin = 202
SWEP.Range = 402
SWEP.Delay = 60 / 450
SWEP.Primary.ClipSize = 40
SWEP.Category = 'REP'

--addons/arccw_weapons/lua/weapons/arccw_sops_e11s.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "E-11s"
SWEP.Trivia_Class = "Blaster Sniper Rifle"
SWEP.Trivia_Desc = "Blastech's E-11 platform was considered to be one of the most successful blaster designs in history. It was no surprise that when the Galactic Empire wanted a dedicated sniper rifle, the company looked to its most successful design for inspiration. The E-11s used the same frame, but incorporated a composite alloy buttstock and the barrel was double the length than a regular E-11 medium blaster rifle. The elongated barrel featured the same perforated shroud and heat-abating fins the E-11 was known for. Unfortunately, heat management problems reduced the weapon's fire rate well below that of market competitors. The Empire deployed E-11s with scout troopers, infantry platoon sharpshooters and special forces snipers. Other than the Empire, Blastech sold E-11s to special law-enforcement units, planetary defense forces; and permitted bounty hunters and mercenaries. The prevalence of the weapon meant they found their way onto the black market usually through salvage from battlefields or hijacked factory shipments."
SWEP.IconOverride = "entities/sopsmisc/e11s.png"

-- Viewmodel & Entity Properties
SWEP.ViewModel = "models/arccw/kraken/sops-v2/e11s_rifle.mdl"
SWEP.WorldModel = "models/arccw/kraken/sops-v2/e11s_worldmodel.mdl"
SWEP.ViewModelFOV = 60
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-8, 3, -6),
    ang = Angle(-5, 0, -180),
    scale = 1.2,
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 146
SWEP.RangeMin = 627
SWEP.DamageMin = 101
SWEP.Range = 1210
SWEP.Penetration = 2
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 18

SWEP.Recoil = 1.27
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.78
SWEP.Delay = 60 / 102

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.2
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/e11s.wav"
SWEP.ShootSound = "sops-v2/weapons/e11s.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.3, 0, 1.5),
    Ang = Angle(1, -0.5, -3),
     Magnification = 2,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 2, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "None", 
        Slot = "optic", 
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.1, -4, 1),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, -180, 0),
        CorrectivePos = Vector(0, 0, -0.125),
    },    
    {
        PrintName = "Muzzle", 
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.1, 28, -0.3),
            vang = Angle(0, -90, 0),
        },
    },   
    {
        PrintName = "Tactical", 
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.5, 17, -0.4),
            vang = Angle(90, -90, 0),
        },
    }, 
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.1, 6, -1),
            vang = Angle(0, -90, 0),
        },          
    },       
    {
        PrintName = "Ammunition", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "ammo_masita", "ammo_stun"},
    },
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },   
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = {"perk", "mw3_pro"},
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.6, -0.65, 0),
            vang = Angle(0, -90, 0),
        },
    },       
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.9, 9, -0.3),
            vang = Angle(0, -90, 0),
        },
    },        
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 120 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_imperialpuncher_short.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "Imperial Short-Firepuncher"
SWEP.Trivia_Class = "Blaster-Experimental Sniper Rifle"
SWEP.Trivia_Desc = "The 773 Firepuncher rifle, also known as the 773 Firepuncher, was a model of sniper rifle manufactured by Merr-Sonn Munitions, Inc. that featured ablative coating and a wide-beam 'burning' mode."
SWEP.IconOverride = "entities/sopsmisc/shortypuncher.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/masita/viewmodels/base_rifle_animations.mdl"
SWEP.WorldModel = "models/weapons/synbf3/w_t21.mdl"
SWEP.ViewModelFOV = 66
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 46
SWEP.RangeMin = 172
SWEP.DamageMin = 24
SWEP.Range = 327
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_green"
SWEP.TracerCol = Color(0, 250, 0)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 26

SWEP.Recoil = 1.02
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.78
SWEP.Delay = 60 / 278

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.1
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 125
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "sops-v2/weapons/firepuncher/firepuncher.wav"
SWEP.ShootSound = "sops-v2/weapons/firepuncher/firepuncher.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_green"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.55, 0, 2),
    Ang = Angle(1, -0.5, -3),
     Magnification = 2,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 5, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/shortypuncher.mdl",
                Bone = "E11S_CONTR",
                ModelBodygroups = "00000",
                Scale = Vector(0.7, 0.7, 0.7),
                Offset = {
                    pos = Vector(-0.4, -8.6, -0.5),
                    ang = Angle(0, -90, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-3, 9, -6),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/shortypuncher.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.7, 0.7, 0.7),
                ModelBodygroups = "00000",
                Offset = {
                    pos = Vector(-10, 10, -20),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(150, 15, -65),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/shortypuncher.mdl"


SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.35, -3, 0.7),
            vang = Angle(0, -90, 0),
            wpos = Vector(52, 10, -51),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0)
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR", 
        Offset = {
            vpos = Vector(0, 3, -0.3),
            vang = Angle(90, -90, 0),
            wpos = Vector(100, 20, -54),
            wang = Angle(-15, 0, -90)
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        WMScale = Vector(11, 11, 11),
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},  
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.4, 6.4, -0.1),
            vang = Angle(0, -90, 0),
            wpos = Vector(155, 9, -71),
            wang = Angle(-15, 0, 180)
        }, 
        
    }, 
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(11, 11, 11),
        Offset = {
            vpos = Vector(0.45, -3.2, -0.55),
            vang = Angle(0, -90, 0),
            wpos = Vector(43, 19, -33),
            wang = Angle(-15, 0, 180)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(11, 11, 11),
        VMScale = Vector(1, 1, 1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.6, -7, -0.4),
            vang = Angle(0, -90, 0),
            wpos = Vector(10, 20, -24),
            wang = Angle(-15, 0, 180)
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 120 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_quadblaster_republic.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "Quad-Blaster (Republic)"
SWEP.Trivia_Class = "Blaster Heavy Repeater"
SWEP.Trivia_Desc = "The reciprocating quad blaster, often shortened to 'Cip-Quad' was an experimental weapon developed during the Clone Wars by Merr-Sonn Munitions."
SWEP.IconOverride = "entities/sopsmisc/quadblaster.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.ViewModel = "models/tor/weapons/v_quadblaster.mdl"
SWEP.WorldModel = "models/tor/weapons/w_quadblaster.mdl"
SWEP.ViewModelFOV = 55
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-7, 6, -8),
    ang = Angle(0, 5, 180)
}

-- Special Properties
SWEP.InfiniteAmmo = true

-- Damage & Tracer
SWEP.Damage = 29
SWEP.RangeMin = 127
SWEP.DamageMin = 24
SWEP.Range = 328
SWEP.Penetration = 7

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 150
SWEP.ExtendedClipSize = 250
SWEP.ReducedClipSize = 75

SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 0.5

SWEP.Recoil = 0.76
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.62

SWEP.Num = 1
SWEP.Delay = 60 / 420
SWEP.Firemode = 2
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 0
    }
}

SWEP.AccuracyMOA = 0.1
SWEP.HipDispersion = 100 
SWEP.MoveDispersion = 250

-- Speed Mult
SWEP.SpeedMult = 0.68
SWEP.SightedSpeedMult = 0.83
SWEP.SightTime = 0.23

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 110 
SWEP.ShootPitch = 87
SWEP.ShootPitchVariation = 0.1

SWEP.FirstShootSound = "sops-v2/weapons/quadblaster/quadblaster_republic.wav"
SWEP.ShootSound = "sops-v2/weapons/quadblaster/quadblaster_republic.wav"
SWEP.ShootSoundSilenced = "weapon/venator/dc17_badbatch.wav"

SWEP.NoFlash = true
SWEP.MuzzleEffectAttachment = "1"
SWEP.ProceduralViewBobAttachment = 1

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = false

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = "duel"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 14, -5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(0, 14, -5)
SWEP.HolsterAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(20.9, -10, 3.9)
SWEP.CustomizeAng = Angle(12.1, 50.5, 45)

SWEP.Attachments = {     
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "ammo_masita", "ammo_stun"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = {"perk", "mw3_pro"},
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },
}


-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle_deployed"
    },
    ["fire"] = {
        Source = "shooting"
    },
    ["draw"] = {
        Source = "deploy",
        SoundTable = {
            {
                s = "sops-v2/weapons/quadblaster/draw.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "retract",
        SoundTable = {
            {
                s = "sops-v2/weapons/quadblaster/out.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = false,
        SoundTable = {
            {s = "sops-v2/weapons/quadblaster/out.wav", t = 10 / 60},
        },
    },
}

if CLIENT then
    function SWEP:PlaceHandsOnGun()
        local leftElbow = self:GetOwner():LookupBone("ValveBiped.Bip01_L_Forearm")
        self:GetOwner():ManipulateBoneAngles(leftElbow, Angle(20, -20, 0))

        local rightShoulder = self:GetOwner():LookupBone("ValveBiped.Bip01_R_UpperArm")
        self:GetOwner():ManipulateBoneAngles(rightShoulder, Angle(0, 15, 0))

        local rightElbow = self:GetOwner():LookupBone("ValveBiped.Bip01_R_Forearm")
        self:GetOwner():ManipulateBoneAngles(rightElbow, Angle(-30, -40, 0))
    end

    function SWEP:ResetBoneAngles()
        local leftElbow = self:GetOwner():LookupBone("ValveBiped.Bip01_L_Forearm")
        self:GetOwner():ManipulateBoneAngles(leftElbow, Angle(0, 0, 0))

        local rightShoulder = self:GetOwner():LookupBone("ValveBiped.Bip01_R_UpperArm")
        self:GetOwner():ManipulateBoneAngles(rightShoulder, Angle(0, 0, 0))

        local rightElbow = self:GetOwner():LookupBone("ValveBiped.Bip01_R_Forearm")
        self:GetOwner():ManipulateBoneAngles(rightElbow, Angle(0, 0, 0))
    end
end

function SWEP:DrawWorldModel()
    if IsValid(self.Owner) then 
        self:SetPoseParameter("head_pitch", self.Owner:EyeAngles()[1])
        self:InvalidateBoneCache()
    end
    self:DrawModel()
end

function SWEP:Deploy()
    if SERVER then
        self:SetSequence(2)
        self:GetOwner():GetViewModel():SendViewModelMatchingSequence(2)
    end
end

function SWEP:Holster()
    if SERVER then
        self:SetSequence(4)
    end
    if CLIENT then
        self:ResetBoneAngles()
    end

    return true
end

function SWEP:ReloadTicker()end

function SWEP:Anims() end

function SWEP:Reload()
    if self:GetCurrentFiremode().Mode == 2 then
        if CurTime() > (self.ReloadWaitTime or 0) then
            if self:Clip1() < self:GetMaxClip1() and self:GetOwner():GetAmmoCount(self:GetPrimaryAmmoType()) > 0 then
                local ammo = math.Clamp(50, 0, self:GetOwner():GetAmmoCount(self:GetPrimaryAmmoType()))
                ammo = math.min(ammo, self:GetMaxClip1() - self:Clip1())
                self:SetClip1(math.Clamp(self:Clip1() + ammo, 0, self:GetMaxClip1()))
                self:GetOwner():RemoveAmmo(ammo, self:GetPrimaryAmmoType())

                if self:Clip1() == self:GetMaxClip1() then
                    self.ReloadWaitTime = 0
                else
                    self.ReloadWaitTime = CurTime() + 0.5
                end
            end
        end
    end
end

function SWEP:ShouldReload()
    return self:GetCurrentFiremode().Mode == 2 and CurTime() > (self.ReloadWaitTime or 0) and self:Clip1() < self:GetMaxClip1() and self:GetOwner():GetAmmoCount(self:GetPrimaryAmmoType()) > 0
end

function SWEP:Think()

    self.Anims()
    self.ReloadTicker()
    
    if SERVER then
        if self:GetCurrentFiremode().Mode == 2 then
            self:GetOwner():GetViewModel():SendViewModelMatchingSequence(3)
            self:SetHoldType("normal")
            self:SetSequence(1)
            self.ReloadTicker = function()
                if self:GetCurrentFiremode().Mode == 0 then
                    if CurTime() then
                        if self:Clip1() < self:GetMaxClip1() and self:GetOwner():GetAmmoCount(self:GetPrimaryAmmoType()) > 0 then
                            local ammo = math.Clamp(50, 0, self:GetOwner():GetAmmoCount(self:GetPrimaryAmmoType()))
                            ammo = math.min(ammo, self:GetMaxClip1()-self:Clip1())
                            self:SetClip1(math.Clamp(self:Clip1() + ammo, 0, self:GetMaxClip1()))
                            self:GetOwner():RemoveAmmo( ammo, self:GetPrimaryAmmoType() )
                            if self:Clip1() == self:GetMaxClip1() then
                                self.ReloadTicker = function()end
                            else
                                self.ReloadWaitTime = CurTime() + 0.5
                            end
                        end
                    end
                else
                    self.ReloadTicker = function()end
                end
            end
        end
        if self:GetCurrentFiremode().Mode == 0 then
            self:SetSequence(3)
        end
        if self:GetOwner():KeyDown(IN_ATTACK) then
            self:SetSequence(5)
            self:GetOwner():GetViewModel():SendViewModelMatchingSequence(5)
            self:SetHoldType("duel")
        end
        if self:GetOwner():KeyReleased(IN_ATTACK) then
            self:SetSequence(1)
        end
        if self:GetSequence() == 5 then
            self:SetCycle( math.min(self:GetCycle() + 5*FrameTime(), 1))
        else
            self:SetCycle( math.min(self:GetCycle() + 0.5*FrameTime(), 1))
        end
        if self:GetCycle() >= 1 then
            if tonumber(self:GetSequence()) == 5 then
                self:SetCycle( 0 )
            end
        end
    end
    self:NextThink(CurTime())
    return true
end
--addons/arccw_weapons/lua/weapons/arccw_sops_scatterpistol.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "Scatter Pistol"
SWEP.Trivia_Class = "Blaster-Scatter Pistol"
SWEP.Trivia_Desc = "Heavy-Powered scatter pistol. Works like a small shotgun."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/sopsmisc/scatterpistol.png"

-- Viewmodel & Entity Properties
SWEP.HideViewmodel = false
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/masita/viewmodels/blasterpistol_template.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 66
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 23
SWEP.RangeMin = 55
SWEP.DamageMin = 20
SWEP.Range = 128
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 12

SWEP.Recoil = 0.43
SWEP.RecoilSide = 0.12
SWEP.RecoilRise = 0.98
SWEP.Delay = 60 / 128

SWEP.Num = 4
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 50
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 100

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/scatterpistol.wav"
SWEP.ShootSound = "sops-v2/weapons/scatterpistol.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-5.3, -10, -0.2),
    Ang = Angle(0, 0, 0),
     Magnification = 1.3,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(-4, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, -20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(10, -13, 0)
SWEP.CustomizeAng = Angle(12, 50.5, 45)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/scatter_pistol.mdl",
                Bone = "DC-15SA",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-2.3, 3.1, -4.6),
                    ang = Angle(0, 0, -90)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "DC-15SA",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2, 3, 9),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/scatter_pistol.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.2, 1.2, 1.2),
                Offset = {
                    pos = Vector(55, 0, 10),
                    ang = Angle(-15, -90, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(100, 13, -50),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/scatter_pistol.mdl"

SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        WMScale = Vector(11, 11, 11),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(-0.27, -3.7, -3.4),
            vang = Angle(90, 0, -90),
            wpos = Vector(45, 25, -70),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 0, 0)
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(11, 11, 11),
        Bone = "DC-15SA", 
        Offset = {
            vpos = Vector(-0.27, -0.5, 1),
            vang = Angle(90, 0, -90),
            wpos = Vector(110, 25, -50),
            wang = Angle(-15, 0, 180)
        },
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
    },    
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(9, 9, 9),
        Offset = {
            vpos = Vector(0.5, -2, -3.3),
            vang = Angle(90, 0, -90),
            wpos = Vector(52, 33, -53),
            wang = Angle(-15, 0, 180)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(11, 11, 11),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(1, -1.7, 1.3),
            vang = Angle(90, 0, -90),
            wpos = Vector(110, 40, -66),
            wang = Angle(-15, 0, 180)
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false
    },
    ["fire"] = {
        Source = {"Fire"},
    },
    ["fire_iron"] = {
        Source = {"Fire"},
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 105 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_z6x.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 5

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "ZX-6"
SWEP.Trivia_Class = "Blaster-Experimental Heavy Canon"
SWEP.Trivia_Desc = "The Zx-6 rotary blaster cannon was a blaster cannon used by the Galactic Republic during the Clone Wars. Later, during the reign of the Galactic Empire, these weapons were used by both the Imperial Army's Heavy Weapons Stormtroopers and Rebel Alliance's Heavy Soldiers during the Galactic Civil War."
SWEP.IconOverride = "entities/sopsmisc/z6x.png"

-- Viewmodel & Entity Properties
SWEP.ViewModel = "models/arccw/masita/viewmodels/base_rifle_animations.mdl"
SWEP.WorldModel = "models/weapons/synbf3/w_t21.mdl"
SWEP.ViewModelFOV = 66
SWEP.UseHands = true
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 26
SWEP.RangeMin = 89
SWEP.DamageMin = 21
SWEP.Range = 289
SWEP.Penetration = 2
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 100

SWEP.Recoil = 0.22
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.98
SWEP.Delay = 60 / 240

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 400
SWEP.MoveDispersion = 100

-- Special Properties
SWEP.TriggerDelay = true

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 125
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/z6x/z6x.wav"
SWEP.ShootSound = "sops-v2/weapons/z6x/z6x.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.6, 0, -1.9),
    Ang = Angle(1, -0.5, -3),
     Magnification = 2,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 2, -3)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -7)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -5)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(0, 0, 0)
SWEP.HolsterAng = Vector(0, 0, 0)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/holo_zx6.mdl",
                Bone = "E11S_CONTR",
                ModelBodygroups = "00000",
                Scale = Vector(0.9, 0.9, 0.9),
                Offset = {
                    pos = Vector(-0.2, -9, -1),
                    ang = Angle(0, -90, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-3, 34, -8),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/holo_zx6.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.9, 0.9, 0.9),
                ModelBodygroups = "00000",
                Offset = {
                    pos = Vector(0, 10, -15),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(470, 15, -149),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/holo_zx6.mdl"


SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.2, -3, 4.4),
            vang = Angle(0, -90, 0),
            wpos = Vector(60, 10, -93),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0)
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR", 
        Offset = {
            vpos = Vector(0.6, 33, 1.2),
            vang = Angle(40, -90, 90),
            wpos = Vector(450, 18, -165),
            wang = Angle(-15, 0, -60)
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = "foregrip",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.1, 6, -2.3),
            vang = Angle(0, -90, 0),
            wpos = Vector(160, 10, -43),
            wang = Angle(-15, 0, 180)
        },          
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        WMScale = Vector(20, 20, 20),
        VMScale = Vector(2, 2, 2),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.2, 38, 1),
            vang = Angle(0, -90, 0),
            wpos = Vector(500, 12, -173),
            wang = Angle(-15, 0, 180)
        },     
    },    
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(9, 9, 9),
        Offset = {
            vpos = Vector(1.1, -6.7, 1.65),
            vang = Angle(0, -90, 0),
            wpos = Vector(17.5, 24, -50),
            wang = Angle(-15, 0, 180)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(11, 11, 11),
        VMScale = Vector(1, 1, 1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.9, 2.2, 2.2),
            vang = Angle(0, -90, 0),
            wpos = Vector(100, 21, -78),
            wang = Angle(-15, 0, 180)
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["trigger"] = {
        Source = "shoot",
        SoundTable = {
            {s = "sops-v2/weapons/z6x/active.wav", t = 0.01 },
        },
    },
    ["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 120 / 60},
        },
    },
}

SWEP.Hook_ModifyRPM = function(wep, delay)
    return delay / Lerp(wep:GetBurstCount() / 15, 1, 3)
end
--addons/arccw_weapons/lua/weapons/arccw_westar11.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "[SMG] Westar-11"
SWEP.Trivia_Class = "Galactic Blaster Rifle"
SWEP.Trivia_Desc = "preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "Concordian Crescent Technologies"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020
SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_e11.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_westar11.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 25
SWEP.RangeMin = 135
SWEP.DamageMin = 13
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1


SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_yellow"
SWEP.TracerCol = Color(255, 165, 18)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 39

SWEP.Recoil = 0.27
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.13

SWEP.Delay = 60 / 270
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    }, 
    {
        Mode = 0
    },   
}

SWEP.AccuracyMOA = 0.5 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(255, 165, 18)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/westar11.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false

SWEP.MuzzleFlashColor = Color(0, 250, 0)

SWEP.IronSightStruct = {
    Pos = Vector(-2.83, -11, 2.8),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 50,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(2.9, -6, -4)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, -10, 0)
SWEP.SprintAng = Angle(-10, 40, 0)

SWEP.HolsterPos = Vector(2, -5, 1)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -16, 4.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"westar11"}

SWEP.AttachmentElements = {
    ["westar11"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/westar_35_rifle.mdl",
                Bone = "v_e11_reference001",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-0.9, 0.55, 1.75),
                    ang = Angle(0, 0, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/westar_35_rifle.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(240, 50, -200.5),
                    ang = Angle(-15, -90, 180)
                }
            }
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}

WMOverride = "models/arccw/sw_battlefront/weapons/westar_35_rifle.mdl"
--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.3, 0.03, 3),
            vang = Angle(90, 0, -90),
            wpos = Vector(800, 45, -650),
            wang = Angle(-15, 0, 180)
        },
    },    
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, 3, 12),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
        vmin = Vector(-0.2, 2.8, 8),
        vmax = Vector(-0.2, 2.8, 14),
        wmin = Vector(1600, 50, -480), 
        wmax = Vector(1600, 50, -480) -- how far this attachment can slide in both directions.
        },        
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1.2, 2, 5),
            vang = Angle(90, 0, -90),
            wpos = Vector(900, 150, -470),
            wang = Angle(-10 , 0, 180)
        },
    },          
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
    },
    ["holster"] = {
        Source = "holster",
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15s.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--lua/weapons/chainsaw/shared.lua:
if CLIENT then
SWEP.DrawWeaponInfoBox = true
end

SWEP.Author       = "-CRY-minal-"
SWEP.Purpose      = "Rip and tear"
SWEP.Instructions = "Too much blood..."
SWEP.Contact      = "Type:Melee Class:Special"

SWEP.PrintName = "  Chainsaw"
SWEP.Category = "Gluk Melee"
SWEP.Spawnable= true

SWEP.ViewModelFOV = 60
SWEP.ViewModel = "models/weapons/c_smg1.mdl"
SWEP.WorldModel = "models/weapons/w_smg1.mdl"
SWEP.ViewModelFlip = false
SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.HoldType = "physgun"

SWEP.ShowWorldModel = false

SWEP.AutoSwitchTo = true
SWEP.AutoSwitchFrom = false
SWEP.Weight = 0
SWEP.Slot = 0
SWEP.SlotPos = 0

SWEP.UseHands = true
SWEP.DrawAmmo = false
SWEP.Base = "weapon_base"

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Damage = 10
SWEP.Primary.DelayMiss = 0.07
SWEP.Primary.DelayHit = 0.07
SWEP.Primary.Force = 25

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(-2, -2, -3.1), angle = Angle(-18.889, -7.778, 0) },
	["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(-0.186, -5, 2.7), angle = Angle(0, 10, 0) },
	["ValveBiped.base"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, -8.7, 5), angle = Angle(0, -25, -30) },
	["ValveBiped.Bip01_L_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 0, 7) }
}

SWEP.VElements = {
	["handle+"] = { type = "Model", model = "models/props_c17/playground_teetertoter_stan.mdl", bone = "ValveBiped.base", rel = "base", pos = Vector(-0.7, 4, 6.5), angle = Angle(0, 0, 0), size = Vector(0.18, 0.18, 0.18), color = Color(80, 80, 80, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["base_decor_small+"] = { type = "Model", model = "models/props_lab/jar01a.mdl", bone = "ValveBiped.base", rel = "", pos = Vector(2, -4.5, 3.5), angle = Angle(-90, 0, 0), size = Vector(0.2, 0.2, 0.2), color = Color(255, 160, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["chain2"] = { type = "Model", model = "models/props_phx/gears/rack70.mdl", bone = "ValveBiped.base", rel = "", pos = Vector(-3.5, -2, 11), angle = Angle(0, 0, -90), size = Vector(0.1, 0.079, 0.1), color = Color(80, 80, 80, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["handle"] = { type = "Model", model = "models/props_c17/playground_teetertoter_stan.mdl", bone = "ValveBiped.base", rel = "base", pos = Vector(-0.7, 4, 4), angle = Angle(0, 0, 0), size = Vector(0.18, 0.18, 0.18), color = Color(100, 100, 100, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["chain"] = { type = "Model", model = "models/Mechanics/gears2/gear_48t1.mdl", bone = "ValveBiped.base", rel = "chain_base1", pos = Vector(0, 0, 0.4), angle = Angle(0, 0, 0), size = Vector(0.05, 0.05, 0.1), color = Color(80, 80, 80, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["button"] = { type = "Model", model = "models/maxofs2d/button_02.mdl", bone = "ValveBiped.base", rel = "", pos = Vector(-1.3, -5.5, 0.5), angle = Angle(0, 0, -90), size = Vector(0.15, 0.15, 0.15), color = Color(255, 200, 145, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["base_decor"] = { type = "Model", model = "models/props_interiors/Furniture_Couch02a.mdl", bone = "ValveBiped.base", rel = "", pos = Vector(-1.4, -2.81, 1.5), angle = Angle(0, -90, 0), size = Vector(0.17, 0.17, 0.17), color = Color(255, 200, 0, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} },
	["handle 2"] = { type = "Model", model = "models/Gibs/helicopter_brokenpiece_05_tailfan.mdl", bone = "ValveBiped.base", rel = "", pos = Vector(1.299, -2, -7), angle = Angle(90, 0, -90), size = Vector(0.07, 0.07, 0.07), color = Color(145, 145, 145, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["base_decor2"] = { type = "Model", model = "models/props_junk/cardboard_box003b_gib01.mdl", bone = "ValveBiped.base", rel = "", pos = Vector(-1, -0.5, 0), angle = Angle(0, 90, 90), size = Vector(0.4, 0.4, 0.4), color = Color(255, 230, 0, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} },
	["base"] = { type = "Model", model = "models/hunter/blocks/cube075x1x075.mdl", bone = "ValveBiped.base", rel = "", pos = Vector(0, 0, 0), angle = Angle(0, 0, -90), size = Vector(0.2, 0.2, 0.2), color = Color(255, 200, 0, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} },
	["base_decor3"] = { type = "Model", model = "models/props_junk/cardboard_box003b_gib01.mdl", bone = "ValveBiped.Bip01_Spine4", rel = "base", pos = Vector(2, 0, 0.5), angle = Angle(-90, 0, 0), size = Vector(0.239, 0.239, 0.239), color = Color(255, 145, 0, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} },
	["tank"] = { type = "Model", model = "models/props_junk/metalgascan.mdl", bone = "ValveBiped.base", rel = "", pos = Vector(0, -0.801, -4.5), angle = Angle(-90, 90, 0), size = Vector(0.4, 0.4, 0.4), color = Color(255, 200, 145, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["prop"] = { type = "Model", model = "models/maxofs2d/thruster_propeller.mdl", bone = "ValveBiped.base", rel = "", pos = Vector(0, -2.401, 0), angle = Angle(0, -45, -90), size = Vector(0.2, 0.2, 0.2), color = Color(255, 180, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["chain_base1"] = { type = "Model", model = "models/props_phx/construct/metal_angle360.mdl", bone = "ValveBiped.base", rel = "chain_base", pos = Vector(0, 9.5, -0.361), angle = Angle(0, 0, 0), size = Vector(0.05, 0.05, 0.05), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} },
	["base_decor_small"] = { type = "Model", model = "models/props_lab/jar01a.mdl", bone = "ValveBiped.base", rel = "", pos = Vector(2.4, -2.901, 2.5), angle = Angle(-90, 0, 0), size = Vector(0.2, 0.2, 0.2), color = Color(255, 160, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["chain_base"] = { type = "Model", model = "models/hunter/plates/plate05x2.mdl", bone = "ValveBiped.base", rel = "base", pos = Vector(-3.5, 14, 0), angle = Angle(90, 0, 0), size = Vector(0.2, 0.2, 0.2), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["handle+"] = { type = "Model", model = "models/props_c17/playground_teetertoter_stan.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(12, 1.6, -5.301), angle = Angle(0, 90, 180), size = Vector(0.18, 0.18, 0.18), color = Color(100, 100, 100, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["base_decor_small+"] = { type = "Model", model = "models/props_lab/jar01a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(10, 5.5, -1), angle = Angle(0, 0, 90), size = Vector(0.2, 0.2, 0.2), color = Color(255, 220, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["chain2"] = { type = "Model", model = "models/props_phx/gears/rack70.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(21, 3.599, -2), angle = Angle(0, 90, 180), size = Vector(0.1, 0.079, 0.1), color = Color(80, 80, 80, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["handle"] = { type = "Model", model = "models/props_c17/playground_teetertoter_stan.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(12, 1.6, -3), angle = Angle(0, 90, 180), size = Vector(0.18, 0.18, 0.18), color = Color(100, 100, 100, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["chain"] = { type = "Model", model = "models/Mechanics/gears2/gear_48t1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "chain_base1", pos = Vector(0, 0, 0.319), angle = Angle(0, 0, 0), size = Vector(0.05, 0.05, 0.05), color = Color(80, 80, 80, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["button"] = { type = "Model", model = "models/maxofs2d/button_06.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(7, 1.5, -3.701), angle = Angle(0, 0, 180), size = Vector(0.15, 0.15, 0.15), color = Color(255, 220, 155, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["base_decor"] = { type = "Model", model = "models/props_interiors/Furniture_Couch02a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(11.399, 1.299, -1.9), angle = Angle(90, 0, 180), size = Vector(0.17, 0.17, 0.17), color = Color(255, 230, 0, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} },
	["handle 2"] = { type = "Model", model = "models/Gibs/helicopter_brokenpiece_05_tailfan.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(0, 1.899, -1), angle = Angle(0, 0, 180), size = Vector(0.07, 0.07, 0.07), color = Color(145, 145, 145, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["base_decor2"] = { type = "Model", model = "models/props_junk/cardboard_box003b_gib01.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(8, 1.6, 1), angle = Angle(90, 90, 0), size = Vector(0.4, 0.4, 0.4), color = Color(255, 230, 0, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} },
	["base"] = { type = "Model", model = "models/hunter/blocks/cube075x1x075.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(10, 0, 0), angle = Angle(0, 90, 0), size = Vector(0.2, 0.2, 0.2), color = Color(255, 230, 0, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} },
	["base_decor3"] = { type = "Model", model = "models/props_junk/cardboard_box003b_gib01.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(8, 4, 1.5), angle = Angle(-90, 90, 0), size = Vector(0.239, 0.239, 0.239), color = Color(255, 220, 0, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} },
	["tank"] = { type = "Model", model = "models/props_junk/metalgascan.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2, 2.5, 0.5), angle = Angle(0, 180, 180), size = Vector(0.3, 0.3, 0.3), color = Color(255, 200, 145, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["prop"] = { type = "Model", model = "models/maxofs2d/thruster_propeller.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(8, 2, -1.5), angle = Angle(0, 0, 135), size = Vector(0.2, 0.2, 0.2), color = Color(255, 240, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["chain_base1"] = { type = "Model", model = "models/props_phx/construct/metal_angle360.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(34, 3.15, 0), angle = Angle(0, 0, 90), size = Vector(0.05, 0.05, 0.189), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} },
	["base_decor_small"] = { type = "Model", model = "models/props_lab/jar01a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(12, 5.5, 0), angle = Angle(0, 0, 90), size = Vector(0.2, 0.2, 0.2), color = Color(255, 220, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["chain_base"] = { type = "Model", model = "models/hunter/plates/plate05x2.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "base", pos = Vector(-3.5, 14, 0), angle = Angle(90, 0, 0), size = Vector(0.2, 0.2, 0.2), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/gear_top", skin = 0, bodygroup = {} }
}



function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 64,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 64,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if !tr.Hit then
self.Owner:EmitSound( "weapons/saw1.wav" )
end
if tr.Hit then
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = 200
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = 25
bullet.Damage = 0
bullet.AmmoType = "none"
self.Owner:FireBullets( bullet )
if tr.Entity:IsNPC() || tr.Entity:IsPlayer() then
self.Owner:EmitSound( "physics/metal/sawblade_stick2.wav" )
if (tr.HitSky) then return end
				local effect = EffectData();
				effect:SetOrigin(tr.HitPos);
				effect:SetNormal( tr.HitNormal );
				local rnum = math.random(1,1)
				if rnum == 1 then
				util.Effect("BloodImpact", effect);
				else
				util.Effect("ManhackSparks", effect);
				end
else
self.Owner:EmitSound( "physics/metal/sawblade_stick3.wav" )
end
end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects( "none" )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:SecondaryAttack()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end

function SWEP:FireAnimationEvent( pos, ang, event, options )

	-- we don't want shell casings
	if( event == 6001 ) then return true; end
	
	-- custom muzzle flash
	if( event == 21 or event == 22 ) then

		local effect = EffectData();
		effect:SetOrigin( pos );
		effect:SetAngles( ang );
		effect:SetEntity( self );
		effect:SetAttachment( 1 );

		util.Effect( "none", effect );
		
		return true;
	end

end



/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end
--lua/weapons/ghost_spanish_sword/shared.lua:
SWEP.Author       = "Killua"
SWEP.PrintName    = "Ghost Spanish sword"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Ghost"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack, Special +speed"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "knife"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 50
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(15, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-47.778, 0, 0) }
}
SWEP.VElements = {
	["hils++++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, -2, 4.9), angle = Angle(0, 0, -90), size = Vector(0.025, 0.025, 0.07), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/misc/shell2x2a.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.5), angle = Angle(0, 0, 0), size = Vector(0.048, 0.048, 0.048), color = Color(255, 255, 255, 160), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils+++++"] = { type = "Model", model = "models/hunter/tubes/tube1x1x1c.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 3), angle = Angle(0, -90, -90), size = Vector(0.09, 0.15, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -1), angle = Angle(0, 90, 0), size = Vector(0.05, 0.039, 0.109), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 2, 4.9), angle = Angle(0, 0, 90), size = Vector(0.025, 0.025, 0.07), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 13.6), angle = Angle(0, 0, 0), size = Vector(0.014, 0.014, 0.4), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils++"] = { type = "Model", model = "models/hunter/misc/shell2x2a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.5), angle = Angle(0, 0, 0), size = Vector(0.048, 0.048, 0.048), color = Color(255, 255, 255, 160), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils+++++"] = { type = "Model", model = "models/hunter/tubes/tube1x1x1c.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 3), angle = Angle(0, -90, -90), size = Vector(0.09, 0.15, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 13.6), angle = Angle(0, 0, 0), size = Vector(0.014, 0.014, 0.4), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 2, 4.9), angle = Angle(0, 0, 90), size = Vector(0.025, 0.025, 0.07), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 50, 8), size = Vector(0.05, 0.039, 0.109), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils++++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, -2, 4.9), angle = Angle(0, 0, -90), size = Vector(0.025, 0.025, 0.07), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} }
}


SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 28
SWEP.Primary.DelayMiss	 = 1.2
SWEP.Primary.DelayHit 	 = 0.28
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 16

SWEP.Secondary.Life        = true
SWEP.Secondary.Damage 	   = 70
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0
SWEP.SetRunSpeed=505

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
self.Owner:SetRunSpeed(self.SetRunSpeed)
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Owner:SetRunSpeed(self.SetRunSpeed+50)
		self.SetRunSpeed=self.SetRunSpeed +5
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Owner:SetRunSpeed(self.SetRunSpeed+50)
		self.SetRunSpeed=self.SetRunSpeed +5
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/aoc_nextbots/lua/weapons/gmod_tool/stools/aocrp_droidspawner.lua:
TOOL.Category = "Age of Clones"
TOOL.Name = "NPC Spawner"
TOOL.Command = nil
TOOL.ConfigName	= ""

if CLIENT then
	language.Add( "Tool.aocrp_droidspawner.name", "NPC Spawner" )
	language.Add( "Tool.aocrp_droidspawner.desc", "Spawnt Nextbot NPCs.")
	language.Add( "Tool.aocrp_droidspawner.left", "Spawnt einen Nextbot NPC.")
	language.Add( "Tool.aocrp_droidspawner.right", "Erstellt einen Markierungspunkt.")
    language.Add( "Tool.aocrp_droidspawner.reload", "Entfernt alle Markierungspunkte.")
end

TOOL.Information = {
	{ name = "left" },
	{ name = "right" },
	{ name = "reload"}
}

local MarkedPoints = {}
local Duty = "Passive"
local SelectedNPC = nil
local Health = 100
local Defense = false
local DisableGrenades = false

function TOOL:BuildCPanel()
    if SERVER then return end

    local Tool = self
    self.selectedIcon = nil

    self:AddControl("Header", {
        Text = "NPC Spawner",
        Description = "Spawne NPCs"
    })

    local defenseBool = vgui.Create("DCheckBoxLabel")
    defenseBool:SetText("Defense Mode")
    defenseBool:SetDark(true)
    defenseBool:SetValue(false)
    function defenseBool:OnChange(value)
        Defense = value
    end

    local healthSlider = vgui.Create("DNumSlider")
    healthSlider:SetText("Health")
    healthSlider:SetMin(1)
    healthSlider:SetMax(10000)
    healthSlider:SetDecimals(0)
    healthSlider:SetValue(100)
    healthSlider:SetDark(true)
    function healthSlider:Paint(w, h)
        surface.SetDrawColor(0, 0, 0, 100)
        surface.DrawRect(0, 0, w, h)
    end
    function healthSlider:OnValueChanged(value)
        Health = value
    end

    local dropdown = vgui.Create("DComboBox")
    dropdown:SetValue("Passive")
    dropdown:SetDark(true)
    dropdown:AddChoice("Passive")
    dropdown:AddChoice("Normal")
    dropdown:AddChoice("Attack")
    dropdown:AddChoice("Patrol")
    function dropdown:OnSelect(index, value, data)
        MarkedPoints = {}
        Duty = value
    end

    local bool = vgui.Create("DCheckBoxLabel")
    bool:SetText("Disable Grenades")
    bool:SetDark(true)
    bool:SetValue(false)
    bool:SetTooltip("Disables the grenade throwing of the NPC.")
    function bool:OnChange(value)
        DisableGrenades = value
    end

    local iconLayout = vgui.Create("DIconLayout")
    iconLayout:SetSpaceY(5)
    iconLayout:SetSpaceX(5)
    iconLayout:Dock(FILL)
    function iconLayout:Paint(w, h)
        surface.SetDrawColor(0, 0, 0, 100)
        surface.DrawRect(0, 0, w, h)
    end

    for k, v in SortedPairs(AOCRPNextbots.Config.Tool) do
        local spawnIcon = iconLayout:Add("SpawnIcon", iconLayout)
        spawnIcon:SetModel(v.previewModel or "models/Gibs/HGIBS.mdl")
        spawnIcon:SetSize(64, 64)
        function spawnIcon:DoClick()
            healthSlider:SetValue(v.health or 100)
            Tool.selectedIcon = self
            SelectedNPC = k
        end

        function spawnIcon:PaintOver(w, h)
            if Tool.selectedIcon == spawnIcon then
                surface.SetDrawColor(0, 255, 21, 100)
                surface.DrawOutlinedRect(0, 0, w, h, 3)
            end
        end

        if k == 1 then
            spawnIcon:DoClick()
        end
    end

    self:AddItem(defenseBool)
    self:AddItem(healthSlider)
    self:AddItem(dropdown)
    self:AddItem(bool)
    self:AddItem(iconLayout)
end

function TOOL:LeftClick(trace)
    if SERVER then return end
    if not IsFirstTimePredicted() then return end

    if IsValid(trace.Entity) and (trace.Entity:IsPlayer() or trace.Entity:IsNPC() or trace.Entity:IsNextBot()) then return end

    net.Start("AOCRP.SpawnNPC")
        net.WriteUInt(SelectedNPC, 10)
        net.WriteUInt(Health, 10)
        net.WriteString(Duty)
        net.WriteVector(trace.HitPos)
        net.WriteTable(MarkedPoints)
        net.WriteBool(Defense)
        net.WriteBool(DisableGrenades)
    net.SendToServer()
end

function TOOL:RightClick(trace)
    if SERVER then return end
    if not IsFirstTimePredicted() then return end

    if IsValid(trace.Entity) and (trace.Entity:IsPlayer() or trace.Entity:IsNPC() or trace.Entity:IsNextBot()) then return end

    if Duty ~= "Patrol" and not table.IsEmpty(MarkedPoints) then return end
    if Duty ~= "Attack" and Duty ~= "Patrol" then return end

    local pos = trace.HitPos
    table.insert(MarkedPoints, pos)
end

function TOOL:Reload()
    if SERVER then return end

    MarkedPoints[#MarkedPoints] = nil
end

hook.Add("PostDrawOpaqueRenderables", "AOCRP_Droidspawner_MarkedPoints", function()
    local ply = LocalPlayer()
    if not IsValid(ply:GetActiveWeapon()) or ply:GetActiveWeapon():GetClass() ~= "gmod_tool" then return end
    local tool = ply:GetTool()
    if not tool or tool.Mode ~= "aocrp_droidspawner" then return end

    for k, v in ipairs(MarkedPoints) do
        local top = Vector(v.x, v.y, v.z + 200)
        render.DrawLine(v, top, Color(255, 255, 255), false)
    end
end)

hook.Add("PostDrawOpaqueRenderables", "AOCRP_DroidSpawner_Preview", function()
    local ply = LocalPlayer()
    if not IsValid(ply:GetActiveWeapon()) or ply:GetActiveWeapon():GetClass() ~= "gmod_tool" then return end
    local tool = ply:GetTool()
    if not tool or tool.Mode ~= "aocrp_droidspawner" then return end

    local tr = util.GetPlayerTrace(ply)
    local trace = util.TraceLine(tr)
    if not trace.Hit then return end

    if not SelectedNPC or not AOCRPNextbots.Config.Tool[SelectedNPC] then return end
    local model = AOCRPNextbots.Config.Tool[SelectedNPC].previewModel

    local modelData = {
        model = model,
        pos = trace.HitPos + trace.HitNormal * 5,
        angle = Angle(0, ply:EyeAngles().y - 90, 0),
    }

    render.Model(modelData)
end)
--gamemodes/starwarsrp/entities/weapons/gmod_tool/stools/removeprops.lua:
TOOL.Category		=	"Age of Clones"
TOOL.Name			=	"RemoveProps"
TOOL.Command		=	nil
TOOL.ConfigName		=	""

if CLIENT then
	language.Add("Tool.removeprops.name", "RemoveProps")
	language.Add("Tool.removeprops.desc", "Remove a props permanently")
	language.Add("Tool.removeprops.0", "LeftClick: Add RightClick: OpenMenu")
end

if SERVER then
	--util.AddNetworkString("ContentRmvProps")
	util.AddNetworkString("RmvPropsSQL")

	--sql.Query("CREATE TABLE IF NOT EXISTS removeprops('id' INTEGER NOT NULL, 'map' TEXT NOT NULL, 'content' TEXT NOT NULL, PRIMARY KEY('id'));")
end

if SERVER then
	local function RmvPropsSQL(um, ply)
		local EntIndex = net.ReadFloat()
        print(EntIndex)
		if not ply:IsAdmin() then return end

        local content = mysql:Select("removeprops")
        content:Where("id", EntIndex)
        content:Callback(function(result, status, lastID)
            if not result then return end

            for k, v in pairs(result) do
                if game.GetMap() == v.map then
                    local data = util.JSONToTable(v.content)
                    print(data.ID)
                    if data.ID == EntIndex then
                        local deleteObj = mysql:Delete("removeprops")
                        deleteObj:Where("id", v.id)
                        deleteObj:Execute()
                    end
                end
            end
        end)
        content:Execute()

		
		-- local content = sql.Query("SELECT * FROM removeprops;")

		-- if content == nil then return end
		
		-- for k, v in pairs( content ) do

		-- 	if game.GetMap() == v.map then

		-- 		local data = util.JSONToTable(v.content)

		-- 		if data.ID == EntIndex then

		-- 			sql.Query("DELETE FROM removeprops WHERE id = ".. v.id ..";")
				
		-- 		end

		-- 	end

		--end

	end
	net.Receive("RmvPropsSQL", RmvPropsSQL)
end

local function RemoveProps()

	if CLIENT then return end

    local selectTable = mysql:Select("removeprops")
    selectTable:Callback(function(result, status, lastID)
        if not result then return end

        for k, v in pairs(result) do
            if game.GetMap() == v.map then
                local data = util.JSONToTable(v.content)
                local ent = ents.GetByIndex(data.ID)

                for k2, v2 in pairs(ents.FindInSphere(data.Pos, 0.2)) do
                    if v2:GetModel() == data.Model and v2:GetClass() == data.Name then
                        v2:Remove()
                    end
                end
            end
        end
    end)
    selectTable:Execute() 


	-- local content = sql.Query( "SELECT * FROM removeprops;" )

	-- if not content or content == nil then return end
	
	-- for k, v in pairs( content ) do

	-- 	if game.GetMap() == v.map then

	-- 		local data = util.JSONToTable(v.content)

	-- 		local ent = ents.GetByIndex(data.ID)

	-- 		for k2, v2 in pairs(ents.FindInSphere( data.Pos, 0.2 )) do
				
	-- 			if v2:GetModel() == data.Model and v2:GetClass() == data.Name  then
					
	-- 				v2:Remove()

	-- 			end

	-- 		end

	-- 		/*if ent:IsValid() then
				
	-- 			ent:Remove()

	-- 		end*/

	-- 	end

	-- end

end
hook.Add("InitPostEntity", "InitializeRemoveProps", RemoveProps)
hook.Add("PostCleanupMap", "WhenCleanUpRemoveProps", RemoveProps)
timer.Simple(5, function() RemoveProps() end) -- When the hook isn't call ...

function TOOL:LeftClick(trace)
	if CLIENT then return end

	local ply = self:GetOwner()
	local ent = trace.Entity

	if not self:GetOwner():IsAdmin() then return false end
	if ent:IsWorld() then ply:ChatPrint( "You can't remove the world DUDE !" ) return false end
	if not ent then ply:ChatPrint( "That is not a valid entity !" ) return false end
	if not ent:IsValid() then ply:ChatPrint( "That is not a valid entity !" ) return false end
	if ent:IsPlayer() then ply:ChatPrint( "That is a player !" ) return false end
	if ent.OnDieFunctions then ply:ChatPrint( "You can't remove this !" ) return false end
	if ent.PermaProps then ply:ChatPrint( "You can't remove this !" ) return false end
    
	local effectdata = EffectData()
	effectdata:SetOrigin(ent:GetPos())
	effectdata:SetMagnitude(2)
	effectdata:SetScale(2)
	effectdata:SetRadius(3)
	util.Effect("Sparks", effectdata)

	local content = {}
	content.ID = ent:EntIndex()
	content.Name = ent:GetClass()
	content.Model = ent:GetModel()
	content.Pos = ent:GetPos()
	content.Angle = ent:GetAngles()

    local insertTable = mysql:Insert("removeprops")
    insertTable:Insert("map", game.GetMap())
    insertTable:Insert("content", util.TableToJSON(content))
    insertTable:Callback(function(result, status, lastID)
        print("S")
        ply:ChatPrint("You remove " .. ent:GetClass() .. " permanently in the map !")
        ent:Remove()
        return true
    end)
    insertTable:Execute()

	--sql.Query("INSERT INTO removeprops (id, map, content) VALUES(NULL, ".. sql.SQLStr(game.GetMap()) ..", ".. sql.SQLStr(util.TableToJSON(content)) ..");")
	-- ply:ChatPrint("You remove " .. ent:GetClass() .. " permanently in the map !")

	-- ent:Remove()

	return false

end

local function ContentRmvProps(Content)
	local DermaPanel = vgui.Create( "DFrame" )
	DermaPanel:SetSize( 500, 200 )
	DermaPanel:SetTitle( "Removed props" )
	DermaPanel:Center()
	DermaPanel:MakePopup()
	 
	local DermaListView = vgui.Create("DListView", DermaPanel)
	DermaListView:SetPos(25, 30)
	DermaListView:SetSize(450, 125)
	DermaListView:SetMultiSelect(false)
	local Col1 = DermaListView:AddColumn("ID")
	local Col2 = DermaListView:AddColumn("Name")
	local Col3 = DermaListView:AddColumn("Model")
	Col1:SetMinWidth(50)
	Col1:SetMaxWidth(50)

	Col2:SetMinWidth(80)
	Col2:SetMaxWidth(80)
	DermaListView.OnRowRightClick = function(panel, line)
		local MenuButtonOptions = DermaMenu()
	    MenuButtonOptions:AddOption("Draw entity", function() 

	    	if not LocalPlayer().DrawRemovedEnt or not istable(LocalPlayer().DrawRemovedEnt) then LocalPlayer().DrawRemovedEnt = {} end

	    	if LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID] and LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID]:IsValid() then return end

		    local ent = ents.CreateClientProp( Content[DermaListView:GetLine(line):GetValue(1)].Model ) 
			ent:SetPos( Content[DermaListView:GetLine(line):GetValue(1)].Pos )
			ent:SetAngles( Content[DermaListView:GetLine(line):GetValue(1)].Angle )

			LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID] = ent

		end)

		if LocalPlayer().DrawRemovedEnt and LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID] != nil then
			MenuButtonOptions:AddOption("Stop Drawing", function() 
				LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID]:Remove()
				LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID] = nil
			end)
		end

	    MenuButtonOptions:AddOption("Remove", function()
            PrintTable(Content[DermaListView:GetLine(line):GetValue(1)])
	    	net.Start("RmvPropsSQL")
	    	net.WriteFloat(Content[DermaListView:GetLine(line):GetValue(1)].ID)
	    	net.SendToServer()

	    	if LocalPlayer().DrawRemovedEnt and LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID] != nil then
	    		LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID]:Remove()
				LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID] = nil
	    	end

	    	DermaListView:RemoveLine(line)

	    	LocalPlayer():ChatPrint("Removed successfully from the database ! ( Need server restart )")
		end)

	    MenuButtonOptions:Open()
	end
	 
	for k, v in pairs(Content) do
        PrintTable(v)
	    DermaListView:AddLine(k, v.Name, v.Model)
	end
end

function TOOL:RightClick(trace)
    if SERVER then return end

    if not IsFirstTimePredicted() then return end

    AOCRP.API:Request("getremoveprops", function(data)
        if table.IsEmpty(data) then return end

        local removedProps = {}
        for k, v in pairs(data) do
            local content = util.JSONToTable(v.content)
            table.insert(removedProps, content)
        end

		ContentRmvProps(removedProps)
	end, {["map"] = game.GetMap()})

	-- if CLIENT then return end

	-- local SendTable = {}
	-- local content = sql.Query( "SELECT * FROM removeprops;" )

	-- if content == nil then return end
	
	-- for k, v in pairs( content ) do

	-- 	if game.GetMap() == v.map then

	-- 		local data = util.JSONToTable(v.content)

	-- 		table.insert(SendTable, data)

	-- 	end

	-- end

	-- net.Start("ContentRmvProps")
	-- net.WriteTable(SendTable)
	-- net.Send(self:GetOwner())

	-- return false

end

function TOOL:Reload(trace)

	if CLIENT then return end

	return false

end

function TOOL.BuildCPanel(panel)

	panel:AddControl("Header",{Text = "Perma Remove Props", Description = "Remove a server props for restarts\nBy Malboro"})

end
--net.Receive("ContentRmvProps", ContentRmvProps)

local function RemoverViewer()

	if not LocalPlayer().DrawRemovedEnt or not istable(LocalPlayer().DrawRemovedEnt) then return end

    local pos = LocalPlayer():EyePos() + LocalPlayer():EyeAngles():Forward() * 10
    local ang = LocalPlayer():EyeAngles()

    ang = Angle(ang.p + 90, ang.y, 0)

    for k, v in pairs(LocalPlayer().DrawRemovedEnt) do

    	if not v or not v:IsValid() then LocalPlayer().DrawRemovedEnt[k] = nil continue end

	    render.ClearStencil()
	    render.SetStencilEnable(true)
	        render.SetStencilWriteMask(255)
	        render.SetStencilTestMask(255)
	        render.SetStencilReferenceValue(15)
	        render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	        render.SetStencilZFailOperation(STENCILOPERATION_REPLACE)
	        render.SetStencilPassOperation(STENCILOPERATION_KEEP)
	        render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_ALWAYS)
	        render.SetBlend(0)
	        v:DrawModel()
	        render.SetBlend(1)
	        render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	        cam.Start3D2D(pos, ang, 1)
	                surface.SetDrawColor(255, 0, 0, 255)
	                surface.DrawRect(-ScrW(), -ScrH(), ScrW() * 2, ScrH() * 2)
	        cam.End3D2D()
	        v:DrawModel()
	    render.SetStencilEnable(false)

	end
end
hook.Add("PostDrawOpaqueRenderables", "RemoverViewer", RemoverViewer)
--addons/tools/lua/weapons/gmod_tool/stools/vanilla_shipdestruction_tool.lua:
-- Why hello there!

TOOL.Category		= "Vanilla"
TOOL.Name			= "Vanilla's Ship Destruction Tool"
TOOL.Command		= nil
TOOL.ConfigName		= ""

TOOL.AdminOnly		= true

if ( CLIENT ) then
    language.Add( "Tool.vanilla_shipdestruction_tool.name", "Vanilla's Ship Destruction Tool" )
    language.Add( "Tool.vanilla_shipdestruction_tool.desc", "Destroy ships, in style!" )
    language.Add( "Tool.vanilla_shipdestruction_tool.left", "Target a entity or prop to destroy.")
end

TOOL.Information = {

    { name = "left" }

}

TOOL.ClientConVar[ "length" ] = "16"
TOOL.ClientConVar[ "explosize" ] = "1"
TOOL.ClientConVar[ "finalsize" ] = "5"
TOOL.ClientConVar[ "turnrate" ] = "0.06"
TOOL.ClientConVar[ "fallrate" ] = "5"
TOOL.ClientConVar[ "forwardrate" ] = "5"
TOOL.ClientConVar[ "flip" ] = "0"

function TOOL:LeftClick( trace )
    if (!trace.Entity) then return false end
    if (CLIENT) then return true end
    local ent = trace.Entity
    if ent == "vanilla_shipdestruction" then print("tes") end

    local ship = ents.Create("vanilla_shipdestruction")
    ship:SetPos(ent:GetPos())
    ship:SetAngles(ent:GetAngles())
    ship:SetModel(ent:GetModel())
    ship:SetKeyValue("Length",self:GetClientInfo("length"))
    ship:SetKeyValue("ExplosionSize",self:GetClientInfo("explosize"))
    ship:SetKeyValue("FinalSize",self:GetClientInfo("finalsize"))
    ship:SetKeyValue("Flip",self:GetClientInfo("flip"))
    ship:SetKeyValue("TurnRate",self:GetClientInfo("turnrate"))
    ship:SetKeyValue("FallRate",self:GetClientInfo("fallrate"))
    ship:SetKeyValue("ForwardRate",self:GetClientInfo("forwardrate"))
    if ! util.IsValidModel(ent:GetModel()) then return end
    ship:Spawn()
    ent:Remove()

    undo.Create("Destruction")
        undo.AddEntity(ship)
        undo.SetCustomUndoText("Undone Ship Destruction")
        undo.SetPlayer(self:GetOwner())
    undo.Finish()

    return true
end

function TOOL:RightClick( trace )
end

function TOOL:Reload( trace )
end

function TOOL:Think()
end

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel(CPanel)
    CPanel:SetName("Vanilla's Ship Destruction Tool")

    CPanel:Help("Version 1.1")

    CPanel:AddControl( "ComboBox", { MenuButton = 1, Folder = "vanilla_shipdestruction_tool", Options = { [ "#preset.default" ] = ConVarsDefault }, CVars = table.GetKeys( ConVarsDefault ) } )

    CPanel:NumSlider("Destruction Length","vanilla_shipdestruction_tool_length","1","120","1")
    CPanel:ControlHelp("Sets the length of the ship explosion. (in seconds)")

    CPanel:NumSlider("Explosion Size","vanilla_shipdestruction_tool_explosize","0","5","0")
    CPanel:ControlHelp("Sets the standard explosion size.")

    CPanel:NumSlider("Final Explosion Size","vanilla_shipdestruction_tool_finalsize","0","20","0")
    CPanel:ControlHelp("Sets the final explosion size.")

    CPanel:NumSlider("Tilt Rate","vanilla_shipdestruction_tool_turnrate","0","1","2")
    CPanel:ControlHelp("Sets how fast the ship tilts down.")

    CPanel:NumSlider("Fall Rate","vanilla_shipdestruction_tool_fallrate","0","10","0")
    CPanel:ControlHelp("Sets how fast the ship falls down.")

    CPanel:NumSlider("Forward Rate","vanilla_shipdestruction_tool_forwardrate","0","10","0")
    CPanel:ControlHelp("Sets how fast the ship is moving forward")

    CPanel:CheckBox("Flip","vanilla_shipdestruction_tool_flip")
    CPanel:ControlHelp("Tick if the ship is turning/moving in the wrong direction.")

end

--lua/weapons/gold_mace/shared.lua:
SWEP.Author       = "Segaretka"
SWEP.PrintName    = "Gold Mace"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Gold"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 40
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.37, 0.37, 0.37), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils++++++"] = { type = "Model", model = "models/hunter/blocks/cube05x05x05.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 22.337), angle = Angle(141.429, 90, 0), size = Vector(0.081, 0.081, 0.081), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils+++++"] = { type = "Model", model = "models/hunter/blocks/cube05x05x05.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 22.337), angle = Angle(0, 90, 50), size = Vector(0.082, 0.082, 0.082), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.4), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.108), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils++++"] = { type = "Model", model = "models/hunter/blocks/cube05x05x05.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 22.337), angle = Angle(0, 90, 0), size = Vector(0.079, 0.079, 0.079), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils++++++"] = { type = "Model", model = "models/hunter/blocks/cube05x05x05.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 22.337), angle = Angle(141.429, 90, 0), size = Vector(0.081, 0.081, 0.081), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils++++"] = { type = "Model", model = "models/hunter/blocks/cube05x05x05.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 22.337), angle = Angle(0, 90, 0), size = Vector(0.079, 0.079, 0.079), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils+++++"] = { type = "Model", model = "models/hunter/blocks/cube05x05x05.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 22.337), angle = Angle(0, 90, 50), size = Vector(0.082, 0.082, 0.082), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.4), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, -26.883, 8), size = Vector(0.05, 0.039, 0.108), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} }
}


SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 40
SWEP.Primary.DelayMiss	 = 1.2
SWEP.Primary.DelayHit 	 = 0.98
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "Impact.Glass"
SWEP.Primary.Range       = 12

SWEP.Secondary.Life        = false
SWEP.Secondary.Damage 	   = 70
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/weapons_other/lua/weapons/jet_mk5.lua:

AddCSLuaFile()

SWEP.ViewModel = Model( "models/weapons/c_arms_animations.mdl" )
SWEP.WorldModel = ""

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

SWEP.PrintName	= "Jetpack"
SWEP.Category	= "Star Wars Jetpacks"

SWEP.Slot		= 4
SWEP.SlotPos	= 1

SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= false
SWEP.Spawnable		= true
SWEP.AdminOnly		= false

if SERVER then
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false
end

function SWEP:SetupDataTables()
	self:NetworkVar( "Int", 0, "Fuel" )
	if ( SERVER ) then
		self:SetFuel(100)
	end
end

function SWEP:Initialize()
	self:SetHoldType( "normal" )
end



function SWEP:Reload()
end

function SWEP:PrimaryAttack()
	if CLIENT then return end

	local ply = self:GetOwner()
	local ex = ply:GetNetVar("Jetted")

	if IsValid(ex) then
		ex:Remove()
		ply:SetNetVar("Jetted", NULL)
		ply.LastJetExecuted = CurTime()
	else
		if !ply:IsOnGround() then return end
		--if (ply.LastJetExecuted or 0)+20 >= CurTime() then return end
		local jp = ents.Create("mk5")
		jp:SetSlotName("mk5")
		jp:Spawn()
		jp:Attach(ply)
		ply.Jetted = jp
		ply:SetNetVar("Jetted", jp)
	end
	ply:EmitSound("buttons/button14.wav")
end

local skinint = 1

function SWEP:SecondaryAttack()
	if CLIENT then return end
	local ply = self:GetOwner()
	local ex = ply:GetNetVar("Jetted")
	if !IsValid(ex) then return end
	skinint = (skinint + 1)%3
	ex:SetSkin(skinint)
	ply:EmitSound("")
end

function SWEP:Deploy()
	return true
end

function SWEP:Equip()

end

function SWEP:ShouldDropOnDie() return false end


if SERVER then return end

--function SWEP:DrawHUD() end
--function SWEP:PrintWeaponInfo( x, y, alpha ) end

--function SWEP:HUDShouldDraw( name )
	--if ( name == "CHudWeaponSelection" ) then return true end
	--if ( name == "CHudChat" ) then return true end
	--return false
--end
--lua/weapons/ls_base_mine_swep/cl_init.lua:
include("shared.lua")

local function table_FullCopy( tab )

    if (!tab) then return nil end
    
    local res = {}
    for k, v in pairs( tab ) do
        if (type(v) == "table") then
            res[k] = table_FullCopy(v) // recursion ho!
        elseif (type(v) == "Vector") then
            res[k] = Vector(v.x, v.y, v.z)
        elseif (type(v) == "Angle") then
            res[k] = Angle(v.p, v.y, v.r)
        else
            res[k] = v
        end
    end
    
    return res
    
end

function SWEP:PrimaryAttack()
end

function SWEP:SecondaryAttack()
end

function SWEP:Initialize()
    self:PreInitialize()

    self.CSMineModel = ClientsideModel(self.MineModel)
    self.CSMineModel:SetNoDraw(true)
    self.CSMineModel:SetMaterial("models/debug/debugwhite")

    // SWEP VElements & WElements Stuff
    self.VElements = table_FullCopy(self.VElements)
    self.WElements = table_FullCopy(self.WElements)
    self.ViewModelBoneMods = table_FullCopy(self.ViewModelBoneMods)

    self:CreateModels(self.VElements) // create viewmodels
    self:CreateModels(self.WElements) // create worldmodels
    
    if IsValid(self:GetOwner()) and (self:GetOwner() == LocalPlayer()) then
        local vm = self:GetOwner():GetViewModel()
        if IsValid(vm) then
            self:ResetBonePositions(vm)
            -- hide grenade of the viewmodel
            vm:ManipulateBoneScale(vm:LookupBone("ValveBiped.Grenade_body"), Vector(0, 0, 0))
        end
    end
end

hook.Add("PostDrawOpaqueRenderables", "SW.Mines.DrawCSMineModel", function ()
    local ply = LocalPlayer()
    local weapon = ply:GetActiveWeapon()
    if (not ply:Alive()) or (not IsValid(weapon)) or (not weapon.IsMineSWEP) or ply:InVehicle() then return end

    local trace = ply:GetEyeTrace()
    local distance = LocalPlayer():EyePos():DistToSqr(trace.HitPos)
    if distance > weapon.Range * 2 then return end

    weapon.CSMineModel:SetPos(trace.HitPos)
    weapon.CSMineModel:SetAngles(Angle(0,0,0))

    local hitAngle = trace.HitNormal:Angle()
    weapon.CSMineModel:SetLocalAngles(weapon.CSMineModel:WorldToLocalAngles(hitAngle) + Angle(90,0,0))

    render.SetColorModulation(0,180/255,25/255)

    if (weapon.AngleLimitation) then
        if (weapon.CSMineModel:GetLocalAngles().x > weapon.AngleLimitation or weapon.CSMineModel:GetLocalAngles().z > weapon.AngleLimitation) then
            render.SetColorModulation(255/255,0,0)
        else
            render.SetColorModulation(0,180/255,25/255)
        end
    end

    if not trace.Entity:IsWorld() then
        render.SetColorModulation(255/255,0,0)
    end

    if weapon:Clip1() <= 0 then
        render.SetColorModulation(255/255,180/255,0)
    end

    render.SetBlend(0.5)

    if distance > weapon.Range then
        render.SetColorModulation(150/255,0,0)
        render.SetBlend(0.2)
    end

    weapon.CSMineModel:DrawModel()
    render.SetColorModulation(0,0,0)
    render.SetBlend(1)
end)

///////////////////////////////////////
// SWEP VIEW & WORLD MODEL FUNCTIONS //
///////////////////////////////////////

SWEP.vRenderOrder = nil
function SWEP:ViewModelDrawn()
    
    local vm = self:GetOwner():GetViewModel()
    if !IsValid(vm) then return end
    
    if (!self.VElements) then return end
    
    self:UpdateBonePositions(vm)

    if (!self.vRenderOrder) then
        
        // we build a render order because sprites need to be drawn after models
        self.vRenderOrder = {}

        for k, v in pairs( self.VElements ) do
            if (v.type == "Model") then
                table.insert(self.vRenderOrder, 1, k)
            end
        end
        
    end

    for k, name in ipairs( self.vRenderOrder ) do
    
        local v = self.VElements[name]
        if (!v) then self.vRenderOrder = nil break end
        if (v.hide) then continue end
        
        local model = v.modelEnt
        
        if (!v.bone) then continue end
        
        local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
        
        if (!pos) then continue end
        
        if (v.type == "Model" and IsValid(model)) then

            model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
            ang:RotateAroundAxis(ang:Up(), v.angle.y)
            ang:RotateAroundAxis(ang:Right(), v.angle.p)
            ang:RotateAroundAxis(ang:Forward(), v.angle.r)

            model:SetAngles(ang)
            
            model:DrawModel()
        end
        
    end
    
end

SWEP.wRenderOrder = nil
function SWEP:DrawWorldModel()
    if (!self.WElements) then return end
    
    if (!self.wRenderOrder) then

        self.wRenderOrder = {}

        for k, v in pairs( self.WElements ) do
            if (v.type == "Model") then
                table.insert(self.wRenderOrder, 1, k)
            end
        end

    end
    
    if (IsValid(self:GetOwner())) then
        bone_ent = self:GetOwner()
    else
        // when the weapon is dropped
        bone_ent = self
    end
    
    for k, name in pairs( self.wRenderOrder ) do
    
        local v = self.WElements[name]
        if (!v) then self.wRenderOrder = nil break end
        if (v.hide) then continue end
        
        local pos, ang
        
        if (v.bone) then
            pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
        else
            pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
        end
        
        if (!pos) then continue end
        
        local model = v.modelEnt
        local sprite = v.spriteMaterial
        
        if (v.type == "Model" and IsValid(model)) then

            model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
            ang:RotateAroundAxis(ang:Up(), v.angle.y)
            ang:RotateAroundAxis(ang:Right(), v.angle.p)
            ang:RotateAroundAxis(ang:Forward(), v.angle.r)

            model:SetAngles(ang)
            
            model:DrawModel()
        end
        
    end
    
end

function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
    
    local bone, pos, ang
    if (tab.rel and tab.rel != "") then
        
        local v = basetab[tab.rel]
        
        if (!v) then return end
        
        // Technically, if there exists an element with the same name as a bone
        // you can get in an infinite loop. Let's just hope nobody's that stupid.
        pos, ang = self:GetBoneOrientation( basetab, v, ent )
        
        if (!pos) then return end
        
        pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
        ang:RotateAroundAxis(ang:Up(), v.angle.y)
        ang:RotateAroundAxis(ang:Right(), v.angle.p)
        ang:RotateAroundAxis(ang:Forward(), v.angle.r)
            
    else
    
        bone = ent:LookupBone(bone_override or tab.bone)

        if (!bone) then return end
        
        pos, ang = Vector(0,0,0), Angle(0,0,0)
        local m = ent:GetBoneMatrix(bone)
        if (m) then
            pos, ang = m:GetTranslation(), m:GetAngles()
        end
        
        if (IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() and 
            ent == self:GetOwner():GetViewModel() and self.ViewModelFlip) then
            ang.r = -ang.r // Fixes mirrored models
        end
    
    end
    
    return pos, ang
end

function SWEP:CreateModels( tab )

    if (!tab) then return end

    // Create the clientside models here because Garry says we can't do it in the render hook
    for k, v in pairs( tab ) do
        if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
                string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
            
            v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
            if (IsValid(v.modelEnt)) then
                v.modelEnt:SetPos(self:GetPos())
                v.modelEnt:SetAngles(self:GetAngles())
                v.modelEnt:SetParent(self)
                v.modelEnt:SetNoDraw(true)
                v.createdModel = v.model
            else
                v.modelEnt = nil
            end
        end
    end
    
end

local allbones
local hasGarryFixedBoneScalingYet = false

function SWEP:UpdateBonePositions(vm)
    
    if self.ViewModelBoneMods then
        
        if (!vm:GetBoneCount()) then return end
        
        // !! WORKAROUND !! //
        // We need to check all model names :/
        local loopthrough = self.ViewModelBoneMods
        if (!hasGarryFixedBoneScalingYet) then
            allbones = {}
            for i=0, vm:GetBoneCount() do
                local bonename = vm:GetBoneName(i)
                if (self.ViewModelBoneMods[bonename]) then 
                    allbones[bonename] = self.ViewModelBoneMods[bonename]
                else
                    allbones[bonename] = { 
                        scale = Vector(1,1,1),
                        pos = Vector(0,0,0),
                        angle = Angle(0,0,0)
                    }
                end
            end
            
            loopthrough = allbones
        end
        // !! ----------- !! //
        
        for k, v in pairs( loopthrough ) do
            local bone = vm:LookupBone(k)
            if (!bone) then continue end
            
            // !! WORKAROUND !! //
            local s = Vector(v.scale.x,v.scale.y,v.scale.z)
            local p = Vector(v.pos.x,v.pos.y,v.pos.z)
            local ms = Vector(1,1,1)
            if (!hasGarryFixedBoneScalingYet) then
                local cur = vm:GetBoneParent(bone)
                while(cur >= 0) do
                    local pscale = loopthrough[vm:GetBoneName(cur)].scale
                    ms = ms * pscale
                    cur = vm:GetBoneParent(cur)
                end
            end
            
            s = s * ms
            // !! ----------- !! //
            
            if vm:GetManipulateBoneScale(bone) != s then
                -- vm:ManipulateBoneScale( bone, s )
            end
            if vm:GetManipulateBoneAngles(bone) != v.angle then
                vm:ManipulateBoneAngles( bone, v.angle )
            end
            if vm:GetManipulateBonePosition(bone) != p then
                vm:ManipulateBonePosition( bone, p )
            end
        end
    else
        self:ResetBonePositions(vm)
    end
        
end
    
function SWEP:ResetBonePositions(vm)
    
    if (!vm:GetBoneCount()) then return end
    for i=0, vm:GetBoneCount() do
        -- vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
        vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
        vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
    end
    
end
--addons/arccw_weapons/lua/weapons/masita_dc15a_train.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Training DC-15a"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The DC-15A blaster rifle, known simply as the DC-15 blaster rifle, was a heavy blaster rifle manufactured by BlasTech Industries, as part of the DC-15 family. It was one of the standard-issue weapons of the Galactic Republic's clone troopers, an army of cloned soldiers in the Grand Army of the Republic, during the Clone Wars against the Confederacy of Independent Systems."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15a_training.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.NoHideLeftHandInCustomization = true
SWEP.ViewModel = "models/servius/weapons/viewmodels/c_dc15a.mdl"
SWEP.WorldModel = "models/servius/weapons/worldmodels/w_dc-15a.mdl"
SWEP.ViewModelFOV = 56

SWEP.DefaultBodygroups = "010"
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 1
SWEP.RangeMin = 243
SWEP.DamageMin = 1
SWEP.Range = 510
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_orange"
SWEP.TracerCol = Color(250, 146, 0)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 55

SWEP.Recoil = 0.43
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.63
SWEP.Delay = 60 / 324
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
		Mode = -2
	},
    {
        Mode = 0
    },            
}

SWEP.AccuracyMOA = 0.50
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 50

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc15.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_orange"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(255, 157, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.66, -12.75, 2.529),
    Ang = Angle(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 2, 3)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(15, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true 
SWEP.BipodDispersion = 1
SWEP.BipodRecoil = 1 

-- Attachments
SWEP.DefaultElements = {"dc15"}
SWEP.AttachmentElements = {
    ["dc15"] = {
        WMElements = {
            {
                Model = "models/servius/weapons/worldmodels/w_dc-15a.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                WBodygroups = {{ind = 0, bg = 0}},
                Offset = {
                    pos = Vector(-550, 0, 470),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(4150, 0, -1100),
                    ang = Angle(-15, 0, 100)
                },
                IsMuzzleDevice = true
            },
        },
    },
}
WMOverride = "models/servius/weapons/worldmodels/w_dc-15a.mdl"

SWEP.Attachments = {
    {
        PrintName = "Sight",
        DefaultAttName = "Standard", 
        Slot = "optic", 
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(0.110, -3.771, 2.1),
            vang = Angle(0, -90, 0),
            wpos = Vector(420, 50, -450),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },          
    {
        PrintName = "Magazine Capacity",
        DefaultAttName = "Standard",
        Slot = {"dc15a_magazine_75"},
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(0, -3.7, 0.5),
            vang = Angle(0, 0, 90),
            wpos = Vector(550, 115, -250),
            wang = Angle(-15, -90, -90)
        },
    },      
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },   
    {
        PrintName = "Ammo", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(1.3, -6.739, 0.504),
            vang = Angle(0, -90, 0),
            wpos = Vector(115, 180, -125),
            wang = Angle(-10 , 0, 180)
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(1.1, -9, 0.7),
            vang = Angle(0, -90, 0),
            wpos = Vector(-100, 180, -75),
            wang = Angle(-15 , 0, 180)
        },
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Neutral"
    },
    ["fire"] = {
        Time = 2.3,
        Source = {"shoot", "shoot2"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_lgequip.wav",
                p = 100, 
                v = 75,
                t = 0, 
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_medequip.wav",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "dc15a_reload1", t = 2 / 10},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_03.mp3", t = 2 },
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 2 / 30},
        },
    },


sound.Add({
    name =          "dc15a_reload1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "armas/misc/dc17s_reload.wav"
    }),
}
--addons/weapon_jedi/lua/weapons/schockstab.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS("weapon_lscs")

SWEP.Category = "[LSCS]"
SWEP.PrintName = "Schockstab"
SWEP.Author = "Rino & Deltaa"

SWEP.Slot = 0
SWEP.SlotPos = 3

SWEP.Spawnable = false
SWEP.AdminOnly = false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("staffel")
		self:SetBladeR("electrostaff")
		self:SetStance("electrostaff")
	end
end

if CLIENT then
    function SWEP:DrawBlade( HandID, BladeID, PosData, bladeObject, Mul, HiltAngles )
        local length = bladeObject.length * (PosData.length_multiplier or 1)
    
        local width = bladeObject.width * (PosData.width_multiplier or 1)
        local actual_width = width + math.Rand(0,bladeObject.widthWiggle)
    
        local pos = PosData.pos
        local dir = PosData.dir
    
        local w12 = width * 6
        local w32 = width * 16
    
        local color_blur = bladeObject.color_blur
        local color_core = bladeObject.color_core
    
        local Frac = self:DoBladeTrace( HandID, BladeID, pos, dir, length * Mul, width ).Fraction
    
        local MulxFrac = Mul * Frac
    
        if bladeObject.mdl then
            self:DrawBladeModel( HandID, BladeID, PosData, bladeObject, MulxFrac, HiltAngles )
    
            return
        end
    
        render.SetMaterial( bladeObject.material_glow )
        render.DrawSprite( pos, width, w32, color_blur )
    
        -- inefficient pls replace
        for i = 0, math.Round( (length - 1) * MulxFrac, 0 ) do
            render.DrawSprite( pos + dir * i, w12, w12, color_blur ) 
        end
    
        local EndPos = pos + dir * math.max(length - 0.9,0) * MulxFrac
    
        render.SetMaterial( bladeObject.material_core )
        render.DrawBeam( pos, EndPos, actual_width , 1, 1, color_core )
    
        render.SetMaterial( bladeObject.material_core_tip )
        render.DrawBeam( EndPos, EndPos + dir, actual_width , 0.9, 0.1, color_core )
    end
end
--addons/weapons_other/lua/weapons/sk_massif_swep.lua:
AddCSLuaFile()

SWEP.PrintName			= "Massif SWEP"
SWEP.Author				= "Spy-Klon[GER]" 
SWEP.Instructions		= "Linksklick zum beißen, Rechtsklick zum knurren, Nachalden zum bellen"--Left click to bite, Right click to bark, Reload to Growl."
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Category	= "Other"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo		= "none"
SWEP.Primary.Distance		= 100
SWEP.Primary.Delay			= 3

 
SWEP.HoldType			= "normal"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo		= "none"
SWEP.Secondary.Delay	= 2

SWEP.Weight			= 5
SWEP.AutoSwitchTo		= false
SWEP.AutoSwitchFrom		= false
SWEP.Slot			= 1
SWEP.SlotPos			= 2
SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= true
SWEP.ViewModel			= "models/weapons/c_arms.mdl"
SWEP.WorldModel	= ""


local bellen = "weapons/massif/bellenneu.mp3"
local bite = "weapons/massif/bite.wav"
local knurren = "weapons/massif/knurrenneu.mp3"
--[[-------------------------------------------------------------------------
local bellen = "weapons/massif/bellenneu.mp3"
local bite = "weapons/massif/bite.wav"
local knurren = "weapons/massif/knurrenneu.mp3"
---------------------------------------------------------------------------]]--

function SWEP:Initialize()
	self:SetWeaponHoldType( self.HoldType )
	self:SetNextPrimaryFire( CurTime() + 3 )
	self:SetNextSecondaryFire( CurTime() + 3)
end

function SWEP:PrimaryAttack()
	local schaden = GetConVar( "sk_massif_bite_damage" ):GetInt()
	if ( self:GetNWFloat("ACooldown",CurTime()) > CurTime() and GetConVar( "sk_massif_bite_self_damage" ):GetInt() == 1) then
		self.Owner:TakeDamage(math.random( (schaden/100)*15, (schaden/100)*15))
		self:EmitSound("npc/headcrab/headbite.wav")
		self.Owner:Freeze(true)
		self.Owner:Freeze(false)
		return end -- eigenschaden
	local tr = self.Owner:GetEyeTrace().Entity
		if not tr:IsValid() then return end
		if tr:GetPos():Distance( self.Owner:GetPos() ) > GetConVar( "sk_massif_bite_range" ):GetInt() then return end
			if SERVER then
				self.Owner:EmitSound( bite )
				if tr:IsNPC() then
					if (SERVER) then
						tr:TakeDamage(math.random((schaden*2)-GetConVar( "sk_massif_bite_random_damage" ):GetInt(),(schaden*2)+GetConVar( "sk_massif_bite_random_damage" ):GetInt())) end
				else
					if (SERVER) then
						tr:TakeDamage(math.random(schaden-GetConVar( "sk_massif_bite_random_damage" ):GetInt(),schaden+GetConVar( "sk_massif_bite_random_damage" ):GetInt())) end
				end
			end
			self:StopSound( bite )
			self:EmitSound( bite )
			self:SetNWFloat("ACooldown", CurTime() + self.Primary.Delay)
			if tr:IsPlayer() then
				tr:Freeze(true)
				tr:Freeze(false)
			end
end

function SWEP:Reload()
	if ( self:GetNWFloat("ACooldown",CurTime()) > CurTime() ) then return end
	self:StopSound( knurren )
	self:EmitSound( knurren )
	self:SetNWFloat("ACooldown", CurTime() + self.Primary.Delay)
end

function SWEP:SecondaryAttack()
	if ( self:GetNWFloat("ACooldown",CurTime()) > CurTime() ) then return end
	self:StopSound( bellen )
	self:EmitSound( bellen )
	self:SetNWFloat("ACooldown", CurTime() + self.Primary.Delay)

end

--addons/weapons_other/lua/weapons/weapon_leash_base.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- weapon_cuff_base.lua     SHARED --
--                                 --
-- Base swep for handcuffs.        --
-------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_cuff_base"

SWEP.Category = "Handcuffs"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = ""

SWEP.Slot = 3
SWEP.PrintName = "UnnamedLeash"

SWEP.IsLeash = true

local Col = {
	Text = Color(255,255,255), TextShadow = Color(0,0,0),
	
	BoxOutline = Color(0,0,0), BoxBackground = Color(255,255,255,20), BoxLeft = Color(255,0,0), BoxRight = Color(0,255,0),
}
local matGrad = Material( "gui/gradient" )
function SWEP:DrawHUD()
	if not self:GetIsCuffing() then
		if self:GetCuffTime()<=CurTime() then return end
		
		local w,h = (ScrW()/2), (ScrH()/2)
		
		surface.SetDrawColor( Col.BoxOutline )
		surface.DrawOutlinedRect( w-101, h+54, 202, 22 )
		surface.SetDrawColor( Col.BoxBackground )
		surface.DrawRect( w-100, h+55, 200, 20 )
		
		local CuffingPercent = math.Clamp( ((self:GetCuffTime()-CurTime())/self.CuffRecharge), 0, 1 )
		render.SetScissorRect( w-100, h+55, (w-100)+(CuffingPercent*200), h+75, true )
			surface.SetDrawColor( Col.BoxRight )
			surface.DrawRect( w-100,h+55, 200,20 )
			
			surface.SetMaterial( matGrad )
			surface.SetDrawColor( Col.BoxLeft )
			surface.DrawTexturedRect( w-100,h+55, 200,20 )
		render.SetScissorRect( 0,0,0,0, false )
		
		return
	end
	
	local w,h = (ScrW()/2), (ScrH()/2)
	
	draw.SimpleText( "Leashing target...", "HandcuffsText", w+1, h+31, Col.TextShadow, TEXT_ALIGN_CENTER )
	draw.SimpleText( "Leashing target...", "HandcuffsText", w, h+30, Col.Text, TEXT_ALIGN_CENTER )
	
	surface.SetDrawColor( Col.BoxOutline )
	surface.DrawOutlinedRect( w-101, h+54, 202, 22 )
	surface.SetDrawColor( Col.BoxBackground )
	surface.DrawRect( w-100, h+55, 200, 20 )
	
	local CuffingPercent = math.Clamp( 1-((self:GetCuffTime()-CurTime())/self.CuffTime), 0, 1 )
	
	render.SetScissorRect( w-100, h+55, (w-100)+(CuffingPercent*200), h+75, true )
		surface.SetDrawColor( Col.BoxRight )
		surface.DrawRect( w-100,h+55, 200,20 )
		
		surface.SetMaterial( matGrad )
		surface.SetDrawColor( Col.BoxLeft )
		surface.DrawTexturedRect( w-100,h+55, 200,20 )
	render.SetScissorRect( 0,0,0,0, false )
end

--addons/lvs_base/lua/includes/circles/circles.lua:
if SERVER then return false end

local _R = debug.getregistry()
if _R.Circles then return _R.Circles end

local CIRCLE = {}
CIRCLE.__index = CIRCLE

CIRCLE_FILLED = 0
CIRCLE_OUTLINED = 1
CIRCLE_BLURRED = 2

local New do
	local err_number = "bad argument #%i to 'New' (number expected, got %s)"

	function New(t, r, x, y, ...)
		assert(isnumber(t), string.format(err_number, 1, type(t)))
		assert(isnumber(r), string.format(err_number, 2, type(r)))
		assert(isnumber(x), string.format(err_number, 3, type(x)))
		assert(isnumber(y), string.format(err_number, 4, type(y)))

		local circle = setmetatable({}, CIRCLE)

		circle:SetType(t)
		circle:SetRadius(r)
		circle:SetX(x)
		circle:SetY(y)

		circle:SetVertices({Count = 0})

		if t == CIRCLE_OUTLINED then
			local outline_width = ...
			assert(outline_width == nil or isnumber(outline_width), string.format(err_number, 5, type(outline_width)))

			circle:SetOutlineWidth(outline_width)
		elseif t == CIRCLE_BLURRED then
			local blur_layers, blur_density = ...
			assert(blur_layers == nil or isnumber(blur_layers), string.format(err_number, 5, type(blur_layers)))
			assert(blur_density == nil or isnumber(blur_density), string.format(err_number, 6, type(blur_density)))

			circle:SetBlurLayers(blur_layers)
			circle:SetBlurDensity(blur_density)
		end

		return circle
	end
end

local RotateVertices do
	local err_table = "bad argument #1 to 'RotateVertices' (table expected, got %s)"
	local err_number = "bad argument #%i to 'RotateVertices' (number expected, got %s)"

	function RotateVertices(vertices, ox, oy, rotation, rotate_uv)
		assert(istable(vertices), string.format(err_table, type(vertices)))
		assert(isnumber(ox), string.format(err_number, 2, type(ox)))
		assert(isnumber(oy), string.format(err_number, 3, type(oy)))
		assert(isnumber(rotation), string.format(err_number, 4, type(rotation)))

		local rotation = math.rad(rotation)
		local c = math.cos(rotation)
		local s = math.sin(rotation)

		for i = 1, vertices.Count or #vertices do
			local vertex = vertices[i]
			local vx, vy = vertex.x, vertex.y

			vx = vx - ox
			vy = vy - oy

			vertex.x = ox + (vx * c - vy * s)
			vertex.y = oy + (vx * s + vy * c)

			if rotate_uv == false then
				local u, v = vertex.u, vertex.v
				u, v = u - 0.5, v - 0.5

				vertex.u = 0.5 + (u * c - v * s)
				vertex.v = 0.5 + (u * s + v * c)
			end
		end
	end
end

local CalculateVertices do
	local err_number = "bad argument #%i to 'CalculateVertices' (number expected, got %s)"

	function CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv)
		assert(isnumber(x), string.format(err_number, 1, type(x)))
		assert(isnumber(y), string.format(err_number, 2, type(y)))
		assert(isnumber(radius), string.format(err_number, 3, type(radius)))
		assert(isnumber(rotation), string.format(err_number, 4, type(rotation)))
		assert(isnumber(start_angle), string.format(err_number, 5, type(start_angle)))
		assert(isnumber(end_angle), string.format(err_number, 6, type(end_angle)))
		assert(isnumber(distance), string.format(err_number, 7, type(distance)))

		local vertices = {Count = 0}
		local step = distance / radius

		local rad_start_angle = math.rad(start_angle)
		local rad_end_angle = math.rad(end_angle)
		local rad_rotation = math.rad(rotation)

		for a = rad_start_angle, rad_end_angle + step, step do
			a = math.min(a, rad_end_angle)

			local c = math.cos(a + rad_rotation)
			local s = math.sin(a + rad_rotation)

			local vertex = {
				x = x + c * radius,
				y = y + s * radius,
			}

			if rotate_uv == false then
				vertex.u = 0.5 + math.cos(a) / 2
				vertex.v = 0.5 + math.sin(a) / 2
			else
				vertex.u = 0.5 + c / 2
				vertex.v = 0.5 + s / 2
			end

			vertices.Count = vertices.Count + 1
			vertices[vertices.Count] = vertex
		end

		if end_angle - start_angle ~= 360 then
			table.insert(vertices, 1, {
				x = x, y = y,
				u = 0.5, v = 0.5,
			})

			vertices.Count = vertices.Count + 1
		else
			table.remove(vertices)
			vertices.Count = vertices.Count - 1
		end

		return vertices
	end
end

function CIRCLE:__tostring()
	return string.format("Circle: %p", self)
end

function CIRCLE:Copy()
	return table.Copy(self)
end

function CIRCLE:IsValid()
	return (
		not self.m_Dirty and
		self.m_Vertices.Count >= 3 and
		self.m_Radius >= 1 and
		self.m_Distance >= 1
	)
end

function CIRCLE:Calculate()
	local rotate_uv = self.m_RotateMaterial

	local radius = self.m_Radius
	local x, y = self.m_X, self.m_Y

	local rotation = self.m_Rotation
	local start_angle = self.m_StartAngle
	local end_angle = self.m_EndAngle

	local distance = self.m_Distance

	assert(radius >= 1, string.format("circle radius should be >= 1 (%.4f)", radius))
	assert(distance >= 1, string.format("circle distance should be >= 1 (%.4f)", distance))

	self:SetVertices(CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv))

	if self.m_Type == CIRCLE_OUTLINED then
		local inner = self.m_ChildCircle or self:Copy()
		local inner_r = radius - self.m_OutlineWidth

		inner:SetType(CIRCLE_FILLED)

		inner:SetPos(x, y)
		inner:SetRadius(inner_r)
		inner:SetRotation(rotation)
		inner:SetAngles(start_angle, end_angle)
		inner:SetDistance(distance)

		inner:SetColor(false)
		inner:SetMaterial(false)

		inner:SetShouldRender(inner_r >= 1)
		inner:SetDirty(inner.m_ShouldRender)

		self:SetShouldRender(inner_r < radius)
		self:SetChildCircle(inner)
	elseif self.m_ChildCircle then
		self.m_ChildCircle = nil
	end

	self:SetDirty(false)

	return self
end

do
	local blur = Material("pp/blurscreen")

	function CIRCLE:__call()
		if self.m_Dirty then self:Calculate() end

		if not self:IsValid() then return false end
		if not self.m_ShouldRender then return false end

		do
			local col, mat = self.m_Color, self.m_Material

			if IsColor(col) then
				if col.a <= 0 then return end
				surface.SetDrawColor(col.r, col.g, col.b, col.a)
			end

			if mat == true then
				draw.NoTexture()
			elseif TypeID(mat) == TYPE_MATERIAL then
				surface.SetMaterial(mat)
			end
		end

		if self.m_Type == CIRCLE_OUTLINED then
			render.ClearStencil()

			render.SetStencilEnable(true)
				render.SetStencilTestMask(0xFF)
				render.SetStencilWriteMask(0xFF)
				render.SetStencilReferenceValue(0x01)

				render.SetStencilCompareFunction(STENCIL_NEVER)
				render.SetStencilFailOperation(STENCIL_REPLACE)
				render.SetStencilZFailOperation(STENCIL_REPLACE)

				self.m_ChildCircle()

				render.SetStencilCompareFunction(STENCIL_GREATER)
				render.SetStencilFailOperation(STENCIL_KEEP)
				render.SetStencilZFailOperation(STENCIL_KEEP)

				surface.DrawPoly(self.m_Vertices)
			render.SetStencilEnable(false)
		elseif self.m_Type == CIRCLE_BLURRED then
			render.ClearStencil()

			render.SetStencilEnable(true)
				render.SetStencilTestMask(0xFF)
				render.SetStencilWriteMask(0xFF)
				render.SetStencilReferenceValue(0x01)

				render.SetStencilCompareFunction(STENCIL_NEVER)
				render.SetStencilFailOperation(STENCIL_REPLACE)
				render.SetStencilZFailOperation(STENCIL_REPLACE)

				surface.DrawPoly(self.m_Vertices)

				render.SetStencilCompareFunction(STENCIL_LESSEQUAL)
				render.SetStencilFailOperation(STENCIL_KEEP)
				render.SetStencilZFailOperation(STENCIL_KEEP)

				surface.SetMaterial(blur)

				local sw, sh = ScrW(), ScrH()

				for i = 1, self.m_BlurLayers do
					blur:SetFloat("$blur", (i / self.m_BlurLayers) * self.m_BlurDensity)
					blur:Recompute()

					render.UpdateScreenEffectTexture()
					surface.DrawTexturedRect(0, 0, sw, sh)
				end
			render.SetStencilEnable(false)
		else
			surface.DrawPoly(self.m_Vertices)
		end

		return true
	end

	CIRCLE.Draw = CIRCLE.__call
end

do
	local err_number = "bad argument #%i to 'Translate' (number expected, got %s)"

	function CIRCLE:Translate(x, y)
		assert(isnumber(x), string.format(err_number, 1, type(x)))
		assert(isnumber(y), string.format(err_number, 2, type(y)))

		if x ~= 0 or y ~= 0 then
			self.m_X = self.m_X + x
			self.m_Y = self.m_Y + y

			if self:IsValid() then
				for i = 1, self.m_Vertices.Count do
					local vertex = self.m_Vertices[i]

					vertex.x = vertex.x + x
					vertex.y = vertex.y + y
				end

				if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
					self.m_ChildCircle:Translate(x, y)
				end
			end
		end

		return self
	end
end

do
	local err_number = "bad argument #1 to 'Scale' (number expected, got %s)"

	function CIRCLE:Scale(scale)
		assert(isnumber(scale), string.format(err_number, type(scale)))

		if scale ~= 1 then
			self.m_Radius = self.m_Radius * scale

			if self:IsValid() then
				local x, y = self.m_X, self.m_Y

				for i = 1, self.m_Vertices.Count do
					local vertex = self.m_Vertices[i]

					vertex.x = x + (vertex.x - x) * scale
					vertex.y = y + (vertex.y - y) * scale
				end

				if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
					self.m_ChildCircle:Scale(scale)
				end
			end
		end

		return self
	end
end

do
	local err_number = "bad argument #1 to 'Rotate' (number expected, got %s)"

	function CIRCLE:Rotate(rotation)
		assert(isnumber(rotation), string.format(err_number, type(rotation)))

		if rotation ~= 0 then
			self.m_Rotation = self.m_Rotation + rotation

			if self:IsValid() then
				local x, y = self.m_X, self.m_Y
				local vertices = self.m_Vertices
				local rotate_uv = self.m_RotateMaterial

				RotateVertices(vertices, x, y, rotation, rotate_uv)

				if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
					self.m_ChildCircle:Rotate(rotation)
				end
			end
		end

		return self
	end
end

do
	local function AccessorFunc(name, default, dirty, callback)
		local varname = "m_" .. name

		CIRCLE["Get" .. name] = function(self)
			return self[varname]
		end

		CIRCLE["Set" .. name] = function(self, value)
			if default ~= nil and value == nil then
				value = default
			end

			if self[varname] ~= value then
				if dirty then
					self[dirty] = true
				end

				if callback ~= nil then
					local new = callback(self, self[varname], value)
					value = new ~= nil and new or value
				end

				self[varname] = value
			end

			return self
		end

		CIRCLE[varname] = default
	end

	local function OffsetVerticesX(circle, old, new)
		circle:Translate(new - old, 0)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			circle.m_ChildCircle:Translate(new - old, 0)
		end
	end

	local function OffsetVerticesY(circle, old, new)
		circle:Translate(0, new - old)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			circle.m_ChildCircle:Translate(0, new - old)
		end
	end

	local function UpdateRotation(circle, old, new)
		circle:Rotate(new - old)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			circle.m_ChildCircle:Rotate(new - old)
		end
	end

	-- These are set internally. Only use them if you know what you're doing.
	AccessorFunc("Dirty", true)
	AccessorFunc("Vertices", false)
	AccessorFunc("ChildCircle", false)
	AccessorFunc("ShouldRender", true)

	AccessorFunc("Color", false)						-- The colour you want the circle to be. If set to false then surface.SetDrawColor's can be used.
	AccessorFunc("Material", false)						-- The material you want the circle to render. If set to false then surface.SetMaterial can be used.
	AccessorFunc("RotateMaterial", true)				-- Sets whether or not the circle's UV points should be rotated with the vertices.

	AccessorFunc("Type", CIRCLE_FILLED, "m_Dirty")		-- The circle's type.
	AccessorFunc("X", 0, false, OffsetVerticesX)		-- The circle's X position relative to the top left of the screen.
	AccessorFunc("Y", 0, false, OffsetVerticesY)		-- The circle's Y position relative to the top left of the screen.
	AccessorFunc("Radius", 8, "m_Dirty")				-- The circle's radius.
	AccessorFunc("Rotation", 0, false, UpdateRotation)	-- The circle's rotation, measured in degrees.
	AccessorFunc("StartAngle", 0, "m_Dirty")			-- The circle's start angle, measured in degrees.
	AccessorFunc("EndAngle", 360, "m_Dirty")			-- The circle's end angle, measured in degrees.
	AccessorFunc("Distance", 10, "m_Dirty")				-- The maximum distance between each of the circle's vertices. This should typically be used for large circles in 3D2D.

	AccessorFunc("BlurLayers", 3)						-- The circle's blur layers if Type is set to CIRCLE_BLURRED.
	AccessorFunc("BlurDensity", 2)						-- The circle's blur density if Type is set to CIRCLE_BLURRED.
	AccessorFunc("OutlineWidth", 10, "m_Dirty")			-- The circle's outline width if Type is set to CIRCLE_OUTLINED.

	function CIRCLE:SetPos(x, y)
		x = tonumber(x) or self.m_X
		y = tonumber(y) or self.m_Y

		if self:IsValid() then
			self:Translate(x - self.m_X, y - self.m_Y)
		else
			self.m_X = x
			self.m_Y = y
		end

		return self
	end

	function CIRCLE:SetAngles(s, e)
		s = tonumber(s) or self.m_StartAngle
		e = tonumber(e) or self.m_EndAngle

		self:SetDirty(self.m_Dirty or s ~= self.m_StartAngle or e ~= self.m_EndAngle)

		self.m_StartAngle = s
		self.m_EndAngle = e

		return self
	end

	function CIRCLE:GetPos()
		return self.m_X, self.m_Y
	end

	function CIRCLE:GetAngles()
		return self.m_StartAngle, self.m_EndAngle
	end
end

_R.Circles = {
	_MT = CIRCLE,

	New = New,
	RotateVertices = RotateVertices,
	CalculateVertices = CalculateVertices,
}

return _R.Circles

--gamemodes/starwarsrp/entities/entities/aoc_ausbildung_boden.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
 
ENT.PrintName = "Ausbildungstafel (Boden)"
ENT.Category = "AOCRP"
ENT.Spawnable = true

function ENT:SetupDataTables()
	self:NetworkVar("Float", 0, "Page")
	self:NetworkVar("Float", 1, "Max")
	
	--[[CONFIG]]--

	--[[change max pages here]]--
	--[[You would do this if you plan on adding more pages with information or removing unnesscary pages]]--
	self:SetPage(1)
	self:SetMax(4) 

	--[[true = Republic | false = Imperial]]--
	self.era = true 

	--[[Header Color and Background Color]]--
	self.hcolor = Color(25, 1, 2448, 0)
	self.bcolor = Color(0, 0, 0, 0)
	--[[Header Text Color and Text Color]]--
	self.htextcolor = Color(255, 255, 255)
	self.textcolor = Color(255, 255, 255)
	--[[Rounded Box and Text inside on bottom of panel]]--
	self.boxcolor = Color(191, 0, 0)
	self.boxtextcolor = Color(255, 255, 255)
	--[[Page changing hint text color and page number color]]--
	self.hinttext = Color(255, 255, 255)
	self.pagenum = Color(255, 255, 255)
	--[[Changes the shade of the arrows when hovered over]]--
	self.pcolor = Color(255, 220, 50, 220)
end


if SERVER then
    
    function math.inrange(val, min, max)
        return val <= max and val >= min
    end

    function ENT:Initialize()
        self:SetModel("models/hunter/plates/plate3x5.mdl")
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        self:SetUseType(SIMPLE_USE)

        self:SetMaterial("Models/effects/vol_light001")
        self:SetColor(Color(255, 255, 255, 0))
    
        local phys = self:GetPhysicsObject()
        
        if IsValid(phys) then
            phys:EnableMotion(false)
        end
    end

    local size = -950 / 2

    function ENT:Use(caller)
        local trace = caller:GetEyeTrace()
        if not trace.Entity == self then return end

        local cursor = self:WorldToLocal(trace.HitPos) * Vector(10, 10, 10)

        if math.inrange(cursor.y, -size - 64 - 64, -size) and math.inrange(cursor.x, -size - 64 - 64, -size) then 
            if self:GetPage() >= self:GetMax() then return end

            self:SetPage(self:GetPage() + 1)
            self:EmitSound("buttons/blip1.wav")
        end

        if math.inrange(cursor.y, size , size + 64 + 64) and math.inrange(cursor.x, -size - 64 - 64, -size) then 
            if self:GetPage() <= 1 then return end

            self:SetPage(self:GetPage() - 1)
            self:EmitSound("buttons/blip1.wav")
        end
    end

end

if CLIENT then
        
    local size = -950 / 2

    function math.inrange(val, min, max)
        return val <= max and val >= min
    end

    local arrow_icon = Material("materials/shared/arrow.png")
    local replogo_icon = Material("materials/shared/replogo.png")
    local aoc_icon = Material("shared/aoclogo.png")
    local boden1 = Material("shared/boden1.png")
    local boden2 = Material("shared/boden2.png")
    local boden3 = Material("shared/boden3.png")
    local boden4 = Material("shared/boden4.png")

    surface.CreateFont("FORMATION:Main", {
        font = "Roboto",
        size = 50
    })

    surface.CreateFont("FORMATION:Title", {
        font = "Roboto",
        size = 80
    })

    function ENT:Initialize()
        self.x = 0
        self.lx = 0
        self.t = 0

        self.min = 0
        self.max = 0

        self.tpage = self:GetPage()

        self:Work()
    end

    function ENT:Work()
        self.t = !self.t

        if self.t then 
            self.x = self.min
        else
            self.x = self.max
        end

        timer.Simple(1, function()
            if not IsValid(self) then return end
            self:Work()
        end)
    end

    function ENT:OnPage()
        if self.tpage == 3 then 
            self.x = -25
            self.lx = -25
            return
        end
        
        self.x = 0
        self.lx = 0
    end

    function ENT:Think()
        if self:GetPage() != self.tpage then 
            self.tpage = self:GetPage()

            self:OnPage()
        end
    end

    function ENT:Page(number)
    if number == 1 then 
            
            if self.era == true then
            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(boden1)
            surface.DrawTexturedRectRotated(size + 550, -size - 580, 1900,1900, 0)
            elseif self.era == false then

            end
            
            end
            
        if number == 2 then 
            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(boden2)
            surface.DrawTexturedRectRotated(size + 550, -size - 580, 1900,1900, 0)
            elseif self.era == false then
        end
                
        if number == 3 then 
            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(boden3)
            surface.DrawTexturedRectRotated(size + 550, -size - 580, 1900,1900, 0)
            elseif self.era == false then
        end
        if number == 4 then 
            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(boden4)
            surface.DrawTexturedRectRotated(size + 550, -size - 580, 1900,1900, 0)
            elseif self.era == false then
        end
        end


    function ENT:Draw()
        self:DrawModel()

        local trace = LocalPlayer():GetEyeTrace()
        if not trace.Entity == self then return end

        local cursor = self:WorldToLocal(trace.HitPos) * Vector(10, 10, 10)

        local pos = self:LocalToWorld(Vector(0, 0, 2.5))
        local ang = self:LocalToWorldAngles(Angle(0, 90, 0))
        --[[Change the distance at which clients will render the panel]]--
        if LocalPlayer():GetPos():Distance(self:GetPos()) >= 500 then return end 

        cam.Start3D2D(pos, ang, 0.1)
            draw.RoundedBox(0, -2370 / 2, -1420 / 2, 2370, 100, self.hcolor)
            draw.RoundedBox(0, -2370 / 2, -1240 / 2, 2370, 1330, self.bcolor)
            --[[---------------------------------------------------------
                Name: Arrows
            -----------------------------------------------------------]]
            if math.inrange(cursor.y, -size - 64 - 64, -size) and math.inrange(cursor.x, -size - 64 - 64, -size) then 
                surface.SetDrawColor(self.pcolor)
            else
                surface.SetDrawColor(Color(255, 255, 255))
            end
            
            surface.SetMaterial(arrow_icon)
            surface.DrawTexturedRectRotated(-size - 64, -size - 20, 64, 64, 180)

            if math.inrange(cursor.y, size , size + 64 + 64) and math.inrange(cursor.x, -size - 64 - 64, -size) then 
                surface.SetDrawColor(self.pcolor)
            else
                surface.SetDrawColor(Color(255, 255, 255))
            end
            
            surface.SetMaterial(arrow_icon)
            surface.DrawTexturedRectRotated(size + 64, -size - 20, 64, 64, 0)

            draw.SimpleText("Formation ".. self:GetPage().. " von ".. self:GetMax(), "FORMATION:Main", 0, -size - 20, self.pagenum, 1, 1)

            self:Page(self:GetPage())
            
            

        cam.End3D2D()
        

        
    end 
end
--gamemodes/starwarsrp/entities/entities/aoc_rocketmarker.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Raketenmakierung"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP"
ENT.Spawnable       = true
ENT.Editable = true


function ENT:SetupDataTables()
	self:NetworkVar( "String", 0, "BatteryName", { KeyName = "batteryname",	Edit = { type = "Generic",	order = 1} })
    if SERVER then
        self:SetBatteryName("Unbekannt")
    end
end


if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/maxofs2d/cube_tool.mdl" )
        self:DrawShadow( false )

        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_NONE)
        self:SetSolid(SOLID_VPHYSICS)
        self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
    end

end


if CLIENT then
    function ENT:Draw()
        if LocalPlayer():GetMoveType() == MOVETYPE_NOCLIP then
            self:DrawModel() 
        end
    end

end
--addons/aoc_nextbots/lua/entities/aocrp_nextbot_droideka.lua:
AddCSLuaFile()

ENT.Base = "summe_nextbot"
ENT.PrintName = "Droideka"
ENT.Category = "AOCRP | Nextbots"
ENT.Spawnable = false
ENT.AdminOnly = false
ENT.AutomaticFrameAdvance = true

ENT.Model = "models/npc/starwars/droidekas/droideka.mdl"
ENT.Weapon = "weapon_npc_droideka"
ENT.HP = 1000
ENT.ShootingRange = 1500
ENT.LooseRadius = 4000
ENT.Proficiency = 0

ENT.Speed = 450

ENT.ThrowGrenades = false
ENT.Grenades = {}

ENT.Sounds = false

ENT.Anims = {
    ["idle"] = {0},
    ["shoot"] = {"range_attack1"},
    ["reload"] = {0},
    ["walk_slow"] = {"walk"},
    ["walk_fast"] = {"walk"}
}

function ENT:SetupDataTables()
    self:NetworkVar("Bool", 0, "ShieldStatus", { KeyName = "ShieldStatus", Edit = { type = "Boolean", order = 1, category = "Settings"}})
end

function ENT:SwitchShield(value)
    if value then
        self:SetShieldStatus(true)
        self:StopSound("summe/nextbots/droids/droideka/droids_droideka_roll_main_loop_01.mp3")
    else
        self:SetShieldStatus(false)
    end
end

function ENT:SetWeapon(weaponClass)
    local currentWeapon = self:GetWeapon()

    if currentWeapon then
        currentWeapon:Remove()
    end

    local newWep = ents.Create(weaponClass)
    newWep:Spawn()
    newWep:Activate()
    newWep:SetPos(self:GetPos() + Vector(0, 0, 20))
    newWep:SetSolid(SOLID_NONE)
    newWep:SetParent(self)
    newWep:AddEffects(EF_BONEMERGE)
    newWep:SetOwner(self)

    self.NormalWeaponClip = newWep:Clip1()

    self.weapon = newWep

    function newWep:CanPrimaryFire()
        return true
    end
end

function ENT:DoNormal()
    if self.Path:GetAge() < 2 then return end

    if self.Duty == "Normal" then
        self:RunTo(self:GetPos() + Vector(math.Rand(-1, 1), math.Rand(-1, 1), 0) * 700, self.Speed * .75)
    elseif self.Duty == "Attack" then
        self:DoAttack()
    elseif self.Duty == "Patrol" then
        self:DoPatrol() 
    else
        if self:GetShieldStatus() then return end
        self:SwitchShield(true)
    end
end

function ENT:DoAttack()
    if not self.AttackPos then return end
    if self.AttackPointReached then return end

    self:RunTo(self.AttackPos, self.Speed * 2)

    if self:GetPos():DistToSqr(self.AttackPos) < 25000 then
        self.AttackPointReached = true

        if self.Path:IsValid() then
            self:PathFollowerStop()
        end

        self:PlayAnimation("idle")

        if self:GetShieldStatus() then return end
        self:SwitchShield(true)
    end
end

function ENT:ShootEnemy()
    local weapon = self:GetWeapon()
    local enemy = self:GetEnemy()

    if not IsValid(weapon) then return end
    if AOCRPNextbots:CannotTarget(enemy) then self:SetEnemy(false) return end

    weapon.LastEnemy = enemy

    if weapon:Clip1() > 0 then
        if self.IsReloading then return end
        self:PlayAnimation("shoot")
        weapon:PrimaryAttack()
        self:SwitchShield(true)
    else
        if self.IsReloading then return end
        self.IsReloading = true
        timer.Simple(3, function()
            if not IsValid(weapon) then return end
            weapon:SetClip1(self.NormalWeaponClip)
            self.IsReloading = false
        end)
    end
end

function ENT:RunTo(pos, speed)
    if self.Path:GetAge() < 1 then return end

    self:StopSound("summe/nextbots/droids/droideka/droids_droideka_roll_main_loop_01.mp3")
    self:EmitSound("summe/nextbots/droids/droideka/droids_droideka_roll_main_loop_01.mp3", 120, 100, 0.5, CHAN_AUTO)

    self:SwitchShield(false)
    if speed and speed < 300 then
        self:PlayAnimation("walk_slow", true)
    else
        self:PlayAnimation("walk_fast", true)
    end

    self.loco:SetDesiredSpeed(speed or 200)
    self:PathFollowerCompute(pos)
end

function ENT:OnTakeDamage(dmgInfo)
    if self:GetShieldStatus() then
        dmgInfo:ScaleDamage(0.25)
    else
        dmgInfo:ScaleDamage(1)
    end

    local attacker = dmgInfo:GetAttacker()
    if IsValid(attacker) and attacker:IsPlayer() then
        if self.DefenseMode then
            -- Disables the defense mode
            self.DefenseMode = false

            self:SetEnemy(attacker)

            -- Disables the defense mode of all nextbots in the area
            local ents = ents.FindInSphere(self:GetPos(), 50000)
            for _, v in pairs(ents) do
                if v:IsNextBot() and v.DefenseMode then
                    v.DefenseMode = false
                    v:SetEnemy(attacker)
                end
            end
        else
            local enemy = self:GetEnemy()
            if IsValid(enemy) then
                if attacker ~= enemy then
                    self:SetEnemy(attacker)
                end
            end
        end
    end
end

function ENT:OnRemove()
    self:StopSound("summe/nextbots/droids/droideka/droids_droideka_roll_main_loop_01.mp3")

    if SERVER then
        AOCRPNextbots.Cache[self] = nil
    end
end

if CLIENT then
    local shieldMat = Material("Models/effects/splodearc_sheet")

    function ENT:Draw()
        self:DrawModel()

        if not self:GetShieldStatus() then return end
        render.SetColorMaterial()

        local pos = self:GetPos() + Vector(0, 0, 30)
        render.DrawSphere(pos, 50, 30, 30, Color(0, 175, 175, self:Health() * .1))
        render.SetMaterial(shieldMat)
        render.DrawSphere(pos, 49, 30, 30, Color(83, 255, 255, self:Health() * .1))
    end
end
--addons/arccw_base_modified/lua/entities/arccw_ammo_357.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"
ENT.RenderGroup               = RENDERGROUP_TRANSLUCENT

ENT.PrintName                 = "Magnum Ammo"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/magnum_ammo.mdl"

ENT.AmmoType = "357"
ENT.AmmoCount = 12
if engine.ActiveGamemode() == "terrortown" then
    ENT.AmmoType = "AlyxGun"
    ENT.AmmoCount = 18
end


ENT.DetonationDamage = 50
ENT.DetonationRadius = 128
ENT.DetonationSound = "weapons/357_fire2.wav"
--addons/arccw_base_modified/lua/entities/arccw_ammo_smg1_grenade_large.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"

ENT.PrintName                 = "Rifle Grenade Box"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/riflegrenade_ammo.mdl"
ENT.Health = 70

ENT.AmmoType = "smg1_grenade"
ENT.AmmoCount = 5

ENT.DetonationDamage = 100 -- Per-round damage
ENT.DetonationRadius = 300

function ENT:DetonateRound(attacker)
    local nade = ents.Create("arccw_gl_ammodet")
    nade:SetPos(self:GetPos())
    local v = self:GetUp():Angle() + AngleRand(-60, 60)
    nade:SetAngles(v)
    nade:Spawn()
    nade:GetPhysicsObject():AddVelocity(self:GetVelocity() + self:GetForward() * math.random(2000, 3000))
    nade:SetOwner(attacker or self.Burner)

    self.AmmoCount = self.AmmoCount - 1

    self:GetPhysicsObject():AddVelocity(VectorRand() * math.random(5, 10) * self:GetPhysicsObject():GetMass())
    self:GetPhysicsObject():AddAngleVelocity(VectorRand() * math.random(60, 300))

    self:EmitSound("weapons/ar2/ar2_altfire.wav", 80, 150)
end

function ENT:Detonate(wet, attacker)
    if wet then
        for i = 1, math.random(1, 3) do
            self:DetonateRound(attacker)
        end
    end

    local e = EffectData()
    e:SetOrigin(self:GetPos())
    util.Effect("Explosion", e)

    util.BlastDamage(self, attacker, self:GetPos(), self.DetonationRadius, self.DetonationDamage * (wet and 1 or 2))
    self:Remove()
end
--addons/arccw_weapons/lua/entities/arccw_nade_launcher17m/shared.lua:
ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.PrintName = "Grenade Launcher Rocket"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/tfa_starwars/w_thermal.mdl"
ENT.FuseTime = 4
ENT.ArmTime = 1
ENT.ImpactFuse = true

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
		ParticleEffectAttach( "astw2_halo_reach_grenade_launcher_trail", PATTACH_POINT_FOLLOW, self, 1 )
		util.SpriteTrail( self, 0, Color(255,185,20,185), false, 16, 4, 0.22, 0.01, "effects/halo3/trail/basic_trail" )
		util.SpriteTrail( self, 0, Color(255,155,20,155), false, 12, 4, 0.25, 0.01, "effects/halo3/trail/flaming_trail" )
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
			phys:SetMass(1)
            phys:SetBuoyancyRatio(0)
            phys:EnableGravity( true )
        end

        self.kt = CurTime() + self.FuseTime
        self.motorsound = CreateSound( self, "weapons/masita_extras/cw/wpn_rep_unit_lockon_lp.wav")
		self.motorsound:Play()
    end
	if CLIENT then
	ParticleEffectAttach( "astw2_halo_reach_grenade_launcher_trail", PATTACH_POINT_FOLLOW, self, 1 )
	end
    self.at = CurTime() + self.ArmTime
    self.Armed = false
end

function ENT:OnRemove()
    if SERVER then
        self.motorsound:Stop()
    end
end


function ENT:PhysicsCollide(data, physobj)
if SERVER then
		if data.Speed > 25 then
            self:EmitSound(Sound("weapons/grenades/wpn_fraggrenade_1p_hardsurface_bounce_01_lr_v" .. math.random(1,2) .. ".wav"))
		end
		end
	if self.at <= CurTime() and self.ImpactFuse then
            self:Detonate()


        end
		local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        util.Effect( "StunstickImpact", effectdata)
end

function ENT:Arm()
    if SERVER then
        
    end
end

function ENT:Think()



    if CurTime() >= self.at and !self.Armed then
        self:Arm()
        self.Armed = true
    end

    if SERVER then

        if self.Armed then
            local phys = self:GetPhysicsObject()
        end
	
	if CurTime() >= self.at then
            local targets = ents.FindInSphere(self:GetPos(), 16)
            for _, k in pairs(targets) do
                if k:IsPlayer() or k:IsNPC() then
                    if self:Visible( k ) and k:Health() > 0 then
                        self:Detonate()
                    end
                elseif (k:IsValid() and scripted_ents.IsBasedOn( k:GetClass(), "base_nextbot" )) then
                    self:Detonate()
                end
            end
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    end

    if CLIENT then
        -- if self:IsValid() then
            -- local emitter = ParticleEmitter(self:GetPos())

            -- if !self:IsValid() or self:WaterLevel() > 2 then return end

	-- local smoke = emitter:Add("effects/halo3/muzzle_magnum", self:GetPos())
        -- smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
        -- smoke:SetVelocity( self:GetAngles():Forward() * 100 )
        -- smoke:SetDieTime( math.Rand(0.1,0.15) )
        -- smoke:SetStartAlpha( 255 )
        -- smoke:SetEndAlpha( 0 )
        -- smoke:SetStartSize( 3 )
        -- smoke:SetEndSize( 0 )
        -- smoke:SetRoll( math.Rand(-180, 180) )
        -- smoke:SetRollDelta( math.Rand(-0.2,0.2) )
        -- smoke:SetColor( 255, 125, 55 )
        -- smoke:SetAirResistance( 2 )
        -- smoke:SetPos( self:GetPos() )
        -- smoke:SetLighting( false )
		
        -- emitter:Finish()
        -- end
    end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_halo_3_frag_explosion", self:GetPos(), self:GetAngles() )
	-- sound.Play( "halo/halo_reach/weapons/grenade_launcher_expl" .. math.random(1,3) .. ".ogg",  self:GetPos(), 100, 100 )
	self:EmitSound("grenades/gren_expl" .. math.random(1,4) .. "_close.ogg", 120, 100, 1, CHAN_AUTO)
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end
	local targets = ents.FindInSphere(self:GetPos(), 300)
        for _, k in pairs(targets) do
            if k != self and k:GetPos().z < self:GetPos().z + 64 then
                local damage = DamageInfo()
                damage:SetAttacker( self:GetOwner() )
                damage:SetDamage( 5 )
                damage:SetDamageType( DMG_SHOCK )
                damage:SetInflictor( self )
                k:TakeDamageInfo( damage )
            end
        end
	util.Decal( "astw2_halo_reach_impact_soft_terrain_explosion", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
         util.BlastDamage(self, attacker, self:GetPos(), 300, 250)
	 util.ScreenShake(self:GetPos(),4500,100,0.6,1024)
	 
        self:Remove()
    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()

        if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/halo3/8pt_ringed_star_flare") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(25, 50), math.random(30, 55), Color(255, 200, 150) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
        end
    end
end
--addons/arccw_weapons/lua/entities/arccw_thr_impact.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.PrintName = "Fragnade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE

ENT.Model = "models/arccw/impact_grenade.mdl"
ENT.Armed = false
ENT.TrailColor = Color(255, 0, 0, 255)
ENT.TrailTexture = "sprites/bluelaser1" -- this is exactly the one hl2 frag uses. Why blue? idk blame gaben

ENT.BlastDamage = {
    [0] = 60,
    [1] = 140,
    [2] = 70,
}

function ENT:Initialize()
    if SERVER then
        self:SetModel(self.Model)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetSkin(self.Skin or 0)

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.SpawnTime = CurTime()
        self.Trail = util.SpriteTrail(self, 0, self.TrailColor, false, 4, 0, 0.5, 4, self.TrailTexture or "sprites/bluelaser1")
        if IsValid(self.Trail) then
            self.Trail:SetRenderMode(RENDERMODE_TRANSADD)
            self.Trail:SetRenderFX(kRenderFxNone)
        end
        self:SetPhysicsAttacker(self:GetOwner(), 10)
    end
    util.PrecacheSound("w/SW02_Weapons_Grenades_Shared_Beeps_10.wav")

    -- Play the sound when the entity is spawned
    self:EmitSound("w/SW02_Weapons_Grenades_Shared_Beeps_10.wav")
end

function ENT:PhysicsCollide(data, physobj)
    local tgt = data.HitEntity
    local dmginfo = DamageInfo()
    dmginfo:SetDamageType(DMG_GENERIC)
    dmginfo:SetDamage(10)
    dmginfo:SetAttacker(self:GetOwner())
    dmginfo:SetInflictor(self)
    dmginfo:SetDamageForce(data.OurOldVelocity * 0.5)
    tgt:TakeDamageInfo(dmginfo)
    if IsValid(self:GetOwner()) and  (tgt:IsNPC() or tgt:IsPlayer() or tgt:IsNextBot()) and self:GetOwner():IsPlayer() then
        net.Start("arccw_apex_hit")
            net.WriteBool(false)
        net.Send(self:GetOwner())
    end
    if (IsValid(tgt) and (tgt:IsNPC() or tgt:IsPlayer() or tgt:IsNextBot()) and tgt:Health() <= 0) or (not tgt:IsWorld() and not IsValid(tgt)) or string.find(tgt:GetClass(), "breakable") then
        local pos, ang, vel = self:GetPos(), self:GetAngles(), data.OurOldVelocity
        timer.Simple(0, function()
            if IsValid(self) then
                self:SetAngles(ang)
                self:SetPos(pos)
                self:GetPhysicsObject():SetVelocityInstantaneous(vel)
            end
        end)
    else
        self:Detonate(data.HitEntity)
    end
end

function ENT:Think()
    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
        self:Detonate()
    end
end

function ENT:Detonate()
    if SERVER then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect("WaterSurfaceExplosion", effectdata)
            self:EmitSound("weapons/underwater_explode3.wav", 120, 100, 1, CHAN_AUTO)
        else
            local explode = ents.Create( "info_particle_system" )
            explode:SetKeyValue( "effect_name", "grenade_final" )
            explode:SetOwner( self.Owner )
            explode:SetPos( self:GetPos() )
            explode:Spawn()
            explode:Activate()
            explode:Fire( "start", "", 0 )
            explode:Fire( "kill", "", 30 )
            --util.Effect("Explosion", effectdata)
            --util.Effect("hl2mmod_explosion_grenade", effectdata)
            self:EmitSound("weapons/grenades/explode" .. math.random(1,3) .. ".wav", 120, 100, 1, CHAN_AUTO)
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        local hit = false
        
        local pos = self:GetPos()

        -- for _, ent in pairs(ents.FindInSphere(pos, 350)) do

        --     local distSqr = ent:GetPos():DistToSqr(pos)
        --     local f = 1
        --     if distSqr > 9216 then -- 96 * 96
        --         f = Lerp((distSqr - 9216) / (122500 - 9216), 1, 0.25)
        --     end
        --     local dmginfo = DamageInfo()
        --     dmginfo:SetDamageType(DMG_BLAST)
        --     dmginfo:SetAttacker(attacker)
        --     dmginfo:SetDamage(85 * f)
        --     dmginfo:SetDamageForce((ent:WorldSpaceCenter() - pos):GetNormalized() * 9001 * f)
        --     dmginfo:SetInflictor(self)
        --     ent:TakeDamageInfo(dmginfo)
        -- end

        local dmginfo = DamageInfo()
        dmginfo:SetDamageType(DMG_BLAST)
        dmginfo:SetAttacker(attacker)
        dmginfo:SetDamage(250)
        dmginfo:SetInflictor(self)
        util.BlastDamageInfo(dmginfo, pos, 400)
        self:Remove()
        util.Decal("Scorch", pos, pos - Vector(0, 0, 16))
    end
end

function ENT:DrawTranslucent()
    self:Draw()
end

function ENT:Draw()
    self:DrawModel()
end
--addons/arccw_weapons/lua/entities/arccw_thr_ion.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.PrintName = "Ion Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE

ENT.Model = "models/arccw/shock_grenade.mdl"
ENT.FuseTime = 3.5
ENT.TrailColor = Color(0, 217, 255, 115)
ENT.TrailTexture = "sprites/bluelaser1" -- this is exactly the one hl2 frag uses. Why blue? idk blame gaben

ENT.BlastDamage = {
    [1] = 200,
}

function ENT:Initialize()
    if SERVER then
        self:SetModel(self.Model)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetSkin(self.Skin or 0)

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.SpawnTime = CurTime()
        self.Trail = util.SpriteTrail(self, 0, self.TrailColor, false, 4, 0, 0.5, 4, self.TrailTexture or "sprites/bluelaser1")
        if IsValid(self.Trail) then
            self.Trail:SetRenderMode(RENDERMODE_TRANSADD)
            self.Trail:SetRenderFX(kRenderFxNone)
        end
        self:SetPhysicsAttacker(self:GetOwner(), 10)
    end
    util.PrecacheSound("weapons/shock/SW02_Weapons_Grenades_Shock_Beep_01.wav")

    -- Play the sound when the entity is spawned
    self:EmitSound("weapons/shock/SW02_Weapons_Grenades_Shock_Beep_01.wav")
end

function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        if data.Speed > 75 then
            self:EmitSound(Sound("weapons/grenades/wpn_fraggrenade_1p_hardsurface_bounce_01_lr_v" .. math.random(1,2) .. ".wav"))

            local tgt = data.HitEntity
            if IsValid(tgt) and not tgt:IsWorld() and (self.NextHit or 0) < CurTime() then
                self.NextHit = CurTime() + 0.1
                local dmginfo = DamageInfo()
                dmginfo:SetDamageType(DMG_GENERIC)
                dmginfo:SetDamage(10)
                dmginfo:SetAttacker(self:GetOwner())
                dmginfo:SetInflictor(self)
                --dmginfo:SetDamageForce(data.OurOldVelocity * 0.5)
                tgt:TakeDamageInfo(dmginfo)
                if (IsValid(tgt) and (tgt:IsNPC() or tgt:IsPlayer() or tgt:IsNextBot()) and tgt:Health() <= 0) or (not tgt:IsWorld() and not IsValid(tgt)) or string.find(tgt:GetClass(), "breakable") then
                    local pos, ang, vel = self:GetPos(), self:GetAngles(), data.OurOldVelocity
                    timer.Simple(0, function()
                        if IsValid(self) then
                            self:SetAngles(ang)
                            self:SetPos(pos)
                            self:GetPhysicsObject():SetVelocityInstantaneous(vel)
                        end
                    end)
                end
            end
        elseif data.Speed > 25 then
            self:EmitSound(Sound("weapons/grenades/grenade_bounce_2ch_v2_0" .. math.random(1,3) .. ".wav"))
        end

    end
end

function ENT:Think()
    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then  
        self:Detonate()
    end
end

function ENT:Detonate()
    if SERVER then
        local effectdata = EffectData()
            effectdata:SetOrigin(self:GetPos())

        if self:WaterLevel() >= 1 then
            util.Effect("WaterSurfaceExplosion", effectdata)
            self:EmitSound("weapons/underwater_explode3.wav", 120, 100, 1, CHAN_AUTO)
        else
            local explode = ents.Create("info_particle_system")
            explode:SetKeyValue("effect_name", "tfa_apex_arcstar_explode")
            explode:SetOwner(self.Owner)
            explode:SetPos(self:GetPos())
            explode:Spawn()
            explode:Activate()
            explode:Fire("start", "", 0)
            explode:Fire("kill", "", 30)
            self:EmitSound("weapons/shock/destruction_explosions_modular_sfx_small_disruption_var_05.mp3", 120, 100, 1, CHAN_AUTO)
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        local hit = false
        local pos = self:GetPos()

        for _, ent in pairs(ents.FindInSphere(pos, 150)) do
            -- Skip players and vehicles
            if ent:IsPlayer() or ent:IsVehicle() then
                continue
            end

            local distSqr = ent:GetPos():DistToSqr(pos)
            local f = 1
            if distSqr > 9216 then -- 96 * 96
                f = Lerp((distSqr - 9216) / (122500 - 9216), 1, 0.25)
            end

            local dmginfo = DamageInfo()
            dmginfo:SetDamageType(DMG_SHOCK)
            dmginfo:SetAttacker(self:GetOwner())
            dmginfo:SetDamage(1000 * f)
            --dmginfo:SetDamageForce((ent:WorldSpaceCenter() - pos):GetNormalized() * 9001 * f)
            dmginfo:SetInflictor(self)
            ent:TakeDamageInfo(dmginfo)

            if ent:IsPlayer() then
                ArcCW.Grenade.ArcSlow(ent, 3 * f)
            end

            if not hit and IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() and ent ~= self:GetOwner() and (ent:IsPlayer() or ent:IsNPC() or ent:IsNextBot()) then
                hit = true
                net.Start("arccw_grenade_hit")
                    net.WriteBool(false)
                net.Send(self:GetOwner())
            end
        end

        self:Remove()
        util.Decal("Scorch", pos, pos - Vector(0, 0, 16))
    end
end

--lua/entities/arccw_uc_40mm_dummy.lua:
AddCSLuaFile()

ENT.Base = "arccw_uc_40mm_he"
ENT.PrintName = "40mm Dummy Grenade"

ENT.GrenadeDamage = 50
ENT.GrenadeRadius = 150
ENT.ExplosionEffect = false
ENT.Scorch = "PaintSplatBlue"

function ENT:DoDetonation()
    --[[]
    local effectdata = EffectData()
    effectdata:SetOrigin(self:GetPos())
    effectdata:SetMagnitude(4)
    effectdata:SetScale(1)
    effectdata:SetRadius(4)
    effectdata:SetNormal(self:GetVelocity():GetNormalized())
    util.Effect("Sparks", effectdata)
    ]]
    self:EmitSound("physics/cardboard/cardboard_box_break2.wav", 80, 110)
end

function ENT:DoImpact(ent)
end

if CLIENT then
    function ENT:Think()
        self.NextSmoke = self.NextSmoke or CurTime()
        if self.SmokeTrail and self.NextSmoke < CurTime() then
            self.NextSmoke = CurTime() + 0.025 / math.Clamp(self:GetVelocity():Length() / 1000, 1, 5)
            local emitter = ParticleEmitter(self:GetPos())
            if not self:IsValid() or self:WaterLevel() > 2 then return end
            if not IsValid(emitter) then return end
            local smoke = emitter:Add("particle/smokestack", self:GetPos())
            smoke:SetVelocity(VectorRand() * 2)
            smoke:SetGravity(Vector(0, 0, -3))
            smoke:SetDieTime(math.Rand(2, 3))
            smoke:SetStartAlpha(150)
            smoke:SetEndAlpha(0)
            smoke:SetStartSize(math.Rand(3, 5))
            smoke:SetEndSize(20)
            smoke:SetRoll(math.Rand(-180, 180))
            smoke:SetRollDelta(math.Rand(-0.1, 0.1))
            smoke:SetColor(150, 150, math.Rand(220, 255))
            smoke:SetAirResistance(5)
            smoke:SetPos(self:GetPos())
            smoke:SetLighting(false)
            emitter:Finish()
        end
    end

    function ENT:OnRemove()
        local emitter = ParticleEmitter(self:GetPos())
        if not self:IsValid() or self:WaterLevel() > 2 then return end
        if not IsValid(emitter) then return end
        for i = 1, 10 do
            local smoke = emitter:Add("particle/smokestack", self:GetPos())
            smoke:SetVelocity(VectorRand() * 100)
            smoke:SetGravity(Vector(math.Rand(-5, 5), math.Rand(-5, 5), -25))
            smoke:SetDieTime(math.Rand(5, 7))
            smoke:SetStartAlpha(100)
            smoke:SetEndAlpha(0)
            smoke:SetStartSize(math.Rand(10, 15))
            smoke:SetEndSize(75)
            smoke:SetRoll(math.Rand(-180, 180))
            smoke:SetRollDelta(math.Rand(-0.5, 0.5))
            smoke:SetColor(150, 150, math.Rand(220, 255))
            smoke:SetAirResistance(150)
            smoke:SetPos(self:GetPos())
            smoke:SetLighting(false)
            smoke:SetBounce(0.5)
            smoke:SetCollide(true)
        end
        emitter:Finish()
    end
end
--addons/aocrp_map/lua/entities/gmaps_pathfinder.lua:
--Keep this file in this directory. 105860597292256157

AddCSLuaFile()

ENT.Base 			= "base_nextbot"
ENT.Spawnable		= false

function ENT:Initialize()

	--self:SetModel( "models/props_halloween/ghost_no_hat.mdl" );
	--self:SetModel( "models/props_wasteland/controlroom_filecabinet002a.mdl" );
	self:SetModel( "models/mossman.mdl" );
	self:SetNoDraw(true)
	self:SetSolid(SOLID_NONE)
	self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
	self:SetSolidMask(MASK_PLAYERSOLID_BRUSHONLY)
	self:SetHealth(1000000)

end

function ENT:OnKilled()
end

function ENT:BehaveAct()
end

function ENT:SetPlayer(ply)
	
	ply.PathFinder = self
	
	self.loco:SetDesiredSpeed(ply:GetRunSpeed())
	self.loco:SetJumpHeight((ply:GetJumpPower()/200)*40)
	self.loco:SetStepHeight(ply:GetStepSize())
	self.loco:SetDeathDropHeight( 800 )
	self:SetPos(ply:GetPos())
	self.Player = ply
	
end

-- function ENT:OnRemove()
	-- if IsValid(self.Player) then
		-- gmaps.FinishNav(self.Player)
	-- end
-- end


function ENT:RunBehaviour()

	while ( IsValid(self) ) do
		
		local ply = self.Player
		
		if not IsValid(ply) then gmaps.FinishNav(ply) return end
		if not ply:Alive() then gmaps.FinishNav(ply) return end
		if not ply.PathFinder == self then gmaps.FinishNav(ply) return end
		
		self:SetPos(ply:GetPos())
		local path = self.path
		local to = self.to
		
		local success = gmaps.ComputePath(self,path,to)
		if IsValid(path) then
			gmaps.SendNav(ply,path)
		else
			gmaps.FailNav(ply)
		end
		
		coroutine.wait(ply:GMapsLimit("NavUpdateRate") or 0)
		
		if not IsValid(ply) then gmaps.FinishNav(ply) return end
		if not ply:Alive() then gmaps.FinishNav(ply) return end
		if not ply.PathFinder == self then gmaps.FinishNav(ply) return end
		
		ProtectedCall(function()
			if path:LastSegment() then
				local veh = ply:InVehicle()
				local dist = dist and gmaps.Config.NavGoalTolerance^2 or gmaps.Config.NavGoalTolerance^2 * 2
				if self:GetPos():DistToSqr(path:LastSegment().pos) < dist then
					gmaps.FinishNav(ply)
				else
					self:SetPos(ply:GetPos())
				end
			else
				gmaps.FailNav(ply)
			end
		end)

	end


end

--
-- List the NPC as spawnable
--
-- list.Set( "NPC", "npc_tf2_ghost", {
	-- Name = "Test NPC", 
	-- Class = "npc_tf2_ghost",
	-- Category = "Nextbot"	
-- } )

--addons/weapons_other/lua/entities/jetpack_base.lua:
AddCSLuaFile()

--[[
	An entity base that allows you to create entity that can be equipped by the player as if they were weapons or powerups, but that can still
	function when not picked up by a player

	For instance you could make a jetpack that flies off when the equipping player dies, or you can make a controllable plane but still allow
	full movement on the player

	This file is licensed under the MIT license, so go nuts.
]]

DEFINE_BASECLASS( "base_entity" )

ENT.UseNWVars = false

ENT.Spawnable = false
ENT.IsPredictedEnt = true
ENT.AttachesToPlayer = true	--whether this entity attaches to the player or not, when true this removes physics and draws the entity on the player

ENT.SaveButtonToCvar = false

if SERVER then
	ENT.DropOnDeath = false
	ENT.ShowPickupNotice = true	--plays the pickup sound and shows the pickup message on the hud
	ENT.DontTransmitToOthers = false --when true, don't transmit to anyone except the owner, this MIGHT conflict with addons that make use of SetPreventTransmit, so mind that!
	ENT.ShouldLagCompensate = true 	--automatically enables/disables lag compensation when physics are created and destroyed, might be annoying for some so disable this if you want
else
	ENT.RenderGroup = RENDERGROUP_OPAQUE
end

ENT.Editable = false

ENT.KeyAllowedKeyboard = 2 ^ 0
ENT.KeyAllowedMouse = 2 ^ 1
ENT.KeyAllowedJoystick = 2 ^ 2

ENT.KeyAllowedAll = bit.bor( ENT.KeyAllowedKeyboard , ENT.KeyAllowedMouse , ENT.KeyAllowedJoystick )

ENT.KeyAllowedFlags = ENT.KeyAllowedAll	--bitflag of the key types you want to use

ENT.HookAlways = 1 --hooks in here always run
ENT.HookEquipped = 2 --hooks in here are only added when the entity is equipped by user, and removed when unequipped
ENT.HookEquippedPrediction = 3 --like above, but on the client, only for the LocalPlayer() equipping this
ENT.HookCallback = 4 --these are callbacks handled with AddCallback, unfortunately we have no way to fully handle these

--example attachment info table, only used if AttachesToPlayer is true
--[[
ENT.AttachmentInfo = {
	BoneName = "ValveBiped.Bip01_Spine2",
	OffsetVec = Vector( 3 , -5.6 , 0 ),
	OffsetAng = Angle( 180 , 90 , -90 ),
}
]]

--[[
	This is a wrapper for NetworkVars/DTVars (same thing) so we can handle their slots properly for child classes instead
	of having to modify them manually everytime something changes in order

	This could be switched to NWVars2 (vinh vars) but then I would have to hack in support for right-click editing, since that's
	based on NetworkVars and some other getters
]]
function ENT:DefineNWVar( dttype , dtname , editable , beautifulname , minval , maxval , customelement , filt )

	if not self.DefinedDTVars[dttype] then
		Error( "Wrong NWVar type " .. ( dttype or "nil" ) )
		return
	end

	local index = -1

	--only do this check for limited dtvars, once we switch to NWVars in :NetworkVar this check will go away
	if not self.UseNWVars then
		local maxindex = self.DefinedDTVars[dttype].Max

		for i = 0 , maxindex - 1 do
			--we either didn't find anything in this slot or we found the requested one again
			--in which case just override it again, someone might want to inherit and add an edit table or something
			if not self.DefinedDTVars[dttype][i] or self.DefinedDTVars[dttype][i] == dtname then
				index = i
				break
			end
		end

		if index == -1 then
			Error( "Not enough slots on "..dttype .. ",	could not add ".. dtname )
			return
		end
	else
		index = dtname:lower()
	end

	self.DefinedDTVars[dttype][index] = dtname

	local edit = nil

	--this used to check if we could actually add the edit table, so we default it to nil to override it again
	--in case of a child class

	if editable then
		edit = {
			KeyName = dtname:lower(),
			Edit = {
				title = beautifulname or dtname,	--doesn't it do this internally already?
				min = minval,
				max = maxval,
				type = customelement or self.DefinedDTVars[dttype].EditableElement,
			}
		}
	end

	self:NetworkVar( dttype , index , dtname , edit )
end

function ENT:SetupDataTables()

	--if the user is in the branch that has the NWVars change then automatically switch to this
	if self.CallNetworkProxies then
		self.UseNWVars = true
	end

	--eventually I'll create more editable elements based on garry's system

	self.DefinedDTVars = {
		Entity = {
			Max = GMOD_MAXDTVARS,
		},
		Float = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Float",
		},
		Int = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Int",
		},
		Bool = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Boolean",
		},
		Vector = {
			Max = GMOD_MAXDTVARS,
		},
		Angle = {
			Max = GMOD_MAXDTVARS,
		},
		String = {
			Max = 4,
			EditableElement = "Generic",
		},
	}

	self:DefineNWVar( "Entity" , "ControllingPlayer" )
	self:DefineNWVar( "Bool" , "BeingHeld" )
	self:DefineNWVar( "String" , "SlotName" )
	self:DefineNWVar( "Float" , "NextFire" ) --similar to primaryattack on a weapon

	--only allow the user to modify the button if the coder wants this entity to have an usable key

	self:DefineNWVar( "Int" , "Key" , true , "Button" , BUTTON_CODE_NONE + 1 , BUTTON_CODE_LAST , "EditKey" )
	self:DefineNWVar( "Bool" , "KeyPressed" )
end

function ENT:Initialize()

	self.HandledHooks = {
		[self.HookAlways] = {},
		[self.HookEquipped] = {},
		[self.HookEquippedPrediction] = {},
		[self.HookCallback] = {}
	}

	self.HookConditions = {
		[self.HookAlways] = function( ent )
			return true
		end,
		[self.HookEquipped] = function( ent )
			return ent:IsCarried()
		end,
		[self.HookEquippedPrediction] = function( ent )
			if SERVER then
				return ent:IsCarried() --self.HookConditions[self.HookEquipped]( self )
			else
				return ent:IsCarriedByLocalPlayer()
			end
		end,
		[self.HookCallback] = function( self )
			return nil --nil means don't handle me
		end,
	}

	--predicted hooks hooking with hookers and futurama memes
	self:InstallHook( "StartCommand" , self.HandlePredictedStartCommand , self.HookEquippedPrediction )
	self:InstallHook( "SetupMove" , self.HandlePredictedSetupMove , self.HookEquippedPrediction )
	self:InstallHook( "Move" , self.HandlePredictedMove , self.HookEquippedPrediction )
	self:InstallHook( "PlayerTick" , self.HandlePredictedThink , self.HookEquippedPrediction )
	self:InstallHook( "FinishMove" , self.HandlePredictedFinishMove , self.HookEquippedPrediction )
	self:InstallHook( "OnPlayerHitGround" , self.HandlePredictedHitGround , self.HookEquippedPrediction )
	self:InstallHook( "PlayerButtonDown" , self.HandlePlayerButtonDown , self.HookEquippedPrediction )
	self:InstallHook( "PlayerButtonUp" , self.HandlePlayerButtonUp , self.HookEquippedPrediction )


	self:InstallHook( "CalcMainActivity" , self.HandleCalcMainActivity , self.HookEquipped )
	self:InstallHook( "UpdateAnimation" , self.HandleUpdateAnimation , self.HookEquipped )
	self:InstallHook( "DoAnimationEvent" , self.HandleAnimationEvent , self.HookEquipped )


	if SERVER then
		self:InstallHook( "SetupPlayerVisibility" , self.HandleEntityVisibility , self.HookAlways )
		self:InstallHook( "EntityRemoved" , self.OnControllerRemoved , self.HookAlways )
		self:InstallHook( "PostPlayerDeath" , self.OnControllerDeath , self.HookAlways )	--using PostPlayerDeath as it's called on all kind of player deaths, even :KillSilent()
		self:InstallHook( "CanEditVariable" , self.HandleCanEditVariable , self.HookAlways )

		--just in case it has been spawned manually and the coder forgot
		if self:GetSlotName() == "" then
			ErrorNoHalt( self:GetClass() .. " was spawned without a slotname!!!!. Defaulting to classname\n" )
			self:SetSlotName( self:GetClass() )
		end

		self:SetUseType( SIMPLE_USE )
		self:SetKey( BUTTON_CODE_NONE )
	else
		self:InstallHook( "PreDrawEffects" , self.DrawFirstPersonInternal , self.HookEquipped )
		self:InstallHook( "PostDrawViewModel" , self.DrawViewModelInternal , self.HookEquipped )
		self:InstallHook( "PostPlayerDraw" , self.DrawOnPlayer , self.HookEquipped )

		self:InstallHook( "NotifyShouldTransmit" , self.HandleFullPacketUpdate , self.HookAlways )

		language.Add( self:GetClass() , self.PrintName )
		language.Add( "dropped_"..self:GetClass() , "Dropped "..self.PrintName )
	end
end

--This is needed mostly for clientside hooks, since IsValid might return false when we're out of PVS with some bad lag
--and when hook.Call tries to call on an invalid entity it removes the hook, so we need to reinstall them when that happens and the entity gets back in the PVS
--prediction and other shit like drawing on a player might fuck up since the hooks got removed
--Now this also works for adding a callback

function ENT:InstallHook( hookname , handler , hooktype )

	if self.HandledHooks[hooktype] == nil then
		hooktype = self.HookAlways
	end

	self.HandledHooks[hooktype][hookname] = handler

	if hooktype == self.HookCallback then
		self:AddCallback( hookname , handler )
	end

end

function ENT:HandleHooks( cleanup )

	--this is direct access to the hook table, but it's not slow at all
	--or at least, it shouldn't be as long as you don't have any ulib shit or some other hook overrides
	local hooktable = hook.GetTable()



	for hookindex , handledshooktab in pairs( self.HandledHooks ) do
		local condition = self.HookConditions[hookindex]( self )

		if condition ~= nil then
			for i , v in pairs( handledshooktab ) do
				if condition and not cleanup then
					if not hooktable[i] or not hooktable[i][self] then
						hook.Add( i , self , v )
					end
				else
					if hooktable[i] and hooktable[i][self] then
						hook.Remove( i , self )
					end
				end
			end
		end
	end

end

function ENT:Think()

	self:HandleHooks()

	if SERVER then

		--check if this guy is still my parent and owner, maybe something is forcibly unparenting us from him, if so, drop
		if self.AttachesToPlayer and self:IsCarried() then
			if not self:IsAttached() then
				self:Remove( true )
			end
		end

		--we have to network this ourselves since it's based on the physics object ( which is mainly serverside )
		--the reason I'm networking this is that due to the gravity gun enabling prediction, it would screw with the manual
		--predictable logic of this entity, so when we try to activate prediction, we check if we're being carried by the gravity gun
		--to prevent disabling it

		--NOTE: this is not as expensive as it looks, it just checks for the FVPHYSICS_PLAYER_HELD flag on our physobj
		self:SetBeingHeld( self:IsPlayerHolding() )
	else
		--calling this in a non-predicted hook is perfectly fine, since we need the entity to enable prediction on its own
		--even when controlling players change

		--Ideally this would be handled on the callback of SetControllingPlayer clientside, but we don't have that yet
		self:HandlePrediction()
		self:HandleButtonBind()
		self:HandleContextMenuButton()
		self:InternalHandleLoopingSounds()
	end

	--set our think rate to be in line with the server tickrate
	--this may also affect animations clientside if they're ran in this hook, considering that also happens in normal source
	--I'd say that's an accurate replication of the issue

	--default behaviour for scripted entities is to think every 200 milliseconds
	--I suppose this should be configurable by child entities

	self:NextThink( CurTime() + engine.TickInterval() )
	return true
end

if SERVER then

	--for map inputs mostly, but other addons may also be using these inputs trough ent:Input or ent:Fire
	--more inputs might come in the future
	--of course child entities are free to call the baseclass function after their own to chain stuff

	function ENT:AcceptInput( inputName, activator, called, data )

		if inputName == "Drop" then
			self:Drop( true )
			return true
		end

		if inputName == "SetSlotName" then
			if self:IsCarried() or not data or #data <= 1 or data == self:GetSlotName() then
				return false
			end

			self:SetSlotName( data )
			return true
		end

	end

	--although we should probably do validity checks on them first, but considering this would *probably* be called from maps it should be ok
	--copied from env_skypaint, allows to have the DT vars set as if they were key values

	function ENT:KeyValue( key, value )

		if self:SetNetworkKeyValue( key, value ) then
			return
		end

	end

	function ENT:ChangeSlot( newslotname )
		local oldslotname = self:GetSlotName()

		if newslotname == oldslotname then
			return false
		end

		local ply = self:GetControllingPlayer()

		--if we have a controlling player and he has an entity in the new slot, abort
		if IsValid( ply ) and IsValid( self.GetOnPlayer( ply , newslotname ) ) then
			--this slot is already occupied!!!
			return false
		end

		if IsValid( ply ) then
			self.SetOnPlayer( ply , oldslotname , NULL )
			self.SetOnPlayer( ply , newslotname , self )
		end

		self:SetSlotName( newslotname )

		return true
	end

	--useful for swapping out two slots at the same time and knowing the other entity,
	--usually in an inventory system
	function ENT:SwapSlotWith( predent )
		local ply = self:GetControllingPlayer()

		if not self:IsCarriedBy( ply ) or not IsValid( predent ) or not predent.IsPredictedEnt
		or not predent:IsCarriedBy( ply ) then
			return false
		end

		local myslot = self:GetSlotName()
		local otherslot = predent:GetSlotName()

		self.SetOnPlayer( ply , otherslot , self )
		self.SetOnPlayer( ply , myslot , predent )

		self:SetSlotName( otherslot )
		predent:SetSlotName( myslot )

		return true
	end

	--override this if you want your equip logic to be different
	function ENT:Use( activator, caller, useType, value )
		if not self:Attach( activator ) then
			self:EmitPESound( "HL2Player.UseDeny" , 150 , nil , 1 , nil , nil , activator )
		end
	end

	function ENT:InitPhysics()
		--don't actually initialize the physics if we're getting removed anyway
		if self:IsEFlagSet( EFL_KILLME ) then
			return
		end


		if self.ShouldLagCompensate then
			self:SetLagCompensated( true )
		end

		self:DoInitPhysics()
		self:OnInitPhysics( self:GetPhysicsObject() )
	end

	function ENT:DoInitPhysics()
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysWake()
	end

	function ENT:RemovePhysics()

		if self.AttachesToPlayer and self.ShouldLagCompensate then
			self:SetLagCompensated( false )	--entities that are attached to players will be moved back when the player is, so don't make them lag compensate on their own
		end

		self:OnRemovePhysics( self:GetPhysicsObject() )
		self:DoRemovePhysics()
	end

	function ENT:DoRemovePhysics()
		self:PhysicsDestroy()
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
	end

	function ENT:OnAttach( ply , forced )
		--override me
	end

	function ENT:CanAttach( ply )
		--override me
	end

	function ENT:OnDrop( ply , forced )
		--override me
	end

	function ENT:CanDrop( ply )
		--override me
	end

	--these two are not necessarely duplicates of the functions above because we may want to modify the mass
	--as soon as the physobj gets created, and that also happens in initialize

	function ENT:OnInitPhysics( physobj )
		--override me
	end

	function ENT:OnRemovePhysics( physobj )
		--override me
	end

	--being attached forcibly is usually something that happens when you want to spawn the player with this item, and you
	--don't want gamemode logic to interfere with it
	function ENT:Attach( activator , forced )

		--we were forced to attach to this player, so drop first to clear out some values
		if forced then
			self:Remove( forced )
		end

		if not IsValid( activator ) or not activator:IsPlayer() then
			return false
		end

		--we're carried in general OR that guy's using that slot already
		if self:IsCarried() or IsValid( self.GetOnPlayer( activator , self:GetSlotName() ) ) then
			return false
		end

		--we can allow the coder or gamemode to only stop the pickup if it's not forced
		if not forced then
			--simulate ourselves being a normal item pickup
			--the reason we're asking this first, is that first we want to make sure the gamemode is OK with us being able to pickup this entity
			local canattach = hook.Run( "PlayerCanPickupItem" , activator , self )

			--THEN we ask the coder if he really wants us to pickup his entity, in case it's out of "ammo", or some other restrictions
			local mycanattach = self:CanAttach( activator )
			if mycanattach == false then
				canattach = mycanattach
			end

			if canattach == false then
				return canattach
			end
		end

		if self.AttachesToPlayer then
			self:RemovePhysics()
			self:SetParent( activator )
			self:SetOwner( activator )
			self:SetTransmitWithParent( true )

			--[[
			if self.DontTransmitToOthers then
				--force a recheck of the transmission, so UpdateTransmitState() is called right away
				self:AddEFlags( EFL_FORCE_CHECK_TRANSMIT )
			else
				self:SetTransmitWithParent( true )
			end
			]]

			self:SetNoDraw( true )
			self:AddEFlags( EFL_NO_PHYSCANNON_INTERACTION )
		end

		self:SendItemMessage( activator , false )

		self.SetOnPlayer( activator , self:GetSlotName() , self )
		self:SetControllingPlayer( activator )

		--if the player has a customized key for this entity, use that instead
		--we do this here so that OnAttach can make use of it

		--this also allows us to prevent the key from another user to be written clientside and override ours
		if self.SaveButtonToCvar then
			local plykey = self:GetControllingPlayerConVarKey()

			if self:IsKeyAllowed( plykey ) and plykey ~= self:GetKey() then
				self:SetKey( plykey )
			end
		end

		--THIS IS VERY SUBJECTIVE
		self:SetKeyPressed( false ) --only reset the button press state when equipped

		self:OnAttach( activator , forced )
		return true
	end

	function ENT:Drop( forced )

		--we can allow the coder to only stop the drop if it's not forced
		if not forced then
			local candrop = self:CanDrop( self:GetControllingPlayer() )

			if candrop == false then
				return candrop
			end
		end

		if self.AttachesToPlayer then
			self:SetParent( NULL )
			self:SetOwner( NULL )
			self:InitPhysics()
			self:SetTransmitWithParent( false )

			--[[
			if self.DontTransmitToOthers then
				--force a recheck during a drop
				self:AddEFlags( EFL_FORCE_CHECK_TRANSMIT )
			else
				self:SetTransmitWithParent( false )
			end
			]]

			self:SetNoDraw( false )
			self:RemoveEFlags( EFL_NO_PHYSCANNON_INTERACTION )
		end

		if not forced and self:IsCarried() then
			self:SendItemMessage( self:GetControllingPlayer() , true )
		end

		--only call OnDrop if we had a player controlling us, don't do it if we were just sweeping up some unclean values
		if self:IsCarried() then
			self:OnDrop( self:GetControllingPlayer() , forced )
			self.SetOnPlayer( self:GetControllingPlayer() , self:GetSlotName() , NULL )
		end

		self:SetControllingPlayer( NULL )
		return true
	end

	function ENT:SendItemMessage( activator , dropped )
		if dropped == nil then
			dropped = false
		end
		--GetShouldPlayPickupSound is actually a Lua table value that is then checked in c++, so it starts out as nil, wow garry
		if self.ShowPickupNotice and ( self:GetShouldPlayPickupSound() == nil or self:GetShouldPlayPickupSound() ) then

			if not dropped then
				self:EmitSound( "HL2Player.PickupWeapon" )
			else
				self:EmitSound( "Weapon_Crowbar.Single" )
			end

			if not activator:IsPlayer() or not activator:IsBot() then
				net.Start( "pe_pickup" )
					net.WriteString( self:GetClass() )
					net.WriteBit( dropped )
				net.Send( activator )
			end
		end
	end

	--we want to get properly dropped when the player entity gets removed ( aka after a disconnect )
	--why not use the disconnect hook? no.

	function ENT:OnControllerRemoved( ent )
		if self:IsCarriedBy( ent ) then
			self:Remove( true )
		end
	end

	function ENT:OnControllerDeath( ply )
		if self.DropOnDeath and self:IsCarriedBy( ply ) then
			self:Remove( true )
		end
	end

	--we're redoing this even though it's hooked up in sandbox because someone might want to use this in another gamemode ( such as ttt or whatever )
	function ENT:HandleCanEditVariable( ent , ply , key , val , editor )
		if ent == self then
			local allow = self:CanPlayerEditVariable( ply , key , val , editor )

			if key == "Key" then
				local btn = tonumber( val )
				if btn and not self:IsKeyAllowed( btn ) then
					allow = false
				end
			end

			--call the editkey hook only if the other one didn't say anything in the matter for this
			if key == "Key" and allow == nil then
				allow = self:CanEditKey( ply , val , editor )
			end

			--we'll only override all the hooks if the answer is yes or no, nil keeps the default behaviour
			if allow ~= nil then
				return allow
			end
		end
	end

	--our key can only be modified by the carrying player or by anyone if it's not carried at all
	function ENT:CanEditKey( ply , val , editor )
		--you could override me if you want to, you could leave your friends behind
		return self:IsCarriedBy( ply ) or not self:IsCarried()
	end

	function ENT:CanPlayerEditVariable( ply , key , val , editor )
		--override me
	end

	--we add this entity's position to the visibility position, but only if it doesn't attach to the player
	function ENT:HandleEntityVisibility( ply , viewent )
		if self:IsCarriedBy( ply ) and not self.AttachesToPlayer and self ~= viewent then --viewents already add themselves to the pvs
			AddOriginToPVS( self:GetPos() )
		end

		--HOW CONVENIENT!!! this hook is called before the client computes what he can see
		--so we can simply use this before this entity gets recomputed for transmission

		--TODO: This will be removed and the ENT:UpdateTransmitState() below will be enabled once Willox is done with TRANSMIT_OWNERONLY
		if self.DontTransmitToOthers and not game.SinglePlayer() then

			local shouldpreventtransmit = false

			if self:IsCarried() then
				shouldpreventtransmit = not self:IsCarriedBy( ply , true )
			end

			self:SetPreventTransmit( ply , shouldpreventtransmit )
		end
	end

	--[[
	function ENT:UpdateTransmitState()


		if self.DontTransmitToOthers and self:IsCarried() then
			return TRANSMIT_OWNERONLY
		end


		--don't return anything, default behaviour
	end
	]]

else

	function ENT:GetConVar()

		--the slotname changed, so we forget this cvar to let another one with the same slot use it
		--and we let the code below create/get one with our slotname
		if self.ConfigurableConVar and self.ConfigurableConVar:GetName() ~= self:GetConVarName() then
			self.ConfigurableConVar = nil
		end

		if not self.ConfigurableConVar then
			--internally this returns the original convar if it was already created, so it's not that big of a deal, this could be done in a better way however
			self.ConfigurableConVar = CreateConVar( self:GetConVarName() , self:GetKey() , FCVAR_ARCHIVE + FCVAR_USERINFO , "Configures the key for "..self:GetSlotName().. " , created by "..self:GetClass() )
		end

		return self.ConfigurableConVar
	end

	function ENT:InternalHandleLoopingSounds( calledinprediction )
		--the calledinprediction variable makes it so HandleLoopingSounds is called from ENT:Think instead
		--and yes, this will never be set at all during singleplayer because there's no prediction

		--if this is set then there's no need to call iscarried checks below, we're always called when that happens
		if calledinprediction and not IsFirstTimePredicted() then
			return
		end

		if game.SinglePlayer() or not self:IsCarried() or not self:IsCarriedByLocalPlayer() or ( self:IsCarriedByLocalPlayer() and calledinprediction ) then
			self:HandleLoopingSounds()
		end
	end

	function ENT:HandleLoopingSounds()
		--override me
	end

	function ENT:IsCarriedByLocalPlayer( checkspectator )
		return self:IsCarriedBy( LocalPlayer() , checkspectator )
	end

	function ENT:ShouldDrawLocalPlayer( checkspectator )
		if checkspectator then
			if LocalPlayer():GetObserverMode() == OBS_MODE_IN_EYE and IsValid( LocalPlayer():GetObserverTarget() ) then
				if LocalPlayer():GetObserverTarget():IsPlayer() then
					return LocalPlayer():GetObserverTarget():ShouldDrawLocalPlayer() --assuming this even works, otherwise just return false
				end
				return false
			end
		end
		return LocalPlayer():ShouldDrawLocalPlayer()
	end

	--immediately make this entity predicted again, if it's equipped by this localplayer
	function ENT:HandleFullPacketUpdate( ent , shouldtransmit )
		if ent == self and shouldtransmit then
			self:HandlePrediction()
		end
	end

	function ENT:HandlePrediction()

		local carried = self:IsCarriedByLocalPlayer()

		--either the gravity gun or some other stuff is carrying me, don't do anything on prediction
		--because they might enable it to carry us around smoothly
		--also don't enable prediction in singleplayer

		if self:GetBeingHeld() or game.SinglePlayer() then
			return
		end

		if self:GetPredictable() ~= carried then
			self:SetPredictable( carried )
		end
	end

	function ENT:HandleButtonBind()
		--did not disable the function call from Think as someone might want to override this

		if self.SaveButtonToCvar then
			--this is a one way server to client saving, the reason I do this is because the user should usually change the value from
			--client to server with the edit system, it still goes to the server, but not to the cvar first, so we save it from the client to the cvar

			--basically we just use the cvar as a way to save the button, but it does come at the cost of not being able to update the cvar and have it update on the
			--entity, this will probably change in the future
			local mykey = self:GetKey()

			--can't use GetControllingPlayerConVarKey as I also need to SetInt on it
			local cv = self:GetConVar()

			if cv then
				if ( mykey ~= cv:GetInt() and self:IsKeyAllowed( mykey ) ) --[[or not self:IsKeyAllowed( cv:GetInt() )]] then
					cv:SetInt( mykey )
				end
			end
		end
	end



	function ENT:CreateContextMenuButton( iconlayout )
		local button = iconlayout:Add( "DPredEnt" )
		button:SetSize( 80 , 80 )
		button:SetClassName( self.PrintName , self:GetSlotName() )
		button:SetMaterial( self.Folder .. ".png" )
		button:SetPredEnt( self )
		--SetClassName
	end

	function ENT:GetContextMenuButton( iconlayout )
		local contextbutton = nil

		for i = 0 , iconlayout:ChildCount() do

			local child = iconlayout:GetChild( i )

			if IsValid( child ) and child:GetName() == "DPredEnt" and child:GetSpawnName() == self:GetSlotName() and child:GetPredEnt() == self then
				contextbutton = child
				break
			end

		end

		return contextbutton
	end

	--forcefully removes it in case it fucks up
	function ENT:RemoveContextMenuButton( iconlayout , buttonpanel )
		if IsValid( buttonpanel ) then
			buttonpanel:Remove()
		end
	end

	function ENT:GetContextMenuLayout()
		if not IsValid( g_ContextMenu ) then
			return
		end

		local iconlayout = nil

		for i = 0 , g_ContextMenu:ChildCount() do

			local child = g_ContextMenu:GetChild( i )

			if IsValid( child ) and child:GetName() == "DIconLayout" then
				iconlayout = child
				break
			end

		end

		return iconlayout
	end

	function ENT:HandleContextMenuButton( docleanup )

		local iconlayout = self:GetContextMenuLayout()

		if not IsValid( iconlayout ) then
			return
		end

		local buttonpanel = self:GetContextMenuButton( iconlayout )

		if IsValid( buttonpanel ) and ( not self:IsCarriedByLocalPlayer() or docleanup )then
			self:RemoveContextMenuButton( iconlayout , buttonpanel )
			iconlayout:InvalidateLayout()
		end

		if not IsValid( buttonpanel ) and self:IsCarriedByLocalPlayer() then
			self:CreateContextMenuButton( iconlayout )
			iconlayout:InvalidateLayout()
		end

	end



	function ENT:DrawFirstPersonInternal()
		if self.AttachesToPlayer and self:IsCarriedByLocalPlayer( true ) and not self:ShouldDrawLocalPlayer( true ) then
			local fov = nil	--TODO: allow changing the FOV
			cam.Start3D( nil , nil , fov , nil , nil , nil , nil , 1 , -1 )	--znear is 1 and zfar is -1
				render.DepthRange( 0 , 0.1 )	--same depth hack valve uses in source!
					self:DrawFirstPerson( self:GetControllingPlayer() )
				render.DepthRange( 0 , 1 )		--they don't even set these back to the original values
			cam.End3D()
		end
	end

	--viewmodels don't draw without an associated weapon ( this is due to garryness, they always do in source )
	function ENT:DrawViewModelInternal( vm , ply , wpn )
		if self.AttachesToPlayer and self:IsCarriedBy( ply , true ) then
			self:DrawOnViewModel( ply , vm , ply:GetHands() ) --this will stay here
		end
	end

	function ENT:DrawFirstPerson( ply )
		--override me
	end

	--mainly used to draw stuff like shields, gloves or whatever on the viewmodel hands

	function ENT:DrawOnViewModel( ply , vm , hands )
		--override me
	end

	--the flags aren't passed yet, maybe in a future update

	function ENT:DrawOnPlayer( ply , flags )
		self:DrawModel( flags )

	end

	function ENT:Draw( flags )
		local pos , ang = self:GetCustomParentOrigin()
		--even though the calcabsoluteposition hook should already prevent this, it doesn't on other players
		--might as well not give it the benefit of the doubt in the first place
		if pos and ang then
			self:SetPos( pos )
			self:SetAngles( ang )
			self:SetupBones()
		end

		self:DrawModel( flags )
	end

end

--these are here to "unify" our two calls to SetNWEntity and GetNWEntity
--these might be called from pe_drop and some other stuff, so we can't rely on the entity itself being present, as lame as that is
--the alternative would be to have these as global, which would be lamer
function ENT.SetOnPlayer( ply , slot , ent )
	ply:SetNW2Entity( slot , ent )
end

function ENT.GetOnPlayer( ply , slot )
	return ply:GetNW2Entity( slot )
end

function ENT:IsAttached()
	local ply = self:GetControllingPlayer()
	return self:GetOwner() == ply and self:GetParent() == ply
end

--LOOK I DON'T CARE, this check is lame as shit but I can't be arsed to add duplicated code
function ENT:IsCarried()
	return self:IsCarriedBy( self:GetControllingPlayer() )
end

function ENT:IsCarriedBy( ply , checkspectator )

	if checkspectator and ply:GetObserverMode() ~= OBS_MODE_NONE then
		return self:IsCarriedBy( ply:GetObserverTarget() )
	end

	return IsValid( ply ) and ply == self:GetControllingPlayer() and self.GetOnPlayer( self:GetControllingPlayer() , self:GetSlotName() ) == self
end

function ENT:IsKeyDown()
	return self:GetKeyPressed()
end

--these functions should totally not be tied to this SENT, but I don't want to go out of my way to add them to an util file
function ENT:IsValidButton( btn )
	return btn > BUTTON_CODE_NONE and btn < BUTTON_CODE_COUNT
end

function ENT:IsKeyboardButton( btn )
	return btn > KEY_FIRST and btn < KEY_COUNT
end

function ENT:IsMouseButton( btn )
	return btn >= MOUSE_FIRST and btn < MOUSE_LAST
end

function ENT:IsJoystickButton( btn )
	return btn >= JOYSTICK_FIRST and btn < JOYSTICK_LAST
end

function ENT:IsKeyAllowed( btn )
	if bit.band( self.KeyAllowedFlags , self.KeyAllowedKeyboard ) == 0 and self:IsKeyboardButton( btn ) then
		return false
	end

	if bit.band( self.KeyAllowedFlags , self.KeyAllowedMouse ) == 0 and self:IsMouseButton( btn ) then
		return false
	end

	if bit.band( self.KeyAllowedFlags , self.KeyAllowedJoystick ) == 0 and self:IsJoystickButton( btn ) then
		return false
	end

	return self:IsValidButton( btn )
end

function ENT:GetConVarName()
	return "prdent_key_"..self:GetSlotName()
end

function ENT:GetControllingPlayerConVarKey()
	local defaultkey = BUTTON_CODE_NONE

	if self:IsCarried() then
		if SERVER then
			return self:GetControllingPlayer():GetInfoNum( self:GetConVarName() , defaultkey )
		else
			--the clientside implementation of GetInfoNum makes a GetConVar lookup everytime, so use the cached one instead
			local cv = self:GetConVar()

			if cv then
				return cv:GetInt()
			end
		end
	end

	return defaultkey
end

function ENT:HandleCalcMainActivity( ply , velocity )
	if self:IsCarriedBy( ply ) then
		local calcideal , calcseqovr = self:HandleMainActivityOverride( ply , velocity )
		if calcideal and calcseqovr then
			return calcideal , calcseqovr
		end
	end
end

function ENT:HandleUpdateAnimation( ply, velocity, maxseqgroundspeed )
	if self:IsCarriedBy( ply ) then
		if self:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed ) then
			return true
		end
	end
end

function ENT:HandleAnimationEvent( ply, event, data )
	if self:IsCarriedBy( ply ) then
		if self:HandleAnimationEventOverride( ply , event , data ) then
			return ACT_INVALID
		end
	end
end

function ENT:HandleMainActivityOverride( ply , velocity )
	--override me
end

function ENT:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed )
	--override me
end

function ENT:HandleAnimationEventOverride( ply , event , data )
	--override me
end

function ENT:HandlePredictedStartCommand( ply , cmd )
	if self:IsCarriedBy( ply ) then
		self:PredictedStartCommand( ply , cmd )
	end
end

function ENT:HandlePlayerButtonDown( ply , btn )
	if self:IsCarriedBy( ply ) then
		self:HandlePlayerButtonInternal( ply , btn , true )
	end
end

function ENT:HandlePlayerButtonUp( ply , btn )
	if self:IsCarriedBy( ply ) then
		self:HandlePlayerButtonInternal( ply , btn , false )
	end
end

function ENT:HandlePlayerButtonInternal( ply , btn , pressed )
	local mykey = self:GetKey()
	if self:IsKeyAllowed( mykey ) and btn == mykey then
		self:SetKeyPressed( pressed )
	end

	self:PredictedPlayerButtonPress( ply , btn , pressed )
end

function ENT:HandlePredictedSetupMove( ply , mv , cmd )
	if self:IsCarriedBy( ply ) then
		if self:PredictedSetupMove( ply , mv , cmd ) then
			return true
		end
	end
end

function ENT:HandlePredictedMove( ply , mv )
	if self:IsCarriedBy( ply ) then
		if self:PredictedMove( ply , mv ) then
			return true
		end
	end
end

function ENT:HandlePredictedThink( ply , mv )
	if self:IsCarriedBy( ply ) then
		if CLIENT then
			self:InternalHandleLoopingSounds( true )
		end
		self:PredictedThink( ply , mv )
	end
end

function ENT:HandlePredictedFinishMove( ply , mv )
	if self:IsCarriedBy( ply ) then
		if self:PredictedFinishMove( ply , mv ) then
			return true
		end
	end
end

function ENT:HandlePredictedHitGround( ply , inwater , onfloater , speed )
	if self:IsCarriedBy( ply ) then
		if self:PredictedHitGround( ply , inwater , onfloater , speed ) then
			return true
		end
	end
end

function ENT:PredictedStartCommand( ply , cmd )
	--override me
end

function ENT:PredictedPlayerButtonPress( ply , btn , pressed )
	--override me
end

function ENT:PredictedSetupMove( ply , mv , cmd )
	--override me
end

function ENT:PredictedMove( ply , mv )
	--override me
end

function ENT:PredictedThink( ply , mv )
	--override me
end

function ENT:PredictedFinishMove( ply , mv )
	--override me
end

function ENT:PredictedHitGround( ply , inwater , onfloater , speed )
	--override me
end

--Allows for predicted movement simulation on non player entities, without disrupting the player movement itself
--FinishMove should be the best place for this, since even in case of fuckups, the rest of the movement should be fine

--[[
	function ENT:PredictedFinishMove( ply , mv )

		local sv = self:BackupMoveData( mv )

		--set the data you want on the movedata, such as the entity origin, speed, angles and stuff

		--run the entity traces

		--set the final position of the entity here with the same way garry does ( see drive.End or whatever it's called )

		--restore the movedata on the player as if nothing happened

		self:RestoreMoveData( mv , sv )


	end
]]


local movedatameta = FindMetaTable( "CMoveData" )

local emptyvalues = {
	[TYPE_VECTOR] = vector_origin * 1,
	[TYPE_ANGLE] = angle_zero * 1,
	[TYPE_NUMBER] = 0,
	[TYPE_ENTITY] = NULL,
}

local methods = {}

--cache the methods we can actually use
for i , v in pairs( movedatameta ) do
	--see if this function has a pattern like "Get*" or whatever
	--then strip out "Get" and add it here
	local functionname = i
	if functionname:find( "^Get" ) then
		local functionnamestripped = functionname:gsub( "^Get" , "" )

		local setter = movedatameta["Set"..functionnamestripped]

		if setter then
			--add the stripped method to the table to reuse later
			methods[#methods + 1] = functionnamestripped
		end
	end
end

function ENT:BackupMoveData( mv )

	if not mv or not movedatameta then
		return
	end

	local sv = {}
	--save the movedata by name on the table, then go trough the metatable to get the setters and set values to empty ones

	for i , v in pairs( methods ) do
		--see if this function has a pattern like "Get*" or whatever
		--then strip out "Get" and add it here

		--we could've cached the functions as well, but just in case someone wants us to use the modified ones
		local getter = movedata["Get"..v]
		local setter = movedata["Set"..v]

		local backupvalue = getter( mv )

		sv[v] = backupvalue

		if emptyvalues[TypeID( backupvalue )] ~= nil then
			setter( mv , emptyvalues[TypeID( backupvalue )] )
		end
	end

	return sv
end

function ENT:RestoreMoveData( mv , sv )
	if not mv or not sv or not movedatameta then
		return
	end

	--restore the values from the table, prevents duplicated code by using the setters from the metatable directly
	for i , v in pairs( sv ) do
		local setter = movedatameta["Set"..i]
		if setter then
			setter( mv , v )
		end
	end
end

--attaches the entity to the player depending on the attachmentinfo table
--you can override this safely as long as you keep the part with ply:SetupBones()
--although you generally should just use the attachment info table instead

function ENT:GetCustomParentOrigin()

	if not self.AttachmentInfo then
		return
	end

	local ply = self:GetControllingPlayer()

	--duplicated check, but people might call this manually in the entity draw hook, so gotta do this
	if not self:IsCarriedBy( ply ) then
		return
	end

	--I put this here because since the entity moves to the player bone matrix, it'll only be updated on the client
	--when the player is actally drawn, or his bones are setup again ( which happens before a draw anyway )
	--this also fixes sounds on the client playing at the last location the LocalPlayer() was drawn

	if CLIENT and self:IsCarriedByLocalPlayer( true ) and not self:ShouldDrawLocalPlayer( true ) then
		ply:SetupBones()
	end

	local boneid = ply:LookupBone( self.AttachmentInfo.BoneName )

	if not boneid then
		return
	end

	local matrix = ply:GetBoneMatrix( boneid )

	if not matrix then
		return
	end

	return LocalToWorld( self.AttachmentInfo.OffsetVec , self.AttachmentInfo.OffsetAng , matrix:GetTranslation() , matrix:GetAngles() )
end

--if we're attached to a player, use custom origin from the function above
--this is called shared, yes it's more expensive than source's normal parenting but it's worth it

function ENT:CalcAbsolutePosition( pos , ang )
	if self.AttachesToPlayer and self:IsCarried() then
		return self:GetCustomParentOrigin()
	end
end

function ENT:EmitPESound( soundname , level , pitch , volume , chan , predicted , activator , worldpos )

	--must've been called manually by some ent:Fire or ent:Input functions
	if IsValid( activator ) and not activator:IsPlayer() then
		activator = NULL
	end

	if not level then
		level = 75
	end

	if not pitch then
		pitch = 100
	end

	if not volume then
		volume = 1
	end

	if not chan then
		chan = CHAN_AUTO
	end

	if game.SinglePlayer() then
		predicted = false
	end

	if not worldpos then
		worldpos = vector_origin
	end

	if SERVER then

		local plys = RecipientFilter()

		if IsValid( activator ) and not predicted and not activator:IsBot() then
			plys:AddPlayer( activator )
		else

			plys:AddPVS( self:GetPos() )

			if predicted and IsValid( self:GetControllingPlayer() ) then
				plys:RemovePlayer( self:GetControllingPlayer() )
			end

		end

		if plys:GetCount() == 0 then
			return
		end

		net.Start( "pe_playsound" )
			net.WriteEntity( self )
			net.WriteString( soundname )
			net.WriteFloat( level )
			net.WriteFloat( pitch )
			net.WriteFloat( volume )
			net.WriteUInt( chan , 8 )
			net.WriteVector( worldpos )
		net.Send( plys )

	else
		if ( predicted and IsFirstTimePredicted() ) or not predicted then
			if worldpos and worldpos ~= vector_origin then
				sound.Play( soundname, worldpos, level, pitch , volume )
			else
				self:EmitSound( soundname , level , pitch , volume , chan )
			end
		end
	end
end

function ENT:OnRemove()
	--if we're being forcibly removed, make sure we're also dropped properly, in case the entity needs to do
	--some stuff on the player before it expires
	if SERVER and self:IsCarried() then
		self:Remove( true )
	end

	if CLIENT then
		self:HandleContextMenuButton( true )
	end

	self:HandleHooks( true ) --remove the hooks immediately instead of relying on garry's "remove if called again"


end

--stuff that should be in an autorun file but that I can't be arsed to split up to

if SERVER then

	util.AddNetworkString( "pe_pickup" )
	util.AddNetworkString( "pe_playsound" )

	--save the function before ENT gets removed during registration
	local GetPredictedEntityOnPlayer = ENT.GetOnPlayer

	concommand.Add( "pe_drop" , function( ply , cmd , args , fullstr )

		if not IsValid( ply ) then
			return
		end

		local nwslot = args[1]

		if not nwslot then
			return
		end

		local slotent = GetPredictedEntityOnPlayer( ply , nwslot )--ply:GetNWEntity( nwslot )

		--user tried to drop an invalid or an entity which is not a predicted entity, or doesn't have a slot assigned

		if not IsValid( slotent ) or not slotent.IsPredictedEnt or slotent:GetSlotName() == "" then
			return
		end

		slotent:Remove( false )

	end)

else

	--tells the hud to show the player the entity pickup
	language.Add( "invalid_entity" , "Invalid Entity" )
	language.Add( "dropped_invalid_entity" , "Dropped Invalid Entity" )

	net.Receive( "pe_pickup" , function( len )
		local str = net.ReadString() or "invalid_entity"
		local dropped = tobool( net.ReadBit() )

		if dropped then
			str = "dropped_" .. str
		end

		gamemode.Call( "HUDItemPickedUp" , str )
	end)

	net.Receive( "pe_playsound" , function( len )
		local ent = net.ReadEntity()

		if not IsValid( ent ) or not ent.EmitPESound then
			return
		end

		local soundname = net.ReadString() --yes I know that I can do util.addnetworkstring to cache it but I cba

		local level = net.ReadFloat()
		local pitch = net.ReadFloat()
		local volume = net.ReadFloat()
		local chan = net.ReadUInt( 8 )
		local pos = net.ReadVector()

		ent:EmitPESound( soundname , level , pitch , volume , chan , false , NULL , pos )
	end)

	--[[
		A DProperty that allows the user to set a preferred key using the same DBinder used in sandbox's tools
	]]

	local DBinderProperty = {}

	function DBinderProperty:Init()
	end

	function DBinderProperty:Setup( vars )

		self:Clear()

		local ctrl = self:Add( "DBinder" )
		ctrl:Dock( FILL )

		self.IsEditing = function( self )
			return ctrl.Trapping
		end

		self.SetValue = function ( self , val )
			ctrl:SetSelected( tonumber( val ) )	--use this instead of setValue to possibly avoid feedback loops
		end

		--DBinder doesn't have an onchange callback, so we must do this little hack to add it
		--[[
		ctrl.SetValue = function( ctrl , val )
			ctrl:SetSelected( val )
			self:ValueChanged( val )
		end
		]]

		ctrl.OnChange = function( ctrl , val )
			self:ValueChanged( val )
		end


	end

	derma.DefineControl( "DProperty_EditKey" , "" , DBinderProperty , "DProperty_Generic" )

	local DPredEnt = {
		matOverlay_Normal = Material( "gui/ContentIcon-normal.png" ),
		matOverlay_Hovered = Material( "gui/ContentIcon-hovered.png" )
	}

	AccessorFunc( DPredEnt, "m_MaxBorder", "MaxBorder" )
	AccessorFunc( DPredEnt, "m_MaterialName", "MaterialName" )
	AccessorFunc( DPredEnt, "m_PredEnt", "PredEnt" )
	AccessorFunc( DPredEnt, "m_Border", "Border" )
	AccessorFunc( DPredEnt, "m_Color", "Color" )
	AccessorFunc( DPredEnt, "m_Type", "ContentType" )
	AccessorFunc( DPredEnt, "m_SpawnName", "SpawnName" )
	AccessorFunc( DPredEnt, "m_NPCWeapon", "NPCWeapon" )
	AccessorFunc( DPredEnt, "m_Image", "Image" )
	AccessorFunc( DPredEnt, "m_Label", "Label" )

	function DPredEnt:Init()

		local w , h = 128, 128
		self:SetSize( w , h )

		self:SetPaintBackground( false )

		self:SetText( "" )
		self:SetDoubleClickingEnabled( false )

		self:SetImage( self:Add( "DImage" ) )
		self:GetImage():SetVisible( false )

		self:SetLabel( self:Add( "DLabel" ) )
		self:GetLabel():Dock( BOTTOM )

		self:GetLabel():SetContentAlignment( 5 )

		self:GetLabel():SetTextColor( Color( 255, 255, 255, 255 ) )
		self:GetLabel():SetExpensiveShadow( 1, Color( 0, 0, 0, 200 ) )

		self:SetBorder( 0 )



	end



	function DPredEnt:PerformLayout( w , h )
		self:SetMaxBorder( w / 16 )
		self:GetImage():SetPos( w / 32 , w / 32 )
		self:GetImage():SetSize( w - w / 16 , h - w / 16 )
		self:GetLabel():SetTall( math.Round( w / 7 ) )
		self:GetLabel():DockMargin( math.Round( w / 32 ) , 0 , math.Round( w / 32 ) , math.Round( w / 21 ) )
	end


	function DPredEnt:SetClassName( name , class )

		self:SetTooltip( name )
		self:GetLabel():SetText( name )
		self:SetSpawnName( class )
	end

	function DPredEnt:SetMaterial( name )

		self:SetMaterialName( name )

		local mat = Material( name )

		-- Look for the old style material
		if not mat or mat:IsError() then

			name = name:Replace( "entities/", "VGUI/entities/" )
			name = name:Replace( ".png", "" )
			mat = Material( name )

		end

		-- Couldn't find any material.. just return
		if not mat or mat:IsError() then
			return
		end

		self:GetImage():SetMaterial( mat )

	end

	function DPredEnt:Think()
		if not IsValid( self:GetPredEnt() ) or not self:GetPredEnt().IsPredictedEnt  then
			self:Remove()
		end
	end

	function DPredEnt:DoRightClick()
		self:OpenMenu()
	end

	function DPredEnt:DoClick()
		RunConsoleCommand( "pe_drop" , self:GetSpawnName() or ""  )
	end

	function DPredEnt:OpenMenu()
		if IsValid( self:GetPredEnt() ) then
			properties.OpenEntityMenu( self:GetPredEnt() )
		end
	end

	function DPredEnt:OnDepressionChanged( b )
	end

	function DPredEnt:Paint( w, h )

		if self.Depressed and not self.Dragging then
			if self:GetBorder() ~= self:GetMaxBorder() then
				self:SetBorder( self:GetMaxBorder() )
				self:OnDepressionChanged( true )
			end
		else
			if self:GetBorder() ~= 0 then
				self:SetBorder( 0 )
				self:OnDepressionChanged( false )
			end
		end

		render.PushFilterMag( TEXFILTER.ANISOTROPIC )
		render.PushFilterMin( TEXFILTER.ANISOTROPIC )

		local bx , by , bw , bh = self:GetBorder(), self:GetBorder(), w - self:GetBorder() * 2 , h - self:GetBorder() * 2


		self:GetImage():PaintAt( bx + self:GetMaxBorder() / 2 , by + self:GetMaxBorder() / 2 , bw - self:GetMaxBorder() , bh - self:GetMaxBorder() )



		render.PopFilterMin()
		render.PopFilterMag()

		surface.SetDrawColor( 255, 255, 255, 255 )

		if not dragndrop.IsDragging() and ( self:IsHovered() or self.Depressed or self:IsChildHovered() ) then

			surface.SetMaterial( self.matOverlay_Hovered )
			self:GetLabel():Hide()

		else

			surface.SetMaterial( self.matOverlay_Normal )
			self:GetLabel():Show()

		end

		surface.DrawTexturedRect( bx , by , bw , bh )

	end

	derma.DefineControl( "DPredEnt" , "ContentIcon for Predicted entities in the context menu" , DPredEnt , "DButton" )

end

--addons/lvs_addons/lua/entities/laat_wingrocket.lua:
AddCSLuaFile()

ENT.Type            = "anim"
DEFINE_BASECLASS( "lunasflightschool_missile" )

if SERVER then
    function ENT:Initialize()	
		self:SetModel("models/weapons/w_missile_launch.mdl")
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetRenderMode(RENDERMODE_TRANSALPHA)
		self:PhysWake()

		local pObj = self:GetPhysicsObject()
		if IsValid(pObj) then
			pObj:EnableGravity(false) 
			pObj:SetMass(1) 
		end
		
		self.LifeTime = CurTime() + 12
	end

	function ENT:FollowTarget( followent )
		self:GetPhysicsObject():SetVelocity(self:GetForward() * 8250)

		local ang = (followent:GetPos() - self:GetPos()):Angle()
		self:SetAngles(ang)

		--[[local speed = self:GetStartVelocity() + (self:GetDirtyMissile() and 5000 or 3500)
		local turnrate = (self:GetCleanMissile() or self:GetDirtyMissile()) and 60 or 50
		
		local TargetPos = followent:LocalToWorld( followent:OBBCenter() )
		
		if isfunction( followent.GetMissileOffset ) then
			local Value = followent:GetMissileOffset()
			if isvector( Value ) then
				TargetPos = followent:LocalToWorld( Value )
			end
		end
		
		local pos = TargetPos + followent:GetVelocity() * 0.25
		
		local pObj = self:GetPhysicsObject()
		
		if IsValid( pObj ) then
			if not self:GetDisabled() then
				local targetdir = (pos - self:GetPos()):GetNormalized()
				
				local AF = self:WorldToLocalAngles( targetdir:Angle() )
				AF.p = math.Clamp( AF.p * 400,-turnrate,turnrate )
				AF.y = math.Clamp( AF.y * 400,-turnrate,turnrate )
				AF.r = math.Clamp( AF.r * 400,-turnrate,turnrate )
				
				local AVel = pObj:GetAngleVelocity()
				pObj:AddAngleVelocity( Vector(AF.r,AF.p,AF.y) - AVel ) 
				
				pObj:SetVelocityInstantaneous( self:GetForward() * speed )
			end
		end]]
	end

	local function GetValidEntity(ent)
		return IsValid(ent) and ent or Entity(0)
	end

    function ENT:Think()	
		local curtime = CurTime()
		self:NextThink(curtime)
		
		local Target = self:GetLockOn()
		if IsValid(Target) then
			self:FollowTarget(Target)
		else
			self:BlindFire()
		end

		if self.MarkForRemove then
			self:Detonate()
		end
		
		if self.Explode then
			local Inflictor = self:GetInflictor()
			local Attacker = self:GetAttacker()

			util.BlastDamage(GetValidEntity(Inflictor), GetValidEntity(Attacker), self:GetPos(), 250, 150)
			
			self:Detonate()
		end
		
		if self.LifeTime <= curtime then
			self:Detonate()
		end
		
		return true
	end

    function ENT:PhysicsCollide( data )
		if self:GetDisabled() then
			self.MarkForRemove = true
		else
			local HitEnt = data.HitEntity
			
			if IsValid(HitEnt) && not self.Explode && (HitEnt.LFS || HitEnt.IdentifiesAsLFS) then 
                local Pos = self:GetPos()

                local effectdata = EffectData()
                    effectdata:SetOrigin(Pos)
                    effectdata:SetNormal(-self:GetForward())
                util.Effect("manhacksparks", effectdata, true, true)

                local dmginfo = DamageInfo()
                    dmginfo:SetDamage(500)
                    dmginfo:SetAttacker(IsValid(self:GetAttacker()) && self:GetAttacker() || self)
                    dmginfo:SetDamageType(DMG_BLAST)
                    dmginfo:SetInflictor(self) 
                    dmginfo:SetDamagePosition(Pos) 
                HitEnt:TakeDamageInfo(dmginfo)

                sound.Play("Missile.ShotDown", Pos, 140)
			end
			
			self.Explode = true
		end
	end
else
	function ENT:Initialize()	
		self.snd = CreateSound(self, "weapons/flaregun/burn.wav")
			self.snd:Play()

		local effectdata = EffectData()
			effectdata:SetOrigin(self:GetPos())
			effectdata:SetEntity(self)
		util.Effect("lfs_fb_wingrocket", effectdata)
	end
end
--lua/entities/ls_ap_mine.lua:
AddCSLuaFile("ls_ap_mine.lua")

if CLIENT then
    language.Add("ls_ap_mine", "Anti-Personnel Mine")
end

ENT.Base = "ls_base_mine"
ENT.Type = "anim"

ENT.PrintName = "Anti-Personnel Mine"
ENT.Category = "Star Wars - Mines"
ENT.Author = "List-Scripts"
ENT.Spawnable = true
ENT.AdminOnly = false

ENT.Model = "models/props/starwars/weapons/ap_mine.mdl"
ENT.TriggerBrush = "ls_brush_sphere"
ENT.TriggerSize = 20
ENT.ExplosionRadius = 100

-- if true, mine will explode when the victim leaves the trigger area
ENT.ExplodeOnLeave = false

ENT.HP = 25
ENT.Damage = 500

if not SERVER then return end

function ENT:canTrigger(ent)
    return ent:IsPlayer() or ent:IsNPC()
end
--addons/lvs_addons/lua/entities/lunasflightschool_niksacokica_tx-427/cl_init.lua:
include("shared.lua")
include( "sh_turret.lua" )
include( "cl_prediction.lua" )

function ENT:OnSpawn()
	local mins, maxs = self:GetRenderBounds()
	self:SetRenderBounds( mins, maxs, Vector( 80, 0, 0 ) )
end

function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(11,0,46) ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(11,40,46) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(11,-40,46) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

function ENT:OnFrame()
	self:PredictPoseParamaters()
	self:DamageFX()
end


function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if ply == self:GetDriver() then
		if not pod:GetThirdPersonMode() then
			return pos + self:GetForward() * 100 - self:GetUp() * 20, angles + Angle(5,0,0), fov
		else
			return pos, angles, fov
		end
	end
	local GunnerPod = self:GetGunnerSeat()
	if pod == GunnerPod and pod:GetThirdPersonMode() then
		return GunnerPod:LocalToWorld( Vector(0,0,30) ), angles + Angle(5,0,0), fov
	end

	local CoSeatPod = self:GetCoSeat()
	if pod == CoSeatPod then
		if pod:GetThirdPersonMode() then
			return CoSeatPod:LocalToWorld( Vector(0,0,100) ), angles + Angle(5,0,0), fov
		else
			return pos, angles, fov
		end
	end

	local originPos = pos
	local mn = self:OBBMins()
	local mx = self:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local TargetOrigin = originPos + ( angles:Forward() * -radius ) + angles:Up() * (40 + radius * pod:GetCameraHeight())
	local WallOffset = 4

	local tr = util.TraceHull( {
		start = originPos,
		endpos = TargetOrigin,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	originPos = tr.HitPos
	if tr.Hit and  not tr.StartSolid then
		originPos = originPos + tr.HitNormal * WallOffset
	end

	return originPos, angles, fov
end

local COLOR_RED = Color(255,0,0,255)
local COLOR_WHITE = Color(255,255,255,255)

function ENT:LVSPreHudPaint( X, Y, ply )
	if self:GetIsCarried() then return false end

	if ply == self:GetDriver() then
		local Col = self:WeaponsInRange() and COLOR_WHITE or COLOR_RED

		local Pos2D = self:GetEyeTrace().HitPos:ToScreen() 

		self:PaintCrosshairCenter( Pos2D, Col )
		self:PaintCrosshairOuter( Pos2D, Col )
		self:LVSPaintHitMarker( Pos2D )
	end

	return true
end

--addons/lvs_addons/lua/entities/lunasflightschool_niksacokica_tx-427/sh_turret.lua:

function ENT:SetPoseParameterTurret( weapon )
	if self:GetIsCarried() then
		self:SetPoseParameter("turret_pitch", 0 )
		self:SetPoseParameter("turret_yaw",  0 )

		if self.TurretWasSet then
			self.TurretWasSet = nil

			self:SetTurretPitch( 0 )
			self:SetTurretYaw( 0 )
		end

		return
	end

	self.TurretWasSet = true

	if not IsValid( weapon:GetDriver() ) and not weapon:GetAI() then return end

	local AimAng = weapon:WorldToLocal( weapon:GetPos() + weapon:GetAimVector() ):Angle()
	AimAng:Normalize()

	local AimRate = self.TurretTurnRate * FrameTime() 

	self:SetTurretPitch( math.ApproachAngle( self:GetTurretPitch(), -AimAng.p, AimRate ) )

 	self:SetTurretYaw( LerpAngle( AimRate * 0.02, Angle( 0, self:GetTurretYaw(), 0 ), Angle(0, AimAng.y, 0 ) ).y )

	self:SetPoseParameter("turret_pitch", self:GetTurretPitch() )
	self:SetPoseParameter("turret_yaw", self:GetTurretYaw() )
end

function ENT:TraceTurret()
	local ID = self:LookupAttachment( "turret_muzzle" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = -Muzzle.Ang:Right()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:InitTurret()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = -1
	weapon.Delay = 2.5
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/vehicles/aat/overheat.mp3")
	end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return true end

		local ID = base:LookupAttachment( "turret_muzzle" )
		local Muzzle = base:GetAttachment( ID )

		if not Muzzle then return end

		local Dir = Muzzle.Ang:Up()
		local bullet = {}
		bullet.Src 	= Muzzle.Pos
		bullet.Dir 	= -Muzzle.Ang:Right()
		bullet.Spread 	= Vector(0,0,0)
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 1000
		bullet.HullSize 	= 30
		bullet.Damage	= 1500
		bullet.Velocity = 7000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lfs_tx-427_main_explosion_red", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,50,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		effectdata:SetScale(100)
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		local PhysObj = base:GetPhysicsObject()
		if IsValid( PhysObj ) then
			PhysObj:ApplyForceOffset( Muzzle.Ang:Right() * 500000, Muzzle.Pos )
		end

		if not IsValid( base.SNDTurret ) then return end

		base.SNDTurret:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetPoseParameterTurret( ent )
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end
		local entWhitelist = {
			[base] = true,
			[ent] = true,
			[self] = true,
		}
		if not pod:GetThirdPersonMode() then
			return view
		end

		local mn = self:OBBMins()
		local mx = self:OBBMaxs()
		local radius = ( mn - mx ):Length()
		local radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )
		local StartPos = self:LocalToWorld( Vector(-75,0,140) )
		local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * radius * 0.2

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

				return collide and not entWhitelist[e]
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.angles = angles + Angle(5,0,0)
		view.origin = tr.HitPos

		if tr.Hit and  not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = -1
	weapon.Delay = 0.125
	weapon.HeatRateUp = 0.15
	weapon.HeatRateDown = 0.125
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/vehicles/aat/overheat.mp3")
	end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return true end


		local ID = base:LookupAttachment( "turret_muzzle" )
		local muzzle = base:GetAttachment( ID )

		if not muzzle then return end

		self:EmitSound( "niksacokica/tx-427/cannon_small.wav" )
		local ang = muzzle.Ang
		local dir = -ang:Right()
		local tr = util.TraceLine( {
			start = muzzle.Pos,
			endpos = muzzle.Pos + dir * 100000,
			filter = { ent, base, self }
		} )
		local bullet = {}
		bullet.Src 	= muzzle.Pos
		bullet.Dir 	= ( tr.HitPos - muzzle.Pos ):GetNormalized()
		bullet.Spread 	= Vector( 0.015,  0.015, 0.01 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 100
		bullet.HullSize 	= 1
		bullet.Damage	= 100
		bullet.Velocity = 40000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )
		
		ent:TakeAmmo()
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetPoseParameterTurret( ent )
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()
		
		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end
		local entWhitelist = {
			[base] = true,
			[ent] = true,
			[self] = true,
		}
		if not pod:GetThirdPersonMode() then
			return view
		end

		local mn = self:OBBMins()
		local mx = self:OBBMaxs()
		local radius = ( mn - mx ):Length()
		local radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )
		local StartPos = self:LocalToWorld( Vector(-75,0,140) )
		local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * radius * 0.2

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

				return collide and not entWhitelist[e]
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.angles = angles + Angle(5,0,0)
		view.origin = tr.HitPos

		if tr.Hit and  not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

--addons/lvs_addons/lua/entities/lvs_arc/cl_init.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

include("shared.lua")

ENT.EngineColor = Color( 255, 50, 0, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	Vector(-163.81,64.51,8.36),
	Vector(-163.81,-64.51,8.36),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-34,326,-13), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-34,-326,-13), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
	self:AnimAstromech()
	self:AnimGunner()
	self:AnimWings()
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 255, 50, 200 )
	end
end

function ENT:AnimGunner()
	local Pod = self:GetTailGunnerSeat()

	if not IsValid( Pod ) then return end

	local weapon = Pod:lvsGetWeapon()

	if not IsValid( weapon ) then return end

	local EyeAngles = self:WorldToLocalAngles( weapon:GetAimVector():Angle() )
	EyeAngles:RotateAroundAxis( EyeAngles:Up(), 180 )

	local Yaw = math.Clamp( EyeAngles.y,-60,60)
	local Pitch = math.Clamp( EyeAngles.p,-60,60 )

	self:ManipulateBoneAngles( 1, Angle(Yaw,0,0) )
	self:ManipulateBoneAngles( 2, Angle(0,0, math.max( Pitch, -25 ) ) )

	self:ManipulateBoneAngles( 5, Angle( math.Clamp( Yaw, -30, 30 ),0,0) )
	self:ManipulateBoneAngles( 3, Angle(0,0, math.Clamp( Pitch, -60, 12 ) ) )
end



function ENT:AnimAstromech()
	local T = CurTime()

	if (self.nextAstro or 0) < T then
		self.nextAstro = T + math.Rand(0.5,2)
		self.AstroAng = math.Rand(-180,180)

		local HasShield = self:GetShield() > 0

		if self.OldShield == true and not HasShield then
			self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/astromech/shieldsdown"..math.random(1,2)..".ogg",100 )
		else
			if math.random(0,4) == 3 then
				self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/astromech/"..math.random(1,11)..".ogg", 70 )
			end
		end
		
		self.OldShield = HasShield
	end

	self.smastro = self.smastro and (self.smastro + ((self.AstroAng or 0) - self.smastro) * RealFrameTime() * 10) or 0

	--self:ManipulateBoneAngles( 1, Angle(self.smastro,0,0) ) -- makes the back gun rotate
end

function ENT:AnimWings()
	self._sm_wing = self._sm_wing or 1

	local target_wing = self:GetFoils() and 0 or 1
	local RFT = RealFrameTime() * (0.5 + math.abs( math.sin( self._sm_wing * math.pi ) ) * 0.5)

	local Rate = RFT * 0.5

	self._sm_wing = self._sm_wing + math.Clamp(target_wing - self._sm_wing,-Rate,Rate)

	local DoneMoving = self._sm_wing == 1 or self._sm_wing == 0

	if self._oldDoneMoving ~= DoneMoving then
		self._oldDoneMoving = DoneMoving
		if not DoneMoving then
			self:EmitSound("lvs/vehicles/arc170/sfoils.wav")
		end
	end

	local Ang = (1 - self._sm_wing) * 20

	self:ManipulateBoneAngles( 13, Angle(0,-Ang,0) ) -- top wing, right
	self:ManipulateBoneAngles( 18, Angle(0,Ang,0) ) -- bottom wing, right
	
	self:ManipulateBoneAngles( 15, Angle(0,Ang,0) )  -- top wing, left
	self:ManipulateBoneAngles( 14, Angle(0,-Ang,0) ) -- bottom wing, left
	self:InvalidateBoneCache()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost() * 2

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/arc170/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/arc170/brake.wav", 85 )
end

function ENT:AnimFins()
	local Driver = self:GetDriver()
	local Gunner = self:GetGunner()
	
	local HasGunner = IsValid( Gunner )
	
	
	if HasGunner then Driver = Gunner end
	
	local EyeAngles = self:WorldToLocalAngles( Driver:EyeAngles() )
	EyeAngles:RotateAroundAxis( EyeAngles:Up(), 180 )
	
	local Yaw = math.Clamp( EyeAngles.y,-45,45)
	local Pitch = math.Clamp( EyeAngles.p,-15,15 )
	
	if not Driver:lfsGetInput( "FREELOOK" ) and not HasGunner then
		Yaw = 0
		Pitch = 0
	end
	
	self:ManipulateBoneAngles( 12, Angle(Yaw,0,0) )
	self:ManipulateBoneAngles( 19, Angle(0,0,Pitch) )
	
	self:ManipulateBoneAngles( 5, Angle(Yaw,0,0) )
	self:ManipulateBoneAngles( 4, Angle(0,0,Pitch) )
end

function ENT:ExhaustFX()
	if not self:GetEngineActive() then return end
	
	self.nextEFX = self.nextEFX or 0
	
	local THR = (self:GetRPM() - self.IdleRPM) / (self.LimitRPM - self.IdleRPM)
	
	local Driver = self:GetDriver()
	if IsValid( Driver ) then
		local W = Driver:lfsGetInput( "+THROTTLE" )
		if W ~= self.oldW then
			self.oldW = W
			if W then
				self.BoostAdd = 0
			end
		end
	end
	
	self.BoostAdd = self.BoostAdd and (self.BoostAdd - self.BoostAdd * FrameTime()) or 0
	
	if self.nextEFX < CurTime() then
		self.nextEFX = CurTime() + 0.01
		
		local emitter = ParticleEmitter( self:GetPos(), false )

		if emitter then
			local Mirror = false
			for i = 0,1 do
				local Sub = Mirror and 1 or -1
				local vOffset = self:LocalToWorld( Vector(-163.81,64.51 * Sub,8.36) )
				local vNormal = -self:GetForward()

				vOffset = vOffset + vNormal * 5

				local particle = emitter:Add( "effects/muzzleflash2", vOffset )
				if not particle then return end

				particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
				particle:SetLifeTime( 0 )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( 255 )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(15,25) )
				particle:SetEndSize( math.Rand(0,10) )
				particle:SetRoll( math.Rand(-1,1) * 100 )
				
				particle:SetColor( 255, 0, 200 )
			
				Mirror = true
			end
			
			emitter:Finish()
		end
	end
end





























--addons/lvs_base/lua/entities/lvs_base_doorhandler.lua:
AddCSLuaFile()

ENT.Type            = "anim"
ENT.DoNotDuplicate = true

ENT.RenderGroup = RENDERGROUP_BOTH 

ENT.UseRange = 75

ENT._UseTargetAllowed = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )

	self:NetworkVar( "Bool",0, "Active" )

	self:NetworkVar( "String",0, "PoseName" )

	self:NetworkVar( "Vector",0, "Mins" )
	self:NetworkVar( "Vector",1, "Maxs" )

	self:NetworkVar( "Float",0, "Rate" )
	self:NetworkVar( "Float",1, "RateExponent" )

	self:NetworkVar( "Float",2, "PoseMin" )
	self:NetworkVar( "Float",3, "PoseMax" )

	if SERVER then
		self:SetRate( 10 )
		self:SetRateExponent( 2 )

		self:SetPoseMax( 1 )
	end
end

function ENT:IsServerSide()
	local EntTable = self:GetTable()

	if isbool( EntTable._IsServerSide ) then return EntTable._IsServerSide end

	local PoseName = self:GetPoseName()

	if PoseName == "" then return false end

	local IsServerSide = string.StartsWith( PoseName, "^" )

	EntTable._IsServerSide = IsServerSide

	return IsServerSide
end

function ENT:IsOpen()
	return self:GetActive()
end

function ENT:InRange( ply, Range )
	local boxOrigin = self:GetPos()
	local boxAngles = self:GetAngles()
	local boxMins = self:GetMins()
	local boxMaxs = self:GetMaxs()

	local HitPos, _, _ = util.IntersectRayWithOBB( ply:GetShootPos(), ply:GetAimVector() * Range, boxOrigin, boxAngles, boxMins, boxMaxs )

	return isvector( HitPos )
end

if SERVER then
	AccessorFunc(ENT, "soundopen", "SoundOpen", FORCE_STRING)
	AccessorFunc(ENT, "soundclose", "SoundClose", FORCE_STRING)

	AccessorFunc(ENT, "maxsopen", "MaxsOpen", FORCE_VECTOR)
	AccessorFunc(ENT, "minsopen", "MinsOpen", FORCE_VECTOR)

	AccessorFunc(ENT, "maxsclosed", "MaxsClosed", FORCE_VECTOR)
	AccessorFunc(ENT, "minsclosed", "MinsClosed", FORCE_VECTOR)


	util.AddNetworkString( "lvs_doorhandler_interact" )

	net.Receive( "lvs_doorhandler_interact", function( length, ply )
		if not IsValid( ply ) then return end

		local ent = net.ReadEntity()

		if not IsValid( ent ) or not ent._UseTargetAllowed or not ent.UseRange or ply:InVehicle() then return end

		local Range = ent.UseRange * 2

		if (ply:GetPos() - ent:GetPos()):Length() > Range then return end

		if not ent:InRange( ply, Range ) then return end

		ent:Use( ply, ply )
	end)

	function ENT:LinkToSeat( ent )
		if not IsValid( ent ) or not ent:IsVehicle() then

			ErrorNoHalt( "[LVS] Couldn't link seat to doorsystem. Entity expected, got "..tostring( ent ).."\n" )

			return
		end

		self._LinkedSeat = ent
	end

	function ENT:GetLinkedSeat()
		return self._LinkedSeat
	end

	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:SetUseType( SIMPLE_USE )
		self:DrawShadow( false )
		debugoverlay.Cross( self:GetPos(), 15, 5, Color( 255, 223, 127 ) )
	end

	function ENT:Use( ply )
		if not IsValid( ply ) then return end

		local Base = self:GetBase()

		if not IsValid( Base ) then return end

		if not Base:IsUseAllowed( ply ) then return end

		if self:IsOpen() then
			self:Close( ply )
		else
			self:Open( ply )
		end
	end

	function ENT:OnOpen( ply )
	end

	function ENT:OnClosed( ply )
	end

	function ENT:OpenAndClose( ply )
		self:Open( ply )

		self._PreventClosing = true

		timer.Simple(0.5, function()
			if not IsValid( self ) then return end

			self:Close( ply )

			self._PreventClosing = false
		end )
	end

	function ENT:DisableOnBodyGroup( group, subgroup )
		self._BodyGroupDisable = group
		self._BodySubGroupDisable = subgroup
	end

	function ENT:IsBodyGroupDisabled()
		if not self._BodyGroupDisable or not self._BodySubGroupDisable then return false end

		local base = self:GetBase()

		if not IsValid( base ) then return false end

		return base:GetBodygroup( self._BodyGroupDisable ) == self._BodySubGroupDisable
	end

	function ENT:Open( ply )
		if self:IsOpen() then return end

		self:SetActive( true )
		self:SetMins( self:GetMinsOpen() )
		self:SetMaxs( self:GetMaxsOpen() )

		if self:IsBodyGroupDisabled() then return end

		self:OnOpen( ply )

		local snd = self:GetSoundOpen()

		if not snd then return end

		self:EmitSound( snd )
	end

	function ENT:Close( ply )
		if not self:IsOpen() then
			if self:IsBodyGroupDisabled() then
				self:Open( ply )
			end

			return
		end

		if self:IsBodyGroupDisabled() then return end

		self:SetActive( false )
		self:SetMins( self:GetMinsClosed() )
		self:SetMaxs( self:GetMaxsClosed() )

		self:OnClosed( ply )

		local snd = self:GetSoundClose()

		if not snd then return end

		self:EmitSound( snd )
	end

	function ENT:OnDriverChanged( oldDriver, newDriver, pod )
		if self._PreventClosing then return end

		if IsValid( newDriver ) then
			if self:IsOpen() then
				self:Close( newDriver )
			end
		else
			timer.Simple( FrameTime() * 2, function()
				if not IsValid( self ) or not IsValid( oldDriver ) or IsValid( self._Driver ) then return end

				if oldDriver:lvsGetVehicle() == self:GetBase() then return end

				if not self:IsOpen() then
					self:OpenAndClose()
				end
			end )
		end
	end

	function ENT:SetPoseParameterSV()
		local Base = self:GetBase()

		if not IsValid( Base ) then return end

		local Target = self:GetActive() and self:GetPoseMax() or self:GetPoseMin()
		local poseName = self:GetPoseName()

		if poseName == "" then return end

		local EntTable = self:GetTable()

		EntTable.sm_pp = EntTable.sm_pp and EntTable.sm_pp + (Target - EntTable.sm_pp) * FrameTime() * self:GetRate() or 0

		local value = EntTable.sm_pp ^ self:GetRateExponent()

		Base:SetPoseParameter( string.Replace(poseName, "^", ""), value )
	end

	function ENT:Think()
		if IsValid( self._LinkedSeat ) then
			local Driver = self._LinkedSeat:GetDriver()
	
			if self._Driver ~= Driver then
			
				self:OnDriverChanged( self._Driver, Driver, self._LinkedSeat )

				self._Driver = Driver
			end
		end

		if self:IsServerSide() then
			self:SetPoseParameterSV()

			self:NextThink( CurTime() )
		else
			self:NextThink( CurTime() + 0.25 )
		end

		return true
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	return
end

function ENT:Initialize()
end

function ENT:Think()
	if self:IsServerSide() then return end

	local Base = self:GetBase()

	if not IsValid( Base ) then return end

	local Target = self:GetActive() and self:GetPoseMax() or self:GetPoseMin()
	local poseName = self:GetPoseName()

	if poseName == "" then return end

	local EntTable = self:GetTable()

	EntTable.sm_pp = EntTable.sm_pp and EntTable.sm_pp + (Target - EntTable.sm_pp) * RealFrameTime() * self:GetRate() or 0

	local value = EntTable.sm_pp ^ self:GetRateExponent()

	if string.StartsWith( poseName, "!" ) then
		Base:SetBonePoseParameter( poseName, value )
	else
		Base:SetPoseParameter( poseName, value )
	end
end

function ENT:OnRemove()
end

function ENT:Draw()
end

local LVS = LVS
ENT.ColorSelect = Color(127,255,127,150)
ENT.ColorNormal = Color(255,0,0,150)
ENT.ColorTransBlack = Color(0,0,0,150)
ENT.OutlineThickness = Vector(0.5,0.5,0.5)

function ENT:DrawTranslucent()
	local ply = LocalPlayer()

	if not IsValid( ply ) or ply:InVehicle() or not ply:KeyDown( IN_SPEED ) then return end

	local InRange = self:InRange( ply, self.UseRange )

	if InRange then
		local EntTable = self:GetTable()

		local Use = ply:KeyDown( IN_USE )

		if EntTable.old_Use ~= Use then
			EntTable.old_Use = Use

			if Use then
				net.Start( "lvs_doorhandler_interact" )
					net.WriteEntity( self )
				net.SendToServer()
			end
		end
	end

	if not LVS.DeveloperEnabled then return end

	local boxOrigin = self:GetPos()
	local boxAngles = self:GetAngles()
	local boxMins = self:GetMins()
	local boxMaxs = self:GetMaxs()

	local EntTable = self:GetTable()

	local Col = InRange and EntTable.ColorSelect or EntTable.ColorNormal

	render.SetColorMaterial()
	render.DrawBox( boxOrigin, boxAngles, boxMins, boxMaxs, Col )
	render.DrawBox( boxOrigin, boxAngles, boxMaxs + EntTable.OutlineThickness, boxMins - EntTable.OutlineThickness, EntTable.ColorTransBlack )
end

--addons/lvs_base/lua/entities/lvs_base_gunner/cl_init.lua:
include("shared.lua")

function ENT:Think()
end

function ENT:OnRemove()
end

function ENT:Draw()
end

function ENT:DrawTranslucent()
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetNWAimVector()
	end

	local Driver = self:GetDriver()

	if IsValid( Driver ) then
		if self._AimVectorUnlocked then
			local pod = self:GetDriverSeat()

			if IsValid( pod ) then
				return pod:WorldToLocalAngles( Driver:EyeAngles() ):Forward()
			end
		end

		return Driver:GetAimVector()
	else
		return self:GetForward()
	end
end

function ENT:LVSPaintHitMarker( scr )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return end

	Base:LVSPaintHitMarker( scr )
end

function ENT:LVSDrawCircle( X, Y, target_radius, value )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return end

	Base:LVSDrawCircle( X, Y, target_radius, value )
end

function ENT:PaintCrosshairCenter( Pos2D, Col )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return end

	Base:PaintCrosshairCenter( Pos2D, Col )
end

function ENT:PaintCrosshairOuter( Pos2D, Col )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return end

	Base:PaintCrosshairOuter( Pos2D, Col )
end

function ENT:PaintCrosshairSquare( Pos2D, Col )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return end

	Base:PaintCrosshairSquare( Pos2D, Col )
end

--addons/lvs_addons/lua/entities/lvs_base_repulsorlift/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "[LVS] Base Gunship"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.ThrustVtol = 30
ENT.ThrustRateVtol = 2

ENT.MaxPitch = 60

ENT.DisableBallistics = true

function ENT:CalcVtolThrottle( ply, cmd )
	local Delta = FrameTime()

	local ThrottleZero = self:GetThrottle() <= 0

	local VtolX = ThrottleZero and (ply:lvsKeyDown( "-VTOL_X_SF" ) and -1 or 0) or 0
	local VtolY = ((ply:lvsKeyDown( "+VTOL_Y_SF" ) and 1 or 0) - (ply:lvsKeyDown( "-VTOL_Y_SF" ) and 1 or 0))

	if ply:lvsMouseAim() then
		VtolY = math.Clamp( VtolY + ((ply:lvsKeyDown( "-ROLL_SF" ) and 1 or 0) - (ply:lvsKeyDown( "+ROLL_SF" ) and 1 or 0)), -1 , 1)
	end

	VtolY = VtolY * math.max( 1 - self:GetThrottle() ^ 2, 0 )
	local VtolZ = ((ply:lvsKeyDown( "+VTOL_Z_SF" ) and 1 or 0) - (ply:lvsKeyDown( "-VTOL_Z_SF" ) and 1 or 0))

	local DesiredVtol = Vector(VtolX,VtolY,VtolZ)
	local NewVtolMove = self:GetNWVtolMove() + (DesiredVtol - self:GetNWVtolMove()) * self.ThrustRateVtol * Delta

	if not ThrottleZero or self:WorldToLocal( self:GetPos() + self:GetVelocity() ).x > 100 then
		NewVtolMove.x = 0
	end

	self:SetVtolMove( NewVtolMove )
end

function ENT:GetVtolMove()
	if self:GetEngineActive() and not self:GetAI() then
		return self:GetNWVtolMove() * self.ThrustVtol
	else
		return Vector(0,0,0)
	end
end

function ENT:PlayerDirectInput( ply, cmd )
	local Pod = self:GetDriverSeat()

	local Delta = FrameTime()

	local KeyLeft = ply:lvsKeyDown( "-ROLL_SF" )
	local KeyRight = ply:lvsKeyDown( "+ROLL_SF" )
	local KeyPitchUp = ply:lvsKeyDown( "+PITCH_SF" )
	local KeyPitchDown = ply:lvsKeyDown( "-PITCH_SF" )

	local MouseX = cmd:GetMouseX()
	local MouseY = cmd:GetMouseY()

	if ply:lvsKeyDown( "FREELOOK" ) and not Pod:GetThirdPersonMode() then
		MouseX = 0
		MouseY = 0
	else
		ply:SetEyeAngles( Angle(0,90,0) )
	end

	local SensX, SensY, ReturnDelta = ply:lvsMouseSensitivity()

	if KeyPitchDown then MouseY = (10 / SensY) * ReturnDelta end
	if KeyPitchUp then MouseY = -(10 / SensY) * ReturnDelta end
	if KeyLeft then MouseX = -(10 / SensX) * ReturnDelta end
	if KeyRight then MouseX = (10 / SensX) * ReturnDelta end

	local Input = Vector( MouseX * 0.4 * SensX, MouseY * SensY, 0 )

	local Cur = self:GetSteer()

	local Rate = Delta * 3 * ReturnDelta

	local New = Vector(Cur.x, Cur.y, 0) - Vector( math.Clamp(Cur.x * Delta * 5 * ReturnDelta,-Rate,Rate), math.Clamp(Cur.y * Delta * 5 * ReturnDelta,-Rate,Rate), 0)

	local Target = New + Input * Delta * 0.8

	local Fx = math.Clamp( Target.x, -1, 1 )
	local Fy = math.Clamp( Target.y, -1, 1 )

	local TargetFz = (KeyLeft and 1 or 0) - (KeyRight and 1 or 0)
	local Fz = Cur.z + math.Clamp(TargetFz - Cur.z,-Rate * 3,Rate * 3)

	local F = Cur + (Vector( Fx, Fy, Fz ) - Cur) * math.min(Delta * 100,1)

	self:SetSteer( F )
end

function ENT:StartCommand( ply, cmd )
	if self:GetDriver() ~= ply then return end

	if SERVER then
		local KeyJump = ply:lvsKeyDown( "VSPEC" )

		if self._lvsOldKeyJump ~= KeyJump then
			self._lvsOldKeyJump = KeyJump

			if KeyJump then
				self:ToggleVehicleSpecific()
			end
		end
	end

	if ply:lvsMouseAim() then
		if SERVER then
			self:PlayerMouseAim( ply, cmd )
		end
	else
		self:PlayerDirectInput( ply, cmd )
	end

	self:CalcThrottle( ply, cmd )
	self:CalcVtolThrottle( ply, cmd )
end

function ENT:GetVehicleType()
	return "repulsorlift"
end
--addons/lvs_addons/lua/entities/lvs_base_starfighter/shared.lua:

ENT.Base = "lvs_base"

ENT.PrintName = "[LVS] Base Starfighter"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

ENT.MaxVelocity = 3000
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.ThrottleRateUp = 0.6
ENT.ThrottleRateDown = 0.6

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.DisableBallistics = true

function ENT:SetupDataTables()
	self:CreateBaseDT()

	self:AddDT( "Vector", "Steer" )
	self:AddDT( "Vector", "AIAimVector" )
	self:AddDT( "Vector", "NWVtolMove" )
	self:AddDT( "Float", "NWThrottle" )
	self:AddDT( "Float", "MaxThrottle" )

	if SERVER then
		self:SetMaxThrottle( 1 )
	end
end

function ENT:PlayerDirectInput( ply, cmd )
	local Pod = self:GetDriverSeat()

	local Delta = FrameTime()

	local KeyLeft = ply:lvsKeyDown( "-ROLL_SF" )
	local KeyRight = ply:lvsKeyDown( "+ROLL_SF" )
	local KeyPitchUp = ply:lvsKeyDown( "+PITCH_SF" )
	local KeyPitchDown = ply:lvsKeyDown( "-PITCH_SF" )
	local KeyRollRight = ply:lvsKeyDown( "+YAW_SF" )
	local KeyRollLeft = ply:lvsKeyDown( "-YAW_SF" )

	local MouseX = cmd:GetMouseX()
	local MouseY = cmd:GetMouseY()

	if ply:lvsKeyDown( "FREELOOK" ) and not Pod:GetThirdPersonMode() then
		MouseX = 0
		MouseY = 0
	else
		ply:SetEyeAngles( Angle(0,90,0) )
	end

	local SensX, SensY, ReturnDelta = ply:lvsMouseSensitivity()

	if KeyPitchDown then MouseY = (10 / SensY) * ReturnDelta end
	if KeyPitchUp then MouseY = -(10 / SensY) * ReturnDelta end
	if KeyRollRight or KeyRollLeft then
		local NewX = (KeyRollRight and 10 or 0) - (KeyRollLeft and 10 or 0)

		MouseX = (NewX / SensX) * ReturnDelta
	end

	local Input = Vector( MouseX * 0.4 * SensX, MouseY * SensY, 0 )

	local Cur = self:GetSteer()

	local Rate = Delta * 3 * ReturnDelta

	local New = Vector(Cur.x, Cur.y, 0) - Vector( math.Clamp(Cur.x * Delta * 5 * ReturnDelta,-Rate,Rate), math.Clamp(Cur.y * Delta * 5 * ReturnDelta,-Rate,Rate), 0)

	local Target = New + Input * Delta * 0.8

	local Fx = math.Clamp( Target.x, -1, 1 )
	local Fy = math.Clamp( Target.y, -1, 1 )

	local TargetFz = (KeyLeft and 1 or 0) - (KeyRight and 1 or 0)
	local Fz = Cur.z + math.Clamp(TargetFz - Cur.z,-Rate * 3,Rate * 3)

	local F = Cur + (Vector( Fx, Fy, Fz ) - Cur) * math.min(Delta * 100,1)

	self:SetSteer( F )
end

function ENT:CalcThrottle( ply, cmd )
	if CLIENT then return end

	local Delta = FrameTime()

	local ThrottleUp =  ply:lvsKeyDown( "+THRUST_SF" ) and self.ThrottleRateUp or 0
	local ThrottleDown = ply:lvsKeyDown( "-THRUST_SF" ) and -self.ThrottleRateDown or 0

	local Throttle = (ThrottleUp + ThrottleDown) * Delta

	self:SetThrottle( self:GetThrottle() + Throttle )
end

function ENT:CalcVtolThrottle( ply, cmd )
	local Delta = FrameTime()

	local ThrottleZero = self:GetThrottle() <= 0

	local VtolX = ThrottleZero and (ply:lvsKeyDown( "-VTOL_X_SF" ) and -1 or 0) or 0
	local VtolY = ((ply:lvsKeyDown( "+VTOL_Y_SF" ) and 1 or 0) - (ply:lvsKeyDown( "-VTOL_Y_SF" ) and 1 or 0))
	local VtolZ = ((ply:lvsKeyDown( "+VTOL_Z_SF" ) and 1 or 0) - (ply:lvsKeyDown( "-VTOL_Z_SF" ) and 1 or 0))

	local DesiredVtol = Vector(VtolX,VtolY,VtolZ)
	local NewVtolMove = self:GetNWVtolMove() + (DesiredVtol - self:GetNWVtolMove()) * self.ThrustRateVtol * Delta

	if not ThrottleZero or self:WorldToLocal( self:GetPos() + self:GetVelocity() ).x > 100 then
		NewVtolMove.x = 0
	end

	self:SetVtolMove( NewVtolMove )
end

function ENT:SetVtolMove( NewMove )
	if self:GetEngineActive() then
		self:SetNWVtolMove( NewMove )
	else
		self:SetNWVtolMove( Vector(0,0,0) )
	end
end

function ENT:SetThrottle( NewThrottle )
	if self:GetEngineActive() then
		self:SetNWThrottle( math.Clamp(NewThrottle,0,self:GetMaxThrottle()) )
	else
		self:SetNWThrottle( 0 )
	end
end

function ENT:GetThrottle()
	if self:GetEngineActive() then
		return self:GetNWThrottle()
	else
		return 0
	end
end

function ENT:GetVtolMove()
	if self:GetEngineActive() and not self:GetAI() then
		return self:GetNWVtolMove() * self.ThrustVtol * (1 - math.min( self:GetThrottle(), 1 ))
	else
		return Vector(0,0,0)
	end
end

function ENT:StartCommand( ply, cmd )
	if self:GetDriver() ~= ply then return end

	if SERVER then
		local KeyJump = ply:lvsKeyDown( "VSPEC" )

		if self._lvsOldKeyJump ~= KeyJump then
			self._lvsOldKeyJump = KeyJump

			if KeyJump then
				self:ToggleVehicleSpecific()
			end
		end
	end

	if not ply:lvsMouseAim() then
		self:PlayerDirectInput( ply, cmd )
	end

	self:CalcThrottle( ply, cmd )
	self:CalcVtolThrottle( ply, cmd )
end

function ENT:GetThrustStrenght()
	local ForwardVelocity = self:WorldToLocal( self:GetPos() + self:GetVelocity() ).x

	return (self.MaxVelocity * self:GetThrottle() - ForwardVelocity) / self.MaxVelocity
end

function ENT:GetVehicleType()
	return "starfighter"
end

--addons/lvs_addons/lua/entities/lvs_base_turret/cl_hud.lua:
ENT.IconEngine = Material( "lvs/engine.png" )

function ENT:LVSHudPaintInfoText( X, Y, W, H, ScrX, ScrY, ply )
	local kmh = math.Round(self:GetVelocity():Length() * 0.09144,0)
	draw.DrawText( "km/h ", "LVS_FONT", X + 72, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( kmh, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, color_white, TEXT_ALIGN_LEFT )

	if ply ~= self:GetDriver() then return end

	--[[local Throttle = self:GetThrottle()
	local Col = Throttle <= 1 and color_white or Color(0,0,0,255)
	local hX = X + W - H * 0.5
	local hY = Y + H * 0.25 + H * 0.25

	surface.SetMaterial( self.IconEngine )
	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawTexturedRectRotated( hX + 4, hY + 1, H * 0.5, H * 0.5, 0 )
	surface.SetDrawColor( color_white )
	surface.DrawTexturedRectRotated( hX + 2, hY - 1, H * 0.5, H * 0.5, 0 )

	if not self:GetEngineActive() then
		draw.SimpleText( "X" , "LVS_FONT",  hX, hY, Color(0,0,0,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	self:LVSDrawCircle( hX, hY, H * 0.35, math.min( Throttle, 1 ) )

	if Throttle > 1 then
		draw.SimpleText( "+"..math.Round((Throttle - 1) * 100,0).."%" , "LVS_FONT",  hX, hY, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end]]
end

function ENT:LVSPreHudPaint( X, Y, ply )
	return true
end

function ENT:LVSHudPaint( X, Y, ply )
	if not self:LVSPreHudPaint( X, Y, ply ) then return end

	if ply ~= self:GetDriver() then return end

	local HitPlane = self:GetEyeTrace( true ).HitPos:ToScreen()
	local HitPilot = self:GetEyeTrace().HitPos:ToScreen()

	self:PaintCrosshairCenter( HitPlane )
	self:PaintCrosshairOuter( HitPilot )

	if ply:lvsMouseAim() and not ply:lvsKeyDown( "FREELOOK" ) then
		self:LVSHudPaintMouseAim( HitPlane, HitPilot )
	end

	self:LVSPaintHitMarker( HitPlane )
end

function ENT:LVSHudPaintDirectInput( Pos2D )
	self:PaintCrosshairCenter( Pos2D )
	self:PaintCrosshairOuter( Pos2D )
end

function ENT:LVSHudPaintMouseAim( HitPlane, HitPilot )
	local Sub = Vector(HitPilot.x,HitPilot.y,0) - Vector(HitPlane.x,HitPlane.y,0)
	local Len = Sub:Length()
	local Dir = Sub:GetNormalized()

	surface.SetDrawColor( 255, 255, 255, 100 )
	if Len > 20 then
		surface.DrawLine( HitPlane.x + Dir.x * 5, HitPlane.y + Dir.y * 5, HitPilot.x - Dir.x * 20, HitPilot.y- Dir.y * 20 )

		-- shadow
		surface.SetDrawColor( 0, 0, 0, 50 )
		surface.DrawLine( HitPlane.x + Dir.x * 5 + 1, HitPlane.y + Dir.y * 5 + 1, HitPilot.x - Dir.x * 20+ 1, HitPilot.y- Dir.y * 20 + 1 )
	end
end

--addons/lvs_addons/lua/entities/lvs_fakehover_barc/cl_init.lua:
include("shared.lua")


function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(-30,0,43) ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(-50,65,14) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(-85,-65,14) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

function ENT:OnFrame()
	self:BTLProjector()
	self:DamageFX()
end

function ENT:BTLProjector()
	local Fire = self:GetBTLFire()

	if Fire == self.OldFireBTL then return end

	self.OldFireBTL = Fire
	
	if Fire then
		local effectdata = EffectData()
		effectdata:SetEntity( self )
		util.Effect( "lvs_laat_left_projector", effectdata )
	end
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if ply == self:GetDriver() and not pod:GetThirdPersonMode() then
		return pos + self:GetForward() * 40 - self:GetUp() * 20, angles, fov
	end

	local GunnerPod = self:GetGunnerSeat()

	if pod == GunnerPod and pod:GetThirdPersonMode() then
		return GunnerPod:LocalToWorld( Vector(0,0,60) ), angles + Angle(6,0,0), fov
	end

	return pos, angles, fov
end

function ENT:RemoveLight()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end
end

function ENT:OnRemoved()
	self:RemoveLight()
end

function ENT:PreDraw()
	self:DrawDriverBTL()

	return true
end

ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.GlowMaterial = Material( "sprites/light_glow02_add" )

function ENT:PreDrawTranslucent()
	if self:GetBodygroup( 2 ) ~= 1 then 
		self:RemoveLight()
		return false
	end

	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 10 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( true ) 
		thelamp:SetFarZ( 2500 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 60 )
		self.projector = thelamp
	end

	local Start1 = self:LocalToWorld( Vector(64,6,10.5) )
	local Start2 = self:LocalToWorld( Vector(64,-6,10.5) )

	local Dir1 = self:LocalToWorldAngles( Angle(0,5,0) ):Forward()
	local Dir2 = self:LocalToWorldAngles( Angle(0,-5,0) ):Forward()

	render.SetMaterial( self.GlowMaterial )
	render.DrawSprite( Start1, 32, 32, Color( 100, 100, 100, 255) )
	render.DrawSprite( Start2, 32, 32, Color( 100, 100, 100, 255) )

	render.SetMaterial( self.LightMaterial )
	render.DrawBeam( Start1,  Start1 + Dir1 * 400, 150, 0, 0.99, Color( 100, 100, 100, 5) ) 
	render.DrawBeam( Start2,  Start2 + Dir2 * 400, 150, 0, 0.99, Color( 100, 100, 100, 5) ) 

	if IsValid( self.projector ) then
		self.projector:SetPos( self:LocalToWorld( Vector(60,0,10.5) ) )
		self.projector:SetAngles( self:LocalToWorldAngles( Angle(15,0,0) ) )
		self.projector:Update()
	end

	return false
end

local COLOR_RED = Color(255,0,0,255)
local COLOR_WHITE = Color(255,255,255,255)

function ENT:LVSPreHudPaint( X, Y, ply )
	if self:GetIsCarried() then return false end

	if ply == self:GetDriver() then
		local Col = self:WeaponsInRange() and COLOR_WHITE or COLOR_RED

		local Pos2D = self:GetEyeTrace().HitPos:ToScreen() 

		self:PaintCrosshairCenter( Pos2D, Col )
		self:PaintCrosshairOuter( Pos2D, Col )
		self:LVSPaintHitMarker( Pos2D )
	end

	return true
end

function ENT:DrawDriverBTL()
	local pod = self:GetGunnerSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if not IsValid( ply ) or (ply == plyL and plyL:GetViewEntity() == plyL and not pod:GetThirdPersonMode()) then return end

	if self:GetBodygroup(1) == 2 then
		ply:SetSequence( "sit_rollercoaster" )
		ply:SetRenderAngles( self:GetAngles() )
		ply:DrawModel()

		return
	end

	local ID = self:LookupAttachment( "muzzle_ballturret_left" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local _,Ang = LocalToWorld( Vector(0,0,0), Angle(-90,0,-90), Muzzle.Pos, Muzzle.Ang )

	local LAng = self:WorldToLocalAngles( Ang )
	LAng.p = 0
	LAng.r = 0

	ply:SetSequence( "sit_rollercoaster" )
	ply:SetRenderAngles( self:LocalToWorldAngles( LAng ) )
	ply:DrawModel()
end

--addons/lvs_addons/lua/entities/lvs_fakehover_iftx/cl_prediction.lua:

function ENT:PredictPoseParamaters()
	local pod = self:GetGunnerSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if ply ~= plyL then return end

	self:SetPoseParameterBTL( pod:lvsGetWeapon() )

	self:InvalidateBoneCache()
end
--addons/lvs_addons/lua/entities/lvs_laatle_patrolgunship_rep/cl_init.lua:
include("shared.lua")


ENT.LightGlow = Material( "sprites/light_glow02_add" )
ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )

function ENT:OnSpawn()
end

function ENT:OnFrame()
	self:AnimFins()
end

function ENT:StartWindSounds()
    self:StopWindSounds()

    if LocalPlayer():lvsGetVehicle() ~= self then return end

    self._WaterSFX = CreateSound( self, "LVS.Physics.Water" )
    self._WaterSFX:PlayEx(0,100)
end

function ENT:AnimFins()
end

function ENT:RemoveLight()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end
end

function ENT:OnRemoved()
	self:RemoveLight()
end

function ENT:PreDrawTranslucent()
	if self:GetSpotlightToggle() == false then 
		self:RemoveLight()
		return false
	end

	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 10 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( false ) 
		thelamp:SetFarZ( 5000 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 40 )
		self.projector = thelamp
	end

	local attachment = {
		Pos = Vector(170,0,30),
		Ang = Angle(135, 0, 0)
	}

	if attachment then
		local StartPos = self:LocalToWorld(attachment.Pos)
		local Dir = self:LocalToWorldAngles(attachment.Ang):Up()

		render.SetMaterial( self.LightGlow )
		render.DrawSprite( StartPos + Dir * 20, 200, 200, Color( 255, 255, 255, 255) )

		render.SetMaterial( self.LightMaterial )
		render.DrawBeam(  StartPos - Dir * 10,  StartPos + Dir * 1500, 350, 0, 0.99, Color( 255, 255, 255, 10) ) 
		
		if IsValid( self.projector ) then
			self.projector:SetPos( StartPos )
			self.projector:SetAngles( Dir:Angle() )
			self.projector:Update()
		end
	end

	return false
end

function ENT:CalcViewOverride(ply, pos, angles, fov, pod)

	if pod ~= self:GetDriverSeat() and pod ~= self:GetGunnerSeat() and not pod:GetThirdPersonMode() then
		return pod:LocalToWorld(Vector(0, 0, 68)), angles, fov
	end

	return pos, angles, fov
end 

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 0, 80, 255 )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "^lvs/vehicles/laat/boost_"..math.random(1,2)..".wav", 85 )
end

function ENT:OnStopBoost()
end
--addons/lvs_addons/lua/entities/lvs_repfighter_swtor/cl_init.lua:
include("shared.lua")

-- Engine Particles start

ENT.EngineColor = Color( 0, 195, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	Vector(-280,66.1,6.31),
	Vector(-280,-66.1,6.31),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-34,326,-13), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-34,-326,-13), 0, 20, 2, 1000, 150 )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 0, 195, 255)
	end
end

function ENT:OnFrame()
	self:EngineEffects()
end


-- Engine Particles End


function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost() * 2

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "ophra/ships/powerstart3.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "ophra/ships/shutdown.wav", 85 )
end


--addons/lvs_addons/lua/entities/lvs_repulsorlift_gunship/cl_init.lua:
include("shared.lua")
include( "sh_mainweapons.lua" )
include( "sh_ballturret_left.lua" )
include( "sh_ballturret_right.lua" )
include( "sh_wingturret.lua" )
include( "cl_drawing.lua" )
include( "cl_prediction.lua" )
include( "cl_lights.lua" )

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if pod == self:GetDriverSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 100, angles, fov
		end

		return pos, angles, fov
	end

	if pod:GetThirdPersonMode() then
		pos = ply:GetShootPos() + pod:GetUp() * 40
	else
		pos = pos + pod:GetUp() * 40
	end

	return pos, angles, fov
end

function ENT:OnSpawn()
end

function ENT:OnFrame()
	self:AnimRearHatch()
	self:AnimLights()
	self:WingTurretProjector()
	self:BTLProjector()
	self:BTRProjector()
	self:PredictPoseParamaters()
end

function ENT:BTRProjector()
	local Fire = self:GetBTRFire()
	if Fire == self.OldFireBTR then return end

	self.OldFireBTR = Fire

	if Fire then
		local effectdata = EffectData()
		effectdata:SetEntity( self )
		util.Effect( "lvs_laat_right_projector", effectdata )
	end
end
	
function ENT:BTLProjector()
	local Fire = self:GetBTLFire()

	if Fire == self.OldFireBTL then return end

	self.OldFireBTL = Fire
	
	if Fire then
		local effectdata = EffectData()
		effectdata:SetEntity( self )
		util.Effect( "lvs_laat_left_projector", effectdata )
	end
end

function ENT:WingTurretProjector()
	local FireWingTurret = self:GetWingTurretFire()

	if FireWingTurret == self.OldWingTurretFire then return end

	self.OldWingTurretFire = FireWingTurret

	if FireWingTurret then
		local effectdata = EffectData()
		effectdata:SetEntity( self )
		util.Effect( "lvs_laat_wing_projector", effectdata )
	end
end

function ENT:AnimRearHatch()
	local Tval = self:GetRearHatch() and 32 or 0
	local Rate = 50 * RealFrameTime()
	
	self.smRH = self.smRH and self.smRH + math.Clamp(Tval - self.smRH,-Rate,Rate) or 0

	if not self.HatchID then
		self.HatchID = self:LookupBone( "hatch" ) 
	else
		self:ManipulateBoneAngles( self.HatchID, Angle(0,-self.smRH,0) )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "^lvs/vehicles/laat/boost_"..math.random(1,2)..".wav", 85 )
end

function ENT:OnStopBoost()
end

--addons/lvs_addons/lua/entities/lvs_repulsorlift_gunship/cl_drawing.lua:

function ENT:PreDraw()
	self:DrawDriverBTL()
	self:DrawDriverBTR()

	return true
end

function ENT:DrawDriverBTL()
	local pod = self:GetBTPodL()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if not IsValid( ply ) or (ply == plyL and plyL:GetViewEntity() == plyL) then return end

	local ID = self:LookupAttachment( "muzzle_ballturret_left" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local _,Ang = LocalToWorld( Vector(0,0,0), Angle(-90,0,-90), Muzzle.Pos, Muzzle.Ang )

	ply:SetSequence( "drive_jeep" )
	ply:SetRenderAngles( Ang )
	ply:DrawModel()
end

function ENT:DrawDriverBTR()
	local pod = self:GetBTPodR()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if not IsValid( ply ) or (ply == plyL and plyL:GetViewEntity() == plyL) then return end

	local ID = self:LookupAttachment( "muzzle_ballturret_right" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local _,Ang = LocalToWorld( Vector(0,0,0), Angle(-90,0,-90), Muzzle.Pos, Muzzle.Ang )

	ply:SetSequence( "drive_jeep" )
	ply:SetRenderAngles( Ang )
	ply:DrawModel()
end
--addons/laat_g/lua/entities/lvs_repulsorlift_gunship_heavy/sh_wingturret.lua:

function ENT:SetNextRearGunFire( delay )
	self._NextRGFire = CurTime() + delay
end

function ENT:CanFireRearGun()
	return (self._NextRGFire or 0) < CurTime()
end

function ENT:GetRearGunInRange( ent )
	return ent:AngleBetweenNormal( ent:GetAimVector(), -ent:GetForward() ) < 35
end

function ENT:HandleRearGun( ent, ShouldFire )
	local trace = ent:GetEyeTrace()

	local Pos,Ang = WorldToLocal( Vector(0,0,0), (trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,180,0) ) )

	if not self:GetRearGunInRange( ent ) then 
		self:SetPoseParameter("reargun_yaw", 0 )

		return false
	end

	self:SetPoseParameter("reargun_pitch", -Ang.p )
	self:SetPoseParameter("reargun_yaw", -Ang.y )

	if not ShouldFire or not self:CanFireRearGun() then self:GetRearGunInRange( ent ) return end

	local ID = self:LookupAttachment( "muzzle_reargun" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return self:GetRearGunInRange( ent ) end

	self:SetNextRearGunFire( 0.3 )

	local bullet = {}
	bullet.Src 	= Muzzle.Pos
	bullet.Dir 	= (trace.HitPos - Muzzle.Pos):GetNormalized()
	bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
	bullet.TracerName = "lvs_laser_green_short"
	bullet.Force	= 10
	bullet.HullSize 	= 25
	bullet.Damage	= 60
	bullet.Velocity = 30000
	bullet.Attacker 	= ent:GetDriver()
	bullet.Callback = function(att, tr, dmginfo)
		local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) ) 
			effectdata:SetOrigin( tr.HitPos )
			effectdata:SetNormal( tr.HitNormal )
		util.Effect( "lvs_laser_impact", effectdata )
	end
	ent:LVSFireBullet( bullet )

	local NewHeat = ent:GetHeat() + 0.25


	ent:SetHeat( NewHeat )
	if NewHeat >= 1 then
		ent:SetOverheated( true )
	end

	if not IsValid( self.SNDTail ) then return end

	self.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
end

function ENT:InitWeaponGunner()
	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)
	local MaxRange = 60
	local MaxTailRange = 35

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.StartAttack = function( ent )
		ent.ShouldFire = true
	end
	weapon.FinishAttack = function( ent )
		ent.ShouldFire = false

		local base = ent:GetVehicle()

		local snd = {
			[-1] = base.WingLeftSND,
			[1] = base.WingRightSND,
		}

		for _, sound in pairs( snd ) do
			if not IsValid( sound ) then continue end

			sound:Stop()
		end
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		local ShouldFire = (ent.ShouldFire == true) and ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) < MaxRange
	
		if base:HandleRearGun( ent, ent.ShouldFire ) then
			ShouldFire = false
		end

		if base:SetWingTurretFire() ~= ShouldFire then
			base:SetWingTurretFire( ShouldFire ) 
		end

		local snd = {
			[-1] = base.WingLeftSND,
			[1] = base.WingRightSND,
		}

		if ent._oldShouldFire ~= ShouldFire then
			ent._oldShouldFire = ShouldFire
			if ShouldFire then
				for _, sound in pairs( snd ) do
					if not IsValid( sound ) then continue end

					sound:EmitSound( "lvs/vehicles/laat/ballturret_fire.mp3", 110 )
				end
			end
		end

		if not ShouldFire then
			for _, sound in pairs( snd ) do
				if not IsValid( sound ) then continue end
				sound:Stop()
			end

			ent:SetHeat( ent:GetHeat() - FrameTime() )

			return
		end
	
		if not active then
			return
		end

		local trace = ent:GetEyeTrace()
		local DesEndPos = trace.HitPos

		base:SetWingTurretTarget( DesEndPos )

		if not base:GetWingTurretFire() then return end

		local DesStartPos

		if base:WorldToLocal( DesEndPos ).z < 0 then
			DesStartPos = Vector(-172.97,334.04,93.25)
		else
			DesStartPos = Vector(-174.79,350.05,125.98)
		end

		local NewHeat = ent:GetHeat()

		for i = -1,1,2 do
			local StartPos = self:LocalToWorld( DesStartPos * Vector(1,i,1) )
			local beam = util.TraceLine( { start = StartPos, endpos = DesEndPos} )

			self:BallturretDamage( beam.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - StartPos):GetNormalized() )

			if not IsValid( snd[i] ) then continue end

			if beam.Entity ~= base then
				snd[i]:Play()
				NewHeat = NewHeat + FrameTime() * 0.25
			else
				snd[i]:Stop()
			end
		end

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local radius = 800
		radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )

		local StartPos = base:LocalToWorld( base:OBBCenter() ) + clamped_angles :Up() * (250 + radius * pod:GetCameraHeight())
		local EndPos = StartPos - clamped_angles:Forward() * radius

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "player" ) and not e.LVS
				
				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.drawviewer = true
		view.origin = tr.HitPos

		if tr.Hit and not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local WingInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= MaxRange
		local RearGunInRange = not base:GetRearGunInRange( ent )

		local Col = (WingInRange and RearGunInRange) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end
--addons/lvs_addons/lua/entities/lvs_sithfighter_swtor/cl_init.lua:
include("shared.lua")

-- Engine Particles start

ENT.EngineColor = Color( 0, 195, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	Vector(-163.81,57,8.36),
	Vector(-163.81,-57,8.36),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-34,326,-13), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-34,-326,-13), 0, 20, 2, 1000, 150 )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 0, 195, 255)
	end
end

function ENT:OnFrame()
	self:EngineEffects()
end


-- Engine Particles End


function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost() * 2

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "ophra/ships/powerstart3.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "ophra/ships/shutdown.wav", 85 )
end

--lua/entities/lvs_space_laat/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.nextEFX = 0
	self.nextDFX = 0
	self.nextBeepSound = 0
	self.nextLFX = 0
	self.NextAlertSound = 0
	--self.ActiveTime = CurTime()
	self.bommed = false
	self.onact = false
end


local spotlight = Material("effects/lvs/laat_spotlight")
local glow_spotlight = Material("sprites/light_glow02_add")
local spotlight_color = Color(255, 255, 255)
local glow_color = Color(255, 255, 255, 10)
local glow_reactor = Material("sprites/light_glow02_add")
local lamp_pos = Vector(3, 0, 135)
local lamp_color_black = Color(0, 0, 0)
local lamp_color_red = Color(255, 0, 0)
local lamp_color_green = Color(0, 255, 0)
local reactor_color = Color(0, 127, 255)
local reactor_pos = {
	Vector(-270, -20, 265),
	Vector(-270, 20, 265),
}

ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.LightGlow = Material( "sprites/light_glow02_add" )
ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.Red = Color( 255, 0, 0, 255)
ENT.SignalSprite = Material( "sprites/light_glow02_add" )
ENT.Spotlight = Material( "effects/lvs/spotlight_projectorbeam" )

ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.GlowMaterial = Material( "sprites/light_glow02_add" )

ENT.EngineColor = Color( 255, 220, 150, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EngineCenter = Material( "vgui/circle" )
ENT.EnginePos = {
	[1] = Vector(-155,0,76.85),
	[2] = Vector(-155,0,41.82),
}

function ENT:WingTurretProjector()
	local FireWingTurret = self:GetWingTurretFire()

	if FireWingTurret == self.OldWingTurretFire then return end

	self.OldWingTurretFire = FireWingTurret

	if FireWingTurret then
		local effectdata = EffectData()
		effectdata:SetEntity( self )
		util.Effect( "lfs_fb_wingturret_projector", effectdata )
	end
end



function ENT:OnFrame()
	self:Boom()

	self:WingTurretProjector()

	self:ENGCheck()

	self:DamageFX()

	self:ExhaustFX()

end

function ENT:Boom()
	if self:GetHP() > 2200 then
		self.bommed = false
		self:StopParticles()
	end
	if self.bommed == false then
		if self:GetHP() < 2200 then
			ParticleEffectAttach("env_fire_large_smoke", PATTACH_POINT_FOLLOW, self, self:LookupAttachment("R_Heat_Hatch"))
			self.bommed = true
			local effectdata = EffectData()
				effectdata:SetOrigin(self:LocalToWorld(Vector(-300, 0, 180)))
			util.Effect("lvs_explosion_small", effectdata)
		end
	end
end

function ENT:ENGCheck()
	if self.onact == false then
		if self:GetEngineActive() == true then
			self.ActiveTime = CurTime()
			self.onact = true
			self.nextEFX = CurTime() + 1
		end
	end
	if self.onact == true then
		if self:GetEngineActive() == false then
			self.onact = false
			self.StopTime = CurTime()
		end
	end
	if self:GetEngineActive() == false then
		self.onact = false
	end
end

function ENT:ExhaustFX()
	local FullThrottle = self:GetThrottle() >= 35

	if self.OldFullThrottle ~= FullThrottle then
		self.OldFullThrottle = FullThrottle
		if FullThrottle then 
			self:EmitSound("laat_bf2/boost_"..math.random(1, 2)..".wav")
		end
	end

	if self:GetEngineActive() then
		if self.nextEFX < CurTime() then
			self.nextEFX = CurTime() + 0.01
			
			local emitter = ParticleEmitter(self:GetPos(), false)
			local Pos = {
				Vector(-270, -20, 265),
				Vector(-270, 20, 265),
			}

			if emitter then
				for _, v in pairs(Pos) do
					local vOffset = self:LocalToWorld( v )
					local vNormal = -self:GetForward()
					local vOffset2 = vOffset + vNormal * 5

					local particle = emitter:Add("sprites/heatwave", vOffset2)
					if not particle then return end
						particle:SetVelocity(vNormal * math.Rand(1500, 1000) + self:GetVelocity())
						particle:SetLifeTime(0)
						particle:SetDieTime(0.1)
						particle:SetStartAlpha(255)
						particle:SetEndAlpha(0)
						particle:SetStartSize(math.Rand(35, 50))
						particle:SetEndSize(math.Rand(0, 5))
						particle:SetRoll(math.Rand(-1, 1) * 100)
						particle:SetColor(255, 255, 255)
				end
				
				emitter:Finish()
			end
		end
	end
end

function ENT:CanSound()
	self.NextSound = self.NextSound or 0
	return self.NextSound < CurTime()
end

function ENT:CanSound2()
	self.NextSound2 = self.NextSound2 or 0
	return self.NextSound2 < CurTime()
end

function ENT:DelayNextSound( fDelay )
	if not isnumber( fDelay ) then return end
	
	self.NextSound = CurTime() + fDelay
end

function ENT:DelayNextSound2( fDelay )
	if not isnumber( fDelay ) then return end
	
	self.NextSound2 = CurTime() + fDelay
end

function ENT:CalcEngineSound( RPM, Pitch, Doppler )
	if self.ENG then
		self.ENG:ChangePitch(math.Clamp(math.Clamp(80 + Pitch * 25, 50, 255) + Doppler, 0, 255))
		self.ENG:ChangeVolume(math.Clamp(-1 + Pitch * 6, 0.5, 1))
	end
	
	if self.DIST then
		local ply = LocalPlayer()
		local DistMul = math.min((self:GetPos() - ply:GetPos()):Length() / 8000, 1) ^ 2
		self.DIST:ChangePitch(math.Clamp(100 + Doppler * 0.2, 0, 255))
		self.DIST:ChangeVolume(math.Clamp(-1.5 + Pitch * 6, 0.5, 1) * DistMul)
	end
end

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP <= 0 or HP > self:GetMaxHP() * 0.5 then return end

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05
		
		local effectdata = EffectData()
			effectdata:SetOrigin(self:LocalToWorld(Vector(-280, 0, 250)))
		util.Effect("lfs_blacksmoke", effectdata)
		local effectdata = EffectData()
			effectdata:SetOrigin(self:LocalToWorld(Vector(-280, 0, 250)))
		util.Effect("lfs_blacksmoke", effectdata)
		local effectdata = EffectData()
			effectdata:SetOrigin(self:LocalToWorld(Vector(-280, 0, 250)))
		util.Effect("lfs_blacksmoke", effectdata)

		if HP <= 2200 then
			if math.random(0, 45) < 3 then
				if math.random(1, 3) == 1 then
					local Pos = self:LocalToWorld(Vector(0, 0, 140) + VectorRand() * 20)
						effectdata:SetOrigin(Pos)
					util.Effect("cball_explode", effectdata, true, true)
					sound.Play("laat_bf2/spark"..math.random(1, 4)..".ogg", Pos, 75)
				end
			end

			local ply = LocalPlayer()
			if self.NextAlertSound < CurTime() then
				self.NextAlertSound = CurTime() + 0.27
				self:EmitSound( "laat_bf2/crash.mp3", 85 )

				--sound.Play("laat_bf2/crash.mp3", self:GetPos() + self:GetForward() * 190 + self:GetUp() * 160, 75)
			end
		end
	end
end



function ENT:Draw()
	self:DrawModel()

	if self:GetEngineActive() then
		render.SetMaterial(glow_reactor)
		local delta = CurTime() - self.ActiveTime
		local max = math.min(15 * ( delta / 1 ), 15)

		local t = 0
		for _, v in pairs(reactor_pos) do
			if self:GetHP() < 2200 then
				if self.nextLFX > CurTime() && t == 1 then continue end
				self.nextLFX = CurTime() + math.random(0, 2)
			end

			local vOffset = self:LocalToWorld(v)
			local vNormal = -self:GetForward()
			
			for i = 0, max do 
				local vUp = -self:GetUp()
				local ind = i * 2
				local vOffsetTmp = vOffset + vNormal * -2 + vUp * ind + vNormal * ind

				render.DrawSprite(vOffsetTmp, 60, 60, reactor_color)
			end

			t = t + 1
		end
	else
		if self:GetHP() < 2200 then
			if self.nextLFX <= CurTime() then 
				self.nextLFX = CurTime() + math.random(0, 1)

				render.SetMaterial(glow_reactor)

				local vOffset = self:LocalToWorld(reactor_pos[2])
				local vNormal = -self:GetForward()
				
				for i = 0, 15 do 
					local vUp = -self:GetUp()
					local ind = i * 2
					local vOffsetTmp = vOffset + vNormal * -2 + vUp * ind + vNormal * ind

					render.DrawSprite(vOffsetTmp, 60, 60, reactor_color)
				end
			end
			
		end
		if self:GetHP() < 2200 then
			if self.nextLFX <= CurTime() then 
				self.nextLFX = CurTime() + math.random(0, 2)

				render.SetMaterial(glow_reactor)

				local vOffset = self:LocalToWorld(reactor_pos[1])
				local vNormal = -self:GetForward()
				
				for i = 0, 15 do 
					local vUp = -self:GetUp()
					local ind = i * 2
					local vOffsetTmp = vOffset + vNormal * -2 + vUp * ind + vNormal * ind

					render.DrawSprite(vOffsetTmp, 60, 60, reactor_color)
				end
			end
		end
	end
	local StartPos = self:LocalToWorld(lamp_pos)
	render.SetMaterial(glow_spotlight)
	local lamp_mode = self:GetLampMode()
	render.DrawSprite(StartPos, 80, 80, lamp_mode == 0 && lamp_color_black || lamp_mode == 1 && lamp_color_red || lamp_color_green)

	if not self:IsSpotlightMounted() or not self:GetSpotlightOn() or not self:GetEngineActive() then 
		self:RemoveLight()
		return
	end

	if not IsValid(self.projector_L) then
		self.projector_L, self.projector_LID = self:CreateSpotlight(), self:LookupAttachment("L_Spotlight_End")
	end

	self:UpdateSpotlight(self.projector_L, self.projector_LID)

	if not IsValid(self.projector_R) then
		self.projector_R, self.projector_RID = self:CreateSpotlight(), self:LookupAttachment("R_Spotlight_End")
	end

	self:UpdateSpotlight(self.projector_R, self.projector_RID)
end

function ENT:OnRemove()
	self:RemoveLight()
	self:RemoveLight2()
end

function ENT:RemoveLight2()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end

	if IsValid( self.frojector ) then
		self.frojector:Remove()
		self.frojector = nil
	end
end

function ENT:RemoveLight()
	if IsValid( self.projector_L ) then
		self.projector_L:Remove()
		self.projector_L = nil
	end

	if IsValid( self.projector_R ) then
		self.projector_R:Remove()
		self.projector_R = nil
	end
end

function ENT:UpdateSpotlight(ent, attachmentID)
	local muzzle = self:GetAttachment(attachmentID)
	local StartPos = muzzle.Pos
	local Dir = muzzle.Ang:Right()

	render.SetMaterial(glow_spotlight)
	render.DrawSprite(StartPos + Dir * 20, 400, 400, spotlight_color)

	render.SetMaterial(spotlight)
	render.DrawBeam(StartPos - Dir * 10, StartPos + Dir * 1500, 350, 0, 0.99, glow_color) 
	
	if IsValid(ent) then
		ent:SetPos(StartPos)
		ent:SetAngles(Dir:Angle())
		ent:Update()
	end
end

function ENT:CreateSpotlight()
	local spotlight = ProjectedTexture()
		spotlight:SetBrightness(10) 
		spotlight:SetTexture("effects/flashlight/soft")
		spotlight:SetColor(spotlight_color) 
		spotlight:SetEnableShadows(false) 
		spotlight:SetFarZ(5000) 
		spotlight:SetNearZ(75) 
		spotlight:SetFOV(40)
	
	return spotlight
end

function ENT:OnSpawn()

end

--[[


function ENT:EngineEffects()
	if not self:GetEngineActive() then return end
end

function ENT:PostDraw()
	if not self:GetEngineActive() then return end
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end
end
]]--
function ENT:OnStartBoost()
	self:EmitSound( "laat_bf2/boost_"..math.random(1, 2)..".wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vwing/brake.wav", 85 )
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if pod == self:GetDriverSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 100, angles, fov
		end

		return pos, angles, fov
	end

	if pod == self:GetGunnerSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 100, angles, fov
		end

		return pos, angles, fov
	end

	if pod:GetThirdPersonMode() then
		pos = ply:GetShootPos() + pod:GetUp() * 40
	else
		pos = pos + pod:GetUp() * 40
	end

	return pos, angles, fov
end

--[[
function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if pod == self:GetDriverSeat() or self:GetGunnerSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 100, angles, fov
		end

		return pos, angles, fov
	end

	if pod:GetThirdPersonMode() then
		pos = ply:GetShootPos() + pod:GetUp() * 40
	else
		pos = pos + pod:GetUp() * 40
	end

	return pos, angles, fov
end]]

function ENT:PreDrawTranslucent()
	if self:GetSpotlightToggle() == false then 
		self:RemoveLight2()
		return false
	end

	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 20 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( false ) 
		thelamp:SetFarZ( 4000 ) 
		thelamp:SetNearZ( 1 ) 
		thelamp:SetFOV( 80 )
		self.projector = thelamp
	end

	local attachment = {
		Pos = Vector(332.26,-2.1,5.41),
		Ang = Angle(135.25,-0.01,0.71)
	}

	if attachment then
		local StartPos = self:LocalToWorld(attachment.Pos)
		local Dir = self:LocalToWorldAngles(attachment.Ang):Up()

		render.SetMaterial( self.LightGlow )
		render.DrawSprite( StartPos + Dir * 0, 20, 20, Color( 255, 255, 255, 255) )

		render.SetMaterial( self.LightMaterial )
		render.DrawBeam(  StartPos - Dir * 0,  StartPos + Dir * 100, 90, 0, 1, Color( 255, 255, 255, 12) ) 
		
		if IsValid( self.projector ) then
			self.projector:SetPos( StartPos )
			self.projector:SetAngles( Dir:Angle() )
			self.projector:Update()
		end
	end

	return false
end
--lua/entities/lvs_space_laat_arc/shared.lua:

ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "LAAT-I Muunilinst 10"
ENT.Author = "Dec"
ENT.Information = "ARC version of the LAAT"
ENT.Category = "[LVS] SW-Vehicles"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Starfighters"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/fisher/laat/laatspacem10.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.DamageSounds = {
	"physics/metal/metal_sheet_impact_bullet2.wav",
	"physics/metal/metal_sheet_impact_hard2.wav",
	"physics/metal/metal_sheet_impact_hard6.wav",
}

ENT.AITEAM = 2

ENT.MaxVelocity = 2850
ENT.MaxThrust = 2850

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1.25

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 6500
ENT.MaxShield = 0

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "WingTurretFire" )
	self:AddDT( "Vector", "WingTurretTarget" )
	self:NetworkVar( "Int", 23, "LampMode" )
	self:AddDT( "Float", "Activetime" )
	self:AddDT( "Bool", "Foils" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Entity", "SecondGunnerSeat" )
	self:NetworkVar( "Bool", 24, "SpotlightOn" )
	self:AddDT( "Bool", "SpotlightToggle" )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "laat_bf2/laat_takeoff.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

function ENT:CalcMainActivity( ply )
	local Pod = ply:GetVehicle()

	if Pod == self:GetDriverSeat() or Pod == self:GetGunnerSeat() then return end

	ply.CalcIdeal = ACT_STAND
	ply.CalcSeqOverride = ply:LookupSequence( "idle_all_02" )

	if ply:GetAllowWeaponsInVehicle() and IsValid( ply:GetActiveWeapon() ) then

		local holdtype = ply:GetActiveWeapon():GetHoldType()

		if holdtype == "smg" then 
			holdtype = "smg1"
		end

		local seqid = ply:LookupSequence( "idle_" .. holdtype )

		if seqid ~= -1 then
			ply.CalcSeqOverride = seqid
		end
	end

	return ply.CalcIdeal, ply.CalcSeqOverride
end

ENT.EngineSounds = {
	{
		sound = "laat_bf2/engine_loop.mp3",
		Pitch = 90,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 85,
	},
	{
		sound = "laat_bf2/laat_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 75,
	},
}

sound.Add( {
	name = "LAAT_FIREMISSILE",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 125,
	pitch = {95, 105},
	sound = "laat_bf2/rocket_shot.mp3"
} )


function ENT:SetNextRearGunFire( delay )
	self._NextRGFire = CurTime() + delay
end

function ENT:CanFireRearGun()
	return (self._NextRGFire or 0) < CurTime()
end

function ENT:GetRearGunInRange( ent )
	return ent:AngleBetweenNormal( ent:GetAimVector(), -ent:GetForward() ) < 35
end

function ENT:HandleRearGun( ent, ShouldFire )

	local trace = ent:GetEyeTrace()

	local Pos,Ang = WorldToLocal( Vector(100,0,0), (trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,180,0) ) )

	if not self:GetRearGunInRange( ent ) then 
		self:SetPoseParameter("back_turret_y", 0 )

		return false
	end

	self:SetPoseParameter("back_turret_z", Ang.p )
	self:SetPoseParameter("back_turret_y", -Ang.y )

	if not ShouldFire or not self:CanFireRearGun() then self:GetRearGunInRange( ent ) return end

	local startpos = self:GetBonePosition(self:LookupBone("Rear_Gun_End"))

	self:SetNextRearGunFire( 0.2 )

	local bullet = {}
	bullet.Src 	= ent:LocalToWorld( Vector(-500,0 ,-20) )
	bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
	bullet.Spread 	= Vector( 0.03,  0.03, 0.03 )
	bullet.TracerName = "lvs_laser_blue_short"
	bullet.Force	= 10
	bullet.HullSize 	= 25
	bullet.Damage	= 65
	bullet.Velocity = 20000
	bullet.Attacker 	= ent:GetDriver()
	bullet.Callback = function(att, tr, dmginfo)
		local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) ) 
			effectdata:SetOrigin( tr.HitPos )
			effectdata:SetNormal( tr.HitNormal )
		util.Effect( "lvs_laser_impact", effectdata )
	end
	ent:LVSFireBullet( bullet )

	local NewHeat = ent:GetHeat() + 0.2


	ent:SetHeat( NewHeat )
	if NewHeat >= 1 then
		ent:SetOverheated( true )
	end

	if not IsValid( self.SNDTail ) then return end

	self.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
end

function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( Vector(100,0,103) )
	end

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:InitWeapons()
	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)
	local MaxRange = 60
	local MaxTailRange = 35

	self.lor = 1

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 600
	weapon.Delay = 0.18
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.1
	weapon.Attack = function( ent )
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		if ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= 20 then return true end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = ent:GetEyeTrace()

		local bullet = {}
		bullet.Spread 	= Vector( 0.02,  0.02, 0.02 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 60
		bullet.SplashDamage = 200
		bullet.SplashDamageRadius = 200
		bullet.Velocity = 28000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
	
		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld( Vector(320,32 * i,37) )
			bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
				
			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )
		local trace = ent:GetEyeTrace()

		local AimAngles = ent:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld(  Vector(256,0,36) ) ):GetNormalized():Angle() )

		ent.frontgunYaw = -AimAngles.y

		if math.abs( ent.frontgunYaw ) > 100 then
			ent:SetPoseParameter("Front_Turret_Z", 0 )
			ent:SetPoseParameter("Front_Turret_Y", 0 )

			return
		end

		ent:SetPoseParameter("Front_Turret_Z", AimAngles.p )
		ent:SetPoseParameter("Front_Turret_Y", -AimAngles.y )
	end
	self:AddWeapon( weapon )

	self:AddWeapon( LVS:GetWeaponPreset( "TURBO" ) )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0.4
	weapon.HeatRateDown = 0
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.StartAttack = function( ent )
		ent.ShouldFire = true
	end
	weapon.FinishAttack = function( ent )
		ent.ShouldFire = false

		local base = ent:GetVehicle()

		local snd = {
			[-1] = base.WingLeftSND,
			[1] = base.WingRightSND,
		}

		for _, sound in pairs( snd ) do
			if not IsValid( sound ) then continue end

			sound:Stop()
		end
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		local ShouldFire = (ent.ShouldFire == true) and ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) < MaxRange
	
		if base:HandleRearGun( ent, ent.ShouldFire ) then
			ShouldFire = false
		end

		if base:SetWingTurretFire() ~= ShouldFire then
			base:SetWingTurretFire( ShouldFire ) 
		end

		local snd = {
			[-1] = base.WingLeftSND,
			[1] = base.WingRightSND,
		}

		if ent._oldShouldFire ~= ShouldFire then
			ent._oldShouldFire = ShouldFire
			if ShouldFire then
				for _, sound in pairs( snd ) do
					if not IsValid( sound ) then continue end

					sound:EmitSound( "lvs/vehicles/laat/ballturret_fire.mp3", 110 )
				end
			end
		end

		if not ShouldFire then
			for _, sound in pairs( snd ) do
				if not IsValid( sound ) then continue end
				sound:Stop()
			end

			ent:SetHeat( ent:GetHeat() - FrameTime() )

			return
		end
	
		if not active then
			return
		end

		local trace = ent:GetEyeTrace()
		local DesEndPos = trace.HitPos

		base:SetWingTurretTarget( DesEndPos )

		if not base:GetWingTurretFire() then return end
		
		local DesStartPos --= Vector(-55, 350, 90)

		if base:WorldToLocal( DesEndPos ).z < 0 then
			DesStartPos = Vector(-55, 350, 90)
		else
			DesStartPos = Vector(-55, 370, 125)
		end

		local NewHeat = ent:GetHeat()

		for i = -1,1,2 do
			local StartPos = self:LocalToWorld( DesStartPos * Vector(1,i,1)  )
			local beam = util.TraceLine( { start = StartPos, endpos = DesEndPos} )

			self:BallturretDamage( beam.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - StartPos):GetNormalized() )

			if not IsValid( snd[i] ) then continue end

			if beam.Entity ~= base then
				snd[i]:Play()
				NewHeat = NewHeat + FrameTime() * 0.25
			else
				snd[i]:Stop()
			end
		end

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local radius = 800
		radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )

		local StartPos = base:LocalToWorld( base:OBBCenter() ) + clamped_angles :Up() * (350 + radius * pod:GetCameraHeight())
		local EndPos = StartPos - clamped_angles:Forward() * radius

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "player" ) and not e.LVS
				
				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.drawviewer = true
		view.origin = tr.HitPos

		if tr.Hit and not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local WingInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= MaxRange
		local RearGunInRange = not base:GetRearGunInRange( ent )

		local Col = (WingInRange and RearGunInRange) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 10
	weapon.Delay = 0 
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )

		local T = CurTime()
		local pos = 0
		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if self.lor == 1 then
			pos = Vector(-63.81,-263.11,132.86)
			self.lor = 2
		else
			pos = Vector(-65.8,271.86,131.86)
			self.lor = 1
		end

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( self:LocalToWorld( pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetDamage( 1250 )
		projectile:SetRadius( 350 )
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.2 )
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local WingInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= MaxRange
		local RearGunInRange = not base:GetRearGunInRange( ent )

		local Col = (WingInRange and RearGunInRange) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 40
	weapon.Delay = 2
	weapon.HeatRateUp = 1 
	weapon.HeatRateDown = 0.08
	weapon.Attack = function( ent )


		--if not ent:WeaponsInRange() then return true end
		local veh = ent:GetVehicle()
		local Driver = ent:GetDriver()

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()

		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 100 then return true end

		for i = 1, 2 do
			timer.Simple( (i / 7) * 0.1, function()
				if not IsValid( ent ) then return end


				if self.lor == 1 then
					pos = Vector(99.71,69.93,276.31)
					self.lor = 2
				else
					pos = Vector(88.08,-69.92,276.24)
					self.lor = 1
				end

				if ent:GetAmmo() <= 0 then ent:SetHeat( 1 ) return end
	
				ent:TakeAmmo()

				local trace = ent:GetEyeTrace()
				local Start = pos
				local Dir = (ent:GetEyeTrace().HitPos - veh:LocalToWorld(Start)):GetNormalized()
				local projectile = ents.Create( "lvs_protontorpedo" )
				projectile:SetPos(veh:LocalToWorld(Start))
				projectile:SetAngles( ent:GetAngles() )
				projectile:SetParent( )
				projectile:Spawn()
				projectile:Activate()
				projectile.GetTarget = function( missile ) return missile end
				projectile.GetTargetPos = function( missile )
					return missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-5,5) )
				end
				projectile:SetAttacker( IsValid( Driver ) and Driver or self )
				projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
				projectile:SetDamage( 1250 )
				projectile:SetRadius( 550 )
				projectile:Enable()
				projectile:EmitSound("LAAT_FIREMISSILE" )
			end)
			self.RocketsModel:ResetSequence("Load_Missile")

		end
	end
	weapon.FinishAttack = function( ent )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()
	
		if not IsValid( base ) then return end
	
		local WingInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= MaxRange
		local RearGunInRange = not base:GetRearGunInRange( ent )
	
		local Col = (WingInRange and RearGunInRange) and COLOR_RED or COLOR_WHITE
	
		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 
	
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon, 2 )
	
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/bomb.png")
	weapon.Ammo = 15
	weapon.Delay = 0.5 
	weapon.HeatRateUp = 0.5 
	weapon.HeatRateDown = .1
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.Attack = function( ent )
		local Pos 	= self:GetPos() + Vector(0,  0, -50 )
		
		local laatbomb = ents.Create( "laat_detonator" )
		laatbomb:SetPos(Pos)
		laatbomb:SetAngles( ent:GetAngles() )
		laatbomb:SetParent()
		laatbomb:Spawn()
		laatbomb:Activate()
	
		
		
		
		ent:TakeAmmo()
	end
	weapon.OnThink = function( ent, active )
	end

	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.1
	weapon.StartAttack = function( ent )
		if (self.gateDown) then
			self.gateDown = false
			self:SetBodygroup(7, 0)
		else
			self:SetBodygroup(7, 1)
			self.gateDown = true
		end
	end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.1
	weapon.StartAttack = function( ent )
		if (self.gateDown) then
			self.gateDown = false
			self:SetSpotlightOn(false)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		else
			self:SetSpotlightOn(true)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
			self.gateDown = true
		end
	end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_reardoor.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.3
	weapon.StartAttack = function( ent )
		if self:GetAI() == true then return end
		self:ToggleHatch()
	end
	self:AddWeapon( weapon, 3 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dropship_grabber.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.1
	weapon.StartAttack = function( ent )
		if self:GetAI() == true then return end
		if (self.gateDown) then
			self.gateDown = false
			self:DropHeldEntity()
		else
			self:GrabEntity()
			self.gateDown = true
		end
	end
	self:AddWeapon( weapon, 3 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_sidedoor.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.3
	weapon.StartAttack = function( ent )
		if self:GetAI() == true then return end
		self:DoorOC()
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		if self:GetSpotlightToggle() == true then
			self:SetSpotlightToggle(false)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		else
			self:SetSpotlightToggle(true)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
end

function ENT:IsSpotlightMounted()
	return self:GetBodygroup(7) == 1
end

--addons/lvs_addons/lua/entities/lvs_starfighter_ig2000/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "IG-2000"
ENT.Author = "Nashatok"
ENT.Information = "Modified Aggressor-class Assault Fighter, used by bounty hunter and assassin IG-88B"
ENT.Category = "[LVS] - Star Wars"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.SpawnNormalOffset = -25

ENT.MDL = "models/ig2000/sfp_ig2000.mdl"

ENT.AITEAM = 1

ENT.MaxVelocity = 2500
ENT.MaxThrust = 2500

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 500
ENT.MaxShield = 100

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 600
	weapon.Delay = 0.12
	weapon.HeatRateUp = 0.34
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld( Vector(280,90 * i,100) )

			local effectdata = EffectData()
			effectdata:SetStart( Vector(255,50,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	--Weapon 2 - Ion Cannon
	local weapon = {}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/bullet.png")
	weapon.Ammo = 250
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.6
	weapon.HeatRateDown = 0.5
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( Vector(120,0,60) )
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 10
		bullet.HullSize 	= 15
		bullet.Damage	= 30
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,250) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "cball_bounce", effectdata )
		end

		ent:LVSFireBullet( bullet )

		ent:TakeAmmo( 1 )
		ent.SecondarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
end

ENT.FlyByAdvance = 0.75
ENT.FlyBySound = "lvs/vehicles/naboo_n1_starfighter/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/naboo_n1_starfighter/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_n1/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "N1 Starfighter"
ENT.Author = "Luna"
ENT.Information = "Starfighter of the Royal Naboo Security Force"
ENT.Category = "[LVS] - Star Wars"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Starfighters"

ENT.MDL = "models/blu/naboostarfighter.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxVelocity = 3000
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 500
ENT.MaxShield = 100

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 400
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 40
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld( Vector(118.24,18.04 * i,49.96) )

			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) end
	self:AddWeapon( weapon )


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 8
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		local Driver = ent:GetDriver()

		local projectile = ents.Create( "lvs_protontorpedo" )
		projectile:SetPos( ent:LocalToWorld( Vector(147.82,0,39.52) ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
end

ENT.FlyByAdvance = 0.75
ENT.FlyBySound = "lvs/vehicles/naboo_n1_starfighter/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/naboo_n1_starfighter/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 90,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_scyk/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-30,220,82), 0, 20, 2, 600, 150 )
	self:RegisterTrail( Vector(-30,-220,82), 0, 20, 2, 600, 150 )
	
	self:RegisterTrail( Vector(-450,75,110), 0, 20, 2, 500, 150 )
	self:RegisterTrail( Vector(-450,-75,110), 0, 20, 2, 500, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
end

function ENT:PostDrawTranslucent()
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01
	
		local emitter = ParticleEmitter( self:GetPos(), false )
		local Pos = {
			Vector(-250,0,75),
			}

		if emitter then
			for _, v in pairs( Pos ) do
				local Sub = Mirror and 1 or -1
				local vOffset = self:LocalToWorld( v )
				local vNormal = -self:GetForward()

				vOffset = vOffset + vNormal * 5

				local particle = emitter:Add( "sprites/heatwave", vOffset )
				if not particle then return end

				particle:SetVelocity( vNormal * math.Rand(1500,1000) + self:GetVelocity() )
				particle:SetLifeTime( 0 )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( 255 )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(35,50) )
				particle:SetEndSize( math.Rand(0,10) )
				particle:SetRoll( math.Rand(-1,1) * 100 )
				
				particle:SetColor( 255, 255, 255 )
			
				Mirror = true
			end
			
			emitter:Finish()
		end
end

function ENT:AnimAstromech()
end

function ENT:AnimCockpit()
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/boost.wav", 125 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/brake.wav", 125 )
end

--addons/lvs_addons/lua/entities/lvs_turret_av_red/cl_init.lua:
include("shared.lua")

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )

	if self:GetGunnerSeat() == ply:GetVehicle() then
		if pod:GetThirdPersonMode() then
			return pos + self:GetUp() * 100, angles, fov
		end
	end

	return pos, angles, fov
end

function ENT:OnSpawn()
end

function ENT:OnFrame()
end

function ENT:PostDrawTranslucent()
end

function ENT:EngineEffects()
end

function ENT:AnimGunner()
end

function ENT:AnimAstromech()
end

function ENT:AnimCockpit()
end

function ENT:OnStartBoost()
end

function ENT:OnStopBoost()
end

--addons/lvs_base/lua/entities/lvs_vehicle_repair.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Maintenance Station"
ENT.Author = "Luna"
ENT.Information = "Repairs Vehicles"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal )
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:Initialize()	
		self:SetModel( "models/props_vehicles/generatortrailer01.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:DrawShadow( false )
		self:SetTrigger( true )
		self:SetCollisionGroup( COLLISION_GROUP_WORLD )
	end

	function ENT:Refil( entity )
		if not IsValid( entity ) then return end

		if not entity.LVS then return end

		local Repaired = false

		if entity:GetHP() ~= entity:GetMaxHP() then
			entity:SetHP( entity:GetMaxHP() )

			Repaired = true
		end

		if entity:OnArmorMaintenance() then
			Repaired = true
		end

		if Repaired then
			entity:EmitSound("npc/dog/dog_servo2.wav")
		end

		if entity:WeaponRestoreAmmo() then
			entity:EmitSound("items/ammo_pickup.wav")
		end

		entity:OnMaintenance()
	end

	function ENT:StartTouch( entity )
		self:Refil( entity )
	end

	function ENT:EndTouch( entity )
		self:Refil( entity )
	end

	function ENT:Touch( entity )
	end

	function ENT:Think()
		return false
	end
end

if CLIENT then
	local WhiteList = {
		["weapon_physgun"] = true,
		["weapon_physcannon"] = true,
		["gmod_tool"] = true,
	}

	local mat = Material( "models/wireframe" )
	local FrameMat = Material( "lvs/3d2dmats/frame.png" )
	local RepairMat = Material( "lvs/3d2dmats/repair.png" )
	function ENT:Draw()
		local ply = LocalPlayer()
		local Small = false

		if IsValid( ply ) and not IsValid( ply:lvsGetVehicle() ) then
			self:DrawModel()

			Small = true

			if GetConVarNumber( "cl_draweffectrings" ) == 0 then return end

			local ply = LocalPlayer()
			local wep = ply:GetActiveWeapon()

			if not IsValid( wep ) then return end

			local weapon_name = wep:GetClass()

			if not WhiteList[ weapon_name ] then
				return
			end
		end

		local Pos = self:GetPos()

		for i = 0, 180, 180 do
			cam.Start3D2D( self:LocalToWorld( Vector(0,0, self:OBBMins().z + 2 ) ), self:LocalToWorldAngles( Angle(i,90,0) ), 0.25 )
				surface.SetDrawColor( 255, 150, 0, 255 )

				surface.SetMaterial( FrameMat )
				surface.DrawTexturedRect( -512, -512, 1024, 1024 )

				surface.SetMaterial( RepairMat )
				if Small then
					surface.DrawTexturedRect( -256, 0, 512, 512 )
				else
					surface.DrawTexturedRect( -512, -512, 1024, 1024 )
				end
			cam.End3D2D()
		end
	end
end
--addons/lvs_addons/lua/entities/lvs_walker_atte_rear.lua:
AddCSLuaFile()

ENT.Base = "lvs_walker_atte_component"

if SERVER then
	function ENT:Initialize()	
		self:SetModel( "models/blu/atte_rear.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetUseType( SIMPLE_USE )
		self:AddFlags( FL_OBJECT )
	end

	function ENT:Think()
		self:NextThink( CurTime() )
		return true
	end

	return
end

include("entities/lvs_walker_atte/cl_ikfunctions.lua")

function ENT:OnRemove()
	self:OnRemoved()
end
--addons/weapons_other/lua/entities/mk4.lua:
AddCSLuaFile()

if SERVER then
	resource.AddFile( "Models/effects/vol_light001" )
end

DEFINE_BASECLASS( "jetpack_base" )

ENT.Spawnable = false
ENT.PrintName = "Infinite Flight"

if CLIENT then
	ENT.MatHeatWave		= Material( "sprites/heatwave" )
	ENT.MatFire			= Material( "effects/fire_cloud1" )


	AccessorFunc( ENT , "NextParticle" , "NextParticle" )
	AccessorFunc( ENT , "LastActive" , "LastActive" )
	AccessorFunc( ENT , "LastFlameTrace" , "LastFlameTrace" )
	AccessorFunc( ENT , "NextFlameTrace" , "NextFlameTrace" )

	ENT.MaxEffectsSize = 0
	ENT.MinEffectsSize = 0



	ENT.JetpackFireBlue = Color( 0 , 0 , 255 , 128 )
	ENT.JetpackFireWhite = Color( 255 , 255 , 255 , 128 )
	ENT.JetpackFireNone = Color( 255 , 255 , 255 , 0 )
	ENT.JetpackFireRed = Color( 255 , 128 , 128 , 255 )

else

	ENT.StandaloneApeShitAngular = Vector( 0 , 10 , 10 )	--do a corkscrew
	ENT.StandaloneApeShitLinear = Vector( 0 , 0 , 0 )

	ENT.StandaloneAngular = vector_origin
	ENT.StandaloneLinear = Vector( 0 , 0 , 0 )

	ENT.ShowPickupNotice = true
	ENT.SpawnOnGroundConVar = CreateConVar(
		"sv_spawnjetpackonground" ,
		"0",
		{
			FCVAR_SERVER_CAN_EXECUTE,
			FCVAR_ARCHIVE
		},
		"When true, it will spawn the jetpack on the ground, otherwise it will try equipping it right away, if you already have one equipped it will not do anything"
	)
end

--use this to calculate the position on the parent because I can't be arsed to deal with source's parenting bullshit with local angles and position
--plus this is also called during that parenting position recompute, so it's perfect

ENT.AttachmentInfo = {
	BoneName = "ValveBiped.Bip01_R_Thigh",
	OffsetVec = Vector( 1 , -0 , 2 ),
	OffsetAng = Angle( 180 , 90 , -91 ),
}

local sv_gravity = GetConVar "sv_gravity"

function ENT:SpawnFunction( ply, tr, ClassName )

	if not tr.Hit then return end

	local SpawnPos = tr.HitPos + tr.HitNormal * 36

	local ent = ents.Create( ClassName )
	ent:SetSlotName( ClassName )	--this is the best place to set the slot, only modify it ingame when it's not equipped
	ent:SetPos( SpawnPos )
	ent:SetAngles( Angle( 90 , 0 , 0 ) )
	ent:Spawn()

	--try equipping it, if we can't we'll just remove it
	if not self.SpawnOnGroundConVar:GetBool() then
		--forced should not be set here, as we still kinda want the equip logic to work as normal
		if not ent:Attach( ply , false ) then
			ent:Remove()
			return
		end
	end

	return ent

end

function ENT:Initialize()
	BaseClass.Initialize( self )
	if SERVER then
		self:SetModel( "models/hunter/plates/plate.mdl" )
		self:SetMaterial ( "Models/effects/vol_light001" )
		self:InitPhysics()

		self:SetMaxHealth( 100 )
		self:SetHealth( self:GetMaxHealth() )

		self:SetInfiniteFuel( true )
		self:SetMaxFuel(150)
		self:SetFuel( self:GetMaxFuel() )
		self:SetFuelDrain(0)	--drain in seconds
		self:SetFuelRecharge( 0 )	--recharge in seconds
		self:SetActive( false )
		self:SetCanStomp( false )
		self:SetDoGroundSlam( false )
		self:SetAirResistance( 3.5 )
		self:SetRemoveGravity( true )
		self:SetJetpackSpeed( 2000 )
		self:SetJetpackStrafeSpeed( 500 )
		self:SetJetpackVelocity( 900 )
		self:SetJetpackStrafeVelocity( 5000 )
	else
		self:SetLastActive( false )
		self:SetNextParticle( 0 )
		self:SetNextFlameTrace( 0 )
		self:SetLastFlameTrace( nil )
	end
end

function ENT:SetupDataTables()
	BaseClass.SetupDataTables( self )

	self:DefineNWVar( "Bool" , "Active" )
	self:DefineNWVar( "Bool" , "GoneApeshit" , true )	--set either when the owner dies with us active, or when we're being shot at
	self:DefineNWVar( "Bool" , "RemoveGravity" )
	self:DefineNWVar( "Bool" , "InfiniteFuel" , true , "Infinite Fuel" )
	self:DefineNWVar( "Bool" , "DoGroundSlam" )
	self:DefineNWVar( "Bool" , "CanStomp" , true , "Can stomp" )

	self:DefineNWVar( "Float" , "Fuel" )
	self:DefineNWVar( "Float" , "MaxFuel" )	--don't modify the max amount, the drain scales anyway, set to -1 to disable the fuel drain
	self:DefineNWVar( "Float" , "FuelDrain" , true , "Seconds to drain fuel" , 1 , 60 ) --how many seconds it's gonna take to drain all the fuel
	self:DefineNWVar( "Float" , "FuelRecharge" , true , "Seconds to recharge the fuel" , 1 , 60 ) --how many seconds it should take to fully recharge this
	self:DefineNWVar( "Float" , "AirResistance" , true , "Air Resistance" , 0 , 10 )
	self:DefineNWVar( "Float" , "GoneApeshitTime" ) --only used if infinite fuel is on

	self:DefineNWVar( "Int" , "Key" )	--override it to disallow people from editing the key since it's unused
	self:DefineNWVar( "Int" , "JetpackSpeed" , true , "Jetpack idle upward speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackStrafeSpeed" , true , "Jetpack idle side speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackVelocity" , true , "Jetpack active upward speed" , 1 , 2000 )
	self:DefineNWVar( "Int" , "JetpackStrafeVelocity" , true , "Jetpack active side speed" , 1 , 2000 )

end

function ENT:HandleFly( predicted , owner , movedata , usercmd )
	self:SetActive( self:CanFly( owner , movedata ) )

	--we have infinite fuel and the apeshit timeout hasn't been set, do it now
	--this is most useful because I CBA to do that everytime ok?
	--also it's serverside only because we only set the apeshit on the server anyway

	if SERVER then
		if self:GetGoneApeshit() and self:GetGoneApeshitTime() == 0 and self:GetInfiniteFuel() then
			self:SetGoneApeshitTime( CurTime() + 5 )
		end
	end

	--the check below has to be done with prediction on the client!

	if CLIENT and not predicted then
		return
	end

	--fixes a bug where if you set goneapeshit manually via the contextmenu and the physobj is asleep it wouldn't apply the simulated forces
	if SERVER and not predicted and self:GetGoneApeshit() then
		local physobj = self:GetPhysicsObject()
		if IsValid( physobj ) and physobj:IsAsleep() then
			physobj:Wake()
		end
	end

	--if we have an apeshit timeout, calm us down ( this doesn't check for infinite fuel, in case we did this manually )
	if self:GetGoneApeshit() and self:GetGoneApeshitTime() ~= 0 and self:GetGoneApeshitTime() <= CurTime() then
		self:SetGoneApeshit( false )
		self:SetGoneApeshitTime( 0 )
	end
end

function ENT:HandleFuel( predicted )

	--like with normal rules of prediction, we don't want to run on the client if we're not in the simulation

	if not predicted and CLIENT then
		return
	end

	--we set the think rate on the entity to the tickrate on the server, we could've done NextThink() - CurTime(), but it's only a setter, not a getter
	local ft = engine.TickInterval()

	--screw that, during prediction we need to recharge with FrameTime()
	if predicted then
		ft = FrameTime()
	end

	local fueltime = self:GetActive() and self:GetFuelDrain() or self:GetFuelRecharge()

	local fuelrate = self:GetMaxFuel() / ( fueltime / ft )

	if self:GetActive() then
		fuelrate = fuelrate * -1

		if self:GetGoneApeshit() then
			--drain twice as much fuel if we're going craaaazy
			fuelrate = fuelrate * 2
		end

		--don't drain any fuel when infinite fuel is on, but still allow recharge
		if self:GetInfiniteFuel() then
			fuelrate = 0
		end
	else
		--recharge in different ways if we have an owner or not, because players might drop and reequip the jetpack to exploit the recharging
		if IsValid( self:GetControllingPlayer() ) then
			--can't recharge until our owner is on the ground!
			--prevents the player from tapping the jump button to fly and recharge at the same time
			if not self:GetControllingPlayer():OnGround() then
				fuelrate = 0
			end
		else
			--only recharge if our physobj is sleeping and it's valid ( should never be invalid in the first place )
			local physobj = self:GetPhysicsObject()
			if not IsValid( physobj ) or not physobj:IsAsleep() then
				fuelrate = 0
			end
		end
	end

	--holy shit, optimization??
	if fuelrate ~= 0 then
		self:SetFuel( math.Clamp( self:GetFuel() + fuelrate , 0 , self:GetMaxFuel() ) )
	end

	--we exhausted all of our fuel, chill out if we're crazy
	if not self:HasFuel() and self:GetGoneApeshit() then
		self:SetGoneApeshit( false )
	end
end

function ENT:HasFuel()
	return self:GetFuel() > 0
end

function ENT:GetFuelFraction()
	return self:GetFuel() / self:GetMaxFuel()
end

function ENT:CanFly( owner , mv )


	if IsValid( owner ) then

		--don't care about player inputs in this case, the player's jetpack is going craaazy

		if self:GetGoneApeshit() then
			return owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and self:HasFuel()
		end

		return ( mv:KeyDown( IN_JUMP ) or mv:KeyDown( IN_DUCK ) or mv:KeyDown( IN_SPEED ) ) and not owner:OnGround() and owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and owner:Alive() and self:HasFuel()
	end

	--making it so the jetpack can also fly on its own without an owner ( in the case we want it go go nuts if the player dies or some shit )
	if self:GetGoneApeshit() then
		return self:WaterLevel() == 0 and self:HasFuel()
	end

	return false
end

function ENT:Think()

	--still act if we're not being held by a player
	if not self:IsCarried() then
		self:HandleFly( false )
		self:HandleFuel( false )
	end

	--animation related stuff should be fine to call here



	return BaseClass.Think( self )
end

function ENT:PredictedSetupMove( owner , mv , usercmd )

	self:HandleFly( true , owner , mv , usercmd )
	self:HandleFuel( true )

	if self:GetActive() then

		local vel = mv:GetVelocity()

		if mv:KeyDown( IN_JUMP ) and vel.z < self:GetJetpackSpeed() then

			-- Apply constant jetpack_velocity

			vel.z = vel.z + self:GetJetpackVelocity() * FrameTime()

		elseif mv:KeyDown( IN_SPEED ) and vel.z < 0 then

			-- Apply just the right amount of thrust

			vel.z = math.Approach( vel.z , 0 , self:GetJetpackVelocity() * FrameTime() )

		end



		-- Quickly descend to do a ground slam, don't check for the velocity cap, we want to slam down as fast as we can
		if self:GetCanStomp() then
			self:SetDoGroundSlam( mv:KeyDown( IN_DUCK ) )
		end

		--even if the user can't stomp, we still allow him to go down by crouching

		if mv:KeyDown( IN_DUCK ) then
			vel.z = vel.z - self:GetJetpackVelocity() * FrameTime()
		end

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--

		if vel.z == 0 then

			self:SetRemoveGravity( true )

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

		end

		--
		-- Apply movement velocity
		--

		local move_vel = Vector( 0, 0, 0 )

		local ang = mv:GetMoveAngles()
		ang.p = 0

		move_vel:Add( ang:Right() * mv:GetSideSpeed() )
		move_vel:Add( ang:Forward() * mv:GetForwardSpeed() )

		move_vel:Normalize()
		move_vel:Mul( self:GetJetpackStrafeVelocity() * FrameTime() )

		if vel:Length2D() < self:GetJetpackStrafeSpeed() then

			vel:Add( move_vel )

		end

		--TODO: goneapeshit stuff, do it before air resistance

		if self:GetGoneApeshit() then
			--boost us in the direction the jetpack is facing in the world ( actual third person angles )
			--ragdolling the user and attaching us to the ragdoll would be quite expensive and wouldn't be worth it
			--as cool as that might look, that might also break stuff in other gamemodes

			local addvel = self:GetAngles():Up() * -1 * self:GetJetpackVelocity() * FrameTime()
			vel:Add( addvel )
		end

		--
		-- Apply air resistance
		--
		vel.x = math.Approach( vel.x, 0, FrameTime() * self:GetAirResistance() * vel.x )
		vel.y = math.Approach( vel.y, 0, FrameTime() * self:GetAirResistance() * vel.y )

		--
		-- Write our calculated velocity back to the CMoveData structure
		--
		mv:SetVelocity( vel )

		mv:SetForwardSpeed( 0 )
		mv:SetSideSpeed( 0 )
		mv:SetUpSpeed( 0 )

		-- Removes the crouch button from the movedata, effectively disabling the crouching behaviour

		mv:SetButtons( bit.band( mv:GetButtons(), bit.bnot( IN_DUCK ) ) )

	end
end

function ENT:PredictedThink( owner , movedata )
end

function ENT:PredictedMove( owner , data )
	if self:GetActive() and self:GetGoneApeshit() then
		owner:SetGroundEntity( NULL )
	end
end

function ENT:PredictedFinishMove( owner , movedata )
	if self:GetActive() then

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--
		if self:GetRemoveGravity() then
			local vel = movedata:GetVelocity()

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

			movedata:SetVelocity( vel )

			self:SetRemoveGravity( false )
		end

	end
end

local	SF_PHYSEXPLOSION_NODAMAGE			=	0x0001
local	SF_PHYSEXPLOSION_PUSH_PLAYER		=	0x0002
local	SF_PHYSEXPLOSION_RADIAL				=	0x0004
local	SF_PHYSEXPLOSION_TEST_LOS			=	0x0008
local	SF_PHYSEXPLOSION_DISORIENT_PLAYER	=	0x0010

function ENT:PredictedHitGround( ply , inwater , onfloater , speed )

	local dogroundslam = self:GetDoGroundSlam()
	self:SetDoGroundSlam( false )

	if dogroundslam and speed > 500 then

		self:EmitPESound( "Player.FallDamage" , nil , nil , nil , nil , true )
		--ply:EmitSound( "Player.FallDamage" )
		--self:EmitPESound( "" , nil , nil , nil , nil , true )	--find the sound smod uses when the player hits the ground in smod

		local fraction = self:GetJetpackStrafeVelocity() / speed	--because the fall speed might be higher than the jetpack one

		local effect = EffectData()
		effect:SetEntity( ply )
		effect:SetOrigin( ply:WorldSpaceCenter() )	--apparently the player is considered in the ground in this hook and stuff doesn't spawn
		effect:SetScale( 128 )
		util.Effect( "ThumperDust" , effect , true )	--todo, make our own effect where the particles start from the player and expand in a circle
														--can even copy the code from c_thumper_dust
		if SERVER then
			--TODO: get the code from the sdk and replicate this on my own
			ply:LagCompensation( true )

			--[[
			local physexpl = ents.Create( "env_physexplosion" )

			if IsValid( physexpl ) then
				physexpl:SetPos( ply:WorldSpaceCenter() )
				physexpl:SetKeyValue( "spawnflags" , bit.bor( SF_PHYSEXPLOSION_NODAMAGE , SF_PHYSEXPLOSION_RADIAL , SF_PHYSEXPLOSION_TEST_LOS ) )
				physexpl:SetKeyValue( "magnitude" , 500 * fraction )
				physexpl:SetKeyValue( "radius" , 250 )
				physexpl:Spawn()
				physexpl:Fire( "Explode" , "" , 0 )
				physexpl:Fire( "Kill" , "" , 0.1 )
			end
			]]



			--this is kind of shit but it's needed to make prediction actually work properly on this screenshake shit
			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( ply )
			end

			util.ScreenShake( self:GetPos() , 1.5 , 250 , 1 , 500 )

			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( NULL )
			end

			ply:LagCompensation( false )
		end

		ply:AnimRestartGesture( GESTURE_SLOT_JUMP, ACT_LAND, true )
		return true	--override the fall damage and other hooks
	end
end

if SERVER then

	function ENT:OnTakeDamage( dmginfo )
		--we're already dead , might happen if multiple jetpacks explode at the same time
		if self:Health() <= 0 then
			return
		end

		self:TakePhysicsDamage( dmginfo )

		local oldhealth = self:Health()

		local newhealth = math.Clamp( self:Health() - dmginfo:GetDamage() , 0 , self:GetMaxHealth() )
		self:SetHealth( newhealth )

		if self:Health() <= 0 then
			--maybe something is relaying damage to the jetpack instead, an explosion maybe?
			if IsValid( self:GetControllingPlayer() ) then
				self:Remove( true )
			end
			self:Detonate( dmginfo:GetAttacker() )
			return
		end

		--roll a random, if we're not being held by a player and the random succeeds, go apeshit
		if dmginfo:GetDamage() > 3 and not self:GetGoneApeshit() then
			local rand = math.random( 1 , 10 )
			if rand <= 2 then
				if IsValid( self:GetControllingPlayer() ) then
					self:Remove( true )
				end
				self:SetGoneApeshit( true )
			end
		end
	end

	function ENT:OnAttach( ply )
		self:SetDoGroundSlam( false )
		--self:SetSolid( SOLID_BBOX )	--we can still be hit when on the player's back
	end

	function ENT:CanAttach( ply )
		if self:GetGoneApeshit() then
			return false
		end
	end

	function ENT:OnDrop( ply , forced )
		if IsValid( ply ) and not ply:Alive() then
			--when the player dies while still using us, keep us active and let us fly with physics until
			--our fuel runs out
			if self:GetActive() then
				self:SetGoneApeshit( true )
			end
		else
			self:SetActive( false )
		end

	end

	function ENT:OnInitPhysics( physobj )
		if IsValid( physobj ) then
			physobj:SetMass( 75 )
			self:StartMotionController()
		end
		self:SetCollisionGroup( COLLISION_GROUP_NONE )
		--self:SetCollisionGroup( COLLISION_GROUP_WEAPON )	--set to COLLISION_GROUP_NONE to reenable collisions against players and npcs
	end

	function ENT:OnRemovePhysics( physobj )
		self:StopMotionController()
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS_TRIGGER )
		--self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
	end

	function ENT:PhysicsSimulate( physobj , delta )

		--no point in applying forces and stuff if something is holding our physobj

		if self:GetActive() and not self:GetBeingHeld() then
			physobj:Wake()
			local force = self.StandaloneLinear
			local angular = self.StandaloneAngular

			if self:GetGoneApeshit() then
				force = self.StandaloneApeShitLinear
				angular = self.StandaloneApeShitAngular
			end

			--yes I know we're technically modifying the variable stored in ENT.StandaloneApeShitLinear and that it might fuck up other jetpacks
			--but it won't because we're simply using it as a cached vector_origin and overriding the z anyway
			force.z = -self:GetJetpackVelocity()

			return angular * physobj:GetMass() , force * physobj:GetMass() , SIM_LOCAL_FORCE
		end
	end

	function ENT:PhysicsCollide( data , physobj )
		--taken straight from valve's code, it's needed since garry overwrote VPhysicsCollision, friction sound is still there though
		--because he didn't override the VPhysicsFriction
		if data.DeltaTime >= 0.05 and data.Speed >= 70 then
			local volume = data.Speed * data.Speed * ( 1 / ( 320 * 320 ) )
			if volume > 1 then
				volume = 1
			end

			--TODO: find a better impact sound for this model
			self:EmitSound( "SolidMetal.ImpactHard" , nil , nil , volume , CHAN_BODY )
		end

		if self:CheckDetonate( data , physobj ) then
			self:Detonate()
		end
	end

	--can't explode on impact if we're not active
	function ENT:CheckDetonate( data , physobj )
		return self:GetActive() and data.Speed > 500 and not self:GetBeingHeld()
	end

	function ENT:Detonate( attacker )
		--you never know!
		if self:IsEFlagSet( EFL_KILLME ) then
			return
		end

		self:Remove()

		local fuel = self:GetFuel()
		local atk = IsValid( attacker ) and attacker or self

		--check how much fuel was left when we impacted
		local dmg = 1.5 * fuel
		local radius = 2.5 * fuel

		util.BlastDamage( self , atk , self:GetPos() , radius , dmg )
		util.ScreenShake( self:GetPos() , 1.5 , dmg , 0.25 , radius * 2 )

		local effect = EffectData()
		effect:SetOrigin( self:GetPos() )
		effect:SetMagnitude( dmg )	--this is actually the force of the explosion
		effect:SetFlags( bit.bor( 0x80 , 0x20 ) ) --NOFIREBALLSMOKE, ROTATE
		util.Effect( "Explosion" , effect )
	end



else

	function ENT:Draw( flags )
		if GetViewEntity() == self:GetOwner() and !self:GetOwner():ShouldDrawLocalPlayer() then return end
		local pos , ang = self:GetCustomParentOrigin()

		--even though the calcabsoluteposition hook should already prevent this, it doesn't on other players
		--might as well not give it the benefit of the doubt in the first place
		if pos and ang then
			self:SetPos( pos )
			self:SetAngles( ang )
			self:SetupBones()
		end

		self:DrawModel( flags )

		local atchpos , atchang = self:GetEffectsOffset()

		local effectsscale = self:GetEffectsScale()

		--technically we shouldn't draw the fire from here, it should be done in drawtranslucent
		--but since we draw from the player and he's not translucent this won't get called despite us being translucent
		--might as well just set us to opaque

		if self:GetActive() then	-- and bit.band( flags , STUDIO_TRANSPARENCY ) ~= 0 then
			self:DrawJetpackFire( atchpos , atchang , effectsscale )
		end

		self:DrawJetpackSmoke( atchpos  , atchang , effectsscale )
	end

	--the less fuel we have, the smaller our particles will be
	function ENT:GetEffectsScale()
		return Lerp( self:GetFuel() / self:GetMaxFuel() , self.MinEffectsSize , self.MaxEffectsSize )
	end

	function ENT:GetEffectsOffset()
		local angup = self:GetAngles():Up()
		return self:GetPos() + angup * 5, angup
	end


	end



	--copied straight from the thruster code
	function ENT:DrawJetpackFire( pos , normal , scale )
		local scroll = 1000 + UnPredictedCurTime() * -10

		--the trace makes sure that the light or the flame don't end up inside walls
		--although it should be cached somehow, and only do the trace every tick

		local tracelength = 148 * scale


		if self:GetNextFlameTrace() < UnPredictedCurTime() or not self:GetLastFlameTrace() then
			local tr = {
				start = pos,
				endpos = pos + normal * tracelength,
				mask = MASK_OPAQUE,
				filter = {
					self:GetControllingPlayer(),
					self
				},
			}

			self:SetLastFlameTrace( util.TraceLine( tr ) )
			self:SetNextFlameTrace( UnPredictedCurTime() +  engine.TickInterval() )
		end

		local traceresult = self:GetLastFlameTrace()

		--what
		if not traceresult then
			return
		end

		-- traceresult.Fraction * ( 60 * scale ) / tracelength


		--TODO: fix the middle segment not being proportional to the tracelength ( and Fraction )

		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 32 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()


		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 100 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 40 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()

		scroll = scroll * 0.5

		render.UpdateRefractTexture()
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 32 * scale, 32 * scale , scroll + 2, color_white )
			render.AddBeam( traceresult.HitPos, 48 * scale , scroll + 5, self.JetpackFireNone )
		render.EndBeam()


		scroll = scroll * 1.3
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos , 8 * scale , scroll, self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 16 * scale , scroll + 1 , self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 16 * scale , scroll + 3 , self.JetpackFireNone )
		render.EndBeam()

		local light = DynamicLight( self:EntIndex() )

		if not light then
			return
		end

		light.Pos = traceresult.HitPos
		light.r = self.JetpackFireRed.r
		light.g = self.JetpackFireRed.g
		light.b = self.JetpackFireRed.b
		light.Brightness = 3
		light.Dir = normal
		light.InnerAngle = -45 --light entities in a cone
		light.OuterAngle = 45 --
		light.Size = 250 * scale -- 125 when the scale is 0.25
		light.Style = 1	--this should do the flicker for us
		light.Decay = 1000
		light.DieTime = UnPredictedCurTime() + 1
	end

	function ENT:DrawJetpackSmoke( pos , normal , scale )

		if not self.JetpackParticleEmitter then
			local emittr = ParticleEmitter( pos )
			if not emittr then
				return
			end
			self.JetpackParticleEmitter = emittr
		end

		--to prevent the smoke from drawing inside of the player when he's looking at a mirror, draw it manually if he's the local player
		--this behaviour is disabled if he's not the one actually using the jetpack ( this also happens when the jetpack is dropped and flies off )

		local particlenodraw = self:IsCarriedByLocalPlayer( true )

		self.JetpackParticleEmitter:SetNoDraw( particlenodraw )

		if self:GetNextParticle() < UnPredictedCurTime() and self:GetActive() then
			local particle = self.JetpackParticleEmitter:Add( "particle/particle_noisesphere", pos )
			if particle then
				--only increase the time on a successful particle
				self:SetNextParticle( UnPredictedCurTime() + 0.01 )
				particle:SetLighting( true )
				particle:SetCollide( true )
				particle:SetBounce( 0.25 )
				particle:SetVelocity( normal * self:GetJetpackSpeed() )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( 15 )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( 16 * scale )
				particle:SetEndSize( 64 * scale )
				particle:SetRoll( math.Rand( -10 , 10  ) )
				particle:SetRollDelta( math.Rand( -0.2 , 0.2 ) )
				particle:SetColor( 255 , 255 , 255 )
			end
		end

		if particlenodraw then
			self.JetpackParticleEmitter:Draw()
		end
	end



function ENT:HandleMainActivityOverride( ply , velocity )
	if self:GetActive() then
		local vel2d = velocity:Length2D()
		local idealact = ACT_INVALID

		if IsValid( ply:GetActiveWeapon() ) then
			idealact = ACT_MP_SWIM	--vel2d >= 10 and ACT_MP_SWIM or ACT_MP_SWIM_IDLE
		else
			idealact = ACT_HL2MP_IDLE + 9
		end

		if self:GetDoGroundSlam() then
			idealact = ACT_MP_CROUCH_IDLE
		end

		return idealact , ACT_INVALID
	end
end

function ENT:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed )
	if self:GetActive() then
		ply:SetPlaybackRate( 0 )	--don't do the full swimming animation
		return true
	end
end

function ENT:OnRemove()

	if CLIENT then

		--if stopping the soundpatch doesn't work, stop the sound manually
		if self.JetpackSound then
			self.JetpackSound:Stop()
			self.JetpackSound = nil
		else
			self:StopSound( "jetpack.thruster_loop" )
		end


		if self.JetpackParticleEmitter then
			self.JetpackParticleEmitter:Finish()
			self.JetpackParticleEmitter = nil
		end
	end

	BaseClass.OnRemove( self )
end

--addons/star_wars_mortar/lua/entities/mortar_bomb_shell/shared.lua:
ENT.Type			=	"anim"
ENT.Base			=	"base_entity"
ENT.PrintName		=	"[DU] Mortar Bomb Shell"
ENT.Spawnable		=	false
ENT.Category 		=   "DolUnity"
--addons/weapons_other/lua/entities/recondroidcamera/cl_init.lua:
include("shared.lua")

function ENT:Draw()

	self:DrawModel()
	
end
--addons/arccw_weapons/lua/entities/rocket_cis/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "PLX-1 Rocket"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/com_weap_missile.mdl"
ENT.FuseTime = 12
ENT.ArmTime = 0

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
            phys:EnableGravity( false )
        end

        self.kt = CurTime() + self.FuseTime
        self.motorsound = CreateSound( self, "weapons/star_wars_battlefront/common/ammo_rocket_lp06.wav")
    end

    self.at = CurTime() + self.ArmTime
    self.Armed = false
end

function ENT:OnRemove()
    if SERVER then
        self.motorsound:Stop()
    end
end


function ENT:PhysicsCollide(data, physobj)
    if self.at <= CurTime() then
        self:Detonate()
    elseif self.at > CurTime() then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        util.Effect( "RPGShotDown", effectdata)
        util.Effect( "StunstickImpact", effectdata)
        self:Remove()
    end
end

function ENT:Arm()
    if SERVER then
        self.motorsound:Play()
    end
end

function ENT:Think()

    if CurTime() >= self.at and !self.Armed then
        self:Arm()
        self.Armed = true
    end

    if SERVER then

        if self.Armed then
            local phys = self:GetPhysicsObject()
            phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    end

    if CLIENT then
        if self.Armed then
			ParticleEffectAttach( "astw2_swbf_muzzle_cis_bulldog", PATTACH_POINT_FOLLOW, self, 0 )
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end

            local smoke = emitter:Add("effects/swbf/thicksmoke", self:GetPos())
        smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
        smoke:SetVelocity( self:GetAngles():Forward() * 100 )
        smoke:SetDieTime( math.Rand(0.5,0.75) )
        smoke:SetStartAlpha( 85 )
        smoke:SetEndAlpha( 0 )
        smoke:SetStartSize( 15 )
        smoke:SetEndSize( 140 )
        smoke:SetRoll( math.Rand(-180, 180) )
        smoke:SetRollDelta( math.Rand(-0.2,0.2) )
        smoke:SetColor( 225, 225, 225 )
        smoke:SetAirResistance( 50 )
        smoke:SetPos( self:GetPos() )
        smoke:SetLighting( true )
        emitter:Finish()
        end
    end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_cis_rocket", self:GetPos(), self:GetAngles() )
			sound.Play( "weapons/star_wars_battlefront/common/exp_ord_rocket_large0" .. math.random(1,3) .. ".wav",  self:GetPos(), 100, 115 )

        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end
        util.BlastDamage(self, attacker, self:GetPos(), 400, 400)
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),18000,500,1.2,2048)
        self:Remove()
    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()

        if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(200, 300), math.random(200, 300), Color(255, 100, 195) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
        end
    end
end
--addons/arccw_weapons/lua/entities/rocket_magna/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Wrist Rocket"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/com_weap_missile.mdl"
ENT.FuseTime = 5
ENT.ArmTime = 0

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
	phys:SetMass(3)
            phys:SetBuoyancyRatio(0)
            phys:EnableGravity( false ) 
        end

        self.kt = CurTime() + self.FuseTime
        self.motorsound = CreateSound( self, "weapons/star_wars_battlefront/common/ammo_rocket_lp02.wav")
    end

    self.at = CurTime() + self.ArmTime
    self.Armed = false
end

function ENT:OnRemove()
    if SERVER then
        self.motorsound:Stop()
    end
end


function ENT:PhysicsCollide(data, physobj)
    if self.at <= CurTime() then
        self:Detonate()
    elseif self.at > CurTime() then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        util.Effect( "RPGShotDown", effectdata)
        util.Effect( "StunstickImpact", effectdata)
        self:Remove()
    end
end

function ENT:Arm()
    if SERVER then
        self.motorsound:Play()
    end
end

function ENT:Think()

    if CurTime() >= self.at and !self.Armed then
        self:Arm()
        self.Armed = true
    end

    if SERVER then

        if self.Armed then
            local phys = self:GetPhysicsObject()
            phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    end

    if CLIENT then
        if self.Armed then
		ParticleEffectAttach( "astw2_swbf_muzzle_cis_bulldog", PATTACH_POINT_FOLLOW, self, 0 )
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end

            local smoke = emitter:Add("effects/swbf/thicksmoke", self:GetPos())
        smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
        smoke:SetVelocity( self:GetAngles():Forward() * 100 )
        smoke:SetDieTime( math.Rand(0.5,0.75) )
        smoke:SetStartAlpha( 85 )
        smoke:SetEndAlpha( 0 )
        smoke:SetStartSize( 10 )
        smoke:SetEndSize( 35 )
        smoke:SetRoll( math.Rand(-180, 180) )
        smoke:SetRollDelta( math.Rand(-0.2,0.2) )
        smoke:SetColor( math.random(155,255), 45, math.random(155,255) )
        smoke:SetAirResistance( 50 )
        smoke:SetPos( self:GetPos() )
        smoke:SetLighting( true )
        emitter:Finish()
        end
    end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_cis_wristrocket", self:GetPos(), self:GetAngles() )
	sound.Play( "weapons/star_wars_battlefront/common/exp_ord_rocket_med0" .. math.random(1,3) .. ".wav",  self:GetPos(), 100, 100 )
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        util.BlastDamage(self, attacker, self:GetPos(), 150, 128)
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),18000,500,1.2,2048)
        self:Remove()
    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()

        if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(32, 128), math.random(32, 128), Color(155, 50, 255) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
        end
    end
end
--addons/tools/lua/entities/sammyservers_textscreen/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "SammyServers Textscreen"
ENT.Author = "SammyServers"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

function ENT:SetupDataTables()
	self:NetworkVar("Bool", 0, "IsPersisted")
end

local function textScreenCanTool(ply, trace, tool)
	-- only allow textscreen, remover, and permaprops tool
	if IsValid(trace.Entity) and trace.Entity:GetClass() == "sammyservers_textscreen" and tool ~= "textscreen" and tool ~= "remover" and tool ~= "permaprops" then
		return false
	end
end
hook.Add("CanTool", "3D2DTextScreensPreventTools", textScreenCanTool)
--addons/joes_stuff/lua/entities/shield_4/shared.lua:
ENT.Type = "anim"
ENT.Base = "shield_base"
 
ENT.PrintName= "Shield Level 4"
ENT.Author= "Joe + JackJack"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Joe"
ENT.AutomaticFrameAdvance = true
ENT.shieldmodel = "models/jackjack/props/circle4.mdl"
ENT.health = 400
ENT.laserlength = 2089
ENT.radius = 2351
ENT.size = 1
--addons/joes_stuff/lua/entities/shield_base/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName= "Shield Base"
ENT.Author= "Joe + JackJack + Nvc"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Category = "Joe"
ENT.AutomaticFrameAdvance = true
ENT.shieldmodel = "models/jackjack/props/circle1.mdl"
ENT.health = 100
ENT.disabledtime = 60
ENT.laserlength = 139
ENT.size = 1
--addons/joes_stuff/lua/entities/shield_bubble_shoot/cl_init.lua:
include('shared.lua')

function ENT:Initialize()
	self.StartTime = CurTime()
	self.height = 0
	self.buildtime = 1.5
	self.isshield = true
end

function ENT:Draw()
	if CurTime() >= self.StartTime + self.buildtime then
		self:DrawModel()
	else
		local min,max = self:GetRenderBounds()
		local center = self:GetPos() + self:OBBCenter()
		self.height = ( max.z / self.buildtime ) * ( CurTime() - self.StartTime )
		local normal = Vector(0,0,1)
		local pos = min + self:LocalToWorld(Vector(0, 0,max.z - self.height))
		local distance = normal:Dot(pos)
		
		render.EnableClipping(true)
		render.PushCustomClipPlane(normal, distance)
		self:DrawModel()
		render.PopCustomClipPlane()
	end
end
--addons/sse_101/lua/entities/sse_box_training.lua:
AddCSLuaFile()


ENT.Base = "sse_base"
ENT.PrintName		= "Trainingsbox"
ENT.Spawnable       = true
ENT.ConfigName = "Trainingsbox"
ENT.Category        = "SSE"

if SERVER then
        

    function ENT:Use( activator, caller )

        activator:SetHealth(activator:GetMaxHealth())
        activator:SetArmor(activator:GetMaxArmor())
        wep = activator:GetActiveWeapon()
        if wep then
            activator:GiveAmmo(self:ConfigValue("Amount"), wep:GetPrimaryAmmoType())
            activator:GiveAmmo(self:ConfigValue("Amount"), wep:GetSecondaryAmmoType())
        end
    end


end

--addons/sse_101/lua/entities/sse_sink.lua:
AddCSLuaFile()


ENT.Base = "sse_base"
ENT.PrintName		= "Sink"
ENT.Spawnable       = true
ENT.ConfigName = "Sink"
ENT.Category        = "SSE"
if SERVER then

    function ENT:Use( activator, caller )

        self:EmitSound(self:ConfigValue("Sound"))

        activator:SetColor( Color( 255, 255, 255 ) )
        activator:SetMaterial( "" ) 
    end


end


--addons/sse_101/lua/entities/sse_teleporter.lua:
AddCSLuaFile()

ENT.Base = "sse_base"
ENT.PrintName = "Teleporter"
ENT.Spawnable = true
ENT.Editable = true
ENT.ConfigName = "Teleporter"
ENT.ClientInteraction = true
ENT.Category        = "SSE"
function ENT:SetupDataTables()
    self:NetworkVar("String", 0, "TeleporterName", { KeyName = "teleportername", Edit = { type = "Text" } })
    self:NetworkVar("Int", 0, "Price", { KeyName = "price", Edit = { type = "Int", order = 4, min = 0, max = 9999999 } })

    if SERVER then
        self:SetTeleporterName("Point A")
        self:SetPrice(0)
    end
end

if SERVER then
    util.AddNetworkString("SSE_TELEPORTER_TELEPORT")

    net.Receive("SSE_TELEPORTER_TELEPORT", function(len, ply)

        if SSE:AntiSpam(ply) then return end
        local requestTele = net.ReadEntity()
        local target = net.ReadEntity()

        if not IsValid(target) then return end
        if not IsValid(ply) then return end
        if requestTele:GetClass() ~= "sse_teleporter" then return end
        if target:GetClass() ~= "sse_teleporter" then return end

        if ply:GetPos():DistToSqr(requestTele:GetPos()) > 10000 then return end
        if !requestTele:ConfirmUse(ply) then return end

        local addVector = target:GetForward() * 50

        if target:GetPrice() == 0 then
            ply:SetPos(target:GetPos() + addVector)
            return
        end

        if ply:canAfford(target:GetPrice()) then
            ply:addMoney(-target:GetPrice())
            ply:SetPos(target:GetPos() + addVector)
        else
            ply:ChatPrint(requestTele:ConfigValue("PoorAsFuck"))
            return
        end
    end)

    function ENT:UpdateTransmitState()
        return TRANSMIT_ALWAYS
    end
end

if CLIENT then
    local function SSE_TELEPORTER_MENU(currentTeleporter)
        if IsValid(SSE_TELEPORTER_FRAME) then SSE_TELEPORTER_FRAME:Remove() end
        SSE_TELEPORTER_FRAME = SSE:DefaultFrame(currentTeleporter:ConfigValue("FrameTitle"))
        SSE_TELEPORTER_FRAME:SetSize(ScrW() * 0.3, ScrH() * 0.8)
        SSE_TELEPORTER_FRAME:Center()
        SSE_TELEPORTER_FRAME:MakePopup()

        local scrollPanel = SSE:ScrollBar(SSE_TELEPORTER_FRAME)
        scrollPanel:Dock(FILL)

        local function fetchEntities(parent)
            for k, v in pairs(ents.GetAll()) do
                if not IsValid(v) then continue end
                if v:GetClass() ~= "sse_teleporter" then continue end

                if v:GetTeleporterName() == currentTeleporter:GetTeleporterName() then continue end

                local name = v:GetTeleporterName()

                if v:GetPrice() ~= 0 then
                    name = name .. " - " .. DarkRP.formatMoney(v:GetPrice())
                end

                local button = SSE:Button(parent, name, function()
                    if not LocalPlayer():canAfford(v:GetPrice()) then
                        LocalPlayer():ChatPrint(currentTeleporter:ConfigValue("PoorAsFuck"))
                        return
                    end

                    surface.PlaySound(currentTeleporter:ConfigValue("Sound"))
                    LocalPlayer():ScreenFade(SCREENFADE.OUT, Color(0, 0, 0), 0.1, currentTeleporter:ConfigValue("BlackscreenTime"))

                    timer.Simple(0.5, function()
                        net.Start("SSE_TELEPORTER_TELEPORT")
                        net.WriteEntity(currentTeleporter)
                        net.WriteEntity(v)
                        net.SendToServer()
                    end)

                    SSE_TELEPORTER_FRAME:Close()
                end)
                button:Dock(TOP)
            end
        end

        fetchEntities(scrollPanel)

        local bottomPanel = vgui.Create("DPanel", SSE_TELEPORTER_FRAME)
        bottomPanel:Dock(BOTTOM)
        bottomPanel:SetTall(SSEH(40))
        bottomPanel:SetPaintBackground(false)

        local refreshButton = SSE:Button(bottomPanel, currentTeleporter:ConfigValue("Rescan"), function()
            scrollPanel:Clear()
            fetchEntities(scrollPanel)
        end, "bctlr")
        refreshButton:Dock(FILL)
    end

    function ENT:ClientUse()
        SSE_TELEPORTER_MENU(self)
    end
end

--addons/aoc_nextbots/lua/entities/summe_boarding_pod_flying/cl_init.lua:
include('shared.lua')

function ENT:Draw()
    self:DrawModel()

    if not self:GetLanded() then return end

    local t = (CurTime() * 300) % 360
    self:SetAngles(Angle(0, t, 0))
 end
--addons/aoc_nextbots/lua/entities/summe_gr_grenade.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

function ENT:Draw()
    self:DrawModel()
end

function ENT:Initialize()
    if SERVER then
        self:SetModel( "models/weapons/tfa_starwars/w_thermal.mdl" )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
        self:DrawShadow( true )
    end

    self:EmitSound("weapons/tfa_csgo/hegrenade/explode4.wav")
    self.Delay = CurTime() + 2.5
end

function ENT:Think()
    if SERVER and self.Delay <= CurTime() then
        self:Explode()
        self:Remove()
    end
end

function ENT:PhysicsCollide(data)
    if SERVER and data.Speed > 150 then
        self:EmitSound("weapons/tfa_csgo/hegrenade/he_bounce-1.wav")
    end
end

function ENT:OnRemove()
end

function ENT:Explode()
    local effectdata = EffectData()
    effectdata:SetOrigin(self:GetPos())
    util.Effect("Explosion", effectdata)
    util.BlastDamage(self, self, self:GetPos(), 250, 150)

    local spos = self:GetPos()

    local trs = util.TraceLine({
        start = spos + Vector(0, 0, 64),
        endpos = spos + Vector(0, 0, -32),
        filter = self
    })

    util.Decal("Scorch", trs.HitPos + trs.HitNormal, trs.HitPos - trs.HitNormal)
end
--addons/aoc_nextbots/lua/entities/summe_gr_impact.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

function ENT:Draw()
    self:DrawModel()
end

function ENT:Initialize()
    if SERVER then
        self:SetModel("models/arccw/impact_grenade.mdl")
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        local phys = self:GetPhysicsObject()

        if (IsValid(phys)) then
            phys:SetMass(1)
        end

        self:DrawShadow(true)
    end

    self.Delay = CurTime() + 100000
end

function ENT:PhysicsCollide(data, phys)
    if (20 < data.Speed and 0.25 < data.DeltaTime) then
        self.Delay = 0
    end
end

function ENT:Think()
    if SERVER and (self.Delay and self.Delay <= CurTime()) then
        self:Explode()
    end

    self:NextThink(CurTime())

    return true
end

function ENT:Explode()
    local effectdata = EffectData()
    effectdata:SetOrigin(self:GetPos())
    util.Effect("Explosion", effectdata)
    util.BlastDamage(self, self, self:GetPos(), 250, 300)
    local spos = self:GetPos()

    local trs = util.TraceLine({
        start = spos + Vector(0, 0, 64),
        endpos = spos + Vector(0, 0, -32),
        filter = self
    })

    util.Decal("Scorch", trs.HitPos + trs.HitNormal, trs.HitPos - trs.HitNormal)
    self:Remove()
end

function ENT:OnRemove()
end
--addons/aocrp_emplacements/lua/entities/turret_rail/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
	self.MuzzleAttachment=self:LookupAttachment("muzzle")
	self.shootPos=self:GetDTEntity(1)
	
end

function ENT:Draw()
	
	self:DrawModel()
	
end
--addons/tools/lua/entities/vanilla_explosion/shared.lua:
-- YOU CAN EDIT AND REUPLOAD THIS FILE.
-- HOWEVER MAKE SURE TO RENAME THE FOLDER TO AVOID CONFLICTS

ENT.Type            = "anim"
DEFINE_BASECLASS( "lunasflightschool_basescript" )

ENT.PrintName = "Vanilla Explosion"
ENT.Author = "*your name*"
ENT.Information = ""
ENT.Category = "[LFS] Vanilla"

ENT.Spawnable		= false -- set to "true" to make it spawnable
ENT.AdminSpawnable	= false

ENT.MDL = "models/hunter/blocks/cube025x025x025.mdl" -- model forward direction must be facing to X+
--[[
ENT.GibModels = {
	"models/XQM/wingpiece2.mdl",
	"models/XQM/wingpiece2.mdl",
	"models/XQM/jetwing2medium.mdl",
	"models/XQM/jetwing2medium.mdl",
	"models/props_phx/misc/propeller3x_small.mdl",
	"models/props_c17/TrapPropeller_Engine.mdl",
	"models/props_junk/Shoe001a.mdl",
	"models/XQM/jetbody2fuselage.mdl",
	"models/XQM/jettailpiece1medium.mdl",
	"models/XQM/pistontype1huge.mdl",
}
]]

ENT.AITEAM = 1 -- 0 = FFA  1 = bad guys  2 = good guys

ENT.Mass = 800 -- lower this value if you encounter spazz
ENT.Inertia = Vector(20000,20000,20000) -- you must increase this when you increase mass or it will spazz
ENT.Drag = 1 -- drag is a good air brake but it will make diving speed worse

--ENT.HideDriver = true -- hide the driver?
ENT.SeatPos = Vector(0,5,0)
ENT.SeatAng = Angle(0,-90,0)

ENT.IdleRPM = 300 -- idle rpm. this can be used to tweak the minimum flight speed
ENT.MaxRPM = 2800 -- rpm at 100% throttle
ENT.LimitRPM = 3000 -- max rpm when holding throttle key
ENT.RPMThrottleIncrement = 350 -- how fast the RPM should increase/decrease per second

ENT.RotorPos = Vector(70,5,20) -- make sure you set these correctly or your plane will act wierd.
ENT.WingPos = Vector(50,5,20) -- make sure you set these correctly or your plane will act wierd. Excessive values can cause spazz.
ENT.ElevatorPos = Vector(-150,5,20) -- make sure you set these correctly or your plane will act wierd. Excessive values can cause spazz.
ENT.RudderPos = Vector(-150,5,20) -- make sure you set these correctly or your plane will act wierd. Excessive values can cause spazz.

ENT.MaxVelocity = 1000 -- max theoretical velocity at 0 degree climb
ENT.MaxPerfVelocity = 1500 -- speed in which the plane will have its maximum turning potential

ENT.MaxThrust = 800 -- max power of rotor

ENT.MaxTurnPitch = 600 -- max turning force in pitch, lower this value if you encounter spazz
ENT.MaxTurnYaw = 600 -- max turning force in yaw, lower this value if you encounter spazz
ENT.MaxTurnRoll = 600 -- max turning force in roll, lower this value if you encounter spazz

ENT.MaxHealth = 450
--ENT.MaxShield = 200  -- uncomment this if you want to use deflector shields. Dont use excessive amounts because it regenerates.

--ENT.Stability = 0.7   -- if you uncomment this the plane will always be able to turn at maximum performance. This causes MaxPerfVelocity to get ignored
ENT.MaxStability = 0.7 -- lower this value if you encounter spazz. You can increase this up to 1 to aid turning performance at MaxPerfVelocity-speeds but be careful

--ENT.VerticalTakeoff = true -- move vertically with landing gear out? REQUIRES ENT.Stability
--ENT.VtolAllowInputBelowThrottle = 10 -- number is in % of throttle. Removes the landing gear dependency. Vtol mode will always be active when throttle is below this number. In this mode up movement is done with "Shift" key instead of W
--ENT.MaxThrustVtol = 100 -- amount of vertical thrust

ENT.MaxPrimaryAmmo = 100   -- set to a positive number if you want to use weapons. set to -1 if you dont
ENT.MaxSecondaryAmmo = -1 -- set to a positive number if you want to use weapons. set to -1 if you dont

function ENT:AddDataTables() -- use this to add networkvariables instead of ENT:SetupDataTables().
	--[[DO NOT USE SLOTS SMALLER THAN 10]]--
end

--addons/tools/lua/entities/vanilla_highwake2/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
    surface.PlaySound("vanilla/hyperspace/vanilla_highwake.wav")
end

--lua/entities/yoda_council_chair.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "base_anim"
ENT.Type = "vehicle"

ENT.PrintName = "Yoda Council Chair"
ENT.Author = "Syphadias, Liam0102s Help"
ENT.Category = "Star Wars Vehicles: Chairs"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;
ENT.EntModel = "models/starwars/syphadias/jedi_knight_jedi_academy/council_chairs/yoda_council_chair.mdl";

list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then



AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("yoda_council_chair");
	e:SetPos(tr.HitPos + Vector(0,0,20));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()

	self:SetModel(self.EntModel);
	self:PhysicsInit(SOLID_VPHYSICS);
	self:SetMoveType(MOVETYPE_VPHYSICS);
	self:SetSolid(SOLID_VPHYSICS);
	self:StartMotionController();
	self:SetUseType(SIMPLE_USE);
	self:SetRenderMode(RENDERMODE_TRANSALPHA);

	self:SecretChair(self:GetPos()+self:GetUp()*10+self:GetForward()*4,self:GetAngles()+Angle(0,-90,15)); // Will most likely require tinkering for position
	
	local phys = self:GetPhysicsObject()

	if(phys:IsValid()) then
		phys:Wake()
		phys:SetMass(100000)
	end
end

function ENT:SecretChair(pos,ang)

	local e = ents.Create("prop_vehicle_prisoner_pod");
	e:SetPos(pos);
	e:SetAngles(ang);
	e:SetParent(self);
	e:SetModel("models/nova/airboat_seat.mdl");
	e:SetRenderMode(RENDERMODE_TRANSALPHA);
	e:SetColor(Color(255,255,255,0));
	e:Spawn();
	e:Activate();
	e.IsSyphSeat = true;
	self.Chair = e;
end

hook.Add("PlayerEnteredVehicle","SyphSeatEnter", function(p,v)
	if(IsValid(p) and IsValid(v)) then
		if(v.IsSyphSeat) then
			p:SetNWEntity("SyphSeat",v)
		end
	end
end)

hook.Add("PlayerLeaveVehicle","SyphSeatExit", function(p,v)
	if(IsValid(p) and IsValid(v)) then
		if(v.IsSyphSeat) then
			p:SetNWEntity("SyphSeat",NULL)
		end
		p:SetPos(v:GetPos()+v:GetUp()*10+v:GetForward()*50)
		p:SetEyeAngles(Angle(0,v:GetAngles().y+90,0))
	end
end)

function ENT:Use(p)
	
	if(!IsValid(self.Chair)) then return end;
	p:EnterVehicle(self.Chair);

end

end

if CLIENT then
	
	function ENT:Draw() self:DrawModel() end
	
	local View = {}
	hook.Add("CalcView", "SyphSeatView", function()

		local p = LocalPlayer();
		local Seat = p:GetNWEntity("SyphSeat",NULL);

		if(IsValid(Seat)) then
			if(Seat:GetThirdPersonMode()) then
				local pos = Seat:GetPos()+LocalPlayer():GetAimVector():GetNormal()*-100+Seat:GetUp()*175;
				local face = ((Seat:GetPos() + Vector(0,0,100))- pos):Angle();
					View.origin = pos;
					View.angles = face;
				return View;
			end
		end
	end)
	
	hook.Add( "ShouldDrawLocalPlayer", "SyphSeatPlayerDraw", function( p )
		local Seat = p:GetNWEntity("SyphSeat",NULL);
		if(IsValid(Seat)) then
			if(Seat:GetThirdPersonMode()) then
				return true;
			end
		end
	end);
end
--addons/arccw_weapons/lua/effects/arccw_apex_muzzle_ar/init.lua:
local ang

EFFECT.ParticleName = "tfa_apex_muzzle_ar"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment() or 1
    self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt:IsFirstPerson() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.Forward = self.Forward or data:GetNormal()
    self.Angle = self.Forward:Angle()

    local dlight = DynamicLight(self.WeaponEnt:EntIndex())
    if (dlight) then
        dlight.pos = self.Position + self.Angle:Up() * 3 + self.Angle:Right() * -2
        dlight.r = 255
        dlight.g = 192
        dlight.b = 64
        dlight.brightness = 5
        dlight.Size = math.Rand(32, 64)
        dlight.Decay = math.Rand(32, 64) / 0.05
        dlight.DieTime = CurTime() + 0.05
    end

    self.Right = self.Angle:Right()
    self.vOffset = self.Position
    dir = self.Forward

    ParticleEffectAttach( self.ParticleName, PATTACH_POINT_FOLLOW, self.WeaponEnt, self.Attachment)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end

--addons/arccw_weapons/lua/effects/arccw_apex_muzzle_smg/init.lua:
local ang

EFFECT.ParticleName = "tfa_apex_muzzle_smg"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment() or 1
    self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt:IsFirstPerson() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.Forward = self.Forward or data:GetNormal()
    self.Angle = self.Forward:Angle()
        
    local dlight = DynamicLight(self.WeaponEnt:EntIndex())
    if (dlight) then
        dlight.pos = self.Position + self.Angle:Up() * 3 + self.Angle:Right() * -2
        dlight.r = 255
        dlight.g = 192
        dlight.b = 64
        dlight.brightness = 5
        dlight.Size = math.Rand(32, 64)
        dlight.Decay = math.Rand(32, 64) / 0.05
        dlight.DieTime = CurTime() + 0.05
    end
    
    self.Right = self.Angle:Right()
    self.vOffset = self.Position
    dir = self.Forward

    ParticleEffectAttach( self.ParticleName, PATTACH_POINT_FOLLOW, self.WeaponEnt, self.Attachment)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end

--addons/arccw_base_modified/lua/effects/arccw_flashexplosion.lua:
local images_smoke = {"particle/smokesprites_0001", "particle/smokesprites_0002", "particle/smokesprites_0003", "particle/smokesprites_0004", "particle/smokesprites_0005", "particle/smokesprites_0006", "particle/smokesprites_0007", "particle/smokesprites_0008", "particle/smokesprites_0009", "particle/smokesprites_0010", "particle/smokesprites_0011", "particle/smokesprites_0012", "particle/smokesprites_0013", "particle/smokesprites_0014", "particle/smokesprites_0015", "particle/smokesprites_0016"}

local function TableRandomChoice(tbl)
    return tbl[math.random(#tbl)]
end

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()

    util.Decal("FadingScorch", self.Origin, self.Origin - Vector(0, 0, 16))

    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )

    for i = 0,5 do
        local particle = emitter:Add( TableRandomChoice(images_smoke) , self.Origin )
        local scol = math.Rand( 200, 225 )

        particle:SetVelocity( 250 * VectorRand() )
        particle:SetDieTime( math.Rand(1.5, 5) )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(100,200) )
        particle:SetEndSize( math.Rand(300,400) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( scol,scol,scol )
        particle:SetAirResistance( 100 )
        particle:SetGravity( Vector( math.Rand(-30,30) ,math.Rand(-30,30),math.Rand(10,40)) )
        particle:SetLighting( true )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
    end

    local particle = emitter:Add( "sprites/heatwave", self.Origin )
        particle:SetAirResistance( 0 )
        particle:SetDieTime( 1.5 )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 255 )
        particle:SetStartSize( 250 )
        particle:SetEndSize( 0 )
        particle:SetRoll( math.Rand(180,480) )
        particle:SetRollDelta( math.Rand(-5,5) )
        particle:SetColor( 255, 255, 255 )

    local fire = emitter:Add( "particle/fire", self.Origin )
        fire:SetAirResistance( 0 )
        fire:SetDieTime( 0.1 )
        fire:SetStartAlpha( 255 )
        fire:SetEndAlpha( 0 )
        fire:SetEndSize( 0 )
        fire:SetStartSize( 800 )
        fire:SetRoll( math.Rand(180,480) )
        fire:SetRollDelta( math.Rand(-1,1) )
        fire:SetColor( 255, 255, 255 )

    local light = DynamicLight(self:EntIndex())
    if (light) then
        light.Pos = self.Origin
        light.r = 255
        light.g = 255
        light.b = 255
        light.Brightness = 9
        light.Decay = 2500
        light.Size = 512
        light.DieTime = CurTime() + 0.1
    end

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--addons/arccw_weapons/lua/effects/astw2_halo2_explosion_fuelrod/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 200
            light.g = 255
            light.b = 155
            light.Brightness = 3
            light.Decay = 10
            light.Size = 512
            light.DieTime = CurTime() + 0.3
        end
    local particle = emitter:Add("effects/halo3/muzzle_fuelrod", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.2 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(5,15) )
    particle:SetEndSize( math.Rand(150,300) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(0,0) )
    particle:SetColor( 255, 255, 255 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )
	


	
		for i= 0,3 do
	  local particle = emitter:Add("effects/halo3/smoke_directional_large", self.Origin)

    particle:SetVelocity( Vector(0,math.Rand(75, 100),math.Rand(65, 125)) )
    particle:SetDieTime( math.Rand(0.5,1) )
    particle:SetStartAlpha( 155 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(25,75) )
    particle:SetEndSize( math.Rand(300,350) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(-0.5,0.5) )
    particle:SetColor( 155, 255, 125 )
    particle:SetAirResistance( 55 )
    particle:SetGravity( Vector( 0, 0, math.Rand(-10,50) ) )
    particle:SetLighting( false )
    particle:SetCollide( false )
	end

    particle = emitter:Add( "effects/halo3/muzzle_plasmapistol", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.25, 0.3) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(250,400) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,200,50 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
	
    particle = emitter:Add( "effects/halo3/electric_arcs", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.3, 0.4) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(300,325) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 225,255,200 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--addons/arccw_weapons/lua/effects/astw2_halo3_explosion_missile/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 255
            light.g = 255
            light.b = 100
            light.Brightness = 3
            light.Decay = 10
            light.Size = 512
            light.DieTime = CurTime() + 0.3
        end
    local particle = emitter:Add("effects/halo3/8pt_ringed_star_flare", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.2 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(5,15) )
    particle:SetEndSize( math.Rand(100,200) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(0,0) )
    particle:SetColor( 255, 255, 255 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )
	

    for i= 0,5 do
   local particle = emitter:Add("effects/halo3/smoke_dark", self.Origin)

    particle:SetVelocity( Vector(math.Rand(-100, 100),math.Rand(-100, 100),math.Rand(250, 400)) )
    particle:SetDieTime( math.Rand(2,3) )
    particle:SetStartAlpha( 25 )
    particle:SetEndAlpha( 100 )
    particle:SetStartSize( math.Rand(95,100) )
    particle:SetEndSize( math.Rand(95,115) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(-0.5,0.5) )
    particle:SetColor( 155, 155, 155 )
    particle:SetAirResistance( 55 )
    particle:SetGravity( Vector( 0, 0, math.Rand(-325,-425) ) )
    particle:SetLighting( true )
    particle:SetCollide( false )
	end

		for i= 0,5 do
        particle = emitter:Add( "effects/halo3/explosion" .. math.random(2,4) , self.Origin )
        particle:SetVelocity( 7 * Vector(math.Rand(-50, 50),math.Rand(-50, 50),math.Rand(20, 50)) )
        particle:SetDieTime( math.Rand(0.5, 0.7) )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(50,75) )
        particle:SetEndSize( math.Rand(85,105) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,math.Rand( 235, 255 ),math.Rand( 200, 215 ) )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,25) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
	end

    for i = 0,5 do
        particle = emitter:Add( "effects/halo3/explosion1" , self.Origin )

        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.2, 0.3) )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(175,225) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,255,210 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
    end

    particle = emitter:Add( "effects/halo3/explosive_burst", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.25, 0.3) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(125,250) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,225,50 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--addons/arccw_weapons/lua/effects/effect_astw2_halo2_impact_laser_blue/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/halo3/8pt_ringed_star_flare" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/muzzle_flash_round_gaseous", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.5 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 10, 15 ) );
			particle:SetEndSize( 20 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );
			particle:SetColor(100, 100, 255, 100);
		end
		emitter:Finish();
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( 100, 100, 255, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo2_impact_plasmapistol/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/halo3/8pt_ringed_star_flare" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/flash_large", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.15 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 30 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(100, 255, 100);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
	for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/explosive_burst", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.1, 0.2 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 25 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(100, 255, 100);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
	end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( rgb, 255, rgb, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_ce_tracer_ar/init.lua:

local Tracer = Material( "effects/halo2/contrail_human" )
local Width = 3

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.05
	self.DieTime = CurTime() + self.LifeTime

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 215, 160, v * 255 ) )

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_ce_tracer_turret_covenant/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 128;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo_ce/c_gun_turret_contrail" );
local MaterialFront			= Material( "effects/halo_ce/flare_generic" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 1, 1, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 24, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_plasma_green_burn/init.lua:

local Tracer = Material( "effects/halo2/c_gun_turret_contrail" )
local Tracer2  = Material( "effects/halo3/spartanlaser" )
local Width = 10
local Width2 = 5

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.1
	self.LifeTime2 = 0.15
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 205, 255, v * 200 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 220, 255, 185, (v2 * 155)*1 ) )

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_spv3_tracer_shredder/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6000;
EFFECT.Length				= 1024;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo3/muzzle_flash_01" );
local MaterialFront			= Material( "effects/halo_spv3/flash/smg_new" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 7.5, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_swbf_laser_green_sniper/init.lua:

local Tracer = Material( "effects/laser1" )
local Tracer2  = Material( "effects/swbf/green_beam" )
local Width = 15
local Width2 = 10

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.25
	self.LifeTime2 = 0.45
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 155, 255, 155, v * 155 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 255, 255, (v2 * 100)*3/2.5 ) )

end

--addons/arccw_weapons/lua/effects/effect_astw2_swbf_laser_red/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 128;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/swbf/redlaser_bolt" );
local MaterialFront			= Material( "effects/swbf/redlaser" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 10, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_swbf_laser_yellow_sniper/init.lua:

local Tracer = Material( "effects/laser1" )
local Tracer2  = Material( "effects/swbf/yellow_beam" )
local Width = 25
local Width2 = 15

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.25
	self.LifeTime2 = 0.45
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 200, 155, v * 100 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 255, 255, (v2 * 100)*3/2.5 ) )

end

--addons/arccw_weapons/lua/effects/effect_sw_laser_blue_stun/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "star/effects/blue_shockwave" );
local MaterialFront			= Material( "star/effects/blue_shockwave" );

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 35, 35, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--addons/aoc_fire_system/lua/effects/fire_effect/init.lua:
--[[
THIS SCRIPT IS CREATED BY CRAP-HEAD
GMODSTORE PROFILE: https://www.gmodstore.com/users/crap-head
CRAP-HEAD STEAM ID || CRAP-HEAD ID 64
STEAM_0:0:14587461 || 76561198055197932
--]]

function EFFECT:Init( data )
	local trace = {}
	trace.start = data:GetOrigin() - Vector(0, 0, 5)
	trace.endpos = data:GetOrigin() - Vector(0, 0, 5) + Vector(0, 0, 500)
	local tr = util.TraceLine( trace )
	
	local pos = data:GetOrigin() - Vector( 0, 0, 5 )
	local fire_emitter = ParticleEmitter( pos )
	
	local TheFire = fire_emitter:Add( "effects/flame", pos )
	
	if ( TheFire ) then
		if tr.Hit then
			TheFire:SetVelocity( Vector( math.random( -30, 30 ), math.random( -30, 30 ), math.random( 0, 70 ) ) )
		else
			TheFire:SetVelocity( Vector( math.random( -30, -20 ), math.random( 20, 30 ), math.random( 0, 70 ) ) )
		end
		TheFire:SetDieTime( math.random( 2, 3 ) )
		TheFire:SetStartAlpha( 230 )
		TheFire:SetEndAlpha( 0 )
		TheFire:SetStartSize( math.random( 70, 80 ) )
		TheFire:SetEndSize( 10 )
		TheFire:SetRoll( math.random( 0, 10 ) )
		TheFire:SetRollDelta( math.random( -0.2, 0.2 ) )
	end
	
	fire_emitter:Finish()
	
	if CH_FireSystem.Config.EnableSmokeEffect then
		local pos = data:GetOrigin() + Vector( 0, 0, 5 )
		local smoke_emitter = ParticleEmitter( pos )
	
		local SmokeEffect = smoke_emitter:Add( "particle/smokestack", pos )
		if ( SmokeEffect ) then
			SmokeEffect:SetAirResistance( 0 )
			SmokeEffect:SetVelocity( Vector( math.random(-30,30), math.random(-30, 30), math.random(0, 70) ) )
			SmokeEffect:SetDieTime( 2 )
			SmokeEffect:SetStartAlpha( math.random( 100, 300 ) )
			SmokeEffect:SetGravity( Vector( 5, 5, 50 ) )
			SmokeEffect:SetCollide( true )
			SmokeEffect:SetColor( Color( 0, 0, 0, 255 ) )
			SmokeEffect:SetEndAlpha( 0 )
			SmokeEffect:SetStartSize( math.random( 35, 80 ) )
			SmokeEffect:SetEndSize( math.random( 10, 25 ) )
			SmokeEffect:SetRoll( math.random( 0, 10 ) )
			SmokeEffect:SetRollDelta( math.random( -0.2, 0.2 ) )
		end
		
		smoke_emitter:Finish()
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--addons/weapon_jedi/lua/effects/force_heal.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE


EFFECT.mat = Material( "sprites/light_glow02_add" )


function EFFECT:Init( data )
	self.Ent = data:GetEntity()
	self.Pos = data:GetOrigin()

	self.LifeTime = 1
	self.DieTime = CurTime() + self.LifeTime

	if not IsValid( self.Ent ) then return end

	self.Model = ClientsideModel( self.Ent:GetModel(), RENDERGROUP_TRANSLUCENT )

	self.Model:SetMaterial("models/alyx/emptool_glow")
	self.Model:SetColor( Color(0,255,0,255) )
	self.Model:SetParent( self.Ent, 0 )
	self.Model:SetMoveType( MOVETYPE_NONE )
	self.Model:SetLocalPos( Vector( 0, 0, 0 ) )
	self.Model:SetLocalAngles( Angle( 0, 0, 0 ) )
	self.Model:AddEffects( EF_BONEMERGE )

	for i = 0,self.Ent:GetBoneCount() do
		self.Model:ManipulateBoneScale( i, Vector(1,1,1) * 1.1 )
	end

	for i = 0, self.Ent:GetNumBodyGroups() do
		self.Model:SetBodygroup(i, self.Ent:GetBodygroup(i))
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid( self.Ent ) or (self.Ent.Alive and not self.Ent:Alive()) then 
		if IsValid( self.Model ) then
			self.Model:Remove()
		end

		return false
	end

	if IsValid( self.Model ) then
		self.Model:SetColor( Color(0,255 * (self.DieTime - CurTime()) / self.LifeTime,0,255) )
	end

	return true
end

function EFFECT:Render()
	if not IsValid( self.Ent ) then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( self.mat )
	render.DrawSprite( self.Ent:LocalToWorld( Vector(0,0,40) ), 200 * Scale, 200 * Scale, Color( 0, 150 * Scale, 0, 150 * Scale ) )
end
	

--addons/weapon_jedi/lua/effects/force_pull.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE


EFFECT.mat = Material( "particle/warp1_warp" )
EFFECT.mat2 = Material( "effects/select_ring" )
EFFECT.mat3 = Material( "particle/smokesprites_0001" )

function EFFECT:Init( data )
	self.Ent = data:GetEntity()

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	if not IsValid( self.Ent ) then self.Ready = true return end

	self.Pos = self.Ent:GetShootPos()
	self.Dir = data:GetNormal()
	self.mat3 = Material( "particle/smokesprites_000"..math.random(1,9) )

	self.Ready = true
end

function EFFECT:Think()
	if not self.Ready then return true end

	if self.DieTime < CurTime() or not IsValid( self.Ent ) then 
		return false
	end

	return true
end

function EFFECT:Render()
	if not self.Ready or not IsValid( self.Ent ) then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	local InvScale =  (1 - Scale)

	render.SetMaterial( self.mat3 )
	render.DrawSprite( self.Pos + self.Dir * 200 * Scale, 100 * InvScale, 100 * InvScale, Color( 150,200,255,50 ) )

	for i = 1, 3 do
		local Scale = (self.DieTime - CurTime()) / self.LifeTime / 3 * i

		local Pos = self.Pos + self.Dir * 200 * Scale
		render.SetMaterial( self.mat )
		render.DrawSprite( Pos, 150 *  Scale, 150 *  Scale, Color( 255,255,255,255 ) )
	end
end

--addons/aocrp_emplacements/lua/effects/gdca_airburst_t/init.lua:

   
 /*--------------------------------------------------------- 
    Initializes the effect. The data is a table of data  
    which was passed from the server. 
 ---------------------------------------------------------*/ 
 function EFFECT:Init( data ) 
	
	self.Origin = data:GetOrigin()
	self.Scale = data:GetScale()
	self.Magnitude = data:GetMagnitude()
	self.Emitter = ParticleEmitter( self.Origin )

	sound.Play( "ambient/explosions/explode_" .. math.random(1, 4) .. ".wav", self.Origin, 75, 100, 1 )
		
	for i=0, 40*self.Scale do
	
		local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Origin )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.Rand(500, 1500)*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 3 )*self.Scale )
		Smoke:SetStartAlpha( math.Rand( 100, 120 ) )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 70*self.Scale )
		Smoke:SetEndSize( math.Rand(100, 130)*self.Scale )
		Smoke:SetRoll( math.Rand(0, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 		
		Smoke:SetColor( 60,60,60 )
		end
		end
	

		for i=0, 40*self.Scale do
		local Shrapnel = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Origin )
		if (Shrapnel) then
		Shrapnel:SetVelocity ( VectorRand():GetNormalized()*math.Rand(3000, 5000)*self.Scale )
		Shrapnel:SetDieTime( math.random( 0.3, 0.6) )
		Shrapnel:SetStartAlpha( 255 )
		Shrapnel:SetEndAlpha( 0 )
		Shrapnel:SetStartSize( math.random(4,7*self.Scale) )
		Shrapnel:SetRoll( math.Rand(0, 360) )
		Shrapnel:SetRollDelta( math.Rand(-5, 5) )			
		Shrapnel:SetAirResistance( 20 ) 			 			
		Shrapnel:SetColor( 53,50,45 )
		Shrapnel:SetGravity( Vector( 0, 0, -600) ) 		
		end
		end

		for i=1,3 do 
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Origin )
		if (Flash) then
		Flash:SetVelocity( VectorRand() )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.1 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Magnitude*10 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=1,1 do 
		local Shockwave = self.Emitter:Add( "sprites/heatwave", self.Origin )
		if (Shockwave) then
		Shockwave:SetVelocity( VectorRand() )
		Shockwave:SetAirResistance( 200 )
		Shockwave:SetDieTime( 0.07 )
		Shockwave:SetStartAlpha( 255 )
		Shockwave:SetEndAlpha( 0 )
		Shockwave:SetStartSize( self.Magnitude*25 )
		Shockwave:SetEndSize( self.Magnitude*20 )
		Shockwave:SetRoll( math.Rand(180,480) )
		Shockwave:SetRollDelta( math.Rand(-1,1) )
		Shockwave:SetColor(255,255,255)	
		end
		end

 end
   
   
/*---------------------------------------------------------
   THINK
---------------------------------------------------------*/
function EFFECT:Think( )
	return false
end

/*---------------------------------------------------------
   Draw the effect
---------------------------------------------------------*/
function EFFECT:Render()
end

 
--addons/arccw_weapons/lua/effects/laser_hit.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.Col = data:GetStart() or Vector(255,100,0)

	self.mat = Material( "sprites/light_glow02_add" )

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()

	local emitter = ParticleEmitter( Pos, false )

	for i = 0, 2 do
		local particle = emitter:Add( "sprites/light_glow02_add", Pos )

		local vel = VectorRand() * 200 - Dir  * 80

		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.2,0.4) )
			particle:SetStartAlpha( 150 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(1, 20) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100, 100) )
			particle:SetRollDelta( math.Rand(-100, 100) )
			particle:SetColor( Col.x,Col.y,Col.z )
			particle:SetGravity( Vector(0, 0, -600) )

			particle:SetAirResistance( 0 )

			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( self.mat )
	render.DrawSprite( self.Pos, 50 * Scale, 50 * Scale, Color( self.Col.x, self.Col.y, self.Col.z, 255) )
	render.DrawSprite( self.Pos, 10 * Scale, 10 * Scale, color_white )
end

--addons/lvs_addons/lua/effects/lfs_fb_wingturret_projector.lua:
EFFECT.Mat = Material( "effects/lfs_base/ballturret_projectorbeam" )
EFFECT.HitMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Entity = data:GetEntity()
	
	self.DownPos = Vector(-55, 350, 90)
	self.UpPos = Vector(-55, 370, 125)
	self.StartPos = self.DownPos
	self.EndPos = self.Entity:GetWingTurretTarget()
end

function EFFECT:Think()
	if not IsValid( self.Entity ) or not self.Entity:GetWingTurretFire() then
		return false
	end
	
	self.EndPosDesired = self.Entity:GetWingTurretTarget() 
	self:SetRenderBoundsWS( self.Entity:GetPos(), self.EndPosDesired )
	
	return true
end

local color_white = Color(255, 255, 255, 255)
local color_green = Color(0, 255, 0, 255)
local trData = {}
function EFFECT:Render()
	if not self.EndPosDesired then return end
	
	self.EndPos = self.EndPos + (self.EndPosDesired - self.EndPos) * FrameTime() * 10
	
	for i = -1, 1, 2 do
		local StartPos = self.Entity:LocalToWorld(self.StartPos * Vector(1, i, 1))
		
		trData.start = StartPos
		trData.endpos = self.EndPos
		local Trace = util.TraceLine(trData)
		local EndPos = Trace.HitPos
		
		if self.Entity:WorldToLocal( EndPos ).z < 0 then
			self.StartPos = self.DownPos
		else
			self.StartPos = self.UpPos
		end
		
		if Trace.Entity ~= self.Entity then
			render.SetMaterial(self.Mat)
			render.DrawBeam(StartPos, EndPos, 14 + math.random(0, 4), 1, 0, color_green)
			render.DrawBeam(StartPos, EndPos, 3 + math.random(0, 4), 1, 0, color_white)
			
			render.SetMaterial( self.HitMat )
			local A = 150 + math.random(0, 20)
			local B = 70 + math.random(0, 20)
			render.DrawSprite(StartPos, A, A, color_green)
			render.DrawSprite(StartPos, B, B, color_white)
			
			render.DrawSprite(EndPos, A, A, color_green)
			render.DrawSprite(EndPos + VectorRand() * 10, B, B, color_white)
			
			if math.random(0,5) == 1 then
				local emitter = ParticleEmitter(EndPos, false)
				local dir = (self.Entity:GetPos() - EndPos):GetNormalized()
				
				for i = 0, 10 do
					local particle = emitter:Add("sprites/rico1", EndPos)
					local vel = VectorRand() * 100 + dir * 40
					
					if particle then
						particle:SetVelocity(vel)
						particle:SetAngles(vel:Angle() + Angle(0, 90, 0))
						particle:SetDieTime(math.Rand(0.1, 0.3) * 0.5)
						particle:SetStartAlpha(math.Rand( 200, 255 ))
						particle:SetEndAlpha(0)
						particle:SetStartSize(math.Rand(1, 30))
						particle:SetEndSize(0)
						particle:SetRoll(math.Rand(-100, 100))
						particle:SetRollDelta(math.Rand(-100, 100))
						particle:SetAirResistance(0)
					end
				end
				
				emitter:Finish()
			end
		end
	end
end
--addons/lvs_addons/lua/effects/lfs_tx-427_main_explosion_red.lua:
function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.DieTime = CurTime() + 0.4

	sound.Play( "lfsAAT_EXPLOSION", self.Pos )
	self:Explode()
end

function EFFECT:Explode()
	local emitter = ParticleEmitter( self.Pos, false )
	if not emitter then return end

	for i = 0, 20 do
		local particle = emitter:Add( "particle/smokesprites_00" .. math.random( 0, 1 ) .. math.random( 1, 6 ), self.Pos + VectorRand() * 5 )
		if particle then
			particle:SetVelocity( VectorRand() * 2000 )
			particle:SetDieTime( math.Rand( 2, 3 ) )
			particle:SetAirResistance( math.Rand( 1000, 1500 ) ) 
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand( 20, 25 ) )
			particle:SetEndSize( math.Rand( 75, 100 ) )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 50, 50, 50 )
			particle:SetGravity( Vector( 0, 0, 50 ) )
			particle:SetCollide( false )
		end
		
		particle = emitter:Add( "sprites/flamelet"..math.random( 1, 5 ), self.Pos )
		if particle then
			particle:SetVelocity( VectorRand() * 200 )
			particle:SetDieTime( math.Rand( 0.2, 0.3 ) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 15 )
			particle:SetEndSize( math.Rand( 25, 50 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
		
		particle = emitter:Add( "sprites/light_glow02_add", self.Pos )
		if particle then
			particle:SetVelocity( VectorRand() * 500 )
			particle:SetDieTime( math.Rand( 0.5, 1 ) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand( 15, 20 ) )
			particle:SetEndSize( math.Rand( 25, 50 ) )
			particle:SetColor( 255, 0, 0 )
			particle:SetGravity( Vector( 0, 0, -1000 ) )
			particle:SetCollide( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end
end

function EFFECT:Render()
end
--lua/effects/ls_mine_explosion.lua:
function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.DieTime = CurTime() + 0.4
	
	self:Explode()
end

function EFFECT:Explode()
	local emitter = ParticleEmitter( self.Pos, false )
	if not IsValid(emitter) then return end

	for i = 0, 20 do
		local particle = emitter:Add( "particle/smokesprites_00" .. math.random( 0, 1 ) .. math.random( 1, 6 ), self.Pos + VectorRand() * 5 )
		if particle then
			particle:SetVelocity( VectorRand() * 2000 )
			particle:SetDieTime( math.Rand( 1, 2 ) )
			particle:SetAirResistance( math.Rand( 1000, 1500 ) ) 
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand( 7, 10 ) )
			particle:SetEndSize( math.Rand( 25, 50 ) )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 50, 50, 50 )
			particle:SetGravity( Vector( 0, 0, 50 ) )
			particle:SetCollide( false )
		end
		
		particle = emitter:Add( "sprites/flamelet"..math.random( 1, 5 ), self.Pos )
		if particle then
			particle:SetVelocity( VectorRand() * 200 )
			particle:SetDieTime( math.Rand( 0.2, 0.3 ) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 5 )
			particle:SetEndSize( math.Rand( 10, 25 ) )
			particle:SetColor( 200,200,130 )
			particle:SetCollide( false )
		end
		
		particle = emitter:Add( "sprites/light_glow02_add", self.Pos )
		if particle then
			particle:SetVelocity( VectorRand() * 250 )
			particle:SetDieTime( math.Rand( 0.3, 0.7 ) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand( 5, 10 ) )
			particle:SetEndSize( math.Rand( 10, 25 ) )
			particle:SetColor( 255,150,0 )
			particle:SetGravity( Vector( 0, 0, -1000 ) )
			particle:SetCollide( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end
end

function EFFECT:Render()
end
--addons/lvs_addons/lua/effects/lvs_laser_blue_short.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 300 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 2, endpos + dir * len * 2, 200, 1, 0, Color( 0, 0, 255, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 0, 0, 255, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--addons/arccw_weapons/lua/effects/new_tracerblue.lua:
AddCSLuaFile()

EFFECT.OuterMat				= "effects/drc_sw/plasma3"
EFFECT.InnerMat				= "effects/drc_sw/flash0"
EFFECT.CenterMat			= "effects/drc_sw/flash0"
EFFECT.PuffMat				= "effects/drc_sw/beam1"
EFFECT.BulletMat			= "effects/drc_sw/flash0"
EFFECT.ThirdPersonScale		= 0.5
EFFECT.FirstPersonScale		= 0.4
EFFECT.OuterSize			= 3
EFFECT.InnerSize			= 10
EFFECT.CenterSize			= 3
EFFECT.PuffSize				= 2
EFFECT.BulletSize			= 10
EFFECT.OuterCol				= Color(0, 150, 255, 255)
EFFECT.InnerCol				= Color(0, 150, 255, 255)
EFFECT.CenterCol			= Color(0, 150, 255, 255)
EFFECT.PuffCol				= Color(0, 150, 255, 255)
EFFECT.BulletCol			= Color(0, 150, 255, 255)
EFFECT.OuterLighting		= false
EFFECT.InnerLighting		= false
EFFECT.CenterLighting		= false
EFFECT.PuffLighting			= false
EFFECT.BulletLighting		= false
EFFECT.LifeTimeMul			= 0.25
EFFECT.SpeedMul				= 15
EFFECT.TotalTracerParticles	= 301
-- always add 1 to your intended particle count, as the final one is the bullet particle.

EFFECT.ImpactEffect = "drc_halo_lightrifle_impact"
EFFECT.MuzzleEffect = "drc_sw_muzzle_blue_lens"
EFFECT.ImpactSound 	= "vsw.sniper_impact"

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	
	self.Size = self.ThirdPersonScale
	self.Speed = self.SpeedMul

	if data:GetEntity() == LocalPlayer():GetViewModel() then
		self.WeaponEnt = LocalPlayer():GetActiveWeapon()
		self.Size = self.FirstPersonScale
		self.Speed = (self.Speed*0.5) / self.Speed
	end
	self.StartPos = self.WeaponEnt:GetWeaponAttachment("muzzle").Pos
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	
	if !IsValid(data:GetEntity()) then return end
	
	local subt = self.EndPos - self.StartPos
	
	self.Normal = subt:GetNormal()
	local muzang = self.Normal:Angle()
	self.StartTime = 0

	local weapon = data:GetEntity()
	local att = self.WeaponEnt:GetWeaponAttachment("muzzle")
	if att == nil then
		att = { Ang = Angle(0, 0, 0), }
	end

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
	
	local ll = render.GetLightColor( self.StartPos ) * GetSF2LightLevel(0.05)
	local lla = ll.x + ll.y + ll.z / 3
	local mini = 200
	local smoketint = Vector(math.Clamp((200 * ll.x), mini, 200), math.Clamp((200 * ll.y), mini, 200), math.Clamp((200 * ll.z), mini, 200))
	
	local pos = Vector(0, 0, 0)
	
	local TracerSmoke = ParticleEmitter( self.StartPos )
	local blt = self.TotalTracerParticles-1
	local third = (self.TotalTracerParticles-1) / 3
	pos = self.StartPos
	for i = 0,self.TotalTracerParticles do
		local rnglight = math.Rand(0,lla * 500)
		local particle = TracerSmoke:Add( "particle/particle_smokegrenade", pos + Vector( math.random(0,0),math.random(0,0),math.random(0,0))) 
		if particle == nil then particle = TracerSmoke:Add( "particle/particle_smokegrenade", pos + Vector(   math.random(0,0),math.random(0,0),math.random(0,0) ) ) end
		if (particle) then
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetAirResistance( math.Rand(5,10) )  
			particle:SetStartSize(math.Rand(1,3) * self.Size)
			particle:SetEndSize(math.Rand(2, 6) * self.Size)
			particle.DoCustomLighting = false
			if i > blt then -- BE the BULLET.
				particle:SetMaterial(self.BulletMat)
				particle:SetVelocity(self.Normal * 20000 * self.Speed)
				particle:SetStartLength(150)
				particle:SetEndLength(150)
				particle:SetBounce(50)
				particle.TintCol = self.BulletCol
				particle:SetColor(self.BulletCol.r, self.BulletCol.g, self.BulletCol.b)
				particle:SetStartAlpha(self.BulletCol.a)
				particle:SetEndAlpha(self.BulletCol.a)
				particle:SetAirResistance(-1)
				particle:SetDieTime(0.25)
				particle:SetStartSize(3 * self.Size)
				particle:SetEndSize(3 * self.Size)
				particle.DoCustomLighting = self.BulletLighting
			elseif i < blt && i > third*2 then
				particle:SetMaterial(self.OuterMat)
				particle:SetStartSize(math.Rand(1,3) * self.Size * self.OuterSize)
				particle:SetEndSize(math.Rand(2, 6) * self.Size * self.OuterSize)
				particle:SetVelocity(self.Normal * math.Rand(0, 10000) * self.Speed) -- outer
				particle.TintCol = self.OuterCol
				particle:SetColor(self.OuterCol.r, self.OuterCol.g, self.OuterCol.b)
				particle:SetDieTime(math.Rand(2, 3) * self.LifeTimeMul)
				particle.DoCustomLighting = self.OuterLighting
			elseif i < (third*2)+1 && i > third*2 then
				particle:SetMaterial(self.InnerMat)
				particle:SetStartSize(math.Rand(1,3) * self.Size * self.InnerSize)
				particle:SetEndSize(math.Rand(2, 6) * self.Size * self.InnerSize)
				particle:SetVelocity(self.Normal * math.Rand(0, 7500) * self.Speed) -- inner
				particle.TintCol = self.InnerCol
				particle:SetColor(self.InnerCol.r, self.InnerCol.g, self.InnerCol.b)
				particle:SetDieTime(math.Rand(2, 3) * self.LifeTimeMul)
				particle.DoCustomLighting = self.InnerLighting
			else
				particle:SetMaterial(self.CenterMat)
				particle:SetStartSize(math.Rand(1,3) * self.Size * self.CenterSize)
				particle:SetEndSize(math.Rand(0, 1) * self.Size * self.CenterSize)
				particle:SetStartLength(math.Rand(50,200))
				particle:SetEndLength(math.Rand(200,400))
				particle:SetVelocity(self.Normal * math.Rand(0, 5000) * self.SpeedMul) -- center
				particle.TintCol = self.CenterCol
				particle:SetColor(self.CenterCol.r, self.CenterCol.g, self.CenterCol.b)
				particle:SetDieTime(math.Rand(2, 3) * self.LifeTimeMul)
				particle.DoCustomLighting = self.CenterLighting
			end
			if i < third then -- puffs
				particle:SetMaterial(self.PuffMat)
				particle.TintCol = self.PuffCol
				particle:SetColor(self.PuffCol.r, self.PuffCol.g, self.PuffCol.b)
				particle:SetStartSize(math.Rand(2,7) * self.Size * self.PuffSize)
				particle:SetEndSize(math.Rand(5, 12) * self.Size * self.PuffSize)
				particle:SetBounce(0.0001)
				particle.DoCustomLighting = self.PuffLighting
			end
			particle:SetLifeTime(0) 
			particle:SetLighting(false)
			particle:SetAngleVelocity( Angle(math.Rand(1,15)) ) 
			particle:SetRoll(math.Rand( 0, math.Rand(0.1,5) ))
			particle:SetGravity( Vector(0,0,0) ) 
			particle:SetCollide(true)
			
			particle:SetCollideCallback( function( part, hitpos, hitnormal )
				particle:SetDieTime(0)
			end )
			particle:SetNextThink(CurTime())
			particle:SetThinkFunction(function(part)
				if part.DoCustomLighting == true then
					local ll = render.GetLightColor(part:GetPos())
					local lla = ll.x + ll.y + ll.z / 3
					local mini = 1
					local smoketint = Vector(math.Clamp((200 * ll.x), mini, 255), math.Clamp((200 * ll.y), mini, 255), math.Clamp((200 * ll.z), mini, 255))
					local boost = 50
					smoketint.x = smoketint.x + (boost * lla)
					smoketint.y = smoketint.y + (boost * lla)
					smoketint.z = smoketint.z + (boost * lla)
					local col2 = Vector()
					smoketint = 255/smoketint
					col2.x = Lerp(smoketint.x, mini, particle.TintCol.r)
					col2.y = Lerp(smoketint.y, mini, particle.TintCol.g)
					col2.z = Lerp(smoketint.z, mini, particle.TintCol.b)
					part:SetColor(col2.x, col2.y, col2.z)
					part:SetNextThink(CurTime() + math.Rand(0.2, 1))
				end
			end)
		end
	end

	TracerSmoke:Finish()
	
	if self.ImpactSound then sound.Play(self.ImpactSound, self.EndPos) end
	
	if self.ImpactEffect then
		local ImpactData = EffectData()
		ImpactData:SetOrigin(self.EndPos)
		ImpactData:SetStart(self.StartPos)
		ImpactData:SetAttachment(data:GetAttachment())
		ImpactData:SetEntity(data:GetEntity())
		util.Effect(self.ImpactEffect, ImpactData)
	end
	
	if self.MuzzleEffect then
		local MuzzleData = EffectData()
		MuzzleData:SetOrigin(self.StartPos)
		MuzzleData:SetStart(self.EndPos)
		MuzzleData:SetAttachment(data:GetAttachment())
		MuzzleData:SetEntity(data:GetEntity())
		util.Effect(self.MuzzleEffect, MuzzleData)
	end
end

function EFFECT:PhysicsCollide()
	self:Remove()
end

function EFFECT:Think()
end

function EFFECT:Render()
end
--addons/weapon_jedi/lua/effects/saber_hitwall.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

local DecalMat = Material( util.DecalMaterial( "FadingScorch" ) )
function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.Col = data:GetStart() or Vector(255,100,0)
	
	self.mat = Material( "sprites/light_glow02_add" )
	
	self.LifeTime = 0.6
	self.DieTime = CurTime() + self.LifeTime

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()
	
	local emitter = ParticleEmitter( Pos, false )

	if LSCS.ImpactEffects then
		local trace = util.TraceLine( {
			start = Pos + Dir * 5,
			endpos = Pos - Dir * 5,
			filter = function( ent ) 
				if ent.GetOwningEnt then return false end
				return true
			end
		} )

		if trace.Hit and not trace.HitNonWorld then
			self.RenderGlow = {
				Pos = trace.HitPos,
				Normal = trace.HitNormal,
				Angle = trace.HitNormal:Angle() + Angle(90,0,0),
				RandomAng = math.random(0,360),
			}

			util.DecalEx( DecalMat, trace.Entity, trace.HitPos + trace.HitNormal, trace.HitNormal, Color(255,255,255,255), math.Rand(0.3,0.6), math.Rand(0.3,0.6) )
		end
	end

	local particle = emitter:Add( Materials[ math.random(1,table.Count( Materials )) ], Pos )
	
	local vel = VectorRand() * 100 + Dir * 40
	
	if particle then			
		particle:SetVelocity( vel )
		particle:SetDieTime( 0.5 )
		particle:SetAirResistance( 1000 ) 
		particle:SetStartAlpha( 50 )
		particle:SetStartSize( 2 )
		particle:SetEndSize( 6 )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 40,40,40 )
		particle:SetGravity( Dir * 10 )
		particle:SetCollide( false )
	end

	local particle = emitter:Add( "sprites/rico1", Pos )
	
	local vel = VectorRand() * 100 + Dir * 40
	
	if particle then
		particle:SetVelocity( vel )
		particle:SetAngles( vel:Angle() + Angle(0,90,0) )
		particle:SetDieTime( 0.5 )
		particle:SetStartAlpha( math.Rand( 200, 255 ) )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( 1 )
		particle:SetEndSize( 0.25 )
		particle:SetRoll( math.Rand(-100,100) )
		particle:SetRollDelta( math.Rand(-100,100) )
		particle:SetCollide( true )
		particle:SetBounce( 0.5 )
		particle:SetAirResistance( 0 )
		particle:SetColor( 255, 150, 0 )
		particle:SetGravity( Vector(0,0,-600) )
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then 
		return false
	end

	return true
end

local Mat = Material("particle/particle_glow_05_addnofog")

function EFFECT:Render()
	if LSCS.ImpactEffects then
		if self.RenderGlow then
			local Timed = 1 - (self.DieTime - CurTime()) / self.LifeTime
			local Scale = math.max(math.min(2 - Timed * 2,1),0)

			cam.Start3D2D( self.RenderGlow.Pos + self.RenderGlow.Normal * 0.5, self.RenderGlow.Angle, 0.1 )
				surface.SetMaterial( Mat )
				surface.SetDrawColor( 255, 93 + 60 * Scale, 60 * Scale, 200 * Scale )
				surface.DrawTexturedRectRotated( 0, 0, 300 , 300 , self.RenderGlow.RandomAng )
			cam.End3D2D()
		end
	else
		local Scale = (self.DieTime - CurTime()) / self.LifeTime
		render.SetMaterial( Mat )
		render.DrawSprite( self.Pos, 32, 32, Color( 255, 93 + 60 * Scale, 60 * Scale, 200 * Scale) ) 
	end
end

--addons/arccw_weapons/lua/effects/tfa_bullet_impact/init.lua:

-- Copyright (c) 2018-2020 TFA Base Devs

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

function EFFECT:Init(data)
	local posoffset = data:GetOrigin()
	local emitter = ParticleEmitter(posoffset)

	if TFA.GetGasEnabled() then
		local p = emitter:Add("sprites/heatwave", posoffset)
		p:SetVelocity(50 * data:GetNormal() + 0.5 * VectorRand())
		p:SetAirResistance(200)
		p:SetStartSize(math.random(12.5, 17.5))
		p:SetEndSize(2)
		p:SetDieTime(math.Rand(0.15, 0.225))
		p:SetRoll(math.Rand(-180, 180))
		p:SetRollDelta(math.Rand(-0.75, 0.75))
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
return false
end
--addons/arccw_weapons/lua/effects/tracer_red/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(255, 0, 0)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(255, 0, 0)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 255
        dlight.g = 0
        dlight.b = 0
        dlight.brightness = 7
        dlight.Decay = 1000
        dlight.Size = 500
        dlight.DieTime = CurTime() + 3
    end
end
end
--addons/gm_prone/lua/prone/sh_thirdparty_compat.lua:
-- This file adds various checks and fixes depending on the gamemode and thirdparty addons.

-- Checked for prone.CanEnter depending on the gamemode.
if DarkRP or GAMEMODE_NAME == "darkrp" or GAMEMODE.DerivedFrom == "darkrp" then
	hook.Add("prone.CanEnter", "prone.CanEnterDarkRP", function(ply)
		if prone.Config.Darkrp_RestrictJobs then
			local rank = ply:GetUserGroup()
			for i, v in ipairs(prone.Config.Darkrp_BypassRanks) do
				if v == rank then
					return true
				end
			end

			local ply_darkrpjob = ply:Team()
			for i, v in ipairs(prone.Config.Darkrp_Joblist) do
				if ply_darkrpjob == v then
					if prone.Config.Darkrp_IsWhitelist then
						return true
					else
						return false
					end
				end
			end

			-- If their job was not on the list and that list was not a whitelist then they can go prone.
			return not prone.Config.Darkrp_IsWhitelist
		end

		return true
	end)

elseif GAMEMODE_NAME == "prop_hunt" or GAMEMODE.DerivedFrom == "prop_hunt" then
	hook.Add("prone.CanEnter", "prone.CanEnterPropHunt", function(ply)
		if not GetGlobalBool("InRound", false) or (GetGlobalFloat("RoundStartTime", 0) + (HUNTER_BLINDLOCK_TIME or 0)) > CurTime() or ply:Team() ~= TEAM_HUNTERS then
			return false
		else
			return true
		end
	end)

elseif Clockwork then
	hook.Add("prone.CanEnter", "prone.CanEnterClockwork", function(ply)
		return not ply:IsRagdolled()
	end)
end

-- Disable viewmodel calcview for CW2.0
hook.Add("prone.ShouldChangeCalcViewModelView", "prone.DisableForCW2", function(localply)
	if CustomizableWeaponry then
		local weapon = localply:GetActiveWeapon()
		if IsValid(weapon) and weapon.CW20Weapon then
			return false
		end
	end
end)


-- TTT Movement support
hook.Add("TTTPlayerSpeed", "prone.RestrictMovement", function(ply)
	if ply:IsProne() then
		return prone.Config.MoveSpeed / 220	-- 220 is the default run speed in TTT
	end
end)

-- CombineControl's weird chatbox support.
if CLIENT and (GAMEMODE_NAME == "combinecontrol" or GAMEMODE.DerivedFrom == "combinecontrol") then
	local lastGetUpPrintTime = 0		-- Last time a print was made.
	local getUpWarningPrintDelay = 2	-- Time it takes before allowing another print.
	function prone.CantGetUpWarning()
		local ct = CurTime()

		if lastGetUpPrintTime < ct then
			GAMEMODE:AddChat(Color(210, 10, 10, 255), "CombineControl.ChatNormal", "There isn't enough room to stand up!", {CB_ALL, CB_IC})
			lastGetUpPrintTime = ct + getUpWarningPrintDelay
		end
	end
end

-- Disable ragdolling while prone to avoid dealing with annoying stuff.
-- This is untested but honestly Im not giving any attention to a commercial, non open-source, out-dated gamemode.
hook.Add("PlayerCanRagdoll", "prone.FixClockworkRagdoll", function(ply)
	if ply:IsProne() then
		return false
	end
end)