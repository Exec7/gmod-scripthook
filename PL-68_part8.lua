--Stealed clientside server code by exechack.cc
--Hostname: [PL] [PixelMod] PelugeRP SWRP | .gg/pixelmod - Part 8/10 - 06/04/2025


--PATH lua/autorun/antiplayerstuck.lua:
return gluapack()()
--PATH lua/arccw/shared/sh_controls.lua:
net.Receive("arccw_firemode", function(len, ply)
    local wpn = ply:GetActiveWeapon()

    if !wpn.ArcCW then return end

    wpn:ChangeFiremode()
end)

net.Receive("arccw_ubgl", function(len, ply)
    local on = net.ReadBool()
    local wpn = ply:GetActiveWeapon()

    if !wpn.ArcCW then return end

    if on then
        wpn:SelectUBGL()
    else
        wpn:DeselectUBGL()
    end
end)

if CLIENT then
    net.Receive("arccw_togglecustomize", function()
        if !LocalPlayer():GetActiveWeapon() or !LocalPlayer():GetActiveWeapon().ArcCW then return end
        LocalPlayer():GetActiveWeapon():ToggleCustomizeHUD(net.ReadBool())
    end)
elseif SERVER then
    net.Receive("arccw_togglecustomize", function(len, ply)
        local wpn = ply:GetActiveWeapon()
        local onoff = net.ReadBool()

        if !wpn.ArcCW then return end

        wpn:ToggleCustomizeHUD(onoff)
    end)
end

hook.Add("EntityTakeDamage", "ArcCW_CloseOnHurt", function(ply, dmg)
    if ply:IsPlayer() and ply:GetActiveWeapon() and ply:GetActiveWeapon().ArcCW
            and tobool(ply:GetInfo("arccw_attinv_closeonhurt"))
            and ply:GetActiveWeapon():GetState() == ArcCW.STATE_CUSTOMIZE then
        net.Start("arccw_togglecustomize")
            net.WriteBool(false)
        net.Send(ply)
        ply:GetActiveWeapon():ToggleCustomizeHUD(false)
    end
end)
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15a_barrel_short.lua:
att.PrintName = "15a Short-barrel"
att.Description = "Short length custom barrel. Improves handling, though offers much worse range and accuracy."
att.SortOrder = 40
att.Icon = Material("interfaz/armas/swrp_att_e11_top1.png")
att.Desc_Pros = {}
att.Desc_Cons = {}

att.AutoStats = true

att.Slot = "15a_barrel"
att.ActivateElements = {"15a_barrel_short"}

att.Mult_Range = 0.75
att.Mult_Recoil = 1.25
att.Mult_SightTime = 0.8
att.Mult_AccuracyMOA = 2

att.Mult_ShootPitch = 1.1
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15a_foregrip.lua:
att.PrintName = "15a Foregrip"
att.Description = "Rubberized grip for the DC-15a. Improves recoil at the cost of aim time."
att.SortOrder = 40
att.Icon = Material("interfaz/armas/swrp_att_e11_grip2.png")

att.AutoStats = true

att.Slot = "15a_foregrip"
att.ActivateElements = {"15a_foregrip"}

att.Mult_Recoil = 0.9
att.Mult_SightTime = 1.1
att.Mult_MoveSpeed = 0.95
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15s_stock_extended.lua:
att.PrintName = "15s Extended Stock"
att.Description = "Extended Stock for DC-15s. Improves the recoil."
att.Icon = Material("interfaz/armas/swrp_att_dlt20_stock.png")
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}

att.Slot = {"15s_stock"}
att.ActivateElements = {"15s_stock_skeleton"}

att.Mult_Damage = 1.05
att.Mult_SightTime = 1.15
att.Mult_Sway = 0.70
att.Mult_SpeedMult = 1.3
att.Mult_DrawTime = 0.76
att.Mult_HolsterTime = 1.05
att.Mult_HipDispersion = 0.90
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/arccw/shared/attachments/a280cfe_barrel_sniper.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_gl_thermal.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_heatbased.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_piercing.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/arccw/shared/attachments/ammunition_heat.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/bipod.lua:
att.PrintName = "Bipod"
att.Icon = Material("entities/acwatt_bipod.png")
att.Description = "Bipod can be deployed by pressing +USE while in an eligible spot. While deployed, the user's aiming angle is limited and recoil is reduced to near-zero. Moving will release bipod. While not in use, the bipod negatively impacts weapon maneuverability."

att.SortOrder = 10

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "bipod"

att.LHIK = true
att.LHIK_Animation = true

att.MountPositionOverride = 1

att.Model = "models/weapons/arccw/atts/bipod.mdl"
att.ModelScale = Vector(1.25, 1.25, 1.25)

att.Bipod = true
att.Mult_BipodRecoil = 0.25
att.Mult_BipodDispersion = 0.1

att.Mult_SightTime = 1.2
att.Mult_HipDispersion = 1.2
att.Mult_SpeedMult = 0.95

att.Hook_LHIK_TranslateAnimation = function(wep, anim)
    if anim == "idle" or anim == "in" or anim == "out" then
        if wep:InBipod() then
            return "idle_bipod"
        else
            return "idle"
        end
    end
end

att.Hook_Compatible = function(wep)
    if wep.Bipod_Integral then return false end
end
--PATH lua/arccw/shared/attachments/muzzle_cr2_pistol_mod.lua:
att.PrintName = "CR-2 Muzzle Mod"
att.Description = "Bulky and heavy, but provides better ballistic performance.\n\n\"By the time you figured it out, it would be too late.\""

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/atts/cr2_pistol_barrel_default.mdl"
att.ModelOffset = Vector(0, 0, 0)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = false
att.IsMuzzleDevice = false

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 1


att.Mult_RecoilSide = 0.75

att.Mult_ShootSpeedMult = 1.05
att.Mult_Sway = 1

att.Add_BarrelLength = 6
att.Mult_SightTime = 1.1
att.Mult_HipDispersion = 1.1
att.Mult_Range = 1
--PATH lua/arccw/shared/attachments/muzzle_heavy_dc15a_mod.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/optic_dc15a_scope.lua:
att.PrintName = "DC15a Magnifying Optic"
att.Icon = Material("entities/dlt19x_icon.png")
att.Description = "High-magnification sniper rifle scope for long range combat."

att.SortOrder = 9

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/atts/scope.mdl"
att.ModelOffset = Vector(0, 0, -0)
att.AdditionalSights = {
    {
        Pos = Vector(0, 9, -1.68),
        Ang = Angle(0, 0, 0),
        Magnification = 1.5,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 10,
        ZoomSound = "weapons/arccw/fiveseven/fiveseven_slideback.wav",
        IgnoreExtra = true
    }
}

att.ScopeGlint = false

att.Holosight = true
att.HolosightReticle = Material("scope/star_ret.png", "smooth")
att.HolosightNoFlare = true
att.HolosightSize = 12
att.HolosightBone = "holosight"
att.HolosightPiece = "models/atts/scope_hsp.mdl"
att.Colorable = false

att.HolosightMagnification = 0
att.HolosightBlackbox = true

att.HolosightConstDist = 64

att.HolosightMagnificationMin = 2
att.HolosightMagnificationMax = 3
att.HoloSightColorable = false

att.Mult_SightTime = 1.35
att.Mult_SightedSpeedMult = 0.8
att.Mult_SpeedMult = 0.9
--PATH lua/arccw/shared/attachments/optic_se.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/optic_se.lua:
att.PrintName = "Experimental Scope (SE)"
att.Icon = Material("entities/acwatt_optic_micro.png")
att.Description = "test scope for swrp"

att.SortOrder = 2

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = false
att.Slot = "swoptic_module_dcse"

att.Model = "models/weapons/arccw/atts/dc17c_sight.mdl"
att.HideModel = false
att.ModelScale = Vector(1.4, 1.4, 1.4)
att.ModelOffset = Vector(0, 0, 0)
att.OffsetAng = Angle(0, 90, 0)
att.AdditionalSights = {
    {
        Pos = Vector(0, 11.5, -2.3),
        Ang = Angle(0, 0, 0),
        Magnification = 2,
    }
}

att.Holosight = true
att.HolosightReticle = Material("#sw/visor/sw_ret_redux_blue.png", "smooth")
att.HolosightNoFlare = false
att.HolosightSize = 6
att.HolosightBone = "holosight"
att.HolosightPiece = "models/weapons/arccw/atts/dc17c_hsp.mdl"

att.HolosightMagnification = 2
att.HolosightBlackbox = true
att.HolosightNoHSP = false

att.Mult_SightTime = 1.08
att.Mult_SightedSpeedMult = 0.94
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_conditionoverload.lua:
att.PrintName = "Condition Overload"

att.Icon = Material("interfaz/armas/sw_powercell2.png")
att.Description = "With a little grease and some compression charge, most magazines can be made to accept an extra round."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true
att.Add_ClipSize = 20

att.Hook_Compatible = function(wep)
    if wep.RejectMagSizeChange or wep:GetCapacity() == 1 then return false end
end

att.NotForNPCs = true
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_gunslinger.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_gunslinger.lua:
att.PrintName = "Gunslinger"

att.Icon = Material("interfaz/iconos/kraken/jedi guns dirty fighting/1908223959_3315526753.png")
att.Description = "Specialist training and a little extra gun care allow you to cycle the action more quickly after a shot, improving your rate of fire."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true
att.Mult_CycleTime = .7

att.Hook_Compatible = function(wep)
    if wep:GetBuff_Override("Override_ManualAction", wep.ManualAction) then return end
    for i, v in pairs(wep.Firemodes) do
        if !v then continue end
        if v.Mode and v.Override_ManualAction then
            return
        end
    end
    return false
end

att.NotForNPCs = true
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_handyman.lua:
att.PrintName = "Handyman"
att.Icon = Material("interfaz/iconos/kraken/jedi guns dirty fighting/3726085931_3536543931.png")
att.Description = "Operate the firearm using only one hand. This improves weapon mobility, but accurate fire becomes difficult at best and near impossible at worst.\nBecause accuracy is already out the window, practictioners of this style also opt to shoot while sprinting at full speed."
att.Desc_Pros = {
    "+6% Coolness"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true

att.Override_ShootWhileSprint = true
att.Mult_HipDispersion = 0.75

att.Mult_Recoil = 1.5
att.Mult_RecoilSide = 2
att.Mult_SightTime = 1.5
att.Mult_Sway = 2
--att.Mult_MoveDispersion = 2
att.Mult_MoveSpeed = .95

att.LHIK = true
att.LHIKHide = true
att.Override_HoldtypeActive = "pistol"
att.Override_HoltypeActive_Priority = 999
att.Override_HoldtypeSights = "pistol"
att.Override_HoltypeSights_Priority = 999
att.Override_HoldtypeHolstered = "normal"

att.Hook_Compatible = function(wep, data)
    if wep:GetIsManualAction() and wep:GetBuff("HoldtypeActive") ~= "pistol" and wep:GetBuff("HoldtypeActive") ~= "revolver" then return false end
end

att.NotForNPCs = true
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_underload.lua:
att.PrintName = "Underload"

att.Icon = Material("interfaz/iconos/kraken/sith merc arsenal/756989185_3020183531.png")
att.Description = "Just because it fits, does not mean you have to fill it. Partially filled magazines reduces follower stress and improves feeding rate."
att.Desc_Pros = {
    "More fire rate, less reload time. More heat capacity & reliability"
}
att.Desc_Cons = {
    "Reduces ammo capacity."
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true
att.SortOrder = 1

function att.Hook_GetCapacity(wep, cap)
    return math.max(math.floor(cap * (1 - 0.14)), 1)
end

att.Hook_Compatible = function(wep)
    if wep.RejectMagSizeChange or wep:GetCapacity() == 1 then return false end
end


att.Mult_MalfunctionMean = 1.25
att.Mult_HeatCapacity = 1.25
att.Mult_RPM = 1.05
att.Mult_ReloadTime = 0.95

att.NotForNPCs = true
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_westernboi.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/rep_ubgl.lua:
att.PrintName = "Underbarrel Grenade-Launcher"
att.AbbrevName = "Underbarrel Grenade-Launcher"
att.Icon = Material("interfaz/iconos/jedi/453218427_4064545516.png", "mips smooth")
att.Description = "Single-shot underbarrel grenade launcher designed to Special Infantry."

att.SortOrder = -100000

att.AutoStats = true
att.Desc_Pros = {
}
att.Slot = "rep_ubgl"
att.ExcludeFlags = {"uc_noubgl"}
att.LHIK = true
att.ModelOffset = Vector(0, 0, 0)
att.Model = "models/weapons/arccw/atts/uc_ubgl_m203.mdl"
att.SelectUBGLSound =  ""
att.ExitUBGLSound = ""
att.UBGL = true
att.UBGL_PrintName = "UBGL"
att.UBGL_Automatic = false
att.UBGL_MuzzleEffect = "wpn_muzzleflash_dc17_orange"
att.UBGL_Ammo = "Grenade"
att.UBGL_RPM = 120
att.UBGL_Recoil = 2
att.UBGL_Capacity = 1
att.UBGL_ClipSize = 1
att.LHIK_GunDriver = 2
att.LHIK_CamDriver = 3

local function Ammo(wep)
    return (wep:GetOwner():GetAmmoCount("Grenade"))
end

att.Hook_LHIK_TranslateAnimation = function(wep, key)
    if key == "idle" then
        if wep:GetInUBGL() then
            return "idle_armed"
        else
            return "idle"
        end
    end
end

att.Hook_ShouldNotSight = function(wep)
    if wep:GetInUBGL() then
        return true
    end
end

att.Hook_OnSelectUBGL = function(wep)
    wep:SetNextSecondaryFire(CurTime() + 0.7)
    if (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoLHIKAnimation("to_armed", 0.7)
        wep:PlaySoundTable({
            {s = "arccw_uc/common/rattle_b2i_rifle.ogg", t = 0},
            {s = "arccw_uc/common/raise.ogg", t = 0.2},
            {s = "arccw_uc/common/grab.ogg", t = 0.5},
        })
    end
end

att.Hook_OnDeselectUBGL = function(wep)
    wep:SetNextSecondaryFire(CurTime() + 0.7)
    if (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoLHIKAnimation("to_idle", 0.7)
        wep:PlaySoundTable({
            {s = "arccw_uc/common/rattle_b2i_rifle.ogg", t = 0},
            {s = "arccw_uc/common/shoulder.ogg", t = 0.4},
        })
    end
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    local owner = wep:GetOwner()
    local class = wep:GetBuff_Override("UBGL_Entity") or "tfa_battlefront_ent_nade_impact"

    if class == "BUCKSHOT" then
        local dir = (owner:EyeAngles() + wep:GetFreeAimOffset()):Forward()

        local bullet = {
            DamageMax = 18,
            DamageMin = 6,
            Range = 50,
            RangeMin = 5,
            DamageType = DMG_BUCKSHOT + DMG_BULLET,
            Penleft = 0,
            Penetration = 0,
            Num = 1,
            Damaged = {},
            Weapon = wep,
        }

        local data = {
            Attacker = owner,
            Dir        = dir,
            Src        = wep:GetShootSrc(),
            Spread     = Vector(0, 0, 0),
            Damage     = 0,
            Num        = 1,
            Force      = 5,
            HullSize   = 4,
            Weapon     = wep,
            Callback = function(attacker, tr, dmg)
                -- HACK: Pass a fake bullet table instead of ourselves so we don't use the weapon's attributes unintentionally
                bullet.Travelled = (tr.HitPos - tr.StartPos):Length()
                ArcCW:BulletCallback(att, tr, dmg, bullet)
            end
        }

        if wep:GetOwner():IsPlayer() then
            for n = 1, 20 do
                local dirry = Vector(dir.x, dir.y, dir.z)
                math.randomseed(math.Round(util.SharedRandom(n, -1337, 1337, !game.SinglePlayer() and wep:GetOwner():GetCurrentCommand():CommandNumber() or CurTime()) * (wep:EntIndex() % 30241)))
                wep:ApplyRandomSpread(dirry, ArcCW.MOAToAcc * 50)
                data.Dir = dirry
                if GetConVar("arccw_bullet_enable"):GetBool() then
                    ArcCW:ShootPhysBullet(wep, data.Src, (250 / ArcCW.HUToM) * data.Dir:GetNormalized(), 0, bullet)
                else
                    owner:FireBullets(data, true)
                end
            end
        else
            data.Spread = Vector(ArcCW.MOAToAcc * 50, ArcCW.MOAToAcc * 50, 0)
            data.Num = 20
            owner:FireBullets(data, true)
        end
        wep:MyEmitSound(")^/arccw_uc/common/gl_fire_buck.ogg", 100, 100, 1, CHAN_WEAPON )
        wep:MyEmitSound(")^/arccw_uc/common/gl_fire_buck_dist.ogg", 149, 100, 0.5, CHAN_WEAPON + 1)
    else
        local proj = wep:FireRocket(class, 2500)
        if SERVER then
            proj.Damage = 130 -- lower than the m79 (200) for balance reasons
        end
        wep:MyEmitSound(")^/arccw_uc/common/40mm/fire-0" .. math.random(1, 6) .. ".ogg", 100, 100, 1, CHAN_WEAPON)
        wep:MyEmitSound(")^/arccw_uc/common/40mm/fire-dist-0" .. math.random(1, 6) .. ".ogg", 149, 100, 0.5, CHAN_BODY)
        wep:MyEmitSound(")^/arccw_uc/common/40mm/mech-0" .. math.random(1, 6) .. ".ogg", 149, 100, 0.5, CHAN_AUTO)
    end

    if game.SinglePlayer() and SERVER or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoEffects()
        wep:DoLHIKAnimation("fire")
    end
    wep:SetClip2(wep:Clip2() - 1)
    wep:DoEffects()
end

local casing = {"arccw_uc/common/40mm/casing-40mm-01.ogg", "arccw_uc/common/40mm/casing-40mm-02.ogg", "arccw_uc/common/40mm/casing-40mm-03.ogg", "arccw_uc/common/40mm/casing-40mm-04.ogg", "arccw_uc/common/40mm/casing-40mm-05.ogg", "arccw_uc/common/40mm/casing-40mm-06.ogg"}

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end
    if Ammo(wep) <= 0 then return end

    wep:SetNextSecondaryFire(CurTime() + 2.75)

    local holy = (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted())
    if holy then
        wep:DoLHIKAnimation("reload", 2.75)
        wep:PlaySoundTable({
            {s = { "arccw_uc/common/rattle1.ogg", "arccw_uc/common/rattle2.ogg", "arccw_uc/common/rattle3.ogg" }, t = 0},
            {s = "arccw_uc/common/40mm/203open.ogg", t = 0.2},
            {s = casing, t = 0.7},
            {s = "arccw_uc/common/magpouch_replace_small.ogg", t = 0.9},
            {s = "arccw_uc/common/40mm/203insert.ogg", t = 1.2},
            {s = "arccw_uc/common/shoulder.ogg", t = 1.5},
            {s = "arccw_uc/common/40mm/203close.ogg", t = 1.7},
            {s = "arccw_uc/common/shoulder.ogg", t = 2.3},
        })
    end

    local reserve = Ammo(wep)
    reserve = reserve + wep:Clip2()
    local clip = 1
    local load = math.Clamp(clip, 0, reserve)
    wep:SetClip2(load)
end

att.Mult_SightTime = 1.2
att.Mult_SpeedMult = 0.9
att.Mult_SightedSpeedMult = 0.85
att.ToggleLockDefault = false
att.ToggleStats = {
    {
        PrintName = "Impact Grenade",
        UBGL_Entity = "tfa_battlefront_ent_nade_impact"
    },
    {
        PrintName = "Poison Grenade",
        UBGL_Entity = "tfa_battlefront_ent_nade_poison"
    },
    {
        PrintName = "Smoke Grenade",
        UBGL_Entity = "tfa_battlefront_ent_nade_smoke"
    },
    {
        PrintName = "Bacta Grenade",
        UBGL_Entity = "tfa_battlefront_ent_nade_heal"
    }
}
--PATH lua/arccw/shared/attachments/sw_imperial_stun.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/sw_imperial_stun.lua:
att.PrintName = "[ Starwars ] Stun Rounds"
att.AbbrevName = "Stun round (5 seconds)"
att.SortOrder = -2
att.Icon = Material("")
att.Description = "Stun round."

att.Desc_Pros = {
    "Causes stun for 5 seconds!"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}

att.Slot = {"sw_imp_ammo"}

att.SortOrder = -9001
att.AutoStats = true

att.Override_AmmoPerShot = 5
att.Override_Num_Priority = 9001
att.Mult_RPM = 0.5
att.Override_Tracer = "effect_sw_laser_blue_stun"

att.Hook_BulletHit = function(wep, data)
	GMSERV:AddStatus(data.tr.Entity, data.att, "stun", 5, 5, true) --Entity,Owner,Status Effect Type (Yes, you can add the others),Duration, Damage, ParticleEffect
end

att.Hook_GetShootSound = function(wep, sound)
    return false
end

att.Hook_AddShootSound = function(wep, data)
    wep:MyEmitSound("w/e11_stun.wav", data.volume, data.pitch, 1, CHAN_WEAPON - 1)
end
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/sw_mag_dc15a_100drum.lua:
att.PrintName = "SW-Drum Magazine"
att.AbbrevName = "100-Round Mag"
att.SortOrder = 100
att.Icon = nil
att.Description = "Twin-drum magazine, ideal for suppressive fire. Bulky construction and high ammo capacity substantially increases weight, making the weapon difficult to handle. Prone to failures."
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "dc15a_magazine_100"

att.Model = "models/weapons/arccw/atts/magazine/rt97_rifle_magazine.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(0, 0, -90)

att.AutoStats = true

att.HideIfBlocked = true

att.Override_ClipSize = 100

att.Mult_SightTime = 1.4
att.Mult_ReloadTime = 1.7
att.Mult_Sway = 2.1

att.Mult_SpeedMult = 0.9
att.Mult_ShootSpeedMult = 0.8

att.Mult_DrawTime = 1.25
att.Mult_HolsterTime = 1.25

att.Mult_HipDispersion = 1.3

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/sw_mag_dc17m_85mag.lua:
att.PrintName = "SW-Extended Magazine"
att.AbbrevName = "85-Round Mag"
att.SortOrder = 100
att.Icon = nil
att.Description = "Extended magazine, ideal for additional fire support. Slight Bulky construction and additional ammo capacity increases weight, making the weapon difficult to handle"
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "dc17m_ext"

att.Model = "models/arccw/cs574/dc17m/dc17m_drummag.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(0, 0, -90)
att.ModelOffset = Vector(-0.5, -6.9, -2.3)
att.ModelScale = Vector(1, 1, 1)

att.AutoStats = true

att.HideIfBlocked = true

att.Override_ClipSize = 85

att.Mult_SightTime = 1.05
att.Mult_Sway = 2.1

att.Mult_SpeedMult = 0.95
att.Mult_ShootSpeedMult = 0.95

att.Mult_DrawTime = 1.25
att.Mult_HolsterTime = 1.25

att.Mult_HipDispersion = 1.3

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/sw_stun15.lua:
att.PrintName = "Stun Rounds - 15s"
att.AbbrevName = "Stun Rounds - 15s"
att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/stun15.png")
att.Description = "Replace the main-fire for stun rounds."

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"sw_ammo"}

att.AutoStats = true
att.Override_AmmoPerShot = 5
att.Override_Tracer = "effect_sw_laser_blue_stun"
att.Hook_BulletHit = function(wep, data)
	GMSERV:AddStatus(data.tr.Entity, data.att, "stun", 15, 1, true) --Entity,Owner,Status Effect Type (Yes, you can add the others),Duration, Damage, ParticleEffect
end
att.Hook_GetShootSound = function(wep, sound)
    return false
end
att.Hook_AddShootSound = function(wep, data)
    wep:MyEmitSound("everfall/weapons/republic/stun.wav", data.volume, data.pitch, 1, CHAN_WEAPON - 1)
end
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/sw_stun30.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/valken38_sling.lua:
att.PrintName = "Valken 38 Sling"
att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/sling.png", "mips smooth")
att.Description = "Assault sling which improves recoil control and stability but takes longer to aim with."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.AutoStats = true

att.Slot = {"sw_sling"}
att.ActivateElements = {"sw_sling"}

att.Mult_Recoil = 0.85
att.Mult_RecoilSide = 0.75
att.Mult_SightTime = 1.1
att.Mult_HipDispersion = 1.25
--PATH lua/arccw/shared/languages/base_en.lua:
return gluapack()()
--PATH lua/arccw/shared/sh_quicknade.lua:
return gluapack()()
--PATH lua/arccw/client/cl_binds.lua:
ArcCW.KEY_FIREMODE        = "+zoom"
ArcCW.KEY_FIREMODE_ALT    = "arccw_firemode"
ArcCW.KEY_ZOOMIN          = "invnext"
ArcCW.KEY_ZOOMIN_ALT      = "arccw_zoom_in"
ArcCW.KEY_ZOOMOUT         = "invprev"
ArcCW.KEY_ZOOMOUT_ALT     = "arccw_zoom_out"
ArcCW.KEY_TOGGLEINV       = "+menu_context"
ArcCW.KEY_TOGGLEINV_ALT   = "arccw_toggle_inv"
ArcCW.KEY_SWITCHSCOPE     = "+use"
ArcCW.KEY_SWITCHSCOPE_ALT = "arccw_switch_scope"
ArcCW.KEY_TOGGLEUBGL      = "arccw_toggle_ubgl"
ArcCW.KEY_TOGGLEATT       = "arccw_toggle_att"
ArcCW.KEY_MELEE           = "arccw_melee"

ArcCW.BindToEffect = {
    [ArcCW.KEY_FIREMODE]    = "firemode",
    [ArcCW.KEY_ZOOMIN]      = "zoomin",
    [ArcCW.KEY_ZOOMOUT]     = "zoomout",
    [ArcCW.KEY_TOGGLEINV]   = "inv",
    [ArcCW.KEY_SWITCHSCOPE] = "switchscope_dtap",
}

ArcCW.BindToEffect_Unique = {
    [ArcCW.KEY_TOGGLEUBGL]      = "ubgl",
    [ArcCW.KEY_SWITCHSCOPE_ALT] = "switchscope",
    [ArcCW.KEY_FIREMODE_ALT]    = "firemode",
    [ArcCW.KEY_ZOOMIN_ALT]      = "zoomin",
    [ArcCW.KEY_ZOOMOUT_ALT]     = "zoomout",
    [ArcCW.KEY_TOGGLEINV_ALT]   = "inv",
    [ArcCW.KEY_TOGGLEATT]       = "toggleatt",
    [ArcCW.KEY_MELEE]           = "melee",
}

local lastpressZ = 0
local lastpressE = 0

function ArcCW:GetBind(bind)
    local button = input.LookupBinding(bind)

    return button == "no value" and bind .. " unbound" or button
end

local function ArcCW_TranslateBindToEffect(bind)
    local alt = ArcCW.ConVars["altbindsonly"]:GetBool()
    if alt then
        return ArcCW.BindToEffect_Unique[bind], true
    else
        return ArcCW.BindToEffect_Unique[bind] or ArcCW.BindToEffect[bind] or bind, ArcCW.BindToEffect_Unique[bind] != nil
    end
end

local function SendNet(string, bool)
    net.Start(string)
    if bool != nil then net.WriteBool(bool) end
    net.SendToServer()
end

local function DoUbgl(wep)
    if wep:GetInUBGL() then
        SendNet("arccw_ubgl", false)

        wep:DeselectUBGL()
    else
        SendNet("arccw_ubgl", true)

        wep:SelectUBGL()
    end
end

local debounce = 0
local function ToggleAtts(wep)
    if debounce > CurTime() then return end -- ugly hack for double trigger
    debounce = CurTime() + 0.15
    local sounds = {}
    for k, v in pairs(wep.Attachments) do
        local atttbl = v.Installed and ArcCW.AttachmentTable[v.Installed]
        if atttbl and atttbl.ToggleStats and !v.ToggleLock then
            if atttbl.ToggleSound then sounds[atttbl.ToggleSound] = true
            else sounds["weapons/arccw/firemode.wav"] = true end
            wep:ToggleSlot(k, nil, true)
        end
    end
    for snd, _ in pairs(sounds) do
        surface.PlaySound(snd)
    end
end

local function ArcCW_PlayerBindPress(ply, bind, pressed)
    if !(ply:IsValid() and pressed) then return end

    local wep = ply:GetActiveWeapon()

    if !wep.ArcCW then return end

    local block = false

    if GetConVar("arccw_nohl2flash"):GetBool() and bind == "impulse 100" then
        ToggleAtts(wep)

        if ply:FlashlightIsOn() then return false end -- if hl2 flahslight is on we will turn it off as expected

        return true -- we dont want hl2 flashlight
     end

    local alt
    bind, alt = ArcCW_TranslateBindToEffect(bind)

    if bind == "firemode" and (alt or true) and !ply:KeyDown(IN_USE) then
		SendNet("arccw_firemode")
		wep:ChangeFiremode()

        block = true
    elseif bind == "inv" and !ply:KeyDown(IN_USE) and ArcCW.ConVars["enable_customization"]:GetInt() > -1 then

        local state = wep:GetState() != ArcCW.STATE_CUSTOMIZE

        SendNet("arccw_togglecustomize", state)

        wep:ToggleCustomizeHUD(state)

        block = true
    elseif bind == "ubgl" then
        DoUbgl(wep)
    elseif bind == "toggleatt" then
        ToggleAtts(wep)
    end

    if wep:GetState() == ArcCW.STATE_SIGHTS then
        if bind == "zoomin" then
            wep:Scroll(1)
            block = true
        elseif bind == "zoomout" then
            wep:Scroll(-1)
            block = true
        elseif bind == "switchscope_dtap" then
            if lastpressE >= CurTime() - 0.25 then
                wep:SwitchActiveSights()
                lastpressE = 0
            else
                lastpressE = CurTime()
            end
        elseif bind == "switchscope" then
            wep:SwitchActiveSights()
            block = true
        end
    end

    if bind == "melee" and wep:GetState() != ArcCW.STATE_SIGHTS then
        wep:Bash()
    end

    if block then return true end
end

hook.Add("PlayerBindPress", "ArcCW_PlayerBindPress", ArcCW_PlayerBindPress)

-- Actually register the damned things so they can be bound
for k, v in pairs(ArcCW.BindToEffect_Unique) do
    concommand.Add(k, function(ply) ArcCW_PlayerBindPress(ply, k, true) end, nil, v, 0)
end

-- ArcCW.CaptureKeys = {
--     KEY_G
-- }
-- ArcCW.LastInputs = {}
-- ArcCW.Inputs = {}

-- local function ArcCW_CustomInputs()
--     local inputs = {}

--     for _, i in pairs(ArcCW.CaptureKeys) do
--         -- local conv = GetConVar(i)

--         -- if !conv then continue end
--         -- if !IsValid(conv) then continue end

--         local kc = i

--         inputs[kc] = input.IsKeyDown(kc)
--     end

--     ArcCW.LastInputs = ArcCW.Inputs
--     ArcCW.Inputs = inputs

--     if ArcCW:KeyPressed(KEY_G) then
--         ArcCW:QuickNade("frag")
--     end
-- end

-- hook.Add("Think", "ArcCW_CustomInputs", ArcCW_CustomInputs)

-- function ArcCW:KeyPressed(key)
--     if !ArcCW.LastInputs[key] and ArcCW.Inputs[key] then
--         return true
--     end

--     return false
-- end
--PATH lua/arccw/client/cl_garbage.lua:
return gluapack()()
--PATH lua/arccw/client/cl_glint.lua:
return gluapack()()
--PATH lua/arccw/client/cl_hud.lua:
local hide = {
    ["CHudHealth"] = true,
    ["CHudBattery"] = true,
    ["CHudAmmo"] = true,
    ["CHudSecondaryAmmo"] = true,
}

CreateClientConVar("arccw_hud_togglestats", "0")

ArcCW.HUDElementConVars = {
    ["CHudHealth"] = CreateClientConVar("arccw_hud_showhealth", "1"),
    ["CHudBattery"] = ArcCW.ConVars["hud_showhealth"],
    ["CHudAmmo"] = CreateClientConVar("arccw_hud_showammo", "1"),
    ["CHudSecondaryAmmo"] = ArcCW.ConVars["hud_showammo"],
}

local grad = Material("arccw/hud/grad.png", "mips smooth")
hook.Add("PreDrawViewModels", "ArcCW_PreDrawViewmodels_Grad", function()
    if ArcCW.InvHUD and !grad:IsError() then
        render.SetViewPort( 0, 0, ScrW(), ScrH() )
        cam.Start2D()
            surface.SetDrawColor(Color(255, 255, 255, Lerp(ArcCW.Inv_Fade-0.01, 0, 255)))
            surface.SetMaterial(grad)
            surface.DrawTexturedRect(0, 0, ScrW(), ScrH())
        cam.End2D()
    end
end)

hook.Add("HUDShouldDraw", "ArcCW_HideHUD", function(name)
    if !hide[name] then return end
    if !LocalPlayer():IsValid() then return end
    if !LocalPlayer():GetActiveWeapon().ArcCW then return end
    if ArcCW.ConVars["override_hud_off"]:GetBool() then return end
    if ArcCW.PollingDefaultHUDElements then return end
    if ArcCW.HUDElementConVars[name] and ArcCW.HUDElementConVars[name]:GetBool() == false then return end
    if engine.ActiveGamemode() == "terrortown" then return end

    return false
end)

hook.Add("RenderScreenspaceEffects", "ArcCW_ToyTown", function()
    if !LocalPlayer():IsValid() then return end
    local wpn = LocalPlayer():GetActiveWeapon()
    if !IsValid(wpn) then return end

    if !wpn.ArcCW then return end

    local delta = wpn:GetSightDelta()

    if delta < 1 then
        wpn:DoToyTown()
    end
end)

ArcCW.PollingDefaultHUDElements = false

function ArcCW:ShouldDrawHUDElement(ele)
    if !GetConVar("cl_drawhud"):GetBool() then return false end
    if ArcCW.ConVars["override_hud_off"]:GetBool() then return false end

    if engine.ActiveGamemode() == "terrortown" and (ele != "CHudAmmo") then return false end

    if ArcCW.HUDElementConVars[ele] and !ArcCW.HUDElementConVars[ele]:GetBool() then
        return false
    end

    ArcCW.PollingDefaultHUDElements = true

    if !ArcCW.ConVars["hud_forceshow"]:GetBool() and hook.Call("HUDShouldDraw", nil, ele) == false then
        ArcCW.PollingDefaultHUDElements = false
        return false
    end

    ArcCW.PollingDefaultHUDElements = false

    return true
end

local function GetFont()
    local font = "Bahnschrift"

    if ArcCW.GetTranslation("default_font") then
        font = ArcCW.GetTranslation("default_font")
    end

    if ArcCW.ConVars["font"]:GetString() != "" then
        font = ArcCW.ConVars["font"]:GetString()
    end

    return font
end

-- Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes.
-- What is the size of your ass. What is it. Tell me.
local ScreenScale_CacheC2 = {}
ArcCW.AugmentedScreenScale = function(size)
    if ScreenScale_CacheC2[size] then return ScreenScale_CacheC2[size] end

    local scrw, scrh = ScrW(), ScrH()
    if vrmod and vrmod.IsPlayerInVR(LocalPlayer()) then
        -- Other resolutions seem to cause stretching issues
        scrw = 1366
        scrh = 768
    end

    local scrwmult = ArcCW.ConVars["hud_deadzone_x"]:GetFloat() * scrw
    local scrhmult = ArcCW.ConVars["hud_deadzone_y"]:GetFloat() * scrh

    scrw, scrh = scrw - scrwmult, scrh - scrhmult

    local r = size
    r = r * (math.max(scrw, scrh) / 800)
    r = r * ArcCW.ConVars["hud_size"]:GetFloat()
    ScreenScale_CacheC2[size] = r
    return r
end

local sizes_to_make = {
    6,
    8,
    10,
    12,
    14,
    16,
    20,
    24,
    26,
    32
}

local sizes_to_make_cust2 = {
    8,
    10,
    12,
    14,
    16,
    24,
    32
}

local unscaled_sizes_to_make = {
    32,
    24
}

local function generatefonts()

    for _, i in pairs(sizes_to_make) do

        surface.CreateFont( "ArcCW_" .. tostring(i), {
            font = GetFont(),
            size = ScreenScale(i) * ArcCW.ConVars["hud_size"]:GetFloat(),
            weight = 0,
            antialias = true,
            extended = true, -- Required for non-latin fonts
        } )

        surface.CreateFont( "ArcCW_" .. tostring(i) .. "_Glow", {
            font = GetFont(),
            size = ScreenScale(i) * ArcCW.ConVars["hud_size"]:GetFloat(),
            weight = 0,
            antialias = true,
            blursize = 6,
            extended = true,
        } )

    end

    for _, i in pairs(sizes_to_make_cust2) do

        surface.CreateFont( "ArcCWC2_" .. tostring(i), {
            font = GetFont(),
            size = ArcCW.AugmentedScreenScale(i) * ArcCW.ConVars["hud_size"]:GetFloat(),
            weight = 0,
            antialias = true,
            extended = true, -- Required for non-latin fonts
        } )

        surface.CreateFont( "ArcCWC2_" .. tostring(i) .. "_Glow", {
            font = GetFont(),
            size = ArcCW.AugmentedScreenScale(i) * ArcCW.ConVars["hud_size"]:GetFloat(),
            weight = 0,
            antialias = true,
            blursize = 6,
            extended = true,
        } )

    end

    for _, i in pairs(unscaled_sizes_to_make) do

        surface.CreateFont( "ArcCW_" .. tostring(i) .. "_Unscaled", {
            font = GetFont(),
            size = i,
            weight = 0,
            antialias = true,
            extended = true,
        } )

    end

end

local og_ScreenScale = ScreenScale

local ScreenScale_Cache = {}

function ScreenScale(a)
    if ScreenScale_Cache[a] then return ScreenScale_Cache[a] end

    ScreenScale_Cache[a] = og_ScreenScale(a)
    return ScreenScale_Cache[a]
end

language.Add("SniperPenetratedRound_ammo", "Sniper Ammo")

generatefonts()
function ArcCW_Regen(full)
    if full then
        generatefonts()
        ScreenScale_Cache = {}
        ScreenScale_CacheC2 = {}
    end
    if IsValid(ArcCW.InvHUD) then
        ArcCW.InvHUD:Clear()
        ArcCW.InvHUD:Remove()
    end
end

--cvars.AddChangeCallback("arccw_dev_cust2beta",  function() ArcCW_Regen(true) end)
cvars.AddChangeCallback("arccw_hud_deadzone_x", function() ArcCW_Regen(true) end)
cvars.AddChangeCallback("arccw_hud_deadzone_y", function() ArcCW_Regen(true) end)
cvars.AddChangeCallback("arccw_hud_size",       function() ArcCW_Regen(true) end)
cvars.AddChangeCallback("arccw_font",           function() ArcCW_Regen(true) end)
hook.Add( "OnScreenSizeChanged", "ArcCW_Regen", function() ArcCW_Regen(true) end)

-- surface.CreateFont( "ArcCW_12", {
--     font = font,
--     size = ScreenScale(12),
--     weight = 0,
--     antialias = true,
-- } )

-- surface.CreateFont( "ArcCW_12_Glow", {
--     font = font,
--     size = ScreenScale(12),
--     weight = 0,
--     antialias = true,
--     blursize = 8,
-- } )

-- surface.CreateFont( "ArcCW_16", {
--     font = font,
--     size = ScreenScale(16),
--     weight = 0,
--     antialias = true,
-- } )

-- surface.CreateFont( "ArcCW_16_Glow", {
--     font = font,
--     size = ScreenScale(16),
--     weight = 0,
--     antialias = true,
--     blursize = 8,
-- } )

-- surface.CreateFont( "ArcCW_26", {
--     font = font,
--     size = ScreenScale(26),
--     weight = 0,
--     antialias = true,
-- } )

-- surface.CreateFont( "ArcCW_26_Glow", {
--     font = font,
--     size = ScreenScale(26),
--     weight = 0,
--     antialias = true,
--     blursize = 8,
-- } )
--PATH lua/arccw/client/cl_npc.lua:
hook.Add("PopulateMenuBar", "ArcCW_NPCWeaponMenu", function (menubar)
    local menu = menubar:AddOrGetMenu("ArcCW NPC Weapons")

    menu:AddCVar("None", "gmod_npcweapon", "none")
    menu:AddSpacer()

    local weaponlist = weapons.GetList()

    table.SortByMember(weaponlist, "PrintName", true)

    local cats = {}

    for _, k in pairs(weaponlist) do
        if weapons.IsBasedOn(k.ClassName, "arccw_base") and !k.NotForNPCs and !k.PrimaryBash and k.Spawnable then
            local cat = k.Category or "Other"

            if !cats[cat] then cats[cat] = menu:AddSubMenu(cat) end

            cats[cat]:SetDeleteSelf(false)
            cats[cat]:AddCVar(k.PrintName, "gmod_npcweapon", k.ClassName)
        end
    end
end)

net.Receive("arccw_npcgiverequest", function(len, ply)
    local class = GetConVar("gmod_npcweapon"):GetString()

    net.Start("arccw_npcgivereturn")
    net.WriteString(class)
    net.SendToServer()
end)
--PATH lua/arccw/client/cl_singleplayer.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/localizations/en-us.lua:
local language_code = "EN-US"

AWarn.Localization:RegisterLanguage( language_code, "American English" )

AWarn.Localization:AddDefinition( language_code, "welcome1", 					"Welcome to AWarn3!" )
AWarn.Localization:AddDefinition( language_code, "insufficientperms", 			"Insufficient permissions to run this command." )
AWarn.Localization:AddDefinition( language_code, "insufficientperms2", 			"Insufficient permissions to view this player's warnings." )
AWarn.Localization:AddDefinition( language_code, "commandnonexist", 			"This command does not exist." )
AWarn.Localization:AddDefinition( language_code, "invalidtargetid", 			"Invalid target or ID." )
AWarn.Localization:AddDefinition( language_code, "invalidtarget", 				"Invalid target." )
AWarn.Localization:AddDefinition( language_code, "reasonrequired", 				"Warning Reason is required." )
AWarn.Localization:AddDefinition( language_code, "remove1activewarn", 			"You removed 1 active warning from" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningid", 			"Deleted warning ID" )
AWarn.Localization:AddDefinition( language_code, "removeallwarnings", 			"You removed all warnings from" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningsfor", 			"Deleted all warnings for" )
AWarn.Localization:AddDefinition( language_code, "cantopenconsole", 			"You can't open the menu from the server console." )
AWarn.Localization:AddDefinition( language_code, "invalidoption", 				"Invalid Option." )
AWarn.Localization:AddDefinition( language_code, "invalidoptionvaluetype",		"Invalid Option Value Type." )
AWarn.Localization:AddDefinition( language_code, "optionsloaded",				"Options Loaded!" )
AWarn.Localization:AddDefinition( language_code, "nopunishment",				"No punishment for this warning count." )
AWarn.Localization:AddDefinition( language_code, "punishmentsloaded",			"Punishments Loaded!" )
AWarn.Localization:AddDefinition( language_code, "playernotallowedwarn",		"This player is not allowed to be warned." )
AWarn.Localization:AddDefinition( language_code, "warnmessage1",				"You were warned by %s for %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage2",				"You warned %s for %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage3",				"%s was warned by %s for %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage4",				"You were warned by %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage5",				"You warned %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage6",				"%s was warned by %s." )
AWarn.Localization:AddDefinition( language_code, "joinmessage1",				"has joined the server with warnings." )
AWarn.Localization:AddDefinition( language_code, "joinmessage2",				"Their last warning was on:" )
AWarn.Localization:AddDefinition( language_code, "joinmessage3",				"Welcome back to the server! It appears you have been warned in the past." )
AWarn.Localization:AddDefinition( language_code, "joinmessage4",				"You can view your warnings at any time by typing" )
AWarn.Localization:AddDefinition( language_code, "joinmessage5",				"Player is joining with active warnings: " )
AWarn.Localization:AddDefinition( language_code, "closemenu",					"Close Menu" )
AWarn.Localization:AddDefinition( language_code, "searchplayers",				"Search Players" )
AWarn.Localization:AddDefinition( language_code, "viewwarnings",				"Warnings" )
AWarn.Localization:AddDefinition( language_code, "configuration",				"Configuration" )
AWarn.Localization:AddDefinition( language_code, "clientoptions",				"User Options" )
AWarn.Localization:AddDefinition( language_code, "serveroptions",				"Server Options" )
AWarn.Localization:AddDefinition( language_code, "colorcustomization",			"Color Customization" )
AWarn.Localization:AddDefinition( language_code, "colorselection",				"Color Selection" )
AWarn.Localization:AddDefinition( language_code, "languageconfiguration",		"Language Customization" )
AWarn.Localization:AddDefinition( language_code, "selectlanguage",				"Select a Language" )
AWarn.Localization:AddDefinition( language_code, "enablekickpunish",			"Enable Kick Punishment" )
AWarn.Localization:AddDefinition( language_code, "enablebanpunish",				"Enable Ban Punishment" )
AWarn.Localization:AddDefinition( language_code, "enabledecay",					"Enable Active Warning Decay" )
AWarn.Localization:AddDefinition( language_code, "resetafterban",				"Reset Active Warnings After Ban" )
AWarn.Localization:AddDefinition( language_code, "allowwarnadmins",				"Allow Warn Admins" )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessage",			"Display warning count to player on join" )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessage",			"Display message to admins when player joins with warnings" )
AWarn.Localization:AddDefinition( language_code, "pressenter",					"Press Enter to Save Change" )
AWarn.Localization:AddDefinition( language_code, "entertosave",					"Enter to Save" )
AWarn.Localization:AddDefinition( language_code, "chatprefix",					"Chat Prefix" )
AWarn.Localization:AddDefinition( language_code, "warningdecayrate",			"Warning Decay Rate" )
AWarn.Localization:AddDefinition( language_code, "serverlanguage",				"Server Language" )
AWarn.Localization:AddDefinition( language_code, "punishmentsconfiguration",	"Punishment Configuration" )
AWarn.Localization:AddDefinition( language_code, "addpunishment",				"Add Punishment" )
AWarn.Localization:AddDefinition( language_code, "warnings",					"Warnings" )
AWarn.Localization:AddDefinition( language_code, "punishtype",					"Punishment Type" )
AWarn.Localization:AddDefinition( language_code, "punishlength",				"Punishment Length" )
AWarn.Localization:AddDefinition( language_code, "playermessage",				"Player Message" )
AWarn.Localization:AddDefinition( language_code, "playername",					"Player Name" )
AWarn.Localization:AddDefinition( language_code, "messagetoplayer",				"Message To Player" )
AWarn.Localization:AddDefinition( language_code, "servermessage",				"Server message" )
AWarn.Localization:AddDefinition( language_code, "messagetoserver",				"Message To Server" )
AWarn.Localization:AddDefinition( language_code, "deletewarning",				"Delete Warning" )
AWarn.Localization:AddDefinition( language_code, "punishaddmenu",				"Punishment Add Menu" )
AWarn.Localization:AddDefinition( language_code, "inminutes",					"In Minutes" )
AWarn.Localization:AddDefinition( language_code, "0equalperma",					"0 = Permanent" )
AWarn.Localization:AddDefinition( language_code, "use%",						"Use %s to show the player's name" )
AWarn.Localization:AddDefinition( language_code, "setdefault",					"Set Default" )
AWarn.Localization:AddDefinition( language_code, "showingownwarnings",			"Showing Your Own Warnings" )
AWarn.Localization:AddDefinition( language_code, "warnedby",					"Warned By" )
AWarn.Localization:AddDefinition( language_code, "warningserver",				"Warning Server" )
AWarn.Localization:AddDefinition( language_code, "warningreason",				"Warning Reason" )
AWarn.Localization:AddDefinition( language_code, "warningdate",					"Warning Date" )
AWarn.Localization:AddDefinition( language_code, "nothing",						"NOTHING" )
AWarn.Localization:AddDefinition( language_code, "submit",						"Submit" )
AWarn.Localization:AddDefinition( language_code, "connectedplayers",			"Connected Players" )
AWarn.Localization:AddDefinition( language_code, "displaywarningsfor",			"Displaying Warnings For" )
AWarn.Localization:AddDefinition( language_code, "activewarnings",				"Active Warnings" )
AWarn.Localization:AddDefinition( language_code, "selectedplayernowarnings",	"Selected player has no warnings on record." )
AWarn.Localization:AddDefinition( language_code, "selectplayerseewarnings",		"Select a player to see their warnings." )
AWarn.Localization:AddDefinition( language_code, "warnplayer",					"Warn Player" )
AWarn.Localization:AddDefinition( language_code, "reduceactiveby1",				"Reduce active warnings by 1" )
AWarn.Localization:AddDefinition( language_code, "playerwarningmenu",			"Player Warning Menu" )
AWarn.Localization:AddDefinition( language_code, "playersearchmenu",			"Player Search Menu" )
AWarn.Localization:AddDefinition( language_code, "warningplayer",				"Warning Player" )
AWarn.Localization:AddDefinition( language_code, "excludeplayers",				"Exclude players with no warning history" )
AWarn.Localization:AddDefinition( language_code, "searchforplayers",			"Search for players by name or SteamID64" )
AWarn.Localization:AddDefinition( language_code, "name",						"Name" )
AWarn.Localization:AddDefinition( language_code, "lastplayed",					"Last Played" )
AWarn.Localization:AddDefinition( language_code, "lastwarned",					"Last Warned" )
AWarn.Localization:AddDefinition( language_code, "never",						"Never" )
AWarn.Localization:AddDefinition( language_code, "playerid",					"Player ID" )
AWarn.Localization:AddDefinition( language_code, "lookupplayerwarnings",		"Lookup this player's warnings" )
AWarn.Localization:AddDefinition( language_code, "servername",					"Server Name" )
AWarn.Localization:AddDefinition( language_code, "punishmentoptions",			"Punishments" )
AWarn.Localization:AddDefinition( language_code, "kickpunishdescription",		"If enabled, AWarn3 can kick players from the server as a punishment." )
AWarn.Localization:AddDefinition( language_code, "banpunishdescription",		"If enabled, AWarn3 can ban players from the server as a punishment." )
AWarn.Localization:AddDefinition( language_code, "enabledecaydescription",		"If enabled, active warnings will decay over time." )
AWarn.Localization:AddDefinition( language_code, "reasonrequireddescription",	"If enabled, admins will be required to provide a reason in their warning." )
AWarn.Localization:AddDefinition( language_code, "resetafterbandescription",	"If enabled, a users active warnings will reset to 0 after they are banned by AWarn3." )
AWarn.Localization:AddDefinition( language_code, "logevents",					"Log Warning Events." )
AWarn.Localization:AddDefinition( language_code, "logeventsdescription",		"If enabled, actions within AWarn3 will be logged to a text file." )
AWarn.Localization:AddDefinition( language_code, "allowwarnadminsdescription",	"If enabled, admins will be able to warn other admins." )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessagedescription","If enabled, users who join the server will see a message in chat if they have warnings." )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessagedescription",	"If enabled, admins on the server will see when any player joins who has warnings." )
AWarn.Localization:AddDefinition( language_code, "chatprefixdescription",		"The chat command used for AWarn3 commands. Default: !warn" )
AWarn.Localization:AddDefinition( language_code, "warningdecayratedescription",	"The time (in minutes) a player needs to be connected for 1 active warning to decay." )
AWarn.Localization:AddDefinition( language_code, "servernamedescription",		"The name of this server. This is useful for multiple server setups." )
AWarn.Localization:AddDefinition( language_code, "selectlanguagedescription",	"This is the language that server messages will be displayed in." )
AWarn.Localization:AddDefinition( language_code, "theme",						"Interface Theme" )
AWarn.Localization:AddDefinition( language_code, "themeselect",					"Select Theme" )
AWarn.Localization:AddDefinition( language_code, "punishgroup",					"Punishment Group" )
AWarn.Localization:AddDefinition( language_code, "grouptoset",					"Group to Set" )
AWarn.Localization:AddDefinition( language_code, "viewnotes",					"View Player Notes" )
AWarn.Localization:AddDefinition( language_code, "playernotes",					"Player Notes" )
AWarn.Localization:AddDefinition( language_code, "interfacecustomizations",		"Interface Customizations" )
AWarn.Localization:AddDefinition( language_code, "enableblur",					"Enable Background Blur" )
AWarn.Localization:AddDefinition( language_code, "chooseapreset",				"Choose a preset (Optional)" )
AWarn.Localization:AddDefinition( language_code, "warningpresets",				"Presets" )
AWarn.Localization:AddDefinition( language_code, "addeditpreset",				"Add/Edit Preset" )
AWarn.Localization:AddDefinition( language_code, "presetname",					"Preset Name" )
AWarn.Localization:AddDefinition( language_code, "presetreason",				"Preset Reason" )
AWarn.Localization:AddDefinition( language_code, "customcommand",				"Custom Command" )
AWarn.Localization:AddDefinition( language_code, "customcommandplaceholder",				"Replacements -- %n: Player Name, %s: SteamID, %i: SteamID64" )
AWarn.Localization:AddDefinition( language_code, "confirm",					"Confirm" )
AWarn.Localization:AddDefinition( language_code, "cancel",				"Cancel" )
AWarn.Localization:AddDefinition( language_code, "deleteconfirmdialogue1",				"Confirm Delete All Warnings" )
AWarn.Localization:AddDefinition( language_code, "deleteconfirmdialogue2",				"You are about to delete all of this player's warnings." )
AWarn.Localization:AddDefinition( language_code, "deleteconfirmdialogue3",				"Please confirm this action" )
AWarn.Localization:AddDefinition( language_code, "removewhendeletewarning",				"Remove active warning when deleting warning" )
AWarn.Localization:AddDefinition( language_code, "removewhendeletewarningdescription",				"If enabled, 1 active warning will be removed form a player when a warning is deleted." )
--PATH addons/[admin] awarn3/lua/localizations/no.lua:
local language_code = "NO"

AWarn.Localization:RegisterLanguage( language_code, "Norwegian" )

AWarn.Localization:AddDefinition( language_code, "welcome1", 					"Velkommen til AWarn3!" )
AWarn.Localization:AddDefinition( language_code, "insufficientperms", 			"Du har ingen tilgang til denne kommandoen!" )
AWarn.Localization:AddDefinition( language_code, "insufficientperms2", 			"Du har ingen tilgang til og se denne profilen!" )
AWarn.Localization:AddDefinition( language_code, "commandnonexist", 			"Kommandoen eksisterer ikke." )
AWarn.Localization:AddDefinition( language_code, "invalidtargetid", 			"Ugyldig bruker eller ID." )
AWarn.Localization:AddDefinition( language_code, "invalidtarget", 				"Ugyldig bruker." )
AWarn.Localization:AddDefinition( language_code, "reasonrequired", 				"Du må ha en grunn til og gi straff" )
AWarn.Localization:AddDefinition( language_code, "remove1activewarn", 			"Du har fjernet 1 aktiv straff fra" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningid", 			"Slettet straffs ID" )
AWarn.Localization:AddDefinition( language_code, "removeallwarnings", 			"Du har fjernet alle straffer fra" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningsfor", 			"Slettet alle straffer for" )
AWarn.Localization:AddDefinition( language_code, "cantopenconsole", 			"Du kan ikke åpne menyen fra konsollen" )
AWarn.Localization:AddDefinition( language_code, "invalidoption", 				"Ugyldig instilling." )
AWarn.Localization:AddDefinition( language_code, "invalidoptionvaluetype",		"Ugyldig alternativstypetype." )
AWarn.Localization:AddDefinition( language_code, "optionsloaded",				"Instilling lastet!" )
AWarn.Localization:AddDefinition( language_code, "nopunishment",				"Ingen straff for denne advarselen teller." )
AWarn.Localization:AddDefinition( language_code, "punishmentsloaded",			"Advarsel lastet!" )
AWarn.Localization:AddDefinition( language_code, "playernotallowedwarn",		"Denne spilleren kan ikke blir straffet" )
AWarn.Localization:AddDefinition( language_code, "warnmessage1",				"Du har motatt en straff fra %s for %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage2",				"Du straffet %s for %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage3",				"%s var straffet av %s for %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage1",				"Du har motatt en straff fra %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage2",				"Du straffet %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage3",				"%s var straffet av %s." )
AWarn.Localization:AddDefinition( language_code, "joinmessage1",				"har joinet serveren med straffer." )
AWarn.Localization:AddDefinition( language_code, "joinmessage2",				"Siste motatt straff var:" )
AWarn.Localization:AddDefinition( language_code, "joinmessage3",				"Velkommen tilbake til serveren. Det ser ut som at du har blitt straffet tidligere" )
AWarn.Localization:AddDefinition( language_code, "joinmessage4",				"Du kan se dinne straffer ved og skrive" )
AWarn.Localization:AddDefinition( language_code, "closemenu",					"Lukk Meny" )
AWarn.Localization:AddDefinition( language_code, "searchplayers",				"Søk for spillere" )
AWarn.Localization:AddDefinition( language_code, "viewwarnings",				"Se straffer" )
AWarn.Localization:AddDefinition( language_code, "configuration",				"Konfigurasjon" )
AWarn.Localization:AddDefinition( language_code, "clientoptions",				"Bruker instillinger" )
AWarn.Localization:AddDefinition( language_code, "serveroptions",				"Server instillinger" )
AWarn.Localization:AddDefinition( language_code, "colorcustomization",			"Farge Konfigurasjoner" )
AWarn.Localization:AddDefinition( language_code, "colorselection",				"Farge Alternativer" )
AWarn.Localization:AddDefinition( language_code, "languageconfiguration",		"Språk konfigurasjon" )
AWarn.Localization:AddDefinition( language_code, "selectlanguage",				"Velg et språk" )
AWarn.Localization:AddDefinition( language_code, "enablekickpunish",			"Aktiver Kick Straff" )
AWarn.Localization:AddDefinition( language_code, "enablebanpunish",				"Aktiver Ban Straff" )
AWarn.Localization:AddDefinition( language_code, "enabledecay",					"Aktiver Straffs Forfalling" )
AWarn.Localization:AddDefinition( language_code, "resetafterban",				"Tilbakestill Aktive Straffer Etter Ban" )
AWarn.Localization:AddDefinition( language_code, "allowwarnadmins",				"Tilatt at administratorer kan bli straffet" )
AWarn.Localization:AddDefinition( language_code, "pressenter",					"Trykk 'ENTER' for og lagre endringer" )
AWarn.Localization:AddDefinition( language_code, "entertosave",					"'ENTER' for lagring" )
AWarn.Localization:AddDefinition( language_code, "chatprefix",					"Chat Prefix" )
AWarn.Localization:AddDefinition( language_code, "warningdecayrate",			"Straff forfalls tid ( minutter )" )
AWarn.Localization:AddDefinition( language_code, "serverlanguage",				"Server Språk")
AWarn.Localization:AddDefinition( language_code, "punishmentsconfiguration",	"Straffs konfigurasjon" )
AWarn.Localization:AddDefinition( language_code, "addpunishment",				"Legg till straff" )
AWarn.Localization:AddDefinition( language_code, "warnings",					"Straffer" )
AWarn.Localization:AddDefinition( language_code, "punishtype",					"Straffs type" )
AWarn.Localization:AddDefinition( language_code, "punishlength",				"Straff lengde" )
AWarn.Localization:AddDefinition( language_code, "playermessage",				"Spiller melding" )
AWarn.Localization:AddDefinition( language_code, "playername",					"Spiller navn" )
AWarn.Localization:AddDefinition( language_code, "messagetoplayer",				"Melding Til Spiller" )
AWarn.Localization:AddDefinition( language_code, "servermessage",				"Server Melding" )
AWarn.Localization:AddDefinition( language_code, "messagetoserver",				"Melding til Server" )
AWarn.Localization:AddDefinition( language_code, "deletewarning",				"Slett alle Straffer" )
AWarn.Localization:AddDefinition( language_code, "punishaddmenu",				"Straff legg til meny" )
AWarn.Localization:AddDefinition( language_code, "inminutes",					"I Minutter" )
AWarn.Localization:AddDefinition( language_code, "0equalperma",					"0 = Permanent" )
AWarn.Localization:AddDefinition( language_code, "use%",						"Bruk %s for og vise spillerens navn" )
AWarn.Localization:AddDefinition( language_code, "setdefault",					"Sett standard" )
AWarn.Localization:AddDefinition( language_code, "showingownwarnings",			"Viser dine egne Straffer" )
AWarn.Localization:AddDefinition( language_code, "warnedby",					"Straffet" )
AWarn.Localization:AddDefinition( language_code, "warningserver",				"Straff Server" )
AWarn.Localization:AddDefinition( language_code, "warningreason",				"Straff Grunn" )
AWarn.Localization:AddDefinition( language_code, "warningdate",					"Straff Dato" )
AWarn.Localization:AddDefinition( language_code, "nothing",						"INGENTING" )
AWarn.Localization:AddDefinition( language_code, "submit",						"OK" )
AWarn.Localization:AddDefinition( language_code, "connectedplayers",			"Tilkoblede spillere" )
AWarn.Localization:AddDefinition( language_code, "displaywarningsfor",			"Viser Straffer For" )
AWarn.Localization:AddDefinition( language_code, "activewarnings",				"Aktive Straffer" )
AWarn.Localization:AddDefinition( language_code, "selectedplayernowarnings",	"Valgt Spiller Har Ingen Straffer." )
AWarn.Localization:AddDefinition( language_code, "selectplayerseewarnings",		"Velg en spiller for og se straffene dems." )
AWarn.Localization:AddDefinition( language_code, "warnplayer",					"Straff Player" )
AWarn.Localization:AddDefinition( language_code, "reduceactiveby1",				"Reduser aktive straffer med 1" )
AWarn.Localization:AddDefinition( language_code, "playerwarningmenu",			"Spiller Straff Meny" )
AWarn.Localization:AddDefinition( language_code, "playersearchmenu",			"Spiller Søk Meny" )
AWarn.Localization:AddDefinition( language_code, "warningplayer",				"Straff Spiller" )
AWarn.Localization:AddDefinition( language_code, "excludeplayers",				"Ekskluder spillere uten straffs historikk" )
AWarn.Localization:AddDefinition( language_code, "searchforplayers",			"Søk etter spiller med 'Navn' eller 'SteamID64'" )
AWarn.Localization:AddDefinition( language_code, "name",						"Navn" )
AWarn.Localization:AddDefinition( language_code, "lastplayed",					"Sist Spilt" )
AWarn.Localization:AddDefinition( language_code, "lastwarned",					"Sist Straffet" )
AWarn.Localization:AddDefinition( language_code, "never",						"Aldri" )
AWarn.Localization:AddDefinition( language_code, "playerid",					"Spiller ID" )
AWarn.Localization:AddDefinition( language_code, "lookupplayerwarnings",		"Slå opp denne spillerens straffer" )
AWarn.Localization:AddDefinition( language_code, "servername",					"Server Navn" )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessage",			"Vis advarseltall for spilleren når han blir med" )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessage",			"Vis melding til administratorer når spilleren slutter seg til advarsler" )
AWarn.Localization:AddDefinition( language_code, "punishmentoptions",			"Straffer" )
AWarn.Localization:AddDefinition( language_code, "kickpunishdescription",		"Hvis den er aktivert, kan AWarn3 sparke spillere fra serveren som en straff." )
AWarn.Localization:AddDefinition( language_code, "banpunishdescription",		"Hvis aktivert, kan AWarn3 utestenge spillere fra serveren som en straff." )
AWarn.Localization:AddDefinition( language_code, "enabledecaydescription",		"Hvis aktivert, vil aktive advarsler avta over tid." )
AWarn.Localization:AddDefinition( language_code, "reasonrequireddescription",	"Hvis aktivert, må administratorer oppgi en årsak i advarselen." )
AWarn.Localization:AddDefinition( language_code, "resetafterbandescription",	"Hvis aktivert, vil en brukers aktive advarsler tilbakestilles til 0 etter at de er utestengt av AWarn3." )
AWarn.Localization:AddDefinition( language_code, "logevents",					"Logg varslingshendelser." )
AWarn.Localization:AddDefinition( language_code, "logeventsdescription",		"Hvis aktivert, vil handlinger i AWarn3 logges til en tekstfil." )
AWarn.Localization:AddDefinition( language_code, "allowwarnadminsdescription",	"Hvis aktivert, vil administratorer kunne advare andre administratorer." )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessagedescription","Hvis aktivert, vil brukere som blir med på serveren se en melding i chat hvis de har advarsler." )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessagedescription",	"Hvis aktivert, vil administratorer på serveren se når en spiller blir med som har advarsler." )
AWarn.Localization:AddDefinition( language_code, "chatprefixdescription",		"Chat-kommandoen som brukes for AWarn3-kommandoer. Standard: !warn" )
AWarn.Localization:AddDefinition( language_code, "warningdecayratedescription",	"Tiden (i minutter) en spiller må være tilkoblet for at 1 aktiv advarsel skal forfalle." )
AWarn.Localization:AddDefinition( language_code, "servernamedescription",		"Navnet på denne serveren. Dette er nyttig for flere serveroppsett." )
AWarn.Localization:AddDefinition( language_code, "selectlanguagedescription",	"Dette er språket som servermeldinger vises på." )
AWarn.Localization:AddDefinition( language_code, "theme",						"Grensesnittstema" )
AWarn.Localization:AddDefinition( language_code, "themeselect",					"Velg tema" )
AWarn.Localization:AddDefinition( language_code, "punishgroup",					"Straffegruppe" )
AWarn.Localization:AddDefinition( language_code, "grouptoset",					"Gruppe å angi" )
AWarn.Localization:AddDefinition( language_code, "viewnotes",					"Se spillernotater" )
AWarn.Localization:AddDefinition( language_code, "playernotes",					"Spillernotater" )
AWarn.Localization:AddDefinition( language_code, "interfacecustomizations",		"Grensesnitttilpasninger" )
AWarn.Localization:AddDefinition( language_code, "enableblur",					"Aktiver bakgrunnsuskarphet" )
AWarn.Localization:AddDefinition( language_code, "chooseapreset",				"Velg en forhåndsinnstilling (valgfritt)" )
AWarn.Localization:AddDefinition( language_code, "warningpresets",				"Forhåndsinnstillinger" )
AWarn.Localization:AddDefinition( language_code, "addeditpreset",				"Legg til/rediger forhåndsinnstilling" )
AWarn.Localization:AddDefinition( language_code, "presetname",					"Forhåndsinnstilt navn" )
AWarn.Localization:AddDefinition( language_code, "presetreason",				"Forhåndsinnstilt grunn" )
--PATH addons/[admin] awarn3/lua/includes/awarn3_permissions.lua:
AddCSLuaFile()
--[[
      __          __              ____  
     /\ \        / /             |___ \ 
    /  \ \  /\  / /_ _ _ __ _ __   __) |
   / /\ \ \/  \/ / _` | '__| '_ \ |__ < 
  / ____ \  /\  / (_| | |  | | | |___) |
 /_/    \_\/  \/ \__,_|_|  |_| |_|____/ 

	AWarn3 by Mr.President
]]

MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, "Loading Permissions Module\n" )

AWarn.Permissions = {}

function AWarn:RegisterPermission( pTbl )
	self.Permissions[ pTbl.permissionString ] = pTbl
end

function AWarn:LookupPermission( p )
	return self.Permissions[ p ] or false
end

function AWarn:CheckPermission( pl, p )
	if not self:LookupPermission( p ) then return false end
	return self:LookupPermission( p ).permissionCheck( pl )
end

function AWarn:AdminCompatStringCheck( pl, pString )
	if ulx then
		return ULib.ucl.query( pl, pString ) or false
	elseif sAdmin then
		return sAdmin.hasPermission(pl, pString) or false
	elseif CAMI then
		return CAMI.PlayerHasAccess( pl, pString, nil )
	elseif xAdmin then
		return pl:xAdminHasPermission( pString ) or false
	elseif serverguard then
		return serverguard.player:HasPermission(pl, pString) or false
	elseif SAM then
		return SAM.HasPermission(pl, pString)
	else
		if pl:IsSuperAdmin() then return true end
		if pl:IsAdmin() then return true end
		return false
	end
end

local PERMISSION = {}
PERMISSION.permissionString = "awarn_view"
PERMISSION.shortString = "AWarn View"
PERMISSION.description = "This allows a player to view other players' warnings."
PERMISSION.permissionCheck = function( pl )
	return AWarn:AdminCompatStringCheck( pl, PERMISSION.permissionString )
end
AWarn:RegisterPermission( PERMISSION )


local PERMISSION = {}
PERMISSION.permissionString = "awarn_warn"
PERMISSION.shortString = "AWarn Warn"
PERMISSION.description = "This allows a player to warn other players."
PERMISSION.permissionCheck = function( pl )
	return AWarn:AdminCompatStringCheck( pl, PERMISSION.permissionString )
end
AWarn:RegisterPermission( PERMISSION )


local PERMISSION = {}
PERMISSION.permissionString = "awarn_remove"
PERMISSION.shortString = "AWarn Remove"
PERMISSION.description = "This allows a player to decrease another player's active warnings."
PERMISSION.permissionCheck = function( pl )
	return AWarn:AdminCompatStringCheck( pl, PERMISSION.permissionString )
end
AWarn:RegisterPermission( PERMISSION )


local PERMISSION = {}
PERMISSION.permissionString = "awarn_delete"
PERMISSION.shortString = "AWarn Delete"
PERMISSION.description = "This allows a player to delete all warnings for a player."
PERMISSION.permissionCheck = function( pl )
	return AWarn:AdminCompatStringCheck( pl, PERMISSION.permissionString )
end
AWarn:RegisterPermission( PERMISSION )

local PERMISSION = {}
PERMISSION.permissionString = "awarn_options"
PERMISSION.shortString = "AWarn Options"
PERMISSION.description = "This allows a player to view and change the configurations for this script."
PERMISSION.permissionCheck = function( pl )
	return AWarn:AdminCompatStringCheck( pl, PERMISSION.permissionString )
end
AWarn:RegisterPermission( PERMISSION )

local PERMISSION = {}
PERMISSION.permissionString = "awarn_immune"
PERMISSION.shortString = "AWarn Immune"
PERMISSION.description = "Players with this permission will be immune to being warned by anyone."
PERMISSION.permissionCheck = function( pl )
	return AWarn:AdminCompatStringCheck( pl, PERMISSION.permissionString )
end
AWarn:RegisterPermission( PERMISSION )
--PATH addons/[misc] bodygroupr/lua/bodyman/arizard_derma.lua:
return gluapack()()
--PATH lua/autorun/cadet_pm.lua:
return gluapack()()
--PATH lua/autorun/cdraw.lua:
return gluapack()()
--PATH addons/[opt] decals/lua/decals/decals_config.lua:
-- Who is allowed to create and save decals
-- SteamIDs, SteamID64s and UserGroups supported
Decals.cfg.Allowed = {
    [ "STEAM_0:0:2316327" ] = true,
    [ "superadmin" ] = true,
}

-- Color for chat notifications and halos
Decals.cfg.Color = Color( 0, 178, 238 )

-- Render distance (distance at which the decal will disappear)
Decals.cfg.RenderDistance = 5000

-- Command to save decals (do not add ! or /)
Decals.cfg.ChatCommand = "savedecals"

-- Command to duplicate decals (do not add ! or /)
Decals.cfg.CopyCommand = "copydecal"

-- Command to remove the current decal (do not add ! or /)
Decals.cfg.RemoveCommand = "removedecal"

-- Command to clear all decals (do not add ! or /)
Decals.cfg.ClearCommand = "cleardecals"

-- Default image (what the decal is by default)
Decals.cfg.DefaultImage = "https://vignette.wikia.nocookie.net/tf2freakshow/images/3/36/GMod_Logo.png"

--PATH addons/[opt] decals/lua/decals/util/sh_properties.lua:
properties.Add( "Edit Decal", {
    MenuLabel = "Edit Decal",
    Order = 5000,
    MenuIcon = "icon16/pencil.png",
    Filter = function( self, ent, ply )
        if !ent:IsValid() or ent:GetClass() != "decal" or !Decals.Authed( ply ) then return false end

        return true
    end,
    Action = function( self, ent )
        Decals.Open( nil, ent )
    end,
    Receive = function( self, len, ply )
    end,
} )

properties.Add( "Duplicate Decal", {
    MenuLabel = "Duplicate Decal",
    Order = 5011,
    MenuIcon = "icon16/database_add.png",
    Filter = function( self, ent, ply )
        if !ent:IsValid() or ent:GetClass() != "decal" or !Decals.Authed( ply ) then return false end

        return true
    end,
    Action = function( self, ent )
        net.Start "Decals.Dupe"
        net.WriteEntity( ent )
        net.SendToServer()
    end,
    Receive = function( self, len, ply )
    end,
} )

properties.Add( "Remove Decal", {
    MenuLabel = "Remove Decal",
    Order = 5022,
    MenuIcon = "icon16/database_delete.png",
    Filter = function( self, ent, ply )
        if !ent:IsValid() or ent:GetClass() != "decal" or !Decals.Authed( ply ) then return false end

        return true
    end,
    Action = function( self, ent )
        net.Start "Decals.Remove"
        net.WriteEntity( ent )
        net.SendToServer()
    end,
    Receive = function( self, len, ply )
    end,
} )

--PATH addons/[opt] decals/lua/decals/vgui/draw.lua:
Decals.Draw = Decals.Draw or {}

function Decals.Draw.Rect( x, y, w, h, col )
    surface.SetDrawColor( col )
    surface.DrawRect( x, y, w, h )
end

function Decals.Draw.Circle( x, y, r, col )
    local circle = {}
    local c = 0

    for i = 1, 360 do
        c = math.rad( i )

        circle[ i ] = {
            x = x + r / 2 + math.cos( c ) * r,
            y = y + r / 2 + math.sin( c ) * r
        }
    end

    draw.NoTexture()
    surface.SetDrawColor( col )
    surface.DrawPoly( circle )
end

function Decals.Draw.LerpColor( oldCol, newCol, ease )
    return Color( Lerp( ease, oldCol.r, newCol.r ), Lerp( ease, oldCol.g, newCol.g ), Lerp( ease, oldCol.b, newCol.b ), Lerp( ease, oldCol.a, newCol.a ) )
end

FindMetaTable "Panel" .BLerpColor = function( self, oldCol, newCol )
    return Decals.Draw.LerpColor( oldCol, newCol, self.ease )
end

--PATH addons/[opt] decals/lua/decals/vgui/frame.lua:
surface.CreateFont( "Decals.Title", { font = "Roboto", size = 16, weight = 500 } )
surface.CreateFont( "Decals.Close", { font = "Roboto", size = 20, weight = 500 } )

local PANEL = {}

AccessorFunc( PANEL, "Edited", "Edited", FORCE_BOOL )
AccessorFunc( PANEL, "Resizing", "Resizing", FORCE_BOOL )

function PANEL:Init()
    self.btnMaxim:Remove()
    self.btnMinim:Remove()
    self.btnClose:Remove()

    self.lblTitle:SetFont "Decals.Title"

    self.ease = FrameTime() * 10

    self.closeColor = Color( 190, 90, 90 )

    self:SetEdited( false )
    self:SetResizing( false )

    self:SetAlpha( 0 )
    self:AlphaTo( 255, .2 )

    self.topPadding = 30

    self:DockPadding( 5, self.topPadding + 5, 5, 5 )

    self.CloseButton = vgui.Create( "DButton", self )
    self.CloseButton:SetText "✕"
    self.CloseButton:SetTextColor( color_white )
    self.CloseButton:SetFont "Decals.Close"
    self.CloseButton.Paint = function()
    end
    self.CloseButton.Think = function( s )
        s:SetTextColor( self:BLerpColor( s:GetTextColor(), ( s.Hovered and Color( 190, 90, 90 ) or color_white ) ) )
    end
    self.CloseButton.DoClick = function( s )
        self:AlphaTo( 0, .2, 0, function()
            self:Remove()
        end )
    end
end

function PANEL:Think()
    DFrame.Think( self )

    if self:GetEdited() and !self:GetResizing() then
        self:SetResizing( true )

        local child = self:GetChild( #self:GetChildren() - 1 )

        child:AlphaTo( 255, .3 )
    end
end

function PANEL:PerformLayout( w, h )
    self.lblTitle:SizeToContents()
    self.lblTitle:SetPos( 10, self.topPadding / 2 - self.lblTitle:GetTall() / 2 )

    self.CloseButton:SizeToContents()
    self.CloseButton:SetPos( w - self.CloseButton:GetWide() - 5, self.topPadding / 2 - self.CloseButton:GetTall() / 2  )
end

function PANEL:Paint( w, h )
    -- sizeto kept breaking
    -- hacky boiz
    local child = self.sections.Save

    h = h - 31 - 10
    h = h + ( ( child:GetTall() + 20 ) ) * ( child:GetAlpha() * 2 / 255 * 2 )

    Decals.Draw.Rect( 0, 0, w, h, Color( 36, 41, 47 ) )
    Decals.Draw.Rect( 0, 0, w, self.topPadding, Color( 24, 27, 30 ) )
end

vgui.Register( "Decals.Frame", PANEL, "DFrame" )

--PATH addons/[opt] decals/lua/decals/vgui/button.lua:
local PANEL = {}

function PANEL:Init()
    self:SetTextColor( color_white )
    self:SetFont "Decals.Header"

    self.hoverCol = Color( 40, 130, 215 )
    self.ease = FrameTime() * 10
end

function PANEL:Paint( w, h )
    self.hoverCol = self:BLerpColor( self.hoverCol, self.Hovered and Color( 20, 90, 190 ) or Color( 40, 130, 215 ) )

    draw.RoundedBox( 4, 0, 0, w, h, self.hoverCol )
end

vgui.Register( "Decals.Button", PANEL, "DButton" )

--PATH addons/!discordintegration/lua/discord/modules/relay/sh_module.lua:
return gluapack()()
--PATH lua/autorun/dw.lua:
player_manager.AddValidModel( "pm_deathwatch_grunt", "models/dw_grunt/pm_deathwatch_grunt.mdl" )
player_manager.AddValidModel( "pm_deathwatch_cpt", "models/dw_cpt/pm_deathwatch_cpt.mdl" )
player_manager.AddValidModel( "pm_deathwatch_nightowl", "models/dw_nightowl/pm_deathwatch_nightowl.mdl" )
player_manager.AddValidModel( "pm_deathwatch_bokatan", "models/dw_bokatan/pm_deathwatch_bokatan.mdl" )
player_manager.AddValidModel( "pm_deathwatch_previzsla", "models/dw_previzsla/pm_deathwatch_previzsla.mdl" )
player_manager.AddValidModel( "pm_deathwatch_maul_brute", "models/dw_brute/pm_deathwatch_maul_brute.mdl" )
player_manager.AddValidModel( "pm_deathwatch_maul_sgt", "models/dw_sgt/pm_deathwatch_maul_sgt.mdl" )
player_manager.AddValidModel( "pm_deathwatch_maul_huntress", "models/dw_huntress/pm_deathwatch_maul_huntress.mdl" )
player_manager.AddValidModel( "pm_deathwatch_maul_garsaxon", "models/dw_garsaxon/pm_deathwatch_maul_garsaxon.mdl" )
--PATH addons/[tfres] frest_levels/lua/autorun/frestloader2.lua:
local rootDirectory = "fstands2"
--local troy = "troy"
if troy then return end
function MRBEAST()
print([[
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,..,,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,....  ..,,.,,,*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,.... .. ..,,.,..,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,         .  .*//(/,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, 
,,,,,,,,,,,,,,,,,,,,,,,,,,     .,*,/,,,/###/%,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,... ,((/*.,*..#**%,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,(#%,/&,,,,.*,,/(####%#####&&&,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,%((#,##/,,,,,,(//(((/((**.,#/*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,]])
print([[,,,,,,,,,,,,,,//(##,%%%,,,,,,,,*//***,.,,,/%(,,,,,,,,,,,,,,,/(,,//,,,,,,,,,,,,,,
,,,,,,,,,,,,,(*/((####%,,,,,#*///***,****/(##(%&%&,,,,,,,,,,/(,(/,,,/(,,,,,,,,,,
,,,,,,,,,,,,/*/#(###%%#,,%####(//***,...,,,(&####&&&,,,,,,,,((((,///,,,,,,,,,,,,
,,,,,,,,,,,,/%%###%##%%%########(/**//(#,%&%&%#&&#%&&&,,,,,(////(/,,(((#,,,,,,,,
,,,,,,,,,,,(/*(%&%%%%%%%%%#%##(#%((/(((#%%%%%%%%&&%###%&,#//******/,,,,,,,,,,,,,
,,,,,,,,,,*,(&%#%%###%%%%%%%&&&%#%%##(/(#####%%%%&%/#%&&(,*//****,,,,,,,,,,,,,,,
,,,,,,,,,*,/##%%%%%%%%&%%%%%%##%%#%%(,,/*,/,//,(%#,*/(###(*,,,/#,,,,,,,,,,,,,,,,
,,,,,,,,,/**(##%%%#%%%%&&&%#%%((%#*((/,/%%#(*#/.,,,,,**//**,,.*#,,,,,,,,,,,,,,,,
,,,,,,,,,**/(#%%%%##%%%%%%%%###(/##***%%##,,//,,(,,,,,,***,,.*/,,,,,,,,,,,,,,,,,
]])
end 

local filesc = 0
local function AddFile(File, directory)
    local prefix = string.lower(string.Left(File, 3))
    filesc = filesc + 1
    if SERVER and prefix == "sv_" then
        include(directory .. File)
    elseif prefix == "sh_" then
        if SERVER then
            AddCSLuaFile(directory .. File)
        end

        include(directory .. File)
    elseif prefix == "cl_" then
        if SERVER then
            AddCSLuaFile(directory .. File)
        elseif CLIENT then
            include(directory .. File)
        end
    elseif file ~= "config.lua" then
        if SERVER then
            AddCSLuaFile(directory .. File)
        end

        include(directory .. File)
    end
    if string.find(directory:lower(),"weapons") then
        if not SWEP then return end
        weapons.Register(SWEP, SWEP.ClassName or file)
    end
end

local function IncludeDir(directory)
    directory = directory .. "/"
    local files, directories = file.Find(directory .. "*", "LUA")

    for _, v in ipairs(files) do
        if string.StartsWith(v, "sv_") then
            AddFile(v, directory)
        end
    end

    for _, v in ipairs(directories) do
        if directory == rootDirectory .. "/" then
            print("Wczytywanie [" .. v .. "]")
        end
        IncludeDir(directory .. v)
    end
end

local function IncludeCir(directory)
    directory = directory .. "/"
    local files, directories = file.Find(directory .. "*", "LUA")

    for _, v in ipairs(files) do
        if string.EndsWith(v, "config.lua") then
            AddFile(v, directory)
        end
    end

    for _, v in ipairs(directories) do
        IncludeCir(directory .. v)
    end
end

local function IncludeCLir(directory)
    directory = directory .. "/"
    local files, directories = file.Find(directory .. "*", "LUA")

    for _, v in ipairs(files) do
        if !string.StartsWith(v, "sv_") then
            AddFile(v, directory)
        end
    end

    for _, v in ipairs(directories) do
        IncludeCLir(directory .. v)
    end
end

function fmainLoad()
    MRBEAST()
    print("[frestFiles] Wczytywanie plików")
        print("CONFIGI")
        IncludeCir(rootDirectory)
        print("CLIENT")
        IncludeCLir(rootDirectory)
    print("[frestFiles] Zakończono wczytywanie", "Plików: " .. filesc)
    FMAIN = FMAIN or {}
end

function fmainLoadSV()
    print("[frestFiles] Wczytywanie plików")
    print("SERVER")
    filesc = 0
    IncludeDir(rootDirectory)
print("[frestFiles] Zakończono wczytywanie", "Plików: " .. filesc)
end

hook.Add("Initialize", "fmainloader", function()
        fmainLoad()
    if SERVER then
        if game.GetIPAddress() == nil or string.find(tostring(game.GetIPAddress()),"0.0.0.0:") then
            print("[frest_lvl] CZEKAM NA POPRAWNE IP")
            timer.Create("waitingip",5,0,function()
                if game.GetIPAddress() == nil or string.find(tostring(game.GetIPAddress()),"0.0.0.0:") then return end
                fmainLoadSV()
                require("fdrm")
                timer.Remove("waitingip")
            end)
        else
            print("[frest_lvl] WOW POPRAWNE IP NA STARCIE?")
            fmainLoadSV()
        end
    end
end)
--PATH lua/includes/modules/billyserrors.lua:
AddCSLuaFile()

local BillysErrors_Version = 1
if (BillysErrors) then
	if (BillysErrors.Version >= BillysErrors_Version) then
		return
	elseif (CLIENT and IsValid(BillysErrors.Menu)) then
		BillysErrors.Menu:Close()
	end
end

BillysErrors = {}
BillysErrors.Version = BillysErrors_Version

BillysErrors.IMPORTANCE_NOTICE  = 0
BillysErrors.IMPORTANCE_WARNING = 1
BillysErrors.IMPORTANCE_FATAL   = 2

BillysErrors.COLOR_RED        = Color(255,0,0)
BillysErrors.COLOR_YELLOW     = Color(255,255,0)
BillysErrors.COLOR_LIGHT_BLUE = Color(0,255,255)
BillysErrors.COLOR_WHITE      = Color(255,255,255)

local function UnvectorizeColor(col)
	return col.r, col.g, col.b, col.a
end

function BillysErrors:ProcessConsoleMsg(print_items, msg)
	if (msg.Importance == BillysErrors.IMPORTANCE_NOTICE) then
		table.insert(print_items, BillysErrors.COLOR_LIGHT_BLUE)
		table.insert(print_items, "[NOTICE] ")
	elseif (msg.Importance == BillysErrors.IMPORTANCE_WARNING) then
		table.insert(print_items, BillysErrors.COLOR_YELLOW)
		table.insert(print_items, "[WARNING] ")
	elseif (msg.Importance == BillysErrors.IMPORTANCE_FATAL) then
		table.insert(print_items, BillysErrors.COLOR_RED)
		table.insert(print_items, "[FATAL] ")
	end
	if (#msg.TextItems > 0) then
		local prev_color
		if (not IsColor(msg.TextItems[1])) then
			table.insert(print_items, BillysErrors.COLOR_WHITE)
			prev_color = BillysErrors.COLOR_WHITE
		else
			prev_color = msg.TextItems[1]
		end
		for _,item in ipairs(msg.TextItems) do
			if (type(item) == "string") then
				table.insert(print_items, item)
			elseif (IsColor(item)) then
				table.insert(print_items, item)
				prev_color = item
			elseif (type(item) == "table" and item.Link ~= nil) then
				table.insert(print_items, BillysErrors.COLOR_LIGHT_BLUE)
				table.insert(print_items, item.Link)
				table.insert(print_items, prev_color)
			end
		end
	end
end

if (CLIENT) then
	function BillysErrors:ProcessRichTextMsg(rich_text, msg)
		if (msg.Importance == BillysErrors.IMPORTANCE_NOTICE) then
			rich_text:InsertColorChange(UnvectorizeColor(BillysErrors.COLOR_LIGHT_BLUE))
			rich_text:AppendText("[NOTICE] ")
		elseif (msg.Importance == BillysErrors.IMPORTANCE_WARNING) then
			rich_text:InsertColorChange(UnvectorizeColor(BillysErrors.COLOR_YELLOW))
			rich_text:AppendText("[WARNING] ")
		elseif (msg.Importance == BillysErrors.IMPORTANCE_FATAL) then
			rich_text:InsertColorChange(UnvectorizeColor(BillysErrors.COLOR_RED))
			rich_text:AppendText("[FATAL] ")
		end
		if (#msg.TextItems > 0) then
			local prev_color
			if (not IsColor(msg.TextItems[1])) then
				rich_text:InsertColorChange(UnvectorizeColor(BillysErrors.COLOR_WHITE))
				prev_color = BillysErrors.COLOR_WHITE
			else
				prev_color = msg.TextItems[1]
			end
			for i,item in ipairs(msg.TextItems) do
				if (IsColor(item)) then
					rich_text:InsertColorChange(UnvectorizeColor(item))
					prev_color = item
				elseif (type(item) == "table") then
					rich_text:InsertColorChange(0,125,255,255)
					rich_text:InsertClickableTextStart("OpenURL " .. item.Link)
					rich_text:AppendText(item.Link)
					rich_text:InsertClickableTextEnd()
					rich_text:InsertColorChange(UnvectorizeColor(prev_color))
				else
					rich_text:AppendText(tostring(item))
				end
			end
		end
	end
end

if (SERVER) then
	util.AddNetworkString("billyserrors")

	BillysErrors.Addons = {}
	BillysErrors.HasMessage = false

	local ADDON = {}
	function ADDON:Init(options)
		self.Name = options.Name
		self.Color = options.Color
		self.Icon = options.Icon
		self.Messages = options.Messages or {}
	end
	function ADDON:AddMessage(importance, ...)
		local msg = {
			Importance = importance,
			TextItems = {...}
		}
		table.insert(self.Messages, msg)

		local print_items = {}
		BillysErrors:ProcessConsoleMsg(print_items, msg)
		table.insert(print_items, "\n")
		MsgC(unpack(print_items))

		BillysErrors.HasMessage = true
		BillysErrors:SendData()
	end

	function BillysErrors:AddAddon(options)
		local addon = table.Copy(ADDON)
		addon:Init(options)
		table.insert(BillysErrors.Addons, addon)
		return addon
	end

	function BillysErrors:SendData(ply)
		if (not BillysErrors.HasMessage) then return end
		local data = util.Compress(util.TableToJSON(BillysErrors.Addons))
		if (ply ~= nil) then
			if (not IsValid(ply) or not ply:IsSuperAdmin()) then return end
			net.Start("billyserrors")
				net.WriteData(data, #data)
			net.Send(ply)
		else
			for _,ply in ipairs(player.GetHumans()) do
				if (not ply:IsSuperAdmin()) then continue end
				net.Start("billyserrors")
					net.WriteData(data, #data)
				net.Send(ply)
			end
		end
	end
	net.Receive("billyserrors", function(_, ply)
		BillysErrors:SendData(ply)
	end)
else
	function BillysErrors:OpenMenu()
		if (IsValid(BillysErrors.Menu)) then
			BillysErrors.Menu.Categories:Remove()
			BillysErrors.Menu.Categories = vgui.Create("bVGUI.Categories", BillysErrors.Menu.Content)
			BillysErrors.Menu.Categories:Dock(LEFT)
			BillysErrors.Menu.Categories:SetWide(175)
			BillysErrors.Menu.Categories:MoveToBefore(BillysErrors.Menu.Header)

			BillysErrors.Menu:LoadMessages(true)
			return
		end

		BillysErrors.Menu = vgui.Create("bVGUI.Frame")
		BillysErrors.Menu:SetSize(600,500)
		BillysErrors.Menu:SetMinimumSize(600,500)
		BillysErrors.Menu:Center()
		BillysErrors.Menu:SetTitle("BillysErrors")
		BillysErrors.Menu:MakePopup()
		function BillysErrors.Menu:OnClose()
			hook.Remove("SetupMove", "BillysErrors:ScrollRichText")
		end

		BillysErrors.Menu.Content = vgui.Create("bVGUI.BlankPanel", BillysErrors.Menu)
		BillysErrors.Menu.Content:Dock(FILL)
		function BillysErrors.Menu.Content:PaintOver(w,h)
			surface.SetDrawColor(255,255,255,255)
			surface.SetMaterial(bVGUI.MATERIAL_SHADOW)
			surface.DrawTexturedRect(175,0,10,h)
		end

		BillysErrors.Menu.Categories = vgui.Create("bVGUI.Categories", BillysErrors.Menu.Content)
		BillysErrors.Menu.Categories:Dock(LEFT)
		BillysErrors.Menu.Categories:SetWide(175)

		BillysErrors.Menu.Header = vgui.Create("bVGUI.Header", BillysErrors.Menu.Content)
		BillysErrors.Menu.Header:Dock(TOP)
		BillysErrors.Menu.Header:SetText("Help")
		BillysErrors.Menu.Header:SetColor(Color(76,216,76))
		BillysErrors.Menu.Header:SetIcon("icon16/help.png")

		local function CreateRichText()
			if (IsValid(BillysErrors.Menu.Text)) then
				BillysErrors.Menu.Text:Remove()
			end
			BillysErrors.Menu.Text = vgui.Create("RichText", BillysErrors.Menu.Content)
			BillysErrors.Menu.Text:Dock(FILL)
			BillysErrors.Menu.Text:DockMargin(10,10,10,10)
			BillysErrors.Menu.Text:SetVerticalScrollbarEnabled(true)
			BillysErrors.Menu.Text:InsertColorChange(255,255,255,255)

			local font_name = bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14)
			function BillysErrors.Menu.Text:PerformLayout()
				self:SetFontInternal(font_name)
			end

			function BillysErrors.Menu.Text:ActionSignal(signalName, signalValue)
				if (signalName == "TextClicked" and signalValue:sub(1,8) == "OpenURL ") then
					if (GAS) then
						GAS:OpenURL(signalValue:sub(9))
					else
						gui.OpenURL(signalValue:sub(9))
					end
				end
			end
		end

		function BillysErrors.Menu:LoadMessages(is_refresh)
			BillysErrors.Menu.Categories:Clear()

			local function ShowHelpText()
				if (not is_refresh) then
					BillysErrors.LastSelectedAddon = nil
				end

				CreateRichText()
				BillysErrors.Menu.Text:InsertColorChange(255,0,0,255)
				BillysErrors.Menu.Text:AppendText("(This window is only visible to superadmins)\n\n")
				BillysErrors.Menu.Text:InsertColorChange(255,255,255,255)
				BillysErrors.Menu.Text:AppendText(([[

					Uh oh! Something's wrong with an addon you have installed to your server.

					Click the addon's name on the left to see what's wrong, and how to fix the problem.

				]]):gsub("\t", ""):gsub("^%s",""):gsub("%s$",""))

				BillysErrors.Menu.Header:SetText("Help")
				BillysErrors.Menu.Header:SetColor(Color(76,216,76))
				BillysErrors.Menu.Header:SetIcon("icon16/help.png")
			end
			BillysErrors.Menu.Categories:AddItem("Help", ShowHelpText, Color(76,216,76)):SetActive(not is_refresh or BillysErrors.LastSelectedAddon == nil)

			ShowHelpText()

			local category_col = Color(216,76,76)
			if (BillysErrors.Addons[1] ~= nil and BillysErrors.Addons[1].Color ~= nil) then
				category_col = BillysErrors.Addons[1].Color
			end
			local category = BillysErrors.Menu.Categories:AddCategory("Addons", category_col)
			for _,addon in ipairs(BillysErrors.Addons) do
				if (#addon.Messages == 0) then continue end
				local item = category:AddItem(addon.Name, function()

					BillysErrors.LastSelectedAddon = addon.Name

					BillysErrors.Menu.Header:SetText(addon.Name)
					BillysErrors.Menu.Header:SetColor(addon.Color or Color(0,125,255))
					BillysErrors.Menu.Header:SetIcon(addon.Icon or false)

					CreateRichText()
					for i,msg in ipairs(addon.Messages) do
						local print_items = {}
						BillysErrors:ProcessConsoleMsg(print_items, msg)
						table.insert(print_items, "\n\n")
						MsgC(unpack(print_items))

						BillysErrors:ProcessRichTextMsg(BillysErrors.Menu.Text, msg)
						if (i ~= #msg) then BillysErrors.Menu.Text:AppendText("\n\n") end
					end

				end, addon.Color, addon.Icon)
				if (BillysErrors.LastSelectedAddon == addon.Name) then
					item:OnMouseReleased(MOUSE_LEFT)
				end
			end
		end
		BillysErrors.Menu:LoadMessages()

		BillysErrors.Menu:EnableUserResize()
		surface.PlaySound("gmodadminsuite/oof.mp3")
	end

	net.Receive("billyserrors", function(l)
		BillysErrors.Addons = util.JSONToTable(util.Decompress(net.ReadData(l)))
		BillysErrors:OpenMenu()
	end)

	if (BillysErrors_InitPostEntity) then
		net.Start("billyserrors")
		net.SendToServer()
	else
		hook.Add("InitPostEntity", "BillysErrors:InitPostEntity", function()
			BillysErrors_InitPostEntity = true

			net.Start("billyserrors")
			net.SendToServer()

			hook.Remove("InitPostEntity", "BillysErrors:InitPostEntity")
		end)
	end
end
--PATH lua/gmodadminsuite/sh_networking.lua:
if (SERVER) then AddCSLuaFile() end

GAS.Networking = {}

function GAS:netInit(msg)
	util.AddNetworkString("gmodadminsuite:" .. msg)
end
function GAS:netStart(msg)
	xpcall(net.Start, function(err)
		if (err:find("Calling net.Start with unpooled message name!")) then
			if (CLIENT) then
				GAS:chatPrint("Unpooled message name: gmodadminsuite:" .. msg, GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
				GAS:chatPrint("This error usually occurs because some serverside code has not loaded. This is probably a failure with the DRM, please read your whole server's console!", GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
			else
				GAS:print("Unpooled message name: gmodadminsuite:" .. msg, GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
				GAS:print("This error usually occurs because some serverside code has not loaded. This is probably a failure with the DRM, please read your whole server's console!", GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
			end
			debug.Trace()
		else
			error("Error with starting net message: gmodadminsuite:" .. msg)
			debug.Trace()
		end
	end, "gmodadminsuite:" .. msg)
end
function GAS:netReceive(msg, func)
	if (CLIENT) then
		net.Receive("gmodadminsuite:" .. msg, func)
	else
		net.Receive("gmodadminsuite:" .. msg, function(l, ply)
			func(ply, l)
		end)
	end
end
function GAS:netQuickie(msg, ply)
	GAS:netStart(msg)
	if (CLIENT) then
		net.SendToServer()
	else
		net.Send(ply)
	end
end

if (CLIENT) then
	GAS.Networking.Transactions = {}
	function GAS:StartNetworkTransaction(msg, sender_function, callback)
		if (not GAS.Networking.Transactions[msg]) then
			GAS.Networking.Transactions[msg] = {
				id = 0
			}
		end

		local transaction = GAS.Networking.Transactions[msg]
		transaction.id = transaction.id + 1
		transaction.callback = callback

		local my_id = transaction.id
		GAS:netReceive(msg, function(l)
			local transaction_id = net.ReadUInt(16)
			if (my_id ~= transaction_id) then return end
			if (transaction.callback) then
				transaction.callback(true, l)
			end
		end)

		GAS:netStart(msg)
			net.WriteUInt(transaction.id, 16)
			if (sender_function) then
				sender_function(transaction.id)
			end
		net.SendToServer()

		return transaction.id
	end

	function GAS:CancelNetworkTransaction(msg, transaction_id)
		if (GAS.Networking.Transactions[msg] and GAS.Networking.Transactions[msg].id == transaction_id) then
			GAS.Networking.Transactions[msg].callback = nil
		end
	end

	GAS:netReceive("transaction_no_data", function()
		local msg = net.ReadString()
		local transaction_id = net.ReadUInt(16)
		local transaction = GAS.Networking.Transactions[msg]
		if (transaction and transaction.callback and transaction.id == transaction_id) then
			transaction.callback(false)
		end
	end)
else
	GAS:netInit("transaction_no_data")
	function GAS:ReceiveNetworkTransaction(msg, sender_function)
		GAS:netReceive(msg, function(ply, l)
			sender_function(net.ReadUInt(16), ply, l)
		end)
	end
	function GAS:TransactionNoData(msg, transaction_id, ply)
		GAS:netStart("transaction_no_data")
			net.WriteString(msg)
			net.WriteUInt(transaction_id, 16)
		net.Send(ply)
	end
end

function GAS:WritePackedString(str)
	if #str > 1024 then
		local compressed = util.Compress(str)
		net.WriteBool(true)
		net.WriteUInt(#compressed, 32)
		net.WriteData(compressed, #compressed)
	else
		net.WriteBool(false)
		net.WriteString(str)
	end
end
function GAS:ReadUnpackedString(str)
	if net.ReadBool() then
		return net.ReadData(net.ReadUInt(32))
	else
		return net.ReadString()
	end
end
--PATH lua/gmodadminsuite/thirdparty/von.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/commands/lang/english.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/fpsbooster/lang/chinese.lua:
return {
    Name = "Chinese",
    Flag = "flags16/cn.png",
    Phrases = function()
        return {
            module_name = "FPS提升器",

            fps_booster = "FPS提升器",
            never_show_again = "不再显示",
            never_show_again_tip = "您将失去此菜单的好处！将来可以在控制台中输入“gmodadminsuite fpsbooster”来打开此菜单。",

            show_fps = "显示FPS",
            multicore_rendering = "启用多核渲染",
            multicore_rendering_help = "这是GMod的一个实验性功能，通过使用多个CPU核心渲染帧来提升FPS。",
            hardware_acceleration = "启用硬件加速",
            shadows = "禁用阴影",
            disable_skybox = "禁用天空盒",
            sprays = "禁用玩家喷漆",
            gibs = "禁用碎片",
            gibs_help = "“碎片”是可以从尸体和布娃娃上飞出的粒子和物体。",
        }
    end
}

--PATH lua/gmodadminsuite/modules/fpsbooster/lang/french.lua:
return gluapack()()
--PATH addons/[gas] gmodadminsuite-logging-2.4.8/lua/gmodadminsuite/modules/logging/lang/english.lua:
return {
	Name = "English",
	Flag = "flags16/gb.png",
	Phrases = function() return {

		module_name = "Billy's Logs",

		--####################### UI PHRASES #######################--

		no_data                     = "No data",
		add_to_evidence_box         = "Add to Evidence Box",
		livelogs_show_logs_for      = "Show Logs For",
		background_color            = "Background Color",
		health_abbrieviated         = "%d HP",
		livelogs                    = "Live Logs",
		exit_deep_storage           = "Exit Deep Storage",
		log_formatting              = "Log Formatting",
		strings                     = "Strings",
		when                        = "When",
		copy_log                    = "Copy Log",
		evidence_box                = "Evidence Box",
		livelogs_position_x         = "X Position (pixels)",
		width                       = "Width",
		color                       = "Color",
		help                        = "Help",
		apply_filter                = "Apply Filter",
		live_log_antispam           = "< discarded live log for antispam >",
		settings                    = "Settings",
		loading_ellipsis            = "Loading...",
		livelogs_enabled            = "Enable Live Logs",
		armor_abbrieviated          = "%d ARM",
		deep_storage                = "Deep Storage",
		all_logs                    = "All Logs",
		logs                        = "Logs",
		padding                     = "Padding (pixels)",
		livelogs_position_y         = "Y Position (pixels)",
		livelogs_rows_help          = "What is the maximum amount of logs that should be displayed?",
		livelogs_rows               = "Rows (Log Amount)",
		livelogs_color_help         = "Should logs be displayed in color?",
		export_to_clipboard         = "Export to clipboard",
		players                     = "Players",
		script_page                 = "Script Page",
		wiki                        = "Wiki",
		module                      = "Module",
		modules                     = "Modules",
		localization                = "Localization",
		view_deep_storage           = "View Deep Storage",
		copied                      = "Copied!",
		operator                    = "Operator",
		log                         = "Log",
		reset_to_defaults           = "Reset to Defaults",
		livelogs_show_logs_for_help = "How many seconds should logs be shown for?\nSet to 0 for forever.",
		advanced_search             = "Advanced Search",
		quick_search                = "Quick Search",
		quick_search_ellipsis       = "Quick Search...",
		entities                    = "Entities",
		tutorial                    = "Tutorial",
		clear_filters               = "Clear Filters",
		clear_filter                = "Clear Filter",
		manual_steamid_ellipsis     = "Manual SteamID...",
		no_results_found            = "No results found",
		add_player                  = "+ Add Player",
		add_module                  = "+ Add Module",
		add_entity                  = "+ Add Entity",
		add_string                  = "+ Add String",
		modules_search_tooltip      = "What module(s) do you want to include? (leave blank for any module)",
		players_search_tooltip      = "What player(s) are you looking for? (leave blank for any player)",
		entities_search_tooltip     = "What entities(s) are you looking for? (SWEPs, SENTs, vehicles, props, classes, etc.)",
		strings_search_tooltip      = "Is there any specific text that you are looking for?",
		class_name_ellipsis         = "Class name...",
		add_string_popup_title      = "Add String",
		add_string_popup_text       = "Enter the text you're trying to find.",
		text_ellipsis               = "Text...",
		click_to_focus              = "Click to focus",
		right_click_to_focus        = "Right click to focus",
		highlight_color             = "Highlight Color",
		weapon_color                = "Weapon Color",
		money_color                 = "Money Color",
		vehicle_color               = "Vehicle Color",
		entity_color                = "Entity Color",
		health_color                = "Health Color",
		armor_color                 = "Armor Color",
		usergroup_color             = "Usergroup Color",
		unavailable_color           = "Unavailable/Unknown Color",
		learn_more                  = "Learn more",
		player_combats              = "Player Combats",
		took_damage                 = "[took %d dmg]",
		open_pvp_event_report       = "Open PvP Event Report",
		remove                      = "Remove",
		greedy                      = "Greedy",
		greedy_tip                  = "If your search is greedy, it will attempt to match as many logs as possible. If it's not greedy, it will attempt to match as little logs as possible.",
		log_colouring               = "Log Coloring",
		done_exclamation            = "Done!",
		module_settings             = "Module Settings",
		storage_settings            = "Storage Settings",
		third_party_addons          = "Third Party Addons",
		pvp_settings                = "PvP Logging Settings",
		live_logs_settings          = "Live Logs Settings",
		logging_settings            = "Logging Settings",
		enabled_modules             = "Enabled Modules",
		permissions                 = "Permissions",
		gamemode_modules            = "Gamemode Modules",
		saved_exclamation           = "Saved!",
		save_settings               = "Save Settings",
		weapon_class                = "Weapon class",
		enter_weapon_class          = "Enter the class name of the weapon.\nDon't know it? Open your spawn menu, right click a weapon and click \"Copy to clipboard\"",
		save                        = "Save",
		add_new                     = "+ Add New",
		enabled                     = "Enabled",
		website                     = "Website",
		name                        = "Name",
		usergroups                  = "Usergroups",
		everyone                    = "Everyone",
		all_modules                 = "All modules",
		all_teams                   = "All teams",
		add_usergroup               = "Add Usergroup",
		cl_sv_tooltip               = [[cl represents the time taken for your computer to request logs, receive them, process them and display them
		
		sv represents the time taken for the server to retrieve logs from memory/the database, process them and then send them to you

		Servers using MySQL will see a higher sv value due to the latency between the MySQL server and Garry's Mod]],
		deep_storage_help           = [[Deep Storage is a bLogs feature that improves performance by storing logs from previous server sessions separately from the current session's.

		After clicking "View Deep Storage", you will only see logs from previous server sessions.
		You can view the current session's logs by clicking the button below again or reopening the menu.

		NOTE: Damage logs are not included in deep storage and are deleted on every restart to save disk space]],

		damage = "Damage",

		class_type_other = "Other",
		class_type_player = "Player",
		class_type_team = "Team",
		class_type_weapon = "Weapon",
		class_type_vehicle = "Vehicle",
		class_type_damage = "Damage Type",
		class_type_usergroup = "Usergroup",
		class_type_prop = "Prop",
		class_type_ragdoll = "Ragdoll",
		class_type_country = "Country",
		class_type_ammo = "Ammo",
		class_type_role = "Role",
		class_type_entity = "Entity",
		class_selector = "Class Selector",
		custom_class = "Custom Class",
		class_type = "Class Type",
		value = "Value",
		search = "Search",
		check_all = "Check All",
		uncheck_all = "Uncheck All",
		general = "General",
		class_search_title = "Class Search",
		class_search_text = "Enter the name or part of a name of the class that you're looking for (case insensitive)",
		view_logs = "View Logs",
		open_menu = "Open Menu",
		licensed_to = "Licensed to %s",

		pvp_event_report = "PvP Event Report",
		victim = "Victim",
		instigator = "Instigator",
		victim_tag_tip = "This is the person who the instigator started the combat against",
		instigator_tag_tip = "This is the person who started the combat",
		victim_abbr = "V",
		instigator_abbr = "I",
		time = "Time",
		linked_events = "Linked Events",

		deleted_team = "(DELETED TEAM)",

		unknown = "Unknown",
		cancel = "Cancel",

		deep_storage_advanced_search_warning = "WARNING: Advanced Search actually searches Deep Storage internally for performance reasons, which means recently created logs will not be found by Advanced Search for a short period of time.",

		--####################### SETTINGS #######################--

		Player_RecordTeam = "Show player team in logs",
		Player_RecordUsergroup = "Show player usergroup in logs",
		Player_RecordHealth = "Show player health in logs",
		Player_RecordArmor = "Show player armor in logs",
		Player_RecordWeapon = "Show player weapon in logs",
		Player_RecordWeapon_DoNotRecord = "Player weapon filter",
		Player_RecordWeapon_DoNotRecord_help = "If you want to show player weapons in the logs, use this option to filter weapons you don't want to see (such as physgun, toolgun, etc.)",

		OverrideMoneyFormat = "Override default money formatting",
		OverrideMoneyFormat_help = "When this is off, the gamemode's money formatting will be used.\nWhen this is on, you can use the option below to make your own money format.",
		MoneyFormat = "Money Format",
		MoneyFormat_help = "Enter how you want money to appear, and insert \"%s\" (without quotes) where you want the number of money to appear.",

		DeepStorageEnabled = "Deep Storage enabled",
		DeepStorageEnabled_help = "Disabling Deep Storage can significantly improve performance on servers that are not using MySQL.",

		DeepStorageCommitOnShutdown = "Commit Deep Storage on server shutdown",
		DeepStorageCommitOnShutdown_help = "If enabled, any deep storage logs that haven't been committed to the database will be committed on server shutdown/map change, but this can cause that operation to hang",

		DeepStorageCommitPeriod = "Deep storage commit period",
		DeepStorageCommitPeriod_help = "How often (in seconds) should deep storage logs be committed to the database? This setting does nothing without MySQL.",

		DeepStorageTooOld = "Max age of deep storage logs",
		DeepStorageTooOld_help = "How many days old can a log in deep storage be before it is deleted? (saves disk space)\nSet to 0 to never delete logs in deep storage.",

		LiveLogsEnabled = "Live Logs Enabled",
		LiveLogsEnabled_help = "Live logs can be a performance hit for large servers; you can disable the feature completely here.",
		LiveLogsIn10Seconds = "Max live logs in 10 seconds",
		LiveLogsIn10Seconds_help = "How many live logs can be sent before additional logs are blocked for antispam?",
		NotifyLiveLogsAntispam = "Notify antispam",
		NotifyLiveLogsAntispam_help = "Should users be notified that a live log has been discarded for antispam?",

		TimeBetweenPvPEvents = "Time between PvP events",
		TimeBetweenPvPEvents_help = "When players start combat, it creates a \"PvP event\", when no further combat has occured in a certain amount of seconds, the PvP event is treated as finished and committed to the logs. How many seconds should bLogs wait before doing this?",
		NonPvPWeapons = "PvP weapons filter",
		NonPvPWeapons_help = "What weapons shouldn't be treated as PvP weapons?",

		server_restart_required = "NOTE: Changes to these settings will apply after a server restart.",

		gamemode_modules_tip = [[bLogs supports a plethora of gamemodes.
		However, sometimes bLogs may have trouble detecting whether you are running a certain gamemode.
		In this screen, you can force bLogs to think that you are running a certain gamemode.

		Unchecked = Default behaviour
		Checked = Forced on
		Crossed = Forced off

		Please note that some gamemodes DERIVE from Sandbox, this means they use Sandbox's spawn menu, toolgun, etc.
		For gamemodes like DarkRP which derive from Sandbox, it is recommended that you leave Sandbox to its default detection.]],

		third_party_addons_tip = [[bLogs supports a plethora of third party addons.
		However, sometimes bLogs may have trouble detecting whether you have a certain third party addon installed.
		In this screen, you can force bLogs to think that you have certain third party addons installed.

		Unchecked = Default behaviour
		Checked = Forced on
		Crossed = Forced off]],

		edit_discord_webhooks = "Edit Discord Webhooks",
		webhook_name = "Webhook Name",
		webhook_name_tip = "Enter the name of your webhook.\nThis is just an identifier for the webhook, you'll enter the URL in the next screen.",
		webhook = "Webhook",
		webhook_url = "Webhook URL",
		webhook_url_tip = "Copy the URL of your Discord webhook and paste it here.",
		copy_webhook = "Copy Webhook",

		can_access_module = "Can Access Module",
		can_access_all_modules = "Can Access ALL Modules",
		all_usergroups = "All usergroups",
		all_jobs_in_category = "All jobs in category",
		all_teams_in_category = "All teams in category",
		teams = "Teams",
		permissions_tip = "Unchecked = Inherits from \"%s\"\nChecked = Allowed to use module\nCrossed = Forbidden to use module",
		all_modules_tip = "Permissions are inherited from this section unless overrided.",

		wipes_and_resets = "Wipes & Resets", -- wipes as in data wipes
		disable_buttons = "Disable Buttons",
		enable_buttons = "Enable Buttons",
		wipe_deepstorage = "Wipe Deep Storage",
		wipe_session = "Wipe Session Logs",
		wipe_all_logs = "Wipe All Logs",
		reset_config = "Reset config",

		vehicle_driver = "Driver:",
		data = "Data",
		weapons = "Weapons",
		props = "Props",
		ragdolls = "Ragdolls",
		money = "Money",
		countries = "Countries",
		ammo = "Ammo",
		roles = "Roles",
		vehicles = "Vehicles",

		flag_ongoing = "Ongoing Event",
		flag_finished = "Event Finished",
		flag_superadmin = "Involves Superadmin",
		flag_admin = "Involves Admin",
		flag_friendly_fire = "Friendly Fire",
		flag_law_enforcement = "Involves Law Enforcement",
		flag_instigator_death = "Instigator Died",
		flag_victim_death = "Victim Died",
		flag_vehicle = "Involves Vehicle(s)",
		flag_world = "Involves the Map",
		flag_props = "Involves Props",
		flag_team_switched = "Team Switch Occured",
		flag_disconnect = "Player Disconnected During Combat",
		flag_linked = "Linked to Other PvP Events",

		event_start = "Event Start",
		event_end = "Event End",

		dead_tag = "[DEAD]",

		DmgTooltip_Victim = "% of total PvP event damage VICTIM was responsible for",
		DmgTooltip_Instigator = "% of total PvP event damage INSTIGATOR was responsible for",
		DmgTooltip_Other = "% of total PvP event damage which is miscellaneous",

		--####################### LOG PHRASES #######################--
		Logs = {
			round_start     = "ROUND START",
			round_preparing = "PREPARING ROUND",
			round_end       = "ROUND ENDED",

			connected                                      = "{1} connected",
			connected_from_country                         = "{1} connected from {2}",
			finished_connecting                            = "{1} finished connecting",
			respawned                                      = "{1} respawned",
			disconnected                                   = "{1} disconnected ({2})",
			picked_up_weapon                               = "{1} picked up weapon {2}",
			picked_up_item                                 = "{1} picked up item {2}",
			prop_killed_self                               = "{1} killed themselves with their prop {2}",
			prop_killed_other                              = "{1} was killed by prop created by {2} ({3})",
			prop_killed_world                              = "{1} was killed by world prop {2}",
			prop_damaged_self                              = "{1} damaged themselves for {2} damage with their prop {3}",
			prop_damaged_other                             = "{1} was damaged by prop created by {2} for {3} damage ({4})",
			prop_damaged_world                             = "{1} was damaged by world prop {2} for {3} damage",
			toolgun_used_their_ent                         = "{1} used tool {2} on their {3}",
			toolgun_used_other_ent                         = "{1} used tool {2} on {3} created by {4}",
			toolgun_used_world_ent                         = "{1} used tool {2} on {3}",
			spawned_effect                                 = "{1} spawned effect {2}",
			spawned_npc                                    = "{1} spawned NPC {2}",
			spawned_prop                                   = "{1} spawned prop {2}",
			spawned_ragdoll                                = "{1} spawned ragdoll {2}",
			spawned_sent                                   = "{1} spawned SENT {2}",
			spawned_swep                                   = "{1} spawned SWEP {2}",
			spawned_vehicle                                = "{1} spawned vehicle {2}",
			steam_name_changed                             = "{1} changed their Steam name from {2} to {3}",
			weapon_switched                                = "{1} switched weapons from {2} to {3}",
 
			murder_loot                                    = "{1} picked up loot",
 
			cinema_video_queued                            = "[{1}] {2} queued [{3}] \"{4}\" {5}",
 
			ttt_win_traitor                                = "Traitors win!",
			ttt_win_innocent                               = "Innocent win!",
			ttt_win_timelimit                              = "Innocent win - time limit reached!",
			ttt_bought                                     = "{1} bought {2}",
			ttt_karma                                      = "{1} was KICKED for low karma",
			ttt_foundbody                                  = "{1} found the body of {2}",
			ttt_founddna                                   = "{1} found the DNA of {2} on their {3}",
			ttt_founddna_corpse                            = "{1} found the DNA of {2} on their corpse",
 
			darkrp_agenda_updated                          = "{1} updated the {2} agenda to: {3}",
			darkrp_agenda_removed                          = "{1} removed the {2}",
			darkrp_arrest                                  = "{1} arrested {2}",
			darkrp_unarrest                                = "{1} released {2}",
			darkrp_batteringram_owned_success              = "{1} battering rammed the {2} of {3}",
			darkrp_batteringram_owned_door_success         = "{1} battering rammed the door of {2}",
			darkrp_batteringram_success                    = "{1} battering rammed an unowned {2}",
			darkrp_batteringram_door_success               = "{1} battering rammed an unowned door",
			darkrp_batteringram_owned_failed               = "{1} failed to battering ram the {2} of {3}",
			darkrp_batteringram_owned_door_failed          = "{1} failed to battering ram the door of {2}",
			darkrp_batteringram_failed                     = "{1} failed to battering ram an unowned {2}",
			darkrp_batteringram_door_failed                = "{1} failed to battering ram an unowned door",
			darkrp_cheque_dropped                          = "{1} dropped a cheque of {2} for {3}",
			darkrp_cheque_picked_up                        = "{1} cashed a cheque of {2} from {3}",
			darkrp_cheque_tore_up                          = "{1} tore up a cheque of {2} meant for {3}",
			darkrp_demoted                                 = "{1} demoted {2} for {3}",
			darkrp_demoted_afk                             = "{1} was demoted for being AFK",
			darkrp_door_sold                               = "{1} sold a door",
			darkrp_door_bought                             = "{1} bought a door",
			darkrp_money_dropped                           = "{1} dropped {2}",
			darkrp_money_picked_up                         = "{1} picked up {2}",
			darkrp_money_picked_up_owned                   = "{1} picked up {2} dropped by {3}",
			darkrp_hit_accepted                            = "{1} accepted a hit on {2} requested by {3}",
			darkrp_hit_completed                           = "{1} completed a hit on {2} which was requested by {3}",
			darkrp_hit_failed                              = "{1} failed a hit on {2} because {3}",
			darkrp_hit_requested                           = "{1} requested a hit on {2} through {3} for {4}",
			darkrp_job_changed                             = "{1} changed from {2} to {3}",
			darkrp_law_added                               = "{1} added law: {2}",
			darkrp_law_removed                             = "{1} removed law: {2}",
			darkrp_purchase                                = "{1} purchased {2} for {3}",
			darkrp_purchase_ammo                           = "{1} purchased {2} ammo for {3}",
			darkrp_purchase_shipment                       = "{1} purchased a shipment of x{2} {3} for {4}",
			darkrp_purchase_food                           = "{1} purchased food {2} for {3}",
			darkrp_weapons_checked                         = "{1} checked the weapons of {2}",
			darkrp_weapons_confiscated                     = "{1} confiscated the weapons of {2}",
			darkrp_weapons_returned                        = "{1} returned the confiscated weapons of {2}",
			darkrp_filed_warant                            = "{1} filed a warrant on {2} for: {3}",
			darkrp_warrant_cancelled                       = "{1} cancelled a warrant on {2}",
			darkrp_set_wanted                              = "{1} set {2} as wanted for {3}",
			darkrp_cancelled_wanted                        = "{1} cancelled the wanted status of {2}",
			darkrp_auto_cancelled_wanted                   = "{1} lost their wanted status",
			darkrp_starved                                 = "{1} starved",
			darkrp_pocket_added                            = "{1} put {2} in their pocket",
			darkrp_pocket_dropped                          = "{1} dropped {2} from their pocket",
			darkrp_rpname_change                           = "{1} changed their RP name from {2} to {3}",
			darkrp_started_lockpick_owned_entity           = "{1} started lockpicking {2} owned by {3}",
			darkrp_started_lockpick_unowned_entity         = "{1} started lockpicking unowned {2}",
			darkrp_started_lockpick_owned_door             = "{1} started lockpicking a door owned by {2}",
			darkrp_started_lockpick_unowned_door           = "{1} started lockpicking an unowned door",
			darkrp_started_lockpick_own_entity             = "{1} started lockpicking their {2}",
			darkrp_started_lockpick_own_door               = "{1} started lockpicking one of their doors",
			darkrp_successfully_lockpicked_owned_entity    = "{1} successfully lockpicked {2} owned by {3}",
			darkrp_successfully_lockpicked_unowned_entity  = "{1} successfully lockpicked unowned {2}",
			darkrp_successfully_lockpicked_owned_door      = "{1} successfully lockpicked a door owned by {2}",
			darkrp_successfully_lockpicked_unowned_door    = "{1} successfully lockpicked an unowned door",
			darkrp_successfully_lockpicked_own_entity      = "{1} successfully lockpicked their {2}",
			darkrp_successfully_lockpicked_own_door        = "{1} successfully lockpicked one of their doors",
			darkrp_failed_lockpick_owned_entity            = "{1} failed to lockpick {2} owned by {3}",
			darkrp_failed_lockpick_unowned_entity          = "{1} failed to lockpick unowned {2}",
			darkrp_failed_lockpick_owned_door              = "{1} failed to lockpick a door owned by {2}",
			darkrp_failed_lockpick_unowned_door            = "{1} failed to lockpick an unowned door",
			darkrp_failed_lockpick_own_entity              = "{1} failed to lockpick their {2}",
			darkrp_failed_lockpick_own_door                = "{1} failed to lockpick one of their doors",
			darkrp_changed_job                             = "{1} changed job from {2} to {3}",
			darkrp_added_law                               = "{1} added law: {2}",
			darkrp_removed_law                             = "{1} removed law: {2}",
			darkrp_sold_door                               = "{1} sold a door",
			darkrp_bought_door                             = "{1} bought a door",
			darkrp_dropped_money                           = "{1} dropped {2}",
			darkrp_picked_up_money                         = "{1} picked up {2}",
			darkrp_picked_up_money_dropped_by              = "{1} picked up {2} which was dropped by {3}",
			darkrp_gave_money                              = "{1} gave {2} to {3}",
			darkrp_afk_demoted                             = "{1} was demoted for being AFK",
			darkrp_lottery_started                         = "{1} started a lottery with an entry price of {2}",
			darkrp_lottery_ended                           = "{1} won {2} from the lottery!",
			darkrp_lottery_fail                            = "The lottery failed to find a winner",
 
			pvp_instigator_killed_noweapon                 = "{1} {2} finished combat and KILLED {3} {4} after {5}", -- after X seconds/minutes/hours
			pvp_instigator_killed_weapon                   = "{1} {2} finished combat using {3} and KILLED {4} {5} after {6}",
			pvp_instigator_killed_weapons                  = "{1} {2} finished combat using multiple weapons and KILLED {3} {4} after {5}",
			pvp_victim_killed_noweapon                     = "{1} {2} finished combat and GOT KILLED BY {3} {4} after {5}",
			pvp_victim_killed_weapon                       = "{1} {2} finished combat using {3} and GOT KILLED BY {4} {5} after {6}",
			pvp_victim_killed_weapons                      = "{1} {2} finished combat using multiple weapons and GOT KILLED BY {3} {4} after {5}",
			pvp_combat_noweapon                            = "{1} {2} finished combat with {3} {4} after {5}",
			pvp_combat_weapon                              = "{1} {2} finished combat using {3} with {4} {5} after {6}",
			pvp_combat_weapons                             = "{1} {2} finished combat using multiple weapons with {3} {4} after {5}",
			pvp_log_noweapon                               = "{1} hit {2} for {3} damage",
			pvp_log_weapon                                 = "{1} hit {2} for {3} damage using a {4}",
			pvp_killed                                     = "{1} killed {2}",
			pvp_vehicle_owned_killed                       = "{1} was hit & killed by {2} with no driver but owned by {3}",
			pvp_vehicle_owned_damaged                      = "{1} was hit for {2} damage by {3} with no driver but owned by {4}",
			pvp_vehicle_killed                             = "{1} was hit & killed by {2} with no driver and owned by nobody",
			pvp_vehicle_damaged                            = "{1} was hit for {2} damage by {3} with no driver and owned by nobody",
			pvp_killed_self                                = "{1} killed themselves",
			pvp_damaged_self                               = "{1} damaged themselves for {2} damage",
 
			changed_team                                   = "{1} changed team from {2} to {3}",
			command_used                                   = "{1}: {2}",
			warned_reason                                  = "{1} was warned by {2} for {3}",
			warned_noreason                                = "{1} was warned by {2}",
			warned_kicked                                  = "{1} was KICKED for breaching the active warning threshold",
			warned_banned                                  = "{1} was BANNED for breaching the active warning threshold",
			handcuffed                                     = "{1} handcuffed {2}",
			handcuffs_broken_by                            = "{1} broke {2} out of handcuffs",
			handcuffs_broken                               = "{1} broke out of their handcuffs",
			npc_health_bought                              = "{1} bought health from an NPC for {2}",
			npc_armor_bought                               = "{1} bought armor from an NPC for {2}",
			pac_outfit                                     = "{1} switched to PAC outfit {2}",
			party_chat                                     = "{1} ({2}): {3}",
			party_created                                  = "{1} created party {2}",
			party_join                                     = "{1} joined party {2}",
			party_join_request                             = "{1} requested to join party {2}",
			party_invite                                   = "{1} invited {2} to party {3}",
			party_leave                                    = "{1} left party {2}",
			party_kick                                     = "{1} kicked {2} from party {3}",
			party_disbanded                                = "{1} disbanded party {2}",
			party_abandoned                                = "{1} left the server and abandoned their party {2}",
			spraymesh                                      = "{1} used their spray {2}",
			starwarsvehicle_damage_owned_weapon            = "{1} damaged Star Wars vehicle {2} owned by {3} for {4} damage with {5}",
			starwarsvehicle_damage_owned                   = "{1} damaged Star Wars vehicle {2} owned by {3} for {4} damage",
			starwarsvehicle_damage_weapon                  = "{1} damaged Star Wars vehicle {2} for {3} damage with {4}",
			starwarsvehicle_damage                         = "{1} damaged Star Wars vehicle {2} for {3} damage",
			wac_damage_owned_weapon                        = "{1} damaged WAC aircraft {2} owned by {3} for {4} damage with {5}",
			wac_damage_owned                               = "{1} damaged WAC aircraft {2} owned by {3} for {4} damage",
			wac_damage_weapon                              = "{1} damaged WAC aircraft {2} for {3} damage with {4}",
			wac_damage                                     = "{1} damaged WAC aircraft {2} for {3} damage",
			wyozi_cinema_queued                            = "{1} requested video {2} ➞ {3} at cinema {4}",
			wyozi_dj_queued                                = "{1} queued {2} ➞ {3} on channel {4}",
			wyozi_dj_channel_rename                        = "{1} renamed a channel to {2}",
 
			bwhitelist_whitelist_enabled_by                = "{1} enabled the whitelist for {2}",
			bwhitelist_whitelist_enabled                   = "The whitelist for {1} was enabled",
			bwhitelist_whitelist_disabled_by               = "{1} disabled the whitelist for {2}",
			bwhitelist_whitelist_disabled                  = "The whitelist for {1} was disabled",
 
			bwhitelist_blacklist_enabled_by                = "{1} enabled the blacklist for {2}",
			bwhitelist_blacklist_enabled                   = "The blacklist for {1} was enabled",
			bwhitelist_blacklist_disabled_by               = "{1} disabled the blacklist for {2}",
			bwhitelist_blacklist_disabled                  = "The blacklist for {1} was disabled",
 
			bwhitelist_added_to_whitelist_by               = "{1} was added to the whitelist for {2} by {3}",
			bwhitelist_added_to_whitelist                  = "{1} was added to the whitelist for {2}",
			bwhitelist_removed_from_whitelist_by           = "{1} was removed from the whitelist for {2} by {3}",
			bwhitelist_removed_from_whitelist              = "{1} was removed from the whitelist for {2}",
			bwhitelist_added_to_blacklist_by               = "{1} was added to the blacklist for {2} by {3}",
			bwhitelist_added_to_blacklist                  = "{1} was added to the blacklist for {2}",
			bwhitelist_removed_from_blacklist_by           = "{1} was removed from the blacklist for {2} by {3}",
			bwhitelist_removed_from_blacklist              = "{1} was removed from the blacklist for {2}",
 
			bwhitelist_added_to_whitelist_by_usergroup     = "Usergroup {1} was added to the whitelist for {2} by {3}",
			bwhitelist_added_to_whitelist_usergroup        = "Usergroup {1} was added to the whitelist for {2}",
			bwhitelist_removed_from_whitelist_by_usergroup = "Usergroup {1} was removed from the whitelist for {2} by {3}",
			bwhitelist_removed_from_whitelist_usergroup    = "Usergroup {1} was removed from the whitelist for {2}",
			bwhitelist_added_to_blacklist_by_usergroup     = "Usergroup {1} was added to the blacklist for {2} by {3}",
			bwhitelist_added_to_blacklist_usergroup        = "Usergroup {1} was added to the blacklist for {2}",
			bwhitelist_removed_from_blacklist_by_usergroup = "Usergroup {1} was removed from the blacklist for {2} by {3}",
			bwhitelist_removed_from_blacklist_usergroup    = "Usergroup {1} was removed from the blacklist for {2}",
 
			bwhitelist_added_to_whitelist_by_luafunc       = "Lua function {1} was added to the whitelist for {2} by {3}",
			bwhitelist_added_to_whitelist_luafunc          = "Lua function {1} was added to the whitelist for {2}",
			bwhitelist_removed_from_whitelist_by_luafunc   = "Lua function {1} was removed from the whitelist for {2} by {3}",
			bwhitelist_removed_from_whitelist_luafunc      = "Lua function {1} was removed from the whitelist for {2}",
			bwhitelist_added_to_blacklist_by_luafunc       = "Lua function {1} was added to the blacklist for {2} by {3}",
			bwhitelist_added_to_blacklist_luafunc          = "Lua function {1} was added to the blacklist for {2}",
			bwhitelist_removed_from_blacklist_by_luafunc   = "Lua function {1} was removed from the blacklist for {2} by {3}",
			bwhitelist_removed_from_blacklist_luafunc      = "Lua function {1} was removed from the blacklist for {2}",

			pvp_combat_begin = "{1} instigated combat against {2}",
			pvp_combat_end   = "The combat instigated by {1} against {2} has ended",

			pvp_player_damage_weapon = "{1} damaged {2} with a {3}",
			pvp_player_damage = "{1} damaged {2}",
			pvp_misc_dmg = "{1} was damaged by {2}",
			pvp_fall_damage = "{1} took fall damage",
			pvp_world_crush_damage = "{1} was crushed against the world",
			pvp_world_damage = "{1} was damaged by the world",
			pvp_prop_self_damage = "{1} damaged themself with prop {2}",
			pvp_prop_damage = "{1} was damaged by prop {2} created by {3}",
			pvp_world_prop_damage = "{1} was damaged by world prop {2}",
			pvp_dmg_self = "{1} damaged themself",
			pvp_vehicle_damage = "{1} was damaged by vehicle {2} driven by {3}",
			pvp_driverless_vehicle_damage = "{1} was damaged by vehicle {2} driven by no one",
			pvp_vehicle_damage_self = "{1} was damaged by crashing their vehicle {2}",

			pvp_player_silent_death = "{1} was silently killed",
			pvp_death_propkill_self = "{1} propkilled themself with {2}",
			pvp_death_propkill_world = "{1} was propkilled by world prop {2}",
			pvp_death_propkill = "{1} was propkilled by {2} using prop {3}",
			pvp_death_player = "{1} was killed by {2}",
			pvp_death_player_weapon = "{1} was killed by {2} with a {3}",
			pvp_death_world = "{1} was killed by the world",
			pvp_death = "{1} was killed",
			
			pvp_misc_dmg_prop = "{1} took {2} from world prop {3}",
			pvp_misc_dmg_attacker = "{1} took {2} from {3}",
			pvp_misc_dmg_other = "{1} took {2}",

			steamfam = "{1} is Steam Family sharing with {2}",
		},

		pvp_dmgtype_generic = "%u damage",
		pvp_dmgtype_burn = "%u burn damage",
		pvp_dmgtype_crush = "%u crush damage",
		pvp_dmgtype_fall = "%u fall damage",
		pvp_dmgtype_bullet = "%u bullet damage",
		pvp_dmgtype_slash = "%u slash damage",
		pvp_dmgtype_vehicle = "%u vehicle damage",
		pvp_dmgtype_blast = "%u explosion damage",
		pvp_dmgtype_club = "%u club damage",
		pvp_dmgtype_shock = "%u electric shock damage",
		pvp_dmgtype_sonic = "%u sonic damage",
		pvp_dmgtype_energybeam = "%u laser damage",
		pvp_dmgtype_drown = "%u drowning damage",
		pvp_dmgtype_nervegas = "%u neurotoxin damage",
		pvp_dmgtype_poison = "%u poison damage",
		pvp_dmgtype_radiation = "%u radiation damage",
		pvp_dmgtype_acid = "%u chemical damage",
		pvp_dmgtype_gravgun = "%u gravity gun damage",
		pvp_dmgtype_plasma = "%u plasma damage",
		pvp_dmgtype_airboat = "%u airboat gun damage",
		pvp_dmgtype_buckshot = "%u buckshot bullet damage",
		pvp_dmgtype_sniper = "%u sniper bullet damage",

} end }
--PATH addons/[gas] gmodadminsuite-logging-2.4.8/lua/gmodadminsuite/modules/logging/lang/french.lua:
return gluapack()()
--PATH lua/gmodadminsuite/sh_teams.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/fpsbooster/_gas_info.lua:
return {
	Name = "FPS Booster",
	Category = GAS.MODULE_CATEGORY_UTILITIES,
	Hidden = true,
	Wiki = "https://gmodsto.re/gmodadminsuite-fpsbooster-wiki",
	Icon = "icon16/lightning.png",
	Public = true
}
--PATH addons/[gas] gmodadminsuite-jobwhitelist-1.3.4/lua/gmodadminsuite/modules/jobwhitelist/sh_init.lua:
if (SERVER) then
	AddCSLuaFile("sh_jobwhitelist.lua")
	AddCSLuaFile("sh_permissions.lua")
	AddCSLuaFile("sh_contextmenu.lua")
	AddCSLuaFile("cl_menu.lua")
	AddCSLuaFile("sh_factions.lua")
end

GAS:hook("gmodadminsuite:LoadModule:jobwhitelist", "LoadModule:jobwhitelist", function(module_info)
	if (SERVER) then
		include("autorun/server/gas_jobwhitelist_darkrp_load.lua")
	end
	
	GAS:GMInitialize(function()
		if (not DarkRP) then
			GAS:print("[JobWhitelist] DarkRP is not running, aborting", GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_ERROR)
			return
		end

		include("gmodadminsuite/modules/jobwhitelist/sh_jobwhitelist.lua")

		if (SERVER) then
			GAS.XEON:PostLoad(function()
				XEON:Init("6017", "[GAS] Billy's Whitelist", "1.3", "gmodadminsuite/modules/jobwhitelist/sv_drm.lua", include("gmodadminsuite/modules/jobwhitelist/license.lua"))
			end)
		end
	end)
end)
--PATH lua/gmodadminsuite/cl_menu.lua:
local function L(phrase, ...)
	if (#({...}) == 0) then
		return GAS:Phrase(phrase)
	else
		return GAS:PhraseFormat(phrase, nil, ...)
	end
end

GAS.LocalConfig = GAS:GetLocalConfig("gas", {
	AllowVoiceChat = true,
	DefaultModule = false,
	ClosePlayerPopups = false
})

GAS:netReceive("menu_nopermission", function()
	GAS:PlaySound("error")
	GAS:chatPrint(L"menu_nopermission", GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
end)
GAS:netReceive("menu_unknown_module", function()
	GAS:PlaySound("error")
	GAS:chatPrint(L"menu_unknown_module", GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
end)
GAS:netReceive("menu_disabled_module", function()
	GAS:PlaySound("error")
	GAS:chatPrint(L"menu_disabled_module", GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
end)
GAS:netReceive("menu_module_nopermission", function()
	GAS:PlaySound("error")
	GAS:chatPrint(L"menu_module_nopermission", GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
end)

concommand.Add("gmodadminsuite", function(_, __, args)
	if (#args == 0) then
		GAS:netStart("menu_open")
			net.WriteString("")
		net.SendToServer()
	else
		if (args[1] == "reload") then
			GAS:Init()
		elseif (args[1] == "screenclicker") then
			gui.EnableScreenClicker(true)
		else
			GAS:netStart("menu_open")
				net.WriteString(args[1])
			net.SendToServer()
		end
	end
end, function(cmd, args)
	local arg = string.TrimLeft(args)
	local tbl = {}
	local is_operator = OpenPermissions:IsOperator(LocalPlayer())
	for module_name, module_data in pairs(GAS.Modules.Info) do
		if (module_data.OperatorOnly and not is_operator) then continue end
		if (arg and #string.Trim(arg) > 0) then
			if (not module_name:lower():find(string.Trim(arg):lower())) then
				continue
			end
		end
		table.insert(tbl, cmd .. " " .. module_name)
	end
	table.sort(tbl)
	table.insert(tbl, 1, cmd .. " reload")
	table.insert(tbl, 2, cmd .. " screenclicker")
	return tbl
end)

function GAS:OpenModuleFrame(module_name)
	if (IsValid(GAS.ModuleFrame)) then
		GAS.ModuleFrame:Close()
	end

	if (IsValid(GAS.Menu)) then
		if (GAS.Menu.Modules.IndexedItems[module_name]) then
			GAS.Menu.Modules.IndexedItems[module_name]:SetActive(true)
		end
	end

	GAS.ModuleFrame = vgui.Create("bVGUI.Frame")
	GAS.ModuleFrame.ModuleName = module_name
	local w, h = 1200, 700
	if (ScrW() < w or ScrH() < h) then
		w = ScrW()
		h = ScrH()
	end
	GAS.ModuleFrame:SetSize(w,h)
	GAS.ModuleFrame:MakePopup()
	GAS.ModuleFrame:SetTitle(GAS.Modules:GetFriendlyName(module_name))
	GAS.ModuleFrame:SetVisible(false)

	GAS.ModuleFrame.DragThink = GAS.ModuleFrame.Think
	function GAS.ModuleFrame:Think()
		self:DragThink()
		if (IsValid(GAS.Menu)) then
			self.bVGUI_FullscreenButton.OffsetX = 200

			local x_1, y_1, w_1, h_1 = self:GetBounds()
			GAS.Menu:SetPos(x_1 - 200 + 1, y_1)
			GAS.Menu:SetSize(200, h_1)
		else
			self.bVGUI_FullscreenButton.OffsetX = nil
		end
	end

	function GAS.ModuleFrame:OnClose()
		local x, y = self:GetPos()
		cookie.Set("gmodadminsuite_module_" .. self.ModuleName .. "_x_" .. ScrW(), x)
		cookie.Set("gmodadminsuite_module_" .. self.ModuleName .. "_y_" .. ScrH(), y)
	end

	function GAS.ModuleFrame:DermaMenuOptions(menu)
		if (not IsValid(GAS.Menu)) then
			menu:AddOption(L"open_gas", function()
				GAS:PlaySound("jump")
				GAS:OpenMenu()
			end):SetIcon("icon16/application_home.png")
		end

		menu:AddOption(L"close", function()
			if IsValid(self) then
				GAS.ModuleFrame:Remove()
			end
		end):SetIcon("icon16/cancel.png")

		menu:AddOption(L"module_shortcut", function()
			GAS:PlaySound("flash")
			bVGUI.RichMessage({
				title = L"module_shortcut",
				button = "OK",
				textCallback = function(richtext)
					local highlight_col = {0,255,255,255}
					local phrase = string.Explode("%s", GAS:Phrase("module_shortcut_info"))
					richtext:AppendText(phrase[1])

					richtext:InsertColorChange(unpack(highlight_col))
					richtext:AppendText("gmodadminsuite " .. module_name)

					richtext:InsertColorChange(255,255,255,255)
					richtext:AppendText(phrase[2])

					richtext:InsertColorChange(unpack(highlight_col))
					richtext:AppendText(GAS.Config.ChatCommand .. " " .. module_name)

					richtext:InsertColorChange(255,255,255,255)
					richtext:AppendText(phrase[3])

					richtext:InsertColorChange(unpack(highlight_col))
					richtext:AppendText("bind KEY \"gmodadminsuite " .. module_name .. "\"")

					richtext:InsertColorChange(255,255,255,255)
					richtext:AppendText(phrase[4])

					richtext:InsertColorChange(unpack(highlight_col))
					richtext:AppendText("https://developer.valvesoftware.com/wiki/Bind#Special_Keys")
				end
			})
		end):SetIcon("icon16/star.png")

		menu:AddOption(L"module_reset_data", function()
			GAS:PlaySound("flash")
			if IsValid(self) then
				self:SetSize(self.RealSize[1], self.RealSize[2])
				self:Center()
				local x, y = self:GetPos()
				cookie.Set("gmodadminsuite_module_" .. self.ModuleName .. "_x_" .. ScrW(), x)
				cookie.Set("gmodadminsuite_module_" .. self.ModuleName .. "_y_" .. ScrH(), y)
				cookie.Set("gmodadminsuite_module_" .. module_name .. "_w", self:GetWide())
				cookie.Set("gmodadminsuite_module_" .. module_name .. "_h", self:GetTall())
			end
		end):SetIcon("icon16/arrow_rotate_clockwise.png")

		if (GAS.Modules.Info[module_name].ScriptPage) then
			menu:AddOption(L"script_page", function()
				GAS:OpenURL(GAS.Modules.Info[module_name].ScriptPage)
			end):SetIcon("icon16/page_code.png")
		end

		if (GAS.Modules.Info[module_name].Wiki) then
			menu:AddOption(L"wiki", function()
				GAS:OpenURL(GAS.Modules.Info[module_name].Wiki)
			end):SetIcon("icon16/book.png")
		end

		if (GAS.ModuleFrame.Extra_DermaMenuOptions) then
			GAS.ModuleFrame:Extra_DermaMenuOptions(menu)
		end
	end

	-- would use file.IsDir, but: https://github.com/Facepunch/garrysmod-issues/issues/3592
	local _,d = file.Find("gmodadminsuite/modules/*", "LUA")
	if (table.HasValue(d, module_name) and not GAS.Modules:IsModuleLoaded(module_name)) then
		GAS.Modules:LoadModule(module_name)
	end

	local real_w, real_h = hook.Run("gmodadminsuite:ModuleSize:" .. module_name)

	w = math.min(cookie.GetNumber("gmodadminsuite_module_" .. module_name .. "_w", real_w), ScrW())
	h = math.min(cookie.GetNumber("gmodadminsuite_module_" .. module_name .. "_h", real_h), ScrH())

	GAS.ModuleFrame:SetSize(w,h)
	GAS.ModuleFrame:SetMinimumSize(real_w, real_h)
	GAS.ModuleFrame:Center()
	GAS.ModuleFrame:SetVisible(true)

	local new_x = cookie.GetNumber("gmodadminsuite_module_" .. module_name .. "_x_" .. ScrW(), false)
	local new_y = cookie.GetNumber("gmodadminsuite_module_" .. module_name .. "_y_" .. ScrH(), false)
	local cur_x, cur_y = GAS.ModuleFrame:GetPos()

	GAS.ModuleFrame:SetPos(new_x or cur_x, new_y or cur_y)

	GAS.ModuleFrame.OpenModule = module_name
	GAS.ModuleFrame.RealSize = {
		real_w,
		real_h
	}

	hook.Run("gmodadminsuite:ModuleFrame:" .. module_name, GAS.ModuleFrame)

	GAS.ModuleFrame:EnableUserResize()

	function GAS.ModuleFrame:OnResize(new_w, new_h)
		cookie.Set("gmodadminsuite_module_" .. module_name .. "_w", new_w)
		cookie.Set("gmodadminsuite_module_" .. module_name .. "_h", new_h)
	end

	return GAS.ModuleFrame
end

local logo_mat = Material("gmodadminsuite/gmodadminsuite.vtf")
local function OpenMenu()
	local is_operator = OpenPermissions:IsOperator(LocalPlayer())

	GAS.Menu = vgui.Create("bVGUI.Frame")
	GAS.Menu:ShowFullscreenButton(false)
	GAS.Menu:SetSize(800,500)
	GAS.Menu:SetTitle("GmodAdminSuite " .. GAS.Version)
	GAS.Menu:Center()
	GAS.Menu:MakePopup()

	if (IsValid(GAS.ModuleFrame) and GAS.ModuleFrame.Fullscreened) then
		GAS.ModuleFrame.bVGUI_FullscreenButton.OffsetX = 200
		GAS.ModuleFrame:Stop()
		GAS.ModuleFrame:SizeTo(ScrW() - 200, ScrH(), 0.5, 0, 0.5)
		GAS.ModuleFrame:MoveTo(200,0, 0.5, 0, 0.5)
	end
	function GAS.Menu:OnClose()
		if (IsValid(GAS.ModuleFrame) and GAS.ModuleFrame.Fullscreened) then
			GAS.ModuleFrame:Stop()
			GAS.ModuleFrame:SizeTo(ScrW(), ScrH(), 0.5, 0, 0.5)
			GAS.ModuleFrame:MoveTo(0, 0, 0.5, 0, 0.5)
		end
	end

	GAS.Menu.Modules = vgui.Create("bVGUI.Categories", GAS.Menu)
	GAS.Menu.Modules:Dock(LEFT)
	GAS.Menu.Modules:SetWide(200)
	GAS.Menu.Modules:SetDrawBackground(false)
	GAS.Menu.Modules.IndexedItems = {}

	GAS.Menu.Content = vgui.Create("bVGUI.BlankPanel", GAS.Menu)
	GAS.Menu.Content:Dock(FILL)
	function GAS.Menu.Content:PaintOver(w,h)
		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(bVGUI.MATERIAL_SHADOW)
		surface.DrawTexturedRect(0,0,10,h)
	end

	GAS.Menu.DragThink = GAS.Menu.Think
	function GAS.Menu:Think()
		self:DragThink()
		if (IsValid(GAS.ModuleFrame)) then
			self:SetTall(GAS.ModuleFrame:GetTall())
			if (self.Dragging) then
				local x,y = self:GetPos()
				GAS.ModuleFrame:SetPos(x + self:GetWide() - 1, y)
			end
		elseif (GAS.Menu:GetWide() ~= 800 or GAS.Menu:GetTall() ~= 500) then
			GAS.Menu:SetSize(800,500)
			GAS.Menu:Center()
			GAS.Menu.Modules:ClearActive()
		end
	end

	function GAS.Menu:DermaMenuOptions(menu)
		menu:AddOption(L"close", function()
			GAS.Menu:Close()
		end):SetIcon("icon16/cancel.png")
		menu:AddOption(L"website", function()
			GAS:OpenURL("https://gmodadminsuite.com")
		end):SetIcon("icon16/monitor.png")
		menu:AddOption(L"wiki", function()
			GAS:OpenURL("https://gmodsto.re/gmodadminsuite-wiki")
		end):SetIcon("icon16/book.png")
		-- menu:AddOption("Discord", function()
		-- 	GAS:OpenURL("https://gmodsto.re/gmodadminsuite-discord")
		-- end):SetIcon("materials/gmodadminsuite/discord.png")
	end

	local function SizeAndPosition(size_w, size_h, pos_x, pos_y)
		size_w = size_w + 200
		size_h = size_h + 24

		GAS.Menu:Stop()

		local anim = GAS.Menu:NewAnimation(0.5)
		anim.Size  = Vector(size_w, size_h, 0)
		anim.Think = function(anim, panel, fraction)
			if (not anim.StartSize) then
				local w, h = panel:GetSize()
				anim.StartSize = Vector(w, h, 0)
			end

			local size = LerpVector(fraction, anim.StartSize, anim.Size)
			panel:SetSize(size.x, size.y)
		end

		local anim = GAS.Menu:NewAnimation(0.5)
		anim.Pos   = Vector(pos_x or ((ScrW() / 2) - (size_w / 2)), pos_y or ((ScrH() / 2) - (size_h / 2)))
		anim.Think = function(anim, panel, fraction)
			if (not anim.StartPos) then
				local w, h = panel:GetPos()
				anim.StartPos = Vector(w, h, 0)
			end

			local size = LerpVector(fraction, anim.StartPos, anim.Pos)
			panel:SetPos(size.x, size.y)
		end
	end

	GAS.Menu.Tabs = vgui.Create("bVGUI.Tabs", GAS.Menu.Content)
	GAS.Menu.Tabs:Dock(TOP)
	GAS.Menu.Tabs:SetTall(40)

	local welcome_content = GAS.Menu.Tabs:AddTab(L"welcome", Color(76,216,76))

	GAS.Menu.Info = vgui.Create("bVGUI.BlankPanel", welcome_content)
	GAS.Menu.Info:Dock(FILL)

	GAS.Menu.Info.Logo = vgui.Create("DImage", GAS.Menu.Info)
	GAS.Menu.Info.Logo:SetMaterial(logo_mat)
	GAS.Menu.Info.Logo:SetSize(256,256)

	GAS.Menu.Info.ButtonContainer = vgui.Create("bVGUI.BlankPanel", GAS.Menu.Info)
	GAS.Menu.Info.ButtonContainer:SetSize(150,(30 * 3) + (10 * 2))

	local btn1 = vgui.Create("bVGUI.Button", GAS.Menu.Info.ButtonContainer)
	btn1:Dock(TOP)
	btn1:DockMargin(0,0,0,10)
	btn1:SetColor(bVGUI.BUTTON_COLOR_RED)
	btn1:SetText(L"website")
	function btn1:DoClick()
		GAS:OpenURL("https://gmodadminsuite.com")
	end

	local btn2 = vgui.Create("bVGUI.Button", GAS.Menu.Info.ButtonContainer)
	btn2:Dock(TOP)
	btn2:DockMargin(0,0,0,10)
	btn2:SetColor(bVGUI.BUTTON_COLOR_GREEN)
	btn2:SetText(L"wiki")
	function btn2:DoClick()
		GAS:OpenURL("https://gmodsto.re/gmodadminsuite-wiki")
	end

	local btn3 = vgui.Create("bVGUI.Button", GAS.Menu.Info.ButtonContainer)
	btn3:Dock(TOP)
	btn3:SetColor(Color(114, 137, 218))
	btn3:SetText("Discord")
	function btn3:DoClick()
		GAS:OpenURL("https://gmodsto.re/gmodadminsuite-discord")
	end

	GAS.Menu.Info.Copyright = vgui.Create("DLabel", GAS.Menu.Info)
	GAS.Menu.Info.Copyright:SetText("Copyright © " .. os.date("%Y") .. " Billy Venner")
	GAS.Menu.Info.Copyright:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	GAS.Menu.Info.Copyright:SizeToContents()
	GAS.Menu.Info.Copyright:SetMouseInputEnabled(true)
	GAS.Menu.Info.Copyright:SetCursor("hand")
	GAS.Menu.Info.Copyright:SetTextColor(Color(255,255,255,10))
	function GAS.Menu.Info.Copyright:DoClick()
		GAS:OpenURL("https://steamcommunity.com/profiles/76561198040894045")
	end

	function GAS.Menu.Info:PerformLayout()
		self.Logo:SetPos(self:GetWide() / 2 - self.Logo:GetWide() / 2, self:GetTall() / 2 - self.Logo:GetTall() / 2 - 150 / 2 - 5)
		self.ButtonContainer:SetPos(self:GetWide() / 2 - self.ButtonContainer:GetWide() / 2, self:GetTall() / 2 + 5)
		self.Copyright:CenterHorizontal()
		self.Copyright:AlignBottom(10)
	end

	local settings_content, settings_tab = GAS.Menu.Tabs:AddTab(L"settings", Color(76,76,216))
	settings_tab:SetFunction(function()
		if (settings_content.Content) then
			PrintTable(settings_content.Content)
			for _,v in ipairs(settings_content.Content) do
				v:Remove()
			end
			settings_content.Content = {}
		else
			settings_content.Content = {}
		end

		local tabs = vgui.Create("bVGUI.Tabs", settings_content)
		tabs:Dock(TOP)
		tabs:SetTall(40)
		table.insert(settings_content.Content, tabs)

		local general_settings = tabs:AddTab(L"general", Color(216,76,76))
		local language_settings = tabs:AddTab(L"localization", Color(76,216,76))

		local general_settings_form = vgui.Create("bVGUI.Form", general_settings)
		general_settings_form:Dock(FILL)
		general_settings_form:DockMargin(15,15,15,15)
		general_settings_form:SetPaddings(15,15)

		local _,combobox = general_settings_form:AddComboBox(L"setting_default_module", nil, L"setting_default_module_tip", function(index, val, data)
			GAS.LocalConfig.DefaultModule = data
			GAS:SaveLocalConfig("gas", GAS.LocalConfig)
		end)
		combobox:SetSortItems(false)
		combobox:AddChoice(L"none", false, not GAS.LocalConfig.DefaultModule, "icon16/cross.png")

		general_settings_form:AddSwitch(L"setting_menu_voicechat", GAS.LocalConfig.AllowVoiceChat, L"setting_menu_voicechat_tip", function(val)
			GAS.LocalConfig.AllowVoiceChat = val
			GAS:SaveLocalConfig("gas", GAS.LocalConfig)
		end)

		general_settings_form:AddSwitch(L"settings_player_popup_close", GAS.LocalConfig.ClosePlayerPopups, L"settings_player_popup_close_tip", function(val)
			GAS.LocalConfig.ClosePlayerPopups = val
			GAS:SaveLocalConfig("gas", GAS.LocalConfig)
		end)

		local language_settings_form = vgui.Create("bVGUI.Form", language_settings)
		language_settings_form:Dock(FILL)
		language_settings_form:DockMargin(15,15,15,15)
		language_settings_form:SetPaddings(15,15)

		language_settings_form:AddTextEntry(L"short_date_format", GAS.Languages.Config.ShortDateFormat or "", L"short_date_format_tip", function(val)
			if (#val == 0) then
				GAS.Languages.Config.ShortDateFormat = false
			else
				GAS.Languages.Config.ShortDateFormat = val
			end
		end, nil, L"default_format")

		language_settings_form:AddTextEntry(L"long_date_format", GAS.Languages.Config.LongDateFormat or "", L"long_date_format_tip", function(val)
			if (#val == 0) then
				GAS.Languages.Config.LongDateFormat = false
			else
				GAS.Languages.Config.LongDateFormat = val
			end
		end, nil, L"default_format")

		language_settings_form:AddSpacing(15)

		local function create_language_setting(module_name, info)
			local _,language_combobox = language_settings_form:AddComboBox(info.Name, nil, "", function(index, value, data)
				if (not data) then
					GAS.Languages.Config.SelectedLanguages[module_name] = nil
				else
					GAS.Languages.Config.SelectedLanguages[module_name] = data
				end
				GAS:SaveLocalConfig("languages", GAS.Languages.Config)
			end, info.Icon)
			language_combobox:SetSortItems(false)
			if (module_name ~= "GAS") then
				language_combobox:AddChoice(L"use_gas_language", false, GAS.Languages.Config.SelectedLanguages[module_name] == nil, "icon16/wand.png")
			end
			for language_name, language_info in pairs(GAS.Languages.LanguageData[module_name]) do
				local selected = false
				if (GAS.Languages.Config.SelectedLanguages[module_name] and GAS.Languages.Config.SelectedLanguages[module_name] == language_name) then
					selected = true
				end
				language_combobox:AddChoice(language_info.Name, language_name, selected, language_info.Flag)
			end
		end
		create_language_setting("GAS", {
			Name = "GmodAdminSuite",
			Icon = "icon16/shield.png",
		})
		for module_name, info in pairs(GAS.Modules.Info) do
			if (info.NoMenu or info.Hidden) then continue end
			combobox:AddChoice(info.Name, module_name, GAS.LocalConfig.DefaultModule == module_name, info.Icon)
			create_language_setting(module_name, info)
		end
	end)

	if (is_operator) then
		local operator_content = GAS.Menu.Tabs:AddTab(L"operator", Color(216,76,76))

		local operator_tabs = vgui.Create("bVGUI.Tabs", operator_content)
		operator_tabs:Dock(TOP)
		operator_tabs:SetTall(40)

		local modules_tab_content = operator_tabs:AddTab(L"modules", Color(76,216,76))
		function modules_tab_content:PaintOver(w,h)
			surface.SetDrawColor(255,255,255,255)
			surface.SetMaterial(bVGUI.MATERIAL_SHADOW)
			surface.DrawTexturedRect(175,0,10,h)
		end

		local modules_categories = vgui.Create("bVGUI.Categories", modules_tab_content)
		modules_categories:Dock(LEFT)
		modules_categories:SetWide(175)

		local modules_content

		modules_categories:AddItem(L"permissions", function()
			if (IsValid(modules_content)) then
				modules_content:Remove()
			end
			modules_content = vgui.Create("bVGUI.BlankPanel", modules_tab_content)
			modules_content:Dock(FILL)

			local permissions_btn_c = vgui.Create("bVGUI.ButtonContainer", modules_content)
			permissions_btn_c:DockMargin(10,10,10,10)
			permissions_btn_c:Dock(TOP)
			permissions_btn_c:SetTall(25)

			local permissions_btn = permissions_btn_c.Button
			permissions_btn:SetColor(bVGUI.BUTTON_COLOR_ORANGE)
			permissions_btn:SetText("OpenPermissions")
			permissions_btn:SetSize(150,25)
			function permissions_btn:DoClick()
				GAS:PlaySound("flash")
				RunConsoleCommand("openpermissions", "gmodadminsuite")
			end

			local text = vgui.Create("DLabel", modules_content)
			text:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
			text:Dock(FILL)
			text:SetContentAlignment(8)
			text:DockMargin(10,0,10,10)
			text:SetTextColor(bVGUI.COLOR_WHITE)
			text:SetText(L"permissions_help")
			text:SetWrap(true)
		end, Color(255,150,50))

		for category, modules in pairs(GAS.Modules.Organised) do
			local category_vgui
			local category_col
			if (category == GAS.MODULE_CATEGORY_ADMINISTRATION) then
				category_col = Color(255,35,35)
				category_vgui = modules_categories:AddCategory(L"administration", category_col)
			elseif (category == GAS.MODULE_CATEGORY_PLAYER_MANAGEMENT) then
				category_col = Color(0,130,255)
				category_vgui = modules_categories:AddCategory(L"player_management", category_col)
			elseif (category == GAS.MODULE_CATEGORY_UTILITIES) then
				category_col = Color(255,75,0)
				category_vgui = modules_categories:AddCategory(L"utilities", category_col)
			elseif (category == GAS.MODULE_CATEGORY_FUN) then
				category_col = Color(190,0,255)
				category_vgui = modules_categories:AddCategory(L"fun", category_col)
			end
			for module_name, info in pairs(modules) do
				local icon = "icon16/delete.png"
				if (GAS.Modules.Config.Enabled[module_name]) then
					icon = "icon16/accept.png"
				end
				local friendly_name = GAS.Modules:GetFriendlyName(module_name)
				local module_item
				module_item = category_vgui:AddItem(friendly_name, function()
					if (IsValid(modules_content)) then
						modules_content:Remove()
					end
					modules_content = vgui.Create("bVGUI.BlankPanel", modules_tab_content)
					modules_content:Dock(FILL)

					local header = vgui.Create("bVGUI.Header", modules_content)
					header:Dock(TOP)
					header:SetText(friendly_name)
					header:SetColor(category_col)
					header:DockMargin(0,0,0,10)

					if (info.Icon) then
						local icon1 = vgui.Create("DImage", header)
						icon1:SetSize(16,16)
						icon1:SetImage(info.Icon)

						local icon2 = vgui.Create("DImage", header)
						icon2:SetSize(16,16)
						icon2:SetImage(info.Icon)

						function header:PerformLayout()
							icon1:AlignLeft(5)
							icon1:CenterVertical()

							icon2:AlignRight(5)
							icon2:CenterVertical()
						end
					end

					local switch_container = vgui.Create("bVGUI.BlankPanel", modules_content)
					switch_container:Dock(TOP)
					switch_container:SetTall(40)
					switch_container:DockMargin(0,0,0,10)

					local switch = vgui.Create("bVGUI.Switch", switch_container)
					switch:SetChecked(GAS.Modules.Config.Enabled[module_name] or false)
					switch:SetText(L"enabled")
					function switch:OnChange()
						if (self:GetChecked()) then
							module_item:SetIcon("icon16/accept.png")
						else
							module_item:SetIcon("icon16/delete.png")
						end
						GAS.Modules.Config.Enabled[module_name] = self:GetChecked() or nil
						GAS:netStart("SetModuleEnabled")
							net.WriteString(module_name)
							net.WriteBool(self:GetChecked())
						net.SendToServer()
					end
					bVGUI.AttachTooltip(switch.ClickableArea, {Text = L"module_enable_switch_tip"})

					function switch_container:PerformLayout()
						switch:Center()
					end

					local script_buttons_container
					local script_buttons = {}
					if (info.GmodStore or info.CridentStore) then
						script_buttons_container = vgui.Create("bVGUI.BlankPanel", modules_content)
						script_buttons_container:Dock(TOP)
						script_buttons_container:SetTall(25)
						script_buttons_container:DockMargin(0,0,0,10)
						function script_buttons_container:PerformLayout(_w)
							local w = (_w - (#script_buttons * (125 + 10)) + 10) / 2
							for i,v in ipairs(script_buttons) do
								v:AlignLeft(w + ((i - 1) * (10 + 125)))
							end
						end
					end

					if (info.GmodStore) then
						local gms = vgui.Create("bVGUI.Button", script_buttons_container)
						table.insert(script_buttons, gms)
						gms:SetSize(125,25)
						gms:SetColor(Color(0,152,234))
						gms:SetText("GmodStore")
						function gms:DoClick()
							GAS:OpenURL("https://gmodstore.com/market/view/" .. info.GmodStore)
						end
					end

					if (info.CridentStore) then
						local crs = vgui.Create("bVGUI.Button", script_buttons_container)
						table.insert(script_buttons, crs)
						crs:SetSize(125,25)
						crs:SetColor(Color(255,40,0))
						crs:SetText("Crident Store")
						function crs:DoClick()
							GAS:OpenURL("https://crident.store/market/products/" .. info.CridentStore)
						end
					end

					if (info.Wiki) then
						local wiki_c = vgui.Create("bVGUI.ButtonContainer", modules_content)
						wiki_c:Dock(TOP)
						wiki_c:SetTall(25)
						wiki_c:DockMargin(0,0,0,10)

						wiki_c.Button:SetColor(bVGUI.BUTTON_COLOR_GREEN)
						wiki_c.Button:SetText(L"wiki")
						wiki_c.Button:SetSize(125,25)
						function wiki_c.Button:DoClick()
							GAS:OpenURL(info.Wiki)
						end
					end
				end, nil, icon)
			end
		end
	end

	local created_anything = false
	for category, modules in pairs(GAS.Modules.Organised) do
		local category_vgui
		for module_name, info in pairs(modules) do
			if (info.NoMenu or info.Hidden) then continue end
			if (info.DarkRP == true and DarkRP == nil) then continue end
			if (GAS.Modules:IsModuleEnabled(module_name) ~= GAS.Modules.MODULE_ENABLED) then continue end
			if (info.OperatorOnly and not is_operator) then continue end
			if (not is_operator and not OpenPermissions:HasPermission(LocalPlayer(), "gmodadminsuite/" .. module_name)) then continue end
			created_anything = true
			if (not category_vgui) then
				if (category == GAS.MODULE_CATEGORY_ADMINISTRATION) then
					category_vgui = GAS.Menu.Modules:AddCategory(L"administration", Color(255,35,35))
				elseif (category == GAS.MODULE_CATEGORY_PLAYER_MANAGEMENT) then
					category_vgui = GAS.Menu.Modules:AddCategory(L"player_management", Color(0,130,255))
				elseif (category == GAS.MODULE_CATEGORY_UTILITIES) then
					category_vgui = GAS.Menu.Modules:AddCategory(L"utilities", Color(255,75,0))
				elseif (category == GAS.MODULE_CATEGORY_FUN) then
					category_vgui = GAS.Menu.Modules:AddCategory(L"fun", Color(190,0,255))
				end
			end
			local item = category_vgui:AddItem(GAS.Modules:GetFriendlyName(module_name), function()
				GAS.Menu.ModuleOpen = module_name

				GAS:OpenModuleFrame(module_name)
				
				GAS.Menu.Fullscreened = false

				local _,h = GAS.ModuleFrame:GetSize()
				GAS.Menu:SetTall(h)
			end, nil, info.Icon)
			if (IsValid(GAS.ModuleFrame)) then
				if (GAS.ModuleFrame.ModuleName == module_name) then
					item:SetActive(true)
				end
			elseif (GAS.LocalConfig.DefaultModule == module_name) then
				item:OnMouseReleased(MOUSE_LEFT)
			end

			GAS.Menu.Modules.IndexedItems[module_name] = item
		end
	end
	if (not created_anything) then
		if (not is_operator) then
			GAS:PlaySound("error")
			bVGUI.RichMessage({
				title = L"no_modules_available",
				text = L"no_modules_available_info",
				button = "OK"
			})
			GAS.Menu:Close()
		else
			GAS.Menu.Modules:SetWide(0)
		end
	else
		GAS.Menu:SetVisible(true)
	end
end

function GAS:OpenMenu()
	if (not GAS_InitPostEntity) then GAS:InitPostEntity_Run() end
	if (IsValid(GAS.Menu)) then GAS.Menu:Close() end

	if (not GAS.Modules.Config) then
		GAS:GetConfig("modules", function(config)
			GAS.Modules.Config = config
			for module_name, enabled in pairs(GAS.Modules.Config.Enabled) do
				if (not enabled) then continue end
				GAS.Modules:LoadModule(module_name, true)
			end
			OpenMenu()
		end)
	else
		OpenMenu()
	end
end

GAS:netReceive("menu", function()
	local selected_module = net.ReadString()
	if (#selected_module == 0) then
		selected_module = false
	end
	if (not selected_module or not hook.Run("gmodadminsuite:ModuleMenu:" .. selected_module)) then
		if (selected_module) then
			GAS:OpenModuleFrame(selected_module)
		else
			GAS:OpenMenu()
		end
	end
end)
--PATH lua/autorun/gunner.lua:
return gluapack()()
--PATH lua/autorun/human_pm.lua:
player_manager.AddValidModel( "pm_prisoner_human1", "models/human1/pm_prisoner_human1.mdl" )
player_manager.AddValidModel( "pm_prisoner_human2", "models/human2/pm_prisoner_human2.mdl" )
player_manager.AddValidModel( "pm_prisoner_human3", "models/human3/pm_prisoner_human3.mdl" )
player_manager.AddValidModel( "pm_prisoner_umbaran", "models/umbaran/pm_prisoner_umbaran.mdl" )
player_manager.AddValidModel( "pm_prisoner_nautolan", "models/nautolan/pm_prisoner_nautolan.mdl" )
player_manager.AddValidModel( "pm_prisoner_clone", "models/clone/pm_prisoner_clone.mdl" )
player_manager.AddValidModel( "pm_prisoner_rodian", "models/rodian/pm_prisoner_rodian.mdl" )
player_manager.AddValidModel( "pm_prisoner_quarren", "models/quarren/pm_prisoner_quarren.mdl" )
player_manager.AddValidModel( "pm_prisoner_pantoran", "models/pantoran/pm_prisoner_pantoran.mdl" )
player_manager.AddValidModel( "pm_prisoner_trandoshan", "models/trandoshan/pm_prisoner_trandoshan.mdl" )
--PATH lua/imagetool/cl_net.lua:
return gluapack()()
--PATH lua/autorun/jawachef.lua:
player_manager.AddValidModel( "Jawa Chef",		"models/jajoff/sw/jawachef.mdl" );
list.Set( "PlayerOptionsModel", "Jawa Chef",		"models/jajoff/sw/jawachef.mdl" );
--PATH lua/autorun/jkrevangoh.lua:
player_manager.AddValidModel( "Jedi Knight Revan (GOH)",                     "models/player/griffbo/JKRevanGOH.mdl" )
list.Set( "PlayerOptionsModel",  "Jedi Knight Revan (GOH)",                     "models/player/griffbo/JKRevanGOH.mdl" ) 
player_manager.AddValidHands( "Jedi Knight Revan (GOH)", "models/player/Griffbo/JKRArm.mdl", 0, "00000000" )
--Add NPC
local Category = "Griffbo's NPCs"

local NPC = { 	Name = "Jedi Knight Revan (Ally)", 
				Class = "npc_citizen",
				Model = "models/player/griffbo/JKRevanGOH.mdl",
				Health = "250",
				KeyValues = { citizentype = 4 },
                                Category = Category    }

list.Set( "NPC", "JKRGOHAlly", NPC )

local Category = "Griffbo's NPCs"

local NPC = { 	Name = "Jedi Knight Revan (Hostile)", 
				Class = "npc_combine_s",
				Model = "models/player/griffbo/JKRevanGOH.mdl",
				Health = "250",
				KeyValues = { citizentype = 4 },
                                Category = Category    }

list.Set( "NPC", "JKRGOHHostile", NPC )
--PATH lua/autorun/kilian.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/cl_forcepowers.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/cl_lscs_menu.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/lscs_damage.lua:
-- this is where the public saber system differentiates the most from the GVP version.
-- in GVP, since i have full control over what weapon systems to expect, the bullet or damage data is never actually messed with as blood effects, damage, tracer information ect all happen through internal communication with the weapon systems.
-- on a public version however, it can not be done like this as we do not know what kind of weapons there are and if they rely on their callbacks ect. Generally the public version is written in alot more cancerous way, as it has to support a wide range of unknown weapon systems.
-- so instead of preventing it all before it happens, this system just lets it happen and then tries to clean up the mess afterwards. BIG GAY

local meta = FindMetaTable( "Player" )

LSCS_BLOCK_NONSABER = 4
LSCS_BLOCK_PERFECT = 3
LSCS_BLOCK_NORMAL = 2
LSCS_BLOCK = 1
LSCS_UNBLOCKED = 0

function meta:lscsSuppressFalldamage( time )
	self._lscsPreventFallDamageTill = time
end

function meta:lscsIsFalldamageSuppressed()
	if self._lscsPreventFallDamageTill == true then
		return true
	else
		return (self._lscsPreventFallDamageTill or 0) > CurTime()
	end
end

function meta:lscsShouldBleed()
	return self:GetNWBool( "lscsShouldBleed", true ) -- gay
end

if SERVER then
	util.AddNetworkString( "lscs_hitmarker" )

	hook.Add("GetFallDamage", "!!lscs_RemoveFallDamage", function(ply, speed)
		if ply:lscsIsFalldamageSuppressed() then
			return 0
		end
	end)

	-- engine stuff doesnt come with the correct callbacks, tracer name and whatnot
	-- so this must be done manually
	local ClassDeflectable = {
		["npc_turret_floor"] = true,
		["npc_strider"] = true,
		["npc_helicopter"] = true,
		["npc_combinegunship"] = true,
	}
	local AmmoTypeDeflectable = {
		["CombineCannon"] = true, -- dropship container gun, the container gives a NULL entity as attacker and inflictor... amazing stuff
		["AR2"] = true, -- AR2
	}


	-- fix conflict with CAP:Code  https://steamcommunity.com/sharedfiles/filedetails/?id=175394472
	local HookSG = false
	hook.Add( "LSCS:EntityFireBullets", "StarGate.CAP.Code.Fix", function( entity, bullet )
		if HookSG == false then
			local FireBulletsSG = hook.GetTable()["EntityFireBullets"]["StarGate.EntityFireBullets"]

			if isfunction( FireBulletsSG ) then
				HookSG = FireBulletsSG

				return HookSG( entity, bullet )
			else
				HookSG = true
			end
		else
			if HookSG ~= true then
				return HookSG( entity, bullet )
			end
		end
	end)


	hook.Add( "EntityFireBullets", "!!!lscs_deflecting", function( entity, bullet )
		if IsValid( entity ) and entity.IsVJBaseSNPC then return end -- for some reason VJBase npc's act different and already break by doing nothing in this hook. So let's let EntityTakeDamage handle this instead. Don't return anything.

		local oldCallback = bullet.Callback
		bullet.Callback = function(att, tr, dmginfo)
			local ply = tr.Entity

			if IsValid( ply ) and ply:IsPlayer() then
				local wep = ply:GetActiveWeapon()

				if not IsValid( wep ) or not wep.LSCS or dmginfo:GetDamage() == 0 then -- damage = 0... ArcCW... detected...
					if oldCallback then
						oldCallback( att, tr, dmginfo )
					end

					return
				end

				local DeflectHack = not bullet.TracerName and AmmoTypeDeflectable[ bullet.AmmoType ] -- if this is true its most likely the AR2 or the dropship container

				if IsValid( bullet.Attacker ) and ClassDeflectable[ bullet.Attacker:GetClass() ] then -- this is for everything else that uses that similar to AR2 plasma bullet type
					DeflectHack = true
				end

				if DeflectHack  then
					bullet.TracerName = "ar2tracer_custom" -- inject a tracer, since i couldnt get vanilla ar2tracer to work i just made my own
				end

				wep:DeflectBullet( att, tr, dmginfo, bullet )

				if DeflectHack then
					bullet.TracerName = nil -- remove the tracer when we are done to avoid conflicts
				end

				if dmginfo:GetDamage() ~= 0 and dmginfo:GetDamageType() ~= DMG_REMOVENORAGDOLL then -- dirty but works
					if oldCallback then -- engine weapons <sometimes> dont have a callback so this check is needed
						oldCallback( att, tr, dmginfo )
					end
				end
			else
				-- just allow normal callback to run if not player
				if oldCallback then -- engine weapons <sometimes> dont have a callback so this check is needed
					oldCallback( att, tr, dmginfo )
				end
			end
		end

		local ShouldFireBullet = hook.Run( "LSCS:EntityFireBullets", entity, bullet ) -- this will allow other addons to still be able to hook into FireBullets while keeping LSCS deflecting intact

		if ShouldFireBullet == false then
			return false
		end

		return true
	end)


	hook.Add( "EntityTakeDamage", "!!!lscs_block_damage", function( ply, dmginfo )

		if not ply:IsPlayer() then return end

		if dmginfo:IsDamageType( DMG_PREVENT_PHYSICS_FORCE ) and dmginfo:IsDamageType( DMG_REMOVENORAGDOLL ) then return end -- failed bullet deflect detected. Don't run block code, but allow damage.

		if dmginfo:GetDamage() == 0 and dmginfo:GetDamageType() == DMG_REMOVENORAGDOLL then return true end -- deflected bullet detected. Don't run block code, prevent damage.

		if not ply:lscsShouldBleed() then
			ply:lscsClearBlood()
		end

		local wep = ply:GetActiveWeapon()

		if not IsValid( wep ) or not wep.LSCS then return end

		if dmginfo:IsDamageType( DMG_BULLET + DMG_AIRBOAT ) then -- some npcs shoot "fake" bullets that just do entitytakedamage with a visual bullet effect
			return wep:BlockDMGinfoBullet( dmginfo ) -- and these can not be deflected properly as they aint calling FireBullets. However we still treat them as bullets internally.
		else
			return wep:Block( dmginfo ) > LSCS_UNBLOCKED
		end
	end )

	util.AddNetworkString( "lscs_saberdamage" )
	util.AddNetworkString( "lscs_clearblood" )

	local slice = {
		["npc_zombie"] = true,
		["npc_zombine"] = true,
		["npc_fastzombie"] = true,
	}

	function LSCS:ApplyDamage( ply, victim, pos, dir )
		local plyID = ply:EntIndex()
		local Time = CurTime()

		if victim._lscsHitTimes then
			local HitTime = victim._lscsHitTimes[ plyID ]

			if HitTime then
				if HitTime > Time then return end
			end
		end

		local dmg = DamageInfo()
		dmg:SetAttacker( ply )
		dmg:SetDamageForce( (victim:GetPos() - ply:GetPos()):GetNormalized() * 10000 )
		dmg:SetDamagePosition( pos ) 
		dmg:SetDamageType( DMG_ENERGYBEAM )

		if slice[ victim:GetClass() ] then -- gay, because it plays metal slicing sound
			victim:SetPos( victim:GetPos() + Vector(0,0,5) ) -- ragdoll spawns 5 units lower than the npc is at causing ragdoll spazz...
			dmg:SetDamageType( bit.bor( DMG_CRUSH, DMG_SLASH ) )
		end

		local wep = ply:GetActiveWeapon()

		if not IsValid( wep ) or not wep.LSCS then return end
		if not wep:GetDMGActive() then return end

		local startpos = ply:GetShootPos()
		local projectile = wep:GetProjectile()

		if IsValid( projectile ) then
			startpos = projectile:GetPos()
		else
			ply:LagCompensation( true )
		end

		local trace = util.TraceLine( {
			start = startpos,
			endpos = pos + dir,
			filter = function( ent ) 
				return ent == victim
			end
		} )

		ply:LagCompensation( false )

		if (trace.HitPos - startpos):Length() > 100 then return end -- protection against net abusers or 1000 ping players

		if not victim._lscsHitTimes then victim._lscsHitTimes = {} end

		victim._lscsHitTimes[ plyID ] = Time + 0.15

		dmg:SetDamage( LSCS.SaberDamage * wep:GetCombo().DamageMul )

		dmg:SetInflictor( wep )

		if victim:IsPlayer() then
			local victim_wep = victim:GetActiveWeapon()
			if IsValid( victim_wep ) and victim_wep.LSCS then
				local Blocked = victim_wep:Block( dmg ) -- this will modify dmginfo internally

				if Blocked ~= LSCS_UNBLOCKED then
					wep:OnBlocked( Blocked ) -- callback function

					return
				end
			end
		end

		if victim:IsPlayer() or victim:IsNPC() or victim:IsNextBot() then
			victim:EmitSound( "saber_hit" )
		else
			victim:EmitSound( "saber_lighthit" )
		end

		victim:TakeDamageInfo( dmg )

		net.Start( "lscs_saberdamage" )
			net.WriteVector( pos )
			net.WriteVector( dir )
			net.WriteBool( false )
		net.Broadcast()
	end

	net.Receive( "lscs_saberdamage", function( len, ply )
		if not IsValid( ply ) then return end

		local wep = ply:GetActiveWeapon()

		if not IsValid( wep ) or not wep.LSCS then return end

		local victim = net.ReadEntity()
		local pos = net.ReadVector()
		local dir = net.ReadVector()

		if not IsValid( victim ) or ply == victim then return end

		LSCS:ApplyDamage( ply, victim, pos, dir )
	end)

	function meta:lscsSetShouldBleed( bleed )
		if bleed then
			if self.lscsBloodColor then
				self:SetBloodColor( self.lscsBloodColor )
			end
		else
			if not self.lscsBloodColor then
				self.lscsBloodColor = self:GetBloodColor()
			end

			self:SetBloodColor( DONT_BLEED )
		end
		self:SetNWBool( "lscsShouldBleed", bleed )
	end

	function meta:lscsClearBlood()
		net.Start( "lscs_clearblood" )
			net.WriteEntity( self )
		net.Broadcast()
	end
else
	net.Receive( "lscs_hitmarker", function( length )
		local num = net.ReadInt( 4 )

		LocalPlayer():EmitSound("lscs/saber/reflect"..num..".mp3", 140, 100, 1, CHAN_ITEM2 )
	end)

	net.Receive( "lscs_saberdamage", function( len )
		local pos = net.ReadVector()
		local dir = net.ReadVector()
		
		local effectdata = EffectData()
			effectdata:SetOrigin( pos )
			effectdata:SetNormal( dir )
			
		if net.ReadBool( ) then
			util.Effect( "saber_block", effectdata, true, true )
		else
			util.Effect( "saber_hit", effectdata, true, true )
		end
	end)

	-- fix gmod bug https://github.com/Facepunch/garrysmod-issues/issues/5946
	net.Receive( "lscs_clearblood", function( len )
		local ply = net.ReadEntity()
		if not IsValid( ply ) then return end
		ply:RemoveAllDecals()
	end)
end
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/lscs_forcepowers.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/includes/circles/circles.lua:
return gluapack()()
--PATH lua/lscs/combos/advanced_form1.lua:
COMBO.id = "form1b"
COMBO.PrintName = "Advanced:Shii-Cho(I)"
COMBO.Author = "Storm"
COMBO.Description = "The Way of the Sarlac"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.BlockDistanceNormal = 75 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 20 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.MaxBlockPoints = 100 -- use this to make op boss saber stances. Avoid using this. Only uncomment if you really need it.
COMBO.BPDrainPerHit = 25

COMBO.DamageMultiplier = 1.15

COMBO.LeftSaberActive = false

COMBO.HoldType = "form1_holdtype"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "judge_h_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,250) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "judge_h_s3_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 800 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,375) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},

	["-45-"] = {
		AttackAnim = "shichoo_atk_ws_70s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .7,
	},
	["+45+"] = {
		AttackAnim = "shichoo_atk_ws_70s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .7,
	},
	["____"] = {
		AttackAnim = "shichoo_atk_ws_70s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .7,
	},
	["_A__"] = {
		AttackAnim = "shichoo_atk_pure_right_70s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .7,
	},
	["__S_"] = {
		AttackAnim = "shichoo_atk_back_70s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .7,
	},
	["___D"] = {
		AttackAnim = "shichoo_atk_pure_left_70s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .7,
	},
	["W___"] = {
		AttackAnim = "shichoo_atk_ws_70s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
	
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .7,
	},
	["WA__"] = {
		AttackAnim = "shichoo_atk_left_sweep_vid_70s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .7,
	},
	["W_S_"] = {
		AttackAnim = "shichoo_at_front_70s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .7,
	},
	["W__D"] = { 
		AttackAnim = "shichoo_atk_right_sweep_vid_70s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .7,
	},
	["_AS_"] = {
		AttackAnim = "shichoo_atk_s_newest_l",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
	["__SD"] = {
		AttackAnim = "shichoo_atk_s_newest_r",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
}

--PATH addons/[miecze] moce i hilty/lua/lscs/combos/agiledual.lua:
return gluapack()()
--PATH lua/lscs/combos/basic_form5.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/jarkai.lua:
COMBO.id = "dualwield"
COMBO.PrintName = "Jar'Kai"
COMBO.Author = "RareLogan"
COMBO.Description = "Look ma! Two hands!"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = true

COMBO.HoldType = "wos-dual-blade"

COMBO.DamageMultiplier = 1.15
COMBO.BPDrainPerHit = 50

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "r_c6_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.25, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "vanguard_r_s1_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "vanguard_r_s3_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_s3_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["+45+"] = {
		AttackAnim = "wos_bs_shared_kick",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["W_S_"] = {
		AttackAnim = "h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.7, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.6,
	},
	["__S_"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "wos_ryoku_r_left_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["___D"] = {
		AttackAnim = "vanguard_r_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["W__D"] = {
		AttackAnim = "vanguard_r_s1_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["WA__"] = {
		AttackAnim = "vanguard_r_left_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["__SD"] = {
		AttackAnim = "judge_b_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.7,
	},
	["_AS_"] = {
		AttackAnim = "wos_phalanx_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.9,
	},
	["W___"] = {
		AttackAnim = "judge_b_s3_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
}
--PATH lua/lscs/combos/master_form1.lua:
COMBO.id = "form1c"
COMBO.PrintName = "Master:Shii-Cho(I)"
COMBO.Author = "Storm"
COMBO.Description = "The Way of the Sarlac"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.BlockDistanceNormal = 85 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 20 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.MaxBlockPoints = 100 -- use this to make op boss saber stances. Avoid using this. Only uncomment if you really need it.
COMBO.BPDrainPerHit = 25

COMBO.DamageMultiplier = 1.25

COMBO.LeftSaberActive = false

COMBO.HoldType = "form1_holdtype"
COMBO.DamageMultiplier = 1.10
COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "judge_h_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,300) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "judge_h_s3_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,500) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},

	["-45-"] = {
		AttackAnim = "shichoo_atk_ws2_60s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .6,
	},
	["+45+"] = {
		AttackAnim = "shichoo_atk_ws2_60s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .6,
	},
	["____"] = {
		AttackAnim = "shichoo_atk_ws2_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .6,
	},
	["_A__"] = {
		AttackAnim = "shichoo_atk_pure_right2_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .6,
	},
	["__S_"] = {
		AttackAnim = "shichoo_atk_back2_60s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .6,
	},
	["___D"] = {
		AttackAnim = "shichoo_atk_pure_left2_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .6,
	},
	["W___"] = {
		AttackAnim = "shichoo_atk_ws2_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
	
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .6,
	},
	["WA__"] = {
		AttackAnim = "shichoo_atk_left_sweep_vid2_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .6,
	},
	["W_S_"] = {
		AttackAnim = "shichoo_at_front2_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .6,
	},
	["W__D"] = { 
		AttackAnim = "shichoo_atk_right_sweep2_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .6,
	},
	["_AS_"] = {
		AttackAnim = "shichoo_atk_s_newest_l",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
	["__SD"] = {
		AttackAnim = "shichoo_atk_s_newest_r",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
}

--PATH lua/lscs/combos/master_form5.lua:
COMBO.id = "formbc"
COMBO.PrintName = "Master:Shien Djem So(V)"
COMBO.Author = "Storm"
COMBO.Description = "The Way of the Krayt Dragon"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.BlockDistanceNormal = 65 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 20 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.MaxBlockPoints = 100 -- use this to make op boss saber stances. Avoid using this. Only uncomment if you really need it.
COMBO.BPDrainPerHit = 25

COMBO.DamageMultiplier = 1

COMBO.LeftSaberActive = false

COMBO.HoldType = "form5_holdtype"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "shien_atk_normal",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "shienv2_atk_w_50s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.50,
	},
	["-45-"] = {
		AttackAnim = "shienv2_atk_w_50s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.50,
	},
	["+45+"] = {
		AttackAnim = "shienv2_atk_w_50s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.50,
	},
	["W_S_"] = {
		AttackAnim = "shienv2_atk_w_50s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.50,
	},
	["__S_"] = {
		AttackAnim = "shienv2_atk_s_50s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.50,
	},
	["_A__"] = {
		AttackAnim = "shienv2_atk_a_50s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.50,
	},
	["___D"] = {
		AttackAnim = "shienv2_atk_d_50s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.50,
	},
	["W__D"] = {
		AttackAnim = "shienv2_atk_wd_50s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.50,
	},
	["WA__"] = {
		AttackAnim = "shienv2_atk_wa_50s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.50,
	},
	["__SD"] = {
		AttackAnim = "shienv2_atk_sd_50s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.50,
	},
	["_AS_"] = {
		AttackAnim = "shienv2_atk_sa_50s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.50,
	},
	["W___"] = {
		AttackAnim = "shienv2_atk_normal_50s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.50,
	},
}

--PATH addons/[miecze] moce i hilty/lua/lscs/combos/ninja.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/visigoth.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/blades_eri.lua:
local blade = {}
blade.PrintName = "White Pink Inner" -- nice name in the menu
blade.Author = "Tenkara"
blade.id = "ericrystall" -- internal ID. Always lower case.
blade.color_blur = Color(255,255,255)
blade.color_core = Color(128,128,128)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.4 -- width
blade.widthWiggle = 0.4 -- how much "noise" the blade has idling
blade.material_core = Material("lscs/effects/lightsaber_tenkara")
blade.material_trail = Material( "" ) -- what material to use for the trail
blade.material_core_tip = Material("")
blade.no_trail = true -- disable trail?
blade.sounds = {
	Attack = "tenkara/tenkara_attack.wav", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "tenkara/tenkara_attack2.wav", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "tenkara/tenkara_attack3.wav", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "tenkara/tenkara_attack.wav", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "tenkara/tenkara_on.wav",
	Disable = "tenkara/tenkara_off.wav",
	Idle =  "tenkara/tenkara_idle.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity


--PATH addons/[miecze] moce i hilty/lua/lscs/content/blades_lscs.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/blades_lscs_extension.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_choke_expert.lua:
local force = {}
force.PrintName = "Choke [Expert]"
force.Author = "htvgamer1000"
force.Description = "Use the force to choke your target out quickly"
force.id = "choke2"
force.OnClk =  function( ply, TIME )
    if not IsValid( ply.Choke2Target ) then return end
    if ply.Choke2Target:IsPlayer() and not ply.Choke2Target:Alive() then ply.Choke2Target = nil return end
    local vec = ( ( ply:EyePos() + ply:GetAimVector()*ply.Choke2Distance  ) - ply.Choke2Target:GetPos() )
    local vec2 = ( ( ply:EyePos() + ply:GetAimVector()*2*ply.Choke2Distance  ) - ply.Choke2Target:GetPos() )

    if ply.Choke2Target:IsPlayer() or ply.Choke2Target:IsNPC() then
        ply.Choke2Target:SetLocalVelocity( vec*10 )
        local dmg = DamageInfo()
        dmg:SetDamage( 40 ) --0.21
        dmg:SetDamageType( DMG_CRUSH )
        dmg:SetAttacker( ply )
        dmg:SetInflictor( ply )
        ply.Choke2Target:TakeDamageInfo( dmg )
    else
        local phys = ply.Choke2Target:GetPhysicsObject()
        phys:SetVelocity( vec*10 )
    end

    ply:lscsTakeForce( 1 )

    if ply:lscsGetForce() < 1 then
        local ed = EffectData()
        ed:SetOrigin( ply.Choke2Target:GetPos() + Vector( 0, 0, 36 ) )
        ed:SetRadius( 128 )
        util.Effect( "rb655_force_repulse_out", ed, true, true )
        if ply.Choke2Target:IsPlayer() then
            if timer.Exists("force_whirlwind_p1_" .. ply.Choke2Target:SteamID64()) then
                timer.Remove("force_whirlwind_p1_" .. ply.Choke2Target:SteamID64())
            end
            ply.Choke2Target:SetNW2Float( "wOS_Hates_Devs.WhirlwindCooldown", CurTime() + 5 )
        end
        ply.Choke2Target = nil
    end

    if not ply:KeyReleased( IN_ATTACK2 ) then return end

    local ed = EffectData()
    ed:SetOrigin( ply.Choke2Target:GetPos() + Vector( 0, 0, 36 ) )
    ed:SetRadius( 128 )
    util.Effect( "rb655_force_repulse_out", ed, true, true )
    if ply.Choke2Target:IsPlayer() or ply.Choke2Target:IsNPC() then
        ply.Choke2Target:SetLocalVelocity( vec2*10 )
    else
        local phys = ply.Choke2Target:GetPhysicsObject()
        phys:SetVelocity( vec2*10 )
    end
    if ply.Choke2Target:IsPlayer() then
        if timer.Exists("force_whirlwind_p1_" .. ply.Choke2Target:SteamID64()) then
            timer.Remove("force_whirlwind_p1_" .. ply.Choke2Target:SteamID64())
        end
        ply.Choke2Target:SetNW2Float( "wOS_Hates_Devs.WhirlwindCooldown", CurTime() + 5 )
    end
    ply.Choke2Target = nil
end
force.StartUse = function( ply )
    if ply:lscsGetForce() < 1 then return end
    if IsValid( ply.Choke2Target ) then return end
    local tr = util.TraceLine( util.GetPlayerTrace( ply ) )
    local dist = tr.HitPos:Distance( ply:GetPos() )
    if not tr.Entity then return end
    if tr.LFS then return end
    if string.match(tr.Entity:GetClass(), "_pod") then return end
    if dist >= 400 then return end
    ply.Choke2Target = tr.Entity
    ply.Choke2Distance = dist

    return true
end
force.StopUse = function( ply )
    if not IsValid( ply.Choke2Target ) then return end
    local ed = EffectData()
    ed:SetOrigin( ply.Choke2Target:GetPos() + Vector( 0, 0, 36 ) )
    ed:SetRadius( 128 )
    util.Effect( "rb655_force_repulse_out", ed, true, true )

    ply.Choke2Target = nil
end
LSCS:RegisterForce( force )

--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_greaterpush.lua:
local force = {}
force.PrintName = "Greater Push"
force.Author = "Solace"
force.Description = "Push things around, but more"
force.id = "greaterpush"
force.StartUse = function( ply )
	if ply:lscsGetForce() < 40 then return end

	local Time = CurTime()

	local CanPush = (ply._lscsNextForce or 0) < Time

	if not CanPush then return end

	ply._lscsNextForce = Time + 1

	ply:EmitSound("lscs/force/push.mp3")
	ply:lscsTakeForce( 40 )

	local AimVector = ply:GetAimVector()
	local MyPos = ply:GetShootPos()

	LSCS:PlayVCDSequence( ply, "gesture_item_throw", 0.5 )

	local effectdata = EffectData()
		effectdata:SetOrigin( MyPos )
		effectdata:SetNormal( AimVector )
		effectdata:SetEntity( ply )
	util.Effect( "force_push", effectdata, true, true )

	for _, Ent in pairs( ents.FindInSphere( MyPos, 1600 ) ) do
		local Sub = (Ent.GetShootPos and Ent:GetShootPos() or Ent:GetPos()) - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 30 then
			local Dist = Sub:Length()

			if IsValid( Ent ) and Dist < 1600 then
				local Vel = Sub:GetNormalized() * 2500 + Vector(0,0,50)

				LSCS:ForceApply( Ent, Vel, ply )	
				if Ent:IsNPC() then
					Ent:TakeDamage( 500, ply, ply)
				end
			end
		end
	end
end
LSCS:RegisterForce( force )
--PATH lua/lscs/content/force_push.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_revive.lua:
local force = {}
force.PrintName = "Revive"
force.Author = "Wiz"
force.Description = "A powerful ability to revive a fallen ally by targeting their corpse."
force.id = "revive" -- lowercase only

force.StartUse = function(ply)
    if ply:lscsGetForce() < 100 then -- Require at least 100 force points
        ply:ChatPrint("Not enough force points to use Revive!")
        return
    end

    local trace = ply:GetEyeTrace() -- Get where the player is looking
    local targetEntity = trace.Entity -- The entity being aimed at

    if not IsValid(targetEntity) or not targetEntity:GetClass():find("ragdoll") then
        ply:ChatPrint("You must aim at a valid corpse to revive!")
        return
    end

    -- Debug: Check the ragdoll and its owner
    print("Target Entity: ", targetEntity)

    -- Check if the target is an NPC (bot created by the bot command)
    if targetEntity:IsNPC() then
        local npcClass = targetEntity:GetClass()
        if npcClass == "npc_combine_s" or npcClass == "npc_metropolice" then
            -- This is a bot created using the bot command (or other bot-like NPCs)
            if targetEntity:Health() <= 0 then
                ply:lscsTakeForce(100) -- Deduct 100 force points for reviving

                -- Revive the bot NPC (just set health to max and restore it)
                targetEntity:SetHealth(targetEntity:GetMaxHealth()) -- Set health to maximum
                targetEntity:SetPos(targetEntity:GetPos() + Vector(0, 0, 10)) -- Position the bot slightly above the ragdoll location

                -- Remove the ragdoll (bots don't have ragdolls in the same way, so this step may not be needed)
                targetEntity:Remove()

                -- Sound and effects
                ply:EmitSound("ambient/levels/labs/electric_explosion1.wav")
                local effectData = EffectData()
                effectData:SetOrigin(targetEntity:GetPos())
                util.Effect("cball_explode", effectData)

                ply:ChatPrint("Revived bot " .. targetEntity:GetClass() .. "!")
            else
                ply:ChatPrint("The targeted bot is not dead and cannot be revived.")
            end
            return
        end
    end

    -- For player-owned ragdolls (if they were previously a player)
    local targetPlayer = targetEntity:GetOwner()
    if IsValid(targetPlayer) and targetPlayer:IsPlayer() then
        -- Ensure the player is dead before reviving
        if targetPlayer:Health() <= 0 then
            ply:lscsTakeForce(20) -- Deduct 20 force points for reviving

            -- Revive the player
            targetPlayer:Spawn()
            targetPlayer:SetHealth(100) -- Set the revived player's health
            targetPlayer:SetPos(targetEntity:GetPos() + Vector(0, 0, 10)) -- Position the revived player at ragdoll's location

            -- Remove the ragdoll
            targetEntity:Remove()

            -- Sound and effects
            ply:EmitSound("ambient/levels/labs/electric_explosion1.wav")
            local effectData = EffectData()
            effectData:SetOrigin(targetPlayer:GetPos())
            util.Effect("cball_explode", effectData)

            ply:ChatPrint("Revived " .. targetPlayer:Nick() .. "!")
            targetPlayer:ChatPrint("You have been revived by " .. ply:Nick() .. "!")
        else
            ply:ChatPrint("The targeted corpse cannot be revived because the player is not dead.")
        end
    end
end

force.StopUse = function(ply)
    ply:ChatPrint("Revive power deactivated.")
end

LSCS:RegisterForce(force)
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_rock_throw.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_sense.lua:
local force = {}
force.PrintName = "Sense"
force.Author = "Blu-x92 / Luna"
force.Description = "Augmented Vision. See through the lies of the Jedi and through walls"
force.id = "sense1"
force.OnClk =  function( ply, TIME )
	if not ply:GetNWBool( "_lscsForceSense", false ) then return end

	if not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
		ply:SetNWBool( "_lscsForceSense", false )
		return
	end

	ply:lscsTakeForce()

	if (ply._lscsSenseTime or 0) < TIME then
		ply:SetNWBool( "_lscsForceSense", false )
	end
end
force.UnEquip = function( ply ) ply:SetNWBool( "_lscsForceSense", false ) end
force.StartUse = function( ply )
	local Time = CurTime()

	local CanDo = (ply._lscsNextForce or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 1

	if ply:GetNWBool( "_lscsForceSense", false ) then
		ply:SetNWBool( "_lscsForceSense", false )
	else
		if ply:lscsGetForce() >= 75 then
			ply:SetNWBool( "_lscsForceSense", true )
			ply._lscsSenseTime = CurTime() + 5

			ply:lscsTakeForce( 75 )
			ply:EmitSound("lscs/force/sense.mp3")
		end
	end

end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Sense [Advanced]"
force.Author = "Blu-x92 / Luna"
force.Description = "Augmented Vision. See through the lies of the Jedi and through walls"
force.id = "sense2"
force.OnClk =  function( ply, TIME )
	if not ply:GetNWBool( "_lscsForceSense", false ) then return end

	if not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
		ply:SetNWBool( "_lscsForceSense", false )
		return
	end

	ply:lscsTakeForce()

	if (ply._lscsSenseTime or 0) < TIME then
		ply:SetNWBool( "_lscsForceSense", false )
	end
end
force.UnEquip = function( ply ) ply:SetNWBool( "_lscsForceSense", false ) end
force.StartUse = function( ply )
	local Time = CurTime()

	local CanDo = (ply._lscsNextForce or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 1

	if ply:GetNWBool( "_lscsForceSense", false ) then
		ply:SetNWBool( "_lscsForceSense", false )
	else
		if ply:lscsGetForce() >= 50 then
			ply:SetNWBool( "_lscsForceSense", true )
			ply._lscsSenseTime = CurTime() + 10

			ply:lscsTakeForce( 50 )
			ply:EmitSound("lscs/force/sense.mp3")
		end
	end

end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Sense [Mastered]"
force.Author = "Blu-x92 / Luna"
force.Description = "Augmented Vision. See through the lies of the Jedi and through walls"
force.id = "sense3"
force.OnClk =  function( ply, TIME )
	if not ply:GetNWBool( "_lscsForceSense", false ) then return end

	if not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
		ply:SetNWBool( "_lscsForceSense", false )
		return
	end

	ply:lscsTakeForce()

	if (ply._lscsSenseTime or 0) < TIME then
		ply:SetNWBool( "_lscsForceSense", false )
	end
end
force.UnEquip = function( ply ) ply:SetNWBool( "_lscsForceSense", false ) end
force.StartUse = function( ply )
	local Time = CurTime()

	local CanDo = (ply._lscsNextForce or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 1

	if ply:GetNWBool( "_lscsForceSense", false ) then
		ply:SetNWBool( "_lscsForceSense", false )
	else
		if ply:lscsGetForce() >= 25 then
			ply:SetNWBool( "_lscsForceSense", true )
			ply._lscsSenseTime = CurTime() + 15

			ply:lscsTakeForce( 25 )
			ply:EmitSound("lscs/force/sense.mp3")
		end
	end

end
LSCS:RegisterForce( force )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilt_anzatis.lua:
toCreate = { -- dont remove
	["Scourgekeeper Staff"] = {
		mdl = "models/anzati/lightsabers/dragon_staff.mdl",
		pData = {
			["RHpos"] = Vector(3.75, -1.5, 0),
			["RHang"] = Angle(-90, -90, -90),
			["LHpos"] = Vector(3.75, -1, 0),
			["LHang"] = Angle(90, 90, 90),
		},
	}, -- That is default example for needing to edit pos / ang, most dont need it. 
	["Thingy Ma-jig"] = {
		mdl = "models/anzati/lightsabers/e.mdl",
	},
	["Malgus"] = {
		mdl = "models/anzati/lightsabers/new_malgus_simple.mdl",
	},
	["Rubix Cube"] = {
		mdl = "models/anzati/lightsabers/rubix_cube.mdl",
	},
	["Slayer"] = {
		mdl = "models/anzati/lightsabers/slayer_simple.mdl",
	},
	["Tulak"] = {
		mdl = "models/anzati/lightsabers/tulak_simple.mdl",
	},
} -- dont remove


local Author = "Midnight" -- Feel free to change i dont care
local Usum = "1"
for k,v in pairs(toCreate) do
	local hilt = {}
	hilt.PrintName = k or Usum -- avoid conflict if someone fucks it up
	hilt.Author = Author
	hilt.id = k or Usum -- as said above
	hilt.mdl = v.mdl or "models/lscs/weapons/katarn.mdl" -- as said above
	hilt.info = {
		ParentData = {
			["RH"] = {
				bone = "ValveBiped.Bip01_R_Hand",
				pos = Vector(3.75, -1.5, -6.5), -- RightHandpos if needs editing.
				ang = Angle(-90, -90, -90), -- RightHandang if needs editing
			},
			["LH"] = {
				bone = "ValveBiped.Bip01_L_Hand",
				pos = Vector(3.75, -1, 6.5), -- same for left
				ang = Angle(90, 90, 90),
			},
		},
		GetBladePos = function( ent ) 

			local blades = {}
		
			for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
				if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
				end
				if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
				end
			end
		
			return blades
		end,
	}
	print("registered " .. k)
	
	if v.pData then
		hilt.info.ParentData["RH"].pos = v.pData["RHpos"]
		hilt.info.ParentData["RH"].ang = v.pData["RHang"]
		
		hilt.info.ParentData["LH"].pos = v.pData["LHpos"]
		hilt.info.ParentData["LH"].ang = v.pData["LHang"]
	end
	LSCS:RegisterHilt( hilt ) -- register the hilt
	Usum = Usum .. "1"
	
	
	
end
print("Extra Sabers Loaded - You're welcome. And this took like an hour total effort.")
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_ink.lua:
local hilt = {}
hilt.PrintName = "Aayla Secura"
hilt.Author = "Ink"
hilt.id = "aayla"
hilt.mdl = "models/aayla_secura/aayla_secura_hilt.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3.5, -1.3, 7),
			ang = Angle(90, -7, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, 0, 0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Aayla Secura{Reverse}"
hilt.Author = "Ink"
hilt.id = "aaylareverse"
hilt.mdl = "models/aayla_secura/aayla_secura_hilt.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, 7),
			ang = Angle(90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3.5, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, 0, 0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Adi Gallia"
hilt.Author = "Ink"
hilt.id = "gallia"
hilt.mdl = "models/plo/cwa/sabers/adi_gallia.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 7),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -0, 0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Adi Gallia{Reverse}"
hilt.Author = "Ink"
hilt.id = "galliareverse"
hilt.mdl = "models/plo/cwa/sabers/adi_gallia.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, 7),
			ang = Angle(90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, -7),
			ang = Angle(-90, 0, 10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, 0, 0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Ahsoka's Second Hilt"
hilt.Author = "Ink"
hilt.id = "ahsoka"
hilt.mdl = "models/plo/cwa/sabers/ahsoka_saber.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3.5, -1.3, 7),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2.5, -0.5, 0) ),
                dir = ent:LocalToWorldAngles( Angle(-90, 0, 0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Ahsoka's Second Hilt{Reverse}'"
hilt.Author = "Ink"
hilt.id = "ahsokareverse"
hilt.mdl = "models/plo/cwa/sabers/reverseahsoka.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, 7),
			ang = Angle(90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(1.8, 0, -0.37) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Barriss Offee"
hilt.Author = "Ink"
hilt.id = "barriss"
hilt.mdl = "models/plo/cwa/sabers/barriss_saber.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -1.3, 7),
			ang = Angle(90, 7, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.5, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -10, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Barriss Offee{Reverse}"
hilt.Author = "Ink"
hilt.id = "barrissreverse"
hilt.mdl = "models/plo/cwa/sabers/barriss_saber.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, 7),
			ang = Angle(90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.5, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -10, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Dooku"
hilt.Author = "Ink"
hilt.id = "dooku"
hilt.mdl = "models/plo/cwa/sabers/count_dooku.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(4.25, -1.5, 1),
			ang = Angle(8, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Eeth"
hilt.Author = "Ink"
hilt.id = "eeth"
hilt.mdl = "models/plo/cwa/sabers/eeth_koth.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -1.3, 7),
			ang = Angle(90, -7, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Ganodi"
hilt.Author = "Ink"
hilt.id = "ganodi"
hilt.mdl = "models/plo/cwa/sabers/ganodi.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 7),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Gungi"
hilt.Author = "Ink"
hilt.id = "gungi"
hilt.mdl = "models/plo/cwa/sabers/gungi.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -8),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Jocasta"
hilt.Author = "Ink"
hilt.id = "jocasta"
hilt.mdl = "models/plo/cwa/sabers/jocastanu.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Kenobi"
hilt.Author = "Ink"
hilt.id = "kenobi"
hilt.mdl = "models/plo/cwa/sabers/obi_wan_kenobi.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Kitfisto"
hilt.Author = "Ink"
hilt.id = "kitfisto"
hilt.mdl = "models/plo/cwa/sabers/kitfisto.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Kyle Katarn"
hilt.Author = "Ink"
hilt.id = "kylekatarn"
hilt.mdl = "models/plo/cwa/sabers/kyle_katarn.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Low Quality Luke Skywalker"
hilt.Author = "Ink"
hilt.id = "luke2"
hilt.mdl = "models/plo/cwa/sabers/luke_skywalker.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Luminara"
hilt.Author = "Ink"
hilt.id = "luminara"
hilt.mdl = "models/plo/cwa/sabers/luminara.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Maul Double Hilt"
hilt.Author = "Ink"
hilt.id = "mauldouble"
hilt.mdl = "models/plo/cwa/sabers/maul_double_blade.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
	GetBladePos = function( ent )
			local blades = {
			[1] = {
                pos = ent:LocalToWorld( Vector(-5, -0.4, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
            [2] = {
                pos = ent:LocalToWorld( Vector(17, -0.4, 0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },	
		}
			return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Maul"
hilt.Author = "Ink"
hilt.id = "maul"
hilt.mdl = "models/plo/cwa/sabers/darthmaul.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Mundi"
hilt.Author = "Ink"
hilt.id = "mundi"
hilt.mdl = "models/plo/cwa/sabers/ki_adi_mundi.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Plo"
hilt.Author = "Ink"
hilt.id = "plo"
hilt.mdl = "models/plo/cwa/sabers/plo_k.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Quinlan Vos"
hilt.Author = "Ink"
hilt.id = "quinlan"
hilt.mdl = "models/plo/cwa/sabers/quinlan_vos.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Saesee Tiin"
hilt.Author = "Ink"
hilt.id = "saeseetiin"
hilt.mdl = "models/plo/cwa/sabers/saeseetiin.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Savage Hilt"
hilt.Author = "Ink"
hilt.id = "savage"
hilt.mdl = "models/plo/cwa/sabers/savage_hilt.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -6),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 6),
			ang = Angle(90, 0, -10),
		},
	},
	GetBladePos = function( ent )
			local blades = {
			[1] = {
                pos = ent:LocalToWorld( Vector(-5, -0.4, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
            [2] = {
                pos = ent:LocalToWorld( Vector(17, -0.4, 0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },	
		}
			return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Shaak Ti"
hilt.Author = "Ink"
hilt.id = "shaakti"
hilt.mdl = "models/plo/cwa/sabers/shaakti.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Ventress"
hilt.Author = "Ink"
hilt.id = "ventress"
hilt.mdl = "models/plo/cwa/sabers/ventress.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -2, -7),
			ang = Angle(-90, 170, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Windu"
hilt.Author = "Ink"
hilt.id = "windu"
hilt.mdl = "models/plo/cwa/sabers/mace_windu.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Yoda"
hilt.Author = "Ink"
hilt.id = "yoda1"
hilt.mdl = "models/plo/cwa/sabers/grand_master_yoda.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1, -6),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -1, 6),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Exile"
hilt.Author = "Ink"
hilt.id = "exile"
hilt.mdl = "models/plo/cwa/sabers/exile.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -9),
			ang = Angle(-90, 0, 110),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3.2, -1, 9),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Felucia 1"
hilt.Author = "Ink"
hilt.id = "felucia1"
hilt.mdl = "models/plo/cwa/sabers/felucia1.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -2, 7),
			ang = Angle(90, -180, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Felucia 2"
hilt.Author = "Ink"
hilt.id = "felucia2"
hilt.mdl = "models/plo/cwa/sabers/felucia2.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -2, 7),
			ang = Angle(90, -180, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Forked"
hilt.Author = "Ink"
hilt.id = "forked"
hilt.mdl = "models/plo/cwa/sabers/forked.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3.5, -1, 7),
			ang = Angle(90, -7, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Gungan"
hilt.Author = "Ink"
hilt.id = "gungan"
hilt.mdl = "models/plo/cwa/sabers/gungan.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -9),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 9),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Kashyyyk"
hilt.Author = "Ink"
hilt.id = "kashyyyk"
hilt.mdl = "models/plo/cwa/sabers/kashyyyk.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 150, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Katana"
hilt.Author = "Ink"
hilt.id = "katana"
hilt.mdl = "models/plo/cwa/sabers/katana_saber.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Katooni"
hilt.Author = "Ink"
hilt.id = "katooni"
hilt.mdl = "models/plo/cwa/sabers/katooni.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Lightside Affiliation"
hilt.Author = "Ink"
hilt.id = "lightside"
hilt.mdl = "models/plo/cwa/sabers/lightsideaffiliation.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -1.3, 8),
			ang = Angle(90, -170, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Nelona Hilt"
hilt.Author = "Ink"
hilt.id = "nelona"
hilt.mdl = "models/plo/cwa/sabers/nelona.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
	GetBladePos = function( ent )
			local blades = {
			[1] = {
                pos = ent:LocalToWorld( Vector(-5, -0.4, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
            [2] = {
                pos = ent:LocalToWorld( Vector(17, -0.4, 0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },	
		}
			return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Petro"
hilt.Author = "Ink"
hilt.id = "pretro"
hilt.mdl = "models/plo/cwa/sabers/petro.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Pulsating Blue"
hilt.Author = "Ink"
hilt.id = "pulsatingblue"
hilt.mdl = "models/plo/cwa/sabers/pulsatingblue.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Pulsating"
hilt.Author = "Ink"
hilt.id = "pulsating"
hilt.mdl = "models/plo/cwa/sabers/pulsating.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Samurai"
hilt.Author = "Ink"
hilt.id = "samurai"
hilt.mdl = "models/plo/cwa/sabers/samurai.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 170, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Sparkling"
hilt.Author = "Ink"
hilt.id = "sparkling"
hilt.mdl = "models/plo/cwa/sabers/sparklingcrystal.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Spiralling"
hilt.Author = "Ink"
hilt.id = "spiralling"
hilt.mdl = "models/plo/cwa/sabers/spiralling.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Survivor"
hilt.Author = "Ink"
hilt.id = "survivor"
hilt.mdl = "models/plo/cwa/sabers/survivor_saber.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Talz"
hilt.Author = "Ink"
hilt.id = "talz"
hilt.mdl = "models/plo/cwa/sabers/talz.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Training"
hilt.Author = "Ink"
hilt.id = "training"
hilt.mdl = "models/plo/cwa/sabers/training.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Unstable"
hilt.Author = "Ink"
hilt.id = "unstable"
hilt.mdl = "models/plo/cwa/sabers/unstable.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Zatt"
hilt.Author = "Ink"
hilt.id = "zatt"
hilt.mdl = "models/plo/cwa/sabers/zatt.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Zebra"
hilt.Author = "Ink"
hilt.id = "zebra"
hilt.mdl = "models/plo/cwa/sabers/zebra.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 8),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Dark Force Phase 1"
hilt.Author = "Ink"
hilt.id = "darkforce1"
hilt.mdl = "models/plo/cwa/sabers/darkforcephase1.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3.5, -1.3, 7),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Dark Forces"
hilt.Author = "Ink"
hilt.id = "darkforces"
hilt.mdl = "models/plo/cwa/sabers/dark_forces_double.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3.5, -1.3, 7),
			ang = Angle(90, 0, -10),
		},
	},
	GetBladePos = function( ent )
			local blades = {
			[1] = {
                pos = ent:LocalToWorld( Vector(-5, -0.4, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
            [2] = {
                pos = ent:LocalToWorld( Vector(17, -0.4, 0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },	
		}
			return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Dark Force Phase 2"
hilt.Author = "Ink"
hilt.id = "darkforce2"
hilt.mdl = "models/plo/cwa/sabers/darkforcephase2.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3.5, -1.3, 7),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Dark Knight Phase 1"
hilt.Author = "Ink"
hilt.id = "darkknight1"
hilt.mdl = "models/plo/cwa/sabers/darkknight1.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3.5, -1.3, 7),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Dark Knight Phase 2"
hilt.Author = "Ink"
hilt.id = "darkknight2"
hilt.mdl = "models/plo/cwa/sabers/darkknight2.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3.5, -1.3, 7),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Darksaber Ancient"
hilt.Author = "Ink"
hilt.id = "darksaberancient"
hilt.mdl = "models/plo/cwa/sabers/darksaber_ancient.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -9),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3.5, -1.3, 9),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Darksaber Golden"
hilt.Author = "Ink"
hilt.id = "darksabergolden"
hilt.mdl = "models/plo/cwa/sabers/darksaber_golden.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -9),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3.5, -1.3, 9),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Darksaber"
hilt.Author = "Ink"
hilt.id = "darksaber"
hilt.mdl = "models/plo/cwa/sabers/darksaber.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -9),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3.5, -1.3, 9),
			ang = Angle(90, 0, -10),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2, -0.7, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Sith Afiiliate Hilt"
hilt.Author = "Ink"
hilt.id = "sithaffliate"
hilt.mdl = "models/plo/cwa/sabers/sith_affiliate.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -6),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -0.5, 6),
			ang = Angle(90, 0, -10),
		},
	},
	GetBladePos = function( ent )
			local blades = {
			[1] = {
                pos = ent:LocalToWorld( Vector(-5, -0.4, -0.2) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
            [2] = {
                pos = ent:LocalToWorld( Vector(17, -0.4, 0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },	
		}
			return blades
	end,
}
LSCS:RegisterHilt( hilt )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/midnights_special_blades.lua:
local blade = {}
blade.PrintName = "Rainbow" 
blade.Author = "Midnight"
blade.id = "rainbow" 
blade.color_blur = Color(80, 80, 80)
blade.color_core = Color(255, 255, 255)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_rainbowtip" )
blade.material_core = Material( "lscs/effects/lightsaber_rainbowcore" )
blade.material_glow = Material( "lscs/effects/lightsaber_rainbowglow" )
blade.material_trail = Material( "lscs/effects/lightsaber_rainbowtrail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Aventurine"
blade.Author = "Midnight"
blade.id = "aventurine"
blade.color_blur = Color(134,210,178)
blade.color_core = Color(116,190,151)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/solid/lightsaber_tip" )
blade.material_core = Material( "lscs/effects/solid/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/solid/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Alexandrite" 
blade.Author = "Midnight"
blade.id = "alexandrite"
blade.color_blur = Color(100, 100, 100)
blade.color_core = Color(255, 255, 255)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_alexandritetip" )
blade.material_core = Material( "lscs/effects/lightsaber_alexandritecore" )
blade.material_glow = Material( "lscs/effects/lightsaber_alexandriteglow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Aquamarine" 
blade.Author = "Midnight"
blade.id = "aquamarine" 
blade.color_blur = Color(58, 106, 101)
blade.color_core = Color(255, 255, 255)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_aquamarinetip" )
blade.material_core = Material( "lscs/effects/lightsaber_aquamarinecore" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Bluebird Azurite"
blade.Author = "Midnight"
blade.id = "bluebirdazurite"
blade.color_blur = Color(100,100,100)
blade.color_core = Color(255,255,255)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_bluebirdtip" )
blade.material_core = Material( "lscs/effects/lightsaber_bluebirdcore" )
blade.material_glow = Material( "lscs/effects/lightsaber_bluebirdglow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Blue Lotus"
blade.Author = "Midnight"
blade.id = "bluelotus"
blade.color_blur = Color(85,95,251)
blade.color_core = Color(118,135,253)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" )
blade.material_core = Material( "lscs/effects/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Carnelian" 
blade.Author = "Midnight"
blade.id = "carnelian"
blade.color_blur = Color(197, 51, 37)
blade.color_core = Color(255, 255, 255)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_carneliantip" )
blade.material_core = Material( "lscs/effects/lightsaber_carneliancore" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Carnelian Agate"
blade.Author = "Midnight"
blade.id = "carnagate"
blade.color_blur = Color(219,174,159)
blade.color_core = Color(222,62,5)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/solid/lightsaber_tip" )
blade.material_core = Material( "lscs/effects/solid/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/solid/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Chrysocolla"
blade.Author = "Midnight"
blade.id = "chrysocolla"
blade.color_blur = Color(23,62,47)
blade.color_core = Color(255,255,255)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_chrysocollatip" )
blade.material_core = Material( "lscs/effects/lightsaber_chrysocollacore" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Cinnabar"
blade.Author = "Midnight"
blade.id = "cinnabar"
blade.color_blur = Color(179,21,12)
blade.color_core = Color(95,18,26)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/solid/lightsaber_tip" )
blade.material_core = Material( "lscs/effects/solid/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/solid/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "lightsaber/saber_on3.wav",
	Disable = "lightsaber/saber_off3.wav",
	Idle =  "lightsaber/saber_loop3.wav",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Cobalt"
blade.Author = "Midnight"
blade.id = "mcobalt"
blade.color_blur = Color(230,244,255)
blade.color_core = Color(0,25,153)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/solid/lightsaber_tip" )
blade.material_core = Material( "lscs/effects/solid/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/solid/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Dumortierite"
blade.Author = "Midnight"
blade.id = "dumortierite"
blade.color_blur = Color(68,122,197)
blade.color_core = Color(20,27,42)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/solid/lightsaber_tip" )
blade.material_core = Material( "lscs/effects/solid/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/solid/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Emerald"
blade.Author = "Midnight"
blade.id = "emerald"
blade.color_blur = Color(0,47,20)
blade.color_core = Color(255,255,255)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_emeraldtip" )
blade.material_core = Material( "lscs/effects/lightsaber_emeraldcore" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Fluorite"
blade.Author = "Midnight"
blade.id = "fluorite"
blade.color_blur = Color(193,150,114)
blade.color_core = Color(255,255,255)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/solid/lightsaber_fluoritetip" )
blade.material_core = Material( "lscs/effects/solid/lightsaber_fluoritecore" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/solid/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Green Apple Quartz"
blade.Author = "Midnight"
blade.id = "greenapplequartz"
blade.color_blur = Color(100,54,96)
blade.color_core = Color(255,255,255)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_greenapplequartztip" )
blade.material_core = Material( "lscs/effects/lightsaber_greenapplequartzcore" )
blade.material_glow = Material( "lscs/effects/lightsaber_greenapplequartzglow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Hessonite"
blade.Author = "Midnight"
blade.id = "hessonite"
blade.color_blur = Color(168,19,0)
blade.color_core = Color(255,255,255)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_hessonitetip" )
blade.material_core = Material( "lscs/effects/lightsaber_hessonitecore" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Jasper"
blade.Author = "Midnight"
blade.id = "jasper"
blade.color_blur = Color(145,40,0)
blade.color_core = Color(255,255,255)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_jaspertip" )
blade.material_core = Material( "lscs/effects/lightsaber_jaspercore" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Lapis Lazuli"
blade.Author = "Midnight"
blade.id = "lapis"
blade.color_blur = Color(50,54,190)
blade.color_core = Color(255,255,255)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_lapistip" )
blade.material_core = Material( "lscs/effects/lightsaber_lapiscore" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Larimar"
blade.Author = "Midnight"
blade.id = "larimar"
blade.color_blur = Color(11,123,147)
blade.color_core = Color(255,255,255)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_larimartip" )
blade.material_core = Material( "lscs/effects/lightsaber_larimarcore" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Moonstone"
blade.Author = "Midnight"
blade.id = "moonstone"
blade.color_blur = Color(197,217,247)
blade.color_core = Color(224,253,253)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/solid/lightsaber_tip" )
blade.material_core = Material( "lscs/effects/solid/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/solid/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Sunstone"
blade.Author = "Midnight"
blade.id = "sunstone"
blade.color_blur = Color(236,123,58)
blade.color_core = Color(237,250,248)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/solid/lightsaber_tip" ) -- lscs/effects/solid/lightsaber_sunstonetip - Leaving this here because I'll need it later
blade.material_core = Material( "lscs/effects/solid/lightsaber_core" ) -- lscs/effects/solid/lightsaber_sunstonecore
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/solid/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Nephrite"
blade.Author = "Midnight"
blade.id = "nephrite"
blade.color_blur = Color(69,98,61)
blade.color_core = Color(150,150,150)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_nephritetip" )
blade.material_core = Material( "lscs/effects/lightsaber_nephritecore" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Royal Purple"
blade.Author = "Midnight"
blade.id = "royalpurple"
blade.color_blur = Color(151,0,255)
blade.color_core = Color(255,255,255)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tippurple" )
blade.material_core = Material( "lscs/effects/lightsaber_corepurple" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Sunset Sodalite"
blade.Author = "Midnight"
blade.id = "sunsetsodalite"
blade.color_blur = Color(0,20,223)
blade.color_core = Color(237,104,30)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/solid/lightsaber_tip" )
blade.material_core = Material( "lscs/effects/solid/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/solid/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Tiger's Eye"
blade.Author = "Midnight"
blade.id = "tigerseye"
blade.color_blur = Color(80,48,0)
blade.color_core = Color(255,255,255)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tigerseyetip" )
blade.material_core = Material( "lscs/effects/lightsaber_tigerseyecore" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Variscite"
blade.Author = "Midnight"
blade.id = "variscite"
blade.color_blur = Color(150,150,150)
blade.color_core = Color(131,208,152)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/solid/lightsaber_tip" )
blade.material_core = Material( "lscs/effects/solid/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/solid/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Pink Yellow Tourmaline"
blade.Author = "Midnight"
blade.id = "pytourmaline"
blade.color_blur = Color(255,103,174)
blade.color_core = Color(226,218,26)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/solid/lightsaber_tip" )
blade.material_core = Material( "lscs/effects/solid/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/solid/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Pink Blue Fluorite"
blade.Author = "Midnight"
blade.id = "pbfluorite"
blade.color_blur = Color(255,80,172)
blade.color_core = Color(78,130,253)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/solid/lightsaber_tip" )
blade.material_core = Material( "lscs/effects/solid/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/solid/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Watermelon Tourmaline"
blade.Author = "Midnight"
blade.id = "watermelontourmaline"
blade.color_blur = Color(37,160,30)
blade.color_core = Color(255,103,174)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/solid/lightsaber_tip" )
blade.material_core = Material( "lscs/effects/solid/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/solid/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Orange Spodumene"
blade.Author = "Midnight"
blade.id = "orangespodumene"
blade.color_blur = Color(32,72,72)
blade.color_core = Color(0,255,255)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tiporange" )
blade.material_core = Material( "lscs/effects/lightsaber_coreorange" )
blade.material_glow = Material( "lscs/effects/lightsaber_glowblack" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Yellow Sodalite"
blade.Author = "Midnight"
blade.id = "ysodalite"
blade.color_blur = Color(210,186,28)
blade.color_core = Color(41,58,140)
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/solid/lightsaber_tip" )
blade.material_core = Material( "lscs/effects/solid/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/solid/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/private_blades.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/tenkara.hilt.lua:
local hilt = {}
hilt.PrintName = "Vethar Trident"
hilt.Author = "Dreamplay"
hilt.id = "eri"
hilt.mdl = "models/dreamplay/vethar_trident_hilt/custom_vethar_trident_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3, -2, 0),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3, -1, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-30,-1,1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
	   [2] = {
                pos = ent:LocalToWorld( Vector(-30,-1,3.95) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
       [3] = {
                pos = ent:LocalToWorld( Vector(-30,-1,-3) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )
--PATH lua/lvs_framework/autorun/lvs_net.lua:
return gluapack()()
--PATH lua/lvs_framework/autorun/lvs_net.lua:

if SERVER then
	util.AddNetworkString( "lvs_player_request_filter" )
	util.AddNetworkString( "lvs_player_enterexit" )
	util.AddNetworkString( "lvs_toggle_mouseaim" )

	net.Receive( "lvs_toggle_mouseaim", function( length, ply )
		ply:lvsBuildControls()

		local veh = ply:lvsGetVehicle()

		if not IsValid( veh ) then return end

		veh:AlignView( ply )
	end)

	net.Receive( "lvs_player_request_filter", function( length, ply )
		if not IsValid( ply ) then return end

		local ent = net.ReadEntity()

		if not IsValid( ent ) or not ent.GetCrosshairFilterEnts then return end -- TODO: Make this loop around and wait for ent.IsInitialized to exist and ent:IsInitialized() to return true

		local CrosshairFilterEnts = table.Copy( ent:GetCrosshairFilterEnts() )

		for id, entity in pairs( CrosshairFilterEnts ) do
			if not IsValid( entity ) or entity:GetNoDraw() then
				CrosshairFilterEnts[ id ] = nil
			end
		end

		net.Start( "lvs_player_request_filter" )
			net.WriteEntity( ent )
			net.WriteTable( CrosshairFilterEnts )
		net.Send( ply )
	end)
else
	net.Receive( "lvs_player_request_filter", function( length )
		local LVSent = net.ReadEntity()

		if not IsValid( LVSent ) then return end

		local Filter = {}

		for _, entity in pairs( net.ReadTable() ) do
			if not IsValid( entity ) then continue end
			table.insert( Filter, entity )
		end

		LVSent.CrosshairFilterEnts = Filter
	end )

	net.Receive( "lvs_player_enterexit", function( len )
		local Enable = net.ReadBool()
		local Vehicle = net.ReadEntity()

		if Enable then
			hook.Run( "LVS.PlayerEnteredVehicle", LocalPlayer(), Vehicle )
		else
			hook.Run( "LVS.PlayerLeaveVehicle", LocalPlayer(), Vehicle )
		end
	end )
end
--PATH lua/lvs_framework/autorun/sh_starwars_keybinding.lua:
return gluapack()()
--PATH lua/mediaplayer/sh_events.lua:
return gluapack()()
--PATH lua/mediaplayer/players/base/sh_snapshot.lua:
return gluapack()()
--PATH lua/mediaplayer/players/base/cl_draw.lua:
local pcall = pcall
local Color = Color
local RealTime = RealTime
local ValidPanel = ValidPanel
local Vector = Vector
local cam = cam
local draw = draw
local math = math
local string = string
local surface = surface

local DrawHTMLPanel = MediaPlayerUtils.DrawHTMLPanel
local FormatSeconds = MediaPlayerUtils.FormatSeconds

local TEXT_ALIGN_CENTER	= draw.TEXT_ALIGN_CENTER
local TEXT_ALIGN_TOP	= draw.TEXT_ALIGN_TOP
local TEXT_ALIGN_BOTTOM	= draw.TEXT_ALIGN_BOTTOM
local TEXT_ALIGN_LEFT	= draw.TEXT_ALIGN_LEFT
local TEXT_ALIGN_RIGHT	= draw.TEXT_ALIGN_RIGHT

local TextPaddingX = 12
local TextPaddingY = 12

local TextBoxPaddingX = 8
local TextBoxPaddingY = 2

local TextBgColor = Color(0, 0, 0, 200)
local BarBgColor = Color(0, 0, 0, 200)
local BarFgColor = Color(255, 255, 255, 255)

local function DrawText( text, font, x, y, xalign, yalign )
	return draw.SimpleText( text, font, x, y, color_white, xalign, yalign )
end

local function DrawTextBox( text, font, x, y, xalign, yalign )

	xalign = xalign or TEXT_ALIGN_LEFT
	yalign = yalign or TEXT_ALIGN_TOP

	surface.SetFont( font )
	tw, th = surface.GetTextSize( text )

	if xalign == TEXT_ALIGN_CENTER then
		x = x - tw/2
	elseif xalign == TEXT_ALIGN_RIGHT then
		x = x - tw
	end

	if yalign == TEXT_ALIGN_CENTER then
		y = y - th/2
	elseif yalign == TEXT_ALIGN_BOTTOM then
		y = y - th
	end

	surface.SetDrawColor( TextBgColor )
	surface.DrawRect( x, y,
		tw + TextBoxPaddingX * 2,
		th + TextBoxPaddingY * 2 )

end

local UTF8SubLastCharPattern = "[^\128-\191][\128-\191]*$"
local OverflowString = "..." -- ellipsis

---
-- Limits a rendered string's width based on a maximum width.
--
-- @param text		Text string.
-- @param font		Font.
-- @param w			Maximum width.
-- @return String	String fitting the maximum required width.
--
local function RestrictStringWidth( text, font, w )

	-- TODO: Cache this

	surface.SetFont( font )
	local curwidth = surface.GetTextSize( text )
	local overflow = false

	-- Reduce text by one character until it fits
	while curwidth > w do

		-- Text has overflowed, append overflow string on return
		if not overflow then
			overflow = true
		end

		-- Cut off last character
		text = string.gsub(text, UTF8SubLastCharPattern, "")

		-- Check size again
		curwidth = surface.GetTextSize( text .. OverflowString )

	end

	return overflow and (text .. OverflowString) or text

end

function MEDIAPLAYER:DrawHTML( browser, w, h )
	surface.SetDrawColor( 0, 0, 0, 255 )
	surface.DrawRect( 0, 0, w, h )
	DrawHTMLPanel( browser, w, h )
end

function MEDIAPLAYER:DrawMediaInfo( media, w, h )

	-- TODO: Fadeout media info instead of just hiding
	if not vgui.CursorVisible() and RealTime() - self._LastMediaUpdate > 3 then
		return
	end

	-- Text dimensions
	local tw, th

	-- Title background
	local titleStr = RestrictStringWidth( media:Title(), "MediaTitle",
		w - (TextPaddingX * 2 + TextBoxPaddingX * 2) )

	DrawTextBox( titleStr, "MediaTitle", TextPaddingX, TextPaddingY )

	-- Title
	DrawText( titleStr, "MediaTitle",
		TextPaddingX + TextBoxPaddingX,
		TextPaddingY + TextBoxPaddingY )

	-- Track bar
	if media:IsTimed() then

		local duration = media:Duration()
		local curTime = media:CurrentTime()
		local percent = math.Clamp( curTime / duration, 0, 1 )

		-- Bar height
		local bh = math.Round(h * 1/32)

		-- Bar background
		draw.RoundedBox( 0, 0, h - bh, w, bh, BarBgColor )

		-- Bar foreground (progress)
		draw.RoundedBox( 0, 0, h - bh, w * percent, bh, BarFgColor )

		local timeY = h - bh - TextPaddingY * 2

		-- Current time
		local curTimeStr = FormatSeconds(math.Clamp(math.Round(curTime), 0, duration))

		DrawTextBox( curTimeStr, "MediaTitle", TextPaddingX, timeY,
			TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM )
		DrawText( curTimeStr, "MediaTitle", TextPaddingX * 2, timeY,
			TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM )

		-- Duration
		local durationStr = FormatSeconds( duration )

		DrawTextBox( durationStr, "MediaTitle", w - TextPaddingX * 2, timeY,
			TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM )
		DrawText( durationStr, "MediaTitle", w - TextBoxPaddingX * 2, timeY,
			TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM )

	end

	-- Volume
	local volume = MediaPlayer.Volume()
	local volumeStr = tostring( math.Round( volume * 100 ) )

	-- DrawText( volumeStr, "MediaTitle", w - TextPaddingX, h/2,
		-- TEXT_ALIGN_CENTER )


	-- Loading indicator

end

--PATH lua/mediaplayer/services/youtube/cl_init.lua:
include "shared.lua"

local urllib = url

local htmlBaseUrl = MediaPlayer.GetConfigValue('html.base_url')

DEFINE_BASECLASS( "mp_service_browser" )

-- https://developers.google.com/youtube/player_parameters
-- TODO: add closed caption option according to cvar
SERVICE.VideoUrlFormat = htmlBaseUrl .. "youtube.html"

local JS_SetVolume = "if(window.MediaPlayer) MediaPlayer.setVolume(%s);"
local JS_Seek = "if(window.MediaPlayer) MediaPlayer.seek(%s);"
local JS_Play = "if(window.MediaPlayer) MediaPlayer.play();"
local JS_Pause = "if(window.MediaPlayer) MediaPlayer.pause();"

local function YTSetVolume( self )
	-- if not self.playerId then return end
	local js = JS_SetVolume:format( MediaPlayer.Volume() * 100 )
	if self.Browser then
		self.Browser:RunJavascript(js)
	end
end

local function YTSeek( self, seekTime )
	-- if not self.playerId then return end
	local js = JS_Seek:format( seekTime )
	if self.Browser then
		self.Browser:RunJavascript(js)
	end
end

function SERVICE:SetVolume( volume )
	local js = JS_SetVolume:format( MediaPlayer.Volume() * 100 )
	self.Browser:RunJavascript(js)
end

function SERVICE:OnBrowserReady( browser )

	BaseClass.OnBrowserReady( self, browser )

	-- Resume paused player
	if self._YTPaused then
		self.Browser:RunJavascript( JS_Play )
		self._YTPaused = nil
		return
	end

	local videoId = self:GetYouTubeVideoId()
	local timedParam = self:IsTimed() and '1' or '0'
	local url = self.VideoUrlFormat .. '?v=' .. videoId ..
				'&timed=' .. timedParam

	local curTime = self:CurrentTime()

	-- Add start time to URL if the video didn't just begin
	if self:IsTimed() and curTime > 3 then
		url = url .. "&start=" .. math.Round(curTime)
	end

	browser:OpenURL(url)

end

function SERVICE:Pause()
	BaseClass.Pause( self )

	if ValidPanel(self.Browser) then
		self.Browser:RunJavascript(JS_Pause)
		self._YTPaused = true
	end
end

function SERVICE:Sync()
	local seekTime = self:CurrentTime()
	if self:IsPlaying() and self:IsTimed() and seekTime > 0 then
		YTSeek( self, seekTime )
	end
end

function SERVICE:IsMouseInputEnabled()
	return IsValid( self.Browser )
end

--PATH lua/mediaplayer/services/twitchstream/cl_init.lua:
include "shared.lua"

local htmlBaseUrl = MediaPlayer.GetConfigValue('html.base_url')

DEFINE_BASECLASS( "mp_service_browser" )

local TwitchUrl = "http://www.twitch.tv/%s/popout"

local JS_Play = "if(window.MediaPlayer) MediaPlayer.play();"
local JS_Pause = "if(window.MediaPlayer) MediaPlayer.pause();"

local JS_HideControls = [[
document.body.style.cssText = 'overflow:hidden;height:106.8% !important';]]

function SERVICE:OnBrowserReady( browser )

	BaseClass.OnBrowserReady( self, browser )

	local channel = self:GetTwitchChannel()
	local url = TwitchUrl:format(channel)

	browser:OpenURL( url )

	browser:QueueJavascript( JS_HideControls )
	self:InjectScript( htmlBaseUrl .. "scripts/services/twitch.js" )

end

function SERVICE:Pause()
	BaseClass.Pause( self )

	if ValidPanel(self.Browser) then
		self.Browser:RunJavascript(JS_Pause)
		self._YTPaused = true
	end
end

--PATH lua/mediaplayer/services/twitchstream/shared.lua:
DEFINE_BASECLASS( "mp_service_browser" )

SERVICE.Name 	= "Twitch.TV - Stream"
SERVICE.Id 		= "twl"
SERVICE.Base 	= "browser"

function SERVICE:New( url )
	local obj = BaseClass.New(self, url)

	local channel = obj:GetTwitchChannel()
	obj._data = channel

	return obj
end

function SERVICE:Match( url )
	return string.match(url, "twitch.tv") and
			string.match(url, ".tv/[%w_]+$")
end

function SERVICE:IsTimed()
	return false
end

function SERVICE:GetTwitchChannel()

	local channel

	if self._twitchChannel then

		channel = self._twitchChannel

	elseif self.urlinfo then

		local url = self.urlinfo

		channel = string.match(url.path, "^/([%w_]+)")
		self._twitchChannel = channel

	end

	return channel

end

--PATH lua/mediaplayer/services/resource/cl_init.lua:
return gluapack()()
--PATH lua/mediaplayer/services/soundcloud/cl_init.lua:
return gluapack()()
--PATH lua/mediaplayer/services/soundcloud/shared.lua:
DEFINE_BASECLASS( "mp_service_base" )

SERVICE.Name 	= "SoundCloud"
SERVICE.Id 		= "sc"
SERVICE.Base 	= "af"

SERVICE.PrefetchMetadata = false

function SERVICE:New( url )
	local obj = BaseClass.New(self, url)

	-- TODO: grab id from /tracks/:id, etc.
	obj._data = obj.urlinfo.path or '0'

	return obj
end

function SERVICE:Match( url )
	return string.match( url, "soundcloud.com" )
end

--PATH lua/mediaplayer/sh_metadata.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/memetispowers/sh_cloak.lua:
return gluapack()()
--PATH addons/[mrs] mc_quests/lua/autorun/mqs_autorun.lua:
-- ╔═╗╔═╦═══╦═══╗───────────────────────
-- ║║╚╝║║╔═╗║╔═╗║───────────────────────
-- ║╔╗╔╗║║─║║╚══╗───────────────────────
-- ║║║║║║║─║╠══╗║──By MacTavish <3──────
-- ║║║║║║╚═╝║╚═╝║───────────────────────
-- ╚╝╚╝╚╩══╗╠═══╝───────────────────────
-- ────────╚╝───────────────────────────

MQS = {}
MQS.Config = {}

MQS.Quests = {}
MQS.Rewards = {}
MQS.Events = {}

MQS.TaskCount = {}
MQS.TaskQueue = {}
MQS.ActiveTask = {}

MQS.Version = "1.5.2a"
MQS.ServerID = "MQS77656119819628010501ID"
MQS.MainUserID = "76561198196280105"
MQS.DB = {}

if SERVER then
	util.AddNetworkString( "MQS.Notify" )
	util.AddNetworkString( "MQS.TaskNotify" )
	util.AddNetworkString( "MQS.SetPData" )
	util.AddNetworkString( "MQS.GetBigData" )
	util.AddNetworkString( "MQS.DataShare" )
	util.AddNetworkString( "MQS.ReQuest" )
	util.AddNetworkString( "MQS.FixPickUP" )
	util.AddNetworkString( "MQS.GetPData" )
	util.AddNetworkString( "MQS.GetOtherQuests" )
	util.AddNetworkString( "MQS.OpenEditor" )
	util.AddNetworkString( "MQS.GetConfigData" )
	util.AddNetworkString( "MQS.SaveConfig" )
	util.AddNetworkString( "MQS.QuestRemove" )
	util.AddNetworkString( "MQS.QuestSubmit" )
	--util.AddNetworkString( "MQS.QuestUpdate" )
	util.AddNetworkString( "MQS.QuestStatus" )
	util.AddNetworkString( "MQS.CreateNPC" )
	util.AddNetworkString( "MQS.UpdateNPC" )
	util.AddNetworkString( "MQS.StartTask" )
	util.AddNetworkString( "MQS.UIEffect" )
	util.AddNetworkString( "MQS.GetPlayersQuests" )
	util.AddNetworkString( "MQS.SavePlayerQuestList" )

	resource.AddWorkshop( "2486994157" )
end

function MQS.Load()

	MsgC( Color(0, 255, 0), "[MQS] Initialization started\n" )
	if !MSD then
		MsgC( Color(255, 0, 0), "[MQS] FAILED To locate MSD module!\nPlease install MSD before using the addon\nLink: https://github.com/the-mactavish/MSD\n" )
	end

	if !file.Exists(MQS.ServerID, "DATA") then
		file.CreateDir(MQS.ServerID)
		MsgC( Color(0, 255, 0), "[MQS] Server DATA Dir created \n" )
	end

	if SERVER then
		MsgC( Color(0, 255, 0), "[MQS] Loading server files\n" )
		include("mqs/sh_config.lua")
		AddCSLuaFile("mqs/sh_config.lua")
		local core = file.Find( "mqs/core/*", "LUA" )
		for k,v in ipairs( core ) do
			if string.StartWith( v, "sh_" ) then
				include( "mqs/core/" .. v )
				AddCSLuaFile( "mqs/core/" .. v )
			elseif string.StartWith( v, "sv_" ) then
				include( "mqs/core/" .. v )
			elseif string.StartWith( v, "cl_" ) then
				AddCSLuaFile( "mqs/core/" .. v )
			end
		end

		local ui = file.Find( "mqs/ui/*", "LUA" )
		for k,v in ipairs( ui ) do
			AddCSLuaFile( "mqs/ui/" .. v )
		end

	else
		MsgC( Color(0, 255, 0), "[MQS] Loading client files\n" )
		include("mqs/sh_config.lua")

		local core = file.Find( "mqs/core/*", "LUA" )
		for k,v in ipairs( core ) do
			if string.StartWith( v, "sh_" ) then
				include( "mqs/core/" .. v )
			elseif string.StartWith( v, "cl_" ) then
				include( "mqs/core/" .. v )
			end
		end

		local ui = file.Find( "mqs/ui/*", "LUA" )
		for k,v in ipairs( ui ) do
			include( "mqs/ui/" .. v )
		end
	end

	MsgC( Color(0, 255, 0), "[MQS] Initialization done\n" )
end

if SERVER then
	MQS.Load()
	hook.Add("PostGamemodeLoaded", "MQS.Load.SV", function() MQS.Load() end)
else
	hook.Add("InitPostEntity", "MQS.Load.CL", function() MQS.Load() end)
end

if GAMEMODE then
	MQS.Load()
end
--PATH addons/[ui] msd_ui/lua/msd/language/es.lua:
return gluapack()()
--PATH addons/[ui] msd_ui/lua/msd/language/fr.lua:
MSD.Language["fr"] = {

	-- UI

	lang_name = "French",

	ok = "OK",
	map = "Map",
	off = "Off",
	on = "On",
	time_add = "Il est temps d'ajouter",
	type = "Taper",
	delay = "Retard",
	cancel = "Annuler",
	enable = "Activé",
	model = "Model",
	name = "Nom",
	settings = "Paramètre",
	editor = "Éditeur",
	red = "Rouge",
	green = "Vert",
	blue = "Bleu",
	admin_menu = "Menu d'administration",
	ui_settings = "Paramètres de l'interface",
	active = "Actif",
	inactive = "Inactif",
	disabled = "Désactivée",
	warning = "Avertissement!",
	remove = "Supprimer",
	theme = "Thème",
	dark_theme = "Thème sombre",
	payment = "Paiement",
	load_autosave = "Charger la dernière sauvegarde automatique?",
	load_save = "Chargement de la sauvegarde",
	create_new = "Créer un nouveau",
	enable_option = "Activer l'option",
	main_opt = "Options principales",
	copy_data = "Copier des données",
	save_chng = "Sauvegarder les modifications",
	enter_name = "Entrez le nom",
	enter_id = "Entrez l'ID",
	confirm_action = "Veuillez confirmer vos actions",
	check_fpr_errors = "Rechercher les erreurs",
	enter_description = "Entrez la description",
	cooldown_ok = "Temps de recharge en cas de succès",
	cooldown_fail = "Temps de recharge en cas d'échec",
	s_team_whitelist = "Configuration de la TEAM Whitelist",
	whitelist_blacklist = "La liste blanche est une liste noire",
	custom_val = "Définir une valeur personnalisée",
	set_hp_full = "Définir les HP complets",
	dist_to_close = "Distance au plus proche",

	e_text = "Entrez du texte",
	e_number = "Entrez un nombre",
	e_class = "Entrer une classe",
	e_value = "Entrez une valeur",
	e_blank_dis = "Laisser vide pour désactiver",
	e_blank_default = "Laissez le noir pour utiliser la valeur par défaut",
	e_url = "Entrer une URL",
	e_model = "Entrez le chemin du modèle",
	e_material = "Entrez le chemin du matériau",
	e_wep_class = "Entrez la classe d'une arme",
	e_ent_class = "Entrez la classe de l'entité",
	e_veh_class = "Entrez la classe du véhicule",
	e_npc_class = "Entrez la classe du NPC",

	select_ammo = "Munitions sélectionnées",
	amount_ammo = "Montant des munitions",
	disable_phys = "Désactiver la physique",
	none = "Rien",
	custom_icon = "Définir une icône personnalisée",
	weapon_name = "Nom de l'arme",
	moveup = "déplacer vers le haut",
	movedown = "déplacer vers le bas",
	movepoint = "Déplacer le point",
	swap = "Échanger",
	swapmod = "Swap mod activé. Cliquez pour désactiver",
	copy_from_ent = "Copier de l'entité recherchée",
	set_pos_self = "Réglez votre position",
	set_pos_aim = "Définir le point de recherche",
	spawn_point = "Point d'apparition",
	spawn_ang = "Angle d'apparition",
	mark_area = "Marquer la zone",
	time_wait = "Il est temps d'attendre",
	map_marker = "Sélectionnez un marqueur de map",
	in_sec = "en secondes",
	def_units = "Défaut %s unités", -- "350 unités par défaut" laisser %s tel quel
	def_seconds = "Défaut %s secondes", -- "Par défaut, 10 secondes" laisser %s comme si
	ent_show_pointer = "Montrer poiter au-dessus de l'entité",
	ent_arcade_style = "Apparence d'entité de style arcade",
	ent_stnd_style = "Apparence d'entité standard",
	custom_color = "Activer la couleur personnalisée",
	mat_default = "Laisser vide pour le matériau par défaut",

	set_ui = "Paramètres de l'interface utilisateur",
	set_hud = "Paramètres du HUD",
	set_hud_pos = "Position du HUD de quête",
	set_hud_themes = "Thèmes HUD",
	set_server = "Paramètres du serveur",
	set_ui_blur = "Arrière-plan flou",
	set_ui_mono = "Fond monochrome",
	set_ui_vignette = "Effet de vignette pour l'arrière-plan",
	set_ui_brightness = "Luminosité d'arrière-plan",
	set_ui_color = "Sélectionnez la couleur principale",
	set_ui_align_left = "Alignement horizontal vers la gauche",
	set_ui_align_right = "Alignement horizontal vers la droite",
	set_ui_align_top = "Alignement vertical vers le haut",
	set_ui_align_bottom = "Alignement vertical vers le bas",
	set_ui_offset_h = "Décalage horizontal",
	set_ui_offset_v = "Décalage vertical",

	upl_changes = "Télécharger les modifications sur le serveur",
	res_changes = "Restaurer les modifications",

	-- Joueur

	dead = "Restaurer les modifications",
	time_ex = "Le temps est écoulé",
	vehicle_bum = "Votre véhicule est détruit",
	left_area = "Vous avez quitté la zone",
	m_blew = "Vous avez fait sauter la mission",
	m_failed = "Mission échouée",
	m_success = "Succès de la mission",
	m_loop = "Mise à jour de la mission",

	-- Erreurs

	inv_quest = "Quête invalide",
	team_bl = "Votre équipe est sur liste noire",
	no_players = "Le serveur a besoin de plus de joueurs pour être en ligne avant de pouvoir le faire",
	no_players_team = "Le serveur a besoin de plus de joueurs pour que des TEAM spécifiques soient en ligne avant que vous puissiez le faire",
	need_admin = "Seuls les administrateurs peuvent effectuer cette action",

	-- Quête

	active_quest = "Vous avez une quête active",
	inactive_quest = "Vous ne pouvez pas jouer à cette quête",
	quest_editor = "Éditeur de quête",
	quest_list = "Liste des quêtes",
	quests = "Quêtes",
	leave_pnt = "Quitter le point",

	q_editobj = "Modifier les objectifs",
	q_incvobj = "Objectif invalide",
	q_setobj = "Paramètres d'objectifs",
	q_newobj = "Ajouter un nouvel objectif",
	q_editrwd = "Modifier les récompenses",
	q_rwdeditor = "Éditeur de récompenses",
	q_rwdlist = "Liste de récompenses",
	q_rwdsets = "Paramètres de récompense",
	q_findmap = "Trouver une quête sur d'autres cartes",
	q_obj_des = "Description de l'objectif",
	q_dist_point = "Distance au point",
	q_dist_from_point = "Distance du point",
	q_ignore_veh = "Ignorer le véhicule de quête",
	q_timer_show = "Montrez le chronomètre au joueur",
	q_area_stay = "Le joueur doit rester dans la zone",
	q_start = "Démarrer la quête",
	q_new = "Nouvelle quête",
	q_submit = "Soumettre la quête",
	q_addnew = "Ajouter une nouvelle quête",
	q_remove = "Supprimer la quête",
	q_id_unique = "L'ID doit être unique pour chaque quête",
	q_complete_msg = "Message complet de la quête",
	q_dotime = "Message complet de la quête",
	q_dotime_ok = "Réussir la quête à la fin du temps",
	q_dotime_fail = "Échec de la quête à la fin du temps",
	q_death_fail = "Échec de la quête à la mort du joueur",
	q_loop = "Tâches de quête en boucle",
	q_loop_reward = "Récompensez le joueur sur chaque boucle",
	q_enable = "Activer la quête",
	q_events = "Événements",
	q_eventadd = "Ajouter un évènement",
	q_eventedit = "Modification d'événement",
	q_eventremove = "Supprimer l'événement",
	q_in_progress = "Quête en cours",
	q_time_left = "Temps restant",
	q_ply_limit = "Limite de joueurs pour la quête",
	q_ply_team_limit = "Limites de l'équipe de configuration",
	q_ply_team_need = "Joueurs d'équipe nécessaires",
	q_ply_need = "Quantité de joueur nécessaire pour commencer",
	q_play_limit = "Il y a une limite au nombre de joueurs pouvant jouer à cette quête",
	q_must_stay_area = "Vous devez rester dans cette zone, sinon la quête échouera",
	q_time_wait = "Vous devez attendre avant de rejouer cette quête",
	q_dotime_reset = "Réinitialiser le temps de la quête",
	q_dotime_add = "Ajouter une quête à faire",
	q_noreplay = "Vous ne pouvez pas rejouer cette quête",
	q_dis_replay = "Désactiver la relecture de quête",
	q_needquest = "Vous devez d'abord terminer une autre quête",
	q_needquest_menu = "Requiert une quête terminée",
	q_enterror = "Les entités de quête ne sont pas apparues, vérifiez la configuration de la quête",
	q_get = "Vous pouvez obtenir une quête de ces PNJ",
	q_noquests = "Il n'y a pas encore moyen de jouer des quêtes :(",
	q_ent_draw = "Distance de tirage de l'entité de quête",
	q_loop_stop_key = "Clé d'arrêt de quête en boucle",
	q_hold_key_stop = "Pour arrêter la suspension de quête [%s] ", -- Pour arrêter la suspension de quête [P]
	q_enter_veh = "Entrez votre véhicule",
	q_npc_link = "Lier la quête à un PNJ",
	q_icon68 = "Entrez l'URL de l'icône .PNG 68 x 68 px",
	q_ent_pos_show = "Afficher l'emplacement des entités au joueur",
	q_area_size = "Taille de la zone",
	q_area_pos = "Position de la zone",
	q_s_area_size = "Taille de la zone de recherche",
	q_s_area_pos = "Position de la zone de recherche",
	q_npc_answer_ok = "Réponse positive du joueur",
	q_npc_answer_no = "Réponse négative du joueur",
	q_npc_answer_noq = "Réponse du joueur si aucune quête",
	q_npc_quest_no = "Discours des PNJ si aucune quête",
	q_money_give = "De l'argent à donner",

	-- Simple NPCs

	npc_editor = "Éditeur de PNJ",
	npc_new = "Nouveau PNJ",
	npc_select = "Sélectionnez un PNJ",
	npc_e_speech = "Entrez le discours du PNJ",
	npc_submit = "Confirmer la création du PNJ",
	npc_update = "Mettre à jour le PNJ",
	npc_remove = "Supprimer un PNJ",
	npc_q_enable = "Activer les PNJ de quête",
	npc_did_open = "ID de boîte de dialogue à ouvrir",
	npc_q_target = "NPC est une cible objective",
	npc_hostile = "PNJ hostile",

	-- Update 1.1.0

	cam_start = "Paramètres de départ de la caméra",
	cam_end = "Paramètres de fin de la caméra",
	cam_pos = "Position de la caméra",
	cam_ang = "Angle de caméra",
	cam_fov = "FOV de caméra",
	cam_effect = "Effet d'obturateur de caméra",
	q_open_target = "Autoriser les joueurs à tuer les autres NPC",
	q_npc_mind = "Distance min. au NPC",
	not_spawned = "non apparu",
	dis_text = "Texte affiché",
	cam_speed = "Vitesse de mouvement de la caméra (nombre bas - mouvement lent)",
	fov_speed = "Vitesse du FOV de la caméra (nombre bas - mouvement lent)",
	category_des = "Catégorie de quêtes, utilisé pour trier les quêtes",
	sortquests_cat = "Trier les quêtes par catégorie",
	search_q = "Rechercher des quêtes",
	quest_tools = "Outils de quête",
	set_anim = "Mettre une animation",
	s_quest_blacklist = "Configurer une liste noire de quête", -- In France, we can say blacklist too 
	s_quest_blacklist_desc = "Sélectionnez les quêtes qui vont se bloquer si elles sont jouées",
	hold_use = "Maintener la touche [%s]",
	duplicate = "Duplicé",
	unsorted = "Non-trié",
	search = "Recherche",
	duration = "Durée",
	category = "Catégorie",
	blacklist = "Liste noire",


	--  Update 1.2.0

	restore_wep = "Restorer les armes à la fin de la quête",
	e_cmd = "Entrer une commande console",
	e_args = "Entrer des commandes d'arguments",
	hint_cmd = "Autoremplissage de raccourcis : \n$uid - IDJoueur, \n$sid - SteamID,  \n$s64 - SteamID 64, \n$n - No du joueur",
	youaretracked = "Votre position est compromise par d'autres joueurs !",
	border_rounded = "Design de bordure ronde",
	border_square = "Design de bordure carrée",
	access_settings = "Accès au menu",
	compact_obj = "Compacter la liste des objectifs pour les quêtes",
	e_usergroup = "Entrer un groupe d'utilisateurs",
	ug_isanadmin = "Ce groupe d'utilisateur à déjà des pleins accès",
	find_player_id32 = "Trouver un joueur par le SteamID 32",
	user_data = "Éditeur de données",
	access_editors = "Accès à configurer l'éditeur de quêtes",
	access_admins = "Mettre des accès complets",
	add_usergroup = "Ajouter un utilisateur au groupe",
	edit_objmod = "Éditer les objectifs du mode",
	editmod = "Éditer des modes",
	move = "Déplacer",
	q_errorloop = "Quête dans une loupe infinie",
	q_cooldow_perply = "Compteur de temps public",
	q_cooldow_publick = "Compteur de temps par joueur",
	q_stop_anytime = "Autoriser manuellement l'abandon de quêtes",
	quest_abandon = "Vous avez abandonné la quête",
	q_dotime_set = "Configurer la fin de quête à la fin d'un temps",


	-- Ranks

	enter_path_or_url = "Entrer l'emplacement ou l'URL",
	rank_edit = "Configuration des grades",
	rank_list = "Liste de grades",
	group_list = "Liste des groupes",
	group_addnew = "Ajouter un nouveau groupe",
	blank = "Blanc",
	mrs_show_all = "Montrer les grades à tous les joueurs",
	mrs_show_team = "Montrer les grades uniquement au groupe",
	mrs_use_sn = "Afficher des noms de grade courts",
	use_url = "Utiliser une URL",
	enter_srt_name = "Entrer un nom court",
	srt_name = "Nom court",
	mrs_prom_demote = "Les prochaines 2 options affectent uniquement les grades les plus bas. Les joueurs ne pourront pas promotionner les autres joueurs les hauts grades ou le même grade.",
	mrs_whilelist = "Si vous sélectionnez un grade requis pour un job, le joueur pourra jouer avec le job que si il a le grade défini ou plus.",
	can_promote = "Peut promotionner le grade d'un joueur",
	can_demote = "Peut rétrograder le grade d'un joueur",
	edit_player_model = "Éditer le playermodel personnalisé",
	enable_player_model = "Activer le playermodel personnalisé",
	disable_player_model = "Désactiver le playermodel personnalisé",
	edit_custom_stats = "Éditer les stats personnalisés du joueur",
	autoprom = "Auto-promotionner au prochain grade",
	in_min = "en minutes",
	mrs_promoted = "Vous avez été promotionné",
	mrs_demoted = "Vous avez été rétrogradé",
	mrs_job_smallrank = "Vous devez être %s ou plus pour jouer en tant que %s",
	show_group = "Montrer uniquement le nom du grade",
	hide_rank = "Montrer uniquement l'icone du grade",
	mrs_hud_follow = "Rotatationner l'UI autour du joueur dépendant de la vue de l'angle",
	set_overhead = "UI de l'information du joueur",
	offline_users = "Utilisateurs hors-ligne",
	mrs_noranks = "Votre métier actuel n'a pas de grades",
	mrs_nopower = "Votre grade actuel n'a pas plus de permissions",
	promotion = "Promotion",
	on_duty = "En service",
	other_players = "Autres joueurs",
	mrs_change_jobname = "Changer le job au nom du grade",
	mrs_set_prefix = "Ajouter le nom du grade au préfix du nom du métier",
}

-- Other phrases
local lng = "fr"

MSD.Language[lng]["Move to point"] = "Déplacer vers le point"
MSD.Language[lng]["Leave area"] = "Quitter la zone"
MSD.Language[lng]["Kill NPC"] = "Tuer un NPC"
MSD.Language[lng]["Collect quest ents"] = "Collecter les ents de quête"
MSD.Language[lng]["Talk to NPC"] = "Parler à NPC"
MSD.Language[lng]["Wait time"] = "Temps d'attente"

MSD.Language[lng]["There is no quests avalible"] = "Il n'y a pas de quêtes disponibles"

MSD.Language[lng]["Give weapon"] = "Donner une arme"
MSD.Language[lng]["Give ammo"] = "Donner des munitions"
MSD.Language[lng]["Strip Weapon"] = "Arme de bande"
MSD.Language[lng]["Spawn quest entity"] = "Entité de quête d'apparition"
MSD.Language[lng]["Spawn entity"] = "Entité d'apparition"
MSD.Language[lng]["Spawn npc"] = "Apparition du npc"
MSD.Language[lng]["Manage do time"] = "Gérer le temps de travail"
MSD.Language[lng]["Spawn vehicle"] = "Apparition du véhicule"
MSD.Language[lng]["Remove vehicle"] = "Retirer le véhicule"
MSD.Language[lng]["Remove all entites"] = "Supprimer toutes les entités"
MSD.Language[lng]["Set HP"] = "Définir HP"
MSD.Language[lng]["Set Armor"] = "Définir l'armure"

MSD.Language[lng]["DarkRP Money"] = "Argent DarkRP"

MSD.Language[lng]["Quest NPCs are disabled"] = "Les PNJ de quête sont désactivés"
MSD.Language[lng]["You can enable them in settings"] = "Vous pouvez les activer dans les paramètres"
--PATH addons/[ui] msd_ui/lua/msd/language/nl.lua:
return gluapack()()
--PATH addons/[ui] msd_ui/lua/msd/ui/msdframe.lua:
local PANEL = {}
AccessorFunc(PANEL, "m_bIsMenuComponent", "IsMenu", FORCE_BOOL)
AccessorFunc(PANEL, "m_bDraggable", "Draggable", FORCE_BOOL)
AccessorFunc(PANEL, "m_bSizable", "Sizable", FORCE_BOOL)
AccessorFunc(PANEL, "m_bScreenLock", "ScreenLock", FORCE_BOOL)
AccessorFunc(PANEL, "m_bDeleteOnClose", "DeleteOnClose", FORCE_BOOL)
AccessorFunc(PANEL, "m_bPaintShadow", "PaintShadow", FORCE_BOOL)
AccessorFunc(PANEL, "m_iMinWidth", "MinWidth", FORCE_NUMBER)
AccessorFunc(PANEL, "m_iMinHeight", "MinHeight", FORCE_NUMBER)

function PANEL:Init()
	self:SetFocusTopLevel(true)
	self:SetPaintShadow(true)
	self:SetDraggable(true)
	self:SetSizable(false)
	self:SetScreenLock(false)
	self:SetDeleteOnClose(true)
	self:SetMinWidth(50)
	self:SetMinHeight(50)
	self:SetPaintBackgroundEnabled(false)
	self:SetPaintBorderEnabled(false)
	self.m_fCreateTime = SysTime()

	self.WorkSpace = {
		x = 0,
		y = 52,
		w = 0,
		h = 0
	}

	self.WorkComponents = {}
end

function PANEL:Close()
	self:SetVisible(false)

	if (self:GetDeleteOnClose()) then
		self:Remove()
	end

	self:OnClose()
end

function PANEL:OnClose()
end

function PANEL:Center()
	self:InvalidateLayout(true)
	self:CenterVertical()
	self:CenterHorizontal()
end

function PANEL:IsActive()
	if (self:HasFocus()) then return true end
	if (vgui.FocusedHasParent(self)) then return true end

	return false
end

function PANEL:Think()
	local mousex = math.Clamp(gui.MouseX(), 1, ScrW() - 1)
	local mousey = math.Clamp(gui.MouseY(), 1, ScrH() - 1)

	if (self.Dragging) then
		local x = mousex - self.Dragging[1]
		local y = mousey - self.Dragging[2]

		-- Lock to screen bounds if screenlock is enabled
		if (self:GetScreenLock()) then
			x = math.Clamp(x, 0, ScrW() - self:GetWide())
			y = math.Clamp(y, 0, ScrH() - self:GetTall())
		end

		self:SetPos(x, y)
	end

	if (self.Sizing) then
		local x = mousex - self.Sizing[1]
		local y = mousey - self.Sizing[2]
		local px, py = self:GetPos()

		if (x < self.m_iMinWidth) then
			x = self.m_iMinWidth
		elseif (x > ScrW() - px and self:GetScreenLock()) then
			x = ScrW() - px
		end

		if (y < self.m_iMinHeight) then
			y = self.m_iMinHeight
		elseif (y > ScrH() - py and self:GetScreenLock()) then
			y = ScrH() - py
		end

		self:SetSize(x, y)
		self:SetCursor("sizenwse")

		return
	end

	local screenX, screenY = self:LocalToScreen(0, 0)

	if (self.Hovered and self.m_bSizable and mousex > (screenX + self:GetWide() - 20) and mousey > (screenY + self:GetTall() - 20)) then
		self:SetCursor("sizenwse")

		return
	end

	if (self.Hovered and self:GetDraggable() and mousey < (screenY + 24)) then
		self:SetCursor("sizeall")

		return
	end

	self:SetCursor("arrow")

	-- Don't allow the frame to go higher than 0
	if (self.y < 0) then
		self:SetPos(self.x, 0)
	end
end

function PANEL:AddToWorkSpace(panel)
	panel:SetParent(self)
	panel:SetSize(self.WorkSpace.w, self.WorkSpace.h)
	panel:SetPos(self.WorkSpace.x, self.WorkSpace.y)
	local id = table.insert(self.WorkComponents, panel)

	panel.OnRemove = function()
		self.WorkComponents[id] = nil
	end
end

function PANEL:Paint(w, h)
	return true
end

function PANEL:OnMousePressed()
	local screenX, screenY = self:LocalToScreen(0, 0)

	if (self.m_bSizable and gui.MouseX() > (screenX + self:GetWide() - 20) and gui.MouseY() > (screenY + self:GetTall() - 20)) then
		self.Sizing = {gui.MouseX() - self:GetWide(), gui.MouseY() - self:GetTall()}

		self:MouseCapture(true)

		return
	end

	if (self:GetDraggable() and gui.MouseY() < (screenY + 24)) then
		self.Dragging = {gui.MouseX() - self.x, gui.MouseY() - self.y}

		self:MouseCapture(true)

		return
	end
end

function PANEL:OnMouseReleased()
	self.Dragging = nil
	self.Sizing = nil
	self:MouseCapture(false)
end

function PANEL:PerformLayout()
	local Wide = self:GetWide()
	local Tall = self:GetTall()

	self.WorkSpace = {
		x = 0,
		y = 52,
		w = Wide,
		h = Tall - 52
	}

	if self.WorkComponents and #self.WorkComponents > 0 then
		for i = 1, #self.WorkComponents do
			local panel = self.WorkComponents[i]

			if panel and IsValid(panel) then
				panel:SetSize(self.WorkSpace.w, self.WorkSpace.h)
				panel:SetPos(self.WorkSpace.x, self.WorkSpace.y)
				panel:InvalidateLayout()
			end
		end
	end
end

derma.DefineControl("MSDSimpleFrame", "A simple window for msd", PANEL, "EditablePanel")
--PATH addons/[ui] msd_ui/lua/msd/ui/msdmenu.lua:
return gluapack()()
--PATH lua/mvp/core/sh_data.lua:
mvp = mvp or {}
mvp.data = mvp.data or {}

mvp.data.bucket = "mvp/" -- path to save data in "data/" folder
mvp.data.cache = {
    global = {}, -- global cache
    map = {}, -- map cache
} -- cache of data

function mvp.data.Set(key, value, isMap)
    -- mvp/global/[key].txt
    -- mvp/maps/[map]/[key].txt

    local destination = isMap and (game.GetMap() .. "/") or "global/"

    local folderPath = mvp.data.bucket .. destination
    local filePath = folderPath .. key .. ".txt"

    if not file.Exists(folderPath, "DATA") then
        file.CreateDir(folderPath)
    end

    file.Write(filePath, util.TableToJSON({value}))
    mvp.data.cache[isMap and "map" or "global"][key] = value

    return value
end

function mvp.data.Get(key, default, isMap, skipCache)
    -- mvp/global/[key].txt
    -- mvp/[map]/[key].txt

    local destination = isMap and (game.GetMap() .. "/") or "global/"
    local cacheType = isMap and "map" or "global"

    local folderPath = mvp.data.bucket .. destination
    local filePath = folderPath .. key .. ".txt"

    if (not skipCache and mvp.data.cache[cacheType][key]) then
        return mvp.data.cache[cacheType][key]
    end

    local data = file.Read(filePath, "DATA")
    if (data) then
        mvp.data.cache[cacheType][key] = util.JSONToTable(data)[1]
        return util.JSONToTable(data)[1]
    end

    return default
end
--PATH lua/mvp/core/sh_types.lua:
--- @module mvp.types

mvp = mvp or {}
mvp.types = mvp.types or {}

--- Sanitizes a value to a specific type
-- @tparam mvp.type type The type to sanitize to
-- @param input The value to sanitize
-- @treturn any The sanitized value
function mvp.types.SanitizeType(type, input)
    if ( type == mvp.type.string ) then return tostring(input) end
    if ( type == mvp.type.text ) then return tostring(input) end
    if ( type == mvp.type.number ) then return tonumber(input) end
    if ( type == mvp.type.bool ) then return tobool(input) end
    if ( type == mvp.type.color ) then return istable(input) and Color(input.r or 255, input.g or 255, input.b or 255, input.a or 255) or color_white end
    if ( type == mvp.type.vector ) then return isvector(input) and input or vector_origin end
    if ( type == mvp.type.array ) then return istable(input) and input or {} end

    error("Attemped to sanitaze " .. ( mvp.type[type] and ("invalid type" .. mvp.type[type] ) or ("unknown type" .. type) ))
end

local typeMap = {
    ["string"] = mvp.type.string,
    ["number"] = mvp.type.number,
    ["boolean"] = mvp.type.bool,
    ["vector"] = mvp.type.vector,
    ["table"] = mvp.type.array,

    ["Player"] = mvp.type.player
}

local tableMap = {
    [mvp.type.color] = function(input)
        return mvp.utils.IsColor(input)
    end,
}

function mvp.types.GetTypeFromValue(input)
    local inputType = type(input)

    if typeMap[inputType] then return typeMap[inputType] end

    if (istable(input)) then
        for typeName, func in pairs(tableMap) do
            if func(input) then return typeName end
        end
    end

    return nil -- unknown type
end
--PATH lua/mvp/core/ui/cl_outlined_rect.lua:
-- Requires: https://github.com/tochnonement/spoly

mvp = mvp or {}
mvp.ui = mvp.ui or {}

do
    local function calculateArc(x, y, ang, p, rad, seg)
        seg = seg or 80
        ang = (-ang) + 180
        local circle = {}

        table.insert(circle, {
            x = x,
            y = y
        })
        for i = 0, seg do
            local a = math.rad((i / seg) * -p + ang)
            table.insert(circle, {
                x = x + math.sin(a) * rad,
                y = y + math.cos(a) * rad
            })
        end

        return circle
    end
    
    -- 32 = 4
    -- 24 = 6
    -- 16 = 8
    -- 8 = 16
    for roundness = 32, 8, -8 do
        local index = roundness / 8
        local multiplier = roundness * 2 / math.pow(2, index)
    
        if (index == 1) then
            multiplier = multiplier * 2
        end
    
        for thickness = 1, 4 do
            local scaledThickness = thickness * 64
            local id = 'arc_' .. thickness .. '_' .. roundness
    
            spoly.Generate(id, function(w, h)
    
                local startAng = 0
                local endAng = 90
                local radius = h
                local x, y = 0, h
                                            -- 
                local arcInner = calculateArc(x - scaledThickness, y + scaledThickness, startAng, endAng, radius, 128, true)
                local arcOuter = calculateArc(x, y, startAng, endAng, radius, 128, true)
            
                render.SetStencilWriteMask(255)
                render.SetStencilTestMask(255)
                render.SetStencilReferenceValue(0)
                render.SetStencilPassOperation(STENCIL_KEEP)
                render.SetStencilZFailOperation(STENCIL_KEEP)
                render.ClearStencil()

                render.SetStencilEnable(true)
                render.SetStencilReferenceValue(1)
                render.SetStencilCompareFunction(STENCIL_NEVER)
                render.SetStencilFailOperation(STENCIL_REPLACE)

                    surface.DrawPoly(arcInner)

                render.SetStencilCompareFunction(STENCIL_GREATER)
                render.SetStencilFailOperation(STENCIL_KEEP)
                render.SetStencilZFailOperation(STENCIL_KEEP)

                    surface.DrawPoly(arcOuter)

                render.SetStencilEnable(false)
    
            end) 
        end
    end
end

function mvp.ui.DrawOutlinedRoundedRect(r, x, y, w, h, thickness, color)
    local thickness = thickness or 1
    local id = 'arc_' .. thickness .. '_' .. r

    thickness = math.floor(r * 0.15)

    local w = math.ceil(w)
    local h = math.ceil(h)

    -- x = x - thickness * .5

    local half = math.Round(r * .5)

    if (color) then
        surface.SetDrawColor(color)
    end

    spoly.DrawRotated(id, x + half, y + half, r, r, 90)
    spoly.DrawRotated(id, x + w - half, y + half, r, r, 0)
    spoly.DrawRotated(id, x + w - half, y + h - half, r, r, 270)
    spoly.DrawRotated(id, x + half, y + h - half, r, r, 180)

    surface.DrawRect(x + r, y, (w - r * 2), thickness)
    surface.DrawRect(x + w - thickness, y + r, thickness, (h - r * 2))
    surface.DrawRect(x + r, y + h - thickness, (w - r * 2), thickness)
    surface.DrawRect(x, y + r, thickness, (h - r * 2))
end
--PATH lua/mvp/core/config/cl_config.lua:
return gluapack()()
--PATH lua/mvp/configs/server.lua:
return gluapack()()
--PATH lua/mvp/credits/sh_icons.lua:
return gluapack()()
--PATH lua/mvp/core/command/sh_command.meta.lua:
mvp = mvp or {}
mvp.meta.command = mvp.meta.command or {}

mvp.meta.command.__proto = mvp.meta.command

mvp.meta.command.__proto._name = "Unnamed"
AccessorFunc(mvp.meta.command, "_name", "Name")

mvp.meta.command.__proto._description = "No description provided."
AccessorFunc(mvp.meta.command, "_description", "Description")

mvp.meta.command.__proto._id = "unnamed_command"
AccessorFunc(mvp.meta.command, "_id", "ID")

function mvp.meta.command:New()
    local o = table.Copy(mvp.meta.command.__proto)

    setmetatable(o, mvp.meta.command)
    o.__index = self

    return o
end

mvp.meta.command.__proto._permissions = {}
function mvp.meta.command:SetPermissions(permissions)
    self._permissions = permissions
end

function mvp.meta.command:CanRun(ply)
    if (#self._permissions == 0) then
        return true
    end
    
    return mvp.permissions.CheckAll(ply, self._permissions)
end

function mvp.meta.command:Run(ply, args)
    if not self:CanRun(ply) then
        mvp.q.NotifyError(mvp.q.Lang("general.command_x", self._name), mvp.q.Lang("general.no_permission"), nil, ply)
        
        return ""
    end

    return self:Execute(ply, args)
end

function mvp.meta.command:Execute(ply, args)
    error("Command has no execute function.")
end
--PATH addons/[bronie] perfect-hands/lua/mvp/packages/perfecthands/languages/en.lua:
local l = {}

l["section.perfecthands"] = "Perfect Hands"
l["section.perfecthands.appearance"] = "Appearance"
l["section.perfecthands.animations"] = "Animations System"
l["section.perfecthands.interactions"] = "Interactions System"

l["value.phands.useIcons.description"] = "If enabled, animations will be using icons, otherwise they will use text."
l["value.phands.useModels.description"] = "If enabled, animations will be using player model, FPS heavy. Themes will be ignored."
l["value.phands.iconsTheme.description"] = "The theme of the icons."

l["value.phands.useAnimations.description"] = "Enable or disable the animation system."
l["value.phands.animationAllowFreelook.description"] = "Allow the player to freelook while playing animations."
l["value.phands.animationSpeed.description"] = "The speed of the animations."
l["value.phands.animationVelocityCutoff.description"] = "Controls the maximum velocity at which the animation will play. If the player's velocity is higher than this value, the animation will not play."

l["value.phands.useInteractions.description"] = "Enable or disable the interaction system."
l["value.phands.interactionDistance.description"] = "The distance at which the player can interact with objects."
l["value.phands.interactionWeightMultiplier.description"] = "Controls the weight multiplier for the interaction system. This will affect how heavy the objects feel when the player is holding them."

l["phands.name"] = "Hands" -- this is the name for the hands SWEP

l["phands.mouse_buttons.MOUSE1"] = "LMB"
l["phands.mouse_buttons.MOUSE2"] = "RMB"
l["phands.mouse_buttons.MOUSE3"] = "MMB"

l["phands.hint.drag"] = "Press and hold {{btn:%s}} to grab this entity."
l["phands.hint.rmb"] = "Press {{btn:%s}} to open animations menu."
l["phands.hint.rmb.stop"] = "Press {{btn:%s}} or {{btn:%s}} button to stop the animation."
l["phands.hint.freelook"] = "Hold {{btn:%s}} button to freelook."

l["phands.cant_use_animation"] = "You can't use \"%s\" animation right now."

l["phands.animation.surrender"] = "Surrender"
l["phands.animation.surrender.description"] = "You raise your hands and accept your fate."
l["phands.animation.armsinfront"] = "Arms in front"
l["phands.animation.armsinfront.description"] = "You put your arms in front of you."
l["phands.animation.armsbehind"] = "Arms behind"
l["phands.animation.armsbehind.description"] = "You put your arms behind you."
l["phands.animation.armsbehindhead"] = "Arms behind head"
l["phands.animation.armsbehindhead.description"] = "You put your arms behind your head."
l["phands.animation.armsonbelt"] = "Arms on belt"
l["phands.animation.armsonbelt.description"] = "You put your arms on your belt."
l["phands.animation.comlink"] = "Comlink"
l["phands.animation.comlink.description"] = "You use your comlink."
l["phands.animation.hololink"] = "Hololink"
l["phands.animation.hololink.description"] = "You use your hololink."
l["phands.animation.highfive"] = "High five"
l["phands.animation.highfive.description"] = "You raise your hand for a high five."
l["phands.animation.point"] = "Point"
l["phands.animation.point.description"] = "You point at something."
l["phands.animation.salute"] = "Salute"
l["phands.animation.salute.description"] = "You salute."
l["phands.animation.pensive"] = "Pensive"
l["phands.animation.pensive.description"] = "You look pensive."
l["phands.animation.typing"] = "Typing"
l["phands.animation.typing.description"] = "You type on a keyboard."
l["phands.animation.middlefinger"] = "Middle Finger"
l["phands.animation.middlefinger.description"] = "Show someone the middle finger."
l["phands.animation.attention"] = "Attention"
l["phands.animation.attention.description"] = "You stand at attention."
l["phands.animation.kneel"] = "Kneel Down"
l["phands.animation.kneel.description"] = "You kneel down on one knee."




mvp.language.Register("en", l)
--PATH addons/[bronie] perfect-hands/lua/mvp/packages/perfecthands/sh_themes.lua:
return gluapack()()
--PATH lua/mvp/vgui/cl_scrollpanel.lua:
return gluapack()()
--PATH lua/mvp/vgui/button/cl_button.lua:
return gluapack()()
--PATH lua/mvp/vgui/checkbox/cl_checkbox.lua:
return gluapack()()
--PATH lua/mvp/vgui/menu/cl_menu_header.lua:
return gluapack()()
--PATH lua/mvp/vgui/menu/cl_menu_header.lua:
local PANEL = {}

AccessorFunc(PANEL, "text", "Text", FORCE_STRING)
AccessorFunc(PANEL, "subText", "Description", FORCE_STRING)

AccessorFunc(PANEL, "textFont", "TextFont", FORCE_STRING)
AccessorFunc(PANEL, "subTextFont", "SubDescriptionFont", FORCE_STRING)

function PANEL:Init()
    self.text = ""
    self.subText = ""

    self.textFont = mvp.Font(28, 800)
    self.subTextFont = mvp.Font(22, 500)
end

function PANEL:Paint(w, h)
    draw.SimpleText(self.text, self.textFont, 0, h * 0.5 + 5, mvp.colors.Accent, nil, TEXT_ALIGN_BOTTOM)
    draw.SimpleText(self.subText, self.subTextFont, 0, h * 0.5 - 1, mvp.colors.Text, nil, TEXT_ALIGN_TOP)
end

vgui.Register("mvp.MenuHeader", PANEL, "Panel")
--PATH lua/mvp/vgui/sidebar/cl_sidebar_hint.lua:
return gluapack()()
--PATH lua/mvp/menus/admin/cl_home.lua:
return gluapack()()
--PATH lua/mvp/menus/admin/cl_packages.lua:
return gluapack()()
--PATH addons/[medic] defib/lua/autorun/ncs_defibrilator_autorun.lua:
timer.Simple(0, function()    
    NCS_DEFIBRILLATOR = NCS_DEFIBRILLATOR or {
        CONFIG = {},
    }

    local rootDir = "ncs_defibrillator_system"

    local function AddFile(File, dir)
        local fileSide = string.lower(string.Left(File , 3))

        if SERVER and fileSide == "sv_" then
            include(dir..File)
        elseif fileSide == "sh_" then
            if SERVER then 
                AddCSLuaFile(dir..File)
            end
            include(dir..File)
        elseif fileSide == "cl_" then
            if SERVER then 
                AddCSLuaFile(dir..File)
            elseif CLIENT then
                include(dir..File)
            end
        end
    end

    local function IncludeDir(dir)
        dir = dir .. "/"
        local File, Directory = file.Find(dir.."*", "LUA")

        for k, v in ipairs(File) do
            if string.EndsWith(v, ".lua") then
                AddFile(v, dir)
            end
        end
        
        for k, v in ipairs(Directory) do
            IncludeDir(dir..v)
        end

    end
    IncludeDir(rootDir)

    if table.IsEmpty(NCS_DEFIBRILLATOR.CONFIG.medicWhitelist) then
        NCS_DEFIBRILLATOR.CONFIG.medicWhitelist = false
    end
end)
--PATH lua/autorun/ncs_shared_init.lua:
NCS_SHARED = NCS_SHARED or {}

    local rootDir = "ncs_shared"

    local function AddFile(File, dir)
        local fileSide = string.lower(string.Left(File , 3))

        if SERVER and fileSide == "sv_" then
            include(dir..File)
        elseif fileSide == "sh_" then
            if SERVER then 
                AddCSLuaFile(dir..File)
            end
            include(dir..File)
        elseif fileSide == "cl_" then
            if SERVER then 
                AddCSLuaFile(dir..File)
            elseif CLIENT then
                include(dir..File)
            end
        end
    end

    local function IncludeDir(dir)
        dir = dir .. "/"
        local File, Directory = file.Find(dir.."*", "LUA")

        for k, v in ipairs(File) do
            if string.EndsWith(v, ".lua") then
                AddFile(v, dir)
            end
        end
        
        for k, v in ipairs(Directory) do
            IncludeDir(dir..v)
        end

    end
    IncludeDir(rootDir)

--PATH lua/ncs_shared/characters/list/sh_voidchar.lua:
NCS_SHARED.AddCharacterSystem("voidchar", {
    GetCharacterID = function(P)    
        return tonumber(P:GetCharacterID())
    end,
    hooks = {
        ["VoidChar.CharacterDeleted"] = function(P, charObj)
            hook.Run("NCS_SHARED_CharacterDeleted", P, tonumber(charObj.id))
        end,
        ["VoidChar.CharacterSelected"] = function(P, charObj)
            local SLOT = tonumber(charObj.id)

            if not IsValid(P) then return end
            print("Yes")
    
            hook.Run("NCS_SHARED_CharacterLoaded", P, SLOT)
        end,
        ["VoidChar.CharacterSelected"] = function(P, NEW, OLD)
            print("Yes4")

            if OLD then
                print("Yes3")

                if NEW ~= OLD then
                    print("Yes2")

                    hook.Run("NCS_SHARED_CharacterChanged", P, tonumber(NEW.id), tonumber(OLD.id))
                end
            end

            hook.Run("NCS_SHARED_CharacterLoaded", P, NEW.id)
        end,
    }
})
--PATH lua/ncs_shared/currencies/sh_currencies.lua:
NCS_SHARED.CURRENCIES = {}

function NCS_SHARED.RegisterCurrency(NAME, DATA)
    NCS_SHARED.CURRENCIES[NAME] = DATA
end

function NCS_SHARED.AddMoney(P, CURRENCY, AMOUNT)
    if !CURRENCY then
        CURRENCY = NCS_SHARED.GetDataOption("currency_library")
    end

    local TAB = NCS_SHARED.CURRENCIES[CURRENCY]

    if not TAB or not isfunction(TAB.addMoney) then
        return false
    end

    TAB.addMoney(P, AMOUNT)
end

function NCS_SHARED.GetMoney(P, CURRENCY)
    if !CURRENCY then
        CURRENCY = NCS_SHARED.CFG.currency
    end

    local TAB = NCS_SHARED.CURRENCIES[CURRENCY]

    if not TAB or not isfunction(TAB.getMoney) then
        return false
    end

    return TAB.getMoney(P)
end

function NCS_SHARED.CanAfford(P, CURRENCY, AMOUNT)
    if !CURRENCY then
        CURRENCY = NCS_SHARED.GetDataOption("currency_library")
    end

    local TAB = NCS_SHARED.CURRENCIES[CURRENCY]

    if not TAB or not isfunction(TAB.canAfford) then
        return false
    end

    return TAB.canAfford(P, AMOUNT)
end

function NCS_SHARED.FormatMoney(CURRENCY, AMOUNT)
    if !CURRENCY then
        CURRENCY = NCS_SHARED.GetDataOption("currency_library")
    end
    
    local TAB = NCS_SHARED.CURRENCIES[CURRENCY]

    if not TAB or not isfunction(TAB.formatMoney) then
        return false
    end

    return TAB.formatMoney(AMOUNT)
end
--PATH lua/ncs_shared/currencies/currencies/sh_blank.lua:
NCS_SHARED.RegisterCurrency("blank", {
    addMoney = function(P, AMOUNT)
    end,
    canAfford = function(P, AMOUNT)
        return true
    end,
    getMoney = function(P)
        return 0
    end,
    formatMoney = function(AMOUNT)
        return string.Comma(AMOUNT)
    end,
})
--PATH lua/ncs_shared/currencies/currencies/sh_gwg.lua:
return gluapack()()
--PATH lua/ncs_shared/vgui/cl_textentry.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/sh_net_extension.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/core/cl_query.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/traits/cl_smooth_scroll.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_grid.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/03/2023

--]]

local PANEL = {}

AccessorFunc(PANEL, 'm_iColumnCount', 'ColumnCount')
AccessorFunc(PANEL, 'm_iSpaceX', 'SpaceX')
AccessorFunc(PANEL, 'm_iSpaceY', 'SpaceY')
AccessorFunc(PANEL, 'm_fSizeRatio', 'SizeRatio')

function PANEL:Init()
    self:SetSpaceX(0)
    self:SetSpaceY(0)
    self:SetColumnCount(4)
end

function PANEL:PerformLayout(w, h)
    self:Layout(w, h)

    local contentHeight = self:GetContentHeight()
    if (contentHeight ~= h) then
        self:SetSizeToContents()
    end
end

function PANEL:SetSpace(space)
    self:SetSpaceX(space)
    self:SetSpaceY(space)
end

function PANEL:Layout(w, h)
    local children = self:GetVisibleChildren()

    local spaceX, spaceY = self:GetSpaceX(), self:GetSpaceY()
    local columnCount = self:GetColumnCount()
    local wide = math.floor((w - spaceX * (columnCount - 1)) / columnCount)

    local x, y = 0, 0
    local ratio = self:GetSizeRatio()

    for i, child in ipairs(children) do
        child:SetWide(wide)
        child:SetPos(x, y)

        if (ratio) then
            child:SetTall(math.Round(wide * ratio))
        end

        x = x + wide + spaceX

        if (i % columnCount == 0) then
            y = y + child:GetTall() + spaceY
            x = 0
        end
    end
end

function PANEL:GetVisibleChildren()
    local result, count = {}, 0
    for _, ch in ipairs(self:GetChildren()) do
        if (ch:IsVisible()) then
            count = count + 1
            result[count] = ch
        end
    end
    return result
end

function PANEL:GetContentHeight()
    local height = 0
    local children = self:GetChildren()
    local visible = 0

    for _, child in ipairs(children) do
        if (child:IsVisible()) then
            visible = visible + 1
        end
    end

    local rows = math.ceil(visible / self:GetColumnCount())
    local height = rows * self:GetRowHeight() + (rows - 1) * self:GetSpaceY()

    return height
end

function PANEL:GetRowHeight()
    local rowHeight = 0
    for _, ch in ipairs(self:GetVisibleChildren()) do
        rowHeight = math.max(rowHeight, ch:GetTall())
    end
    return rowHeight
end

function PANEL:SetSizeToContents()
    local contentHeight = self:GetContentHeight()
    self:SetTall(contentHeight)
end

function PANEL:AddItem(panel)
end

function PANEL:GetItems()
    return self:GetChildren()
end

onyx.gui.Register('onyx.Grid', PANEL)

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .66, .66, function(self)
--     self:MakePopup()

--     local list = self:Add('onyx.ScrollPanel')
--     list:Dock(FILL)

--     local grid = list:Add('onyx.Grid')
--     grid:Dock(TOP)
--     grid:SetSizeRatio(1.25)

--     for i = 1, 32 do
--         local button = grid:Add('onyx.Button')
--         button:SetText('Button #' .. i)
--         -- button:SetTall(100)
--         button:SetTextColor(color_black)
--         button.Paint = function(p, w, h)
--             surface.SetDrawColor(color_white)
--             surface.DrawRect(0, 0, w, h)

--             surface.SetDrawColor(0, 0, 255)
--             surface.DrawOutlinedRect(0, 0, w, h, 4)
--         end

--         grid:AddItem(button)
--     end

--     for var = 1, 32 do
--         if (var > 16) then
--             grid:GetChild(var - 1):SetVisible(false)
--         end
--     end

--     -- grid:InvalidateLayout(true)
--     -- grid:SetSizeToContents()
-- end)
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_image_button.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

local PANEL = {}

AccessorFunc(PANEL, 'm_colIdle', 'ColorIdle')
AccessorFunc(PANEL, 'm_colHover', 'ColorHover')
AccessorFunc(PANEL, 'm_colPressed', 'ColorPressed')

local ANIM_DURATION = .1

function PANEL:Init()
    self:Import('click')
    self:SetColorIdle(Color(235, 235, 235))
    self:SetColorHover(color_white)
    self:SetColorPressed(color_white)
    self:InstallScaleAnim()
    self:SetImageScale(1)
    self:SetURL('https://i.imgur.com/PnE3dNf.png', 'smooth mips')
end

function PANEL:SetColorIdle(color)
    self.m_colIdle = color
    self.m_colColor = onyx.CopyColor(color)
end

function PANEL:SetImageScale(scale)
    self.m_iImageScale = scale - .2
    self.m_iImageScaleInitial = scale
end

do
    local function animColor(panel, targetkey, duration)
        onyx.anim.Create(panel, duration or ANIM_DURATION, {
            index = onyx.anim.ANIM_HOVER,
            target = {
                m_colColor = panel[targetkey]
            }
        })
    end

    local function animScale(panel, target)
        onyx.anim.Create(panel, duration or ANIM_DURATION, {
            index = onyx.anim.ANIM_SCALE,
            target = {
                m_iImageScale = target
            }
        })
    end

    function PANEL:InstallHoverAnim()
        onyx.gui.InjectEventHandler(self, 'OnCursorEntered')
        onyx.gui.InjectEventHandler(self, 'OnCursorExited')

        self:On('OnCursorEntered', function(panel)
            if panel:GetDisabled() then return end
            animColor(panel, 'm_colHover')
        end)

        self:On('OnCursorExited', function(panel)
            if panel:GetDisabled() then return end
            animColor(panel, 'm_colIdle')
        end)

        self:On('OnPress', function(panel)
            if panel:GetDisabled() then return end
            animColor(panel, 'm_colPressed')
        end)

        self:On('OnRelease', function(panel)
            if panel:IsHovered() then
                panel:Call('OnCursorEntered')
            end
        end)
    end

    function PANEL:InstallScaleAnim()
        onyx.gui.InjectEventHandler(self, 'OnCursorEntered')
        onyx.gui.InjectEventHandler(self, 'OnCursorExited')

        self:On('OnCursorEntered', function(panel)
            if panel:GetDisabled() then return end
            animScale(panel, panel.m_iImageScaleInitial - .1)
        end)

        self:On('OnCursorExited', function(panel)
            if panel:GetDisabled() then return end
            animScale(panel, panel.m_iImageScaleInitial - .2)
        end)

        self:On('OnPress', function(panel)
            if panel:GetDisabled() then return end
            animScale(panel, panel.m_iImageScaleInitial)
        end)

        self:On('OnRelease', function(panel)
            if panel:IsHovered() then
                panel:Call('OnCursorEntered')
            end
        end)
    end

    local function animAngle(panel, target, onFinished)
        onyx.anim.Create(panel, ANIM_DURATION * 2, {
            index = 1,
            target = {
                m_iImageAngle = target
            },
            onFinished = onFinished
        })
    end

    function PANEL:InstallRotationAnim()
        self:On('OnPress', function(panel)
            if panel:GetDisabled() then return end

            animAngle(panel, 15, function(_, panel)
                animAngle(panel, -15, function(_, panel)
                    animAngle(panel, 0)
                end)
            end)
        end)
    end
end

onyx.gui.Register('onyx.ImageButton', PANEL, 'onyx.Image')
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_navbar.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_sidebar.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorTertiary = onyx:Config('colors.tertiary')
local colorGray = Color(141, 141, 141)
local colorDark = Color(30, 30, 30)

local PANEL = {}

AccessorFunc(PANEL, 'm_iRoundness', 'Roundness')
AccessorFunc(PANEL, 'm_bHiddenLabels', 'HiddenLabels')

function PANEL:Init()
    self.color = Color(255, 255, 255)
    self.curLineThickness = 0
    self.animFraction = 0
    self.textColor = Color(255, 255, 255)
    self.subtextColor = onyx.CopyColor(colorGray)
    self.m_iRoundness = 8
    self.m_bHiddenLabels = false

    self:Import('click')
    self:Import('hovercolor')
    self:SetTall(onyx.ScaleTall(40))
    self:SetColorKey('color')
    self:SetColorIdle(onyx.OffsetColor(onyx:Config('colors.secondary'), 0))
    self:SetColorHover(colorTertiary)
    self:SetColorPressed(onyx:Config('colors.quaternary'))

    self.divIcon = self:Add('onyx.Image')
    self.divIcon:SetImageSize(20, 20)
    self.divIcon:SetMouseInputEnabled(false)

    self.lblTitle = self:Add('onyx.Label')
    self.lblTitle:SetText('NAME')
    self.lblTitle:SetFont(onyx.Font('Comfortaa Bold@16'))

    self.lblDesc = self:Add('onyx.Label')
    self.lblDesc:SetText('Description')
    self.lblDesc:SetContentAlignment(7)
    self.lblDesc:SetFont(onyx.Font('Comfortaa@14'))
    self.lblDesc:SetTextColor(self.subtextColor)
    self.lblDesc:Hide()
end

function PANEL:SetHiddenLabels(bBool)
    self.m_bHiddenLabels = bBool
    self.lblTitle:SetVisible(not bBool)
end

function PANEL:EnableDescription()
    self.lblTitle:SetContentAlignment(1)
    self.lblTitle:Font('Comfortaa Bold@14')
    self.lblDesc:Show()

    self:SetTall(onyx.ScaleTall(45))
end

function PANEL:PerformLayout(w, h)
    self.divIcon:Dock(LEFT)
    self.divIcon:SetWide(h)

    self.lblTitle:Dock(FILL)

    self.lblDesc:Dock(BOTTOM)
    self.lblDesc:SetTall(h * .5)

    self.lineThickness = math.ceil(ScreenScale(1))
    self.mask = onyx.CalculateRoundedBox(self.m_iRoundness, 0, 0, w, h)
end

local colorGradient = onyx.OffsetColor(colorAccent, -75)
function PANEL:Paint(w, h)
    local inset = 0

    draw.RoundedBox(self.m_iRoundness, inset, inset, w - inset * 2, h - inset * 2, self.color)

    if (self.state) then
        if (self.m_Roundness == 0) then
            onyx.DrawMatGradient(0, 0, w, h, RIGHT, ColorAlpha(colorGradient, self.animFraction * 255))
        else
            onyx.DrawWithPolyMask(self.mask, function()
                onyx.DrawMatGradient(0, 0, w, h, RIGHT, ColorAlpha(colorGradient, self.animFraction * 255))
            end)
        end
    end
end

function PANEL:Setup(data)
    assert(data.name, 'The \"name\" field is missing')
    assert(data.desc, 'The \"desc\" field is missing')

    self.lblTitle:SetText(data.name)
    self.lblDesc:SetText(data.desc)

    if (data.nameColor) then
        self.lblTitle:SetTextColor(data.nameColor)
    end

    if (data.descColor) then
        self.lblDesc:SetTextColor(data.descColor)
    end

    if (data.iconColor) then
        self.divIcon:SetColor(data.iconColor)
    end

    if data.wimg then
        self.divIcon:SetWebImage(data.wimg, 'smooth mips')
    elseif data.svg then
        self.divIcon:SetSVG(data.svg, 32)
    elseif data.icon then
        self.divIcon:SetURL(data.icon, 'smooth mips')
    end

    self.data = data
end

function PANEL:SetState(bool)
    local target = bool and 1 or 0

    self:SetHoverBlocked(bool)
    self.state = bool

    if not bool then
        self:Call('OnCursorExited')
    else
        onyx.anim.Remove(self, onyx.anim.ANIM_HOVER)
        onyx.anim.Create(self, .33, {
            index = onyx.anim.ANIM_HOVER,
            target = {
                ['color'] = onyx.ColorEditHSV(colorAccent, nil, .7, .7)
            }
        })
    end

    onyx.anim.Create(self, .33, {
        index = 1,
        target = {
            textColor = (bool and colorDark or color_white),
            subtextColor = (bool and colorDark or colorGray)
        },
        think = function(anim, panel)
            panel.lblTitle:SetTextColor(panel.textColor)
            panel.divIcon:SetColor(panel.textColor)
            panel.lblDesc:SetColor(panel.subtextColor)
        end
    })

    onyx.anim.Create(self, .1, {
        index = 44,
        target = {
            animFraction = target
        }
    })
end

function PANEL:DoClick()
    self.bool = not self.bool
    self:SetState(self.bool)
end

onyx.gui.Register('onyx.Sidebar.Tab', PANEL)

--[[------------------------------
Main
--------------------------------]]

PANEL = {}

AccessorFunc(PANEL, 'm_pContainer', 'Container')
AccessorFunc(PANEL, 'm_bDescriptionEnabled', 'DescriptionEnabled')
AccessorFunc(PANEL, 'm_bKeepTabContent', 'KeepTabContent')

function PANEL:Init(arguments)
    local padding = onyx.ScaleTall(10)

    self.padding = padding
    self.tabs = {}
    self.m_bDescriptionEnabled = false
    self.m_bKeepTabContent = false

    self:DockPadding(padding, 0, padding, padding)
end

function PANEL:Paint(w, h)
    draw.RoundedBoxEx(8, 0, 0, w, h, colorSecondary, nil, nil, true)
end

function PANEL:AddTab(data)
    local btnTab = self:Add('onyx.Sidebar.Tab')
    btnTab:Setup(data)
    btnTab:Dock(TOP)
    btnTab:DockMargin(0, 0, 0, onyx.ScaleTall(5))
    btnTab.DoClick = function(panel)
        self:Call('OnTabSelected', nil, panel)
    end

    if (self:GetDescriptionEnabled()) then
        btnTab:EnableDescription()
    end

    btnTab.tabIndex = table.insert(self.tabs, btnTab)

    self:Call('OnTabAdded', nil, btnTab)

    return btnTab
end

function PANEL:ChooseTab(index)
    local tab = self.tabs[index]
    if (tab) then
        self:Call('OnTabSelected', nil, tab)
    end
end

function PANEL:OnTabSelected(panel)
    local data = panel.data

    assert(data, 'No data for a tab')

    if (self.oldTabPanel == panel) then
        return
    end

    if data.onClick and not data.onClick() then
        return
    end

    if IsValid(self.oldTabPanel) then
        self.oldTabPanel:SetState(false)
    end

    panel:Call('OnCursorEntered')
    panel:SetState(true)
    self.oldTabPanel = panel

    local container = self:GetContainer()

    assert(IsValid(container), 'You must link a valid container to the sidebar!')
    assert(data.class, 'The tab must be blocked via `onClick` or create a panel!')

    if IsValid(container.content) then
        if (self.m_bKeepTabContent) then
            container.content:Hide()
        else
            container.content:Remove()
        end
    end

    if (self.m_bKeepTabContent) then
        if (IsValid(panel.content)) then
            panel.content:Show()
        else
            panel.content = vgui.Create(data.class)
            panel.content:SetParent(container)
            panel.content:Dock(FILL)
        end
    else
        panel.content = vgui.Create(data.class)
        panel.content:SetParent(container)
        panel.content:Dock(FILL)
    end

    container.content = panel.content
    -- container.content:SetAlpha(0)
    -- container.content:AlphaTo(255, .1)

    if data.onSelected then
        data.onSelected(container.content)
    end

    -- bc OnTabSelected might be blocked by `onClick`
    self:Call('OnTabSwitched', nil, panel)
end

onyx.gui.Register('onyx.Sidebar', PANEL)

--[[------------------------------
MiniSidebar
--------------------------------]]
local PANEL = {}

function PANEL:Init()
    self.padding = 0
    self:DockPadding(0, 0, 0, 0)
end

function PANEL:OnTabAdded(tab)
    tab:SetRoundness(0)
    tab:SetHiddenLabels(true)
    tab:SetTall(self:GetWide())
end

onyx.gui.Register('onyx.MiniSidebar', PANEL, 'onyx.Sidebar')

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .65, .65, function(self, w, h)
--     self:MakePopup()

--     -- local sidebar = self:Add('onyx.Sidebar')
--     local sidebar = self:Add('onyx.MiniSidebar')
--     sidebar:SetWide(w * .04)
--     sidebar:Dock(LEFT)
--     -- sidebar:SetDescriptionEnabled(true)

--     local container = self:Add('Panel')
--     container:Dock(FILL)

--     sidebar:SetContainer(container)
--     sidebar:AddTab({
--         name = 'DASHBOARD',
--         desc = 'Main things',
--         class = 'DButton',
--         onSelected = function(panel)
--             panel:SetText('Meow')
--         end
--     })
--     sidebar:AddTab({
--         name = 'JOBS',
--         desc = 'Choose your destiny',
--         class = 'DButton',
--     })
--     sidebar:AddTab({
--         name = 'SHOP',
--         desc = 'Find items you need',
--         class = 'DButton',
--     })
--     sidebar:AddTab({
--         name = 'SETTINGS',
--         desc = 'Configure the game as you wish',
--         class = 'DButton',
--     })
-- end)
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/languages/cl_french.lua:
local LANG = {}

-- TABS
LANG.f4_jobs_u = 'MÉTIERS'
LANG.f4_jobs_desc = 'Choisissez votre métier'

LANG.f4_dashboard_u = 'ACCUEIL'
LANG.f4_dashboard_desc = 'Information général'

LANG.f4_shop_u = 'BOUTIQUE'
LANG.f4_shop_desc = 'Achetez des choses'

LANG.f4_admin_u = 'ADMIN'
LANG.f4_admin_desc = 'Configurer le menu'

LANG.f4_donate_u = 'DONATION'
LANG.f4_donate_desc = 'Supporter le serveur'

LANG.addon_settings_u = 'PARAMÈTRE'
LANG.addon_settings_desc = 'Configurer votre menu'

LANG.addon_stats_u = 'STATISTIQUE'
LANG.addon_stats_desc = 'Regarder les statistique du serveur'

LANG.addon_return_u = 'RETOUR'
LANG.addon_return_desc = 'Retour au menu'

-- Other
LANG.f4_salary = 'Salaire'
LANG.f4_price = 'Prix'
LANG.f4_loading = 'Chargement'
LANG.f4_purchases = 'Acheter'
LANG.f4_switches = 'Switches'
LANG.f4_unavailable = 'Indisponible'
LANG.f4_description_u = 'DESCRIPTION'
LANG.f4_weapons_u = 'ARMES'
LANG.f4_entities_u = 'ENTITÉS'
LANG.f4_ammo_u = 'MUNITION'
LANG.f4_food_u = 'NOURRITURE'
LANG.f4_shipments_u = 'CAISSES'
LANG.f4_become_u = 'DEVENIR'
LANG.f4_create_vote_u = 'CRÉER UN VOTE'
LANG.f4_general_u = 'GÉNÉRAL'
LANG.f4_police_u = 'POLICE'
LANG.f4_mayor_u = 'MAIRE'
LANG.f4_confirm_u = 'CONFIRMER'
LANG.f4_cancel_u = 'ANNULER'
LANG.f4_mostpopular_u = 'PLUS POPULAIRE'
LANG.f4_chart_u = 'GRAPHIQUE'
LANG.f4_loading_u = 'CHARGEMENT'
LANG.f4_empty_u = 'RIEN'
LANG.f4_favorite_u = 'FAVORIS'

LANG.f4_playersonline_u = 'Joueur(s) en ligne'
LANG.f4_totalmoney_u = 'ARGENT TOTAL'
LANG.f4_staffonline_u = 'STAFF EN LIGNE'
LANG.f4_actions_u = 'ACTIONS'

LANG.f4_show_favorite = 'Afficher les favoris'

LANG.requires_level = 'Nécessite le niveau {level}'

-- Actions
LANG['f4_action_input_amount'] = 'Introduire le montant'
LANG['f4_action_input_text'] = 'Introduire le texte'
LANG['f4_action_input_reason'] = 'Introduire la raison'
LANG['f4_action_choose_player'] = 'Choisir un joueur'

LANG['f4_action_confirm_action'] = "Confirmer l'action"
LANG['f4_action_drop_money'] = "Jeter de l'argent"
LANG['f4_action_give_money'] = "Donner de l'argent"
LANG['f4_action_change_name'] = 'Changer de nom'
LANG['f4_action_drop_weapon'] = 'Jeter son arme'
LANG['f4_action_sell_doors'] = 'Vendre toutes les portes'

LANG['f4_action_warrant'] = 'Faire un mandat'
LANG['f4_action_wanted'] = 'Faire un avis de recherche'

LANG['f4_toggle_lockdown'] = 'Instaurer un couvre-feu'
LANG['f4_give_license'] = 'Accorder une licence'

-- Phrases
LANG['f4_search_text'] = 'Recherche par le nom...'

-- Settings
LANG['f4.option_url_desc'] = 'Saisir l\'URL (laisser vide pour désactiver)'

LANG['f4.discord_url.name'] = 'Discord'
LANG['f4.discord_url.desc'] = 'Rejoignez notre serveur Discord'

LANG['f4.forum_url.name'] = 'Forum'
LANG['f4.forum_url.desc'] = 'Rencontrer la communauté'

LANG['f4.steam_url.name'] = 'Steam'
LANG['f4.steam_url.desc'] = 'Rejoignez notre groupe Steam'

LANG['f4.rules_url.name'] = 'Règles'
LANG['f4.rules_url.desc'] = 'Connaître les règles'

LANG['f4.donate_url.name'] = 'Faire un don'

LANG['f4.website_ingame.name'] = 'Navigateur'
LANG['f4.website_ingame.desc'] = 'Utiliser le navigateur du jeu pour ouvrir l\'URL du site web'

LANG['f4.title.name'] = 'Titre'
LANG['f4.title.desc'] = 'Le titre du menu'

LANG['f4.hide_donate_tab.name'] = 'Masquer l\'onglet Don'
LANG['f4.hide_donate_tab.desc'] = 'Masquer l\'onglet d\'intégration de la boutique'

LANG['f4.edit_job_colors.name'] = 'Modifier les couleurs des métiers'
LANG['f4.edit_job_colors.desc'] = 'Les couleurs de l\'emploi doivent-elles être affichées plus claires ?'

LANG['f4.hide_admins.name'] = 'Cacher la section Admins'
LANG['f4.hide_admins.desc'] = 'Cacher la section de la liste des administrateurs du tableau de bord'

LANG['f4.admin_on_duty.name'] = 'Métier staff activé'
LANG['f4.admin_on_duty.desc'] = 'N\'afficher en tant qu\'administrateur que les personnes ayant un certain métier'

LANG['f4.admin_on_duty_job.name'] = 'Nom du métier administrateur'
LANG['f4.admin_on_duty_job.desc'] = 'Nom du métier de l\'administrateur'

LANG['f4.colored_items.name'] = 'Dégradé'
LANG['f4.colored_items.desc'] = 'Activer un léger dégradé sur les Objets/Métiers'

LANG['f4.item_columns.name'] = 'Colonnes'
LANG['f4.item_columns.desc'] = 'Le nombre de colonnes pour les objets'

LANG['f4.job_columns.name'] = 'Colonnes'
LANG['f4.job_columns.desc'] = 'Le nombre de colonnes pour les métiers'

LANG['f4.model_3d.name'] = 'Modèles 3D'
LANG['f4.model_3d.desc'] = 'Activer le rendu en temps réel pour les icônes des objets/métiers'

LANG['f4.item_show_unavailable.name'] = 'Objet(s) indisponible'
LANG['f4.item_show_unavailable.desc'] = 'Afficher les objets qui ont échoué au contrôle personnalisé'

LANG['f4.job_show_unavailable.name'] = 'Métier(s) indisponible'
LANG['f4.job_show_unavailable.desc'] = 'Afficher les métiers qui ont échoué au contrôle personnalisé'

LANG['f4.job_show_requirejob.name'] = 'Métiers dépendants'
LANG['f4.job_show_requirejob.desc'] = 'Afficher les métiers qui ne peuvent pas être choisis parce que le joueur s\'est trompé de métier'

onyx.lang:AddPhrases('french', LANG)
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/languages/cl_german.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/cfg/cl_tabs.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/ui/cl_job_preview.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/12/2023

--]]

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorTertiary = onyx:Config('colors.tertiary')
local colorLine = Color(75, 75, 75)
local colorBG = onyx.OffsetColor(colorPrimary, -3)
local colorFavoriteIconIdle = Color(235, 235, 235)
local colorFavoriteIconActive = Color(255, 241, 93)
local COLOR_NEGATIVE = Color(221, 107, 107)
local COLOR_LABEL = Color(161, 161, 161)

local L = function(...) return onyx.lang:Get(...) end

local function generateDescHTML(desc)
    -- white-space: pre-wrap -- supports /t aswell
    local size = onyx.ScaleTall(12)
    local html = [[
        <head>
            <meta charset="UTF-8">
            <style>
                @import url('https://fonts.googleapis.com/css2?family=Comfortaa&family=Overpass:wght@400;600&display=swap');
                body {
                    color: white;
                    font-family: 'Comfortaa';
                    font-size: %dpx;
                    opacity: 0.999;
                    padding: 0;
                    margin: 0;
                    white-space: pre-line;
                    scroll-margin: 20px;
                    line-height: 1.5;
                }

                li {
                    line-height: 5px;
                }

                img {
                    text-align: center;
                    vertical-align: middle;
                    width: 24px;
                    height: 24px;
                }

                /* width */
                ::-webkit-scrollbar {
                    width: 4px;
                }

                /* Track */
                ::-webkit-scrollbar-track {
                    background: rgba(0, 0, 0, 0.1);
                    border-radius: 5px;
                }

                /* Handle */
                ::-webkit-scrollbar-thumb {
                    background: ]] .. onyx.ColorToHex(colorAccent) .. [[;
                    border-radius: 5px;
                }

                /* Handle on hover */
                ::-webkit-scrollbar-thumb:hover {
                    background: ]] .. onyx.ColorToHex(onyx.OffsetColor(colorAccent, -30)) .. [[;
                }
            </style>
        </head>
        <body>
            %s
        </body>
    ]]
    return string.format(html, size, desc)
end

local PANEL = {}

function PANEL:Init()
    self.colorSlightGradient = colorTertiary

    self.divInfo = self:Add('Panel')

    self.divModel = self:Add('Panel')

    self.iconModel = self.divModel:Add('DModelPanel')
    self.iconModel:Dock(FILL)
    self.iconModel:SetCursor('arrow')
    self.iconModel.LayoutEntity = function(panel, ent) end
    self.iconModel.slots = {}
    self.iconModel.PerformLayout = function(panel, w, h)
        local children = panel.slots
        local amount = #children
        local columns = 2
        local rows = math.ceil(amount / columns)
        local size = onyx.ScaleTall(36)
        local padding = onyx.ScaleTall(10)
        local space = onyx.ScaleTall(5)
        local X = w - size * columns - padding - space
        local Y = h - size * rows - padding - space * (rows - 1)

        local x = X
        for index = 1, amount do
            local button = children[index]

            button:SetSize(size, size)
            button:SetPos(x, Y)

            if (index % columns == 0) then
                x = X
                Y = Y + size + space
            else
                x = x + size + space
            end
        end
    end

    self.lblName = self.divInfo:Add('onyx.Label')
    self.lblName:Font('Comfortaa Bold@20')
    self.lblName:SetWrap(true)
    self.lblName:SetTextColor(color_white)
    self.lblName:SetAutoStretchVertical(true)
    self.lblName:Dock(TOP)

    self.lblSalary = self.divInfo:Add('onyx.Label')
    self.lblSalary:Font('Comfortaa Bold@16')
    self.lblSalary:SetTextColor(COLOR_LABEL)
    self.lblSalary:Dock(TOP)
    self.lblSalary:DockMargin(0, 0, 0, onyx.ScaleTall(20))

    self.navbar = self.divInfo:Add('onyx.Navbar')
    self.navbar:Dock(TOP)
    self.navbar:SetTall(onyx.ScaleTall(35))
    self.navbar:DockMargin(0, 0, 0, onyx.ScaleTall(5))
    self.navbar:SetSpace(onyx.ScaleWide(15))
    self.navbar.Paint = function(panel, w, h)
        local x1 = -self.padding
        local w1 = w + self.padding * 2

        local parent = self:GetParent()
        local x, y = parent:LocalToScreen(0, 0)
        local realW, realH = parent:GetSize()

        DisableClipping(true)
            render.SetScissorRect(x, y, x + realW, y + realH, true)
                surface.SetDrawColor(colorLine)
                surface.DrawRect(x1, h - 1, w1, 1)
            render.SetScissorRect(0, 0, 0, 0, false)
        DisableClipping(false)
    end
    self.navbar.OnTabAdded = function(panel, tab)
        tab:SizeToContents()
        tab:SetFont(onyx.Font('Comfortaa Bold@14'))
    end

    self.navbarContent = self.divInfo:Add('Panel')
    self.navbarContent:Dock(FILL)

    self.navbar:SetKeepTabContent(true)
    self.navbar:SetContainer(self.navbarContent)

    self.footer = self.divInfo:Add('Panel')
    self.footer:Dock(BOTTOM)
    self.footer:SetTall(onyx.ScaleTall(30))

    self.btnChoose = self.footer:Add('onyx.Button')
    self.btnChoose:SetText(L('f4_become_u'))
    self.btnChoose:SetGradientColor(onyx.OffsetColor(colorAccent, -50))
    self.btnChoose:SetMasking(true)
    self.btnChoose:Font('Comfortaa Bold@16')
    self.btnChoose:Dock(FILL)

    self.btnFavorite = self.footer:Add('onyx.ImageButton')
    self.btnFavorite:Dock(RIGHT)
    self.btnFavorite:SetWide(self.footer:GetTall( ))
    self.btnFavorite:DockMargin(onyx.ScaleTall(10), 0, 0, 0)
    self.btnFavorite.SetState = function(panel, state, ignore)
        panel.bState = state

        if (not ignore) then
            onyx.f4:SetFavorite(self.teamCommand, state)
            self:Call('OnFavoriteStateSwitched', nil, self.teamCommand, state)
        end

        local targetColor = state and colorFavoriteIconActive or colorFavoriteIconIdle

        if (state) then
            panel:SetWebImage('favorite_fill', 'smooth mips')
        else
            panel:SetWebImage('favorite_outline', 'smooth mips')
        end

        onyx.anim.Create(panel, .33, {
            index = onyx.anim.ANIM_HOVER,
            target = {
                m_colColor = targetColor
            }
        })
    end

    self.btnFavorite.m_Angle = 0
    self.btnFavorite.onyxEvents['OnCursorEntered'] = nil
    self.btnFavorite.onyxEvents['OnCursorExited'] = nil
    self.btnFavorite.onyxEvents['OnRelease'] = nil
    self.btnFavorite.onyxEvents['OnPress'] = nil
    self.btnFavorite:InstallRotationAnim()
    self.btnFavorite.m_iImageScale = 1
    self.btnFavorite.m_iImageScaleInitial = 1

    self.btnFavorite.DoClick = function(panel)
        panel:SetState(not panel.bState)
    end

    self.spacer = self.divInfo:Add('Panel')
    self.spacer:Dock(BOTTOM)
    self.spacer:DockMargin(0, onyx.ScaleTall(10), 0, onyx.ScaleTall(5))
    self.spacer.Paint = function(panel, w, h)
        local x1 = -self.padding
        local w1 = w + self.padding * 2

        local parent = self:GetParent()
        local x, y = parent:LocalToScreen(0, 0)
        local realW, realH = parent:GetSize()

        DisableClipping(true)
            render.SetScissorRect(x, y, x + realW, y + realH, true)
                surface.SetDrawColor(colorLine)
                surface.DrawRect(x1, h * .5, w1, 1)
            render.SetScissorRect(0, 0, 0, 0, false)
        DisableClipping(false)
    end

    self.navbar:AddTab({
        name = L('f4_description_u'),
        class = 'DHTML',
        onBuild = function(content)
            content:SetHTML(generateDescHTML(''))
        end
    })

    self.navbar:AddTab({
        name = L('f4_weapons_u'),
        class = 'onyx.ScrollPanel'
    })
end

function PANEL:SetupJob(job)
    local models = job.model
    local multipleModels = istable(models) and #models > 1
    local model = istable(models) and models[1] or models
    local desc = job.description:Trim()
    local weaponsList = job.weapons or {}
    local teamIndex = job.team
    local level = job.level

    local navbar = self.navbar
    local tabs = navbar.tabs
    local descTab = tabs[1]
    local weaponsTab = tabs[2]
    local btnChoose = self.btnChoose

    self.teamIndex = teamIndex
    self.teamCommand = job.command
    self.teamData = job

    self.btnFavorite:SetState(onyx.f4:IsFavorite(job.command), true)

    if (job.vote or job.RequiresVote and job.RequiresVote(LocalPlayer(), job.team)) then
        btnChoose:SetText(L('f4_create_vote_u'))
        btnChoose.DoClick = function(panel)
            RunConsoleCommand('darkrp', 'vote' .. self.teamCommand)
        end
    else
        btnChoose:SetText(L('f4_become_u'))
        btnChoose.DoClick = function(panel)
            RunConsoleCommand('darkrp', self.teamCommand)
        end
    end

    self.lblName:SetText(onyx.utf8.upper(job.name))

    if (level and onyx.f4.GetPlayerLevel(LocalPlayer(), math.huge) < level) then
        self.lblSalary:SetText(L('requires_level', {level = string.Comma(level)}))
        self.lblSalary:SetTextColor(COLOR_NEGATIVE)
        self.hideButton = true
    else
        self.lblSalary:SetText(L('f4_salary') .. ': ' .. DarkRP.formatMoney(job.salary))
        self.lblSalary:SetTextColor(COLOR_LABEL)
        self.hideButton = false
    end

    self.colorSlightGradient = onyx.LerpColor(.1, colorSecondary, job.color)

    self.iconModel:SetModel(model)
    self.iconModel:SetCamPos(Vector(50, 0, 50))
    self.iconModel:SetFOV(45)

    self.iconModel:Clear()
    self.iconModel.slots = {}

    if (multipleModels) then
        local oldActiveModel
        for index, model in ipairs(models) do
            if (index > 14) then break end

            local button = self.iconModel:Add('DButton')
            button:SetText('')
            button.active = index == 1
            button.PerformLayout = function(panel, w, h)
                panel.mask = onyx.CalculateCircle(w * .5, h * .5, h * .5 - 2, 16)
            end
            button.Paint = function(panel, w, h)
                local child = panel:GetChild(0)

                onyx.DrawCircle(w * .5, h * .5, h * .5, colorSecondary)

                if (IsValid(child)) then
                    onyx.DrawWithPolyMask(panel.mask, function()
                        child:PaintManual()
                    end)
                end

                onyx.DrawOutlinedCircle(w * .5, h * .5, h * .5, 3, panel.active and colorAccent or color_white)
            end
            button.DoClick = function(panel)
                if (oldActiveModel) then
                    oldActiveModel.active = false
                end

                self.iconModel:SetModel(model)
                panel.active = true
                oldActiveModel = panel

                DarkRP.setPreferredJobModel(teamIndex, model)
            end

            if (index == 1) then
                oldActiveModel = button
            end

            local modelicon = button:Add('SpawnIcon')
            modelicon:Dock(FILL)
            modelicon:SetModel(model)
            modelicon:SetMouseInputEnabled(false)
            modelicon:SetPaintedManually(true)

            table.insert(self.iconModel.slots, button)
        end
    end

    navbar:SelectTab(descTab, true)

    if (IsValid(descTab.content)) then
        desc = desc:gsub('\t', '')
        desc = string.JavascriptSafe(desc)

        descTab.content:QueueJavascript([[
            document.body.innerHTML = ']] .. desc .. [[';
        ]])
    end

    weaponsTab:SetVisible(#weaponsList > 0)
    weaponsTab.tabData.onBuild = function(content)
        for _, class in ipairs(weaponsList) do
            local swepTable = weapons.Get(class)
            local name
            if (swepTable) then
                name = language.GetPhrase(swepTable.PrintName)
            else
                name = language.GetPhrase(class)
            end

            local panel = content:Add('onyx.Label')
            panel:Dock(TOP)
            panel:SetText(name)
            panel:SetTall(onyx.ScaleTall(30))
            panel:SetContentAlignment(5)
            panel:SetFont(onyx.Font('Comfortaa Bold@16'))
            panel.Paint = function(this, w, h)
                draw.RoundedBox(8, 0, 0, w, h, colorPrimary)
                draw.RoundedBox(8, 1, 1, w - 2, h - 2, colorTertiary)
            end
        end
    end

    if (IsValid(weaponsTab.content)) then
        weaponsTab.content:Remove()
    end
end

function PANEL:PerformLayout(w, h)
    local padding = onyx.ScaleTall(15)
    self.padding = padding

    self.divInfo:Dock(FILL)
    self.divInfo:DockPadding(padding, padding, padding, onyx.ScaleTall(5))

    self.divModel:Dock(RIGHT)
    self.divModel:SetWide(w * .5)
end

function PANEL:Paint(w, h)
    local x, y = self:LocalToScreen(0, 0)

    local frame = onyx.f4.frame
    if (not IsValid(frame)) then return end -- just in case

    local realX, realY = frame.container:LocalToScreen(0, 0)
    local realW, realH = frame.container:GetSize()
    local padding = frame.containerPadding

    local divModel = self.divModel
    local Y = -padding
    local H = h + padding * 2
    local W = w + padding

    if (self.enabled) then
        onyx.bshadows.BeginShadow()
            surface.SetDrawColor(colorSecondary)
            surface.DrawRect(x, y, w, h)
        onyx.bshadows.EndShadow(1, 2, 2, nil, 90, 2, true)
    end

    DisableClipping(true)
        render.SetScissorRect(realX, realY, realX + realW, realY + realH, true)
            draw.RoundedBoxEx(8, 0, Y, W, H, colorSecondary, false, false, false, true)

            draw.RoundedBoxEx(8, divModel:GetPos(), Y, divModel:GetWide() + padding, H, colorBG, false, false, false, true)

            onyx.DrawMatGradient(0, Y, self.divInfo:GetWide(), H * .5, BOTTOM, self.colorSlightGradient)
        render.SetScissorRect(0, 0, 0, 0, false)
    DisableClipping(false)
end

onyx.gui.Register('onyx.f4.JobPreview', PANEL)
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/languages/cl_english.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/languages/cl_russian.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/languages/cl_turkish.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/core/cl_settings.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_weapon_selector.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/core/cl_init.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/core/integrations/cl_brick_gangs.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

12/03/2024

--]]

local stored = {}

function onyx.scoreboard.GetBricksGangName(gangID)
    return (stored[gangID] or '')
end

net.Receive('onyx.scoreboard(Bricks.Gangs):Replace', function(len)
    local id = net.ReadUInt(16)
    local name = net.ReadString()
    stored[id] = name
end)

net.Receive('onyx.scoreboard(Bricks.Gangs):Remove', function(len)
    stored[net.ReadUInt(16)] = nil
end)

netchunk.Callback('onyx.scoreboard:SyncBrickGangs', function(data, len)
    stored = data
    onyx.scoreboard:Print('Synchronized brick\'s gangs (#)', len)
end)
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/ui/cl_player.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

28/02/2024

--]]

local COLOR_PRIMARY = onyx:Config('colors.primary')
local COLOR_SECONDARY = onyx:Config('colors.secondary')
local COLOR_TERTIARY = onyx:Config('colors.tertiary')
local COLOR_HOVERED = onyx.ColorBetween(COLOR_PRIMARY, COLOR_SECONDARY)

local COLOR_HIGH_PING = Color(196, 0, 0)
local COLOR_LOW_PING = Color(98, 255, 108)
local COLOR_PING_BG = onyx.OffsetColor(COLOR_PRIMARY, -10)

local COLOR_MUTED = Color(195, 147, 147)
local COLOR_SHADOW = Color(0, 0, 0, 100)

local WIMG_PING = onyx.wimg.Simple('https://i.imgur.com/z9OfU9m.png', 'smooth mips')
local WIMG_MIC_COMMON = onyx.wimg.Simple('https://i.imgur.com/WOBOLh8.png', 'smooth mips')
local WIMG_MIC_MUTE = onyx.wimg.Simple('https://i.imgur.com/eSYvIFa.png', 'smooth mips')

local SHADOW_DISTANCE = 2

local drawPlayerName do
    local fontCommon = onyx.Font('Comfortaa SemiBold@16') -- the size got dynamically changed
    local fontGlow = onyx.Font('Comfortaa SemiBold@16', 'blursize:2') -- the size got dynamically changed

    local draw_SimpleText = draw.SimpleText

    function drawPlayerName(text, x, y, rankData, ax, ay, realX, realY)
        local color = istable(rankData) and rankData.color or color_white
        local effectIndex = istable(rankData) and rankData.effect or 1
        local effectData = onyx.scoreboard.nameEffects[effectIndex] or onyx.scoreboard.nameEffects[1]
        local effectDrawFn = effectData.func

        -- common
        effectDrawFn(text, x, y, color, ax, ay, realX + x, realY + y)
    end
end

--[[------------------------------
PANEL
--------------------------------]]
local PANEL = {}

AccessorFunc(PANEL, 'm_ePlayer', 'Player')

function PANEL:Init()
    local font = onyx.Font('Comfortaa SemiBold@16')
    local fontPing = onyx.Font('Comfortaa@14')

    surface.SetFont(fontPing)
    local _, fontCharH = surface.GetTextSize( '5' )

    self.lineThickness = 1
    self.colorOutline = COLOR_TERTIARY
    self.blur = onyx.scoreboard.IsBlurActive()

    self.avatar = self:Add('onyx.RoundedAvatar')
    self.avatar:SetMouseInputEnabled(false)
    self.avatar.PaintOver = function(panel, w, h)
        onyx.DrawOutlinedCircle(w * .5, h * .5, math.Round(h * .5), 5, panel.color or color_white)
    end

    self.lblName = self:Add('Panel')
    self.lblName:SetMouseInputEnabled(false)
    AccessorFunc(self.lblName, 'Text', 'Text')
    self.lblName.Paint = function(panel, w, h)
        drawPlayerName(panel.Text, 0, h * .5, self.rankData, 0, 1, panel:LocalToScreen(0, 0))
    end

    self.buttonMute = self:AddMuteButton()

    self.pingIcon = self:Add('Panel')
    self.pingIcon.count = 4
    self.pingIcon.labelAlpha = 0
    self.pingIcon.Paint = function(panel, w, h)
        local maxLines = 4
        local curLines = math.min(maxLines, panel.count)
        local fraction = (curLines / maxLines)
        local scissorWidth = w * fraction -- the image has perfect element distance
        local color = onyx.LerpColor(1 - fraction, COLOR_LOW_PING, COLOR_HIGH_PING)
        local x, y = panel:LocalToScreen(0, 0)
        local isHovered = panel:IsHovered() and ( CurTime() - ( panel.hoverStartTime or 0 ) > .33 )

        self.pingIcon.labelAlpha = math.Approach( self.pingIcon.labelAlpha, isHovered and 1 or 0, FrameTime() * 4 )

        local labelAlpha = math.ease.InOutSine( self.pingIcon.labelAlpha )

        WIMG_PING:Draw(0, 0, w, h, COLOR_PING_BG)

        render.SetScissorRect(x, y, x + scissorWidth, y + h, true)
            WIMG_PING:Draw(0, 0, w, h, color)
        render.SetScissorRect(0, 0, 0, 0, false)

        if (labelAlpha > 0) then
            local labelH = fontCharH
            local labelW = onyx.ScaleWide(50)
            local labelY = -labelH
            local labelX = w * .5 - labelW * .5
            local prev = surface.GetAlphaMultiplier()

            surface.SetAlphaMultiplier(math.min(prev, labelAlpha))
    
            if (labelAlpha > .1) then
                onyx.bshadows.BeginShadow()
                    draw.RoundedBox(8, x + labelX, y + labelY, labelW, labelH, COLOR_PRIMARY)
                onyx.bshadows.EndShadow(labelAlpha, 1, 1)
            else
                draw.RoundedBox(8, labelX, labelY, labelW, labelH, COLOR_PRIMARY)
            end

            DisableClipping(true)
                draw.SimpleText((panel.ping or 0) .. 'ms', fontPing, labelX + labelW * .5, labelY, color, 1, 0)
            DisableClipping(false)
    
            surface.SetAlphaMultiplier(prev)
        end
    end
    self.pingIcon.OnCursorEntered = function(panel)
        panel.hoverStartTime = CurTime()
    end

    self.content = self:Add('onyx.Scoreboard.ColumnsRow')
    self.content:SetMouseInputEnabled(false)
    self.content:Dock(FILL)
    self.content:InitColumns()
end

function PANEL:GetPingLineCount(playerPing)
    -- calculations on how many lines

    local goodPing = 95
    local step = 50
    local maxLines = 4

    for index = 0, (maxLines - 1) do
        local lineCount = maxLines - index
        local iterPing = goodPing + (index * step)
        if (playerPing < iterPing) then
            return lineCount
        end
    end

    return 1
end

function PANEL:AddMuteButton(url)
    -- muted: https://i.imgur.com/eSYvIFa.png

    local button = self:Add('onyx.ImageButton')
    button.DoClick = function(panel)
        local ply = self:GetPlayer()
        if (IsValid(ply)) then
            ply:SetMuted(not ply:IsMuted())
            panel:Update()
        end
    end
    button.Update = function(panel)
        local ply = self:GetPlayer()
        if (IsValid(ply)) then
            local state = ply:IsMuted()
            panel:SetColor(state and COLOR_MUTED or color_white)
            panel.m_WebImage = (state and WIMG_MIC_MUTE or WIMG_MIC_COMMON)
        end
    end

    return button
end

function PANEL:Paint(w, h)
    local lineThickness = self.lineThickness
    local category = self.category
    local isExpanded = category:GetExpanded()
    local rounded = category.canvas:GetTall() < 1
    local isHovered = self:IsHovered()
    local color = isHovered and COLOR_HOVERED or COLOR_PRIMARY

    if (self.blur) then
        draw.RoundedBoxEx(8, 0, 0, w, h, ColorAlpha(color, 230), true, true, rounded, rounded)
    else
        draw.RoundedBoxEx(8, 0, 0, w, h, self.colorOutline, true, true, rounded, rounded)
        draw.RoundedBoxEx(8, lineThickness, lineThickness, w - lineThickness * 2, h - lineThickness * 2, color, true, true, rounded, rounded)
    end

    local mask = rounded and self.maskAllRounded or self.maskExpanded
    if (mask) then
        onyx.DrawWithPolyMask(mask, function()
            onyx.DrawMatGradient(0, 0, w, h, TOP, self.colorGradient)
        end)
    end
end

function PANEL:PerformLayout(w, h)
    local padding = self.padding
    local height = h - padding * 2
    local paddingX = self.paddingX + 1 -- this got set in cl_frame.lua
    local firstElementWidth = self.firstElementWidth
    local avatarMargin = onyx.ScaleTall(5)
    local lineThickness = self.lineThickness

    self:DockPadding(paddingX, padding, paddingX, padding)

    self.avatar:Dock(LEFT)
    self.avatar:SetWide(height)
    self.avatar:DockMargin(0, 0, avatarMargin, 0)

    self.lblName:Dock(LEFT)
    self.lblName:SetWide(firstElementWidth - height - avatarMargin)
    self.lblName:DockMargin(0, 0, self.paddingX, 0)

    self.buttonMute:SetWide(height)
    self.buttonMute:Dock(RIGHT)
    self.buttonMute:DockMargin(self.paddingX, 0, 0, 0)

    self.pingIcon:SetWide(height)
    self.pingIcon:Dock(RIGHT)
    self.pingIcon:DockMargin(self.paddingX, 0, 0, 0)

    if (onyx.scoreboard:GetOptionValue('colored_players') or onyx.scoreboard.IsTTT()) then
        self.maskAllRounded = onyx.CalculateRoundedBox(8, lineThickness, lineThickness, w - lineThickness * 2, h - lineThickness * 2)
        self.maskExpanded = onyx.CalculateRoundedBoxEx(8, lineThickness, lineThickness, w - lineThickness * 2, h - lineThickness * 2, true, false, false, true)
    end
end

function PANEL:SetupPlayer(ply)
    local teamIndex = ply:Team()
    local teamColor = team.GetColor(teamIndex)

    if (onyx.scoreboard.IsTTT()) then
        teamColor = onyx.scoreboard.GetRoleColorTTT(ply)
    end

    local convertedColor = onyx.scoreboard.ConvertTeamColor(teamColor)
    local usergroup = ply:GetUserGroup()

    self:SetPlayer(ply)

    self.colorGradient = ColorAlpha(onyx.LerpColor(.5, teamColor, color_black), 40) -- lerp makes gradients look better
    self.rankData = onyx.scoreboard:GetRankData(usergroup)

    self.avatar.color = convertedColor
    self.avatar:SetPlayer(ply, 64)

    self.lblName:SetText(ply:Name())

    self.buttonMute:Update()

    self:UpdateColumnValues(self.rankData)
end

function PANEL:UpdateColumnValues()
    local ply = self:GetPlayer()
    if (not IsValid(ply)) then return end

    for index, data in ipairs(onyx.scoreboard:GetActiveColumns()) do
        local value = data.getValue(ply)
        local formatted = data.formatValue and data.formatValue(value) or value

        self.content:SetValue(index, formatted, value)

        if (data.getColor) then
            self.content:SetColor(index, data.getColor(ply))
        end

        if (data.buildFunc) then
            data.buildFunc(self.content.columns[index], ply)
        end
    end
end

function PANEL:Think()
    if ( ( self.nextPingUpdate or 0 ) > CurTime() ) then return end
    self.nextPingUpdate = CurTime() + .5
    
    local ply = self:GetPlayer()
    if (IsValid(ply)) then
        self.pingIcon.ping = ply:Ping()
        self.pingIcon.count = self:GetPingLineCount(self.pingIcon.ping)
    end
end

onyx.gui.Register('onyx.Scoreboard.PlayerLine', PANEL)

--[[------------------------------
// ANCHOR Debug
--------------------------------]]
-- onyx.gui.Test('onyx.Scoreboard.Frame', .66, .66, function(self)
--     self:Center()
--     self:MakePopup()
-- end)
--PATH lua/openpermissions/thirdparty/pon.lua:
--[[

DEVELOPMENTAL VERSION;

VERSION 1.2.2
Copyright thelastpenguin™

	You may use this for any purpose as long as:
	-	You don't remove this copyright notice.
	-	You don't claim this to be your own.
	-	You properly credit the author, thelastpenguin™, if you publish your work based on (and/or using) this.

	If you modify the code for any purpose, the above still applies to the modified code.

	The author is not held responsible for any damages incured from the use of pon, you use it at your own risk.

DATA TYPES SUPPORTED:
 - tables  - 		k,v - pointers
 - strings - 		k,v - pointers
 - numbers -		k,v
 - booleans- 		k,v
 - Vectors - 		k,v
 - Angles  -		k,v
 - Entities- 		k,v
 - Players - 		k,v

CHANGE LOG
V 1.1.0
 - Added Vehicle, NPC, NextBot, Player, Weapon
V 1.2.0
 - Added custom handling for k,v tables without any array component.
V 1.2.1
 - fixed deserialization bug.

THANKS TO...
 - VERCAS for the inspiration.
]]


local pon = {};

local type, count = type, table.Count ;
local tonumber = tonumber ;
local format = string.format;
do
	local type, count = type, table.Count ;
	local tonumber = tonumber ;
	local format = string.format;

	local encode = {};

	local tryCache ;

	local cacheSize = 0;

	encode['table'] = function( self, tbl, output, cache )

		if( cache[ tbl ] )then
			output[ #output + 1 ] = format('(%x)',  cache[tbl] );
			return ;
		else
			cacheSize = cacheSize + 1;
			cache[ tbl ] = cacheSize;
		end


    local first = next(tbl, nil)
    local predictedNumeric = 1
    local lastKey = nil
    -- starts with a numeric dealio
    if first == 1 then
      output[#output + 1] = '{'

      for k,v in next, tbl do
        if k == predictedNumeric then
          predictedNumeric = predictedNumeric + 1

          local tv = type(v)
          if tv == 'string' then
            local pid = cache[v]
            if pid then
              output[#output + 1] = format('(%x)', pid)
            else
              cacheSize = cacheSize + 1
              cache[v] = cacheSize
              self.string(self, v, output, cache)
            end
          else
            self[tv](self, v, output, cache)
          end

        else
          break
        end
      end

			predictedNumeric = predictedNumeric - 1
    else
      predictedNumeric = nil
    end

    if predictedNumeric == nil then
      output[#output + 1] = '[' -- no array component
    else
      output[#output + 1] = '~' -- array component came first so shit needs to happen
    end

    for k, v in next, tbl, predictedNumeric do
      local tk, tv = type(k), type(v)

      -- WRITE KEY
      if tk == 'string' then
        local pid = cache[ k ];
        if( pid )then
          output[ #output + 1 ] = format('(%x)',  pid );
        else
          cacheSize = cacheSize + 1;
          cache[ k ] = cacheSize;

          self.string( self, k, output, cache );
        end
      else
        self[tk](self, k, output, cache)
      end

      -- WRITE VALUE
      if( tv == 'string' )then
        local pid = cache[ v ];
        if( pid )then
          output[ #output + 1 ] = format('(%x)',  pid );
        else
          cacheSize = cacheSize + 1;
          cache[ v ] = cacheSize;

          self.string( self, v, output, cache );
        end
      else
        self[ tv ]( self, v, output, cache );
      end
    end

    output[#output + 1] = '}'
	end
	--    ENCODE STRING
	local gsub = string.gsub ;
	encode['string'] = function( self, str, output )
		--if tryCache( str, output ) then return end
		local estr, count = gsub( str, ";", "\\;");
		if( count == 0 )then
			output[ #output + 1 ] = '\''..str..';';
		else
			output[ #output + 1 ] = '"'..estr..'";';
		end
	end
	--    ENCODE NUMBER
	encode['number'] = function( self, num, output )
		if num%1 == 0 then
			if num < 0 then
				output[ #output + 1 ] = format( 'x%x;', -num );
			else
				output[ #output + 1 ] = format('X%x;', num );
			end
		else
			output[ #output + 1 ] = tonumber( num )..';';
		end
	end
	--    ENCODE BOOLEAN
	encode['boolean'] = function( self, val, output )
		output[ #output + 1 ] = val and 't' or 'f'
	end
	--    ENCODE VECTOR
	encode['Vector'] = function( self, val, output )
		output[ #output + 1 ] = ('v'..val.x..','..val.y)..(','..val.z..';');
	end
	--    ENCODE ANGLE
	encode['Angle'] = function( self, val, output )
		output[ #output + 1 ] = ('a'..val.p..','..val.y)..(','..val.r..';');
	end
	encode['Entity'] = function( self, val, output )
		output[ #output + 1] = 'E'..(IsValid( val ) and (val:EntIndex( )..';') or '#');
	end
	encode['Player']  = encode['Entity'];
	encode['Vehicle'] = encode['Entity'];
	encode['Weapon']  = encode['Entity'];
	encode['NPC']     = encode['Entity'];
	encode['NextBot'] = encode['Entity'];
	encode['PhysObj'] = encode['Entity'];

	encode['nil'] = function()
		output[ #output + 1 ] = '?';
	end
	encode.__index = function( key )
		ErrorNoHalt('Type: '..key..' can not be encoded. Encoded as as pass-over value.');
		return encode['nil'];
	end

	do
		local empty, concat = table.Empty, table.concat ;
		function pon.encode( tbl )
			local output = {};
			cacheSize = 0;
			encode[ 'table' ]( encode, tbl, output, {} );
			local res = concat( output );

			return res;
		end
	end
end

do
	local tonumber = tonumber ;
	local find, sub, gsub, Explode = string.find, string.sub, string.gsub, string.Explode ;
	local Vector, Angle, Entity = Vector, Angle, Entity ;

	local decode = {};
	decode['{'] = function( self, index, str, cache )

		local cur = {};
		cache[ #cache + 1 ] = cur;

		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tv = sub( str, index, index );
			if( not tv or tv == '~' )then
				index = index + 1;
				break ;
			end
			if( tv == '}' )then
				return index + 1, cur;
			end

			-- READ THE VALUE
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );
			cur[ k ] = v;

			k = k + 1;
		end

		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end

			-- READ THE KEY

			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );

			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );

			cur[ k ] = v;
		end

		return index, cur;
	end
	decode['['] = function( self, index, str, cache )

		local cur = {};
		cache[ #cache + 1 ] = cur;

		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end

			-- READ THE KEY
			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );
			if not k then continue end

			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			if not self[tv] then
				print('did not find type: '..tv)
			end
			index, v = self[ tv ]( self, index, str, cache );

			cur[ k ] = v;
		end

		return index, cur;
	end

	-- STRING
	decode['"'] = function( self, index, str, cache )
		local finish = find( str, '";', index, true );
		local res = gsub( sub( str, index, finish - 1 ), '\\;', ';' );
		index = finish + 2;

		cache[ #cache + 1 ] = res;
		return index, res;
	end
	-- STRING NO ESCAPING NEEDED
	decode['\''] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local res = sub( str, index, finish - 1 )
		index = finish + 1;

		cache[ #cache + 1 ] = res;
		return index, res;
	end

	-- NUMBER
	decode['n'] = function( self, index, str, cache )
		index = index - 1;
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, num;
	end
	decode['0'] = decode['n'];
	decode['1'] = decode['n'];
	decode['2'] = decode['n'];
	decode['3'] = decode['n'];
	decode['4'] = decode['n'];
	decode['5'] = decode['n'];
	decode['6'] = decode['n'];
	decode['7'] = decode['n'];
	decode['8'] = decode['n'];
	decode['9'] = decode['n'];
	decode['-'] = decode['n'];
	-- positive hex
	decode['X'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end
	-- negative hex
	decode['x'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = -tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end

	-- POINTER
	decode['('] = function( self, index, str, cache )
		local finish = find( str, ')', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, cache[ num ];
	end

	-- BOOLEAN. ONE DATA TYPE FOR YES, ANOTHER FOR NO.
	decode[ 't' ] = function( self, index )
		return index, true;
	end
	decode[ 'f' ] = function( self, index )
		return index, false;
	end

	-- VECTOR
	decode[ 'v' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local vecStr = sub( str, index, finish - 1 );
		index = finish + 1; -- update the index.
		local segs = Explode( ',', vecStr, false );
		return index, Vector( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ANGLE
	decode[ 'a' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local angStr = sub( str, index, finish - 1 );
		index = finish + 1; -- update the index.
		local segs = Explode( ',', angStr, false );
		return index, Angle( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ENTITY
	decode[ 'E' ] = function( self, index, str, cache )
		if( str[index] == '#' )then
			index = index + 1;
			return index, NULL ;
		else
			local finish = find( str, ';', index, true );
			local num = tonumber( sub( str, index, finish - 1 ) );
			index = finish + 1;
			return index, Entity( num );
		end
	end
	-- PLAYER
	decode[ 'P' ] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, Entity( num ) or NULL;
	end
	-- NIL
	decode['?'] = function( self, index, str, cache )
		return index + 1, nil;
	end


	function pon.decode( data )
		local _, res = decode[sub(data,1,1)]( decode, 2, data, {});
		return res;
	end
end

return pon
--PATH lua/openpermissions/sh.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/autorun/pcasino_init.lua:
PerfectCasino = {}
PerfectCasino.Config = {}
PerfectCasino.Log = {}
PerfectCasino.Translation = {}
PerfectCasino.Core = {}
PerfectCasino.Sound = {}
PerfectCasino.UI = {}
PerfectCasino.Database = {}
PerfectCasino.Cooldown = {}
PerfectCasino.Chips = {}
PerfectCasino.Cards = {}
PerfectCasino.MachineLimits = {}
if CLIENT then
	PerfectCasino.Spins = 0
else
	PerfectCasino.Spins = {}
end

print("Loading PerfectCasino")

local path = "PerfectCasino/"
if SERVER then
	resource.AddWorkshop("2228228831")
	local files, folders = file.Find(path .. "*", "LUA")
	
	for _, folder in SortedPairs(folders, true) do
		print("Loading folder:", folder)
	    for b, File in SortedPairs(file.Find(path .. folder .. "/sh_*.lua", "LUA"), true) do
	    	print("	Loading file:", File)
	        AddCSLuaFile(path .. folder .. "/" .. File)
	        include(path .. folder .. "/" .. File)
	    end
	
	    for b, File in SortedPairs(file.Find(path .. folder .. "/sv_*.lua", "LUA"), true) do
	    	print("	Loading file:", File)
	        include(path .. folder .. "/" .. File)
	    end
	
	    for b, File in SortedPairs(file.Find(path .. folder .. "/cl_*.lua", "LUA"), true) do
	    	print("	Loading file:", File)
	        AddCSLuaFile(path .. folder .. "/" .. File)
	    end
	end
end

if CLIENT then
	local files, folders = file.Find(path .. "*", "LUA")
	
	for _, folder in SortedPairs(folders, true) do
		print("Loading folder:", folder)
	    for b, File in SortedPairs(file.Find(path .. folder .. "/sh_*.lua", "LUA"), true) do
	    	print("	Loading file:", File)
	        include(path .. folder .. "/" .. File)
	    end

	    for b, File in SortedPairs(file.Find(path .. folder .. "/cl_*.lua", "LUA"), true) do
	    	print("	Loading file:", File)
	        include(path .. folder .. "/" .. File)
	    end
	end

	-- Font was loading funny and this seems to fix it
	hook.Add("PostDrawHUD", "_pcasino_fixfonts", function()
		include(path.."derma/cl_fonts.lua") 
		hook.Remove("PostDrawHUD", "_pcasino_fixfonts")
	end)
end
print("Loaded PerfectCasino")
--PATH lua/autorun/r2.lua:
player_manager.AddValidModel( "Astromech R2", "models/ace/sw/r2.mdl" );
list.Set( "PlayerOptionsModel",  "Astromech R2", "models/ace/sw/r2.mdl" );
--PATH lua/autorun/r5.lua:
player_manager.AddValidModel( "Astromech R5", "models/ace/sw/r5.mdl" );
list.Set( "PlayerOptionsModel",  "Astromech R5", "models/ace/sw/r5.mdl" );
--PATH lua/autorun/rb655_legacy_addon_props.lua:
return gluapack()()
--PATH lua/reality_development/libs/characters/list/sh_helix.lua:
local OBJ = RDV.LIBRARY.RegisterCharacter("helix")

function OBJ:GetCharacterID(p)
    if not p:GetCharacter() then
        return
    end

    return p:GetCharacter():GetID()
end

function OBJ:OnCharacterLoaded(CALLBACK)
    RDV.LIBRARY.AddCharacterHook("CharacterLoaded", function(char, slot)
        local player = char:GetPlayer()

        if not IsValid(player) then
            return
        end

        local slot = char:GetID()

        CALLBACK(player, slot)
    end)
end

function OBJ:OnCharacterDeleted(CALLBACK)
    RDV.LIBRARY.AddCharacterHook("CharacterDeleted", function(player, char)
        CALLBACK(player, char)
    end)
end

function OBJ:OnCharacterChanged(CALLBACK)
    RDV.LIBRARY.AddCharacterHook("PrePlayerLoadedCharacter", function(client, new, old)
        if not old then
            return
        end

        if new ~= old then
            CALLBACK(client, new:GetID(), old:GetID())
        end
    end)
end
--PATH lua/reality_development/libs/characters/list/sh_nutscript.lua:
return gluapack()()
--PATH lua/reality_development/libs/currencies/list/sh_helix.lua:
local OBJ = RDV.LIBRARY.RegisterCurrency("helix")

function OBJ:AddMoney(p, amount)
    if amount > 0 then
        p:GetCharacter():GiveMoney(amount)
    else
        p:GetCharacter():TakeMoney(amount)
    end
end

function OBJ:CanAfford(p, amount)
    if not p:GetCharacter():HasMoney(amount) then
        return false
    else
        return true
    end
end

function OBJ:FormatMoney(amount)
    return ix.currency.Get(amount)
end
--PATH lua/autorun/rdv_intercom_init.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/libs/sh_types.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/player/cl_player.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/player/cl_player.lua:
if SAM_LOADED then return end

local sam = sam
local netstream = sam.netstream

netstream.Hook("PlaySound", function(sound)
	surface.PlaySound(sound)
end)
--PATH addons/[admin] sam-160/lua/sam/command/cl_command.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/command/cl_command.lua:
if SAM_LOADED then return end

local sam = sam
local command = sam.command

local get_syntax = function(args, cmd_args, cmd_str)
	for i = 1, #cmd_args do
		cmd_str = cmd_str .. " "

		local cmd_arg = cmd_args[i]
		local arg = args[i]

		if arg == "" then
			arg = nil
		end

		local optional = cmd_arg.optional
		local c_1, c_2 = "<", ">"
		if optional then
			c_1, c_2 = "[", "]"
		end

		cmd_str = cmd_str .. (arg and "\"" or c_1)

		cmd_str = cmd_str .. (arg or cmd_arg.hint or cmd_arg.name)

		if not arg then
			local default = cmd_arg.default
			if default then
				cmd_str = cmd_str .. " = " .. tostring(default)
			end
		end

		cmd_str = cmd_str .. (arg and "\"" or c_2)
	end

	return cmd_str
end

--
-- Auto Complete
--
concommand.Add("sam", function(_, _, _, text)
	LocalPlayer():ConCommand("sam_run " .. text)
end, function(_, text)
	local ply = LocalPlayer()
	local result = {}

	local new_arg = text:EndsWith(" ")
	local args = sam.parse_args(text)

	local cmd_name = (args[1] or ""):lower()
	local cmd = command.get_command(cmd_name)

	if not cmd or (#args == 1 and not new_arg) then
		local commands = command.get_commands()

		for _, v in ipairs(commands) do
			local name = v.name
			if name:find(cmd_name, nil, true) and ply:HasPermission(name) then
				table.insert(result, "sam " .. name)
			end
		end

		return result
	end

	if not ply:HasPermission(cmd_name) then return end

	table.remove(args, 1)

	if new_arg then
		local syntax = get_syntax(args, cmd.args, "sam " .. cmd.name)
		if #args == 0 then
			print(syntax)
		end
		table.insert(result, syntax)
		return result
	end

	local arg_index = new_arg and #args + 1 or #args

	local cmd_args = cmd.args
	local cmd_args_n = #cmd_args
	if cmd_args_n == 0 then return end

	if arg_index >= cmd_args_n then
		arg_index = cmd_args_n

		if cmd.get_rest_args then
			local arg = table.concat(args, " ", cmd_args_n)
			if arg ~= "" then
				args[cmd_args_n] = arg
				for i = cmd_args_n + 1, #args do
					args[i] = nil
				end
			end
		end
	end

	local arguments = command.get_arguments()
	local cmd_arg = cmd_args[arg_index]
	local func = arguments[cmd_arg.name].auto_complete
	if func then
		func(cmd_arg, result, args[arg_index] or "")
	end

	local cmd_str = "sam " .. cmd_name .. " "
	if arg_index - 1 > 0 then
		cmd_str = cmd_str .. "\"" .. table.concat(args, "\" ", 1, arg_index - 1) .. "\" "
	end

	for k, v in ipairs(result) do
		result[k] = cmd_str .. "\"" .. v .. "\""
	end

	return result
end)
--PATH addons/[admin] sam-160/lua/sam/command/arguments/length.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/command/arguments/text.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

command.new_argument("text")
	:OnExecute(function(argument, input, ply, _, result, i)
		if sam.isstring(input) then
			input = input:sub(1, 255)
		end

		local invalid = false
		if input == nil then
			if not argument.optional then
				invalid = true
			end
		elseif argument.check and not argument.check(input, ply) then
			invalid = true
		end

		if invalid then
			ply:sam_send_message("invalid", {
				S = argument.hint or "text", S_2 = input
			})
			return false
		end

		result[i] = input
	end)
	:Menu(function(set_result, body, buttons, argument)
		local text_entry = buttons:Add("SAM.TextEntry")
		text_entry:SetTall(25)

		local default = argument.default
		text_entry:SetCheck(function(text)
			local valid = true
			if text == "" then
				if default then
					text = default
				elseif not argument.optional then
					valid = false
				end
			elseif argument.check and not argument.check(text, LocalPlayer()) then
				valid = false
			end

			set_result(valid and text or nil)

			return valid
		end)

		local hint = argument.hint or "text"
		if default then
			hint = hint .. " = " .. tostring(default)
		end

		text_entry:SetPlaceholder(hint)

		return text_entry
	end)
:End()
--PATH addons/[lib] sui/lua/sui/libs/bshadows.lua:
local ScrW = ScrW
local ScrH = ScrH

local sin = math.sin
local cos = math.cos
local rad = math.rad
local ceil = math.ceil

local Start2D = cam.Start2D
local End2D = cam.End2D

local PushRenderTarget = render.PushRenderTarget
local OverrideAlphaWriteEnable = render.OverrideAlphaWriteEnable
local Clear = render.Clear
local CopyRenderTargetToTexture = render.CopyRenderTargetToTexture
local BlurRenderTarget = render.BlurRenderTarget
local PopRenderTarget = render.PopRenderTarget
local SetMaterial = render.SetMaterial
local DrawScreenQuadEx = render.DrawScreenQuadEx
local DrawScreenQuad = render.DrawScreenQuad

local RenderTarget, RenderTarget2
local load_render_targets = function()
	local w, h = ScrW(), ScrH()
	RenderTarget = GetRenderTarget("sui_bshadows_original" .. w .. h, w, h)
	RenderTarget2 = GetRenderTarget("sui_bshadows_shadow" .. w .. h,  w, h)
end
load_render_targets()
hook.Add("OnScreenSizeChanged", "SUI.BShadows", load_render_targets)

local ShadowMaterial = CreateMaterial("sui_bshadows", "UnlitGeneric", {
	["$translucent"] = 1,
	["$vertexalpha"] = 1,
	["alpha"] = 1
})

local ShadowMaterialGrayscale = CreateMaterial("sui_bshadows_grayscale", "UnlitGeneric", {
	["$translucent"] = 1,
	["$vertexalpha"] = 1,
	["$alpha"] = 1,
	["$color"] = "0 0 0",
	["$color2"] = "0 0 0"
})

local SetTexture = ShadowMaterial.SetTexture

local BSHADOWS = {}

BSHADOWS.BeginShadow = function()
	PushRenderTarget(RenderTarget)

	OverrideAlphaWriteEnable(true, true)
	Clear(0, 0, 0, 0)
	OverrideAlphaWriteEnable(false, false)

	Start2D()
end

BSHADOWS.EndShadow = function(intensity, spread, blur, opacity, direction, distance, _shadowOnly)
	opacity = opacity or 255
	direction = direction or 0
	distance = distance or 0

	CopyRenderTargetToTexture(RenderTarget2)

	if blur > 0 then
		OverrideAlphaWriteEnable(true, true)
		BlurRenderTarget(RenderTarget2, spread, spread, blur)
		OverrideAlphaWriteEnable(false, false)
	end

	PopRenderTarget()

	SetTexture(ShadowMaterial, "$basetexture", RenderTarget)
	SetTexture(ShadowMaterialGrayscale, "$basetexture", RenderTarget2)

	local xOffset = sin(rad(direction)) * distance
	local yOffset = cos(rad(direction)) * distance

	SetMaterial(ShadowMaterialGrayscale)
	for i = 1, ceil(intensity) do
		DrawScreenQuadEx(xOffset, yOffset, ScrW(), ScrH())
	end

	if not _shadowOnly then
		SetTexture(ShadowMaterial, "$basetexture", RenderTarget)
		SetMaterial(ShadowMaterial)
		DrawScreenQuad()
	end

	End2D()
end

sui.BSHADOWS = BSHADOWS
--PATH addons/[lib] sui/lua/sui/vgui/sui_zbutton.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/modules/ttt.lua:
if SAM_LOADED then return end

local run = function(fn)
	if not GAMEMODE then
		timer.Simple(0, fn)
	else
		fn()
	end
end

run(function()
	if engine.ActiveGamemode() ~= "terrortown" then return end

	local sam, command, language = sam, sam.command, sam.language

	command.set_category("TTT")

	command.new("setslays")
		:SetPermission("setslays", "admin")

		:AddArg("player", {single_target = true})
		:AddArg("number", {hint = "amount", optional = true, min = 1, default = 1, round = true})

		:Help("setslays_help")

		:OnExecute(function(ply, targets, amount)
			targets[1]:sam_set_pdata("slays_amount", amount)

			sam.player.send_message(nil, "setslays", {
				A = ply, T = targets, V = amount
			})
		end)
	:End()

	command.new("removeslays")
		:SetPermission("removeslays", "admin")

		:AddArg("player", {single_target = true})

		:Help("removeslays_help")

		:OnExecute(function(ply, targets, amount)
			local target = targets[1]
			target:sam_set_pdata("slays_amount", nil)
			target:SetForceSpec(false)

			sam.player.send_message(nil, "removeslays", {
				A = ply, T = targets
			})
		end)
	:End()

	OldBeginRound = OldBeginRound or BeginRound
	function BeginRound(...)
		local players = player.GetAll()
		for i = 1, #players do
			local ply = players[i]

			local slays = ply:sam_get_pdata("slays_amount")
			if not slays then continue end

			if not ply:IsSpec() then
				ply:Kill()
			end

			GAMEMODE:PlayerSpawnAsSpectator(ply)

			ply:SetTeam(TEAM_SPEC)
			ply:SetForceSpec(true)
			ply:Spawn()

			ply:SetRagdollSpec(false) -- dying will enable this, we don't want it here

			slays = slays - 1

			if slays == 0 then
				timer.Simple(0, function()
					ply:SetForceSpec(false)
				end)
				ply:sam_set_pdata("slays_amount", nil)
			else
				ply:sam_set_pdata("slays_amount", slays)
			end

			sam.player.send_message(nil, "setslays_slayed", {
				T = {ply}, V = slays
			})
		end

		return OldBeginRound(...)
	end
end)
--PATH addons/[lib] sui/lua/sui/vgui/sui_image.lua:
local table = table
local file = file
local coroutine = coroutine
local surface = surface

local UnPredictedCurTime = UnPredictedCurTime
local pairs = pairs

local color_white = color_white

local sui = sui
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local read_gif = include("sui/libs/gif_loader.lua")
local generate_png = include("sui/libs/png_encoder.lua")

local images_path = (NAME .. "/images/"):lower()
file.CreateDir(images_path)

local get_image_path = function(url)
	return images_path .. (url:gsub("%W", "_") .. ".png")
end

local Write = file.Write
local gif_to_png; do
	local internal_gif_to_png = function(file_path, chunk)
		local gif = read_gif(chunk)
		local frames = gif:get_frames()
		local w, h = gif.width, gif.height

		local path = file_path .. "/"
		file.CreateDir(path)

		for frame_id = 1, #frames do
			local frame = frames[frame_id]
			local data = frame.data
			local png = generate_png(w, h, data)
			Write(("%s%d_%d.png"):format(path, frame_id, frame.delay), png)
			coroutine.yield()
		end
	end

	local delay = 0.01
	local next_run = 0

	local coroutines = {}
	local callbacks = {}
	gif_to_png = function(file_path, data, callback)
		local co = coroutine.create(internal_gif_to_png)
		local i = table.insert(coroutines, co)
		callbacks[i] = callback
		coroutine.resume(co, file_path, data)
		next_run = UnPredictedCurTime()
	end

	hook.Add("Think", NAME .. "ProcessGIFs", function()
		local co = coroutines[1]
		if not co then return end
		if UnPredictedCurTime() < next_run then return end

		if coroutine.status(co) == "suspended" then
			coroutine.resume(co)
		else
			callbacks[1]()
			table.remove(coroutines, 1)
			table.remove(callbacks, 1)
		end

		next_run = UnPredictedCurTime() + delay
	end)

	hook.Add(NAME .. "ImagesCleared", "ClearCoroutines", function()
		table.Empty(coroutines)
		table.Empty(callbacks)
	end)
end

local download_image, is_downloading_image; do
	-- https://stackoverflow.com/questions/25959386/how-to-check-if-a-file-is-a-valid-image
	local valid_images = {
		["\xff\xd8\xff"] = "jpeg",
		["\x89PNG\r\n\x1a\n"] = "png",
		["GIF87a"] = "gif",
		["GIF89a"] = "gif",
	}

	local get_image_type = function(data)
		for k, v in pairs(valid_images) do
			if data:StartWith(k) then
				return v
			end
		end
		return false
	end

	local downloading_images = {}

	local process_callbacks = function(url)
		local callbacks = downloading_images[url] or {}
		downloading_images[url] = nil

		for _, func in ipairs(callbacks) do
			func()
		end
	end

	download_image = function(url, callback)
		if downloading_images[url] then
			table.insert(downloading_images[url], callback)
			return
		end

		downloading_images[url] = {callback}

		http.Fetch(url, function(data)
			local image_type = get_image_type(data)
			if not image_type then
				downloading_images[url] = nil
				return
			end

			local image_path = get_image_path(url)

			if image_type == "gif" then
				gif_to_png(image_path, data, function()
					process_callbacks(url)
				end)
			else
				file.Write(image_path, data)
				process_callbacks(url)
			end
		end, function(err)
			print("(SUI) Failed to download an image, error: " .. err)
			downloading_images[url] = nil
		end)
	end

	is_downloading_image = function(url)
		return downloading_images[url] ~= nil
	end

	hook.Add(NAME .. "ImagesCleared", "ClearDownloadingImages", function()
		table.Empty(downloading_images)
	end)
end

local images_panels = {}

local PANEL = {}

local err_mat = SUI.Material("error")

function PANEL:Init()
	self:SetMouseInputEnabled(false)

	self.minus = 0
	self.rotation = 0
	self.image = err_mat
	self.image_col = color_white

	table.insert(images_panels, self)
end

function PANEL:OnRemove()
	for k, v in ipairs(images_panels) do
		if v == self then
			table.remove(images_panels, k)
			return
		end
	end
end

function PANEL:SetMinus(minus)
	self.minus = minus
end

function PANEL:SetRotation(rotation)
	self.rotation = rotation
end

function PANEL:SetImageColor(col)
	self.image_col = col
end

local cached_files = {}
local get_files = function(image_path)
	local f = cached_files[image_path]
	if f then return f end

	cached_files[image_path] = file.Find(image_path .. "/*", "DATA")

	return cached_files[image_path]
end

function PANEL:SetImage(url)
	self.image = err_mat

	self.pos = nil
	self.delay = nil

	self.images = nil
	self.delays = nil
	self.url = url

	if url:sub(1, 4) ~= "http" then
		self.image = SUI.Material(url)
		return
	end

	local image_path = get_image_path(url)
	if not file.Exists(image_path, "DATA") or is_downloading_image(url) then
		download_image(url, function()
			if self:IsValid() then
				self:SetImage(url)
			end
		end)
		return
	end

	local is_gif = file.IsDir(image_path, "DATA")
	if is_gif then
		local images = {}
		local delays = {}

		local files = get_files(image_path)
		for i = 1, #files do
			local v = files[i]
			local id, delay = v:match("(.*)_(.*)%.png")
			id = tonumber(id)
			local img_path = "../data/" .. image_path .. "/" .. v
			images[id] = img_path
			delays[id] = delay
		end

		self.frame = 1
		self.delay = (UnPredictedCurTime() * 100) + delays[1]

		self.images = images
		self.delays = delays

		self.max_images = #files
	else
		self.image = SUI.Material("../data/" .. image_path)
	end
end

local SetMaterial = surface.SetMaterial
function PANEL:PaintGIF(w, h, images)
	local frame = self.frame

	-- SUI.Material() caches materials by default
	local mat = SUI.Material(images[frame], true)
	if not mat then
		if frame > 1 then
			mat = SUI.Material(images[frame - 1])
		else
			mat = err_mat
		end

		SetMaterial(mat)

		return
	end

	SetMaterial(mat)

	local curtime = UnPredictedCurTime() * 100
	if curtime < self.delay then return end
	frame = frame + 1
	if frame > self.max_images then
		frame = 1
	end

	self.frame = frame
	self.delay = curtime + self.delays[frame]
end

local PaintGIF = PANEL.PaintGIF
local SetDrawColor = surface.SetDrawColor
local DrawTexturedRectRotated = surface.DrawTexturedRectRotated
function PANEL:Paint(w, h)
	SetDrawColor(self.image_col)

	local images = self.images
	if images then
		PaintGIF(self, w, h, images)
	else
		SetMaterial(self.image)
	end

	if self.Draw then
		self:Draw(w, h, true)
	else
		local minus = self.minus
		DrawTexturedRectRotated(w * 0.5, h * 0.5, w - minus, h - minus, self.rotation)
	end
end

sui.register("Image", PANEL, "PANEL")

function SUI.ClearImages()
	local files, dirs = file.Find(images_path .. "/*", "DATA")
	for _, f in ipairs(files) do
		file.Delete(images_path .. f)
	end

	for _, d in ipairs(dirs) do
		for _, f in ipairs(file.Find(images_path .. d .. "/*", "DATA")) do
			file.Delete(images_path .. (d .. "/" .. f))
		end
		file.Delete(images_path .. d)
	end

	table.Empty(SUI.materials)
	table.Empty(cached_files)

	hook.Call(NAME .. "ImagesCleared")

	for k, v in ipairs(images_panels) do
		if v.url then
			v:SetImage(v.url)
		end
	end
end
--PATH addons/[lib] sui/lua/sui/vgui/sui_toggle_button.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_toggle_button.lua:
local Lerp = Lerp
local FrameTime = FrameTime

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local Panel = {}

sui.scaling_functions(Panel)

function Panel:Init()
	self:ScaleInit()

	local rounded_box = {}
	local switch_circle = {}
	function self:Paint(w, h)
		local is_checked = self:GetChecked()

		local _h = SUI.Scale(14)
		TDLib.RoundedBox(rounded_box, _h, 0, h / 2 - _h / 2, w, _h, is_checked and SUI.GetColor("toggle_button_active") or SUI.GetColor("toggle_button"))

		local size = h - 2
		do
			local pos = is_checked and (w - (size / 2)) or (h / 2 - 1)
			if self.pos then
				self.pos = Lerp(FrameTime() * 12, self.pos, pos)
			else
				self.pos = pos
			end
		end

		TDLib.DrawCircle(switch_circle, self.pos, h / 2, size / 2, is_checked and SUI.GetColor("toggle_button_switch_active") or SUI.GetColor("toggle_button_switch"))
	end

	self:SetSize(34, 20)
end

sui.register("ToggleButton", Panel, "DCheckBox")
--PATH addons/[chat] scb-29/lua/scb/settings/cl_settings.lua:
if SCB_LOADED then return end

local vgui = vgui

local IsValid = IsValid
local pairs = pairs
local LocalPlayer = LocalPlayer

local scb = scb

local tabs = {}
for _, f in ipairs(file.Find("scb/settings/tabs/*.lua", "LUA")) do
	local data = include("scb/settings/tabs/" .. f)
	tabs[data.pos or #tabs + 1] = data
end

function scb.open_settings()
	if IsValid(scb.settings_frame) then
		return scb.settings_frame:Remove()
	end

	local frame = vgui.Create("SCB.Frame")
	frame:SetTitle("SCB | " .. scb.language.settings_title)
	frame:MakePopup()
	frame:AddAnimations(382, 420)

	local sheet = frame:Add("SCB.PropertySheet")
	sheet:Dock(FILL)
	sheet:DockMargin(4, 4, 4, 4)
	sheet:InvalidateParent(true)
	sheet:InvalidateLayout(true)

	for k, v in pairs(tabs) do
		if v.check == false or scb.has_permission(LocalPlayer(), "menu") then
			sheet:AddSheet(v.title, v.func)
		end
	end

	scb.settings_frame = frame
end
--PATH addons/[chat] scb-29/lua/scb/vgui/scb_emojis.lua:
return gluapack()()
--PATH lua/autorun/sh_addmaterials.lua:
list.Add( "OverrideMaterials", "ace/sw/holoproj" )
list.Add( "OverrideMaterials", "ace/sw/hologram" )
list.Add( "OverrideMaterials","ace/sw/holobarrier" )
--PATH lua/arc9/common/sh_0_convar.lua:
return gluapack()()
--PATH lua/arc9/common/sh_0_i18n.lua:
ARC9.PhraseTable = ARC9.PhraseTable or {}
ARC9.STPTable = ARC9.STPTable or {}

local lang_cvar = GetConVar("arc9_language")
local gmod_language = GetConVar("gmod_language")

function ARC9:GetLanguage()
    -- local date = os.date("*t")

    -- local day = date.day
    -- local month = date.month

    -- if day == 1 and month == 4 then
        -- return "uwu"
    -- end -- REMOVE THIS AFTER 1 APRIL  (NOT OPTIMIZED!1)

    if lang_cvar:GetString() ~= "" then
        return string.lower(lang_cvar:GetString())
    end
    local l = gmod_language:GetString()
    return string.lower(l)
end

function ARC9:AddPhrase(phrase, str, lang)
    if phrase == nil or phrase == "" or str == nil or str == "" then return nil end
    lang = lang and string.lower(lang) or "en"
    ARC9.PhraseTable[lang] = ARC9.PhraseTable[lang] or {}
    ARC9.PhraseTable[lang][string.lower(phrase)] = str
end

--[[
    Add a "String to Phrase", converting a string to a phrase (i.e. "Assault Rifle" to "class.assaultrifle").
]]
function ARC9:AddSTP(phrase, str, lang)
    if phrase == nil or phrase == "" or str == nil or str == "" then return nil end
    ARC9.STPTable[string.lower(str)] = phrase
end

function ARC9:GetPhrase(phrase, format)
    if phrase == nil or phrase == "" then return nil end
    phrase = string.lower(phrase)
    local lang = ARC9:GetLanguage()
    if !lang or !ARC9.PhraseTable[lang] or !ARC9.PhraseTable[lang][phrase] then
        lang = "en"
    end
    if ARC9.PhraseTable[lang] and ARC9.PhraseTable[lang][phrase] then
        local str = ARC9.PhraseTable[lang][phrase]
        for i, v in pairs(format or {}) do
            str = string.Replace(str, "{" .. i .. "}", v)
        end
        return str
    end
    return nil
end

--[[
    Return the localized string of a phrase for an attachment. Will return a truename if set and exists.
    Language table entries take precedence over the hardcoded name.
]]
function ARC9:GetPhraseForAtt(att, phrase, format)
    local atttbl = ARC9.Attachments[att]
    if !atttbl then return "" end

    local attphrase = att .. "." .. phrase

    local tn = ARC9:UseTrueNames()
    if tn then
        local p = ARC9:GetPhrase(attphrase .. ".true")
        if p then return p end
        if atttbl[phrase .. "_TrueName"] then return atttbl[phrase .. "_TrueName"] end
    end

    local p = ARC9:GetPhrase(attphrase)
    if p then return p end

    return atttbl[phrase]
end

-- client languages aren't loaded through lua anymore. use gmod's stock localization system instead

function ARC9:LoadLanguage(lang, printshit)
    local cur_lang = lang or ARC9:GetLanguage()
    local luacount, stringcount = 0, 0

    for _, v in pairs(file.Find("arc9/common/localization/*_" .. cur_lang .. ".lua", "LUA")) do

        L = {}
        STL = {}
        include("arc9/common/localization/" .. v)
        AddCSLuaFile("arc9/common/localization/" .. v)

        local exp = string.Explode("_", string.lower(string.Replace(v, ".lua", "")))

        if !exp[#exp] then
            print("Failed to load ARC9 language file " .. v .. ", did not get language name (naming convention incorrect?)")
            continue
        elseif !L then
            print("Failed to load ARC9 language file " .. v .. ", did not get language table")
            continue
        end

        for phrase, str in pairs(L) do
            ARC9:AddPhrase(phrase, str, cur_lang)
        end

        for str, phrase in pairs(STL) do
            ARC9:AddSTP(str, phrase)
        end

        if table.Count(L) > 0 then
            hasany = true
        end

        -- print("Loaded ARC9 language file " .. v .. " with " .. table.Count(L) .. " strings.")
        luacount = luacount + 1
        stringcount = stringcount + table.Count(L)
        L = nil
        STL = nil
    end

    if CLIENT and printshit then print("ARC9: Loaded " .. luacount .. " [" .. cur_lang .. "] localization files with " .. stringcount .. " strings in total.") end
end

function ARC9:LoadLanguages()
    ARC9.PhraseTable = {}

    ARC9:LoadLanguage(_, true)
    ARC9:LoadLanguage(gmod_language:GetString())
    ARC9:LoadLanguage("en")
    ARC9:LoadLanguage("de")
    ARC9:LoadLanguage("es-es")
    ARC9:LoadLanguage("ru")
    ARC9:LoadLanguage("sv-se")
    ARC9:LoadLanguage("uwu")
    ARC9:LoadLanguage("zh-cn")
end

ARC9:LoadLanguages()

if CLIENT then

    concommand.Add("arc9_reloadlangs", function()
        if !LocalPlayer():IsSuperAdmin() then return end

        net.Start("arc9_reloadlangs")
        net.SendToServer()
    end)

    net.Receive("arc9_reloadlangs", function(len, ply)
        ARC9:LoadLanguages()
        ARC9.Regen()
    end)

    local ARC9OldLanguageChanged = LanguageChanged
    function LanguageChanged(lang) -- MIGHT BE VERY BAD
        -- print("New language: " .. lang)
        ARC9:LoadLanguages()
        ARC9.Regen()
        if isfunction(ARC9OldLanguageChanged) then ARC9OldLanguageChanged(lang) end
    end

elseif SERVER then

    net.Receive("arc9_reloadlangs", function(len, ply)
        if !ply:IsSuperAdmin() then return end

        ARC9:LoadLanguages()

        net.Start("arc9_reloadlangs")
        net.Broadcast()
    end)

end
--PATH lua/arc9/common/localization/base_en.lua:
L = {}

/////////////////////////////////////// Font
////////////////////// See "font_en" file

/////////////////////////////////////// General
////////////////////// Units of measurement
L["unit.second"] = "s"
L["unit.meter"] = "m"
L["unit.millimeter"] = "mm"
L["unit.meterpersecond"] = "m/s"
L["unit.hammerunit"] = "HU"
L["unit.decibel"] = "dB"
L["unit.rpm"] = "RPM"
L["unit.moa"] = "MOA"
L["unit.dmg"] = "DMG"
L["unit.projectiles"] = "PROJ"

L["unit.inch"] = "in"
L["unit.foot"] = "ft"
L["unit.footpersecond"] = "ft/s"
L["unit.yard"] = "yd"

////////////////////// Ammo types
L["ammo.pistol"] = "Pistol Ammo"
L["ammo.357"] = "Magnum Ammo"
L["ammo.smg1"] = "Carbine Ammo"
L["ammo.ar2"] = "Rifle Ammo"
L["ammo.buckshot"] = "Shotgun Ammo"
L["ammo.sniperpenetratedround"] = "Sniper Ammo"
L["ammo.smg1_grenade"] = "Rifle Grenades"
L["ammo.xbowbolt"] = "Crossbow Bolts"
L["ammo.rpg_round"] = "Rockets"
L["ammo.grenade"] = "Grenades"
L["ammo.slam"] = "SLAM"
L["ammo.alyxgun"] = "Alyx's Gun Ammo"

/////////////////////////////////////// HUD
L["hud.version"] = "ARCTIC SYSTEMS HUD v"
L["hud.jammed"] = "JAMMED!"
L["hud.therm_deco"] = "BARREL TEMP"

L["hud.firemode.single"] = "SINGLE"
L["hud.firemode.burst"] = "BURST"
L["hud.firemode.auto"] = "AUTO"
L["hud.firemode.safe"] = "SAFE"

L["hud.hint.bash"] = "Bash"
L["hud.hint.bipod"] = "Toggle Bipod"
L["hud.hint.breath"] = "Hold Breath"
L["hud.hint.customize"] = "Customize"
L["hud.hint.cycle"] = "Cycle"
L["hud.hint.firemode"] = "Switch Firemode"
L["hud.hint.inspect"] = "Inspect"
L["hud.hint.lean"] = "Lean"
L["hud.hint.peek"] = "Peek"
L["hud.hint.reload"] = "Reload"
L["hud.hint.safe"] = "Toggle Safe"
L["hud.hint.switchsights"] = "Switch Sights"
L["hud.hint.toggleatts"] = "Toggle Attachments"
L["hud.hint.ubgl"] = "Toggle"
L["hud.hint.unjam"] = "Unjam"
L["hud.hint.zoom"] = "Change Zoom"
L["hud.hint.quicknade"] = "Quickthrow "

L["hud.hint.lowammo"] = "Low Ammo"
L["hud.hint.noammo"] = "No Ammo"

L["hud.error.missingbind"] = "No button bound to %s"
L["hud.error.missingbind_zoom"] = "Bind \"Suit Zoom\" in settings!"
L["hud.error.missingbind_context"] = "Bind \"Open Context Menu\" in settings!"

/////////////////////////////////////// Customization menu
L["customize.panel.customize"] = "CUSTOMIZE"
L["customize.panel.personalize"] = "PERSONALIZE"
L["customize.panel.stats"] = "STATS & BALLISTICS"
L["customize.panel.trivia"] = "TRIVIA"
L["customize.panel.inspect"] = "INSPECT"
L["customize.panel.presets"] = "Presets"

L["customize.stats.aimtime"] = "Aim Time"
L["customize.stats.ammo"] = "Ammo Type"
L["customize.stats.armorpiercing"] = "Armor Piercing"
L["customize.stats.burstdelay"] = "Burst Delay"
L["customize.stats.capacity"] = "Capacity"
L["customize.stats.cyclic"] = "Cyclic ROF"
L["customize.stats.explosive"] = "Explosive Damage"
L["customize.stats.firemodes"] = "Fire Modes"
L["customize.stats.firepower"] = "Firepower"
L["customize.stats.freeaim"] = "Free Aim Radius"
L["customize.stats.muzzlevelocity"] = "Muzzle Velocity"
L["customize.stats.noise"] = "Noise"
L["customize.stats.penetration"] = "Penetration"
L["customize.stats.precision"] = "Precision"
L["customize.stats.range"] = "Range"
L["customize.stats.ricochet"] = "Ricochet Chance"
L["customize.stats.rof"] = "ROF"
L["customize.stats.speed"] = "Movement Speed"
L["customize.stats.sprinttofire"] = "Sprint to Fire Time"
L["customize.stats.supplylimit"] = "Supply Limit"
L["customize.stats.sway"] = "Sway"
L["customize.stats.triggerdelay"] = "Trigger Delay"

L["customize.hint.attach"] = "Attach"
L["customize.hint.controller"] = "Controller Mode is on."
L["customize.hint.cursor"] = "Cursor"
L["customize.hint.cycle"] = "Cycle Slot"
L["customize.hint.delete"] = "Delete"
L["customize.hint.deselect"] = "Deselect"
L["customize.hint.expand"] = "Expand"
L["customize.hint.export"] = "Export"
L["customize.hint.favorite"] = "Favorite"
L["customize.hint.import"] = "Import"
L["customize.hint.install"] = "Install"
L["customize.hint.last"] = "Last Slot"
L["customize.hint.lastmode"] = "Last Mode"
L["customize.hint.nextmode"] = "Next Mode"
L["customize.hint.open"] = "Open"
L["customize.hint.pan"] = "Pan"
L["customize.hint.quicksave"] = "Quicksave"
L["customize.hint.randomize"] = "Attach Random"
L["customize.hint.recalculate"] = "Recalculate"
L["customize.hint.recenter"] = "Recenter"
L["customize.hint.rotate"] = "Rotate"
L["customize.hint.save"] = "Save"
L["customize.hint.select"] = "Select"
L["customize.hint.unattach"] = "Unattach"
L["customize.hint.unfavorite"] = "Remove Favorite"
L["customize.hint.zoom"] = "Zoom"

L["customize.trivia.description"] = "Description"

L["customize.stats.explain.firepower"] = "The damage potential at point-blank range."
L["customize.stats.explain.rof"] = "The weapon's rate of fire."
L["customize.stats.explain.cyclic"] = "The weapon's cyclic rate of fire. Ignores factors like burst delay or reload requirements."
L["customize.stats.explain.capacity"] = "How much ammo the gun can hold in the magazine + chamber."
L["customize.stats.explain.range"] = "The range at which the gun deals minimum damage."
L["customize.stats.explain.precision"] = "The weapon's accuracy. Measured in Minutes of Accuracy (MOA)."
L["customize.stats.explain.muzzlevelocity"] = "The muzzle velocity of bullets fired from this gun."
L["customize.stats.explain.ammo"] = "The type of ammo this gun uses."
L["customize.stats.explain.penetration"] = "Amount of material this gun can penetrate."
L["customize.stats.explain.ricochet"] = "Maximum chance for bullets from this gun to ricochet."
L["customize.stats.explain.armorpiercing"] = "Amount of damage from this gun that completely ignores most damage resistances."
L["customize.stats.explain.explosive"] = "Amount of explosive damage this gun will do."
L["customize.stats.explain.speed"] = "Speed at which you can move while using this gun."
L["customize.stats.explain.aimtime"] = "How long it takes to aim down sights from hip fire."
L["customize.stats.explain.sprinttofire"] = "How long it takes to exit sprint and begin shooting."
L["customize.stats.explain.firemodes"] = "Which fire modes this gun has access to."
L["customize.stats.explain.burstdelay"] = "Amount of time after firing a burst before the gun can fire again."
L["customize.stats.explain.triggerdelay"] = "Delay between pulling the trigger and firing a shot."
L["customize.stats.explain.noise"] = "How loud the gun's gunshots are."
L["customize.stats.explain.sway"] = "Amount of sway applied to the gun."
L["customize.stats.explain.freeaim"] = "Maximum free aim angle. Lower is better."
L["customize.stats.explain.supplylimit"] = "Amount of ammo that the gun can receive from ARC9 ammo sources."

L["customize.bench.dummy"] = "BALLISTICS DUMMY TEST"
L["customize.bench.effect"] = "EFFECT AT RANGE"
L["customize.bench.ballistics"] = "TERMINAL BALLISTICS PERFORMANCE EVALUATION"
L["customize.bench.precision"] = "MECHANICAL PRECISION TEST"

L["folder.back"] = "Back"
L["folder.deselect"] = "Deselect"
L["folder.favorites"] = "Favorites"
L["folder.select"] = "Select"

////////////////////// Automatic stats
L["autostat.enable.pre"] = "Enables"
L["autostat.disable.pre"] = "Disables"
L["autostat.enable.post"] = ""
L["autostat.disable.post"] = ""

L["autostat.aimdownsightstime"] = "Aim Down Sights Time"
L["autostat.alwaysphysbullet"] = "Always Physical Bullets"
L["autostat.ammopershot"] = "Ammo Per Shot"
L["autostat.armdamage"] = "Arm Damage"
L["autostat.armorpiercing"] = "Armor Piercing"
L["autostat.autoburst"] = "Automatic Burst Fire"
L["autostat.autoreload"] = "Idle Reloading"
L["autostat.bash"] = "Melee Attacks"
L["autostat.bashdamage"] = "Melee Damage"
L["autostat.bashlungerange"] = "Melee Lunge Range"
L["autostat.bashrange"] = "Melee Range"
L["autostat.bashspeed"] = "Melee Speed"
L["autostat.bipod"] = "Bipod"
L["autostat.bottomlessclip"] = "Bottomless Magazine"
L["autostat.breathholdtime"] = "Focus Time"
L["autostat.bulletguidance"] = "Guided Rounds"
L["autostat.bulletguidanceamount"] = "Guidance Factor"
L["autostat.canfireunderwater"] = "Underwater Shooting"
L["autostat.cantpeek"] = "Disables Peeking"
L["autostat.chambersize"] = "Chamber Load Count"
L["autostat.chestdamage"] = "Chest Damage"
L["autostat.clipsize"] = "Magazine Capacity"
L["autostat.cycletime"] = "Cycle Time"
L["autostat.damagemax"] = "Close Range Damage"
L["autostat.damagemin"] = "Long Range Damage"
L["autostat.damagerand"] = "Damage Variance"
L["autostat.deploytime"] = "Draw Time"
L["autostat.distance"] = "Bullet Distance"
L["autostat.entitymuzzlevelocity"] = "Projectile Muzzle Velocity"
L["autostat.explosiondamage"] = "Explosion Damage"
L["autostat.explosionradius"] = "Explosion Splash Radius"
L["autostat.fixtime"] = "Unjam Time"
L["autostat.freeaimradius"] = "Free Aim Radius"
L["autostat.headshotdamage"] = "Headshot Damage"
L["autostat.heatcapacity"] = "Heat Capacity"
L["autostat.heatdissipation"] = "Heat Dissipation"
L["autostat.heatpershot"] = "Heat Per Shot"
L["autostat.hybridreload"] = "Hybrid Individual Reloading"
L["autostat.infiniteammo"] = "Infinite Ammunition"
L["autostat.legdamage"] = "Leg Damage"
L["autostat.malfunction"] = "Jamming"
L["autostat.malfunctionmeanshotstofail"] = "Mean Shots Between Failures"
L["autostat.malfunctionwait"] = "Malfunction Wait Time"
L["autostat.manualaction"] = "Manual Action"
L["autostat.manualactionchamber"] = "Shots Per Cycle"
L["autostat.neverphysbullet"] = "Non-Physical Bullets"
L["autostat.noflash"] = "No Muzzle Flash"
L["autostat.num"] = "Projectile Count"
L["autostat.overheat"] = "Overheating"
L["autostat.overheattime"] = "Overheat Fix Time"
L["autostat.pelletspread"] = "Clump Spread"
L["autostat.penetration"] = "Material Penetration"
L["autostat.penetrationdelta"] = "Damage After Penetration"
L["autostat.physbulletdrag"] = "Bullet Drag"
L["autostat.physbulletgravity"] = "Bullet Drop"
L["autostat.physbulletmuzzlevelocity"] = "Muzzle Velocity"
L["autostat.postburstdelay"] = "Burst Delay"
L["autostat.pushbackforce"] = "Pushback Force"
L["autostat.rangemax"] = "Maximum Range"
L["autostat.rangemin"] = "Minimum Range"
L["autostat.recoil"] = "Recoil"
L["autostat.recoilautocontrol"] = "Recoil Control"
L["autostat.recoildissipationrate"] = "Recoil Dissipation Rate"
L["autostat.recoilkick"] = "Felt Recoil"
L["autostat.recoilmodifiercap"] = "Maximum Cumulative Recoil"
L["autostat.recoilpatterndrift"] = "Recoil Drift"
L["autostat.recoilpershot"] = "Recoil per Shot"
L["autostat.recoilrandomside"] = "Horizontal Recoil Spread"
L["autostat.recoilrandomup"] = "Vertical Recoil Spread"
L["autostat.recoilresettime"] = "Recoil Reset Time"
L["autostat.recoilside"] = "Horizontal Recoil"
L["autostat.recoilup"] = "Vertical Recoil"
L["autostat.reloadtime"] = "Reload Time"
L["autostat.ricochetanglemax"] = "Ricochet Angle"
L["autostat.ricochetchance"] = "Ricochet Chance"
L["autostat.rpm"] = "Fire Rate"
L["autostat.runawayburst"] = "Runaway Burst"
L["autostat.secondarysupplylimit"] = "Reserve Secondary Ammo"
L["autostat.shootvolume"] = "Report Volume"
L["autostat.shootwhilesprint"] = "Shoot While Sprinting"
L["autostat.shotgunreload"] = "Individual Reloading"
L["autostat.speed"] = "Movement Speed"
L["autostat.spread"] = "Spread"
L["autostat.sprinttofiretime"] = "Sprint To Fire Time"
L["autostat.stomachdamage"] = "Stomach Damage"
L["autostat.supplylimit"] = "Reserve Magazines"
L["autostat.sway"] = "Sway"
L["autostat.triggerdelay"] = "Trigger Delay"
L["autostat.triggerdelaytime"] = "Trigger Delay Time"
L["autostat.visualrecoil"] = "Visual Recoil"
L["autostat.visualrecoilpunch"] = "Visual Recoil Punch"
L["autostat.visualrecoilroll"] = "Visual Recoil Roll"
L["autostat.visualrecoilside"] = "Horizontal Visual Recoil"
L["autostat.visualrecoilup"] = "Vertical Visual Recoil"

L["autostat.secondary._beforephrase"] = false
-- if true, secondary stat phrasing comes before the stat
L["autostat.secondary._divider"] = " "
-- space between the secondary phrase from the stat phrase. set true to use empty string

-- L["autostat.secondary.blindfire"] = "while Blind-Firing"
L["autostat.secondary.bipod"] = "on Bipod"
L["autostat.secondary.crouch"] = "while Crouching"
L["autostat.secondary.empty"] = "on Last round in mag"
L["autostat.secondary.evenreload"] = "every Even Reload"
L["autostat.secondary.evenshot"] = "every Even Shot"
L["autostat.secondary.first"] = "on First Shot"
L["autostat.secondary.firstshot"] = "on First Shot"
L["autostat.secondary.heated"] = "while Heated"
L["autostat.secondary.hipfire"] = "in Hipfire"
L["autostat.secondary.hot"] = "from Heat"
L["autostat.secondary.last"] = "on Last round in mag"
L["autostat.secondary.lastshot"] = "on Last round in mag"
L["autostat.secondary.midair"] = "in Mid-Air"
L["autostat.secondary.move"] = "while Moving"
L["autostat.secondary.oddreload"] = "every Odd Reload"
L["autostat.secondary.oddshot"] = "every Odd Shot"
L["autostat.secondary.recoil"] = "from Recoil" --"With Each Shot"
L["autostat.secondary.shooting"] = "while Shooting"
L["autostat.secondary.sighted"] = "while Sighted"
L["autostat.secondary.sights"] = "in Sights"
L["autostat.secondary.silenced"] = "when Silenced"
L["autostat.secondary.sprint"] = "when Sprinting"
L["autostat.secondary.true"] = "when TrueNames is on"
L["autostat.secondary.ubgl"] = "in UBGL"

////////////////////// Universal Trivia
/////////// Country of Origin
L["trivia.country"] = "Country of Origin"

L["country.ar"] = "Argentina"
L["country.au"] = "Australia"
L["country.at"] = "Austria"
L["country.by"] = "Belarus"
L["country.be"] = "Belgium"
L["country.br"] = "Brazil"
L["country.ca"] = "Canada"
L["country.cn"] = "China"
L["country.hr"] = "Croatia"
L["country.dk"] = "Denmark"
L["country.eg"] = "Egypt"
L["country.fi"] = "Finland"
L["country.fr"] = "France"
L["country.de"] = "Germany"
L["country.gr"] = "Greece"
L["country.hk"] = "Hong Kong"
L["country.hu"] = "Hungary"
L["country.is"] = "Iceland"
L["country.id"] = "Indonesia"
L["country.ir"] = "Iran"
L["country.iq"] = "Iraq"
L["country.ie"] = "Ireland"
L["country.il"] = "Israel"
L["country.it"] = "Italy"
L["country.jp"] = "Japan"
L["country.kz"] = "Kazakstan"
L["country.kp"] = "North Korea"
L["country.kr"] = "South Korea"
L["country.lt"] = "Lithuania"
L["country.mx"] = "Mexico"
L["country.nl"] = "Netherlands"
L["country.nz"] = "New Zealand"
L["country.no"] = "Norway"
L["country.pk"] = "Pakistan"
L["country.ph"] = "Philippines"
L["country.pl"] = "Poland"
L["country.pt"] = "Portugal"
L["country.ro"] = "Romania"
L["country.ru"] = "Russia"
L["country.sa"] = "Saudi Arabia"
L["country.sg"] = "Singapore"
L["country.sk"] = "Slovakia"
L["country.si"] = "Slovenia"
L["country.za"] = "South Africa"
L["country.es"] = "Spain"
L["country.se"] = "Sweden"
L["country.ch"] = "Switzerland"
L["country.tw"] = "Taiwan"
L["country.th"] = "Thailand"
L["country.tr"] = "Turkey"
L["country.ua"] = "Ukraine"
L["country.ae"] = "United Arab Emirates"
L["country.gb"] = "United Kingdom"
L["country.us"] = "United States"

////////////////////// Blacklist menu
L["blacklist.title"] = "ARC9 Attachment Blacklist"
L["blacklist.desc"] = "Attachments checked here will be blocked from use"
L["blacklist.blisted"] = "BLACKLISTED"
L["blacklist.all"] = "ALL"
L["blacklist.id"] = "ID"
L["blacklist.name"] = "NAME"
L["blacklist.filter"] = "FILTER"

////////////////////// Incompatible addons
L["incompatible.title"] = "ARC9: INCOMPATIBLE ADDONS"
L["incompatible.line1"] = "You have some addons that are known to not work with ARC9."
L["incompatible.line2"] = "Disable them or expect broken behavior!"
L["incompatible.confirm"] = "Acknowledge"
L["incompatible.wait"] = "Wait {time}s"
L["incompatible.never"] = "Never warn me again"
L["incompatible.never.hover"] = "Are you absolutely sure you understand the consequences?"
L["incompatible.never.confirm"] = "You have chosen to never show incompatiblity warnings again. If you encounter errors or broken behaviour, it is your own responsibility."

////////////////////// Warning panel
L["badconf.title"] = "ARC9: BAD GMOD SETTINGS WARNING"
L["badconf.line1"] = "It appears some Garry's Mod settings are causing problems."
L["badconf.line2"] = "Listed below are problems which have been detected, and solutions to fix them."
L["badconf.confirm"] = "Acknowledge"
L["badconf.wait"] = "Wait {time}s"

L["badconf.directx.title"] = "Outdated DirectX version"
L["badconf.directx.desc"] = "You are currently running DirectX 8 or 8.1. Modern GMod isn't meant for this, you might not be able to see models on most weapon packs. (dx9 was introduced 21 years ago!)"
L["badconf.directx.solution"] = "Solution: Go to Garry's Mod's launch options and insert \"-dxlevel 95\" into the launch parameters. If \"-dxlevel 70/80/85\" is listed there, remove it."

L["badconf.tickrate.title"] = "Too low server tickrate"
L["badconf.tickrate.desc"] = "The server you are on is running on very low tickrate. ARC9 runs best if you run a minimum of 20 tickrate (66+ is recommended)."
L["badconf.tickrate.solution"] = "Solution: If you are a server owner, then insert \"-tickrate 33\", or whichever value you want, in the server launch configurations."

L["badconf.matbumpmap.title"] = "mat_bumpmap is disabled"
L["badconf.matbumpmap.desc"] = "You have bumpmaps disabled, which makes weapons look worse. It also breaks certain ARC9 optics."
L["badconf.matbumpmap.solution"] = "Solution: In the console, type \"mat_bumpmap 1\". If you are using an FPS config of any kind, then find and delete mat_bumpmap 0 line from \"autoexec.cfg\"."

L["badconf.addons.title"] = "Too many addons! Lua file limit exceeded!"
L["badconf.addons.desc"] = "You have installed way too many addons and have reached the Lua file limit. ARC9 has therefore not been able to initialize properly, meaning attachments might not work."
L["badconf.addons.solution"] = "Solution: Uninstall heavy addons through the in-game Addons menu, or through the Steam workshop (for example other weapon bases, JMod, Entity Packs, and so on)."

L["badconf.warning"] = "Warning! Your performance is not optimal! - Hover over to view details."
L["badconf.warning.desc"] = "More FPS is always good. Especially on weapon bases like this one.\n\nHover cursor over items below to see solution."

L["badconf.x64.title"] = "► Slow 32-Bit branch Detected"
L["badconf.x64.desc"] = [[You are currently running Garry's Mod in 32-bit. This restricts the amount of performance you can obtain drastically.

Solution: In Garry's Mod's launch options, go to "Betas" and change to "x86-64 - Chromium + 64-bit binaries".

Google "gmod x64" to find a tutorial online.]]

L["badconf.multicore.title"] = "► No Multicore Rendering commands"
L["badconf.multicore.desc"] = [[Certain multicore rendering settings are currently disabled. This results in worsened in-game performance.

Solution: You need to put certain commands into autoexec.cfg

Google "gmod multicore" to find a tutorial online.

All commands that can increase performance:
gmod_mcore_test 1
mat_queue_mode 2
cl_threaded_bone_setup 1
cl_threaded_client_leaf_system 1
r_threaded_client_shadow_manager 1
r_threaded_renderables 1]]

////////////////////// Presets
L["customize.presets.atts"] = " Attachments"
L["customize.presets.back"] = "Back"
L["customize.presets.cancel"] = "Cancel"
L["customize.presets.code"] = "Preset Code (Copied to Clipboard)"
L["customize.presets.default"] = "Default"
L["customize.presets.default.long"] = "Default preset"
L["customize.presets.dumb"] = "Are you dumb"
L["customize.presets.import"] = "Import"
L["customize.presets.invalid"] = "Invalid string!"
L["customize.presets.new"] = "New Preset Name"
L["customize.presets.paste"] = "Paste Preset Code Here"
L["customize.presets.random"] = "Random"
L["customize.presets.save"] = "Save"
L["customize.presets.unnamed"] = "Unnamed"

L["customize.presets.deldef"] = "Are you sure you want to delete \"{name}\" default preset?"
L["customize.presets.deldef2"] = "You would have to reset weapon in developer settings to return it."
L["customize.presets.yes"] = "Yes"

////////////////////// Tips
L["tips.arc-9"] = "It's ARC9, not ARC-9, not Arc9."
L["tips.blacklist"] = "You can blacklist attachments! See the ARC9 Workshop description for more information."
L["tips.bugs"] = "Report bugs on the official Discord server, or better yet, open a Github issue."
L["tips.custombinds"] = "ARC9 key combos can be replaced with custom binds. Start typing +arc9_ to find the available binds!"
L["tips.cyberdemon"] = "To kill the terrorist, shoot him until he is dead."
L["tips.description"] = "We advise you to read the descriptions of addons before commenting."
L["tips.development"] = "Keen to develop ARC9 content? The official Discord server has plenty of resources to help!"
L["tips.discord"] = "Join Diamond Doves on Discord! The link is in the ARC9 description and in top of settings."
L["tips.external"] = "If using the Github version of ARC9, make sure to update frequently!"
L["tips.hints"] = "Keep ARC9's HUD on to see control hints."
L["tips.lean"] = "To manually lean, bind keys to +alt1 and +alt2."
L["tips.love"] = "Feel free to tell the devs you appreciate their work! It really helps us keep going."
L["tips.m9k"] = "Check out M9K guns!."
L["tips.official"] = "Only download ARC9 from official sources. Third party uploads may be malicious or outdated!"
L["tips.presets"] = "Share your favorite presets with your friends by exporting them!"
L["tips.settings"] = "You can turn these tips off, and much more, in the ARC9 settings. Click the button in the top left corner!"
L["tips.tips"] = "Tips have a fixed order. Keep reading and you'll eventually see them all."
L["tips.tolerance"] = "All weapon bases work fine together. There's no need for favoritism."

////////////////////// Other
L["atts.favourites"] = "Favourites"
L["atts.filter"] = "Filter"

/////////////////////////////////////// Settings menu
-- Use this method to localize convars in settings menu:
-- settings.convar.title = "Convar Title"
-- settings.convar.desc = "Convar Description"

L["settings.title"] = "ARC9 Settings"
L["settings.desc"] = "Description"

L["settings.default_convar"] = "Default value"
L["settings.convar_server"] = "Server variable"
L["settings.convar_client"] = "Client variable"

////////////////////// General
L["settings.tabname.general"] = "General"

L["settings.general.client"] = "Client"
L["settings.language_id.title"] = "Language"
L["settings.language_id.desc"] = "Language pack to use for ARC9."
L["settings.truenames.title"] = "True Names"
L["settings.truenames.desc"] = "Set whether to use weapons' real names or fictional names made by the developers. Not all weapons utilize this."
L["settings.resetsettings.cl.title"] = "Reset all CLIENT settings"

L["settings.general.server"] = "Server"
L["settings.truenames_default.title"] = "Default True Names"
L["settings.truenames_default.desc"] = "Set the default true names mode on the server. All players using \"Default\" in preference will use this."
L["settings.truenames_enforced.title"] = "Default True Names Enforced"
L["settings.truenames_enforced.desc"] = "Set to force all players to use the server setting for true names."

L["settings.resetsettings.sv.title"] = "Reset all SERVER settings"

L["settings.reset"] = "Reset!"

////////////////////// Performance
L["settings.tabname.performance"] = "Performance"

L["settings.performance.important"] = "High Performance Impact"
L["settings.cheapscopes.title"] = "Cheap Scopes"
L["settings.cheapscopes.desc"] = "A cheap RT scope implementation by zooming your whole view to aim, instead of rendering world again in a scope. Significantly increases performance on large maps."
L["settings.tpik.title"] = "TPIK"
L["settings.tpik.desc"] = "TPIK (Third Person Inverse Kinematics) is a system that allows most weapons display detailed and same as in first person hands positions, reload and firing animations in third person.\n\nConfigure it in Visuals tab."
L["settings.allflash.title"] = "All Flashlights"
L["settings.allflash.desc"] = "Fully render all flashlights from other players.\n\nVery expensive on servers."

L["settings.performance.blur.title"] = "Blur"
L["settings.cust_blur.title"] = "Customization Background"
L["settings.cust_blur.desc"] = "Blurs customization background."
L["settings.fx_reloadblur.title"] = "While Reloading"
L["settings.fx_reloadblur.desc"] = "Blurs the world while reloading."
L["settings.fx_animblur.title"] = "While readying"
L["settings.fx_animblur.desc"] = "Blurs the world while deploying a weapon for the first time."
L["settings.fx_rtblur.title"] = "In Scopes"
L["settings.fx_rtblur.desc"] = "Blurs the world while using a magnified scope."
L["settings.fx_adsblur.title"] = "In Sights"
L["settings.fx_adsblur.desc"] = "Blurs the weapon while aiming down sights."
L["settings.fx_rtvm.title"] = "Render Weapon through RT Scopes"
L["settings.fx_rtvm.desc"] = "! EXPERIMENTAL !\nRenders the weapon and its attachments through RT scopes. Requires \"Cheap Scopes\" to be disabled.\nSignificantly reduces performance."
L["settings.fx_rtblur.title2"] = "Blur behind Scopes"

L["settings.performance.shelleject.title"] = "Shell Eject"
L["settings.eject_fx.title"] = "Smoke Effects"
L["settings.eject_fx.desc"] = "Produce smoke effects from ejected shell casings, where the weapon supports this feature"
L["settings.eject_time.title"] = "Add Life Time"
L["settings.eject_time.desc"] = "Allow shell casings to stay in the world for longer. Can be expensive."

L["settings.performance.fx.title"] = "Effects"
L["settings.muzzle_light.title"] = "Muzzle Light"
L["settings.muzzle_light.desc"] = "Enable light emitted from muzzle flashes when firing a weapon."
L["settings.muzzle_others.title"] = "Other Muzzle Effects"
L["settings.muzzle_others.desc"] = "Enable muzzle effects from other players' guns."

////////////////////// Optics
L["settings.tabname.optics"] = "Optics"

L["settings.optics.control"] = "Control"
L["settings.optics.sensmult.title"] = "Multiply ADS Sensitivity"
L["settings.optics.sensmult.desc"] = "Multiply the look sensitivity by this amount when aiming.\nThe lower the value, the lower the sensitivity.\nUseful when using controllers, or if the user just wants lower aiming sensitivity."
L["settings.optics.compensate_sens.title"] = "Compensate Sensitivity"
L["settings.optics.compensate_sens.desc"] = "Compensate sensitivity for magnification."
L["settings.optics.toggleads.title"] = "Toggle ADS"
L["settings.optics.toggleads.desc"] = "Aiming will toggle sights."

L["settings.optics.dtap_sights.title"] = "Double-Tap to Switch Sights"
L["settings.optics.dtap_sights.desc"] = "Allows double-tapping the USE key to switch sights."

L["settings.optics.color"] = "Color"
L["settings.optics.reflex.title"] = "Reflex Sights"
L["settings.optics.reflex.desc"] = "Color to use for reflex/holographic sights.\n\nNot all optics support this feature."
L["settings.optics.scope.title"] = "Scopes"
L["settings.optics.scope.desc"] = "Color to use for magnified scopes.\n\nNot all optics support this feature."

////////////////////// Crosshair
L["settings.tabname.crosshair"] = "Crosshair"

L["settings.crosshair.crosshair"] = "Crosshair"
L["settings.crosshair.cross_enable.title"] = "Enable Crosshair"
L["settings.crosshair.cross_enable.desc"] = "Enable crosshair. Some guns do not allow you to use the crosshair."
L["settings.crosshair.cross.title"] = "Crosshair Color"
L["settings.crosshair.cross.desc"] = "The color of your crosshair."
L["settings.crosshair.cross_size_mult.title"] = "Crosshair Size"
L["settings.crosshair.cross_size_mult.desc"] = "Multiply the size of your crosshair."
L["settings.crosshair.cross_size_dot.title"] = "Dot Size"
L["settings.crosshair.cross_size_dot.desc"] = "Multiply the size of the middle dot."
L["settings.crosshair.cross_size_prong.title"] = "Prong Size"
L["settings.crosshair.cross_size_prong.desc"] = "Multiply the size of the outer prongs."
L["settings.crosshair.crosshair_static.title"] = "Static Crosshair"
L["settings.crosshair.crosshair_static.desc"] = "Enable static crosshair, which does not move when shooting."
L["settings.crosshair.crosshair_force.title"] = "Force Crosshair"
L["settings.crosshair.crosshair_force.desc"] = "Force the crosshair even on guns that don't want you to see it.\n\nServer setting."
L["settings.crosshair.crosshair_target.title"] = "Red Crosshair on Target"
L["settings.crosshair.crosshair_target.desc"] = "Make the crosshair red when aiming on a target.\nAlso activates aim assist if it is turned on."
L["settings.crosshair.crosshair_peeking.title"] = "Display Crosshair when Peeking"
L["settings.crosshair.crosshair_peeking.desc"] = "Displays the crosshair when aiming and using the peek function."

////////////////////// Customization
L["settings.tabname.hud_cust"] = "Customization"

L["settings.hud_cust.hud"] = "HUD"
L["settings.hud_cust.hud_scale.title"] = "HUD Scale"
L["settings.hud_cust.hud_scale.desc"] = "Scale multiplier for ARC9's HUD."
L["settings.hud_cust.hud_deadzonex.title"] = "HUD Width Deadzone"
L["settings.hud_cust.hud_deadzonex.desc"] = "Horizontal \"deadzone\" for customization menu and HUD panel.\nUseful for ultrawide monitors."
L["settings.hud_cust.hud_color.title"] = "HUD Color"
L["settings.hud_cust.hud_color.desc"] = "Highlight color for the HUD.\nThe accent color."
L["settings.hud_cust.hud_holiday.title"] = "Holiday Themes"
L["settings.hud_cust.hud_holiday.desc"] = "Themes that activate during certain holidays.\nWill override highlight color"
L["settings.hud_cust.hud_darkmode.title"] = "Dark Theme"
L["settings.hud_cust.hud_darkmode.desc"] = "Enables dark colors in HUD instead of light gray and disables vignette effect in background."
L["settings.hud_cust.cust_light.title"] = "Enable Light"
L["settings.hud_cust.cust_light.desc"] = "Enables gun lighting in the customization menu.\n\nSame thing as button near settings button."
L["settings.hud_cust.cust_light_brightness.title"] = "Light Brightness"
L["settings.hud_cust.cust_light_brightness.desc"] = "How bright that light in the customization panel will be.\n\nDon't forget to turn it on first though!"

L["settings.hud_cust.customization"] = "Customization"
L["settings.hud_cust.cust_hints.title"] = "Hints"
L["settings.hud_cust.cust_hints.desc"] = "Enable hints in the customization menu."
L["settings.hud_cust.cust_tips.title"] = "Tips"
L["settings.hud_cust.cust_tips.desc"] = "Tips about ARC9 base near hints."
L["settings.hud_cust.cust_exit_reset_sel.title"] = "Exit Resets Selection"
L["settings.hud_cust.cust_exit_reset_sel.desc"] = "Exiting customization menu resets the active slot selection."
L["settings.hud_cust.imperial.title"] = "Imperial Measurement"
L["settings.hud_cust.imperial.desc"] = "Replaces various measurement systems to their Imperial variants.\nOnly affects the \"Stats & Ballistics\" customization screen."

////////////////////// Game HUD
L["settings.tabname.hud_game"] = "Game HUD"

L["settings.hud_game.lcd"] = "LCD Panel"
L["settings.hud_game.hud_arc9.title"] = "Enable HUD"
L["settings.hud_game.hud_arc9.desc"] = "Enable HUD for ARC9 weapons."
L["settings.hud_game.hud_always.title"] = "On all weapons"
L["settings.hud_game.hud_always.desc"] = "Enable that HUD on all weapons."
L["settings.hud_game.hud_compact.title"] = "Compact Mode"
L["settings.hud_game.hud_compact.desc"] = "Compact appearance for the HUD panel."
L["settings.hud_game.hud_nohints.title"] = "Disable Hints"
L["settings.hud_game.hud_nohints.desc"] = "Disable hints completely. They will not show up in the 3D HUD, nor in the 2D HUD."
L["settings.hud_game.hud_keephints.title"] = "Keep Hints"
L["settings.hud_game.hud_keephints.desc"] = "Show the ARC9 control hints on top on HUD panel."
L["settings.hud_game.hud_force_disable.title"] = "Force Disable HUD"
L["settings.hud_game.hud_force_disable.desc"] = "Disable ARC9 HUD for all players. Does not affect hints."

L["settings.hud_game.killfeed"] = "Killfeed"
L["settings.hud_game.killfeed_enable.title"] = "Killfeed Icons"
L["settings.hud_game.killfeed_enable.desc"] = "Enable auto-generation of killfeed icons for ARC9 guns."
L["settings.hud_game.killfeed_dynamic.title"] = "Dynamic updating"
L["settings.hud_game.killfeed_dynamic.desc"] = "Killfeed icons will be regenerated after each kill.\n\nTurn off if you want get that 0.1 fps."
L["settings.hud_game.killfeed_colour.title"] = "Full Color Icons"
L["settings.hud_game.killfeed_colour.desc"] = "Dynamically generated icons are fully colored."

L["settings.hud_game.breath"] = "Breath"
L["settings.hud_game.breath_hud.title"] = "Breath HUD"
L["settings.hud_game.breath_hud.desc"] = "Show a bar that displays your remaining breath while stabilizing your gun in sights."
L["settings.hud_game.breath_pp.title"] = "Breath Post-Process"
L["settings.hud_game.breath_pp.desc"] = "Holding breath will also add post-processing effects to your screen."
L["settings.hud_game.breath_sfx.title"] = "Breath SFX"
L["settings.hud_game.breath_sfx.desc"] = "Holding breath will play associated sound effects."

L["settings.hud_game.centerhint"] = "Tooltips"
L["settings.hud_game.centerhint_reload.title"] = "Display Reload Tip"
L["settings.hud_game.centerhint_reload.desc"] = "Display a reload tip when low on ammunition."
L["settings.hud_game.centerhint_reload_percent.title"] = "Magazine Percentage"
L["settings.hud_game.centerhint_reload_percent.desc"] = "Display the reload tip when the current magazine is at this percentage value."
L["settings.hud_game.centerhint_bipod.title"] = "Display Toggle Bipod"
L["settings.hud_game.centerhint_bipod.desc"] = "Display a tip when the bipod can be toggled."
L["settings.hud_game.centerhint_jammed.title"] = "Display Jammed Tip"
L["settings.hud_game.centerhint_jammed.desc"] = "Display a tip when your weapon is jammed."

L["settings.hud_game.centerhint_firemode.title"] = "Display Firemode Tip"
L["settings.hud_game.centerhint_firemode.desc"] = "Display a tip when you swap firing mode or toggle your safety."
L["settings.hud_game.centerhint_firemode_time.title"] = "Display Firemode Time"
L["settings.hud_game.centerhint_firemode_time.desc"] = "How long the firing mode should be displayed."

L["settings.hud_game.centerhint_overheat.title"] = "Display Overheat Tip"
L["settings.hud_game.centerhint_overheat.desc"] = "Displays an overlayed tip showing how close the weapon is to overheating.\n\nNot displayed if ARC9 HUD is enabled or the weapon does not support overheat."

L["settings.hud_game.hud_glyph"] = "Glyph Type"

L["settings.hud_game.hud_glyph_type_hud.title"] = "HUD"
L["settings.hud_game.hud_glyph_type_hud.desc"] = "Change which family of glyphs to use.\nThis affects the HUD tips."

L["settings.hud_game.hud_glyph_type_cust.title"] = "Customization Menu"
L["settings.hud_game.hud_glyph_type_cust.desc"] = "Change which family of glyphs to use.\nThis affects the customization menu tips.\nChanges apply next time the customization menu is opened."

L["settings.hud_game.hud_glyph_light"] = "Light"
L["settings.hud_game.hud_glyph_dark"] = "Dark"
L["settings.hud_game.hud_glyph_knockout"] = "Knockout"

////////////////////// NPCs
L["settings.tabname.npc"] = "NPCs"

L["settings.npc.weapons"] = "NPC Weapons"
L["settings.npc.npc_equality.title"] = "Damage Equality"
L["settings.npc.npc_equality.desc"] = "NPCs do just as much damage as players do.\n\nThis is a server variable."
L["settings.npc.npc_spread.title"] = "NPC Spread"
L["settings.npc.npc_spread.desc"] = "Multiplier for how inaccurate NPCs will be when firing."
L["settings.npc.npc_atts.title"] = "Give Attachments"
L["settings.npc.npc_atts.desc"] = "Spawned or given ARC9 weapons receive a random set of attachments.\n\nThis is a server variable."
L["settings.npc.npc_autoreplace.title"] = "Replace NPC Weapons"
L["settings.npc.npc_autoreplace.desc"] = "Replace NPC weapons with randomly chosen ARC9 weapons.\n\nThis is a server variable."
L["settings.npc.replace_spawned.title"] = "Replace Ground Weapons"
L["settings.npc.replace_spawned.desc"] = "Replace map/spawned HL2 weapons with randomly chosen ARC9 weapons.\n\nThis is a server variable."
L["settings.npc.npc_give_weapons.title"] = "Players Can Give Weapons"
L["settings.npc.npc_give_weapons.desc"] = "Players are able to press E on NPCs to give them their weapon.\n\nThis is a server variable."

////////////////////// Gameplay
L["settings.tabname.gameplay"] = "Gameplay"

L["settings.gameplay.controls"] = "Controls"
L["settings.gameplay.toggleads.title"] = "Toggle ADS"
L["settings.gameplay.toggleads.desc"] = "Aiming will toggle sights."
L["settings.gameplay.autolean.title"] = "Automatic Lean"
L["settings.gameplay.autolean.desc"] = "Aiming will try to automatically lean if this is possible."
L["settings.gameplay.autoreload.title"] = "Automatic Reload"
L["settings.gameplay.autoreload.desc"] = "Empty ARC9 weapons will reload automatically."
L["settings.gameplay.togglelean.title"] = "Toggle Lean"
L["settings.gameplay.togglelean.desc"] = "Pressing the lean keys will toggle leaning instead of needing to be held down.\n\nWorks poorly in conjunction with autolean. If using toggle lean, you should disable autolean."
L["settings.gameplay.togglepeek.title"] = "Toggle Peek"
L["settings.gameplay.togglepeek.desc"] = "Pressing the peek key will toggle peeking instead of needing to be held down."
L["settings.gameplay.togglepeek_reset.title"] = "Reset Peek State After Aiming"
L["settings.gameplay.togglepeek_reset.desc"] = "(Only if Toggle Peek is on)\nPeek state will not be retained when exiting aim down sights."
L["settings.gameplay.togglebreath.title"] = "Toggle Holding Breath"
L["settings.gameplay.togglebreath.desc"] = "Pressing the Holding Breath key will toggle Holding Breath instead of needing to be held down."

L["settings.gameplay.mechanics"] = "Game Mechanics"
L["settings.gameplay.infinite_ammo.title"] = "Infinite Ammo"
L["settings.gameplay.infinite_ammo.desc"] = "Weapons have infinite ammunition.\n\nThis is a server variable."
L["settings.gameplay.realrecoil.title"] = "Physical Visual Recoil"
L["settings.gameplay.realrecoil.desc"] = "Select weapons set up for this feature experience physical muzzle rise, meaning they will fire where their viewmodel shows it rather than at the center of the screen. Very important for some weapon packs' balancing schemes.\n\nThis is a server variable."
L["settings.gameplay.lean.title"] = "Leaning"
L["settings.gameplay.lean.desc"] = "Whether players can lean with +alt1 and +alt2, including automatic lean.\n\nThis is a server variable."
L["settings.gameplay.mod_sway.title"] = "Sway"
L["settings.gameplay.mod_sway.desc"] = "Weapons will have sway, if they are set up to use it.\n\nThis is a server variable."
L["settings.gameplay.mod_freeaim.title"] = "Free Aim"
L["settings.gameplay.mod_freeaim.desc"] = "Weapons will have free aim, and will not always shoot in the middle of the screen.\n\nThis is a server variable."
L["settings.gameplay.mod_bodydamagecancel.title"] = "Body Damage Cancel"
L["settings.gameplay.mod_bodydamagecancel.desc"] = "Cancel out default body damage multiplier. Only disable if using another mod that provides this type of functionality.\ne.g. Mods which change the default limb multipliers.\n\nThis is a server variable."
L["settings.gameplay.breath_slowmo.title"] = "Slow-Mo Breath"
L["settings.gameplay.breath_slowmo.desc"] = "Holding breath slows time.\n\nSingleplayer only."
L["settings.gameplay.manualbolt.title"] = "Manual Cycling"
L["settings.gameplay.manualbolt.desc"] = "Bolt-action weapons configured for this feature will only bolt when R is pressed, and not when the attack key is released."
L["settings.gameplay.never_ready.title"] = "No Ready Anims"
L["settings.gameplay.never_ready.desc"] = "Disable ready animations when deploying a weapon.\n\nThis is a server variable."
L["settings.gameplay.recoilshake.title"] = "Recoil FOV Shake"
L["settings.gameplay.recoilshake.desc"] = "Snaps field of view when shooting"
L["settings.gameplay.equipment_generate_ammo.title"] = "Unique Ammo Types for Equipment"
L["settings.gameplay.equipment_generate_ammo.desc"] = "There is a limit of 255 ammo types, and disabling this option may help fix some problems if you have lots of addons.\n\nThis is a server variable.\n\nRequires restart."

-- ??
L["settings.gameplay.mult_defaultammo.title"] = "Default Reserve Ammo"
L["settings.gameplay.mult_defaultammo.desc"] = "How many magazines/grenades/equipment give to player when he takes weapon for first time?\n\nThis is a server variable."
L["settings.gameplay.nearwall.title"] = "Near-walling"
L["settings.gameplay.nearwall.desc"] = "Not allow gun shoot when you standing too close to wall or any obstacle."

////////////////////// Visuals
L["settings.tabname.visuals"] = "Visuals"

L["settings.visuals.viewmodel"] = "Viewmodel"
L["settings.visuals.vm_bobstyle.title"] = "Bob Style"
L["settings.visuals.vm_bobstyle.desc"] = "Select different viewmodel bobbing styles, to the flavor of different contributors of ARC9 (and Valve Software)."
L["settings.visuals.fov.title"] = "FOV"
L["settings.visuals.fov.desc"] = "Add viewmodel FOV. Makes the viewmodel bigger or smaller. Use responsibly."
L["settings.visuals.vm_addx.title"] = "Add X"
L["settings.visuals.vm_addx.desc"] = "Shift the viewmodel to the right or left."
L["settings.visuals.vm_addy.title"] = "Add Y"
L["settings.visuals.vm_addy.desc"] = "Shift the viewmodel forwards and backwards."
L["settings.visuals.vm_addz.title"] = "Add Z"
L["settings.visuals.vm_addz.desc"] = "Shift the viewmodel up and down."

L["settings.visuals.cambob"] = "View Bobbing"
L["settings.visuals.vm_cambob.title"] = "Sprint View Bobbing"
L["settings.visuals.vm_cambob.desc"] = "Makes your camera move when you sprinting"
L["settings.visuals.vm_cambobwalk.title"] = "Walk View Bobbing"
L["settings.visuals.vm_cambobwalk.desc"] = "Makes your camera slightly move when you walking around (requires sprint bobbing)"
L["settings.visuals.vm_cambobintensity.title"] = "Intensity"
L["settings.visuals.vm_cambobintensity.desc"] = "How intense bobbing will be"

L["settings.visuals.tpik"] = "TPIK"
L["settings.visuals.tpik.title"] = "Enable TPIK"
L["settings.visuals.tpik.desc"] = "TPIK (Third Person Inverse Kinematics) is a system that allows most weapons display detailed and same as in first person hands positions, reload and firing animations in third person."
L["settings.visuals.tpik_others.title"] = "Other Players TPIK"
L["settings.visuals.tpik_others.desc"] = "Show TPIK for players other than yourself. Negatively impacts performance."
L["settings.visuals.tpik_framerate.title"] = "TPIK Framerate"
L["settings.visuals.tpik_framerate.desc"] = "Maximum framerate at which TPIK can run. Set to 0 for unlimited."

////////////////////// Bullet Physics
L["settings.tabname.bullets"] = "Bullet Physics"

L["settings.bullets.bullets"] = "Bullet Physics"
L["settings.bullets.bullet_physics.title"] = "Physical Bullets"
L["settings.bullets.bullet_physics.desc"] = "Weapons that support this feature will fire physical bullets, which have drop, travel time, and drag.\n\nThis is a server variable."
L["settings.bullets.bullet_gravity.title"] = "Gravity"
L["settings.bullets.bullet_gravity.desc"] = "Multiplier for bullet gravity.\n\nThis is a server variable."
L["settings.bullets.bullet_drag.title"] = "Drag"
L["settings.bullets.bullet_drag.desc"] = "Multiplier for bullet drag.\n\nThis is a server variable."
L["settings.bullets.ricochet.title"] = "Ricochet"
L["settings.bullets.ricochet.desc"] = "Bullets fired from select weapons can sometimes bounce off of surfaces and continue to travel and do damage.\n\nThis is a server variable."
L["settings.bullets.mod_penetration.title"] = "Penetration"
L["settings.bullets.mod_penetration.desc"] = "Bullets fired from select weapons can penetrate surfaces and deal damage to whatever is on the other side.\n\nThis is a server variable."
L["settings.bullets.bullet_lifetime.title"] = "Life Time"
L["settings.bullets.bullet_lifetime.desc"] = "Time in seconds after which a bullet will be deleted.\n\nThis is a server variable."
L["settings.bullets.bullet_imaginary.title"] = "Imaginary Bullets"
L["settings.bullets.bullet_imaginary.desc"] = "Bullets will appear to travel into the skybox, beyond the map's bounds."

////////////////////// Attachments
L["settings.tabname.attachments"] = "Attachments"

L["settings.attachments.customization"] = "Customization"
L["settings.attachments.atts_nocustomize.title"] = "Disable Customization"
L["settings.attachments.atts_nocustomize.desc"] = "Disallow all customization via the customization menu.\n\nThis is a server variable."
L["settings.attachments.atts_max.title"] = "Max Attachments"
L["settings.attachments.atts_max.desc"] = "The maximum number of attachments that can be put on a weapon, including cosmetic attachments.\n\nThis is a server variable."
L["settings.attachments.autosave.title"] = "Autosave"
L["settings.attachments.autosave.desc"] = "Your last weapon customization options will be saved and automatically applied the next time you spawn that weapon."
L["settings.attachments.blacklist.title"] = "Blacklist Menu"
L["settings.attachments.blacklist.open"] = "Open"

L["settings.attachments.inventory"] = "Inventory"
L["settings.attachments.free_atts.title"] = "Free Attachments"
L["settings.attachments.free_atts.desc"] = "Attachments can be used without being picked up first.\n\nThis is a server variable."
L["settings.attachments.atts_lock.title"] = "One For All"
L["settings.attachments.atts_lock.desc"] = "Picking up one instance of an attachments allows you to use it infinite times on all your guns.\n\nThis is a server variable."
L["settings.attachments.atts_loseondie.title"] = "Lose On Death"
L["settings.attachments.atts_loseondie.desc"] = "Your attachment inventory will be lost when you die.\n\nThis is a server variable."
L["settings.attachments.atts_generateentities.title"] = "Generate Entities"
L["settings.attachments.atts_generateentities.desc"] = "Generate entities that can be spawned, allowing you to pick up attachments when free attachments is off.\n\nMight increase load time.\n\nThis is a server variable."

////////////////////// Modifiers
L["settings.tabname.modifiers"] = "Modifiers"

L["settings.modifiers.quick.title"] = "Quick Stats Modifiers"
L["settings.modifiers.quick.desc"] = " "

L["settings.mod_damage.title"] = "Damage"
L["settings.mod_spread.title"] = "Spread"
L["settings.mod_recoil.title"] = "Recoil"
L["settings.mod_visualrecoil.title"] = "Visual Recoil"
L["settings.mod_adstime.title"] = "Aim Down Sights Time"
L["settings.mod_sprinttime.title"] = "Sprint To Fire Time"
L["settings.mod_damagerand.title"] = "Damage Variance"
L["settings.mod_muzzlevelocity.title"] = "Muzzle Velocity"
L["settings.mod_rpm.title"] = "RPM"
L["settings.mod_headshotdamage.title"] = "Headshot Damage"
L["settings.mod_malfunction.title"] = "Malfunction Chance"

////////////////////// Controller
L["settings.tabname.controller"] = "Controller"

L["settings.controller.misc"] = "Misc"
L["settings.controller.misc.desc"] = "There should be button that will open panel with advanced controller config, but for now it is in  spawnmenu > Options > ARC9 > Controller."
L["settings.controller.controller.title"] = "Enable Controller Mode"
L["settings.controller.controller.desc"] = "Enable custom controller-compatible glyphs, showing controller buttons instead of the default keys."
-- L["settings.controller.controller_rumble.title"] = "Rumble"
-- L["settings.controller.controller_rumble.desc"] = "Enable controller rumble as long as Fesiug's DLL mod is loaded.\n\ngithub.com/Fesiug/\ngmod-sinput"
L["settings.controller.controller_config.title"] = "Advanced config"
L["settings.controller.controller_config.content"] = "Open panel"
L["settings.controller.controller_config.desc"] = "Open advanced controller configuration panel."

L["settings.controller.glyphs.title"] = "Glyph Type"
L["settings.controller.glyphs.desc"] = "Choose which family of glyphs you want to use.\nSet up glyphs in \"Spawnmenu\" > Options > ARC9 > Controller."

////////////////////// Aim Assist
L["settings.tabname.aimassist"] = "Aim Assist"
L["settings.tabname.aimassist.desc"] = "You can enable aim assistance if you might have trouble keeping your aim on your target, or if you just prefer to not put effort into shooting your targets."

L["settings.aimassist.enable.title"] = "Enable Aim Assist"
L["settings.aimassist.enable.desc"] = "Enables an aim assistance feature that moves your aim towards a target when aiming near them.\n\nThis is a server variable.\n\nRequires Aim Assist to be enabled on CLIENT."

L["settings.aimassist.enable_general.desc"] = "Enables an aim assistance feature that moves your aim towards a target when aiming near them.\n\nConfigure it in the \"Aim Assist\" tab."

L["settings.aimassist.enable_client.desc"] = "Enables an aim assistance feature that moves your aim towards a target when aiming near them.\n\nRequires Aim Assist to be enabled on SERVER."

L["settings.aimassist.intensity.title"] = "Intensity"
L["settings.aimassist.intensity.desc"] = "How intense the aim assist is.\n\nThis is a server variable."

L["settings.aimassist.cone.title"] = "Cone"
L["settings.aimassist.cone.desc"] = "How close or far away you need to look towards a target before the aim assist engages.\n\nThis is a server variable."

L["settings.aimassist.head.title"] = "Lock onto head"
L["settings.aimassist.head.desc"] = "If the aim assist should lock onto the target's head instead of its chest.\n\nThis is a server variable."

L["settings.aimassist.sensmult.desc"] = "Multiply the look sensitivity by this amount when hovering over a valid target.\nThe lower the value, the lower the sensitivity."

////////////////////// Asset Caching
L["settings.tabname.caching"] = "Asset Caching"
L["settings.caching.title"] = "Asset Caching"
L["settings.caching.desc"] = "You can cache some ARC9 assets (save in memory without loading while playing) to prevent stutters for comfort gameplay!\n\nYou surely should enable some stuff if your gmod running on HDD."

L["settings.caching.precache_sounds_onfirsttake.title"] = "On first equip: Cache gun sounds"
L["settings.caching.precache_sounds_onfirsttake.desc"] = "Caches all sounds only from gun you just took in hands (except reload sounds).\n\nNot any impactful, rather helpful to prevent stutters while firing."

L["settings.caching.precache_attsmodels_onfirsttake.title"] = "On first equip: Cache all attachments"
L["settings.caching.precache_attsmodels_onfirsttake.desc"] = "Caches all ARC9 attachments models when any ARC9 weapon was first equipped.\n\nCauses pretty big freeze, especially when you have lots of weapons."
L["settings.caching.precache_wepmodels_onfirsttake.title"] = "On first equip: Cache all weapon models"
L["settings.caching.precache_wepmodels_onfirsttake.desc"] = "Caches all ARC9 weapons viewmodels when any ARC9 weapon was first equipped.\n\nCauses REALLY BIG freeze, especially when you have lots of weapons."

L["settings.caching.precache_allsounds_onstartup.title"] = "On game start: Cache all guns sounds"
L["settings.caching.precache_allsounds_onstartup.desc"] = "Caches all sounds from all guns on server start-up. (except reload sounds).\n\nNot so impactful, but anyway you better use first option here."
L["settings.caching.precache_attsmodels_onstartup.title"] = "On game start: Cache all attachments"
L["settings.caching.precache_attsmodels_onstartup.desc"] = "Caches all ARC9 attachments models on server start-up.\n\nCauses pretty big load time increase, especially when you have lots of weapons."
L["settings.caching.precache_wepmodels_onstartup.title"] = "On game start: Cache all weapon models"
L["settings.caching.precache_wepmodels_onstartup.desc"] = "Caches all ARC9 weapons viewmodels on server start-up.\n\nCauses REALLY BIG load time increase, especially when you have lots of weapons."

L["settings.caching.precache_allsounds.title"] = "All weapon sounds"
L["settings.caching.precache_wepmodels.title"] = "All weapon models"
L["settings.caching.precache_attsmodels.title"] = "All attachments models"

L["settings.developer.cache"] = "Cache"

////////////////////// Developer
L["settings.tabname.developer"] = "Developer"

L["settings.developer.developer"] = "Developer Options"
L["settings.developer.dev_always_ready.title"] = "Always Ready"
L["settings.developer.dev_always_ready.desc"] = "Always play \"ready\" animation when deploying a weapon.\n\nThis is a server variable."
L["settings.developer.dev_benchgun.title"] = "Benchgun"
L["settings.developer.dev_benchgun.desc"] = "Keep the weapon where it currently is."
L["settings.developer.dev_crosshair.title"] = "Dev Crosshair"
L["settings.developer.dev_crosshair.desc"] = "Funky looking crosshair showing the exact point of aim and some useful numbers.\n\nThis is a server variable, and only works for admins - don't get cheaty with this!"
L["settings.developer.dev_show_affectors.title"] = "Display Affectors"
L["settings.developer.dev_show_affectors.desc"] = "Displays which current affectors are currently applied.\n\nRequires \"Dev Crosshair\"."
L["settings.developer.dev_show_shield.title"] = "Show Shield"
L["settings.developer.dev_show_shield.desc"] = "Show the model for the player's shield."
L["settings.developer.dev_greenscreen.title"] = "Green Screen"
L["settings.developer.dev_greenscreen.desc"] = "Show a green screen background in the customisation menu for screenshots.\n\nIf you are using HDR, don't forget to set mat_bloom_scalefactor_scalar to 0!"
L["settings.developer.reloadatts.title"] = "Reload Attachments"
L["settings.developer.reloadlangs.title"] = "Reload Languages"
L["settings.developer.dev_listmyatts.title"] = "List My Attachments"
L["settings.developer.dev_listanims.title"] = "List Anims"
L["settings.developer.dev_listbones.title"] = "List Bones"
L["settings.developer.dev_listbgs.title"] = "List Bodygroups"
L["settings.developer.dev_listatts.title"] = "List QCAttachments"
L["settings.developer.dev_listmats.title"] = "List Materials"
L["settings.developer.dev_export.title"] = "Get Export Code"
L["settings.developer.dev_getjson.title"] = "Get Weapon JSON"

L["settings.developer.presets_clear.title"] = "Clear weapon data"
L["settings.developer.presets_clear.desc"] = "Clear presets, all icons and default preset for weapon you currently holding.\n\nWarning: if menu opened without ARC9 weapon in hands it will delete all existing ARC9 presets and icons!"

L["settings.developer.clear"] = "Clear"
L["settings.developer.print"] = "Print to Console"
L["settings.developer.reload"] = "Reload"

////////////////////// ARC9 Premium
L["premium.title"] = "ARC9 Premium"
L["premium.desc"] = "ARC9 Premium allows additional customization as a major thanks for supporting the addon financially."

L["premium.requires"] = "Requires <color=255,106,0>ARC9 Premium</color>."
L["premium.acquire"] = "Subscribe to <color=255,106,0>ARC9 Premium</color>"

L["premium.ownedno"] = "<color=255,106,0>ARC9 Premium</color>: <color=255,100,100>Not owned</color>"
L["premium.owned"] = "<color=255,106,0>ARC9 Premium</color>: <color=255,100,100>Owned</color>"

L["premium.help"] = "What is ARC9 Premium?"
L["premium.help.header"] = "Guide to ARC9 Premium"
L["premium.help.desc"] = "Creating addons takes time and resources. ARC9 has always been available for free, and it will remain that way. However, if you wish to support the base financially, you may do so, and get rewarded for it!"

L["premium.help.ownedbutnoaccess"] = "Have you recently purchased ARC9 Premium, but do not have automatic access to it? Contact us on the Diamond Doves Discord Server for assistance.\nEnsure you can provide proof of purchase before contacting. Simply saying \"I buy, now give\" is not good enough."

L["premium.content"] = "Included in <color=255,106,0>ARC9 Premium</color>:"
L["premium.content.list"] = [[
- Unlimited Customization Slots (Increased from 32)
- Unlimited Preset Slots (Increased from 10 per weapon)
- Access to Supermodifier settings*
- Access to an exclusive Dark UI mode
- Ability to colour optic reticles, UI and more
- Exclusive camos made available through the base
- Exclusive support channel on Discord

*Requires administrator if on a server
]]

L["premium.payment.month"] = [[
$%s
Acquire ARC9 Premium for 1 Month.
]]

L["premium.payment.months"] = [[
$%s
Acquire ARC9 Premium for %s Months and get a <color=100,255,100>%s%% discount</color>!
]]

L["premium.payment.info"] = [[
Purchasing ARC9 Premium grants immediate access to all the contents listed previously for the time purchased.
Time can be extended by purchasing any of the options once more, and the time will refresh automatically once the original time has expired.
Once the time has passed, and no additional payment has been made, access to ARC9 Premium will be removed.

All customization options, including attachment slots, presets and coloured reticles made with ARC9 Premium will remain available, but you will not alter them or add any additional ones.
]]

L["premium.purchased"] = "Purchased <color=255,106,0>ARC9 Premium</color>!"
L["premium.purchased.desc"] = [[
Thank you for purchasing ARC9 Premium! You made the bird a very happy one!

A receipt will be sent to your connected Email.

If you have not immediately acquired access to the ARC9 Premium bonuses, please rejoin the server, or restart your game.

If you are still having problems with it, or if you still have not been granted Premium, then do visit the Diamond Doves Discord server and provide valid proof of purchase, and we will have it fixed for you.
]]

--PATH lua/arc9/common/localization/font_en.lua:
L = {}

/////////////////////////////////////// Font
//////////////////// If a custom font should be used, rename the string. Useful for Pinyin, Kanji, etc.
////////// Do not create a font file if your language does not need it.

L["font"] = "Venryn Sans"
--PATH lua/arc9/common/localization/base_en.lua:
L = {}

/////////////////////////////////////// Font
////////////////////// See "font_en" file

/////////////////////////////////////// General
////////////////////// Units of measurement
L["unit.second"] = "s"
L["unit.meter"] = "m"
L["unit.millimeter"] = "mm"
L["unit.meterpersecond"] = "m/s"
L["unit.hammerunit"] = "HU"
L["unit.decibel"] = "dB"
L["unit.rpm"] = "RPM"
L["unit.moa"] = "MOA"
L["unit.dmg"] = "DMG"
L["unit.projectiles"] = "PROJ"

L["unit.inch"] = "in"
L["unit.foot"] = "ft"
L["unit.footpersecond"] = "ft/s"
L["unit.yard"] = "yd"

////////////////////// Ammo types
L["ammo.pistol"] = "Pistol Ammo"
L["ammo.357"] = "Magnum Ammo"
L["ammo.smg1"] = "Carbine Ammo"
L["ammo.ar2"] = "Rifle Ammo"
L["ammo.buckshot"] = "Shotgun Ammo"
L["ammo.sniperpenetratedround"] = "Sniper Ammo"
L["ammo.smg1_grenade"] = "Rifle Grenades"
L["ammo.xbowbolt"] = "Crossbow Bolts"
L["ammo.rpg_round"] = "Rockets"
L["ammo.grenade"] = "Grenades"
L["ammo.slam"] = "SLAM"
L["ammo.alyxgun"] = "Alyx's Gun Ammo"

/////////////////////////////////////// HUD
L["hud.version"] = "ARCTIC SYSTEMS HUD v"
L["hud.jammed"] = "JAMMED!"
L["hud.therm_deco"] = "BARREL TEMP"

L["hud.firemode.single"] = "SINGLE"
L["hud.firemode.burst"] = "BURST"
L["hud.firemode.auto"] = "AUTO"
L["hud.firemode.safe"] = "SAFE"

L["hud.hint.bash"] = "Bash"
L["hud.hint.bipod"] = "Toggle Bipod"
L["hud.hint.breath"] = "Hold Breath"
L["hud.hint.customize"] = "Customize"
L["hud.hint.cycle"] = "Cycle"
L["hud.hint.firemode"] = "Switch Firemode"
L["hud.hint.inspect"] = "Inspect"
L["hud.hint.lean"] = "Lean"
L["hud.hint.peek"] = "Peek"
L["hud.hint.reload"] = "Reload"
L["hud.hint.safe"] = "Toggle Safe"
L["hud.hint.switchsights"] = "Switch Sights"
L["hud.hint.toggleatts"] = "Toggle Attachments"
L["hud.hint.ubgl"] = "Toggle"
L["hud.hint.unjam"] = "Unjam"
L["hud.hint.zoom"] = "Change Zoom"
L["hud.hint.quicknade"] = "Quickthrow "

L["hud.hint.lowammo"] = "Low Ammo"
L["hud.hint.noammo"] = "No Ammo"

L["hud.error.missingbind"] = "No button bound to %s"
L["hud.error.missingbind_zoom"] = "Bind \"Suit Zoom\" in settings!"
L["hud.error.missingbind_context"] = "Bind \"Open Context Menu\" in settings!"

/////////////////////////////////////// Customization menu
L["customize.panel.customize"] = "CUSTOMIZE"
L["customize.panel.personalize"] = "PERSONALIZE"
L["customize.panel.stats"] = "STATS & BALLISTICS"
L["customize.panel.trivia"] = "TRIVIA"
L["customize.panel.inspect"] = "INSPECT"
L["customize.panel.presets"] = "Presets"

L["customize.stats.aimtime"] = "Aim Time"
L["customize.stats.ammo"] = "Ammo Type"
L["customize.stats.armorpiercing"] = "Armor Piercing"
L["customize.stats.burstdelay"] = "Burst Delay"
L["customize.stats.capacity"] = "Capacity"
L["customize.stats.cyclic"] = "Cyclic ROF"
L["customize.stats.explosive"] = "Explosive Damage"
L["customize.stats.firemodes"] = "Fire Modes"
L["customize.stats.firepower"] = "Firepower"
L["customize.stats.freeaim"] = "Free Aim Radius"
L["customize.stats.muzzlevelocity"] = "Muzzle Velocity"
L["customize.stats.noise"] = "Noise"
L["customize.stats.penetration"] = "Penetration"
L["customize.stats.precision"] = "Precision"
L["customize.stats.range"] = "Range"
L["customize.stats.ricochet"] = "Ricochet Chance"
L["customize.stats.rof"] = "ROF"
L["customize.stats.speed"] = "Movement Speed"
L["customize.stats.sprinttofire"] = "Sprint to Fire Time"
L["customize.stats.supplylimit"] = "Supply Limit"
L["customize.stats.sway"] = "Sway"
L["customize.stats.triggerdelay"] = "Trigger Delay"

L["customize.hint.attach"] = "Attach"
L["customize.hint.controller"] = "Controller Mode is on."
L["customize.hint.cursor"] = "Cursor"
L["customize.hint.cycle"] = "Cycle Slot"
L["customize.hint.delete"] = "Delete"
L["customize.hint.deselect"] = "Deselect"
L["customize.hint.expand"] = "Expand"
L["customize.hint.export"] = "Export"
L["customize.hint.favorite"] = "Favorite"
L["customize.hint.import"] = "Import"
L["customize.hint.install"] = "Install"
L["customize.hint.last"] = "Last Slot"
L["customize.hint.lastmode"] = "Last Mode"
L["customize.hint.nextmode"] = "Next Mode"
L["customize.hint.open"] = "Open"
L["customize.hint.pan"] = "Pan"
L["customize.hint.quicksave"] = "Quicksave"
L["customize.hint.randomize"] = "Attach Random"
L["customize.hint.recalculate"] = "Recalculate"
L["customize.hint.recenter"] = "Recenter"
L["customize.hint.rotate"] = "Rotate"
L["customize.hint.save"] = "Save"
L["customize.hint.select"] = "Select"
L["customize.hint.unattach"] = "Unattach"
L["customize.hint.unfavorite"] = "Remove Favorite"
L["customize.hint.zoom"] = "Zoom"

L["customize.trivia.description"] = "Description"

L["customize.stats.explain.firepower"] = "The damage potential at point-blank range."
L["customize.stats.explain.rof"] = "The weapon's rate of fire."
L["customize.stats.explain.cyclic"] = "The weapon's cyclic rate of fire. Ignores factors like burst delay or reload requirements."
L["customize.stats.explain.capacity"] = "How much ammo the gun can hold in the magazine + chamber."
L["customize.stats.explain.range"] = "The range at which the gun deals minimum damage."
L["customize.stats.explain.precision"] = "The weapon's accuracy. Measured in Minutes of Accuracy (MOA)."
L["customize.stats.explain.muzzlevelocity"] = "The muzzle velocity of bullets fired from this gun."
L["customize.stats.explain.ammo"] = "The type of ammo this gun uses."
L["customize.stats.explain.penetration"] = "Amount of material this gun can penetrate."
L["customize.stats.explain.ricochet"] = "Maximum chance for bullets from this gun to ricochet."
L["customize.stats.explain.armorpiercing"] = "Amount of damage from this gun that completely ignores most damage resistances."
L["customize.stats.explain.explosive"] = "Amount of explosive damage this gun will do."
L["customize.stats.explain.speed"] = "Speed at which you can move while using this gun."
L["customize.stats.explain.aimtime"] = "How long it takes to aim down sights from hip fire."
L["customize.stats.explain.sprinttofire"] = "How long it takes to exit sprint and begin shooting."
L["customize.stats.explain.firemodes"] = "Which fire modes this gun has access to."
L["customize.stats.explain.burstdelay"] = "Amount of time after firing a burst before the gun can fire again."
L["customize.stats.explain.triggerdelay"] = "Delay between pulling the trigger and firing a shot."
L["customize.stats.explain.noise"] = "How loud the gun's gunshots are."
L["customize.stats.explain.sway"] = "Amount of sway applied to the gun."
L["customize.stats.explain.freeaim"] = "Maximum free aim angle. Lower is better."
L["customize.stats.explain.supplylimit"] = "Amount of ammo that the gun can receive from ARC9 ammo sources."

L["customize.bench.dummy"] = "BALLISTICS DUMMY TEST"
L["customize.bench.effect"] = "EFFECT AT RANGE"
L["customize.bench.ballistics"] = "TERMINAL BALLISTICS PERFORMANCE EVALUATION"
L["customize.bench.precision"] = "MECHANICAL PRECISION TEST"

L["folder.back"] = "Back"
L["folder.deselect"] = "Deselect"
L["folder.favorites"] = "Favorites"
L["folder.select"] = "Select"

////////////////////// Automatic stats
L["autostat.enable.pre"] = "Enables"
L["autostat.disable.pre"] = "Disables"
L["autostat.enable.post"] = ""
L["autostat.disable.post"] = ""

L["autostat.aimdownsightstime"] = "Aim Down Sights Time"
L["autostat.alwaysphysbullet"] = "Always Physical Bullets"
L["autostat.ammopershot"] = "Ammo Per Shot"
L["autostat.armdamage"] = "Arm Damage"
L["autostat.armorpiercing"] = "Armor Piercing"
L["autostat.autoburst"] = "Automatic Burst Fire"
L["autostat.autoreload"] = "Idle Reloading"
L["autostat.bash"] = "Melee Attacks"
L["autostat.bashdamage"] = "Melee Damage"
L["autostat.bashlungerange"] = "Melee Lunge Range"
L["autostat.bashrange"] = "Melee Range"
L["autostat.bashspeed"] = "Melee Speed"
L["autostat.bipod"] = "Bipod"
L["autostat.bottomlessclip"] = "Bottomless Magazine"
L["autostat.breathholdtime"] = "Focus Time"
L["autostat.bulletguidance"] = "Guided Rounds"
L["autostat.bulletguidanceamount"] = "Guidance Factor"
L["autostat.canfireunderwater"] = "Underwater Shooting"
L["autostat.cantpeek"] = "Disables Peeking"
L["autostat.chambersize"] = "Chamber Load Count"
L["autostat.chestdamage"] = "Chest Damage"
L["autostat.clipsize"] = "Magazine Capacity"
L["autostat.cycletime"] = "Cycle Time"
L["autostat.damagemax"] = "Close Range Damage"
L["autostat.damagemin"] = "Long Range Damage"
L["autostat.damagerand"] = "Damage Variance"
L["autostat.deploytime"] = "Draw Time"
L["autostat.distance"] = "Bullet Distance"
L["autostat.entitymuzzlevelocity"] = "Projectile Muzzle Velocity"
L["autostat.explosiondamage"] = "Explosion Damage"
L["autostat.explosionradius"] = "Explosion Splash Radius"
L["autostat.fixtime"] = "Unjam Time"
L["autostat.freeaimradius"] = "Free Aim Radius"
L["autostat.headshotdamage"] = "Headshot Damage"
L["autostat.heatcapacity"] = "Heat Capacity"
L["autostat.heatdissipation"] = "Heat Dissipation"
L["autostat.heatpershot"] = "Heat Per Shot"
L["autostat.hybridreload"] = "Hybrid Individual Reloading"
L["autostat.infiniteammo"] = "Infinite Ammunition"
L["autostat.legdamage"] = "Leg Damage"
L["autostat.malfunction"] = "Jamming"
L["autostat.malfunctionmeanshotstofail"] = "Mean Shots Between Failures"
L["autostat.malfunctionwait"] = "Malfunction Wait Time"
L["autostat.manualaction"] = "Manual Action"
L["autostat.manualactionchamber"] = "Shots Per Cycle"
L["autostat.neverphysbullet"] = "Non-Physical Bullets"
L["autostat.noflash"] = "No Muzzle Flash"
L["autostat.num"] = "Projectile Count"
L["autostat.overheat"] = "Overheating"
L["autostat.overheattime"] = "Overheat Fix Time"
L["autostat.pelletspread"] = "Clump Spread"
L["autostat.penetration"] = "Material Penetration"
L["autostat.penetrationdelta"] = "Damage After Penetration"
L["autostat.physbulletdrag"] = "Bullet Drag"
L["autostat.physbulletgravity"] = "Bullet Drop"
L["autostat.physbulletmuzzlevelocity"] = "Muzzle Velocity"
L["autostat.postburstdelay"] = "Burst Delay"
L["autostat.pushbackforce"] = "Pushback Force"
L["autostat.rangemax"] = "Maximum Range"
L["autostat.rangemin"] = "Minimum Range"
L["autostat.recoil"] = "Recoil"
L["autostat.recoilautocontrol"] = "Recoil Control"
L["autostat.recoildissipationrate"] = "Recoil Dissipation Rate"
L["autostat.recoilkick"] = "Felt Recoil"
L["autostat.recoilmodifiercap"] = "Maximum Cumulative Recoil"
L["autostat.recoilpatterndrift"] = "Recoil Drift"
L["autostat.recoilpershot"] = "Recoil per Shot"
L["autostat.recoilrandomside"] = "Horizontal Recoil Spread"
L["autostat.recoilrandomup"] = "Vertical Recoil Spread"
L["autostat.recoilresettime"] = "Recoil Reset Time"
L["autostat.recoilside"] = "Horizontal Recoil"
L["autostat.recoilup"] = "Vertical Recoil"
L["autostat.reloadtime"] = "Reload Time"
L["autostat.ricochetanglemax"] = "Ricochet Angle"
L["autostat.ricochetchance"] = "Ricochet Chance"
L["autostat.rpm"] = "Fire Rate"
L["autostat.runawayburst"] = "Runaway Burst"
L["autostat.secondarysupplylimit"] = "Reserve Secondary Ammo"
L["autostat.shootvolume"] = "Report Volume"
L["autostat.shootwhilesprint"] = "Shoot While Sprinting"
L["autostat.shotgunreload"] = "Individual Reloading"
L["autostat.speed"] = "Movement Speed"
L["autostat.spread"] = "Spread"
L["autostat.sprinttofiretime"] = "Sprint To Fire Time"
L["autostat.stomachdamage"] = "Stomach Damage"
L["autostat.supplylimit"] = "Reserve Magazines"
L["autostat.sway"] = "Sway"
L["autostat.triggerdelay"] = "Trigger Delay"
L["autostat.triggerdelaytime"] = "Trigger Delay Time"
L["autostat.visualrecoil"] = "Visual Recoil"
L["autostat.visualrecoilpunch"] = "Visual Recoil Punch"
L["autostat.visualrecoilroll"] = "Visual Recoil Roll"
L["autostat.visualrecoilside"] = "Horizontal Visual Recoil"
L["autostat.visualrecoilup"] = "Vertical Visual Recoil"

L["autostat.secondary._beforephrase"] = false
-- if true, secondary stat phrasing comes before the stat
L["autostat.secondary._divider"] = " "
-- space between the secondary phrase from the stat phrase. set true to use empty string

-- L["autostat.secondary.blindfire"] = "while Blind-Firing"
L["autostat.secondary.bipod"] = "on Bipod"
L["autostat.secondary.crouch"] = "while Crouching"
L["autostat.secondary.empty"] = "on Last round in mag"
L["autostat.secondary.evenreload"] = "every Even Reload"
L["autostat.secondary.evenshot"] = "every Even Shot"
L["autostat.secondary.first"] = "on First Shot"
L["autostat.secondary.firstshot"] = "on First Shot"
L["autostat.secondary.heated"] = "while Heated"
L["autostat.secondary.hipfire"] = "in Hipfire"
L["autostat.secondary.hot"] = "from Heat"
L["autostat.secondary.last"] = "on Last round in mag"
L["autostat.secondary.lastshot"] = "on Last round in mag"
L["autostat.secondary.midair"] = "in Mid-Air"
L["autostat.secondary.move"] = "while Moving"
L["autostat.secondary.oddreload"] = "every Odd Reload"
L["autostat.secondary.oddshot"] = "every Odd Shot"
L["autostat.secondary.recoil"] = "from Recoil" --"With Each Shot"
L["autostat.secondary.shooting"] = "while Shooting"
L["autostat.secondary.sighted"] = "while Sighted"
L["autostat.secondary.sights"] = "in Sights"
L["autostat.secondary.silenced"] = "when Silenced"
L["autostat.secondary.sprint"] = "when Sprinting"
L["autostat.secondary.true"] = "when TrueNames is on"
L["autostat.secondary.ubgl"] = "in UBGL"

////////////////////// Universal Trivia
/////////// Country of Origin
L["trivia.country"] = "Country of Origin"

L["country.ar"] = "Argentina"
L["country.au"] = "Australia"
L["country.at"] = "Austria"
L["country.by"] = "Belarus"
L["country.be"] = "Belgium"
L["country.br"] = "Brazil"
L["country.ca"] = "Canada"
L["country.cn"] = "China"
L["country.hr"] = "Croatia"
L["country.dk"] = "Denmark"
L["country.eg"] = "Egypt"
L["country.fi"] = "Finland"
L["country.fr"] = "France"
L["country.de"] = "Germany"
L["country.gr"] = "Greece"
L["country.hk"] = "Hong Kong"
L["country.hu"] = "Hungary"
L["country.is"] = "Iceland"
L["country.id"] = "Indonesia"
L["country.ir"] = "Iran"
L["country.iq"] = "Iraq"
L["country.ie"] = "Ireland"
L["country.il"] = "Israel"
L["country.it"] = "Italy"
L["country.jp"] = "Japan"
L["country.kz"] = "Kazakstan"
L["country.kp"] = "North Korea"
L["country.kr"] = "South Korea"
L["country.lt"] = "Lithuania"
L["country.mx"] = "Mexico"
L["country.nl"] = "Netherlands"
L["country.nz"] = "New Zealand"
L["country.no"] = "Norway"
L["country.pk"] = "Pakistan"
L["country.ph"] = "Philippines"
L["country.pl"] = "Poland"
L["country.pt"] = "Portugal"
L["country.ro"] = "Romania"
L["country.ru"] = "Russia"
L["country.sa"] = "Saudi Arabia"
L["country.sg"] = "Singapore"
L["country.sk"] = "Slovakia"
L["country.si"] = "Slovenia"
L["country.za"] = "South Africa"
L["country.es"] = "Spain"
L["country.se"] = "Sweden"
L["country.ch"] = "Switzerland"
L["country.tw"] = "Taiwan"
L["country.th"] = "Thailand"
L["country.tr"] = "Turkey"
L["country.ua"] = "Ukraine"
L["country.ae"] = "United Arab Emirates"
L["country.gb"] = "United Kingdom"
L["country.us"] = "United States"

////////////////////// Blacklist menu
L["blacklist.title"] = "ARC9 Attachment Blacklist"
L["blacklist.desc"] = "Attachments checked here will be blocked from use"
L["blacklist.blisted"] = "BLACKLISTED"
L["blacklist.all"] = "ALL"
L["blacklist.id"] = "ID"
L["blacklist.name"] = "NAME"
L["blacklist.filter"] = "FILTER"

////////////////////// Incompatible addons
L["incompatible.title"] = "ARC9: INCOMPATIBLE ADDONS"
L["incompatible.line1"] = "You have some addons that are known to not work with ARC9."
L["incompatible.line2"] = "Disable them or expect broken behavior!"
L["incompatible.confirm"] = "Acknowledge"
L["incompatible.wait"] = "Wait {time}s"
L["incompatible.never"] = "Never warn me again"
L["incompatible.never.hover"] = "Are you absolutely sure you understand the consequences?"
L["incompatible.never.confirm"] = "You have chosen to never show incompatiblity warnings again. If you encounter errors or broken behaviour, it is your own responsibility."

////////////////////// Warning panel
L["badconf.title"] = "ARC9: BAD GMOD SETTINGS WARNING"
L["badconf.line1"] = "It appears some Garry's Mod settings are causing problems."
L["badconf.line2"] = "Listed below are problems which have been detected, and solutions to fix them."
L["badconf.confirm"] = "Acknowledge"
L["badconf.wait"] = "Wait {time}s"

L["badconf.directx.title"] = "Outdated DirectX version"
L["badconf.directx.desc"] = "You are currently running DirectX 8 or 8.1. Modern GMod isn't meant for this, you might not be able to see models on most weapon packs. (dx9 was introduced 21 years ago!)"
L["badconf.directx.solution"] = "Solution: Go to Garry's Mod's launch options and insert \"-dxlevel 95\" into the launch parameters. If \"-dxlevel 70/80/85\" is listed there, remove it."

L["badconf.tickrate.title"] = "Too low server tickrate"
L["badconf.tickrate.desc"] = "The server you are on is running on very low tickrate. ARC9 runs best if you run a minimum of 20 tickrate (66+ is recommended)."
L["badconf.tickrate.solution"] = "Solution: If you are a server owner, then insert \"-tickrate 33\", or whichever value you want, in the server launch configurations."

L["badconf.matbumpmap.title"] = "mat_bumpmap is disabled"
L["badconf.matbumpmap.desc"] = "You have bumpmaps disabled, which makes weapons look worse. It also breaks certain ARC9 optics."
L["badconf.matbumpmap.solution"] = "Solution: In the console, type \"mat_bumpmap 1\". If you are using an FPS config of any kind, then find and delete mat_bumpmap 0 line from \"autoexec.cfg\"."

L["badconf.addons.title"] = "Too many addons! Lua file limit exceeded!"
L["badconf.addons.desc"] = "You have installed way too many addons and have reached the Lua file limit. ARC9 has therefore not been able to initialize properly, meaning attachments might not work."
L["badconf.addons.solution"] = "Solution: Uninstall heavy addons through the in-game Addons menu, or through the Steam workshop (for example other weapon bases, JMod, Entity Packs, and so on)."

L["badconf.warning"] = "Warning! Your performance is not optimal! - Hover over to view details."
L["badconf.warning.desc"] = "More FPS is always good. Especially on weapon bases like this one.\n\nHover cursor over items below to see solution."

L["badconf.x64.title"] = "► Slow 32-Bit branch Detected"
L["badconf.x64.desc"] = [[You are currently running Garry's Mod in 32-bit. This restricts the amount of performance you can obtain drastically.

Solution: In Garry's Mod's launch options, go to "Betas" and change to "x86-64 - Chromium + 64-bit binaries".

Google "gmod x64" to find a tutorial online.]]

L["badconf.multicore.title"] = "► No Multicore Rendering commands"
L["badconf.multicore.desc"] = [[Certain multicore rendering settings are currently disabled. This results in worsened in-game performance.

Solution: You need to put certain commands into autoexec.cfg

Google "gmod multicore" to find a tutorial online.

All commands that can increase performance:
gmod_mcore_test 1
mat_queue_mode 2
cl_threaded_bone_setup 1
cl_threaded_client_leaf_system 1
r_threaded_client_shadow_manager 1
r_threaded_renderables 1]]

////////////////////// Presets
L["customize.presets.atts"] = " Attachments"
L["customize.presets.back"] = "Back"
L["customize.presets.cancel"] = "Cancel"
L["customize.presets.code"] = "Preset Code (Copied to Clipboard)"
L["customize.presets.default"] = "Default"
L["customize.presets.default.long"] = "Default preset"
L["customize.presets.dumb"] = "Are you dumb"
L["customize.presets.import"] = "Import"
L["customize.presets.invalid"] = "Invalid string!"
L["customize.presets.new"] = "New Preset Name"
L["customize.presets.paste"] = "Paste Preset Code Here"
L["customize.presets.random"] = "Random"
L["customize.presets.save"] = "Save"
L["customize.presets.unnamed"] = "Unnamed"

L["customize.presets.deldef"] = "Are you sure you want to delete \"{name}\" default preset?"
L["customize.presets.deldef2"] = "You would have to reset weapon in developer settings to return it."
L["customize.presets.yes"] = "Yes"

////////////////////// Tips
L["tips.arc-9"] = "It's ARC9, not ARC-9, not Arc9."
L["tips.blacklist"] = "You can blacklist attachments! See the ARC9 Workshop description for more information."
L["tips.bugs"] = "Report bugs on the official Discord server, or better yet, open a Github issue."
L["tips.custombinds"] = "ARC9 key combos can be replaced with custom binds. Start typing +arc9_ to find the available binds!"
L["tips.cyberdemon"] = "To kill the terrorist, shoot him until he is dead."
L["tips.description"] = "We advise you to read the descriptions of addons before commenting."
L["tips.development"] = "Keen to develop ARC9 content? The official Discord server has plenty of resources to help!"
L["tips.discord"] = "Join Diamond Doves on Discord! The link is in the ARC9 description and in top of settings."
L["tips.external"] = "If using the Github version of ARC9, make sure to update frequently!"
L["tips.hints"] = "Keep ARC9's HUD on to see control hints."
L["tips.lean"] = "To manually lean, bind keys to +alt1 and +alt2."
L["tips.love"] = "Feel free to tell the devs you appreciate their work! It really helps us keep going."
L["tips.m9k"] = "Check out M9K guns!."
L["tips.official"] = "Only download ARC9 from official sources. Third party uploads may be malicious or outdated!"
L["tips.presets"] = "Share your favorite presets with your friends by exporting them!"
L["tips.settings"] = "You can turn these tips off, and much more, in the ARC9 settings. Click the button in the top left corner!"
L["tips.tips"] = "Tips have a fixed order. Keep reading and you'll eventually see them all."
L["tips.tolerance"] = "All weapon bases work fine together. There's no need for favoritism."

////////////////////// Other
L["atts.favourites"] = "Favourites"
L["atts.filter"] = "Filter"

/////////////////////////////////////// Settings menu
-- Use this method to localize convars in settings menu:
-- settings.convar.title = "Convar Title"
-- settings.convar.desc = "Convar Description"

L["settings.title"] = "ARC9 Settings"
L["settings.desc"] = "Description"

L["settings.default_convar"] = "Default value"
L["settings.convar_server"] = "Server variable"
L["settings.convar_client"] = "Client variable"

////////////////////// General
L["settings.tabname.general"] = "General"

L["settings.general.client"] = "Client"
L["settings.language_id.title"] = "Language"
L["settings.language_id.desc"] = "Language pack to use for ARC9."
L["settings.truenames.title"] = "True Names"
L["settings.truenames.desc"] = "Set whether to use weapons' real names or fictional names made by the developers. Not all weapons utilize this."
L["settings.resetsettings.cl.title"] = "Reset all CLIENT settings"

L["settings.general.server"] = "Server"
L["settings.truenames_default.title"] = "Default True Names"
L["settings.truenames_default.desc"] = "Set the default true names mode on the server. All players using \"Default\" in preference will use this."
L["settings.truenames_enforced.title"] = "Default True Names Enforced"
L["settings.truenames_enforced.desc"] = "Set to force all players to use the server setting for true names."

L["settings.resetsettings.sv.title"] = "Reset all SERVER settings"

L["settings.reset"] = "Reset!"

////////////////////// Performance
L["settings.tabname.performance"] = "Performance"

L["settings.performance.important"] = "High Performance Impact"
L["settings.cheapscopes.title"] = "Cheap Scopes"
L["settings.cheapscopes.desc"] = "A cheap RT scope implementation by zooming your whole view to aim, instead of rendering world again in a scope. Significantly increases performance on large maps."
L["settings.tpik.title"] = "TPIK"
L["settings.tpik.desc"] = "TPIK (Third Person Inverse Kinematics) is a system that allows most weapons display detailed and same as in first person hands positions, reload and firing animations in third person.\n\nConfigure it in Visuals tab."
L["settings.allflash.title"] = "All Flashlights"
L["settings.allflash.desc"] = "Fully render all flashlights from other players.\n\nVery expensive on servers."

L["settings.performance.blur.title"] = "Blur"
L["settings.cust_blur.title"] = "Customization Background"
L["settings.cust_blur.desc"] = "Blurs customization background."
L["settings.fx_reloadblur.title"] = "While Reloading"
L["settings.fx_reloadblur.desc"] = "Blurs the world while reloading."
L["settings.fx_animblur.title"] = "While readying"
L["settings.fx_animblur.desc"] = "Blurs the world while deploying a weapon for the first time."
L["settings.fx_rtblur.title"] = "In Scopes"
L["settings.fx_rtblur.desc"] = "Blurs the world while using a magnified scope."
L["settings.fx_adsblur.title"] = "In Sights"
L["settings.fx_adsblur.desc"] = "Blurs the weapon while aiming down sights."
L["settings.fx_rtvm.title"] = "Render Weapon through RT Scopes"
L["settings.fx_rtvm.desc"] = "! EXPERIMENTAL !\nRenders the weapon and its attachments through RT scopes. Requires \"Cheap Scopes\" to be disabled.\nSignificantly reduces performance."
L["settings.fx_rtblur.title2"] = "Blur behind Scopes"

L["settings.performance.shelleject.title"] = "Shell Eject"
L["settings.eject_fx.title"] = "Smoke Effects"
L["settings.eject_fx.desc"] = "Produce smoke effects from ejected shell casings, where the weapon supports this feature"
L["settings.eject_time.title"] = "Add Life Time"
L["settings.eject_time.desc"] = "Allow shell casings to stay in the world for longer. Can be expensive."

L["settings.performance.fx.title"] = "Effects"
L["settings.muzzle_light.title"] = "Muzzle Light"
L["settings.muzzle_light.desc"] = "Enable light emitted from muzzle flashes when firing a weapon."
L["settings.muzzle_others.title"] = "Other Muzzle Effects"
L["settings.muzzle_others.desc"] = "Enable muzzle effects from other players' guns."

////////////////////// Optics
L["settings.tabname.optics"] = "Optics"

L["settings.optics.control"] = "Control"
L["settings.optics.sensmult.title"] = "Multiply ADS Sensitivity"
L["settings.optics.sensmult.desc"] = "Multiply the look sensitivity by this amount when aiming.\nThe lower the value, the lower the sensitivity.\nUseful when using controllers, or if the user just wants lower aiming sensitivity."
L["settings.optics.compensate_sens.title"] = "Compensate Sensitivity"
L["settings.optics.compensate_sens.desc"] = "Compensate sensitivity for magnification."
L["settings.optics.toggleads.title"] = "Toggle ADS"
L["settings.optics.toggleads.desc"] = "Aiming will toggle sights."

L["settings.optics.dtap_sights.title"] = "Double-Tap to Switch Sights"
L["settings.optics.dtap_sights.desc"] = "Allows double-tapping the USE key to switch sights."

L["settings.optics.color"] = "Color"
L["settings.optics.reflex.title"] = "Reflex Sights"
L["settings.optics.reflex.desc"] = "Color to use for reflex/holographic sights.\n\nNot all optics support this feature."
L["settings.optics.scope.title"] = "Scopes"
L["settings.optics.scope.desc"] = "Color to use for magnified scopes.\n\nNot all optics support this feature."

////////////////////// Crosshair
L["settings.tabname.crosshair"] = "Crosshair"

L["settings.crosshair.crosshair"] = "Crosshair"
L["settings.crosshair.cross_enable.title"] = "Enable Crosshair"
L["settings.crosshair.cross_enable.desc"] = "Enable crosshair. Some guns do not allow you to use the crosshair."
L["settings.crosshair.cross.title"] = "Crosshair Color"
L["settings.crosshair.cross.desc"] = "The color of your crosshair."
L["settings.crosshair.cross_size_mult.title"] = "Crosshair Size"
L["settings.crosshair.cross_size_mult.desc"] = "Multiply the size of your crosshair."
L["settings.crosshair.cross_size_dot.title"] = "Dot Size"
L["settings.crosshair.cross_size_dot.desc"] = "Multiply the size of the middle dot."
L["settings.crosshair.cross_size_prong.title"] = "Prong Size"
L["settings.crosshair.cross_size_prong.desc"] = "Multiply the size of the outer prongs."
L["settings.crosshair.crosshair_static.title"] = "Static Crosshair"
L["settings.crosshair.crosshair_static.desc"] = "Enable static crosshair, which does not move when shooting."
L["settings.crosshair.crosshair_force.title"] = "Force Crosshair"
L["settings.crosshair.crosshair_force.desc"] = "Force the crosshair even on guns that don't want you to see it.\n\nServer setting."
L["settings.crosshair.crosshair_target.title"] = "Red Crosshair on Target"
L["settings.crosshair.crosshair_target.desc"] = "Make the crosshair red when aiming on a target.\nAlso activates aim assist if it is turned on."
L["settings.crosshair.crosshair_peeking.title"] = "Display Crosshair when Peeking"
L["settings.crosshair.crosshair_peeking.desc"] = "Displays the crosshair when aiming and using the peek function."

////////////////////// Customization
L["settings.tabname.hud_cust"] = "Customization"

L["settings.hud_cust.hud"] = "HUD"
L["settings.hud_cust.hud_scale.title"] = "HUD Scale"
L["settings.hud_cust.hud_scale.desc"] = "Scale multiplier for ARC9's HUD."
L["settings.hud_cust.hud_deadzonex.title"] = "HUD Width Deadzone"
L["settings.hud_cust.hud_deadzonex.desc"] = "Horizontal \"deadzone\" for customization menu and HUD panel.\nUseful for ultrawide monitors."
L["settings.hud_cust.hud_color.title"] = "HUD Color"
L["settings.hud_cust.hud_color.desc"] = "Highlight color for the HUD.\nThe accent color."
L["settings.hud_cust.hud_holiday.title"] = "Holiday Themes"
L["settings.hud_cust.hud_holiday.desc"] = "Themes that activate during certain holidays.\nWill override highlight color"
L["settings.hud_cust.hud_darkmode.title"] = "Dark Theme"
L["settings.hud_cust.hud_darkmode.desc"] = "Enables dark colors in HUD instead of light gray and disables vignette effect in background."
L["settings.hud_cust.cust_light.title"] = "Enable Light"
L["settings.hud_cust.cust_light.desc"] = "Enables gun lighting in the customization menu.\n\nSame thing as button near settings button."
L["settings.hud_cust.cust_light_brightness.title"] = "Light Brightness"
L["settings.hud_cust.cust_light_brightness.desc"] = "How bright that light in the customization panel will be.\n\nDon't forget to turn it on first though!"

L["settings.hud_cust.customization"] = "Customization"
L["settings.hud_cust.cust_hints.title"] = "Hints"
L["settings.hud_cust.cust_hints.desc"] = "Enable hints in the customization menu."
L["settings.hud_cust.cust_tips.title"] = "Tips"
L["settings.hud_cust.cust_tips.desc"] = "Tips about ARC9 base near hints."
L["settings.hud_cust.cust_exit_reset_sel.title"] = "Exit Resets Selection"
L["settings.hud_cust.cust_exit_reset_sel.desc"] = "Exiting customization menu resets the active slot selection."
L["settings.hud_cust.imperial.title"] = "Imperial Measurement"
L["settings.hud_cust.imperial.desc"] = "Replaces various measurement systems to their Imperial variants.\nOnly affects the \"Stats & Ballistics\" customization screen."

////////////////////// Game HUD
L["settings.tabname.hud_game"] = "Game HUD"

L["settings.hud_game.lcd"] = "LCD Panel"
L["settings.hud_game.hud_arc9.title"] = "Enable HUD"
L["settings.hud_game.hud_arc9.desc"] = "Enable HUD for ARC9 weapons."
L["settings.hud_game.hud_always.title"] = "On all weapons"
L["settings.hud_game.hud_always.desc"] = "Enable that HUD on all weapons."
L["settings.hud_game.hud_compact.title"] = "Compact Mode"
L["settings.hud_game.hud_compact.desc"] = "Compact appearance for the HUD panel."
L["settings.hud_game.hud_nohints.title"] = "Disable Hints"
L["settings.hud_game.hud_nohints.desc"] = "Disable hints completely. They will not show up in the 3D HUD, nor in the 2D HUD."
L["settings.hud_game.hud_keephints.title"] = "Keep Hints"
L["settings.hud_game.hud_keephints.desc"] = "Show the ARC9 control hints on top on HUD panel."
L["settings.hud_game.hud_force_disable.title"] = "Force Disable HUD"
L["settings.hud_game.hud_force_disable.desc"] = "Disable ARC9 HUD for all players. Does not affect hints."

L["settings.hud_game.killfeed"] = "Killfeed"
L["settings.hud_game.killfeed_enable.title"] = "Killfeed Icons"
L["settings.hud_game.killfeed_enable.desc"] = "Enable auto-generation of killfeed icons for ARC9 guns."
L["settings.hud_game.killfeed_dynamic.title"] = "Dynamic updating"
L["settings.hud_game.killfeed_dynamic.desc"] = "Killfeed icons will be regenerated after each kill.\n\nTurn off if you want get that 0.1 fps."
L["settings.hud_game.killfeed_colour.title"] = "Full Color Icons"
L["settings.hud_game.killfeed_colour.desc"] = "Dynamically generated icons are fully colored."

L["settings.hud_game.breath"] = "Breath"
L["settings.hud_game.breath_hud.title"] = "Breath HUD"
L["settings.hud_game.breath_hud.desc"] = "Show a bar that displays your remaining breath while stabilizing your gun in sights."
L["settings.hud_game.breath_pp.title"] = "Breath Post-Process"
L["settings.hud_game.breath_pp.desc"] = "Holding breath will also add post-processing effects to your screen."
L["settings.hud_game.breath_sfx.title"] = "Breath SFX"
L["settings.hud_game.breath_sfx.desc"] = "Holding breath will play associated sound effects."

L["settings.hud_game.centerhint"] = "Tooltips"
L["settings.hud_game.centerhint_reload.title"] = "Display Reload Tip"
L["settings.hud_game.centerhint_reload.desc"] = "Display a reload tip when low on ammunition."
L["settings.hud_game.centerhint_reload_percent.title"] = "Magazine Percentage"
L["settings.hud_game.centerhint_reload_percent.desc"] = "Display the reload tip when the current magazine is at this percentage value."
L["settings.hud_game.centerhint_bipod.title"] = "Display Toggle Bipod"
L["settings.hud_game.centerhint_bipod.desc"] = "Display a tip when the bipod can be toggled."
L["settings.hud_game.centerhint_jammed.title"] = "Display Jammed Tip"
L["settings.hud_game.centerhint_jammed.desc"] = "Display a tip when your weapon is jammed."

L["settings.hud_game.centerhint_firemode.title"] = "Display Firemode Tip"
L["settings.hud_game.centerhint_firemode.desc"] = "Display a tip when you swap firing mode or toggle your safety."
L["settings.hud_game.centerhint_firemode_time.title"] = "Display Firemode Time"
L["settings.hud_game.centerhint_firemode_time.desc"] = "How long the firing mode should be displayed."

L["settings.hud_game.centerhint_overheat.title"] = "Display Overheat Tip"
L["settings.hud_game.centerhint_overheat.desc"] = "Displays an overlayed tip showing how close the weapon is to overheating.\n\nNot displayed if ARC9 HUD is enabled or the weapon does not support overheat."

L["settings.hud_game.hud_glyph"] = "Glyph Type"

L["settings.hud_game.hud_glyph_type_hud.title"] = "HUD"
L["settings.hud_game.hud_glyph_type_hud.desc"] = "Change which family of glyphs to use.\nThis affects the HUD tips."

L["settings.hud_game.hud_glyph_type_cust.title"] = "Customization Menu"
L["settings.hud_game.hud_glyph_type_cust.desc"] = "Change which family of glyphs to use.\nThis affects the customization menu tips.\nChanges apply next time the customization menu is opened."

L["settings.hud_game.hud_glyph_light"] = "Light"
L["settings.hud_game.hud_glyph_dark"] = "Dark"
L["settings.hud_game.hud_glyph_knockout"] = "Knockout"

////////////////////// NPCs
L["settings.tabname.npc"] = "NPCs"

L["settings.npc.weapons"] = "NPC Weapons"
L["settings.npc.npc_equality.title"] = "Damage Equality"
L["settings.npc.npc_equality.desc"] = "NPCs do just as much damage as players do.\n\nThis is a server variable."
L["settings.npc.npc_spread.title"] = "NPC Spread"
L["settings.npc.npc_spread.desc"] = "Multiplier for how inaccurate NPCs will be when firing."
L["settings.npc.npc_atts.title"] = "Give Attachments"
L["settings.npc.npc_atts.desc"] = "Spawned or given ARC9 weapons receive a random set of attachments.\n\nThis is a server variable."
L["settings.npc.npc_autoreplace.title"] = "Replace NPC Weapons"
L["settings.npc.npc_autoreplace.desc"] = "Replace NPC weapons with randomly chosen ARC9 weapons.\n\nThis is a server variable."
L["settings.npc.replace_spawned.title"] = "Replace Ground Weapons"
L["settings.npc.replace_spawned.desc"] = "Replace map/spawned HL2 weapons with randomly chosen ARC9 weapons.\n\nThis is a server variable."
L["settings.npc.npc_give_weapons.title"] = "Players Can Give Weapons"
L["settings.npc.npc_give_weapons.desc"] = "Players are able to press E on NPCs to give them their weapon.\n\nThis is a server variable."

////////////////////// Gameplay
L["settings.tabname.gameplay"] = "Gameplay"

L["settings.gameplay.controls"] = "Controls"
L["settings.gameplay.toggleads.title"] = "Toggle ADS"
L["settings.gameplay.toggleads.desc"] = "Aiming will toggle sights."
L["settings.gameplay.autolean.title"] = "Automatic Lean"
L["settings.gameplay.autolean.desc"] = "Aiming will try to automatically lean if this is possible."
L["settings.gameplay.autoreload.title"] = "Automatic Reload"
L["settings.gameplay.autoreload.desc"] = "Empty ARC9 weapons will reload automatically."
L["settings.gameplay.togglelean.title"] = "Toggle Lean"
L["settings.gameplay.togglelean.desc"] = "Pressing the lean keys will toggle leaning instead of needing to be held down.\n\nWorks poorly in conjunction with autolean. If using toggle lean, you should disable autolean."
L["settings.gameplay.togglepeek.title"] = "Toggle Peek"
L["settings.gameplay.togglepeek.desc"] = "Pressing the peek key will toggle peeking instead of needing to be held down."
L["settings.gameplay.togglepeek_reset.title"] = "Reset Peek State After Aiming"
L["settings.gameplay.togglepeek_reset.desc"] = "(Only if Toggle Peek is on)\nPeek state will not be retained when exiting aim down sights."
L["settings.gameplay.togglebreath.title"] = "Toggle Holding Breath"
L["settings.gameplay.togglebreath.desc"] = "Pressing the Holding Breath key will toggle Holding Breath instead of needing to be held down."

L["settings.gameplay.mechanics"] = "Game Mechanics"
L["settings.gameplay.infinite_ammo.title"] = "Infinite Ammo"
L["settings.gameplay.infinite_ammo.desc"] = "Weapons have infinite ammunition.\n\nThis is a server variable."
L["settings.gameplay.realrecoil.title"] = "Physical Visual Recoil"
L["settings.gameplay.realrecoil.desc"] = "Select weapons set up for this feature experience physical muzzle rise, meaning they will fire where their viewmodel shows it rather than at the center of the screen. Very important for some weapon packs' balancing schemes.\n\nThis is a server variable."
L["settings.gameplay.lean.title"] = "Leaning"
L["settings.gameplay.lean.desc"] = "Whether players can lean with +alt1 and +alt2, including automatic lean.\n\nThis is a server variable."
L["settings.gameplay.mod_sway.title"] = "Sway"
L["settings.gameplay.mod_sway.desc"] = "Weapons will have sway, if they are set up to use it.\n\nThis is a server variable."
L["settings.gameplay.mod_freeaim.title"] = "Free Aim"
L["settings.gameplay.mod_freeaim.desc"] = "Weapons will have free aim, and will not always shoot in the middle of the screen.\n\nThis is a server variable."
L["settings.gameplay.mod_bodydamagecancel.title"] = "Body Damage Cancel"
L["settings.gameplay.mod_bodydamagecancel.desc"] = "Cancel out default body damage multiplier. Only disable if using another mod that provides this type of functionality.\ne.g. Mods which change the default limb multipliers.\n\nThis is a server variable."
L["settings.gameplay.breath_slowmo.title"] = "Slow-Mo Breath"
L["settings.gameplay.breath_slowmo.desc"] = "Holding breath slows time.\n\nSingleplayer only."
L["settings.gameplay.manualbolt.title"] = "Manual Cycling"
L["settings.gameplay.manualbolt.desc"] = "Bolt-action weapons configured for this feature will only bolt when R is pressed, and not when the attack key is released."
L["settings.gameplay.never_ready.title"] = "No Ready Anims"
L["settings.gameplay.never_ready.desc"] = "Disable ready animations when deploying a weapon.\n\nThis is a server variable."
L["settings.gameplay.recoilshake.title"] = "Recoil FOV Shake"
L["settings.gameplay.recoilshake.desc"] = "Snaps field of view when shooting"
L["settings.gameplay.equipment_generate_ammo.title"] = "Unique Ammo Types for Equipment"
L["settings.gameplay.equipment_generate_ammo.desc"] = "There is a limit of 255 ammo types, and disabling this option may help fix some problems if you have lots of addons.\n\nThis is a server variable.\n\nRequires restart."

-- ??
L["settings.gameplay.mult_defaultammo.title"] = "Default Reserve Ammo"
L["settings.gameplay.mult_defaultammo.desc"] = "How many magazines/grenades/equipment give to player when he takes weapon for first time?\n\nThis is a server variable."
L["settings.gameplay.nearwall.title"] = "Near-walling"
L["settings.gameplay.nearwall.desc"] = "Not allow gun shoot when you standing too close to wall or any obstacle."

////////////////////// Visuals
L["settings.tabname.visuals"] = "Visuals"

L["settings.visuals.viewmodel"] = "Viewmodel"
L["settings.visuals.vm_bobstyle.title"] = "Bob Style"
L["settings.visuals.vm_bobstyle.desc"] = "Select different viewmodel bobbing styles, to the flavor of different contributors of ARC9 (and Valve Software)."
L["settings.visuals.fov.title"] = "FOV"
L["settings.visuals.fov.desc"] = "Add viewmodel FOV. Makes the viewmodel bigger or smaller. Use responsibly."
L["settings.visuals.vm_addx.title"] = "Add X"
L["settings.visuals.vm_addx.desc"] = "Shift the viewmodel to the right or left."
L["settings.visuals.vm_addy.title"] = "Add Y"
L["settings.visuals.vm_addy.desc"] = "Shift the viewmodel forwards and backwards."
L["settings.visuals.vm_addz.title"] = "Add Z"
L["settings.visuals.vm_addz.desc"] = "Shift the viewmodel up and down."

L["settings.visuals.cambob"] = "View Bobbing"
L["settings.visuals.vm_cambob.title"] = "Sprint View Bobbing"
L["settings.visuals.vm_cambob.desc"] = "Makes your camera move when you sprinting"
L["settings.visuals.vm_cambobwalk.title"] = "Walk View Bobbing"
L["settings.visuals.vm_cambobwalk.desc"] = "Makes your camera slightly move when you walking around (requires sprint bobbing)"
L["settings.visuals.vm_cambobintensity.title"] = "Intensity"
L["settings.visuals.vm_cambobintensity.desc"] = "How intense bobbing will be"

L["settings.visuals.tpik"] = "TPIK"
L["settings.visuals.tpik.title"] = "Enable TPIK"
L["settings.visuals.tpik.desc"] = "TPIK (Third Person Inverse Kinematics) is a system that allows most weapons display detailed and same as in first person hands positions, reload and firing animations in third person."
L["settings.visuals.tpik_others.title"] = "Other Players TPIK"
L["settings.visuals.tpik_others.desc"] = "Show TPIK for players other than yourself. Negatively impacts performance."
L["settings.visuals.tpik_framerate.title"] = "TPIK Framerate"
L["settings.visuals.tpik_framerate.desc"] = "Maximum framerate at which TPIK can run. Set to 0 for unlimited."

////////////////////// Bullet Physics
L["settings.tabname.bullets"] = "Bullet Physics"

L["settings.bullets.bullets"] = "Bullet Physics"
L["settings.bullets.bullet_physics.title"] = "Physical Bullets"
L["settings.bullets.bullet_physics.desc"] = "Weapons that support this feature will fire physical bullets, which have drop, travel time, and drag.\n\nThis is a server variable."
L["settings.bullets.bullet_gravity.title"] = "Gravity"
L["settings.bullets.bullet_gravity.desc"] = "Multiplier for bullet gravity.\n\nThis is a server variable."
L["settings.bullets.bullet_drag.title"] = "Drag"
L["settings.bullets.bullet_drag.desc"] = "Multiplier for bullet drag.\n\nThis is a server variable."
L["settings.bullets.ricochet.title"] = "Ricochet"
L["settings.bullets.ricochet.desc"] = "Bullets fired from select weapons can sometimes bounce off of surfaces and continue to travel and do damage.\n\nThis is a server variable."
L["settings.bullets.mod_penetration.title"] = "Penetration"
L["settings.bullets.mod_penetration.desc"] = "Bullets fired from select weapons can penetrate surfaces and deal damage to whatever is on the other side.\n\nThis is a server variable."
L["settings.bullets.bullet_lifetime.title"] = "Life Time"
L["settings.bullets.bullet_lifetime.desc"] = "Time in seconds after which a bullet will be deleted.\n\nThis is a server variable."
L["settings.bullets.bullet_imaginary.title"] = "Imaginary Bullets"
L["settings.bullets.bullet_imaginary.desc"] = "Bullets will appear to travel into the skybox, beyond the map's bounds."

////////////////////// Attachments
L["settings.tabname.attachments"] = "Attachments"

L["settings.attachments.customization"] = "Customization"
L["settings.attachments.atts_nocustomize.title"] = "Disable Customization"
L["settings.attachments.atts_nocustomize.desc"] = "Disallow all customization via the customization menu.\n\nThis is a server variable."
L["settings.attachments.atts_max.title"] = "Max Attachments"
L["settings.attachments.atts_max.desc"] = "The maximum number of attachments that can be put on a weapon, including cosmetic attachments.\n\nThis is a server variable."
L["settings.attachments.autosave.title"] = "Autosave"
L["settings.attachments.autosave.desc"] = "Your last weapon customization options will be saved and automatically applied the next time you spawn that weapon."
L["settings.attachments.blacklist.title"] = "Blacklist Menu"
L["settings.attachments.blacklist.open"] = "Open"

L["settings.attachments.inventory"] = "Inventory"
L["settings.attachments.free_atts.title"] = "Free Attachments"
L["settings.attachments.free_atts.desc"] = "Attachments can be used without being picked up first.\n\nThis is a server variable."
L["settings.attachments.atts_lock.title"] = "One For All"
L["settings.attachments.atts_lock.desc"] = "Picking up one instance of an attachments allows you to use it infinite times on all your guns.\n\nThis is a server variable."
L["settings.attachments.atts_loseondie.title"] = "Lose On Death"
L["settings.attachments.atts_loseondie.desc"] = "Your attachment inventory will be lost when you die.\n\nThis is a server variable."
L["settings.attachments.atts_generateentities.title"] = "Generate Entities"
L["settings.attachments.atts_generateentities.desc"] = "Generate entities that can be spawned, allowing you to pick up attachments when free attachments is off.\n\nMight increase load time.\n\nThis is a server variable."

////////////////////// Modifiers
L["settings.tabname.modifiers"] = "Modifiers"

L["settings.modifiers.quick.title"] = "Quick Stats Modifiers"
L["settings.modifiers.quick.desc"] = " "

L["settings.mod_damage.title"] = "Damage"
L["settings.mod_spread.title"] = "Spread"
L["settings.mod_recoil.title"] = "Recoil"
L["settings.mod_visualrecoil.title"] = "Visual Recoil"
L["settings.mod_adstime.title"] = "Aim Down Sights Time"
L["settings.mod_sprinttime.title"] = "Sprint To Fire Time"
L["settings.mod_damagerand.title"] = "Damage Variance"
L["settings.mod_muzzlevelocity.title"] = "Muzzle Velocity"
L["settings.mod_rpm.title"] = "RPM"
L["settings.mod_headshotdamage.title"] = "Headshot Damage"
L["settings.mod_malfunction.title"] = "Malfunction Chance"

////////////////////// Controller
L["settings.tabname.controller"] = "Controller"

L["settings.controller.misc"] = "Misc"
L["settings.controller.misc.desc"] = "There should be button that will open panel with advanced controller config, but for now it is in  spawnmenu > Options > ARC9 > Controller."
L["settings.controller.controller.title"] = "Enable Controller Mode"
L["settings.controller.controller.desc"] = "Enable custom controller-compatible glyphs, showing controller buttons instead of the default keys."
-- L["settings.controller.controller_rumble.title"] = "Rumble"
-- L["settings.controller.controller_rumble.desc"] = "Enable controller rumble as long as Fesiug's DLL mod is loaded.\n\ngithub.com/Fesiug/\ngmod-sinput"
L["settings.controller.controller_config.title"] = "Advanced config"
L["settings.controller.controller_config.content"] = "Open panel"
L["settings.controller.controller_config.desc"] = "Open advanced controller configuration panel."

L["settings.controller.glyphs.title"] = "Glyph Type"
L["settings.controller.glyphs.desc"] = "Choose which family of glyphs you want to use.\nSet up glyphs in \"Spawnmenu\" > Options > ARC9 > Controller."

////////////////////// Aim Assist
L["settings.tabname.aimassist"] = "Aim Assist"
L["settings.tabname.aimassist.desc"] = "You can enable aim assistance if you might have trouble keeping your aim on your target, or if you just prefer to not put effort into shooting your targets."

L["settings.aimassist.enable.title"] = "Enable Aim Assist"
L["settings.aimassist.enable.desc"] = "Enables an aim assistance feature that moves your aim towards a target when aiming near them.\n\nThis is a server variable.\n\nRequires Aim Assist to be enabled on CLIENT."

L["settings.aimassist.enable_general.desc"] = "Enables an aim assistance feature that moves your aim towards a target when aiming near them.\n\nConfigure it in the \"Aim Assist\" tab."

L["settings.aimassist.enable_client.desc"] = "Enables an aim assistance feature that moves your aim towards a target when aiming near them.\n\nRequires Aim Assist to be enabled on SERVER."

L["settings.aimassist.intensity.title"] = "Intensity"
L["settings.aimassist.intensity.desc"] = "How intense the aim assist is.\n\nThis is a server variable."

L["settings.aimassist.cone.title"] = "Cone"
L["settings.aimassist.cone.desc"] = "How close or far away you need to look towards a target before the aim assist engages.\n\nThis is a server variable."

L["settings.aimassist.head.title"] = "Lock onto head"
L["settings.aimassist.head.desc"] = "If the aim assist should lock onto the target's head instead of its chest.\n\nThis is a server variable."

L["settings.aimassist.sensmult.desc"] = "Multiply the look sensitivity by this amount when hovering over a valid target.\nThe lower the value, the lower the sensitivity."

////////////////////// Asset Caching
L["settings.tabname.caching"] = "Asset Caching"
L["settings.caching.title"] = "Asset Caching"
L["settings.caching.desc"] = "You can cache some ARC9 assets (save in memory without loading while playing) to prevent stutters for comfort gameplay!\n\nYou surely should enable some stuff if your gmod running on HDD."

L["settings.caching.precache_sounds_onfirsttake.title"] = "On first equip: Cache gun sounds"
L["settings.caching.precache_sounds_onfirsttake.desc"] = "Caches all sounds only from gun you just took in hands (except reload sounds).\n\nNot any impactful, rather helpful to prevent stutters while firing."

L["settings.caching.precache_attsmodels_onfirsttake.title"] = "On first equip: Cache all attachments"
L["settings.caching.precache_attsmodels_onfirsttake.desc"] = "Caches all ARC9 attachments models when any ARC9 weapon was first equipped.\n\nCauses pretty big freeze, especially when you have lots of weapons."
L["settings.caching.precache_wepmodels_onfirsttake.title"] = "On first equip: Cache all weapon models"
L["settings.caching.precache_wepmodels_onfirsttake.desc"] = "Caches all ARC9 weapons viewmodels when any ARC9 weapon was first equipped.\n\nCauses REALLY BIG freeze, especially when you have lots of weapons."

L["settings.caching.precache_allsounds_onstartup.title"] = "On game start: Cache all guns sounds"
L["settings.caching.precache_allsounds_onstartup.desc"] = "Caches all sounds from all guns on server start-up. (except reload sounds).\n\nNot so impactful, but anyway you better use first option here."
L["settings.caching.precache_attsmodels_onstartup.title"] = "On game start: Cache all attachments"
L["settings.caching.precache_attsmodels_onstartup.desc"] = "Caches all ARC9 attachments models on server start-up.\n\nCauses pretty big load time increase, especially when you have lots of weapons."
L["settings.caching.precache_wepmodels_onstartup.title"] = "On game start: Cache all weapon models"
L["settings.caching.precache_wepmodels_onstartup.desc"] = "Caches all ARC9 weapons viewmodels on server start-up.\n\nCauses REALLY BIG load time increase, especially when you have lots of weapons."

L["settings.caching.precache_allsounds.title"] = "All weapon sounds"
L["settings.caching.precache_wepmodels.title"] = "All weapon models"
L["settings.caching.precache_attsmodels.title"] = "All attachments models"

L["settings.developer.cache"] = "Cache"

////////////////////// Developer
L["settings.tabname.developer"] = "Developer"

L["settings.developer.developer"] = "Developer Options"
L["settings.developer.dev_always_ready.title"] = "Always Ready"
L["settings.developer.dev_always_ready.desc"] = "Always play \"ready\" animation when deploying a weapon.\n\nThis is a server variable."
L["settings.developer.dev_benchgun.title"] = "Benchgun"
L["settings.developer.dev_benchgun.desc"] = "Keep the weapon where it currently is."
L["settings.developer.dev_crosshair.title"] = "Dev Crosshair"
L["settings.developer.dev_crosshair.desc"] = "Funky looking crosshair showing the exact point of aim and some useful numbers.\n\nThis is a server variable, and only works for admins - don't get cheaty with this!"
L["settings.developer.dev_show_affectors.title"] = "Display Affectors"
L["settings.developer.dev_show_affectors.desc"] = "Displays which current affectors are currently applied.\n\nRequires \"Dev Crosshair\"."
L["settings.developer.dev_show_shield.title"] = "Show Shield"
L["settings.developer.dev_show_shield.desc"] = "Show the model for the player's shield."
L["settings.developer.dev_greenscreen.title"] = "Green Screen"
L["settings.developer.dev_greenscreen.desc"] = "Show a green screen background in the customisation menu for screenshots.\n\nIf you are using HDR, don't forget to set mat_bloom_scalefactor_scalar to 0!"
L["settings.developer.reloadatts.title"] = "Reload Attachments"
L["settings.developer.reloadlangs.title"] = "Reload Languages"
L["settings.developer.dev_listmyatts.title"] = "List My Attachments"
L["settings.developer.dev_listanims.title"] = "List Anims"
L["settings.developer.dev_listbones.title"] = "List Bones"
L["settings.developer.dev_listbgs.title"] = "List Bodygroups"
L["settings.developer.dev_listatts.title"] = "List QCAttachments"
L["settings.developer.dev_listmats.title"] = "List Materials"
L["settings.developer.dev_export.title"] = "Get Export Code"
L["settings.developer.dev_getjson.title"] = "Get Weapon JSON"

L["settings.developer.presets_clear.title"] = "Clear weapon data"
L["settings.developer.presets_clear.desc"] = "Clear presets, all icons and default preset for weapon you currently holding.\n\nWarning: if menu opened without ARC9 weapon in hands it will delete all existing ARC9 presets and icons!"

L["settings.developer.clear"] = "Clear"
L["settings.developer.print"] = "Print to Console"
L["settings.developer.reload"] = "Reload"

////////////////////// ARC9 Premium
L["premium.title"] = "ARC9 Premium"
L["premium.desc"] = "ARC9 Premium allows additional customization as a major thanks for supporting the addon financially."

L["premium.requires"] = "Requires <color=255,106,0>ARC9 Premium</color>."
L["premium.acquire"] = "Subscribe to <color=255,106,0>ARC9 Premium</color>"

L["premium.ownedno"] = "<color=255,106,0>ARC9 Premium</color>: <color=255,100,100>Not owned</color>"
L["premium.owned"] = "<color=255,106,0>ARC9 Premium</color>: <color=255,100,100>Owned</color>"

L["premium.help"] = "What is ARC9 Premium?"
L["premium.help.header"] = "Guide to ARC9 Premium"
L["premium.help.desc"] = "Creating addons takes time and resources. ARC9 has always been available for free, and it will remain that way. However, if you wish to support the base financially, you may do so, and get rewarded for it!"

L["premium.help.ownedbutnoaccess"] = "Have you recently purchased ARC9 Premium, but do not have automatic access to it? Contact us on the Diamond Doves Discord Server for assistance.\nEnsure you can provide proof of purchase before contacting. Simply saying \"I buy, now give\" is not good enough."

L["premium.content"] = "Included in <color=255,106,0>ARC9 Premium</color>:"
L["premium.content.list"] = [[
- Unlimited Customization Slots (Increased from 32)
- Unlimited Preset Slots (Increased from 10 per weapon)
- Access to Supermodifier settings*
- Access to an exclusive Dark UI mode
- Ability to colour optic reticles, UI and more
- Exclusive camos made available through the base
- Exclusive support channel on Discord

*Requires administrator if on a server
]]

L["premium.payment.month"] = [[
$%s
Acquire ARC9 Premium for 1 Month.
]]

L["premium.payment.months"] = [[
$%s
Acquire ARC9 Premium for %s Months and get a <color=100,255,100>%s%% discount</color>!
]]

L["premium.payment.info"] = [[
Purchasing ARC9 Premium grants immediate access to all the contents listed previously for the time purchased.
Time can be extended by purchasing any of the options once more, and the time will refresh automatically once the original time has expired.
Once the time has passed, and no additional payment has been made, access to ARC9 Premium will be removed.

All customization options, including attachment slots, presets and coloured reticles made with ARC9 Premium will remain available, but you will not alter them or add any additional ones.
]]

L["premium.purchased"] = "Purchased <color=255,106,0>ARC9 Premium</color>!"
L["premium.purchased.desc"] = [[
Thank you for purchasing ARC9 Premium! You made the bird a very happy one!

A receipt will be sent to your connected Email.

If you have not immediately acquired access to the ARC9 Premium bonuses, please rejoin the server, or restart your game.

If you are still having problems with it, or if you still have not been granted Premium, then do visit the Diamond Doves Discord server and provide valid proof of purchase, and we will have it fixed for you.
]]

--PATH lua/arc9/common/localization/content_base_es-es.lua:
return gluapack()()
--PATH lua/arc9/common/localization/font_zh-cn.lua:
return gluapack()()
--PATH lua/arc9/common/sh_common.lua:
ARC9.PenTable = {
    [MAT_ANTLION]     = 1,
    [MAT_BLOODYFLESH] = 1,
    [MAT_CONCRETE]    = 1,
    [MAT_DIRT]        = 1,
    [MAT_EGGSHELL]    = 1,
    [MAT_FLESH]       = 1,
    [MAT_GRATE]       = 1,
    [MAT_ALIENFLESH]  = 1,
    [MAT_CLIP]        = 1,
    [MAT_SNOW]        = 1,
    [MAT_PLASTIC]     = 1,
    [MAT_METAL]       = 2,
    [MAT_SAND]        = 1,
    [MAT_FOLIAGE]     = 1,
    [MAT_COMPUTER]    = 1,
    [MAT_SLOSH]       = 1,
    [MAT_TILE]        = 1,
    [MAT_GRASS]       = 1,
    [MAT_VENT]        = 1,
    [MAT_WOOD]        = 0.5,
    [MAT_DEFAULT]     = 1,
    [MAT_GLASS]       = 0.25,
    [MAT_WARPSHIELD]  = 1,
}

ARC9.CosmeticCategories = {
    ["charm"] = true,
    ["camo"] = true,
    ["stickers"] = true,
}
ARC9.ShellSoundsTable = {
    "arc9/casings/casing_556_1.ogg",
    "arc9/casings/casing_556_2.ogg",
    "arc9/casings/casing_556_3.ogg",
    "arc9/casings/casing_556_4.ogg",
    "arc9/casings/casing_308_1.ogg",
    "arc9/casings/casing_308_2.ogg",
    "arc9/casings/casing_308_3.ogg",
    "arc9/casings/casing_308_4.ogg"
}

ARC9.PistolShellSoundsTable = {
    "arc9/casings/casing_9mm_1.ogg",
    "arc9/casings/casing_9mm_2.ogg",
    "arc9/casings/casing_9mm_3.ogg",
    "arc9/casings/casing_9mm_4.ogg",
    "arc9/casings/casing_9mm_1.ogg",
    "arc9/casings/casing_9mm_2.ogg",
    "arc9/casings/casing_9mm_3.ogg",
    "arc9/casings/casing_9mm_4.ogg"
}

ARC9.TinyShellSoundsTable = {
    "arc9/casings/casing_22_1.ogg",
    "arc9/casings/casing_22_2.ogg",
    "arc9/casings/casing_22_3.ogg",
    "arc9/casings/casing_22_4.ogg",
    "arc9/casings/casing_22_1.ogg",
    "arc9/casings/casing_22_2.ogg",
    "arc9/casings/casing_22_3.ogg",
    "arc9/casings/casing_22_4.ogg"
}

ARC9.ShotgunShellSoundsTable = {
    "arc9/casings/casing_12ga_1.ogg",
    "arc9/casings/casing_12ga_2.ogg",
    "arc9/casings/casing_12ga_3.ogg",
    "arc9/casings/casing_12ga_4.ogg",
    "arc9/casings/casing_12ga_1.ogg",
    "arc9/casings/casing_12ga_2.ogg",
    "arc9/casings/casing_12ga_3.ogg",
    "arc9/casings/casing_12ga_4.ogg"
}

ARC9.RicochetSounds = {
    "arc9/fx/ricochet_01.ogg",
	"arc9/fx/ricochet_02.ogg",
	"arc9/fx/ricochet_03.ogg",
	"arc9/fx/ricochet_04.ogg",
	"arc9/fx/ricochet_05.ogg",
	"arc9/fx/ricochet_06.ogg",
	"arc9/fx/ricochet_07.ogg",
	"arc9/fx/ricochet_08.ogg",
	"arc9/fx/ricochet_09.ogg",
	"arc9/fx/ricochet_10.ogg",
	"arc9/fx/ricochet_11.ogg",
	"arc9/fx/ricochet_12.ogg",
	"arc9/fx/ricochet_13.ogg",
	"arc9/fx/ricochet_14.ogg",
	"arc9/fx/ricochet_15.ogg"
 }

ARC9.PresetPath = "arc9_presets/"
ARC9.PresetIconFormat = "arc9.png"

ARC9.ATTsHaveBeenReloaded = false
ARC9.OverDraw = false

ARC9.LHIKHandBones = {
    "ValveBiped.Bip01_L_Wrist",
    "ValveBiped.Bip01_L_Ulna",
    "ValveBiped.Bip01_L_Hand",
    "ValveBiped.Bip01_L_Finger4",
    "ValveBiped.Bip01_L_Finger41",
    "ValveBiped.Bip01_L_Finger42",
    "ValveBiped.Bip01_L_Finger3",
    "ValveBiped.Bip01_L_Finger31",
    "ValveBiped.Bip01_L_Finger32",
    "ValveBiped.Bip01_L_Finger2",
    "ValveBiped.Bip01_L_Finger21",
    "ValveBiped.Bip01_L_Finger22",
    "ValveBiped.Bip01_L_Finger1",
    "ValveBiped.Bip01_L_Finger11",
    "ValveBiped.Bip01_L_Finger12",
    "ValveBiped.Bip01_L_Finger0",
    "ValveBiped.Bip01_L_Finger01",
    "ValveBiped.Bip01_L_Finger02"
}

ARC9.RHIKHandBones = {
    "ValveBiped.Bip01_R_Wrist",
    "ValveBiped.Bip01_R_Ulna",
    "ValveBiped.Bip01_R_Hand",
    "ValveBiped.Bip01_R_Finger4",
    "ValveBiped.Bip01_R_Finger41",
    "ValveBiped.Bip01_R_Finger42",
    "ValveBiped.Bip01_R_Finger3",
    "ValveBiped.Bip01_R_Finger31",
    "ValveBiped.Bip01_R_Finger32",
    "ValveBiped.Bip01_R_Finger2",
    "ValveBiped.Bip01_R_Finger21",
    "ValveBiped.Bip01_R_Finger22",
    "ValveBiped.Bip01_R_Finger1",
    "ValveBiped.Bip01_R_Finger11",
    "ValveBiped.Bip01_R_Finger12",
    "ValveBiped.Bip01_R_Finger0",
    "ValveBiped.Bip01_R_Finger01",
    "ValveBiped.Bip01_R_Finger02"
}

ARC9.TPIKBones = {
    "ValveBiped.Bip01_L_Wrist",
    "ValveBiped.Bip01_L_Ulna",
    "ValveBiped.Bip01_L_Hand",
    "ValveBiped.Bip01_L_Finger4",
    "ValveBiped.Bip01_L_Finger41",
    "ValveBiped.Bip01_L_Finger42",
    "ValveBiped.Bip01_L_Finger3",
    "ValveBiped.Bip01_L_Finger31",
    "ValveBiped.Bip01_L_Finger32",
    "ValveBiped.Bip01_L_Finger2",
    "ValveBiped.Bip01_L_Finger21",
    "ValveBiped.Bip01_L_Finger22",
    "ValveBiped.Bip01_L_Finger1",
    "ValveBiped.Bip01_L_Finger11",
    "ValveBiped.Bip01_L_Finger12",
    "ValveBiped.Bip01_L_Finger0",
    "ValveBiped.Bip01_L_Finger01",
    "ValveBiped.Bip01_L_Finger02",
    "ValveBiped.Bip01_R_Wrist",
    "ValveBiped.Bip01_R_Ulna",
    "ValveBiped.Bip01_R_Hand",
    "ValveBiped.Bip01_R_Finger4",
    "ValveBiped.Bip01_R_Finger41",
    "ValveBiped.Bip01_R_Finger42",
    "ValveBiped.Bip01_R_Finger3",
    "ValveBiped.Bip01_R_Finger31",
    "ValveBiped.Bip01_R_Finger32",
    "ValveBiped.Bip01_R_Finger2",
    "ValveBiped.Bip01_R_Finger21",
    "ValveBiped.Bip01_R_Finger22",
    "ValveBiped.Bip01_R_Finger1",
    "ValveBiped.Bip01_R_Finger11",
    "ValveBiped.Bip01_R_Finger12",
    "ValveBiped.Bip01_R_Finger0",
    "ValveBiped.Bip01_R_Finger01",
    "ValveBiped.Bip01_R_Finger02"
}

ARC9.LHIKBones = {
    "ValveBiped.Bip01_L_UpperArm",
    "ValveBiped.Bip01_L_Forearm",
    "ValveBiped.Bip01_L_Wrist",
    "ValveBiped.Bip01_L_Ulna",
    "ValveBiped.Bip01_L_Hand",
    "ValveBiped.Bip01_L_Finger4",
    "ValveBiped.Bip01_L_Finger41",
    "ValveBiped.Bip01_L_Finger42",
    "ValveBiped.Bip01_L_Finger3",
    "ValveBiped.Bip01_L_Finger31",
    "ValveBiped.Bip01_L_Finger32",
    "ValveBiped.Bip01_L_Finger2",
    "ValveBiped.Bip01_L_Finger21",
    "ValveBiped.Bip01_L_Finger22",
    "ValveBiped.Bip01_L_Finger1",
    "ValveBiped.Bip01_L_Finger11",
    "ValveBiped.Bip01_L_Finger12",
    "ValveBiped.Bip01_L_Finger0",
    "ValveBiped.Bip01_L_Finger01",
    "ValveBiped.Bip01_L_Finger02"
}

ARC9.RHIKBones = {
    "ValveBiped.Bip01_R_UpperArm",
    "ValveBiped.Bip01_R_Forearm",
    "ValveBiped.Bip01_R_Wrist",
    "ValveBiped.Bip01_R_Ulna",
    "ValveBiped.Bip01_R_Hand",
    "ValveBiped.Bip01_R_Finger4",
    "ValveBiped.Bip01_R_Finger41",
    "ValveBiped.Bip01_R_Finger42",
    "ValveBiped.Bip01_R_Finger3",
    "ValveBiped.Bip01_R_Finger31",
    "ValveBiped.Bip01_R_Finger32",
    "ValveBiped.Bip01_R_Finger2",
    "ValveBiped.Bip01_R_Finger21",
    "ValveBiped.Bip01_R_Finger22",
    "ValveBiped.Bip01_R_Finger1",
    "ValveBiped.Bip01_R_Finger11",
    "ValveBiped.Bip01_R_Finger12",
    "ValveBiped.Bip01_R_Finger0",
    "ValveBiped.Bip01_R_Finger01",
    "ValveBiped.Bip01_R_Finger02"
}

ARC9.CancelMultipliers = {
    [1] = {
        [HITGROUP_HEAD]     = 2,
        [HITGROUP_CHEST]    = 1,
        [HITGROUP_STOMACH]  = 1,
        [HITGROUP_LEFTARM]  = 0.25,
        [HITGROUP_RIGHTARM] = 0.25,
        [HITGROUP_LEFTLEG]  = 0.25,
        [HITGROUP_RIGHTLEG] = 0.25,
        [HITGROUP_GEAR]     = 1,
        [HITGROUP_GENERIC]  = 1,
    },
    ["terrortown"] = {
        [HITGROUP_HEAD]     = 1, -- TTT headshot damage is per weapon, there is no global multiplier.
        [HITGROUP_CHEST]    = 1,
        [HITGROUP_STOMACH]  = 1,
        [HITGROUP_LEFTARM]  = 0.55,
        [HITGROUP_RIGHTARM] = 0.55,
        [HITGROUP_LEFTLEG]  = 0.55,
        [HITGROUP_RIGHTLEG] = 0.55,
        [HITGROUP_GEAR]     = 1,
        [HITGROUP_GENERIC]  = 1,
    },
}

-- 0.0254 is only applicable to model scale, since actual map scaling is based on 1 foot = 16 units.
-- Not changing this in case some other addon is using the constant as stat
ARC9.HUToM = 0.0254

-- 10 / 360 / 60 is incorrect, how'd you even get it?
-- MOA is 1/60 of a degree, 1 radian = 57.2958 degrees
-- Not changing this in case some other addon is using the constant as stat
ARC9.MOAToAcc = 10 / 360 / 60
ARC9.TrueMOAToAcc = 1 / 60 / 57.2958

ARC9.Version = "1.0"

ARC9.NADETHROWTYPE_NORMAL = 0
ARC9.NADETHROWTYPE_TOSS = 1
ARC9.NADETHROWTYPE_EXPLODEINHANDS = 2

ARC9.CHAN_AUTO = 0
ARC9.CHAN_WEAPON = 1
ARC9.CHAN_DISTANT = 136
ARC9.CHAN_LAYER = 137
ARC9.CHAN_INDOOR = 139
ARC9.CHAN_INDOORDISTANT = 144
ARC9.CHAN_INDOORLAYER = 6
ARC9.CHAN_FIDDLE = 6
ARC9.CHAN_TRIGGER = 141
ARC9.CHAN_MELEE = 142
ARC9.CHAN_BREATH = 143

--USE THESE ENUMS IN A SWEP'S LUA FOR HL2 WEAPON REPLACEMENTS
-- I.E.:    "SWEP.ARC9WeaponCategory = 1"     WILL REPLACE PISTOLS AND MAGNUM REVOLVERS

ARC9.WEAPON_PISTOL = 1
ARC9.WEAPON_SHOTGUN = 2
ARC9.WEAPON_SMG = 3
ARC9.WEAPON_AR = 4
ARC9.WEAPON_SNIPER = 5
ARC9.WEAPON_RPG = 6
ARC9.WEAPON_MELEE = 7
ARC9.WEAPON_FRAG = 8
ARC9.WEAPON_SPECIAL = 9
ARC9.WEAPON_MISC = 0

ARC9.IMPULSE_TOGGLEATTS = 40

ARC9.IN_CUSTOMIZE = IN_WEAPON1
ARC9.IN_MELEE = IN_BULLRUSH
ARC9.IN_UBGL = IN_WEAPON2
ARC9.IN_INSPECT = IN_CANCEL
ARC9.IN_SWITCHSIGHTS = IN_RUN
-- Official enums end at 2^24
-- IN flags is 32 bit!
-- We still have 7 free values!!!
-- Use them up!!!!!

-- Used in dmginfo:SetDamageCustom to denote pending AP damage
ARC9.DMG_CUST_AP = 4096

ARC9.HL2Replacements = {
    ["weapon_pistol"] = {ARC9.WEAPON_PISTOL},
    ["weapon_357"] = {ARC9.WEAPON_PISTOL, ARC9.WEAPON_SNIPER},
    ["weapon_smg1"] = {ARC9.WEAPON_SMG},
    ["weapon_ar2"] = {ARC9.WEAPON_AR},
    ["weapon_shotgun"] = {ARC9.WEAPON_SHOTGUN},
    ["weapon_crossbow"] = {ARC9.WEAPON_SNIPER},
    ["weapon_crowbar"] = {ARC9.WEAPON_MELEE},
    ["weapon_rpg"] = {ARC9.WEAPON_RPG},
    ["weapon_frag"] = {ARC9.WEAPON_FRAG},
    ["weapon_alyxgun"] = {ARC9.WEAPON_SPECIAL},
    ["weapon_annabelle"] = {ARC9.WEAPON_SPECIAL, ARC9.WEAPON_SHOTGUN}
}

do
    local cvarDeveloper = GetConVar("developer")
    local cvarGetInt = FindMetaTable("ConVar").GetInt

    ARC9.DevCheckCached = false 

    local engineTickCount = engine.TickCount
    local ARC9DevCheckTick, ARC9DevCheckCached, ARC9DevCheckLast = 0, false, 0

    if CLIENT and not game.SinglePlayer() then
        local localPlayer

        local function initLocalPlayer()
            localPlayer = LocalPlayer()
        end

        hook.Add("InitPostEntity", "ARC9_CacheLocalPlayer", initLocalPlayer)

        -- for autorefresh
        if IsValid(LocalPlayer()) then
            initLocalPlayer()
        end

        local PlayerIsSuperAdmin = FindMetaTable("Player").IsSuperAdmin

        function ARC9.Dev(level)
            local now = engineTickCount()
    
            if ARC9DevCheckTick == now then return ARC9DevCheckCached end
    
            if (ARC9DevCheckLast or 0) > now then return ARC9DevCheckCached end
            ARC9DevCheckLast = now + 64 -- 64 ticks before next check
            
            local output = IsValid(localPlayer) and PlayerIsSuperAdmin(localPlayer) and cvarGetInt(cvarDeveloper) >= level

            ARC9DevCheckCached = output
            ARC9DevCheckTick = now
    
            return output
        end
    else
        function ARC9.Dev(level)
            local now = engineTickCount()
    
            if ARC9DevCheckTick == now then return ARC9DevCheckCached end
    
            if (ARC9DevCheckLast or 0) > now then return ARC9DevCheckCached end
            ARC9DevCheckLast = now + 64 -- 64 ticks before next check
            
            local output = cvarGetInt(cvarDeveloper) >= level
            
            ARC9DevCheckCached = output
            ARC9DevCheckTick = now
    
            return output
        end
    end
end

-- A cheaper, dirtier branchless implementation
function math.Approach(cur, target, inc)
    inc = math.abs(inc)

    -- if (cur < target) then
    --     return math.min(cur + inc, target)
    -- elseif (cur > target) then
    --     return math.max(cur - inc, target)
    -- end

    -- return target
    return ((cur < target) and math.min(cur + inc, target)) or ((cur > target) and math.max(cur - inc, target)) or target
end

function ARC9.IsPointOutOfBounds(vec)
    local v1, v2, v3 = vec:Unpack()

    if math.abs(v1) > 16384 or math.abs(v2) > 16384 or math.abs(v3) > 16384 then
        return true
    end
end

--PATH lua/arc9/shared/sh_attinv.lua:
return gluapack()()
--PATH lua/arc9/shared/sh_gunutils.lua:
gameevent.Listen( "entity_killed" )
hook.Add( "entity_killed", "entity_killed_example", function( data ) 
    local inflictor_index = data.entindex_inflictor		-- Same as Weapon:EntIndex() / weapon used to kill victim
    local attacker_index = data.entindex_attacker		-- Same as Player/Entity:EntIndex() / person or entity who did the damage
    local damagebits = data.damagebits			-- DAMAGE_TYPE - use BIT operations to decipher damage types...
    local victim_index = data.entindex_killed		-- Same as Victim:EntIndex() / the entity / player victim

    -- Called when a Player or Entity is killed

    if !victim_index then return end
    if !attacker_index then return end
    if !inflictor_index then return end

    local ent = Entity( victim_index )
    local attacker = Entity( attacker_index )
    local inflictor = Entity( inflictor_index )

    if IsValid(inflictor) and inflictor:IsWeapon() and inflictor.ARC9 then
        inflictor:RunHook("Hook_OnKill", ent)
    elseif attacker:IsPlayer() then
        local wpn = attacker:GetActiveWeapon()

        if IsValid(wpn) and wpn.ARC9 then
            wpn:RunHook("Hook_OnKill", ent)
        end
    end
end )

hook.Add("OnNPCKilled", "ARC9_OnNPCKilled", function(npc, attacker, inflictor)
    if !IsValid(attacker) or !attacker:IsPlayer() then return end
    
    local wpn = attacker:GetActiveWeapon()
    if IsValid(wpn) and wpn.ARC9 then
        wpn:RunHook("Hook_OnKill", npc)
        
        net.Start("arc9_sendnpckill")
        net.WriteEntity(npc)
        net.Send(attacker)
    end
end)

timer.Simple(10, function() -- tfa does same thing, no need to copy (timer here cuz tfa loads after arc9)
    if !TFA then 
        -- code stolen from wiki
        local cheats = GetConVar("sv_cheats")
        local timeScale = GetConVar("host_timescale")

        hook.Add("EntityEmitSound", "ARC9_TimeWarpSounds", function(t)
            local p = t.Pitch
            
            if game.GetTimeScale() != 1 then
                p = p * game.GetTimeScale()
            end

            if timeScale then
                local ts = timeScale:GetFloat()
                if isnumber(ts) then
                    if ts != 1 and cheats:GetBool() then
                        p = p * ts
                    end
                end
            end
            
            if p != t.Pitch then
                t.Pitch = math.Clamp(p, 0, 255)
                return true
            end
            
            if CLIENT and engine.GetDemoPlaybackTimeScale() != 1 then
                t.Pitch = math.Clamp(t.Pitch * engine.GetDemoPlaybackTimeScale(), 0, 255)
                return true
            end
            
        end)
    end
end)
--PATH lua/arc9/shared/sh_npc.lua:
hook.Add("InitPostEntity", "ARC9_NPCRegister", function()
    for _, wpn in pairs(weapons.GetList()) do
        local tbl = weapons.Get(wpn.ClassName)

        if !tbl.ARC9 then continue end
        if tbl.NotForNPCs then continue end
        if !tbl.Spawnable then continue end

        list.Add("NPCUsableWeapons",
            {
                class = wpn.ClassName or "Missing ARC9 ClassName",
                title = wpn.PrintName or "Missing ARC9 PrintName"
            }
        )
    end
end)

if SERVER then
    local arc9_npc_give_weapons = GetConVar("arc9_npc_give_weapons")

    net.Receive("arc9_givenpcweapon", function(len, ply)
        local ent = net.ReadEntity()

        if !arc9_npc_give_weapons:GetBool() then return end

        if !ent:IsValid() then return end
        if !ent:IsNPC() then return end

        ARC9.GiveNPCPlayerWeapon(ent, ply)
    end)
end

function ARC9.GiveNPCPlayerWeapon(npc, ply)
    if bit.band(npc:CapabilitiesGet(), CAP_USE_WEAPONS) != CAP_USE_WEAPONS then return end

    if ply:GetPos():DistToSqr(npc:GetPos()) > 40000 then return end

    local weapon = ply:GetActiveWeapon()

    if !weapon.ARC9 then return end

    npc:DropWeapon(nil, ply:GetPos())
    npc:Give(weapon:GetClass())

    timer.Simple(0.05, function() 
        if !IsValid(npc) then return end
        local wpn = npc:GetActiveWeapon()
        if !IsValid(wpn) then return end

        wpn.Attachments = weapon.Attachments
        wpn.WeaponWasGiven = true
        wpn:NPC_Initialize()
        wpn:SendWeapon()
        -- wpn:Activate() -- idk what this for
        wpn:SetClip1(weapon:Clip1())

        ply:StripWeapon(weapon:GetClass())
    end)
end

hook.Add("AllowPlayerPickup", "ARC9_AllowPlayerPickup", function(ply, ent)
    local wep = ply:GetActiveWeapon()
    if !wep.ARC9 then return end

    if wep:GetBipod() then return false end
end)
--PATH lua/arc9/client/cl_hud.lua:
local hide = {
    ["CHudHealth"] = true,
    ["CHudBattery"] = true,
    ["CHudAmmo"] = true,
    ["CHudSecondaryAmmo"] = true,
    ["CHudGMod"] = false,
}

hook.Add("HUDShouldDraw", "ARC9_HideHUD", function(name)
    if !IsValid(LocalPlayer()) then return end

    if ARC9.ShouldDrawHUD() then
        if hide[name] then return false end
    end
end)

local arc9_hud_scale = GetConVar("arc9_hud_scale")
ARC9.ScreenScale = function(size)
    return size * (ScrW() / 640) * arc9_hud_scale:GetFloat() * 0.9
end

local ARC9ScreenScale = ARC9.ScreenScale

ARC9.Colors = {
    bg      = Color(153, 153, 153, 97), --
    bgdark  = Color(37, 37, 37, 240), --
    bg_pro  = Color(53, 179, 53, 97), --
    bg_con  = Color(204, 61, 61, 97), --
    pro  = Color(54, 179, 54), --
    con  = Color(179, 54, 54), --
    fg      = Color(255, 255, 255), --
    hi      = Color(255, 123, 0), --
    hint    = Color(200, 200, 200, 120), --
    unowned = Color(255, 255, 255, 32),

    notoccupied      = Color(216, 216, 216, 70), --

    sel      = Color(255, 150, 100),
    occupied = Color(150, 255, 100),
    shadow   = Color(17, 17, 9),
    neg      = Color(255, 100, 100),
    pos      = Color(100, 255, 100),

    bg_3d = Color(255, 255, 240),
    fg_3d = Color(0, 0, 0),
    shadow_3d = Color(0, 0, 0),
    hi_3d = Color(255, 50, 50),
    pos_3d = Color(255, 255, 255),

    bg_menu = Color(26, 26, 23, 252),
    md = Color(107,107,92),
}

local cl_drawhud = GetConVar("cl_drawhud")
local arc9_hud_arc9 = GetConVar("arc9_hud_arc9")
local arc9_hud_always = GetConVar("arc9_hud_always")
local arc9_hud_force_disable = GetConVar("arc9_hud_force_disable")
local infammo = GetConVar("arc9_infinite_ammo")

function ARC9.ShouldDrawHUD()
    if !cl_drawhud:GetBool() then return end
    if arc9_hud_force_disable:GetBool() then return end

    local wpn = LocalPlayer():GetActiveWeapon()
    local a9 = wpn.ARC9 and !wpn.NotAWeapon
    local incust = a9 and wpn:GetCustomize()
    -- local hud = arc9_hud_arc9:GetBool()
    -- local hudalways = arc9_hud_always:GetBool()

    hide.CHudGMod = incust

    -- if (!hud and !incust) or (!a9 and !hudalways) then return end
    if (!arc9_hud_arc9:GetBool() and !incust) or (!a9 and !arc9_hud_always:GetBool()) then return end -- this line was hard

    return true
end

local alldays = {
    [1] = true,
    [2] = true,
    [3] = true,
    [4] = true,
    [5] = true,
    [6] = true,
    [7] = true,
    [8] = true,
    [9] = true,
    [10] = true,
    [11] = true,
    [12] = true,
    [13] = true,
    [14] = true,
    [15] = true,
    [16] = true,
    [17] = true,
    [18] = true,
    [19] = true,
    [20] = true,
    [21] = true,
    [22] = true,
    [23] = true,
    [24] = true,
    [25] = true,
    [26] = true,
    [27] = true,
    [28] = true,
    [29] = true,
    [30] = true,
    [31] = true,
    [32] = true, -- you can't fight nature, jack
}
local events = {
    ["New Year's"] = {
        months = { [1] = true },
        days = { [1] = true },
    },
    ["Leap Day"] = {
        months = { [2] = true },
        days = { [29] = true },
    },
    -- ["Opposite Day"] = {
    --     months = { 1 },
    --     days = { 25 },
    -- },
    -- ["Earth Day"] = {
    --     months = { 4 },
    --     days = { 22 },
    -- },
    ["Earth Day"] = {
        months = { [4] = true },
        days = { [22] = true },
    },
    ["Easter"] = {
        months = { [4] = true },
        days = alldays,
    },
    ["Halloween"] = {
        months = { [10] = true },
        days = { [31] = true },
    },
    ["Thanksgiving"] = {
        months = { [11] = true }, 
        days = { [23] = true },
    },
    ["Christmas"] = {
        months = { [12] = true },
        days = { [25] = true },
    },
    ["Birthday - Arctic"] = {
        months = { [7] = true },
        days = { [27] = true },
    },
    ["Summer Break"] = {
        months = { [6] = true, [7] = true, [8] = true,  },
        days = alldays,
    },
    ["Troll Day"] = {
        months = { [4] = true },
        days = { [1] = true }
    },
}

local holidayscolors = {
    ["Christmas"] = {
        hi     = Color(184, 210, 160),
        bg     = Color(153, 113, 110, 97),
        bgdark = Color(33, 11, 9, 240),
    },
    ["Halloween"] = {
        hi     = Color(255, 187, 132),
        bg     = Color(120, 110, 153, 97),
        bgdark = Color(14, 6, 37, 240),
    },
    ["Thanksgiving"] = {
        hi     = Color(240, 195, 172),
        bg     = Color(153, 137, 110, 97),
        bgdark = Color(38, 34, 27, 240),
    },
    ["New Year's"] = {
        hi     = Color(255, 255, 200),
        bg     = Color(114, 114, 153, 97),
        bgdark = Color(30, 30, 40, 240),
    },
    ["Birthday - Arctic"] = {
        hi     = Color(210, 235, 255),
        bg     = Color(153, 153, 114, 97),
        bgdark = Color(40, 40, 30, 240),
    },
    ["None"] = {
        hi     = ARC9.Colors.hi,
        bg     = ARC9.Colors.bg,
        bgdark = ARC9.Colors.bgdark,
    },
}

local arc9_holiday_month = GetConVar("arc9_holiday_month")
local arc9_holiday_day = GetConVar("arc9_holiday_day")

function ARC9.GetTime()
    if arc9_holiday_month:GetInt() > 0 and arc9_holiday_day:GetInt() > 0 then
        return os.time( { month = arc9_holiday_month:GetInt(), day = arc9_holiday_day:GetInt(), year = 2000 } )
    else
        return os.time( )--{ month = 12, day = 1, year = 2000 } )
    end
end

function ARC9.GetHolidayColor()
    local d = os.date( "*t", ARC9.GetTime() )
    for i,j in pairs(holidayscolors) do
        if i == "None" then continue end
        if events[i].days[d.day] and events[i].months[d.month] then
            return i
        end
    end
    return "None"
end

ARC9.ActiveHolidays = {}

local d = os.date( "*t", ARC9.GetTime() )
for i,j in pairs(events) do
	if j.days[d.day] and j.months[d.month] then
		ARC9.ActiveHolidays[i] = true
	end
end

local arc9_hud_color_r = GetConVar("arc9_hud_color_r")
local arc9_hud_color_g = GetConVar("arc9_hud_color_g")
local arc9_hud_color_b = GetConVar("arc9_hud_color_b")
local arc9_hud_darkmode = GetConVar("arc9_hud_darkmode")
local arc9_hud_holiday = GetConVar("arc9_hud_holiday")

function ARC9.GetHUDColor(part, alpha)
    alpha = alpha or 255
    local holidayenabled = arc9_hud_holiday:GetBool()
    local col = ARC9.Colors[part] or ARC9.Colors.hi
    local holidaycol = holidayscolors[ARC9.GetHolidayColor()]
    
    
    if part == "hi" then
        col = Color(
            arc9_hud_color_r:GetInt(),
            arc9_hud_color_g:GetInt(),
            arc9_hud_color_b:GetInt()
        )
        if holidayenabled then
            col = holidaycol.hi
        end
    end

    if part == "bg" then
        if holidayenabled then
            col = holidaycol.bg
        end
        if arc9_hud_darkmode:GetBool() then
            col = ARC9.Colors["bgdark"]
            if holidayenabled then
                col = holidaycol.bgdark
            end
        end
    end
    
    if alpha < 255 then
        col = Color(col.r, col.g, col.b)
        col.a = alpha or 255
    end
    return col
end


local rackrisetime = 0
local lastrow = 0
local lastweapon = NULL
local hint_alpha = 1
local lasthintcount = 0
local hidefadetime = 0
local first = true
local convar_keephints = GetConVar("arc9_hud_keephints")

local hud_bg = Material("arc9/hud_bg.png", "mips smooth")
local hud_t_full = Material("arc9/thermometer_full.png", "mips")
local hud_t_empty = Material("arc9/thermometer_empty.png", "mips")
local hud_bigblur = Material("arc9/bigblur.png", "mips")
local hud_sillyhints = Material("arc9/sillyhintsblur.png", "mips")
local hud_logo_lowvis = Material("arc9/logo/logo_lowvis.png", "mips smooth")

local firemode_pics = {
    [-1] = Material("arc9/fs_auto.png", "mips smooth"),
    [0] = Material("arc9/fs_safe.png", "mips smooth"),
    [1] = Material("arc9/fs_semi.png", "mips smooth"),
    [2] = Material("arc9/fs_2rb.png", "mips smooth"),
    [3] = Material("arc9/fs_3rb.png", "mips smooth"),
}

local automatics = {
    ["weapon_smg1"] = true,
    ["weapon_ar2"] = true,
    ["weapon_mp5_hl1"] = true,
    ["weapon_gauss"] = true,
    ["weapon_egon"] = true
}

local arc9_lean = GetConVar("arc9_lean")

local function GetWeaponCapabilities(wpn)
    cap = {
        UBGL = tobool(!wpn:GetInSights() and wpn:GetValue("UBGL")),
        Bash = tobool(!wpn:GetInSights() and wpn:GetValue("Bash")),
        SwitchSights = tobool(wpn:GetInSights() and #wpn.MultiSightTable > 1),
        Inspect = !wpn:GetInSights() and !wpn.NoInspect and tobool(wpn:HasAnimation("enter_inspect") or wpn:HasAnimation("inspect")),
        -- Blindfire = tobool(!wpn:GetInSights() and wpn:GetValue("CanBlindFire")),
        -- BlindfireLeft = tobool(!wpn:GetInSights() and wpn:GetValue("CanBlindFire") and wpn:GetValue("BlindFireLeft")),
        -- BlindfireRight = tobool(!wpn:GetInSights() and wpn:GetValue("CanBlindFire") and wpn:GetValue("BlindFireRight")),
        Firemode = tobool(!wpn:GetUBGL() and #wpn:GetValue("Firemodes") > 1),
        HoldBreath = tobool(wpn:GetInSights() and wpn:GetValue("HoldBreathTime") > 0),
        VariableZoom = tobool(wpn:GetInSights() and (wpn:GetSight().atttbl or {}).RTScopeAdjustable),
        ManualCycle = tobool(wpn:GetNeedsCycle() and wpn:ShouldManualCycle()),
        Lean = tobool(wpn:GetProcessedValue("CanLean", true) and arc9_lean:GetBool()),
    }

    return cap
end

local function GetHintsTable(capabilities)
    local weapon = LocalPlayer():GetActiveWeapon()
	local wait = weapon:StillWaiting()
    local hints = {}

    if capabilities.UBGL then
        if ARC9.GetKeyIsBound("+arc9_ubgl") then
            table.insert(hints, {
                glyph = ARC9.GetBindKey("+arc9_ubgl"),
                action = ARC9:GetPhrase("hud.hint.ubgl") .. " " .. tostring(weapon:GetProcessedValue("UBGLFiremodeName", true))
            })
        else
            table.insert(hints, {
                glyph = ARC9.GetBindKey("+use"),
                glyph2 = ARC9.GetBindKey("+attack2"),
                action = ARC9:GetPhrase("hud.hint.ubgl") .. " " .. tostring(weapon:GetProcessedValue("UBGLFiremodeName", true))
            })
        end
    end

    if capabilities.SwitchSights then
        if ARC9.GetKeyIsBound("+arc9_switchsights") then
            table.insert(hints, {
                glyph = ARC9.GetBindKey("+arc9_switchsights"),
                action = ARC9:GetPhrase("hud.hint.switchsights")
            })
        else
			dtap = GetConVar("arc9_dtap_sights"):GetBool()
            table.insert(hints, {
                glyph = ARC9.GetBindKey("+use"),
				glyph2 = !dtap and ARC9.GetBindKey("invnext") or ARC9.GetBindKey("+use"),
                action = ARC9:GetPhrase("hud.hint.switchsights")
            }) -- TODO: hardcoded to mouse wheel, see sh_move.lua ARC9.StartCommand
        end
    end

    if capabilities.VariableZoom then
        table.insert(hints, {
            glyph = !input.LookupBinding("invnext") and !(input.LookupKeyBinding(113) != nil and input.LookupKeyBinding(113):len() > 0) and "shared_mouse_scroll_down" or ARC9.GetBindKey("invnext"),
            glyph2 = !input.LookupBinding("invprev") and !(input.LookupKeyBinding(112) != nil and input.LookupKeyBinding(112):len() > 0) and "shared_mouse_scroll_up" or ARC9.GetBindKey("invprev"),
            action = ARC9:GetPhrase("hud.hint.zoom")
        }) -- use mouse wheel if invnext or invprev not bound, possible convar to swap maybe? currently for semi parity with switchsights
    end

    if capabilities.HoldBreath then
        table.insert(hints, {
            glyph = ARC9.GetBindKey("+speed"),
            action = ARC9:GetPhrase("hud.hint.breath")
        })
    end

    if capabilities.Bash and !weapon.PrimaryBash then
		if weapon.SecondaryBash then -- If the weapon performs bashing as the primary attack function, only display the "+attack" function.
			table.insert(hints, {
				glyph = ARC9.GetBindKey("+attack2"),
				action = ARC9:GetPhrase("hud.hint.bash")
			})
		else
			if ARC9.GetKeyIsBound("+arc9_melee") then
				table.insert(hints, {
					glyph = ARC9.GetBindKey("+arc9_melee"),
					action = ARC9:GetPhrase("hud.hint.bash")
				})
			else
				table.insert(hints, {
					glyph = ARC9.GetBindKey("+use"),
					glyph2 = ARC9.GetBindKey("+attack"),
					action = ARC9:GetPhrase("hud.hint.bash")
				})
			end
		end
    end

    if capabilities.Inspect then
        if ARC9.GetKeyIsBound("+arc9_inspect") then
            table.insert(hints, {
                glyph = ARC9.GetBindKey("+arc9_inspect"),
                action = ARC9:GetPhrase("hud.hint.inspect")
            })
        else
            table.insert(hints, {
                glyph = ARC9.GetBindKey("+use"),
                glyph2 = ARC9.GetBindKey("+reload"),
                action = ARC9:GetPhrase("hud.hint.inspect")
            })
        end
    end

    if capabilities.Firemode then
		table.insert(hints, {
            glyph = ARC9.GetBindKey("+zoom"),
            action = ARC9:GetPhrase("hud.hint.firemode")
        })
    end

    if capabilities.ManualCycle then
        table.insert(hints, {
            glyph = ARC9.GetBindKey("+reload"),
            action = ARC9:GetPhrase("hud.hint.cycle")
        })
    end

    if weapon:CanToggleAllStatsOnF() then
        table.insert(hints, {
            glyph = ARC9.GetBindKey("impulse 100"),
            action = ARC9:GetPhrase("hud.hint.toggleatts")
        })
    end

    local cantpeek = weapon:GetProcessedValue("CantPeek", true)
	local sight = weapon:GetInSights()
	local bipod = weapon:GetBipod()
    if !(cantpeek and sight) and !(sight and bipod) then 
        table.insert(hints, {
            glyph = ARC9.GetBindKey("+menu_context"),
            action = !cantpeek and weapon:GetInSights() and ARC9:GetPhrase("hud.hint.peek") or ARC9:GetPhrase("hud.hint.customize") 
        })
    end

    if !weapon.CantSafety then 
        table.insert(hints, {
            glyph = ARC9.GetBindKey("+use"),
            glyph2 = ARC9.GetBindKey("+zoom"),
            action = ARC9:GetPhrase("hud.hint.safe")
        })
    end

    if capabilities.Lean and input.LookupBinding("+alt1") and input.LookupBinding("+alt2") then
        table.insert(hints, {
            glyph = ARC9.GetBindKey("+alt1"),
            glyph2 = ARC9.GetBindKey("+alt2"),
            action = ARC9:GetPhrase("hud.hint.lean")
        })
    end

    local owner = weapon:GetOwner()
    local quicknade = owner.ARC9LastSelectedGrenade
    if quicknade then
        local quicknadeent = owner:GetWeapon(quicknade)
        if IsValid(quicknadeent) then
            local howmanyquicknades = infammo:GetBool() and 0 or owner:GetAmmoCount(quicknadeent.Ammo)
            if quicknade and owner:HasWeapon(quicknade) and !weapon.IsQuickGrenade then
                table.insert(hints, {
                    glyph = ARC9.GetBindKey("+grenade1"),
                    action = ARC9:GetPhrase("hud.hint.quicknade") .. (quicknadeent.ShortPrintName and quicknadeent.ShortPrintName or quicknadeent.PrintName) .. (howmanyquicknades > 0 and " (" .. howmanyquicknades + 1 .. ")" or "")
                })
            end
        end
    end

    for i, v in ipairs(hints) do
        if ARC9.CTRL_Lookup[v.glyph] then v.glyph = ARC9.CTRL_Lookup[v.glyph] end
        if ARC9.CTRL_ConvertTo[v.glyph] then v.glyph = ARC9.CTRL_ConvertTo[v.glyph] end
        if ARC9.CTRL_Exists[v.glyph] then v.glyph = Material( "arc9/" .. ARC9.GlyphFamilyHUD() .. v.glyph .. ".png", "smooth" ) end
        if v.glyph2 then
            if ARC9.CTRL_Lookup[v.glyph2] then v.glyph2 = ARC9.CTRL_Lookup[v.glyph2] end
            if ARC9.CTRL_ConvertTo[v.glyph2] then v.glyph2 = ARC9.CTRL_ConvertTo[v.glyph2] end
            if ARC9.CTRL_Exists[v.glyph2] then v.glyph2 = Material( "arc9/" .. ARC9.GlyphFamilyHUD() .. v.glyph2 .. ".png", "smooth" ) end
        end
    end

    return hints
end

local arc9_hud_nohints = GetConVar("arc9_hud_nohints")
local arc9_hud_compact = GetConVar("arc9_hud_compact")
local deadzonex = GetConVar("arc9_hud_deadzonex")

local function DrawSimpleHints()
    if arc9_hud_nohints:GetBool() then return end

    local weapon = LocalPlayer():GetActiveWeapon()
    if !weapon.ARC9 or weapon.NotAWeapon then return end

    if !cl_drawhud:GetBool() then return end
    if weapon:GetCustomize() then return end

    local ct = CurTime()

    local capabilities = GetWeaponCapabilities(weapon)

    local CTRL = false

    local hints = GetHintsTable(capabilities)

    if lasthintcount != #hints and hidefadetime + 1.5 < ct then
        hidefadetime = ct
    end

    if weapon:GetInSights() and hidefadetime + 1.5 < ct then
        hidefadetime = ct
    end

    if first then
        hidefadetime = ct + 7
        first = false
    end

    lasthintcount = #hints

    local hx = 0
    local hy = 0
    local SIZE = ARC9ScreenScale(8)

    if hidefadetime + 1.5 > ct then
        hint_alpha = math.Approach(hint_alpha, 1, FrameTime() / 0.1)
    else
        hint_alpha = math.Approach(hint_alpha, 0, FrameTime() / 1)
    end
    if convar_keephints:GetBool() then hint_alpha = 1 end

    local hints_w = ARC9ScreenScale(100)
    local hints_h = ARC9ScreenScale(11) * table.Count(hints)

    hx = ARC9ScreenScale(10) + deadzonex:GetInt()
    hy = (ScrH() - hints_h) / 2

    surface.SetDrawColor(ARC9.GetHUDColor("shadow", 160 * hint_alpha))
    surface.SetMaterial(hud_sillyhints)
    surface.DrawTexturedRect(-ARC9ScreenScale(5) + deadzonex:GetInt(), hy-ARC9ScreenScale(12.5), hints_w, hints_h+ARC9ScreenScale(25))

    local off_x = ARC9ScreenScale(1)
    local off_y = ARC9ScreenScale(1)

    local txt_off_y = -ARC9ScreenScale(0.8)

    for _, hint in ipairs(hints) do
        local strreturn = 0
        surface.SetFont("ARC9_10")
        surface.SetDrawColor(ARC9.GetHUDColor("shadow", 100 * hint_alpha))
        surface.SetTextColor(ARC9.GetHUDColor("shadow", 100 * hint_alpha))
        surface.SetTextPos(hx + off_x, hy + off_y)
        strreturn = CreateControllerKeyLine( {x = hx + off_x, y = hy + off_y, size = ARC9ScreenScale(9), font_keyb = "ARC9_10", font = "ARC9_10" }, { hint.glyph, SIZE }, (hint.glyph2 and "  " or ""), (hint.glyph2 and { hint.glyph2, SIZE } or "") )
        CreateControllerKeyLine( {x = hx + off_x + math.max(strreturn, ARC9ScreenScale(25)), y = hy + txt_off_y + off_y, size = ARC9ScreenScale(10), font_keyb = "ARC9_10", font = "ARC9_10" }, " " .. hint.action )

        surface.SetFont("ARC9_10")
        surface.SetDrawColor(ARC9.GetHUDColor("fg", 200 * hint_alpha))
        surface.SetTextColor(ARC9.GetHUDColor("fg", 200 * hint_alpha))
        surface.SetTextPos(hx, hy)
        strreturn = CreateControllerKeyLine( {x = hx, y = hy, size = ARC9ScreenScale(9), font_keyb = "ARC9_10", font = "ARC9_10" }, { hint.glyph, SIZE }, (hint.glyph2 and "  " or ""), (hint.glyph2 and { hint.glyph2, SIZE } or "") )
        CreateControllerKeyLine( {x = hx + math.max(strreturn, ARC9ScreenScale(25)), y = hy + txt_off_y, size = ARC9ScreenScale(10), font_keyb = "ARC9_10", font = "ARC9_10" }, " " .. hint.action )

        hy = hy + ARC9ScreenScale(12)
    end
end

local deadzonex = GetConVar("arc9_hud_deadzonex")

function ARC9.DrawHUD()
    EyeAngles() -- This, for some ungodly reason, allows sway to work when the HUD is off.
    EyePos()

    if !ARC9.ShouldDrawHUD() then
        DrawSimpleHints()
        return
    end

    local localplayer = LocalPlayer()
    local weapon = localplayer:GetActiveWeapon()

    if !IsValid(weapon) then return end

    local ct = CurTime()

    if lastweapon != weapon then
        rackrisetime = ct
        lastrow = 0
        hidefadetime = ct
    end

    -- local weapon_printname = weapon:GetPrintName()
    local weapon_clipsize = weapon:GetMaxClip1()
    local weapon_clip = weapon:Clip1()
    local weapon_reserve = localplayer:GetAmmoCount(weapon:GetPrimaryAmmoType())

    local flash_period = 3

    local firemode_text = "AUTO"
    local firemode_pic = firemode_pics[-1]

    local chambered = math.max(weapon_clip - weapon_clipsize, 0)
    local clip_to_show = math.min(weapon_clip, weapon_clipsize)

    local inf_clip = false
    local inf_reserve = false
    local melee = false
    local jammed = false
    local showheat = false
    local heat = 0
    local heatcap = 100
    local heatlocked = false
    local multiple_modes = false

    if weapon_clipsize <= 0 then
        inf_clip = true
        clip_to_show = weapon_reserve
    end

    if weapon.ARC9 then
        if weapon:GetCustomize() then return end

        local arc9_mode = weapon:GetCurrentFiremodeTable()

        firemode_text = weapon:GetFiremodeName()

        if #weapon:GetValue("Firemodes") > 1 then
            multiple_modes = true
        end

        if weapon:GetProcessedValue("NoFiremodeWhenEmpty", true) and weapon:Clip1() <= 0 then
            multiple_modes = false
        end

        if weapon:GetUBGL() then
            arc9_mode = {
                Mode = weapon:GetCurrentFiremode(),
                PrintName = weapon:GetProcessedValue("UBGLFiremodeName", true)
            }
            firemode_text = arc9_mode.PrintName
            weapon_clipsize = weapon:GetMaxClip2()
            weapon_clip = weapon:Clip2()
            clip_to_show = weapon_clip
            weapon_reserve = localplayer:GetAmmoCount(weapon:GetSecondaryAmmoType())
            multiple_modes = false
        end

        if arc9_mode.Icon then
            firemode_pic = arc9_mode.Icon
        else
            if firemode_pics[arc9_mode.Mode] then
                firemode_pic = firemode_pics[arc9_mode.Mode]
            elseif arc9_mode.Mode < 0 then
                firemode_pic = firemode_pics[-1]
            else
                firemode_pic = firemode_pics[3]
            end
        end

        if weapon:GetSafe() then
            firemode_pic = firemode_pics[0]
        end

        if weapon:GetInfiniteAmmo() then
            inf_reserve = true
            weapon_reserve = 2147483640
        end

        if weapon:GetProcessedValue("BottomlessClip", true) then
            inf_clip = true
            weapon_reserve = weapon_reserve + weapon_clip
            clip_to_show = weapon_reserve
            weapon_clip = weapon_reserve
            weapon_clipsize = 1
            chambered = 0

            if inf_reserve then
                clip_to_show = 2147483640 - weapon:GetNthShot() % 2147483640
            end
        end

        if weapon:GetJammed() then
            jammed = true
        end

        if weapon:GetProcessedValue("Overheat", true) then
            showheat = true
            heat = weapon:GetHeatAmount()
            heatcap = weapon:GetProcessedValue("HeatCapacity", true)
            heatlocked = weapon:GetHeatLockout()
        end
    elseif weapon.ArcCW then
        local arccw_mode = weapon:GetCurrentFiremode()

        firemode_text = weapon:GetFiremodeName()
        -- there was a reason I kept it to 4 letters you assholes

        firemode_text = string.Replace(firemode_text, "-", "")
        firemode_text = string.Replace(firemode_text, " ", "")
        firemode_text = string.sub(firemode_text, 1, 4)
        firemode_text = string.upper(firemode_text)

        if arccw_mode.Mode > 1 then
            firemode_pic = firemode_pics[-1]
        elseif arccw_mode.Mode == 1 then
            firemode_pic = firemode_pics[1]
        elseif firemode_pics[-arccw_mode.Mode] then
            firemode_pic = firemode_pics[-arccw_mode.Mode]
        else
            firemode_pic = firemode_pics[3]
        end
    elseif weapon:IsScripted() then
        if !weapon.Primary.Automatic then
            firemode_pic = firemode_pics[1]
            firemode_text = ARC9:GetPhrase("hud.firemode.single")
        end

        if weapon.ThreeRoundBurst then
            firemode_pic = firemode_pics[3]
            firemode_text = "3-" .. ARC9:GetPhrase("hud.firemode.burst")
        end

        if weapon.TwoRoundBurst then
            firemode_pic = firemode_pics[2]
            firemode_text = "2-" .. ARC9:GetPhrase("hud.firemode.burst")
        end

        if weapon.GetSafe then
            if weapon:GetSafe() then
                firemode_pic = firemode_pics[0]
                firemode_text = ARC9:GetPhrase("hud.firemode.safe")
            end
        end

        if isfunction(weapon.Safe) then
            if weapon:Safe() then
                firemode_pic = firemode_pics[0]
                firemode_text = ARC9:GetPhrase("hud.firemode.safe")
            end
        end

        if isfunction(weapon.Safety) then
            if weapon:Safety() then
                firemode_pic = firemode_pics[0]
                firemode_text = ARC9:GetPhrase("hud.firemode.safe")
            end
        end
    else
        if !automatics[weapon:GetClass()] then
            firemode_pic = firemode_pics[1]
            firemode_text = ARC9:GetPhrase("hud.firemode.single")
        end
    end

    local flashammowidgets = false

    if (weapon_clip / weapon_clipsize) < 0.34 then
        flashammowidgets = true
        if weapon_clip == 0 then
            flashammowidgets = false
        end
    end

    if weapon_clipsize <= 0 and weapon:GetPrimaryAmmoType() == -1 then
        melee = true
        flashammowidgets = false
    end

    if inf_clip then
        weapon_clipsize = 30
    end

    if jammed then
        flashammowidgets = true
    end

    local flashheatbar = false

    if heatlocked then flashheatbar = true end

    local heat_col = ARC9.GetHUDColor("fg_3d", 200)

    if (flashheatbar and math.floor(ct * flash_period) % 2 == 0) then
        heat_col = ARC9.GetHUDColor("hi_3d", 200)
    end

    local am_col = ARC9.GetHUDColor("fg_3d", 255)

    if (flashammowidgets and math.floor(ct * flash_period) % 2 == 0) or (weapon_clip == 0 and !melee) then
        am_col = ARC9.GetHUDColor("hi_3d", 255)
    end

    local s_right = 2
    local s_down = 1

    -- cam.Start3D(Vector pos=EyePos(), Angle angles=EyeAngles(), number fov=nil, number x=0, number y=0, number w=ScrW(), number h=ScrH(), number zNear=nil, number zFar=nil)
    local anchorwidth = math.min(ScrW() / 2, ScrH() / 2)

    cam.Start3D(nil, nil, 55, deadzonex:GetInt(), ScrH() - anchorwidth, anchorwidth, anchorwidth)
    -- cam.Start3D(nil, nil, 105)

    local ang = EyeAngles()

    local up, right, forward = ang:Up(), ang:Right(), ang:Forward()

    -- local ang = EyeAngles()

    -- ang = ang + Angle(0, 180, 0)

    -- ang = -ang

    -- ang:RotateAroundAxis(up, 175)
    -- ang:RotateAroundAxis(right, 80)
    -- ang:RotateAroundAxis(forward, -90)

    ang:RotateAroundAxis(up, 180)
    ang:RotateAroundAxis(right, 105)
    ang:RotateAroundAxis(forward, -95)

    -- cam.Start3D2D(EyePos() + (forward * 8) + (up * -3.25) + (right * -10), ang2, 0.0125 )
    -- cam.End3D2D()

    -- local ratio = ScrW() / ScrH()

    local pos = EyePos() + (forward * 4) + (up * -0.25) + (right * -1.5)

    pos, ang = ARC9.HUDBob(pos, ang)
    pos, ang = ARC9.HUDSway(pos, ang)

    local compatc = arc9_hud_compact:GetBool()

    cam.Start3D2D(pos, ang, 0.0125)
        -- surface.SetDrawColor(ARC9.GetHUDColor("shadow_3d", 20))
        -- surface.DrawRect( 8, 4, 254, 110 )

        if compatc then
            surface.SetDrawColor(ARC9.GetHUDColor("bg_3d", 20))
            surface.DrawRect( 0, 0, 254, 80 )

            surface.SetDrawColor(ARC9.GetHUDColor("bg_3d", 100))
            surface.SetMaterial(hud_bg)
            surface.DrawTexturedRect(0, 0, 254, 80)

            surface.DrawLine(0, 85, 254, 85)

            surface.SetDrawColor(Color(0, 0, 0, 50))
            surface.SetMaterial(hud_logo_lowvis)
            surface.DrawTexturedRect((254 - 80) / 2, 0, 80, 80)
        else
            surface.SetDrawColor(ARC9.GetHUDColor("bg_3d", 20))
            surface.DrawRect( 0, 0, 254, 110 )

            surface.SetDrawColor(ARC9.GetHUDColor("bg_3d", 100))
            surface.SetMaterial(hud_bg)
            surface.DrawTexturedRect(0, 0, 254, 110)

            surface.DrawLine(0, 115, 254, 115)

            surface.SetDrawColor(Color(0, 0, 0, 50))
            surface.SetMaterial(hud_logo_lowvis)
            surface.DrawTexturedRect((254 - 110) / 2, 0, 110, 110)
        end

        -- surface.SetDrawColor(ARC9.GetHUDColor("bg_3d", 20))
        -- surface.DrawRect( 0, 0, 140, 70 )

        local deco_x = 6
        local deco_y = 2
        local deco = ARC9:GetPhrase("hud.version") .. ARC9.Version

        surface.SetTextColor(ARC9.GetHUDColor("shadow_3d", 100))
        surface.SetFont("ARC9_Deco_8_Unscaled")
        surface.SetTextPos(deco_x + s_right, deco_y + s_down)
        surface.DrawText(deco)

        surface.SetTextColor(ARC9.GetHUDColor("fg_3d", 255))
        surface.SetFont("ARC9_Deco_8_Unscaled")
        surface.SetTextPos(deco_x, deco_y)
        surface.DrawText(deco)

        local health_x = 8
        local health_y = 9
        local health = math.Clamp(localplayer:Health() / localplayer:GetMaxHealth(), 0, 99.99)
        local overheal = localplayer:Health() > localplayer:GetMaxHealth() or localplayer:Armor() > 100

        local flashhealthwidgets = false

        if localplayer:Health() <= 10 then
            flashhealthwidgets = true
        end

        local hb_col = ARC9.GetHUDColor("fg_3d", 225)
        local hw_col = ARC9.GetHUDColor("fg_3d", 255)

        if (flashhealthwidgets and math.floor(ct * flash_period) % 2 == 0) then
            hw_col = ARC9.GetHUDColor("hi_3d", 255)
            hb_col = ARC9.GetHUDColor("hi_3d", 170)
        end

        local hb_left = 30
        local hb_tall = 24
        local hb_wide = 209

        if compatc and showheat then
            hb_wide = 140
        end

        if !overheal then
            if localplayer:Armor() > 0 then
                hb_tall = 18

                local armor = math.min(localplayer:Armor() / 100, 1)

                surface.SetDrawColor(ARC9.GetHUDColor("shadow_3d", 100))
                surface.DrawRect(hb_left + s_right, 32 + s_down, hb_wide * armor, 3)

                surface.SetDrawColor(hb_col)
                surface.DrawRect(hb_left, 32, hb_wide * armor, 3)
            end

            surface.SetDrawColor(ARC9.GetHUDColor("shadow_3d", 100))
            if health < 1 then
                surface.DrawLine(hb_wide + hb_left + s_right, 12 + s_down, hb_wide + hb_left + s_right, 12 + hb_tall + s_down)
            end
            surface.DrawRect(hb_left + s_right, 12 + s_down, hb_wide * health, hb_tall)

            surface.SetDrawColor(hb_col)
            if health < 1 then
                surface.DrawLine(hb_wide + hb_left, 12, hb_wide + hb_left, 12 + hb_tall)
            end
            surface.DrawRect(hb_left, 12, hb_wide * health, hb_tall)
        end

        local healthtext = "♥"

        if overheal then
            healthtext = "♥:" .. tostring(math.ceil(health * 100)) .. "%"
        end

        surface.SetTextColor(ARC9.GetHUDColor("shadow_3d", 100))
        surface.SetFont("ARC9_24_LCD")
        surface.SetTextPos(health_x + s_right, health_y + s_down)
        surface.DrawText(healthtext)

        surface.SetTextColor(hw_col)
        surface.SetFont("ARC9_24_LCD")
        surface.SetTextPos(health_x, health_y)
        surface.DrawText(healthtext)

        if overheal then
            local armor_x = 250
            local armor_y = 9
            local armor = math.Round((localplayer:Armor() / 100) * 100)
            armor = "⌂:" .. tostring(math.ceil(armor)) .. "%"

            surface.SetFont("ARC9_24_LCD")
            armor_x = armor_x - surface.GetTextSize(armor)

            surface.SetTextColor(ARC9.GetHUDColor("shadow_3d", 100))
            surface.SetFont("ARC9_24_LCD")
            surface.SetTextPos(armor_x + s_right, armor_y + s_down)
            surface.DrawText(armor)

            surface.SetTextColor(ARC9.GetHUDColor("fg_3d", 255))
            surface.SetFont("ARC9_24_LCD")
            surface.SetTextPos(armor_x, armor_y)
            surface.DrawText(armor)
        end

        -- local title_x = 8
        -- local title_y = 2

        -- surface.SetTextColor(ARC9.GetHUDColor("shadow_3d", 100))
        -- surface.SetFont("ARC9_24_Unscaled")
        -- surface.SetTextPos(title_x + s_right, title_y + s_down)
        -- surface.DrawText(weapon_printname)

        -- surface.SetTextColor(ARC9.GetHUDColor("fg_3d", 255))
        -- surface.SetFont("ARC9_24_Unscaled")
        -- surface.SetTextPos(title_x, title_y)
        -- surface.DrawText(weapon_printname)

        if showheat then
            local therm_x = 174
            local therm_y = 66
            local therm_w = 70
            local therm_h = 35

            local therm_deco_x = 190
            local therm_deco_y = 97
            local therm_deco = ARC9:GetPhrase("hud.therm_deco")

            if compatc then
                therm_x = 174
                therm_y = 6
                therm_w = 70
                therm_h = 35

                therm_deco_x = 190
                therm_deco_y = 5
            end

            surface.SetTextColor(ARC9.GetHUDColor("shadow_3d", 100))
            surface.SetFont("ARC9_Deco_8_Unscaled")
            surface.SetTextPos(therm_deco_x + s_right, therm_deco_y + s_down)
            surface.DrawText(therm_deco)

            surface.SetTextColor(ARC9.GetHUDColor("fg_3d", 255))
            surface.SetFont("ARC9_Deco_8_Unscaled")
            surface.SetTextPos(therm_deco_x, therm_deco_y)
            surface.DrawText(therm_deco)

            local fill = math.Clamp(0.05 + (0.9 * heat) / heatcap, 0, 1)

            surface.SetDrawColor(ARC9.GetHUDColor("shadow_3d", 100))
            surface.SetMaterial(hud_t_full)
            surface.DrawTexturedRectUV(therm_x + s_right, therm_y + s_down, math.ceil(therm_w * fill), therm_h, 0, 0, fill, 1)
            -- surface.DrawTexturedRect(therm_x + s_right, therm_y + s_down, therm_s, therm_s)

            surface.SetDrawColor(heat_col)
            surface.SetMaterial(hud_t_full)
            surface.DrawTexturedRectUV(therm_x, therm_y, math.ceil(therm_w * fill), therm_h, 0, 0,  fill, 1)

            surface.SetDrawColor(ARC9.GetHUDColor("shadow_3d", 100))
            surface.SetMaterial(hud_t_empty)
            surface.DrawTexturedRectUV(therm_x + math.ceil(therm_w * fill) + s_right, therm_y + s_down, therm_w * (1 - fill), therm_h, fill, 0, 1, 1)
            -- surface.DrawTexturedRect(therm_x + s_right, therm_y + s_down, therm_s, therm_s)

            surface.SetDrawColor(heat_col)
            surface.SetMaterial(hud_t_empty)
            surface.DrawTexturedRectUV(therm_x + math.ceil(therm_w * fill), therm_y, therm_w * (1 - fill), therm_h, fill, 0, 1, 1)
            -- surface.DrawTexturedRect(therm_x, therm_y, therm_s, therm_s)
        end

        local ammo_x = 8
        local ammo_y = 40
        local ammo_text = tostring(weapon_clip)

        if inf_reserve then
            ammo_text = ammo_text .. "/∞"
            if inf_clip then
                ammo_text = "∞"
            end
        else
            ammo_text = ammo_text .. "/" .. tostring(weapon_reserve)
            if inf_clip then
                ammo_text = tostring(weapon_reserve)
            end
        end

        if melee then
            ammo_text = "-"
        end

        if jammed then
            ammo_text = ARC9:GetPhrase("hud.jammed")
        end

        surface.SetTextColor(ARC9.GetHUDColor("shadow_3d", 100))
        surface.SetFont("ARC9_24_LCD")
        surface.SetTextPos(ammo_x + s_right, ammo_y + s_down)
        surface.DrawText(ammo_text)

        surface.SetTextColor(am_col)
        surface.SetFont("ARC9_24_LCD")
        surface.SetTextPos(ammo_x, ammo_y)
        surface.DrawText(ammo_text)

        local fmi_x = 215
        local fmi_y = 38
        local fmi_s = 30

        surface.SetDrawColor(ARC9.GetHUDColor("shadow_3d", 100))
        surface.SetMaterial(firemode_pic)
        surface.DrawTexturedRect(fmi_x + s_right, fmi_y + s_down, fmi_s, fmi_s)

        surface.SetDrawColor(ARC9.GetHUDColor("fg_3d", 255))
        surface.SetMaterial(firemode_pic)
        surface.DrawTexturedRect(fmi_x, fmi_y, fmi_s, fmi_s)

        local fmm_text = firemode_text
        local fmm_x = 212
        local fmm_y = 39

        if !multiple_modes then
            fmm_y = 45
        end

        surface.SetTextColor(ARC9.GetHUDColor("shadow_3d", 100))
        surface.SetFont("ARC9_12_Unscaled")
        local fmm_w = surface.GetTextSize(fmm_text)
        surface.SetTextPos(fmm_x + s_right - fmm_w, fmm_y + s_down)
        surface.DrawText(fmm_text)

        surface.SetTextColor(ARC9.GetHUDColor("fg_3d", 255))
        surface.SetFont("ARC9_12_Unscaled")
        surface.SetTextPos(fmm_x - fmm_w, fmm_y)
        surface.DrawText(fmm_text)

        if multiple_modes then
            local fmh_text = ARC9.GetBindKey("+zoom")--"[" .. ARC9.GetBindKey("+zoom") .. "]"
            local fmh_x = 212
            local fmh_y = 53

            if ARC9.CTRL_Lookup[fmh_text] then fmh_text = ARC9.CTRL_Lookup[fmh_text] end
            if ARC9.CTRL_ConvertTo[fmh_text] then fmh_text = ARC9.CTRL_ConvertTo[fmh_text] end
            if ARC9.CTRL_Exists[fmh_text] then fmh_text = Material( "arc9/" .. ARC9.GlyphFamilyHUD() .. fmh_text .. ".png", "smooth" ) else fmh_text = "["..fmh_text.."]" end
            fmh_text = isstring(fmh_text) and fmh_text or { fmh_text, 15 }

            surface.SetDrawColor(ARC9.GetHUDColor("shadow", 100))
            surface.SetTextColor(ARC9.GetHUDColor("shadow", 100))
            surface.SetFont("ARC9_12_LCD")
            local fmh_w = GetControllerKeyLineSize( { font = "ARC9_12_LCD" }, fmh_text )
            CreateControllerKeyLine( { x = fmh_x + s_right - fmh_w, y = fmh_y + s_down, size = 16, font = "ARC9_12_LCD" }, fmh_text )

            surface.SetDrawColor(ARC9.GetHUDColor("fg", 200 * hint_alpha))
            surface.SetTextColor(ARC9.GetHUDColor("fg_3d", 255))
            surface.SetFont("ARC9_12_LCD")
            CreateControllerKeyLine( { x = fmh_x - fmh_w, y = fmh_y, size = 16, font = "ARC9_12_LCD" }, fmh_text )
        end

        if !compatc then
            -- bullet fields

            local b_alpha = 225

            local b_m_left = -8
            local b_m_down = 72
            local b_m_margin = 2

            local row_size = 15

            if showheat then
                row_size = 10
            end

            local row1_bullets = 0
            local row2_bullets = 0
            local rackrise = 0

            local disparity = weapon_clipsize % row_size

            local corrected = clip_to_show - disparity

            local row = math.ceil(corrected / row_size)

            local sb = 14

            local crc = clip_to_show

            if disparity > 0 then
                crc = clip_to_show + row_size - disparity
            end

            if crc > row_size then
                row2_bullets = math.min(row_size, clip_to_show + disparity)
                row1_bullets = (corrected % row_size)

                if row1_bullets == 0 then
                    row1_bullets = row_size
                end

                if clip_to_show <= row_size + disparity then
                    row2_bullets = disparity
                end

                if row < lastrow then
                    rackrisetime = ct
                end

                lastrow = row
            else
                row2_bullets = clip_to_show
            end

            if rackrisetime + 0.2 > ct then
                local rackrisedelta = ((rackrisetime + 0.2) - ct) / 0.2
                rackrise = rackrisedelta * (sb + b_m_margin)
            end

            for i = 1, row1_bullets do
                surface.SetDrawColor(ARC9.GetHUDColor("shadow_3d", 100))
                surface.DrawRect(b_m_left + ((sb + b_m_margin) * i) + s_right, b_m_down + rackrise + s_down, sb, sb)

                if row1_bullets - i < chambered then
                    surface.SetDrawColor(ARC9.GetHUDColor("hi_3d", b_alpha))
                else
                    surface.SetDrawColor(ARC9.GetHUDColor("fg_3d", b_alpha))
                end
                surface.DrawRect(b_m_left + ((sb + b_m_margin) * i), b_m_down + rackrise, sb, sb)
            end

            for i = 1, row2_bullets do
                surface.SetDrawColor(ARC9.GetHUDColor("shadow_3d", 100))
                surface.DrawRect(b_m_left + ((sb + b_m_margin) * i) + s_right, b_m_down + sb + b_m_margin + rackrise + s_down, sb, sb)

                if row2_bullets - i < chambered - row1_bullets then
                    surface.SetDrawColor(ARC9.GetHUDColor("hi_3d", b_alpha))
                else
                    surface.SetDrawColor(ARC9.GetHUDColor("fg_3d", b_alpha))
                end
                surface.DrawRect(b_m_left + ((sb + b_m_margin) * i), b_m_down + sb + b_m_margin + rackrise, sb, sb)
            end
        end

    cam.End3D2D()

    if weapon.ARC9 and !arc9_hud_nohints:GetBool() then
        local capabilities = GetWeaponCapabilities(weapon)

        -- local hints = {
        --     {
        --         {"E", "R"},
        --         "Inspect"
        --     },
        --     {
        --         {"E", "M2"},
        --         "Toggle Alt-Weapon"
        --     },
        --     {
        --         {"E", "M1"},
        --         "Bash"
        --     },
        --     {
        --         {"B"},
        --         "Switch Firemode"
        --     },
        -- }

        local hints = GetHintsTable(capabilities)

        if lasthintcount != #hints and hidefadetime + 1.5 < ct then
            hidefadetime = ct
        end

        if weapon:GetInSights() and hidefadetime + 1.5 < ct then
            hidefadetime = ct
        end

        if first then
            hidefadetime = ct + 10
            first = false
        end

		-- hints = table.Reverse(hints)

        lasthintcount = #hints

        local hx = 0
        local hy = 0
        local SIZE = 16

        if hidefadetime + 1.5 > ct then
            hint_alpha = math.Approach(hint_alpha, 1, FrameTime() / 0.1)
        else
            hint_alpha = math.Approach(hint_alpha, 0, FrameTime() / 1)
        end
        if convar_keephints:GetBool() then hint_alpha = 1 end

        cam.Start3D2D(pos - (ang:Right() * ((20 * #hints * 0.0125) + 0.25)), ang, 0.0125)
            surface.SetDrawColor(ARC9.GetHUDColor("shadow", 150 * hint_alpha))
            surface.SetMaterial(hud_bigblur)
            surface.DrawTexturedRect(-32, 0, 300, 20 * #hints)

            for _, hint in ipairs(hints) do
                local strreturn = 0
                surface.SetFont("ARC9_16_Unscaled")
                surface.SetDrawColor(ARC9.GetHUDColor("shadow", 100 * hint_alpha))
                surface.SetTextColor(ARC9.GetHUDColor("shadow", 100 * hint_alpha))
                surface.SetTextPos(hx + 4, hy + 2)
                strreturn = CreateControllerKeyLine( {x = hx + 2, y = hy + 1, size = 16, font = "ARC9_16_Unscaled" }, { hint.glyph, SIZE }, (hint.glyph2 and " " or ""), (hint.glyph2 and { hint.glyph2, SIZE } or "") )
                CreateControllerKeyLine( {x = hx + 4 + math.max(strreturn, 48), y = hy + 2, size = 16, font = "ARC9_16_Unscaled" }, " " .. hint.action )


                surface.SetFont("ARC9_16_Unscaled")
                surface.SetDrawColor(ARC9.GetHUDColor("fg", 200 * hint_alpha))
                surface.SetTextColor(ARC9.GetHUDColor("fg", 200 * hint_alpha))
                surface.SetTextPos(hx, hy)
                strreturn = CreateControllerKeyLine( {x = hx, y = hy, size = 16, font = "ARC9_16_Unscaled" }, { hint.glyph, SIZE }, (hint.glyph2 and " " or ""), (hint.glyph2 and { hint.glyph2, SIZE } or "") )
                CreateControllerKeyLine( {x = hx + math.max(strreturn, 48), y = hy, size = 16, font = "ARC9_16_Unscaled" }, " " .. hint.action )

                hy = hy + 22
            end
        cam.End3D2D()
    end

    cam.End3D()

    lastweapon = weapon
end

hook.Add("HUDPaint", "ARC9_DrawHud", ARC9.DrawHUD)



-- Controller / key additions by Fesiug. Blame Fesiug!

local convar_controllermode = GetConVar("arc9_controller")
function ARC9.ControllerMode()
    return convar_controllermode:GetBool()
end

ARC9.CTRL_Set_Xbox = {}
ARC9.CTRL_Set_UserCustom = {}

ARC9.CTRL_ConvertTo = ARC9.CTRL_Set_Xbox -- {}

function ARC9.GlyphFamilyHUD()
	local con = GetConVar("arc9_glyph_family_hud"):GetString()
	local family = "glyphs_light/" -- Fallback
	
	if con == "light" then
		family = "glyphs_light/"
	elseif con == "dark" then
		family = "glyphs_dark/"
	elseif con == "knockout" then
		family = "glyphs_knockout/"
	end

	return family
end

function ARC9.GlyphFamilyCust()
	local con = GetConVar("arc9_glyph_family_cust"):GetString()
	local family = "glyphs_light/" -- Fallback
	
	if con == "light" then
		family = "glyphs_light/"
	elseif con == "dark" then
		family = "glyphs_dark/"
	elseif con == "knockout" then
		family = "glyphs_knockout/"
	end

	return family
end

function ARC9.GlyphSet()
	local buttonfamily = "Keyboard/"
	local glyphf = GetConVar("arc9_glyph_type"):GetString()
	
	if glyphf == "xbox" then buttonfamily = "Xbox/"
		elseif glyphf == "ps" then buttonfamily = "PS/"
		elseif glyphf == "switch" then buttonfamily = "Switch/"
		else buttonfamily = "Xbox/"
	end

	return buttonfamily
end

ARC9.CTRL_Lookup = {
    MOUSE1 = "shared_mouse_l_click_lg",
    MOUSE2 = "shared_mouse_r_click_lg",
    MOUSE3 = "shared_mouse_mid_click_lg",
    MOUSE4 = "shared_mouse_5_lg",
    MOUSE5 = "shared_mouse_4_lg",

    MWHEELUP = "shared_mouse_scroll_up_lg",
    MWHEELDOWN = "shared_mouse_scroll_down_lg",

    KP_INS = "KP 0",
    KP_END = "KP 1",
    KP_DOWNARROW  = "KP 2",
    KP_PGDN       = "KP 3",
    KP_LEFTARROW  = "KP 4",
    KP_5   = "KP 5",
    KP_RIGHTARROW = "KP 6",
    KP_HOME       = "KP 7",
    KP_UPARROW    = "KP 8",
    KP_PGUP       = "KP 9",
    KP_SLASH      = "KP /",
    KP_MULTIPLY   = "KP *",
    KP_MINUS      = "KP -",
    KP_PLUS       = "KP +",
    KP_ENTER      = "KP ENTER",
    KP_DEL = "KP .",

}

ARC9.CTRL_Exists = {

--[[
	mousel =  true,
	mousemid =  true,
	mouser =  true,
	mouse4 =  true,
	mouse5 =  true,
	mousewhup =  true,
	mousewhdown =  true,
	
-- Shared
	faced = true,
	facel = true,
	facer = true,
	faceu = true,
	stickl = true,
	stickr = true,
	sticklc = true,
	stickrc = true,
	triggerl = true,
	triggerr = true,
	bumperl = true,
	bumperr = true,
	back = true,
	start = true,
	dpadd = true,
	dpadl = true,
	dpadr = true,
	dpadu = true,
--]] 

	ps4_button_logo_lg =  true,
	ps4_button_options_lg =  true,
	ps4_button_share_lg =  true,
	ps4_l1_lg =  true,
	ps4_l2_lg =  true,
	ps4_r1_lg =  true,
	ps4_r2_lg =  true,
	ps4_trackpad_click_lg =  true,
	ps4_trackpad_down_lg =  true,
	ps4_trackpad_l_click_lg =  true,
	ps4_trackpad_l_down_lg =  true,
	ps4_trackpad_l_left_lg =  true,
	ps4_trackpad_l_right_lg =  true,
	ps4_trackpad_l_ring_lg =  true,
	ps4_trackpad_l_swipe_lg =  true,
	ps4_trackpad_l_touch_lg =  true,
	ps4_trackpad_l_up_lg =  true,
	ps4_trackpad_left_lg =  true,
	ps4_trackpad_lg =  true,
	ps4_trackpad_r_click_lg =  true,
	ps4_trackpad_r_down_lg =  true,
	ps4_trackpad_r_left_lg =  true,
	ps4_trackpad_r_right_lg =  true,
	ps4_trackpad_r_ring_lg =  true,
	ps4_trackpad_r_swipe_lg =  true,
	ps4_trackpad_r_touch_lg =  true,
	ps4_trackpad_r_up_lg =  true,
	ps4_trackpad_right_lg =  true,
	ps4_trackpad_ring_lg =  true,
	ps4_trackpad_swipe_lg =  true,
	ps4_trackpad_up_lg =  true,
	ps5_button_create_lg =  true,
	ps5_button_options_lg =  true,
	ps5_l1_lg =  true,
	ps5_l2_lg =  true,
	ps5_r1_lg =  true,
	ps5_r2_lg =  true,
	ps5_trackpad_click_lg =  true,
	ps5_trackpad_down_lg =  true,
	ps5_trackpad_l_click_lg =  true,
	ps5_trackpad_l_down_lg =  true,
	ps5_trackpad_l_left_lg =  true,
	ps5_trackpad_l_right_lg =  true,
	ps5_trackpad_l_ring_lg =  true,
	ps5_trackpad_l_swipe_lg =  true,
	ps5_trackpad_l_touch_lg =  true,
	ps5_trackpad_l_up_lg =  true,
	ps5_trackpad_left_lg =  true,
	ps5_trackpad_lg =  true,
	ps5_trackpad_r_click_lg =  true,
	ps5_trackpad_r_down_lg =  true,
	ps5_trackpad_r_left_lg =  true,
	ps5_trackpad_r_right_lg =  true,
	ps5_trackpad_r_ring_lg =  true,
	ps5_trackpad_r_swipe_lg =  true,
	ps5_trackpad_r_touch_lg =  true,
	ps5_trackpad_r_up_lg =  true,
	ps5_trackpad_right_lg =  true,
	ps5_trackpad_ring_lg =  true,
	ps5_trackpad_swipe_lg =  true,
	ps5_trackpad_up_lg =  true,
	ps_button_circle_lg =  true,
	ps_button_mute_lg =  true,
	ps_button_square_lg =  true,
	ps_button_triangle_lg =  true,
	ps_button_x_lg =  true,
	ps_color_button_circle_lg =  true,
	ps_color_button_square_lg =  true,
	ps_color_button_triangle_lg =  true,
	ps_color_button_x_lg =  true,
	ps_color_outlined_button_circle_lg =  true,
	ps_color_outlined_button_square_lg =  true,
	ps_color_outlined_button_triangle_lg =  true,
	ps_color_outlined_button_x_lg =  true,
	ps_dpad_down_lg =  true,
	ps_dpad_left_lg =  true,
	ps_dpad_lg =  true,
	ps_dpad_right_lg =  true,
	ps_dpad_up_lg =  true,
	ps_outlined_button_circle_lg =  true,
	ps_outlined_button_square_lg =  true,
	ps_outlined_button_triangle_lg =  true,
	ps_outlined_button_x_lg =  true,
	sc_button_l_arrow_lg =  true,
	sc_button_r_arrow_lg =  true,
	sc_button_steam_lg =  true,
	sc_dpad_click_lg =  true,
	sc_dpad_down_lg =  true,
	sc_dpad_left_lg =  true,
	sc_dpad_lg =  true,
	sc_dpad_right_lg =  true,
	sc_dpad_swipe_lg =  true,
	sc_dpad_touch_lg =  true,
	sc_dpad_up_lg =  true,
	sc_lb_lg =  true,
	sc_lg_lg =  true,
	sc_lt_click_lg =  true,
	sc_lt_lg =  true,
	sc_rb_lg =  true,
	sc_rg_lg =  true,
	sc_rt_click_lg =  true,
	sc_rt_lg =  true,
	sc_touchpad_click_lg =  true,
	sc_touchpad_down_lg =  true,
	sc_touchpad_edge_lg =  true,
	sc_touchpad_left_lg =  true,
	sc_touchpad_lg =  true,
	sc_touchpad_right_lg =  true,
	sc_touchpad_swipe_lg =  true,
	sc_touchpad_touch_lg =  true,
	sc_touchpad_up_lg =  true,
	sd_button_aux_lg =  true,
	sd_button_menu_lg =  true,
	sd_button_steam_lg =  true,
	sd_button_view_lg =  true,
	sd_l1_lg =  true,
	sd_l2_half_lg =  true,
	sd_l2_lg =  true,
	sd_l4_lg =  true,
	sd_l5_lg =  true,
	sd_ltrackpad_click_lg =  true,
	sd_ltrackpad_down_lg =  true,
	sd_ltrackpad_left_lg =  true,
	sd_ltrackpad_lg =  true,
	sd_ltrackpad_right_lg =  true,
	sd_ltrackpad_ring_lg =  true,
	sd_ltrackpad_swipe_lg =  true,
	sd_ltrackpad_up_lg =  true,
	sd_r1_lg =  true,
	sd_r2_half_lg =  true,
	sd_r2_lg =  true,
	sd_r4_lg =  true,
	sd_r5_lg =  true,
	sd_rtrackpad_click_lg =  true,
	sd_rtrackpad_down_lg =  true,
	sd_rtrackpad_left_lg =  true,
	sd_rtrackpad_lg =  true,
	sd_rtrackpad_right_lg =  true,
	sd_rtrackpad_ring_lg =  true,
	sd_rtrackpad_swipe_lg =  true,
	sd_rtrackpad_up_lg =  true,
	shared_button_a_lg =  true,
	shared_button_b_lg =  true,
	shared_button_x_lg =  true,
	shared_button_y_lg =  true,
	shared_buttons_e_lg =  true,
	shared_buttons_n_lg =  true,
	shared_buttons_s_lg =  true,
	shared_buttons_w_lg =  true,
	shared_color_button_a_lg =  true,
	shared_color_button_b_lg =  true,
	shared_color_button_x_lg =  true,
	shared_color_button_y_lg =  true,
	shared_color_outlined_button_a_lg =  true,
	shared_color_outlined_button_b_lg =  true,
	shared_color_outlined_button_x_lg =  true,
	shared_color_outlined_button_y_lg =  true,
	shared_dpad_down_lg =  true,
	shared_dpad_left_lg =  true,
	shared_dpad_lg =  true,
	shared_dpad_right_lg =  true,
	shared_dpad_up_lg =  true,
	shared_gyro_lg =  true,
	shared_gyro_pitch_lg =  true,
	shared_gyro_roll_lg =  true,
	shared_gyro_yaw_lg =  true,
	shared_l3_lg =  true,
	shared_lstick_click_lg =  true,
	shared_lstick_down_lg =  true,
	shared_lstick_left_lg =  true,
	shared_lstick_lg =  true,
	shared_lstick_right_lg =  true,
	shared_lstick_touch_lg =  true,
	shared_lstick_up_lg =  true,
	shared_mouse_4_lg =  true,
	shared_mouse_5_lg =  true,
	shared_mouse_l_click_lg =  true,
	shared_mouse_mid_click_lg =  true,
	shared_mouse_r_click_lg =  true,
	shared_mouse_scroll_down_lg =  true,
	shared_mouse_scroll_up_lg =  true,
	shared_outlined_button_a_lg =  true,
	shared_outlined_button_b_lg =  true,
	shared_outlined_button_x_lg =  true,
	shared_outlined_button_y_lg =  true,
	shared_r3_lg =  true,
	shared_rstick_click_lg =  true,
	shared_rstick_down_lg =  true,
	shared_rstick_left_lg =  true,
	shared_rstick_lg =  true,
	shared_rstick_right_lg =  true,
	shared_rstick_touch_lg =  true,
	shared_rstick_up_lg =  true,
	switchpro_button_capture_lg =  true,
	switchpro_button_home_lg =  true,
	switchpro_button_minus_lg =  true,
	switchpro_button_plus_lg =  true,
	switchpro_dpad_down_lg =  true,
	switchpro_dpad_left_lg =  true,
	switchpro_dpad_lg =  true,
	switchpro_dpad_right_lg =  true,
	switchpro_dpad_up_lg =  true,
	switchpro_l2_lg =  true,
	switchpro_l_lg =  true,
	switchpro_lstick_click_lg =  true,
	switchpro_lstick_down_lg =  true,
	switchpro_lstick_left_lg =  true,
	switchpro_lstick_lg =  true,
	switchpro_lstick_right_lg =  true,
	switchpro_lstick_up_lg =  true,
	switchpro_r2_lg =  true,
	switchpro_r_lg =  true,
	switchpro_rstick_click_lg =  true,
	switchpro_rstick_down_lg =  true,
	switchpro_rstick_left_lg =  true,
	switchpro_rstick_lg =  true,
	switchpro_rstick_right_lg =  true,
	switchpro_rstick_up_lg =  true,
	xbox360_button_select_lg =  true,
	xbox360_button_start_lg =  true,
	xbox_button_logo_lg =  true,
	xbox_button_select_lg =  true,
	xbox_button_share_lg =  true,
	xbox_button_start_lg =  true,
	xbox_lb_lg =  true,
	xbox_lt_lg =  true,
	xbox_p1_lg =  true,
	xbox_p2_lg =  true,
	xbox_p3_lg =  true,
	xbox_p4_lg =  true,
	xbox_rb_lg =  true,
	xbox_rt_lg =  true,

}

surface.CreateFont( "ARC9_KeybindPreview", {
    font = "Arial",
    size = 16,
    weight = 600,
    antialias = false,
} )

--[[
    Creates a controller key line.
Info:
     x: X position
     y: Y position
     size: Height of font
     font: Font to use

Vararg:
    String: Out goes a string.
    Table:
        If it has a proper glyph name, it is used.
        If it doesn't, it is made into a key.
]]

local lastupdate = 0
local arc9_controller_glyphset = GetConVar("arc9_controller_glyphset")
local function UpdateGlyphs()
    if lastupdate == FrameNumber() then
        return false
    end
    lastupdate = FrameNumber()

    local glyphset = arc9_controller_glyphset:GetString()
    if glyphset != "" then
        table.Empty(ARC9.CTRL_Set_UserCustom)
        local config = glyphset
        config = string.Split( config, "\\n" )
        for i, v in ipairs(config) do
            local swig = string.Split( v, "\\t" )
            ARC9.CTRL_Set_UserCustom[swig[1]] = swig[2]
        end
        ARC9.CTRL_ConvertTo = ARC9.CTRL_Set_UserCustom
    else
        ARC9.CTRL_ConvertTo = ARC9.CTRL_Set_Xbox
    end

    return true
end

function CreateControllerKeyLine( info, ... )
    UpdateGlyphs()
    local args = { ... }
    local strlength = 0

    for i, v in ipairs( args ) do
        if IsColor(v) then
            surface.SetDrawColor(v)
            surface.SetTextColor(v)
        elseif isstring(v) then
            -- Draw text.
            surface.SetTextPos(info.x + strlength, info.y)
            surface.DrawText(v)
            strlength = strlength + surface.GetTextSize(v)
        elseif istable(v) then
            local size = v[2]
            if isstring(v[1]) and !ARC9.CTRL_Exists[v[1]] then
                -- Draw a key.
                surface.SetFont(info.font_keyb or "ARC9_KeybindPreview")
                local sx, sy = surface.GetTextSize(v[1])
                local keylength = math.max(sx + (info.size/2), info.size)
                surface.DrawOutlinedRect(info.x + strlength, info.y, keylength, info.size )
                surface.SetTextPos(info.x + strlength - (sx/2) + (keylength/2), info.y - (sy/2) + (info.size/2) )
                surface.DrawText( v[1] )
                surface.SetFont(info.font)
                strlength = strlength + keylength
            else
                -- Draw a controller input.
                surface.SetMaterial(v[1])
                surface.DrawTexturedRect( info.x + strlength, info.y - ((size - info.size)*0), size * 1.25, size * 1.25 )
                strlength = strlength + size
            end
        end
    end
    return strlength
end

-- Gets the size of the controller key line.
function GetControllerKeyLineSize( info, ... )
    UpdateGlyphs()
    local args = { ... }
    local strlength = 0

    for i, v in ipairs( args ) do
        if isstring(v) then
            strlength = strlength + surface.GetTextSize(v)
        elseif istable(v) then
            local size = v[2]
            if isstring(v[1]) and !ARC9.CTRL_Exists[v[1]] then
                surface.SetFont(info.font_keyb or "ARC9_KeybindPreview")
                local sx = surface.GetTextSize(v[1])
                local keylength = math.max(sx + (info.size/2), info.size)
                surface.SetFont(info.font)
                strlength = strlength + keylength
            else
                strlength = strlength + size
            end
        end
    end
    return strlength
end




function ARC9MultiLineText(text, maxw, font)
    local content = {}
    local tline = ""
    local x = 0
    surface.SetFont(font)

    local ts = surface.GetTextSize(" ")

    local newlined = string.Split(text, "\n")

    for _, line in ipairs(newlined) do
        local words = string.Split(line, " ")

        -- Keep track of the current color tag across lines
        local active_color_tag = nil

        for _, word in ipairs(words) do
            local tx = surface.GetTextSize(word)

            -- Don't count color tags for length purposes
            local match = {string.match(word, "<color=%d+,%d+,%d+>")}
            local matchend = {string.match(word, "</color>")}
            
            local matchfont = {string.match(word, "<font=^.*$>")}
            local matchfontend = {string.match(word, "</font>")}
            
            for _, v in ipairs(match) do
                tx = tx - surface.GetTextSize(v)
            end
            for _, v in ipairs(matchend) do
                tx = tx - surface.GetTextSize(v)
            end

            for _, v in ipairs(matchfont) do
                tx = tx - surface.GetTextSize(v)
            end
            for _, v in ipairs(matchfontend) do
                tx = tx - surface.GetTextSize(v)
            end

            -- if #match + #matchend > 0 then
            --     print(word, table.ToString(match), table.ToString(matchend))
            -- end

            if x + tx > maxw then
                local dashi = string.find(word, "-")
                if dashi and surface.GetTextSize(utf8.sub(word, 0, dashi)) <= maxw - x then
                    -- cut the word at the dash sign if possible
                    table.insert(content, tline .. utf8.sub(word, 0, dashi))
                    tline = ""
                    x = 0
                    word = utf8.sub(word, dashi + 1)
                    tx = surface.GetTextSize(word)
                else
                    -- move whole word to new line

                    -- close color tag
                    if active_color_tag != nil then
                        tline = tline .. "</color>"
                    end

                    table.insert(content, tline)
                    tline = ""
                    x = 0

                    -- reopen color tag
                    if active_color_tag != nil then
                        tline = tline .. active_color_tag
                    end
                end
            end

            -- Check the status of the color tag at the end of current word
            if math.abs(#match - #matchend) > 1 then
                ErrorNoHalt("<color> tag miscount!\n")
            elseif #match > #matchend then
                if active_color_tag != nil then
                    ErrorNoHalt("<color> tag miscount (too many opening tags)!\n")
                else
                    active_color_tag = match[#match]
                end
            elseif #matchend > #match then
                if active_color_tag == nil then
                    ErrorNoHalt("<color> tag miscount (too many closing tags)!\n")
                else
                    active_color_tag = nil
                end
            end

            tline = tline .. word .. " "

            x = x + tx + ts
        end

        -- close color tag
        if active_color_tag != nil then
            tline = tline .. "</color>"
        end

        table.insert(content, tline)
        tline = ""
        x = 0
    end

    return content
end


-- span: panel that hosts the rotating text
-- txt: the text to draw
-- x: where to start the crop
-- y: where to start the crp
-- tx, ty: where to draw the text
-- maxw: maximum width
-- only: don't advance text
function ARC9.DrawTextRot(span, txt, x, y, tx, ty, maxw, only)
    local tw, th = surface.GetTextSize(txt or "")

    span.TextRot = span.TextRot or {}

    if tw > maxw then
        local realx, realy = span:LocalToScreen(x, y)
        render.SetScissorRect(realx, realy, realx + maxw, realy + (th * 2), true)

        span.TextRot[txt] = span.TextRot[txt] or 0

        if !only then
            span.StartTextRot = span.StartTextRot or CurTime()
            span.TextRotState = span.TextRotState or 0 -- 0: start, 1: moving, 2: end
            if span.TextRotState == 0 then
                span.TextRot[txt] = 0
                if span.StartTextRot < CurTime() - 2 then
                    span.TextRotState = 1
                end
            elseif span.TextRotState == 1 then
                span.TextRot[txt] = span.TextRot[txt] + (FrameTime() * ARC9ScreenScale(32))
                if span.TextRot[txt] >= (tw - maxw) + ARC9ScreenScale(8) then
                    span.StartTextRot = CurTime()
                    span.TextRotState = 2
                end
            elseif span.TextRotState == 2 then
                if span.StartTextRot < CurTime() - 2 then
                    span.TextRotState = 3
                    span.StartTextRot = CurTime()
                end
            elseif span.TextRotState == 3 then
                span.TextRot[txt] = span.TextRot[txt] - (FrameTime() * ARC9ScreenScale(32))
                if span.TextRot[txt] <= 0 then
                    span.StartTextRot = CurTime()
                    span.TextRotState = 0
                end
            end
        end
        surface.SetTextPos(tx - span.TextRot[txt], ty)
        surface.DrawText(txt)
        render.SetScissorRect(0, 0, 0, 0, false)
    else
        surface.SetTextPos(tx, ty)
        surface.DrawText(txt)
    end
end

--PATH lua/arc9/client/cl_matproxy.lua:
matproxy.Add({
    name = "CustomCamo",
    init = function( self, mat, values )
        -- Store the name of the variable we want to set
        self.DetailResult = values.camotexture
        self.ScaleResult = values.camoscale
        self.BlendResult = values.blend

        if self.DetailResult then
            self.DefaultTexture = mat:GetTexture(self.DetailResult)
        end

        if self.ScaleResult then
            self.DefaultScale = mat:GetFloat(self.ScaleResult)
        end

        if self.BlendResult then
            self.DefaultBlend = mat:GetFloat(self.BlendResult)
        end
    end,
    bind = function( self, mat, ent )
        if self.DetailResult and ent.CustomCamoTexture then
            -- mat:SetString(self.DetailResult, self.CustomCamoTexture)
            mat:SetTexture(self.DetailResult, ent.CustomCamoTexture)
            self.ShouldRecomputeIfSet = true
        elseif self.DetailResult then
            self.DefaultTexture = nil
            if !self.DefaultTexture then
                mat:SetUndefined(self.DetailResult)
                if self.ShouldRecomputeIfSet then
                    mat:Recompute()
                    self.ShouldRecomputeIfSet = false
                end
            else
                mat:SetTexture(self.DetailResult, self.DefaultTexture)
            end
        end

        if self.ScaleResult and ent.CustomCamoScale then
            mat:SetFloat(self.ScaleResult, ent.CustomCamoScale)
            self.ShouldRecomputeIfSet = true
        elseif self.ScaleResult then
            if self.DefaultScale then
                mat:SetFloat(self.ScaleResult, self.DefaultScale)
            else
                mat:SetUndefined(self.ScaleResult)
                if self.ShouldRecomputeIfSet then
                    mat:Recompute()
                    self.ShouldRecomputeIfSet = false
                end
            end
        end

        if self.BlendResult and ent.CustomCamoBlend then
            mat:SetFloat(self.BlendResult, ent.CustomCamoBlend)
            self.ShouldRecomputeIfSet = true
        elseif self.BlendResult then
            if self.DefaultBlend then
                mat:SetFloat(self.BlendResult, self.DefaultBlend)
            else
                mat:SetUndefined(self.DefaultBlend)
                if self.ShouldRecomputeIfSet then
                    mat:Recompute()
                    self.ShouldRecomputeIfSet = false
                end
            end
        end

    end
})

matproxy.Add({
    name = "ARC9_Heat",
    init = function( self, mat, values )
        self.BlendResult = values.blend
    end,

    bind = function( self, mat, ent )
        if IsValid(ent) and IsValid(ent.weapon) then ent = ent.weapon end

        if IsValid(ent) and IsValid(ent:GetOwner()) and IsValid(ent:GetOwner():GetActiveWeapon()) then
            local weapon = ent:GetOwner():GetActiveWeapon()
            if weapon and weapon.ARC9 and weapon:GetProcessedValue("Overheat", true) then
                mat:SetFloat(self.BlendResult, (math.ease.InExpo(weapon:GetHeatAmount() / weapon:GetProcessedValue("HeatCapacity", true))) * 2)
            end
        else
            mat:SetFloat(self.BlendResult, 0)
        end
    end
})

matproxy.Add({
    name = "arc9_scope_alpha",
    init = function(self, mat, values)
        self.ResultTo = values.resultvar
    end,
    bind = function(self, mat, ent)
        local ply = LocalPlayer()

        if IsValid(ply) then
            local weapon = ply:GetActiveWeapon()

            if IsValid(weapon) and weapon.ARC9 then
                local amt = 1 - weapon:GetSightAmount() / 1 
                amt = amt * 0.2
                mat:SetVector(self.ResultTo, Vector(amt*2.2, amt*1.8, amt*2.6))
            end
        end
   end
})

local lastPos = Vector()
local lastValue = 0
local lerp = Lerp
matproxy.Add( {
	name = "Arc9EnvMapTint",
	
	init = function(self, mat, values)
		local color = {1, 1, 1} 

		if (values.color != nil) then
			color = string.Explode(" ", string.Replace(string.Replace(values.color, "[", ""), "]", ""))
		end

		self.min = values.min || 0
		self.max = values.max || 1
		self.color = Vector(color[1], color[2], color[3])
		--mat:SetTexture("$envmap", values.envmap || "arc9/shared/envmaps/specularity_50")
		if (values.envmap != "env_cubemap") then
		   mat:SetTexture("$envmap", values.envmap || "arc9/shared/envmaps/specularity_50")
		else
		   mat:SetString("$envmap", "env_cubemap")
		end
	end,

	bind = function(self, mat, ent)
		if (!IsValid(ent)) then return end

		if (!lastPos:IsEqualTol(ent:GetPos(), 1)) then
			local c = render.GetLightColor(ent:GetPos())
			lastValue = (c.x * 0.2126) + (c.y * 0.7152) + (c.z * 0.0722)
			lastValue = math.min(lastValue * 2, 1)
			lastPos = ent:GetPos()
		end

		ent.m_Arc9EnvMapTint = lerp(10 * RealFrameTime(), ent.m_Arc9EnvMapTint || 0, lastValue)
		mat:SetVector("$envmaptint", self.color * lerp(ent.m_Arc9EnvMapTint, self.min, self.max))
	end
})

----- Add this to your VMT to fix garbage/shitty reflection

    -- "Proxies"
    -- {
        -- "Arc9EnvMapTint"
        -- {
            -- "specularity" "0.5"
            -- "min" "0"
            -- "max" "0.2" // Change this if its too bright in game
        -- }
    -- }
-- }
--PATH lua/arc9/client/cl_pp.lua:
return gluapack()()
--PATH lua/arc9/client/cl_tpik.lua:
hook.Add("PrePlayerDraw", "ARC9_TPIK", function(ply, flags)
    local wpn = ply:GetActiveWeapon()

    if !wpn.ARC9 then return end

    wpn:DoTPIK()
end)
--PATH addons/[misc] szachy/lua/chess/cl_top.lua:

local Top10
local function ChessTop10( typ )
	if IsValid(Top10) then Top10:Remove() end
	
	typ = typ or "Chess"
	
	Top10 = vgui.Create( "DFrame" )
	Top10:SetSize( 450, 245 )
	Top10:SetPos( (ScrW()/2)-150, (ScrH()/2)-100 )
	Top10:SetTitle( "Top 10 Chess Elo ratings" )
	Top10:MakePopup()
	Top10.Column = "Elo"
	
	local pnl = vgui.Create("DPanel", Top10)
	pnl.Paint = function() end
	pnl:SetTall(20)
	pnl:Dock(BOTTOM)
	
	Top10.Rank = vgui.Create( "DLabel", pnl )
	Top10.Rank:Dock( LEFT )
	Top10.Rank:SetTall( 20 )
	Top10.Rank:SetWide( 150 )
	Top10.Rank:SetText("")
	
	Top10.Updated = vgui.Create( "DLabel", pnl )
	Top10.Updated:Dock( RIGHT )
	Top10.Updated:SetTall( 150 )
	Top10.Updated:SetText("")
	
	Top10.List = vgui.Create( "DListView", Top10 )
	local List = Top10.List
	List:Dock( FILL )
	List:AddColumn( "Rank" )
	List:AddColumn( "Name" )
	List:AddColumn( "SteamID" )
	List:AddColumn( "Elo" )
	
	List:AddLine( "", "Loading..." )
	-- PrintTable( List.Columns )
	List:OnRequestResize( List.Columns[1], 10 )
	List:OnRequestResize( List.Columns[2], 150 )
	List:OnRequestResize( List.Columns[3], 100 )
	List:OnRequestResize( List.Columns[4], 10 )
	
	net.Start( "Chess Top10" ) net.WriteString( typ ) net.SendToServer()
end
local function DraughtsTop10()
	ChessTop10( "Draughts" )
end
concommand.Add( "chess_top", function( p,c,a ) ChessTop10() end)
concommand.Add( "checkers_top", function( p,c,a ) DraughtsTop10() end)

local ChatCommands = {
	["!chess"]=ChessTop10,	["!chesstop"]=ChessTop10,	["!topchess"]=ChessTop10,
	["/chess"]=ChessTop10,	["/chesstop"]=ChessTop10,	["/topchess"]=ChessTop10,
	
	["!draughts"]=DraughtsTop10,	["!draughtstop"]=DraughtsTop10,	["!topdraughts"]=DraughtsTop10,
	["/draughts"]=DraughtsTop10,	["/draughtstop"]=DraughtsTop10,	["/topdraughts"]=DraughtsTop10,
	
	["!checkers"]=DraughtsTop10,	["!checkerstop"]=DraughtsTop10,	["!topcheckers"]=DraughtsTop10,
	["/checkers"]=DraughtsTop10,	["/checkerstop"]=DraughtsTop10,	["/topcheckers"]=DraughtsTop10,
}
hook.Add( "OnPlayerChat", "Chess Top10 PlayerChat", function( ply, str, tm, dead )
	if ChatCommands[str:lower()] then
		if ply==LocalPlayer() then
			ChatCommands[str:lower()]()
		end
		return true
	end
end)

local function SecondsToTime(num)
	if updateTime>=86400 then
		return ("%i day%s"):format( math.floor(updateTime/86400), updateTime>=172800 and "s" or "")
	elseif updateTime>=3600 then
		return ("%i hour%s"):format( math.floor(updateTime/3600), updateTime>=7200 and "s" or "")
	elseif updateTime>=60 then
		return ("%i minute%s"):format( math.floor(updateTime/60), updateTime>=120 and "s" or "")
	else
		return ("%i second%s"):format(updateTime, updateTime>=2 and "s" or "")
	end
end

local lastTable = {}
local lastRank = {}
local lastUpdate = {}
net.Receive( "Chess Top10", function()
	if not (IsValid(Top10) and IsValid(Top10.List)) then return end
	
	Top10.List:Clear()
	
	local typ = net.ReadString() or "[Error]"
	
	Top10:SetTitle( "Top 10 "..typ.." Elo ratings" )
	
	local tbl = net.ReadTable()
	if (not tbl) or (#tbl==0) then -- Rate limit exceeded
		if lastTable[typ] then
			for i=1,#lastTable[typ] do
				Top10.List:AddLine( tonumber(lastTable[typ][i].Rank), lastTable[typ][i].Username, lastTable[typ][i].SteamID, tonumber(lastTable[typ][i]["Elo" ]) )
			end
			Top10.Rank:SetText( "You are rank "..lastRank[typ] )
			
			if lastUpdate[typ] then
				updateTime = math.floor(CurTime() - lastUpdate[typ])
				if updateTime>0 then
					Top10.Updated:SetText( ("Updated %s ago."):format(SecondsToTime(updateTime)) )
				end
				Top10.Updated:SizeToContents()
			end
		else
			Top10.List:AddLine( "", "ERROR: Rate limit exceeded." )
			Top10.List:AddLine( "", "Please try again in a few minutes." )
		end
		
		return
	end
	
	for i=1,#tbl do
		Top10.List:AddLine( tonumber(tbl[i].Rank), tbl[i].Username, tbl[i].SteamID, tonumber(tbl[i]["Elo" ]) )
	end
	
	local rank = (net.ReadString() or "N/A")
	Top10.Rank:SetText( "You are rank "..rank )
	
	lastUpdate[typ] = tonumber(net.ReadString())
	if lastUpdate[typ] then
		updateTime = math.floor(CurTime() - lastUpdate[typ])
		
		if updateTime>0 then
			Top10.Updated:SetText( ("Updated %s ago."):format(SecondsToTime(updateTime)) )
		end
		Top10.Updated:SizeToContents()
	end
	
	lastTable[typ] = tbl
	lastRank[typ] = rank
end)

--PATH lua/autorun/sh_default-configurations.lua:
hook.Add("LoadSmokeScreenConfiguration", "UnitysSmokeScreens.SetupSmokeScreenConfiguration", function ()
    USS:RegisterSmokeScreenVehicleConfiguration("lunasflightschool_niksacokica_tx-427",
            {
                {
                    pos = Vector(-30,-67.55,77.33),
                    dir = USS.CONST.UP_FORWARD,
                    dirMulti = 500,
                },
                {
                    pos = Vector(-30,67.55,77.33),
                    dir = USS.CONST.UP_FORWARD,
                    dirMulti = 500,
                },
                {
                    pos = Vector(-40,-67.55,77.33),
                    dir = USS.CONST.UP_FORWARD_22R,
                    dirMulti = 500,
                },
                {
                    pos = Vector(-40,67.55,77.33),
                    dir = USS.CONST.UP_FORWARD_22L,
                    dirMulti = 500,
                },
                {
                    pos = Vector(-50,-67.55,77.33),
                    dir = USS.CONST.UP_FORWARD_45R,
                    dirMulti = 500,
                },
                {
                    pos = Vector(-50,67.55,77.33),
                    dir = USS.CONST.UP_FORWARD_45L,
                    dirMulti = 500,
                },
            },
            1
    )

    USS:RegisterSmokeScreenVehicleConfiguration("lvs_walker_atte",
            {
                {
                    pos = Vector(160,-28.73,188.03),
                    dir = USS.CONST.UP_FORWARD,
                    dirMulti = 500,
                },
                {
                    pos = Vector(160,28.73,188.03),
                    dir = USS.CONST.UP_FORWARD,
                    dirMulti = 500,
                },
                {
                    pos = Vector(150,-28.73,188.03),
                    dir = USS.CONST.UP_FORWARD_22R,
                    dirMulti = 500,
                },
                {
                    pos = Vector(150,28.73,188.03),
                    dir = USS.CONST.UP_FORWARD_22L,
                    dirMulti = 500,
                },
                {
                    pos = Vector(140,-28.73,188.03),
                    dir = USS.CONST.UP_FORWARD_45R,
                    dirMulti = 500,
                },
                {
                    pos = Vector(140,28.73,188.03),
                    dir = USS.CONST.UP_FORWARD_45L,
                    dirMulti = 500,
                },
            },
            1
    )

end)

--PATH lua/autorun/sh_pixelui_loader.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

if PIXEL and PIXEL.UI then return end

PIXEL = PIXEL or {}
PIXEL.UI = PIXEL.UI or {}
PIXEL.UI.Version = "1.3.2"

function PIXEL.LoadDirectory(path)
	local files, folders = file.Find(path .. "/*", "LUA")

	for _, fileName in ipairs(files) do
		local filePath = path .. "/" .. fileName

		if CLIENT then
			include(filePath)
		else
			if fileName:StartWith("cl_") then
				AddCSLuaFile(filePath)
			elseif fileName:StartWith("sh_") then
				AddCSLuaFile(filePath)
				include(filePath)
			else
				include(filePath)
			end
		end
	end

	return files, folders
end

function PIXEL.LoadDirectoryRecursive(basePath)
	local _, folders = PIXEL.LoadDirectory(basePath)
	for _, folderName in ipairs(folders) do
		PIXEL.LoadDirectoryRecursive(basePath .. "/" .. folderName)
	end
end

PIXEL.LoadDirectoryRecursive("pixelui")

hook.Run("PIXEL.UI.FullyLoaded")

if CLIENT then return end

resource.AddWorkshop("2468112758")

hook.Add("Think", "PIXEL.UI.VersionChecker", function()
	hook.Remove("Think", "PIXEL.UI.VersionChecker")

	http.Fetch("https://raw.githubusercontent.com/TomDotBat/pixel-ui/master/VERSION", function(body)
		if PIXEL.UI.Version ~= string.Trim(body) then
			local red = Color(192, 27, 27)

			MsgC(red, "[PIXEL UI] There is an update available, please download it at: https://github.com/TomDotBat/pixel-ui/releases\n")
			MsgC(red, "\nYour version: " .. PIXEL.UI.Version .. "\n")
			MsgC(red, "New  version: " .. body .. "\n")
			return
		end
	end)
end)

--PATH lua/pixelui/core/cl_overrides.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

PIXEL.UI.Overrides = PIXEL.UI.Overrides or {}

function PIXEL.UI.CreateToggleableOverride(method, override, toggleGetter)
    return function(...)
        return toggleGetter(...) and override(...) or method(...)
    end
end

local overridePopupsCvar = CreateClientConVar("pixel_ui_override_popups", (PIXEL.OverrideDermaMenus > 1) and "1" or "0", true, false, "Should the default derma popups be restyled with PIXEL UI?", 0, 1)
function PIXEL.UI.ShouldOverrideDermaPopups()
    local overrideSetting = PIXEL.OverrideDermaMenus

    if not overrideSetting or overrideSetting == 0 then return false end
    if overrideSetting == 3 then return true end

    return overridePopupsCvar:GetBool()
end
--PATH lua/pixelui/drawing/cl_circle.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

do
    local materials = {
        "https://pixel-cdn.lythium.dev/i/srlt7tk7m", --8
        "https://pixel-cdn.lythium.dev/i/l2km82zi", --16
        "https://pixel-cdn.lythium.dev/i/5mqrguuxd", --32
        "https://pixel-cdn.lythium.dev/i/yxh641f2a", --64
        "https://pixel-cdn.lythium.dev/i/yz2n2neu", --128
        "https://pixel-cdn.lythium.dev/i/v4sxyjdd8", --256
        "https://pixel-cdn.lythium.dev/i/nmp8368j", --512
        "https://pixel-cdn.lythium.dev/i/e425w7lrj", --1024
        "https://pixel-cdn.lythium.dev/i/iinrlgj5b" --2048
    }

    local max = math.max
    function PIXEL.DrawCircle(x, y, w, h, col)
        local size = max(w, h)
        local id = materials[1]

        local curSize = 8
        for i = 1, #materials do
            if size <= curSize then break end
            id = materials[i + 1] or id
            curSize = curSize + curSize
        end

        PIXEL.DrawImage(x, y, w, h, id, col)
    end
end

do
    local insert = table.insert
    local rad, sin, cos = math.rad, math.sin, math.cos

    function PIXEL.CreateCircle(x, y, ang, seg, pct, radius)
        local circle = {}

        insert(circle, {x = x, y = y})

        for i = 0, seg do
            local segAngle = rad((i / seg) * -pct + ang)
            insert(circle, {x = x + sin(segAngle) * radius, y = y + cos(segAngle) * radius})
        end

        return circle
    end
end

local createCircle = PIXEL.CreateCircle
local drawPoly = surface.DrawPoly
function PIXEL.DrawCircleUncached(x, y, ang, seg, pct, radius)
    drawPoly(createCircle(x, y, ang, seg, pct, radius))
end
--PATH lua/pixelui/drawing/cl_images.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local progressMat

local drawProgressWheel
local setMaterial = surface.SetMaterial
local setDrawColor = surface.SetDrawColor

do
    local min = math.min
    local curTime = CurTime
    local drawTexturedRectRotated = surface.DrawTexturedRectRotated

    function PIXEL.DrawProgressWheel(x, y, w, h, col)
        local progSize = min(w, h)
        setMaterial(progressMat)
        setDrawColor(col.r, col.g, col.b, col.a)
        drawTexturedRectRotated(x + w * .5, y + h * .5, progSize, progSize, -curTime() * 100)
    end
    drawProgressWheel = PIXEL.DrawProgressWheel
end

local materials = {}
local grabbingMaterials = {}

local getImage = PIXEL.GetImage
getImage(PIXEL.ProgressImageURL, function(mat)
    progressMat = mat
end)

local drawTexturedRect = surface.DrawTexturedRect
function PIXEL.DrawImage(x, y, w, h, url, col)
    if not materials[url] then
        drawProgressWheel(x, y, w, h, col)

        if grabbingMaterials[url] then return end
        grabbingMaterials[url] = true

        getImage(url, function(mat)
            materials[url] = mat
            grabbingMaterials[url] = nil
        end)

        return
    end

    setMaterial(materials[url])
    setDrawColor(col.r, col.g, col.b, col.a)
    drawTexturedRect(x, y, w, h)
end

local drawTexturedRectRotated = surface.DrawTexturedRectRotated
function PIXEL.DrawImageRotated(x, y, w, h, rot, url, col)
    if not materials[url] then
        drawProgressWheel(x - w * .5, y - h * .5, w, h, col)

        if grabbingMaterials[url] then return end
        grabbingMaterials[url] = true

        getImage(url, function(mat)
            materials[url] = mat
            grabbingMaterials[url] = nil
        end)

        return
    end

    setMaterial(materials[url])
    setDrawColor(col.r, col.g, col.b, col.a)
    drawTexturedRectRotated(x, y, w, h, rot)
end

function PIXEL.DrawImgur(x, y, w, h, imgurId, col)
    local url = "https://i.imgur.com/" .. imgurId .. ".png"
    PIXEL.DrawImage(x, y, w, h, url, col)
end

function PIXEL.DrawImgurRotated(x, y, w, h, rot, imgurId, col)
    local url = "https://i.imgur.com/" .. imgurId .. ".png"
    PIXEL.DrawImageRotated(x, y, w, h, rot, url, col)
end
--PATH lua/pixelui/elements/cl_button.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_frame.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

AccessorFunc(PANEL, "Draggable", "Draggable", FORCE_BOOL)
AccessorFunc(PANEL, "Sizable", "Sizable", FORCE_BOOL)
AccessorFunc(PANEL, "MinWidth", "MinWidth", FORCE_NUMBER)
AccessorFunc(PANEL, "MinHeight", "MinHeight", FORCE_NUMBER)
AccessorFunc(PANEL, "ScreenLock", "ScreenLock", FORCE_BOOL)
AccessorFunc(PANEL, "RemoveOnClose", "RemoveOnClose", FORCE_BOOL)

AccessorFunc(PANEL, "Title", "Title", FORCE_STRING)
AccessorFunc(PANEL, "ImgurID", "ImgurID", FORCE_STRING) -- Deprecated
AccessorFunc(PANEL, "ImageURL", "ImageURL", FORCE_STRING)

function PANEL:SetImgurID(id)
	self:SetImageURL("https://i.imgur.com/" .. id .. ".png")
	self.ImgurID = id
end

function PANEL:GetImgurID()
	return self:GetImageURL():match("https://i.imgur.com/(.-).png")
end

PIXEL.RegisterFont("UI.FrameTitle", "Open Sans Bold", 22)

function PANEL:Init()
	self.CloseButton = vgui.Create("PIXEL.ImageButton", self)
	self.CloseButton:SetImageURL("https://pixel-cdn.lythium.dev/i/fh640z2o")
	self.CloseButton:SetNormalColor(PIXEL.Colors.PrimaryText)
	self.CloseButton:SetHoverColor(PIXEL.Colors.Negative)
	self.CloseButton:SetClickColor(PIXEL.Colors.Negative)
	self.CloseButton:SetDisabledColor(PIXEL.Colors.DisabledText)

	self.CloseButton.DoClick = function(s)
		self:Close()
	end

	self.ExtraButtons = {}

	self:SetTitle("PIXEL Frame")

	self:SetDraggable(true)
	self:SetScreenLock(true)
	self:SetRemoveOnClose(true)

	local size = PIXEL.Scale(200)
	self:SetMinWidth(size)
	self:SetMinHeight(size)

	local oldMakePopup = self.MakePopup
	function self:MakePopup()
		oldMakePopup(self)
		self:Open()
	end
end

function PANEL:DragThink(targetPanel, hoverPanel)
	local scrw, scrh = ScrW(), ScrH()
	local mousex, mousey = math.Clamp(gui.MouseX(), 1, scrw - 1), math.Clamp(gui.MouseY(), 1, scrh - 1)

	if targetPanel.Dragging then
		local x = mousex - targetPanel.Dragging[1]
		local y = mousey - targetPanel.Dragging[2]

		if targetPanel:GetScreenLock() then
			x = math.Clamp(x, 0, scrw - targetPanel:GetWide())
			y = math.Clamp(y, 0, scrh - targetPanel:GetTall())
		end

		targetPanel:SetPos(x, y)
	end

	local _, screenY = targetPanel:LocalToScreen(0, 0)
	if (hoverPanel or targetPanel).Hovered and targetPanel:GetDraggable() and mousey < (screenY + PIXEL.Scale(30)) then
		targetPanel:SetCursor("sizeall")
		return true
	end
end

function PANEL:SizeThink(targetPanel, hoverPanel)
	local scrw, scrh = ScrW(), ScrH()
	local mousex, mousey = math.Clamp(gui.MouseX(), 1, scrw - 1), math.Clamp(gui.MouseY(), 1, scrh - 1)

	if targetPanel.Sizing then
		local x = mousex - targetPanel.Sizing[1]
		local y = mousey - targetPanel.Sizing[2]
		local px, py = targetPanel:GetPos()

		local screenLock = self:GetScreenLock()
		if x < targetPanel.MinWidth then x = targetPanel.MinWidth elseif x > scrw - px and screenLock then x = scrw - px end
		if y < targetPanel.MinHeight then y = targetPanel.MinHeight elseif y > scrh - py and screenLock then y = scrh - py end

		targetPanel:SetSize(x, y)
		targetPanel:SetCursor("sizenwse")
		return true
	end

	local screenX, screenY = targetPanel:LocalToScreen(0, 0)
	if (hoverPanel or targetPanel).Hovered and targetPanel.Sizable and mousex > (screenX + targetPanel:GetWide() - PIXEL.Scale(20)) and mousey > (screenY + targetPanel:GetTall() - PIXEL.Scale(20)) then
		(hoverPanel or targetPanel):SetCursor("sizenwse")
		return true
	end
end

function PANEL:Think()
	if self:DragThink(self) then return end
	if self:SizeThink(self) then return end

	self:SetCursor("arrow")

	if self.y < 0 then
		self:SetPos(self.x, 0)
	end
end

function PANEL:OnMousePressed()
	local screenX, screenY = self:LocalToScreen(0, 0)
	local mouseX, mouseY = gui.MouseX(), gui.MouseY()

	if self.Sizable and mouseX > (screenX + self:GetWide() - PIXEL.Scale(30)) and mouseY > (screenY + self:GetTall() - PIXEL.Scale(30)) then
		self.Sizing = {mouseX - self:GetWide(), mouseY - self:GetTall()}
		self:MouseCapture(true)
		return
	end

	if self:GetDraggable() and mouseY < (screenY + PIXEL.Scale(30)) then
		self.Dragging = {mouseX - self.x, mouseY - self.y}
		self:MouseCapture(true)
		return
	end
end

function PANEL:OnMouseReleased()
	self.Dragging = nil
	self.Sizing = nil
	self:MouseCapture(false)
end

function PANEL:CreateSidebar(defaultItem, imageURL, imageScale, imageYOffset, buttonYOffset)
	if IsValid(self.SideBar) then return end
	self.SideBar = vgui.Create("PIXEL.Sidebar", self)

	if defaultItem then
		timer.Simple(0, function()
			if not IsValid(self.SideBar) then return end
			self.SideBar:SelectItem(defaultItem)
		end)
	end

	if imageURL then
		local imgurMatch = (imageURL or ""):match("^[a-zA-Z0-9]+$")
		if imgurMatch then
			imageURL = "https://i.imgur.com/" .. imageURL .. ".png"
		end

		self.SideBar:SetImageURL(imageURL)
	end

	if imageScale then self.SideBar:SetImageScale(imageScale) end
	if imageYOffset then self.SideBar:SetImageOffset(imageYOffset) end
	if buttonYOffset then self.SideBar:SetButtonOffset(buttonYOffset) end

	return self.SideBar
end

function PANEL:AddHeaderButton(elem, size)
	elem.HeaderIconSize = size or .45
	return table.insert(self.ExtraButtons, elem)
end

function PANEL:LayoutContent(w, h) end

function PANEL:PerformLayout(w, h)
	local headerH = PIXEL.Scale(30)
	local btnPad = PIXEL.Scale(6)
	local btnSpacing = PIXEL.Scale(6)

	if IsValid(self.CloseButton) then
		local btnSize = headerH * .45
		self.CloseButton:SetSize(btnSize, btnSize)
		self.CloseButton:SetPos(w - btnSize - btnPad, (headerH - btnSize) / 2)

		btnPad = btnPad + btnSize + btnSpacing
	end

	for _, btn in ipairs(self.ExtraButtons) do
		local btnSize = headerH * btn.HeaderIconSize
		btn:SetSize(btnSize, btnSize)
		btn:SetPos(w - btnSize - btnPad, (headerH - btnSize) / 2)
		btnPad = btnPad + btnSize + btnSpacing
	end

	if IsValid(self.SideBar) then
		self.SideBar:SetPos(0, headerH)
		self.SideBar:SetSize(PIXEL.Scale(200), h - headerH)
	end

	local padding = PIXEL.Scale(6)
	self:DockPadding(self.SideBar and PIXEL.Scale(200) + padding or padding, headerH + padding, padding, padding)

	self:LayoutContent(w, h)
end

function PANEL:Open()
	self:SetAlpha(0)
	self:SetVisible(true)
	self:AlphaTo(255, .1, 0)
end

function PANEL:Close()
	self:AlphaTo(0, .1, 0, function(anim, pnl)
		if not IsValid(pnl) then return end
		pnl:SetVisible(false)
		pnl:OnClose()
		if pnl:GetRemoveOnClose() then pnl:Remove() end
	end)
end

function PANEL:OnClose() end

function PANEL:PaintHeader(x, y, w, h)
	PIXEL.DrawRoundedBoxEx(PIXEL.Scale(6), x, y, w, h, PIXEL.Colors.Header, true, true)

	local imageURL = self:GetImageURL()
	if imageURL then
		local iconSize = h * .6
		PIXEL.DrawImage(PIXEL.Scale(6), x + (h - iconSize) / 2, y + iconSize, iconSize, imageURL, color_white)
		PIXEL.DrawSimpleText(self:GetTitle(), "UI.FrameTitle", x + PIXEL.Scale(12) + iconSize, y + h / 2, PIXEL.Colors.PrimaryText, nil, TEXT_ALIGN_CENTER)
		return
	end

	PIXEL.DrawSimpleText(self:GetTitle(), "UI.FrameTitle", x + PIXEL.Scale(6), y + h / 2, PIXEL.Colors.PrimaryText, nil, TEXT_ALIGN_CENTER)
end

function PANEL:Paint(w, h)
	self:PaintBefore(w, h)
	PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, 0, w, h, PIXEL.Colors.Background)
	self:PaintHeader(0, 0, w, PIXEL.Scale(30))
end

function PANEL:PaintBefore(w, h)
end

vgui.Register("PIXEL.Frame", PANEL, "EditablePanel")

--PATH lua/pixelui/elements/cl_imgur_button.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_scrollbar.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_scrollpanel.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

AccessorFunc(PANEL, "Padding",   "Padding")
AccessorFunc(PANEL, "Canvas", "Canvas")
AccessorFunc(PANEL, "ScrollbarLeft", "ScrollbarLeftSide")
AccessorFunc(PANEL, "BarDockShouldOffset", "BarDockShouldOffset", FORCE_BOOL)

function PANEL:Init()
    self.Canvas = vgui.Create("Panel", self)
    self.Canvas.OnMousePressed = function(s, code) s:GetParent():OnMousePressed(code) end
    self.Canvas:SetMouseInputEnabled(true)
    self.Canvas.PerformLayout = function(pnl)
        self:PerformLayout()
        self:InvalidateParent()
    end

    self.VBar = vgui.Create("PIXEL.Scrollbar", self)
    self.VBar:Dock(RIGHT)

    self:SetPadding(0)
    self:SetMouseInputEnabled(true)

    self:SetPaintBackgroundEnabled(false)
    self:SetPaintBorderEnabled(false)

    self.ScrollDelta = 0
    self.ScrollReturnWait = 0

    self:SetBarDockShouldOffset(true)
    self.VBar:SetWide(PIXEL.Scale(8))

    self.Canvas.PerformLayout = function(s, w, h)
        self:LayoutContent(w, h)
    end
end

function PANEL:AddItem(pnl)
    pnl:SetParent(self:GetCanvas())
end

function PANEL:OnChildAdded(child)
    self:AddItem(child)
end

function PANEL:SizeToContents()
    self:SetSize(self.Canvas:GetSize())
end

function PANEL:GetVBar()
    return self.VBar
end

function PANEL:GetCanvas()
    return self.Canvas
end

function PANEL:InnerWidth()
    return self:GetCanvas():GetWide()
end

function PANEL:Rebuild()
    self:GetCanvas():SizeToChildren(false, true)

    if self.m_bNoSizing and self:GetCanvas():GetTall() < self:GetTall() then
        self:GetCanvas():SetPos(0, (self:GetTall() - self:GetCanvas():GetTall()) * 0.5)
    end
end

function PANEL:Think()
    if not self.lastThink then self.lastThink = CurTime() end
    local elapsed = CurTime() - self.lastThink
    self.lastThink = CurTime()

    if self.ScrollDelta > 0 then
        self.VBar:OnMouseWheeled(self.ScrollDelta / 1)

        if self.VBar.Scroll >= 0 then
            self.ScrollDelta = self.ScrollDelta - 10 * elapsed
        end
        if self.ScrollDelta < 0 then self.ScrollDelta = 0 end
    elseif self.ScrollDelta < 0 then
        self.VBar:OnMouseWheeled(self.ScrollDelta / 1)

        if self.VBar.Scroll <= self.VBar.CanvasSize then
            self.ScrollDelta = self.ScrollDelta + 10 * elapsed
        end
        if self.ScrollDelta > 0 then self.ScrollDelta = 0 end
    end

    if self.ScrollReturnWait >= 1 then
        if self.VBar.Scroll < 0 then
            if self.VBar.Scroll <= -75 and self.ScrollDelta > 0 then self.ScrollDelta = self.ScrollDelta / 2 end

            self.ScrollDelta = self.ScrollDelta + (self.VBar.Scroll / 1500 - 0.01) * 100 * elapsed

        elseif self.VBar.Scroll > self.VBar.CanvasSize then
            if self.VBar.Scroll >= self.VBar.CanvasSize + 75 and self.ScrollDelta < 0 then self.ScrollDelta = self.ScrollDelta / 2 end

            self.ScrollDelta = self.ScrollDelta + ((self.VBar.Scroll - self.VBar.CanvasSize) / 1500 + 0.01) * 100 * elapsed
        end
    else
        self.ScrollReturnWait = self.ScrollReturnWait + 10 * elapsed
    end
end

function PANEL:OnMouseWheeled(delta)
    if (delta > 0 and self.VBar.Scroll <= self.VBar.CanvasSize * 0.005) or
            (delta < 0 and self.VBar.Scroll >= self.VBar.CanvasSize * 0.995) then
        self.ScrollDelta = self.ScrollDelta + delta / 10
        return
    end

    self.ScrollDelta = delta / 2
    self.ScrollReturnWait = 0
end

function PANEL:OnVScroll(iOffset)
    self.Canvas:SetPos(0, iOffset)
end

function PANEL:ScrollToChild(panel)
    self:PerformLayout()

    local y = select(2, self.Canvas:GetChildPosition(panel)) + select(2, panel:GetSize()) * 0.5;
    y = y - self:GetTall() * 0.5;

    self.VBar:AnimateTo(y, 0.5, 0, 0.5);
end

function PANEL:LayoutContent(w, h) end

function PANEL:PerformLayout(w, h)
    if self:GetScrollbarLeftSide() then
        self.VBar:Dock(LEFT)
    else
        self.VBar:Dock(RIGHT)
    end

    local wide = self:GetWide()
    local xPos = 0
    local yPos = 0

    self:Rebuild()

    self.VBar:SetUp(self:GetTall(), self.Canvas:GetTall())
    yPos = self.VBar:GetOffset()

    if self.VBar.Enabled or not self:GetBarDockShouldOffset() then
        wide = wide - self.VBar:GetWide()

        if self:GetScrollbarLeftSide() then
            xPos = self.VBar:GetWide()
        end
    end

    self.Canvas:SetPos(xPos, yPos)
    self.Canvas:SetWide(wide)

    self:Rebuild()
end

function PANEL:Clear()
    return self.Canvas:Clear()
end

function PANEL:Paint(w, h) end

vgui.Register("PIXEL.ScrollPanel", PANEL, "DPanel")

--PATH lua/pixelui/elements/cl_sidebar.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

AccessorFunc(PANEL, "Name", "Name", FORCE_STRING)
AccessorFunc(PANEL, "ImageURL", "ImageURL", FORCE_STRING)
AccessorFunc(PANEL, "DrawOutline", "DrawOutline", FORCE_BOOL)
AccessorFunc(PANEL, "ImgurID", "ImgurID", FORCE_STRING) -- Deprecated

function PANEL:SetImgurID(id)
	self:SetImageURL("https://i.imgur.com/" .. id .. ".png")
	self.ImgurID = id
end

function PANEL:GetImgurID()
	return self:GetImageURL():match("https://i.imgur.com/(.-).png")
end

PIXEL.RegisterFont("SidebarItem", "Open Sans Bold", 19)

function PANEL:Init()
	self:SetName("N/A")
	self:SetDrawOutline(true)

	self.TextCol = PIXEL.CopyColor(PIXEL.Colors.SecondaryText)
	self.BackgroundCol = PIXEL.CopyColor(PIXEL.Colors.Transparent)
	self.BackgroundHoverCol = ColorAlpha(PIXEL.Colors.Scroller, 80)
end

function PANEL:Paint(w, h)
	local textCol = PIXEL.Colors.SecondaryText
	local backgroundCol = PIXEL.Colors.Transparent

	if self:IsHovered() then
		textCol = PIXEL.Colors.PrimaryText
		backgroundCol = self.BackgroundHoverCol
	end

	if self:IsDown() or self:GetToggle() then
		textCol = PIXEL.Colors.PrimaryText
		backgroundCol = self.BackgroundHoverCol
	end

	local animTime = FrameTime() * 12
	self.TextCol = PIXEL.LerpColor(animTime, self.TextCol, textCol)
	self.BackgroundCol = PIXEL.LerpColor(animTime, self.BackgroundCol, backgroundCol)

	if self:GetDrawOutline() then PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, 0, w, h, self.BackgroundCol, PIXEL.Scale(1)) end

	local imageURL = self:GetImageURL()
	if imageURL then
		local iconSize = h * .65
		PIXEL.DrawImage(PIXEL.Scale(10), (h - iconSize) / 2, iconSize, iconSize, imageURL, self.TextCol)
		PIXEL.DrawSimpleText(self:GetName(), "SidebarItem", PIXEL.Scale(20) + iconSize, h / 2, self.TextCol, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		return
	end

	PIXEL.DrawSimpleText(self:GetName(), "SidebarItem", PIXEL.Scale(10), h / 2, self.TextCol, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
end

vgui.Register("PIXEL.SidebarItem", PANEL, "PIXEL.Button")

PANEL = {}

AccessorFunc(PANEL, "ImageURL", "ImageURL", FORCE_STRING)
AccessorFunc(PANEL, "ImageScale", "ImageScale", FORCE_NUMBER)
AccessorFunc(PANEL, "ImageOffset", "ImageOffset", FORCE_NUMBER)
AccessorFunc(PANEL, "ButtonOffset", "ButtonOffset", FORCE_NUMBER)

AccessorFunc(PANEL, "ImgurID", "ImgurID", FORCE_STRING) -- Deprecated
AccessorFunc(PANEL, "ImgurScale", "ImgurScale", FORCE_NUMBER) -- Deprecated
AccessorFunc(PANEL, "ImgurOffset", "ImgurOffset", FORCE_NUMBER) -- Deprecated

function PANEL:SetImgurID(id)
	self:SetImageURL("https://i.imgur.com/" .. id .. ".png")
	self.ImgurID = id
end

function PANEL:GetImgurID()
	return self:GetImageURL():match("https://i.imgur.com/(.-).png")
end

function PANEL:SetImgurScale(scale)
	self:SetImageScale(scale)
	self.ImgurScale = scale
end

function PANEL:GetImgurScale()
	return self:GetImageScale()
end

function PANEL:SetImgurOffset(offset)
	self:SetImageOffset(offset)
	self.ImgurOffset = offset
end

function PANEL:GetImgurOffset()
	return self:GetImageOffset()
end

function PANEL:Init()
	self.Items = {}

	self.Scroller = vgui.Create("PIXEL.ScrollPanel", self)
	self.Scroller:SetBarDockShouldOffset(true)
	self.Scroller.LayoutContent = function(s, w, h)
		local spacing = PIXEL.Scale(8)
		local height = PIXEL.Scale(35)
		for k,v in pairs(self.Items) do
			v:SetTall(height)
			v:Dock(TOP)
			v:DockMargin(0, 0, 0, spacing)
		end
	end

	self:SetImageScale(.6)
	self:SetImageOffset(0)
	self:SetButtonOffset(0)

	self.BackgroundCol = PIXEL.CopyColor(PIXEL.Colors.Header)
end

function PANEL:AddItem(id, name, imageURL, doClick, order)
	local btn = vgui.Create("PIXEL.SidebarItem", self.Scroller)

	btn:SetZPos(order or table.Count(self.Items) + 1)
	btn:SetName(name)
	if imageURL then
		local imgurMatch = (imageURL or ""):match("^[a-zA-Z0-9]+$")
		if imgurMatch then
			imageURL = "https://i.imgur.com/" .. imageURL .. ".png"
		end

		btn:SetImageURL(imageURL)
	end
	btn.Function = doClick

	btn.DoClick = function(s)
		self:SelectItem(id)
	end

	self.Items[id] = btn

	return btn
end

function PANEL:RemoveItem(id)
	local item = self.Items[id]
	if not item then return end

	item:Remove()
	self.Items[id] = nil

	if self.SelectedItem != id then return end
	self:SelectItem(next(self.Items))
end

function PANEL:SelectItem(id)
	local item = self.Items[id]
	if not item then return end

	if self.SelectedItem and self.SelectedItem == id then return end
	self.SelectedItem = id

	for k,v in pairs(self.Items) do
		v:SetToggle(false)
	end

	item:SetToggle(true)
	item.Function(item)
end

function PANEL:PerformLayout(w, h)
	local sideSpacing = PIXEL.Scale(7)
	local topSpacing = PIXEL.Scale(7)
	self:DockPadding(sideSpacing, self:GetImageURL() and w * self:GetImageScale() + self:GetImageOffset() + self:GetButtonOffset() + topSpacing * 2 or topSpacing, sideSpacing, topSpacing)

	self.Scroller:Dock(FILL)
	self.Scroller:GetCanvas():DockPadding(0, 0, self.Scroller.VBar.Enabled and sideSpacing or 0, 0)
end

function PANEL:Paint(w, h)
	PIXEL.DrawRoundedBoxEx(PIXEL.Scale(6), 0, 0, w, h, self.BackgroundCol, false, false, true)

	local imageURL = self:GetImageURL()
	if imageURL then
		local imageSize = w * self:GetImageScale()
		PIXEL.DrawImage((w - imageSize) / 2, self:GetImageOffset() + PIXEL.Scale(15), imageSize, imageSize, imageURL, color_white)
	end
end

vgui.Register("PIXEL.Sidebar", PANEL, "Panel")
--PATH lua/pixelui/elements/cl_validated_text_entry.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_validated_text_entry.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

function PANEL:Init()
    self.TextEntry = vgui.Create("PIXEL.TextEntry", self)
    self.Message = vgui.Create("PIXEL.Label", self)
    self.Message:SetText("")

    self.TextEntry.OnChange = function(s)
        local text = s:GetValue()
        if text == "" then
            self.Message:SetText("")
            s.OverrideCol = nil
            return
        end

        local valid, message = self:IsTextValid(text)

        self:OnValidate(valid, message)

        if valid then
            self.Message:SetText(message or "")
            self.Message:SetTextColor(PIXEL.Colors.Positive)

            s.OverrideCol = PIXEL.Colors.Positive
        else
            self.Message:SetText(message or "")
            self.Message:SetTextColor(PIXEL.Colors.Negative)

            s.OverrideCol = PIXEL.Colors.Negative
        end
    end
end

function PANEL:IsTextValid(text)
    if text == "test" then
        return true
    end

    return false, "This is invalid text lol"
end

function PANEL:OnValidate(valid, message) end

function PANEL:PerformLayout(w, h)
    self.TextEntry:SetTall(PIXEL.Scale(34))
    self.TextEntry:Dock(TOP)

    self.Message:Dock(TOP)
    self.Message:DockMargin(PIXEL.Scale(4), PIXEL.Scale(5), 0, 0)

    self:SizeToChildren(false, true)
end

function PANEL:SetValue(text) self.TextEntry:SetValue(text) end
function PANEL:GetValue() return self.TextEntry:GetValue() end

function PANEL:SetPlaceholderText(text) self.TextEntry:SetPlaceholderText(text) end
function PANEL:GetPlaceholderText() return self.TextEntry:GetPlaceholderText() end

vgui.Register("PIXEL.ValidatedTextEntry", PANEL, "Panel")
--PATH lua/autorun/sh_tx-2112-smokescreens-config.lua:
hook.Add("LoadSmokeScreenConfiguration", "UnitysSmokeScreens.SetupTX2112SmokeScreenConfiguration", function ()
    USS:RegisterSmokeScreenVehicleConfiguration("unitys-lvs-tx-2112",
            {
                {
                    pos = Vector(28,27,-30),
                    dir = USS.CONST.DIR_UP_FORWARD,
                    dirMulti = 500,
                },
                {
                    pos = Vector(-28,27,-30),
                    dir = USS.CONST.DIR_UP_FORWARD,
                    dirMulti = 500,
                },
                {
                    pos = Vector(28,27,-29),
                    dir = USS.CONST.DIR_UP_FORWARD_22R,
                    dirMulti = 500,
                },
                {
                    pos = Vector(-28,27,-29),
                    dir = USS.CONST.DIR_UP_FORWARD_22L,
                    dirMulti = 500,
                },
                {
                    pos = Vector(28,27,-18),
                    dir = USS.CONST.DIR_UP_FORWARD_45R,
                    dirMulti = 500,
                },
                {
                    pos = Vector(-28,27,-18),
                    dir = USS.CONST.DIR_UP_FORWARD_45L,
                    dirMulti = 500,
                },
            },
            2,
            nil,
            "turret"
    )
end)

--PATH lua/autorun/sh_unitys_smokescreens.lua:
USS = USS or {}

USS.IsSmokeScreenVehicleConfigurationInitialized = false
--- This table contains configuration for vehicles that require a smoke screen setup
USS.SmokeScreenVehicleConfigurations = {}

function USS:RegisterSmokeScreenVehicleConfiguration(class, ejectPositions, seat, totalSmokes, parent)
    class = string.Trim(class or "")

    if (class == "") then error("Invalid Smokescreen Vehicle Configuration: No vehicle class") end
    if (not istable(ejectPositions)) then error("Invalid Smokescreen Vehicle Configuration: No eject positions") end

    USS.SmokeScreenVehicleConfigurations[class] = {
        seat = seat or 1,
        totalSmokes = totalSmokes or 8,
        ejectPositions = ejectPositions,
        parent = parent
    }
end

local function CreateSmoke(ent, smokeTable, oPos, oAng)
    local pos = LocalToWorld(smokeTable.pos, Angle(), oPos, oAng)
    local dir = isfunction(smokeTable.dir) and smokeTable.dir(ent) or Vector()
    local dirMulti = smokeTable.dirMulti or 1

    debugoverlay.Cross(pos, 5, 10, Color(0,200,0), true)
    local veh = ent:GetVehicle()
    local projectile = ents.Create("unity_smoke")
    projectile:SetPos(pos)
    projectile:SetAngles(Angle())
    projectile:Spawn()
    projectile:Activate()
    projectile:SetEntityFilter(ent:GetCrosshairFilterEnts())
    local offsetDir = Vector(dir)
    offsetDir:Rotate(Angle(0,90,0))
    projectile:GetPhysicsObject():SetVelocity(veh:GetVelocity() + veh:GetRight() + dir * dirMulti)
end

local function CreateSmokeScreenWeapon(veh, configuration)
    local ejectPositions = configuration.ejectPositions
    local smokes = configuration.totalSmokes
    local parent = configuration.parent

    if (SERVER) then
        veh.SNDSmokeScreen = veh:AddSoundEmitter(Vector(0,0,0), "unitys_smokescreens/deploy_ext.mp3", "unitys_smokescreens/deploy_ext.mp3")
        veh.SNDSmokeScreen:SetSoundLevel(110)
    end

    local smokeScreenSystem = {}
    smokeScreenSystem.Icon = Material("unitys_smokescreens/wpn-smokescreen.png")
    smokeScreenSystem.Ammo = smokes * #ejectPositions
    smokeScreenSystem.Delay = 2
    smokeScreenSystem.HeatRateUp = 0
    smokeScreenSystem.HeatRateDown = 0
    smokeScreenSystem.UseableByAI = false
    smokeScreenSystem.Attack = function(ent)

        if (not IsValid(ent:GetVehicle())) then return end
        local vehicle = ent:GetVehicle()

        if isfunction(vehicle.GetDisabled) and vehicle:GetDisabled() then return end

        local oPos, oAng = ent:GetPos(), ent:GetAngles()
        if parent then
            local turretId = vehicle:LookupBone("turret")
            oPos, oAng = vehicle:GetBonePosition(turretId)
        end

        local i = 1
        timer.Create("timer_smokes" .. tostring(ent) .. math.random(0,10000), 0.1, #ejectPositions, function ()
            if (IsValid(vehicle)) then
                local v = ejectPositions[i]
                CreateSmoke(ent, v, oPos, oAng)
                vehicle.SNDSmokeScreen:PlayOnce(100 + math.Rand(-3,3), 1)
                ent:TakeAmmo()
                i = i + 1
            end
        end)
    end
    smokeScreenSystem.OnSelect = function(ent )
        ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
    end
    smokeScreenSystem.OnOverheat = function(ent )
        ent:EmitSound("lvs/overheat.wav")
    end
    veh.SmokeScreenSystem = smokeScreenSystem

    return smokeScreenSystem
end

local function GetVehicleConfiguration(class)
    if (not USS.IsSmokeScreenVehicleConfigurationInitialized) then hook.Run("LoadSmokeScreenConfiguration", USS) end

    return USS.SmokeScreenVehicleConfigurations[class]
end

hook.Add("PreRegisterSENT", "UnitysSmokeScreens.SetupSmokeScreenWeapons", function (ent, class)
    local configuration = GetVehicleConfiguration(class)
    if (not configuration) then return end

    ent.OldInitWeapons = ent.InitWeapons

    ent.InitWeapons = function (self)
        if (isfunction(ent.OldInitWeapons)) then
            self:OldInitWeapons()
        end

        local wep = CreateSmokeScreenWeapon(self, configuration)

        if isfunction(self.ModifySmokes) then
            self:ModifySmokes(wep)
        end

        self:AddWeapon(wep, configuration.seat)
    end
end)

USS.CONST = {}
USS.CONST.DIR_FORWARDS = function (veh) return veh:GetAimVector() end
USS.CONST.DIR_BACKWARDS = function (veh) return veh:GetAimVector() * -1 end
USS.CONST.DIR_RIGHT = function (veh) return veh:GetAimVector():Angle():Right() end
USS.CONST.DIR_LEFT = function (veh) return veh:GetAimVector():Angle():Right() * -1 end

USS.CONST.DIR_UP_FORWARD = function (veh) return veh:GetAimVector() + veh:GetAimVector():Angle():Up() * 2 end
USS.CONST.DIR_UP_FORWARD_22R = function (veh) return veh:GetAimVector() * 0.75 + veh:GetAimVector():Angle():Up() * 2 + veh:GetAimVector():Angle():Right() * 0.25 end
USS.CONST.DIR_UP_FORWARD_22L = function (veh) return veh:GetAimVector() * 0.75 + veh:GetAimVector():Angle():Up() * 2 + veh:GetAimVector():Angle():Right() * -0.25 end
USS.CONST.DIR_UP_FORWARD_45R = function (veh) return veh:GetAimVector() * 0.5 + veh:GetAimVector():Angle():Up() * 2 + veh:GetAimVector():Angle():Right() * 0.5 end
USS.CONST.DIR_UP_FORWARD_45L = function (veh) return veh:GetAimVector() * 0.5 + veh:GetAimVector():Angle():Up() * 2 + veh:GetAimVector():Angle():Right() * -0.5 end
USS.CONST.DIR_UP_FORWARD_67R = function (veh) return veh:GetAimVector() * 0.25 + veh:GetAimVector():Angle():Up() * 2 + veh:GetAimVector():Angle():Right() * 0.75 end
USS.CONST.DIR_UP_FORWARD_67L = function (veh) return veh:GetAimVector() * 0.25 + veh:GetAimVector():Angle():Up() * 2 + veh:GetAimVector():Angle():Right() * -0.75 end

USS.CONST.FORWARDS = function (veh) return veh:GetForward() end
USS.CONST.BACKWARDS = function (veh) return veh:GetForward() * -1 end
USS.CONST.RIGHT = function (veh) return veh:GetRight() end
USS.CONST.LEFT = function (veh) return veh:GetRight() * -1 end

USS.CONST.UP_FORWARD = function (veh) return veh:GetForward() + veh:GetUp() * 2 end
USS.CONST.UP_FORWARD_22R = function (veh) return veh:GetForward() * 0.75 + veh:GetUp() * 2 + veh:GetRight() * 0.25 end
USS.CONST.UP_FORWARD_22L = function (veh) return veh:GetForward() * 0.75 + veh:GetUp() * 2 + veh:GetRight() * -0.25 end
USS.CONST.UP_FORWARD_45R = function (veh) return veh:GetForward() * 0.5 + veh:GetUp() * 2 + veh:GetRight() * 0.5 end
USS.CONST.UP_FORWARD_45L = function (veh) return veh:GetForward() * 0.5 + veh:GetUp() * 2 + veh:GetRight() * -0.5 end
USS.CONST.UP_FORWARD_67R = function (veh) return veh:GetForward() * 0.25 + veh:GetUp() * 2 + veh:GetRight() * 0.75 end
USS.CONST.UP_FORWARD_67L = function (veh) return veh:GetForward() * 0.25 + veh:GetUp() * 2 + veh:GetRight() * -0.75 end


--PATH lua/slib/vgui/cl_scollapsiblepanel.lua:
return gluapack()()
--PATH lua/slib/vgui/cl_slistview.lua:
local PANEL = {}

local font = slib.createFont("Roboto", 15)
local textcolor, maincolor_7, linecol, neutralcolor, margin = slib.getTheme("textcolor"), slib.getTheme("maincolor", 7), Color(24,24,24,160), slib.getTheme("neutralcolor"), slib.getTheme("margin")

function PANEL:Init()
    self.Columns = self.Columns or {}
    self.Lines = self.Lines or {}

    self.columniteration = 0
    self.lineiteration = 0
    
    self.assortment = self.assortment or {}

    slib.wrapFunction(self, "Dock", nil, function() return self end, true)
    slib.wrapFunction(self, "SetSize", nil, function() return self end, true)
	slib.wrapFunction(self, "Center", nil, function() return self end, true)
	slib.wrapFunction(self, "SetPos", nil, function() return self end, true)
	slib.wrapFunction(self, "MakePopup", nil, function() return self end, true)
end

function PANEL:getColumnPos(col)
    local result = self.Columns[col]:GetPos()
    return select(1, result)
end

function PANEL:getColumnWide(col)
    return self.Columns[col]:GetWide()
end

local function differenciate(a, b)
    if isfunction(a) then a = a() end
    if isfunction(b) then b = b() end
    if isnumber(tonumber(a)) and isnumber(tonumber(b)) then return tonumber(a), tonumber(b) end

    if !(isstring(a) == isstring(b)) or isbool(a) or isbool(b) then
        return tostring(a), tostring(b)
    end

    return a, b
end

function PANEL:addColumn(name)
    if !IsValid(self.topbar) then
        self.topbar = vgui.Create("EditablePanel", self)
        self.topbar:Dock(TOP)
        self.topbar:SetZPos(-32768)
        self.topbar:SetTall(slib.getScaledSize(25, "y"))

        self.topbar.Paint = function(s,w,h)
            surface.SetDrawColor(maincolor_7)
            surface.DrawRect(0, 0, w, h)

            surface.SetDrawColor(linecol)
            surface.DrawRect(0, h - 1, w - 1, 1)
        end
    end

    self.columniteration = self.columniteration + 1

    local iteration = self.columniteration
    local ignoreWidth = false


    if istable(name) then
        if name[2] then
            ignoreWidth = name[2]
        end
        name = name[1]
    end

    self.Columns[iteration] = vgui.Create("DButton", self.topbar)
    self.Columns[iteration]:Dock(LEFT)
    self.Columns[iteration]:SetWide(self:GetWide() / #self.Columns)
    self.Columns[iteration].Width = self:GetWide() / #self.Columns
    self.Columns[iteration]:SetText("")
    self.Columns[iteration].name = name
    self.Columns[iteration].iteration = iteration
    self.Columns[iteration].ignoreWidth = ignoreWidth

    self.Columns[iteration].DoClick = function()
        if self.assortment.iteration == iteration then
            self.assortment.ascending = !self.assortment.ascending
        else
            self.assortment.iteration = iteration
            self.assortment.ascending = true
        end
        
        local basictable = {}
        local cleantable = {}

        for i=1,#self.Lines do
            local tbl = self.Columns[iteration]["lines"][i]
            local sortvalue = istable(tbl) and (tbl.sortvalue or tbl.text) or tbl

            table.insert(basictable, sortvalue)
        end
        
        if self.assortment.ascending then
            table.sort(basictable, function(a, b) a, b = differenciate(a, b) return a > b end)
        else
            table.sort(basictable, function(a, b) a, b = differenciate(a, b) return a < b end)
        end

        for i, z in pairs(basictable) do
            cleantable[z] = i
        end
        
        for i=1,#self.Lines do
            local tbl = self.Columns[iteration]["lines"][i]
            local final = istable(tbl) and (tbl.sortvalue or tbl.text) or tbl

            if !IsValid(self.Lines[i]) then continue end

            self.Lines[i]:SetZPos(cleantable[final])
        end
    end

    self.Columns[iteration].Paint = function(s,w,h)
        draw.SimpleText(name, font, slib.getTheme("margin"), h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    return self
end

function PANEL:addColumns(...)
    local args = {...}

    for k,v in pairs(args) do
        self:addColumn(v)
    end

    return self
end

function PANEL:addLine(...)
    local args = {...}
    if !IsValid(self.frame) then
        self.frame = vgui.Create("SScrollPanel", self)
        self.frame:Dock(FILL)
        self.frame:SetTall(slib.getScaledSize(25, "y"))
    end

    self.lineiteration = self.lineiteration + 1

    local iteration = self.lineiteration

    for k,v in ipairs(args) do
        local display = istable(v) and v[1] or v
        local sortingvalue

        if istable(v) and v[2] then
            sortingvalue = v[2]
        end

        self.Columns[k]["lines"] = self.Columns[k]["lines"] or {}
        self.Columns[k]["lines"][iteration] = self.Columns[k]["lines"][iteration] or {}
        
        self.Columns[k]["lines"][iteration]["text"] = display
        
        if sortingvalue then
            self.Columns[k]["lines"][iteration]["sortvalue"] = sortingvalue
        end
    end

    self.Lines[iteration] = vgui.Create("DButton", self)
    self.Lines[iteration]:Dock(TOP)
    self.Lines[iteration]:SetTall(slib.getScaledSize(25, "y"))
    self.Lines[iteration]:SetText("")
    self.Lines[iteration].InitDoClick = self.Lines[iteration].DoClick

    self.Lines[iteration].Think = function()
        self.Lines[iteration]:SetMouseInputEnabled(self.Lines[iteration].DoClick ~= self.Lines[iteration].InitDoClick)
    end

    self.Lines[iteration].Paint = function(s,w,h)
        local wantedcolor = neutralcolor

        if !s:IsHovered() then
            wantedcolor = table.Copy(wantedcolor)
            wantedcolor.a = 0
        end
        
        surface.SetDrawColor(slib.lerpColor(s, wantedcolor))
        surface.DrawRect(0, 0, w, h)
        
        for i = 1,#self.Columns do
            local display = self.Columns[i]["lines"][iteration].text

            if isfunction(display) then
                display = display()
            end

            local x,y = self:getColumnPos(i), h * .5
            local w = self:getColumnWide(i)

            if w < (self:getTextWidth(display, self.Columns[i].maxTxtLen) + margin * 2) then self:resizeColumns() end
            if i == 1 then
                s.name = display
            end

            if self.Columns[i].ignoreWidth or self.Columns[i].maxTxtLen then
                surface.SetFont(font)
                local txt_h = select(2, surface.GetTextSize(display))
                local screen_x, screen_y = s:LocalToScreen(0,0)

                render.SetScissorRect(screen_x + x, screen_y, screen_x + x + self.Columns[i]:GetWide() - margin, screen_y + h, true)
                draw.SimpleText(display, font, x + slib.getTheme("margin"), y, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
                render.SetScissorRect(0, 0, 0, 0, false)
            else

                if self.Columns[i].customRender and self.Columns[i].customRender(x, 0, w, h, s) == true then return end

                draw.SimpleText(display, font, x + slib.getTheme("margin"), y, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
            end
        end
    end

    self:resizeColumns()

    return self, self.Lines[iteration]
end

function PANEL:getTextWidth(txt, max)
    txt = tostring(txt)

    if max then
        txt = string.sub(txt, 1, max)
    end

    surface.SetFont(font)

    return surface.GetTextSize(txt)
end

function PANEL:resizeColumns()
    local columnsizes = {}
    local fullwidth = self:GetWide()
    local spaceleft = 0

    for k, v in pairs(self.Columns) do
        local ignoreWidth = self.Columns[k].ignoreWidth
        surface.SetFont(font)

        local longest = self:getTextWidth(self.Columns[k].name)
        if ignoreWidth then columnsizes[k] = isstring(ignoreWidth) and self:getTextWidth(ignoreWidth) or longest continue end
        if !self.Columns[k]["lines"] then continue end
        for i, z in pairs(self.Columns[k]["lines"]) do
            local compare = isfunction(z.text) and z.text() or z.text
            local width = self:getTextWidth(compare, self.Columns[k].maxTxtLen) + (slib.getTheme("margin") * 10)
            if longest < width then longest = width end
        end

        columnsizes[k] = longest
    end

    local occupiedspace = 0
    for k,v in pairs(columnsizes) do
        occupiedspace = occupiedspace + v
    end

    for k,v in pairs(self.Columns) do
        local v = columnsizes[k] or 0

        local gapadd = (fullwidth - occupiedspace) / #self.Columns
        self.Columns[k]:SetWide(v + gapadd)
    end
end

function PANEL:OnSizeChanged()
    self:resizeColumns()
end

function PANEL:PaintOver(w,h)
    for k,v in pairs(self.Columns) do
        if k >= #self.Columns then break end
        local x,y = self:getColumnPos(k), h * .5
        local w = self:getColumnWide(k)
        surface.SetDrawColor(linecol)
        surface.DrawRect(x + w - 1, 0, 1, h)
    end
end

vgui.Register("SListView", PANEL, "SScrollPanel")
--PATH lua/slib/vgui/cl_spopupbox.lua:
local PANEL = {}

local font = slib.createFont("Roboto", 13)
local textcolor, textcolor_min10, margin, maincolor_10 = slib.getTheme("textcolor"), slib.getTheme("textcolor", -10), slib.getTheme("margin"), slib.getTheme("maincolor", 10)

function PANEL:Init()
    self:SetSize(slib.getScaledSize(260, "x"), self.topbarheight)
    self:Center()
    self:addCloseButton()
    self.frame:DockPadding(0,margin,0,0)

    self.bgcloser = vgui.Create("SButton")
    self.bgcloser:Dock(FILL)
    self.bgcloser:MakePopup()
    self.bgcloser.Paint = function() end
    self.bgcloser.DoClick = function()
        self:Remove()
    end

    local buttonsH = slib.getScaledSize(25, "y")
    self.choises = vgui.Create("EditablePanel", self.frame)
    self.choises:Dock(BOTTOM)
    self.choises:SetTall(slib.getScaledSize(25, "y"))
    self.choises:DockMargin(0,0,0,margin)
    self.choises:DockPadding(margin,0,margin,0)

    self.choises.ResizeChilds = function()
        local childs = self.choises:GetChildren()
        local count = table.Count(childs)
        local width = self.choises:GetWide()

        for k,v in pairs(childs) do
            v:SetWide(math.Clamp(width / count, 0, width - (margin * 2)) + (count > 1 and k < 3 and -margin*1.5 or 0))
            if count > 1 then
                v:DockMargin(k > 1 and margin * .5 or 0,0,margin * .5,0)
            end
        end
    end

    self.choises.OnSizeChanged = self.choises.ResizeChilds

    self:MakePopup()

    local realh = self.frame:GetTall() - self.choises:GetTall() - margin
    self.frame.PaintOver = function(s,w,h)
        if self.parse then
            self.parse:Draw(w * .5, (h - buttonsH) * .5, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end
end

function PANEL:OnRemove()
    if IsValid(self.bgcloser) then self.bgcloser:Remove() end
end

function PANEL:setText(str)
    self.parse = markup.Parse("<colour="..textcolor_min10.r..","..textcolor_min10.g..","..textcolor_min10.b..","..textcolor_min10.a.."><font="..slib.createFont("Roboto", 16)..">"..str.."</font></colour>", self.frame:GetWide() - (margin * 2))
    local height = self.parse:GetHeight()

    self:SetTall(self:GetTall() + height + (margin * 6))

    return self
end

local inputTypes = {
    ["int"] = "STextEntry",
    ["dropdown"] = "SDropDown",
    ["text"] = "STextEntry"
}

function PANEL:addInput(type, placeholder)
    placeholder = placeholder or ""
    local element = vgui.Create(inputTypes[type], self.frame)
    element:Dock(TOP)
    element:DockMargin(margin, 0, margin, margin)
    element:SetTall(slib.getScaledSize(25, "y"))
    element.placeholder = placeholder
    element.bg = maincolor_10

    if type == "int" then
        element:SetNumeric(true)
        element:SetRefreshRate(0)
    end

    element:SetPlaceholder(placeholder)

    self:SetTall(self:GetTall() + element:GetTall() + margin)

    return element
end

function PANEL:addChoise(title, func)
    if !self.addedH then
        self:SetTall(self:GetTall() + self.choises:GetTall() + margin)
    end

    self.addedH = true

    local choise = vgui.Create("SButton", self.choises)
    choise:setTitle(title)
    choise:Dock(LEFT)
    choise:DockMargin(0,margin,0,0)
    choise:SetTall(slib.getScaledSize(25, "y"))
    choise.bg = slib.getTheme("maincolor", 5)

    choise.DoClick = function() if func then func() end self:Remove() end

    self.choises.ResizeChilds()

    return self
end

vgui.Register("SPopupBox", PANEL, "SFrame")
--PATH lua/slib/vgui/cl_stableviewer.lua:
local PANEL = {}

local font = slib.createFont("Roboto", 15)
local neutralcolor, textcolor, successcolor_100, failcolor_100, maincolor_5, maincolor_7, maincolor_10, maincolor_15 = slib.getTheme("neutralcolor"), slib.getTheme("textcolor"), slib.getTheme("successcolor", -100), slib.getTheme("failcolor", -100), slib.getTheme("maincolor", 5), slib.getTheme("maincolor", 7), slib.getTheme("maincolor", 10), slib.getTheme("maincolor", 15)

function PANEL:Init()
    self:SetSize(slib.getScaledSize(450, "x"), slib.getScaledSize(330, "y"))
    :Center()
    :MakePopup()
    :addCloseButton()
    :setTitle("Table Viewer", slib.createFont("Roboto", 17))
    :setBlur(true)

    self.entryheight = slib.getScaledSize(20, "y")
    
    self.viewbox = vgui.Create("EditablePanel", self.frame)
    self.viewbox:Dock(RIGHT)
    self.viewbox:SetWide(self.frame:GetWide())

    self.viewer = vgui.Create("SScrollPanel", self.viewbox)
    :Dock(FILL)
end

local function createButton(self, parent, str, val)
    local istbl = istable(val)
    local selparent = parent and parent or self.viewer

    local value = vgui.Create("SButton", selparent)
    :Dock(TOP)
    :SetZPos(-10)
    :SetTall(slib.getScaledSize(25, "y"))

    value.title = str
    value.tbl = istbl and val or parent.tbl

    value.Paint = function(s,w,h)
        local wantedcolor = selparent == self.suggestions and successcolor_100 or (value.toggleable and selparent.tbl[str] and successcolor_100 or failcolor_100)

        if !value.toggleable and (!s:IsHovered() or self.viewOnly) then
            wantedcolor = table.Copy(wantedcolor)
            wantedcolor.a = 0
        end
        
        surface.SetDrawColor(slib.lerpColor(s, wantedcolor))
        surface.DrawRect(0, 0, w, h)
        local display = ""

        if !istbl and (isstring(val) or isnumber(val)) then
            display = ": "..tostring(val)
        end
        
        draw.SimpleText(str..display, font, slib.getTheme("margin"), h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    value.Think = function()
        if !value.toggleable and self:getRule("toggleables", str) then
            value.toggleable = true
        end

        if value:IsHovered() and input.IsKeyDown(KEY_LSHIFT) and input.IsMouseDown(MOUSE_RIGHT) then
            value:DoClick()
        end
    end

    value.DoClick = function()
        if self.viewOnly then return end

        self.modified = true
        
        if selparent == self.suggestions then
            local edit = IsValid(self.selected) and self.selected or self.viewer

            if self.rules and self.rules.onlymodifytable and edit:GetName() == "SScrollPanel" then return end

            if self.customvalues then
                local popup = vgui.Create("SPopupBox")
                :setTitle(value.title)
                
                local entry = popup:addInput("text", self.customvalueplaceholder)

                if self.customnumeric then
                    entry:SetNumeric(true)
                end
                
                popup:addChoise(self.customvalues, function()
                    local val = entry:GetValue()
                    self:addValue(editTbl, value.title, val, edit)
                    edit.tbl[value.title] = val

                    if edit == self.viewer then
                        self:sortValues(self.viewer)
                    end
                end)

                return
            else
                edit.tbl[value.title] = true
                self:addValue(editTbl, value.title, true, edit)
            end
            
            if edit == self.viewer then
                self:sortValues(self.viewer)
            end
        else
            if value.toggleable then
                selparent.tbl[str] = !selparent.tbl[str]
            return end

            value:Remove()
        end

        selparent.tbl[str] = nil
    end

    return value
end

function PANEL:addValue(panel, str, val, parent)
    if istable(val) then
        local selpar = parent or panel
        parent = vgui.Create("EditablePanel", selpar)
        parent:Dock(TOP)
        parent:SetTall(slib.getScaledSize(25, "y"))
        parent:DockMargin(slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"))
        parent:DockPadding(0,slib.getScaledSize(25, "y"),0,0)
        parent.isTblContainer = true
        parent.tbl = val
        parent.title = str
        parent.OnSizeChanged = function(w,h)
            parent.top:SetWide(parent:GetWide())
        end

        parent.top = vgui.Create("SButton", parent)
        parent.top:SetSize(parent:GetWide(), slib.getScaledSize(25, "y"))

        parent.top.DoClick = function()
            if self.rules and self.rules.tableDeletable and !self:getRule("undeleteableTables", str)  then
                parent:Remove()
                selpar.tbl[str] = nil
                self.modified = true
            return end

            self.selected = self.selected ~= parent and parent or nil
        end

        parent.top.Paint = function(s,w,h)
            local wantedcolor = self.rules and self.rules.tableDeletable and !self:getRule("undeleteableTables", str) and failcolor_100 or neutralcolor
            
            surface.SetDrawColor(maincolor_7)
            surface.DrawRect(0, 0, w, h)

            surface.SetDrawColor(maincolor_5)
            surface.DrawRect(0,h-1,w,1)

            if self.rules and self.rules.tableDeletable and !self:getRule("undeleteableTables", str) then
                if !s:IsHovered() then
                    wantedcolor = table.Copy(wantedcolor)
                    wantedcolor.a = 0
                end
            elseif self.selected ~= parent then
                wantedcolor = table.Copy(wantedcolor)
                wantedcolor.a = 0
            end


            surface.SetDrawColor(slib.lerpColor(s, wantedcolor))
            surface.DrawRect(0, 0, w, h)

            draw.SimpleText(str, font, slib.getTheme("margin"), h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end

        parent.PaintOver = function(s, w, h)
            surface.SetDrawColor(maincolor_5)
            surface.DrawOutlinedRect(0, 0, w, h)
        end

        parent.OnChildAdded = function(child)
            local addheight = slib.getScaledSize(25, "y")
            parent:SetTall(parent:GetTall() + addheight)

            local grandparent = parent:GetParent()
            if !grandparent.isTblContainer then return end
            grandparent:SetTall(grandparent:GetTall() + addheight)
        end

        parent.OnChildRemoved = function(child)
            local addheight = slib.getScaledSize(25, "y")
            parent:SetTall(parent:GetTall() - addheight)

            local grandparent = parent:GetParent()
            if !grandparent.isTblContainer then return end
            grandparent:SetTall(grandparent:GetTall() - addheight)
        end
        
        if selpar ~= self.viewer then
            selpar:SetTall(selpar:GetTall() + (slib.getTheme("margin") * 2))
        end

        for k,v in pairs(val) do
            self:addValue(panel, k, v, parent)
        end
    return end

    return createButton(self, parent and parent or panel, str, val)
end

local function differenciate(a, b)
    if !(isstring(a) == isstring(b)) or isbool(a) or isbool(b) then
        return tostring(a), tostring(b)
    end

    return a, b
end

function PANEL:setCustomValues(bool, placeholder, numeric)
    self.customvalues = bool
    self.customvalueplaceholder = placeholder
    self.customnumeric = numeric

    return self
end

function PANEL:sortValues(panel)
    if !IsValid(panel) then return self end
    local basictable = {}
    local cleantable = {}

    for k,v in pairs(panel.tbl) do
        table.insert(basictable, k)
    end

    table.sort(basictable, function(a, b) local a, b = differenciate(a, b) return a < b end)
    
    for k,v in pairs(basictable) do
        cleantable[v] = k
    end

    for k, v in pairs(panel:GetCanvas():GetChildren()) do
        if !v.title then continue end
        v:SetZPos(cleantable[v.title])
    end

    return self
end

function PANEL:addSuggestions(tbl)
    if !tbl then return self end

    local wide, tall = self.frame:GetWide() * .5, self.frame:GetTall()
    self.viewer:SetPos(wide, 0)
    self.viewer:SetWide(wide)

    self.suggestionbox = vgui.Create("EditablePanel", self.frame)
    self.suggestionbox:Dock(LEFT)
    self.suggestionbox:SetWide(self.frame:GetWide() * .5)
    self.viewbox:SetWide(self.frame:GetWide() * .5)

    self.suggestions = vgui.Create("SScrollPanel", self.suggestionbox)
    self.suggestions:Dock(FILL)
    self.suggestions.tbl = tbl
    self.suggestions.hidden = {}

    self.suggestions.PaintOver = function(s,w,h)
        surface.SetDrawColor(maincolor_10)
        surface.DrawRect(w - 1, 0, 1, h)
    end

    self.suggestions.Think = function()
        local edit = IsValid(self.selected) and self.selected or self.viewer
        for k, value in pairs(self.suggestions:GetCanvas():GetChildren()) do
            if value:IsVisible() ~= !edit.tbl[value.title] and !value.searchHidden then
                value:SetVisible(!edit.tbl[value.title])
                self.suggestions:GetCanvas():InvalidateLayout(true)
            end
        end
    end

    for k,v in pairs(tbl) do
        self:addValue(self.suggestions, k, v)
    end

    return self
end

function PANEL:setOnlyModifyTable(bool)
    self.rules = self.rules or {}
    self.rules.onlymodifytable = bool
end

function PANEL:setToggleable(module, name, string)
    self.rules = self.rules or {}
    self.rules[module] = self.rules[module] or {}
    self.rules[module][name] = self.rules[module][name] or {}
    self.rules[module][name].toggleables = self.rules[module][name].toggleables or {}

    self.rules[module][name].toggleables[string] = true
end

function PANEL:setTableDeletable(bool)
    self.rules = self.rules or {}
    self.rules.tableDeletable = bool
end

function PANEL:setundeleteableTable(module, name, string)
    self.rules = self.rules or {}
    self.rules[module] = self.rules[module] or {}
    self.rules[module][name] = self.rules[module][name] or {}
    self.rules[module][name].undeleteableTables = self.rules[module][name].undeleteableTables or {}

    self.rules[module][name].undeleteableTables[string] = true
end

function PANEL:setAddRules(rule)
    self.rules = self.rules or {}
    self.rules.addRules = rule
end

function PANEL:getRule(type, str)
    local returnval = false

    if self.rules and self.rules[self.modulename] and self.rules[self.modulename][self.name] and self.rules[self.modulename][self.name][type] and self.rules[self.modulename][self.name][type][str] then
        returnval = true
    end
    
    return returnval
end

function PANEL:setIdentifiers(module, name)
    self.modulename, self.name = module, name
end

function PANEL:setTable(tbl)
    if !tbl or !istable(tbl) then return self end
    self.viewer.tbl = tbl
    for k,v in pairs(tbl) do
        self:addValue(self.viewer, k, v)
    end

    return self
end

function PANEL:addSearch(panel, viewer)
    if !IsValid(panel) or !IsValid(viewer) then return self end
    panel.search = vgui.Create("SSearchBar", panel)
    :addIcon()
    :SetWide(panel:GetWide())
    :Dock(TOP)
    :DockMargin(0,0,0,0)

    panel.search.entry.onValueChange = function(newvalue)
        for k,v in pairs(viewer:GetCanvas():GetChildren()) do
            if !v.title then continue end

            v:SetVisible(string.find(string.lower(v.title), string.lower(newvalue)))

            if v:IsVisible() then
                v.searchHidden = nil
            else
                v.searchHidden = true
            end
        end

        viewer:GetCanvas():InvalidateLayout(true)
    end

    return self
end

function PANEL:addEntry()
    self.addEntryFrame = vgui.Create("EditablePanel", self.viewbox)
    self.addEntryFrame:Dock(BOTTOM)

    self.addEntryButton = vgui.Create("SButton", self.addEntryFrame)
    :Dock(RIGHT)
    :setTitle("Add")

    self.addEntryButton.accentheight = 1
    self.addEntryButton.bg = maincolor_10

    self.addEntryButton.DoClick = function()
        local key, edit = self.entry:GetValue(), (IsValid(self.selected) and self.selected or self.viewer)
        if !key or key == "" or edit.tbl[key] then return end
        if self.rules and self.rules.onlymodifytable and edit:GetName() == "SScrollPanel" then return end
        
        local val

        if self.rules and self.rules.addRules and edit:GetName() == "SScrollPanel" then
            val = table.Copy(self.rules.addRules)
        end

        if !val then val = key end

        local result = !istable(val) and true or val
        edit.tbl[key] = result

        self:addValue(edit, key, result, edit)
        self:sortValues(self.viewer)
        self.modified = true
        self.entry:SetValue("")
    end

    self.entry = vgui.Create("STextEntry", self.addEntryFrame)
    :Dock(FILL)
    :SetValue("")

    self.entry.bg = maincolor_10

    self.entry.placeholder = ""

    self.addEntryFrame:SetTall(self.entry:GetTall())
    self.addEntryButton:SetTall(self.entry:GetTall())

    return self
end

vgui.Register("STableViewer", PANEL, "SFrame")
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/sh_gprotect_baseconfig.lua:
------------------------------------------------------                                   
-- NO NOT TOUCH ANYTHING IN HERE!!!!!!!!!                                                  
------------------------------------------------------                  
                  
gProtect = gProtect or {}                        
gProtect.config = gProtect.config or {}
gProtect.config.modules = gProtect.config.modules or {}

gProtect.config.modules.general = {
	["blacklist"] = {                   
		["prop_physics"] = true,
		["prop_physics_multiplayer"] = true
	},
	["remDiscPlyEnt"] = 120,
	["remDiscPlyEntSpecific"] = {},
	["remOutOfBounds"] = 120,
	["remOutOfBoundsWhitelist"] = {},
	["protectedFrozenEnts"] = {
		["prop_physics"] = true,
		["prop_physics_multiplayer"] = true
	},
	["protectedFrozenGroup"] = COLLISION_GROUP_INTERACTIVE_DEBRIS
}

gProtect.config.modules.ghosting = {
	["enabled"] = true,
	["ghostColor"] = Color(66, 135, 40, 120),
	["antiObscuring"] = {["player"] = true},
	["obscureOffset"] = 10,
	["entities"] = {},
	["onPhysgun"] = true,
	["forceUnfrozen"] = false,
	["forceUnfrozenEntities"] = {["prop_physics"] = true},
	["useBlacklist"] = true,
	["enableMotion"] = false,
}

gProtect.config.modules.damage = {
	["enabled"] = true,
	["useBlacklist"] = true,
	["vehiclePlayerDamage"] = false,
	["blacklistedEntPlayerDamage"] = true,
	["worldPlayerDamage"] = true,
	["entities"] = {},
	["immortalEntities"] = {},
	["bypassGroups"] = {},
	["canDamageWorldEntities"] = {["*"] = true}
}

gProtect.config.modules.anticollide = {
	["enabled"] = true,
	["notifyStaff"] = true,
	["protectDarkRPEntities"] = 1,
	["DRPentitiesThreshold"] = 125,
	["DRPentitiesException"] = 1,
	["protectSpawnedEntities"] = 1,
	["entitiesThreshold"] = 75,
	["entitiesException"] = 1,
	["protectSpawnedProps"] = 3,
	["propsThreshold"] = 45,
	["propsException"] = 1,
	["playerPropAction"] = 4,
	["playerPropThreshold"] = 500,
	["specificEntities"] = {},
	["squaredPhysicsMaxSize"] = 0,
	["squaredPhysicsEnts"] = {}
}

gProtect.config.modules.spamprotection = {
	["enabled"] = true,
	["threshold"] = 3,
	["delay"] = 1,
	["action"] = 1,
	["notifyStaff"] = true,
	["protectProps"] = true,
	["protectEntities"] = true
}

gProtect.config.modules.spawnrestriction = {
	["enabled"] = true,

	["propSpawnPermission"] = {["*"] = true},
	["SENTSpawnPermission"] = {["owner"] = true, ["superadmin"] = true},
	["SWEPSpawnPermission"] = {["owner"] = true, ["superadmin"] = true},
	["vehicleSpawnPermission"] = {["owner"] = true, ["superadmin"] = true},
	["NPCSpawnPermission"] = {["owner"] = true, ["superadmin"] = true},
	["ragdollSpawnPermission"] = {["owner"] = true, ["superadmin"] = true},
	["effectSpawnPermission"] = {["owner"] = true, ["superadmin"] = true},
	["blockedEntities"] = {},
	["blockedModels"] = {},
	["blockedModelsisBlacklist"] = true,
	["blockedModelsVehicleBypass"] = true,
	["blockedEntitiesIsBlacklist"] = true,
	["bypassGroups"] = {["owner"] = true, ["superadmin"] = true},
	["maxPropModelComplexity"] = 10,
	["maxModelSize"] = 3000
}

gProtect.config.modules.toolgunsettings = {
	["enabled"] = true,            
	["targetWorld"] = {},
	["targetPlayerOwned"] =  {},     
	["targetPlayerOwnedProps"] = {},
	["targetVehiclePermission"] = {["superadmin"] = true},
	["restrictTools"] = {["rope"] = true},
	["groupToolRestrictions"] = {             
		["superadmin"] = {
			isBlacklist = true,
			list = {}
		}
	},
	["bypassGroups"] = {["owner"] = true, ["superadmin"] = true},
	["entityTargetability"] = {
		isBlacklist = true,
		list = {["sammyservers_textscreen"] = true, ["player"] = true},
	},
	["bypassTargetabilityTools"] = {["remover"] = true},
	["bypassTargetabilityGroups"] = {["owner"] = true, ["superadmin"] = true},
	["antiSpam"] = {}
}

gProtect.config.modules.physgunsettings = {                    
	["enabled"] = true,
	["targetWorld"] = {},
	["targetPlayerOwned"] = {},
	["targetPlayerOwnedProps"] = {},
	["targetPlayerOwnedPropsGroupLevel"] = {},
	["DisableReloadUnfreeze"] = true,          
	["PickupVehiclePermission"] = {["superadmin"] = true},
	["StopMotionOnDrop"] = true,
	["blockMultiplePhysgunning"] = true,
	["maxDropObstructs"] = 3,               
	["maxDropObstructsAction"] = 1,
	["preventPropClimbing"] = true,
	["preventPropClimbingThreshold"] = 5,
	["preventPropClimbingAction"] = 1,
	["blockedEntities"] = {},
	["bypassGroups"] = {}
}

gProtect.config.modules.gravitygunsettings = {                   
	["enabled"] = true,
	["targetWorld"] = {["*"] = true},
	["targetPlayerOwned"] = {["*"] = true},
	["targetPlayerOwnedProps"] = {["*"] = true},
	["DisableGravityGunPunting"] = true,
	["blockedEntities"] = {},
	["bypassGroups"] = {}
}

gProtect.config.modules.canpropertysettings = {
	["enabled"] = true,
	["targetWorld"] = {},
	["targetPlayerOwned"] = {},
	["targetPlayerOwnedProps"] = {},
	["blockedProperties"] = {},
	["blockedPropertiesisBlacklist"] = true,
	["blockedEntities"] = {},
	["bypassGroups"] = {["owner"] = true, ["superadmin"] = true}
}

gProtect.config.modules.canusesettings = {
	["enabled"] = true,
	["targetWorld"] = {["*"] = true},
	["targetPlayerOwned"] = {["*"] = true},
	["targetPlayerOwnedProps"] = {["*"] = true},
	["blockedEntities"] = {},
	["blockedEntitiesisBlacklist"] = true,
	["bypassGroups"] = {["owner"] = true, ["superadmin"] = true}
}

gProtect.config.modules.advdupe2 = {
	["enabled"] = true,
	["notifyStaff"] = true,
	["PreventRopes"] = 1,
	["PreventScaling"] = 1,
	["PreventNoGravity"] = 1,
	["PreventTrail"] = 1,
	["PreventUnreasonableValues"] = true,
	["PreventUnfreezeAll"] = true,
 	["BlacklistedCollisionGroups"] = {[COLLISION_GROUP_IN_VEHICLE] = true, [COLLISION_GROUP_PROJECTILE] = true},
	["WhitelistedConstraints"] = {
		["weld"] = true
	},
	["whitelistedClasses"] = {["gmod_button"] = true},
	["DelayBetweenUse"] = 2
}

gProtect.config.modules.miscs = {
	["enabled"] = true,
	["ClearDecals"] = 120,
	["blacklistedFadingDoorMats_punishment"] = 1,
	["blacklistedFadingDoorMats"] = {["pp/copy"] = true, ["dev/upscale"] = true},
	["FadingDoorLag"] = true,
	["DisableMotion"] = false,
	["DisableMotionEntities"] = {["prop_physics"] = true},
	["freezeOnSpawn"] = true,
	["preventFadingDoorAbuse"] = true,
	["precisionMoveFix"] = true,
	["preventSpawnNearbyPlayer"] = 10,
	["DRPEntForceOwnership"] = {},
	["DRPMaxObstructsOnPurchaseEnts"] = 3,
	["DRPObstructsFilter"] = 1
}

------------------------------------------------------           
-- NO NOT TOUCH ANYTHING IN HERE!!!!!!!!!                                                  
------------------------------------------------------76561198196280105
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/sh_gprotect_operators.lua:
gProtect = gProtect or {config = {}}
gProtect.config = gProtect.config or {}

gProtect.config.ModuleCoordination = {
	["general"] = -3,
	["ghosting"] = 2,
	["damage"] = 3,
	["anticollide"] = 4,
	["spamprotection"] = 5,
	["spawnrestriction"] = 6,
	["toolgunsettings"] = 7,
	["physgunsettings"] = 8,
	["gravitygunsettings"] = 9,
	["canpropertysettings"] = 10,
	["canusesettings"] = 11,
	["advdupe2"] = 12,
	["miscs"] = 13
}

gProtect.config.ModuleShouldDisplay = {
	["advdupe2"] = function()
		if !AdvDupe2 then return false end
	end,
}

gProtect.config.sortOrders = {
	["general"] = {
		["blacklist"] = 0,
		["remDiscPlyEnt"] = 2,
		["remDiscPlyEntSpecific"] = 3,
		["remOutOfBounds"] = 4,
		["remOutOfBoundsWhitelist"] = 5,
		["protectedFrozenEnts"] = 6,
		["protectedFrozenGroup"] = 7
	},

	["ghosting"] = {
		["enabled"] = 1,
		["ghostColor"] = 2,
		["antiObscuring"] = 3,
		["obscureOffset"] = 4,
		["onPhysgun"] = 5,
		["useBlacklist"] = 6,
		["entities"] = 7,
		["forceUnfrozen"] = 8,
		["forceUnfrozenEntities"] = 9,
		["enableMotion"] = 10
	},

	["damage"] = {
		["enabled"] = 1,
		["useBlacklist"] = 2,
		["entities"] = 3,
		["blacklistedEntPlayerDamage"] = 4,
		["vehiclePlayerDamage"] = 5,
		["worldPlayerDamage"] = 6,
		["immortalEntities"] = 7,
		["bypassGroups"] = 8,
		["canDamageWorldEntities"] = 9
	},

	["anticollide"] = {
		["enabled"] = 1,
		["notifyStaff"] = 2,
		["protectDarkRPEntities"] = 3,
		["DRPentitiesThreshold"] = 4,
		["DRPentitiesException"] = 5,
		["protectSpawnedEntities"] = 6,
		["entitiesThreshold"] = 7,
		["entitiesException"] = 8,
		["protectSpawnedProps"] = 9,
		["propsThreshold"] = 10,
		["propsException"] = 11,
		["playerPropAction"] = 12,
		["playerPropThreshold"] = 13,
		["useBlacklist"] = 14,
		["ghostEntities"] = 15,
		["specificEntities"] = 16,
		["squaredPhysicsMaxSize"] = 17,
		["squaredPhysicsEnts"] = 18
	},

	["spamprotection"] = {
		["enabled"] = 1,
		["threshold"] = 2,
		["delay"] = 3,
		["action"] = 4,
		["notifyStaff"] = 5,
		["protectProps"] = 6,
		["protectEntities"] = 7,
	},

	["spawnrestriction"] = {
		["enabled"] = 1,
		["propSpawnPermission"] = 2,
		["SENTSpawnPermission"] = 3,
		["SWEPSpawnPermission"] = 4,
		["vehicleSpawnPermission"] = 5,
		["NPCSpawnPermission"] = 6,
		["ragdollSpawnPermission"] = 7,
		["effectSpawnPermission"] = 8,
		["blockedEntities"] = 9,
		["blockedEntitiesIsBlacklist"] = 10,
		["blockedModels"] = 11,
		["blockedModelsisBlacklist"] = 12,
		["blockedModelsVehicleBypass"] = 13,
		["bypassGroups"] = 14,
		["maxPropModelComplexity"] = 15,
		["maxModelSize"] = 16
	},

	["toolgunsettings"] = {
		["enabled"] = 1,
		["targetWorld"] = 2,
		["targetPlayerOwned"] = 3,
		["targetPlayerOwnedProps"] = 4,
		["targetVehiclePermission"] = 5,
		["restrictTools"] = 6,
		["groupToolRestrictions"] = 7,
		["bypassGroups"] = 8,
		["entityTargetability"] = 9,
		["bypassTargetabilityTools"] = 10,
		["bypassTargetabilityGroups"] = 11,
		["antiSpam"] = 12
	},

	["physgunsettings"] = {
		["enabled"] = 1,
		["targetWorld"] = 2,
		["targetPlayerOwned"] = 3,
		["targetPlayerOwnedProps"] = 4,
		["targetPlayerOwnedPropsGroupLevel"] = 5,
		["DisableReloadUnfreeze"] = 6,
		["PickupVehiclePermission"] = 7,
		["StopMotionOnDrop"] = 8,
		["blockMultiplePhysgunning"] = 9,
		["maxDropObstructs"] = 10,
		["maxDropObstructsAction"] = 11,
		["preventPropClimbing"] = 12,
		["preventPropClimbingThreshold"] = 13,
		["preventPropClimbingAction"] = 14,
		["blockedEntities"] = 15,
		["bypassGroups"] = 16
	},

	["gravitygunsettings"] = {
		["enabled"] = 1,
		["targetWorld"] = 2,
		["targetPlayerOwned"] = 3,
		["targetPlayerOwnedProps"] = 4,
		["DisableGravityGunPunting"] = 5,
		["blockedEntities"] = 6,
		["bypassGroups"] = 7
	},

	["canpropertysettings"] = {
		["enabled"] = 1,
		["targetWorld"] = 2,
		["targetPlayerOwned"] = 3,
		["targetPlayerOwnedProps"] = 4,
		["blockedProperties"] = 5,
		["blockedPropertiesisBlacklist"] = 6,
		["blockedEntities"] = 7,
		["bypassGroups"] = 8
	},

	["canusesettings"] = {
		["enabled"] = 1,
		["targetWorld"] = 2,
		["targetPlayerOwned"] = 3,
		["targetPlayerOwnedProps"] = 4,
		["blockedEntities"] = 5,
		["blockedEntitiesisBlacklist"] = 6,
		["bypassGroups"] = 7
	},

	["advdupe2"] = {
		["enabled"] = 1,
		["notifyStaff"] = 2,
		["PreventRopes"] = 3,
		["PreventScaling"] = 4,
		["PreventNoGravity"] = 5,
		["PreventTrail"] = 6,
		["PreventUnreasonableValues"] = 7,
		["PreventUnfreezeAll"] = 8,
		["BlacklistedCollisionGroups"] = 9,
		["WhitelistedConstraints"] = 10,
		["whitelistedClasses"] = 11,
		["DelayBetweenUse"] = 12
	},

	["miscs"] = {
		["enabled"] = 1,
		["ClearDecals"] = 2,
		["blacklistedFadingDoorMats_punishment"] = 3,
		["blacklistedFadingDoorMats"] = 4,
		["FadingDoorLag"] = 5,
		["DisableReloadUnfreeze"] = 6,
		["DisableMotion"] = 7,
		["DisableMotionEntities"] = 8,
		["DisableGravityGunPunting"] = 9,
		["freezeOnSpawn"] = 10,
		["preventFadingDoorAbuse"] = 11,
		["precisionMoveFix"] = 12,
		["preventSpawnNearbyPlayer"] = 13,
		["DRPEntForceOwnership"] = 14,
		["DRPMaxObstructsOnPurchaseEnts"] = 15,
		["DRPObstructsFilter"] = 16
	}
}

local function getEntitiesList()
	local tbl = {
		["prop_physics"] = true,
		["prop_physics_multiplayer"] = true,
		["prop_vehicle_jeep"] = true
	}

	for k,v in pairs(scripted_ents.GetList()) do
		tbl[v.ClassName or k] = true
	end
	
	return tbl
end

local function getUsergroups()
	local tbl = {}

	if CAMI and CAMI.GetUsergroups then for k,v in pairs(CAMI.GetUsergroups()) do tbl[k] = true end end

	return tbl
end

local function getTools()
	local tbl = {}

	for k,v in pairs(spawnmenu.GetTools()) do
		for i,z in pairs(v.Items) do
			for key, data in pairs(z) do
				if istable(data) and data.ItemName then
					if data.ItemName ~= string.lower(data.ItemName) then continue end
					tbl[data.ItemName] = true
				end
			end
		end
	end
	
	return tbl
end

local function getProperties()
	local tbl = {
		["ignite"] = true,
		["remover"] = true,
		["collision"] = true
	}

	module( "properties", package.seeall )
	
	for k,v in pairs(List) do tbl[k] = true end

	return tbl
end

gProtect.config.valueRules = { --- This is because the tableviewer is modular and coded to be as efficient as possible hence its structure.76561198196280112
	["general"] = {
		["blacklist"] = {tableAlternatives = getEntitiesList},
		["notifyType"] = {intLimit = {min = 0, max = 2}},
		["remDiscPlyEnt"] = {intLimit = {min = -1, max = 999}},
		["remDiscPlyEntSpecific"] = {customTable = "int", tableAlternatives = getEntitiesList},
		["remOutOfBounds"] = {intLimit = {min = -1, max = 999}},
		["remOutOfBoundsWhitelist"] = {tableAlternatives = getEntitiesList},
		["protectedFrozenEnts"] = {tableAlternatives = getEntitiesList},
	},
	["ghosting"] = {
		["entities"] = {tableAlternatives = getEntitiesList},
		["forceUnfrozenEntities"] = {tableAlternatives = getEntitiesList},
		["antiObscuring"] = {tableAlternatives = getEntitiesList},
		["obscureOffset"] = {intLimit = {min = 0, max = 300}},
	},
	["damage"] = {
		["entities"] = {tableAlternatives = getEntitiesList},
		["immortalEntities"] = {tableAlternatives = getEntitiesList},
		["bypassGroups"] = {tableAlternatives = getUsergroups},
		["canDamageWorldEntities"] = {tableAlternatives = getUsergroups},
	},
	["anticollide"] = {
		["ghostEntities"] = {tableAlternatives = getEntitiesList},
		["threshold"] = {intLimit = {min = 0, max = 100000}},
		["delay"] = {intLimit = {min = 0, max = 30}},
		["action"] = {intLimit = {min = 1, max = 3}},
		["exception"] = {intLimit = {min = 0, max = 2}},
		["protectDarkRPEntities"] = {intLimit = {min = 0, max = 4}},
		["protectSpawnedEntities"] = {intLimit = {min = 0, max = 3}},
		["protectSpawnedProps"] = {intLimit = {min = 0, max = 4}},
		["specificEntities"] = {customTable = "int", tableAlternatives = getEntitiesList},
		["squaredPhysicsEnts"] = {tableAlternatives = getEntitiesList},
		["playerPropAction"] = {intLimit = {min = 0, max = 4}},
	},
	["spamprotection"] = {
		["threshold"] = {intLimit = {min = 0, max = 100000}},
		["delay"] = {intLimit = {min = 0, max = 30}},
		["action"] = {intLimit = {min = 0, max = 2}}
 	},
	["spawnrestriction"] = {
		["blockedEntities"] = {tableAlternatives = getEntitiesList},
		["bypassGroups"] = {tableAlternatives = getUsergroups},
		["propSpawnPermission"] = {tableAlternatives = getUsergroups},
		["SENTSpawnPermission"] = {tableAlternatives = getUsergroups},
		["SWEPSpawnPermission"] = {tableAlternatives = getUsergroups},
		["vehicleSpawnPermission"] = {tableAlternatives = getUsergroups},
		["NPCSpawnPermission"] = {tableAlternatives = getUsergroups},
		["ragdollSpawnPermission"] = {tableAlternatives = getUsergroups},
		["effectSpawnPermission"] = {tableAlternatives = getUsergroups},
		["maxPropModelComplexity"] = {intLimit = {min = 0, max = 100}},
		["maxModelSize"] = {intLimit = {min = 0, max = 100000}}
	},
	["toolgunsettings"] = {
		["restrictTools"] = {tableAlternatives = getTools},
		["groupToolRestrictions"] = {addRules = {list = {}, isBlacklist = true}, toggleableValue = "isBlacklist", tableDeletable = true, undeleteableTable = "list", tableAlternatives = getTools},
		["bypassGroups"] = {tableAlternatives = getUsergroups},
		["entityTargetability"] = {tableAlternatives = getEntitiesList, toggleableValue = "isBlacklist", onlymodifytable = true},
		["targetWorld"] = {tableAlternatives = getUsergroups},
		["targetPlayerOwned"] = {tableAlternatives = getUsergroups},
		["targetPlayerOwnedProps"] = {tableAlternatives = getUsergroups},
		["targetVehiclePermission"] = {tableAlternatives = getUsergroups},
		["blockedEntities"] = {tableAlternatives = getEntitiesList},
		["bypassTargetabilityTools"] = {tableAlternatives = getTools},
		["bypassTargetabilityGroups"] = {tableAlternatives = getUsergroups},
		["antiSpam"] = {customTable = "int", tableAlternatives = getTools},

	},
	["physgunsettings"] = {
		["targetWorld"] = {tableAlternatives = getUsergroups},
		["targetPlayerOwned"] = {tableAlternatives = getUsergroups},
		["targetPlayerOwnedProps"] = {tableAlternatives = getUsergroups},
		["targetPlayerOwnedPropsGroupLevel"] = {customTable = "int", tableAlternatives = getUsergroups},
		["maxDropObstructs"] = {intLimit = {min = 0, max = 10000}},
		["maxDropObstructsAction"] = {intLimit = {min = 1, max = 3}},
		["preventPropClimbingThreshold"] = {intLimit = {min = 1, max = 30}},
		["preventPropClimbingAction"] = {intLimit = {min = 1, max = 2}},
		["blockedEntities"] = {tableAlternatives = getEntitiesList},
		["bypassGroups"] = {tableAlternatives = getUsergroups},
		["PickupVehiclePermission"] = {tableAlternatives = getUsergroups}
	},
	["gravitygunsettings"] = {
		["targetWorld"] = {tableAlternatives = getUsergroups},
		["targetPlayerOwned"] = {tableAlternatives = getUsergroups},
		["targetPlayerOwnedProps"] = {tableAlternatives = getUsergroups},
		["blockedEntities"] = {tableAlternatives = getEntitiesList},
		["bypassGroups"] = {tableAlternatives = getUsergroups}
	},
	["canpropertysettings"] = {
		["blockedProperties"] = {tableAlternatives = getProperties},
		["targetWorld"] = {tableAlternatives = getUsergroups},
		["targetPlayerOwned"] = {tableAlternatives = getUsergroups},
		["targetPlayerOwnedProps"] = {tableAlternatives = getUsergroups},
		["bypassGroups"] = {tableAlternatives = getUsergroups},
		["blockedEntities"] = {tableAlternatives = getEntitiesList}
	},
	["canusesettings"] = {
		["targetWorld"] = {tableAlternatives = getUsergroups},
		["targetPlayerOwned"] = {tableAlternatives = getUsergroups},
		["targetPlayerOwnedProps"] = {tableAlternatives = getUsergroups},
		["blockedEntities"] = {tableAlternatives = getEntitiesList},
		["bypassGroups"] = {tableAlternatives = getUsergroups}
	},
	["advdupe2"] = {
		["WhitelistedConstraints"] = {tableAlternatives = {["weld"] = true, ["rope"] = true, ["axis"] = true, ["ballsocket"] = true, ["elastic"] = true, ["hydraulic"] = true, ["motor"] = true, ["muscle"] = true, ["pulley"] = true, ["slider"] = true, ["winch"] = true}},
		["PreventRopes"] = {intLimit = {min = 0, max = 2}},
		["PreventScaling"] = {intLimit = {min = 0, max = 2}},
		["PreventNoGravity"] =  {intLimit = {min = 0, max = 2}},
		["PreventTrail"] =  {intLimit = {min = 0, max = 2}},
		["whitelistedClasses"] = {tableAlternatives = getEntitiesList},
	},

	["miscs"] = {
		["ClearDecals"] = {intLimit = {min = 0, max = 1200}},
		["NoBlackoutGlitch"] = {intLimit = {min = 0, max = 3}},
		["DRPEntForceOwnership"] = {tableAlternatives = getEntitiesList},
		["DisableMotionEntities"] = {tableAlternatives = getEntitiesList},
	}
}
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/client/cl_overrides.lua:
local custom_for_all_tabs = CreateConVar( "wire_tool_menu_custom_menu_for_all_tabs", 0, {FCVAR_ARCHIVE} ) -- Wiremod Support

local updateToolMenu = function()
    if !gProtect.config.HideToolsInSpawnMenu then return end
    
    local lp = LocalPlayer()

    if !IsValid(lp) or !gProtect or !gProtect.LoadedModules or !gProtect.LoadedModules["toolgunsettings"] then return end

    local perms = gProtect.LoadedModules["toolgunsettings"]
    local usergroup = lp:GetUserGroup()
    local groupToolsRestrictions = perms["groupToolRestrictions"][usergroup]
    
    local wiremodCustomTabs = custom_for_all_tabs:GetBool()
    
    local toolMenu = g_SpawnMenu:GetToolMenu()
    local toolsTab = toolMenu.ToolPanels[1]
    local tabCanvas = toolsTab.List:GetChildren()[1]
    local wireTabCanvas = wiremodCustomTabs and tabCanvas:GetChildren()[1]:GetChildren()[4]

    for _, tab in ipairs((wireTabCanvas or tabCanvas):GetChildren()) do
        local visibleTabs = 0
        local wireTab = wiremodCustomTabs and tab:GetChildren()[3]

        if wireTab then tab = wireTab end

        for _, tool in ipairs(tab:GetChildren()) do
            if !tool.Name then continue end

            local blockedByGroups = groupToolsRestrictions and groupToolsRestrictions and groupToolsRestrictions.list and (groupToolsRestrictions.list[tool.Name] == (groupToolsRestrictions.isBlacklist or false))
            local isBlocked = (perms["restrictTools"][tool.Name] and !perms["bypassGroups"][usergroup]) or blockedByGroups

            tool:SetVisible(!isBlocked)

            if !isBlocked then
                visibleTabs = visibleTabs + 1
            end
        end

        if !wireTab then
            tab:SetVisible(visibleTabs > 0)
        else
            wireTab:GetParent():SetVisible(visibleTabs > 0)
            wireTab:InvalidateLayout(true)
        end

        tab:InvalidateLayout(true)
    end

    tabCanvas:InvalidateLayout(true)
end

hook.Add("gP:ConfigUpdated", "gP:FilterTools", function(moduleName)
    if moduleName == "toolgunsettings" then
        updateToolMenu()
    end
end)

hook.Add("OnSpawnMenuOpen", "gP:FilterTools", function()
    timer.Simple(0, function() updateToolMenu() end)
end)
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/languages/sh_russian.lua:
return gluapack()()
--PATH addons/[misc] smartspawnmanager/lua/autorun/smartspawn/sh_config.lua:
//
/*
	Smart Spawn Manager Configuration
	5/12/2018
	Author: Smart ( Badass Development )
*/

local config = {};

config.version 				= "1.0.9"; 			// What version of Smart Spawn Manger is this?
config.controlPanelCmd		= "!ss";			// What chat command do staff use to open the control panel?

config.fileDir				= "smartspawn";		// What directory do we store our data in?
config.configFileName		= "config.txt";		// What file do we store our config data in?
config.spawnsFileName		= "%s_spawns.txt";	// What file do we store our spawn data in?

config.staff				= {};				// What ULX usergroups are considered staff? (If you use ServerGuard ignore this)
config.staff["admin"]		= true;
config.staff["superadmin"]	= true;
config.staff["owner"]		= true;
config.staff["developer"]	= true;
config.staff["founder"]		= true;
config.staff["operator"]	= true;

config.toolRemoveSearchRadius	= 30;			// How far to search when trying to find a spawn point to remove (with the toolgun)
config.spawnRenderRadius		= 1500;			// How far away do we render spawnpoints? (source units)

// Language settings 
config.lang 				= {};
config.lang.menuTitle		= "Smart Spawn Manager";
config.lang.tab1Title		= "Config";
config.lang.tab2Title		= "Player";
config.lang.tab3Title		= "Entities";
config.lang.tab4Title		= "Categories";

config.lang.uniqueID		= "UniqueID: ";
config.lang.remove			= "Remove";

config.lang.removePlayer	= "Removed player spawn!";
config.lang.removeEntity	= "Removed entity spawn!";
config.lang.saved			= "All changes saved!";

config.lang.renderSpawns	= "Render spawns for staff";
config.lang.playerSpawns	= "Custom Player Spawns";
config.lang.entitySpawns	= "Custom Entity Spawns";
config.lang.overrideSpawns	= "Override Default Player Spawns";
config.lang.saveChanges		= "Save";

// END OF CONFIG 
smartspawn_config = config;
--PATH addons/[misc] sreward_1.6.31/lua/autorun/sreward_loader.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/core/cl_sreward.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/languages/sh_french.lua:
if CLIENT then
    slib.setLang("sreward", "fr", "general", "Général")
    slib.setLang("sreward", "fr", "submit", "Soumettre")
    slib.setLang("sreward", "fr", "tasks", "Tâches")
    slib.setLang("sreward", "fr", "referral", "Référence")
    slib.setLang("sreward", "fr", "shop", "Boutique")
    slib.setLang("sreward", "fr", "leaderboard", "Tableau de bord")
    slib.setLang("sreward", "fr", "coupons", "Coupons")

    slib.setLang("sreward", "fr", "main_title", "Système de récompenses")
    slib.setLang("sreward", "fr", "title_admin", "Panel Admin")

    slib.setLang("sreward", "fr", "rewards_title", "%s - Récompenses")
    slib.setLang("sreward", "fr", "coupon_title", "Coupons")

    slib.setLang("sreward", "fr", "coupon_receive_title", "Nouveau coupon")
    slib.setLang("sreward", "fr", "coupon_receive", "Vous avez reçu un nouveau coupon, \n    Vérifiez votre inventaire !") --- Had to fine tune like that :(

    slib.setLang("sreward", "fr", "copied_clipboard", "Copié dans le presse-papiers !")
    slib.setLang("sreward", "fr", "no_coupons", "Vous n'avez pas de coupons !")

    slib.setLang("sreward", "fr", "delete", "Supprimer")
    slib.setLang("sreward", "fr", "yes", "Oui")
    slib.setLang("sreward", "fr", "no", "Non")
    slib.setLang("sreward", "fr", "reffered_me", "M'a renvoyé")

    slib.setLang("sreward", "fr", "are_you_sure", "Êtes-vous sûr ?")
    slib.setLang("sreward", "fr", "manage", "Gérer")

    slib.setLang("sreward", "fr", "tokens", "Tokens")
    slib.setLang("sreward", "fr", "select_reward", "Sélectionner une récompense")
    slib.setLang("sreward", "fr", "number", "Numéro")

    slib.setLang("sreward", "fr", "submit", "Envoyer")
    slib.setLang("sreward", "fr", "name", "Nom")
    slib.setLang("sreward", "fr", "uses", "Utilise")
    slib.setLang("sreward", "fr", "used", "Utilisé")
    slib.setLang("sreward", "fr", "task", "Tâche")
    slib.setLang("sreward", "fr", "verify", "Vérifier")
    slib.setLang("sreward", "fr", "total_tokens", "Total des Tokens")
    slib.setLang("sreward", "fr", "referrals", "Références")

    slib.setLang("sreward", "fr", "rewards", "Récompenses")
    slib.setLang("sreward", "fr", "price", "Prix")
    slib.setLang("sreward", "fr", "imgur_id", "Imgur ID")

    slib.setLang("sreward", "fr", "edit_rewards", "Modifier les récompenses")
    slib.setLang("sreward", "fr", "save", "Save")

    slib.setLang("sreward", "fr", "insert_imgur_id", "Insérer Imgur ID")
    slib.setLang("sreward", "fr", "insert_name", "Insérer Nom")
    slib.setLang("sreward", "fr", "insert_price", "Insérer Prix")

    slib.setLang("sreward", "fr", "create_coupon", "Créer un coupon")
    slib.setLang("sreward", "fr", "coupon_name", "Nom du coupon")

    slib.setLang("sreward", "fr", "create_shopitem", "Créer un article de la boutique")
    slib.setLang("sreward", "fr", "item_name", "Nom de l'article")

    slib.setLang("sreward", "fr", "this_will_cost", "'%s' vous coûtera %s tokens")
    slib.setLang("sreward", "fr", "coupon_delete_confirm", "Le coupon sera ainsi supprimé '%s'?")
    slib.setLang("sreward", "fr", "this_delete", "Cela permettra de supprimer '%s'")

    slib.setLang("sreward", "fr", "manage_item", "Gérer l'article")

    slib.setLang("sreward", "fr", "discord_failed_application_com", "Nous n'avons pas réussi à communiquer avec votre application discord, assurez-vous qu'elle fonctionne !")
    slib.setLang("sreward", "fr", "discord_error_retrieving_data", "Nous avons rencontré un problème lors de la récupération des données du discord, veuillez en informer le staff !")
else
    slib.setLang("sreward", "fr", "cooldown", "Vous êtes en période de vérification, veuillez patienter %s secondes")

    slib.setLang("sreward", "fr", "added_queue", "Vous avez été ajouté à la liste d'attente pour '%s' vous recevrez une réponse dans un délai de %s secondes")

    slib.setLang("sreward", "fr", "added_steamgroup_queue", "Vous avez été ajouté à la file d'attente pour le contrôle du groupe steam, vous recevrez une réponse dans les %s secondes")
    slib.setLang("sreward", "fr", "didnt_find_steamgroup", "Nous n'avons pas pu vous trouver dans le groupe steam, veuillez réessayer !")
    slib.setLang("sreward", "fr", "failed_verification", "Il semble que nous n'ayons pas réussi à vérifier la récompense '%s', s'assurer que la tâche est bien accomplie.")
    
    slib.setLang("sreward", "fr", "discord_error_retrieving_data", "Nous n'avons pas réussi à communiquer avec discord, veuillez réessayer plus tard !")
    slib.setLang("sreward", "fr", "checking_wait", "Veuillez patienter pendant que nous vérifions la récompense '%s' pour vous")

    slib.setLang("sreward", "fr", "steam_unsuccessfull", "Nous n'avons pas réussi à communiquer avec steam, veuillez réessayer plus tard !")
    slib.setLang("sreward", "fr", "steam_private", "Nous n'avons pas réussi à vérifier le groupe steam, assurez-vous que votre profil est public afin que nous puissions le vérifier")
    slib.setLang("sreward", "fr", "success_reward", "Vous avez reçu '%s' !")

    slib.setLang("sreward", "fr", "referral_limit", "Vous avez atteint la limite maximale de parrainage !")
    slib.setLang("sreward", "fr", "referred_person", "Vous avez été parrainé par %s")
    slib.setLang("sreward", "fr", "referred_by", "Vous avez parrainé %s !")

    slib.setLang("sreward", "fr", "mysql_successfull", "Nous avons réussi à nous connecter à la base de données !")
    slib.setLang("sreward", "fr", "mysql_failed", "Nous n'avons pas réussi à nous connecter à la base de données !")
    slib.setLang("sreward", "fr", "cannot_afford", "Vous ne pouvez pas vous permettre cela !")
    slib.setLang("sreward", "fr", "successfull_purchase", "Vous avez acheté avec succès '%s'")

    slib.setLang("sreward", "fr", "taken_tokens", "Quelqu'un a pris %s de vos tokens, vous en avez désormais %s")
    slib.setLang("sreward", "fr", "given_tokens", "Quelqu'un vous a donné %s tokens, vous en avez désormais %s")
    slib.setLang("sreward", "fr", "given_reward", "Quelqu'un vous a donné la récompense '%s'")

    slib.setLang("sreward", "fr", "performed_admin_action", "Vous avez effectué une action administrative à l'égard de '%s' avec une valeur de '%s'")
    slib.setLang("sreward", "fr", "coupon_out_of_stock", "Nous sommes actuellement en rupture de stock pour '%s' coupons, veuillez contacter les SUPER-ADMIN afin que nous puissions réapprovisionner")
end

slib.setLang("sreward", "fr", "on_cooldown", "Vous êtes en attente de %s secondes pour utiliser à nouveau cette récompense !")

slib.setLang("sreward", "fr", "max_use_reached", "Vous avez atteint la limite d'utilisation maximale de cette récompense !")

slib.setLang("sreward", "fr", "sr_tokens", "Tokens")

slib.setLang("sreward", "fr", "darkrp_money", "Argent")

slib.setLang("sreward", "fr", "reward_rank", "Grade")

slib.setLang("sreward", "fr", "coupon", "Coupon")

slib.setLang("sreward", "fr", "give_weapon", "Donner une arme")

slib.setLang("sreward", "fr", "basewars_money", "Basewars Money")
slib.setLang("sreward", "fr", "basewars_level", "Basewars Level")

slib.setLang("sreward", "fr", "vrondakis_level", "Level")
slib.setLang("sreward", "fr", "vrondakis_xp", "XP")

slib.setLang("sreward", "fr", "glorified_level", "Level")
slib.setLang("sreward", "fr", "glorified_xp", "XP")

slib.setLang("sreward", "fr", "essentials_level", "Level")
slib.setLang("sreward", "fr", "essentials_xp", "XP")

slib.setLang("sreward", "fr", "elite_xp", "XP")

slib.setLang("sreward", "fr", "zpn_candy", "ZPN Bonbons")

slib.setLang("sreward", "fr", "ps1_points", "PS1 Points")

slib.setLang("sreward", "fr", "ps2_standard_points", "PS2 Standard Points")
slib.setLang("sreward", "fr", "ps2_premium_points", "PS2 Premium Points")

slib.setLang("sreward", "fr", "sh_ps_standard_points", "SH PS Standard Points")
slib.setLang("sreward", "fr", "sh_ps_premium_points", "SH PS Premium Points")

slib.setLang("sreward", "fr", "give_tokens", "Donner Tokens")
slib.setLang("sreward", "fr", "give_reward", "Donner Récompense")
slib.setLang("sreward", "fr", "take_tokens", "Récupérer Récompense")
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/modules/sh_discord.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_glorifiedleveling.lua:
sReward.RegisterReward("glorified_level", function(ply, levels)
    if !isfunction(GlorifiedLeveling.AddPlayerLevels) then return end
    GlorifiedLeveling.AddPlayerLevels(ply, levels)
end, Material("sreward/level-up.png", "smooth"))

sReward.RegisterReward("glorified_xp", function(ply, xp)
    if !isfunction(GlorifiedLeveling.AddPlayerXP) then return end
    GlorifiedLeveling.AddPlayerXP(ply, xp)
end)
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_vrondakisleveling.lua:
sReward.RegisterReward("vrondakis_level", function(ply, levels)
    if !isfunction(ply.addLevels) then return end
    ply:addLevels(levels)
end, Material("sreward/level-up.png", "smooth"))

sReward.RegisterReward("vrondakis_xp", function(ply, xp)
    if !isfunction(ply.addXP) then return end
    ply:addXP(xp)
end)
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_zpncandy.lua:
return gluapack()()
--PATH lua/streamradio_core/external/neturl.lua:
return gluapack()()
--PATH lua/streamradio_core/language.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Language = StreamRadioLib.Language or {}

local LIB = StreamRadioLib.Language
table.Empty(LIB)

local g_nameprefix = "3dstreamradio."
local g_translated = {}

function LIB.GetName(identifier)
	identifier = g_nameprefix .. tostring(identifier or "")
	identifier = string.lower(identifier)

	return identifier
end

function LIB.GetPhrase(identifier)
	identifier = LIB.GetName(identifier)

	if g_translated[identifier] then
		return g_translated[identifier]
	end

	local backup = '#' .. identifier
	if g_translated[backup] then
		return g_translated[backup]
	end

	if CLIENT then
		g_translated[identifier] = language.GetPhrase(identifier) or backup
	else
		g_translated[identifier] = backup
	end

	g_translated[backup] = g_translated[identifier]
	return g_translated[identifier]
end

function LIB.Translate(identifier, defaultEnglishText)
	identifier = LIB.GetName(identifier)
	defaultEnglishText = tostring(defaultEnglishText or "")

	if #defaultEnglishText >= 1024 then
		-- Limit by GMod: https://github.com/Facepunch/garrysmod-issues/issues/5524
		error("defaultEnglishText is too long (length >= 1024)")
	end

	if defaultEnglishText == "" then
		defaultEnglishText = nil
	end

	if g_translated[identifier] then
		return g_translated[identifier]
	end

	local backup = '#' .. identifier
	if g_translated[backup] then
		return g_translated[backup]
	end

	if CLIENT then
		if defaultEnglishText then
			language.Add(identifier, defaultEnglishText)
		end

		g_translated[identifier] = language.GetPhrase(identifier) or defaultEnglishText or backup
	else
		g_translated[identifier] = defaultEnglishText or backup
	end

	g_translated[backup] = g_translated[identifier]
	return g_translated[identifier]
end

LIB.T = LIB.Translate

return true


--PATH lua/streamradio_core/bass3.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Bass = StreamRadioLib.Bass or {}

local LIB = StreamRadioLib.Bass
table.Empty(LIB)

LIB.g_IsInstalledOnServer = false

local catchAndErrorNoHaltWithStack = StreamRadioLib.Util.CatchAndErrorNoHaltWithStack

local g_dll = "bass3"
local g_dllName = string.upper("gm_" .. g_dll)
local g_dllMinVersion = 14

local g_dllSupportedBranches = {
	["dev"] = true,
	["prerelease"] = true,
	["unknown"] = true,
	["none"] = true,
	["live"] = true,
	["main"] = true,
	[""] = true,
}

local g_bass_loaded = nil
local g_bass_dll_required = nil
local g_bass_can_loaded = nil
local g_bass_info_shown = nil

local g_cvar_cl_bass3_enable = nil
local g_cvar_sv_bass3_enable = nil
local g_cvar_sv_bass3_allow_client = nil

local function resetCache(...)
	g_bass_loaded = nil
	g_bass_can_loaded = nil
end

if SERVER then
	cvars.AddChangeCallback("sv_streamradio_bass3_enable", resetCache, "streamradio_bass3_callback")
end

if CLIENT then
	cvars.AddChangeCallback("cl_streamradio_bass3_enable", resetCache, "streamradio_bass3_callback")
	cvars.AddChangeCallback("sv_streamradio_bass3_allow_client", resetCache, "streamradio_bass3_callback")
end

local g_colDefault = Color(255, 255, 255)
local g_colOk = Color(100, 200, 100)
local g_colCL = Color(255, 222, 137)
local g_colSV = Color(137, 222, 255)

local function printBass3Info()
	if g_bass_info_shown then
		return
	end

	g_bass_info_shown = true

	local baseString = string.format(
		"loaded %s (ver. %s, %s)",
		g_dllName,
		BASS3.ModuleVersion or 0,
		BASS3.Version or 0
	)

	local message = nil
	local realmcol = nil

	if SERVER then
		message = "Serverside streaming API for advanced wire outputs active!"
		realmcol = g_colSV
	else
		message = "Clientside streaming API active!"
		realmcol = g_colCL
	end

	MsgN()
	MsgN()
	MsgC(realmcol, "###########################################################################")
	MsgN()
	MsgN()

	MsgC(g_colDefault, "    ", StreamRadioLib.AddonTitle, " ")
	MsgC(g_colOk, baseString)
	MsgN()
	MsgN()
	MsgC(g_colOk, "    ", message)
	MsgN()

	MsgN()
	MsgC(realmcol, "###########################################################################")
	MsgN()
	MsgN()
end

local function onLoadBASS3()
	StreamRadioLib.Error.AddStreamErrorCode({
		id = 102,
		name = "STREAM_ERROR_BASS3_FILESYSTEM",
		description = "Valve Filesystem is missing in " .. g_dllName,
	})

	printBass3Info()
end

local function loadBASS3()
	if g_bass_dll_required ~= nil then
		-- only attempt to load gm_bass3 once
		return
	end

	g_bass_dll_required = false
	require(g_dll)

	if not BASS3 then
		error("Couldn't load '" .. g_dllName .. "'! BASS3 is missing!")
		return false
	end

	if not BASS3.Version then
		error("Couldn't load '" .. g_dllName .. "'! BASS3.Version is missing!")
		return false
	end

	if not BASS3.ModuleVersion then
		error("Couldn't load '" .. g_dllName .. "'! BASS3.ModuleVersion is missing!")
		return false
	end

	if not BASS3.ENUM then
		error("Couldn't load '" .. g_dllName .. "'! BASS3.ENUM is missing!")
		return false
	end

	local BassModuleVersion = tonumber(BASS3.ModuleVersion) or 0

	if BassModuleVersion < g_dllMinVersion then
		error("Couldn't load '" .. g_dllName .. "'! Version is outdated!")
		return false
	end

	g_bass_dll_required = true
	return true
end

function LIB.HasLoadedDLL()
	if not g_bass_dll_required then
		return false
	end

	if not BASS3 then
		return false
	end

	if not BASS3.Version then
		return false
	end

	if not BASS3.ModuleVersion then
		return false
	end

	if not BASS3.ENUM then
		return false
	end

	local BassModuleVersion = tonumber(BASS3.ModuleVersion) or 0

	if BassModuleVersion < g_dllMinVersion then
		return false
	end

	return true
end

function LIB.IsInstalled()
	if g_bass_dll_required == false then
		-- already attempted to load, but failed
		return false
	end

	local branch = tostring(BRANCH or "")

	if not g_dllSupportedBranches[branch] then
		-- GM_BASS3 is broken on some branches
		return false
	end

	if not util.IsBinaryModuleInstalled(g_dll) then
		return false
	end

	return true
end

function LIB.CanLoadDLL()
	if g_bass_loaded ~= nil then
		return g_bass_loaded
	end

	if g_bass_can_loaded ~= nil then
		return g_bass_can_loaded
	end

	g_bass_can_loaded = false

	if not LIB.IsInstalled() then
		return false
	end

	if SERVER then
		if not g_cvar_sv_bass3_enable then
			g_cvar_sv_bass3_enable = GetConVar("sv_streamradio_bass3_enable")
		end

		if g_cvar_sv_bass3_enable and g_cvar_sv_bass3_enable:GetInt() <= 0 then
			return false
		end
	end

	if CLIENT then
		if not g_cvar_cl_bass3_enable then
			g_cvar_cl_bass3_enable = GetConVar("cl_streamradio_bass3_enable")
		end

		if g_cvar_cl_bass3_enable and g_cvar_cl_bass3_enable:GetInt() <= 0 then
			return false
		end

		if not g_cvar_sv_bass3_allow_client then
			g_cvar_sv_bass3_allow_client = GetConVar("sv_streamradio_bass3_allow_client")
		end

		if g_cvar_sv_bass3_allow_client and g_cvar_sv_bass3_allow_client:GetInt() <= 0 then
			return false
		end
	end

	g_bass_can_loaded = true
	return true
end

function LIB.ClearCache()
	resetCache()
end

function LIB.LoadDLL()
	if g_bass_loaded ~= nil then
		return g_bass_loaded
	end

	if not LIB.CanLoadDLL() then
		g_bass_loaded = false
		return g_bass_loaded
	end

	if LIB.HasLoadedDLL() then
		onLoadBASS3()

		g_bass_loaded = true
		return g_bass_loaded
	end

	catchAndErrorNoHaltWithStack(loadBASS3)

	g_bass_loaded = LIB.HasLoadedDLL()

	if g_bass_loaded then
		onLoadBASS3()
	end

	return g_bass_loaded
end

function LIB.IsInstalledOnServer()
	return LIB.g_IsInstalledOnServer or false
end

if SERVER then
	LIB.g_IsInstalledOnServer = LIB.IsInstalled()
end

return true


--PATH lua/streamradio_core/net.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Net = StreamRadioLib.Net or {}

local LIB = StreamRadioLib.Net
table.Empty(LIB)

local LIBNetwork = StreamRadioLib.Network

LIBNetwork.AddNetworkString("StaticState")
LIBNetwork.AddNetworkString("Control")

LIBNetwork.AddNetworkString("Editor_Return_Files")
LIBNetwork.AddNetworkString("Editor_Return_Playlist")
LIBNetwork.AddNetworkString("Editor_Request_Files")
LIBNetwork.AddNetworkString("Editor_Request_Playlist")
LIBNetwork.AddNetworkString("Editor_Error")

do
	-- Automaticly generated network string table map

	LIBNetwork.AddNetworkString("classsystem_listen")
	LIBNetwork.AddNetworkString("LoadError")
	LIBNetwork.AddNetworkString("ClientToolHook")
	LIBNetwork.AddNetworkString("clientstate")
	LIBNetwork.AddNetworkString("str")
	LIBNetwork.AddNetworkString("str/Volume")
	LIBNetwork.AddNetworkString("str/URL")
	LIBNetwork.AddNetworkString("str/PlayMode")
	LIBNetwork.AddNetworkString("str/Loop")
	LIBNetwork.AddNetworkString("str/Name")
	LIBNetwork.AddNetworkString("str/MasterTime")
	LIBNetwork.AddNetworkString("skin")
	LIBNetwork.AddNetworkString("skinrequest")
	LIBNetwork.AddNetworkString("skintoserver")
	LIBNetwork.AddNetworkString("g")
	LIBNetwork.AddNetworkString("gui_sk")
	LIBNetwork.AddNetworkString("gui_sk/Hash")
	LIBNetwork.AddNetworkString("data")
	LIBNetwork.AddNetworkString("datarequest")
	LIBNetwork.AddNetworkString("streamreset_on_sv")
	LIBNetwork.AddNetworkString("streamreset_on_cl")
	LIBNetwork.AddNetworkString("whitelist_check_url")
	LIBNetwork.AddNetworkString("whitelist_check_url_result")
	LIBNetwork.AddNetworkString("whitelist_quick_whitelist")
	LIBNetwork.AddNetworkString("whitelist_clear_cache")
	LIBNetwork.AddNetworkString("g/m")
	LIBNetwork.AddNetworkString("g/m/brw")
	LIBNetwork.AddNetworkString("g/m/brw/lstp")
	LIBNetwork.AddNetworkString("g/m/brw/lstp/sbar")
	LIBNetwork.AddNetworkString("g/m/brw/lstp/sbar/ScrollPos")
	LIBNetwork.AddNetworkString("g/m/brw/lstp/sbar/ScrollMax")
	LIBNetwork.AddNetworkString("g/m/brw/lstp/ListGridX")
	LIBNetwork.AddNetworkString("g/m/brw/lstp/ListGridY")
	LIBNetwork.AddNetworkString("g/m/brw/lstp/IsHorizontal")
	LIBNetwork.AddNetworkString("g/m/brw/lstp/Hash")
	LIBNetwork.AddNetworkString("g/m/brw/lstp/Path")
	LIBNetwork.AddNetworkString("g/m/brw/lstpv")
	LIBNetwork.AddNetworkString("g/m/brw/lstpv/sbar")
	LIBNetwork.AddNetworkString("g/m/brw/lstpv/sbar/ScrollPos")
	LIBNetwork.AddNetworkString("g/m/brw/lstpv/sbar/ScrollMax")
	LIBNetwork.AddNetworkString("g/m/brw/lstpv/ListGridX")
	LIBNetwork.AddNetworkString("g/m/brw/lstpv/ListGridY")
	LIBNetwork.AddNetworkString("g/m/brw/lstpv/IsHorizontal")
	LIBNetwork.AddNetworkString("g/m/brw/lstpv/Hash")
	LIBNetwork.AddNetworkString("g/m/brw/lstpv/Path")
	LIBNetwork.AddNetworkString("g/m/brw/lstpv/PathType")
	LIBNetwork.AddNetworkString("g/m/brw/lstpv/Error")
	LIBNetwork.AddNetworkString("g/m/brw/PlaylistOpened")
	LIBNetwork.AddNetworkString("g/m/ply")
	LIBNetwork.AddNetworkString("g/m/PlayerOpened")
	LIBNetwork.AddNetworkString("g/m/ply/ctrl")
	LIBNetwork.AddNetworkString("g/m/ply/ctrl/PlaylistEnabled")
	LIBNetwork.AddNetworkString("properties")
end

function LIB.Receive(name, ...)
	name = LIBNetwork.TransformNWIdentifier(name)
	return net.Receive(name, ...)
end

function LIB.Start(name, ...)
	name = LIBNetwork.TransformNWIdentifier(name)
	return net.Start(name, ...)
end

function LIB.SendIdentifier(identifier)
	local identifierId = 0

	if isstring(identifier) then
		identifierId = LIBNetwork.NetworkStringToID(identifier)

		if identifierId == 0 then
			StreamRadioLib.Util.ErrorNoHaltWithStack("Identifier '" .. identifier .. "' was not added via util.AddNetworkString() yet.")
		end
	end

	net.WriteUInt(identifierId, 12)
end

function LIB.ReceiveIdentifier()
	local identifierId = net.ReadUInt(12) or 0
	local identifier = LIBNetwork.NetworkIDToString(identifierId)

	return identifier
end

function LIB.SendHash(hash)
	net.WriteString(hash or "")
end

function LIB.ReceiveHash()
	local hash = net.ReadString() or ""
	return hash
end

function LIB.SendListEntry( text, iconid )
	net.WriteString( text or "" )
	net.WriteInt( iconid or -1, 16 )
end

function LIB.ReceiveListEntry( )
	local text = net.ReadString( ) or ""
	local iconid = net.ReadInt( 16 ) or -1

	return text, iconid
end

function StreamRadioLib.NetSendEditorError( path, code )
	if ( not path ) then return end
	if ( not code ) then return end

	net.WriteString( path )
	net.WriteUInt( code, 8 )
end

function StreamRadioLib.NetReceiveEditorError( )
	local path = net.ReadString( ) or ""
	local code = net.ReadUInt( 8 ) or StreamRadioLib.EDITOR_ERROR_UNKNOWN

	return path, code
end

function StreamRadioLib.NetSendFileEditor( path, name, format, parentpath )
	if ( not path ) then return end
	if ( not name ) then return end
	if ( not format ) then return end
	if ( not parentpath ) then return end

	net.WriteString( path )
	net.WriteString( name )
	net.WriteString( parentpath )
	net.WriteUInt( format, 8 )
end

function StreamRadioLib.NetReceiveFileEditor( )
	local path = net.ReadString( ) or ""
	local name = net.ReadString( ) or ""
	local parentpath = net.ReadString( ) or ""
	local format = net.ReadUInt( 8 ) or StreamRadioLib.TYPE_FOLDER

	return path, name, format, parentpath
end

function StreamRadioLib.NetSendPlaylistEditor( url, name, parentpath )
	if ( not url ) then return end
	if ( not name ) then return end
	if ( not parentpath ) then return end

	net.WriteString( name )
	net.WriteString( url )
	net.WriteString( parentpath )
end

function StreamRadioLib.NetReceivePlaylistEditor( )
	local name = net.ReadString( ) or ""
	local url = net.ReadString( ) or ""
	local parentpath = net.ReadString( ) or ""

	return url, name, parentpath
end

local function networkStaticAddonStates()
	if SERVER then
		StreamRadioLib.Hook.Add("PlayerInitialSpawn", "StaticState", function(ply)
			if not IsValid(ply) then
				return
			end

			LIB.Start("StaticState")
				net.WriteBool(StreamRadioLib.Bass.IsInstalledOnServer())
			net.Send(ply)
		end)
	else
		LIB.Receive("StaticState", function()
			StreamRadioLib.Bass.g_IsInstalledOnServer = net.ReadBool()
		end)
	end
end

networkStaticAddonStates()

return true


--PATH lua/streamradio_core/timer.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Timer = StreamRadioLib.Timer or {}

local LIB = StreamRadioLib.Timer
table.Empty(LIB)

local g_nameprefix = "3DStreamRadio_Timer_"

function LIB.GetName(identifier)
	identifier = g_nameprefix .. tostring(identifier or "")
	return identifier
end

function LIB.Interval(identifier, delay, repetitions, func)
	if not isfunction(func) then return end
	local name = LIB.GetName(identifier)

	timer.Remove(name)
	timer.Create(name, delay, repetitions, func)
end

function LIB.Once(identifier, delay, func)
	if not isfunction(func) then return end
	local name = LIB.GetName(identifier)

	timer.Remove(name)
	timer.Create(name, delay, 1, function()
		timer.Remove(name)
		func()
	end)
end

function LIB.Until(identifier, delay, func)
	if not isfunction(func) then return end
	local name = LIB.GetName(identifier)

	timer.Remove(name)
	timer.Create(name, delay, 0, function()
		local endtimer = func()
		if not endtimer then return end

		timer.Remove(name)
	end)
end

function LIB.NextFrame(identifier, func)
	LIB.Once(identifier, 0.001, func)
end

function LIB.Remove(identifier)
	local name = LIB.GetName(identifier)
	timer.Remove(name)
end

return true


--PATH lua/streamradio_core/models/111as_h500_radio.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- ZENITH Trans-Oceanic H500 Radio
-- Addon: https://steamcommunity.com/sharedfiles/filedetails/?id=1652510511
RADIOMDL.model = "models/props_111as/h500.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(5, -10.15, -5.68)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)

RADIOMDL.DisplayAngles = Angle(0, 90, 90)

                              --      F,     R,    U
RADIOMDL.DisplayOffset    = Vector(-7.40, -9.30, 14.25) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(-7.40,  9.30, 4.85) -- Bottom Right

RADIOMDL.DisplayWidth = 768
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)

RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {21,	1000},
	Default	= {20,	700},
	Tooltip	= {18,	800},
	Big		= {22,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 40)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 2, y = 6})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 2, y = 6})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 50)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 45)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 35)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 35)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 16)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 5
	local padding = 5
	local margin = 5

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--PATH lua/streamradio_core/models/cs_office_tv.lua:
return gluapack()()
--PATH lua/streamradio_core/models/sw_gramophone.lua:
return gluapack()()
--PATH lua/streamradio_core/models/sw_jukebox.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- SligWolf's Jukebox
RADIOMDL.model = "models/sligwolf/grocel/radio/jukebox.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(10, 0, 25)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)

RADIOMDL.DisplayAngles = Angle(0, 90, 90)

                               --      F,     R,     U
RADIOMDL.DisplayOffset    = Vector(12.30, -9.60, 40.00) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(12.30,  9.60, 35.00) -- Bottom Right

RADIOMDL.DisplayWidth = 1024
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)


RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {23,	1000},
	Error	= {17,	700},
	Default	= {22,	700},
	Tooltip	= {22,	1000},
	Big		= {23,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Error)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Error)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Error)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Error)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 35)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 35)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 3, y = 4})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 2, y = 4})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 40)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 0)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 3
	local padding = 5
	local margin = 5

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

RADIOMDL.Sounds = {
	Noise = "",
}

function RADIOMDL:Initialize(ent)
	if CLIENT then
		ent:InvalidateBoneCache()
		return
	end

	if ent._mdl_skinset then return end

	local skinid = math.random(0, 4)
	ent:SetSkin( skinid )

	local color = ColorRand()
	ent:SetColor( color )

	ent._mdl_skinset = true
end

function RADIOMDL:AnimReset(ent)
	local sequence = ent:LookupSequence( "idle" )
	ent:SetAnim( sequence, 0, 1 )
end

function RADIOMDL:OnPlay(ent, stream)
	if SERVER then return end

	local sequence = ent:LookupSequence( "cdplayidle" )
	ent:SetAnim( sequence, 0, 1 )
end

function RADIOMDL:OnError(ent, stream)
	if SERVER then return end

	local sequence = ent:LookupSequence( "idle" )
	ent:SetAnim( sequence, 0, 1 )
end

function RADIOMDL:OnStop(ent, stream)
	if SERVER then return end

	local sequence = ent:LookupSequence( "idle" )
	ent:SetAnim( sequence, 0, 1 )
end

function RADIOMDL:WhileLoading(ent)
	if SERVER then return end

	local sequence = ent:LookupSequence( "idle" )
	ent:SetAnim( sequence, 0, 1 )
end

return true


--PATH lua/streamradio_core/models/wire_monitor_big.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/label_fade.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/button.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

function CLASS:Create()
	BASE.Create(self)

	self.CanHaveLabel = false

	self.Layout.Align = TEXT_ALIGN_RIGHT

	self.ImagePanel = self:AddPanelByClassname("image", true)
	self.ImagePanel:SetPos(0, 0)
	self.ImagePanel:SetAlign(TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	self.ImagePanel:SetName("image")
	self.ImagePanel:SetNWName("img")
	self.ImagePanel:SetSkinIdentifyer("image")

	self.ImagePanel.OnMaterialChange = function(pnl)
		if not IsValid(self) then return end
		self:InvalidateLayout()
		self:CallHook("OnMaterialChange")
	end

	self.ImagePanel.OnAlignChange = function(pnl)
		if not IsValid(self) then return end
		self:InvalidateLayout()
		self:CallHook("OnAlignChange")
	end

	self.LabelPanel = self:AddPanelByClassname("label", true)
	self.LabelPanel:SetPos(0, 0)
	self.LabelPanel:SetAlign(TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	self.LabelPanel:SetName("label")
	self.LabelPanel:SetNWName("lbl")
	self.LabelPanel:SetSkinIdentifyer("label")

	self.LabelPanel.OnTextChange = function(pnl)
		if not IsValid(self) then return end
		self:InvalidateLayout()
		self:CallHook("OnTextChange")
	end

	self.LabelPanel.OnFontChange = function(pnl)
		if not IsValid(self) then return end
		self:InvalidateLayout()
		self:CallHook("OnFontChange")
	end

	self.LabelPanel.OnAlignChange = function(pnl)
		if not IsValid(self) then return end
		self:InvalidateLayout()
		self:CallHook("OnAlignChange")
	end

	self.SkinMap["color_hover"] = {
		set = "SetHoverColor",
		get = "GetHoverColor",
	}

	self.SkinMap["color_disabled"] = {
		set = "SetDisabledColor",
		get = "GetDisabledColor",
	}

	self.SkinMap["color_foreground_hover"] = {
		set = "SetTextHoverColor",
		get = "GetTextHoverColor",
	}

	self.SkinMap["color_foreground_disabled"] = {
		set = "SetTextDisabledColor",
		get = "GetTextDisabledColor",
	}

	self.SkinMap["color_icon_hover"] = {
		set = "SetIconHoverColor",
		get = "GetIconHoverColor",
	}

	self.SkinMap["color_icon_disabled"] = {
		set = "SetIconDisabledColor",
		get = "GetIconDisabledColor",
	}

	if not SERVER then
		self.Colors.Disabled = Color(128,128,128)
		self.Colors.DisabledText = Color(255,255,255)
		self.Colors.DisabledIcon = Color(255,255,255)

		self.Colors.Hover = Color(192,192,192)
		self.Colors.HoverText = Color(0,0,0)
		self.Colors.HoverIcon = Color(255,255,255)

		self.Colors.NoHover = Color(255,255,255)
		self.Colors.NoHoverText = Color(0,0,0)
		self.Colors.NoHoverIcon = Color(255,255,255)

		self.Colors = self.Colors + function(this, k, v)
			if k == "Main" then return end
			self:QueueCall("UpdateColor")
		end
	end

	self:IconFitToPanel()
end

function CLASS:PerformLayout(...)
	BASE.PerformLayout(self, ...)

	self:QueueCall("UpdateColor")
	self:QueueCall(self._recallonlaylout)

	local mat_panel = self.ImagePanel
	local text_panel = self.LabelPanel

	if not IsValid(mat_panel) then
		return
	end

	if not IsValid(text_panel) then
		return
	end

	local has_mat = mat_panel:GetMaterial() ~= nil
	local has_text = text_panel:GetText() ~= ""

	if not has_text and not has_mat then
		return
	end

	local w, h = self:GetClientSize()
	local align = self.Layout.Align

	if has_mat and not has_text then
		text_panel:SetSize(0, 0)
		text_panel:SetVisible(false)
		mat_panel:SetSize(w, h)
		mat_panel:SetVisible(true)
		return
	end

	if has_text and not has_mat then
		text_panel:SetSize(w, h)
		text_panel:SetVisible(true)
		mat_panel:SetSize(0, 0)
		mat_panel:SetVisible(false)
		return
	end

	text_panel:SetVisible(true)
	mat_panel:SetVisible(true)

	local mat_size = self:GetSquareSize()
	local padding = self:GetPadding()

	if align == TEXT_ALIGN_RIGHT then
		mat_panel:SetPos(0, 0)
		mat_panel:SetSize(mat_size, mat_size)
		text_panel:SetPos(mat_size + padding, 0)
		text_panel:SetSize(w - mat_size - padding, h)
		return
	end

	if align == TEXT_ALIGN_LEFT then
		mat_panel:SetPos(w - mat_size, 0)
		mat_panel:SetSize(mat_size, mat_size)
		text_panel:SetPos(0, 0)
		text_panel:SetSize(w - mat_size - padding, h)
		return
	end

	local _, text_h = text_panel:GetTextSize()

	if align == TEXT_ALIGN_BOTTOM then
		mat_panel:SetPos(0, 0)
		mat_panel:SetSize(w, h - text_h - padding)
		text_panel:SetPos(0, h - text_h)
		text_panel:SetSize(w, text_h)
		return
	end

	if align == TEXT_ALIGN_TOP then
		mat_panel:SetPos(0, text_h + padding)
		mat_panel:SetSize(w, h - text_h - padding)
		text_panel:SetPos(0, 0)
		text_panel:SetSize(w, text_h)
		return
	end
end

function CLASS:CursorChangedInternal()
	BASE.CursorChangedInternal(self)

	if SERVER then return end
	self:UpdateColor()
end

function CLASS:UpdateColor()
	if SERVER then return end

	if self:IsDisabled() then
		self.Colors.Main = self.Colors.Disabled
		if IsValid(self.LabelPanel) then
			self.LabelPanel:SetColor(self.Colors.DisabledText)
		end

		if IsValid(self.ImagePanel) then
			self.ImagePanel:SetColor(self.Colors.DisabledIcon)
		end

		return
	end

	if self:IsCursorOnPanel() then
		self.Colors.Main = self.Colors.Hover

		if IsValid(self.LabelPanel) then
			self.LabelPanel:SetColor(self.Colors.HoverText)
		end

		if IsValid(self.ImagePanel) then
			self.ImagePanel:SetColor(self.Colors.HoverIcon)
		end

		return
	end

	self.Colors.Main = self.Colors.NoHover
	if IsValid(self.LabelPanel) then
		self.LabelPanel:SetColor(self.Colors.NoHoverText)
	end

	if IsValid(self.ImagePanel) then
		self.ImagePanel:SetColor(self.Colors.NoHoverIcon)
	end
end

function CLASS:GetAlign()
	return self.Layout.Align or TEXT_ALIGN_RIGHT
end

function CLASS:SetAlign(align)
	self.Layout.Align = align or TEXT_ALIGN_RIGHT
end

function CLASS:GetIconAlign(...)
	return self.ImagePanel:GetAlign(...)
end

function CLASS:SetIconAlign(...)
	return self.ImagePanel:SetAlign(...)
end

function CLASS:GetTextAlign(...)
	return self.LabelPanel:GetAlign(...)
end

function CLASS:SetTextAlign(...)
	return self.LabelPanel:SetAlign(...)
end

function CLASS:SetText(...)
	return self.LabelPanel:SetText(...)
end

function CLASS:GetText(...)
	return self.LabelPanel:GetText(...)
end

function CLASS:SetFont(...)
	return self.LabelPanel:SetFont(...)
end

function CLASS:GetFont(...)
	return self.LabelPanel:GetFont(...)
end

function CLASS:GetMaterial(...)
	return self.ImagePanel:GetMaterial(...)
end

function CLASS:SetMaterial(...)
	return self.ImagePanel:SetMaterial(...)
end

function CLASS:GetMaterialName(...)
	return self.ImagePanel:GetMaterialName(...)
end

function CLASS:SetTexture(...)
	return self.ImagePanel:SetTexture(...)
end

function CLASS:SetIcon(...)
	return self.ImagePanel:SetMaterial(...)
end

function CLASS:GetIcon(...)
	return self.ImagePanel:GetMaterial(...)
end

function CLASS:IconSizeToPanel(...)
	self._recallonlaylout = "IconSizeToPanel"
	return self.ImagePanel:TextureSizeToPanel(...)
end

function CLASS:IconFitToPanel(...)
	self._recallonlaylout = "IconFitToPanel"
	return self.ImagePanel:TextureFitToPanel(...)
end

function CLASS:IconSizeToTexture(...)
	self._recallonlaylout = "IconSizeToTexture"
	return self.ImagePanel:TextureSizeToTexture(...)
end

function CLASS:SetColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.NoHover = color
end

function CLASS:GetColor()
	if SERVER then return end

	local col = self.Colors.NoHover
	return col
end

function CLASS:SetHoverColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.Hover = color
end

function CLASS:GetHoverColor()
	if SERVER then return end

	local col = self.Colors.Hover
	return col
end

function CLASS:SetDisabledColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.Disabled = color
end

function CLASS:GetDisabledColor()
	if SERVER then return end

	local col = self.Colors.Disabled
	return col
end

function CLASS:SetTextColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.NoHoverText = color
end

function CLASS:GetTextColor()
	if SERVER then return end

	local col = self.Colors.NoHoverText
	return col
end

function CLASS:SetTextHoverColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.HoverText = color
end

function CLASS:GetTextHoverColor()
	if SERVER then return end

	local col = self.Colors.HoverText
	return col
end

function CLASS:SetTextDisabledColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.DisabledText = color
end

function CLASS:GetTextDisabledColor()
	if SERVER then return end

	local col = self.Colors.DisabledText
	return col
end

function CLASS:SetIconColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.NoHoverIcon = color
end

function CLASS:GetIconColor()
	if SERVER then return end

	local col = self.Colors.NoHoverIcon
	return col
end

function CLASS:SetIconHoverColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.HoverIcon = color
end

function CLASS:GetIconHoverColor()
	if SERVER then return end

	local col = self.Colors.HoverIcon
	return col
end

function CLASS:SetIconDisabledColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.DisabledIcon = color
end

function CLASS:GetIconDisabledColor()
	if SERVER then return end

	local col = self.Colors.DisabledIcon
	return col
end

function CLASS:DoClick()
	-- Override me
end

function CLASS:OnMouseReleased()
	-- Override me
end

function CLASS:OnModelSetup(setup)
	BASE.OnModelSetup(self, setup)

	if setup.font then
		self:SetFont(setup.font)
	end
end

return true


--PATH lua/streamradio_core/classes/ui/radio/gui_player.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local LIBNetwork = StreamRadioLib.Network
local LIBError = StreamRadioLib.Error
local LIBUtil = StreamRadioLib.Util
local LIBError = StreamRadioLib.Error

local emptyTableSafe = LIBUtil.EmptyTableSafe

local BASE = CLASS:GetBaseClass()

local g_mat_closebutton = StreamRadioLib.GetPNGIcon("door_in")

function CLASS:Create()
	BASE.Create(self)

	self.HeaderPanel = self:AddPanelByClassname("shadow_panel", true)
	self.HeaderPanel:SetSize(1, 40)
	self.HeaderPanel:SetName("header")
	self.HeaderPanel:SetNWName("hdr")
	self.HeaderPanel:SetSkinIdentifyer("header")

	self.HeaderText = self.HeaderPanel:CreateText("label_fade")
	self.HeaderPanel:SetAlign(TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

	self.SpectrumPanel = self:AddPanelByClassname("radio/gui_player_spectrum", true)
	self.SpectrumPanel:SetSize(1, 1)
	self.SpectrumPanel:SetName("spectrum")
	self.SpectrumPanel:SetNWName("spc")
	self.SpectrumPanel:SetSkinIdentifyer("spectrum")

	self.VolumePanel = self.SpectrumPanel:AddPanelByClassname("shadow_panel")
	self.VolumePanel:SetSize(1, 60)
	self.VolumePanel:SetName("volume")
	self.VolumePanel:SetNWName("vol")
	self.VolumePanel:SetSkinIdentifyer("volume")
	self.VolumePanel:SetShadowWidth(0)
	self.VolumePanel:SetColor(Color(128, 128, 128, 160))
	self.VolumePanel.SkinAble = false
	self.VolumePanel:SetZPos(200)
	self.VolumePanel:Close()

	self.VolumeBar = self.VolumePanel:AddPanelByClassname("progressbar", true)
	self.VolumeBar:SetName("progressbar")
	self.VolumeBar:SetNWName("bar")
	self.VolumeBar:SetSkinIdentifyer("bar")
	self.VolumeBar:SetAllowFractionEdit(true)
	self.VolumeBar:SetShadowWidth(0)
	self.VolumeBar:SetColor(Color(0, 0, 0, 200))
	self.VolumeBar:SetTextColor(Color(255, 255, 255, 255))
	self.VolumeBar.SkinAble = false

	self.VolumeBar.FractionChangeText = function(this, v)
		return string.format("Volume: %3i%%", math.Round(v * 100))
	end

	self.VolumeBar.OnFractionChangeEdit = function(this, v)
		if CLIENT then return end
		if not IsValid(self.StreamOBJ) then return end
		self.StreamOBJ:SetVolume(v)
	end

	self.VolumeBar:SetSize(1, 1)

	self.ControlPanel = self:AddPanelByClassname("radio/gui_player_controls", true)
	self.ControlPanel:SetSize(1, 1)
	self.ControlPanel:SetName("controls")
	self.ControlPanel:SetNWName("ctrl")
	self.ControlPanel:SetSkinIdentifyer("controls")

	self.ControlPanel.OnPlaylistBack = function()
		self:CallHook("OnPlaylistBack")
	end

	self.ControlPanel.OnPlaylistForward = function()
		self:CallHook("OnPlaylistForward")
	end

	self.ControlPanel.OnPlaybackLoopModeChange = function(this, newLoopMode)
		self:CallHook("OnPlaybackLoopModeChange", newLoopMode)
	end

	if CLIENT then
		self.Errorbox = self.SpectrumPanel:AddPanelByClassname("radio/gui_errorbox")
		self.Errorbox:SetName("error")
		self.Errorbox:SetNWName("err")
		self.Errorbox:SetSkinIdentifyer("error")

		self.Errorbox.OnRetry = function()
			if not IsValid(self.Errorbox) then
				return
			end

			self.Errorbox:Close()
		end

		self.Errorbox.OnClose = function()
			if not IsValid(self.StreamOBJ) then return end
			if not self.State then return end

			if not self.State.Error then return end
			if self.State.Error == 0 then return end

			self.State.Error = 0
			self:ResetStream()
		end

		self.Errorbox.OnWhitelist = function()
			if not IsValid(self.StreamOBJ) then return end

			StreamRadioLib.Whitelist.QuickWhitelistAdd(self.StreamOBJ:GetURL())
		end

		self.Errorbox:SetZPos(100)
		self.Errorbox:Close()

		if self.Errorbox.CloseButton then
			self.Errorbox.CloseButton:Remove()
			self.Errorbox.CloseButton = nil
		end
	end

	self.CloseButton = self:AddPanelByClassname("button", true)
	self.CloseButton:SetName("backbutton")
	self.CloseButton:SetNWName("bk")
	self.CloseButton:SetSkinIdentifyer("button")
	self.CloseButton:SetIcon(g_mat_closebutton)
	self.CloseButton:SetAlign(TEXT_ALIGN_RIGHT)
	self.CloseButton:SetTextAlign(TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

	self.CloseButton:SetSize(200, 60)
	self.CloseButton:SetText("Back")
	self.CloseButton.DoClick = function()
		if CLIENT then
			return
		end

		if self.State then
			self.State.Error = 0
		end

		if IsValid(self.StreamOBJ) then
			self.StreamOBJ:Stop()
		end

		self:Close()
	end

	if CLIENT then
		self._textlistBuffer = {}

		self.State = self:CreateListener({
			Error = 0,
		}, function(this, k, v)
			if not IsValid(self.Errorbox) then
				return
			end

			local err = tonumber(v or 0) or 0
			local url = nil

			if IsValid(self.StreamOBJ) then
				url = self.StreamOBJ:GetURL()
			end

			self.Errorbox:SetErrorCode(err, url)
		end)
	end

	if SERVER then
		LIBNetwork.AddNetworkString("streamreset_on_sv")
		LIBNetwork.AddNetworkString("streamreset_on_cl")

		self:NetReceive("streamreset_on_sv", function(this, id, len, ply)
			self:ResetStream()
		end)
	else
		self:NetReceive("streamreset_on_cl", function(this, id, len, ply)
			self:ResetStream(true)
		end)
	end
end

function CLASS:Remove()
	if IsValid(self.StreamOBJ) then
		self.StreamOBJ:RemoveEvent("OnVolumeChange", self:GetID())

		if CLIENT then
			self.StreamOBJ:RemoveEvent("OnConnect", self:GetID())
			self.StreamOBJ:RemoveEvent("OnError", self:GetID())
			self.StreamOBJ:RemoveEvent("OnSearch", self:GetID())
			self.StreamOBJ:RemoveEvent("OnMute", self:GetID())
		end
	end

	BASE.Remove(self)
end

function CLASS:ResetStream(nosend)
	if not nosend then
		if SERVER then
			self:NetSend("streamreset_on_cl")
		else
			self:NetSend("streamreset_on_sv")
			return
		end
	end

	if not IsValid(self.StreamOBJ) then return end
	self.StreamOBJ:Reconnect()
end

function CLASS:SetStream(stream)
	if self.StreamOBJ == stream then
		return
	end

	self.StreamOBJ = stream

	self:SetFastThinkRate(0)

	if IsValid(self.ControlPanel) then
		self.ControlPanel:SetStream(stream)
	end

	if IsValid(self.SpectrumPanel) then
		self.SpectrumPanel:SetStream(stream)
	end

	if not IsValid(stream) then return end

	stream:SetEvent("OnVolumeChange", self:GetID(), function(this, vol)
		if not IsValid(self) then return end

		if IsValid(self.VolumeBar) then
			self.VolumeBar:SetFraction(vol)
		end

		if IsValid(self.VolumePanel) then
			local volumetimeout = 5

			self.VolumePanel:Show()

			self:TimerOnce("volumebar", volumetimeout, function()
				if not IsValid(self.VolumePanel) then return end
				self.VolumePanel:Hide()
			end)
		end

		self:CallHook("OnVolumeChange", v)
	end)

	if IsValid(self.VolumeBar) then
		self.VolumeBar:SetFraction(stream:GetVolume())
	end

	if CLIENT then
		local updateErrorState = function()
			if not IsValid(self) then return end
			if not self.State then return end

			local err = stream:GetError()

			if err == LIBError.STREAM_OK then
				self.State.Error = LIBError.STREAM_OK
			else
				if IsValid(self.Errorbox) then
					self.Errorbox:SetErrorCode(err, stream:GetURL())
				end

				self.State.Error = err
			end
		end

		stream:SetEvent("OnClose", self:GetID(), updateErrorState)
		stream:SetEvent("OnSearch", self:GetID(), updateErrorState)
		stream:SetEvent("OnConnect", self:GetID(), updateErrorState)
		stream:SetEvent("OnError", self:GetID(), updateErrorState)
		stream:SetEvent("OnMute", self:GetID(), updateErrorState)

		updateErrorState()
	end

	self:UpdateFromStream()
end

function CLASS:GetStream()
	return self.StreamOBJ
end

if CLIENT then
	function CLASS:Think()
		self.thinkRate = 0.5

		if not self:IsSeen() then return end
		if not self:IsVisible() then return end

		self.thinkRate = 0
		self:UpdateFromStream()
	end
end

local function formatInterfaceName(interfaceName, text)
	interfaceName = interfaceName or ""
	text = text or ""

	if text == "" then
		return ""
	end

	if interfaceName == "" then
		return text
	end

	text = string.format("[%s] %s", interfaceName, text)
	return text
end

function CLASS:UpdateHeaderTextFromStream()
	if SERVER then return end

	local stream = self.StreamOBJ
	if not IsValid(stream) then return end

	local headerText = self.HeaderText
	if not IsValid(headerText) then return end

	local textlist = self._textlistBuffer
	if not textlist then return end

	emptyTableSafe(textlist)

	local interfaceName = stream:GetActiveInterfaceName()
	local name = stream:GetStreamName()
	local url = stream:GetURL()

	name = string.Trim(name)
	url = string.Trim(url)

	if url == "" then
		url = "(Unknown URL)"
	end

	if name == url then
		-- Avoid showing the name if it is the URL
		name = ""
	end

	if name ~= "" then
		table.insert(textlist, name)
	end

	if name == "" or not string.find(name, url, 1, true) then
		-- Avoid showing the URL twice

		local urlText = formatInterfaceName(interfaceName, url)
		table.insert(textlist, urlText)
	end

	local metatags = stream:GetMetaTags() or {}

	local remotename = metatags["streamtitle"] or ""
	remotename = string.Trim(remotename)

	remotename = formatInterfaceName(interfaceName, remotename)

	if remotename ~= "" then
		table.insert(textlist, remotename)
	end

	headerText:SetList(textlist)
end

function CLASS:UpdateWhitelistButtonFromStream()
	if SERVER then return end

	local stream = self.StreamOBJ
	if not IsValid(stream) then return end

	local errorbox = self.Errorbox
	if not IsValid(errorbox) then return end

	local isAdmin = LIBUtil.IsAdmin()
	local isOnlineUrl = stream:IsOnlineUrl()
	local isWhitelistError = stream:GetError() == LIBError.STREAM_ERROR_URL_NOT_WHITELISTED
	local showButton = isAdmin and isWhitelistError and isOnlineUrl

	errorbox:SetAdminWhitelistButtonVisible(showButton)
end

function CLASS:UpdateFromStream()
	if SERVER then return end
	if not IsValid(self.StreamOBJ) then return end

	self:UpdateWhitelistButtonFromStream()
	self:UpdateHeaderTextFromStream()
end

function CLASS:PerformLayout(...)
	BASE.PerformLayout(self, ...)

	if not IsValid(self.HeaderPanel) then return end
	if not IsValid(self.CloseButton) then return end
	if not IsValid(self.SpectrumPanel) then return end

	local w, h = self:GetClientSize()
	local margin = self:GetMargin()

	local headerh = self.HeaderPanel:GetHeight()
	local closew, closeh = self.CloseButton:GetSize()

	closew = closeh * 4
	self.CloseButton:SetWidth(closew)

	local closex = w - closew
	local closey = h - closeh

	local spectrumy = headerh + margin

	local spectrumbgw = w
	local spectrumbgh = h - headerh - closeh - margin * 2

	local controlx = 0
	local controly = closey

	local controlw = w - closew - margin
	local controlh = closeh

	local ultrawideminh = closeh * 2 + margin

	if spectrumbgh <= ultrawideminh then
		if IsValid(self.ControlPanel) then
			closew = closeh * (self.ControlPanel.State.PlaylistEnabled and 6 or 4)
			self.CloseButton:SetWidth(closew)
		end

		spectrumbgw = w - closew - margin
		spectrumbgh = h - headerh - margin

		controlx = closex
		controly = spectrumy

		controlw = closew
		controlh = spectrumbgh - closeh - margin
	end

	self.HeaderPanel:SetPos(0, 0)
	self.HeaderPanel:SetWidth(w)

	self.SpectrumPanel:SetPos(0, spectrumy)
	self.SpectrumPanel:SetSize(spectrumbgw, spectrumbgh)

	local spectrumw, spectrumh = self.SpectrumPanel:GetClientSize()

	if IsValid(self.Errorbox) then
		self.Errorbox:SetPos(0, 0)
		self.Errorbox:SetSize(spectrumw, spectrumh)
	end

	if IsValid(self.ControlPanel) then
		self.ControlPanel:SetPos(controlx, controly)
		self.ControlPanel:SetSize(controlw, controlh)
	end

	if IsValid(self.VolumePanel) and IsValid(self.VolumeBar) then
		local headerheight = self.HeaderPanel:GetHeight()
		local volumew = spectrumw * 0.618
		local volumeh = math.Clamp(spectrumh * 0.1, headerheight, headerheight * 2)

		local volumex = (spectrumw - volumew) / 2
		local volumey = spectrumh * 0.95 - volumeh

		self.VolumePanel:SetPos(volumex, volumey)
		self.VolumePanel:SetSize(volumew, volumeh)

		self.VolumeBar:SetPos(0, 0)
		self.VolumeBar:SetSize(self.VolumePanel:GetClientSize())
	end

	self.CloseButton:SetPos(closex, closey)
end

function CLASS:GetHasPlaylist()
	return self._hasplaylist or false
end

function CLASS:SetHasPlaylist(bool)
	self._hasplaylist = bool
end

function CLASS:EnablePlaylist(...)
	if not IsValid(self.ControlPanel) then
		return
	end

	self.ControlPanel:EnablePlaylist(...)
end

function CLASS:IsPlaylistEnabled()
	if not IsValid(self.ControlPanel) then
		return
	end

	return self.ControlPanel:IsPlaylistEnabled()
end

function CLASS:UpdatePlaybackLoopMode(...)
	if not IsValid(self.ControlPanel) then
		return
	end

	self.ControlPanel:UpdatePlaybackLoopMode(...)
end

function CLASS:SetSyncMode(bool)
	self._syncmode = bool or false

	if IsValid(self.CloseButton) then
		self.CloseButton:SetDisabled(bool)
	end

	if IsValid(self.ControlPanel) then
		self.ControlPanel:SetSyncMode(bool)
	end
end

function CLASS:GetSyncMode()
	return self._syncmode or  false
end

return true


--PATH lua/streamradio_core/classes/ui/radio/gui_player_spectrum.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()
local g_mat_play = StreamRadioLib.GetPNGIcon("control_play")
local g_mat_pause = StreamRadioLib.GetPNGIcon("control_pause")
local g_mat_stop = StreamRadioLib.GetPNGIcon("control_stop")
local g_mat_mute = StreamRadioLib.GetPNGIcon("sound_mute")

function CLASS:Create()
	BASE.Create(self)

	self.StreamOBJ = nil
	self.Spectrum = {}

	self.SkinMap["color_foreground"] = {
		set = "SetForegroundColor",
		get = "GetForegroundColor",
	}

	self.SkinMap["color_icon"] = {
		set = "SetIconColor",
		get = "GetIconColor",
	}

	if CLIENT then
		self.Colors.Foreground = Color(0, 0, 0, 255)
		self.Colors.Icon = Color(255, 255, 255, 255)
	end

	self.CanHaveLabel = false
	self.SkinAble = true

	if CLIENT then
		self:StartFastThink()
	end
end

function CLASS:SetForegroundColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.Foreground = color
end

function CLASS:GetForegroundColor()
	if SERVER then return end

	local col = self.Colors.Foreground
	return col
end

function CLASS:SetIconColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.Icon = color
end

function CLASS:GetIconColor()
	if SERVER then return end

	local col = self.Colors.Icon
	return col
end

local function RenderSpectrumBar(index, level, bars, x, y, w, h, cR, cG, cB, cA)
	if ( index > w ) then return false end

	if ( bars > w ) then
		bars = w
	end

	local barwide = w / bars

	local BarX = math.Round(x + (index - 1) * barwide)
	local NextBarX = math.Round(x + index * barwide)

	-- close the bar gaps
	barwide = NextBarX - BarX

	local BarY = h + y
	local barheight = math.floor( math.Clamp( level * h, 0, h ) )

	surface.SetDrawColor( cR, cG, cB, cA )
	surface.DrawRect( BarX, BarY - barheight, barwide, barheight )

	return true
end

function CLASS:RenderSpectrum()
	local color = self:GetForegroundColor()

	local x, y = self:GetRenderPos()
	local p = self:GetPadding()
	x = x + p
	y = y + p

	local w, h = self:GetClientSize()

	local soundlevel = self.StreamOBJ:GetAverageLevel()
	soundlevel = math.Clamp( soundlevel ^ 2, 0, 1 )
	soundlevel = ( soundlevel * 0.5 ) + 0.5

	local cR, cG, cB, cA = color:Unpack()

	cR = cR * soundlevel
	cG = cG * soundlevel
	cB = cB * soundlevel

	self.StreamOBJ:GetSpectrumTable(StreamRadioLib.GetSpectrumBars(), self.Spectrum, RenderSpectrumBar, x, y, w, h, cR, cG, cB, cA)
end

function CLASS:RenderLoader()
	local color = self.Colors.Foreground

	local x, y = self:GetRenderPos()
	local p = self:GetPadding()
	x = x + p
	y = y + p

	local w, h = self:GetClientSize()

	local sqmax, sqmin = math.max(w, h), math.min(w, h)
	local isq = math.min(sqmax * 0.125, sqmin * 0.5)

	StreamRadioLib.Surface.Loading( x + (w - isq) / 2, y + (h - isq) / 2, isq, isq, color, 8)
end

function CLASS:RenderIcon(icon)
	local colIcon = self.Colors.Icon or color_white

	local x, y = self:GetRenderPos()
	local p = self:GetPadding()
	x = x + p
	y = y + p

	local w, h = self:GetClientSize()

	local sqmax, sqmin = math.max(w, h), math.min(w, h)
	local isq = math.min(sqmax * 0.125, sqmin * 0.5)

	surface.SetDrawColor( colIcon:Unpack() )
	surface.SetMaterial( icon )
	surface.DrawTexturedRectUV( x + (w - isq) / 2, y + (h - isq) / 2, isq, isq, 0, 0, 1, 1 )
end

function CLASS:RenderSpectrumReplacement()
	local isPlayMode = self.StreamOBJ:IsPlayMode()
	self:RenderIcon(isPlayMode and g_mat_play or g_mat_pause)
end

function CLASS:Render()
	BASE.Render(self)

	local stream = self.StreamOBJ

	if not IsValid(stream) then return end

	if stream:GetMuted() then
		self:RenderIcon(g_mat_mute)
		return
	end

	if stream:IsKilled() then
		self:RenderIcon(g_mat_mute)
		return
	end

	if stream:IsLoading() then
		self:RenderLoader()
		return
	end

	if stream:IsCheckingUrl() then
		self:RenderLoader()
		return
	end

	if stream:IsBuffering() then
		self:RenderLoader()
		return
	end

	if stream:IsSeeking() then
		self:RenderLoader()
		return
	end

	if stream:IsStopMode() then
		self:RenderIcon(g_mat_stop)
		return
	end

	if StreamRadioLib.IsSpectrumHidden() then
		self:RenderSpectrumReplacement()
		return
	end

	local ent = self:GetEntity()
	if IsValid(ent) and ent.CanDrawSpectrum and not ent:CanDrawSpectrum() then
		self:RenderSpectrumReplacement()
		return
	end

	if not stream:IsPlayMode() then
		self:RenderIcon(g_mat_pause)
		return
	end

	self:RenderSpectrum()
end

function CLASS:ShouldPerformRerender()
	if SERVER then return false end

	local stream = self.StreamOBJ

	if stream:GetMuted() then
		return false
	end

	if stream:IsKilled() then
		return false
	end

	if stream:HasError() then
		return false
	end

	if stream:IsLoading() then
		return true
	end

	if stream:IsCheckingUrl() then
		return true
	end

	if stream:IsBuffering() then
		return true
	end

	if stream:IsSeeking() then
		return true
	end

	if StreamRadioLib.IsSpectrumHidden() then
		return false
	end

	local ent = self:GetEntity()
	if IsValid(ent) and ent.CanDrawSpectrum and not ent:CanDrawSpectrum() then
		return false
	end

	if not stream:IsPlaying() then
		return false
	end

	return true
end

if CLIENT then
	function CLASS:FastThink()
		self.fastThinkRate = 10

		if not IsValid(self.StreamOBJ) then return end

		self.fastThinkRate = 0.25

		if not self:IsSeen() then return end
		if not self:IsVisible() then return end

		if not self:ShouldPerformRerender() then return end

		self.fastThinkRate = 0
		self:PerformRerender(true)
	end
end

function CLASS:SetStream(stream)
	if self.StreamOBJ == stream then
		return
	end

	self.StreamOBJ = stream

	self:SetFastThinkRate(0)
end

function CLASS:GetStream()
	return self.StreamOBJ
end

return true


--PATH lua/streamradio_core/client/cl_lib.lua:
return gluapack()()
--PATH lua/streamradio_core/client/cl_lib.lua:

local LIBNet = StreamRadioLib.Net

local g_camPos = nil
local g_inRenderScene = false

StreamRadioLib.Hook.Add( "RenderScene", "CamInfo", function( origin, angles, fov )
	if not StreamRadioLib then return end
	if not StreamRadioLib.Loaded then return end
	if not StreamRadioLib.HasSpawnedRadios() then return end

	if g_inRenderScene then return end
	g_inRenderScene = true

	if StreamRadioLib.VR.IsActive() then
		g_camPos = nil
		g_inRenderScene = false

		return
	end

	g_camPos = origin
	g_inRenderScene = false
end )

local g_pressed = false
local g_lastradio = nil

local function ReleaseLastRadioControl()
	if not StreamRadioLib then return end
	if not StreamRadioLib.Loaded then return end
	if not StreamRadioLib.HasSpawnedRadios() then return end

	local ply = LocalPlayer()
	if not IsValid( ply ) then return end
	if not IsValid( g_lastradio ) then return end
	if not g_lastradio.__IsRadio then return end
	if not g_lastradio.Control then return end

	local wasPressed = g_pressed
	g_pressed = false

	if not wasPressed then return end

	local trace = StreamRadioLib.Trace( ply )

	LIBNet.Start("Control")
		net.WriteBool( false )
	net.SendToServer()

	StreamRadioLib.Control( ply, trace, false )
	g_lastradio = nil
end

local function GetPressed(ply)
	if StreamRadioLib.Util.GameIsPaused() then
		return false
	end

	if StreamRadioLib.VR.IsActive(ply) then
		-- Only allow if there is no focus on any menu
		if StreamRadioLib.VR.MenuIsOpen() then
			return false
		end

		-- Check if trigger is pressed
		if StreamRadioLib.VR.GetTriggerPressed() then
			return true
		end

		-- Or check if the player's right hand touches the radio
		if StreamRadioLib.VR.GetRadioTouched() then
			return true
		end

		return false
	end

	if gui.IsGameUIVisible() then
		return false
	end

	local inVehicle = ply.InVehicle and ply:InVehicle()

	local key = StreamRadioLib.GetControlKey()

	if inVehicle then
		key = StreamRadioLib.GetControlKeyVehicle()
	end

	if not key then
		return false
	end

	local pressed = input.IsButtonDown( key )
	return pressed
end

StreamRadioLib.Hook.Add("Think", "Control", function( )
	if not StreamRadioLib then return end
	if not StreamRadioLib.Loaded then return end
	if not StreamRadioLib.HasSpawnedRadios() then return end

	local ply = LocalPlayer()
	if not IsValid( ply ) then return end

	local pressed = GetPressed(ply)
	if g_pressed == pressed then return end

	if not pressed then
		ReleaseLastRadioControl()
		g_pressed = pressed
		return
	end
	g_pressed = pressed

	local trace = StreamRadioLib.Trace( ply )
	if not trace then
		ReleaseLastRadioControl()
		return
	end

	local Radio = trace.Entity
	if not IsValid( Radio ) then
		ReleaseLastRadioControl()
		return
	end

	if not Radio.__IsRadio then
		ReleaseLastRadioControl()
		return
	end

	if not Radio.Control then
		ReleaseLastRadioControl()
		return
	end

	if IsValid(g_lastradio) and Radio ~= g_lastradio then
		ReleaseLastRadioControl()
	end

	LIBNet.Start("Control")
		net.WriteBool( pressed )
	net.SendToServer()

	StreamRadioLib.Control( ply, trace, pressed )
	g_lastradio = Radio
end)

function StreamRadioLib.IsCursorEnabled()
	if StreamRadioLib.VR.IsActive() then
		return StreamRadioLib.Settings.GetConVarValue("vr_enable_cursor")
	end

	return StreamRadioLib.Settings.GetConVarValue("enable_cursor")
end

function StreamRadioLib.GetCameraViewPos(ply)
	local islocal = false

	if not IsValid(ply) then
		islocal = true
	end

	if ply == LocalPlayer() then
		islocal = true
	end

	if StreamRadioLib.VR.IsActive(ply) then
		local pos = StreamRadioLib.VR.GetCameraPos(ply)
		return pos
	end

	if not g_camPos or not islocal then
		local pos = StreamRadioLib.GetCameraPos(ply)
		return pos
	end

	return g_camPos
end

function StreamRadioLib.CalcDistanceVolume( distance, max )
	distance = distance or 0
	local threshold = 0.25
	max = math.min(max or 0, StreamRadioLib.GetMuteDistance())
	local min = (max or 0) / 3
	local fullmin = min / 4
	if min <= 0 then return 0 end
	if max <= 0 then return 0 end
	if distance > max then return 0 end
	if distance <= 0 then return 1 end
	if distance <= fullmin then return 1 end
	if distance <= min then return Lerp((distance - fullmin) / (min - fullmin), 1, threshold) end

	return Lerp((distance - min) / (max - min), threshold, 0)
end

return true


--PATH lua/streamradio_core/client/settings/vr.lua:
return gluapack()()
--PATH lua/streamradio_core/client/cl_playlist_edit.lua:
return gluapack()()
--PATH lua/streamradio_core/interfaces/cache.lua:
local RADIOIFACE = RADIOIFACE
if not istable( RADIOIFACE ) then
	StreamRadioLib.Interface.Load()
	return
end

RADIOIFACE.name = "Cache"
RADIOIFACE.priority = 99000
RADIOIFACE.online = false
RADIOIFACE.cache = true

RADIOIFACE.downloadTimeout = 0
RADIOIFACE.downloadFirst = false
RADIOIFACE.allowCaching = false

local LIBUrl = StreamRadioLib.Url
local LIBString = StreamRadioLib.String
local LIBCache = StreamRadioLib.Cache

function RADIOIFACE:CheckURL(url)
	if LIBUrl.IsOfflineURL(url) then
		return false
	end

	if not LIBCache.GetFile(url) then
		return false
	end

	return true
end

function RADIOIFACE:ParseURL(url)
	local cachefile = LIBCache.GetFile(url)

	if not cachefile then
		return nil
	end

	local urlResult = "data/" .. cachefile
	urlResult = LIBString.NormalizeSlashes(urlResult)

	return urlResult
end

function RADIOIFACE:Convert(url, callback)
	local path = self:ParseURL(url)

	if not path then
		callback(self, false)
		return
	end

	callback(self, true, path)
end

return true


--PATH lua/streamradio_core/interfaces/shoutcast.lua:
local RADIOIFACE = RADIOIFACE
if not istable( RADIOIFACE ) then
	StreamRadioLib.Interface.Load()
	return
end

RADIOIFACE.name = "SHOUTcast"
RADIOIFACE.priority = 100
RADIOIFACE.online = true
RADIOIFACE.cache = false

RADIOIFACE.downloadTimeout = 0
RADIOIFACE.downloadFirst = false
RADIOIFACE.allowCaching = false

local ERROR_NO_ID = 120000

StreamRadioLib.Error.AddStreamErrorCode({
	id = ERROR_NO_ID,
	name = "STREAM_ERROR_SHOUTCAST_NO_ID",
	description = "[SHOUTcast] Invalid stream ID",
	helptext = [[
An invalid stream ID was given.

Notes:
	- Make sure you enter a URL of an existing SHOUTcast stream.
	- The URL should look like this shoutcast://123456
	- Only numbers are supported.
]],
})

local ShoutcastPatterns = {
	"shoutcast%://([%d]+)",
}

local ShoutcastURLs = {
	"shoutcast://",
}

function RADIOIFACE:CheckURL(url)
	for i, v in ipairs(ShoutcastURLs) do
		local result = string.find(string.lower(url), v, 1, true)

		if not result then
			continue
		end

		return true
	end

	return false
end

function RADIOIFACE:ParseURL(url)
	for i, v in ipairs(ShoutcastPatterns) do
		local result = string.Trim(string.match(url, v) or "")

		if result == "" then
			continue
		end

		return result
	end

	return nil
end

function RADIOIFACE:Convert(url, callback)
	local id = self:ParseURL(url)

	if not id then
		callback(self, false, nil, ERROR_NO_ID)
		return
	end

	local streamUrl = StreamRadioLib.Shoutcast.GetStreamUrlById(id)
	callback(self, true, streamUrl)

	return
end

return true


--PATH lua/streamradio_core/filesystem/shoutcast.lua:
return gluapack()()
--PATH addons/[miecze] mexicano_drzewko/lua/autorun/sv_drzewo.lua:
if not SERVER then return end

util.AddNetworkString("drzewoderma")
util.AddNetworkString("DrzewoKupSkill") 
util.AddNetworkString("Drzewko_RequestTable")
util.AddNetworkString("Drzewko_SendTable")
util.AddNetworkString("DrzewoResetPunktow")

net.Receive("Drzewko_RequestTable", function(len, ply)
    if not IsValid(ply) then return end
    local teamData = RPExtraTeams[ply:Team()]
    if not teamData or (teamData.category ~= MX_CatJedi and teamData.jedi ~= true) then 
        return 
    
    end
    local data = ply:LoadData() 
    net.Start("Drzewko_SendTable")
    net.WriteTable(data)
    net.Send(ply) 
    --PrintTable(data)
end)

local function AlreadyHasItem(ply, skillPath)
    local inventory = ply:LoadData()
    for _, item in ipairs(inventory.kupione_upgradey) do
        if item == skillPath then
            return true
        end
    end
    return false
end

local function SkillPathContains(skillPath, keyword)
    return string.find(skillPath, keyword) ~= nil
end
local function StripSkillPathPrefix(skillPath)
    return skillPath:gsub("^item_stance_", ""):gsub("^item_force_", "")
end

net.Receive("DrzewoKupSkill", function(len, ply)
    local skillPath = net.ReadString()
    local skillCost, skillTier, skillSubcategory = nil, nil, nil

    for _, skill in ipairs(MX_LSCS.Moce) do
        if skill.sciezka == skillPath then
            skillCost = skill.cost
            skillTier = skill.tier
            skillSubcategory = skill.subcategory
            break
        end
    end

    if not skillPath or not skillCost or not skillTier then return end

    local teamData = RPExtraTeams[ply:Team()]
    if not teamData or (teamData.category ~= MX_CatJedi and teamData.jedi ~= true) then 
        return 
    end

    if AlreadyHasItem(ply, skillPath) then
        ply:ChatPrint("Już posiadasz tę moc w swoim ekwipunku!")
        return
    end

    local inventory = ply:LoadData()
    local hasPreviousTier = false

    if skillTier > 1 then
        for _, skill in ipairs(MX_LSCS.Moce) do
            if skill.subcategory == skillSubcategory and skill.tier == skillTier - 1 then
                if AlreadyHasItem(ply, skill.sciezka) then
                    hasPreviousTier = true
                    break
                end
            end
        end

        if not hasPreviousTier then
            ply:ChatPrint("Musisz najpierw kupić wcześniejszy poziom tej mocy!")
            return
        end
    end

     
    if skillCost > ply:GetNWInt("jedi_punkty") then 
        if skillCost != 0 then
        --print("gagatek: ".. ply:Nick()) 
        return 
        end
    end
   

    if SkillPathContains(skillPath, "mocpoj") then
      
    elseif SkillPathContains(skillPath, "mocregen") then
        
    elseif SkillPathContains(skillPath, "hp") then
        
    elseif SkillPathContains(skillPath, "armor") then
        
    else
        ply:lscsAddInventory(skillPath, nil)
    end

    
    ply:addPunkty(-skillCost)
    table.insert(inventory.kupione_upgradey, skillPath)
    ply:SaveData(inventory)
    ply:lscsWriteInventory()

    ply:ChatPrint("Zakupiono moc: " .. skillPath .. " za " .. skillCost .. " punktów doświadczenia!")
end)

net.Receive("DrzewoResetPunktow", function(len, ply)
    local teamData = RPExtraTeams[ply:Team()]
    if not teamData or (teamData.category ~= MX_CatJedi and teamData.jedi ~= true) then 
        return 
    end

    local inventory = ply:LoadData()
    local totalRefundXP = 0

    for _, skillPath in ipairs(inventory.kupione_upgradey) do
        if SkillPathContains(skillPath, "hp") or SkillPathContains(skillPath, "armor") or SkillPathContains(skillPath, "mocpoj") or SkillPathContains(skillPath, "mocregen") then
            for _, skill in ipairs(MX_LSCS.Moce) do
                if skill.sciezka == skillPath then
                    totalRefundXP = totalRefundXP + (skill.cost or 0)
                    break
                end
            end
        end
        for _, skill in ipairs(MX_LSCS.Moce) do
            if skill.sciezka == skillPath then
                
                --print("Sprawdzanie: " .. skillPath)

                
                local playerInventory = ply:lscsGetInventory()
                
                for id, item in pairs(playerInventory) do
                    --print("id: ".. id.. " item: ".. item.. " skillPath: ".. skillPath)
                    if item == skillPath then
                        --print("Usuwanie przedmiotu z ID: " .. id)
                        ply:lscsRemoveItem(id)
                        totalRefundXP = totalRefundXP + (skill.cost or 0)
                        
                    end
                end
               

                break
            end
        end
    end


    inventory.kupione_upgradey = {}
    
    ply:SaveData(inventory)

    ply:lscsWriteInventory()
    ply:addPunkty(totalRefundXP)
    ply:SetNWInt("jedi_punkty", ply:getPunkty())

    ply:ChatPrint("Zresetowano wszystkie punkty i zwrócono " .. totalRefundXP .. " Punktów doświadczenia.")
end)
--PATH lua/autorun/sv_tracer_count.lua:
return gluapack()()
--PATH lua/autorun/swrc_particles_autorun.lua:
return gluapack()()
--PATH lua/autorun/swrc_particles_autorun.lua:
AddCSLuaFile()
game.AddParticles( "particles/swrc/astw2_swrc_pack_explosions.pcf" )
game.AddParticles( "particles/swrc/astw2_swrc_pack_muzzle_effects.pcf" )
PrecacheParticleSystem( "astw2_swrc_muzzle_cis_blaster" )
PrecacheParticleSystem( "astw2_swrc_muzzle_cis_blaster_heavy" )
PrecacheParticleSystem( "astw2_swrc_muzzle_geo_elite_beam" )
PrecacheParticleSystem( "astw2_swrc_muzzle_rep_aa" )
PrecacheParticleSystem( "astw2_swrc_muzzle_rep_blaster" )
PrecacheParticleSystem( "astw2_swrc_muzzle_rep_pistol" )
PrecacheParticleSystem( "astw2_swrc_muzzle_rep_sniper" )
PrecacheParticleSystem( "astw2_swrc_muzzle_trando_conc_rifle" )
PrecacheParticleSystem( "astw2_swrc_muzzle_trando_minigun" )
PrecacheParticleSystem( "astw2_swrc_muzzle_trando_shotgun" )
PrecacheParticleSystem( "astw2_swrc_muzzle_trando_smg" )
PrecacheParticleSystem( "astw2_swrc_muzzle_wookie_bowcaster" )
PrecacheParticleSystem( "astw2_swrc_muzzle_wookie_rocket" )
PrecacheParticleSystem( "astw2_swrc_explosion_rep_aa" )
PrecacheParticleSystem( "astw2_swrc_explosion_emp" )
PrecacheParticleSystem( "astw2_swrc_explosion_geo_det" )
PrecacheParticleSystem( "astw2_swrc_explosion_stun_det" )
PrecacheParticleSystem( "astw2_swrc_explosion_thermal_det" )
PrecacheParticleSystem( "astw2_swrc_explosion_conc_rifle" )
PrecacheParticleSystem( "astw2_swrc_explosion_wookie_rocket" )
game.AddParticles( "particles/gb5_emp.pcf") 
game.AddParticles( "particles/gb5_littleboy.pcf") 
game.AddParticles( "particles/gb5_fatman.pcf") 
game.AddParticles( "particles/gb5_trinity_explo.pcf") 
game.AddParticles( "particles/gb5_blackhole.pcf") 
game.AddParticles( "particles/gb5_redmatter.pcf") 
game.AddParticles( "particles/gb5_idle_special.pcf")  
game.AddParticles( "particles/gb5_large_explosion.pcf")  
game.AddParticles( "particles/gb5_high_explosive.pcf")  
game.AddParticles( "particles/gb5_poison_gas.pcf")  
game.AddParticles( "particles/gb5_wildfire_vial.pcf")  
game.AddParticles( "particles/gb5_fireball.pcf")  
game.AddParticles( "particles/gb5_fireball_wildfire.pcf")  
game.AddParticles( "particles/gb5_fireboom.pcf")  
game.AddParticles( "particles/gb5_grable.pcf")  
game.AddParticles( "particles/gb5_nitro.pcf")  
game.AddParticles( "particles/gb5_napalm.pcf")  
game.AddParticles( "particles/gb5_500lb.pcf")  
game.AddParticles( "particles/gb5_1000lb.pcf")  
game.AddParticles( "particles/gb5_mini_can.pcf")  
game.AddParticles( "particles/gb5_c4.pcf")  
game.AddParticles( "particles/gb5_highyield_nuke.pcf")  
game.AddParticles( "particles/gb5_antimatter_idle.pcf")  
game.AddParticles( "particles/gb5_antimatter_natsu.pcf") 
game.AddParticles( "particles/gb5_exoendo.pcf") 
game.AddParticles( "particles/gb5_fissionbomb.pcf") 
game.AddParticles( "particles/gb5_vx_gas.pcf") 
game.AddParticles( "particles/gb5_tsar_bomba.pcf") 
game.AddParticles( "particles/gb5_fusionbomb.pcf") 
game.AddParticles( "particles/gb5_super_hyper.pcf") 
game.AddParticles( "particles/gb5_rep_attr.pcf") 
game.AddParticles( "particles/gb5_singularity_bomb.pcf") 
game.AddParticles( "particles/gb5_steam_explosion.pcf") 
game.AddParticles( "particles/gb5_light_bomb.pcf") 
game.AddParticles( "particles/gb5_tvirus.pcf") 
game.AddParticles( "particles/gb5_propellant_petrolium.pcf") 
game.AddParticles( "particles/gb5_propellant_oxykerosine.pcf") 
game.AddParticles( "particles/gb5_propellant_hydrogen.pcf") 
game.AddParticles( "particles/gb5_propellant_antimatter.pcf") 
game.AddParticles( "particles/gb5_propellant_trilithium.pcf") 
game.AddParticles( "particles/gb5_davycrockett.pcf")
game.AddParticles( "particles/gb5_liqtiberium.pcf")
game.AddParticles( "particles/gb5_high_explosive_2.pcf")  
game.AddParticles( "particles/gb5_jdam.pcf")  
game.AddParticles( "particles/gb5_icbm_trail.pcf")  
game.AddParticles( "particles/gb5_icbm_small.pcf")  
game.AddParticles( "particles/gb5_tomahawk_trail.pcf")  
game.AddParticles( "particles/gb5_chlorine_gas.pcf")  
game.AddParticles( "particles/gb5_photon_torpedo.pcf")
game.AddParticles( "particles/gb5_50lb.pcf")
game.AddParticles( "particles/gb5_100lb.pcf")
game.AddParticles( "particles/gb5_v2.pcf")
game.AddParticles( "particles/gb5_v2_rocket.pcf")
game.AddParticles( "particles/gb5_tvirus_splash.pcf")
--PATH addons/[chat] talk-modes/lua/autorun/talkmodes_load.lua:
--[[-------------------------------------------

    Talk Modes - whisper/talk/yell 

    Licensed to 76561198327810923
	Version: 1.1.1

	By: SaturdaysHeroes & Djuk
	Special thanks to CupCakeR.

--]]-------------------------------------------
TalkModes = TalkModes || {}

local function Log(sMessage)
	MsgC(Color(255, 0, 0), "[Talk Modes] ", Color(255, 255, 255), string.format("%s.", sMessage.."\n"))
end

local function LoadClientFile(sFile)
	if (SERVER) then AddCSLuaFile(sFile) return end

	include(sFile)
	Log(string.format("Loaded file: %s (client)", sFile))
end

local function LoadSharedFile( sFile )
	AddCSLuaFile(sFile)
	include(sFile)
	Log(string.format("Loaded file: %s (shared)", sFile))
end

local function LoadServerFile( sFile )
	if (CLIENT) then return end

	include( sFile )
	Log(string.format("Loaded file: %s (server)", sFile))
end

local function LoadDirectory( wildCard )
	local wildCard = ( wildCard and ( wildCard .. "/*" ) or "*" )
	local tblFiles, tblDirectories = file.Find( wildCard, "LUA")

	for _, sFile in ipairs( tblFiles ) do
		local wildCard = string.TrimRight( wildCard, "/*" )
		if ( !string.EndsWith( sFile, ".lua" ) ) then continue end

		if ( string.StartWith( sFile, "cl_" ) ) then
			LoadClientFile( wildCard .. "/" .. sFile )
		elseif ( string.StartWith( sFile, "sv_" ) ) then
			LoadServerFile( wildCard .. "/" .. sFile )
		else
			LoadSharedFile( wildCard .. "/" .. sFile )
		end
	end

	for _, sDirectory in ipairs( tblDirectories ) do
		local wildCard = string.TrimRight( wildCard, "*" ) .. sDirectory

		LoadDirectory( wildCard )
	end
end

Log("Loading Talk Modes - version 1.1.1")

-- Config
LoadServerFile("talk_modes/config/sv_config.lua")
LoadSharedFile("talk_modes/config/sh_config.lua")

-- Language
LoadSharedFile("talk_modes/language/sh_languages.lua")
LoadDirectory("talk_modes/language")

-- Core
LoadSharedFile("talk_modes/core/sh_core.lua")
LoadServerFile("talk_modes/core/sv_core.lua")
LoadClientFile("talk_modes/core/cl_core.lua")

-- Networking
LoadServerFile("talk_modes/networking/sv_net.lua")
LoadClientFile("talk_modes/networking/cl_net.lua")

-- VGUI
LoadDirectory("talk_modes/vgui")

Log("Loaded Talk Modes - version 1.1.1")

--PATH addons/[chat] talk-modes/lua/talk_modes/config/sh_config.lua:
--[[-------------------------------------------

    Talk Modes - whisper/talk/yell 

    Licensed to 76561198327810923
	Version: 1.1.1

	By: SaturdaysHeroes & Djuk
	Special thanks to CupCakeR

--]]-------------------------------------------
TalkModes = TalkModes || {}
TalkModes.Config = TalkModes.Config || {}

-- Ranks allowed to open in-game config
TalkModes.Config.AllowedRanks = {
    ["superadmin"] = true
}

-- List of commands to open the in-game config. 
TalkModes.Config.ConfigCommands = {
    ["!talkmodes"] = true,
    ["/talkmodes"] = true
}

-- Please do not change anything beyond this point, it could potentially break the script. 
-- All of the script functionality is based around these two functions, I will not help if this is modified. 
function TalkModes.Config:GetSetting(strTable, strSetting)
    if (SERVER) then 
        return self.Server[strTable][strSetting]
    else
        return self.Client[strTable][strSetting]
    end
end

function TalkModes.Config:GetTable(strTable)
    if (SERVER) then 
        return self.Server[strTable]
    else
        return self.Client[strTable]
    end
end
--PATH addons/[chat] talk-modes/lua/talk_modes/language/sh_languages.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/language/sh_french.lua:
--[[-------------------------------------------

    Talk Modes - whisper/talk/yell 

    Licensed to 76561198327810923
	Version: 1.1.1

	By: SaturdaysHeroes & Djuk
	Special thanks to CupCakeR

--]]-------------------------------------------

local LANGUAGE = {}
LANGUAGE["General"] = "Général"
LANGUAGE["Theme"] = "Thème"
LANGUAGE["Modes"] = "Modes"
LANGUAGE["Whisper"] = "Chuchotement"
LANGUAGE["Whisper_Desc"] = "Quelle distance le chuchotement doit-il atteindre ?"
LANGUAGE["Yell"] = "Hurler"
LANGUAGE["Yell_Desc"] = "Quelle distance le hurlement doit-il atteindre ?"
LANGUAGE["Talk"] = "Parler" 
LANGUAGE["Talk_Desc"] = "Quelle distance le parler doit-il atteindre ?"
LANGUAGE["3D Voice"] = "Voix 3D"
LANGUAGE["3D Voice_Desc"] = "La voix 3D doit-elle être activée ?"
LANGUAGE["Language"] = "Langue"
LANGUAGE["Language_Desc"] = "Quelle langue doit être utilisée ?"
LANGUAGE["Selection Key"] = "Touche de sélection"
LANGUAGE["Selection Key_Desc"] = "Quelle touche doit ouvrir le menu de sélection ?"
LANGUAGE["Talking Dead"] = "Parler en étant mort"
LANGUAGE["Talking Dead_Desc"] = "Les morts devraient-ils pouvoir parler ?"
LANGUAGE["Selection Menu Position"] = "Position du menu de sélection"
LANGUAGE["Selection Menu Position_Desc"] = "Où doit se trouver le menu ?"
LANGUAGE["Save"] = "Sauvegarder"
LANGUAGE["Reset"] = "Réinitialiser"
LANGUAGE["Preview"] = "Aperçu"
LANGUAGE["PreviewHeader"] = "APPUYER SUR [%s] POUR QUITTER L'APERÇU"
LANGUAGE["PreviewText"] = "APERÇU EN DIRECT D'UNE PORTÉE DE: %s UNITS"
LANGUAGE["Background"] = "Arrière-plan"
LANGUAGE["Background_Desc"] = "Quelle couleur doit être utilisée pour l'arrière-plan ?"
LANGUAGE["Foreground"] = "Premier plan"
LANGUAGE["Foreground_Desc"] = "Quelle couleur doit être utilisée pour le premier plan ?"
LANGUAGE["Hover"] = "Accentuée"
LANGUAGE["Hover_Desc"] = "Quelle couleur doit être utilisée pour l'accentuation ?"
LANGUAGE["White"] = "Blanc"
LANGUAGE["White_Desc"] = "Quelle couleur doit être utilisée comme blanc ?"
LANGUAGE["Gray"] = "Gris"
LANGUAGE["Gray_Desc"] = "Quelle couleur doit être utilisée comme gris ?"
LANGUAGE["WelcomeMessage"] = "Ce serveur utilise le script Talk Modes, maintenez %s pour sélectionner votre mode de conversation !"
LANGUAGE["Turn Off"] = "Éteindre"
LANGUAGE["Using Mode"] = "Façon de parler"
LANGUAGE["Auto-Hide"] = "Masquer automatiquement"
LANGUAGE["Auto-Hide_Desc"] = "Le menu de sélection doit-il se masquer automatiquement lorsqu'il n'est pas utilisé ?"
LANGUAGE["Mode Change Message"] = "Mode Notification"
LANGUAGE["Mode Change Message_Desc"] = "Should players be notified when their talk mode is changed?"

TalkModes.Languages:Register("Français", LANGUAGE)
--PATH addons/[chat] talk-modes/lua/talk_modes/language/sh_russian.lua:
--[[-------------------------------------------

    Talk Modes - whisper/talk/yell 

    Licensed to 76561198327810923
	Version: 1.1.1

	By: SaturdaysHeroes & Djuk
	Special thanks to CupCakeR

--]]-------------------------------------------
local LANGUAGE = {}
LANGUAGE["General"] = "Основные"
LANGUAGE["Theme"] = "Тема"
LANGUAGE["Modes"] = "Режимы"
LANGUAGE["Whisper"] = "Шепот"
LANGUAGE["Whisper_Desc"] = "На какой дистанции работает Шепот?"
LANGUAGE["Yell"] = "Крик"
LANGUAGE["Yell_Desc"] = "На какой дистанции работает Крик?"
LANGUAGE["Talk"] = "Говор" 
LANGUAGE["Talk_Desc"] = "На какой дистанции работает Говор?"
LANGUAGE["3D Voice"] = "3D Голос"
LANGUAGE["3D Voice_Desc"] = "Должен ли 3D Голос быть включен?"
LANGUAGE["Language"] = "Язык"
LANGUAGE["Language_Desc"] = "Какой язык следует использовать?"
LANGUAGE["Selection Key"] = "Кнопка выбора"
LANGUAGE["Selection Key_Desc"] = "Какая кнопка должна открыть меню выбора?"
LANGUAGE["Talking Dead"] = "Говорящие мертвецы"
LANGUAGE["Talking Dead_Desc"] = "Должны ли мертвые люди говорить?"
LANGUAGE["Selection Menu Position"] = "Позиция меню выбора"
LANGUAGE["Selection Menu Position_Desc"] = "Где должно находиться меню на экране?"
LANGUAGE["Save"] = "Сохранить"
LANGUAGE["Reset"] = "Сбросить"
LANGUAGE["Preview"] = "Предпросмотр"
LANGUAGE["PreviewHeader"] = "НАЖМИТЕ [%f] ЧТОБЫ ЗАКРЫТЬ ПРЕДПРОСМОТР"
LANGUAGE["PreviewText"] = "ТЕКУЩАЯ ДИСТАНЦИЯ ПРЕДПРОСМОТРА: %s ЮНИТОВ"
LANGUAGE["Background"] = "Фон"
LANGUAGE["Background_Desc"] = "Выберете цвет фона"
LANGUAGE["Foreground"] = "Передний план"
LANGUAGE["Foreground_Desc"] = "Выберете цвет переднего плана"
LANGUAGE["Hover"] = "Акцент"
LANGUAGE["Hover_Desc"] = "Выберете цвет выделенного текста"
LANGUAGE["White"] = "Белый"
LANGUAGE["White_Desc"] = "Выберете цвет вместо белого"
LANGUAGE["Gray"] = "Серый"
LANGUAGE["Gray_Desc"] = "Выберете цвет вместо серого"
LANGUAGE["WelcomeMessage"] = "Этот сервер использует скрипт Talk Modes, удерживайте %s, чтобы сменить режим разговора!"
LANGUAGE["Turn Off"] = "Отключить"
LANGUAGE["Using Mode"] = "Режим использования"
LANGUAGE["Auto-Hide"] = "Скрывать автоматически"
LANGUAGE["Auto-Hide_Desc"] = "Скрывать меню выбора автоматически если не используется?"
LANGUAGE["Mode Change Message"] = "Mode Notification"
LANGUAGE["Mode Change Message_Desc"] = "Should players be notified when their talk mode is changed?"

TalkModes.Languages:Register("Русский", LANGUAGE)
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/cl_preview.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_docker.lua:
local THEME = TalkModes.Client.ActiveTheme

local PANEL = {}
function PANEL:Init()
    self.bChanging = false
    self.base = self:GetParent()
end

function PANEL:ChangePage(strPage, bFade)
    if (self.base:GetLoadedPanel() == strPage) then return end
    if (self.bChanging) then return end
    if !(self.page) then
        self.page = self:Add(strPage)
        self.page:Dock(FILL)
        return
    end
    if (bFade) then
        self.bChanging = true
        self.page:AlphaTo(0, 0.2, 0, function()
            self:Clear()

            self.page = self:Add(strPage)
            self.page:Dock(FILL)
            self.page:SetAlpha(0)
            self.page:AlphaTo(255, 0.2, 0, function()
                self.bChanging = false
            end)
        end)
    else
        self:Clear()
        self.page = self:Add(strPage)
        self.page:Dock(FILL)
    end
end


function PANEL:Paint(intW, intH)
    draw.RoundedBoxEx(8, 0, 0, intW, intH, THEME["Foreground"], false, false, false, true)
end

vgui.Register("TalkModes.Docker", PANEL, "DPanel")
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/libs/cl_circles.lua:
return gluapack()()
--PATH lua/autorun/textscreens_util.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_commands.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_commands.lua:
local function CreateReplConVar(cvarname, cvarvalue, description, ...)
	return CreateConVar(cvarname, cvarvalue, CLIENT and {FCVAR_REPLICATED} or {FCVAR_REPLICATED, FCVAR_ARCHIVE, FCVAR_NOTIFY}, description, ...)
end -- replicated only on clients, archive/notify on server

-- Shared Convars

if GetConVar("sv_tfa_changelog") == nil then
	CreateReplConVar("sv_tfa_changelog", "1", "Enable changelog?")
end

if GetConVar("sv_tfa_soundscale") == nil then
	CreateReplConVar("sv_tfa_soundscale", "1", "Scale sound pitch in accordance to timescale?")
end

if GetConVar("sv_tfa_weapon_strip") == nil then
	CreateReplConVar("sv_tfa_weapon_strip", "0", "Allow the removal of empty weapons?")
end

if GetConVar("sv_tfa_spread_legacy") == nil then
	CreateReplConVar("sv_tfa_spread_legacy", "0", "Use legacy spread algorithms?")
end

if GetConVar("sv_tfa_cmenu") == nil then
	CreateReplConVar("sv_tfa_cmenu", "1", "Allow custom context menu?")
end

if GetConVar("sv_tfa_cmenu_key") == nil then
	CreateReplConVar("sv_tfa_cmenu_key", "-1", "Override the inspection menu key?  Uses the KEY enum available on the gmod wiki. -1 to not.")
end

if GetConVar("sv_tfa_range_modifier") == nil then
	CreateReplConVar("sv_tfa_range_modifier", "0.5", "This controls how much the range affects damage.  0.5 means the maximum loss of damage is 0.5.")
end

if GetConVar("sv_tfa_allow_dryfire") == nil then
	CreateReplConVar("sv_tfa_allow_dryfire", "1", "Allow dryfire?")
end

if GetConVar("sv_tfa_penetration_hardlimit") == nil then
	CreateReplConVar("sv_tfa_penetration_hardlimit", "100", "Max number of objects we can penetrate through.")
end

if GetConVar("sv_tfa_bullet_penetration_power_mul") == nil then
	CreateReplConVar("sv_tfa_bullet_penetration_power_mul", "1", "Power multiplier. 1 or 1.5 for CS 1.6 experience, 0.25 for semi-realistic behavior")
end

if GetConVar("sv_tfa_penetration_hitmarker") == nil then
	CreateReplConVar("sv_tfa_penetration_hitmarker", "1", "Should penetrating bullet send hitmarker to attacker?")
end

if GetConVar("sv_tfa_damage_multiplier") == nil then
	CreateReplConVar("sv_tfa_damage_multiplier", "1", "Multiplier for TFA base projectile damage.")
end

if GetConVar("sv_tfa_damage_multiplier_npc") == nil then
	CreateReplConVar("sv_tfa_damage_multiplier_npc", "1", "Multiplier for TFA base projectile damage for NPCs.")
end

if GetConVar("sv_tfa_damage_mult_min") == nil then
	CreateReplConVar("sv_tfa_damage_mult_min", "0.95", "This is the lower range of a random damage factor.")
end

if GetConVar("sv_tfa_damage_mult_max") == nil then
	CreateReplConVar("sv_tfa_damage_mult_max", "1.05", "This is the higher range of a random damage factor.")
end

if GetConVar("sv_tfa_melee_damage_npc") == nil then
	CreateReplConVar("sv_tfa_melee_damage_npc", "1", "Damage multiplier against NPCs using TFA Melees.")
end

if GetConVar("sv_tfa_melee_damage_ply") == nil then
	CreateReplConVar("sv_tfa_melee_damage_ply", "0.65", "Damage multiplier against players using TFA Melees.")
end

if GetConVar("sv_tfa_melee_blocking_timed") == nil then
	CreateReplConVar("sv_tfa_melee_blocking_timed", "1", "Enable timed blocking?")
end

if GetConVar("sv_tfa_melee_blocking_anglemult") == nil then
	CreateReplConVar("sv_tfa_melee_blocking_anglemult", "1", "Players can block attacks in an angle around their view.  This multiplies that angle.")
end

if GetConVar("sv_tfa_melee_blocking_deflection") == nil then
	CreateReplConVar("sv_tfa_melee_blocking_deflection", "1", "For weapons that can deflect bullets ( e.g. certain katans ), can you deflect bullets?  Set to 1 to enable for parries, or 2 for all blocks.")
end

if GetConVar("sv_tfa_melee_blocking_timed") == nil then
	CreateReplConVar("sv_tfa_melee_blocking_timed", "1", "Enable timed blocking?")
end

if GetConVar("sv_tfa_melee_blocking_stun_enabled") == nil then
	CreateReplConVar("sv_tfa_melee_blocking_stun_enabled", "1", "Stun NPCs on block?")
end

if GetConVar("sv_tfa_melee_blocking_stun_time") == nil then
	CreateReplConVar("sv_tfa_melee_blocking_stun_time", "0.65", "How long to stun NPCs on block.")
end

if GetConVar("sv_tfa_melee_doordestruction") == nil then
	CreateReplConVar("sv_tfa_melee_doordestruction", "1", "Allow players to bash open doors?")
end

if GetConVar("sv_tfa_door_respawn") == nil then
	CreateReplConVar("sv_tfa_door_respawn", "-1", "Time for doors to respawn; -1 for never.")
end

if GetConVar("sv_tfa_npc_randomize_atts") == nil then
	CreateReplConVar("sv_tfa_npc_randomize_atts", "1", "Randomize NPC's weapons attachments.")
end

local cv_dfc
if GetConVar("sv_tfa_default_clip") == nil then
	cv_dfc = CreateReplConVar("sv_tfa_default_clip", "-1", "How many clips will a weapon spawn with? Negative reverts to default values.")
else
	cv_dfc = GetConVar("sv_tfa_default_clip")
end

local function TFAUpdateDefaultClip()
	local dfc = cv_dfc:GetInt()
	local weplist = weapons.GetList()
	if not weplist or #weplist <= 0 then return end

	for _, v in pairs(weplist) do
		local cl = v.ClassName and v.ClassName or v
		local wep = weapons.GetStored(cl)

		if wep and (wep.IsTFAWeapon or string.find(string.lower(wep.Base and wep.Base or ""), "tfa")) then
			if not wep.Primary then
				wep.Primary = {}
			end

			if not wep.Primary.TrueDefaultClip then
				wep.Primary.TrueDefaultClip = wep.Primary.DefaultClip
			end

			if not wep.Primary.TrueDefaultClip then
				wep.Primary.TrueDefaultClip = 0
			end

			if dfc < 0 then
				wep.Primary.DefaultClip = wep.Primary.TrueDefaultClip
			else
				if wep.Primary.ClipSize and wep.Primary.ClipSize > 0 then
					wep.Primary.DefaultClip = wep.Primary.ClipSize * dfc
				else
					wep.Primary.DefaultClip = wep.Primary.TrueDefaultClip * 1
				end
			end
		end
	end
end

hook.Add("InitPostEntity", "TFADefaultClipPE", TFAUpdateDefaultClip)

if TFAUpdateDefaultClip then
	TFAUpdateDefaultClip()
end

--if GetConVar("sv_tfa_default_clip") == nil then

cvars.AddChangeCallback("sv_tfa_default_clip", function(convar_name, value_old, value_new)
	TFAUpdateDefaultClip()
end, "TFAUpdateDefaultClip")

local function sv_tfa_range_modifier()
	for k, v in ipairs(ents.GetAll()) do
		if v.IsTFAWeapon and v.Primary_TFA.RangeFalloffLUT_IsConverted then
			v.Primary_TFA.RangeFalloffLUT = nil
			v:AutoDetectRange()
		end
	end
end

cvars.AddChangeCallback("sv_tfa_range_modifier", sv_tfa_range_modifier, "TFA")

sv_tfa_range_modifier()

if CLIENT then
	hook.Add("InitPostEntity", "sv_tfa_range_modifier", sv_tfa_range_modifier)
end

--end
if GetConVar("sv_tfa_unique_slots") == nil then
	CreateReplConVar("sv_tfa_unique_slots", "1", "Give TFA-based Weapons unique slots? 1 for true, 0 for false. RESTART AFTER CHANGING.")
end

if GetConVar("sv_tfa_spread_multiplier") == nil then
	CreateReplConVar("sv_tfa_spread_multiplier", "1", "Increase for more spread, decrease for less.")
end

if GetConVar("sv_tfa_force_multiplier") == nil then
	CreateReplConVar("sv_tfa_force_multiplier", "1", "Arrow force multiplier (not arrow velocity, but how much force they give on impact).")
end

if GetConVar("sv_tfa_recoil_multiplier") == nil then
	CreateReplConVar("sv_tfa_recoil_multiplier", "1", "Recoil multiplier")
end

if GetConVar("sv_tfa_knockback_multiplier") == nil then
	CreateReplConVar("sv_tfa_knockback_multiplier", "1", "Knockback force multiplier")
end

if GetConVar("sv_tfa_dynamicaccuracy") == nil then
	CreateReplConVar("sv_tfa_dynamicaccuracy", "1", "Dynamic acuracy?  (e.g.more accurate on crouch, less accurate on jumping.")
end

if GetConVar("sv_tfa_ammo_detonation") == nil then
	CreateReplConVar("sv_tfa_ammo_detonation", "1", "Ammo Detonation?  (e.g. shoot ammo until it explodes) ")
end

if GetConVar("sv_tfa_ammo_detonation_mode") == nil then
	CreateReplConVar("sv_tfa_ammo_detonation_mode", "2", "Ammo Detonation Mode?  (0=Bullets,1=Blast,2=Mix) ")
end

if GetConVar("sv_tfa_ammo_detonation_chain") == nil then
	CreateReplConVar("sv_tfa_ammo_detonation_chain", "1", "Ammo Detonation Chain?  (0=Ammo boxes don't detonate other ammo boxes, 1 you can chain them together) ")
end

if GetConVar("sv_tfa_scope_gun_speed_scale") == nil then
	CreateReplConVar("sv_tfa_scope_gun_speed_scale", "0", "Scale player sensitivity based on player move speed?")
end

if GetConVar("sv_tfa_bullet_penetration") == nil then
	CreateReplConVar("sv_tfa_bullet_penetration", "1", "Allow bullet penetration?")
end

if GetConVar("sv_tfa_bullet_doordestruction") == nil then
	CreateReplConVar("sv_tfa_bullet_doordestruction", "1", "Allow to shoot down doors?")
end

if GetConVar("sv_tfa_bullet_doordestruction_keep") == nil then
	CreateReplConVar("sv_tfa_bullet_doordestruction_keep", "0", "Don't shoot door off hinges")
end

if GetConVar("sv_tfa_npc_burst") == nil then
	CreateReplConVar("sv_tfa_npc_burst", "0", "Whenever NPCs should fire in bursts like they do with HL2 weapons.")
end

if GetConVar("sv_tfa_bullet_ricochet") == nil then
	CreateReplConVar("sv_tfa_bullet_ricochet", "0", "Allow bullet ricochet?")
end

if GetConVar("sv_tfa_bullet_randomseed") == nil then
	CreateReplConVar("sv_tfa_bullet_randomseed", "0", "Populate extra seed serverside? This will cause spread to be out of sync with server!")
end

if GetConVar("sv_tfa_debug") == nil then
	CreateReplConVar("sv_tfa_debug", "0", "Enable debug mode?")
end

if GetConVar("sv_tfa_holdtype_dynamic") == nil then
	CreateReplConVar("sv_tfa_holdtype_dynamic", "1", "Allow dynamic holdtype?")
end

if GetConVar("sv_tfa_arrow_lifetime") == nil then
	CreateReplConVar("sv_tfa_arrow_lifetime", "30", "Arrow lifetime.")
end

if GetConVar("sv_tfa_worldmodel_culldistance") == nil then
	CreateReplConVar("sv_tfa_worldmodel_culldistance", "-1", "-1 to leave unculled.  Anything else is feet*16.")
end

if GetConVar("sv_tfa_reloads_legacy") == nil then
	CreateReplConVar("sv_tfa_reloads_legacy", "0", "Enable legacy-style reloading?")
end

if GetConVar("sv_tfa_recoil_legacy") == nil then
	CreateReplConVar("sv_tfa_recoil_legacy", "0", "Enable legacy-style recoil? This will cause prediction issues in multiplayer. Always disabled for NPCs!")
end

if GetConVar("sv_tfa_recoil_mul_p") == nil then
	CreateReplConVar("sv_tfa_recoil_mul_p", "1", "Pitch kick multiplier for recoil")
end

if GetConVar("sv_tfa_recoil_mul_y") == nil then
	CreateReplConVar("sv_tfa_recoil_mul_y", "1", "Yaw kick multiplier for recoil")
end

if GetConVar("sv_tfa_recoil_mul_p_npc") == nil then
	CreateReplConVar("sv_tfa_recoil_mul_p_npc", "1", "Pitch kick multiplier for recoil for NPCs")
end

if GetConVar("sv_tfa_recoil_mul_y_npc") == nil then
	CreateReplConVar("sv_tfa_recoil_mul_y_npc", "1", "Yaw kick multiplier for recoil for NPCs")
end

if GetConVar("sv_tfa_recoil_viewpunch_mul") == nil then
	CreateReplConVar("sv_tfa_recoil_viewpunch_mul", "1", "Multiplier for viewpunch recoil (visual viewmodel recoil)")
end

if GetConVar("sv_tfa_recoil_eyeangles_mul") == nil then
	CreateReplConVar("sv_tfa_recoil_eyeangles_mul", "1", "Multiplier for eye angles recoil (real angle change recoil)")
end

if GetConVar("sv_tfa_fx_penetration_decal") == nil then
	CreateReplConVar("sv_tfa_fx_penetration_decal", "1", "Enable decals on the other side of a penetrated object?")
end

local cv_ironsights = GetConVar("sv_tfa_ironsights_enabled")

if cv_ironsights == nil then
	cv_ironsights = CreateReplConVar("sv_tfa_ironsights_enabled", "1", "Enable ironsights? Disabling this still allows scopes.")
end

local is_stats = {
	["data.ironsights"] = 0,
	["Secondary.IronSightsEnabled"] = false,
}

hook.Add("TFA_GetStat", "TFA_IronsightsConVarToggle", function(wep, stat, val)
	if not IsValid(wep) or is_stats[stat] == nil then return end

	if not cv_ironsights:GetBool() and not wep:GetStatRawL("Scoped") and not wep:GetStatRawL("Scoped_3D") then
		return is_stats[stat]
	end
end)

if GetConVar("sv_tfa_sprint_enabled") == nil then
	CreateReplConVar("sv_tfa_sprint_enabled", "1", "Enable sprinting? Disabling this allows shooting while IN_SPEED.")
end

if GetConVar("sv_tfa_reloads_enabled") == nil then
	CreateReplConVar("sv_tfa_reloads_enabled", "1", "Enable reloading? Disabling this allows shooting from ammo pool.")
end

if GetConVar("sv_tfa_attachments_enabled") == nil then
	CreateReplConVar("sv_tfa_attachments_enabled", "1", "Display attachment picker?")
end

if GetConVar("sv_tfa_attachments_alphabetical") == nil then
	CreateReplConVar("sv_tfa_attachments_alphabetical", "0", "Override weapon attachment order to be alphabetical.")
end

if GetConVar("sv_tfa_jamming") == nil then
	CreateReplConVar("sv_tfa_jamming", "1", "Enable jamming mechanics?")
end

if GetConVar("sv_tfa_jamming_mult") == nil then
	CreateReplConVar("sv_tfa_jamming_mult", "1", "Multiply jam chance by this value. You really should modify sv_tfa_jamming_factor_inc rather than this.")
end

if GetConVar("sv_tfa_jamming_factor") == nil then
	CreateReplConVar("sv_tfa_jamming_factor", "1", "Multiply jam factor by this value")
end

if GetConVar("sv_tfa_jamming_factor_inc") == nil then
	CreateReplConVar("sv_tfa_jamming_factor_inc", "1", "Multiply jam factor gain by this value")
end

if GetConVar("sv_tfa_nearlyempty") == nil then
	CreateReplConVar("sv_tfa_nearlyempty", "1", "Enable nearly-empty sounds")
end

if GetConVar("sv_tfa_fixed_crosshair") == nil then
	CreateReplConVar("sv_tfa_fixed_crosshair", "0", "Fix crosshair position on center of the screen (CS:GO style)")
end

if GetConVar("sv_tfa_crosshair_showplayer") == nil then
	CreateReplConVar("sv_tfa_crosshair_showplayer", "1", "Crosshair team color option reveals players")
end

if GetConVar("sv_tfa_crosshair_showplayerteam") == nil then
	CreateReplConVar("sv_tfa_crosshair_showplayerteam", engine.ActiveGamemode() == "terrortown" and "0" or "1", "Crosshair team color option reveals players's team")
end

if GetConVar("sv_tfa_weapon_weight") == nil then
	CreateReplConVar("sv_tfa_weapon_weight", "1", "Disabling this WILL break certain SWEPs and Mechanics. You were warned.")
end

if GetConVar("sv_tfa_fov_sprintmod") == nil then
	CreateReplConVar("sv_tfa_fov_sprintmod", "1", "Enable sprint FOV modification")
end

if GetConVar("sv_tfa_first_draw_anim_enabled") == nil then
	CreateReplConVar("sv_tfa_first_draw_anim_enabled", "1", "Enable first draw animation")
end

--PATH lua/tfa/modules/tfa_envcheck.lua:
local EmptyFunc = function() end

local debugInfoTbl = debug.getinfo(EmptyFunc)

local cv_do_check = CreateConVar("sv_tfa_envcheck", "1", {FCVAR_ARCHIVE, FCVAR_NOTIFY, FCVAR_REPLICATED}, "Enable environment sanity checks and warnings?")

local function checkEnv(plyIn)
	if not cv_do_check:GetBool() then return end

	local function printFunc(msg, ...)
		msg = "[TFA Base] " .. msg

		if chat and chat.AddText then
			return chat.AddText(msg, ...)
		end

		return print(msg, ...)
	end

	if game.SinglePlayer() then
		if CLIENT then
			local found = false
			for _, wepDefTable in ipairs(weapons.GetList()) do
				if wepDefTable.Spawnable and weapons.IsBasedOn(wepDefTable.ClassName, "tfa_gun_base") then
					found = true

					break
				end
			end

			if not found then
				printFunc("Thank you for installing our weapons base! It appears that you have installed only the base itself, which does not include any weapons by default. Please install some weapons/packs that utilize TFA Base for full experience!")
			end
		end

		local shortsrc = debugInfoTbl.short_src

		if shortsrc:StartWith("addons") then -- legacy/unpacked addon
			local addonRootFolder = shortsrc:GetPathFromFilename():Replace("lua/tfa/modules/", "")

			if not file.Exists(addonRootFolder .. ".git", "GAME") then -- assume unpacked version by missing .git folder, which is ignored by gmad.exe
				printFunc("You are using unpacked version of TFA Base.\nWe only provide support for Steam Workshop version.")
			end
		end
	else
		local activeGamemode = engine.ActiveGamemode()
		local isRP = activeGamemode:find("rp")
				or activeGamemode:find("roleplay")
				or activeGamemode:find("serious")

		if isRP and (SERVER or (IsValid(plyIn) and (plyIn:IsAdmin() or plyIn:IsSuperAdmin()))) then
			print("You are running the base on DarkRP or DarkRP-derived gamemode. We can't guarantee that it will work correctly with any possible addons the server might have installed (especially the paid ones), so we don't provide support for RP gamemodes/servers. If you've encountered a conflict error with another addon, it's most likely that addon's fault. DO NOT CONTACT US ABOUT THAT!")
		end
	end

	timer.Simple(0, function()
		if not TFA.BASE_LOAD_COMPLETE or not TFA.SWEP_LOAD_COMPLETE then
			printFunc("Some of the base's modules have failed to load. You are probably going over Lua files limit. Try disabling some addons until you stop getting this error.")
		end
	end)
end

if CLIENT then
	hook.Add("HUDPaint", "TFA_CheckEnv", function()
		local ply = LocalPlayer()

		if not IsValid(ply) then return end

		hook.Remove("HUDPaint", "TFA_CheckEnv")

		checkEnv(ply)
	end)
else
	resource.AddWorkshop("2840031720")

	hook.Add("InitPostEntity", "TFA_CheckEnv", checkEnv)
end

--PATH lua/tfa/modules/tfa_ammo.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_effects.lua:
TFA.Effects = TFA.Effects or {}
local Effects = TFA.Effects

Effects.Overrides = Effects.Overrides or {}
local Overrides = Effects.Overrides

function Effects.AddOverride(target, override)
	assert(type(target) == "string", "No target effect name or not a string")
	assert(type(override) == "string", "No override effect name or not a string")

	Overrides[target] = override
end

function Effects.GetOverride(target)
	if Overrides[target] then
		return Overrides[target]
	end

	return target
end

local util_Effect = util.Effect

function Effects.Create(effectName, effectData, allowOverride, ignorePredictionOrRecipientFilter)
	effectName = Effects.GetOverride(effectName)

	util_Effect(effectName, effectData, allowOverride, ignorePredictionOrRecipientFilter)
end

if SERVER then
	AddCSLuaFile("tfa/muzzleflash_base.lua")
end

--PATH lua/tfa/modules/tfa_hooks.lua:
local TFA = TFA

TFA.INSPECTION_IMPULSE = 148
TFA.BASH_IMPULSE = 149
TFA.CYCLE_FIREMODE_IMPULSE = 150
TFA.CYCLE_SAFETY_IMPULSE = 151

TFA.INSPECTION_IMPULSE_STRING = "148"
TFA.BASH_IMPULSE_STRING = "149"
TFA.CYCLE_FIREMODE_IMPULSE_STRING = "150"
TFA.CYCLE_SAFETY_IMPULSE_STRING = "151"

local sp = game.SinglePlayer()
local CurTime = CurTime

local ENTITY = FindMetaTable("Entity")
local PLAYER = FindMetaTable("Player")

--[[
Hook: PlayerPostThink
Function: Weapon Logic
Used For: Main weapon "think" logic
]]
--
if CLIENT and sp then
	local engine_TickCount = engine.TickCount

	hook.Add("PlayerPostThink", "PlayerTickTFA", function(plyv)
		local wepv = PLAYER.GetActiveWeapon(plyv)
		if not IsValid(wepv) then return end
		local wep2 = ENTITY.GetTable(wepv)

		if wep2.IsTFAWeapon then
			local ply2 = PLAYER.GetTable(plyv)

			local tickCount = engine_TickCount()
			wep2.PlayerThink(wepv, plyv, ply2.last_tfa_think == tickCount)
			ply2.last_tfa_think = tickCount
		end
	end)
end

if SERVER or not sp then
	local IsFirstTimePredicted = IsFirstTimePredicted

	hook.Add("FinishMove", "PlayerTickTFA", function(plyv)
		local wepv = PLAYER.GetActiveWeapon(plyv)
		if not IsValid(wepv) then return end
		local wep2 = ENTITY.GetTable(wepv)

		if wep2.IsTFAWeapon then
			wep2.PlayerThink(wepv, plyv, not IsFirstTimePredicted())
		end
	end)
end

--[[
Hook: Think
Function: Weapon Logic for NPC
User For: Calling SWEP:Think for NPCs manually
]]
--
if SERVER then
	hook.Add("Think", "NPCTickTFA", function()
		hook.Run("TFA_NPCWeaponThink")
	end)
end

--[[
Hook: Tick
Function: Inspection mouse support
Used For: Enables and disables screen clicker
]]
--
if CLIENT then
	local tfablurintensity
	local its_old = 0
	local ScreenClicker = false
	local cl_tfa_inspect_hide = GetConVar("cl_tfa_inspect_hide")
	local cl_drawhud = GetConVar("cl_drawhud")

	hook.Add("Tick", "TFAInspectionScreenClicker", function()
		tfablurintensity = 0

		if LocalPlayer():IsValid() and LocalPlayer():GetActiveWeapon():IsValid() then
			local w = LocalPlayer():GetActiveWeapon()

			if w.IsTFAWeapon then
				tfablurintensity = w:GetCustomizing() and 1 or 0
			end
		end

		if tfablurintensity > its_old and not ScreenClicker and not cl_tfa_inspect_hide:GetBool() and cl_drawhud:GetBool() then
			gui.EnableScreenClicker(true)
			ScreenClicker = true
		elseif tfablurintensity < its_old and ScreenClicker then
			gui.EnableScreenClicker(false)
			ScreenClicker = false
		end

		its_old = tfablurintensity
	end)

	local engine_TickCount = engine.TickCount
	local tickInterval = engine.TickInterval()
	local FrameTime = FrameTime
	local math_Clamp = math.Clamp

	TFA.TickDeltaLastTick = TFA.TickDeltaLastTick or engine_TickCount() - 1
	TFA.TickDelta = 0

	hook.Add("Think", "TFABase_PlayerThinkCL", function()
		TFA.TickDelta = math_Clamp(TFA.TickDelta + FrameTime() / tickInterval, 0, 1)

		local tcount = engine_TickCount()
		if TFA.TickDeltaLastTick ~= tcount then
			TFA.TickDeltaLastTick = tcount
			TFA.TickDelta = 0
		end

		local ply = LocalPlayer()
		if not IsValid(ply) then return end

		local weapon = ply:GetActiveWeapon()

		if IsValid(weapon) and weapon.IsTFAWeapon and weapon.PlayerThinkCL then
			weapon:PlayerThinkCL(ply)
		end
	end)
end

if CLIENT and sp then
	local lastSDLP

	local function SyncSDLP()
		local ply = LocalPlayer()
		if not IsValid(ply) then return end

		local SDLP = ply:ShouldDrawLocalPlayer()
		if lastSDLP == nil or lastSDLP ~= SDLP then
			net.Start("tfaSDLP", true)
			net.WriteBool(SDLP)
			net.SendToServer()

			lastSDLP = SDLP
		end
	end

	hook.Add("Think", "TFABase_ShouldDrawLocalPlayer", SyncSDLP)
end

--[[
Hook: AllowPlayerPickup
Function: Prop holding
Used For: Records last held object
]]
--
hook.Add("AllowPlayerPickup", "TFAPickupDisable", function(plyv, ent)
	plyv:SetNW2Entity("LastHeldEntity", ent)
end)

--[[
Hook: PlayerBindPress
Function: Intercept Keybinds
Used For:  Alternate attack, inspection, shotgun interrupts, and more
]]
--
local cv_cm = GetConVar("sv_tfa_cmenu")
local cv_cm_key = GetConVar("sv_tfa_cmenu_key")
local keyv

local function GetInspectionKey()
	if cv_cm_key and cv_cm_key:GetInt() >= 0 then
		keyv = cv_cm_key:GetInt()
	else
		keyv = TFA.BindToKey(input.LookupBinding("+menu_context", true) or "c", KEY_C)
	end

	return keyv
end

local function TFAContextBlock()
	local plyv = LocalPlayer()

	if not plyv:IsValid() or GetViewEntity() ~= plyv then return end

	if plyv:InVehicle() and not plyv:GetAllowWeaponsInVehicle() then return end

	local wepv = plyv:GetActiveWeapon()
	if not IsValid(wepv) then return end

	if plyv:GetInfoNum("cl_tfa_keys_customize", 0) > 0 then return end

	if GetInspectionKey() == TFA.BindToKey(input.LookupBinding("+menu_context", true) or "c", KEY_C) and wepv.ToggleInspect and cv_cm:GetBool() and not plyv:KeyDown(IN_USE) then return false end
end

hook.Add("ContextMenuOpen", "TFAContextBlock", TFAContextBlock)

if CLIENT then
	local kd_old = false

	local cl_tfa_keys_customize

	local function TFAKPThink()
		local plyv = LocalPlayer()
		if not plyv:IsValid() then return end
		local wepv = plyv:GetActiveWeapon()
		if not IsValid(wepv) then return end

		if not cl_tfa_keys_customize then
			cl_tfa_keys_customize = GetConVar("cl_tfa_keys_customize")
		end

		if cl_tfa_keys_customize:GetBool() then return end

		local key = GetInspectionKey()
		local kd = input.IsKeyDown(key)

		if IsValid(vgui.GetKeyboardFocus()) then
			kd = false
		end

		if kd ~= kd_old and kd and cv_cm:GetBool() and not plyv:KeyDown(IN_USE) then
			RunConsoleCommand("impulse", tostring(TFA.INSPECTION_IMPULSE))
		end

		kd_old = kd
	end

	hook.Add("Think", "TFAInspectionMenu", TFAKPThink)
end

local cv_lr = GetConVar("sv_tfa_reloads_legacy")
local reload_threshold = 0.3

local sv_cheats = GetConVar("sv_cheats")
local host_timescale = GetConVar("host_timescale")

local band = bit.band
local bxor = bit.bxor
local bnot = bit.bnot
local GetTimeScale = game.GetTimeScale
local IN_ATTACK2 = IN_ATTACK2
local IN_RELOAD = IN_RELOAD

local function FinishMove(ply, cmovedata)
	if ply:InVehicle() and not ply:GetAllowWeaponsInVehicle() then return end

	local wepv = ply:GetActiveWeapon()
	if not IsValid(wepv) or not wepv.IsTFAWeapon then return end

	wepv:TFAFinishMove(ply, cmovedata:GetVelocity(), cmovedata)

	local impulse = cmovedata:GetImpulseCommand()

	if impulse == TFA.INSPECTION_IMPULSE then
		wepv:ToggleInspect()
	elseif impulse == TFA.CYCLE_FIREMODE_IMPULSE and wepv:GetStatus() == TFA.Enum.STATUS_IDLE and wepv:GetStatL("SelectiveFire") then
		wepv:CycleFireMode()
	elseif impulse == TFA.CYCLE_SAFETY_IMPULSE and wepv:GetStatus() == TFA.Enum.STATUS_IDLE then
		wepv:CycleSafety()
	end

	local BashImpulse = cmovedata:GetImpulseCommand() == TFA.BASH_IMPULSE
	ply:TFA_SetZoomKeyDown(BashImpulse) -- this may or may not work

	if wepv.SetBashImpulse then
		wepv:SetBashImpulse(BashImpulse)
	end

	if cmovedata:GetImpulseCommand() == 100 and (wepv:GetStatL("FlashlightAttachmentName") ~= nil or wepv:GetStatL("FlashlightAttachment", 0) > 0) then
		wepv:ToggleFlashlight()
	end

	local lastButtons = wepv:GetDownButtons()
	local buttons = cmovedata:GetButtons()
	local stillPressed = band(lastButtons, buttons)
	local changed = bxor(lastButtons, buttons)
	local pressed = band(changed, bnot(lastButtons), buttons)
	local depressed = band(changed, lastButtons, bnot(buttons))

	wepv:SetDownButtons(buttons)
	wepv:SetLastPressedButtons(pressed)

	local time = CurTime()

	local cl_tfa_ironsights_toggle = (ply:GetInfoNum("cl_tfa_ironsights_toggle", 0) or 0) >= 1
	local cl_tfa_ironsights_resight = (ply:GetInfoNum("cl_tfa_ironsights_resight", 0) or 0) >= 1
	local cl_tfa_ironsights_responsive = (ply:GetInfoNum("cl_tfa_ironsights_responsive", 0) or 0) >= 1
	local cl_tfa_ironsights_responsive_timer = ply:GetInfoNum("cl_tfa_ironsights_responsive_timer", 0.175) or 0.175

	local scale_dividier = GetTimeScale() * (sv_cheats:GetBool() and host_timescale:GetFloat() or 1)

	if wepv:GetStatL("Secondary.IronSightsEnabled", false) and not wepv:IsSafety() then
		if band(changed, IN_ATTACK2) == IN_ATTACK2 then
			local deltaPress = (time - wepv:GetLastIronSightsPressed()) / scale_dividier

			-- pressing for first time
			if not wepv:GetIronSightsRaw() and band(pressed, IN_ATTACK2) == IN_ATTACK2 then
				wepv:SetIronSightsRaw(true)
				wepv:SetLastIronSightsPressed(time)
			elseif wepv:GetIronSightsRaw() and
				((cl_tfa_ironsights_toggle or cl_tfa_ironsights_responsive) and band(pressed, IN_ATTACK2) == IN_ATTACK2 or
				not cl_tfa_ironsights_toggle and not cl_tfa_ironsights_responsive and band(depressed, IN_ATTACK2) == IN_ATTACK2)
			then
				-- get out of iron sights
				wepv:SetIronSightsRaw(false)
				wepv:SetLastIronSightsPressed(-1)
			elseif wepv:GetIronSightsRaw() and cl_tfa_ironsights_responsive and band(depressed, IN_ATTACK2) == IN_ATTACK2 and deltaPress > cl_tfa_ironsights_responsive_timer then
				-- we depressed IN_ATTACK2 with it were being held down
				wepv:SetIronSightsRaw(false)
				wepv:SetLastIronSightsPressed(-1)
			end
		elseif wepv:GetIronSightsRaw() and not cl_tfa_ironsights_resight and (not TFA.Enum.IronStatus[wepv:GetStatus()] or wepv:GetSprinting()) then
			wepv:SetIronSightsRaw(false)
			wepv:SetLastIronSightsPressed(-1)
		end
	end

	if
		band(depressed, IN_RELOAD) == IN_RELOAD and
		not cv_lr:GetBool()
		and band(buttons, IN_USE) == 0
		and time <= (wepv:GetLastReloadPressed() + reload_threshold * scale_dividier)
	then
		wepv:SetLastReloadPressed(-1)
		wepv:Reload(true)
	elseif band(pressed, IN_RELOAD) == IN_RELOAD then
		wepv:SetLastReloadPressed(time)
	elseif band(buttons, IN_RELOAD) ~= 0 and band(buttons, IN_USE) == 0 and time > (wepv:GetLastReloadPressed() + reload_threshold * scale_dividier) then
		wepv:CheckAmmo()
	end

	if BashImpulse then
		if wepv.AltAttack then
			wepv:AltAttack()
		end
	end
end

hook.Add("FinishMove", "TFAFinishMove", FinishMove)

local function TFABashZoom(plyv, cusercmd)
	if plyv:InVehicle() and not plyv:GetAllowWeaponsInVehicle() then return end

	if plyv:GetInfoNum("cl_tfa_keys_bash", 0) ~= 0 then
		if (sp or CLIENT) and plyv.tfa_bash_hack then
			cusercmd:SetImpulse(TFA.BASH_IMPULSE)
		end

		return
	end

	local zoom = cusercmd:KeyDown(IN_ZOOM)

	if zoom then
		local wepv = plyv:GetActiveWeapon()

		if IsValid(wepv) and wepv.IsTFAWeapon and wepv.AltAttack then
			cusercmd:RemoveKey(IN_ZOOM)
			cusercmd:SetImpulse(TFA.BASH_IMPULSE)
		end
	end
end

hook.Add("StartCommand", "TFABashZoom", TFABashZoom)

--[[
Hook: PlayerSpawn
Function: Extinguishes players, zoom cleanup
Used For:  Fixes incendiary bullets post-respawn
]]
--
hook.Add("PlayerSpawn", "TFAExtinguishQOL", function(plyv)
	if IsValid(plyv) and plyv:IsOnFire() then
		plyv:Extinguish()
	end
end)

local sv_tfa_weapon_weight = GetConVar("sv_tfa_weapon_weight")

--[[
Hook: SetupMove
Function: Modify movement speed
Used For:  Weapon slowdown, ironsights slowdown
]]
--
hook.Add("SetupMove", "tfa_setupmove", function(plyv, movedata, commanddata)
	local wepv = plyv:GetActiveWeapon()

	if IsValid(wepv) and wepv.IsTFAWeapon and sv_tfa_weapon_weight:GetBool() then
		local speedmult = Lerp(wepv:GetIronSightsProgress(), wepv:GetStatL("RegularMoveSpeedMultiplier", 1), wepv:GetStatL("AimingDownSightsSpeedMultiplier", 1))
		movedata:SetMaxClientSpeed(movedata:GetMaxClientSpeed() * speedmult)
		commanddata:SetForwardMove(commanddata:GetForwardMove() * speedmult)
		commanddata:SetSideMove(commanddata:GetSideMove() * speedmult)
	end
end)

--[[
Hook: InitPostEntity
Function: Patches or removes other hooks that breaking or changing behavior of our weapons in a negative way
Used For: Fixing our stuff
]]
--

local function FixInvalidPMHook()
	if not CLIENT then return end

	local hookTable = hook.GetTable()

	if hookTable["PostDrawViewModel"] and hookTable["PostDrawViewModel"]["Set player hand skin"] then
		local targetFunc = hookTable["PostDrawViewModel"]["Set player hand skin"]
		if not targetFunc then return end

		local cv_shouldfix = GetConVar("cl_tfa_fix_pmhands_hook") or CreateClientConVar("cl_tfa_fix_pmhands_hook", "1", true, false, "Fix hands skin hook for CaptainBigButt's (and others) playermodels (Change requires map restart)")

		if not cv_shouldfix:GetBool() then return end

		print("[TFA Base] The playermodels you have installed breaks the automatic rig parenting for Insurgency and CS:GO weapons. The fix is applied but it's more of a band-aid, the solution would be to either fix this properly on author's side or to uninstall the addon.")

		if CLIENT and debug and debug.getinfo then
			local funcPath = debug.getinfo(targetFunc).short_src

			print("Type whereis " .. funcPath .. " in console to see the conflicting addon.")
		end

		hook.Remove("PostDrawViewModel", "Set player hand skin")
		hook.Add("PreDrawPlayerHands", "Set player hand skin BUT FIXED", function(hands, vm, ply, weapon)
			if hands:SkinCount() == ply:SkinCount() then
				hands:SetSkin(ply:GetSkin())
			end
		end)
	end
end

local function PatchSiminovSniperHook()
	if not CLIENT then return end -- that hook is clientside only

	local hookTable = hook.GetTable()

	if hookTable["CreateMove"] and hookTable["CreateMove"]["SniperCreateMove"] then
		local SniperCreateMove = hookTable["CreateMove"]["SniperCreateMove"] -- getting the original function
		if not SniperCreateMove then return end

		local cv_shouldfix = GetConVar("cl_tfa_fix_siminov_scopes") or CreateClientConVar("cl_tfa_fix_siminov_scopes", "1", true, false, "Patch Siminov's sniper overlay hook with weapon base check (Change requires map restart)")

		if not cv_shouldfix:GetBool() then return end

		local PatchedSniperCreateMove = function(cmd) -- wrapping their function with our check
			local ply = LocalPlayer()

			if IsValid(ply) and IsValid(ply:GetActiveWeapon()) and ply:GetActiveWeapon().IsTFAWeapon then
				return
			end

			SniperCreateMove(cmd)
		end

		hook.Remove("CreateMove", "SniperCreateMove") -- removing original hook
		hook.Add("CreateMove", "SniperCreateMove_PatchedByTFABase", PatchedSniperCreateMove) -- creating new hook with wrap
	end
end

hook.Add("InitPostEntity", "tfa_unfuckeverything", function()
	FixInvalidPMHook()
	PatchSiminovSniperHook()
end)

--[[
Hook: PlayerSwitchFlashlight
Function: Flashlight toggle
Used For: Switching flashlight on weapon and blocking HEV flashlight
]]
--
hook.Add("PlayerSwitchFlashlight", "tfa_toggleflashlight", function(plyv, toEnable)
	if CLIENT then return end -- this is serverside hook GO AWAY
	-- fuck you source
	-- where is fucking prediction??!??!?!?/

	if not IsValid(plyv) or not toEnable then return end -- allow disabling HEV flashlight

	local wepv = plyv:GetActiveWeapon()

	if IsValid(wepv) and wepv.IsTFAWeapon and (wepv:GetStatL("FlashlightAttachmentName") ~= nil or wepv:GetStatL("FlashlightAttachment", 0) > 0) then
		-- wepv:ToggleFlashlight()

		return false
	end
end)

--[[
Hook: SetupMove
Function: Update players NW2 variable
Used For: Walking animation NW2 var
]]
--
hook.Add("SetupMove", "tfa_checkforplayerwalking", function(plyv, mvdatav, cmdv)
	if not IsValid(plyv) or not mvdatav then return end

	if mvdatav:GetForwardSpeed() ~= 0 or mvdatav:GetSideSpeed() ~= 0 then
		if not plyv:GetNW2Bool("TFA_IsWalking") then
			plyv:SetNW2Bool("TFA_IsWalking", true)
		end
	elseif plyv:GetNW2Bool("TFA_IsWalking") then
		plyv:SetNW2Bool("TFA_IsWalking", false)
	end
end)

--[[
Hook: PreDrawOpaqueRenderables
Function: Calls SWEP:PreDrawOpaqueRenderables()
Used For: whatever draw stuff you need lol
]]
--
hook.Add("PreDrawOpaqueRenderables", "tfaweaponspredrawopaque", function()
	for _, v in ipairs(player.GetAll()) do
		local wepv = v:GetActiveWeapon()

		if IsValid(wepv) and wepv.IsTFAWeapon and wepv.PreDrawOpaqueRenderables then
			wepv:PreDrawOpaqueRenderables()
		end
	end
end)

--[[
Hook: PreDrawViewModel
Function: Calculating viewmodel offsets
Used For: Viewmodel sway, offset and flip
]]
--
if CLIENT then
	local vec = Vector()
	local ang = Angle()

	local IsGameUIVisible = gui and gui.IsGameUIVisible

	local FrameTime = FrameTime
	local FrameNumber = FrameNumber
	local lastframe = FrameNumber() - 1
	hook.Add("PreDrawViewModel", "TFACalculateViewmodel", function(vm, plyv, wepv)
		if lastframe == FrameNumber() then return end
		lastframe = FrameNumber()

		if not IsValid(wepv) or not wepv.IsTFAWeapon then return end
		local wep2 = wepv:GetTable()

		if sp and IsGameUIVisible and IsGameUIVisible() then return end

		wep2.UpdateEngineBob(wepv)

		local delta = FrameTime()

		wep2.Sway(wepv, vec, ang, delta)
		wep2.CalculateViewModelOffset(wepv, delta)
		wep2.CalculateViewModelFlip(wepv)

		wep2.UpdateProjectedTextures(wepv, true)
	end)
end

--[[
Hook: EntityTakeDamage
Function: Applies physics damage to Combine Turrets
Used For: Knocking up Combine Turrets with TFA Base weapons
]]
--
hook.Add("EntityTakeDamage", "TFA_TurretPhysics", function(entv, dmg)
	if entv:GetClass() == "npc_turret_floor" then
		entv:TakePhysicsDamage(dmg)
	end
end)

--[[
Hook: HUDPaint
Function: Calls another hook
Used For: Hook that notifies when player is fully loaded.
]]
--
hook.Add("HUDPaint", "TFA_TRIGGERCLIENTLOAD", function()
	if LocalPlayer():IsValid() then
		hook.Remove("HUDPaint", "TFA_TRIGGERCLIENTLOAD")

		hook.Run("TFA_ClientLoad")
	end
end)

--[[
Hook: InitPostEntity
Function: Wraps SWEP:Think functions
Used For: Patching old, broken weapons that override SWEP:Think without calling baseclass
]]
--
local PatchClassBlacklisted = {
	tfa_gun_base = true,
	tfa_melee_base = true,
	tfa_bash_base = true,
	tfa_bow_base = true,
	tfa_knife_base = true,
	tfa_nade_base = true,
	tfa_sword_advanced_base = true,
	tfa_cssnade_base = true,
	tfa_shotty_base = true,
	tfa_akimbo_base = true,
	tfa_3dbash_base = true,
	tfa_3dscoped_base = true,
	tfa_scoped_base = true,
}

local cv_shouldpatchthink = GetConVar("sv_tfa_backcompat_patchswepthink") or CreateConVar("sv_tfa_backcompat_patchswepthink", "1", CLIENT and {FCVAR_REPLICATED} or {FCVAR_REPLICATED, FCVAR_ARCHIVE, FCVAR_NOTIFY}, "Enable patching of old weapons that override SWEP:Think function to work with newer version of the base?\n\tDISABLING THIS IS NOT RECOMMENDED AND MAY LEAD TO NON-FUNCTIONING WEAPONS!")

hook.Add("InitPostEntity", "TFA_PatchThinkOverride", function()
	if not cv_shouldpatchthink:GetBool() then return end
	if not debug or not debug.getinfo then return end

	for _, wepRefTable in ipairs(weapons.GetList()) do
		local class = wepRefTable.ClassName

		if PatchClassBlacklisted[class] or not weapons.IsBasedOn(class, "tfa_gun_base") then
			goto THINK1FOUND
		end

		local wepRealTbl = weapons.GetStored(class)

		if wepRealTbl.Think then
			local info = debug.getinfo(wepRealTbl.Think, "S")
			if not info or not info.linedefined or not info.lastlinedefined then goto THINK1FOUND end

			local src = info.short_src

			if src:StartWith("addons/") then
				src = src:gsub("^addons/[^%0:/]+/", "")
			end

			local luafile = file.Read(src:sub(5), "LUA")
			if not luafile or luafile == "" then goto THINK1FOUND end

			local lua = luafile:gsub("\r\n","\n"):gsub("\r","\n"):Split("\n")

			for i = info.linedefined, info.lastlinedefined do
				local line = lua[i]

				if not line or line:find("BaseClass%s*.%s*Think%s*%(") then
					goto THINK1FOUND
				end
			end

			print(("[TFA Base] Weapon %s (%s) is overriding SWEP:Think() function without calling baseclass!"):format(wepRefTable.ClassName, info.short_src))

			local BaseClass = baseclass.Get(wepRealTbl.Base)

			wepRealTbl.ThinkFuncUnwrapped = wepRealTbl.ThinkFuncUnwrapped or wepRealTbl.Think
			function wepRealTbl:Think(...)
				self:ThinkFuncUnwrapped(...)

				return BaseClass.Think(self, ...)
			end
		end

		::THINK1FOUND::
	end
end)
--PATH lua/tfa/modules/tfa_meta.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_npc_teamcolor.lua:
return gluapack()()
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1, band(rshift(state, 22), 1) == 0 and 0 or 1, band(rshift(state, 23), 1) == 0 and 0 or 1, band(rshift(state, 24), 1) == 0 and 0 or 1, band(rshift(state, 25), 1) == 0 and 0 or 1, band(rshift(state, 26), 1) == 0 and 0 or 1, band(rshift(state, 27), 1) == 0 and 0 or 1, band(rshift(state, 28), 1) == 0 and 0 or 1, band(rshift(state, 29), 1) == 0 and 0 or 1, band(rshift(state, 30), 1) == 0 and 0 or 1, band(rshift(state, 31), 1) == 0 and 0 or 1		end
	
--PATH lua/tfa/modules/cl_tfa_materials.lua:
TFA_SCOPE_ACOG = {
	scopetex = surface.GetTextureID("scope/gdcw_closedsight"),
	reticletex = surface.GetTextureID("scope/gdcw_acogchevron"),
	dottex = surface.GetTextureID("scope/gdcw_acogcross")
}

TFA_SCOPE_MILDOT = {
	scopetex = surface.GetTextureID("scope/gdcw_scopesight")
}

TFA_SCOPE_SVD = {
	scopetex = surface.GetTextureID("scope/gdcw_svdsight")
}

TFA_SCOPE_PARABOLIC = {
	scopetex = surface.GetTextureID("scope/gdcw_parabolicsight")
}

TFA_SCOPE_ELCAN = {
	scopetex = surface.GetTextureID("scope/gdcw_elcansight"),
	reticletex = surface.GetTextureID("scope/gdcw_elcanreticle")
}

TFA_SCOPE_GREENDUPLEX = {
	scopetex = surface.GetTextureID("scope/gdcw_closedsight"),
	reticletex = surface.GetTextureID("scope/gdcw_nvgilluminatedduplex")
}

TFA_SCOPE_AIMPOINT = {
	scopetex = surface.GetTextureID("scope/gdcw_closedsight"),
	reticletex = surface.GetTextureID("scope/aimpoint")
}

TFA_SCOPE_MATADOR = {
	scopetex = surface.GetTextureID("scope/rocketscope")
}

TFA_SCOPE_SCOPESCALE = 4
TFA_SCOPE_RETICLESCALE = 1
TFA_SCOPE_DOTSCALE = 1

--PATH lua/tfa/att/mod_stun15_servius.lua:
return gluapack()()
--PATH lua/tfa/att/mod_stun20_servius.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end

ATTACHMENT.Name = "Charge Round Delta"
ATTACHMENT.ShortName = "20s" --Abbreviation, 5 chars or less please
--ATTACHMENT.ID = "base" -- normally this is just your filename
ATTACHMENT.Description = { 
	TFA.AttachmentColors["+"],"Stunned for 20 Seconds",
}
ATTACHMENT.Icon = "entities/icon/mod_stun20.png" --Revers to label, please give it an icon though!  This should be the path to a png, like "entities/tfa_ammo_match.png"

ATTACHMENT.WeaponTable = {
	["Primary"] = {
		["AmmoConsumption"] = 7,
		["StatusEffect"] = "stun",
		["StatusEffectDmg"] = 60,
		["StatusEffectDur"] = 20,
		["StatusEffectParticle"] = true,
	},
	["TracerName"] = "effect_sw_laser_blue_stun",
}

function ATTACHMENT:Attach(wep)
	wep.CustomBulletCallbackOld = wep.CustomBulletCallbackOld or wep.CustomBulletCallback
	wep.CustomBulletCallback = function(a, tr, dmg)
		local wep = dmg:GetInflictor()
		if wep:GetStat("Primary.StatusEffect") then
			GMSERV:AddStatus(tr.Entity, wep:GetOwner(), wep:GetStat("Primary.StatusEffect"), wep:GetStat("Primary.StatusEffectDur"), wep:GetStat("Primary.StatusEffectDmg"), wep:GetStat("Primary.StatusEffectParticle"))
			--util.Effect("BGOLightning", ED_Stun, true, true)
		end
	end
end

function ATTACHMENT:Detach(wep)
	wep.CustomBulletCallback = wep.CustomBulletCallbackOld
	wep.CustomBulletCallbackOld = nil
end

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end
--PATH lua/autorun/twk_slave_addon.lua:
return gluapack()()
--PATH lua/autorun/venator_bacta.lua:
-- Created by Oninoni
-- Based on Code by Syphadias
-- Huge thanks to them!

-- This has to match the map Name
if not (game.GetMap() == "rp_venator_extensive_v1_4") then return end

-- The Ammount of Bacta Tanks that are used
local bactaCount = 2

-- The Name of the prop_vehicle_prisoner_pod without its suffix (e.g. bacta1, bacta2, ... -> bacta)
local entityName = "bacta"

-- Bacta Seat Don't fricking touch anything below this line!
local Category = "Map Utilities"
local function StandAnimation( vehicle, player )
	return player:SelectWeightedSequence( ACT_GMOD_NOCLIP_LAYER )
end
local V = {
    Name = "Bacta Tank Seat",
	Model = "models/lordtrilobite/starwars/props/bactatankb.mdl",
    Class = "prop_vehicle_prisoner_pod",
    Category = Category,
 
    Author = "Syphadias, Oninoni",
    Information = "Seat with custom animation",
    Offset = 16,
 
    KeyValues = {
        vehiclescript = "scripts/vehicles/prisoner_pod.txt",
        limitview = "0"
    },
    Members = {
        HandleAnimation = StandAnimation
    }
}
list.Set( "Vehicles", "bacta_seat", V )
 
if SERVER then
    local seatCache = {}
    local function IsValidSeat(seat)
        local seat = seatCache[seat]
     
        if seat and IsValid(seat) then
			return true
        end
     
        return false
    end
	
	hook.Add("Think", "UpdateseatPosBacta", function()
		for i = 1, bactaCount, 1 do
			if !IsValidSeat(i) then
				seatCache[i] = ents.FindByName(entityName .. i)[1]

				if !IsValidSeat(i) then
					continue
				end
			end

			seatCache[i]:SetVehicleClass("bacta_seat")
		end
	end)
end
--PATH lua/autorun/venator_lfs_fix.lua:
--[[
This is a workaround for LFS not being able to be teleported
It disables the ships engines and enables them again shortly after
dont know if this works well on low tick servers
Luna plz fix
]]



-- This has to match the map Name
if not (game.GetMap() == "rp_venator_extensive_v1_4") then return end

local function startEngine(ship)
	if ship:GetEngineActive() or ship:IsDestroyed() or ship:InWater() or ship:GetRotorDestroyed() then return end

	ship:SetEngineActive( true )
	ship:OnEngineStarted()

	ship:InertiaSetNow()
end

function LFSEnter()
	local ship = ACTIVATOR
	if IsValid(ship) and ship.LFS then
		if ship:GetEngineActive() then
			ship:StopEngine()
			timer.Simple(0.1, function() startEngine(ship) end)
		end
	end
end

--PATH lua/autorun/vj_controls.lua:
return gluapack()()
--PATH lua/autorun/vj_files.lua:
return gluapack()()
--PATH lua/autorun/vj_controls.lua:
/*--------------------------------------------------
	=============== VJ Controls ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ VJ Spawnmenu Controls ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
local killIconColor = Color(255, 80, 0, 255)

if !VJ then VJ = {} end -- If VJ isn't initialized, initialize it!

-- Variables ----------------------------------------------------------------------------------------------------
if !VJ.Plugins then VJ.Plugins = {} end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers the addon to the VJ plugin list
		- name = Addon name
		- type = Type of addon | EX: NPC, Weapon, etc.
-----------------------------------------------------------]]
VJ.AddAddonProperty = function(name, type)
	table.insert(VJ.Plugins, {Name = name, Type = type})
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers spawn menu category information
		- name = Category name
		- options = Table that holds all possible options
			- Icon = Category icon
-----------------------------------------------------------]]
VJ.AddCategoryInfo = function(category, options)
	list.Set("VJBASE_CATEGORY_INFO", category, {
		icon = options.Icon or "icon16/monkey.png",
	})
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds an NPC to the spawn menu
		- name = NPC's name
		- class = NPC's class
		- category = The spawn menu category it should be in
		- adminOnly = Is this an admin only NPC?
		- customFunc(property) = Used to apply more options (Located in GMod's source code) | EX: OnCeiling, Offset, etc.
-----------------------------------------------------------]]
VJ.AddNPC = function(name, class, category, adminOnly, customFunc)
	local property = {Name = name, Class = class, Category = category, AdminOnly = adminOnly}
	if (customFunc) then customFunc(property) end
	list.Set("NPC", class, property)
	list.Set("VJBASE_SPAWNABLE_NPC", class, property)
	if CLIENT then
		language.Add(class, name)
		killicon.Add(class, "HUD/killicons/default", killIconColor)
		language.Add("#" .. class, name)
		killicon.Add("#" .. class, "HUD/killicons/default", killIconColor)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds a human NPC to the spawn menu
		- name = NPC's name
		- class = NPC's class
		- weapons = Default weapon list for this NPC
		- category = The spawn menu category it should be in
		- adminOnly = Is this an admin only NPC?
		- customFunc(property) = Used to apply more options (Located in GMod's source code) | EX: OnCeiling, Offset, etc.
-----------------------------------------------------------]]
VJ.AddNPC_HUMAN = function(name, class, weapons, category, adminOnly, customFunc)
	local property = {Name = name, Class = class, Weapons = weapons, Category = category, AdminOnly = adminOnly}
	if (customFunc) then customFunc(property) end
	list.Set("NPC", class, property)
	list.Set("VJBASE_SPAWNABLE_NPC", class, property)
	if CLIENT then
		language.Add(class, name)
		killicon.Add(class, "HUD/killicons/default", killIconColor)
		language.Add("#" .. class, name)
		killicon.Add("#" .. class, "HUD/killicons/default", killIconColor)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds a weapon to the NPC weapon override list
		- name = Weapon's name
		- class = Weapon's class
		- category = The category group it should be in
-----------------------------------------------------------]]
VJ.AddNPCWeapon = function(name, class, category)
	local property = {title = name, class = class, category = category or "VJ Base"}
	list.Add("NPCUsableWeapons", property)
	list.Add("VJBASE_SPAWNABLE_NPC_WEAPON", property)
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds a weapon to the weapon spawn list
		- name = Weapon's name
		- class = Weapon's class
		- adminOnly = Is this an admin only weapon?
		- category = The spawn menu category it should be in
		- customFunc(property) = Used to apply more options (Located in GMod's source code)
-----------------------------------------------------------]]
VJ.AddWeapon = function(name, class, adminOnly, category, customFunc)
	local property = {PrintName = name, ClassName = class, Category = category, AdminOnly = adminOnly, Spawnable = true}
	if (customFunc) then customFunc(property) end
	list.Set("Weapon", class, property)
	list.Set("VJBASE_SPAWNABLE_WEAPON", class, property)
	duplicator.Allow(class)
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds an entity to the weapon spawn list
		- name = Entity's name
		- class = Entity's class
		- author = Author's name
		- adminOnly = Is this an admin only entity?
		- offset = Spawn offset
		- dropToFloor = Should it drop to the floor on spawn?
		- category = The spawn menu category it should be in
		- customFunc(property) = Used to apply more options (Located in GMod's source code)
-----------------------------------------------------------]]
VJ.AddEntity = function(name, class, author, adminOnly, offset, dropToFloor, category, customFunc)
	local Ent = {PrintName = name, ClassName = class, Author = author, AdminOnly = adminOnly, NormalOffset = offset, DropToFloor = dropToFloor, Category = category, Spawnable = true}
	if (customFunc) then customFunc(Ent) end
	list.Set("SpawnableEntities", class, Ent)
	list.Set("VJBASE_SPAWNABLE_ENTITIES", class, Ent)
	duplicator.Allow(class)
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds and registers a particle file
		- fileName = Addon name | EX: "particles/explosion.pcf"
		- particleList = List of particles to precache from the given particle file
-----------------------------------------------------------]]
VJ.AddParticle = function(fileName, particleList)
	game.AddParticles(fileName)
	for _, name in ipairs(particleList) do
		PrecacheParticleSystem(name)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers a ConVar
		- name = Convar name
		- defValue = Default value
		- flags = Convar's flags | Can be a bitflag or a table | Flag List: https://wiki.facepunch.com/gmod/Enums/FCVAR
		- helpText = Help text to display in the console
		- min = If set, the ConVar cannot be changed to a number lower than this value
		- max = If set, the ConVar cannot be changed to a number higher than this value
-----------------------------------------------------------]]
VJ.AddConVar = function(name, defValue, flags, helpText, min, max)
	if !ConVarExists(name) then
		CreateConVar(name, defValue, flags or FCVAR_NONE, helpText or "", min, max)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers a client ConVar
		- name = ConVar name
		- defValue = Default value
		- helpText = Help text to display in the console
		- min = If set, the ConVar cannot be changed to a number lower than this value
		- max = If set, the ConVar cannot be changed to a number higher than this value
-----------------------------------------------------------]]
VJ.AddClientConVar = function(name, defValue, helpText, min, max)
	if !ConVarExists(name) then
		CreateClientConVar(name, defValue, true, true, helpText or "", min, max)
	end
end

/*
if CLIENT then
local gmod_npcweapon = CreateConVar("gmod_npcweapon","",{FCVAR_ARCHIVE})
spawnmenu.AddContentType( "vjbase_npc", function( container, obj )
	if ( !obj.material ) then return end
	if ( !obj.nicename ) then return end
	if ( !obj.spawnname ) then return end
	if ( !obj.weapon ) then obj.weapon = { "" } end
	local icon = vgui.Create( "ContentIcon", container )
		icon:SetContentType( "vjbase_npc" )
		icon:SetSpawnName( obj.spawnname )
		icon:SetName( obj.nicename )
		icon:SetMaterial( obj.material )
		icon:SetAdminOnly( obj.admin )
		icon:SetNPCWeapon( obj.weapon )
		icon:SetColor(Color(244,164,96,255))
		icon.DoClick = function() 
			local weapon = table.Random( obj.weapon )
			if ( gmod_npcweapon:GetString() != "" ) then weapon = gmod_npcweapon:GetString() end
			RunConsoleCommand( "vjbase_spawnnpc", obj.spawnname, weapon ) 
			surface.PlaySound( "ui/buttonclickrelease.wav" )
		end
		icon.OpenMenu = function( icon ) 
			local menu = DermaMenu()
			local weapon = table.Random( obj.weapon )
			if ( gmod_npcweapon:GetString() != "" ) then weapon = gmod_npcweapon:GetString() end
			menu:AddOption( "Copy to Clipboard", function() SetClipboardText( obj.spawnname ) end )
			menu:AddOption( "Spawn Using Toolgun", function() RunConsoleCommand( "gmod_tool", "creator" ) RunConsoleCommand( "creator_type", "2" ) RunConsoleCommand( "creator_name", obj.spawnname ) RunConsoleCommand( "creator_arg", weapon ) end )
			menu:AddSpacer()
			menu:AddOption( "Delete", function() icon:Remove() hook.Run( "SpawnlistContentChanged", icon ) end )
			menu:Open()
		end
	if (IsValid(container)) then
		container:Add(icon)
	end
	return icon
end)
-------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateVJBaseWeapons","AddVJBaseSpawnMenu_weapon",function(pnlContent,tree,node)
	local weapontree = tree:AddNode("Weapons", "icon16/gun.png")
	local Weapons = list.Get("VJBASE_SPAWNABLE_WEAPON")  -- Get a list of available Weapons
	local WeaponCatagory = {}
	for k, weapon in pairs( Weapons ) do
		if ( !weapon.Spawnable ) then continue end
		WeaponCatagory[ weapon.Category ] = WeaponCatagory[ weapon.Category ] or {}
		table.insert( WeaponCatagory[ weapon.Category ], weapon )
	end
	Weapons = nil
	for CategoryName, v in SortedPairs(WeaponCatagory) do -- Create an icon for each one and put them on the panel
		local node = weapontree:AddNode(CategoryName,"icon16/page_white_go.png") -- Add a node to the tree
		node.DoPopulate = function(self) -- When we click on the node - populate it using this function
			if ( self.PropPanel ) then return end -- If we've already populated it - forget it.
			self.PropPanel = vgui.Create("ContentContainer", pnlContent) -- Create the container panel
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )
			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "weapon", self.PropPanel, 
				{ 
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.ClassName,
					material	= "entities/"..ent.ClassName..".png",
					admin		= ent.AdminOnly
				})
			end
		end
		node.DoClick = function(self) -- If we click on the node populate it and switch to it.
			self:DoPopulate()		
			pnlContent:SwitchPanel( self.PropPanel );
		end
	end
	//local FirstNode = tree:Root():GetChildNode(0) -- Select the first node
	//if ( IsValid( FirstNode ) ) then
		//FirstNode:InternalDoClick()
	//end
	weapontree:SetExpanded(true)
end)
-------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateVJBaseEntities","AddVJBaseSpawnMenu_Entity",function(pnlContent,tree,node)
	local entitytree = tree:AddNode("Entities", "icon16/bricks.png")
	local EntitiesCategories = {}
	local EntitiesList = list.Get("VJBASE_SPAWNABLE_ENTITIES") -- Get a list of available Entities
	if (EntitiesList) then
		for k, v in pairs(EntitiesList) do
			v.SpawnName = k
			v.Category = v.Category or "Other"
			EntitiesCategories[ v.Category ] = EntitiesCategories[ v.Category ] or {}
			table.insert( EntitiesCategories[ v.Category ], v )
		end
	end
	for CategoryName, v in SortedPairs(EntitiesCategories) do -- Create an icon for each one and put them on the panel
		local node = entitytree:AddNode(CategoryName,"icon16/page_white_go.png") -- Add a node to the tree
		node.DoPopulate = function(self) -- When we click on the node - populate it using this function
			if ( self.PropPanel ) then return end -- If we've already populated it - forget it.
			self.PropPanel = vgui.Create("ContentContainer", pnlContent) -- Create the container panel
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )
			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel, 
				{ 
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.SpawnName,
					material	= "entities/"..ent.SpawnName..".png",
					admin		= ent.AdminOnly
				})
			end
		end
		node.DoClick = function(self) -- If we click on the node populate it and switch to it.
			self:DoPopulate()		
			pnlContent:SwitchPanel( self.PropPanel );
		end
	end
	//local FirstNode = tree:Root():GetChildNode(0) -- Select the first node
	//if ( IsValid( FirstNode ) ) then
		//FirstNode:InternalDoClick()
	//end
	entitytree:SetExpanded(true)
end)
-------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateVJBaseNPC","AddVJBaseSpawnMenu_NPC",function(pnlContent,tree,node)
	local npctree = tree:AddNode("NPCs", "icon16/monkey.png")
	local NPCList = list.Get("VJBASE_SPAWNABLE_NPC") -- Get a list of available NPCs
	local NPCCategories = {} -- Categorize them
	for k, v in pairs(NPCList) do
		local Category = v.Category or "Other"
		local Tab = NPCCategories[Category] or {}
		Tab[ k ] = v
		NPCCategories[Category] = Tab
	end
	for CategoryName, v in SortedPairs(NPCCategories) do -- Create an icon for each one and put them on the panel
		local node = npctree:AddNode(CategoryName,"icon16/page_white_go.png") -- Add a node to the tree
		node.DoPopulate = function(self) -- When we click on the node - populate it using this function
			if ( self.PropPanel ) then return end -- If we've already populated it - forget it.
			self.PropPanel = vgui.Create("ContentContainer", pnlContent) -- Create the container panel
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )
			for name, ent in SortedPairsByMemberValue( v, "Name" ) do
				spawnmenu.CreateContentIcon( "vjbase_npc", self.PropPanel, 
				{ 
					nicename	= ent.Name or name,
					spawnname	= name,
					material	= "entities/"..name..".png",
					weapon		= ent.Weapons,
					admin		= ent.AdminOnly
				})
			end
		end
		node.DoClick = function(self) -- If we click on the node populate it and switch to it.
			self:DoPopulate()		
			pnlContent:SwitchPanel(self.PropPanel)
		end	
	end
	//local FirstNode = tree:Root():GetChildNode(0) -- Select the first node
	//if (IsValid(FirstNode)) then
		//FirstNode:InternalDoClick()
	//end
	npctree:SetExpanded(true)
end)
-------------------------------------------------------------------------------------------------------------------------
spawnmenu.AddCreationTab("VJ Base",function()
	local ctrl = vgui.Create("SpawnmenuContentPanel")
	ctrl:CallPopulateHook("PopulateVJBaseWeapons")
	ctrl:CallPopulateHook("PopulateVJBaseEntities")
	ctrl:CallPopulateHook("PopulateVJBaseNPC")
	return ctrl
end, "icon16/plugin.png", 60 )
*/
--PATH lua/autorun/vj_menu_spawn.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/extensions/wos_bs.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Blade Symphony" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted animation extension: Blade Symphony\n" )
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/extensions/wos_dod.lua:
-- "addons\\wosanim_fixes\\lua\\wos\\anim_extension\\extensions\\wos_dod.lua"
-- Retrieved by https://github.com/lewisclark/glua-steal
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Day of Defeat" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted animation extension: Day of Defeat\n" )
--PATH lua/wos/anim_extension/holdtypes/a_combo1.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/a_combo4.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "a_combo4"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "a_combo4" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "a_combo4" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/agile.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/agile.lua:
local DATA = {}
DATA.Name = "TEST"
DATA.HoldType = "wos_agile_corvinus"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "wos_ryoku_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "walk_knife", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "phalanx_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "ryoku_r_idle", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "wos_bs_shared_jump_descend", Weight = 1 },
}

DATA.Translations[ ACT_MP_CROUCH_IDLE ] = {
	{ Sequence = "couch_idle", Weight = 1 },
}

wOS.AnimExtension:RegisterHoldtype( DATA )
--=====================================================================

--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/bladedancer.lua:
local DATA = {}
DATA.Name = "DANCER"
DATA.HoldType = "wos_dancer_corvinus"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "wos_ryoku_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "walk_knife", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "phalanx_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "ryoku_r_idle", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "wos_bs_shared_jump_descend", Weight = 1 },
}

DATA.Translations[ ACT_MP_CROUCH_IDLE ] = {
	{ Sequence = "couch_idle", Weight = 1 },
}

wOS.AnimExtension:RegisterHoldtype( DATA )
--=====================================================================

--PATH lua/wos/anim_extension/holdtypes/form4.lua:

local DATA = {}
DATA.Name = "form4"
DATA.HoldType = "form4_holdtype"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 
DATA.Translations[ ACT_MP_STAND_IDLE ] = "ata_idle"
DATA.Translations[ ACT_MP_WALK ] = "ata4_run"
DATA.Translations[ ACT_MP_RUN ] = "ata_run"
wOS.AnimExtension:RegisterHoldtype( DATA )

--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/juggernaut.lua:

local DATA = {}
DATA.Name = "[LSCS] HoldType Juggernaut"
DATA.HoldType = "wos_jugger_corvinus"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "wos_ryoku_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "walk_knife", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "phalanx_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "judge_b_idle", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "wos_bs_shared_jump_descend", Weight = 1 },
}

DATA.Translations[ ACT_MP_CROUCH_IDLE ] = {
	{ Sequence = "couch_idle", Weight = 1 },
}

wOS.AnimExtension:RegisterHoldtype( DATA )

--PATH lua/wos/anim_extension/holdtypes/leapattack.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/lscs_vader_holdtype.lua:

local DATA = {}
DATA.Name = "[LSCS] HoldType Vader"
DATA.HoldType = "lscs_vader"
DATA.BaseHoldType = "melee"
DATA.Translations = {} 
DATA.Translations[ ACT_MP_STAND_IDLE ] = "vader_idle"
DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "h_jump", Weight = 1 },
}
wOS.AnimExtension:RegisterHoldtype( DATA )

--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/melee2greater.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/ninja.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/saber_staff.lua:
local DATA = {}
DATA.Name = "saberstaff"
DATA.HoldType = "wos-saber-staff"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "wos_ryoku_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "wos_judge_b_idle", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "wos_ryoku_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "wos_ryoku_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "balanced_jump", Weight = 1 },
}

wOS.AnimExtension:RegisterHoldtype( DATA )
--=====================================================================

--PATH lua/wos/anim_extension/holdtypes/slashuph.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "slashuph"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "slashuph" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "slashuph" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH lua/wos/dynabase/core/sh_model_operations.lua:
wOS = wOS or {}
wOS.DynaBase = wOS.DynaBase or {}
wOS.DynaBase.PreservedModels = wOS.DynaBase.PreservedModels or {}

local function FIX_MODEL_ACTIVITIES( path )
    if not path then return end

	local new_path = string.Replace(path, "models/", "wos/dynabase/fixedmodels/")
	new_path = string.Replace( new_path, ".mdl", WOS_DYNABASE_FILE_EXTENSION )
    if file.Exists( new_path, "DATA" ) and not wOS.DynaBase.ReloadFixedModels then return "data/" .. new_path end

	local mdl_file = file.Open( path, "r", "GAME" )
    if not mdl_file then return end

	local str = ""
	local sanitary_str = ""
	for i=0, mdl_file:Size() do
		local byte = mdl_file:ReadByte()
		if not byte then continue end
		str = str .. string.char( byte )
		if byte == 0 then
			sanitary_str = sanitary_str .. string.char( 35 )
		else
			sanitary_str = sanitary_str .. string.char( byte )
		end
	end
	local _start, _end = string.find( sanitary_str, "ACT_" )
	while _start do
		local act_name = "WDB_"
		for i=0, 3 do 
			str = string.SetChar( str, _start + i, act_name[i + 1] )
		end
		_start, _end = string.find( sanitary_str, "ACT_", _end )
	end


	local dt = string.Explode("/", new_path)
	dt = dt[#dt]
	
	local file_path = string.Left( path, #path - #dt - 1 )

	file.CreateDir( file_path )
	file.Write( new_path, str )

    return "data/" .. new_path
end

function wOS.DynaBase:FixActivities( data )
    if not data then return end
    
    if data.Shared and ( not self.PreservedModels[ data.Shared ] or wOS.DynaBase.ReloadFixedModels ) then
        local path = FIX_MODEL_ACTIVITIES( data.Shared )
        if path then
            self.PreservedModels[ data.Shared ] = path
        end
    end

    if data.Male and ( not self.PreservedModels[ data.Male ] or wOS.DynaBase.ReloadFixedModels ) then
        local path = FIX_MODEL_ACTIVITIES( data.Male )
        if path then
            self.PreservedModels[ data.Male ] = path
        end    
    end

    if data.Female and ( not self.PreservedModels[ data.Female ] or wOS.DynaBase.ReloadFixedModels ) then
        local path = FIX_MODEL_ACTIVITIES( data.Female )
        if path then
            self.PreservedModels[ data.Female ] = path
        end    
    end

    if data.Zombie and ( not self.PreservedModels[ data.Zombie ] or wOS.DynaBase.ReloadFixedModels ) then
        local path = FIX_MODEL_ACTIVITIES( data.Zombie )
        if path then
            self.PreservedModels[ data.Zombie ] = path
        end
    end

end

concommand.Add( "wos_dynabase_debug_reloadfixedmodels", function()
	wOS.DynaBase.ReloadFixedModels = true
    for name, data in pairs( wOS.DynaBase:GetAllSources() ) do
        if not data.PreventActivities then continue end
        wOS.DynaBase:FixActivities( data )      
    end
	wOS.DynaBase.ReloadFixedModels = false
end )

file.CreateDir("wos/dynabase/fixedmodels")


local function FixConflictingBases()
    for _, addon in ipairs( engine.GetAddons() ) do
        if addon.wsid == "2916561591" then
            game.MountGMA( addon.file )
            RunConsoleCommand( "r_flushlod" )
            break
        end
    end
end
hook.Add( "InitLoadAnimations", "wOS.DynaBase.FixConflictingBases", FixConflictingBases )

concommand.Add( "wos_dynabase_fixconflicts", function()
    FixConflictingBases()
    print( "[wOS-DynaBase] Conflicting bases have been unloaded for this session. Double check by running the wos_dynabase_help command!\n\nNote: The addon may still be mounted when you restart your game.")
end )

--PATH lua/xeninui/libs/animations.lua:
return gluapack()()
--PATH lua/xeninui/libs/promises.lua:
local M = {}

local deferred = {}
deferred.__index = deferred

local PENDING = 0
local RESOLVING = 1
local REJECTING = 2
local RESOLVED = 3
local REJECTED = 4

local function finish(deferred, state)
	state = state or REJECTED
	for i, f in ipairs(deferred.queue) do
		if state == RESOLVED then
			f:resolve(deferred.value)
		else
			f:reject(deferred.value)
		end
	end
	deferred.state = state
end

local function isfunction(f)
	if type(f) == 'table' then
		local mt = getmetatable(f)
		return mt ~= nil and type(mt.__call) == 'function'
	end
	return type(f) == 'function'
end

local function promise(deferred, next, success, failure, nonpromisecb)
	if type(deferred) == 'table' and type(deferred.value) == 'table' and isfunction(next) then
		local called = false
		local ok, err = pcall(next, deferred.value, function(v)
			if called then return end
			called = true
			deferred.value = v
			success()
		end, function(v)
			if called then return end
			called = true
			deferred.value = v
			failure()
		end)
		if not ok and not called then
			deferred.value = err
			failure()
		end
	else
		nonpromisecb()
	end
end

local function fire(deferred)
	local next
	if type(deferred.value) == 'table' then
		next = deferred.value.next
	end
	promise(deferred, next, function()
		deferred.state = RESOLVING
		fire(deferred)
	end, function()
		deferred.state = REJECTING
		fire(deferred)
	end, function()
		local ok
		local v
		if deferred.state == RESOLVING and isfunction(deferred.success) then
			ok, v = pcall(deferred.success, deferred.value)
		elseif deferred.state == REJECTING and isfunction(deferred.failure) then
			ok, v = pcall(deferred.failure, deferred.value)
			if ok then
				deferred.state = RESOLVING
			end
		end

		if ok ~= nil then
			if ok then
				deferred.value = v
			else
				deferred.value = v
				return finish(deferred)
			end
		end

		if deferred.value == deferred then
			deferred.value = pcall(error, 'resolving promise with itself')
			return finish(deferred)
		else
			promise(deferred, next, function()
				finish(deferred, RESOLVED)
			end, function(state)
				finish(deferred, state)
			end, function()
				finish(deferred, deferred.state == RESOLVING and RESOLVED)
			end)
		end
	end)
end

local function resolve(deferred, state, value)
	if deferred.state == 0 then
		deferred.value = value
		deferred.state = state
		fire(deferred)
	end
	return deferred
end




function deferred:resolve(value)
	return resolve(self, RESOLVING, value)
end

function deferred:reject(value)
	return resolve(self, REJECTING, value)
end





function M.new(options)
	if isfunction(options) then
		local d = M.new()
		local ok, err = pcall(options, d)
		if not ok then
			d:reject(err)
		end
		return d
	end
	options = options or {}
	local d
	d = {
		next = function(self, success, failure)
			local next = M.new({
				success = success,
				failure = failure,
				extend = options.extend
			})
			if d.state == RESOLVED then
				next:resolve(d.value)
			elseif d.state == REJECTED then
				next:reject(d.value)
			else
				table.insert(d.queue, next)
			end
			return next
		end,
		state = 0,
		queue = {},
		success = options.success,
		failure = options.failure
	}
	d = setmetatable(d, deferred)
	if isfunction(options.extend) then
		options.extend(d)
	end
	return d
end





function M.all(args)
	local d = M.new()
	if #args == 0 then
		return d:resolve({})
	end
	local method = "resolve"
	local pending = #args
	local results = {}

	local function synchronizer(i, resolved)
		return function(value)
			results[i] = value
			if not resolved then
				method = "reject"
			end
			pending = pending - 1
			if pending == 0 then
				d[method](d, results)
			end
			return value
		end
	end

	for i = 1, pending do
		args[i]:next(synchronizer(i, true), synchronizer(i, false))
	end
	return d
end





function M.map(args, fn)
	local d = M.new()
	local results = {}
	local function donext(i)
		if i > #args then
			d:resolve(results)
		else
			fn(args[i]):next(function(res)
				table.insert(results, res)
				donext(i + 1)
			end, function(err)
				d:reject(err)
			end)
		end
	end
	donext(1)
	return d
end





function M.first(args)
	local d = M.new()
	for _, v in ipairs(args) do
		v:next(function(res)
			d:resolve(res)
		end, function(err)
			d:reject(err)
		end)
	end
	return d
end





XeninUI.Promises = M

--PATH lua/xeninui/libs/languages/core.lua:
XeninUI.HTTPReady = (function() local __laux_nilish_coalescing_var = XeninUI.HTTPReady if __laux_nilish_coalescing_var ~= nil then return __laux_nilish_coalescing_var else return false end end)()
XeninUI.LanguageAddons = {}

if (!file.IsDir("xenin/languages", "DATA")) then
	file.CreateDir("xenin/languages")
end

local LANG = {}
LANG.Languages = {}
LANG.Queue = {}

AccessorFunc(LANG, "m_url", "URL")
AccessorFunc(LANG, "m_folder", "Folder")
AccessorFunc(LANG, "m_branch", "Branch")

function LANG:SetActiveLanguage(lang)
	self.activeLang = lang

	self.Languages[lang] = self.Languages[lang] or {
		phrases = {},
		cachedPhrases = {}
	}
end

function LANG:GetActiveLanguage(lang)
	return self.activeLang end

function LANG:SetID(id)
	self.ID = id

	if (!file.IsDir("xenin/languages/" .. id, "DATA")) then
		file.CreateDir("xenin/languages/" .. id)
	end
end

function LANG:GetID()
	return self.ID
end

function LANG:GetQueue()
	return self.Queue
end

function LANG:AddToQueue(lang, overwrite, promise)
	table.insert(self.Queue, {
		lang = lang,
		overwrite = overwrite,
		promise = promise
	})
end

function LANG:EmptyQueue()
	self.Queue = {}
end

function LANG:ProcessQueue()
	for i, v in ipairs(self:GetQueue()) do
		self:Download(v.lang, v.overwrite, v.promise)
	end
end

function LANG:GetFilePath(lang)
	return "xenin/languages/" .. self:GetID() .. "/" .. lang .. ".json"
end

function LANG:Exists(lang)
	return file.Exists(self:GetFilePath(lang), "DATA")
end

function LANG:SetLocalLanguage(lang, tbl)
	local _tbl = {}
	_tbl.cachedPhrases = {}
	tbl = isstring(tbl) and self:ParseJSON(tbl) or tbl
	table.Merge(_tbl, tbl)

	self.Languages[lang] = _tbl
end

function LANG:ParseJSON(json)
	local tbl = util.JSONToTable(json)
	if (!tbl) then return end
	for i, v in pairs(tbl.functions or {}) do
		tbl.functions[i] = CompileString(v, i)
	end

	return tbl
end

function LANG:Download(lang, overwrite, p)
	if p == nil then p = XeninUI.Promises.new()
	end
	if (self:GetLanguage(lang) and !overwrite) then
		local tbl = self:GetLanguage(lang)
		if tbl then
			return p:resolve(tbl)
		else
			local tbl = file.Read(self:GetFilePath(lang), "DATA")
			if tbl then
				return p:resolve(self:ParseJSON(tbl))
			end
		end


	end

	if (!XeninUI.HTTPReady) then
		self:AddToQueue(lang, overwrite, p)

		return p
	end

	local branch = self:GetBranch() or "master"
	local url = self.ComputeURL and self:ComputeURL(lang) or self:GetURL() .. "/raw/" .. branch .. "/" .. self:GetFolder() .. "/" .. lang .. ".json"
	local function tryDownloadFromServer(err)
		if (CLIENT and !LocalPlayer()["__XeninLanguageRequest_" .. tostring(self:GetID()) .. "_" .. tostring(lang)]) then
			LocalPlayer()["__XeninLanguageRequest_" .. tostring(self:GetID()) .. "_" .. tostring(lang)] = true

			XeninUI.LanguagesNetwork:sendRequestLanguage(self:GetID(), lang)

			return p:reject(err or "Download failure, attempting to download from server>")
		end

		return p:reject(err or "Download failure, attempting to download from server>")
	end

	http.Fetch(url, function(body, size, headers, code)
		if (code != 200) then
			return tryDownloadFromServer()
		end
		if (size == 0) then
			return tryDownloadFromServer("GitLab is down??")
		end


		if (body:sub(1, 15) == "<!DOCTYPE html>") then
			return tryDownloadFromServer(lang .. " language not found")
		end
		local tbl = self:ParseJSON(body)
		if (!tbl) then
			return tryDownloadFromServer("Unable to decode JSON")
		end

		file.Write(self:GetFilePath(lang), body)

		local _tbl = {}
		_tbl.cachedPhrases = {}
		table.Merge(_tbl, tbl)

		self.Languages[lang] = _tbl

		p:resolve(tbl, body, headers)
	end, function(err)

		if (CLIENT and !LocalPlayer()["__XeninLanguageRequest_" .. tostring(self:GetID()) .. "_" .. tostring(lang)]) then
			LocalPlayer()["__XeninLanguageRequest_" .. tostring(self:GetID()) .. "_" .. tostring(lang)] = true

			XeninUI.LanguagesNetwork:sendRequestLanguage(self:GetID(), lang)

			return p:reject("Download failure, attempting to download from server>")
		end

		p:reject(err)
	end)

	return p
end

function LANG:GetLanguage(lang)
	return self.Languages[lang] or {
		phrases = {},
		cachedPhrases = {},
		functions = {}
	}
end

function LANG:GetCachedPhrase(lang, phrase)
	local tbl = self:GetLanguage(lang)
	local str

	if (!tbl.cachedPhrases[phrase]) then
		local split = string.Explode(".", phrase)
		local outputPhrase = tbl.phrases
		for i, v in ipairs(split) do
			if (!outputPhrase[v]) then
				outputPhrase = nil

				break
			end

			outputPhrase = outputPhrase[v]
		end

		str = outputPhrase
		tbl.cachedPhrases[phrase] = outputPhrase
	else
		str = tbl.cachedPhrases[phrase]
	end

	return str
end

function LANG:GetPhrase(phrase, replacement)
	local activeLang = self:GetActiveLanguage()
	local str = self:GetCachedPhrase(activeLang, phrase)
	if (!str and activeLang != "english") then
		str = self:GetCachedPhrase("english", phrase)

		if (!str) then str = phrase end
	end

	if (replacement and str) then
		for i, v in pairs(replacement) do
			str = str:Replace(":" .. i .. ":", v)
		end
	end

	return str
end

function XeninUI:Language(id)
	if self.LanguageAddons[id] then
		return self.LanguageAddons[id]
	end

	local tbl = table.Copy(LANG)
	tbl:SetID(id)

	self.LanguageAddons[id] = tbl

	return tbl
end

hook.Add("InitPostEntity", "XeninUI.Languages", function()

	timer.Simple(3, function()
		XeninUI.HTTPReady = true

		for i, v in pairs(XeninUI.LanguageAddons) do
			v:ProcessQueue()
		end
	end)
end)

--PATH lua/xeninui/libs/configurator/classes/controller.lua:
local function __laux_concat_0(...)
  local arr = {
  ...
  }
  local result = {}
  for _, obj in ipairs(arr) do
    for i = 1, #obj do
      result[#result + 1] = obj[i]
    end
    for k, v in pairs(obj) do
      if type(k) == "number" and k > #obj then result[k] = v
      elseif type(k) ~= "number" then
        result[k] = v
      end
    end
  end
  return result
end
XeninUI.Configurator.Controllers = XeninUI.Configurator.Controllers || {}

function XeninUI.Configurator:GetControllers()
  return self.Controllers
end

function XeninUI.Configurator:FindControllerByScriptName(script)
  return self:GetControllers()[script]
end

do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Configurator.Controller",
    setTitle = function(self, title)
      self.title = title
      return self
    end,
    getSettings = function(self)
      return self.settings
    end,
    getTabs = function(self)
      return self.tabs
    end,
    getScript = function(self)
      return self.script
    end,
    getTitle = function(self)
      return self.title
    end,
    IsValid = function(self)
      return XeninUI.Configurator:FindControllerByScriptName(self.script) == self
    end,
    addSettingTab = function(self, name)
      table.insert(self.settingTab, {
        name = name,
        subtabs = {}
      })
    end,
    getSettingTabs = function(self)
      return self.settingTab
    end,
    addSetting = function(self, id, category, subCategory, name, desc, value, type, data, sortOrder)
      if data == nil then data = {}
      end
      self.settings[id] = {
        id = id,
        category = category,
        subCategory = subCategory,
        name = name,
        desc = desc,
        value = value,
        defaultValue = value,
        type = type,
        data = data,
        sortOrder = sortOrder or table.Count(self.settings) + 1
      }

      self.cache:set(id, value)
    end,
    addTab = function(self, name, icon, color, panel, settings)
      if settings == nil then settings = {}
      end
      table.insert(self.tabs, __laux_concat_0({
        name = name,
        icon = icon,
        color = color or color_white,
        panel = panel or "DPanel"
      }, settings))
    end,
    addSettingsTab = function(self, name, icon, color, settings)
      if settings == nil then settings = {}
      end
      local panel = "Xenin.Configurator.Admin.Panel"
      settings.settingsTab = true

      self:addTab(name, icon, color, panel, settings)
    end,
    addEntityTab = function(self, name, icon, color, entity, settings)
      if settings == nil then settings = {}
      end
      local panel = settings.panelOverride or "Xenin.Configurator.Admin.Entity"
      if (settings.isGrid and !settings.panelOverride) then
        panel = "Xenin.Configurator.Admin.EntityGrid"
      end
      if (settings.isList and !settings.panelOverride) then
        panel = "Xenin.Configurator.Admin.EntityList"
      end

      table.Merge(settings, {
        __entity = entity,
        script = self:getScript(),
        name = name
      })
      self:addTab(name, icon, color, panel, settings)
    end,
    getSettingsKV = function(self)
      local tbl = {}
      for i, v in pairs(self:getSettings()) do
        tbl[v.id] = self.cache:get(v.id)
      end

      return tbl
    end,
    getSortedSettings = function(self)
      local tbl = {}
      for i, v in pairs(self:getSettings()) do
        table.insert(tbl, v)
      end
      table.sort(tbl, function(a, b)
        return a.sortOrder < b.sortOrder end)

      return tbl
    end,
    getSettingsByCategory = function(self)
      local tbl = {}
      for i, v in pairs(self:getSettings()) do
        tbl[v.category] = tbl[v.category] || {}

        table.insert(tbl[v.category], v)
      end
      for i, v in pairs(tbl) do
        table.sort(v, function(a, b)
          return a.sortOrder < b.sortOrder end)
      end

      return tbl
    end,
    get = function(self, key, default)
      local val = self.cache:get(key)
      if (val != nil) then
        return val
      end

      return default
    end,
    onSettingChanged = function(self, key, value) end,
    set = function(self, key, value)
      self.cache:set(key, value)
      self.settings[key].value = value

      self:onSettingChanged(key, value)
    end,
    saveSetting = function(self, id, val)
      if CLIENT then
        XeninUI.Configurator.Network:sendSaveSetting(self:getScript(), id, val)
      else
        return XeninUI.Configurator.ORM:saveSetting(self:getScript(), id, val)
      end
    end,
    load = function(self)
      local p = XeninUI.Promises.new()

      if self.hasLoadedSettings then
        return p:resolve()
      end

      XeninUI.Configurator.ORM:getScriptSettings(self:getScript()):next(function(results)
        if results == nil then results = {}
        end
        for i, v in ipairs(results) do
          assert(v ~= nil, "cannot destructure nil value")
          local id, value, json = v.id, v.value, v.json
          if (json and json != "NULL") then
            value = util.JSONToTable(value)
          end

          self.cache:set(id, value)
        end

        self.hasLoadedSettings = true
        p:resolve()
      end, function(err)
        p:reject(err)
      end)

      return p
    end,
    networkSettings = function(self, target)
      if (CLIENT) then return end

      local isAdmin = XeninUI.Permissions:canAccessFramework(target)
      local tbl = {}
      for i, v in pairs(self:getSettings()) do
        local setting = self.settings[v.id]
        if (setting.data.secret and !isAdmin) then continue end

        tbl[v.id] = self.cache:get(v.id)
      end

      XeninUI.Configurator.Network:sendSettings(target, self:getScript(), tbl)
    end,
    loadEntities = function(self, ent)
      local p = XeninUI.Promises.new()
      local id = ent:getDatabaseEntity()
      if self.loadedEntities[id] then
        return p:resolve()
      end

      XeninUI.Configurator.ORM:findEntities(ent):next(function(results)
        results = results || {}

        local tbl = {}

        for _, entData in ipairs(results) do
          local inst = XeninUI.Configurator.Entities:create(id)
          for i, v in pairs(entData) do
            local val = v
            local col = inst:getColumn(i)
            if col.onLoad then
              val = col:onLoad(v)
            end

            inst["set" .. tostring(i)](inst, val)
          end
          inst:save()
          inst:onLoad()
        end

        self.loadedEntities[id] = true
        p:resolve()
      end)

      return p
    end,
    networkEntities = function(self, target)
      if (CLIENT) then return end

      local ents = XeninUI.Configurator.Entities:getEntities()
      local type = self:__type()
      local id = (string.Explode(".", type) and string.Explode(".", type)[1])
      local length = #id
      for entId, ent in pairs(ents) do
        local str = entId:sub(1, length)
        if (str != id) then continue end

        if (!ent.getAllEntities) then
          Error(tostring(entId) .. " has no way of getting all instances of said entity. Please implement a static getAllEntities function\n")
        end

        self:loadEntities(ent()):next(function(result)
          local allEnts = ent.getAllEntities()

          XeninUI.Configurator.Network:sendEntities(target, allEnts)
        end)
      end
    end,
    addSearch = function(self, id, tabFunc, matchFunc, clickFunc)
      if clickFunc == nil then clickFunc = function() end
      end
      table.insert(self.search, {
        id = id,
        matchFunc = matchFunc,
        tabFunc = tabFunc,
        clickFunc = clickFunc
      })
    end,
    getSearch = function(self, text)
      text = text:lower()

      local function findTab(func)
        for i, v in pairs(self.tabs) do
          if (!func(v, i)) then continue end

          return v, i
        end
      end

      local tbl = {}
      for i, v in ipairs(self.search) do

        local tab = findTab(v.tabFunc)
        if (!tab) then continue end

        local results = v:matchFunc(text, tab)
        tbl = __laux_concat_0(tbl, results)

        if (#tbl >= 4) then break end
      end

      return {
        tbl[1],
        tbl[2],
        tbl[3],
        tbl[4]
      }
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self, script)
      self.search = {}
      self.loadedEntities = {}
      self.tabs = {}
      self.settingTab = {}
      self.settings = {}
      self.hasLoadedSettings = false
      self.cache = XeninUI.Configurator.Cache()
      self.script = script:lower()

      XeninUI.Configurator.Controllers[self.script] = self

      hook.Add("PlayerInitialSpawn", "XeninUI.Configurator.Scripts." .. tostring(script), function(ply)
        timer.Simple(3, function()
          self:load():next(function()
            if (!IsValid(ply)) then return end

            self:networkSettings(ply)
            self:networkEntities(ply)
          end)
        end)
      end)
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Configurator.Controller = _class_0
end

--PATH lua/xeninui/libs/configurator/ui/inputs.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/search_bar.lua:
local function __laux_concat_0(...)
  local arr = {
  ...
  }
  local result = {}
  for _, obj in ipairs(arr) do
    for i = 1, #obj do
      result[#result + 1] = obj[i]
    end
    for k, v in pairs(obj) do
      if type(k) == "number" and k > #obj then result[k] = v
      elseif type(k) ~= "number" then
        result[k] = v
      end
    end
  end
  return result
end
local PANEL = {}

function PANEL:Init()
  self.textentry:SetUpdateOnType(true)
  self.textentry.OnValueChange = function(pnl, text)
    self:Search(text:lower())
  end
end

function PANEL:RemovePopup()
  if IsValid(self.Popup) then self.Popup:Remove()end
end

PANEL.OnRemove = PANEL.RemovePopup

XeninUI:CreateFont("Xenin.Configurator.Admin.SearchBar.Title", 18)
XeninUI:CreateFont("Xenin.Configurator.Admin.SearchBar.Subtitle", 13)

function PANEL:Paint(w, h)
  if IsValid(self.Popup) then
    return draw.RoundedBoxEx(self:GetRounded(), 0, 0, w, h, self:GetBackgroundColor(), true, true, false, false)
  end

  draw.RoundedBox(self:GetRounded(), 0, 0, w, h, self:GetBackgroundColor())
end

function PANEL:CreatePopup(results)
  local size = #results
  local x, y = self:GetPos()
  x = x + 16
  y = y + 16
  y = y + self:GetTall()
  local w = self:GetWide()
  local h = 16 + (size * 48 + ((size - 1) * 4))
  if (size == 0) then h = h + 30
  end

  self.Popup = XeninUI.Configurator.AdminMenu:Add("DPanel")
  self.Popup:SetPos(x, y)
  self.Popup:SetSize(w, h)
  self.Popup:SetZPos(100)
  self.Popup:SetDrawOnTop(true)
  self.Popup.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBoxEx(6, 0, 0, w, h, XeninUI.Theme.Navbar, false, false, true, true)
  end

  self.Popup.Layout = self.Popup:Add("DListLayout")
  self.Popup.Layout:DockPadding(8, 8, 8, 8)
  self.Popup.Layout:Dock(TOP)

  if (size == 0) then
    local panel = self.Popup.Layout:Add("DLabel")
    panel:SetText("No Results")
    panel:SetFont("Xenin.Configurator.Admin.SearchBar.Title")
    panel:SetTextColor(color_white)
    panel:SetContentAlignment(5)

    return
  end

  for i = 1, size do
    local result = results[i]
    local panel = self.Popup.Layout:Add("DButton")
    panel:DockMargin(0, 0, 0, 4)
    panel:SetText("")
    panel:SetTall(48)
    panel.Result = result
    panel.Color = XeninUI.Theme.Navbar
    local cat = {
      icon = result.icon,
      color = result.color
    }
    XeninUI:DownloadIcon(panel, cat.icon)
    local desc = result.desc
    if (#desc >= 58) then
      desc = result.desc:sub(1, 58 - 3) .. "..."
    end
    panel.Markup = markup.Parse("<font=Xenin.Configurator.Admin.SearchBar.Title><color=255,255,255>" .. tostring(result.name) .. "</color></font>")
    panel.Paint = function(pnl, w, h)
      XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.Color)
      XeninUI:DrawIcon(8, 8, h - 16, h - 16, pnl, cat.color)

      pnl.Markup:Draw(h, h / 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
      XeninUI:DrawShadowText(desc, "Xenin.Configurator.Admin.SearchBar.Subtitle", h, h / 2, Color(179, 179, 179), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, 150)

      surface.SetFont("Xenin.Configurator.Admin.SearchBar.Title")
      local tw, th = pnl.Markup:GetWidth(), pnl.Markup:GetHeight()
      surface.SetFont("Xenin.Configurator.Admin.SearchBar.Subtitle")
      local sw, sh = surface.GetTextSize(result.category)
      XeninUI:DrawRoundedBox(6, h + tw + 4, h / 2 - th / 2 - 6, sw + 8, sh, result.color or cat.color)
      local col = XeninUI:GetContrastColor(result.color or cat.color, color_white, Color(65, 65, 65))
      draw.SimpleText(result.category, "Xenin.Configurator.Admin.SearchBar.Subtitle", h + tw + 4 + 4, h / 2 - th / 2 - 6, col, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
    end
    panel.OnCursorEntered = function(pnl, w, h)
      pnl:LerpColor("Color", XeninUI.Theme.Background)
    end
    panel.OnCursorExited = function(pnl, w, h)
      pnl:LerpColor("Color", XeninUI.Theme.Navbar)
    end
    panel.DoClick = function(pnl)
      if result.onClick then
        result.onClick(pnl, XeninUI.Configurator.AdminMenu)
      end

      self:RemovePopup()
    end
  end
end

function PANEL:Find(text, search)
  return text:find(search, nil, nil, true)
end

function PANEL:SetScript(script, ctr)
  self.script = script
  self.ctr = ctr
end

function PANEL:AddToSearch(name, desc, category, id, extra)
  if extra == nil then extra = {}
  end
  table.insert(self.Results, __laux_concat_0({
    name = name,
    desc = desc,
    category = category,
    catId = id
  }, extra))
end

function PANEL:GetSettings()
  if (self:HasReachedSearchLimit()) then return end
end

function PANEL:HasReachedSearchLimit()
  return #self.Results >= 4
end

function PANEL:Search(text)
  self:RemovePopup()
  if (#text == 0) then return end
  self.Results = self.ctr:getSearch(text)

  self:CreatePopup(self.Results)
end

vgui.Register("Xenin.Configurator.Admin.SearchBar", PANEL, "XeninUI.TextEntry")

--PATH lua/xeninui/libs/configurator/ui/inputs/checkbox.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/inputs/popup.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/inputs/toggle.lua:
return gluapack()()
--PATH lua/xeninui/libs/players/ui/frame.lua:
return gluapack()()
--PATH lua/xeninui/elements/checkbox.lua:
return gluapack()()
--PATH lua/xeninui/elements/checkbox_v2.lua:
local PANEL = {}

local matTick = Material("xenin/tick.png", "smooth")

function PANEL:Init()
	self:SetText("")

	self.State = false
	self.AnimationController = 0
	self.Color = XeninUI.Theme.Accent
	self.Background = XeninUI.Theme.Primary
	self.Font = "XeninUI.CheckboxV2"
end

XeninUI:CreateFont("XeninUI.CheckboxV2", 18)

function PANEL:Paint(w, h)
	XeninUI:MaskInverse(function()
		surface.SetDrawColor(color_white)
		local x = h * math.Clamp((self.AnimationController - 0.5) * 2, 0, 1)
		surface.DrawRect(h - x, 0, h, h)
	end, function()
		XeninUI:DrawRoundedBoxEx(6, 0, 0, h, h * 0.5, self.Color, true, true, false, false)
	end)
	XeninUI:MaskInverse(function()
		surface.SetDrawColor(color_white)
		local width = h * math.Clamp(self.AnimationController * 2, 0, 1)
		surface.DrawRect(0, 0, width, h)
	end, function()
		XeninUI:DrawRoundedBoxEx(6, 0, h * 0.5, h, h * 0.5, self.Color, false, false, true, true)
	end)
	XeninUI:DrawRoundedBox(4, 2, 2, h - 4, h - 4, self.Background)

	XeninUI:MaskInverse(function()
		surface.SetDrawColor(color_white)
		local x = h * math.Clamp((self.AnimationController - 1) * 2, 0, 1)
		surface.DrawRect(x, 0, h, h)
	end, function()
		surface.SetMaterial(matTick)
		surface.SetDrawColor(self.Color)
		surface.DrawTexturedRect(0, 0, h, h)
	end)

	if self.Text then
		local x = h + 5
		XeninUI:DrawShadowText(self.Text, self.Font, x, h / 2 - 1, self.TextColor or color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, 125)
	end
end

function PANEL:SizeToContentsX()
	surface.SetFont(self.Font)
	local tw = surface.GetTextSize(self.Text)

	self:SetWide(self:GetTall() + 5 + tw)
end

function PANEL:SetState(state, instant)
	self.State = state

	if state then
		if instant then
			self:EndAnimations()
			self.AnimationController = 1.5
		else
			self:Lerp("AnimationController", 1.5, 0.4)
		end
	else
		self:EndAnimations()
		self.AnimationController = 0
	end
end

function PANEL:OnStateChanged() end

function PANEL:Toggle()
	self:SetState(!self.State)
	self:OnStateChanged(self.State)
end

vgui.Register("XeninUI.CheckboxV2", PANEL, "DButton")

--PATH lua/xeninui/elements/query.lua:
return gluapack()()
--PATH lua/xeninui/elements/textentry.lua:
return gluapack()()
--PATH lua/xeninui/elements/wyvern_scrollbar.lua:
return gluapack()()
--PATH lua/xeninui/core/ui/tab.lua:
return gluapack()()
--PATH lua/xeninui/libs/units/main.lua:
return gluapack()()
--PATH lua/xeninui/libs/units/classes/result.lua:
return gluapack()()
--PATH lua/autorun/client/advdupe2_cl_init.lua:
return gluapack()()
--PATH lua/advdupe2/file_browser.lua:
return gluapack()()
--PATH lua/advdupe2/cl_file.lua:
return gluapack()()
--PATH lua/autorun/client/alydus_destructiblefortificationsextension.lua:
 --[[
 - Destructible Fortifications Extension for Fortification Builder Tablet
 - 
 - /lua/autorun/client/alydus_destructablefortificationsextension.lua
 - 
 - Feel free to modify, but please leave appropriate credit.
 - Do not reupload this (modified or original) to this workshop, however you may ruin modified versions on your servers.
 -
 - Thanks so much for the support with the addon since it's creation in 2018.
 -
 --]]

alydusDestructibleFortificationExtension = true
--PATH lua/autorun/client/cl_vmanip.lua:
return gluapack()()
--PATH addons/[tfres] datapad/lua/autorun/client/datapad.lua:
return gluapack()()
--PATH lua/autorun/client/jetted.lua:
surface.CreateFont('Jetted',{font='Trebuchet MS',size=48,weight=400})

local function DrawRect(col,x,y,w,h)
	x, y = math.Round(x), math.Round(y)
	w, h = math.Round(w), math.Round(h)
	surface.SetDrawColor(col.r,col.g,col.b,col.a)
	surface.DrawRect(x,y,w,h)
end

local function DrawText(...)
	local aye = {...}
	surface.SetFont(aye[1])
	local oldx, oldy = 0, 0
	for i = 4, #aye do
		if istable(aye[i]) then
			surface.SetTextColor(aye[i])
		else
			surface.SetTextPos(aye[2]+oldx,aye[3])
			surface.DrawText(tostring(aye[i]))
			local _ox, _oy = surface.GetTextSize(tostring(aye[i]))
			oldx, oldy = oldx+_ox, oldy+_oy
		end
	end
end

local function GetTextSize(...)
	local aye = {...}
	surface.SetFont(aye[1])
	local legx, legy = 0, 0
	for i = 2, #aye do
		if isstring(aye[i]) then
			local xd, yd = surface.GetTextSize(tostring(aye[i]))
			legx = legx + xd
			legy = legy > yd and legy or yd
		end
	end
	return legx, legy
end

local MSW, MSH = ScrW(), ScrH()
local fuelbarwidth, fuelbarheigth = 256, 48
local col_bg = Color(0,0,0,192)
local col_fuel = Color(255,128,0,255)
local col_txt = Color(255,255,255)
local jet, cf, mf = NULL, 100, 100

hook.Add('Tick','Jetted',function()
	if !IsValid(LocalPlayer()) then return end
	jet = LocalPlayer():GetNWEntity('Jetted')
	if !IsValid(jet) then return end
	cf, mf = jet:GetFuel(), jet:GetMaxFuel()
end)

hook.Add('HUDPaint','jetted',function()
	if !IsValid(jet) then return end
	local percent = math.floor(cf/mf*100)
	DrawRect(col_bg,MSW/2-fuelbarwidth/2,MSH-fuelbarheigth*1.4,fuelbarwidth,fuelbarheigth)
	DrawRect(col_fuel,MSW/2-fuelbarwidth/2+4,MSH-fuelbarheigth*1.4+4,(fuelbarwidth-8)*percent/100,fuelbarheigth-8)
	DrawText('Jetted',MSW/2-fuelbarwidth/2+12,MSH-fuelbarheigth*1.4,col_txt,'Fuel: '..percent..'%')
end)

















--PATH addons/[tfres] frest_levels/lua/autorun/client/lvlpanel.lua:
return gluapack()()
--PATH lua/autorun/client/vj_menu_plugins.lua:
return gluapack()()
--PATH lua/autorun/client/vj_menu_plugins.lua:
/*--------------------------------------------------
	=============== VJ Base Plugins ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

---------------------------------------------------------------------------------------------------------------------------------------------
local function VJ_PLUGINS(Panel)
	local numPlugins = #VJ.Plugins
	
	Panel:AddControl("Label", {Text = "#vjbase.menu.plugins.label"})
	Panel:ControlHelp(language.GetPhrase("#vjbase.menu.plugins.version").." "..VJBASE_VERSION) -- Main Number / Version / Patches
	Panel:ControlHelp(language.GetPhrase("#vjbase.menu.plugins.totalplugins").." "..numPlugins)
	
	local CheckList = vgui.Create("DListView")
	CheckList:SetTooltip(false)
	//CheckList:Center() -- No need since Size does it already
	CheckList:SetSize(100, 300) -- Size
	CheckList:SetMultiSelect(false)
	CheckList:AddColumn("#vjbase.menu.plugins.header1") -- Add column
	CheckList:AddColumn("#vjbase.menu.plugins.header2"):SetFixedWidth(50) -- Add column
	//Panel:SetName("Test") -- Renames the blue label
	if VJ.Plugins != nil then
		for _,v in SortedPairsByMemberValue(VJ.Plugins, "Name") do
			CheckList:AddLine(v.Name, v.Type)
		end
	else
		CheckList:AddLine("#vjbase.menu.plugins.notfound", "")
	end
	CheckList.OnRowSelected = function()
		surface.PlaySound(Sound("vj_misc/illuminati_confirmed.mp3"))
		chat.AddText(Color(255,255,0),"-=-=-=-=-=-=-=-=- ", Color(255,100,0), "VJ Base", Color(255,255,0)," -=-=-=-=-=-=-=-=-")
		chat.AddText(Color(0,255,0), language.GetPhrase("#vjbase.menu.plugins.version").." "..VJBASE_VERSION)
		chat.AddText(Color(0,255,0), language.GetPhrase("#vjbase.menu.plugins.totalplugins").." "..numPlugins)
	end
	Panel:AddItem(CheckList)
	
	-- Changelog for VJ Base
	local changelog = vgui.Create("DButton")
	changelog:SetFont("TargetID")
	changelog:SetText("#vjbase.menu.plugins.changelog")
	changelog:SetSize(150, 25)
	changelog:SetColor(Color(0, 102, 0))
	changelog:SetFont("VJFont_Trebuchet24_SmallMedium")
	changelog.DoClick = function(x)
		gui.OpenURL("https://github.com/DrVrej/VJ-Base/releases")
	end
	Panel:AddPanel(changelog)
	
	-- Github Wiki
	local github = vgui.Create("DButton")
	github:SetFont("TargetID")
	github:SetText("#vjbase.menu.plugins.makeaddon")
	github:SetSize(150, 25)
	github:SetColor(Color(0, 0, 102))
	github:SetFont("VJFont_Trebuchet24_SmallMedium")
	github.DoClick = function(x)
		gui.OpenURL("https://github.com/DrVrej/VJ-Base/wiki")
	end
	Panel:AddPanel(github)
	
	-- Tutorial Video
	local tutorialVid = vgui.Create("DButton")
	tutorialVid:SetFont("TargetID")
	tutorialVid:SetText("#tool.vjstool.menu.tutorialvideo")
	tutorialVid:SetSize(150, 25)
	tutorialVid:SetColor(Color(0, 0, 102))
	tutorialVid:SetFont("VJFont_Trebuchet24_SmallMedium")
	tutorialVid.DoClick = function(x)
		gui.OpenURL("https://www.youtube.com/watch?v=dGoqEpFZ5_M")
	end
	Panel:AddPanel(tutorialVid)
	
	-- *insert lenny face*
	if (LocalPlayer():SteamID() == "STEAM_0:0:22688298") then
		local lennyface = vgui.Create("DButton")
		lennyface:SetFont("TargetID")
		lennyface:SetText("HELLO")
		lennyface:SetSize(150, 25)
		lennyface:SetColor(Color(0, 0, 102))
		lennyface:SetFont("VJFont_Trebuchet24_SmallMedium")
		lennyface.DoClick = function(x)
			net.Start("vj_meme")
			net.SendToServer()
		end
		Panel:AddPanel(lennyface)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateToolMenu", "VJ_ADDTOMENU_INSTALLATIONS", function()
	spawnmenu.AddToolMenuOption("DrVrej", "Main Menu", "Installed Plugins", "#vjbase.menu.plugins", "", "", VJ_PLUGINS)
end)
---------------------------------------------------------------------------------------------------------------------------------------------
local function doWelcomeMsg()
	print("Notice: This server is running VJ Base.")

	local amt = #VJ.Plugins
    if amt <= 9 then
		amt = "0"..tostring(amt)
	else
		amt = tostring(amt)
	end
    local dashes = "----------------------------"
	
    chat.AddText(Color(255,215,0),"|"..dashes..">", Color(0,255,255), " VJ Base ", Color(30,200,255), VJBASE_VERSION.." ", Color(255,215,0), "<"..dashes.."|")
    chat.AddText(Color(255,215,0),"|- ", Color(255,255,0),"NOTICE! ", Color(255,255,255), "To configure ", Color(0,255,255), "VJ Base ", Color(255,255,255), "click on ", Color(0,255,255), "DrVrej", Color(255,255,255)," in the spawn menu! ", Color(255,215,0),"-|")
    //chat.AddText(Color(255,215,0),"|"..dashes..">", Color(30,200,255), " "..amt, Color(0,255,255), " VJ Plugins ", Color(255,215,0), "<"..dashes.."|")
end
concommand.Add("vj_welcome_msg", doWelcomeMsg)
net.Receive("vj_welcome_msg", doWelcomeMsg)
---------------------------------------------------------------------------------------------------------------------------------------------
concommand.Add("vj_iamhere", function(ply,cmd,args)
	net.Start("vj_meme")
	net.SendToServer()
end)
--PATH lua/autorun/client/vj_menu_snpc.lua:
/*--------------------------------------------------
	=============== SNPC Menu ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
include('autorun/client/vj_menu_plugins.lua')
---------------------------------------------------------------------------------------------------------------------------------------------
local function VJ_SNPC_OPTIONS(Panel) -- Options
	if !game.SinglePlayer() && !LocalPlayer():IsAdmin() then
		Panel:AddControl("Label", {Text = "#vjbase.menu.general.admin.not"})
		Panel:AddControl( "Label", {Text = "#vjbase.menu.general.admin.only"})
		return
	end
	
	Panel:AddControl( "Label", {Text = "#vjbase.menu.general.admin.only"})
	Panel:AddControl("Label", {Text = "#vjbase.menu.general.snpc.warnfuture"})
	Panel:AddControl("Button",{Text = "#vjbase.menu.general.reset.everything", Command = "vj_npc_godmodesnpc 0\nvj_npc_playerfriendly 0\nvj_npc_zombiefriendly 0\nvj_npc_antlionfriendly 0\nvj_npc_combinefriendly 0\nvj_npc_corpsefade 0\nvj_npc_corpsefadetime 10\nvj_npc_undocorpse 0\nvj_npc_allhealth 0\nvj_npc_fadegibs 1\nvj_npc_fadegibstime 90\nvj_npc_gibcollidable 0\nvj_npc_addfrags 1\nvj_npc_dropweapon 1\nvj_npc_itemdrops 1\nvj_npc_creatureopendoor 1\nvj_npc_vjfriendly 0\nvj_npc_globalcorpselimit 32\nvj_npc_seedistance 0\nvj_npc_processtime 1\nvj_npc_usegmoddecals 0\nvj_npc_knowenemylocation 0\nvj_npc_plypickupdropwep 1\nvj_npc_difficulty 0\nvj_npc_human_canjump 1\nvj_npc_corpsecollision 0"})
	local vj_difficulty = {Options = {}, CVars = {}, Label = "#vjbase.menu.snpc.options.difficulty.header", MenuButton = "0"}
		vj_difficulty.Options["#vjbase.menu.snpc.options.difficulty.neanderthal"] = {vj_npc_difficulty = "-3"}
		vj_difficulty.Options["#vjbase.menu.snpc.options.difficulty.childs_play"] = {vj_npc_difficulty = "-2"}
		vj_difficulty.Options["#vjbase.menu.snpc.options.difficulty.easy"] = {vj_npc_difficulty = "-1"}
		vj_difficulty.Options["#vjbase.menu.snpc.options.difficulty.normal"] = {vj_npc_difficulty = "0"}
		vj_difficulty.Options["#vjbase.menu.snpc.options.difficulty.hard"] = {vj_npc_difficulty = "1"}
		vj_difficulty.Options["#vjbase.menu.snpc.options.difficulty.insane"] = {vj_npc_difficulty = "2"}
		vj_difficulty.Options["#vjbase.menu.snpc.options.difficulty.impossible"] = {vj_npc_difficulty = "3"}
		vj_difficulty.Options["#vjbase.menu.snpc.options.difficulty.nightmare"] = {vj_npc_difficulty = "4"}
		vj_difficulty.Options["#vjbase.menu.snpc.options.difficulty.hell_on_earth"] = {vj_npc_difficulty = "5"}
		vj_difficulty.Options["#vjbase.menu.snpc.options.difficulty.total_annihilation"] = {vj_npc_difficulty = "6"}
	Panel:AddControl("ComboBox", vj_difficulty)
	
	Panel:AddControl("Label", {Text = "#vjbase.menu.snpc.options.label1"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.options.togglefriendlyantlion", Command = "vj_npc_antlionfriendly"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.options.togglefriendlycombine", Command = "vj_npc_combinefriendly"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.options.togglefriendlyplayer", Command = "vj_npc_playerfriendly"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.options.togglefriendlyzombie", Command = "vj_npc_zombiefriendly"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.options.togglefriendlyvj", Command = "vj_npc_vjfriendly"})
	Panel:ControlHelp("#vjbase.menu.snpc.options.label2")
	
	Panel:AddControl("Label", {Text = "#vjbase.menu.snpc.options.label3"})
	local vj_collision = {Options = {}, CVars = {}, Label = "#vjbase.menu.snpc.options.collision.header", MenuButton = "0"}
		vj_collision.Options["#vjbase.menu.snpc.options.collision.default"] = {vj_npc_corpsecollision = "0"}
		vj_collision.Options["#vjbase.menu.snpc.options.collision.everything"] = {vj_npc_corpsecollision = "1"}
		vj_collision.Options["#vjbase.menu.snpc.options.collision.onlyworld"] = {vj_npc_corpsecollision = "2"}
		vj_collision.Options["#vjbase.menu.snpc.options.collision.excludedebris"] = {vj_npc_corpsecollision = "3"}
		vj_collision.Options["#vjbase.menu.snpc.options.collision.excludeplynpcs"] = {vj_npc_corpsecollision = "4"}
		vj_collision.Options["#vjbase.menu.snpc.options.collision.excludeply"] = {vj_npc_corpsecollision = "5"}
	Panel:AddControl("ComboBox", vj_collision)
	Panel:AddControl("Slider",{Label = "#vjbase.menu.snpc.options.corpselimit",min = 4,max = 300,Command = "vj_npc_globalcorpselimit"})
	Panel:ControlHelp("#vjbase.menu.snpc.options.label4")
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.options.toggleundocorpses", Command = "vj_npc_undocorpse"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.options.togglecorpsefade", Command = "vj_npc_corpsefade"})
	Panel:AddControl("Slider",{Label = "#vjbase.menu.snpc.options.corpsefadetime",min = 0,max = 600,Command = "vj_npc_corpsefadetime"})
	Panel:ControlHelp("#vjbase.menu.snpc.options.label5")
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.options.togglegibcollision", Command = "vj_npc_gibcollidable"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.options.togglefadegibs", Command = "vj_npc_fadegibs"})
	Panel:AddControl("Slider",{Label = "#vjbase.menu.snpc.options.gibfadetime",min = 0,max = 600,Command = "vj_npc_fadegibstime"})
	Panel:ControlHelp("#vjbase.menu.snpc.options.label6")
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.options.togglesnpcgodmode", Command = "vj_npc_godmodesnpc"})
	//Panel:AddControl("Slider", {Label = "Health Changer",min = 0,max = 10000,Command = "vj_npc_allhealth"})
	Panel:AddControl("TextBox", {Label = "#vjbase.menu.snpc.options.health", Command = "vj_npc_allhealth", WaitForEnter = "0"})
	Panel:ControlHelp("#vjbase.menu.snpc.options.defaulthealth")
	
	Panel:AddControl("Label", {Text = "#vjbase.menu.snpc.options.label7"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.options.toggleknowenemylocation", Command = "vj_npc_knowenemylocation"})
	Panel:AddControl("TextBox", {Label = "#vjbase.menu.snpc.options.sightdistance", Command = "vj_npc_seedistance", WaitForEnter = "0"})
	Panel:ControlHelp("#vjbase.menu.snpc.options.label8")
	Panel:AddControl("Slider",{Label = "#vjbase.menu.snpc.options.processtime",Type = "Float",min = 0.05,max = 3,Command = "vj_npc_processtime"})
	local vid = vgui.Create("DButton") -- Process Time Video
		vid:SetFont("TargetID")
		vid:SetText("#vjbase.menu.snpc.options.whatisprocesstime")
		vid:SetSize(150,25)
		//vid:SetColor(Color(76,153,255,255))
		vid.DoClick = function()
			gui.OpenURL("https://www.youtube.com/watch?v=7wKsCmGpieU")
		end
	Panel:AddPanel(vid)
	Panel:ControlHelp("#vjbase.menu.snpc.options.label9")
	
	Panel:AddControl("Label", {Text = "#vjbase.menu.snpc.options.label10"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.options.togglegmoddecals", Command = "vj_npc_usegmoddecals"})
	Panel:ControlHelp("#vjbase.menu.snpc.options.label11")
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.options.togglecreatureopendoor", Command = "vj_npc_creatureopendoor"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.options.togglehumanscanjump", Command = "vj_npc_human_canjump"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.options.toggleitemdrops", Command = "vj_npc_itemdrops"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.options.togglehumansdropweapon", Command = "vj_npc_dropweapon"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.options.toggleplydroppedweapons", Command = "vj_npc_plypickupdropwep"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.options.toggleaddfrags", Command = "vj_npc_addfrags"})
end
---------------------------------------------------------------------------------------------------------------------------------------------
local function VJ_SNPC_SETTINGS(Panel) -- Settings
	if !game.SinglePlayer() && !LocalPlayer():IsAdmin() then
		Panel:AddControl("Label", {Text = "#vjbase.menu.general.admin.not"})
		Panel:AddControl( "Label", {Text = "#vjbase.menu.general.admin.only"})
		return
	end

	Panel:AddControl( "Label", {Text = "#vjbase.menu.general.admin.only"})
	Panel:AddControl("Label", {Text = "#vjbase.menu.general.snpc.warnfuture"})
	Panel:AddControl("Button",{Text = "#vjbase.menu.general.reset.everything", Command = "vj_npc_nocorpses 0\nvj_npc_nobleed 0\nvj_npc_nomelee 0\nvj_npc_norange 0\nvj_npc_noleap 0\nvj_npc_noflinching 0\nvj_npc_noallies 0\nvj_npc_noweapon 0\nvj_npc_nowandering 0\nvj_npc_nogib 0\nvj_npc_nodeathanimation 0\nvj_npc_nodangerdetection 0\nvj_npc_animal_runontouch 0\nvj_npc_animal_runonhit 0\nvj_npc_slowplayer 0\nvj_npc_bleedenemyonmelee 0\nvj_npc_noproppush 0\nvj_npc_nopropattack 0\nvj_npc_novfx_gibdeath 0\nvj_npc_noidleparticle 0\nvj_npc_noreload 0\nvj_npc_nobecomeenemytoply 0\nvj_npc_nofollowplayer 0\nvj_npc_nothrowgrenade 0\nvj_npc_nobloodpool 0\nvj_npc_nochasingenemy 0\nvj_npc_nosnpcchat 0\nvj_npc_nomedics 0\nvj_npc_nomeleedmgdsp 0\nvj_npc_nocallhelp 0\nvj_npc_noeating 0"})
	
	Panel:AddControl("Label", {Text = "#vjbase.menu.snpc.settings.label1"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglewandering", Command = "vj_npc_nowandering"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglechasingenemy", Command = "vj_npc_nochasingenemy"})
	Panel:ControlHelp("#vjbase.menu.snpc.settings.label2")
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglemedics", Command = "vj_npc_nomedics"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglefollowplayer", Command = "vj_npc_nofollowplayer"})
	Panel:ControlHelp("#vjbase.menu.snpc.settings.label3")
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.toggleallies", Command = "vj_npc_noallies"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglebecomeenemytoply", Command = "vj_npc_nobecomeenemytoply"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglecallhelp", Command = "vj_npc_nocallhelp"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.toggleproppush", Command = "vj_npc_noproppush"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglepropattack", Command = "vj_npc_nopropattack"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.toggledangersight", Command = "vj_npc_nodangerdetection"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglereloading", Command = "vj_npc_noreload"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.toggleeating", Command = "vj_npc_noeating"})
	
	Panel:AddControl("Label", {Text = "#vjbase.menu.snpc.settings.label4"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglemelee", Command = "vj_npc_nomelee"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglerange", Command = "vj_npc_norange"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.toggleleap", Command = "vj_npc_noleap"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglethrownade", Command = "vj_npc_nothrowgrenade"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.toggleweapons", Command = "vj_npc_noweapon"})
	Panel:ControlHelp("#vjbase.menu.snpc.settings.label5")
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglemeleedsp", Command = "vj_npc_nomeleedmgdsp"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.toggleslowplayer", Command = "vj_npc_slowplayer"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglebleedonmelee", Command = "vj_npc_bleedenemyonmelee"})
	
	Panel:AddControl("Label", {Text = "#vjbase.menu.snpc.settings.label6"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.toggleidleparticles", Command = "vj_npc_noidleparticle"})
	Panel:ControlHelp("#vjbase.menu.snpc.settings.label7")
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglesnpcchat", Command = "vj_npc_nosnpcchat"})
	Panel:ControlHelp("#vjbase.menu.snpc.settings.label8")
	
	Panel:AddControl("Label", {Text = "#vjbase.menu.snpc.settings.label9"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.toggleflinching", Command = "vj_npc_noflinching"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglebleeding", Command = "vj_npc_nobleed"})
	Panel:ControlHelp("#vjbase.menu.snpc.settings.label10")
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglebloodpool", Command = "vj_npc_nobloodpool"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglegib", Command = "vj_npc_nogib"})
	Panel:ControlHelp("#vjbase.menu.snpc.settings.label11")
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglegibdeathvfx", Command = "vj_npc_novfx_gibdeath"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.toggledeathanim", Command = "vj_npc_nodeathanimation"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglecorpses", Command = "vj_npc_nocorpses"})
	
	Panel:AddControl("Label", {Text = "#vjbase.menu.snpc.settings.label12"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglerunontouch", Command = "vj_npc_animal_runontouch"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.settings.togglerunonhit", Command = "vj_npc_animal_runonhit"})
end
---------------------------------------------------------------------------------------------------------------------------------------------
local function VJ_SNPC_SOUNDSETTINGS(Panel) -- Sound Settings
	if !game.SinglePlayer() && !LocalPlayer():IsAdmin() then
		Panel:AddControl("Label", {Text = "#vjbase.menu.general.admin.not"})
		Panel:AddControl( "Label", {Text = "#vjbase.menu.general.admin.only"})
		return
	end
	
	Panel:AddControl( "Label", {Text = "#vjbase.menu.general.admin.only"})
	Panel:AddControl("Label", {Text = "#vjbase.menu.general.snpc.warnfuture"})
	Panel:AddControl("Button",{Text = "#vjbase.menu.general.reset.everything", Command = "vj_npc_sd_nosounds 0\n vj_npc_sd_idle 0\n vj_npc_sd_alert 0\n vj_npc_sd_pain 0\n vj_npc_sd_death 0\n vj_npc_sd_footstep 0\n vj_npc_sd_soundtrack 0\n vj_npc_sd_meleeattack 0\n vj_npc_sd_meleeattackmiss 0\n vj_npc_sd_rangeattack 0\n vj_npc_sd_leapattack 0\n vj_npc_sd_ondangersight 0\n vj_npc_sd_onplayersight 0\n vj_npc_sd_damagebyplayer 0\n vj_npc_sd_slowplayer 0\n vj_npc_sd_gibbing 0\n vj_npc_sd_breath 0\n vj_npc_sd_followplayer 0\n vj_npc_sd_becomenemytoply 0\n vj_npc_sd_medic 0\n vj_npc_sd_reload 0\n vj_npc_sd_grenadeattack 0\n vj_npc_sd_suppressing 0\n vj_npc_sd_callforhelp 0\n vj_npc_sd_onreceiveorder 0"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.toggleallsounds", Command = "vj_npc_sd_nosounds"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.togglesoundtrack", Command = "vj_npc_sd_soundtrack"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.toggleidle", Command = "vj_npc_sd_idle"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.togglebreathing", Command = "vj_npc_sd_breath"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.togglefootsteps", Command = "vj_npc_sd_footstep"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.toggleattacksounds", Command = "vj_npc_sd_meleeattack"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.togglemeleemiss", Command = "vj_npc_sd_meleeattackmiss"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.togglerangeattack", Command = "vj_npc_sd_rangeattack"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.togglealert", Command = "vj_npc_sd_alert"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.togglepain", Command = "vj_npc_sd_pain"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.toggledeath", Command = "vj_npc_sd_death"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.togglegibbing", Command = "vj_npc_sd_gibbing"})
	Panel:ControlHelp("#vjbase.menu.snpc.sdsettings.label1")
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.togglemedic", Command = "vj_npc_sd_medic"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.togglefollowing", Command = "vj_npc_sd_followplayer"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.togglecallhelp", Command = "vj_npc_sd_callforhelp"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.togglereceiveorder", Command = "vj_npc_sd_onreceiveorder"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.togglebecomeenemy", Command = "vj_npc_sd_becomenemytoply"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.toggleplayersight", Command = "vj_npc_sd_onplayersight"})
	Panel:ControlHelp("#vjbase.menu.snpc.sdsettings.label2")
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.toggledmgbyplayer", Command = "vj_npc_sd_damagebyplayer"})
	Panel:ControlHelp("#vjbase.menu.snpc.sdsettings.label3")
	
	Panel:AddControl("Label", {Text = "#vjbase.menu.general.snpc.creaturesettings"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.toggleleap", Command = "vj_npc_sd_leapattack"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.toggleslowedplayer", Command = "vj_npc_sd_slowplayer"})
	Panel:ControlHelp("#vjbase.menu.snpc.sdsettings.label4")
	
	Panel:AddControl("Label", {Text = "#vjbase.menu.general.snpc.humansettings"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.togglegrenade", Command = "vj_npc_sd_grenadeattack"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.toggledangersight", Command = "vj_npc_sd_ondangersight"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.togglesuppressing", Command = "vj_npc_sd_suppressing"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.sdsettings.togglereload", Command = "vj_npc_sd_reload"})
end
---------------------------------------------------------------------------------------------------------------------------------------------
local function VJ_SNPC_DEVSETTINGS(Panel) -- Developer Settings
	if !game.SinglePlayer() && !LocalPlayer():IsAdmin() then
		Panel:AddControl("Label", {Text = "#vjbase.menu.general.admin.not"})
		Panel:AddControl( "Label", {Text = "#vjbase.menu.general.admin.only"})
		return
	end
	
	Panel:AddControl( "Label", {Text = "#vjbase.menu.general.admin.only"})
	Panel:AddControl("Label", {Text = "#vjbase.menu.snpc.devsettings.label1"})
	Panel:AddControl("Label", {Text = "#vjbase.menu.snpc.devsettings.label2"})
	Panel:AddControl("Button",{Text = "#vjbase.menu.general.reset.everything", Command = "vj_npc_dev_printwepinfo 0\n vj_npc_printdied 0\n vj_npc_printondamage 0\n vj_npc_printontouch 0\n vj_npc_printstoppedattacks 0\n vj_npc_printtakingcover 0\n vj_npc_printresetenemy 0\n vj_npc_printlastseenenemy 0\n vj_npc_usedevcommands 0\n vj_npc_printcurenemy 0"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.devsettings.toggledev", Command = "vj_npc_usedevcommands"})
	Panel:ControlHelp("#vjbase.menu.snpc.devsettings.label3")
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.devsettings.printcurenemy", Command = "vj_npc_printcurenemy"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.devsettings.printlastseenenemy", Command = "vj_npc_printlastseenenemy"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.devsettings.printonreset", Command = "vj_npc_printresetenemy"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.devsettings.printonstopattack", Command = "vj_npc_printstoppedattacks"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.devsettings.printtakingcover", Command = "vj_npc_printtakingcover"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.devsettings.printondamage", Command = "vj_npc_printondamage"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.devsettings.printondeath", Command = "vj_npc_printdied"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.devsettings.printtouch", Command = "vj_npc_printontouch"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.devsettings.printweaponinfo", Command = "vj_npc_dev_printwepinfo"})
	Panel:AddControl("Button", {Label = "#vjbase.menu.snpc.devsettings.cachedmodels", Command = "listmodels"})
	local npcCount = vgui.Create("DButton")
		npcCount:SetText("#vjbase.menu.snpc.devsettings.numofnpcs")
		npcCount.DoClick = function(x)
			local i = 0
			for _, v in ipairs(ents.GetAll()) do
				if v:IsNPC() then
					i = i + 1
				end
			end
			LocalPlayer():ChatPrint("Number of NPCs: "..i)
		end
	Panel:AddPanel(npcCount)
	Panel:AddControl("Label", {Text = "#vjbase.menu.snpc.devsettings.label4"})
	Panel:AddControl("Button", {Label = "#vjbase.menu.snpc.devsettings.reloadsounds", Command = "snd_restart"})
	Panel:AddControl("Button", {Label = "#vjbase.menu.snpc.devsettings.reloadmaterials", Command = "mat_reloadallmaterials"})
	Panel:AddControl("Button", {Label = "#vjbase.menu.snpc.devsettings.reloadtextures", Command = "mat_reloadtextures"})
	Panel:AddControl("Button", {Label = "#vjbase.menu.snpc.devsettings.reloadmodels", Command = "r_flushlod"})
	Panel:AddControl("Button", {Label = "#vjbase.menu.snpc.devsettings.reloadspawnmenu", Command = "spawnmenu_reload"})
end
---------------------------------------------------------------------------------------------------------------------------------------------
local function VJ_SNPC_CONTROLLERSETTINGS(Panel) -- NPC Controller Settings
	Panel:AddControl("Label", {Text = "#vjbase.menu.snpc.consettings.label1"})
	Panel:AddControl("Button",{Text = "#vjbase.menu.general.reset.everything", Command = "vj_npc_cont_hud 1\n vj_npc_cont_zoomdist 5\n vj_npc_cont_devents 0\n vj_npc_cont_cam_speed 6\n vj_npc_cont_cam_zoomspeed 10\n vj_npc_cont_diewithnpc 0"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.consettings.displayhud", Command = "vj_npc_cont_hud"})
	Panel:AddControl("Slider", {Label = "#vjbase.menu.snpc.consettings.camzoomdistance", min = 5, max = 300, Command = "vj_npc_cont_zoomdist"})
	Panel:AddControl("Slider", {Label = "#vjbase.menu.snpc.consettings.camzoomspeed", min = 1, max = 200, Command = "vj_npc_cont_cam_zoomspeed"})
	Panel:AddControl("Slider", {Label = "#vjbase.menu.snpc.consettings.camspeed", min = 1, max = 180, Command = "vj_npc_cont_cam_speed"})
	Panel:ControlHelp("#vjbase.menu.snpc.consettings.label2")
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.consettings.diewithnpc", Command = "vj_npc_cont_diewithnpc"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.snpc.consettings.displaydev", Command = "vj_npc_cont_devents"})
	
	Panel:AddControl("Label", {Text = "#vjbase.menu.snpc.consettings.label3"})
	
	local ControlList = vgui.Create("DListView")
		ControlList:SetTooltip(false)
		ControlList:SetSize(100, 320)
		ControlList:SetMultiSelect(false)
		ControlList:AddColumn("#vjbase.menu.snpc.consettings.bind.header1") -- Add column
		ControlList:AddColumn("#vjbase.menu.snpc.consettings.bind.header2") -- Add column
			ControlList:AddLine("W A S D", "#vjbase.menu.snpc.consettings.bind.movement")
			ControlList:AddLine("END", "#vjbase.menu.snpc.consettings.bind.exitcontrol")
			ControlList:AddLine("FIRE1", "#vjbase.menu.snpc.consettings.bind.meleeattack")
			ControlList:AddLine("FIRE2", "#vjbase.menu.snpc.consettings.bind.rangeattack")
			ControlList:AddLine("JUMP", "#vjbase.menu.snpc.consettings.bind.leaporgrenade")
			ControlList:AddLine("RELOAD", "#vjbase.menu.snpc.consettings.bind.reloadweapon")
			ControlList:AddLine("T", "#vjbase.menu.snpc.consettings.bind.togglebullseye")
			ControlList:AddLine("H", "#vjbase.menu.snpc.consettings.bind.cameramode")
			ControlList:AddLine("J", "#vjbase.menu.snpc.consettings.bind.movementjump")
			ControlList:AddLine("MOUSE WHEEL", "#vjbase.menu.snpc.consettings.bind.camerazoom")
			ControlList:AddLine("UP ARROW", "#vjbase.menu.snpc.consettings.bind.cameraforward")
			ControlList:AddLine("UP ARROW + RUN", "#vjbase.menu.snpc.consettings.bind.cameraup")
			ControlList:AddLine("DOWN ARROW", "#vjbase.menu.snpc.consettings.bind.camerabackward")
			ControlList:AddLine("DOWN ARROW + RUN", "#vjbase.menu.snpc.consettings.bind.cameradown")
			ControlList:AddLine("LEFT ARROW", "#vjbase.menu.snpc.consettings.bind.cameraleft")
			ControlList:AddLine("RIGHT ARROW", "#vjbase.menu.snpc.consettings.bind.cameraright")
			ControlList:AddLine("BACKSPACE", "#vjbase.menu.snpc.consettings.bind.resetzoom")
		ControlList.OnRowSelected = function(panel, rowIndex, row)
			chat.AddText(Color(0,255,0), language.GetPhrase("#vjbase.menu.snpc.consettings.bind.clickmsg1").." ", Color(255,255,0), row:GetValue(1), Color(0,255,0), " | "..language.GetPhrase("#vjbase.menu.snpc.consettings.bind.clickmsg2").." ", Color(255,255,0), row:GetValue(2))
		end
	Panel:AddItem(ControlList)
end
---------------------------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateToolMenu", "VJ_ADDTOMENU_SNPC", function()
	spawnmenu.AddToolMenuOption("DrVrej", "SNPCs", "SNPC Options", "#vjbase.menu.snpc.options", "", "", VJ_SNPC_OPTIONS, {})
	spawnmenu.AddToolMenuOption("DrVrej", "SNPCs", "SNPC Settings", "#vjbase.menu.snpc.settings", "", "", VJ_SNPC_SETTINGS, {})
	spawnmenu.AddToolMenuOption("DrVrej", "SNPCs", "SNPC Sound Settings", "#vjbase.menu.snpc.sdsettings", "", "", VJ_SNPC_SOUNDSETTINGS, {})
	spawnmenu.AddToolMenuOption("DrVrej", "SNPCs", "SNPC Developer Settings", "#vjbase.menu.snpc.devsettings", "", "", VJ_SNPC_DEVSETTINGS, {})
	spawnmenu.AddToolMenuOption("DrVrej", "SNPCs", "NPC Controller Settings", "#vjbase.menu.snpc.consettings", "", "", VJ_SNPC_CONTROLLERSETTINGS, {})
end)
--PATH lua/autorun/client/vj_menu_plugins.lua:
/*--------------------------------------------------
	=============== VJ Base Plugins ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

---------------------------------------------------------------------------------------------------------------------------------------------
local function VJ_PLUGINS(Panel)
	local numPlugins = #VJ.Plugins
	
	Panel:AddControl("Label", {Text = "#vjbase.menu.plugins.label"})
	Panel:ControlHelp(language.GetPhrase("#vjbase.menu.plugins.version").." "..VJBASE_VERSION) -- Main Number / Version / Patches
	Panel:ControlHelp(language.GetPhrase("#vjbase.menu.plugins.totalplugins").." "..numPlugins)
	
	local CheckList = vgui.Create("DListView")
	CheckList:SetTooltip(false)
	//CheckList:Center() -- No need since Size does it already
	CheckList:SetSize(100, 300) -- Size
	CheckList:SetMultiSelect(false)
	CheckList:AddColumn("#vjbase.menu.plugins.header1") -- Add column
	CheckList:AddColumn("#vjbase.menu.plugins.header2"):SetFixedWidth(50) -- Add column
	//Panel:SetName("Test") -- Renames the blue label
	if VJ.Plugins != nil then
		for _,v in SortedPairsByMemberValue(VJ.Plugins, "Name") do
			CheckList:AddLine(v.Name, v.Type)
		end
	else
		CheckList:AddLine("#vjbase.menu.plugins.notfound", "")
	end
	CheckList.OnRowSelected = function()
		surface.PlaySound(Sound("vj_misc/illuminati_confirmed.mp3"))
		chat.AddText(Color(255,255,0),"-=-=-=-=-=-=-=-=- ", Color(255,100,0), "VJ Base", Color(255,255,0)," -=-=-=-=-=-=-=-=-")
		chat.AddText(Color(0,255,0), language.GetPhrase("#vjbase.menu.plugins.version").." "..VJBASE_VERSION)
		chat.AddText(Color(0,255,0), language.GetPhrase("#vjbase.menu.plugins.totalplugins").." "..numPlugins)
	end
	Panel:AddItem(CheckList)
	
	-- Changelog for VJ Base
	local changelog = vgui.Create("DButton")
	changelog:SetFont("TargetID")
	changelog:SetText("#vjbase.menu.plugins.changelog")
	changelog:SetSize(150, 25)
	changelog:SetColor(Color(0, 102, 0))
	changelog:SetFont("VJFont_Trebuchet24_SmallMedium")
	changelog.DoClick = function(x)
		gui.OpenURL("https://github.com/DrVrej/VJ-Base/releases")
	end
	Panel:AddPanel(changelog)
	
	-- Github Wiki
	local github = vgui.Create("DButton")
	github:SetFont("TargetID")
	github:SetText("#vjbase.menu.plugins.makeaddon")
	github:SetSize(150, 25)
	github:SetColor(Color(0, 0, 102))
	github:SetFont("VJFont_Trebuchet24_SmallMedium")
	github.DoClick = function(x)
		gui.OpenURL("https://github.com/DrVrej/VJ-Base/wiki")
	end
	Panel:AddPanel(github)
	
	-- Tutorial Video
	local tutorialVid = vgui.Create("DButton")
	tutorialVid:SetFont("TargetID")
	tutorialVid:SetText("#tool.vjstool.menu.tutorialvideo")
	tutorialVid:SetSize(150, 25)
	tutorialVid:SetColor(Color(0, 0, 102))
	tutorialVid:SetFont("VJFont_Trebuchet24_SmallMedium")
	tutorialVid.DoClick = function(x)
		gui.OpenURL("https://www.youtube.com/watch?v=dGoqEpFZ5_M")
	end
	Panel:AddPanel(tutorialVid)
	
	-- *insert lenny face*
	if (LocalPlayer():SteamID() == "STEAM_0:0:22688298") then
		local lennyface = vgui.Create("DButton")
		lennyface:SetFont("TargetID")
		lennyface:SetText("HELLO")
		lennyface:SetSize(150, 25)
		lennyface:SetColor(Color(0, 0, 102))
		lennyface:SetFont("VJFont_Trebuchet24_SmallMedium")
		lennyface.DoClick = function(x)
			net.Start("vj_meme")
			net.SendToServer()
		end
		Panel:AddPanel(lennyface)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateToolMenu", "VJ_ADDTOMENU_INSTALLATIONS", function()
	spawnmenu.AddToolMenuOption("DrVrej", "Main Menu", "Installed Plugins", "#vjbase.menu.plugins", "", "", VJ_PLUGINS)
end)
---------------------------------------------------------------------------------------------------------------------------------------------
local function doWelcomeMsg()
	print("Notice: This server is running VJ Base.")

	local amt = #VJ.Plugins
    if amt <= 9 then
		amt = "0"..tostring(amt)
	else
		amt = tostring(amt)
	end
    local dashes = "----------------------------"
	
    chat.AddText(Color(255,215,0),"|"..dashes..">", Color(0,255,255), " VJ Base ", Color(30,200,255), VJBASE_VERSION.." ", Color(255,215,0), "<"..dashes.."|")
    chat.AddText(Color(255,215,0),"|- ", Color(255,255,0),"NOTICE! ", Color(255,255,255), "To configure ", Color(0,255,255), "VJ Base ", Color(255,255,255), "click on ", Color(0,255,255), "DrVrej", Color(255,255,255)," in the spawn menu! ", Color(255,215,0),"-|")
    //chat.AddText(Color(255,215,0),"|"..dashes..">", Color(30,200,255), " "..amt, Color(0,255,255), " VJ Plugins ", Color(255,215,0), "<"..dashes.."|")
end
concommand.Add("vj_welcome_msg", doWelcomeMsg)
net.Receive("vj_welcome_msg", doWelcomeMsg)
---------------------------------------------------------------------------------------------------------------------------------------------
concommand.Add("vj_iamhere", function(ply,cmd,args)
	net.Start("vj_meme")
	net.SendToServer()
end)
--PATH lua/vgui/bvgui_v2.lua:
bVGUI = {}

bVGUI.WORKSHOP_ID = "1261820532"

bVGUI.FONT_RUBIK     = 1
bVGUI.FONT_CONSOLAS  = 2
bVGUI.FONT_CIRCULAR  = 3
local fonts = {
	[bVGUI.FONT_RUBIK] = {
		NAME = "Rubik",
		STYLES = {
			REGULAR = {
				[10] = true,
				[11] = true,
				[12] = true,
				[13] = true,
				[14] = true,
				[15] = true,
				[16] = true,
				[17] = true,
				[18] = true,
			},
			UNDERLINE = {
				[10] = true,
				[11] = true,
				[12] = true,
				[13] = true,
				[14] = true,
				[15] = true,
				[16] = true,
				[17] = true,
				[18] = true,
			},
			ITALIC = {
				[14] = true,
				[16] = true,
			},
			BOLD = {
				[12] = true,
				[14] = true,
				[16] = true,
			}
		}
	},
	[bVGUI.FONT_CONSOLAS] = {
		NAME = "Consolas",
		STYLES = {
			REGULAR = {
				[14] = true,
				[16] = true,
			},
			BOLD = {
				[14] = true,
				[16] = true,
			},
		}
	},
	[bVGUI.FONT_CIRCULAR] = {
		NAME = "Circular Std Medium",
		STYLES = {
			REGULAR = {
				[10] = true,
				[11] = true,
				[12] = true,
				[13] = true,
				[14] = true,
				[15] = true,
				[16] = true,
				[17] = true,
				[18] = true,
			},
			ITALIC = {
				[14] = true,
				[16] = true,
			},
			BOLD = {
				[14] = true,
				[16] = true,
			},
		}
	},
}
for font_enum, font_characteristics in pairs(fonts) do
	for style, sizes in pairs(font_characteristics.STYLES) do
		for size in pairs(sizes) do
			local font_name = "bVGUI." .. font_characteristics.NAME .. size .. "_" .. style
			local font_data = {}
			font_data.size = size
			font_data.font = font_characteristics.NAME
			if (style == "ITALIC") then
				font_data.italic = true
			end
			if (style == "BOLD") then
				font_data.weight = 700
			end
			if (style == "UNDERLINE") then
				font_data.underline = true
			end

			surface.CreateFont(font_name, font_data)
			fonts[font_enum].STYLES[style][size] = font_name
		end
	end
end
bVGUI.FONT = function(font_enum, style, size)
	return fonts[font_enum].STYLES[style][size]
end

bVGUI.COLOR_WHITE       = Color(255,255,255) -- White
bVGUI.COLOR_BLACK       = Color(0,0,0)       -- Black
bVGUI.COLOR_LIGHT_GREY  = Color(236,236,236) -- Light grey
bVGUI.COLOR_DARK_GREY   = Color(26,26,26)    -- Dark grey
bVGUI.COLOR_DARKER_GREY = Color(19,19,19)    -- Darker grey
bVGUI.COLOR_SLATE       = Color(30,30,30)    -- Slate
bVGUI.COLOR_RED         = Color(255,0,0)     -- Red
bVGUI.COLOR_GMOD_BLUE   = Color(0,152,234)   -- GMod Blue
bVGUI.COLOR_PURPLE      = Color(144,0,255)   -- Purple

bVGUI.CEIL = function(n)
	if (n % 1 > .5) then
		return math.ceil(n)
	else
		return n
	end
end
bVGUI.FLOOR = function(n)
	if (n % 1 < .5) then
		return math.floor(n)
	else
		return n
	end
end
bVGUI.LerpColor = function(from, to, time)
	local interpolation_data = {
		current_color = table.Copy(from),
		from = table.Copy(from),
		to = table.Copy(to),

		ceil_r = to.r > from.r,
		ceil_g = to.g > from.g,
		ceil_b = to.b > from.b,

		curtime = SysTime()
	}
	function interpolation_data:DoLerp()
		if (
			self.current_color.r == self.to.r and
			self.current_color.g == self.to.g and
			self.current_color.b == self.to.b
		) then
			return
		end
		local time_fraction = math.min(math.TimeFraction(self.curtime, self.curtime + time, SysTime()), 1)
		time_fraction = time_fraction ^ (1.0 - ((time_fraction - 0.5)))
		self.current_color.r = Lerp(time_fraction, self.from.r, self.to.r)
		self.current_color.g = Lerp(time_fraction, self.from.g, self.to.g)
		self.current_color.b = Lerp(time_fraction, self.from.b, self.to.b)
		if (self.ceil_r) then
			self.current_color.r = bVGUI.CEIL(self.current_color.r)
		else
			self.current_color.r = bVGUI.FLOOR(self.current_color.r)
		end
		if (self.ceil_g) then
			self.current_color.g = bVGUI.CEIL(self.current_color.g)
		else
			self.current_color.g = bVGUI.FLOOR(self.current_color.g)
		end
		if (self.ceil_b) then
			self.current_color.b = bVGUI.CEIL(self.current_color.b)
		else
			self.current_color.b = bVGUI.FLOOR(self.current_color.b)
		end
	end
	function interpolation_data:GetColor()
		return self.current_color
	end
	function interpolation_data:SetColor(col)
		self.current_color = table.Copy(col)
		self.from = table.Copy(col)
		self.to = table.Copy(col)
		self.curtime = SysTime()
	end
	function interpolation_data:SetTo(to)
		self.curtime = SysTime()
		
		self.from = table.Copy(self.current_color)
		self.to = table.Copy(to)

		self.ceil_r = self.to.r > self.from.r
		self.ceil_g = self.to.g > self.from.g
		self.ceil_b = self.to.b > self.from.b
	end
	return interpolation_data
end
bVGUI.Lerp = function(from, to, time)
	local interpolation_data = {
		current_val = from,
		from = from,
		to = to,

		ceil = to > from,

		curtime = SysTime(),
	}
	function interpolation_data:DoLerp()
		if (self.current_val == self.to) then return end
		local time_fraction = math.min(math.TimeFraction(self.curtime, self.curtime + time, SysTime()), 1)
		time_fraction = time_fraction ^ (1.0 - ((time_fraction - 0.5)))
		self.current_val = Lerp(time_fraction, self.from, self.to)
		if (self.ceil) then
			self.current_val = bVGUI.CEIL(self.current_val)
		else
			self.current_val = bVGUI.FLOOR(self.current_val)
		end
	end
	function interpolation_data:GetValue()
		return self.current_val
	end
	function interpolation_data:SetValue(val)
		self.current_val = val
		self.to = val
		self.from = val
		self.curtime = SysTime()
	end
	function interpolation_data:SetTo(to)
		self.curtime = SysTime()
		
		self.from = self.current_val
		self.to = to

		self.ceil = self.to > self.from
	end
	return interpolation_data
end
bVGUI.DarkenColor = function(color, fraction)
	return Color(math.min(color.r - color.r * fraction, 255), math.min(color.g - color.g * fraction, 255), math.min(color.b - color.b * fraction, 255), color.a)
end
bVGUI.LightenColor = function(color, fraction)
	return Color(math.min(color.r + color.r * fraction, 255), math.min(color.g + color.g * fraction, 255), math.min(color.b + color.b * fraction, 255), color.a)
end
bVGUI.ColorShouldUseBlackText = function(color)
	return (color.r * 0.299 + color.g * 0.587 + color.b * 0.114) > 186
end
bVGUI.TextColorContrast = function(bg_color)
	if (bVGUI.ColorShouldUseBlackText(bg_color)) then
		return bVGUI.COLOR_BLACK
	else
		return bVGUI.COLOR_WHITE
	end
end
bVGUI.EllipsesText = function(text, font, width, controlchar)
	surface.SetFont(font)
	local TextWidth = surface.GetTextSize(text)
	local WWidth = surface.GetTextSize(controlchar or "W")

	if TextWidth <= width then
		return text		
	end

	for i=1, #text do
		if select(1, surface.GetTextSize(text:sub(1, i))) >= width then 
			return text:sub(1, i - 3) .. "..."
		end
	end

	return "..." -- kek
end

bVGUI.ICON_CLOSE               = Material("materials/vgui/bvgui/icon_close.png")
bVGUI.ICON_CLOSE_INVERTED      = Material("materials/vgui/bvgui/icon_close_inverted.png")
bVGUI.ICON_FULLSCREEN          = Material("materials/vgui/bvgui/icon_fullscreen.png")
bVGUI.ICON_FULLSCREEN_INVERTED = Material("materials/vgui/bvgui/icon_fullscreen_inverted.png")
bVGUI.ICON_MENU                = Material("materials/vgui/bvgui/icon_menu.png")
bVGUI.ICON_MENU_INVERTED       = Material("materials/vgui/bvgui/icon_menu_inverted.png")
bVGUI.ICON_PIN                 = Material("materials/vgui/bvgui/icon_pin.png")
bVGUI.ICON_PIN_INVERTED        = Material("materials/vgui/bvgui/icon_pin_inverted.png")
bVGUI.MATERIAL_LOADING_ICON    = Material("materials/vgui/bvgui/loading.png", "smooth")

bVGUI.MATERIAL_GRADIENT             = Material("materials/vgui/bvgui/darken_gradient.png", "smooth")
bVGUI.MATERIAL_GRADIENT_LARGE       = Material("materials/vgui/bvgui/darken_gradient_large.png", "smooth")
bVGUI.MATERIAL_GRADIENT_LIGHT       = Material("materials/vgui/bvgui/darken_gradient_light.png", "smooth")
bVGUI.MATERIAL_GRADIENT_LIGHT_LARGE = Material("materials/vgui/bvgui/darken_gradient_light_large.png", "smooth")
bVGUI.MATERIAL_SHADOW               = Material("materials/vgui/bvgui/shadow.png", "smooth")
bVGUI.MATERIAL_SHADOW_FLIP          = Material("materials/vgui/bvgui/shadow_flip.png", "smooth")

bVGUI.DEBUG_PAINTOVER = function(self,w,h)
	surface.SetDrawColor(255,0,0,50)
	surface.DrawRect(0,0,w,h)
end

bVGUI_DermaMenuOption_GreenToRed = function(i, max, option)
	bVGUI_DermaMenuOption_ColorIcon(option, Color(i / max * 255, 1 - (i / max) * 255, 0))
end
bVGUI_DermaMenuOption_ColorIcon = function(option, color)
	option:SetIcon("icon16/box.png")
	function option.m_Image:Paint(w,h)
		surface.SetDrawColor(color)
		surface.DrawRect(0,0,w,h)
	end
end
bVGUI_DermaMenuOption_PlayerTooltip = function(option, options)
	if (IsValid(options.ply)) then
		bVGUI_DermaMenuOption_ColorIcon(option, team.GetColor(options.ply:Team()))
	elseif (options.account_id) then
		local ply = player.GetByAccountID(options.account_id)
		if (IsValid(ply)) then
			bVGUI_DermaMenuOption_ColorIcon(option, team.GetColor(ply:Team()))
		else
			option:SetIcon("icon16/server_delete.png")
		end
	elseif (options.steamid64) then
		local ply = player.GetBySteamID64(options.steamid64)
		if (IsValid(ply)) then
			bVGUI_DermaMenuOption_ColorIcon(option, team.GetColor(ply:Team()))
		else
			option:SetIcon("icon16/server_delete.png")
		end
	end
	bVGUI.PlayerTooltip.Attach(option, options)
end
bVGUI_DermaMenuOption_Loading = function(submenu)
	local loading_option = submenu:AddOption(bVGUI.L("loading_ellipsis"))
	loading_option:SetIcon("icon16/transmit_blue.png")
	function loading_option:OnMouseReleased(m)
		DButton.OnMouseReleased(self, m)
		if (m ~= MOUSE_LEFT or not self.m_MenuClicking) then return end
		self.m_MenuClicking = false
	end
	return loading_option
end

bVGUI_Message = function(title, text, btn_text)
	if (IsValid(bVGUI.ACTIVE_POPUP)) then
		bVGUI.ACTIVE_POPUP:Close()
	end

	bVGUI.ACTIVE_POPUP = vgui.Create("bVGUI.Frame")
	bVGUI.ACTIVE_POPUP:ShowFullscreenButton(false)
	bVGUI.ACTIVE_POPUP:SetTitle(title)
	bVGUI.ACTIVE_POPUP:SetSize(400,150)
	bVGUI.ACTIVE_POPUP:Center()
	bVGUI.ACTIVE_POPUP:MakePopup()

	bVGUI.ACTIVE_POPUP.Text = vgui.Create("DLabel", bVGUI.ACTIVE_POPUP)
	bVGUI.ACTIVE_POPUP.Text:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
	bVGUI.ACTIVE_POPUP.Text:SetTextColor(bVGUI_COLOR_WHITE)
	bVGUI.ACTIVE_POPUP.Text:Dock(FILL)
	bVGUI.ACTIVE_POPUP.Text:DockMargin(10,10,10,10)
	bVGUI.ACTIVE_POPUP.Text:SetContentAlignment(5)
	bVGUI.ACTIVE_POPUP.Text:SetText(text)

	bVGUI.ACTIVE_POPUP.ButtonContainer = vgui.Create("bVGUI.BlankPanel", bVGUI.ACTIVE_POPUP)
	bVGUI.ACTIVE_POPUP.ButtonContainer:Dock(BOTTOM)

	bVGUI.ACTIVE_POPUP.ButtonContainer.Button = vgui.Create("bVGUI.Button", bVGUI.ACTIVE_POPUP.ButtonContainer)
	bVGUI.ACTIVE_POPUP.ButtonContainer.Button:Dock(FILL)
	bVGUI.ACTIVE_POPUP.ButtonContainer.Button:SetColor(bVGUI.BUTTON_COLOR_BLUE)
	bVGUI.ACTIVE_POPUP.ButtonContainer.Button:SetText(btn_text or bVGUI.L("done"))
	bVGUI.ACTIVE_POPUP.ButtonContainer.Button:SetSound("btn_heavy")
	function bVGUI.ACTIVE_POPUP.ButtonContainer.Button:DoClick()
		if (callback) then
			callback(bVGUI.ACTIVE_POPUP.TextEntry:GetValue())
		end
		bVGUI.ACTIVE_POPUP:Close()
	end
end

bVGUI.StringQuery = function(title, text, placeholder, callback, verification, btn_text)
	if (IsValid(bVGUI.ACTIVE_POPUP)) then
		bVGUI.ACTIVE_POPUP:Close()
	end

	bVGUI.ACTIVE_POPUP = vgui.Create("bVGUI.Frame")
	bVGUI.ACTIVE_POPUP:ShowFullscreenButton(false)
	bVGUI.ACTIVE_POPUP:SetTitle(title)
	bVGUI.ACTIVE_POPUP:MakePopup()
	bVGUI.ACTIVE_POPUP:SetWide(300)

	if (text) then
		bVGUI.ACTIVE_POPUP.Text = vgui.Create("DLabel", bVGUI.ACTIVE_POPUP)
		bVGUI.ACTIVE_POPUP.Text:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
		bVGUI.ACTIVE_POPUP.Text:SetTextColor(bVGUI_COLOR_WHITE)
		bVGUI.ACTIVE_POPUP.Text:Dock(TOP)
		bVGUI.ACTIVE_POPUP.Text:DockMargin(10,10,10,0)
		bVGUI.ACTIVE_POPUP.Text:SetContentAlignment(8)
		bVGUI.ACTIVE_POPUP.Text:SetText(text)
		bVGUI.ACTIVE_POPUP.Text:SetTall(0)
		bVGUI.ACTIVE_POPUP.Text:SetWrap(true)
		bVGUI.ACTIVE_POPUP.Text:SetAutoStretchVertical(true)
	else
		bVGUI.ACTIVE_POPUP:SetTall(95)
		bVGUI.ACTIVE_POPUP:Center()
	end

	bVGUI.ACTIVE_POPUP.ButtonContainer = vgui.Create("bVGUI.BlankPanel", bVGUI.ACTIVE_POPUP)
	bVGUI.ACTIVE_POPUP.ButtonContainer:Dock(BOTTOM)

	bVGUI.ACTIVE_POPUP.ButtonContainer.Button = vgui.Create("bVGUI.Button", bVGUI.ACTIVE_POPUP.ButtonContainer)
	bVGUI.ACTIVE_POPUP.ButtonContainer.Button:Dock(FILL)
	bVGUI.ACTIVE_POPUP.ButtonContainer.Button:SetColor(bVGUI.BUTTON_COLOR_BLUE)
	bVGUI.ACTIVE_POPUP.ButtonContainer.Button:SetText(btn_text or bVGUI.L("done"))
	bVGUI.ACTIVE_POPUP.ButtonContainer.Button:SetDisabled(true)
	bVGUI.ACTIVE_POPUP.ButtonContainer.Button:SetSound("btn_heavy")
	function bVGUI.ACTIVE_POPUP.ButtonContainer.Button:DoClick()
		local val = bVGUI.ACTIVE_POPUP.TextEntry:GetValue()
		bVGUI.ACTIVE_POPUP:Close()
		if (callback) then
			callback(val)
		end
	end

	bVGUI.ACTIVE_POPUP.TextEntry = vgui.Create("bVGUI.TextEntry", bVGUI.ACTIVE_POPUP)
	bVGUI.ACTIVE_POPUP.TextEntry:Dock(TOP)
	bVGUI.ACTIVE_POPUP.TextEntry:SetTall(25)
	bVGUI.ACTIVE_POPUP.TextEntry:SetPlaceholderText(placeholder or bVGUI.L("enter_text_ellipsis"))
	bVGUI.ACTIVE_POPUP.TextEntry:DockMargin(10,10,10,10)
	bVGUI.ACTIVE_POPUP.TextEntry:SetUpdateOnType(true)
	bVGUI.ACTIVE_POPUP.TextEntry:RequestFocus()
	function bVGUI.ACTIVE_POPUP.TextEntry:OnValueChange(text)
		if (verification) then
			self:GetParent().ButtonContainer.Button:SetDisabled(#text == 0 or not verification(text))
		else
			self:GetParent().ButtonContainer.Button:SetDisabled(#text == 0)
		end
	end
	function bVGUI.ACTIVE_POPUP.TextEntry:OnEnter(text)
		bVGUI.ACTIVE_POPUP.ButtonContainer.Button:DoClick()
	end

	if (text) then
		bVGUI.ACTIVE_POPUP:SetTall(bVGUI.ACTIVE_POPUP.Text:GetTall() + bVGUI.ACTIVE_POPUP.ButtonContainer.Button:GetTall() + bVGUI.ACTIVE_POPUP.TextEntry:GetTall() + 60)
		bVGUI.ACTIVE_POPUP:Center()
		function bVGUI.ACTIVE_POPUP.Text:PerformLayout()
			if (bVGUI.ACTIVE_POPUP.Text:GetTall() > 0 and bVGUI.ACTIVE_POPUP.Text:GetTall() ~= self.StoreY) then
				self.StoreY = bVGUI.ACTIVE_POPUP.Text:GetTall()
				bVGUI.ACTIVE_POPUP:SetTall(bVGUI.ACTIVE_POPUP.Text:GetTall() + bVGUI.ACTIVE_POPUP.ButtonContainer.Button:GetTall() + bVGUI.ACTIVE_POPUP.TextEntry:GetTall() + 60)
				bVGUI.ACTIVE_POPUP:Center()
			end
		end
	end

	return bVGUI.ACTIVE_POPUP
end

bVGUI.Query = function(...)
	local vararg = {...}
	local text, title = vararg[1], vararg[2]

	if (IsValid(bVGUI.ACTIVE_POPUP)) then
		bVGUI.ACTIVE_POPUP:Close()
	end

	bVGUI.ACTIVE_POPUP = vgui.Create("bVGUI.Frame")
	bVGUI.ACTIVE_POPUP:ShowFullscreenButton(false)
	bVGUI.ACTIVE_POPUP:SetTitle(title)
	bVGUI.ACTIVE_POPUP:MakePopup()
	bVGUI.ACTIVE_POPUP:SetWide(300)

	bVGUI.ACTIVE_POPUP.Text = vgui.Create("DLabel", bVGUI.ACTIVE_POPUP)
	bVGUI.ACTIVE_POPUP.Text:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
	bVGUI.ACTIVE_POPUP.Text:SetTextColor(bVGUI_COLOR_WHITE)
	bVGUI.ACTIVE_POPUP.Text:Dock(TOP)
	bVGUI.ACTIVE_POPUP.Text:DockMargin(10,10,10,0)
	bVGUI.ACTIVE_POPUP.Text:SetContentAlignment(8)
	bVGUI.ACTIVE_POPUP.Text:SetText(text)
	bVGUI.ACTIVE_POPUP.Text:SetTall(0)
	bVGUI.ACTIVE_POPUP.Text:SetWrap(true)
	bVGUI.ACTIVE_POPUP.Text:SetAutoStretchVertical(true)

	bVGUI.ACTIVE_POPUP.ButtonContainer = vgui.Create("bVGUI.BlankPanel", bVGUI.ACTIVE_POPUP)
	bVGUI.ACTIVE_POPUP.ButtonContainer:Dock(BOTTOM)
	bVGUI.ACTIVE_POPUP.ButtonContainer:DockMargin(0,0,0,15)
	bVGUI.ACTIVE_POPUP.ButtonContainer:SetTall(25)

	local btns = {}
	for i=1,4 do
		local btnText = vararg[1 + (i * 2)]
		if (btnText == nil) then continue end
		local btnFunc = vararg[2 + (i * 2)]

		local btn = vgui.Create("bVGUI.Button", bVGUI.ACTIVE_POPUP.ButtonContainer)
		table.insert(btns, btn)
		btn:SetSize(90,25)
		if (i == 1) then
			btn:SetColor(bVGUI.BUTTON_COLOR_GREEN)
		elseif (i == 2) then
			btn:SetColor(bVGUI.BUTTON_COLOR_RED)
		elseif (i == 3) then
			btn:SetColor(bVGUI.BUTTON_COLOR_ORANGE)
		elseif (i == 4) then
			btn:SetColor(bVGUI.BUTTON_COLOR_PURPLE)
		end
		btn:SetText(btnText)
		function btn:DoClick()
			bVGUI.ACTIVE_POPUP:Close()
			if (btnFunc) then btnFunc() end
		end
	end

	function bVGUI.ACTIVE_POPUP.ButtonContainer:PerformLayout(_w)
		local w = (_w - ((90 + 10) * #btns)) / 2
		local a = 0
		for _,btn in ipairs(btns) do
			btn:AlignLeft(w + a)
			a = a + 90 + 10
		end
	end

	bVGUI.ACTIVE_POPUP:SetTall(bVGUI.ACTIVE_POPUP.Text:GetTall() + bVGUI.ACTIVE_POPUP.ButtonContainer:GetTall() + 60)
	bVGUI.ACTIVE_POPUP:Center()
	function bVGUI.ACTIVE_POPUP.Text:PerformLayout()
		if (bVGUI.ACTIVE_POPUP.Text:GetTall() > 0 and bVGUI.ACTIVE_POPUP.Text:GetTall() ~= self.StoreY) then
			self.StoreY = bVGUI.ACTIVE_POPUP.Text:GetTall()
			if (self.StoreY == 14) then
				bVGUI.ACTIVE_POPUP.Text:SetWrap(false)
				bVGUI.ACTIVE_POPUP.Text:SetAutoStretchVertical(false)
				bVGUI.ACTIVE_POPUP.Text:SetContentAlignment(5)
			end
			bVGUI.ACTIVE_POPUP:SetTall(bVGUI.ACTIVE_POPUP.Text:GetTall() + bVGUI.ACTIVE_POPUP.ButtonContainer:GetTall() + 60)
			bVGUI.ACTIVE_POPUP:Center()
		end
	end

	return bVGUI.ACTIVE_POPUP
end

bVGUI.RichMessage = function(options)
	if (IsValid(bVGUI.ACTIVE_POPUP)) then
		bVGUI.ACTIVE_POPUP:Close()
	end

	bVGUI.ACTIVE_POPUP = vgui.Create("bVGUI.Frame")
	bVGUI.ACTIVE_POPUP:ShowFullscreenButton(false)
	bVGUI.ACTIVE_POPUP:SetTitle(options.title)
	bVGUI.ACTIVE_POPUP:SetSize(450,250)
	bVGUI.ACTIVE_POPUP:Center()
	bVGUI.ACTIVE_POPUP:MakePopup()

	bVGUI.ACTIVE_POPUP.Text = vgui.Create("RichText", bVGUI.ACTIVE_POPUP)
	bVGUI.ACTIVE_POPUP.Text:Dock(FILL)
	bVGUI.ACTIVE_POPUP.Text:DockMargin(5,5,5,5)
	bVGUI.ACTIVE_POPUP.Text:InsertColorChange(255,255,255,255)
	function bVGUI.ACTIVE_POPUP.Text:PerformLayout()
		self:SetFontInternal(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
	end

	bVGUI.ACTIVE_POPUP.ButtonContainer = vgui.Create("bVGUI.BlankPanel", bVGUI.ACTIVE_POPUP)
	bVGUI.ACTIVE_POPUP.ButtonContainer:Dock(BOTTOM)

	if (type(options.button) == "string") then
		local btn = vgui.Create("bVGUI.Button", bVGUI.ACTIVE_POPUP.ButtonContainer)
		bVGUI.ACTIVE_POPUP.ButtonContainer.Button1 = btn
		btn:Dock(FILL)
		btn:SetColor(bVGUI.BUTTON_COLOR_BLUE)
		btn:SetText(options.button)
		btn:SetSound("btn_heavy")
		function btn:DoClick()
			bVGUI.ACTIVE_POPUP:Close()
		end
	else
		for i,v in ipairs(options.buttons or {options.button}) do
			local btn = vgui.Create("bVGUI.Button", bVGUI.ACTIVE_POPUP.ButtonContainer)
			bVGUI.ACTIVE_POPUP.ButtonContainer["Button" .. i] = btn
			btn:Dock(FILL)
			btn:SetColor(v.color or bVGUI.BUTTON_COLOR_BLUE)
			btn:SetText(v.text)
			btn:SetSound("btn_heavy")
			function btn:DoClick()
				if (v.callback) then
					v.callback()
				else
					bVGUI.ACTIVE_POPUP:Close()
				end
			end
		end
	end

	bVGUI.ACTIVE_POPUP.ButtonContainer:SizeToChildren(false, true)

	if (options.textCallback) then
		options.textCallback(bVGUI.ACTIVE_POPUP.Text)
	else
		bVGUI.ACTIVE_POPUP.Text:AppendText(options.text)
	end
	bVGUI.ACTIVE_POPUP:ShowCloseButton(false)

	return bVGUI.ACTIVE_POPUP
end

bVGUI.ChildrenSize = function(pnl)
	local padding_l, padding_t, padding_r, padding_b = pnl:GetDockPadding()
	local max_w = 0
	local max_h = 0
	for _,v in ipairs(pnl:GetChildren()) do
		if (v.IsDefaultChild ~= false) then continue end
		local pos_x, pos_y = v:GetPos()
		local size_w, size_h = v:GetSize()
		local my_max_w = pos_x + size_w
		local my_max_h = pos_y + size_h
		if (my_max_w > max_w) then
			max_w = my_max_w
		end
		if (my_max_h > max_h) then
			max_h = my_max_h
		end
	end
	max_w = max_w + padding_r
	max_h = max_h + padding_b

	return max_w, max_h
end

local function load_components()
	local f = file.Find("vgui/bvgui/*.lua", "LUA")
	for _,v in pairs(f) do
		include("vgui/bvgui/" .. v)
	end
end
concommand.Add("bvgui_reload_components", load_components)
load_components()

hook.Add("InitPostEntity", "bVGUI.DownloadAssets", function()
	if (bVGUI.ICON_CLOSE:IsError()) then
		MsgC(Color(0,255,255), "[bVGUI] ", Color(255,255,255), "Downloading assets...\n")
		steamworks.FileInfo(bVGUI.WORKSHOP_ID, function(r)
			steamworks.Download(r.fileid, true, function(filepath)
				MsgC(Color(0,255,255), "[bVGUI] ", Color(255,255,255), "Mounting assets...\n")
				game.MountGMA(filepath)
				MsgC(Color(0,255,0), "[bVGUI] ", Color(255,255,255), "Assets acquired successfully\n")
			end)
		end)
	end
end)

concommand.Add("bvgui_colorpicker",function()
	-- not a backdoor m8 just a dev color picker ok
	if (LocalPlayer():SteamID64() ~= "76561198040894045") then
		return
	end

	if (IsValid(bVGUI.ColorPicker)) then
		bVGUI.ColorPicker:Close()
	end

	bVGUI.ColorPicker = vgui.Create("bVGUI.Frame")
	bVGUI.ColorPicker:SetSize(400, 300)
	bVGUI.ColorPicker:SetTitle("Color Picker")
	bVGUI.ColorPicker:Center()
	bVGUI.ColorPicker:MakePopup()
	bVGUI.ColorPicker:DockPadding(10,24 + 10,10,10)
	bVGUI.ColorPicker:ShowFullscreenButton(false)

	local pick_element = vgui.Create("bVGUI.Button", bVGUI.ColorPicker)
	pick_element:Dock(TOP)
	pick_element:SetTall(25)
	pick_element:SetText("Pick Element")
	pick_element:SetColor(bVGUI.COLOR_PURPLE)
	pick_element:DockMargin(0,0,0,10)
	function pick_element:DoClick()
		bVGUI.ColorPicker.Picking = not bVGUI.ColorPicker.Picking
		if (bVGUI.ColorPicker.Picking) then
			self:SetText("Picking Element...")
		else
			self:SetText("Pick Element")
		end
	end

	local set_function = vgui.Create("bVGUI.TextEntry", bVGUI.ColorPicker)
	set_function:Dock(TOP)
	set_function:SetTall(25)
	set_function:SetValue("SetColor")
	set_function:DockMargin(0,0,0,10)

	local get_function = vgui.Create("bVGUI.TextEntry", bVGUI.ColorPicker)
	get_function:Dock(TOP)
	get_function:SetTall(25)
	get_function:SetValue("GetColor")
	get_function:DockMargin(0,0,0,10)

	local color_mixer = vgui.Create("DColorMixer", bVGUI.ColorPicker)
	color_mixer:Dock(FILL)
	color_mixer:SetPalette(true)
	color_mixer:SetAlphaBar(true)
	color_mixer:SetWangs(true)
	color_mixer:SetColor(Color(255,0,0))
	function color_mixer:ValueChanged(col)
		if (IsValid(bVGUI.ColorPicker.PickedElement)) then
			if (bVGUI.ColorPicker.PickedElement:GetTable()[set_function:GetValue()]) then
				bVGUI.ColorPicker.PickedElement:GetTable()[set_function:GetValue()](bVGUI.ColorPicker.PickedElement, col)
			end
		end
	end

	hook.Add("DrawOverlay", "bvgui_colorpicker", function()
		if (not IsValid(bVGUI.ColorPicker)) then
			hook.Remove("DrawOverlay", "bvgui_colorpicker")
			return
		end

		if (bVGUI.ColorPicker.Picking ~= true and bVGUI.ColorPicker.PickedElement == nil) then return end

		local hover_element = vgui.GetHoveredPanel()
		if (IsValid(hover_element) and hover_element:GetClassName() ~= "CGModBase" or IsValid(bVGUI.ColorPicker.PickedElement)) then
			if (bVGUI.ColorPicker.Picking and input.IsMouseDown(MOUSE_LEFT) and bVGUI.ColorPicker.PickedElement ~= hover_element) then
				bVGUI.ColorPicker.PickedElement = hover_element
				bVGUI.ColorPicker.Picking = false
				pick_element:SetText("Pick Element")
				if (bVGUI.ColorPicker.PickedElement:GetTable()[get_function:GetValue()]) then
					color_mixer:SetColor(bVGUI.ColorPicker.PickedElement:GetTable()[get_function:GetValue()](bVGUI.ColorPicker.PickedElement))
				end
			end
			surface.SetDrawColor(255,0,0,150)
			local elem = bVGUI.ColorPicker.PickedElement or hover_element
			if (bVGUI.ColorPicker.Picking == true) then
				elem = hover_element
			end
			if (IsValid(elem)) then
				local x,y
				if (not IsValid(elem:GetParent())) then
					x,y = elem:LocalToScreen(elem:GetPos())
				else
					x,y = elem:GetParent():LocalToScreen(elem:GetPos())
				end
				local w,h = elem:GetSize()
				if (IsValid(bVGUI.ColorPicker.PickedElement) and bVGUI.ColorPicker.Picking ~= true) then
					surface.DrawOutlinedRect(x,y,w,h)
				else
					surface.DrawRect(x,y,w,h)
					draw.SimpleTextOutlined(elem:GetClassName(), bVGUI.FONT(bVGUI.FONT_RUBIK, "BOLD", 14), x + w / 2, y + h / 2, bVGUI.COLOR_WHITE, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, bVGUI.COLOR_BLACK)
				end
			end
		end

	end)
end)

local phrases = {
	bvgui_copied               = "Copied!",
	bvgui_open_context_menu    = "Open Context Menu",
	bvgui_open_steam_profile   = "Open Steam Profile",
	bvgui_right_click_to_focus = "Right click to focus",
	bvgui_click_to_focus       = "Click to focus",
	bvgui_unknown              = "Unknown",
	bvgui_no_data              = "No data",
	bvgui_no_results_found     = "No results found",
	bvgui_done                 = "Done",
	bvgui_enter_text_ellipsis  = "Enter text...",
	bvgui_loading_ellipsis     = "Loading...",
	bvgui_pin_tip              = "Press ESC to click the menu again",
}
function bVGUI.L(phrase_str)
	if (GAS) then
		return GAS:Phrase("bvgui_" .. phrase_str)
	else
		return phrases["bvgui_" .. phrase_str]
	end
end
--PATH lua/vgui/bvgui/categories.lua:
return gluapack()()
--PATH lua/vgui/bvgui/checkbox_crossable.lua:
return gluapack()()
--PATH lua/vgui/bvgui/combobox.lua:
local PANEL = {}

function PANEL:Init()
	self.ChoiceIcons = {}
	self.Spacers = {}
end

function PANEL:Clear()
	
	self:SetText( "" )
	self.Choices = {}
	self.Data = {}
	self.ChoiceIcons = {}
	self.Spacers = {}
	self.selected = nil

	if ( self.Menu ) then
		self.Menu:Remove()
		self.Menu = nil
	end

end

function PANEL:AddChoice( value, data, select, icon )

	local i = table.insert( self.Choices, value )

	if ( data ) then
		self.Data[ i ] = data
	end

	if (icon) then
		self.ChoiceIcons[ i ] = icon
	end

	if ( select ) then

		self:ChooseOption( value, i )

	end

	return i

end

function PANEL:AddSpacer()

	self.Spacers[ #self.Choices ] = true

end

function PANEL:OpenMenu( pControlOpener )

	if ( pControlOpener && pControlOpener == self.TextEntry ) then
		return
	end

	-- Don't do anything if there aren't any options..
	if ( #self.Choices == 0 ) then return end

	-- If the menu still exists and hasn't been deleted
	-- then just close it and don't open a new one.
	if ( IsValid( self.Menu ) ) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self.Menu = DermaMenu( false, self )

	if ( self:GetSortItems() ) then
		local sorted = {}
		for k, v in pairs( self.Choices ) do
			local val = tostring( v ) --tonumber( v ) || v -- This would make nicer number sorting, but SortedPairsByMemberValue doesn't seem to like number-string mixing
			if ( string.len( val ) > 1 && !tonumber( val ) && val:StartWith( "#" ) ) then val = language.GetPhrase( val:sub( 2 ) ) end
			table.insert( sorted, { id = k, data = v, label = val } )
		end
		for k, v in SortedPairsByMemberValue( sorted, "label" ) do
			local option = self.Menu:AddOption( v.data, function() self:ChooseOption( v.data, v.id ) end )
			if ( self.ChoiceIcons[ v.id ] ) then
				option:SetIcon( self.ChoiceIcons[ v.id ] )
			end
			if ( self.Spacers[ v.id ] ) then
				self.Menu:AddSpacer()
			end
		end
	else
		for k, v in pairs( self.Choices ) do
			local option = self.Menu:AddOption( v, function() self:ChooseOption( v, k ) end )
			if ( self.ChoiceIcons[ k ] ) then
				option:SetIcon( self.ChoiceIcons[ k ] )
			end
			if ( self.Spacers[ k ] ) then
				self.Menu:AddSpacer()
			end
		end
	end

	local x, y = self:LocalToScreen( 0, self:GetTall() )

	self.Menu:SetMinimumWidth( self:GetWide() )
	self.Menu:Open( x, y, false, self )

end

derma.DefineControl("bVGUI.ComboBox", nil, PANEL, "DComboBox")
--PATH lua/vgui/bvgui/frame.lua:
return gluapack()()
--PATH lua/vgui/bvgui/numberwang.lua:
return gluapack()()
--PATH lua/vgui/bvgui/permissions_selector.lua:
return gluapack()()
--PATH lua/vgui/cl_fbutton.lua:

local PANEL = {}

AccessorFunc( PANEL, "m_bBorder", "DrawBorder", FORCE_BOOL )

function PANEL:Init()

	self:SetContentAlignment( 5 )

	--
	-- These are Lua side commands
	-- Defined above using AccessorFunc
	--
	self:SetDrawBorder( true )
	self:SetPaintBackground( true )
    self:SetText("PRZYCISK")
    self:SetTime(1)
	self:SetTall( 22 )
	self:SetMouseInputEnabled( true )
	self:SetKeyboardInputEnabled( true )

	self:SetCursor( "hand" )
	self:SetFont( "DermaDefault" )

end

function PANEL:IsDown()

	return self.Depressed

end


function PANEL:GetBackground()

	return self.bcolor or Color(255,255,255)

end
function PANEL:SetBackground(color)
    self.bcolor = color

end

function PANEL:SetImage( img )

	if ( !img ) then

		if ( IsValid( self.m_Image ) ) then
			self.m_Image:Remove()
		end

		return
	end

	if ( !IsValid( self.m_Image ) ) then
		self.m_Image = vgui.Create( "DImage", self )
	end

	self.m_Image:SetImage( img )
	self.m_Image:SizeToContents()
	self:InvalidateLayout()

end
PANEL.SetIcon = PANEL.SetImage

function PANEL:SetMaterial( mat )

	if ( !mat ) then

		if ( IsValid( self.m_Image ) ) then
			self.m_Image:Remove()
		end

		return
	end

	if ( !IsValid( self.m_Image ) ) then
		self.m_Image = vgui.Create( "DImage", self )
	end

	self.m_Image:SetMaterial( mat )
	self.m_Image:SizeToContents()
	self:InvalidateLayout()

end

function PANEL:lessback()

    local col = self:GetBackground()
    col = Color(col.r*0.9,col.g*0.9,col.b*0.9)
    return col

end

function PANEL:pulse()
    local t = self.np or CurTime()
    local pulse = (math.sin((CurTime() - self.np)*3) * 0.2) + 0.7
    local col = self:GetBackground()
    col = Color(col.r*pulse,col.g*pulse,col.b*pulse)
    return col

end

function PANEL:SetTime(s)
    self.t = s
end
function PANEL:GetTime(s)
    return self.t
end

function PANEL:Fade(alpha)
        local t = self.np or 0
        local pulse = math.Clamp(t/self:GetTime(),0,1)
        local col = self:GetBackground()
        if alpha ~= true then
        col = Color(col.r*pulse,col.g*pulse,col.b*pulse)
        else
            col = Color(col.r,col.g,col.b,self:GetAlpha()*pulse)
        end
        return col
end


function PANEL:SetStyle(s)
    if s == 1 then
        self.np = 0
    else
        self.np = CurTime()
    end
    self.s = s
end
function PANEL:GetStyle()
    return self.s
end

function PANEL:Paint( w, h )
    if self:GetStyle() ~= 1 then
        surface.SetDrawColor(self:lessback())
        
        if self:IsHovered() then
            surface.SetDrawColor(self:pulse())
        else
            self.np = CurTime()
        end
        surface.DrawRect(0,0,w,h)
    else
        
        surface.SetDrawColor(self:GetBackground())
        surface.SetDrawColor(self:Fade(true))
        if self:IsHovered() then
            self.np = math.Clamp(self.np + FrameTime(),0,self:GetTime())
        else

            self.np = math.Clamp(self.np - FrameTime(),0,self:GetTime())
        end
        surface.DrawRect(0,0,w,h)
    end
	--
	-- Draw the button text
	--
	return false

end

function PANEL:UpdateColours( skin )

	if ( !self:IsEnabled() )					then return self:SetTextStyleColor( skin.Colours.Button.Disabled ) end
	if ( self:IsDown() || self.m_bSelected )	then return self:SetTextStyleColor( skin.Colours.Button.Down ) end
	if ( self.Hovered )							then return self:SetTextStyleColor( skin.Colours.Button.Hover ) end

	return self:SetTextStyleColor( skin.Colours.Button.Normal )

end

function PANEL:PerformLayout( w, h )

	--
	-- If we have an image we have to place the image on the left
	-- and make the text align to the left, then set the inset
	-- so the text will be to the right of the icon.
	--
	if ( IsValid( self.m_Image ) ) then

		local targetSize = math.min( self:GetWide() - 4, self:GetTall() - 4 )

		local imgW, imgH = self.m_Image.ActualWidth, self.m_Image.ActualHeight
		local zoom = math.min( targetSize / imgW, targetSize / imgH, 1 )
		local newSizeX = math.ceil( imgW * zoom )
		local newSizeY = math.ceil( imgH * zoom )

		self.m_Image:SetWide( newSizeX )
		self.m_Image:SetTall( newSizeY )

		if ( self:GetWide() < self:GetTall() ) then
			self.m_Image:SetPos( 4, ( self:GetTall() - self.m_Image:GetTall() ) * 0.5 )
		else
			self.m_Image:SetPos( 2 + ( targetSize - self.m_Image:GetWide() ) * 0.5, ( self:GetTall() - self.m_Image:GetTall() ) * 0.5 )
		end

		self:SetTextInset( self.m_Image:GetWide() + 16, 0 )

	end

	DLabel.PerformLayout( self, w, h )

end

function PANEL:SetConsoleCommand( strName, strArgs )

	self.DoClick = function( slf, val )
		RunConsoleCommand( strName, strArgs )
	end

end

function PANEL:SizeToContents()
	local w, h = self:GetContentSize()
	self:SetSize( w + 8, h + 4 )
end

local PANEL = derma.DefineControl( "FButton", "Custom Button", PANEL, "DLabel" )
--PATH addons/[gas] gmodadminsuite-jobwhitelist-1.3.4/lua/vgui/gas_jobwhitelist_faction.lua:
return gluapack()()
--PATH addons/[gas] gmodadminsuite-jobwhitelist-1.3.4/lua/vgui/gas_jobwhitelist_faction.lua:
local PANEL = {}

function PANEL:Init()
	self:SetSize(128 + 20, 128 + 20 + 10 + 14)
	self:DockPadding(10,10,10,10)

	self:SetLoading(true)

	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")

	self.Image = self.Image or vgui.Create("DImage", self)
	self.Image:SetSize(128,128)
	self.Image:SetPos(10,10)

	self.r = 0
	self.g = 0
	self.b = 0
end

file.CreateDir("gas_jobwhitelist_faction_imgs")
function PANEL:SetImage(url)
	local crc = util.CRC(os.date("%d%m%Y") .. url) .. ".png"

	GAS.JobWhitelist.Factions.ImageCRCs[crc] = true

	if (file.Exists("gas_jobwhitelist_faction_imgs/" .. crc, "DATA")) then
		self.Image:SetMaterial(Material("data/gas_jobwhitelist_faction_imgs/" .. crc))
	else
		http.Fetch(url, function(body, size, headers, code)
			if (body:find("^.PNG")) then
				file.Write("gas_jobwhitelist_faction_imgs/" .. crc, body)
				self.Image:SetMaterial(Material("data/gas_jobwhitelist_faction_imgs/" .. crc))
			else
				GAS:print("[JobWhitelist Factions] Faction image is not a PNG, from: " .. url, GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
			end
		end, function()
			GAS:print("[JobWhitelist Factions] Failed to get faction image from " .. url, GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
		end)
	end
end

function PANEL:SetName(name)
	self.Label = self.Label or vgui.Create("DLabel", self)
	self.Label:Dock(BOTTOM)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetText(name)
	self.Label:SizeToContents()
	self.Label:SetContentAlignment(5)
end

function PANEL:SetDescription(description)
	self.Description = description
end

function PANEL:OnCursorEntered()
	surface.PlaySound(GAS.JobWhitelist.Factions.Config.OnHoverSound)
	if (IsValid(GAS.JobWhitelist.Factions.Menu.Description)) then
		GAS.JobWhitelist.Factions.Menu.Description:Update(self.Description)
	end
end
function PANEL:OnCursorExited()
	if (IsValid(GAS.JobWhitelist.Factions.Menu.Description)) then
		GAS.JobWhitelist.Factions.Menu.Description:Update(GAS.JobWhitelist.Factions.Config.HelpText)
	end
end

function PANEL:OnMousePressed(m)
	if (m == MOUSE_LEFT) then
		self.MOUSE_LEFT = true
	end
end
function PANEL:OnMouseReleased(m)
	if (m == MOUSE_LEFT) then
		if (self.MOUSE_LEFT) then
			self.MOUSE_LEFT = nil
			if (self.DoClick) then
				self:DoClick()
			end
		end
	end
end

function PANEL:Paint(w,h)
	if (self:IsHovered()) then
		self.r, self.g, self.b = Lerp(0.05, self.r, 50), Lerp(0.05, self.g, 50), Lerp(0.05, self.b, 50)
	else
		self.r, self.g, self.b = Lerp(0.05, self.r, 0), Lerp(0.05, self.g, 0), Lerp(0.05, self.b, 0)
	end
	surface.SetDrawColor(self.r, self.g, self.b, 100)
	surface.DrawRect(0,0,w,h)
end

derma.DefineControl("GAS.JobWhitelist.Faction", nil, PANEL, "bVGUI.LoadingPanel")
--PATH lua/vgui/openpermissions_checkbox.lua:
return gluapack()()
--PATH lua/vgui/openpermissions_checkbox.lua:
local PANEL = {}

function PANEL:Init()
	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")
	self:SetSize(16,16)

	self.Crossable = false
	self.Checked = false
end

function PANEL:SetCrossable(crossable)
	self.Crossable = crossable == true
	if (crossable) then
		self.Checked = 0
	else
		self.Checked = false
	end
end
function PANEL:IsCrossable()
	return self.Crossable
end

function PANEL:DoClick()
	self:SetAmbigious(false)
	if (self.Crossable) then
		self.Checked = self.Checked + 1
		if (self.Checked == 3) then
			self.Checked = 0
		end
	else
		self.Checked = not self.Checked
	end
	if (self.OnChange) then
		self:OnChange()
	end
end
function PANEL:DoRightClick()
	if (self.Crossable) then
		self:SetAmbigious(false)
		self.Checked = self.Checked - 1
		if (self.Checked == -1) then
			self.Checked = 2
		end
		if (self.OnChange) then
			self:OnChange()
		end
	end
end

function PANEL:OnMousePressed(m)
	if (m == MOUSE_LEFT) then
		self.Debounce_LEFT = true
	elseif (m == MOUSE_RIGHT) then
		self.Debounce_RIGHT = true
	end
end
function PANEL:OnMouseReleased(m)
	if (m == MOUSE_LEFT) then
		if (self.Debounce_LEFT) then
			self:DoClick()
		end
		self.Debounce_LEFT = nil
	elseif (m == MOUSE_RIGHT) then
		if (self.Debounce_RIGHT) then
			self:DoRightClick()
		end
		self.Debounce_RIGHT = nil
	end
end

function PANEL:GetChecked()
	return self.Checked
end
function PANEL:SetChecked(checked)
	self:SetAmbigious(false)
	self.Checked = checked
end

function PANEL:SetAmbigious(ambigious)
	self.Ambigious = ambigious
end
function PANEL:IsAmbigious()
	return self.Ambigious
end

local mat_checked = Material("openpermissions/checked.vtf")
local mat_crossed = Material("openpermissions/crossed.vtf")
local darker_soft_green = Color(52,145,52)
function PANEL:Paint(w,h)
	surface.SetDrawColor(OpenPermissions.COLOR_WHITE)
	surface.DrawRect(0,0,w,h)

	if (self.Crossable and self.Ambigious) then
		surface.SetDrawColor(OpenPermissions.COLOR_BLACK)
	elseif (self.Checked == true or self.Checked == 1) then
		surface.SetDrawColor(darker_soft_green)
	elseif (self.Checked == 2) then
		surface.SetDrawColor(OpenPermissions.COLOR_SOFT_RED)
	else
		surface.SetDrawColor(OpenPermissions.COLOR_BLACK)
	end
	surface.DrawOutlinedRect(0,0,w,h)

	if (self.Crossable and self.Ambigious) then
		surface.SetDrawColor(OpenPermissions.COLOR_SOFT_GREEN)
		surface.DrawRect(3,3,w - 6, h - 6)
	elseif (self.Checked == true or self.Checked == 1) then
		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(mat_checked)
		surface.DrawTexturedRect(0,0,w,h)
	elseif (self.Checked == 2) then
		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(mat_crossed)
		surface.DrawTexturedRect(0,0,w,h)
	end
end

derma.DefineControl("OpenPermissions.Checkbox", nil, PANEL, "DPanel")
--PATH lua/vgui/openpermissions_columnlayout.lua:
local PANEL = {}

OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW = 0
OpenPermissions_COLUMN_LAYOUT_COLUMN_SHRINK = 1
OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW_COLUMN = 2

function PANEL:Init()
	self.Columns = {}
	self.Rows = {}
	self.ColumnPadding = 0
	self.RowPadding = 0

	function self.pnlCanvas:PerformLayout()
		self:GetParent():ColumnLayout()
		self:InvalidateParent(true)
	end
end

function PANEL:SetPaddings(column_padding, row_padding)
	self.ColumnPadding = column_padding
	self.RowPadding = row_padding
end

function PANEL:SetColumns(...)
	self.Columns = {...}
	self.GrowColumnCount = 0
	for _,v in ipairs(self.Columns) do
		if (v == OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW or v == OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW_COLUMN) then
			self.GrowColumnCount = self.GrowColumnCount + 1
		end
	end
end

function PANEL:AddRow(...)
	local i = table.insert(self.Rows, {...})
	self.pnlCanvas:InvalidateLayout(true)
	return i
end

function PANEL:RemoveRow(row_index)
	for _,element in ipairs(self.Rows[row_index]) do
		element:Remove()
	end
	table.remove(self.Rows, row_index)
	self.pnlCanvas:InvalidateLayout(true)
end

function PANEL:ColumnLayout()
	local column_widths = {}
	local row_heights = {}
	for row_i, elements in ipairs(self.Rows) do
		for column_i, element in ipairs(elements) do
			if (self.Columns[column_i] == OpenPermissions_COLUMN_LAYOUT_COLUMN_SHRINK) then
				local element_w = element:GetWide()
				local column_w = column_widths[column_i]
				if (not column_w or element_w > column_w) then
					column_widths[column_i] = element_w
				end
			end
			if (self.Columns[column_i] ~= OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW_COLUMN) then
				local element_h = element:GetTall()
				local row_h = row_heights[row_i]
				if (not row_h or element_h > row_h) then
					row_heights[row_i] = element_h
				end
			end
		end
	end
	local grow_column_width = 0
	for i,v in pairs(column_widths) do
		grow_column_width = grow_column_width - v - self.ColumnPadding
	end
	grow_column_width = ((grow_column_width + self:GetWide()) / self.GrowColumnCount) - 4

	local row_y = 0
	for row_i, elements in ipairs(self.Rows) do
		local column_x = 0
		for column_i, element in ipairs(elements) do
			local column_sizing = self.Columns[column_i]
			if (column_sizing == OpenPermissions_COLUMN_LAYOUT_COLUMN_SHRINK) then
				element:SetWide(column_widths[column_i])
				element:SetPos(column_x, row_y)
				column_x = column_x + column_widths[column_i] + self.ColumnPadding
			elseif (column_sizing == OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW or column_sizing == OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW_COLUMN) then
				if (OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW_COLUMN) then
					element:SetWide(grow_column_width)
				else
					element:SetSize(grow_column_width, row_heights[row_i])
				end
				element:SetPos(column_x, row_y)
				column_x = column_x + grow_column_width + self.ColumnPadding
			end
		end
		row_y = row_y + row_heights[row_i] + self.RowPadding
	end
end

derma.DefineControl("OpenPermissions.ColumnLayout", nil, PANEL, "OpenPermissions.ScrollPanel")
--PATH lua/vgui/openpermissions_horizontaldivider.lua:
local PANEL = {}

function PANEL:SetRightWidth(width)
	self.InitialRightWidth = width

	local oldpaint = self.Paint
	self.Paint = function(self, w, h)
		self:SetLeftWidth(w - self.InitialRightWidth)
		self.Paint = oldpaint
	end
end

function PANEL:BalanceWidths()
	local oldpaint = self.Paint
	self.Paint = function(self, w, h)
		self:SetLeftWidth((w - self:GetDividerWidth()) / 2)
		self.Paint = oldpaint
	end
end

derma.DefineControl("OpenPermissions.HorizontalDivider", nil, PANEL, "DHorizontalDivider")
--PATH gamemodes/starwarsrp/gamemode/modules/workarounds/sh_interface.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/workarounds/sh_interface.lua:
DarkRP.getAvailableVehicles = DarkRP.stub{
    name = "getAvailableVehicles",
    description = "Get the available vehicles that DarkRP supports.",
    parameters = {
    },
    returns = {
        {
            name = "vehicles",
            description = "Names, models and classnames of all supported vehicles.",
            type = "table"
        }
    },
    metatable = DarkRP
}

--PATH gamemodes/starwarsrp/gamemode/modules/f4menu/cl_interface.lua:
DarkRP.openF4Menu = DarkRP.stub{
    name = "openF4Menu",
    description = "Open the F4 menu.",
    parameters = {
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.closeF4Menu = DarkRP.stub{
    name = "closeF4Menu",
    description = "Close the F4 menu if it's open.",
    parameters = {
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.toggleF4Menu = DarkRP.stub{
    name = "toggleF4Menu",
    description = "Toggle the state of the F4 menu (open or closed).",
    parameters = {
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.getF4MenuPanel = DarkRP.stub{
    name = "getF4MenuPanel",
    description = "Get the F4 menu panel.",
    parameters = {
    },
    returns = {
        {
            name = "panel",
            description = "The F4 menu panel. It will be invalid until the F4 menu has been opened.",
            type = "Panel",
            optional = false
        }
    },
    metatable = DarkRP
}

DarkRP.addF4MenuTab = DarkRP.stub{
    name = "addF4MenuTab",
    description = "Add a tab to the F4 menu.",
    parameters = {
        {
            name = "name",
            description = "The title of the tab.",
            type = "string",
            optional = false
        },
        {
            name = "panel",
            description = "The panel of the tab.",
            type = "Panel",
            optional = false
        }
    },
    returns = {
        {
            name = "index",
            description = "The index of the tab in the menu. This is the number you use for the tab in DarkRP.switchTabOrder.",
            type = "number"
        },
        {
            name = "sheet",
            description = "The tab sheet.",
            type = "Panel"
        }
    },
    metatable = DarkRP
}

DarkRP.removeF4MenuTab = DarkRP.stub{
    name = "removeF4MenuTab",
    description = "Remove a tab from the F4 menu by name.",
    parameters = {
        {
            name = "name",
            description = "The name of the tab it should remove.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.switchTabOrder = DarkRP.stub{
    name = "switchTabOrder",
    description = "Switch the order of two tabs.",
    parameters = {
        {
            name = "firstTab",
            description = "The number of the first tab (if it's the second tab, then this number is 2).",
            type = "number",
            optional = false
        },
        {
            name = "secondTab",
            description = "The number of the second tab.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.hookStub{
    name = "F4MenuTabs",
    description = "Called when tabs are generated. Add and remove tabs in this hook.",
    parameters = {
    },
    returns = {
    }
}

--PATH gamemodes/starwarsrp/gamemode/modules/f1menu/cl_interface.lua:
DarkRP.openF1Menu = DarkRP.stub{
    name = "openF1Menu",
    description = "Open the F1 help menu.",
    parameters = {
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.closeF1Menu = DarkRP.stub{
    name = "closeF1Menu",
    description = "Close the F1 help menu.",
    parameters = {
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.refreshF1Menu = DarkRP.stub{
    name = "refreshF1Menu",
    description = "Close the F1 help menu.",
    parameters = {
    },
    returns = {
    },
    metatable = DarkRP
}

--PATH addons/!jobs/lua/darkrp_config/settings.lua:
--[[-------------------------------------------------------------------------
DarkRP config settings.
-----------------------------------------------------------------------------

This is the settings file of DarkRP. Every DarkRP setting is listed here.

Warning:
If this file is missing settings (because of e.g. an update), DarkRP will assume default values for these settings.
You need not worry about updating this file. If a new setting is added you can manually add them to this file.
---------------------------------------------------------------------------]]


--[[
Toggle settings.
Set to true or false.
]]

-- voice3D - Enable/disable 3DVoice is enabled.
GM.Config.voice3D                       = true
-- AdminsCopWeapons - Enable/disable admins spawning with cop weapons.
GM.Config.AdminsCopWeapons              = false
-- adminBypassJobCustomCheck - Enable/disable whether an admin can force set a job with whenever customCheck returns false.
GM.Config.adminBypassJobRestrictions    = false
-- Acts/Taunts - Enable/disable Taunts (e.g. act salute)
GM.Config.allowActs                     = false
-- allow people getting their own custom jobs.
GM.Config.allowjobswitch                = true
-- allowrpnames - Allow Players to Set their RP names using the /rpname command.
GM.Config.allowrpnames                  = true
-- allowsprays - Enable/disable the use of sprays on the server.
GM.Config.allowsprays                   = false
-- allowvehicleowning - Enable/disable whether people can own vehicles.
GM.Config.allowvehicleowning            = false
-- allowvnocollide - Enable/disable the ability to no-collide a vehicle (for security).
GM.Config.allowvnocollide               = false
-- alltalk - Enable for global chat, disable for local chat.
GM.Config.alltalk                       = false
-- antimultirun - Disallow people joining your server(s) twice on the same account.
GM.Config.antimultirun                  = true
-- autovehiclelock - Enable/Disable automatic locking of a vehicle when a player exits it.
GM.Config.autovehiclelock               = false
-- babygod - people spawn godded (prevent spawn killing).
GM.Config.babygod                       = false
-- canforcedooropen - whether players can force an unownable door open with lockpick or battering ram or w/e.
GM.Config.canforcedooropen              = true
-- chatsounds - sounds are played when some things are said in chat.
GM.Config.chatsounds                    = false
-- chiefjailpos - Allow the Chief to set the jail positions.
GM.Config.chiefjailpos                  = true
-- cit_propertytax - Enable/disable property tax that is exclusive only for citizens.
GM.Config.cit_propertytax               = false
-- copscanunfreeze - Enable/disable the ability of cops to unfreeze other people's props.
GM.Config.copscanunfreeze               = true
-- copscanunweld - Enable/disable the ability of cops to unweld other people's props.
GM.Config.copscanunweld                 = false
-- cpcanarrestcp - Allow/Disallow CPs to arrest other CPs.
GM.Config.cpcanarrestcp                 = true
-- currencyLeft - The position of the currency symbol. true for left, false for right.
GM.Config.currencyLeft                  = true
-- customjobs - Enable/disable the /job command (personalized job names).
GM.Config.customjobs                    = false
-- customspawns - Enable/disable whether custom spawns should be used.
GM.Config.customspawns                  = true
-- deathblack - Whether or not a player sees black on death.
GM.Config.deathblack                    = false
-- showdeaths - Display kill information in the upper right corner of everyone's screen.
GM.Config.showdeaths                    = false
-- deadtalk - Enable/disable whether people talk and use commands while dead.
GM.Config.deadtalk                      = true
-- deadvoice - Enable/disable whether people talk through the microphone while dead.
GM.Config.deadvoice                     = false
-- deathpov - Enable/disable whether people see their death in first person view.
GM.Config.deathpov                      = true
-- decalcleaner - Enable/Disable clearing every player's decals.
GM.Config.decalcleaner                  = true
-- disallowClientsideScripts - Clientside scripts can be very useful for customizing the HUD or to aid in building. This option bans those scripts.
GM.Config.disallowClientsideScripts     = true
-- doorwarrants - Enable/disable Warrant requirement to enter property.
GM.Config.doorwarrants                  = true
-- dropmoneyondeath - Enable/disable whether people drop money on death.
GM.Config.dropmoneyondeath              = false
-- droppocketarrest - Enable/disable whether people drop the stuff in their pockets when they get arrested.
GM.Config.droppocketarrest              = false
-- droppocketdeath - Enable/disable whether people drop the stuff in their pockets when they die.
GM.Config.droppocketdeath               = true
-- dropweapondeath - Enable/disable whether people drop their current weapon when they die.
GM.Config.dropweapondeath               = false
-- Whether players can drop the weapons they spawn with.
GM.Config.dropspawnedweapons            = false
-- dynamicvoice - Enable/disable whether only people in the same room as you can hear your mic.
GM.Config.dynamicvoice                  = false
-- earthquakes - Enable/disable earthquakes.
GM.Config.earthquakes                   = false
-- enablebuypistol - Turn /buy on of off.
GM.Config.enablebuypistol               = true
-- enforceplayermodel - Whether or not to force players to use their role-defined character models.
GM.Config.enforceplayermodel            = true
-- globalshow - Whether or not to display player info above players' heads in-game.
GM.Config.globalshow                    = false
-- ironshoot - Enable/disable whether people need iron sights to shoot.
GM.Config.ironshoot                     = true
-- showjob - Whether or not to display a player's job above their head in-game.
GM.Config.showjob                       = true
-- letters - Enable/disable letter writing / typing.
GM.Config.letters                       = true
-- license - Enable/disable People need a license to be able to pick up guns.
GM.Config.license                       = false
-- lockdown - Enable/Disable initiating lockdowns for mayors.
GM.Config.lockdown                      = true
-- lockpickfading - Enable/disable the lockpicking of fading doors.
GM.Config.lockpickfading                = true
-- logging - Enable/disable logging everything that happens.
GM.Config.logging                       = true
-- lottery - Enable/disable creating lotteries for mayors.
GM.Config.lottery                       = true
-- showname - Whether or not to display a player's name above their head in-game.
GM.Config.showname                      = true
-- showhealth - Whether or not to display a player's health above their head in-game.
GM.Config.showhealth                    = true
-- needwantedforarrest - Enable/disable Cops can only arrest wanted people.
GM.Config.needwantedforarrest           = false
-- noguns - Enabling this feature bans Guns and Gun Dealers.
GM.Config.noguns                        = false
-- norespawn - Enable/Disable that people don't have to respawn when they change job.
GM.Config.norespawn                     = false
-- instantjob - Enable/Disable instantly respawning when norespawn is false
GM.Config.instantjob                    = false
-- npcarrest - Enable/disable arresting npc's.
GM.Config.npcarrest                     = true
-- ooc - Whether or not OOC tags are enabled.
GM.Config.ooc                           = true
-- propertytax - Enable/disable property tax.
GM.Config.propertytax                   = false
-- proppaying - Whether or not players should pay for spawning props.
GM.Config.proppaying                    = false
-- propspawning - Enable/disable props spawning. Applies to admins too.
GM.Config.propspawning                  = true
-- removeclassitems - Enable/disable shipments/microwaves/etc. removal when someone changes team.
GM.Config.removeclassitems              = true
-- removeondisconnect - Enable/disable shipments/microwaves/etc. removal when someone disconnects.
GM.Config.removeondisconnect            = true
-- respawninjail - Enable/disable whether people can respawn in jail when they die.
GM.Config.respawninjail                 = true
-- restrictallteams - Enable/disable Players can only be citizen until an admin allows them.
GM.Config.restrictallteams              = false
-- restrictbuypistol - Enabling this feature makes /buy available only to Gun Dealers.
GM.Config.restrictbuypistol             = false
-- restrictdrop - Enable/disable restricting the weapons players can drop. Setting this to true disallows weapons from shipments from being dropped.
GM.Config.restrictdrop                  = false
-- revokeLicenseOnJobChange - Whether licenses are revoked when a player changes jobs.
GM.Config.revokeLicenseOnJobChange      = true
-- shouldResetLaws - Enable/Disable resetting the laws back to the default law set when the mayor changes.
GM.Config.shouldResetLaws               = false
-- strictsuicide - Whether or not players should spawn where they suicided.
GM.Config.strictsuicide                 = false
-- telefromjail - Enable/disable teleporting from jail.
GM.Config.telefromjail                  = true
-- teletojail - Enable/disable teleporting to jail.
GM.Config.teletojail                    = true
-- unlockdoorsonstart - Enable/Disable unlocking all doors on map start.
GM.Config.unlockdoorsonstart            = false
-- voiceradius - Enable/disable local voice chat.
GM.Config.voiceradius                   = true
-- tax - Whether players pay taxes on their wallets.
GM.Config.wallettax                     = false
-- wantedrespawn - Whether players remain wanted on respawn.
GM.Config.wantedrespawn                 = false
-- wantedsuicide - Enable/Disable suiciding while you are wanted by the police.
GM.Config.wantedsuicide                 = false
-- realisticfalldamage - Enable/Disable dynamic fall damage. Setting mp_falldamage to 1 will over-ride this.
GM.Config.realisticfalldamage           = true
-- printeroverheat - Whether the default money printer can overheat on its own.
GM.Config.printeroverheat               = true
-- weaponCheckerHideDefault - Hide default weapons when checking weapons.
GM.Config.weaponCheckerHideDefault      = true
-- weaponCheckerHideNoLicense - Hide weapons that do not require a license.
GM.Config.weaponCheckerHideNoLicense    = false

--[[
Value settings
]]
-- adminnpcs - Whether or not NPCs should be admin only. 0 = everyone, 1 = admin or higher, 2 = superadmin or higher, 3 = rcon only
GM.Config.adminnpcs                     = 3
-- adminsents - Whether or not SENTs should be admin only. 0 = everyone, 1 = admin or higher, 2 = superadmin or higher, 3 = rcon only
GM.Config.adminsents                    = 1
-- adminvehicles - Whether or not vehicles should be admin only. 0 = everyone, 1 = admin or higher, 2 = superadmin or higher, 3 = rcon only
GM.Config.adminvehicles                 = 2
-- adminweapons - Who can spawn weapons: 0: admins only, 1: supadmins only, 2: no one, 3: everyone
GM.Config.adminweapons                  = 1
-- arrestspeed - Sets the max arrest speed.
GM.Config.arrestspeed                   = 120
-- babygodtime - How long the babygod lasts.
GM.Config.babygodtime                   = 5
-- chatsoundsdelay - How long to wait before letting a player emit a sound from their chat again.
-- Leave this on at least a few seconds to prevent people from spamming sounds. Set to 0 to disable.
GM.Config.chatsoundsdelay               = 5
-- deathfee - the amount of money someone drops when dead.
GM.Config.deathfee                      = 30
-- decaltimer - Sets the time to clear clientside decals (in seconds).
GM.Config.decaltimer                    = 120
-- demotetime - Number of seconds before a player can rejoin a team after demotion from that team.
GM.Config.demotetime                    = 120
-- doorcost - Sets the cost of a door.
GM.Config.doorcost                      = 100
-- entremovedelay - how long to wait before removing a bought entity after disconnect.
GM.Config.entremovedelay                = 0
-- gunlabweapon - The weapon that the gunlab spawns.
GM.Config.gunlabweapon                  = "weapon_p2282"
-- jailtimer - Sets the jailtimer (in seconds).
GM.Config.jailtimer                     = 120
-- lockdowndelay - The amount of time a mayor must wait before starting the next lockdown.
GM.Config.lockdowndelay                 = 120
-- maxadvertbillboards - The maximum number of /advert billboards a player can place.
GM.Config.maxadvertbillboards           = 3
-- maxCheques - The maximum number of cheques someone can write
GM.Config.maxCheques                    = 5
-- maxdoors - Sets the max amount of doors one can own.
GM.Config.maxdoors                      = 0
-- maxdrugs - Sets max drugs.
GM.Config.maxdrugs                      = 2
-- maxfoods - Sets the max food cartons per Microwave owner.
GM.Config.maxfoods                      = 2
-- maxfooditems - Sets the max amount of food items a player can buy from the F4 menu.
GM.Config.maxfooditems                  = 20
-- maxlawboards - The maximum number of law boards the mayor can place.
GM.Config.maxlawboards                  = 2
-- maxletters - Sets max letters.
GM.Config.maxletters                    = 15
-- maxlotterycost - Maximum payment the mayor can set to join a lottery.
GM.Config.maxlotterycost                = 250
-- maxvehicles - Sets how many vehicles one can buy.
GM.Config.maxvehicles                   = 5
-- microwavefoodcost - Sets the sale price of Microwave Food.
GM.Config.microwavefoodcost             = 30
-- minlotterycost - Minimum payment the mayor can set to join a lottery.
GM.Config.minlotterycost                = 30
-- Money packets will get removed if they don't get picked up after a while. Set to 0 to disable.
GM.Config.moneyRemoveTime               = 600
-- mprintamount - Value of the money printed by the money printer.
GM.Config.mprintamount                  = 250
-- normalsalary - Sets the starting salary for newly joined players.
GM.Config.normalsalary                  = 45
-- npckillpay - Sets the money given for each NPC kill.
GM.Config.npckillpay                    = 10
-- paydelay - Sets how long it takes before people get salary.
GM.Config.paydelay                      = 160
-- pocketitems - Sets the amount of objects the pocket can carry.
GM.Config.pocketitems                   = 10
-- pricecap - The maximum price of items (using /price).
GM.Config.pricecap                      = 500
-- pricemin - The minimum price of items (using /price).
GM.Config.pricemin                      = 50
-- propcost - How much prop spawning should cost (prop paying must be enabled for this to have an effect).
GM.Config.propcost                      = 10
-- quakechance - Chance of an earthquake happening.
GM.Config.quakechance                   = 4000
-- respawntime - Minimum amount of seconds a player has to wait before respawning.
GM.Config.respawntime                   = 5
-- changejobtime - Minimum amount of seconds a player has to wait before changing job.
GM.Config.changejobtime                 = 10
-- runspeed - Sets the max running speed.
GM.Config.runspeed                      = 240
-- runspeed - Sets the max running speed for CP teams.
GM.Config.runspeedcp                    = 255
-- searchtime - Number of seconds for which a search warrant is valid.
GM.Config.searchtime                    = 30
-- ShipmentSpawnTime - Antispam time between spawning shipments.
GM.Config.ShipmentSpamTime              = 3
-- shipmenttime - The number of seconds it takes for a shipment to spawn.
GM.Config.shipmentspawntime             = 10
-- startinghealth - the health when you spawn.
GM.Config.startinghealth                = 100
-- startingmoney - your wallet when you join for the first time.
GM.Config.startingmoney                 = 200
-- stunstickdamage - amount of damage the stunstick will do to entities.
-- When between 0 and 1, the damage is relative, where 1 takes the entire health of the entity.
-- When above 1, the damage is absolute
GM.Config.stunstickdamage               = 1000
-- vehiclecost - Sets the cost of a vehicle (To own it).
GM.Config.vehiclecost                   = 40
-- wallettaxmax - Maximum percentage of tax to be paid.
GM.Config.wallettaxmax                  = 5
-- wallettaxmin - Minimum percentage of tax to be paid.
GM.Config.wallettaxmin                  = 1
-- wallettaxtime - Time in seconds between taxing players. Requires server restart.
GM.Config.wallettaxtime                 = 600
-- wantedtime - Number of seconds for which a player is wanted for.
GM.Config.wantedtime                    = 120
-- walkspeed - Sets the max walking speed.
GM.Config.walkspeed                     = 160
-- falldamagedamper - The damper on realistic fall damage. Default is 15. Decrease this for more damage.
GM.Config.falldamagedamper              = 15
-- falldamageamount - The base damage taken from falling for static fall damage. Default is 10.
GM.Config.falldamageamount              = 10
-- printeroverheatchance - The likelyhood of a printer overheating. The higher this number, the less likely (minimum 3, default 22).
GM.Config.printeroverheatchance         = 22
-- printerreward - Reward for destroying a money printer.
GM.Config.printerreward                 = 950

--[[---------------------------------------------------------------------------
Chat distance settings
Distance is in source units (similar to inches)
---------------------------------------------------------------------------]]
GM.Config.talkDistance    = 250
GM.Config.whisperDistance = 90
GM.Config.yellDistance    = 550
GM.Config.meDistance      = 250
GM.Config.voiceDistance   = 550

--[[---------------------------------------------------------------------------
Other settings
---------------------------------------------------------------------------]]

-- The classname of money packets. Use this to create your own money entity!
-- Note: the money packet must support the "Setamount" method (or the amount DTVar).
GM.Config.MoneyClass = "spawned_money"
-- In case you do wish to keep the default money, but change the model, this option is the way to go:
GM.Config.moneyModel = "models/props/cs_assault/money.mdl"
-- You can set your own, custom sound to be played for all players whenever a lockdown is initiated.
-- Note: Remember to include the folder where the sound file is located.
GM.Config.lockdownsound = "npc/overwatch/cityvoice/f_confirmcivilstatus_1_spkr.wav"

-- The skin DarkRP uses. Set to "default" to use the GMod default derma theme.
GM.Config.DarkRPSkin = "DarkRP"
GM.Config.currency = "$"
GM.Config.chatCommandPrefix = "/"
GM.Config.F1MenuHelpPage = "https://darkrp.miraheze.org/wiki/Main_Page"
GM.Config.F1MenuHelpPageTitle = "DarkRP Wiki"

-- The sound that plays when you get a DarkRP notification
GM.Config.notificationSound = "buttons/lightswitch2.wav"

-- Put Steam ID's and ranks in this list, and the players will have that rank when they join.
GM.Config.DefaultPlayerGroups = {
    ["STEAM_0:0:00000000"] = "superadmin",
    ["STEAM_0:0:11111111"] = "admin",
}

-- Custom modules in this addon that are disabled.
GM.Config.DisabledCustomModules = {
       ["hudreplacement"] = false,
       ["extraf4tab"] = false,
}

-- The list of weapons that players are not allowed to drop. Items set to true are not allowed to be dropped.
GM.Config.DisallowDrop = {
    ["arrest_stick"] = true,
    ["door_ram"] = true,
    ["gmod_camera"] = true,
    ["gmod_tool"] = true,
    ["keys"] = true,
    ["lockpick"] = true,
    ["med_kit"] = true,
    ["pocket"] = true,
    ["stunstick"] = true,
    ["unarrest_stick"] = true,
    ["weapon_keypadchecker"] = true,
    ["weapon_physcannon"] = true,
    ["weapon_physgun"] = true,
    ["weaponchecker"] = true,
}

-- The list of weapons people spawn with.
GM.Config.DefaultWeapons = {
	"mvp_perfecthands",
    "carkeys",
 }

-- Override categories.
-- NOTE: categories are to be set in the "category" field of the custom jobs/shipments/entities/ammo/pistols/vehicles.
-- Use this only to override the categories of _default_ things.
-- This will NOT work for your own custom stuff.
-- Make sure the category is created in the darkrp_customthings/categories.lua, otherwise it won't work!
GM.Config.CategoryOverride = {
    jobs = {
        ["Citizen"]                             = "Citizens",
        ["Hobo"]                                = "Citizens",
        ["Gun Dealer"]                          = "Citizens",
        ["Medic"]                               = "Citizens",
        ["Civil Protection"]                    = "Civil Protection",
        ["Gangster"]                            = "Gangsters",
        ["Mob boss"]                            = "Gangsters",
        ["Civil Protection Chief"]              = "Civil Protection",
        ["Mayor"]                               = "Civil Protection",
    },
    entities = {
        ["Drug lab"]                            = "Other",
        ["Money printer"]                       = "Other",
        ["Gun lab"]                             = "Other",

    },
    shipments = {
        ["AK47"]                                = "Rifles",
        ["MP5"]                                 = "Rifles",
        ["M4"]                                  = "Rifles",
        ["Mac 10"]                              = "Other",
        ["Pump shotgun"]                        = "Shotguns",
        ["Sniper rifle"]                        = "Snipers",

    },
    weapons = {
        ["Desert eagle"]                        = "Pistols",
        ["Fiveseven"]                           = "Pistols",
        ["Glock"]                               = "Pistols",
        ["P228"]                                = "Pistols",
    },
    vehicles = {}, -- There are no default vehicles.
    ammo = {
        ["Pistol ammo"]                         = "Other",
        ["Shotgun ammo"]                        = "Other",
        ["Rifle ammo"]                          = "Other",
    },
}

-- The list of weapons admins spawn with, in addition to the default weapons, a job's weapons and GM.Config.AdminsCopWeapons.
GM.Config.AdminWeapons = {
    "weapon_physgun",
    "gmod_tool"
}

-- These are the default laws, they're unchangeable in-game.
GM.Config.DefaultLaws = {
    "Do not attack other citizens except in self-defence.",
    "Do not steal or break into people's homes.",
    "Money printers/drugs are illegal.",
}

GM.Config.PocketBlacklist = {
    ["fadmin_jail"] = true,
    ["meteor"] = true,
    ["door"] = true,
    ["func_"] = true,
    ["player"] = true,
    ["beam"] = true,
    ["worldspawn"] = true,
    ["env_"] = true,
    ["path_"] = true,
    ["prop_physics"] = true,
    ["money_printer"] = true,
    ["gunlab"] = true,
    ["prop_dynamic"] = true,
    ["prop_vehicle_prisoner_pod"] = true,
    ["keypad_wire"] = true,
    ["gmod_button"] = true,
    ["gmod_rtcameraprop"] = true,
    ["gmod_cameraprop"] = true,
    ["gmod_dynamite"] = true,
    ["gmod_thruster"] = true,
    ["gmod_light"] = true,
    ["gmod_lamp"] = true,
    ["gmod_emitter"] = true,
}

-- These weapons are classed as 'legal' in the weapon checker and are not stripped when confiscating weapons.
-- This setting is used IN ADDITION to GM.Config.weaponCheckerHideDefault and GM.Config.weaponCheckerHideNoLicense.
-- You should use the former if you want to class the default weapons (GM.Config.DefaultWeapons and, if admin, GM.Config.AdminWeapons) and a player's job weapons as legal.
-- The latter takes GM.NoLicense weapons as legal (see licenseweapons.lua).
-- The format of this config is similar to GM.Config.DisallowDrop.
GM.Config.noStripWeapons = {
}

-- The entities listed here will not be removed when a player changes their job.
-- This only applies when removeclassitems is set to true.
-- Note: entities will only be removed when the player changes to a job that is not allowed to have the entity.
GM.Config.preventClassItemRemoval = {
    ["gunlab"] = false,
    ["microwave"] = false,
    ["spawned_shipment"] = false,
}

-- Properties set to true are allowed to be used. Values set to false or are missing from this list are blocked.
GM.Config.allowedProperties = {
    remover = true,
    ignite = false,
    extinguish = true,
    keepupright = true,
    gravity = true,
    collision = true,
    skin = true,
    bodygroups = true,
}

--[[---------------------------------------------------------------------------
F4 menu
---------------------------------------------------------------------------]]
-- hide the items that you can't buy and the jobs you can't get (instead of graying them out).
-- this option hides items when you don't have enough money, when the maximum is reached for a job or any other reason.
GM.Config.hideNonBuyable = false

-- Hide only the items that you have the wrong job for (or for which the customCheck says no).
-- When you set this option to true and hideNonBuyable to false, you WILL see e.g. items that are too expensive for you to buy.
-- but you won't see gundealer shipments when you have the citizen job.
GM.Config.hideTeamUnbuyable = true

--[[---------------------------------------------------------------------------
AFK module
---------------------------------------------------------------------------]]
-- The time of inactivity before being demoted.
GM.Config.afkdemotetime = 600
-- Prevent people from spamming AFK.
GM.Config.AFKDelay = 300

--[[---------------------------------------------------------------------------
Hitmenu module
---------------------------------------------------------------------------]]
-- The minimum price for a hit.
GM.Config.minHitPrice = 200
-- The maximum price for a hit.
GM.Config.maxHitPrice = 50000
-- The minimum distance between a hitman and his customer when they make the deal.
GM.Config.minHitDistance = 150
-- The text that tells the player he can press use on the hitman to request a hit.
GM.Config.hudText = "I am a hitman.\nPress E on me to request a hit!"
-- The text above a hitman when he's got a hit.
GM.Config.hitmanText = "Hit\naccepted!"
-- The cooldown time for a hit target (so they aren't spam killed).
GM.Config.hitTargetCooldown = 120
-- How long a customer has to wait to be able to buy another hit (from the moment the hit is accepted).
GM.Config.hitCustomerCooldown = 240

--[[---------------------------------------------------------------------------
Hungermod module
---------------------------------------------------------------------------]]
-- hungerspeed <Amount> - Set the rate at which players will become hungry (2 is the default).
GM.Config.hungerspeed = 2
-- starverate <Amount> - How much health that is taken away every second the player is starving  (3 is the default).
GM.Config.starverate = 3

--PATH gamemodes/starwarsrp/gamemode/modules/voting/sh_chatcommands.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/voting/cl_voting.lua:
local QuestionVGUI = {}
local PanelNum = 0
local VoteVGUI = {}
local function MsgDoVote(msg)
    local _, chatY = chat.GetChatBoxPos()

    local question = msg:ReadString()
    local voteid = msg:ReadShort()
    local timeleft = msg:ReadFloat()
    if timeleft == 0 then
        timeleft = 100
    end
    local OldTime = CurTime()
    if not IsValid(LocalPlayer()) then return end -- Sent right before player initialisation

    LocalPlayer():EmitSound("Town.d1_town_02_elevbell1", 100, 100)
    local panel = vgui.Create("DFrame")
    panel:SetPos(3 + PanelNum, chatY - 145)
    panel:SetTitle(DarkRP.getPhrase("vote"))
    panel:SetSize(140, 140)
    panel:SetSizable(false)
    panel.btnClose:SetVisible(false)
    panel.btnMaxim:SetVisible(false)
    panel.btnMinim:SetVisible(false)
    panel:SetDraggable(false)
    function panel:Close()
        PanelNum = PanelNum - 140
        VoteVGUI[voteid .. "vote"] = nil

        local num = 0
        for _, v in SortedPairs(VoteVGUI) do
            v:SetPos(num, ScrH() / 2 - 50)
            num = num + 140
        end

        for _, v in SortedPairs(QuestionVGUI) do
            v:SetPos(num, ScrH() / 2 - 50)
            num = num + 300
        end
        self:Remove()
    end

    function panel:Think()
        self:SetTitle(DarkRP.getPhrase("time", math.Clamp(math.ceil(timeleft - (CurTime() - OldTime)), 0, 9999)))
        if timeleft - (CurTime() - OldTime) <= 0 then
            panel:Close()
        end
    end

    panel:SetKeyboardInputEnabled(false)
    panel:SetMouseInputEnabled(true)
    panel:SetVisible(true)

    local label = vgui.Create("DLabel")
    label:SetParent(panel)
    label:SetPos(5, 25)
    label:SetText(DarkRP.textWrap(DarkRP.deLocalise(question), "DermaDefault", 130))
    label:SizeToContents()
    label:SetVisible(true)

    local nextHeight = label:GetTall() > 78 and label:GetTall() - 78 or 0 -- Make panel taller for divider and buttons
    panel:SetTall(panel:GetTall() + nextHeight)

    local divider = vgui.Create("Divider")
    divider:SetParent(panel)
    divider:SetPos(2, panel:GetTall() - 30)
    divider:SetSize(180, 2)
    divider:SetVisible(true)

    local ybutton = vgui.Create("Button")
    ybutton:SetParent(panel)
    ybutton:SetPos(25, panel:GetTall() - 25)
    ybutton:SetSize(40, 20)
    ybutton:SetText(DarkRP.getPhrase("yes"))
    ybutton:SetVisible(true)
    ybutton.DoClick = function()
        LocalPlayer():ConCommand("vote " .. voteid .. " yea\n")
        panel:Close()
    end

    local nbutton = vgui.Create("Button")
    nbutton:SetParent(panel)
    nbutton:SetPos(70, panel:GetTall() - 25)
    nbutton:SetSize(40, 20)
    nbutton:SetText(DarkRP.getPhrase("no"))
    nbutton:SetVisible(true)
    nbutton.DoClick = function()
        LocalPlayer():ConCommand("vote " .. voteid .. " nay\n")
        panel:Close()
    end

    PanelNum = PanelNum + 140
    VoteVGUI[voteid .. "vote"] = panel
    panel:SetSkin(GAMEMODE.Config.DarkRPSkin)
end
usermessage.Hook("DoVote", MsgDoVote)

local function KillVoteVGUI(msg)
    local id = msg:ReadShort()

    if VoteVGUI[id .. "vote"] and VoteVGUI[id .. "vote"]:IsValid() then
        VoteVGUI[id .. "vote"]:Close()
    end
end
usermessage.Hook("KillVoteVGUI", KillVoteVGUI)

local function MsgDoQuestion(msg)
    if not IsValid(LocalPlayer()) then return end

    local question = msg:ReadString()
    local quesid = msg:ReadString()
    local timeleft = msg:ReadFloat()
    if timeleft == 0 then
        timeleft = 100
    end
    local OldTime = CurTime()
    LocalPlayer():EmitSound("Town.d1_town_02_elevbell1", 100, 100)
    local panel = vgui.Create("DFrame")
    panel:SetPos(3 + PanelNum, ScrH() / 2 - 50) -- Times 140 because if the question is the second screen, the first screen is always a vote screen.
    panel:SetSize(300, 140)
    panel:SetSizable(false)
    panel.btnClose:SetVisible(false)
    panel.btnMaxim:SetVisible(false)
    panel.btnMinim:SetVisible(false)
    panel:SetKeyboardInputEnabled(false)
    panel:SetMouseInputEnabled(true)
    panel:SetVisible(true)

    function panel:Close()
        PanelNum = PanelNum - 300
        QuestionVGUI[quesid .. "ques"] = nil
        local num = 0
        for _, v in SortedPairs(VoteVGUI) do
            v:SetPos(num, ScrH() / 2 - 50)
            num = num + 140
        end

        for _, v in SortedPairs(QuestionVGUI) do
            v:SetPos(num, ScrH() / 2 - 50)
            num = num + 300
        end

        self:Remove()
    end

    function panel:Think()
        self:SetTitle(DarkRP.getPhrase("time", math.Clamp(math.ceil(timeleft - (CurTime() - OldTime)), 0, 9999)))
        if timeleft - (CurTime() - OldTime) <= 0 then
            panel:Close()
        end
    end

    local label = vgui.Create("DLabel")
    label:SetParent(panel)
    label:SetPos(5, 30)
    label:SetSize(380, 40)
    label:SetText(DarkRP.deLocalise(question))
    label:SetVisible(true)

    local divider = vgui.Create("Divider")
    divider:SetParent(panel)
    divider:SetPos(2, 80)
    divider:SetSize(380, 2)
    divider:SetVisible(true)

    local ybutton = vgui.Create("DButton")
    ybutton:SetParent(panel)
    ybutton:SetPos(105, 100)
    ybutton:SetSize(40, 20)
    ybutton:SetText(DarkRP.getPhrase("yes"))
    ybutton:SetVisible(true)
    ybutton.DoClick = function()
        LocalPlayer():ConCommand("ans " .. quesid .. " 1\n")
        panel:Close()
    end

    local nbutton = vgui.Create("DButton")
    nbutton:SetParent(panel)
    nbutton:SetPos(155, 100)
    nbutton:SetSize(40, 20)
    nbutton:SetText(DarkRP.getPhrase("no"))
    nbutton:SetVisible(true)
    nbutton.DoClick = function()
        LocalPlayer():ConCommand("ans " .. quesid .. " 2\n")
        panel:Close()
    end

    PanelNum = PanelNum + 300
    QuestionVGUI[quesid .. "ques"] = panel

    panel:SetSkin(GAMEMODE.Config.DarkRPSkin)
end
usermessage.Hook("DoQuestion", MsgDoQuestion)

local function KillQuestionVGUI(msg)
    local id = msg:ReadString()

    if QuestionVGUI[id .. "ques"] and QuestionVGUI[id .. "ques"]:IsValid() then
        QuestionVGUI[id .. "ques"]:Close()
    end
end
usermessage.Hook("KillQuestionVGUI", KillQuestionVGUI)

local function DoVoteAnswerQuestion(ply, cmd, args)
    if not args[1] then return end

    local vote = 0
    if tonumber(args[1]) == 1 or string.lower(args[1]) == "yes" or string.lower(args[1]) == "true" then vote = 1 end

    for k, v in pairs(VoteVGUI) do
        if IsValid(v) then
            local ID = string.sub(k, 1, -5)
            VoteVGUI[k]:Close()
            RunConsoleCommand("vote", ID, vote)
            return
        end
    end

    for k, v in pairs(QuestionVGUI) do
        if IsValid(v) then
            local ID = string.sub(k, 1, -5)
            QuestionVGUI[k]:Close()
            RunConsoleCommand("ans", ID, vote)
            return
        end
    end
end
concommand.Add("rp_vote", DoVoteAnswerQuestion)

--PATH gamemodes/starwarsrp/gamemode/modules/language/sh_language.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/chat/sh_chatcommands.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/base/sh_commands.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/base/cl_fonts.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/base/cl_entityvars.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/base/cl_entityvars.lua:
DarkRP.ClientsideDarkRPVars = DarkRP.ClientsideDarkRPVars or {}

--[[---------------------------------------------------------------------------
Interface
---------------------------------------------------------------------------]]
local pmeta = FindMetaTable("Player")
-- This function is made local to optimise getDarkRPVar, which is called often
-- enough to warrant optimizing. See https://github.com/FPtje/DarkRP/pull/3212
local get_user_id = pmeta.UserID
function pmeta:getDarkRPVar(var, fallback)
    local user_id = get_user_id(self)

    -- Special case: when in the EntityRemoved hook, UserID returns -1. In this
    -- case, hope that we still have a stored userID lying around somewhere.
    -- See https://github.com/FPtje/DarkRP/pull/3270
    if user_id == -1 then
        user_id = self._darkrp_stored_user_id_for_entity_removed_hook
    end

    local vars = DarkRP.ClientsideDarkRPVars[user_id]
    if vars == nil then return fallback end

    local results = vars[var]
    if results == nil then return fallback end

    return results
end

--[[---------------------------------------------------------------------------
Retrieve the information of a player var
---------------------------------------------------------------------------]]
local function RetrievePlayerVar(userID, var, value)
    local ply = Player(userID)
    DarkRP.ClientsideDarkRPVars[userID] = DarkRP.ClientsideDarkRPVars[userID] or {}

    hook.Call("DarkRPVarChanged", nil, ply, var, DarkRP.ClientsideDarkRPVars[userID][var], value)
    DarkRP.ClientsideDarkRPVars[userID][var] = value

    -- Backwards compatibility
    if IsValid(ply) then
        ply.DarkRPVars = DarkRP.ClientsideDarkRPVars[userID]
    end
end

--[[---------------------------------------------------------------------------
Retrieve a player var.
Read the usermessage and attempt to set the DarkRP var
---------------------------------------------------------------------------]]
local function doRetrieve()
    local userID = net.ReadUInt(16)
    local var, value = DarkRP.readNetDarkRPVar()

    RetrievePlayerVar(userID, var, value)
end
net.Receive("DarkRP_PlayerVar", doRetrieve)

--[[---------------------------------------------------------------------------
Retrieve the message to remove a DarkRPVar
---------------------------------------------------------------------------]]
local function doRetrieveRemoval()
    local userID = net.ReadUInt(16)
    local vars = DarkRP.ClientsideDarkRPVars[userID] or {}
    local var = DarkRP.readNetDarkRPVarRemoval()
    local ply = Player(userID)

    hook.Call("DarkRPVarChanged", nil, ply, var, vars[var], nil)

    vars[var] = nil
end
net.Receive("DarkRP_PlayerVarRemoval", doRetrieveRemoval)

--[[---------------------------------------------------------------------------
Initialize the DarkRPVars at the start of the game
---------------------------------------------------------------------------]]
local function InitializeDarkRPVars(len)
    local plyCount = net.ReadUInt(8)

    for i = 1, plyCount, 1 do
        local userID = net.ReadUInt(16)
        local varCount = net.ReadUInt(DarkRP.DARKRP_ID_BITS + 2)

        for j = 1, varCount, 1 do
            local var, value = DarkRP.readNetDarkRPVar()
            RetrievePlayerVar(userID, var, value)
        end
    end
end
net.Receive("DarkRP_InitializeVars", InitializeDarkRPVars)
timer.Simple(0, fp{RunConsoleCommand, "_sendDarkRPvars"})

net.Receive("DarkRP_DarkRPVarDisconnect", function(len)
    local userID = net.ReadUInt(16)
    local ply = Player(userID)

    -- If the player is already gone, then immediately clear the data and move on.
    if not IsValid(ply) then
        DarkRP.ClientsideDarkRPVars[userID] = nil
        return
    end
    -- Otherwise, we need to wait until the player is actually removed
    -- clientside. The net message may come in _much_ earlier than the message
    -- that the player disconnected and should therefore be removed.
    local hook_name = "darkrp_remove_darkrp_var_" .. userID

    -- Workaround: the player's user ID is -1 in the EntityRemoved hook. This
    -- stores the user ID in a separate variable so that it is still accessible.
    -- See https://github.com/Facepunch/garrysmod-issues/issues/6117
    --
    -- This will allow getDarkRPVar to keep working
    if IsValid(ply) then
        ply._darkrp_stored_user_id_for_entity_removed_hook = userID
    end

    hook.Add("EntityRemoved", hook_name, function(ent)
        if ent ~= ply then return end
        hook.Remove("EntityRemoved", hook_name)

        -- Placing this in a timer allows for the rest of the hook runners to
        -- still use the DarkRPVars until the entity is _really_ gone.
        -- See https://github.com/FPtje/DarkRP/pull/3270
        timer.Simple(0, function()
            DarkRP.ClientsideDarkRPVars[userID] = nil
        end)
    end)
end)

--[[---------------------------------------------------------------------------
Request the DarkRPVars when they haven't arrived
---------------------------------------------------------------------------]]
timer.Create("DarkRPCheckifitcamethrough", 15, 0, function()
    for _, v in ipairs(player.GetAll()) do
        if v:getDarkRPVar("rpname") then continue end

        RunConsoleCommand("_sendDarkRPvars")
        return
    end

    timer.Remove("DarkRPCheckifitcamethrough")
end)

--PATH addons/!jobs/lua/darkrp_modules/hudreplacement/cl_hudreplacement.lua:
--[[---------------------------------------------------------------------------
Which default HUD elements should be hidden?
---------------------------------------------------------------------------]]

local hideHUDElements = {
    -- if you DarkRP_HUD this to true, ALL of DarkRP's HUD will be disabled. That is the health bar and stuff,
    -- but also the agenda, the voice chat icons, lockdown text, player arrested text and the names above players' heads
    ["DarkRP_HUD"] = false,

    -- DarkRP_EntityDisplay is the text that is drawn above a player when you look at them.
    -- This also draws the information on doors and vehicles
    ["DarkRP_EntityDisplay"] = false,

    -- This is the one you're most likely to replace first
    -- DarkRP_LocalPlayerHUD is the default HUD you see on the bottom left of the screen
    -- It shows your health, job, salary and wallet, but NOT hunger (if you have hungermod enabled)
    ["DarkRP_LocalPlayerHUD"] = false,

    -- If you have hungermod enabled, you will see a hunger bar in the DarkRP_LocalPlayerHUD
    -- This does not get disabled with DarkRP_LocalPlayerHUD so you will need to disable DarkRP_Hungermod too
    ["DarkRP_Hungermod"] = false,

    -- Drawing the DarkRP agenda
    ["DarkRP_Agenda"] = false,

    -- Lockdown info on the HUD
    ["DarkRP_LockdownHUD"] = false,

    -- Arrested HUD
    ["DarkRP_ArrestedHUD"] = false,

    -- Chat receivers box when you open chat or speak over the microphone
    ["DarkRP_ChatReceivers"] = false,
}

-- this is the code that actually disables the drawing.
hook.Add("HUDShouldDraw", "HideDefaultDarkRPHud", function(name)
    if hideHUDElements[name] then return false end
end)

if true then return end -- REMOVE THIS LINE TO ENABLE THE CUSTOM HUD BELOW

--[[---------------------------------------------------------------------------
The Custom HUD
only draws health
---------------------------------------------------------------------------]]
local Health = 0
local function hudPaint()
    local x, y = 30, ScrH() - 20
    local localplayer = LocalPlayer()
    Health = math.min(100, (Health == localplayer:Health() and Health) or Lerp(0.1, Health, localplayer:Health()))

    local DrawHealth = math.Min(Health / GAMEMODE.Config.startinghealth, 1)
    local Border = math.Min(6, math.pow(2, math.Round(3 * DrawHealth)))
    draw.RoundedBox(Border, x + 4, y - 30, 200 - 8, 20, Color(0,0,0,200))
    draw.RoundedBox(Border, x + 5, y - 29, (200 - 9) * DrawHealth, 18, Color(140,0,0,180))

    draw.DrawText(math.Max(0, math.Round(localplayer:Health())), "DarkRPHUD2", x + 4 + (200 - 8) / 2, y - 32, Color(255, 255, 255, 200), 1)

    -- Armor
    local armor = localplayer:Armor()
    if armor ~= 0 then
        draw.RoundedBox(2, x + 4, y - 15, (200 - 8) * armor / 100, 5, Color(0, 0, 255, 255))
    end
end
hook.Add("HUDPaint", "DarkRP_Mod_HUDPaint", hudPaint)

--PATH addons/!jobs/lua/darkrp_customthings/agendas.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_laser.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_presets.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_thirdarm.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_wm.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_grenade.lua:
function SWEP:ThinkGrenade()
    if !self:GetProcessedValue("Throwable", true) then return end
    local owner = self:GetOwner()

    owner.ARC9QuickthrowPls = nil 
    local QuicknadeBind = owner:KeyDown(IN_GRENADE1)

	if self:GetSafe() and owner:KeyPressed(IN_ATTACK) then self:ToggleSafety(false) return end
	
    if IsValid(self:GetDetonatorEntity()) then
        if owner:KeyPressed(IN_ATTACK) then
            self:TouchOff()
            return
        end
    end

    local fuse = self:GetProcessedValue("FuseTimer")

    if fuse >= 0 and self:GetGrenadePrimed() then
        local time = CurTime() - self:GetGrenadePrimedTime()

        if time >= fuse then
            self:ThrowGrenade(ARC9.NADETHROWTYPE_EXPLODEINHANDS, 0)

            if self:HasAnimation("explodeinhands") then
                self:PlayAnimation("explodeinhands", 1, true)
            else
                self:PlayAnimation("throw", 1, true)
            end
        end
    end

    local tossable = self:GetProcessedValue("Tossable", true) and self:HasAnimation("toss")

    if !self:GetGrenadePrimed() then
        if self:GetAnimLockTime() > CurTime() then return end

        local throwanimspeed = self:GetProcessedValue("ThrowAnimSpeed", true)
        if self:GetGrenadeRecovering() then
            if self:GetProcessedValue("Disposable", true) and !self:HasAmmoInClip() and !IsValid(self:GetDetonatorEntity()) and SERVER then
                self:Remove()
                owner:ConCommand("lastinv") -- switch to prev weapon
            elseif self.WasThrownByBind then
                self.WasThrownByBind = nil
                self:Holster(owner:GetPreviousWeapon())
                -- owner:ConCommand("lastinv") -- switch to prev weapon man we dont need dis shid!!
            else
                self:PlayAnimation("draw", throwanimspeed, true)
                self:SetGrenadeRecovering(false)
            end
        elseif ((tossable and owner:KeyDown(IN_ATTACK2)) or
        owner:KeyDown(IN_ATTACK)) and
            self:HasAmmoInClip() and
            (!owner:KeyDown(IN_USE) or !self:GetProcessedValue("PrimaryBash", true)) and
            !IsValid(self:GetDetonatorEntity())
            then
            self:SetGrenadePrimed(true)
            self:SetGrenadePrimedTime(CurTime())

            if owner:KeyDown(IN_ATTACK2) and self:HasAnimation("pullpin_toss") then
                self:PlayAnimation("pullpin_toss", throwanimspeed, true)
            else
                self:PlayAnimation("pullpin", throwanimspeed, true)
            end
            self:SetGrenadeTossing(owner:KeyDown(IN_ATTACK2))
        end
    else
        if self:GetAnimLockTime() > CurTime() then return end

        if self:GetGrenadeTossing() and (!owner:KeyDown(IN_ATTACK2) or self:GetProcessedValue("ThrowInstantly", true)) then
            local t = self:PlayAnimation("toss", throwanimspeed, true)
            local mp = self:GetAnimationEntry("toss").MinProgress or 0
            self:ThrowGrenade(ARC9.NADETHROWTYPE_TOSS, t * mp)
        elseif !self:GetGrenadeTossing() and (!(owner:KeyDown(IN_ATTACK) or QuicknadeBind) or self:GetProcessedValue("ThrowInstantly", true)) then
            local t = self:PlayAnimation("throw", throwanimspeed, true)
            local mp = self:GetAnimationEntry("throw").MinProgress or 0
            self:ThrowGrenade(ARC9.NADETHROWTYPE_NORMAL, t * mp)
        end

        self:SetGrenadeRecovering(true)
    end
end

function SWEP:ThrowGrenade(nttype, delaytime)
    delaytime = delaytime or 0
    self:SetGrenadePrimed(false)

    self:TakeAmmo()

    self:DoPlayerAnimationEvent(self:GetProcessedValue("AnimShoot", true))

    if CLIENT then return end

    local time = math.huge
    local fusetimer = self:GetProcessedValue("FuseTimer")
    local forcemax = self:GetProcessedValue("ThrowForceMax")
    local forcemin = self:GetProcessedValue("ThrowForceMin")
    local forcetime = self:GetProcessedValue("ThrowChargeTime")

    time = CurTime() - self:GetGrenadePrimedTime()

    local force = forcemax

    if forcetime > 0 then
        force = forcemin + (forcemax - forcemin) * math.Clamp(time / forcetime, 0, 1)
    end

    local num = self:GetProcessedValue("Num")
    local ent = self:GetProcessedValue("ShootEnt")

    local owner = self:GetOwner()

    if owner:IsNPC() then
        -- ang = self:GetOwner():GetAimVector():Angle()
        spread = self:GetNPCBulletSpread()
    else
        spread = self:GetProcessedValue("Spread")
    end

    spread = math.Max(spread, 0)

    local override = {
        force = force,
        delay = delaytime,
    }
    self:RunHook("Hook_GrenadeThrown", override)

    force = override.force or force
    delaytime = override.delay or delaytime

    self:SetTimer(delaytime, function()

        local src, dir
        if self:GetProcessedValue("ThrowOnGround", true) then
            src = owner:EyePos()
            dir = Angle(0, owner:GetAngles().y, 0)

            local shootposoffset = self:GetProcessedValue("ShootPosOffset", true)

            local angRight = dir:Right()
            local angForward = dir:Forward()
            local angUp = dir:Up()

            angRight:Mul(shootposoffset[1])
            angForward:Mul(shootposoffset[2])
            angUp:Mul(shootposoffset[3])

            src:Add(angRight)
            src:Add(angForward)
            src:Add(angUp)

            src, dir = self:GetRecoilOffset(src, dir)

            local tr = util.TraceLine({
                start = src,
                endpos = src - Vector(0, 0, 64),
                mask = MASK_SOLID,
            })
            src = tr.HitPos
        else
            src, dir = self:GetShootPos()
        end

        local nades = {}
        for i = 1, num do
            local nade = ents.Create(ent)

            if !IsValid(nade) then return end
            local dispersion = Angle(math.Rand(-1, 1), math.Rand(-1, 1), 0)

            dispersion = dispersion * spread * 36

            nade:SetPos(src)
            nade:SetAngles(dir)
            nade:SetOwner(owner)
            nade:Spawn()

            if fusetimer >= 0 then
                nade.LifeTime = fusetimer - time
            end

            if nttype  == ARC9.NADETHROWTYPE_TOSS then
                force = self:GetProcessedValue("TossForce", true)
            elseif nttype == ARC9.NADETHROWTYPE_EXPLODEINHANDS then
                force = 0
                time = 0
                nade:Detonate()
            end

            if self:GetProcessedValue("Detonator", true) then
                self:SetDetonatorEntity(nade)
            end

            local phys = nade:GetPhysicsObject()

            if IsValid(phys) then
                if self:GetProcessedValue("ThrowTumble", true) then
                    nade:SetAngles(Angle(math.random(-180, 180), math.random(-180, 180), math.random(-180, 180)))
                    phys:AddAngleVelocity(Vector(math.random(-180, 180), math.random(-180, 180), math.random(-180, 180)))
                end

                if self:GetProcessedValue("ShootEntInheritPlayerVelocity") then
                    local vel = owner:GetVelocity()
                    local limit = self:GetProcessedValue("ShootEntInheritPlayerVelocityLimit")
                    if isnumber(limit) and limit > 0 and vel:Length() > limit then
                        vel = vel:GetNormalized() * limit
                    end
                    phys:SetVelocity(vel)
                end

                phys:AddVelocity((dir + dispersion):Forward() * force)
            end

            table.insert(nades, nade)
        end

        self:RunHook("Hook_GrenadeCreated", nades)
    end)
end

function SWEP:TouchOff()
    self:PlayAnimation("touchoff", 1, true)

    self:SetGrenadeRecovering(true)

    if SERVER and IsValid(self:GetDetonatorEntity()) then
        self:GetDetonatorEntity():Detonate()
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_jamming.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_lean.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_lean.lua:
SWEP.MaxLeanOffset = 16
SWEP.MaxLeanAngle = 15

SWEP.LastLeanAmountSERVER = 0

local leanconvar = GetConVar("arc9_lean")

function SWEP:ThinkLean()
    if !leanconvar:GetBool() or !self:GetProcessedValue("CanLean", true) then
        self:SetLeanAmount(0)
        return
    end

    local leanstate = self:GetLeanState()
    local owner = self:GetOwner()

    if !(owner:KeyDown(IN_SPEED) and (owner:KeyDown(IN_FORWARD) or owner:KeyDown(IN_BACK) or owner:KeyDown(IN_MOVELEFT) or owner:KeyDown(IN_MOVERIGHT))) then
        if owner:GetInfoNum("arc9_togglelean", 0) >= 1 then
            local pressalt1 = owner:KeyPressed(IN_ALT1)
            local pressalt2 = owner:KeyPressed(IN_ALT2)

            if leanstate == -1 then
                if pressalt1 then
                    leanstate = 0
                elseif pressalt2 then
                    leanstate = 1
                end
            elseif leanstate == 1 then
                if pressalt2 then
                    leanstate = 0
                elseif pressalt1 then
                    leanstate = -1
                end
            else
                if pressalt1 then
                    leanstate = -1
                elseif pressalt2 then
                    leanstate = 1
                end
            end
        else
            if owner:KeyDown(IN_ALT1) then
                leanstate = -1
            elseif owner:KeyDown(IN_ALT2) then
                leanstate = 1
            else
                leanstate = 0
            end
        end
    else
        leanstate = 0
    end

    self:SetLeanState(leanstate)

    local maxleanfrac = 1

    if leanstate != 0 then
        local tr = util.TraceHull({
            start = owner:EyePos(),
            endpos = owner:EyePos() + owner:EyeAngles():Right() * (self.MaxLeanOffset - 2) * leanstate,
            filter = owner,
            maxs = Vector(1, 1, 1) * 4,
            mins = Vector(-1, -1, -1) * 4,
        })

        if tr.Hit then
            maxleanfrac = tr.Fraction * 0.5
        end
    end

    local amt = self:GetLeanAmount()
    local tgt = leanstate

    if maxleanfrac < 1 then
        tgt = 0
    end

    amt = math.Approach(amt, tgt, FrameTime() * 7)
    amt = math.Clamp(amt, -maxleanfrac, maxleanfrac)

    self:SetLeanAmount(amt)

    if amt != 0 then
        owner:SetCollisionBounds(Vector(-32, -32, 0), Vector(32, 32, 64))
    end

    local force = SERVER and (math.abs(amt) == 1 or math.abs(amt) == 0) and self.LastLeanAmountSERVER != amt

    self:DoPlayerModelLean(false, force)

    self.LastLeanAmountSERVER = amt
end

function SWEP:GetLeanDelta()
    return math.ease.InSine(self:GetLeanAmount()) * (self:GetLeanAmount() > 0 and 1 or -1)
end

function SWEP:GetLeanOffset()
    local amt = self:GetLeanDelta()

    return amt * self.MaxLeanOffset
end

function SWEP:DoCameraLean(pos, ang)
    local amt = self:GetLeanDelta()

    if amt == 0 then return pos, ang end

    local newpos = pos + self:GetOwner():EyeAngles():Right() * self:GetLeanOffset()

    ang:RotateAroundAxis(ang:Forward(), amt * self.MaxLeanAngle)

    return newpos, ang
end

function SWEP:DoWeaponLean(pos, ang)
    local amt = self:GetLeanDelta()

    if amt == 0 then return pos, ang end

    local newpos = pos + self:GetOwner():EyeAngles():Right() * self:GetLeanOffset()

    return newpos, ang
end

local leanbone = "ValveBiped.Bip01_Spine1"

local leanang_left = Angle(3.6, 2.65, 1.2)
local leanang_right = Angle(3, 2.2, 1)

function SWEP:DoPlayerModelLean(cancel, forceupdate)
    local amt = self:GetLeanDelta()

    if cancel then amt = 0 end

    local owner = self:GetOwner()

    local bone = owner:LookupBone(leanbone)

    if !bone then return end

    owner:ManipulateBoneAngles(bone, (amt < 0 and leanang_left or leanang_right) * amt * self.MaxLeanAngle, game.SinglePlayer() or cancel or forceupdate)
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_sprint.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_triggersounds.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/shared.lua:
AddCSLuaFile()

-- For those who may find it useful...
-- use WEAPONENTITY:SetNWBool("ArcCW_DisableAutosave", true) to tell the client to not load their autosaves.

SWEP.Spawnable = false -- this obviously has to be set to true
SWEP.AutoSpawnable = nil -- TTT weapon autospawn. ArcCW weapons automatically spawn in TTT as long as SWEP.Spawnable is set to true
SWEP.Category = "ArcCW - Firearms" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "ArcCW Base"
SWEP.Trivia_Class = nil -- "Submachine Gun"
SWEP.Trivia_Desc = nil -- "Ubiquitous 9mm SMG. Created as a response to the need for a faster-firing and more reliable submachine gun than existing options at the time."
SWEP.Trivia_Manufacturer = nil -- "Auschen Waffenfabrik"
SWEP.Trivia_Calibre = nil -- "9x21mm Jager"
SWEP.Trivia_Mechanism = nil -- "Roller-Delayed Blowback"
SWEP.Trivia_Country = nil -- "Austria"
SWEP.Trivia_Year = nil -- 1968

SWEP.UseHands = true

SWEP.ViewModel = "" -- I mean, you probably have to edit these too
SWEP.WorldModel = ""

SWEP.MirrorVMWM = nil -- Copy the viewmodel, along with all its attachments, to the worldmodel. Super convenient!
SWEP.MirrorWorldModel = nil -- Use this to set the mirrored viewmodel to a different model, without any floating speedloaders or cartridges you may have. Needs MirrorVMWM
SWEP.HideViewmodel = nil
--[[SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}]]

SWEP.PresetBase = nil -- make this weapon share saves with this one.

SWEP.KillIconAlias = nil -- set to other weapon class to share select and kill icons

SWEP.DefaultBodygroups = "00000000"
SWEP.DefaultWMBodygroups = "00000000"
SWEP.DefaultSkin = 0
SWEP.DefaultWMSkin = 0

SWEP.WorldModelOffset = nil
-- {
--     pos = Vector(0, 0, 0),
--     ang = Angle(0, 0, 0)
-- }

SWEP.NoHideLeftHandInCustomization = false

SWEP.Damage = 26
SWEP.DamageMin = 10 -- damage done at maximum range
SWEP.DamageRand = 0 -- damage will vary randomly each shot by this fraction
SWEP.RangeMin = 0 -- how far bullets will retain their maximum damage for
SWEP.Range = 200 -- in METRES
SWEP.Penetration = 4
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false -- set to true to have the base not do anything with damage types
-- this includes: igniting if type has DMG_BURN; adding DMG_AIRBOAT when hitting helicopter; adding DMG_BULLET to DMG_BUCKSHOT

SWEP.Distance = nil -- Maximum distance of the bullet (does not affect physbullets)

SWEP.Force = nil -- bullet force. set nil to autocalculate

SWEP.ShootEntity = nil -- entity to fire, if any
SWEP.MuzzleVelocity = 400 -- projectile muzzle velocity in m/s
SWEP.PhysBulletMuzzleVelocity = nil -- override phys bullet muzzle velocity
SWEP.PhysBulletDrag = 1
SWEP.PhysBulletGravity = 1
SWEP.PhysBulletDontInheritPlayerVelocity = true

SWEP.BodyDamageMults = nil
-- if a limb is not set the damage multiplier will default to 1
-- that means gmod's stupid default limb mults will **NOT** apply
-- {
--     [HITGROUP_HEAD] = 1.25,
--     [HITGROUP_CHEST] = 1,
--     [HITGROUP_LEFTARM] = 0.9,
--     [HITGROUP_RIGHTARM] = 0.9,
-- }

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 0 -- color for phys tracer. can be a number or a string (see sh_physbullet2.lua)
-- there are 8 default options:
-- 0 = normal
-- 1 = red
-- 2 = green
-- 3 = blue
-- 4 = yellow
-- 5 = violet
-- 6 = cyan
-- 7 = black/invisible

SWEP.TracerNum = 1 -- tracer every X
SWEP.TracerFinalMag = 0 -- the last X bullets in a magazine are all tracers
SWEP.Tracer = "arccw_tracer" -- override tracer (hitscan) effect
SWEP.TracerCol = Color(255, 255, 255)
SWEP.HullSize = 0 -- HullSize used by FireBullets

SWEP.ChamberSize = 1 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 25 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 50
SWEP.ReducedClipSize = 10

-- But if you insist...
SWEP.ForceDefaultClip = nil
SWEP.ForceDefaultAmmo = nil

-- The amount of rounds to load in the chamber when the gun is non-empty or empty
-- Defaults to ChamberSize and 0. Don't change unless you have a good reason
SWEP.ChamberLoadNonEmpty = nil
SWEP.ChamberLoadEmpty = nil

SWEP.AmmoPerShot = 1
SWEP.InfiniteAmmo = false -- weapon can reload for free
SWEP.BottomlessClip = false -- weapon never has to reload

SWEP.DoNotEquipmentAmmo = false -- do not automatically give this weapon unique ammo when arccw_equipmentammo is used

SWEP.ShotgunReload = false -- reloads like shotgun instead of magazines
SWEP.HybridReload = false -- reload normally when empty, reload like shotgun when part full

SWEP.ManualAction = false -- pump/bolt action
SWEP.NoLastCycle = false -- do not cycle on last shot

SWEP.RevolverReload = false -- cases all eject on reload

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.LockSightsInPriorityAnim = false

SWEP.CanFireUnderwater = false

SWEP.Disposable = false -- when all ammo is expended, the gun will remove itself when holstered

SWEP.AutoReload = false -- when weapon is drawn, the gun will reload itself.

SWEP.IsShotgun = false -- weapon receives shotgun ammo types

SWEP.TriggerDelay = false -- Set to true to play the "trigger" animation before firing. Delay time is dependent on animation time.
SWEP.TriggerCharge = false -- If TriggerDelay is set, holding trigger will charge and releasing it fires. Also allows premature release of trigger.
SWEP.TriggerPullWhenEmpty = true -- If true, can pull the trigger even if no ammo is left.

SWEP.Recoil = 2
SWEP.RecoilSide = 1
SWEP.RecoilRise = 1
SWEP.MaxRecoilBlowback = -1
SWEP.VisualRecoilMult = 1.25
SWEP.RecoilPunch = 1.5
SWEP.RecoilPunchBackMax = 1
SWEP.RecoilPunchBackMaxSights = nil -- may clip with scopes
SWEP.RecoilVMShake = 1 -- random viewmodel offset when shooty

SWEP.Sway = 0

SWEP.ShotgunSpreadDispersion = false -- dispersion will cause pattern to increase instead of shifting
SWEP.ShotgunSpreadPattern = nil
SWEP.ShotgunSpreadPatternOverrun = nil
-- {Angle(1, 1, 0), Angle(1, 0, 0) ..}
-- list of how far each pellet should veer
-- if only one pellet then it'll use the first index
-- if two then the first two
-- in case of overrun pellets will start looping, preferably with the second one, so use that for the loopables
-- precision will still be applied
SWEP.NoRandSpread = false

SWEP.RecoilDirection = Angle(1, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1, 0)

SWEP.Delay = 60 / 750 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemode = 1 -- 0: safe, 1: semi, 2: auto, negative: burst
SWEP.Firemodes = {
    -- {
    --     Mode = 1,
    --     CustomBars = "---_#!",
--[[
                Custom bar setup
        Colored variants        Classic
        'a' Filled              '-' Filled
        'b' Outline             '_' Outline
        'd' CLR w Outline       '!' Red w Outline
                    '#' Empty
]]
    --     PrintName = "PUMP",
    --     RunAwayBurst = false,
    --     AutoBurst = false, -- hold fire to continue firing bursts
    --     PostBurstDelay = 0,
    --     ActivateElements = {}
    --     RestoreAmmo = false -- switching to this firemode will call RestoreAmmo(). intended to be used alongside firemode changing animations
    -- }
}

SWEP.ShotRecoilTable = nil -- {[1] = 0.25, [2] = 2} etc.

SWEP.NotForNPCS = false
SWEP.NPCWeaponType = nil -- string or table, the NPC weapons for this gun to replace
-- if nil, this will be based on holdtype
SWEP.NPCWeight = 0 -- relative likeliness for an NPC to have this weapon
SWEP.TTTWeaponType = nil -- string or table, like NPCWeaponType but specifically for TTT weapons (takes precdence over NPCWeaponType)
SWEP.TTTWeight = 0 -- like NPCWeight but for TTT gamemode

SWEP.AccuracyMOA = 15 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 150 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 0 -- dispersion that remains even in sights
SWEP.JumpDispersion = 300 -- dispersion penalty when in the air

SWEP.Bipod_Integral = false -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 1 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 1 -- Bipod recoil for Integral bipods

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "pistol" -- what ammo type the gun uses
SWEP.MagID = "mpk1" -- the magazine pool this gun draws from

SWEP.ShootVol = 125 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = nil
SWEP.ShootSound = ""
SWEP.ShootSoundLooping = nil
SWEP.FirstShootSoundSilenced = nil
SWEP.ShootDrySound = nil -- Add an attachment hook for Hook_GetShootDrySound please!
SWEP.DistantShootSound = nil
SWEP.ShootSoundSilenced = "weapons/arccw/m4a1/m4a1-1.wav"
SWEP.ShootSoundSilencedLooping = nil
SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"
SWEP.EnterBipodSound = "weapons/arccw/bipod_down.wav"
SWEP.ExitBipodSound = "weapons/arccw/bipod_up.wav"
SWEP.SelectUBGLSound =  "weapons/arccw/ubgl_select.wav"
SWEP.ExitUBGLSound = "weapons/arccw/ubgl_exit.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects
SWEP.ImpactEffect = nil
SWEP.ImpactDecal = nil

SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellMaterial = nil
SWEP.ShellEffect = nil
SWEP.ShellEjectPosCorrection = nil
SWEP.ShellScale = 1
SWEP.ShellPhysScale = 1
SWEP.ShellPitch = 100
SWEP.ShellSounds = "autocheck"--ArcCW.ShellSoundsTable
SWEP.ShellRotate = 0
SWEP.ShellTime = 0.5

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on
SWEP.ProceduralViewBobAttachment = nil -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.CamAttachment = nil -- if set, this attachment will control camera movement
SWEP.MuzzleFlashColor = Color(244, 209, 66)

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1

SWEP.BulletBones = { -- the bone that represents bullets in gun/mag
    -- [0] = "bulletchamber",
    -- [1] = "bullet1"
}
SWEP.CaseBones = {}
-- Unlike BulletBones, these bones are determined by the missing bullet amount when reloading
SWEP.StripperClipBones = {}

-- the same as the bone versions but works via bodygroups.
-- bodygroups work the same as in attachmentelements.
-- [0] = {ind = 0, bg = 1}
SWEP.BulletBGs = {}
SWEP.CaseBGs = {}
SWEP.StripperClipBGs = {}

SWEP.KeepBaseIrons = false -- do not override iron sights when scope installed
SWEP.BaseIronsFirst = false -- If a sight keeps base irons, irons comes first

SWEP.IronSightStruct = {
    Pos = Vector(-8.728, -13.702, 4.014),
    Ang = Angle(-1.397, -0.341, -2.602),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 15, -4),
        Ang = Angle(0, 0, -45),
    },
    Magnification = 1,
    BlackBox = false,
    ScopeTexture = nil,
    SwitchToSound = "", -- sound that plays when switching to this sight
    SwitchFromSound = "",
    ScrollFunc = ArcCW.SCROLL_NONE,
    CrosshairInSights = false,
}

SWEP.LaserOffsetAngle = nil -- adjusts the offset angle of lasers
SWEP.LaserIronsAngle = nil -- additional offset when using ironsights only

-- Works identically to AdditionalSights in attachments
-- KeepBaseIrons and BaseIronsFirst also affect this
SWEP.ExtraIrons = nil

-- add lasers to your weapon without attachments
SWEP.Lasers = nil
-- {
--     {
--         LaserStrength = 1,
--         LaserBone = "laser",
--         Color = Color(255, 0, 0)
--     }
-- }

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false
SWEP.SightTime = 0.33
SWEP.SprintTime = 0

-- Override free aim convar and variable
SWEP.FreeAimAngle = nil -- defaults to HipDispersion / 80. overwrite here
SWEP.NeverFreeAim = nil
SWEP.AlwaysFreeAim = nil

-- If Jamming is enabled, a heat meter will gradually build up until it reaches HeatCapacity.
-- Once that happens, the gun will overheat, playing an animation. If HeatLockout is true, it cannot be fired until heat is 0 again.
SWEP.Jamming = false
SWEP.HeatGain = 1 -- heat gained per shot
SWEP.HeatCapacity = 200 -- rounds that can be fired non-stop before the gun jams, playing the "fix" animation
SWEP.HeatDissipation = 2 -- rounds' worth of heat lost per second
SWEP.HeatLockout = false -- overheating means you cannot fire until heat has been fully depleted
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = false -- when the "fix" animation is played, all heat is restored.
SWEP.HeatOverflow = nil -- if true, heat is allowed to exceed capacity (this only applies when the default overheat handling is overridden)

-- If Malfunction is enabled, the gun has a random chance to be jammed
-- after the gun is jammed, it won't fire unless reload is pressed, which plays the "unjam" animation
-- if no "unjam", "fix", or "cycle" animations exist, the weapon will reload instead
SWEP.Malfunction = false
SWEP.MalfunctionJam = true -- After a malfunction happens, the gun will dryfire until reload is pressed. If unset, instead plays animation right after.
SWEP.MalfunctionTakeRound = true -- When malfunctioning, a bullet is consumed.
SWEP.MalfunctionPostFire = false -- If set, jam will occur after firing the round successfully.
SWEP.MalfunctionWait = 0.5 -- The amount of time to wait before playing malfunction animation (or can reload)
SWEP.MalfunctionMean = nil -- The mean number of shots between malfunctions, will be autocalculated if nil
SWEP.MalfunctionVariance = 0.25 -- The fraction of mean for variance. e.g. 0.2 means 20% variance
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "smg"
SWEP.HoldtypeCustomize = "slam"
SWEP.HoldtypeSprintShoot = nil
SWEP.HoldtypeNPC = nil

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.GuaranteeLaser = false -- GUARANTEE that the laser position will be accurate, so don't bother with sighted correction

SWEP.ShieldProps = nil
-- {
--     {
--         Model = "",
--         Pos = Vector(0, 0, 0),
--         Ang = Angle(0, 0, 0),
--         Bone = "", -- leave blank for valvebiped right hand
--         Resistance = 5, -- one unit of this object counts for how much penetration amount
--     }
-- }

SWEP.CanBash = true
SWEP.PrimaryBash = false -- primary attack triggers melee attack

SWEP.Lunge = nil -- Whether to allow the bash/melee to lunge a short distance
SWEP.LungeLength = 64 -- Maximum distance for lunging

SWEP.MeleeDamage = 25
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.Melee2 = false
SWEP.Melee2Damage = 25
SWEP.Melee2Range = 16
SWEP.Melee2Time = 0.5
SWEP.Melee2Gesture = nil
SWEP.Melee2AttackTime = 0.2

SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)

SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.ReloadPos = nil
SWEP.ReloadAng = nil

SWEP.CrouchPos = nil
SWEP.CrouchAng = nil

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)

-- When using custom sprint animations, set this to the same as ActivePos and ActiveAng
SWEP.SprintPos = nil
SWEP.SprintAng = nil

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)

SWEP.CustomizePos = Vector(9.824, 0, -4.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.BarrelLength = 24

SWEP.SightPlusOffset = nil

SWEP.DefaultPoseParams = {} -- {["pose"] = 0.5}
SWEP.DefaultWMPoseParams = {}

SWEP.DefaultElements = {} -- {"ele1", "ele2"}

SWEP.AttachmentElements = {
    -- ["name"] = {
    --     RequireFlags = {}, -- same as attachments
    --     ExcludeFlags = {},
    --     NamePriority = 0, -- higher = more likely to be chosen
    --     NameChange = "",
    --     TrueNameChange = "",
    --     AddPrefix = "",
    --     AddSuffix = "",
    --     VMPoseParams = {}, -- {["pose"] = 0.5}
    --     VMColor = Color(),
    --     VMMaterial = "",
    --     VMBodygroups = {{ind = 1, bg = 1}},
    --     VMElements = {
    --         {
    --             Model = "",
    --             Bone = "",
    --             Offset = {
    --                 pos = Vector(),
    --                 ang = Angle(),
    --             },
    --             ModelSkin = 0,
    --             ModelBodygroups = "",
    --             Scale = Vector(1, 1, 1),
    --             IsMuzzleDevice = false -- this element is a muzzle device, and the muzzle flash should come from here.
    --         }
    --     },
    --     VMOverride = "", -- change the view model to something else. Please make sure it's compatible with the last one.
    --     VMBoneMods = {
    --         ["bone"] = Vector(0, 0, 0)
    --     },
    --     WMPoseParams = {}, -- {["pose"] = 0.5}
    --     WMColor = Color(),
    --     WMMaterial = "",
    --     WMBodygroups = {},
    --     WMElements = {
    --         {
    --             Model = "",
    --             Offset = {
    --                 pos = Vector(),
    --                 ang = Angle(),
    --             },
    --             IsMuzzleDevice = false -- this element is a muzzle device, and the muzzle flash should come from here.
    --         }
    --     },
    --     WMOverride = "", -- change the world model to something else. Please make sure it's compatible with the last one.
    --     WMBoneMods = {
    --         ["bone"] = Vector(0, 0, 0)
    --     },
    --     AttPosMods = {
    --         [1] = {
    --             bone = "", -- optional
    --             vpos = Vector(0, 0, 0),
    --             vang = Angle(0, 0, 0),
    --             wpos = Vector(0, 0, 0),
    --             wang = Angle(0, 0, 0),
    --             SlideAmount = { -- only if base att has slideable
    --                 vmin = Vector(0, 0, 0),
    --                 vmax = Vector(0, 0, 0),
    --                 wmin = Vector(0, 0, 0),
    --                 wmax = Vector(0, 0, 0)
    --             }
    --         }
    --     }
    -- }
}

SWEP.RejectAttachments = {
    -- ["optic_docter"] = true -- stop this attachment from being usable on this gun
}

SWEP.TTT_DoNotAttachOnBuy = false -- don't give all attachments when bought

SWEP.Attachments = {}
-- [1] = {
--     PrintName = "Optic", -- print name
--     DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
--     DefaultAttIcon = Material(),
--     Slot = "pic_sight", -- what kind of attachments can fit here
--     MergeSlots = {}, -- these other slots will be merged into this one.
--     Bone = "sight", -- relevant bone any attachments will be mostly referring to
--     WMBone = "ValveBiped.Bip01_L_Hand", -- set it to change parent bone of attachment WM
--     KeepBaseIrons = false,
--     ExtraSightDist = 0,
--     Offset = {
--         vpos = Vector(0, 0, 0), -- offset that the attachment will be relative to the bone
--         vang = Angle(0, 0, 0),
--         wpos = Vector(0, 0, 0), -- same, for the worldmodels
--         wang = Angle(0, 0, 0)
--     },
--     RejectAttachments = {}, -- specific blacklist of attachments this slot cannot accept. Needs to be like {"optic_mrs" = true}
--     VMScale = Vector(1, 1, 1),
--     WMScale = Vector(1, 1, 1),
--     SlideAmount = { -- how far this attachment can slide in both directions.
--         -- overrides Offset.
--         vmin = Vector(0, 0, 0),
--         vmax = Vector(0, 0, 0),
--         wmin = Vector(0, 0, 0),
--         wmax = Vector(0, 0, 0),
--     },
--     CorrectiveAng = Vector(1, 1, 1), -- okay, I know I said sights were pain-free.
--     CorrectivePos = Vector(0, 0, 0), -- that won't always be the case. Use these to fix it. Issues mainly crop up in case of sights parented to bones that are not a root bone.
--     InstalledEles = {"toprail"}, -- activate these AttachmentElements if something is installed
--     DefaultEles = {""} -- activeate these AttachmentElements *unless* something is installed
--     Hidden = false, -- attachment cannot be seen in customize menu
--     Integral = false, -- attachment is assumed never to change
--     RandomChance = 1, -- multiplies chance this slot will get a random attachment
--     DoNotRandomize = false,
--     NoWM = false, -- do not make this show up on worldmodel
--     NoVM = false, -- what do *you* think this one does?
--     FreeSlot = false, -- slot does not count towards attachment capacity
--     -- ABOUT THE FLAG SYSTEM:
--     -- Attachments and slots can give flags
--     -- All attachments automatically give themselves as a flag, e.g. "optic_mrs"
--     -- If requirements are not satisfied, the slot or attachment will not be attachable
--     ExcludeFlags = {}, -- if the weapon has this flag, hide this slot
--     RequireFlags = {}, -- if the weapon does not have all these flags, hide this slot
--     GivesFlags = {} -- give these slots if something is installed here
--     DefaultFlags = {} -- give these slots UNLESS something is installed here
--     HideIfBlocked = false, -- If flag requirements are not met, do not show the attachment at all
-- }

-- ready: deploy first time
-- draw
-- holster
-- reload
-- fire
-- cycle (for bolt/pump actions)
-- bash
-- fix
-- enter_bipod
-- exit_bipod
-- enter_sight
-- exit_sight
-- a_to_b: switch from firemode a to firemode b. e.g.: 1_to_2
-- idle
-- idle_sights
-- idle_sprint
-- idle_bipod
-- enter_inspect
-- idle_inspect
-- exit_inspect
-- enter_ubgl
-- exit_ubgl
-- idle_ubgl

-- you can append suffixes for different states
-- append list:

-- _iron, _sights, or _sight     for sighted variation
-- _sprint                       for sprinting variation
-- _bipod                        for bipod variation
-- _empty                        for empty variation
-- _jammed                       for jammed variation

-- this does not apply to reload animations.

-- !! they MUST be in the order of this list.
-- example: fire_iron_bipod_empty

-- use SWEP/wep.Hook_TranslateAnimation, same as in attachment, to do even more behaviours
-- use SWEP/wep.Hook_SelectReloadAnimation to change the reload animation
-- use SWEP/wep.Hook_SelectInsertAnimation to change the shotgun reload insert animation
-- use SWEP/wep.Hook_SelectFireAnimation to change the fire animation
-- use SWEP/wep.Hook_SelectCycleAnimation to change the cycle/pump animation
-- use SWEP/wep.Hook_SelectBashAnim to change the bash animation
-- use SWEP/wep.Hook_SelectJamAnim to change the jam animation

-- which sequence to derive the sight autosolver from.
SWEP.AutosolveSourceSeq = "idle"

-- Disclaimer: LHIK is *actually* a type of forward kinematics.
-- If you prefer, LHIK can stand for "Left Hand Individual Kinematics" or some shit

SWEP.Animations = {
    -- ["idle"] = {
    --     Source = "idle",
    --     Time = 10
    -- },
    -- ["draw"] = {
    --     RestoreAmmo = 1, -- only used by shotgun empty insert reload
    --     Source = "deploy",
    --     RareSource = "", -- 1/RareSourceChance of playing this animation instead
    --     RareSourceChance = 100, -- Chance the rapper
    --     Time = 0.5, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    --     Mult = 1, -- Multiplies the rate of animation.
    --     TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, -- third person animation to play when this animation is played
    --     TPAnimStartTime = 0, -- when to start it from
    --     Checkpoints = {}, -- time checkpoints. If weapon is unequipped, the animation will continue to play from these checkpoints when reequipped.
    --     ShellEjectAt = 0, -- animation includes a shell eject at these times
    --     LHIKIn = 0.25, -- In/Out controls how long it takes to switch to regular animation.
    --     LHIKOut = 0.25, -- (not actually inverse kinematics)
    --     LHIKEaseIn = 0.1, -- how long LHIK eases in.
    --     LHIKEaseOut = 0.1, -- if no value is specified then ease = lhikin
    --     LHIKTimeline = { -- allows arbitrary LHIK values to be interpolated between
    --         {
    --             t = 0.1,
    --             lhik = 0,
    --         },
    --         {
    --             t = 0.25,
    --             lhik = 1
    --         }
    --     },
    --     LHIK = true, -- basically disable foregrips on this anim
    --     SoundTable = {
    --         {
    --             s = "", -- sound; can be string or table
    --             p = 100, -- pitch
    --             v = 75, -- volume
    --             t = 1, -- time at which to play relative to Animations.Time
    --             c = CHAN_ITEM, -- channel to play the sound

    --             -- Can also play an effect at the same time
    --             e = "", -- effect name
    --             att = nil, -- attachment, defaults to shell attachment
    --             mag = 100, -- magnitude
    --             -- also capable of modifying bodygroups
    --             ind = 0,
    --             bg = 0,
    --             -- and poseparams
    --             pp = "pose",
    --             ppv = 0.25,
    --         }
    --     },
    --     ViewPunchTable = {
    --         {
    --             p = Vector(0, 0, 0),
    --             t = 1
    --         }
    --     },
    --     ProcDraw = false, -- for draw/deploy animations, always procedurally draw in addition to playing animation
    --     ProcHolster = false, -- procedural holster weapon, THEN play animation
    --     LastClip1OutTime = 0, -- when should the belt visually replenish on a belt fed
    --     MinProgress = 0, -- how much time in seconds must pass before the animation can be cancelled
    --     ForceEmpty = false, -- Used by empty shotgun reloads that load rounds to force consider the weapon to still be empty.
    --     ForceCamReset = false, -- Use the first frame of the sequence as starting angles for the cambone.
    -- }
}

-- don't change any of this stuff

SWEP.Primary.Automatic = true
SWEP.Primary.DefaultClip = -1
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.DrawCrosshair = true
SWEP.m_WeaponDeploySpeed = 80.08135 -- 8008135 boobies is funny but it'll bitch in console :(
        -- We don't do that here

SWEP.ArcCW = true
SWEP.BurstCount = 0
SWEP.AnimQueue = {}
SWEP.FiremodeIndex = 1
SWEP.UnReady = true
SWEP.EventTable = {
    [1] = {} -- for every overlapping one, a new one is made -- checked to be removed afterwards, except 1
}

SWEP.ProneMod_DisableTransitions = true

SWEP.DrawWeaponInfoBox = false
SWEP.BounceWeaponIcon = false

if CLIENT or game.SinglePlayer() then

SWEP.RecoilAmount = 0
SWEP.RecoilAmountSide = 0
SWEP.RecoilPunchBack = 0
SWEP.RecoilPunchUp = 0
SWEP.RecoilPunchSide = 0
SWEP.HammerDown = false

SWEP.LHIKTimeline = nil
SWEP.LHIKStartTime = 0
-- {number starttime, number intime, number outtime, number finishouttime}
end

SWEP.Bodygroups = {} -- [0] = 1, [1] = 0...
-- SWEP.RegularClipSize = 0

local searchdir = "weapons/arccw_base"

local function autoinclude(dir)
    local files, dirs = file.Find(searchdir .. "/*.lua", "LUA")

    for _, filename in pairs(files) do
        if filename == "shared.lua" then continue end
        local luatype = string.sub(filename, 1, 2)

        if luatype == "sv" then
            if SERVER then
                include(dir .. "/" .. filename)
            end
        elseif luatype == "cl" then
            AddCSLuaFile(dir .. "/" .. filename)
            if CLIENT then
                include(dir .. "/" .. filename)
            end
        else
            AddCSLuaFile(dir .. "/" .. filename)
            include(dir .. "/" .. filename)
        end
    end

    for _, path in pairs(dirs) do
        autoinclude(dir .. "/" .. path)
    end
end

autoinclude(searchdir)

function SWEP:SetupDataTables()
    self:NetworkVar("Int", 0, "NWState")
    self:NetworkVar("Int", 1, "FireMode")
    self:NetworkVar("Int", 2, "BurstCountUM")
    self:NetworkVar("Int", 3, "LastLoad")
    self:NetworkVar("Int", 4, "NthReload")
    self:NetworkVar("Int", 5, "NthShot")

    -- 2 = insert
    -- 3 = cancelling
    -- 4 = insert empty
    -- 5 = cancelling empty
    self:NetworkVar("Int", 6, "ShotgunReloading")
    self:NetworkVar("Int", 7, "MagUpCount")

    self:NetworkVar("Bool", 0, "HeatLocked")
    self:NetworkVar("Bool", 1, "NeedCycle")
    self:NetworkVar("Bool", 2, "InBipod")
    self:NetworkVar("Bool", 3, "InUBGL")
    self:NetworkVar("Bool", 4, "InCustomize")
    self:NetworkVar("Bool", 5, "GrenadePrimed")
    self:NetworkVar("Bool", 6, "NWMalfunctionJam")
    self:NetworkVar("Bool", 7, "UBGLDebounce")

    self:NetworkVar("Float", 0, "Heat")
    self:NetworkVar("Float", 1, "WeaponOpDelay")
    self:NetworkVar("Float", 2, "ReloadingREAL")
    self:NetworkVar("Float", 3, "MagUpIn")
    self:NetworkVar("Float", 4, "NextPrimaryFireSlowdown")
    self:NetworkVar("Float", 5, "NextIdle")
    self:NetworkVar("Float", 6, "Holster_Time")
    self:NetworkVar("Float", 7, "NWSightDelta")
    self:NetworkVar("Float", 8, "NWSprintDelta")
    self:NetworkVar("Float", 9, "NWPriorityAnim")

    self:NetworkVar("Vector", 0, "BipodPos")

    self:NetworkVar("Angle", 0, "BipodAngle")
    self:NetworkVar("Angle", 1, "FreeAimAngle")
    self:NetworkVar("Angle", 2, "LastAimAngle")

    self:NetworkVar("Entity", 0, "Holster_Entity")

    self:SetNWSightDelta(1)
end

function SWEP:OnRestore()
    self:SetNthReload(0)
    self:SetNthShot(0)
    self:SetBurstCountUM(0)
    self:SetReloadingREAL(0)
    self:SetWeaponOpDelay(0)
    self:SetMagUpIn(0)
    self:SetNWPriorityAnim(0)

    self:KillTimers()
    self:Initialize()

    self.UnReady = false
end


function SWEP:SetReloading(v)
    if isbool(v) then
        if v then
            self:SetReloadingREAL(math.huge)
        else
            self:SetReloadingREAL(-math.huge)
        end
    elseif isnumber(v) and v > self:GetReloadingREAL() then
        self:SetReloadingREAL( v )
    end
end

function SWEP:GetReloading()
    local decide

    if self:GetReloadingREAL() > CurTime() then
        decide = true
    else
        decide = false
    end

    self:GetBuff_Hook("Hook_GetReloading", decide)

    return decide
end

function SWEP:SetBurstCount(b)
    self:SetBurstCountUM(b)
end

function SWEP:GetBurstCount()
    return self:GetBuff_Hook("Hook_GetBurstCount", self:GetBurstCountUM()) or self:GetBurstCountUM() or 0
end

function SWEP:SetState(v)
    self:SetNWState(v)
    if !game.SinglePlayer() and CLIENT then self.State = v end
end

function SWEP:GetState(v)
    if !game.SinglePlayer() and CLIENT and self.State then return self.State end
    return self:GetNWState(v)
end

function SWEP:IsProne()
    if PRONE_INPRONE then
        return self:GetOwner().IsProne and self:GetOwner():IsProne()
    else
        return false
    end
end

-- BarrelHitWall is known to cause viewmodel flickering on certain playermodels if called during VM position function (a270cc9)
local hitwallcache
function SWEP:BarrelHitWall()

    local len = self:GetBuff("BarrelLength")
    if len == 0 or !ArcCW.ConVars["override_nearwall"]:GetBool()
            or (vrmod and vrmod.IsPlayerInVR(self:GetOwner()))
            or (self:GetOwner():IsPlayer() and self:GetOwner():InVehicle()) then
        hitwallcache = {0, CurTime()}
    end

    if !hitwallcache or hitwallcache[2] ~= CurTime() then

        local offset = self:GetBuff("BarrelOffsetHip")

        if self:GetState() == ArcCW.STATE_SIGHTS then
            offset = LerpVector(self:GetSightDelta(), self:GetBuff("BarrelOffsetSighted"), offset)
        end

        local dir = self:GetOwner():EyeAngles()
        local src = self:GetOwner():EyePos()
        local r, f, u = dir:Right(), dir:Forward(), dir:Up()

        for i = 1, 3 do
            src[i] = src[i]
                    + r[i] * offset[1]
                    + f[i] * offset[2]
                    + u[i] * offset[3]
        end

        local filter = {self:GetOwner()}

        table.Add(filter, self.Shields)

        local tr = util.TraceLine({
            start = src,
            endpos = src + (f * len),
            filter = filter,
            mask = MASK_SOLID
        })

        if tr.Hit and !tr.Entity.ArcCWProjectile then
            --local l = (tr.HitPos - src):Length()
            --hitwallcache = {math.Clamp(1 - l / len, 0, 1), CurTime()}
            hitwallcache = {1 - tr.Fraction, CurTime()}
        else
            hitwallcache = {0, CurTime()}
        end
    end

    return hitwallcache[1] or 0
end

function SWEP:GetBarrelNearWall()
    return hitwallcache and hitwallcache[1] or 0
end

SWEP.CL_SightDelta = 1
function SWEP:SetSightDelta(d)
    if !game.SinglePlayer() and CLIENT then self.CL_SightDelta = d end
    self:SetNWSightDelta(d)
end

function SWEP:GetSightDelta()
    if !game.SinglePlayer() and CLIENT then return self.CL_SightDelta end
    return self:GetNWSightDelta()
end

SWEP.CL_SprintDelta = 0
function SWEP:SetSprintDelta(d)
    if !game.SinglePlayer() and CLIENT then self.CL_SprintDelta = d end
    self:SetNWSprintDelta(d)
end

function SWEP:GetSprintDelta()
    if !game.SinglePlayer() and CLIENT then return self.CL_SprintDelta end
    return self:GetNWSprintDelta()
end

SWEP.CL_MalfunctionJam = false
function SWEP:SetMalfunctionJam(d)
    if !game.SinglePlayer() and CLIENT then self.CL_MalfunctionJam = tobool(d) end
    self:SetNWMalfunctionJam(d)
end

function SWEP:GetMalfunctionJam()
    if !game.SinglePlayer() and CLIENT then return self.CL_MalfunctionJam end
    return self:GetNWMalfunctionJam()
end

-- DIRTY OPTIMIZATION TRICK: NeedCycle is reused for grenades!
function SWEP:SetGrenadeAlt(d)
    if !self.Throwing then return end
    self:SetNeedCycle(d)
end

function SWEP:GetGrenadeAlt()
    if !self.Throwing then return false end
    return self:GetNeedCycle()
end

function SWEP:SetPriorityAnim(v)
    if isbool(v) then
        if v then
            self:SetNWPriorityAnim(math.huge)
        else
            self:SetNWPriorityAnim(-math.huge)
        end
    elseif isnumber(v) and v > self:GetNWPriorityAnim() then
        self:SetNWPriorityAnim(v)
    end
end

function SWEP:GetPriorityAnim()
    local decide = self:GetNWPriorityAnim() > CurTime()

    -- Reloading is always a priority animation
    if !decide then decide = self:GetReloading() end

    self:GetBuff_Hook("Hook_GetPriorityAnim", decide)

    return decide
end
--PATH lua/weapons/arccw_base/cl_light.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/sh_firemodes.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/sh_sights.lua:
SWEP.Sighted = false
SWEP.Sprinted = false

local function linearlerp(a, b, c)
    return b + (c - b) * a
end

function SWEP:GetSightTime()
    return self:GetBuff("SightTime")
end

function SWEP:EnterSprint()
    if engine.ActiveGamemode() == "terrortown" and !(TTT2 and self:GetOwner().isSprinting) then return end
    if self:GetState() == ArcCW.STATE_SPRINT then return end
    if self:GetState() == ArcCW.STATE_CUSTOMIZE then return end
    if self:GetTriggerDelta() > 0 then return end
    if self:GetGrenadePrimed() and !self:CanShootWhileSprint() then return end
    self:SetState(ArcCW.STATE_SPRINT)
    self.Sighted = false
    self.Sprinted = true

    local ct = CurTime()

    -- self.SwayScale = 1
    -- self.BobScale = 5

    self:SetShouldHoldType()

    local s = self:CanShootWhileSprint()

    if !s and self:GetNextPrimaryFire() <= ct then
        self:SetNextPrimaryFire(ct)
    end

    local anim = self:SelectAnimation("enter_sprint")
    if anim and !s and self:GetNextSecondaryFire() <= ct then
        self:PlayAnimation(anim, self:GetBuff("SightTime") / self:GetAnimKeyTime(anim, true), true, nil, false, nil, false, false)
    end
end

function SWEP:ExitSprint()
    if self:GetState() == ArcCW.STATE_IDLE then return end

    local delta = self:GetNWSprintDelta()
    local ct = CurTime()

    self:SetState(ArcCW.STATE_IDLE)
    self.Sighted = false
    self.Sprinted = false

    -- self.SwayScale = 1
    -- self.BobScale = 1.5

    self:SetShouldHoldType()

    local s = self:CanShootWhileSprint()

    if !s and self:GetNextPrimaryFire() <= ct then
        self:SetNextPrimaryFire(ct + self:GetSprintTime() * delta)
    end

    if self:GetOwner():KeyDown(IN_ATTACK2) then
        self:EnterSights()
    end

    local anim = self:SelectAnimation("exit_sprint")
    if anim and !s then -- and self:GetNextSecondaryFire() <= ct
        self:PlayAnimation(anim, self:GetBuff("SightTime") / self:GetAnimKeyTime(anim, true), true, nil, false, nil, false, false)
    end
end

-- defined above already?

function SWEP:EnterSights()
    local asight = self:GetActiveSights()
    if !asight then return end
    if self:GetState() != ArcCW.STATE_IDLE then return end
    if self:GetCurrentFiremode().Mode == 0 then return end
    if !self.ReloadInSights and (self:GetReloading() or self:GetOwner():KeyDown(IN_RELOAD)) then return end
    if self.LockSightsInPriorityAnim and self:GetPriorityAnim() then return end
    if self:GetBuff_Hook("Hook_ShouldNotSight") then return end
    if (!game.SinglePlayer() and !IsFirstTimePredicted()) then return end

    self:SetupActiveSights()

    self:SetState(ArcCW.STATE_SIGHTS)
    self.Sighted = true
    self.Sprinted = false

    self:SetShouldHoldType()

    self:MyEmitSound(asight.SwitchToSound or "", 75, math.Rand(95, 105), 0.5, CHAN_AUTO)

    local anim = self:SelectAnimation("enter_sight")
    if anim then
        self:PlayAnimation(anim, 1 * self:GetBuff_Mult("Mult_SightTime"), true)
    end

    self:GetBuff_Hook("Hook_SightToggle", true)
end

function SWEP:ExitSights()
    local asight = self:GetActiveSights()
    if self:GetState() != ArcCW.STATE_SIGHTS then return end
    if self.LockSightsInReload and self:GetReloading() then return end
    if self.LockSightsInPriorityAnim and self:GetPriorityAnim() then return end
    if (!game.SinglePlayer() and !IsFirstTimePredicted()) then return end

    self:SetState(ArcCW.STATE_IDLE)
    self.Sighted = false
    self.Sprinted = false

    self:SetShouldHoldType()

    self:MyEmitSound(asight.SwitchFromSound or "", 75, math.Rand(80, 90), 0.5, CHAN_AUTO)

    if self:InSprint() then
        self:EnterSprint()
    end

    self:MyEmitSound(asight.SwitchFromSound or "", 75, math.Rand(80, 90), 0.5, CHAN_AUTO)

    local anim = self:SelectAnimation("exit_sight")
    if anim then
        self:PlayAnimation(anim, 1 * self:GetBuff_Mult("Mult_SightTime"), true)
    end

    self:GetBuff_Hook("Hook_SightToggle", false)
end

function SWEP:GetSprintTime()
    return self:GetSightTime()
end

SWEP.SightTable = {}
SWEP.SightMagnifications = {}

function SWEP:SetupActiveSights()
    if !self.IronSightStruct then return end
    if self:GetBuff_Hook("Hook_ShouldNotSight") then return false end

    if !self:GetOwner():IsPlayer() then return end

    local sighttable = {}
    local vm = self:GetOwner():GetViewModel()

    if !vm or !vm:IsValid() then return end

    local kbi = self.KeepBaseIrons or true
    local bif = self.BaseIronsFirst or true

    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end

        local atttbl = ArcCW.AttachmentTable[k.Installed]

        local addsights = self:GetBuff_Stat("AdditionalSights", i)
        if !addsights then continue end

        if !k.KeepBaseIrons and !atttbl.KeepBaseIrons then kbi = false end
        if !k.BaseIronsFirst and !atttbl.BaseIronsFirst then bif = false end

        for _, s in pairs(addsights) do
            local stab = table.Copy(s)

            stab.Slot = i

            if stab.HolosightData then atttbl = stab.HolosightData end

            stab.HolosightData = atttbl

            if atttbl.HolosightMagnification then
                stab.MagnifiedOptic = true
                stab.ScopeMagnification = atttbl.HolosightMagnification or 1

                if atttbl.HolosightMagnificationMin then
                    stab.ScopeMagnificationMin = atttbl.HolosightMagnificationMin
                    stab.ScopeMagnificationMax = atttbl.HolosightMagnificationMax

                    stab.ScopeMagnification = math.max(stab.ScopeMagnificationMax, stab.ScopeMagnificationMin)

                    if !i and self.SightMagnifications[0] then
                        stab.ScopeMagnification = self.SightMagnifications[0]
                    elseif self.SightMagnifications[i] then
                        stab.ScopeMagnification = self.SightMagnifications[i]
                    end
                else
                    stab.ScopeMagnification = atttbl.HolosightMagnification
                end
            end

            if atttbl.Holosight then
                stab.Holosight = true
            end

            if !k.Bone then return end

            local boneid = vm:LookupBone(k.Bone)

            if !boneid then return end

            if CLIENT then

                if atttbl.HolosightPiece then
                    stab.HolosightPiece = (k.HSPElement or {}).Model
                end

                if atttbl.Holosight then
                    stab.HolosightModel = (k.VElement or {}).Model
                end

                local bpos, bang = self:GetFromReference(boneid)

                local offset
                local offset_ang

                local vmang = Angle()

                offset = k.Offset.vpos or Vector(0, 0, 0)

                local attslot = k

                local delta = attslot.SlidePos or 0.5

                local vmelemod = nil
                local slidemod = nil

                for _, e in pairs(self:GetActiveElements()) do
                    local ele = self.AttachmentElements[e]

                    if !ele then continue end

                    if ((ele.AttPosMods or {})[i] or {}).vpos then
                        vmelemod = ele.AttPosMods[i].vpos
                    end

                    if ((ele.AttPosMods or {})[i] or {}).slide then
                        slidemod = ele.AttPosMods[i].slide
                    end

                    -- Refer to sh_model Line 837
                    if ((ele.AttPosMods or {})[i] or {}).SlideAmount then
                        slidemod = ele.AttPosMods[i].SlideAmount
                    end
                end

                offset = vmelemod or attslot.Offset.vpos or Vector()

                if slidemod or attslot.SlideAmount then
                    offset = LerpVector(delta, (slidemod or attslot.SlideAmount).vmin, (slidemod or attslot.SlideAmount).vmax)
                end

                offset_ang = k.Offset.vang or Angle(0, 0, 0)
                offset_ang = offset_ang + (atttbl.OffsetAng or Angle(0, 0, 0))

                offset_ang = k.VMOffsetAng or offset_ang

                bpos, bang = WorldToLocal(Vector(0, 0, 0), Angle(0, 0, 0), bpos, bang)

                bpos = bpos + bang:Forward() * offset.x
                bpos = bpos + bang:Right() * offset.y
                bpos = bpos + bang:Up() * offset.z

                bang:RotateAroundAxis(bang:Right(), offset_ang.p)
                bang:RotateAroundAxis(bang:Up(), -offset_ang.y)
                bang:RotateAroundAxis(bang:Forward(), offset_ang.r)

                local vpos = Vector()

                vpos.y = -bpos.x
                vpos.x = bpos.y
                vpos.z = -bpos.z

                local corpos = (k.CorrectivePos or Vector(0, 0, 0))

                vpos = vpos + bang:Forward() * corpos.x
                vpos = vpos + bang:Right() * corpos.y
                vpos = vpos + bang:Up() * corpos.z

                -- vpos = vpos + (bang:Forward() * s.Pos.x)
                -- vpos = vpos - (bang:Right() * s.Pos.y)
                -- vpos = vpos + (bang:Up() * s.Pos.z)

                vmang:Set(-bang)

                bang.r = -bang.r
                bang.p = -bang.p
                bang.y = -bang.y

                corang = k.CorrectiveAng or Angle(0, 0, 0)

                bang:RotateAroundAxis(bang:Right(), corang.p)
                bang:RotateAroundAxis(bang:Up(), corang.y)
                bang:RotateAroundAxis(bang:Forward(), corang.r)

                -- vpos = LocalToWorld(s.Pos + Vector(0, self.ExtraSightDist or 0, 0), Angle(0, 0, 0), vpos, bang)

                -- local vmf = (vmang):Forward():GetNormalized()
                -- local vmr = (vmang):Right():GetNormalized()
                -- local vmu = (vmang):Up():GetNormalized()

                -- print(" ----- vmf, vmr, vmu")
                -- print(vmf)
                -- print(vmr)
                -- print(vmu)

                -- vmf = -vmf
                -- vmf.x = -vmf.x

                -- local r = vmf.y
                -- vmf.y = vmf.z
                -- vmf.z = r

                -- vmr = -vmr
                -- vmr.y = -vmr.y

                -- -- local r = vmr.y
                -- -- vmr.y = vmr.z
                -- -- vmr.z = r

                -- vmu = -vmu
                -- vmu.z = vmu.z

                -- local evpos = Vector(0, 0, 0)

                -- evpos = evpos + (vmf * (s.Pos.x + k.CorrectivePos.x))
                -- evpos = evpos - (vmr * (s.Pos.y + (self.ExtraSightDist or 0) + k.CorrectivePos.y))
                -- evpos = evpos + (vmu * (s.Pos.z + k.CorrectivePos.z))

                -- print(vmang:Forward())

                local evpos = s.Pos

                evpos = evpos * (k.VMScale or Vector(1, 1, 1))

                if atttbl.Holosight and !atttbl.HolosightMagnification then
                    evpos = evpos + Vector(0, k.ExtraSightDist or self.ExtraSightDist or 0, 0)
                end

                evpos = evpos + (k.CorrectivePos or Vector(0, 0, 0))

                stab.Pos, stab.Ang = vpos, bang

                stab.EVPos = evpos
                stab.EVAng = s.Ang

                if s.GlobalPos then
                    stab.EVPos = Vector(0, 0, 0)
                    stab.Pos = s.Pos
                end

                if s.GlobalAng then
                    stab.Ang = Angle(0, 0, 0)
                end

            end

            table.insert(sighttable, stab)
        end
    end

    if kbi then
        local extra = self.ExtraIrons
        if extra then
            for _, ot in pairs(extra) do
                local t = table.Copy(ot)
                t.IronSight = true
                if bif then
                    table.insert(sighttable, 1, t)
                else
                    table.insert(sighttable, t)
                end
            end
        end

        local t = table.Copy(self:GetBuff_Override("Override_IronSightStruct") or self.IronSightStruct)
        t.IronSight = true
        if bif then
            table.insert(sighttable, 1, t)
        else
            table.insert(sighttable, t)
        end
    end

    self.SightTable = sighttable
end

function SWEP:SwitchActiveSights()
    if table.Count(self.SightTable) == 1 then return end

    self.ActiveSight = (self.ActiveSight or 1) + 1

    if self.ActiveSight > table.Count(self.SightTable) then
        self.ActiveSight = 1
    end

    local asight = self:GetActiveSights()

    local tbl = self:GetBuff_Hook("Hook_SwitchActiveSights", {active = self.ActiveSight, asight = asight})

    self.ActiveSight = tbl.active or self.ActiveSight

    if self.ActiveSight > table.Count(self.SightTable) then
        self.ActiveSight = 1
    end

    local asight2 = self:GetActiveSights()

    if asight2.SwitchToSound then
        self:MyEmitSound(asight2.SwitchToSound, 75, math.Rand(95, 105), 0.5, CHAN_VOICE2)
    end
end

function SWEP:GetActiveSights()
    if (self.ActiveSight or 1) > table.Count(self.SightTable) then
        self.ActiveSight = 1
    end

    if table.Count(self.SightTable) == 0 then
        return self.IronSightStruct
    else
        return self.SightTable[self.ActiveSight or 1]
    end
end

local function ScaleFOVByWidthRatio( fovDegrees, ratio )
    local halfAngleRadians = fovDegrees * ( 0.5 * math.pi / 180 )
    local t = math.tan( halfAngleRadians )
    t = t * ratio
    local retDegrees = ( 180 / math.pi ) * math.atan( t )
    return retDegrees * 2
end

function SWEP:QuickFOVix( fov )
    return ScaleFOVByWidthRatio( fov, (ScrW and ScrW() or 4)/(ScrH and ScrH() or 3)/(4/3) )
end

SWEP.LastTranslateFOV = 0
function SWEP:TranslateFOV(fov)
    local irons = self:GetActiveSights()

    if CLIENT and ArcCW.ConVars["dev_benchgun"]:GetBool() then self.CurrentFOV = fov self.CurrentViewModelFOV = fov return fov end

    self.ApproachFOV = self.ApproachFOV or fov
    self.CurrentFOV = self.CurrentFOV or fov

    -- Only update every tick (this function is called multiple times per tick)
    if self.LastTranslateFOV == UnPredictedCurTime() then return self.CurrentFOV end
    local timed = UnPredictedCurTime() - self.LastTranslateFOV
    self.LastTranslateFOV = UnPredictedCurTime()

    local app_vm = self.ViewModelFOV + self:GetOwner():GetInfoNum("arccw_vm_fov", 0)
    if CLIENT then
        app_vm = app_vm * (LocalPlayer():GetFOV()/GetConVar("fov_desired"):GetInt())
    end

    if self:GetState() == ArcCW.STATE_SIGHTS then
        local asight = self:GetActiveSights()
        local mag = asight and asight.ScopeMagnification or 1

        local delta = math.pow(self:GetSightDelta(), 2)

        if CLIENT then
            local addads = math.Clamp(ArcCW.ConVars["vm_add_ads"]:GetFloat() or 0, -2, 14)
            local csratio = math.Clamp(GetConVar("arccw_cheapscopesv2_ratio"):GetFloat() or 0, 0, 1)
            local pfov = GetConVar("fov_desired"):GetInt()

            if ArcCW.ConVars["cheapscopes"]:GetBool() and mag > 1 then
                fov = (pfov / (asight and asight.Magnification or 1)) / (mag / (1 + csratio * mag) + (addads or 0) / 3)
            else
                fov = ( (pfov / (asight and asight.Magnification or 1)) * (1 - delta)) + (GetConVar("fov_desired"):GetInt() * delta)
            end

            app_vm = irons.ViewModelFOV or 45

            app_vm = app_vm - (asight.MagnifiedOptic and (addads or 0) * 3 or 0)
        end
    end

    self.ApproachFOV = fov

    -- magic number? multiplier of 10 seems similar to previous behavior
    self.CurrentFOV = math.Approach(self.CurrentFOV, self.ApproachFOV, timed * 10 * (self.CurrentFOV - self.ApproachFOV))

    self.CurrentViewModelFOV = self.CurrentViewModelFOV or self.ViewModelFOV
    self.CurrentViewModelFOV = math.Approach(self.CurrentViewModelFOV, app_vm, timed * 10 * (self.CurrentViewModelFOV - app_vm))

    return self.CurrentFOV
end

function SWEP:SetShouldHoldType()
    if self:GetCurrentFiremode().Mode == 0 then
        self:SetHoldType(self.HoldtypeHolstered)
        return
    end

    if IsValid(self:GetOwner()) and self:GetOwner():IsNPC() and self.HoldtypeNPC then
        self:SetHoldType(self.HoldtypeNPC)
        return
    end

    local ht = "normal"

    if self:GetState() == ArcCW.STATE_SIGHTS then
        ht = self:GetBuff_Override("Override_HoldtypeSights", self.HoldtypeSights)
    elseif self:GetState() == ArcCW.STATE_SPRINT then
        if self:CanShootWhileSprint() then
            ht = self:GetBuff_Override("Override_HoldtypeSprintShoot", self.HoldtypeSprintShoot) or self:GetBuff_Override("Override_HoldtypeActive", self.HoldtypeActive)
        else
            ht = self:GetBuff_Override("Override_HoldtypeHolstered", self.HoldtypeHolstered)
        end
    elseif self:GetState() == ArcCW.STATE_CUSTOMIZE then
        ht = self:GetBuff_Override("Override_HoldtypeCustomize", self.HoldtypeCustomize)
    elseif self:GetCurrentFiremode().Mode == 0 then
        ht = self:GetBuff_Override("Override_HoldtypeHolstered", self.HoldtypeHolstered)
    elseif self.Throwing and self:GetGrenadePrimed() then
        ht = self:GetBuff_Override("Override_HoldtypeSights", self.HoldtypeSights)
    else
        ht = self:GetBuff_Override("Override_HoldtypeActive", self.HoldtypeActive)
    end

    self:SetHoldType(ht)
end

--PATH lua/weapons/arccw_dual_se14.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "[ ArcCW ] CIS TFA Weapons"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Dual SE-14"
SWEP.Trivia_Class = "CIS Dual Blaster Carbine"
SWEP.Trivia_Desc = "High tech compact Dual SE-14 Blaster Carbine."
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel = "models/arccw/weapons/synbf3/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dual_se14.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 120
SWEP.DamageMin = 17
SWEP.Range = 345
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.NoHideLeftHandInCustomization = true

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20*2

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 1.4
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 380
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },    
}

SWEP.AccuracyMOA = 0.75 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 800 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/se14c.wav"

SWEP.MuzzleFlashColor = Color(255, 0, 0, 50)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1.2,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -4)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)

SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)
SWEP.DrawCrosshair = true

SWEP.BarrelLength = 44
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"se14c", "se14c+"}

SWEP.AttachmentElements = {
    ["se14c"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/2019/se14_pistol.mdl",
                Bone = "LeftHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(05, -1.5, -0.75),
                    ang = Angle(-8, -2, 90)
                }
            }
        },
    },
    ["se14c+"] = {
         VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/2019/se14_pistol.mdl",
                Bone = "RightHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),                
                Offset = {
                    pos = Vector(-5, 1.5, 0.75),
                    ang = Angle(4, 178, 90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/2019/se14_pistol.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(40.5, 10, 20.75),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/sw_battlefront/weapons/2019/se14_pistol.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-40, 230, -25),
                    ang = Angle(180, -180, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/sw_battlefront/weapons/2019/se14_pistol.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-12, -4, 2.5),
            vang = Angle(170, 0, 0),
        },
    },    
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    }
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_lw", "shoot_rw"},
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--PATH lua/weapons/arccw_e5bx.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_grenade_base.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_a280s.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "A-280s"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The A280 blaster rifle was a type of blaster rifle mostly used by Rebel Alliance troopers and New Republic soldiers. There existed two variants of the A280 blaster, the A280C and the A280-CFE, both of which were favored by commandos and special force of the Rebel Alliance."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/a280s.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0000001000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_a280.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(0.9, 0.5, -2.9),
    ang = Angle(-10, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 31
SWEP.DamageMin = 23
SWEP.RangeMin = 0
SWEP.Range = 430
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 31

SWEP.Recoil = 0.93
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.75
SWEP.RecoilPunch = 0.8

SWEP.Delay = 60 / 450
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_A280"
SWEP.ShootSound = "ArcCW_Kraken.SW_A280"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(250, 0, 0)
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.373, -3, 0),
    Ang = Vector(0, 0.1, -3),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -2, 0)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, 0)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, -3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["optic_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["laser_attach"] = {
        VMBodygroups = {{ind = 4, bg = 1}},
    },
    ["foregrip_attach"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_attachments",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        InstalledEles = {"optic_attach"},
        Offset = {
            vpos = Vector(8.5, -0, 2),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(22.4, -0.1, 0.15),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        InstalledEles = {"laser_attach"},
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(13.5, 0.6, 0.5),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "A-280 Foregrip",
        Slot = {"foregrip"},
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        InstalledEles = {"foregrip_attach"},
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(13.4, 0.1, -0.3),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(5.55, -1.0, -1.34),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(2.5, -0.5, 0.09),
            vang = Angle(0, 0, 0),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/a280/handling_2/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
    },
    ["reload"] = {
        Source = "reload_short",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_plr_ar_falima_reload_start.ogg", t = 0.033},
            {s = "ArcCW_Kraken.Overheat", t = 0.67},
            {s = path .. "wfoly_plr_ar_falima_reload_magout_01.ogg", t = 0.65},
            {s = path .. "wfoly_plr_ar_falima_reload_arm.ogg", t = 0.75},
            {s = path .. "wfoly_plr_ar_falima_reload_elbow.ogg", t = 1.45},
			{s = path .. "wfoly_plr_ar_falima_reload_magin_v2_01.ogg", t = 1.5},
			{s = path .. "wfoly_plr_ar_falima_reload_magin_v2_02.ogg", t = 1.75},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 1.6},
			{s = path .. "wfoly_plr_ar_falima_reload_end.ogg", t = 2.06},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_plr_ar_falima_reload_empty_start.ogg", t = 0},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_rotate.ogg", t = 0.46},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_magout_01.ogg", t = 0.73},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_shake.ogg", t = 0.93},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_arm.ogg", t = 1.63},
			{s = path .. "wfoly_plr_ar_falima_reload_empty_magin_v2_01.ogg", t = 1.83},
			{s = path .. "wfoly_plr_ar_falima_reload_empty_magin_v2_02.ogg", t = 2.1},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_elbow.ogg", t = 2.2},
			{s = path .. "wfoly_plr_ar_falima_reload_empty_boltopen_01.ogg", t = 2.66},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_boltclose_01.ogg", t = 2.96},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_end.ogg", t = 3},
        },
    },
    ["ready"] = {
        Source = "draw_short",
        LHIK = true,
		MinProgress = 0.5,
        SoundTable = {
            {s = path .. "wfoly_plr_ar_falima_raise_start.ogg", t = 0/30},
			{s = path .. "wfoly_plr_ar_falima_raise_settle.ogg", t = 0/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
        LHIK = true,
		MinProgress = 0.5,
        SoundTable = {
            {s = path .. "wfoly_plr_ar_falima_raise_start.ogg", t = 0/30},
			{s = path .. "wfoly_plr_ar_falima_raise_settle.ogg", t = 0/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_plr_ar_falima_drop_down.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 1.25,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 1.25,
    },
    ["exit_inspect"] = {
        Source = "lookat01",
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_ar_falima_inspect_01.ogg", t = 0},
			{s = path .. "wfoly_ar_falima_inspect_02.ogg", t = 1.3},
			{s = path .. "wfoly_ar_falima_inspect_03.ogg", t = 2.36},
			{s = path .. "wfoly_ar_falima_inspect_04.ogg", t = 3.6},
			{s = path .. "wfoly_ar_falima_inspect_05.ogg", t = 4.1},
        },
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"},
    },
    ["changefiremode"] = {
        Source = "semi_on",
        SoundTable = {
            {s = path .. "weap_ar_falima_selector_off.ogg", t = 0/30},
        },
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}

--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_bowcaster_ext.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Bowcaster Extended"
SWEP.Trivia_Class = "Blaster Crossbow"
SWEP.Trivia_Desc = "A bowcaster, also known as a laser crossbow, was a type of traditional, handcrafted projectile weapon commonly used by Wookiees."
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/bowcaster_ext.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "01100000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_bowcaster.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 65
SWEP.DamageMin = 20
SWEP.RangeMin = 0
SWEP.Range = 320
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_green"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 15

SWEP.Recoil = 0.7
SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0.6

SWEP.Delay = 60 / 400
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_BOWCASTEREXT"
SWEP.ShootSound = "ArcCW_Kraken.SW_BOWCASTEREXT"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.905, 0, 0.4),
    Ang = Vector(2, 0, -0.487),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 16, -2),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.14, -3, 1.8),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.4, 10.15, 0.6),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.1, 16.2, 1.5),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.84, -3.1, -0.72),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.9, -3.2, 0.4),
            vang = Angle(0, -90, 0),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15a.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15a_grenadier.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15s_train.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-17"
SWEP.Trivia_Class = "Hand Blaster"
SWEP.Trivia_Desc = "The DC-17 repeater hand blaster, also known more simply as the DC-17 hand blaster or DC-17 blaster pistol, was a model of heavy blaster pistol and the Grand Army of the Republic's standard-issue sidearm. Produced by BlasTech Industries, the DC-17 was usually given to weapon teams, the crews of vehicles, and officers. The weapon was one of the most reliable and toughest models of blaster pistols created, as well as having remarkable stopping power in its small design. The weapon was also well balanced, possessed a respectable rate of fire, and lightweight."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc17.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc17.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-16, 5, -3.4),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 2
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 22
SWEP.DamageMin = 19
SWEP.RangeMin = 0
SWEP.Range = 180
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 35

SWEP.Recoil = 0.9
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.55

SWEP.Delay = 60 / 250
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC17"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC17"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.79, -6.251, 0.55),
    Ang = Vector(0, 0, 0),
     Magnification = 1.1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(0, -6, -9)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.CustomizePos = Vector(10, -5, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(0, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.AttachmentElements = {
    ["akimbo"] = {
        Override_ActivePos = Vector(2, -2, 0),
        Override_CrouchPos = Vector(0, -3, 0),	
        Override_CrouchAng = Angle(0, 0, 0),
        Override_HolsterPos = Vector(2,2,2),
        Override_HolsterAng = Angle(-20, 0, -5),		
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Hook_SelectReloadAnimation = function(wep, anim)
    if wep.Attachments[4].Installed then
        return anim .. "_akimbo"
    end

    return anim
end

SWEP.Attachments = {
    {
        PrintName = "Optic",
        Slot = "optic",
        Bone = "frame",
        InstalledEles = {"scope_attach"},
        DefaultAttName = "DC-17 Holosight",
        Offset = {
            vpos = Vector(-2, 4.2, 0.13),
            vang = Angle(180,0,90),
        },
        VMScale = Vector(1.25, 1.25, 1.25),
    },
    {
        PrintName = "Tactical",
        Slot = {"tactical", "tac_pistol", "tac"},
        Bone = "frame",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-6, 1, 0.15),
            vang = Angle(180,0,90),
        },
        ExtraSightDist = 9,
        CorrectivePos = Vector(1, 0, -1),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "frame",
        Offset = {
            vpos = Vector(-7.88, 2.35, 0.11),
            vang = Angle(180,0,90),
        },
    },
    {
        PrintName = "Left Hand",
        Slot = {"mifl_fas2_akimbo", "akimbotest"},
        Bone = "Akimbo_Base",
        DefaultAttName = "None",
        Offset = {
            vpos = Vector(6, -2.8, 0.2),
            vang = Angle(0, 0, 0),
        },
        InstalledEles = {"akimbo"},
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_pistol"},
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "frame",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.3, -1, -0.45),
            vang = Angle(180,0,90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "frame",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-5.5, 1.7, -0.75),
            vang = Angle(180,0,90),
        },
    },     
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["draw"] = {
        Source = "draw",
    },
    ["holster"] = {
        Source = "holster",
    },
    ["ready"] = {
        Source = "draw",
    },
    ["fire"] = {
        Source = "fire1",
        ShellEjectAt = false,
    },
    ["fire_iron"] = {
        Source = "fire_scoped2",
        ShellEjectAt = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKOut = 0.8,
        LHIKEaseOut = 0.5,
        SoundTable = {
            {s = "arccw/kraken/republic/dc17/handling/magout.wav", t = 5 / 30},
            {s = "arccw/kraken/republic/dc17/handling/magin_partial.wav", t = 30 / 30},
            {s = "arccw/kraken/republic/dc17/handling/magin.wav", t = 40 / 30},
        },
    },
--------------------------------------------------------
    ["reload_akimbo"] = {
        Source = "reload_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },
    ["reload_empty_akimbo"] = {
        Source = "reload_empty_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },
    ["reload_nomen_akimbo"] = {
        Source = "reload_nomen_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },
    ["reload_nomen_empty_akimbo"] = {
        Source = "reload_empty_nomen_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },

    ["fix"] = {
        Source = "overheat", 
        Mult = 1.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 75 / 30},
            {s = "ArcCW_Kraken.Grab", t = 78 / 30},
        },
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17_akimbo.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17ext_akimbo.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Dual DC-17 Extended"
SWEP.Trivia_Class = "Hand Blaster"
SWEP.Trivia_Desc = "The DC-17 repeater hand blaster, also known more simply as the DC-17 hand blaster or DC-17 blaster pistol, was a model of heavy blaster pistol and the Grand Army of the Republic's standard-issue sidearm. Produced by BlasTech Industries, the DC-17 was usually given to weapon teams, the crews of vehicles, and officers. The weapon was one of the most reliable and toughest models of blaster pistols created, as well as having remarkable stopping power in its small design. The weapon was also well balanced, possessed a respectable rate of fire, and lightweight."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc17_ext_dual.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"

SWEP.MirrorVMWM = false
SWEP.NoHideLeftHandInCustomization = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc17ext_akimbo.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 65

SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 2
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = true

SWEP.InfiniteAmmo = true
SWEP.BottomlessClip = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 28
SWEP.DamageMin = 16
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 22

SWEP.Recoil = 1.13
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.67

SWEP.Delay = 60 / 190
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC17"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC17"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = nil
SWEP.MuzzleFlashColor = nil

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(0,0,0),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = "duel"
SWEP.HoltypeCustomize = "normal"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(0, -10, -10)
SWEP.SprintAng = Angle(25, 0, 0)

SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(0, -5.226, 1)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(0, -4, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"dc17"}
SWEP.AttachmentElements = {
    ["dc17"] = {
        WMElements = {
            {
                Model = "models/arccw/kraken/republic/v_dc17ext.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1,1,1),
                Offset = {
                    pos = Vector(-170, 50, -65),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/kraken/republic/v_dc17ext.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1,1,1),
                Offset = {
                    pos = Vector(-265, 275, -120),
                    ang = Angle(180, -180, 2)
                }
            },
        },   
    }
}
WMOverride = "models/arccw/kraken/republic/v_dc17.mdl"

SWEP.Attachments = {
    {
        PrintName = "Energization",
        DefaultAttName = "Standard",
        Slot = {"ammo"}
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_pistol"},
    },   
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    }, 
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "bash",
    },
    ["idle_iron"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = {"shoot_l", "shoot_r"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot_l", "shoot_r"},
        Mult = 2,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 25/30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["enter_inspect"] = {
        Source = "lookat01",
        Mult = 2,
    },
    ["idle_inspect"] = {
        Source = "lookat01",
        Mult = 2,
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17s.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-17s"
SWEP.Trivia_Class = "Hand Blaster"
SWEP.Trivia_Desc = "The DC-17 repeater hand blaster, also known more simply as the DC-17 hand blaster or DC-17 blaster pistol, was a model of heavy blaster pistol and the Grand Army of the Republic's standard-issue sidearm. Produced by BlasTech Industries, the DC-17 was usually given to weapon teams, the crews of vehicles, and officers. The weapon was one of the most reliable and toughest models of blaster pistols created, as well as having remarkable stopping power in its small design. The weapon was also well balanced, possessed a respectable rate of fire, and lightweight."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc17s.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc17s.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-16, 4.8, -2.9),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 2
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 28
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30

SWEP.Recoil = 0.55
SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0.1
SWEP.RecoilPunch = 2.5
SWEP.RecoilVMShake = 0.1

SWEP.Delay = 60 / 285
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC17"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC17"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.79, -8, 0.13),
    Ang = Vector(0, 0, 0),
     Magnification = 1.1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(0, -6, -9)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.CustomizePos = Vector(10, -5, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(0, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.AttachmentElements = {
    ["akimbo"] = {
        Override_ActivePos = Vector(2, -2, 0),
        Override_CrouchPos = Vector(0, -3, 0),	
        Override_CrouchAng = Angle(0, 0, 0),
        Override_HolsterPos = Vector(2,2,2),
        Override_HolsterAng = Angle(-20, 0, -5),		
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 7, bg = 1}},
    },
    ["dc17_powerpack"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["dc17s_module"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["dc17_cooling"] = {
        VMBodygroups = {{ind = 4, bg = 1}},
    },
}

SWEP.Hook_SelectReloadAnimation = function(wep, anim)
    if wep.Attachments[4].Installed then
        return anim .. "_akimbo"
    end

    return anim
end

SWEP.Attachments = {
    {
        PrintName = "Optic",
        Slot = "optic",
        Bone = "Slide",
        InstalledEles = {"scope_attach"},
        DefaultAttName = "DC-17 Holosight",
        Offset = {
            vpos = Vector(-2, 4.8, 0.13),
            vang = Angle(180,0,90),
        },
        VMScale = Vector(1.25, 1.25, 1.25),
    },
    {
        PrintName = "Tactical",
        Slot = {"tactical", "tac_pistol", "tac"},
        Bone = "frame",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(-6, 1.56, 0.15),
            vang = Angle(180,0,90),
        },
        ExtraSightDist = 9,
        CorrectivePos = Vector(1, 0, -1),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "frame",
        Offset = {
            vpos = Vector(-9.3, 2.8, 0.11),
            vang = Angle(180,0,90),
        },
    },
    {
        PrintName = "Left Hand",
        Slot = {"gso_extra_pistol_akimbo", "mifl_fas2_akimbo", "akimbotest"},
        Bone = "Akimbo_Base",
        DefaultAttName = "None",
        Offset = {
            vpos = Vector(6, -2.8, 0.2),
            vang = Angle(0, 0, 0),
        },
        InstalledEles = {"akimbo"},
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_pistol"},
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Module",
        DefaultAttName = "DC-17",
        Slot = {"dc17s_module"},
    },
    {
        PrintName = "Powerpack",
        DefaultAttName = "None",
        Slot = {"dc17_powerpack"},
    },
    {
        PrintName = "Cooling System",
        DefaultAttName = "Standard",
        Slot = {"dc17_cooling"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "frame",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Offset = {
            vpos = Vector(-7, 3.05, -0.5),
            vang = Angle(180,0,90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "frame",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(0.2, 2.18, -0.75),
            vang = Angle(180,0,90),
        },
    },     
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["draw"] = {
        Source = "draw",
    },
    ["holster"] = {
        Source = "holster",
    },
    ["ready"] = {
        Source = "draw",
    },
    ["fire"] = {
        Source = "fire1",
        ShellEjectAt = false,
    },
    ["fire_iron"] = {
        Source = "fire_scoped2",
        ShellEjectAt = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKOut = 0.8,
        LHIKEaseOut = 0.5,
        SoundTable = {
            {s = "arccw/kraken/republic/dc17/handling/magout.wav", t = 5 / 30},
            {s = "arccw/kraken/republic/dc17/handling/magin_partial.wav", t = 30 / 30},
            {s = "arccw/kraken/republic/dc17/handling/magin.wav", t = 40 / 30},
        },
    },
--------------------------------------------------------
    ["reload_akimbo"] = {
        Source = "reload_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },
    ["reload_empty_akimbo"] = {
        Source = "reload_empty_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },
    ["reload_nomen_akimbo"] = {
        Source = "reload_nomen_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },
    ["reload_nomen_empty_akimbo"] = {
        Source = "reload_empty_nomen_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },

    ["fix"] = {
        Source = "overheat", 
        Mult = 1.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 75 / 30},
            {s = "ArcCW_Kraken.Grab", t = 78 / 30},
        },
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17sa.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc19.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-19"
SWEP.Trivia_Class = "Blaster Silent Carbine"
SWEP.Trivia_Desc = "The DC-15A blaster carbine, also referred to as the DC-15S blaster, was a blaster carbine model used by the Grand Army of the Republic. It was part of the DC-15 family. While smaller than the larger DC-15A blaster rifle, both could be referred to as blaster rifles. It was one of the most common weapons issued to clone troopers during the Clone Wars and were used during many battles."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc19.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc15s.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-9, 3.5, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.2
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 44
SWEP.DamageMin = 28
SWEP.RangeMin = 0
SWEP.Range = 230
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = nil
SWEP.TracerCol = nil

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.65
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.55

SWEP.Delay = 60 / 250
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = nil
SWEP.MuzzleFlashColor = nil

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.816, -1.966, 1.894),
    Ang = Vector(0, 0, 1.513),
     Magnification = 1.1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 2, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4, -3, -1)
SWEP.SprintAng = Angle(0, 30, -15)

SWEP.CustomizePos = Vector(15, 0, 5)
SWEP.CustomizeAng = Angle(0, 40, 30)

SWEP.HolsterPos = Vector(4, -3, -1)
SWEP.HolsterAng = Angle(0, 30, -15)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["grip_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
    ["vibroknife"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
}
SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "DC-15 Holosight",
        Slot = "optic",
        Bone = "DC15",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(0.02, -1.1, 4.9),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.02, -0.442, 11.638),
            vang = Angle(90, 0, -90),

        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC15", 
        Offset = {
            vpos = Vector(-0.8, -0.5, 10.5),
            vang = Angle(90, 0, 180),
        },
    },  
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "DC15",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(-0.101, 0.15, 5),
            vang = Angle(90, 0, -90),
        },       
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_rifle"},
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.95, 0.05, -3.55),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(1, -0.2, -7),
            vang = Angle(90, 0, -90),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.1,
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "dc15a_reload1", t = 2 / 10},
            {s = "ArcCW_Kraken.Overheat", t = 5 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 37 / 30},
            {s = "ArcCW_Kraken.Grab", t = 37 / 30},
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 1.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_de18_akimbo.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DE-18 Akimbo"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "Blaster Pistol designed originally for military purposes, now modernized and being used by many Bounty Hunters, Civillians and even Mercenaries or Military Corporations in the galaxy."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/de18_akimbo.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_akimbo_de18.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.NoHideLeftHandInCustomization = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 12
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 72
SWEP.DamageMin = 39
SWEP.RangeMin = 0
SWEP.Range = 170
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(179, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_purple"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30

SWEP.Recoil = 2
SWEP.RecoilSide = 0.65
SWEP.RecoilRise = 0.85
SWEP.RecoilPunch = 1.5

SWEP.Delay = 60 / 160
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DE18"
SWEP.ShootSound = "ArcCW_Kraken.SW_DE18"
SWEP.DistantShootSound = "ArcCW_Kraken.LightCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = false
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(179, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(0, 0, 0),
    Ang = Angle(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = "duel"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -4, -17)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.ReloadPos = Vector(0, -5, -0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(10, 0, 0)

-- Attachments
SWEP.DefaultElements = {"de18dual"}
SWEP.AttachmentElements = {
    ["de18dual"] = {
        WMElements = {
            {
                Model = "models/arccw/kraken/galactic/v_de18.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-200, 70, -65),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/kraken/galactic/v_de18.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-300, 290, -110),
                    ang = Angle(180, -180, 2)
                }
            },
        },   
    }
}WMOverride = "models/arccw/kraken/galactic/v_de18.mdl"

SWEP.Attachments = {
    {
        PrintName = "Energization",
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    }, 
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "bash",
    },
    ["idle_iron"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = {"shoot_l", "shoot_r"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot_l", "shoot_r"},
        Mult = 2,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 20 / 30},
            {s = "ArcCW_Kraken.Grab", t = 35 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 20 / 30},
            {s = "ArcCW_Kraken.Grab", t = 35 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["enter_inspect"] = {
        Source = "lookat01",
        Mult = 2,
    },
    ["idle_inspect"] = {
        Source = "lookat01",
        Mult = 2,
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_defender_s.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dh17c.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dlt20x.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dlt74.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DLT-74"
SWEP.Trivia_Class = "Outer Rim Machine Gun"
SWEP.Trivia_Desc = "Old Weapon used by the Humans during the Old Republic wars. Now, it's a cheap and powerful option for Mercenaries or Military."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/dlt74.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.MirrorWorldModel = "models/arccw/kraken/galactic/mirror_dlt74.mdl"

SWEP.ViewModel = "models/arccw/kraken/galactic/v_dlt74.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-11, 5, -5),
    ang = Angle(-10, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 34
SWEP.DamageMin = 19
SWEP.RangeMin = 0
SWEP.Range = 450
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 100

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.65
SWEP.RecoilPunch = 0.5

SWEP.Delay = 60 / 680
SWEP.Num = 4
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 20
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 1.10
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DLT74"
SWEP.ShootSound = "ArcCW_Kraken.SW_DLT74"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(250, 0, 0)
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-4.183, -6.968, -0.735),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-1, 0, -2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 1.5)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, -1)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, 3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_weapon_right",
        Offset = {
            vpos = Vector(9, 0, 7.4),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "tag_weapon_right",
        Offset = {
            vpos = Vector(18, 0, 1.6),
            vang = Angle(0, 0, 0),
        },       
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_weapon_right",
        Offset = {
            vpos = Vector(27, 0, 1.4),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "tag_weapon_right",
        Offset = {
            vpos = Vector(2, -1.7, 3.4),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_weapon_right",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(10, -1.4, 3.65),
            vang = Angle(0, 0, 0),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/cr2/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = {"shoot", "shoot1"},
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
		MinProgress = 0.925,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_reload_up.ogg", t = 0.8},
            {s = "ArcCW_Kraken.Overheat", t = 0.84 },
            {s = path .. "wfoly_sm_secho_reload_magout.ogg", t = 1.5},
			{s = path .. "wfoly_sm_secho_reload_maghit.ogg", t = 1.2},
			{s = path .. "wfoly_sm_secho_reload_magin.ogg", t = 1.9},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 2},
			{s = path .. "wfoly_sm_secho_reload_end.ogg", t = 2.1},
        },
    },
    ["ready"] = {
        Source = "first_draw",
        LHIK = true,
		MinProgress = 0.85,
		FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_raise_first_up.ogg", t = 0.0},
            {s = path .. "wfoly_sm_secho_raise_first_charge.ogg", t = 0.5},
            {s = path .. "wfoly_sm_secho_raise_first_end.ogg", t = 0.667},
        },
    },
    ["draw"] = {
        Source = "draw",
		MinProgress = 0.5,
        LHIK = true,
		FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_raise.ogg", t = 0/30},
        },
    },
    ["holster"] = {
        Source = "holdster",
        SoundTable = {
            {s = path .. "wfoly_sm_secho_reload_end.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = {"bash"},
        LHIK = true,
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_ee3r.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_ee3s.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_el16hfe.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_f11.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_glie44.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_launcher_hh12.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Slot = 3

SWEP.Category = "[ArcCW] Kraken's Explosives - Rocket Launchers"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Republic HH-12"
SWEP.Trivia_Class = "Rocket Launcher"
SWEP.Trivia_Desc = "The HH-12 rocket launcher was a model of black-colored missile launcher used by the Special Forces of the Alliance to Restore the Republic during the Galactic Civil War against the Galactic Empire."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Rocket"
SWEP.Trivia_Country = "Galactic Republic, Galactic Empire, Rebel Alliance"
SWEP.IconOverride = "entities/kraken/explosives/hh12.png"

-- Base
SWEP.DefaultBodygroups = "0000000000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_hh12_republic.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-1, 1.3, -2.2),
    ang = Angle(0, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1.5
}

-- Damage & Tracer
SWEP.ShootEntity = "rocket_hh12"

SWEP.MuzzleVelocity = 12000

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.Recoil = 4.5
SWEP.RecoilSide = 0.550
SWEP.RecoilRise = 0.5
SWEP.RecoilPunch = 2.5
SWEP.RecoilVMShake = 1.5
SWEP.VisualRecoilMult = 0.7

SWEP.Delay = 60 / 60
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 500

-- Speed Mult
SWEP.SpeedMult = 0.825
SWEP.SightedSpeedMult = 0.85
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "RPG_Round"
SWEP.ShootVol = 120
SWEP.ShootPitch = 95
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/launchers/rps/weap_rpapa7_fire_plr_01.ogg"
SWEP.ShootSound = "kraken/launchers/rps/weap_rpapa7_fire_plr_01.ogg"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "muzzleflash_m79"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 146, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-1.04, -5, 0.31),
    Ang = Vector(16, 0, -4),
     Magnification = 4,
     SwitchToSound = "kraken/launchers/rps/wfoly_la_rpapa7_ads_up.ogg",
     SwitchFromSound = "kraken/launchers/rps/wfoly_la_rpapa7_ads_down.ogg",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "rpg"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(8, 1, 0)

SWEP.SprintPos = Vector(1, 0, -2.5)
SWEP.SprintAng = Angle(0, -2, 0)

SWEP.CrouchPos = Vector(-1, -0.5, -1)
SWEP.CrouchAng = Angle(0, 0, -5)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.Attachments = {
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_launcher_offset",
        Offset = {
            vpos = Vector(9, -1.8, 0.95),
            vang = Angle(0, 0, 90),
        },
    }, 
    {
        PrintName = "Ammunition",
        DefaultAttName = "Rocket",
        Slot = {"k_rocket_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "tag_launcher_offset",
        Offset = {
            vpos = Vector(2, -1.45, 2),
            vang = Angle(0, 0, 25),
        },
    },
}

-- Animations!
local path = "kraken/launchers/hh12/"

SWEP.Animations = {
	["enter_sights"] = {
		Source = "idle",

	},
    ["fire"] = {
        Source = "shoot1",
    },
    ["dryfire"] = {
        Source = "firemode",
		MinProgress = 0.01,
		FireASAP = true,
    },
    ["reload"] = {
        Source = "reload",
		MinProgress = 0.95,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
			{s = path .. "wfoly_la_kgolf_reload_raise.ogg", t = 0/30},
			{s = path .. "wfoly_la_kgolf_reload_raise.ogg", t = 15/30},
			{s = path .. "wfoly_la_kgolf_reload_rotate.ogg", t = 45/30},
			{s = path .. "wfoly_la_kgolf_reload_breechopen.ogg", t = 52/30},
			{s = path .. "wfoly_la_kgolf_reload_shellout.ogg", t = 65/30},
			{s = path .. "wfoly_la_kgolf_reload_shelldrop.ogg", t = 77/30},
			{s = path .. "wfoly_la_kgolf_reload_raise.ogg", t = 102/30},
			{s = path .. "wfoly_la_kgolf_reload_shellin.ogg", t = 132/30},
			{s = path .. "wfoly_la_kgolf_reload_breechclose.ogg", t = 147/30},
			{s = path .. "wfoly_la_kgolf_reload_breechclose2.ogg", t = 152/30},
			{s = path .. "wfoly_la_kgolf_reload_end.ogg", t = 157/30},
        },
    },
    ["ready"] = {
        Source = {"draw"},
        SoundTable = {
            {s = path .. "wfoly_plr_la_kgolf_raise_first_up.ogg", t = 3/30},
			{s = path .. "wfoly_plr_la_kgolf_raise_first_settle.ogg", t = 20/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
		MinProgress = 0.4,
        SoundTable = {
            {s = path .. "wfoly_plr_la_kgolf_raise_up.ogg", t = 7/30},
			{s = path .. "wfoly_plr_la_kgolf_raise_settle.ogg", t = 24/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_la_kgolf_drop_rattle.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["inspect"] = {
        Source = "lookat01",
        SoundTable = {
            {s = path .. "wfoly_la_kgolf_inspect_01.ogg", t = 1/30},
			{s = path .. "wfoly_la_kgolf_inspect_02.ogg", t = 88/30},
			{s = path .. "wfoly_la_kgolf_inspect_03.ogg", t = 135/30},
			{s = path .. "wfoly_la_kgolf_reload_raise.ogg", t = 3.25},
			{s = path .. "wfoly_la_kgolf_reload_breechopen.ogg", t = 4.21},
			{s = path .. "wfoly_la_kgolf_reload_breechclose2.ogg", t = 6.17},
			{s = path .. "wfoly_la_kgolf_reload_end.ogg", t = 6.62},
        },
    },
    ["bash"] = {
        Source = "melee_01",
    },
}


--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_launcher_hh12_empire.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_launcher_plx1_empire.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_m45.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_m45c.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_impact.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_smoke.lua:
AddCSLuaFile()

SWEP.Base = "arccw_k_nade_base"
SWEP.Spawnable = true

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Explosives - Grenades"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Smoke Grenade"
SWEP.Trivia_Class = "Hand Grenade, Smoke"
SWEP.Trivia_Desc = "A smoke grenade is a canister-type grenade used as a signaling device, target or landing zone marking device, or as a screening device for unit movements.."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Smoke"
SWEP.Trivia_Mechanism = "Non-Lethal Smoke"
SWEP.Trivia_Country = "Universal"
SWEP.IconOverride = "entities/kraken/explosives/smoke.png"

-- Base
SWEP.DefaultBodygroups = "0000000000"
SWEP.MirrorVMWM = false
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_smoke.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.ShootEntity = "nade_k_thrown_smoke"

SWEP.MuzzleVelocity = 800
SWEP.MuzzleVelocityAlt = 700

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.FuseTime = 3.5
SWEP.PullPinTime = 0.5

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
}



-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "grenade"
SWEP.HoldtypeSights = "grenade"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0,0,-5)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.DefaultElements = {"grenade"}
SWEP.AttachmentElements = {
    ["grenade"] = {
            WMElements = {
            {
                Model = "models/arccw/kraken/sw/explosives/v_smoke.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1,1,1),
                ModelBodygroups = "0000000000000000000",
                Offset = {
                    pos = Vector(-140,100,-20),
                    ang = Angle(0, 0, 180),
                },
            },
        },
    },
}WMOverride = "models/arccw/kraken/sw/explosives/v_smoke.mdl"

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_primed"] = {
        Source = "idle_primed"
    },
    ["ready"] = {
        Source = "draw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Holster", t = 0.1/30},
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        MinProgress = 0,
		Mult = 1.4,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.PreThrow", t = 0.1/30},
        },
        FireASAP = true,
    },
    ["throw"] = {
        Source = "throw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.1
    },
    ["throw_alt"] = {
        Source = "underhand",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.1
    },
    ["bash"] = {
        Source = {"melee"}
    },
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_stun.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_s5c.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_s5e.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "S-5e"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The Security S-5 was a heavy blaster pistol produced by Theed Arms for the Royal Naboo Security Forces. This weapon was commonly used by members of the Security Officer Corps."
SWEP.Trivia_Manufacturer = "Theed Arms"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/s5e.png"

-- Base
SWEP.DefaultBodygroups = "011000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_s5.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 7
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 55
SWEP.DamageMin = 38
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_green"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 15

SWEP.Recoil = 1.5
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 0.9

SWEP.Delay = 60 / 280
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_S5"
SWEP.ShootSound = "ArcCW_Kraken.SW_S5"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.045, -11.296, 1.3),
    Ang = Angle(0.5,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {}
SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.01, -1.95, -3),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0, -1.4, 10.3),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.36, -1.35, 8),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.8, -1.45, -6.8),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.45, -1.4, -4),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_x8.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "X-8 Night Sniper"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The X-8 Night Sniper was a model of blaster pistol manufactured by BlasTech Industries that featured a computerized scope and silent mode operation. X-8 Night Snipers were used by both the Galactic Empire and the Alliance to Restore the Republic during the Galactic Civil War."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/x8.png"

-- Base
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_x8.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 4
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 67
SWEP.DamageMin = 44
SWEP.RangeMin = 0
SWEP.Range = 330
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 8

SWEP.Recoil = 1
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 0.9

SWEP.Delay = 60 / 180
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_X8"
SWEP.ShootSound = "ArcCW_Kraken.SW_X8"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.045, -11.296, 1.15),
    Ang = Angle(0.5,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.03, -2.06, -2),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA",
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(0, -1.4, 2.9),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Offset = {
            vpos = Vector(-0.36, -1.35, 1),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.65, -1.3, -4.9),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.43, -1.3, 0),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_z4.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 

SWEP.Category = "[ArcCW] Kraken's Confederacy Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Z-4"
SWEP.Trivia_Class = "Blaster, Rotatory Cannon"
SWEP.Trivia_Desc = "The Z-4 rotary blaster cannon was a blaster cannon used by the Galactic Republic during the Clone Wars. Later, during the reign of the Galactic Empire, these weapons were used by both the Imperial Army's Heavy Weapons Stormtroopers and Rebel Alliance's Heavy Soldiers during the Galactic Civil War."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Confederacy of Independent Systems"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/z4.png"

-- Base
SWEP.MirrorVMWM = false
SWEP.UseHands = true
SWEP.NoHideLeftHandInCustomization = false
SWEP.ViewModel = "models/arccw/kraken/cis/v_z4.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 65

SWEP.HideViewmodel = false

SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Special properties
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 110
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5

SWEP.TriggerDelay = true 

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 32
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 320
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 1200

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 200
SWEP.ExtendedClipSize = 250
SWEP.ReducedClipSize = 100

SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.3
SWEP.Recoil = 0.5

SWEP.Delay = 60 / 220
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 5.5
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 200
SWEP.JumpDispersion = 1000

-- Speed Mult
SWEP.SpeedMult = 0.875
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.8

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_Z6"
SWEP.ShootSound = "ArcCW_Kraken.SW_Z6"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "arccw/kraken/empire/silenced.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.9, -6.961, 2.45),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(1, 0, -1)
SWEP.SprintAng = Angle(0, 0, 15)

SWEP.CrouchPos = Vector(-0.5, -0, -1)
SWEP.CrouchAng = Angle(0, 0, -5)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(3, 0, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

-- Attachments
SWEP.DefaultElements = {"z6"}
SWEP.AttachmentElements = {
    ["z6"] = {
        WMElements = {
            {
                Model = "models/arccw/kraken/republic/v_z6.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                WBodygroups = {{ind = 0, bg = 0}},
                Offset = {
                    pos = Vector(250, 0, 600),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(450, 0, -100),
                    ang = Angle(-15, 0, 100)
                },
                IsMuzzleDevice = true
            },
        },
    },
}
WMOverride = "models/arccw/kraken/republic/v_z6.mdl"

SWEP.Attachments = {
    {
        PrintName = "Energization",
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode"},
    },   
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
}

local path = "arccw/kraken/republic/z6rotaryblaster/handling/"


SWEP.TriggerDelay = true

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
        SoundTable = {
            {s = path .. "arccw/kraken/republic/z6rotaryblaster/sw02_blasters_z6rotaryblaster_gunner_loop_01.wav", v = 0.2, t = 0.01},
			{s = path .. "arccw/kraken/republic/z6rotaryblaster/sw02_blasters_z6rotaryblaster_start_short_var_01_04.wavqqqqqq", v = 0.3, t = 4/30},
        },
    },
    ["trigger"] = {
        Source = "windup",
        SoundTable = {
            {
                s = "arccw/kraken/republic/z6rotaryblaster/sw02_blasters_z6rotaryblaster_start_short_var_01_04.wav",
                p = 100,
                v = 100,
                t = 0.01,
                c = CHAN_ITEM,
            },
        }
    },
    ["untrigger"] = {
        Source = "windup",
        SoundTable = {
            {
                s = "arccw/kraken/republic/z6rotaryblaster/sw02_blasters_z6rotaryblaster_gunner_stop_01.wav",
                p = 100,
                v = 100,
                t = 0.05,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "jam_fix",
		MinProgress = 0.8,
        Mult = 2,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
			{s = "ArcCW_Kraken.Overheat", t = 0.01},
			{s = "ArcCW_Kraken.OverheatReplenished", t = 1.5},
        },
    },
    ["draw"] = {
        Source = "draw",
		MinProgress = 0.7,
		FireASAP = true,
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
		Mult = 3,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
		Mult = 3,
    },
    ["exit_inspect"] = {
        Source = "lookat01",
		MinProgress = 0.9,
		FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_lm_dblmg_inspect_01.ogg", t = 18/30},
			{s = path .. "wfoly_lm_dblmg_inspect_02.ogg", t = 56/30},
			{s = path .. "wfoly_lm_dblmg_inspect_03.ogg", t = 109/30},
        },
    },
    ["bash"] = {
        Source = "melee",
    },
}

-- Special properties
SWEP.Hook_ModifyRPM = function(wep, delay)
    return delay / Lerp(wep:GetBurstCount() / 15, 1, 3)
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_kraken_heavyproj_base.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = false -- this obviously has to be set to true

// names and stuff
SWEP.PrintName = "Masita ArcCW Weapon Base"
SWEP.Category = "[MASITA] ArcCW Weapon Base"

SWEP.Description = ""

SWEP.ViewModel = ""
SWEP.WorldModel = ""

SWEP.ViewModelFOV = 56
SWEP.MirrorVMWM = nil --Copy the viewmodel, along with all its attachments, to the worldmodel. Super convenient!
SWEP.MirrorWorldModel = nil -- Use this to set the mirrored viewmodel to a different model, without any floating speedloaders or cartridges you may have. Needs MirrorVMWM

--[[SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}]]

SWEP.PresetBase = nil -- make this weapon share saves with this one.

SWEP.KillIconAlias = nil -- set to other weapon class to share select and kill icons

SWEP.DefaultBodygroups = "00000000"
SWEP.DefaultWMBodygroups = "00000000"
SWEP.DefaultSkin = 0
SWEP.DefaultWMSkin = 0

SWEP.WorldModelOffset = nil
-- {
--     pos = Vector(0, 0, 0),
--     ang = Angle(0, 0, 0)
-- }

SWEP.NoHideLeftHandInCustomization = false

SWEP.Damage = 26
SWEP.DamageMin = 10 -- damage done at maximum range
SWEP.DamageRand = 0 -- damage will vary randomly each shot by this fraction
SWEP.RangeMin = 0 -- how far bullets will retain their maximum damage for
SWEP.Range = 200 -- in METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false -- set to true to have the base not do anything with damage types
-- this includes: igniting if type has DMG_BURN; adding DMG_AIRBOAT when hitting helicopter; adding DMG_BULLET to DMG_BUCKSHOT

SWEP.ShootEntity = nil -- entity to fire, if any
SWEP.MuzzleVelocity = 400 -- projectile muzzle velocity in m/s
SWEP.PhysBulletMuzzleVelocity = nil -- override phys bullet muzzle velocity
SWEP.PhysBulletDrag = 1
SWEP.PhysBulletGravity = 1
SWEP.PhysBulletDontInheritPlayerVelocity = true

SWEP.BodyDamageMults = nil
-- if a limb is not set the damage multiplier will default to 1
-- that means gmod's stupid default limb mults will **NOT** apply
-- {
--     [HITGROUP_HEAD] = 1.25,
--     [HITGROUP_CHEST] = 1,
--     [HITGROUP_LEFTARM] = 0.9,
--     [HITGROUP_RIGHTARM] = 0.9,
-- }

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 0 -- color for phys tracer.
-- there are 8 options:
-- 0 = normal
-- 1 = red
-- 2 = green
-- 3 = blue
-- 4 = yellow
-- 5 = violet
-- 6 = cyan
-- 7 = black/invisible
SWEP.HullSize = 1.5 -- HullSize used by FireBullets

SWEP.ImpactEffect = "StunstickImpact"
function SWEP:DoImpactEffect(tr, dmgtype)
    if tr.HitSky then return true end

    util.Decal("FadingScorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal);
    if( game.SinglePlayer() or SERVER or not self:IsCarriedByLocalPlayer() or IsFirstTimePredicted() ) then
        local soundToPlay = "warhammer/impacts/fx_laser_impact_01.wav"
        local randomSound = math.random(1,14)
        if randomSound == 1 then
            soundToPlay = "warhammer/impacts/fx_laser_impact_02.wav"
        elseif randomSound == 2 then
            soundToPlay = "warhammer/impacts/fx_laser_impact_03.wav"
        elseif randomSound == 3 then
            soundToPlay = "warhammer/impacts/fx_laser_impact_04.wav"
        end

    
        local effect = EffectData()
        effect:SetOrigin(tr.HitPos)
        effect:SetNormal(tr.HitNormal)

        sound.Play( soundToPlay, tr.HitPos, 75, 100, 1 );

        local effect = EffectData()
        effect:SetOrigin(tr.HitPos)
        effect:SetStart(tr.StartPos)
        effect:SetDamageType(dmgtype)

        util.Effect("StunstickImpact", effect)
    end

    return true;
end

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 25 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 50
SWEP.ReducedClipSize = 10

-- But if you insist...
SWEP.ForceDefaultClip = nil
SWEP.ForceDefaultAmmo = nil

-- The amount of rounds to load in the chamber when the gun is non-empty or empty
-- Defaults to ChamberSize and 0. Don't change unless you have a good reason
SWEP.ChamberLoadNonEmpty = nil
SWEP.ChamberLoadEmpty = nil

SWEP.AmmoPerShot = 1
SWEP.InfiniteAmmo = false -- weapon can reload for free
SWEP.BottomlessClip = false -- weapon never has to reload

SWEP.DoNotEquipmentAmmo = false -- do not automatically give this weapon unique ammo when arccw_equipmentammo is used

SWEP.ShotgunReload = false -- reloads like shotgun instead of magazines
SWEP.HybridReload = false -- reload normally when empty, reload like shotgun when part full

SWEP.ManualAction = false -- pump/bolt action
SWEP.NoLastCycle = false -- do not cycle on last shot

SWEP.RevolverReload = false -- cases all eject on reload

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.CanFireUnderwater = false

SWEP.Disposable = false -- when all ammo is expended, the gun will remove itself when holstered

SWEP.AutoReload = false -- when weapon is drawn, the gun will reload itself.

SWEP.IsShotgun = false -- weapon receives shotgun ammo types

SWEP.TriggerDelay = false -- Set to true to play the "trigger" animation before firing. Delay time is dependent on animation time.

SWEP.Recoil = 2
SWEP.RecoilSide = 1
SWEP.RecoilRise = 1
SWEP.MaxRecoilBlowback = -1
SWEP.VisualRecoilMult = 1.25
SWEP.RecoilPunch = 1.5
SWEP.RecoilPunchBackMax = 1
SWEP.RecoilPunchBackMaxSights = nil -- may clip with scopes
SWEP.RecoilVMShake = 1 -- random viewmodel offset when shooty

SWEP.Sway = 0

SWEP.ShotgunSpreadDispersion = false -- dispersion will cause pattern to increase instead of shifting
SWEP.ShotgunSpreadPattern = nil
SWEP.ShotgunSpreadPatternOverrun = nil
-- {Angle(1, 1, 0), Angle(1, 0, 0) ..}
-- list of how far each pellet should veer
-- if only one pellet then it'll use the first index
-- if two then the first two
-- in case of overrun pellets will start looping, preferably with the second one, so use that for the loopables
-- precision will still be applied

SWEP.RecoilDirection = Angle(1, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1, 0)

SWEP.Delay = 60 / 750 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemode = 1 -- 0: safe, 1: semi, 2: auto, negative: burst
SWEP.Firemodes = {
    -- {
    --     Mode = 1,
    --     CustomBars = "---_!",
    -- }
}

--[[
	Custom bar setup
	Colored variants        Classic
	'a' Filled              '-' Filled
	'b' Outline             '_' Outline
	'd' CLR w Outline       '!' Red w Outline
	'#' Empty
]]
--     PrintName = "PUMP",
--     RunAwayBurst = false,
--     AutoBurst = false, -- hold fire to continue firing bursts
--     PostBurstDelay = 0,
--     ActivateElements = {}

SWEP.ShotRecoilTable = nil -- {[1] = 0.25, [2] = 2} etc.

SWEP.NotForNPCS = true
SWEP.NPCWeaponType = nil -- string or table, the NPC weapons for this gun to replace
-- if nil, this will be based on holdtype
SWEP.NPCWeight = 100 -- relative likeliness for an NPC to have this weapon
SWEP.TTTWeaponType = nil -- string or table, like NPCWeaponType but specifically for TTT weapons (takes precdence over NPCWeaponType)
SWEP.TTTWeight = 100 -- like NPCWeight but for TTT gamemode

SWEP.AccuracyMOA = 15 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 150 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 0 -- dispersion that remains even in sights
SWEP.JumpDispersion = 300 -- dispersion penalty when in the air

SWEP.Bipod_Integral = false -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 1 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 1 -- Bipod recoil for Integral bipods

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "pistol" -- what ammo type the gun uses
SWEP.MagID = "mpk1" -- the magazine pool this gun draws from

SWEP.ShootVol = 125 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = nil
SWEP.ShootSound = ""
SWEP.ShootSoundLooping = nil
SWEP.FirstShootSoundSilenced = nil
SWEP.ShootDrySound = nil -- Add an attachment hook for Hook_GetShootDrySound please!
SWEP.DistantShootSound = nil
SWEP.ShootSoundSilenced = "w/dc19.wav"
SWEP.ShootSoundSilencedLooping = nil
SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"
SWEP.EnterBipodSound = "weapons/arccw/bipod_down.wav"
SWEP.ExitBipodSound = "weapons/arccw/bipod_up.wav"
SWEP.SelectUBGLSound =  "weapons/arccw/ubgl_select.wav"
SWEP.ExitUBGLSound = "weapons/arccw/ubgl_exit.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects
SWEP.ImpactEffect = nil
SWEP.ImpactDecal = nil

SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellMaterial = nil
SWEP.ShellEffect = nil
SWEP.ShellEjectPosCorrection = nil
SWEP.ShellScale = 1
SWEP.ShellPhysScale = 1
SWEP.ShellPitch = 100
SWEP.ShellSounds = "autocheck"--ArcCW.ShellSoundsTable
SWEP.ShellRotate = 0
SWEP.ShellTime = 0.5

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on
SWEP.ProceduralViewBobAttachment = nil -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.CamAttachment = nil -- if set, this attachment will control camera movement
SWEP.MuzzleFlashColor = Color(0, 110, 255)

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1

SWEP.KeepBaseIrons = false -- do not override iron sights when scope installed
SWEP.BaseIronsFirst = false -- If a sight keeps base irons, irons comes first

SWEP.IronSightStruct = {
    Pos = Vector(-8.728, -13.702, 4.014),
    Ang = Angle(-1.397, -0.341, -2.602),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 15, -4),
        Ang = Angle(0, 0, -45),
    },
    Magnification = 1,
    BlackBox = false,
    ScopeTexture = nil,
    SwitchToSound = "", -- sound that plays when switching to this sight
    SwitchFromSound = "",
    ScrollFunc = ArcCW.SCROLL_NONE,
    CrosshairInSights = false,
}

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

-- Override free aim convar and variable
SWEP.FreeAimAngle = nil -- defaults to HipDispersion / 80. overwrite here
SWEP.NeverFreeAim = nil
SWEP.AlwaysFreeAim = nil

-- If Jamming is enabled, a heat meter will gradually build up until it reaches HeatCapacity.
-- Once that happens, the gun will overheat, playing an animation. If HeatLockout is true, it cannot be fired until heat is 0 again.
SWEP.Jamming = false
SWEP.HeatCapacity = 200 -- rounds that can be fired non-stop before the gun jams, playing the "fix" animation
SWEP.HeatDissipation = 2 -- rounds' worth of heat lost per second
SWEP.HeatLockout = false -- overheating means you cannot fire until heat has been fully depleted
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = false -- when the "fix" animation is played, all heat is restored.
SWEP.HeatOverflow = nil -- if true, heat is allowed to exceed capacity (this only applies when the default overheat handling is overridden)

-- If Malfunction is enabled, the gun has a random chance to be jammed
-- after the gun is jammed, it won't fire unless reload is pressed, which plays the "unjam" animation
-- if no "unjam", "fix", or "cycle" animations exist, the weapon will reload instead
SWEP.Malfunction = false
SWEP.MalfunctionJam = true -- After a malfunction happens, the gun will dryfire until reload is pressed. If unset, instead plays animation right after.
SWEP.MalfunctionTakeRound = true -- When malfunctioning, a bullet is consumed.
SWEP.MalfunctionWait = 0.5 -- The amount of time to wait before playing malfunction animation (or can reload)
SWEP.MalfunctionMean = nil -- The mean number of shots between malfunctions, will be autocalculated if nil
SWEP.MalfunctionVariance = 0.25 -- The fraction of mean for variance. e.g. 0.2 means 20% variance
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"
SWEP.HoldtypeCustomize = "slam"
SWEP.HoldtypeNPC = nil

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.GuaranteeLaser = false -- GUARANTEE that the laser position will be accurate, so don't bother with sighted correction

SWEP.ShieldProps = nil
-- {
--     {
--         Model = "",
--         Pos = Vector(0, 0, 0),
--         Ang = Angle(0, 0, 0),
--         Bone = "", -- leave blank for valvebiped right hand
--         Resistance = 5, -- one unit of this object counts for how much penetration amount
--     }
-- }

SWEP.CanBash = true
SWEP.PrimaryBash = false -- primary attack triggers melee attack

SWEP.MeleeDamage = 25
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)

SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.ReloadPos = nil
SWEP.ReloadAng = nil

SWEP.CrouchPos = nil
SWEP.CrouchAng = nil

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)

-- When using custom sprint animations, set this to the same as ActivePos and ActiveAng
SWEP.SprintPos = nil
SWEP.SprintAng = nil

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)

SWEP.CustomizePos = Vector(9.824, 0, -4.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.BarrelLength = 24

SWEP.SightPlusOffset = nil

SWEP.DefaultPoseParams = {} -- {["pose"] = 0.5}
SWEP.DefaultWMPoseParams = {}

SWEP.DefaultElements = {} -- {"ele1", "ele2"}

SWEP.AttachmentElements = {
    -- ["name"] = {
    --     RequireFlags = {}, -- same as attachments
    --     ExcludeFlags = {},
    --     NamePriority = 0, -- higher = more likely to be chosen
    --     NameChange = "",
    --     TrueNameChange = "",
    --     AddPrefix = "",
    --     AddSuffix = "",
    --     VMPoseParams = {}, -- {["pose"] = 0.5}
    --     VMColor = Color(),
    --     VMMaterial = "",
    --     VMBodygroups = {{ind = 1, bg = 1}},
    --     VMElements = {
    --         {
    --             Model = "",
    --             Bone = "",
    --             Offset = {
    --                 pos = Vector(),
    --                 ang = Angle(),
    --             },
    --             ModelSkin = 0,
    --             ModelBodygroups = "",
    --             Scale = Vector(1, 1, 1),
    --             IsMuzzleDevice = false -- this element is a muzzle device, and the muzzle flash should come from here.
    --         }
    --     },
    --     VMOverride = "", -- change the view model to something else. Please make sure it's compatible with the last one.
    --     VMBoneMods = {
    --         ["bone"] = Vector(0, 0, 0)
    --     },
    --     WMPoseParams = {}, -- {["pose"] = 0.5}
    --     WMColor = Color(),
    --     WMMaterial = "",
    --     WMBodygroups = {},
    --     WMElements = {
    --         {
    --             Model = "",
    --             Offset = {
    --                 pos = Vector(),
    --                 ang = Angle(),
    --             },
    --             IsMuzzleDevice = false -- this element is a muzzle device, and the muzzle flash should come from here.
    --         }
    --     },
    --     WMOverride = "", -- change the world model to something else. Please make sure it's compatible with the last one.
    --     WMBoneMods = {
    --         ["bone"] = Vector(0, 0, 0)
    --     },
    --     AttPosMods = {
    --         [1] = {
    --             bone = "", -- optional
    --             vpos = Vector(0, 0, 0),
    --             vang = Angle(0, 0, 0),
    --             wpos = Vector(0, 0, 0),
    --             wang = Angle(0, 0, 0),
    --             SlideAmount = { -- only if base att has slideable
    --                 vmin = Vector(0, 0, 0),
    --                 vmax = Vector(0, 0, 0),
    --                 wmin = Vector(0, 0, 0),
    --                 wmax = Vector(0, 0, 0)
    --             }
    --         }
    --     }
    -- }
}

SWEP.RejectAttachments = {
    -- ["optic_docter"] = true -- stop this attachment from being usable on this gun
}

SWEP.AttachmentOverrides = {
    -- ["optic_docter"] = {} -- allows you to overwrite atttbl values
}

SWEP.TTT_DoNotAttachOnBuy = false -- don't give all attachments when bought

SWEP.Attachments = {}
-- [1] = {
--     PrintName = "Optic", -- print name
--     DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
--     DefaultAttIcon = Material(),
--     Slot = "pic_sight", -- what kind of attachments can fit here
--     MergeSlots = {}, -- these other slots will be merged into this one.
--     Bone = "sight", -- relevant bone any attachments will be mostly referring to
--     WMBone = "ValveBiped.Bip01_L_Hand", -- set it to change parent bone of attachment WM
--     KeepBaseIrons = false,
--     ExtraSightDist = 0,
--     Offset = {
--         vpos = Vector(0, 0, 0), -- offset that the attachment will be relative to the bone
--         vang = Angle(0, 0, 0),
--         wpos = Vector(0, 0, 0), -- same, for the worldmodels
--         wang = Angle(0, 0, 0)
--     },
--     RejectAttachments = {}, -- specific blacklist of attachments this slot cannot accept. Needs to be like {"optic_mrs" = true}
--     VMScale = Vector(1, 1, 1),
--     WMScale = Vector(1, 1, 1),
--     SlideAmount = { -- how far this attachment can slide in both directions.
--         -- overrides Offset.
--         vmin = Vector(0, 0, 0),
--         vmax = Vector(0, 0, 0),
--         wmin = Vector(0, 0, 0),
--         wmax = Vector(0, 0, 0),
--     },
--     CorrectiveAng = Vector(1, 1, 1), -- okay, I know I said sights were pain-free.
--     CorrectivePos = Vector(0, 0, 0), -- that won't always be the case. Use these to fix it. Issues mainly crop up in case of sights parented to bones that are not a root bone.
--     InstalledEles = {"toprail"}, -- activate these AttachmentElements if something is installed
--     DefaultEles = {""} -- activeate these AttachmentElements *unless* something is installed
--     Hidden = false, -- attachment cannot be seen in customize menu
--     Integral = false, -- attachment is assumed never to change
--     RandomChance = 1, -- multiplies chance this slot will get a random attachment
--     DoNotRandomize = false,
--     NoWM = false, -- do not make this show up on worldmodel
--     NoVM = false, -- what do *you* think this one does?
--     FreeSlot = false, -- slot does not count towards attachment capacity
--     -- ABOUT THE FLAG SYSTEM:
--     -- Attachments and slots can give flags
--     -- All attachments automatically give themselves as a flag, e.g. "optic_mrs"
--     -- If requirements are not satisfied, the slot or attachment will not be attachable
--     ExcludeFlags = {}, -- if the weapon has this flag, hide this slot
--     RequireFlags = {}, -- if the weapon does not have all these flags, hide this slot
--     GivesFlags = {} -- give these slots if something is installed here
--     HideIfBlocked = false, -- If flag requirements are not met, do not show the attachment at all
-- }

-- ready: deploy first time
-- draw
-- holster
-- reload
-- fire
-- cycle (for bolt/pump actions)
-- bash
-- fix
-- enter_bipod
-- exit_bipod
-- enter_sight
-- exit_sight
-- a_to_b: switch from firemode a to firemode b. e.g.: 1_to_2
-- idle
-- idle_sights
-- idle_sprint
-- idle_bipod
-- enter_inspect
-- idle_inspect
-- exit_inspect
-- enter_ubgl
-- exit_ubgl
-- idle_ubgl

-- you can append suffixes for different states
-- append list:

-- _iron, _sights, or _sight     for sighted variation
-- _sprint                       for sprinting variation
-- _bipod                        for bipod variation
-- _empty                        for empty variation
-- _jammed                       for jammed variation

-- this does not apply to reload animations.

-- !! they MUST be in the order of this list.
-- example: fire_iron_bipod_empty

-- use SWEP/wep.Hook_TranslateAnimation, same as in attachment, to do even more behaviours
-- use SWEP/wep.Hook_SelectReloadAnimation to change the reload animation
-- use SWEP/wep.Hook_SelectInsertAnimation to change the shotgun reload insert animation
-- use SWEP/wep.Hook_SelectFireAnimation to change the fire animation
-- use SWEP/wep.Hook_SelectCycleAnimation to change the cycle/pump animation
-- use SWEP/wep.Hook_SelectBashAnimation to change the bash animation

-- which sequence to derive the sight autosolver from.
SWEP.AutosolveSourceSeq = "idle"

-- Disclaimer: LHIK is *actually* a type of forward kinematics.
-- If you prefer, LHIK can stand for "Left Hand Individual Kinematics" or some shit

SWEP.Animations = {
    -- ["idle"] = {
    --     Source = "idle",
    --     Time = 10
    -- },
    -- ["draw"] = {
    --     RestoreAmmo = 1, -- only used by shotgun empty insert reload
    --     Source = "deploy",
    --     RareSource = "", -- 1/RareSourceChance of playing this animation instead
    --     RareSourceChance = 100, -- Chance the rapper
    --     Time = 0.5, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    --     Mult = 1, -- Multiplies the rate of animation.
    --     TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, -- third person animation to play when this animation is played
    --     TPAnimStartTime = 0, -- when to start it from
    --     Checkpoints = {}, -- time checkpoints. If weapon is unequipped, the animation will continue to play from these checkpoints when reequipped.
    --     ShellEjectAt = 0, -- animation includes a shell eject at these times
    --     LHIKIn = 0.25, -- In/Out controls how long it takes to switch to regular animation.
    --     LHIKOut = 0.25, -- (not actually inverse kinematics)
    --     LHIKEaseIn = 0.1, -- how long LHIK eases in.
    --     LHIKEaseOut = 0.1, -- if no value is specified then ease = lhikin
    --     LHIKTimeline = { -- allows arbitrary LHIK values to be interpolated between
    --         {
    --             t = 0.1,
    --             lhik = 0,
    --         },
    --         {
    --             t = 0.25,
    --             lhik = 1
    --         }
    --     },
    --     LHIK = true, -- basically disable foregrips on this anim
    --     SoundTable = {
    --         {
    --             s = "", -- sound; can be string or table
    --             p = 100, -- pitch
    --             v = 75, -- volume
    --             t = 1, -- time at which to play relative to Animations.Time
    --             c = CHAN_ITEM, -- channel to play the sound

    --             -- Can also play an effect at the same time
    --             e = "", -- effect name
    --             att = nil, -- attachment, defaults to shell attachment
    --             mag = 100, -- magnitude
    --             -- also capable of modifying bodygroups
    --             ind = 0,
    --             bg = 0,
    --             -- and poseparams
    --             pp = "pose",
    --             ppv = 0.25,
    --         }
    --     },
    --     ViewPunchTable = {
    --         {
    --             p = Vector(0, 0, 0),
    --             t = 1
    --         }
    --     },
    --     ProcDraw = false, -- for draw/deploy animations, always procedurally draw in addition to playing animation
    --     ProcHolster = false, -- procedural holster weapon, THEN play animation
    --     LastClip1OutTime = 0, -- when should the belt visually replenish on a belt fed
    --     MinProgress = 0, -- how much time in seconds must pass before the animation can be cancelled
    --     ForceEmpty = false, -- Used by empty shotgun reloads that load rounds to force consider the weapon to still be empty.
    -- }
}

--[[
for k, v in ipairs(ents.FindByClass("sb*")) do
	if v.Droid then
		v:Give("arccw_ef_blaster_dc15s")
	end
end
]]

DEFINE_BASECLASS( SWEP.Base )
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_masita_base.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_dlt23v.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_dh16.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_galaar15.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "GALAAR-15"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The GALAAR-15 blaster rifle was a popular blaster carbine manufactured by the Mandalorian arms giant Concordian Crescent Technologies. It was named after the galaar, a common bird of prey that was native to the planet Mandalore. It was a sleek, short-barreled rifle constructed from high-quality materials and was covered in shock-resistant polycarbonate. And while relatively rare, the GALAAR-15 was a frequent item that appeared on the black market. Due to its high-quality design, the rifle became a popular weapon among bounty hunters and other professional killers. Its popularity allowed arms dealers to charge a premium for the GALAAR-15, with even used weapons going above their standard value.[1] Similar in appearance to the smaller WESTAR-35 blaster pistol, the GALAAR-15 featured a angular design that made it blocky and squarish. It was mainly light grey with additional darker grey pieces and was known to fire yellow, blue or red blaster bolts, seeming dependent on the political allegiance of the user."
SWEP.Trivia_Manufacturer = "Concordian Crescent Technologies"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/galaar15.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_galaar15.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-9, 5, -5.75),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 43
SWEP.DamageMin = 27
SWEP.RangeMin = 0
SWEP.Range = 450
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 37

SWEP.Recoil = 0.7
SWEP.RecoilSide = 0.45
SWEP.RecoilRise = 0.90
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 430
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 3,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/galaar.wav"
SWEP.ShootSound = "kraken/sops/galaar.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.744, -2.648, 2.368),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 3)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt34",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, -1, 25),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(-0.03, -2.8, 6),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        InstalledEles = {"muzzle_attach"},
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.4,1.4,1.4),
        WMScale = Vector(1.4,1.4,1.4),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.01, -1.55, 26.5),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-1.2, -1.3, 19.5),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(1.05, -1, 9),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(1.17, -1.25, 5.5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.3,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 110 / 30},
            {s = "ArcCW_Kraken.Grab", t = 115 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_r1ca.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_scatterpistol.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Scatter Pistol"
SWEP.Trivia_Class = "Blaster-Scatter Pistol"
SWEP.Trivia_Desc = "Heavy-Powered scatter pistol. Works like a small shotgun."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/scatterpistol.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_scatterpistol.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-14, 6.7, -7.65),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.NoRandSpread = true
SWEP.CanBash = true

SWEP.ShotgunSpreadPattern = {
    [1] = Angle(0, 0, 0),
    [2] = Angle(0, 1, 0),
    [3] = Angle(0, -1, 0),
    [4] = Angle(2.1, 0, 0),
    [5] = Angle(-2.1, 0, 0),
    [6] = Angle(1.4, 1.2, 0),
    [7] = Angle(-1.4, 1.2, 0),
    [8] = Angle(1.4, -1.2, 0),
    [9] = Angle(-1.4, -1.2, 0),
}

SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 5
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 9
SWEP.DamageMin = 7
SWEP.RangeMin = 0
SWEP.Range = 90
SWEP.Penetration = 8
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 15

SWEP.Recoil = 1.9
SWEP.RecoilSide = 1
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.9
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 120
SWEP.Num = 9
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 3,
    },
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/scatterpistol.wav"
SWEP.ShootSound = "kraken/sops/scatterpistol.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-6.132, 0, 2.684),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -5, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "a180",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0.25, 2, 5.5),
                   ang = Angle(90, 0, -90),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "a180",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.20, -2.6, 1),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "a180",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.9, -1., 4.3),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "a180",
        Offset = {
            vpos = Vector(1, -1.1, 0.7),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "a180",
        Offset = {
            vpos = Vector(1.4, -0.9, 4.7),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        Mult = 1.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_z5.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_republic_dc19.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Republic"
SWEP.Credits = "Kraken"
SWEP.PrintName = "DC-19"
SWEP.Trivia_Class = "Blaster Stealth Carbine"
SWEP.Trivia_Desc = "The DC-19 'Stealth' carbine was a blaster carbine in BlasTech Industries' DC-15 blaster line. The DC-19 was equipped with a sound suppressor unit for silent operations and an optional stealth function, which used a refined tibanna gas mixture that made the DC-19's plasma bolts invisible to the naked eye. However, the tibanna mixture was highly expensive, had to be reloaded after ten shots, and needed to be cooled down after each shot to prevent damage to the carbine's dampeners. The DC-19 was used almost exclusively by clone shadow troopers in the Grand Army of the Republic during the Clone Wars and for a short time afterward, when the clone shadow troopers became part of the Imperial Army."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Stealth Tibanna"
SWEP.IconOverride = "entities/kraken/sops/dc19.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_dc19.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-9, 5, -5.75),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 54
SWEP.DamageMin = 20
SWEP.RangeMin = 0
SWEP.Range = 700
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "emg_tracer"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 22

SWEP.Recoil = 0.6
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.5
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 280
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 3,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/dc19.wav"
SWEP.ShootSound = "kraken/sops/dc19.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.686, 0, 3.411),
    Ang = Vector(0, 0, 1.73),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 3)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 0)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt34",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, -1, 20),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(0.08, -2.2, 5),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.4,1.4,1.4),
        WMScale = Vector(1.4,1.4,1.4),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.08, -1.2, 20.8),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-1, -1.1, 15),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.88, 0.79, 5.8),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(1.14, -0.7, 0),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.3,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 110 / 30},
            {s = "ArcCW_Kraken.Grab", t = 115 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH lua/weapons/climb_swep2/cl_init.lua:
include("shared.lua")

CreateClientConVar("climbswep2_showhud", 1, true, false)
SWEP.PrintName       = "Climb SWEP 2"
SWEP.Slot             = 0
SWEP.SlotPos         = 4
SWEP.DrawAmmo         = false
SWEP.DrawCrosshair     = false

local flags = {FCVAR_REPLICATED, FCVAR_ARCHIVE};
CreateConVar("climbswep2_necksnaps", "0", flags);
CreateConVar("climbswep2_wallrun_minheight", "250", flags);
CreateConVar("climbswep2_roll_allweps", "0", flags);
CreateConVar("climbswep2_slide_allweps", "0", flags);
CreateConVar("climbswep2_maxjumps", "3", flags);
--PATH lua/weapons/climb_swep2/shared.lua:
SWEP.Author              = "Jonascone"
SWEP.Contact             = ""
SWEP.Purpose             = "A reiteration of the Climb SWEP."
SWEP.Instructions        = "Refer to the Workshop page!"

SWEP.Spawnable                  = true
SWEP.AdminSpawnable             = false

SWEP.ViewModel                  = "models/weapons/v_pistol.mdl"
SWEP.HoldType                   = "normal"

SWEP.Primary.ClipSize           = -1
SWEP.Primary.DefaultClip        = -1
SWEP.Primary.Automatic          = false
SWEP.Primary.Ammo               = "none"

SWEP.Secondary.ClipSize         = -1
SWEP.Secondary.DefaultClip      = -1
SWEP.Secondary.Automatic        = true
SWEP.Secondary.Ammo             = "none"


local HitPlayer = { Sound("npc/vort/foot_hit.wav"), Sound("npc/zombie/zombie_hit.wav") }
local MatList = { }
MatList[67] = "concrete"
MatList[68] = "dirt"
MatList[71] = "chainlink"
MatList[76] = "tile"
MatList[77] = "metal"
MatList[78] = "dirt"
MatList[84] = "tile"
MatList[86] = "duct"
MatList[87] = "wood"

function SWEP:DrawWorldModel() return false; end

function SWEP:Initialize()
    self:SetWeaponHoldType(self.HoldType)
    self.Weapon:DrawShadow(false)
	self.nextThink = 0
	self.Jumps = 0
    self.JumpSequence = 0
	self.EasterEgg = false
	self.Released = false
	self.MFC = "male"
	self.WallJumpTrace = nil
	self.CanWallRun = true
	self.WallRunAnim = 0
    return true
end
function SWEP:Deploy()
    self.Owner:DrawViewModel(false)
    if string.find(self.Owner:GetModel(), "female") or string.find(self.Owner:GetModel(), "alyx") or string.find(self.Owner:GetModel(), "mossman") then self.MFC = "female"
    elseif string.find(self.Owner:GetModel(), "combine") or string.find(self.Owner:GetModel(), "metro") then self.MFC = "combine"
    else self.MFC = "male" end

    self.Owner:SetNWBool("ClimbWallJump", false)
    self.Owner:SetNWBool("ClimbFalling", false)
    self.Owner:SetNWBool("ClimbWallRun", false)
    self.Released = false
    self.CanWallRun = true;		
    self.Parent = NULL;
end
function SWEP:Forget()

    if self.Grab then
        if self.Owner:GetMoveType() == MOVETYPE_NONE then self.Owner:SetMoveType(MOVETYPE_WALK) end
        self.Grab = false
        self.Parent = NULL;
    end
    return true

end
function SWEP:Think()

    if CLIENT or !IsValid(self.Owner) or !self.Owner:Alive() then return false end

    if self.Jumps != self.Owner:GetNWInt("ClimbJumps") then self.Owner:SetNWInt("ClimbJumps", self.Jumps) end
    if !self.Released and !self.Owner:KeyDown(IN_ATTACK2) then
        self.Released = true
    elseif self.Owner:OnGround() and (self.Jumps > 0 or !self.CanWallRun) or self.Owner:GetNWBool("ClimbFalling") then

        self.Jumps, self.JumpSequence = 0, 0
        self.EasterEgg = false
		self.CanWallRun = true
		self.Owner:SetNWBool("ClimbWallJump", false)
        self.Owner:SetNWBool("ClimbFalling", false)

	elseif self.Owner:GetNWBool("ClimbWallRun") and !self.Grab then
	
		local traceData = {};
		traceData.start = self.Owner:GetPos() + Vector(0, 0, 20);
		traceData.endpos = traceData.start + self.Owner:GetForward() * 70;
		traceData.filter = self.Owner;
		local trace = util.TraceLine(traceData);
		
		local vel = self.Owner:GetVelocity();
		if !self.Owner:OnGround() and trace.Hit and self.Owner:KeyDown(IN_FORWARD) and math.abs(vel:Length()) > 100 then
		
			local vel = self.Owner:GetVelocity() + self.Owner:GetForward();
			vel.z = 0;			
			if CurTime() > self.WallRunAnim then
			
				self.WallRunAnim = CurTime() + (0.2 - vel:Length() / 10000);
				self.Owner:ViewPunch(Angle(10, 0, 0));
				if trace.MatType == MAT_GLASS then self.Owner:EmitSound(Sound("physics/glass/glass_sheet_step"..math.random(1, 4)..".wav"), 75, math.random(95, 105))
				elseif trace.MatType and MatList[trace.MatType] then self.Owner:EmitSound(Sound("player/footsteps/"..MatList[trace.MatType]..math.random(1, 4)..".wav"), 75, math.random(95, 105)) end
				vel.z = -(100 + vel:Length());
				
			end
			self.Owner:SetLocalVelocity(vel);
			
		else 
			
			self.Owner:SetNWBool("ClimbWallRun", false); 
			self.CanWallRun = false;
			
		end
    elseif self.Owner:KeyDown(IN_FORWARD) then
		if self.Owner:KeyDown(IN_USE) and !self.Owner:OnGround() and self.CanWallRun and self.Jumps < GetConVarNumber("climbswep2_maxjumps") and !self.Grab then
	
			local traceData = {};
			traceData.start = self.Owner:GetPos();
			traceData.endpos = traceData.start - Vector(0, 0, GetConVarNumber("climbswep2_wallrun_minheight"));
			if !util.TraceLine(traceData).Hit then
			
				self.Owner:SetNWBool("ClimbWallRun", true);
				self.Jumps = self.Jumps + 1
				local vel = self.Owner:GetVelocity() + self.Owner:GetForward() * 100;
				vel.z = 0;
				self.Owner:SetLocalVelocity(vel);
			
			end
		end
	end

    if CurTime() < self.nextThink then return false end

    // For the lulz.
    if self.Owner:GetVelocity().z <= -900 and self.Owner:GetMoveType() == MOVETYPE_WALK then

        if !self.Owner:GetNWBool("ClimbFalling") then self.Owner:SetNWBool("ClimbFalling", true); self.Owner:SetNWBool("ClimbWallJump", false)
        elseif self.Owner:KeyDown(IN_JUMP) then

            self.nextThink = CurTime() + 2.5
            if self.MFC == "combine" then

                self.Owner:EmitSound("npc/metropolice/vo/help.wav", 125, math.random(90, 110))
                return true

            end
            self.Owner:EmitSound("vo/npc/"..self.MFC.."01/help01.wav", 125, math.random(90, 110))
            return true

        elseif !self.EasterEgg and math.random(1, 128) == 1 then

            self.EasterEgg = true
            if self.MFC == "combine" then self.Owner:EmitSound("npc/metropolice/vo/shit.wav", 100)
            else self.Owner:EmitSound("vo/npc/"..self.MFC.."01/gordead_ans19.wav", 100) end
            return true

        end

        return true

    elseif self.Owner:GetNWBool("ClimbFalling") then self.Owner:SetNWBool("ClimbFalling", false)
    end

    // Are we grabbing a ledge?
    if self.Grab then

        // Is it a prop?
		local physObj = NULL;
        if IsValid(self.Parent) then
			
			physObj = self.Parent:GetPhysicsObject();
            if physObj:IsMoveable() then 
				if math.abs(self.OldVelocity - self.Parent:GetVelocity():Length()) >= 500 then 
					return false;
				end
			end

        end
        if !self.Owner:KeyDown(IN_FORWARD) and !self.Owner:KeyDown(IN_MOVELEFT) and !self.Owner:KeyDown(IN_MOVERIGHT) then return false
        elseif self.Owner:KeyDown(IN_FORWARD) then

            if self.Owner:KeyDown(IN_JUMP) then

                self:Forget()
                self.Owner:EmitSound(Sound("npc/combine_soldier/gear"..math.random(1, 6)..".wav"), 75, math.random(95, 105))
                self.Owner:ViewPunch(Angle(-7.5, 0, 0))
                self.Owner:SetLocalVelocity(self.Owner:GetAimVector() * 400)
                return true

            end
            return true

        end

        local Predict
        local Shift = 0
        if self.Owner:KeyDown(IN_SPEED) then Shift = 0.15 end
        self.nextThink = CurTime() + (0.35 - Shift)

        if self.Owner:KeyDown(IN_MOVELEFT) then Predict = -self.Owner:GetRight() * 10
        elseif self.Owner:KeyDown(IN_MOVERIGHT) then Predict = self.Owner:GetRight() * 10 end

        local tracedata = {}
        tracedata.start = self.Owner:GetShootPos() + Predict
        tracedata.endpos = tracedata.start + self.Owner:GetForward() * 40
        tracedata.filter = self.Owner
        local trLo =  util.TraceLine(tracedata)

        local tracedata = {}
        tracedata.start = self.Owner:GetShootPos() + Vector(0, 0, 15) + Predict
        tracedata.endpos = tracedata.start + self.Owner:GetForward() * self.Owner:GetShootPos():Distance(trLo.HitPos)
        tracedata.filter = self.Owner
        local trHi =  util.TraceLine(tracedata)

        if !trHi.Hit and trLo.Hit then

            self.Owner:SetPos(self.Owner:GetPos() + Predict)
			if physObj != NULL then
				self.LocalPos = self.Parent:WorldToLocal(self.Owner:GetPos());
			end
            if trLo.MatType == MAT_GLASS then self.Owner:EmitSound(Sound("physics/glass/glass_sheet_step"..math.random(1, 4)..".wav"), 75, math.random(95, 105))
			elseif trLo.MatType and MatList[trLo.MatType] then self.Owner:EmitSound(Sound("player/footsteps/"..MatList[trLo.MatType]..math.random(1, 4)..".wav"), 75, math.random(95, 105)) end

            if self.Owner:KeyDown(IN_MOVELEFT) then self.Owner:ViewPunch(Angle(0, 0, -2.5))
            else self.Owner:ViewPunch(Angle(0, 0, 2.5)) end
            return true

        end

    end

    // Wall Jumping. (In Think due to HUD Implementation)
    if self.Jumps > 0 then

        // Are we actually against a wall?
        local tracedata = { }
        local ShootPos = self.Owner:GetShootPos()
        local AimVector = self.Owner:GetAimVector()
        tracedata.start = ShootPos
        tracedata.endpos = ShootPos - AimVector*45
        tracedata.filter = self.Owner

        local trace = util.TraceLine(tracedata)

        if trace.Hit and !trace.HitSky and !self.Owner:GetNWBool("ClimbWallJump") then

            self.Owner:SetNWBool("ClimbWallJump", true)

        end

    elseif self.Owner:GetNWBool("ClimbWallJump") then self.Owner:SetNWBool("ClimbWallJump", false)
    end

    return true

end
function SWEP:ShakeEffect()
    if self.JumpSequence == 0 then
        self.Owner:ViewPunch(Angle(0, 5, 0))
    elseif self.JumpSequence == 1 then
        self.Owner:ViewPunch(Angle(0, -5, 0))
    elseif self.JumpSequence == 2 then
        self.Owner:ViewPunch(Angle(-5, 0, 0))
    end
    self.JumpSequence = self.JumpSequence < 3 and self.JumpSequence + 1 or 0
end
function SWEP:PrimaryAttack()

    if CLIENT or self.Owner:GetNWBool("ClimbWallRun") then return true end

    // We'll use this trace for determining whether we're looking at a Wall!
    local tracedata = { }
    local ShootPos = self.Owner:GetShootPos()
    local AimVector = self.Owner:GetAimVector()
    tracedata.start = ShootPos
    tracedata.endpos = ShootPos + AimVector*45
    tracedata.filter = self.Owner
    local trace = util.TraceLine(tracedata)

    // We'll have to be off the ground to start climbing!
    if self.Owner:OnGround() then

        // General Melee Functionality

        self:SetNextPrimaryFire(CurTime() + 0.4)

        if !trace.Hit or trace.HitWorld or trace.HitSky then

            self.Owner:EmitSound(Sound("npc/fast_zombie/claw_miss"..math.random(1, 2)..".wav"), 75)
            return false

        end

        if IsValid(trace.Entity) then

            if !trace.Entity:IsWorld() then

                if GetConVarNumber("climbswep2_necksnaps") == 1 and (trace.Entity:IsPlayer() or trace.Entity:IsNPC()) and trace.Entity:GetAimVector():DotProduct(self.Owner:GetAimVector()) > 0.6 then

                    if trace.Entity:IsPlayer() then

                        if GetConVarNumber("sbox_playershurtplayers") <= 0 then return false end
                        trace.Entity:Kill()
                        self.Owner:AddFrags(1)
                        self.Owner:EmitSound(Sound("physics/body/body_medium_break"..math.random(3, 4)..".wav"), 80, math.random(95, 105))
                        return true

                    else

                        trace.Entity:TakeDamage(trace.Entity:Health(), self.Owner, self)
                        self.Owner:AddFrags(1)
                        self.Owner:EmitSound(Sound("physics/body/body_medium_break"..math.random(3, 4)..".wav"), 80, math.random(95, 105))
                        return true

                    end

                    return true

                elseif trace.Entity:IsPlayer() then

                    trace.Entity:ViewPunch(Angle(-25, 20, 0))
					if trace.Entity:GetActiveWeapon().Grab then trace.Entity:GetActiveWeapon().Grab = false end
					
                elseif trace.Entity:IsNPC() then
                    trace.Entity:TakeDamage(10, self.Owner, self)
                end
                if (IsValid(trace.Entity:GetPhysicsObject())) then
                    trace.Entity:GetPhysicsObject():ApplyForceOffset((trace.HitPos-self.Owner:EyePos())*128, trace.HitPos)
                end
                self.Owner:EmitSound(table.Random(HitPlayer), 80, math.random(95, 105))
                return true

            end

        end

        return false

    end

    // Are we grabbing?
    if self.Grab then

        // If so, we'll want to reset our variables!
        self:Forget()

        // Now, run up that wall!
        self.Owner:ViewPunch(Angle(-15, self.Owner:EyeAngles().yaw/32, 0))
        self.Owner:EmitSound(Sound("player/suit_sprint.wav"), 80, math.random(95, 105))
        self.Owner:SetVelocity(-self.Owner:GetVelocity() + Vector(0, 0, 250))
        self:SetNextPrimaryFire(CurTime() + 0.15)
        return true

    end

    // Wall Jumping. (Code in Think due to HUD Implementation)
    if self.Owner:GetNWBool("ClimbWallJump") then

        // We can Wall Jump!
        self.CanWallRun = true;
		self.Jumps = 0
        self.Owner:SetLocalVelocity(self.Owner:GetAimVector() * 300)
        self.Owner:EmitSound(Sound("npc/combine_soldier/gear"..math.random(1, 6)..".wav"), 75, math.random(95, 105))
        self.Owner:ViewPunch(Angle(-7.5, 0, 0))
        return true

    end

    // Are we close enough to start climbing?
    if ( (self.Jumps == 0 and trace.HitPos:Distance(ShootPos) > 40) or self.Jumps > (GetConVarNumber("climbswep2_maxjumps") - 1) or trace.HitSky) then return false end

    // If we've mysteriously lost the wall we'll want to stop climbing!
    if !trace.Hit then return false end

    if self.Owner:GetVelocity().z <= -750 then

        self:SetNextPrimaryFire(CurTime() + 1)
        self.Owner:EmitSound("ambient/levels/canals/toxic_slime_sizzle4.wav", 50, 200)

        if self.MFC == "combine" then self.Owner:EmitSound("npc/metropolice/knockout2.wav", 125)
        else self.Owner:EmitSound("vo/npc/"..self.MFC.."01/ow0"..math.random(1, 2)..".wav", 125) end

        return true

    end

    // Add some effects.
    if trace.MatType == MAT_GLASS then self.Owner:EmitSound(Sound("physics/glass/glass_sheet_step"..math.random(1, 4)..".wav"), 75, math.random(95, 105))
	elseif trace.MatType and MatList[trace.MatType] then self.Owner:EmitSound(Sound("player/footsteps/"..MatList[trace.MatType]..math.random(1, 4)..".wav"), 75, math.random(95, 105))
    else self.Owner:EmitSound(Sound("npc/fast_zombie/claw_miss"..math.random(1, 2)..".wav"), 75, math.random(95, 105)) end

    // Climb the wall and modify our jump count.

    local Vel = self.Owner:GetVelocity()
    self.Owner:SetVelocity(Vector(0, 0, 240 - 15 * 1 + self.JumpSequence - Vel.z))
    self:SetNextPrimaryFire(CurTime() + 0.15)
    self.Jumps = self.Jumps + 1
    self:ShakeEffect()
    return true

end
function SWEP:CanGrab() -- This too, but modified it somewhat.

    // We'll detect whether we can grab onto the ledge.
    local trace = {}
    trace.start = self.Owner:GetShootPos() + Vector( 0, 0, 15 )
    trace.endpos = trace.start + self.Owner:GetAimVector() * 30
    trace.filter = self.Owner

    local trHi = util.TraceLine(trace)

    local trace = {}
    trace.start = self.Owner:GetShootPos()
    trace.endpos = trace.start + self.Owner:GetAimVector() * 30
    trace.filter = self.Owner

    local trLo = util.TraceLine(trace)

    // Is the ledge actually grabbable?
    if trLo and trHi and trLo.Hit and !trHi.Hit then
        return {true, trLo}
    else
        return {false, trLo}
    end

end
function SWEP:SecondaryAttack()

    if CLIENT then return true end

    if !self.Released then return end

    if self.Owner:OnGround() then return false end // We don't want to grab onto a ledge if we're on the ground!

    // If we're already grabbing something, we want to let go!
    if self.Grab then
        self:Forget()
        self.Released = false
        return false
    end

    // Returns whether we can grab(boolean) and a traceres.
    local Grab = self:CanGrab()

    // If we can't grab we're done here.
    if !Grab[1] then 
        return false 
    end

    // Otherwise reset our jumps and enter ledge holding mode!
    self.Jumps = 0
    self.Grab  = true
    self.Released = false
    local VelZ = self.Owner:GetVelocity().z;
	self.Owner:ViewPunch(Angle(math.max(15, math.min(30, VelZ)) * (VelZ > 0 and 1 or -1), 0, 0));
    self.Owner:SetLocalVelocity(Vector(0, 0, 0))
    self.Owner:SetMoveType(MOVETYPE_NONE)
    self.Owner:EmitSound(Sound("physics/flesh/flesh_impact_hard"..math.random(1, 3)..".wav"), 75)
	
    // Are we looking at a valid entity?
    if IsValid(Grab[2].Entity) then

        // Does the prop/entity use valid prop-like behaviour?
        if Grab[2].Entity:GetMoveType() == MOVETYPE_VPHYSICS then

            // Then we can grab onto it!
            self.OldVelocity      = Grab[2].Entity:GetVelocity():Length()
            self.Parent           = Grab[2].Entity
            self.LocalPos      	= Grab[2].Entity:WorldToLocal(self.Owner:GetPos())
        end

    end

    local ClimbSwep = self
	local Ply = self.Owner;
    local Forget = function()
        self:Forget();
		hook.Remove("Think", "ClimbGrab"..Ply:UniqueID())
    end
    local IsOneHanded = function()

        if !IsValid(Ply:GetActiveWeapon()) then return false end

        local Weps = {climb_swep2 = true, weapon_pistol = true, weapon_357 = true, weapon_crowbar = true, weapon_frag = true}
        local HoldTypes = {pistol = true, grenade = true, knife = true}
        local Wep = Ply:GetActiveWeapon()
        if Weps[Wep:GetClass()] then return true
        elseif HoldTypes[Wep.HoldType] then return true end
        return false

    end


    local ThinkFunction = function()

		if !Ply:Alive() then hook.Remove("Think", "ClimbGrab"..Ply:UniqueID());
	    elseif !ClimbSwep.Grab or Ply:GetMoveType() != MOVETYPE_NONE then Forget(); return
        elseif !IsOneHanded() then Forget(); 
            return
        elseif IsValid(ClimbSwep.Parent) then

            if ClimbSwep.Parent:GetPhysicsObject():IsMoveable() then
            
                if math.abs(ClimbSwep.OldVelocity - ClimbSwep.Parent:GetVelocity():Length()) >= 500 then Forget()
                else

                    ClimbSwep.OldVelocity = ClimbSwep.Parent:GetVelocity():Length()
                    Ply:SetLocalVelocity(Vector(0, 0, 0))
                    Ply:SetPos(ClimbSwep.Parent:LocalToWorld(ClimbSwep.LocalPos))
                    return

                end

            end

        end

    end
    hook.Add("Think", "ClimbGrab"..Ply:UniqueID(), ThinkFunction)
    return true

end
function SWEP:DrawHUD()

    if SERVER or GetConVarNumber("climbswep2_showhud") == 0 then return false end

    /*
        We can't make use of the variables the SERVER has indexed.
        Instead we'll make use of Networked Variables, available to both
        the CLIENT and the SERVER.
    */

    local Jumps, MaxJumps = LocalPlayer():GetNWInt("ClimbJumps"), GetConVarNumber("climbswep2_maxjumps")
    local Width, Height = 256, 18


    // Draw Jump-Monitor
    draw.RoundedBox(4, ScrW() / 2 - Width / 2, ScrH() - Height * 2, Width, Height, Color(51, 181, 229, 122))
    if (MaxJumps - Jumps) > 0 then draw.RoundedBox(4, ScrW() / 2 - Width / 2, ScrH() - Height * 2, Width * (MaxJumps - Jumps) / MaxJumps, Height, Color(51, 181, 229, 255)) end
    draw.DrawText("Jumps: "..(MaxJumps - Jumps).." of "..GetConVarNumber("climbswep2_maxjumps"), "Default", ScrW() / 2, ScrH() - 33, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER)

    // Draw Custom HUD Icons
    if LocalPlayer():GetNWBool("ClimbWallJump") then

        surface.SetDrawColor(Color(51, 181, 229, 255))
        surface.DrawRect(ScrW() / 2 - 8, ScrH() - Height * 2 - 36, 8, 32)
        surface.SetTexture(surface.GetTextureID("gui/arrow.vmt"))
        surface.DrawTexturedRectRotated(ScrW() / 2 + 9, ScrH() - Height * 2 - 22, 30, 30, -60)
        surface.SetDrawColor(Color(255, 255, 255, 255))

    elseif LocalPlayer():GetNWBool("ClimbFalling") then

        surface.SetDrawColor(Color(51, 181, 229, 255))
        surface.DrawRect(ScrW() / 2 - 16, ScrH() - Height * 2 - 12, 32, 8)
        surface.SetTexture(surface.GetTextureID("gui/arrow.vmt"))
        surface.DrawTexturedRectRotated(ScrW() / 2, ScrH() - Height * 2 - 28, 30, 30, 180)
        surface.SetDrawColor(Color(255, 255, 255, 255))

    end

end
--PATH lua/weapons/cloaking-2/shared.lua:
return gluapack()()
--PATH lua/weapons/ce_bcr_config.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/door_ram/shared.lua:
return gluapack()()
--PATH lua/weapons/dual_base/cl_init.lua:
return gluapack()()
--PATH lua/weapons/dual_base/shared.lua:
SWEP.HoldType = "duel"
SWEP.ViewModelFOV = 72.160804020101
SWEP.ViewModelFlip = false
SWEP.UseHands = true
SWEP.ViewModel = "models/weapons/v_dc17.mdl"
SWEP.WorldModel = "models/weapons/w_DC17.mdl"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = true
SWEP.Akimbo = true
SWEP.ViewModelBoneMods = {
	["v_weapon.Hands_parent"] = { scale = Vector(0.961, 1.001, 0.961), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.elite_right"] = { scale = Vector(0.018, 0.018, 0.018), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Left_Hand"] = { scale = Vector(1.016, 1.016, 1.016), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Right_Arm"] = { scale = Vector(1, 1, 1), pos = Vector(-3.149, -1.297, 0.185), angle = Angle(0, 0, 0) },
	["v_weapon.elite_left"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["dc17"] = { type = "Model", model = "models/weapons/w_DC17.mdl", bone = "v_weapon.elite_left", rel = "", pos = Vector(-0.519, -1.558, 4.675), angle = Angle(90, -99.351, 15.194), size = Vector(0.69, 0.69, 0.69), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["dc17+"] = { type = "Model", model = "models/weapons/w_DC17.mdl", bone = "v_weapon.elite_right", rel = "", pos = Vector(-0.519, -1.558, 4.675), angle = Angle(90, -99.351, 15.194), size = Vector(0.69, 0.69, 0.69), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}


SWEP.WElements = {
	["dc17"] = { type = "Model", model = "models/weapons/w_DC17.mdl", bone = "ValveBiped.Bip01_L_Hand", rel = "", pos = Vector(9.362, 1.738, 3.665), angle = Angle(0, 0, 0), size = Vector(0.827, 0.827, 0.827), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.MuzzleAttachment			= "1" --Where the muzzleflash AND bullet should come out of on the weapon. Most models have this as 1.
SWEP.ShellAttachment			= "2" --Where the bullet casing should come out of on the weapon. Most models have this as 2.
SWEP.MuzzleEffect    			= "MuzzleEffect" --Which effect to use as the muzzleflash.
SWEP.ShellEffect				= "ShellEject" --Which effect to use as the bullet casing.
SWEP.Tracer						= "Tracer" --Which effect to use as the bullet tracer.
SWEP.TracerX					= 1 --For every X bullets, show the tracer effect.
SWEP.Primary.Spread		= 0.0125
SWEP.Damage						= 1 --How much damage each bullet should do. Rule of thumb is somewhere around 4-8 for small caliber weapons like pistols, 8-12 for rifles, and 15+ for large caliber weapons.
SWEP.Force						= 0 --How much force each bullet should do. Rule of thumb is set this the same as damage, unless goes outside this range (5, 15). You usually don't want this to be outside that range.
SWEP.Spread						= Vector(0, 0, 0) --How inaccurate the weapon should be. Only the first 2 values are needed. Examples: AWP - Vector(0.003, 0.003, 0), M4A1 - Vector(0.030, 0.030, 0), MAC10 - Vector(0.060, 0.060, 0)
SWEP.SpreadMPenalty				= 1 --How much should we multiply the spread if the NPC is moving? Higher values mean the weapon is more inaccurate while moving. Rule of thumb is 1.2 for rifles, 1.1 for pistols, 1 for SMGs, 1.3-1.5 for MGs, and 5+ for sniper rifles.
SWEP.BurstCount					= 0 --How many EXTRA bullets should we fire every time the NPC shoots? A value of 0 means fire 1 bullet (pistols, sniper rifles), 2 means fire 3 bullets (assault rifles, some smgs). This allows burst-fire weapons like the FAMAS and Glock.
SWEP.BurstDelay					= 0 --How much time should there be between shots in the same burst? Higher values make the delay between shots in the same burst longer.
SWEP.Primary.NumShots			= 1 --How many bullets should there be for each shot? Most weapons would have this as 1, but shotguns would have a different value, like 8 or 9.
SWEP.Primary.ClipSize			= 1 --How many shots should we get per reload?
SWEP.Primary.DefaultClip		= 1 --How many shots should the weapon spawn with in the magazine? Usually you want this the same as ClipSize.
SWEP.Primary.Delay				= 0 --How much time should there be between pulls of the trigger? For weapons with a BurstCount of 0 this is essentially firerate, and for weapons with a nonzero BurstCount this is the delay between bursts.
SWEP.FireDelay 					= 0 --This value is used to store the current server time in order to handle delays between firing. Don't change this value.
SWEP.Primary.Ammo				= "pistol" --Since NPCs have infinite ammo, this value is not important and should just be left alone.
SWEP.Primary.Sound				= "weapons/pistol/pistol_fire2.wav"

SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

SWEP.IronSightsPos = Vector(-1.16, 0, 1.09)
SWEP.IronSightsAng = Vector(-0.101, 1, -1.407)


function SWEP:PrimaryAttack()
	
	if not self:CanPrimaryAttack() then
		self:AIReload()
		return
	end
	
	local curtime = CurTime()
	
	if self.FireDelay > curtime then
		return
	end
	
	if self.Owner:IsNPC() and IsValid(self.Owner:GetEnemy()) then
		
		self.FireDelay = curtime + self.Primary.Delay
		
		for i=0, self.BurstCount do
		
			timer.Simple(i * self.BurstDelay, function()
			
				if not IsValid(self) or not IsValid(self.Owner) then
					return
				end
				
				if not self.Owner:GetEnemy() or not self:CanPrimaryAttack() then
					return
				end
				
				self:Shoot()
			
			end)
		
		end
		
	end
	
end

function SWEP:Proficiency()
timer.Simple(0.5, function()
if !self:IsValid() or !self.Owner:IsValid() then return; end
	local Proficiency = GetConVar( "NPC_Proficiency" )
  if GetConVar( "new_acc_system" ):GetInt() == 1 then
	if Proficiency:GetInt() == 0 then
	self.Owner:SetCurrentWeaponProficiency(0)
	end

	if Proficiency:GetInt() == 1 then
	self.Owner:SetCurrentWeaponProficiency(1)
	end
	
	if Proficiency:GetInt() == 2 then
	self.Owner:SetCurrentWeaponProficiency(2)
	end
	
	if Proficiency:GetInt() == 3 then
	self.Owner:SetCurrentWeaponProficiency(3)
	end

	if Proficiency:GetInt() == 4 then
	self.Owner:SetCurrentWeaponProficiency(4)
	end
	else
		self.Owner:SetCurrentWeaponProficiency(3)
end
	end)
end

function SWEP:Shoot()

	local owner = self.Owner
	local enemy = owner:GetEnemy()
	local enemycl = enemy:GetClass()
	local targetPos = nil
	
	if enemy:IsPlayer() or enemycl == "npc_combine_s" or enemycl == "npc_citizen" or enemycl == "npc_metropolice" then
	
		if enemy:LookupBone("ValveBiped.Bip01_Head1") == nil then
		
			targetPos = enemy:EyePos()
		
		else
		
			targetPos = enemy:GetBonePosition(enemy:LookupBone("ValveBiped.Bip01_Head1"))
			
		end
		
	elseif enemycl == "npc_fastzombie" or enemycl == "npc_poisonzombie" or enemycl == "npc_zombie_torso" or enemycl == "npc_fastzombie_torso" or enemycl == "npc_headcrab" or enemycl == "npc_headcrab_black" or enemycl == "npc_headcrab_fast" then
	
		targetPos = enemy:WorldSpaceCenter()
		
	else
	
		targetPos = enemy:EyePos()
		
	end
	
	local muzzlePos = self.Weapon:GetAttachment(self.MuzzleAttachment).Pos
	local direction = self.Owner:GetAimVector()	
	local spread = Vector( cone, cone, 0 )
	
	local bulletInfo = {}
	bulletInfo.Attacker = owner
	bulletInfo.Damage = self.Damage
	bulletInfo.Force  = self.Force
	bulletInfo.Num = self.Primary.NumShots
	bulletInfo.Tracer = self.TracerX
	bulletInfo.TracerName = self.Tracer
	bulletInfo.AmmoType = self.Primary.Ammo
	bulletInfo.Dir = direction
	bulletInfo.Spread = spread
	bulletInfo.Src = muzzlePos
	
	owner:FireBullets(bulletInfo)
	self:ShootEffects()
	
	self:TakePrimaryAmmo(1)
	
end

function SWEP:ShootEffects()

	local shootSound = Sound(self.Primary.Sound)
	self.Weapon:EmitSound(shootSound, SNDLVL_GUNFIRE, 100, 1, CHAN_WEAPON)
	
	local muzzleEffect = EffectData()
	local muzzleAttach = self.Weapon:GetAttachment(self.MuzzleAttachment)
	muzzleEffect:SetEntity(self.Weapon)
	muzzleEffect:SetOrigin(muzzleAttach.Pos)
	muzzleEffect:SetAngles(muzzleAttach.Ang)
	muzzleEffect:SetScale(1)
	muzzleEffect:SetMagnitude(1)
	muzzleEffect:SetRadius(1)
	util.Effect(self.MuzzleEffect, muzzleEffect)

	local shellEffect = EffectData()
	local shellAttach = self.Weapon:GetAttachment(self.ShellAttachment)
	shellEffect:SetEntity(self.Weapon)
	shellEffect:SetOrigin(shellAttach.Pos)
	shellEffect:SetAngles(shellAttach.Ang)
	shellEffect:SetScale(1)
	shellEffect:SetMagnitude(1)
	shellEffect:SetRadius(1)
	util.Effect(self.ShellEffect, shellEffect)
	
	self.Owner:MuzzleFlash()

end

function SWEP:AIReload()

	if not IsValid(self) or not IsValid(self.Owner) then
		return
	end
	
	local owner = self.Owner

	if owner:IsNPC() and not owner:IsCurrentSchedule(SCHED_HIDE_AND_RELOAD) and not owner:IsCurrentSchedule(SCHED_RELOAD) and not owner:GetActivity() == ACT_RELOAD then
		owner:SetSchedule(SCHED_RELOAD)
	end
	
end

function SWEP:SecondaryAttack()

end

function SWEP:Think()
	
	timer.Simple(engine.TickInterval() * 5, function()
	
		if IsValid(self) then
			self:Think()
		end
	
	end)
	
	if not IsValid(self.Owner) then
		self:Remove()
		return
	end
	
	if IsValid(self.Owner) and IsValid(self.Owner:GetEnemy()) then
		
		local owner = self.Owner
		local enemy = owner:GetEnemy()
		
		if self:CanPrimaryAttack() and owner:GetActivity() ~= ACT_RELOAD and enemy:Health() > 0 then
			
			if enemy:Visible(owner) then
			
				self:PrimaryAttack()
			
			end
		
		end
		
	end

end

function SWEP:CanPrimaryAttack()

	if self.Weapon:Clip1() <= 0 then
	
		return false
	
	end
	
	return true

end

function SWEP:Initialize()

	--// other initialize code goes here

	if CLIENT then
	
		--// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		--// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				if self.Akimbo then
		self.AutoDetectMuzzleAttachment = true
		self.MuzzleAttachmentRaw = 2-self.AnimCycle
	end	
				
				--// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					--// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					--// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					--// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end

end

function SWEP:Deploy()

	return true
	
end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

function SWEP:Initialize()

	--// other initialize code goes here

	if CLIENT then
	
		--// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) --// create viewmodels
		self:CreateModels(self.WElements) --// create worldmodels
		
		--// init view model bone build function
		if IsValid(self.Owner) then
			--local vm = self.Owner:GetViewModel()
			--if IsValid(vm) then
				--self:ResetBonePositions(vm)
				
				--// Init viewmodel visibility
				--if (self.ShowViewModel == nil or self.ShowViewModel) then
				--	vm:SetColor(Color(255,255,255,255))
				--else
					--// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
				--	vm:SetColor(Color(255,255,255,1))
					--// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					--// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
				--	vm:SetMaterial("Debug/hsv")			
				--end
			--end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		--local vm = self.Owner:GetViewModel()
		--if IsValid(vm) then
		--	self:ResetBonePositions(vm)
		--end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			--// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				--//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			--// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				--//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			--// Technically, if there exists an element with the same name as a bone
			--// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		--// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				--// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			--// !! WORKAROUND !! //
			--// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			--// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				--// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				--// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	--/**************************
	--	Global utility code
	--**************************/

	--// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	--// Does not copy entities of course, only copies their reference.
	--// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end

function SWEP:FireAnimationEvent(pos,ang,event)
return (event==20)
end

function SWEP:CanClip2Attack()
	if clip2 <= 0 and self.Primary.ClipSize > -1 then
		self.Weapon:SetNextSecondaryFire(CurTime() + 0.5)
		self.Weapon:EmitSound("weapons/DC17_fire.wav")
		clip2 = 0
		return false
	end

	return true
end



--PATH lua/weapons/gmod_tool/stools/bossbartool.lua:

TOOL.Category = "Stoneman"
TOOL.Name = "Boss Bar"

if CLIENT then
	language.Add( "tool.bossbartool.name", "Boss Health Bar Tool" )
	language.Add( "tool.bossbartool.desc", "Broadcast a specific player health to the server, with a boss health bar.." )
	language.Add( "tool.bossbartool.0", "Left Click: Select target to become a boss, Right click: Select yourself to become the boss, Reload: Disable all boss health bars." )
end

if SERVER then
    ---Precaching network messages---
    util.AddNetworkString("bossbar_start")
    util.AddNetworkString("bossbar_stop")
    util.AddNetworkString("bossbar_death")
	util.AddNetworkString("bossbar_buffer")
end

TOOL.ClientConVar[ "name" ] = "Stoneman, Destroyer of Worlds"
TOOL.ClientConVar[ "icon" ] = ""
TOOL.ClientConVar[ "maxhealth" ] = "1000"
TOOL.ClientConVar[ "health" ] = "1000"
TOOL.ClientConVar[ "label" ] = "BOSS :"
TOOL.ClientConVar[ "dmgscale" ] = "1"

list.Set("BossIcon", "Default (Star)", 				{bossbartool_icon = ""})
list.Set("BossIcon", "Eliminate (Skull)", 			{bossbartool_icon = "bossbar/skull.png"})
list.Set("BossIcon", "Defend (Shield)", 			{bossbartool_icon = "bossbar/defend.png"})
list.Set("BossIcon", "Capture (Prison)", 			{bossbartool_icon = "bossbar/capture.png"})

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel(CPanel)
	
	local Options = {
		Default = {
			bossbartool_icon 		= "",
		}
	}

    CPanel:AddControl( "ComboBox", 
	{ 
		MenuButton = 1,
		Folder = "bossbartool",
		Options = { [ "#preset.default" ] = ConVarsDefault },
		CVars = table.GetKeys( ConVarsDefault ) 
	}
	)
	
	CPanel:AddControl("Header",
	{
		Text = "Boss Bar Tool",
		Description = [[Left-Click to enable a boss health bar for the entity you're looking at. Right click to disable the boss bar.]]
	}
	)

    CPanel:AddControl( "TextBox",
	{
		Label = "Name:",
		Command = "bossbartool_name",
		MaxLength = "48"
	}
	)

	CPanel:AddControl("ComboBox",
	{
		Label = "Icon Options:",
		MenuButton = 0,
		Command = "bossbartool_icon",
		Options = list.Get("BossIcon")
	}
	)	

	CPanel:AddControl( "slider", 
	{
		Label = "Max Health:",
		Command = "bossbartool_maxhealth",
		min = "1",
		max = "100000000"
	}
	)

    CPanel:ControlHelp("Sets the max health of the boss entity.")

    CPanel:AddControl( "slider", 
	{ 
		Label = "Health:",
		Command = "bossbartool_health",
		min = "1",
		max = "100000000"
	} 
	)

    CPanel:ControlHelp("Sets the current health of the boss entity.")

	CPanel:AddControl( "slider", 
	{ 
		type = "float",
		Label = "Damage Scale:",
		Command = "bossbartool_dmgscale",
		min = "0",
		max = "1000"
	} 
	)

    CPanel:ControlHelp("Multiplies the boss damage by this number.")

    CPanel:AddControl( "TextBox", 
	{ 
		Label = "Label:",
		Command = "bossbartool_label",
		MaxLength = "12"
	} 
	)

    CPanel:ControlHelp("Sets the label.")	
end

function TOOL:LeftClick(tr)
	if not IsFirstTimePredicted() then return end
	if bossHealthSystem:IsValidBoss() then return end

	if !IsValid(tr.Entity) then return end
	local ent = tr.Entity
	
	if ent:IsWorld() then return end
	if (!ent:IsPlayer() and !ent:IsNPC() ) then return end
	
	self:SetBoss(ent)
end

function TOOL:RightClick(tr)
	if not IsFirstTimePredicted() then return end
	if bossHealthSystem:IsValidBoss() then return end

	local ent = self:GetOwner()

	self:SetBoss(ent)
end

function TOOL:Reload()
	if not IsFirstTimePredicted() then return end
	if bossHealthSystem:IsValidBoss() then
		bossHealthSystem:RemoveBoss()
		if CLIENT then
			notification.AddLegacy(("Turned off the boss bar"),0,5)
			surface.PlaySound("buttons/button14.wav")
		end
	end
	if not bossHealthSystem:IsValidBoss() then return end
	self:SetBoss(NULL)
end

function TOOL:SetBoss(ent)
	if CLIENT then
		if ent:IsPlayer() then
			notification.AddLegacy(("Turned on the boss bar for " .. ent:Nick()),0,5)
		else
			notification.AddLegacy(("Turned on the boss bar for an NPC"),0,5)
		end
	end
	
	local maxHealth = self:GetClientInfo("maxhealth")
	local health =  self:GetClientInfo("health")
	local name = self:GetClientInfo("name")
	local label = self:GetClientInfo("label")
	local dmgscale = self:GetClientInfo("dmgscale")
	local icon = self:GetClientInfo("icon")
	bossHealthSystem:AddBoss(ent, maxHealth, health, name, label, dmgscale, icon)
end
--PATH lua/weapons/gmod_tool/stools/removeprops.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15a.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc17_stun.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc19.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-19"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "The DC-15A blaster carbine, also referred to as the DC-15S blaster, was a blaster carbine model used by the Grand Army of the Republic. It was part of the DC-15 family. While smaller than the larger DC-15A blaster rifle, both could be referred to as blaster rifles. It was one of the most common weapons issued to clone troopers during the Clone Wars and were used during many battles."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc19.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = true

SWEP.ViewModel = "models/servius/starwars/c_dc15s.mdl"
SWEP.WorldModel = "models/servius/starwars/w_dc15s.mdl"
SWEP.ViewModelFOV = 58
SWEP.WorldModelOffset = {
    pos = Vector(-9, 3.5, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.7,
    [HITGROUP_CHEST] = 1.2,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 45
SWEP.RangeMin = 224
SWEP.DamageMin = 26
SWEP.Range = 478
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = nil
SWEP.TracerCol = nil
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 34

SWEP.Recoil = 0.67
SWEP.RecoilSide = 0.34
SWEP.RecoilRise = 0.53
SWEP.Delay = 60 / 298

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.5 
SWEP.HipDispersion = 490
SWEP.MoveDispersion = 60

-- Sounds & Muzzleflash
SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc19.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0,0,0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.837, 0.619, 1.656),
    Ang = Angle(0, 0, 0),
     Magnification = 1.3,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1

SWEP.ActivePos = Vector(0, 2, 0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, 0)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC15",
        Offset = {
            vpos = Vector(0, -1.6, -0.5),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Grip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "DC15",
        Offset = {
            vpos = Vector(-0.101, 2.378, 6.164),
            vang = Angle(90, 0, -90),
        },
        SlideAmount = {
        vmin = Vector(-0.2, 0, 5.100),
        vmax = Vector(-0.2, 0, 9),
        },          
    },
    {
        PrintName = "Stock",
        DefaultAttName = "None",
        Bone = "DC15",
        Slot = "stock",
        Offset = {
            vpos = Vector(0, 0.5, -9.1),
            vang = Angle(0, 0, -90),
        },
    }, 
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC15", 
        Offset = {
            vpos = Vector(0.8, -0.5, 10),
            vang = Angle(90, 0, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.1, -0.442, 11.638),
            vang = Angle(90, 0, -90),

        },
    },    
    {
        PrintName = "Ammo",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.9, -0.7, 5.7),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.8, -0.2, -5),
            vang = Angle(90, 0, -90),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3",
                p = 100, 
                v = 75, 
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "dc15s_1", t = 1.68 / 60},
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_manualcooling_var_02.mp3", t = 0.1},
        },
    },

sound.Add({
    name =          "dc15s_1",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armasclasicas/wpn_empire_medreload.wav"
    }),

}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_sb2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "SB-2"
SWEP.Trivia_Class = "Blaster Heavy Shotgun"
SWEP.Trivia_Desc = "The SB-2 was a type of blaster that could pierce through enemy defenses. It was used by the Grand Army of the Republic's clone troopers during the Clone Wars between the Galactic Republic and the Confederacy of Independent Systems. The DP-23 fired blue blaster bolts, and had a ridged barrel with a pointed muzzle, a black stock, and a small foregrip."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/sb2.png"

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/servius/weapons/viewmodels/c_sb-2.mdl"
SWEP.WorldModel = "models/servius/weapons/worldmodels/w_sb-2.mdl"
SWEP.ViewModelFOV = 55
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-5, 5, -6),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.DefaultBodygroups = "000000000000"

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1.5,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 27
SWEP.NoLastCycle = true
SWEP.ManualAction = true
SWEP.ShotgunReload = true
SWEP.RangeMin = 20
SWEP.DamageMin = 17
SWEP.Range = 50
SWEP.Penetration = 1
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 8

SWEP.Recoil = 2
SWEP.RecoilSide = 2
SWEP.RecoilPunch = 0.9
SWEP.RecoilRise = 0.9

SWEP.Delay = 10/30
SWEP.Num = 5
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 50 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 450 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 100

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "armas/disparos/sb2.wav"
SWEP.ShootSoundSilenced = "armas/disparos/silenced_sniper.mp3"

SWEP.IronSightStruct = {
    Pos = Vector(-3.724, -3.964, 2.733),
    Ang = Vector(0, 0, 3),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(-1, 4, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(.5, -6, -12)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -3, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard",
        Slot = "optic",
        Bone = "w_sb2",
        Offset = {
            vpos = Vector(0.261, 0.523, 2.338),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    }, 
    {
        PrintName = "Tactical", 
        DefaultAttName = "None",
        Slot = {"tactical","tac_pistol"},
        Bone = "w_sb2", 
        Offset = {
            vpos = Vector(0.894, 8.522, 1.233),
            vang = Angle(0, -90, 90),
        },
    },    
    {
        PrintName = "Muzzle", 
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "w_sb2",
        Offset = {
            vpos = Vector(0.2, 15.5, 1.1),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "shotgun_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None", 
        Slot = {"charm"},
        Bone = "w_sb2", 
        Offset = {
            vpos = Vector(0.796, -0.996, 1.276),
            vang = Angle(0, -90, 0),
        },
    },          
}
SWEP.Animations = {
    ["idle"] = {
        Source = "neutral"
    },
    ["fire"] = {
        Source = "shoot",
    },
    ["cycle"] = {
        Source = "pump",
        Time = 0.9,
        SoundTable = {
            {s = "armas/disparos/sb2_pump.wav", t = 0.1 / 30}, 
        },
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_10.mp3",
                p = 100, 
                v = 75, 
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["sgreload_start"] = {
        Source = "reload_start",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {
			{s = "everfall/weapons/handling/misc_handling/hard_pickups/023d-0000106a.mp3", 	t = 0/30},
			{s = "weapons/fesiugmw2/foley/wpfoly_winchester_reload_loop_v1.wav", 	t = 14/30},
		},
    },
    ["sgreload_insert"] = {
        Source = "reload_insert",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {{s = "everfall/weapons/handling/reload_shells/heavy_shells/023d-00000777.mp3", 		t = 3/30}},
        RestoreAmmo = 1,
    },
    ["sgreload_finish"] = {
        Source = {"reload_finish"},
        SoundTable = {{s = "armas/disparos/sb2_pump.wav", 		t = 8/30}},
    },


sound.Add({
    name =          "ArcCW_dc15a.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/heavy.wav"
    }),
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_westarm5_alpha.lua:
return gluapack()()
--PATH lua/weapons/mortar_constructor_dark/shared.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/stick_base/shared.lua:
return gluapack()()
--PATH lua/weapons/tfa_bow_base.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/common/effects.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/common/skins.lua:
SWEP.MaterialTable = {}
SWEP.MaterialTable_V = {}
SWEP.MaterialTable_W = {}

function SWEP:InitializeMaterialTable()
	if not self.HasSetMaterialMeta then
		setmetatable(self.MaterialTable_V, {
			["__index"] = function(t,k) return self:GetStatL("MaterialTable")[k] end
		})

		setmetatable(self.MaterialTable_W, {
			["__index"] = function(t,k) return self:GetStatL("MaterialTable")[k] end
		})

		self.HasSetMaterialMeta = true
	end
end

--if both nil then we can just clear it all
function SWEP:ClearMaterialCache(view, world)
	if view == nil and world == nil then
		self.MaterialCached_V = nil
		self.MaterialCached_W = nil
		self.MaterialCached = nil
		self.SCKMaterialCached_V = nil
		self.SCKMaterialCached_W = nil
	else
		if view then
			self.MaterialCached_V = nil
			self.SCKMaterialCached_V = nil
		end

		if world then
			self.MaterialCached_W = nil
			self.SCKMaterialCached_W = nil
		end
	end
end

if SERVER then TFA.SWEP_LOAD_COMPLETE = true end
--PATH lua/weapons/tfa_gun_base/client/viewbob.lua:
return gluapack()()
--PATH lua/weapons/tfa_knife_base.lua:
if SERVER then
	AddCSLuaFile()
end

DEFINE_BASECLASS("tfa_gun_base")
SWEP.DrawCrosshair = true
SWEP.Primary.Automatic = true
SWEP.Secondary.Automatic = true
SWEP.Primary.RPM = 120 --Primary Slashs per minute
SWEP.Secondary.RPM = 60 --Secondary stabs per minute
SWEP.Primary.Delay = 0.15 --Delay for hull (primary)
SWEP.Secondary.Delay = 0.33 --Delay for hull (secondary)
SWEP.Primary.Length = 32
SWEP.Secondary.Length = 48
SWEP.Primary.Sound = Sound("Weapon_Knife.Slash") --Sounds
SWEP.KnifeShink = "Weapon_Knife.HitWall" --Sounds
SWEP.KnifeSlash = "Weapon_Knife.Hit" --Sounds
SWEP.KnifeStab = "Weapon_Knife.Slash" --Sounds
SWEP.SlashTable = {"midslash1", "midslash2"} --Table of possible hull sequences
SWEP.StabTable = {"stab"} --Table of possible hull sequences
SWEP.StabMissTable = {"stab_miss"} --Table of possible hull sequences
SWEP.DisableIdleAnimations = false --Enable idles
--[[ Don't Edit Below ]]
--
SWEP.DamageType = DMG_SLASH
SWEP.MuzzleFlashEffect = "" --No muzzle
SWEP.DoMuzzleFlash = false --No muzzle
SWEP.WeaponLength = 1 --No nearwall
SWEP.Primary.Ammo = "" -- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
SWEP.Primary.ClipSize = 1 -- Size of a clip
SWEP.Primary.DefaultClip = 1 -- Bullets you start with
SWEP.data = {} --No ironsights
SWEP.Secondary.IronSightsEnabled = false --No ironsights
SWEP.Secondary.DisplaySpread = false
SWEP.IsMelee = true

SWEP.CrosshairConeRecoilOverride = .05

SWEP.HullData = {
	hullMin = Vector(-16, -16, -16),
	hullMax = Vector(16, 16, 16)
}

SWEP.Primary.DisplayFalloff = false

SWEP.SlashCounter = 1
SWEP.StabCounter = 1

function SWEP:Deploy()
	return BaseClass.Deploy(self)
end

local lim_up_vec = Vector(1,1,0.1)

function SWEP:ApplyForce(ent, force, posv, now)
	if not IsValid(ent) or not ent.GetPhysicsObjectNum then return end

	if now then
		if ent.GetRagdollEntity then
			ent = ent:GetRagdollEntity() or ent
		end

		if not IsValid(ent) then return end
		local phys = ent:GetPhysicsObjectNum(0)

		if IsValid(phys) then
			if ent:IsPlayer() or ent:IsNPC() then
				ent:SetVelocity( force * 0.1 * lim_up_vec )
				phys:SetVelocity(phys:GetVelocity() + force * 0.1 * lim_up_vec )
			else
				phys:ApplyForceOffset(force, posv)
			end
		end
	else
		timer.Simple(0, function()
			if IsValid(self) and self:OwnerIsValid() and IsValid(ent) then
				self:ApplyForce(ent, force, posv, true)
			end
		end)
	end
end

function SWEP:SlashSound(tr)
	if IsFirstTimePredicted() then
		if tr.Hit then
			if tr.MatType == MAT_FLESH or tr.MatType == MAT_ALIENFLESH then
				self:EmitSound(self.KnifeSlash)
			else
				self:EmitSound(self.KnifeShink)
			end
		else
			self:EmitSound(self.Primary_TFA.Sound)
		end
	end
end

local sp = game.SinglePlayer()

function SWEP:GetSlashTrace(tbl, fwd)
	local ow = self:GetOwner()

	if not sp and ow:IsPlayer() then
		ow:LagCompensation(true)
	end

	local traceRes = util.TraceLine(tbl)

	if (not traceRes.Hit) then
		if not self.HullData.Radius then
			self.HullData.Radius = self.HullData.hullMin:Distance(self.HullData.hullMax) / 2
		end

		local hd = self.HullData
		tbl.mins = -hd.hullMin
		tbl.maxs = hd.hullMax
		tbl.endpos = tbl.endpos - fwd * hd.Radius
		traceRes = util.TraceHull(tbl)
	end

	if not sp and ow:IsPlayer() then
		ow:LagCompensation(false)
	end

	return traceRes
end

function SWEP:SmackDamage(tr, fwd, primary)
	if not tr.Entity:IsValid() then return end
	local dmg, force

	if primary then
		dmg = self:GetStatL("Primary.Damage")
	else
		dmg = self:GetStatL("Secondary.Damage")
	end

	force = dmg * 25
	local dmginfo = DamageInfo()
	dmginfo:SetAttacker(self:GetOwner())
	dmginfo:SetInflictor(self)
	dmginfo:SetDamage(dmg)
	dmginfo:SetDamageType(self.DamageType)
	dmginfo:SetDamagePosition(tr.HitPos)
	dmginfo:SetReportedPosition(tr.StartPos)
	dmginfo:SetDamageForce(fwd * force)
	tr.Entity:DispatchTraceAttack(dmginfo, tr, fwd)
	self:ApplyForce( tr.Entity, dmginfo:GetDamageForce(), tr.HitPos )
end

function SWEP:SmackEffect(tr)
	local vSrc = tr.StartPos
	local bFirstTimePredicted = IsFirstTimePredicted()
	local bHitWater = bit.band(util.PointContents(vSrc), MASK_WATER) ~= 0
	local bEndNotWater = bit.band(util.PointContents(tr.HitPos), MASK_WATER) == 0

	local trSplash = bHitWater and bEndNotWater and util.TraceLine({
		start = tr.HitPos,
		endpos = vSrc,
		mask = MASK_WATER
	}) or not (bHitWater or bEndNotWater) and util.TraceLine({
		start = vSrc,
		endpos = tr.HitPos,
		mask = MASK_WATER
	})

	if (trSplash and bFirstTimePredicted) then
		local data = EffectData()
		data:SetOrigin(trSplash.HitPos)
		data:SetScale(1)

		if (bit.band(util.PointContents(trSplash.HitPos), CONTENTS_SLIME) ~= 0) then
			data:SetFlags(1) --FX_WATER_IN_SLIME
		end

		util.Effect("watersplash", data)
	end

	self:DoImpactEffect(tr, self.DamageType)

	if (tr.Hit and bFirstTimePredicted and not trSplash) then
		local data = EffectData()
		data:SetOrigin(tr.HitPos)
		data:SetStart(vSrc)
		data:SetSurfaceProp(tr.SurfaceProps)
		data:SetDamageType(self.DamageType)
		data:SetHitBox(tr.HitBox)
		data:SetEntity(tr.Entity)
		util.Effect("Impact", data)
	end
end

local tracedata = {}

function SWEP:Slash(bPrimary)
	local ow, gsp, ea, fw, tr, rpm, delay

	if bPrimary == nil then
		bPrimary = true
	end

	ow = self:GetOwner()
	gsp = ow:GetShootPos()
	ea = ow:EyeAngles()
	fw = ea:Forward()
	tracedata.start = gsp
	tracedata.endpos = gsp + fw * (bPrimary and self.Primary_TFA.Length or self.Secondary_TFA.Length)
	tracedata.filter = ow

	tr = self:GetSlashTrace(tracedata, fw)
	rpm = self:GetStatL("Primary.RPM")
	delay = self:GetStatL("Primary.Delay")
	self:SlashSound(tr)
	self:SmackDamage(tr, fw, bPrimary)
	self:SmackEffect(tr, fw, bPrimary)
	self:ScheduleStatus(TFA.Enum.STATUS_SHOOTING, 60 / rpm - delay)
end

function SWEP:CanAttack()
	if not TFA.Enum.ReadyStatus[self:GetStatus()] then return false end
	if CurTime() < self:GetNextPrimaryFire() then return false end
	return true
end

function SWEP:PrimaryAttack()
	if not self:CanAttack() then return end

	if self:GetNextPrimaryFire() < CurTime() and self:GetOwner():IsPlayer() and not self:GetOwner():KeyDown(IN_RELOAD) then
		self.SlashCounter = self.SlashCounter + 1

		if self.SlashCounter > #self.SlashTable then
			self.SlashCounter = 1
		end

		self:SendViewModelSeq(self.SlashTable[self.SlashCounter])

		self:GetOwner():SetAnimation(PLAYER_ATTACK1)
		self:SetNextPrimaryFire(CurTime() + 1 / (self.Primary_TFA.RPM / 60))
		self:SetNextSecondaryFire(CurTime() + 1 / (self.Primary_TFA.RPM / 60))
		self:ScheduleStatus(TFA.Enum.STATUS_KNIFE_SLASH, self.Primary_TFA.Delay)
	end
end

function SWEP:SecondaryAttack()

	if not self:CanAttack() then return end

	local ow, gsp, ea, fw, tr

	ow = self:GetOwner()
	gsp = ow:GetShootPos()
	ea = ow:EyeAngles()
	fw = ea:Forward()
	tracedata.start = gsp
	tracedata.endpos = gsp + fw * self.Secondary_TFA.Length
	tracedata.filter = ow

	tr = self:GetSlashTrace(tracedata, fw)

	if tr.Hit then
		self.StabIndex = self.StabIndex or 0
		self.StabIndex = self.StabIndex + 1

		if self.StabIndex > #self.StabTable then
			self.StabIndex = 1
		end

		self:SendViewModelSeq(self.StabTable[self.StabIndex])
	else
		self.StabMiss = self.StabMiss or 0
		self.StabMiss = self.StabMiss + 1

		if self.StabMiss > #self.StabMissTable then
			self.StabMiss = 1
		end

		self:SendViewModelSeq(self.StabMissTable[self.StabMiss])
	end

	self:GetOwner():SetAnimation(PLAYER_ATTACK1)
	self:SetNextPrimaryFire(CurTime() + 60 / self.Secondary_TFA.RPM)
	self:SetNextSecondaryFire(CurTime() + 60 / self.Secondary_TFA.RPM )
	self:ScheduleStatus(TFA.Enum.STATUS_KNIFE_STAB, self.Secondary_TFA.Delay)
end

function SWEP:ThrowKnife()
	if not IsFirstTimePredicted() then return end
	self:EmitSound(self.Primary_TFA.Sound)

	if SERVER then
		local ent = ents.Create("tfa_thrown_blade")

		if ent:IsValid() then
			ent:SetPos(self:GetOwner():GetShootPos())
			ent:SetAngles(self:GetOwner():EyeAngles())
			ent:SetModel(self.Primary_TFA.ProjectileModel or self.WorldModel)
			ent:SetOwner(self:GetOwner())
			ent:SetPhysicsAttacker(self:GetOwner())
			ent:Spawn()
			ent:Activate()
			ent:SetNW2String("ClassName", self:GetClass())
			local phys = ent:GetPhysicsObject()

			if IsValid(phys) then
				phys:SetVelocity(self:GetOwner():GetAimVector() * 1250)
				phys:AddAngleVelocity(Vector(0, 480, 0))
			end

			self:GetOwner():SetAnimation(PLAYER_ATTACK1)
			self:GetOwner():StripWeapon(self:GetClass())
		end
	end
end

function SWEP:Reload()
	if not self:OwnerIsValid() and self:GetOwner():KeyDown(IN_RELOAD) then return end
	self:ThrowKnife()
end

function SWEP:Think2(...)
	if self:GetStatus() == TFA.Enum.STATUS_KNIFE_STAB and CurTime() > self:GetStatusEnd() then
		self:Slash(false)
	elseif self:GetStatus() == TFA.Enum.STATUS_KNIFE_SLASH and CurTime() > self:GetStatusEnd() then
		self:Slash(true)
	end

	BaseClass.Think2(self, ...)
end

SWEP.IsKnife = true
SWEP.WeaponLength = 8

TFA.FillMissingMetaValues(SWEP)

--PATH lua/weapons/tfa_swsft_base/cl_init.lua:
return gluapack()()
--PATH lua/weapons/tfa_swsft_base_servius/cl_init.lua:
include('shared.lua')

SWEP.PrintName				= ""				// 'Nice' Weapon name (Shown on HUD)	
SWEP.Slot				= 4				// Slot in the weapon selection menu
SWEP.SlotPos				= 1				// Position in the slot
SWEP.DrawAmmo				= true				// Should draw the default HL2 ammo counter				// Should draw the default crosshair
SWEP.DrawWeaponInfoBox			= true			// Should draw the weapon info box
SWEP.BounceWeaponIcon   			= false				// Should the weapon icon bounce?
SWEP.CSMuzzleFlashes			= false


--PATH addons/[bronie] kajdanki/lua/weapons/weapon_cuff_police.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- weapon_cuff_police.lua   SHARED --
--                                 --
-- Strong police handcuffs.        --
-------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_cuff_base"

SWEP.Category = "Handcuffs"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Sturdy police-issue handcuffs."

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.AdminSpawnable = true

SWEP.Slot = 3
SWEP.PrintName = "Police Handcuffs"

//
// Handcuff Vars
SWEP.CuffTime = 1.0 // Seconds to handcuff
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "phoenix_storms/gear"
SWEP.CuffRope = "cable/cable2"
SWEP.CuffStrength = 1.4
SWEP.CuffRegen = 1.4
SWEP.RopeLength = 0
SWEP.CuffReusable = true

SWEP.CuffBlindfold = false
SWEP.CuffGag = false

SWEP.CuffStrengthVariance = 0.1 // Randomise strangth
SWEP.CuffRegenVariance = 0.1 // Randomise regen

--PATH gamemodes/starwarsrp/entities/weapons/weapon_fiveseven2/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.Author = "DarkRP Developers"
    SWEP.Slot = 1
    SWEP.SlotPos = 1
    SWEP.IconLetter = "u"

    killicon.AddFont("weapon_fiveseven2", "CSKillIcons", SWEP.IconLetter, Color(255, 80, 0, 255))
end

SWEP.Base = "weapon_cs_base2"

SWEP.PrintName = "FiveSeven"
SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.Category = "DarkRP (Weapon)"

SWEP.ViewModel = "models/weapons/cstrike/c_pist_fiveseven.mdl"
SWEP.WorldModel = "models/weapons/w_pist_fiveseven.mdl"

SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.HoldType = "pistol"
SWEP.LoweredHoldType = "normal"

SWEP.Primary.Sound = Sound("Weapon_FiveSeven.Single")
SWEP.Primary.Recoil = .5
SWEP.Primary.Damage = 10
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0.03
SWEP.Primary.ClipSize = 21
SWEP.Primary.Delay = 0.05
SWEP.Primary.DefaultClip = 21
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "pistol"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.IronSightsPos = Vector(-5.92, -6.2, 3)
SWEP.IronSightsAng = Vector(-0.5, 0.07, 0)

--PATH gamemodes/starwarsrp/entities/weapons/weapon_keypadchecker/shared.lua:
AddCSLuaFile()

if SERVER then
    AddCSLuaFile("cl_init.lua")

    util.AddNetworkString("DarkRP_keypadData")
end

SWEP.Base = "weapon_base"

SWEP.PrintName = "Admin Keypad Checker"
SWEP.Author = "DarkRP Developers"
SWEP.Instructions = "Left click on a keypad or fading door to check it\nRight click to clear"
SWEP.Slot = 5
SWEP.SlotPos = 1
SWEP.DrawAmmo = false
SWEP.ViewModelFlip = false
SWEP.Primary.ClipSize = 0
SWEP.Primary.Ammo = ""
SWEP.Secondary.Ammo = ""

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "DarkRP (Utility)"

SWEP.HoldType = "normal"
SWEP.ViewModel = Model("models/weapons/c_pistol.mdl")
SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.IconLetter = ""

SWEP.ViewModel = "models/weapons/c_pistol.mdl"
SWEP.UseHands = true

local table_insert = table.insert
local tonumber = tonumber

--[[
    Gets which entities are controlled by which keyboard keys
]]
local function getTargets(keypad, keyPass, keyDenied, delayPass, delayDenied)
    local targets = {}
    local Owner = keypad:CPPIGetOwner()

    for _, v in pairs(numpad.OnDownItems or {}) do
        if v.key == keyPass and v.ply == Owner then
            table_insert(targets, {type = DarkRP.getPhrase("keypad_checker_entering_right_pass"), name = v.name, ent = v.ent, original = keypad})
        end
        if v.key == keyDenied and v.ply == Owner then
            table_insert(targets, {type = DarkRP.getPhrase("keypad_checker_entering_wrong_pass"), name = v.name, ent = v.ent, original = keypad})
        end
    end

    for _, v in pairs(numpad.OnUpItems or {}) do
        if v.key == keyPass and v.ply == Owner then
            table_insert(targets, {type = DarkRP.getPhrase("keypad_checker_after_right_pass"), name = v.name, delay = math.Round(delayPass, 2), ent = v.ent, original = keypad})
        end
        if v.key == keyDenied and v.ply == Owner then
            table_insert(targets, {type = DarkRP.getPhrase("keypad_checker_after_wrong_pass"), name = v.name, delay = math.Round(delayDenied, 2), ent = v.ent, original = keypad})
        end
    end

    return targets
end

--[[---------------------------------------------------------------------------
Get the entities that are affected by the keypad
---------------------------------------------------------------------------]]
local function get_sent_keypad_Info(keypad)
    local keyPass = keypad:GetNWInt("keypad_keygroup1")
    local keyDenied = keypad:GetNWInt("keypad_keygroup2")
    local delayPass = keypad:GetNWInt("keypad_length1")
    local delayDenied = keypad:GetNWInt("keypad_length2")

    return getTargets(keypad, keyPass, keyDenied, delayPass, delayDenied)
end

--[[---------------------------------------------------------------------------
Overload for a different keypad addon
---------------------------------------------------------------------------]]
local function get_keypad_Info(keypad)
    local keyPass = tonumber(keypad.KeypadData.KeyGranted) or 0
    local keyDenied = tonumber(keypad.KeypadData.KeyDenied) or 0
    local delayPass = tonumber(keypad.KeypadData.LengthGranted) or 0
    local delayDenied = tonumber(keypad.KeypadData.LengthDenied) or 0

    return getTargets(keypad, keyPass, keyDenied, delayPass, delayDenied)
end


--[[---------------------------------------------------------------------------
Get the keypads that trigger this entity
---------------------------------------------------------------------------]]
local function getEntityKeypad(ent)
    local targets = {}
    local doorKeys = {} -- The numpad keys that activate this entity
    local entOwner = ent:CPPIGetOwner()

    for _, v in pairs(numpad.OnDownItems or {}) do
        if v.ent == ent then
            table_insert(doorKeys, v.key)
        end
    end

    for _, v in pairs(numpad.OnUpItems or {}) do
        if v.ent == ent then
            table_insert(doorKeys, v.key)
        end
    end

    for _, v in ipairs(ents.FindByClass("sent_keypad")) do
        local vOwner = v:CPPIGetOwner()

        if vOwner == entOwner and table.HasValue(doorKeys, v:GetNWInt("keypad_keygroup1")) then
            table_insert(targets, {type = DarkRP.getPhrase("keypad_checker_right_pass_entered"), ent = v, original = ent})
        end
        if vOwner == entOwner and table.HasValue(doorKeys, v:GetNWInt("keypad_keygroup2")) then
            table_insert(targets, {type = DarkRP.getPhrase("keypad_checker_wrong_pass_entered"), ent = v, original = ent})
        end
    end

    for _, v in ipairs(ents.FindByClass("keypad")) do
        local vOwner = v:CPPIGetOwner()

        if vOwner == entOwner and table.HasValue(doorKeys, tonumber(v.KeypadData.KeyGranted) or 0) then
            table_insert(targets, {type = DarkRP.getPhrase("keypad_checker_right_pass_entered"), ent = v, original = ent})
        end
        if vOwner == entOwner and table.HasValue(doorKeys, tonumber(v.KeypadData.KeyDenied) or 0) then
            table_insert(targets, {type = DarkRP.getPhrase("keypad_checker_wrong_pass_entered"), ent = v, original = ent})
        end
    end

    return targets
end

--[[---------------------------------------------------------------------------
Send the info to the client
---------------------------------------------------------------------------]]
function SWEP:PrimaryAttack()
    self:SetNextPrimaryFire(CurTime() + 0.3)
    if not SERVER then return end

    local Owner = self:GetOwner()
    local trace = Owner:GetEyeTrace()
    if not IsValid(trace.Entity) then return end
    local ent, class = trace.Entity, string.lower(trace.Entity:GetClass() or "")
    local data

    if class == "sent_keypad" then
        data = get_sent_keypad_Info(ent)
        DarkRP.notify(Owner, 1, 4, DarkRP.getPhrase("keypad_checker_controls_x_entities", #data / 2))
    elseif class == "keypad" then
        data = get_keypad_Info(ent)
        DarkRP.notify(Owner, 1, 4, DarkRP.getPhrase("keypad_checker_controls_x_entities", #data / 2))
    else
        data = getEntityKeypad(ent)
        DarkRP.notify(Owner, 1, 4, DarkRP.getPhrase("keypad_checker_controlled_by_x_keypads", #data))
    end

    net.Start("DarkRP_keypadData")
        net.WriteTable(data)
    net.Send(Owner)
end

function SWEP:SecondaryAttack()
end

if not SERVER then return end

--[[---------------------------------------------------------------------------
Registering numpad data
---------------------------------------------------------------------------]]
local oldNumpadUp = numpad.OnUp
local oldNumpadDown = numpad.OnDown

function numpad.OnUp(ply, key, name, ent, ...)
    numpad.OnUpItems = numpad.OnUpItems or {}
    table_insert(numpad.OnUpItems, {ply = ply, key = key, name = name, ent = ent, arg = {...}})

    return oldNumpadUp(ply, key, name, ent, ...)
end

function numpad.OnDown(ply, key, name, ent, ...)
    numpad.OnDownItems = numpad.OnDownItems or {}
    table_insert(numpad.OnDownItems, {ply = ply, key = key, name = name, ent = ent, arg = {...}})

    return oldNumpadDown(ply, key, name, ent, ...)
end

--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs/sh_stance_override.lua:

function SWEP:SetStance( stance )
	if isnumber( stance ) then
		self:SetNWStance( stance )
	else
		self:SetLockedCombo( stance  )
		self:SetNWStance( -1 )
	end
end

function SWEP:GetStance()
	return self:GetNWStance()
end

function SWEP:SetLockedCombo( name )
	local data = LSCS:GetStance( name )

	if data then
		self._lscsLockedCombo = name

		if SERVER then
			net.Start( "lscs_stance_override_networker" )
				net.WriteEntity( self )
				net.WriteString( name )
			net.Broadcast()
		end
	else
		self._lscsLockedCombo = nil
	end
end

if SERVER then
	util.AddNetworkString( "lscs_stance_override_networker" )

	function SWEP:GetLockedCombo()
		return self._lscsLockedCombo or "default"
	end

	net.Receive( "lscs_stance_override_networker", function( len, ply )
		local SWEP = net.ReadEntity()

		if not IsValid( SWEP ) then return end

		net.Start( "lscs_stance_override_networker" )
			net.WriteEntity( SWEP )
			net.WriteString( SWEP:GetLockedCombo() )
		net.Send( ply )
	end )
else
	function SWEP:GetLockedCombo()
		if not self._lscsComboRequested then -- only request once ( for fresh connected players )
			self._lscsComboRequested = true

			net.Start( "lscs_stance_override_networker" )
				net.WriteEntity( self )
			net.SendToServer()
		end

		return self._lscsLockedCombo or "default"
	end

	net.Receive( "lscs_stance_override_networker", function( len )
		local SWEP = net.ReadEntity()

		if not IsValid( SWEP ) then return end

		SWEP:SetLockedCombo( net.ReadString() )
	end )
end

--PATH addons/[miecze] moce i hilty/lua/includes/circles/circles.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_forcepike.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_purgestaff.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category		= "[LSCS]"
SWEP.PrintName	= "Purge Staff"
SWEP.Author		= "BadJay707"
SWEP.Slot		= 0
SWEP.SlotPos 	= 3
SWEP.HoldType = "melee2"
SWEP.Spawnable	= true
SWEP.AdminOnly	= false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("purgestaff") 
		self:SetBladeR("elst") 
	end
end
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_skreejipike.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_spear.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category		= "[LSCS]"
SWEP.PrintName	= "Spear"
SWEP.Author		= "BadJay707"
SWEP.Slot		= 0
SWEP.SlotPos 	= 3
SWEP.HoldType = "melee2"
SWEP.Spawnable	= true
SWEP.AdminOnly	= false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("spear") 
		self:SetBladeR("spearcrys") 
	end
end
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_tusken.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/weapon_mp52/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.Author = "DarkRP Developers"
    SWEP.Slot = 2
    SWEP.SlotPos = 0
    SWEP.IconLetter = "x"

    killicon.AddFont("weapon_mp52", "CSKillIcons", SWEP.IconLetter, Color(255, 80, 0, 255))
end

SWEP.Base = "weapon_cs_base2"

SWEP.PrintName = "MP5"
SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.Category = "DarkRP (Weapon)"

SWEP.ViewModel = "models/weapons/cstrike/c_smg_mp5.mdl"
SWEP.WorldModel = "models/weapons/w_smg_mp5.mdl"

SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.HoldType = "smg"
SWEP.LoweredHoldType = "passive"

SWEP.Primary.Sound = Sound("Weapon_MP5Navy.Single")
SWEP.Primary.Recoil = 0.5
SWEP.Primary.Damage = 15
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0.005
SWEP.Primary.ClipSize = 32
SWEP.Primary.Delay = 0.08
SWEP.Primary.DefaultClip = 32
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.IronSightsPos = Vector(-5.3, -7, 2.1)
SWEP.IronSightsAng = Vector(0.9, 0.1, 0)

--PATH addons/[medic] defib/lua/weapons/weapon_ncs_defib/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_policebaton/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_shield_activator.lua:
return gluapack()()
--PATH lua/weapons/weapon_standardswordart/shared.lua:
if (SERVER) then
	AddCSLuaFile()
end

if (CLIENT) then
	SWEP.Slot = 0
	SWEP.SlotPos = 5
	SWEP.DrawAmmo = false
	SWEP.PrintName = "Standard Sword Art"
	SWEP.DrawCrosshair = true
end


SWEP.ViewModelFOV = 77
SWEP.UseHands = false
SWEP.Category = "Custom Character"
SWEP.Instructions = "do your combo "
SWEP.Purpose = ""
SWEP.Contact = ""
SWEP.Author = "YongLi"
SWEP.ViewModel = "models/weapons/c_pistol.mdl"
SWEP.WorldModel = "models/weapons/charactersword.mdl"
SWEP.AdminSpawnable = false
SWEP.Spawnable = true
SWEP.Primary.NeverRaised = true
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.ClipSize = -1
SWEP.Primary.Damage = 90
SWEP.Primary.Delay = 3
SWEP.Primary.Ammo = ""
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.Delay = 0
SWEP.Secondary.Ammo = ""
SWEP.NoIronSightFovChange = true
SWEP.NoIronSightAttack = true
SWEP.LoweredAngles = Angle(60, 60, 60)
SWEP.IronSightPos = Vector(0, 0, 0)
SWEP.IronSightAng = Vector(0, 0, 0)


local AttackHit2 = Sound( "custom characters/attack_hit2.wav")
local AttackHit1 = Sound( "custom characters/attack_hit.wav")
local Hitground2 = Sound( "custom characters/attack4_hit.mp3")
local Hitground = Sound( "custom characters/sword_crash.wav")
local Ready = Sound( "custom characters/sword_ready.wav")
local Stapout = Sound( "custom characters/sword_stapouthit.wav")
local Stapin = Sound( "custom characters/sword_stabinhit.wav")
local Stap = Sound( "custom characters/sword_stap.wav")
local Cloth = Sound( "custom characters/player_cloth.wav")
local Roll = Sound( "npc/combine_soldier/gear2.wav")
local Combo1 = Sound( "custom characters/sword_swim1.wav")
local Combo2 = Sound( "custom characters/sword_swim2.wav")
local Combo3 = Sound( "custom characters/sword_swim3.wav")
local Combo4 = Sound( "custom characters/sword_swim4.wav")
local SwordTrail = Sound ( "custom characters/sword_trail.mp3" )

function SWEP:Deploy()
	self.Owner:ConCommand( "thirdperson_etp 1" )
		hook.Add("GetFallDamage", "RemoveFallDamage"..self.Owner:GetName(), function(ply, speed)
			if( GetConVarNumber( "mp_falldamage" ) > 0 ) then
				return ( speed - 826.5 ) * ( 100 / 896 )
			end
			
			return 0
		end)

end


function SWEP:Initialize()
	self.combo = 11
	self:SetHoldType("g_combo1")
	self.duringattack = false
	self.backtime = 0
	self.duringattacktime = 0
	self.dodgetime = 0
	self.plyindirction = false
	self.npcfreezetime = 0
	self.DownSlashed = true
	self.downslashingdelay = 0
	self.back = true
end

function SWEP:DoAnimation( anim1 )
self:SetHoldType(anim1)
self.Owner:SetAnimation(PLAYER_ATTACK1)
end
  
 
  
function SWEP:Think()
local ply = self.Owner
--====================--
if self.Owner:KeyDown( IN_WALK ) and self.Owner:KeyDown( IN_ATTACK ) and self.duringattack == true and self.Owner:KeyDown( IN_FORWARD ) then
if IsValid(self) and self.Owner:IsOnGround() then
self:LeapAttack()
end
end

--====================--
if self.Owner:KeyDown( IN_WALK ) and self.Owner:KeyDown( IN_ATTACK ) and self.duringattack == true and self.Owner:KeyDown( IN_BACK ) then
if IsValid(self) and self.Owner:IsOnGround() then
self:SlashUp()
end
end

--====================--

if self.Owner:KeyDown( IN_WALK ) and self.Owner:KeyDown( IN_ATTACK ) and self.duringattack == true and self.Owner:KeyDown( IN_BACK ) then
if IsValid(self) and not self.Owner:IsOnGround() then
self:SlashDown()
end
end

--====================--
if self.Owner:KeyDown( IN_JUMP ) or self.Owner:KeyDown( IN_FORWARD ) or self.Owner:KeyDown( IN_BACK ) or
 self.Owner:KeyDown( IN_MOVELEFT ) or self.Owner:KeyDown( IN_MOVERIGHT ) then
 self.plyindirction = true
 else
 self.plyindirction = false
end

if self.duringattacktime < CurTime() then
self.duringattack = true
elseif self.duringattacktime > CurTime() then
self.duringattack = false
end

if self.duringattack == true then
self.Owner:SetWalkSpeed( 250 )
self.Owner:SetRunSpeed( 450 )
self.Owner:SetJumpPower(300)
self.Owner:SetSlowWalkSpeed( 120 )
elseif self.duringattack == false  then
self.Owner:SetWalkSpeed( 7 )
self.Owner:SetSlowWalkSpeed( 10 )
self.Owner:SetJumpPower(50)
self.Owner:SetRunSpeed( 200 )
end 

--==============================--
if self.Owner:KeyDown( IN_WALK ) and self.duringattack == true and not self.Owner:KeyDown( IN_ATTACK ) and self.Owner:KeyDown( IN_JUMP ) and CurTime() > self.dodgetime then
self.Owner:SetRunSpeed( 100 )
self.Owner:SetJumpPower(300)
if self.Owner:KeyDown( IN_MOVELEFT ) then
if SERVER then
self.Owner:EmitSound(Roll)
end
self:SetHoldType("g_rollleft")
self.Owner:SetAnimation(PLAYER_ATTACK1)
self.dodgetime = CurTime() + 1.3
self.Owner:SetVelocity((self.Owner:GetRight() * -1) * 400 - Vector(0,0,200))	
self.Weapon:SetNextPrimaryFire(CurTime() + 1.3 )
elseif self.Owner:KeyDown( IN_MOVERIGHT ) then
if SERVER then
self.Owner:EmitSound(Roll)
end
self:SetHoldType("g_rollright")
self.Owner:SetAnimation(PLAYER_ATTACK1)
self.dodgetime = CurTime() + 1.4
self.Owner:SetVelocity((self.Owner:GetRight() * 1) * 400 - Vector(0,0,200))	
self.Weapon:SetNextPrimaryFire(CurTime() + 1.3 )
elseif self.Owner:KeyDown( IN_BACK ) then
if SERVER then
self.Owner:EmitSound(Roll)
end
self:SetHoldType("g_rollback")
self.Owner:SetAnimation(PLAYER_ATTACK1)
self.dodgetime = CurTime() + 1.6
self.Owner:SetVelocity(Vector(0,0,100))	
self.Weapon:SetNextPrimaryFire(CurTime() + 1.3 )
end

self.duringattacktime = CurTime() + 0.76
self.back = false
end

--==============================--


if ply:IsOnGround() and self.DownSlashed == false then
self:FinialDownSlash()
if SERVER then
ply:EmitSound(Hitground)
ply:EmitSound(Hitground2)
end
ParticleEffect("blood_impact_synth_01",self.Owner:GetPos() + self.Owner:GetForward() * 0 + Vector( 0, 0, 20 ),Angle(0,45,0),nil)
end

if ply:IsOnGround() then
self.DownSlashed = true
end


if not ply:IsOnGround() and self.DownSlashed == false then
if self.downslashingdelay < CurTime() then
self.downslashingdelay = CurTime() + 0.05
self:DownSlashing()
end
end

--==============================--
if  self.duringattacktime == CurTime() then
self.back = true
end

if  self.duringattacktime < CurTime() and self.back == false and self.Owner:IsOnGround() and self.plyindirction == true then
self.back = true
self:SetHoldType("g_restart")
ply:SetAnimation( PLAYER_ATTACK1 )
end
end
SWEP.SlashUph = false
SWEP.enemystuntime = 0
--==================--
function SWEP:LeapAttack()
self.combo = 0
self.Owner:ViewPunch(Angle(3, 4, 3))
self.Weapon:SetNextPrimaryFire(CurTime() + 1.2 )
self.back = false
local ply = self.Owner
self:SetHoldType("leap")
ply:SetAnimation( PLAYER_ATTACK1 )
if SERVER then
ply:EmitSound(Ready)
ply:EmitSound(Cloth)
end
self.duringattack = true
self.duringattacktime = CurTime() + 1
self.dodgetime = CurTime() + 1.2
ply:SetVelocity((self.Owner:GetForward() * 1) * 1 + Vector(0,0,200) )	
timer.Simple(0.05, function()
ply:SetVelocity((self.Owner:GetForward() * 1) * 10100 + Vector(0,0,-100) )
end)
timer.Simple(0.3, function() 
self:SetHoldType("leapattack")
ply:SetAnimation( PLAYER_ATTACK1 )
if SERVER then
ply:EmitSound(Hitground)
end
self.Owner:ViewPunch(Angle(-6, -5, 0))
self.combo = 11
if SERVER then
ply:EmitSound(Combo2)
ply:EmitSound(SwordTrail)
end
		local k, v
		local dmg = DamageInfo()
			dmg:SetDamage( 43 ) 
			dmg:SetDamageType(DMG_SLASH)
			dmg:SetAttacker(self.Owner) 
			dmg:SetInflictor(self.Owner)
		for k, v in pairs ( ents.FindInSphere( self.Owner:GetPos() +  Vector(0,0,40) + (self.Owner:GetForward() * 1) * 50, 140 ) ) do 
			if v:IsValid() and self.Owner:Alive() and  v != self.Owner then
			if v:IsNPC() then	--
			if SERVER then
			v:SetCondition( 67 )
			v:EmitSound(AttackHit2)
			timer.Simple(2.3, function()
			if IsValid(v) then 
			v:SetCondition( 68 )
			end
			end)			
			v:SetVelocity((self.Owner:GetForward() * 1) * 120 + Vector(0,0,50) )	
			ParticleEffect("blood_advisor_puncture",v:GetPos() + v:GetForward() * 0 + Vector( 0, 0, 40 ),Angle(0,45,0),nil)
			end
			end
			if v:IsPlayer() then --
			v:Freeze( true )
			v:EmitSound(AttackHit2)
			timer.Simple(2, function()
			if IsValid(v) then 
			v:Freeze( false )
			end
			end)			
			v:SetVelocity((self.Owner:GetForward() * 1) * 120 + Vector(0,0,50) )	
			ParticleEffect("blood_advisor_puncture",v:GetPos() + v:GetForward() * 0 + Vector( 0, 0, 40 ),Angle(0,45,0),nil)
			end
				dmg:SetDamageForce( ( v:GetPos() - self.Owner:GetPos() ):GetNormalized() * 100 )
				if SERVER then
				v:TakeDamageInfo( dmg )
				end
			end	
		end	
end)
end


--==================--
function SWEP:FinialDownSlash()
self.duringattacktime = CurTime() + 0.5
self.back = false
if IsValid(self.Owner) then
		local k, v
		local dmg = DamageInfo()
			dmg:SetDamage(45)
			dmg:SetDamageType(DMG_SLASH)
			dmg:SetAttacker(self.Owner)
			dmg:SetInflictor(self.Owner)
		
		for k, v in pairs ( ents.FindInSphere( self.Owner:GetPos() +  Vector(0,0,10) + (self.Owner:GetForward() * 1) * 50, 120 ) ) do
			if v:IsValid() and v != self.Owner then
				dmg:SetDamageForce( ( v:GetPos() - self.Owner:GetPos() ):GetNormalized() * 100 )
				if SERVER then
				v:TakeDamageInfo( dmg )
				end
				if v:IsNPC() or v:IsPlayer() then
				v:EmitSound(Stapout)
				ParticleEffect("blood_advisor_puncture_withdraw",v:GetPos() + v:GetForward() * 0 + Vector( 0, 0, 40 ),Angle(0,45,0),nil)
				end	
			end
		end
	end
end

function SWEP:DownSlashing()
if IsValid(self.Owner) then
		local k, v
		local dmg = DamageInfo()
			dmg:SetDamage(10)
			dmg:SetDamageType(DMG_SLASH)
			dmg:SetAttacker(self.Owner)
			dmg:SetInflictor(self.Owner)
		
		for k, v in pairs ( ents.FindInSphere( self.Owner:GetPos() +  Vector(0,0,10) + (self.Owner:GetForward() * 1) * 50, 120 ) ) do
			if v:IsValid() and v != self.Owner then
				dmg:SetDamageForce( ( v:GetPos() - self.Owner:GetPos() ):GetNormalized() * 100 )
				if SERVER then
				v:TakeDamageInfo( dmg )
				end
				if v:IsNPC() or v:IsPlayer() then
				ParticleEffect("blood_advisor_puncture",v:GetPos() + v:GetForward() * 0 + Vector( 0, 0, 40 ),Angle(0,45,0),nil)
				end	
			end
		end
	end
end

--==================--
function SWEP:SlashDown()
local ply = self.Owner
self.combo = 0
self.Owner:ViewPunch(Angle(-4, 4, 6))
if SERVER then
ply:EmitSound(Ready)
ply:EmitSound(Cloth)
end
if self.Owner:IsOnGround() then	
	local k, v
	v:TakeDamageInfo( dmg )
		local dmg = DamageInfo()
			dmg:SetDamage( 15 ) 
			dmg:SetDamageType(DMG_SLASH)
			dmg:SetAttacker(self.Owner) 
			dmg:SetInflictor(self.Owner)
		for k, v in pairs ( ents.FindInSphere( self.Owner:GetPos() +  Vector(0,0,10) + (self.Owner:GetForward() * 1) * 50, 120 ) ) do 
			if v:IsValid() and self.Owner:Alive() and  v != self.Owner then
			if v:IsNPC() then	
			if SERVER then
			v:EmitSound(AttackHit1)
			v:SetCondition( 67 )
			timer.Simple(3, function()
			if IsValid(v) then 
			v:SetCondition( 68 )
			end
			end)			
			v:SetVelocity((self.Owner:GetForward() * 1) * 300 + Vector(0,0,500) )	
			ParticleEffect("blood_advisor_puncture",v:GetPos() + v:GetForward() * 0 + Vector( 0, 0, 40 ),Angle(0,45,0),nil)
			end
			end
			if v:IsPlayer() then
			v:EmitSound(AttackHit1)
			v:Freeze( true )
			timer.Simple(2, function()
			if IsValid(v) then 
			v:Freeze( false )
			end
			end)			
			v:SetVelocity((self.Owner:GetForward() * 1) * 300 + Vector(0,0,500) )	
			ParticleEffect("blood_advisor_puncture",v:GetPos() + v:GetForward() * 0 + Vector( 0, 0, 40 ),Angle(0,45,0),nil)
			end
				dmg:SetDamageForce( ( v:GetPos() - self.Owner:GetPos() ):GetNormalized() * 100 )
				if SERVER then
				v:TakeDamageInfo( dmg )
				end
			end	
		end	

end
self.Weapon:SetNextPrimaryFire(CurTime() + 0.7 )
local ply = self.Owner
self:SetHoldType("slashdown")
ply:SetAnimation( PLAYER_ATTACK1 )
self.duringattack = true
self.duringattacktime = CurTime() + 0.7
self.dodgetime = CurTime() + 1
		local pl = self.Owner
		local ang = pl:GetAngles()
		local forward, right = ang:Forward(), ang:Right()
		
		local vel = -1 * pl:GetVelocity() -- Nullify current velocity
		vel = vel + Vector(0, 0, 300) -- Add vertical force
		
		local spd = pl:GetMaxSpeed()
		
		if pl:KeyDown(IN_FORWARD) then
			vel = vel + forward * spd
		elseif pl:KeyDown(IN_BACK) then
			vel = vel - forward * spd
		end
		
		if pl:KeyDown(IN_MOVERIGHT) then
			vel = vel + right * spd
		elseif pl:KeyDown(IN_MOVELEFT) then
			vel = vel - right * spd
		end
		
		pl:SetVelocity(vel) 

timer.Simple(0.4, function() 
if SERVER then
ply:EmitSound(Cloth)
end
self.combo = 11
self.DownSlashed = false
self.Owner:ViewPunch(Angle(4, -1, 0))
		local pl = self.Owner
		local ang = pl:GetAngles()
		local forward, right = ang:Forward(), ang:Right()
		
		local vel = -1 * pl:GetVelocity() -- Nullify current velocity
		vel = vel + Vector(0, 0, -2500) -- Add vertical force
		
		local spd = pl:GetMaxSpeed()
		
		if pl:KeyDown(IN_FORWARD) then
			vel = vel + forward * spd
		elseif pl:KeyDown(IN_BACK) then
			vel = vel - forward * spd
		end
		
		if pl:KeyDown(IN_MOVERIGHT) then
			vel = vel + right * spd
		elseif pl:KeyDown(IN_MOVELEFT) then
			vel = vel - right * spd
		end
		
		pl:SetVelocity(vel)
end)
timer.Simple(0.3, function() 
if SERVER then
ply:EmitSound(Combo2)
ply:EmitSound(SwordTrail)
end
		local k, v
		local dmg = DamageInfo()
			dmg:SetDamage( 15 ) 
			dmg:SetDamageType(DMG_SLASH)
			dmg:SetAttacker(self.Owner) 
			dmg:SetInflictor(self.Owner)
		for k, v in pairs ( ents.FindInSphere( self.Owner:GetPos() + (self.Owner:GetForward() * 1) * 50, 120 ) ) do 
			if v:IsValid() and self.Owner:Alive() and  v != self.Owner then
			if v:IsNPC() then		
			if SERVER then
			v:SetCondition( 67 )
			timer.Simple(3, function()
			if IsValid(v) then 
			v:SetCondition( 68 )
			end
			end)
			v:SetVelocity((self.Owner:GetForward() * 1) * 1 + Vector(0,0,-2500) + (ply:GetForward() * 1) * 700 )	
			ParticleEffect("blood_advisor_puncture",v:GetPos() + v:GetForward() * 0 + Vector( 0, 0, 40 ),Angle(0,45,0),nil)
			end
			end
			if v:IsPlayer() then
			v:Freeze( true )
			timer.Simple(2, function()
			if IsValid(v) then 
			v:Freeze( false )
			end
			end)			
			v:SetVelocity((self.Owner:GetForward() * 1) * 1 + Vector(0,0,-2500) + (ply:GetForward() * 1) * 700 )	
			ParticleEffect("blood_advisor_puncture",v:GetPos() + v:GetForward() * 0 + Vector( 0, 0, 40 ),Angle(0,45,0),nil)
			end
			dmg:SetDamageForce( ( v:GetPos() - self.Owner:GetPos() ):GetNormalized() * 100 )
				if SERVER then
				v:TakeDamageInfo( dmg )
				end
			end	
		end	
end)
end

function SWEP:SlashUp()
self.combo = 0
self.back = false
if SERVER then
self.Owner:EmitSound(Ready)
end
self.SlashUph = false
self.Owner:ViewPunch(Angle(3, 2, 3))
self.Weapon:SetNextSecondaryFire(CurTime() + 0.7 )
self.Weapon:SetNextPrimaryFire(CurTime() + 0.7 )
local ply = self.Owner
self:SetHoldType("slashready")
ply:SetAnimation( PLAYER_ATTACK1 )
self.duringattack = true
self.duringattacktime = CurTime() + 0.7
self.dodgetime = CurTime() + 1
timer.Simple(0.2, function() 
ParticleEffect("blood_impact_synth_01",self.Owner:GetPos() + self.Owner:GetForward() * 0 + Vector( 0, 0, 20 ),Angle(0,45,0),nil)
if SERVER then
ply:EmitSound(Hitground)
ply:EmitSound(Cloth)
end
self.Owner:ViewPunch(Angle(-6, -2, 0))
self.combo = 11
if SERVER then
ply:EmitSound(Combo2)
ply:EmitSound(SwordTrail)
end
if self.Owner:KeyDown( IN_ATTACK ) or self.Owner:KeyDown( IN_ATTACK2 ) then
self:SetHoldType("slashuph")
self.SlashUph = true
		local pl = self.Owner
		local ang = pl:GetAngles()
		local forward, right = ang:Forward(), ang:Right()
		
		local vel = -1 * pl:GetVelocity() -- Nullify current velocity
		vel = vel + Vector(0, 0, 450) -- Add vertical force
		
		local spd = pl:GetMaxSpeed()
		
		if pl:KeyDown(IN_FORWARD) then
			vel = vel + forward * spd
		elseif pl:KeyDown(IN_BACK) then
			vel = vel - forward * spd
		end
		
		if pl:KeyDown(IN_MOVERIGHT) then
			vel = vel + right * spd
		elseif pl:KeyDown(IN_MOVELEFT) then
			vel = vel - right * spd
		end
		
		pl:SetVelocity(vel) 
	
else
self:SetHoldType("slashup")
end
		local k, v
		local dmg = DamageInfo()
			dmg:SetDamage( 20 ) 
			dmg:SetDamageType(DMG_SLASH)
			dmg:SetAttacker(self.Owner) 
			dmg:SetInflictor(self.Owner)
		for k, v in pairs ( ents.FindInSphere( self.Owner:GetPos() +  Vector(0,0,40) + (self.Owner:GetForward() * 1) * 50, 120 ) ) do 
			if v:IsValid() and self.Owner:Alive() and  v != self.Owner then
			if v:IsNPC() then	--
			if SERVER then
			v:SetCondition( 67 )
			v:EmitSound(AttackHit2)
			timer.Simple(2.3, function()
			if IsValid(v) then 
			v:SetCondition( 68 )
			end
			end)			
			v:SetVelocity((self.Owner:GetForward() * 1) * 1 + Vector(0,0,400) )	
			ParticleEffect("blood_advisor_puncture",v:GetPos() + v:GetForward() * 0 + Vector( 0, 0, 40 ),Angle(0,45,0),nil)
			end
			end
			if v:IsPlayer() then --
			v:Freeze( true )
			v:EmitSound(AttackHit2)
			timer.Simple(2, function()
			if IsValid(v) then 
			v:Freeze( false )
			end
			end)			
			v:SetVelocity((self.Owner:GetForward() * 1) * 1 + Vector(0,0,400) )	
			ParticleEffect("blood_advisor_puncture",v:GetPos() + v:GetForward() * 0 + Vector( 0, 0, 40 ),Angle(0,45,0),nil)
			end
				dmg:SetDamageForce( ( v:GetPos() - self.Owner:GetPos() ):GetNormalized() * 100 )
				if SERVER then
				v:TakeDamageInfo( dmg )
				end
			end	
		end	
ply:SetAnimation( PLAYER_ATTACK1 )
end)
end
	
function SWEP:KillMove()
self.Weapon:SetNextPrimaryFire(CurTime() + 1.3 )
local ply = self.Owner
self:SetHoldType("g_combo32")
ply:SetAnimation( PLAYER_ATTACK1 )
self.duringattack = true
self.duringattacktime = CurTime() + 1.2
self.dodgetime = CurTime() + 1.3
self.Owner:ViewPunch(Angle(5, 1, 0))
timer.Simple(0.2, function() 
ply:SetVelocity((self.Owner:GetForward() * 1) * 500 + Vector(0,0,50) )	
ply:EmitSound(Combo2)
		local k, v
		local dmg = DamageInfo()
			dmg:SetDamage( 1 ) 
			dmg:SetDamageType(DMG_SLASH)
			dmg:SetAttacker(self.Owner) 
			dmg:SetInflictor(self.Owner)
		for k, v in pairs ( ents.FindInSphere( self.Owner:GetPos() +  Vector(0,0,40) + (self.Owner:GetForward() * 1) * 50, 120 ) ) do 
			if v:IsValid() and self.Owner:Alive() and  v != self.Owner then
			ply:EmitSound(Stap)
			if v:IsNPC() then	--
			if SERVER then
			v:EmitSound(Stapin)			
			v:SetCondition( 67 )
			timer.Simple(3, function()
			if IsValid(v) then 
			v:SetCondition( 68 )
			end
			end)			
			v:SetVelocity((self.Owner:GetForward() * 1) * 100  )	
			ParticleEffect("blood_advisor_puncture",v:GetPos() + v:GetForward() * 0 + Vector( 0, 0, 40 ),Angle(0,45,0),nil)
			end
			end
			if v:IsPlayer() then--
			v:EmitSound(Stapin)			
			v:Freeze( true )
			timer.Simple(3, function()
			if IsValid(v) then 
			v:Freeze( false )
			end
			end)			
			v:SetVelocity((self.Owner:GetForward() * 1) * 100 )	
			ParticleEffect("blood_advisor_puncture",v:GetPos() + v:GetForward() * 0 + Vector( 0, 0, 40 ),Angle(0,45,0),nil)
			end
				dmg:SetDamageForce( ( v:GetPos() - self.Owner:GetPos() ):GetNormalized() * 100 )
				if SERVER then
				v:TakeDamageInfo( dmg )
				end
			end	
		end	
end)

timer.Simple(0.75, function() 
ply:SetVelocity((self.Owner:GetForward() * 1) * -400 + Vector(0,0,50) )	
ply:EmitSound(Combo3)
ply:EmitSound(Stap)
self.Owner:ViewPunch(Angle(-5, -1, 0))
		local k, v
		local dmg = DamageInfo()
			dmg:SetDamage( 80 ) 
			dmg:SetDamageType(DMG_SLASH)
			dmg:SetAttacker(self.Owner) 
			dmg:SetInflictor(self.Owner)
		for k, v in pairs ( ents.FindInSphere( self.Owner:GetPos() +  Vector(0,0,40) + (self.Owner:GetForward() * 1) * 50, 150 ) ) do 
			if v:IsValid() and self.Owner:Alive() and  v != self.Owner then
			if v:IsNPC() then--
			if SERVER then
			v:SetCondition( 67 )
			v:EmitSound(Stapout)			
			timer.Simple(2, function()
			if IsValid(v) then 
			v:SetCondition( 68 )
			end
			end)			
			v:SetVelocity((self.Owner:GetForward() * 1) * 100  )	
			ParticleEffect("blood_advisor_puncture_withdraw",v:GetPos() + v:GetForward() * 0 + Vector( 0, 0, 40 ),Angle(0,45,0),nil)
			end
			end
			if v:IsPlayer() then--
			v:Freeze( true )
			v:EmitSound(Stapout)
			timer.Simple(2, function()
			if IsValid(v) then 
			v:Freeze( false )
			end
			end)			
			v:SetVelocity((self.Owner:GetForward() * 1) * 100 )	
			ParticleEffect("blood_advisor_puncture_withdraw",v:GetPos() + v:GetForward() * 0 + Vector( 0, 0, 40 ),Angle(0,45,0),nil)
			end
				dmg:SetDamageForce( ( v:GetPos() - self.Owner:GetPos() ):GetNormalized() * 100 )
				if SERVER then
				v:TakeDamageInfo( dmg )
				end
			end	
		end	
end)
end

--==================--
function SWEP:DoCombo( hitsound, combonumber, force, freezetime, attackdelay, anim, viewbob, primarystuntime, stuntime, sound, sounddelay, hastrail, haspush, push, pushdelay, aircombo ,pushenemy)
	local ply = self.Owner
	self.back = false
	self.combo = combonumber
	self:SetHoldType(anim)
	ply:ViewPunch(viewbob)
	self.backtime = CurTime() + stuntime
	if haspush == true then
	timer.Simple(pushdelay, function()
	ply:SetVelocity((self.Owner:GetForward() * 1) * push + Vector(0,0,50) )	
	end)
	end
	timer.Simple(sounddelay, function() 
	ply:EmitSound(sound)
	if hastrail == true then
	ply:EmitSound(SwordTrail)
	end
	end)
	self.dodgetime = CurTime() + primarystuntime
	ply:SetAnimation( PLAYER_ATTACK1 )
	self.duringattack = true
	self.duringattacktime = CurTime() + stuntime
	self.Weapon:SetNextPrimaryFire(CurTime() + primarystuntime )
	if aircombo == true then
		local pl = self.Owner
		local ang = pl:GetAngles()
		local forward, right = ang:Forward(), ang:Right()
		
		local vel = -1 * pl:GetVelocity() -- Nullify current velocity
		vel = vel + Vector(0, 0, 240) -- Add vertical force
		
		local spd = pl:GetMaxSpeed()
		
		if pl:KeyDown(IN_FORWARD) then
			vel = vel + forward * spd
		elseif pl:KeyDown(IN_BACK) then
			vel = vel - forward * spd
		end
		
		if pl:KeyDown(IN_MOVERIGHT) then
			vel = vel + right * spd
		elseif pl:KeyDown(IN_MOVELEFT) then
			vel = vel - right * spd
		end
		
		pl:SetVelocity(vel) 
	end

	timer.Simple(attackdelay, function()
		local k, v
		local dmg = DamageInfo()
			dmg:SetDamage( force ) 
			dmg:SetDamageType(DMG_SLASH)
			dmg:SetAttacker(self.Owner) 
			dmg:SetInflictor(self.Owner)
		for k, v in pairs ( ents.FindInSphere( self.Owner:GetPos() +  Vector(0,0,40) + (self.Owner:GetForward() * 1) * 50, 120 ) ) do 
			if v:IsValid() and self.Owner:Alive() and  v != self.Owner then
			if v:IsNPC() then --===============================--
			if SERVER then
			v:SetCondition( 67 )
			v:EmitSound(hitsound)
			timer.Simple(freezetime, function()
			self:Think(v)
			if self.combo != 14 and self.combo != 24 then
			if IsValid(v) and self.combo == 11 then 
			v:SetCondition( 68 )
			end
			if IsValid(v) and self.combo == combonumber + 1 then 
			v:SetCondition( 68 )
			end
			end
			end)
			v:TakeDamageInfo( dmg )	ParticleEffect("blood_advisor_puncture",v:GetPos() + v:GetForward() * 0 + Vector( 0, 0, 40 ),Angle(0,45,0),nil)
			if aircombo == true then
			
		local ang = v:GetAngles()
		local forward, right = ang:Forward(), ang:Right()
		
		local vel = -1 * v:GetVelocity() -- Nullify current velocity
		vel = vel + Vector(0, 0, 220) -- Add vertical force
		
		
		v:SetVelocity(vel) 
			end
			
			end
			end
	--========================================================--
			if v:IsPlayer() then
			v:Freeze( true )
			v:EmitSound(hitsound)
			timer.Simple(freezetime, function()
			if self.combo != 14 and self.combo != 24 then
			if IsValid(v) and self.combo == 11 then 
			v:Freeze( false )
			end
			if IsValid(v) and self.combo == combonumber + 1 then 
			v:Freeze( false )
			end
			end
			end)
			v:TakeDamageInfo( dmg )	ParticleEffect("blood_advisor_puncture",v:GetPos() + v:GetForward() * 0 + Vector( 0, 0, 40 ),Angle(0,45,0),nil)
			if aircombo == true then
			
		local ang = v:GetAngles()
		local forward, right = ang:Forward(), ang:Right()
		
		local vel = -1 * v:GetVelocity() -- Nullify current velocity
		vel = vel + Vector(0, 0, 220) -- Add vertical force
		
		
		v:SetVelocity(vel) 
			end
			
			end
			if pushenemy == true then
			v:SetVelocity((ply:GetForward() * 10) * 2700 + Vector(0,0,300) )			
			end
				dmg:SetDamageForce( ( v:GetPos() - self.Owner:GetPos() ):GetNormalized() * 100 )
				if SERVER then
				v:TakeDamageInfo( dmg )
				end
			end	
		end
	end)
end

function SWEP:PrimaryAttack()
self.Weapon:SetNextSecondaryFire(CurTime() + 0.6 )
if self.combo == 0 then
return end

if self.Owner:KeyDown(IN_WALK) and self.Owner:KeyDown(IN_ATTACK) and (self.Owner:KeyDown(IN_BACK) or self.Owner:KeyDown(IN_FORWARD)) then
else
if self.Owner:IsOnGround() then
if self.combo == 11 then
	self:DoCombo( AttackHit1, 11, 22, 1.2, 0.16, "g_combo1", Angle(3, -3, 0),0.3, 0.7, Combo1, 0.14, false, true, 150, 0.2 )
	self.combo = 12
timer.Simple(1, function()
	if self.combo == 12 then
	self.combo = 11 
	end
end)
elseif self.combo == 12 then
	self:DoCombo( AttackHit2, 12, 23, 1.2, 0.15, "g_combo2", Angle(1, 3, 0), 0.4, 0.8, Combo4, 0.12, false, true, 230, 0.2 )
	self.combo = 13
timer.Simple(1, function()
	if self.combo == 13 then
	self.combo = 11
	end
end)
elseif self.combo == 13 then
	self:DoCombo( AttackHit1, 13, 26, 1.2,  0.17, "g_combo3", Angle(-2, -3, 0),0.3, 0.9, Combo2, 0.17, false, true, 300, 0.2 )
	self.combo = 14
timer.Simple(0.8, function()
	if self.combo == 14 then
	self.combo = 15
	timer.Simple(0.7, function()
	if self.combo == 15 then
	self.combo = 11
	end
	end)
	end
end)
elseif self.combo == 14 then
self.Owner:EmitSound(Ready)
	self:DoCombo( Stapout, 14, 57, 2.7, 0.4, "g_combo4", Angle(3, -5, 0), 1.3, 1.2, Combo3, 0.4, true, true, 600, 0.3, false, true )
	self.combo = 11
	self.Owner:EmitSound(Cloth)
elseif self.combo == 15 then
self:KillMove()
self.combo = 14
timer.Simple(1.8, function()
	if self.combo == 14 then
	self.combo = 11
	end
end)
end
end
if not self.Owner:IsOnGround() then
if self.combo == 11 then
	self:DoCombo( AttackHit2, 21, 22, 1.2, 0.16, "a_combo1", Angle(3, -3, 0), 0.25, 0.7, Combo1, 0.14, false, false, 150, 0.2 , true)
	self.combo = 12
timer.Simple(1, function()
	if self.combo == 12 then
	self.combo = 11 
	end
end)
elseif self.combo == 12 then
	self:DoCombo( AttackHit1, 22, 22, 1.2, 0.15, "a_combo2", Angle(-2, 3, 0), 0.25, 0.8, Combo4, 0.12, false, false, 230, 0.2, true )
	self.combo = 13
timer.Simple(1, function()
	if self.combo == 13 then
	self.combo = 11
	end
end)
elseif self.combo == 13 then
	self:DoCombo( AttackHit1, 23, 23, 1.2, 0.15, "a_combo3", Angle(1, 3, 0), 0.32, 0.8, Combo2, 0.12, false, false, 230, 0.2, true )
	self.combo = 14
timer.Simple(1, function()
	if self.combo == 14 then
	self.combo = 11
	end
end)
elseif self.combo == 14 then
	self:SlashDown()
	self.combo = 11
end
end
end
end

 
function SWEP:SecondaryAttack()
if not self.Owner:IsOnGround() then
self:SlashDown()
self.Weapon:SetNextSecondaryFire(CurTime() + 0.8 )
else
if self.Owner:KeyDown( IN_FORWARD ) then
self:LeapAttack()
self.Weapon:SetNextSecondaryFire(CurTime() + 1.3 )
else self.Owner:KeyDown( IN_BACK )
self:SlashUp()
self.Weapon:SetNextSecondaryFire(CurTime() + 0.8 )
end
end
end

function SWEP:Holster()
self.duringattack = true
self.Owner:SetWalkSpeed( 250 )
self.Owner:SetRunSpeed( 450 )
self.Owner:SetJumpPower(300)
self.Owner:SetSlowWalkSpeed( 120 )
self.combo = 11
self.DownSlashed = true
return true
end

function SWEP:Reload()
if self.Owner:KeyDown( IN_ATTACK ) or self.Owner:KeyDown( IN_ATTACK2 ) then
else
self:SetHoldType("rollsword")
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end
end


--PATH lua/weapons/weapon_swsft_base/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_vj_9mmpistol/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_vj_base/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_vj_base/ai_translations.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

-- !!! USED ONLY FOR HL2 NPCS, NOT VJ NPCS !!!
function SWEP:SetupWeaponHoldTypeForAI(hType)
	if self:GetOwner().IsVJBaseSNPC_Human == true then return end
	
	-- Yete NPC-en Rebel-e, ere vor medz zenki animation-ere kordzadze yerp vor ge kalegor
	local bezdigZenk_Kalel = ACT_WALK_AIM_PISTOL
	local bezdigZenk_Vazel = ACT_RUN_AIM_PISTOL
	if self.NPC_AnimationSet == "Rebel" then
		bezdigZenk_Kalel = ACT_WALK_AIM_RIFLE
		bezdigZenk_Vazel = ACT_RUN_AIM_RIFLE
	end
	
	-- Yete NPC-en Combine-e yev bizdig zenk pernere, ere vor medz zenki animation-ere kordzadze
	local rifleOverride = false
	local medzZenk_Genal = ACT_IDLE_SMG1
	local medzZenk_Kalel = ACT_WALK_RIFLE
	if self.NPC_AnimationSet == "Combine" && (hType == "pistol" or hType == "revolver") then
		rifleOverride = true
		medzZenk_Genal = VJ_SequenceToActivity(self:GetOwner(),"idle_unarmed")
		medzZenk_Kalel = VJ_SequenceToActivity(self:GetOwner(),"walkunarmed_all")
	end
	
	-- Yete NPC-en Metrocop-e gamal Rebel-e, ere vor medz zenki animation-ere kordzadze yerp vor ge kalegor
	local bonbakshen_varichadz = ACT_RANGE_ATTACK_SHOTGUN_LOW
	local bonbakshen_Vazel = ACT_RUN_AIM_SHOTGUN
	if self.NPC_AnimationSet == "Metrocop" or self.NPC_AnimationSet == "Rebel" then
		bonbakshen_varichadz = ACT_RANGE_ATTACK_SMG1_LOW
		bonbakshen_Kalel = ACT_WALK_AIM_RIFLE
		bonbakshen_Vazel = ACT_RUN_AIM_RIFLE
	end
	
	self.ActivityTranslateAI = {}
	if rifleOverride == true or hType == "ar2" or hType == "smg" then
		if hType == "ar2" or rifleOverride == true then
			self.ActivityTranslateAI[ACT_RANGE_ATTACK1] 				= ACT_RANGE_ATTACK_AR2
			self.ActivityTranslateAI[ACT_GESTURE_RANGE_ATTACK1] 		= ACT_GESTURE_RANGE_ATTACK_AR2
			self.ActivityTranslateAI[ACT_RANGE_AIM_LOW] 				= ACT_RANGE_AIM_AR2_LOW
			self.ActivityTranslateAI[ACT_RANGE_ATTACK1_LOW] 			= ACT_RANGE_ATTACK_AR2_LOW
		elseif hType == "smg" then
			self.ActivityTranslateAI[ACT_RANGE_ATTACK1] 				= ACT_RANGE_ATTACK_SMG1
			self.ActivityTranslateAI[ACT_GESTURE_RANGE_ATTACK1] 		= ACT_GESTURE_RANGE_ATTACK_SMG1
			self.ActivityTranslateAI[ACT_RANGE_AIM_LOW] 				= ACT_RANGE_AIM_SMG1_LOW
			self.ActivityTranslateAI[ACT_RANGE_ATTACK1_LOW] 			= ACT_RANGE_ATTACK_SMG1_LOW
		end
		self.ActivityTranslateAI[ACT_COVER_LOW] 					= ACT_COVER_SMG1_LOW
		self.ActivityTranslateAI[ACT_RELOAD] 						= ACT_RELOAD_SMG1
		self.ActivityTranslateAI[ACT_RELOAD_LOW] 					= ACT_RELOAD_SMG1_LOW
		self.ActivityTranslateAI[ACT_GESTURE_RELOAD] 				= ACT_GESTURE_RELOAD_SMG1
		self.ActivityTranslateAI[ACT_IDLE] 							= medzZenk_Genal
		self.ActivityTranslateAI[ACT_IDLE_ANGRY] 					= ACT_IDLE_ANGRY_SMG1
		self.ActivityTranslateAI[ACT_IDLE_RELAXED] 					= ACT_IDLE_SMG1_RELAXED
		self.ActivityTranslateAI[ACT_IDLE_STIMULATED] 				= ACT_IDLE_SMG1_STIMULATED
		self.ActivityTranslateAI[ACT_IDLE_AGITATED] 				= ACT_IDLE_ANGRY_SMG1
		self.ActivityTranslateAI[ACT_IDLE_AIM_RELAXED] 				= ACT_IDLE_SMG1_RELAXED
		self.ActivityTranslateAI[ACT_IDLE_AIM_STIMULATED] 			= ACT_IDLE_AIM_RIFLE_STIMULATED
		self.ActivityTranslateAI[ACT_IDLE_AIM_AGITATED] 			= ACT_IDLE_ANGRY_SMG1
		self.ActivityTranslateAI[ACT_WALK] 							= medzZenk_Kalel
		self.ActivityTranslateAI[ACT_WALK_AIM] 						= ACT_WALK_AIM_RIFLE
		self.ActivityTranslateAI[ACT_WALK_CROUCH] 					= ACT_WALK_CROUCH_RIFLE
		self.ActivityTranslateAI[ACT_WALK_CROUCH_AIM] 				= ACT_WALK_CROUCH_AIM_RIFLE
		self.ActivityTranslateAI[ACT_WALK_RELAXED] 					= ACT_WALK_RIFLE_RELAXED
		self.ActivityTranslateAI[ACT_WALK_STIMULATED] 				= ACT_WALK_RIFLE_STIMULATED
		self.ActivityTranslateAI[ACT_WALK_AGITATED] 				= ACT_WALK_AIM_RIFLE
		self.ActivityTranslateAI[ACT_WALK_AIM_RELAXED] 				= ACT_WALK_RIFLE_RELAXED
		self.ActivityTranslateAI[ACT_WALK_AIM_STIMULATED] 			= ACT_WALK_AIM_RIFLE_STIMULATED
		self.ActivityTranslateAI[ACT_WALK_AIM_AGITATED] 			= ACT_WALK_AIM_RIFLE
		self.ActivityTranslateAI[ACT_RUN] 							= ACT_RUN_RIFLE
		self.ActivityTranslateAI[ACT_RUN_AIM] 						= ACT_RUN_AIM_RIFLE
		self.ActivityTranslateAI[ACT_RUN_CROUCH] 					= ACT_RUN_CROUCH_RIFLE
		self.ActivityTranslateAI[ACT_RUN_CROUCH_AIM] 				= ACT_RUN_CROUCH_AIM_RIFLE
		self.ActivityTranslateAI[ACT_RUN_RELAXED] 					= ACT_RUN_RIFLE_RELAXED
		self.ActivityTranslateAI[ACT_RUN_STIMULATED] 				= ACT_RUN_RIFLE_STIMULATED
		self.ActivityTranslateAI[ACT_RUN_AGITATED] 					= ACT_RUN_AIM_RIFLE
		self.ActivityTranslateAI[ACT_RUN_AIM_RELAXED] 				= ACT_RUN_RIFLE_RELAXED
		self.ActivityTranslateAI[ACT_RUN_AIM_STIMULATED] 			= ACT_RUN_AIM_RIFLE_STIMULATED
		self.ActivityTranslateAI[ACT_RUN_AIM_AGITATED] 				= ACT_RUN_AIM_RIFLE
	elseif hType == "crossbow" or hType == "shotgun" then
		self.ActivityTranslateAI[ACT_RANGE_ATTACK1] 				= ACT_RANGE_ATTACK_SHOTGUN				-- ****
		self.ActivityTranslateAI[ACT_GESTURE_RANGE_ATTACK1] 		= ACT_GESTURE_RANGE_ATTACK_SHOTGUN
		self.ActivityTranslateAI[ACT_RANGE_AIM_LOW] 				= ACT_RANGE_AIM_AR2_LOW
		self.ActivityTranslateAI[ACT_RANGE_ATTACK1_LOW] 			= bonbakshen_varichadz					-- ****
		self.ActivityTranslateAI[ACT_COVER_LOW] 					= ACT_COVER_SMG1_LOW
		self.ActivityTranslateAI[ACT_RELOAD] 						= ACT_RELOAD_SHOTGUN					-- ****
		self.ActivityTranslateAI[ACT_RELOAD_LOW] 					= ACT_RELOAD_SMG1_LOW //ACT_RELOAD_SHOTGUN_LOW	-- ****
		self.ActivityTranslateAI[ACT_GESTURE_RELOAD] 				= ACT_GESTURE_RELOAD_SHOTGUN
		
		self.ActivityTranslateAI[ACT_IDLE] 							= ACT_SHOTGUN_IDLE4						-- ****
		self.ActivityTranslateAI[ACT_IDLE_ANGRY] 					= ACT_IDLE_ANGRY_SHOTGUN				-- ****
		self.ActivityTranslateAI[ACT_IDLE_RELAXED] 					= ACT_IDLE_SHOTGUN_RELAXED
		self.ActivityTranslateAI[ACT_IDLE_STIMULATED] 				= ACT_IDLE_SHOTGUN_STIMULATED
		self.ActivityTranslateAI[ACT_IDLE_AGITATED] 				= ACT_IDLE_SHOTGUN_AGITATED
		self.ActivityTranslateAI[ACT_IDLE_AIM_RELAXED] 				= ACT_SHOTGUN_IDLE_DEEP
		self.ActivityTranslateAI[ACT_IDLE_AIM_STIMULATED] 			= ACT_SHOTGUN_IDLE_DEEP
		self.ActivityTranslateAI[ACT_IDLE_AIM_AGITATED] 			= ACT_SHOTGUN_IDLE_DEEP
		
		self.ActivityTranslateAI[ACT_WALK] 							= ACT_WALK_AIM_SHOTGUN					-- ****
		self.ActivityTranslateAI[ACT_WALK_AIM] 						= ACT_WALK_AIM_SHOTGUN						-- ****
		self.ActivityTranslateAI[ACT_WALK_CROUCH] 					= ACT_WALK_CROUCH_RIFLE					-- ****
		self.ActivityTranslateAI[ACT_WALK_CROUCH_AIM] 				= ACT_WALK_CROUCH_AIM_RIFLE
		self.ActivityTranslateAI[ACT_WALK_RELAXED] 					= ACT_WALK_AIM_SHOTGUN
		self.ActivityTranslateAI[ACT_WALK_STIMULATED] 				= ACT_WALK_AIM_SHOTGUN
		self.ActivityTranslateAI[ACT_WALK_AGITATED] 				= ACT_WALK_AIM_SHOTGUN
		self.ActivityTranslateAI[ACT_WALK_AIM_RELAXED] 				= ACT_WALK_AIM_SHOTGUN
		self.ActivityTranslateAI[ACT_WALK_AIM_STIMULATED] 			= ACT_WALK_AIM_SHOTGUN
		self.ActivityTranslateAI[ACT_WALK_AIM_AGITATED] 			= ACT_WALK_AIM_SHOTGUN
		
		self.ActivityTranslateAI[ACT_RUN] 							= ACT_RUN_RIFLE							-- ****
		self.ActivityTranslateAI[ACT_RUN_AIM] 						= bonbakshen_Vazel						-- ****
		self.ActivityTranslateAI[ACT_RUN_CROUCH] 					= ACT_RUN_CROUCH_RIFLE					-- ****
		self.ActivityTranslateAI[ACT_RUN_CROUCH_AIM] 				= ACT_RUN_CROUCH_AIM_RIFLE
		self.ActivityTranslateAI[ACT_RUN_RELAXED] 					= ACT_RUN_RIFLE
		self.ActivityTranslateAI[ACT_RUN_STIMULATED] 				= ACT_RUN_RIFLE
		self.ActivityTranslateAI[ACT_RUN_AGITATED] 					= ACT_RUN_RIFLE
		self.ActivityTranslateAI[ACT_RUN_AIM_RELAXED] 				= ACT_RUN_AIM_SHOTGUN
		self.ActivityTranslateAI[ACT_RUN_AIM_STIMULATED] 			= ACT_RUN_AIM_SHOTGUN
		self.ActivityTranslateAI[ACT_RUN_AIM_AGITATED] 				= ACT_RUN_AIM_SHOTGUN
	elseif hType == "rpg" then
		self.ActivityTranslateAI[ACT_RANGE_ATTACK1] 				= ACT_CROUCHIDLE
		self.ActivityTranslateAI[ACT_GESTURE_RANGE_ATTACK1] 		= ACT_GESTURE_RANGE_ATTACK_SMG1
		self.ActivityTranslateAI[ACT_RANGE_AIM_LOW] 				= ACT_RANGE_AIM_SMG1_LOW
		self.ActivityTranslateAI[ACT_RANGE_ATTACK1_LOW] 			= ACT_RANGE_ATTACK_SMG1_LOW
		self.ActivityTranslateAI[ACT_COVER_LOW] 					= ACT_COVER_LOW_RPG
		self.ActivityTranslateAI[ACT_RELOAD] 						= ACT_RELOAD_SMG1
		self.ActivityTranslateAI[ACT_RELOAD_LOW] 					= ACT_RELOAD_SMG1_LOW
		self.ActivityTranslateAI[ACT_GESTURE_RELOAD] 				= ACT_GESTURE_RELOAD_SMG1
		self.ActivityTranslateAI[ACT_IDLE] 							= ACT_IDLE_RPG
		self.ActivityTranslateAI[ACT_IDLE_ANGRY] 					= ACT_IDLE_ANGRY_RPG
		self.ActivityTranslateAI[ACT_IDLE_RELAXED] 					= ACT_IDLE_RPG_RELAXED
		self.ActivityTranslateAI[ACT_IDLE_STIMULATED] 				= ACT_IDLE_SMG1_STIMULATED
		self.ActivityTranslateAI[ACT_IDLE_AGITATED] 				= ACT_IDLE_ANGRY_RPG
		self.ActivityTranslateAI[ACT_IDLE_AIM_RELAXED] 				= ACT_IDLE_RPG_RELAXED
		self.ActivityTranslateAI[ACT_IDLE_AIM_STIMULATED] 			= ACT_IDLE_AIM_RIFLE_STIMULATED
		self.ActivityTranslateAI[ACT_IDLE_AIM_AGITATED] 			= ACT_IDLE_ANGRY_RPG
		self.ActivityTranslateAI[ACT_WALK] 							= ACT_WALK_RPG
		self.ActivityTranslateAI[ACT_WALK_AIM] 						= ACT_WALK_AIM_RIFLE
		self.ActivityTranslateAI[ACT_WALK_CROUCH] 					= ACT_WALK_CROUCH_RPG
		self.ActivityTranslateAI[ACT_WALK_CROUCH_AIM] 				= ACT_WALK_CROUCH_RPG
		self.ActivityTranslateAI[ACT_WALK_RELAXED] 					= ACT_WALK_RPG_RELAXED
		self.ActivityTranslateAI[ACT_WALK_STIMULATED] 				= ACT_WALK_RIFLE_STIMULATED
		self.ActivityTranslateAI[ACT_WALK_AGITATED] 				= ACT_WALK_AIM_RIFLE
		self.ActivityTranslateAI[ACT_WALK_AIM_RELAXED] 				= ACT_WALK_RPG_RELAXED
		self.ActivityTranslateAI[ACT_WALK_AIM_STIMULATED] 			= ACT_WALK_AIM_RIFLE_STIMULATED
		self.ActivityTranslateAI[ACT_WALK_AIM_AGITATED] 			= ACT_WALK_AIM_RIFLE
		self.ActivityTranslateAI[ACT_RUN] 							= ACT_RUN_RPG
		self.ActivityTranslateAI[ACT_RUN_AIM] 						= ACT_RUN_AIM_RIFLE
		self.ActivityTranslateAI[ACT_RUN_CROUCH] 					= ACT_RUN_CROUCH_RPG
		self.ActivityTranslateAI[ACT_RUN_CROUCH_AIM] 				= ACT_RUN_CROUCH_RPG
		self.ActivityTranslateAI[ACT_RUN_RELAXED] 					= ACT_RUN_RPG_RELAXED
		self.ActivityTranslateAI[ACT_RUN_STIMULATED] 				= ACT_RUN_RIFLE_STIMULATED
		self.ActivityTranslateAI[ACT_RUN_AGITATED] 					= ACT_RUN_AIM_RIFLE
		self.ActivityTranslateAI[ACT_RUN_AIM_RELAXED] 				= ACT_RUN_RPG_RELAXED
		self.ActivityTranslateAI[ACT_RUN_AIM_STIMULATED] 			= ACT_RUN_AIM_RIFLE_STIMULATED
		self.ActivityTranslateAI[ACT_RUN_AIM_AGITATED] 				= ACT_RUN_AIM_RIFLE
	else
		-- revolver or pistol
		self.ActivityTranslateAI[ACT_RANGE_ATTACK1] 				= ACT_RANGE_ATTACK_PISTOL
		self.ActivityTranslateAI[ACT_GESTURE_RANGE_ATTACK1] 		= ACT_GESTURE_RANGE_ATTACK_PISTOL
		self.ActivityTranslateAI[ACT_RANGE_AIM_LOW] 				= ACT_RANGE_AIM_PISTOL_LOW
		self.ActivityTranslateAI[ACT_RANGE_ATTACK1_LOW] 			= ACT_RANGE_ATTACK_PISTOL_LOW
		self.ActivityTranslateAI[ACT_COVER_LOW] 					= ACT_COVER_PISTOL_LOW
		self.ActivityTranslateAI[ACT_RELOAD] 						= ACT_RELOAD_PISTOL
		self.ActivityTranslateAI[ACT_RELOAD_LOW] 					= ACT_RELOAD_PISTOL_LOW
		self.ActivityTranslateAI[ACT_GESTURE_RELOAD] 				= ACT_GESTURE_RELOAD_PISTOL
		self.ActivityTranslateAI[ACT_IDLE] 							= ACT_IDLE_PISTOL
		self.ActivityTranslateAI[ACT_IDLE_ANGRY] 					= ACT_IDLE_ANGRY_PISTOL
		
		self.ActivityTranslateAI[ACT_WALK] 							= ACT_WALK_PISTOL
		self.ActivityTranslateAI[ACT_WALK_AIM] 						= bezdigZenk_Kalel
		
		self.ActivityTranslateAI[ACT_RUN] 							= ACT_RUN_PISTOL
		self.ActivityTranslateAI[ACT_RUN_AIM] 						= bezdigZenk_Vazel
	end
	return
end
--PATH lua/weapons/weapon_vj_crowbar/shared.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/weaponchecker/shared.lua:
return gluapack()()
--PATH lua/entities/alydus_destructiblefortification.lua:
return gluapack()()
--PATH lua/entities/alydus_destructiblefortification.lua:
 --[[
 - Destructible Fortifications Extension for Fortification Builder Tablet
 - 
 - /lua/entities/alydus_destructablefortification.lua
 - 
 - Feel free to modify, but please leave appropriate credit.
 - Do not reupload this (modified or original) to this workshop, however you may ruin modified versions on your servers.
 -
 - Thanks so much for the support with the addon since it's creation in 2018.
 -
 --]]

AddCSLuaFile()

if CLIENT then
	function ENT:Draw()
		self:DrawModel()
	end
else
	CreateConVar("alydus_enablefortificationdestructionmessage", 1)
end

function ENT:Initialize()
	if SERVER then
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:DrawShadow(false)

		local phys = self:GetPhysicsObject()
		if IsValid(phys) then
			phys:Wake()
		end
	end
end

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "FortificationHealth")
	self:NetworkVar("Int", 1, "MaximumFortificationHealth")
end

function ENT:OnTakeDamage(dmg)
	if SERVER then
		local currentFortificationHealth = self:GetFortificationHealth()

		if currentFortificationHealth <= 0 then
			return false
		end

		if dmg:GetDamage() >= 1 then
			currentFortificationHealth = currentFortificationHealth - dmg:GetDamage()

			self:SetFortificationHealth(currentFortificationHealth)
		end
	end
end

function ENT:Think()
	if SERVER then
		if self.previousHealth != self:GetFortificationHealth() then
			self.previousHealth = self:GetFortificationHealth()
		end
		if self.previousHealth == 0 or self:GetFortificationHealth() <= 0 then
			self:EmitSound("physics/concrete/concrete_break2.wav")

			if GetConVar("alydus_enablefortificationdestructionmessage"):GetInt() == 1 and IsValid(self.isPlayerPlacedFortification) and self.isPlayerPlacedFortification:IsPlayer() then
				self.isPlayerPlacedFortification:ChatPrint("A fortification you owned has been destroyed!")
			end

			self:Remove()
		end
	end
end

ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.Spawnable = true

ENT.PrintName = "Destructable Fortification"
ENT.Author = "Alydus"
ENT.Contact = "Alydus"
ENT.Purpose = "A destructable fortification, can only be spawned using the fortification builder tablet."
ENT.Instructions = "Spawn by using the fortification builder tablet weapon."
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/arc9_gsr_plantable.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Claymore"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.RenderGroup = RENDERGROUP_BOTH

ENT.WeaponClass = ""
ENT.Model = "models/weapons/w_eq_claymore_dropped.mdl"
ENT.LockYaw = false
ENT.AdjustPitch = false
ENT.AdjustOffset = false
ENT.MinS = Vector(-2, -5, 0)
ENT.MaxS = Vector(2, 5, 8)
ENT.Bury = 0

ENT.BurySurfaces = {
    [MAT_DIRT] = true,
    [MAT_SAND] = true,
    [MAT_GRASS] = true,
    [MAT_FLESH] = true,
    [MAT_BLOODYFLESH] = true,
    [MAT_SNOW] = true,
    [MAT_SLOSH] = true,
}

function ENT:SetupDataTables()
    self:NetworkVar("Float", 0, "ArmTime")
    self:NetworkVar("Angle", 0, "Adjustment")
end

function ENT:OnInitialize()
end

function ENT:Initialize()
    if SERVER then
        self:SetModel(self.Model)
        self:PhysicsInitBox(self.MinS, self.MaxS)
        self:DrawShadow(true)
        self:SetArmTime(-1)

        local phys = self:GetPhysicsObject()

        if phys:IsValid() then
            phys:Wake()
            phys:SetMass(5)
            phys:SetBuoyancyRatio(0)
        end

        self:SetHealth(10)
        self:SetMaxHealth(10)

        self.SpawnAngle = self:GetAngles().y

        self.Attacker = self:GetOwner()
    end
    self.SpawnTime = CurTime()

    self:OnInitialize()
end

function ENT:GetArmed()
    return self:GetArmTime() > 0 and CurTime() > self:GetArmTime() + self.ArmDelay
end

if SERVER then
    function ENT:OnPlant()
    end

    function ENT:Plant(ent, pos, normal, v)
        if self:GetArmTime() > 0 then return end
        if IsValid(ent) and (ent:IsPlayer() or ent:IsNPC() or ent:IsNextBot()) then return end

        -- The AdjustOffset nudge works poorly when the entity is not already aligned with the surface
        local adjustoffset = self.AdjustOffset and self:GetUp():Dot(normal) > 0.5

        -- Use the normal to place our center on the surface if possible
        if v and not adjustoffset then
            local wsc = self:WorldSpaceCenter()
            local tr = util.TraceLine({
                start = wsc,
                endpos = wsc - normal * 24,
                filter = {self, self:GetOwner()},
                mask = MASK_SOLID,
                collisiongroup = self:GetCollisionGroup(),
            })
            debugoverlay.Line(tr.StartPos, tr.HitPos, 5, Color(255, 0, 0), true)
            debugoverlay.Cross(tr.HitPos, 4, 5, Color(255, 0, 0), true)
            debugoverlay.Cross(pos, 4, 5, Color(255, 0, 255), true)
            debugoverlay.Line(tr.HitPos, tr.HitPos + tr.HitNormal * 8, 5, Color(255, 0, 255), true)
            -- If we find a spot for the center, treat that as the location; otherwise don't adjust (it will visually snap but at least the pos/ang will be correct)
            if tr.Hit then
                pos = tr.HitPos
                normal = tr.HitNormal
                ent = tr.Entity
            end
        end

        self:SetOwner(NULL)
        self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)

        local a = Angle(0, self.LockYaw and self.SpawnAngle or self:GetAngles().y, 0)
        local f = a:Forward()

        local na = normal:Angle()
        na:RotateAroundAxis(na:Right(), -90)

        local angle = Angle(na)
        local dir = angle:Forward()
        dir.z = 0
        dir:Normalize()

        local turn = angle:Forward():Cross(dir):GetNormalized()
        local theta = math.deg(math.acos(angle:Forward():Dot(dir)))

        angle:RotateAroundAxis(turn, theta)
        angle:RotateAroundAxis(dir:Cross(f):GetNormalized(), math.deg(math.acos(dir:Dot(f))))
        angle:RotateAroundAxis(turn, -theta)

        if self.AdjustPitch then
            self:SetAdjustment(Angle(-math.Clamp(theta * 0.5, 3, 15), 0, 0))
        end

        if adjustoffset then
            local offset = self:WorldToLocal(pos)
            pos = pos + angle:Forward() * -offset.x + angle:Right() * offset.y
        end

        if self.Bury > 0 then
            local tr_mat = util.TraceLine({
                start = pos + normal,
                endpos = pos - normal,
                filter = {self},
            })
            if self.BurySurfaces[tr_mat.MatType] and normal:Dot(Vector(0, 0, 1)) >= 0.5 then
                pos = pos - normal * self.Bury
                self:DrawShadow(false)
            end
        end

        if ent:IsWorld() or (IsValid(ent) and ent:GetSolid() == SOLID_BSP) then
            self:SetMoveType(MOVETYPE_NONE)
            self:SetPos(pos)
        else
            self:SetPos(pos)
            self:SetParent(ent)
        end

        self:SetAngles(angle)
        self:SetArmTime(CurTime())

        self:OnPlant()
    end

    function ENT:PhysicsCollide(data, physobj)
        self:Plant(data.HitEntity, data.HitPos, -data.HitNormal, data.OurOldVelocity:GetNormalized())
    end

    function ENT:Detonate()
        self:Remove()
    end

    function ENT:OnTakeDamage(dmg)
        self:SetHealth(self:Health() - dmg:GetDamage())
        if not self.BOOM and self:Health() <= 0 then
            self.BOOM = true
            self:Detonate()
        end
        return dmg:GetDamage()
    end

    function ENT:Use(act, call, calltype, integer)
        if not self.BOOM and self.WeaponClass and IsValid(act) and act:IsPlayer() then
            act:GiveAmmo(1, weapons.GetStored(self.WeaponClass).Ammo, true)
            act:Give(self.WeaponClass, true)

            self:EmitSound("CSGO.Breacher.BreachUse", 75)
            self:Remove()
        end
    end
else
    function ENT:DrawTranslucent()
        self:Draw()
    end

    function ENT:Draw()
        self:DrawModel()
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/arc9_proj_base.lua:
AddCSLuaFile()

ENT.Type 				= "anim"
ENT.Base 				= "base_entity"
ENT.PrintName 			= "Base Projectile"

ENT.Spawnable 			= false
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE

ENT.Model = "models/Items/grenadeAmmo.mdl"
ENT.Ticks = 0
ENT.FuseTime = 0
ENT.Defused = false
ENT.SphereSize = 2
ENT.PhysMat = "grenade"
ENT.SmokeTrail = true
ENT.SmokeTrailMat = "trails/smoke"
ENT.SmokeTrailSize = 6
ENT.SmokeTrailTime = 0.5
ENT.Flare = false
ENT.LifeTime = 5

ENT.Drag = true
ENT.Gravity = true
ENT.DragCoefficient = 0.25
ENT.Boost = 0
ENT.Lift = 0
ENT.GunshipWorkaround = true
ENT.HelicopterWorkaround = true

ENT.Damage = 150
ENT.Radius = 300
ENT.ImpactDamage = nil
ENT.ExplodeOnImpact = false

ENT.Scorch = true
ENT.ExplosionEffect = "explosion"

ENT.Dead = false
ENT.DieTime = 0
ENT.BounceSounds = {""}

ENT.SteerSpeed = 60 -- The maximum amount of degrees per second the missile can steer.
ENT.SeekerAngle = math.cos(35) -- The missile will lose tracking outside of this angle.
ENT.SuperSeeker = false
ENT.SACLOS = false -- This missile is manually guided by its shooter.
ENT.SemiActive = false -- This missile needs to be locked on to the target at all times.
ENT.FireAndForget = false -- This missile automatically tracks its target.
ENT.TopAttack = false -- This missile flies up above its target before going down in a top-attack trajectory.
ENT.TopAttackHeight = 5000
ENT.SuperSteerBoostTime = 5 -- Time given for this projectile to adjust its trajectory from top attack to direct
ENT.NoReacquire = false -- F&F target is permanently lost if it cannot reacquire

ENT.ShootEntData = {}

ENT.IsProjectile = true

ENT.LastHitNormal = Vector(0, 0, 0)

ENT.LoopingSound = nil

if SERVER then
    local gunship = {["npc_combinegunship"] = true, ["npc_combinedropship"] = true}

    function ENT:Initialize()
        self:SetModel(self.Model)
        self:PhysicsInitSphere(self.SphereSize, self.PhysMat)

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:EnableDrag(self.Drag)
            phys:SetDragCoefficient(self.DragCoefficient)
            phys:EnableGravity(self.Gravity)
            phys:SetMass(5)
            phys:SetBuoyancyRatio(0.4)
        end

        self.SpawnTime = CurTime()

        if self.SmokeTrail then
            util.SpriteTrail(self, 0, Color( 255 , 255 , 255 ), false, self.SmokeTrailSize, 0, self.SmokeTrailTime, 1 / self.SmokeTrailSize * 0.5, self.SmokeTrailMat)
        end

        if self.LoopingSound then
            self.Sound = CreateSound(self, self.LoopingSound)
            self.Sound:Play()
        end
    end

    function ENT:OnRemove()
        if self.Sound then
            self.Sound:Stop()
        end
    end

    function ENT:Think()
        if self.Defused then return end

        if self.SpawnTime + self.LifeTime < CurTime() then
            self:Detonate()
            return
        end

        if self:WaterLevel() > 0 then
            self:Detonate()
            return
        end

        local drunk = false

        if self.FireAndForget or self.SemiActive then
            if self.SemiActive then
                if IsValid(self.Weapon) then
                    self.ShootEntData = self.Weapon:RunHook("Hook_GetShootEntData", {})
                end
            end

            if self.ShootEntData.Target and IsValid(self.ShootEntData.Target) then
                local target = self.ShootEntData.Target
                if target.UnTrackable then self.ShootEntData.Target = nil end

                -- if self.TopAttack then
                --     local tpos = target:GetPos() + Vector(0, 0, 5000)
                --     if self.SpawnTime + self.TopAttackTime - 1 < CurTime() or self.TopAttackReached then
                --         tpos = target:GetPos()
                --     end
                --     local dir = (tpos - self:GetPos()):GetNormalized()
                --     local dist = (tpos - self:GetPos()):Length()
                --     local ang = dir:Angle()

                --     local p = self:GetAngles().p
                --     local y = self:GetAngles().y

                --     p = math.ApproachAngle(p, ang.p, FrameTime() * self.SteerSpeed)
                --     y = math.ApproachAngle(y, ang.y, FrameTime() * self.SteerSpeed)

                --     self:SetAngles(Angle(p, y, 0))

                --     if dist <= 1024 then
                --         self.TopAttackReached = true
                --     end
                -- else
                local tpos = target:EyePos()
                if self.TopAttack and !self.TopAttackReached then
                    tpos = tpos + Vector(0, 0, self.TopAttackHeight)

                    local dist = (tpos - self:GetPos()):Length()

                    if dist <= 2000 then
                        self.TopAttackReached = true
                        self.SuperSteerTime = CurTime() + self.SuperSteerBoostTime
                    end
                end
                local dir = (tpos - self:GetPos()):GetNormalized()
                local dot = dir:Dot(self:GetAngles():Forward())
                local ang = dir:Angle()

                if self.SuperSeeker or dot >= self.SeekerAngle or !self.TopAttackReached or (self.SuperSteerTime and self.SuperSteerTime >= CurTime()) then
                    local p = self:GetAngles().p
                    local y = self:GetAngles().y

                    p = math.ApproachAngle(p, ang.p, FrameTime() * self.SteerSpeed)
                    y = math.ApproachAngle(y, ang.y, FrameTime() * self.SteerSpeed)

                    self:SetAngles(Angle(p, y, 0))
                    -- self:SetVelocity(dir * 15000)
                elseif self.NoReacquire then
                    self.ShootEntData.Target = nil
                    drunk = true
                end
                -- end
            else
                drunk = true
            end
        elseif self.SACLOS then
            if self:GetOwner():IsValid() then
                local tpos = self:GetOwner():GetEyeTrace().HitPos
                local dir = (tpos - self:GetPos()):GetNormalized()
                local dot = dir:Dot(self:GetAngles():Forward())
                local ang = dir:Angle()

                if dot >= self.SeekerAngle then
                    local p = self:GetAngles().p
                    local y = self:GetAngles().y

                    p = math.ApproachAngle(p, ang.p, FrameTime() * self.SteerSpeed)
                    y = math.ApproachAngle(y, ang.y, FrameTime() * self.SteerSpeed)

                    self:SetAngles(Angle(p, y, 0))
                else
                    drunk = true
                end
            else
                drunk = true
            end
        end

        if drunk then
            self:SetAngles(self:GetAngles() + (AngleRand() * FrameTime() * 1000 / 360))
        end

        self:GetPhysicsObject():AddVelocity(Vector(0, 0, self.Lift) + self:GetForward() * self.Boost)

        -- Gunships have no physics collection, periodically trace to try and blow up in their face
        if self.GunshipWorkaround and (self.GunshipCheck or 0 < CurTime()) then
            self.GunshipCheck = CurTime() + 0.33
            local tr = util.TraceLine({
                start = self:GetPos(),
                endpos = self:GetPos() + (self:GetVelocity() * 6 * engine.TickInterval()),
                filter = self,
                mask = MASK_SHOT
            })
            if IsValid(tr.Entity) and gunship[tr.Entity:GetClass()] then
                self:SetPos(tr.HitPos)
                self:Detonate()
            end
        end
    end

    function ENT:Detonate()
        if !self:IsValid() then return end
        if self.Defused then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() > 0 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
            --self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
        else
            util.Effect( self.ExplosionEffect, effectdata)
            --self:EmitSound("phx/kaboom.wav", 125, 100, 1, CHAN_AUTO)
        end

        util.BlastDamage(self, IsValid(self:GetOwner()) and self:GetOwner() or self, self:GetPos(), self.Radius, self.DamageOverride or self.Damage)

        if SERVER then
            local dir = self.HitVelocity or self:GetVelocity()

            if self.Boost <= 0 then
                dir = Vector(0, 0, -1)
            end

            self:FireBullets({
                Attacker = self,
                Damage = 0,
                Tracer = 0,
                Distance = 256,
                Dir = dir,
                Src = self:GetPos(),
                Callback = function(att, tr, dmg)
                    if self.Scorch then
                        util.Decal("Scorch", tr.StartPos, tr.HitPos - (tr.HitNormal * 16), self)
                    end
                end
            })
        end
        self.Defused = true
        -- self:Remove()

        SafeRemoveEntityDelayed(self, self.SmokeTrailTime)
        self:SetRenderMode(RENDERMODE_NONE)
        self:SetMoveType(MOVETYPE_NONE)
        self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
    end

    function ENT:PhysicsCollide(colData, physobj)
        if !self:IsValid() then return end

        self.LastHitNormal = colData.HitNormal

        local tgt

        if self.ExplodeOnImpact then
            if CurTime() - self.SpawnTime < self.FuseTime then
                if IsValid(colData.HitEntity) then
                    local v = colData.OurOldVelocity:Length() ^ 0.5
                    local dmg = DamageInfo()
                    dmg:SetAttacker(IsValid(self:GetOwner()) and self:GetOwner() or self)
                    dmg:SetInflictor(self)
                    dmg:SetDamageType(DMG_CRUSH)
                    dmg:SetDamage(v)
                    dmg:SetDamagePosition(colData.HitPos)
                    dmg:SetDamageForce(colData.OurOldVelocity)
                    colData.HitEntity:TakeDamageInfo(dmg)
                    self:EmitSound("weapons/rpg/shotdown.wav", 80, math.random(90, 110))
                end
                self:Defuse()
                return
            end

            timer.Simple(0, function()  -- to prevent "Changing collision rules within a callback is likely to cause crashes!" errors
                if !self:IsValid() then return end
                self:EmitSound("")

                self:GetPhysicsObject():EnableMotion(false)

                if self:IsValid() then
                    self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
                end
            end)

            local effectdata = EffectData()
                effectdata:SetOrigin( self:GetPos() )

            -- simulate AP damage on vehicles, mainly simfphys
            tgt = colData.HitEntity
            while IsValid(tgt) do
                if tgt.GetParent and IsValid(tgt:GetParent()) then
                    tgt = tgt:GetParent()
                elseif tgt.GetBaseEnt and IsValid(tgt:GetBaseEnt()) then
                    tgt = tgt:GetBaseEnt()
                else
                    break
                end
            end
        else
            if colData.DeltaTime > 0.1 then
                self:EmitSound(self.BounceSounds[math.random(1, #self.BounceSounds)], 75)
            end
        end

        if self.ImpactDamage and IsValid(tgt) then
            local dmg = DamageInfo()
            dmg:SetAttacker(IsValid(self:GetOwner()) and self:GetOwner() or self)
            dmg:SetInflictor(self)
            dmg:SetDamageType(DMG_BLAST) -- helicopters
            dmg:SetDamage(self.ImpactDamage)
            dmg:SetDamagePosition(colData.HitPos)
            dmg:SetDamageForce(self:GetForward() * self.ImpactDamage)

            if IsValid(tgt:GetOwner()) and tgt:GetOwner():GetClass() == "npc_helicopter" then
                tgt = tgt:GetOwner()
                dmg:ScaleDamage(0.1)
                dmg:SetDamageType(DMG_BLAST + DMG_AIRBOAT)
                dmg:SetDamageForce(self:GetForward() * 100)
            end

            tgt:TakeDamageInfo(dmg)
        end

        if self.ExplodeOnImpact then
            self.HitPos = colData.HitPos
            self.HitVelocity = colData.OurOldVelocity
            self:Detonate()
        end
    end

    -- Combine Helicopters are hard-coded to only take DMG_AIRBOAT damage
    hook.Add("EntityTakeDamage", "ARC9_HelicopterWorkaround", function(ent, dmginfo)
        if IsValid(ent:GetOwner()) and ent:GetOwner():GetClass() == "npc_helicopter" then ent = ent:GetOwner() end
        if ent:GetClass() == "npc_helicopter" and dmginfo:GetInflictor().HelicopterWorkaround then
            dmginfo:SetDamageType(bit.bor(dmginfo:GetDamageType(), DMG_AIRBOAT))
        end
    end)
end

function ENT:Defuse()
    self.Defused = true
    SafeRemoveEntityDelayed(self, 5)
end

local flaremat = Material("effects/arc9_lensflare")
function ENT:Draw()
    if self.Flare and !self.Defused then
        render.SetMaterial(flaremat)
        render.DrawSprite(self:GetPos(), math.Rand(90, 110), math.Rand(90, 110), Color(255, 250, 240))
    else
        self:DrawModel()
    end
end
--PATH lua/entities/arccw_ammo_357_large.lua:
return gluapack()()
--PATH lua/entities/arccw_ammo_ar2.lua:
return gluapack()()
--PATH lua/entities/arccw_ammo_smg1_large.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"

ENT.PrintName                 = "Carbine Ammo (Large)"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/smg_ammo.mdl"
ENT.Scale = 1.5

ENT.AmmoType = "smg1"
ENT.AmmoCount = 300

ENT.DetonationDamage = 30
ENT.DetonationRadius = 256
ENT.DetonationSound = "weapons/smg1/npc_smg1_fire1.wav"
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/entities/arccw_fire_ubgl.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Fire Particle"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/Items/AR2_Grenade.mdl"

ENT.FireTime = 20

ENT.Armed = false

ENT.NextDamageTick = 0

ENT.Ticks = 0

ENT.ArcCW_Killable = false

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        local maxs = Vector(1, 1, 1)
        local mins = -maxs
        self:PhysicsInitBox(mins, maxs)
        self:DrawShadow( false )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.SpawnTime = CurTime()
        self:Detonate()

        self.FireTime = math.Rand(self.FireTime - 1, self.FireTime + 1)
    end
end

local fired = {
    "sprites/flamelet1",
    "sprites/flamelet2",
    "sprites/flamelet3",
    "sprites/flamelet4",
    "sprites/flamelet5",
}
local function GetFireParticle()
    return fired[math.random(#fired)]
end

function ENT:Think()
    if !self.SpawnTime then self.SpawnTime = CurTime() end

    if CLIENT then
        local emitter = ParticleEmitter(self:GetPos())

        if !self:IsValid() or self:WaterLevel() > 2 then return end
        if !IsValid(emitter) then return end

        if math.random(1, 100) < 10 then
            local fire = emitter:Add(GetFireParticle(), self:GetPos() + (VectorRand() * 16))
            fire:SetVelocity( VectorRand() * 500 * VectorRand() )
            fire:SetGravity( Vector(0, 0, 100) )
            fire:SetDieTime( math.Rand(0.5, 0.75) )
            fire:SetStartAlpha( 255 )
            fire:SetEndAlpha( 0 )
            fire:SetStartSize( 25 )
            fire:SetEndSize( 100 )
            fire:SetRoll( math.Rand(-180, 180) )
            fire:SetRollDelta( math.Rand(-0.2,0.2) )
            fire:SetColor( 255, 255, 255 )
            fire:SetAirResistance( 150 )
            fire:SetPos( self:GetPos() )
            fire:SetLighting( false )
            fire:SetCollide(true)
            fire:SetBounce(0.75)
            fire:SetNextThink( CurTime() + FrameTime() )
            fire:SetThinkFunction( function(pa)
                if !pa then return end
                local col1 = Color(255, 255, 255)
                local col2 = Color(0, 0, 0)

                local col3 = col1
                local d = pa:GetLifeTime() / pa:GetDieTime()
                col3.r = Lerp(d, col1.r, col2.r)
                col3.g = Lerp(d, col1.g, col2.g)
                col3.b = Lerp(d, col1.b, col2.b)

                pa:SetColor(col3.r, col3.g, col3.b)
                pa:SetNextThink( CurTime() + FrameTime() )
            end )
        end

        if math.random(1, 100) < 5 then
            local fire = emitter:Add("particles/smokey", self:GetPos())
                fire:SetVelocity( VectorRand() * 25 )
                fire:SetGravity( Vector(0, 0, 1500) )
                fire:SetDieTime( math.Rand(0.25, 1) )
                fire:SetStartAlpha( 255 )
                fire:SetEndAlpha( 0 )
                fire:SetStartSize( 10 )
                fire:SetEndSize( 150 )
                fire:SetRoll( math.Rand(-180, 180) )
                fire:SetRollDelta( math.Rand(-0.2,0.2) )
                fire:SetColor( 255, 255, 255 )
                fire:SetAirResistance( 150 )
                fire:SetPos( self:GetPos() )
                fire:SetLighting( false )
                fire:SetCollide(true)
                fire:SetBounce(0.75)
                fire:SetNextThink( CurTime() + FrameTime() )
                fire:SetThinkFunction( function(pa)
                    if !pa then return end
                    local col1 = Color(255, 135, 0)
                    local col2 = Color(150, 150, 150)

                    local col3 = col1
                    local d = pa:GetLifeTime() / pa:GetDieTime()
                    col3.r = Lerp(d, col1.r, col2.r)
                    col3.g = Lerp(d, col1.g, col2.g)
                    col3.b = Lerp(d, col1.b, col2.b)

                    pa:SetColor(col3.r, col3.g, col3.b)
                    pa:SetNextThink( CurTime() + FrameTime() )
                end )
        end

        emitter:Finish()

        self.Ticks = self.Ticks + 1
    else

        if self:GetVelocity():LengthSqr() <= 32 then
            self:SetMoveType( MOVETYPE_NONE )
        end

        if self.NextDamageTick > CurTime() then return end

        if self:WaterLevel() > 2 then self:Remove() return end

        local dmg = DamageInfo()
        dmg:SetDamageType(DMG_BURN)
        dmg:SetDamage(math.Round(math.random() * 2 + 3))
        dmg:SetInflictor(self)
        dmg:SetAttacker(self:GetOwner())
        util.BlastDamageInfo(dmg, self:GetPos(), 200)

        self.NextDamageTick = CurTime() + 0.15

        if self.SpawnTime + self.FireTime <= CurTime() then self:Remove() return end
    end
end

function ENT:OnRemove()
    if !self.FireSound then return end
    self.FireSound:Stop()
end

function ENT:Detonate()
    if !self:IsValid() then return end

    self.Armed = true

    if self.Order and self.Order != 1 then return end

    self.FireSound = CreateSound(self, "arccw_go/molotov/fire_loop_1.wav")
    self.FireSound:Play()

    self.FireSound:ChangePitch(80, self.FireTime)

    timer.Simple(self.FireTime - 1, function()
        if !IsValid(self) then return end

        self.FireSound:ChangeVolume(0, 1)
    end)

    timer.Simple(self.FireTime, function()
        if !IsValid(self) then return end

        self:Remove()
    end)
end

function ENT:Draw()
    -- cam.Start3D() -- Start the 3D function so we can draw onto the screen.
    --     render.SetMaterial( GetFireParticle() ) -- Tell render what material we want, in this case the flash from the gravgun
    --     render.DrawSprite( self:GetPos(), math.random(200, 250), math.random(200, 250), Color(255, 255, 255) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
    -- cam.End3D()
end
--PATH addons/[bronie] arccw-krakens-explosives-v1.3/lua/entities/arccw_k_proj_base.lua:
AddCSLuaFile()

ENT.Type                     = "anim"
ENT.Base                     = "base_entity"
ENT.RenderGroup              = RENDERGROUP_TRANSLUCENT

ENT.PrintName                = "Base Projectile"
ENT.Category                 = ""

ENT.Spawnable                = false
ENT.Model                    = ""

local smokeimages = {"particle/particle_smokegrenade"}
local function GetSmokeImage()
    return smokeimages[math.random(#smokeimages)]
end

game.AddParticles("particles/mw2019_rockettrail.pcf")
PrecacheParticleSystem("rockettrail")

ENT.Material = false -- custom material
ENT.IsRocket = false -- projectile has a booster and will not drop.
ENT.Sticky = false -- projectile sticks on impact

ENT.InstantFuse = true -- projectile is armed immediately after firing.
ENT.TimeFuse = false -- projectile will arm after this amount of time
ENT.RemoteFuse = false -- allow this projectile to be triggered by remote detonator.
ENT.ImpactFuse = false -- projectile explodes on impact.
ENT.StickyFuse = false -- projectile becomes timed after sticking.
ENT.NoBounce = false -- projectile doesn't bounce.
ENT.BounceWall = false -- projectile doesn't detonate until it hits the ground

ENT.RemoveOnImpact = false
ENT.ExplodeOnImpact = false
ENT.ExplodeOnDamage = false -- projectile explodes when it takes damage.
ENT.ExplodeUnderwater = false -- projectile explodes when it enters water

ENT.Defusable = false -- press E on the projectile to defuse it
ENT.DefuseOnDamage = false

ENT.ImpactDamage = 25
ENT.ImpactDamageSpeed = 1000

ENT.Delay = 5 -- after being triggered and this amount of time has passed, the projectile will explode.
ENT.Armed = false

ENT.RocketTrailParticle = "rockettrail"  -- name of the particle effect
ENT.RocketTrail = false -- leaves trail of a particle effct
ENT.SmokeTrail = false -- leaves trail of smoke
ENT.SmokeColor = Color(255, 165, 0)
ENT.Flare = true
ENT.FlareColor = nil
ENT.FlareSizeMin = 50
ENT.FlareSizeMax = 100

ENT.AudioLoop = nil
ENT.BounceSounds = nil
ENT.CollisionSphere = nil

ENT.GunshipWorkaround = true

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "Weapon")
end

function ENT:Initialize()
    if SERVER then
        self:SetModel(self.Model)
        self:SetMaterial(self.Material or "")
        if self.CollisionSphere then
            self:PhysicsInitSphere(self.CollisionSphere)
        else
            self:PhysicsInit(SOLID_VPHYSICS)
        end
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)

        self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)
        if self.Defusable then
            self:SetUseType(SIMPLE_USE)
        end

        local phys = self:GetPhysicsObject()
        if !phys:IsValid() then
            self:Remove()
            return
        end

        phys:EnableDrag(false)
        phys:SetDragCoefficient(0)
        phys:SetBuoyancyRatio(0)
        phys:Wake()

        if self.IsRocket then
            phys:EnableGravity(false)
			phys:SetMass(5)
        end
    end

    self.SpawnTime = CurTime()

    self.NPCDamage = IsValid(self:GetOwner()) and self:GetOwner():IsNPC() and self:GetOwner():IsNextBot()

    if self.AudioLoop then
        self.LoopSound = CreateSound(self, self.AudioLoop)
        self.LoopSound:Play()
	   if self:GetNWBool("HasDetonated") then
       self.LoopSound:Stop()
       end
    end

    if self.InstantFuse then
        self.ArmTime = CurTime()
        self.Armed = true
    end
	
    if self.RocketTrail then
	   ParticleEffectAttach(self.RocketTrailParticle, PATTACH_ABSORIGIN_FOLLOW, self, 0)
	   if self:GetNWBool("HasDetonated") then
       self.RocketTrail = false
       end
    end
	
	self.HitSkybox = false
    self:OnInitialize()
end

function ENT:OnRemove()
    if self.LoopSound then
        self.LoopSound:Stop()
    end
	self:StopParticles()
end

function ENT:OnTakeDamage(dmg)
    if self.Detonated then return end

    -- self:TakePhysicsDamage(dmg)

    if self.ExplodeOnDamage then
        if IsValid(self:GetOwner()) and IsValid(dmg:GetAttacker()) then self:SetOwner(dmg:GetAttacker())
        else self.Attacker = dmg:GetAttacker() or self.Attacker end
        self:PreDetonate(data)
    elseif self.DefuseOnDamage and dmg:GetDamageType() != DMG_BLAST then
        self:EmitSound("physics/plastic/plastic_box_break" .. math.random(1, 2) .. ".wav", 70, math.Rand(95, 105))
        local fx = EffectData()
        fx:SetOrigin(self:GetPos())
        fx:SetNormal(self:GetAngles():Forward())
        fx:SetAngles(self:GetAngles())
        util.Effect("ManhackSparks", fx)
        self.Detonated = true
        self:Remove()
    end
end

function ENT:PhysicsCollide(data, collider, physobj)
    if IsValid(data.HitEntity) and data.HitEntity:GetClass() == "func_breakable_surf" then
        self:FireBullets({
            Attacker = self:GetOwner(),
            Inflictor = self,
            Damage = 0,
            Distance = 32,
            Tracer = 0,
            Src = self:GetPos(),
            Dir = data.OurOldVelocity:GetNormalized(),
	        })
        local pos, ang, vel = self:GetPos(), self:GetAngles(), data.OurOldVelocity
        self:SetAngles(ang)
        self:SetPos(pos)
        self:GetPhysicsObject():SetVelocityInstantaneous(vel * 0.5)
        return
    end
	
    -- local theirProps = util.GetSurfaceData(data.TheirSurfaceProps)
    -- if (theirProps != nil && theirProps.material == MAT_DEFAULT) then
    -- timer.Simple(0, function() self:Remove() end)
    -- return
    -- end
	
    if self.BounceWall then
        local ang = data.HitNormal:Angle()
        ang.p = math.abs( ang.p )
        ang.y = math.abs( ang.y )
        ang.r = math.abs( ang.r )
	
        if ang.p > 90 or ang.p < 60 then
        --self:EmitSound(Sound("GlassBottle.ImpactHard"))
		self:SetNWBool("HasDetonated",true)

        local impulse = (data.OurOldVelocity - 2 * data.OurOldVelocity:Dot(data.HitNormal) * data.HitNormal)*0.25
        collider:ApplyForceCenter(impulse)
        else
        self:PreDetonate(data)
        end
    end
	
    if self.ImpactFuse and !self.Armed then
        self.ArmTime = CurTime()
        self.Armed = true

        if self:Impact(data, collider) then
            return
        end

        if self.Delay == 0 or self.ExplodeOnImpact then
            self:PreDetonate(data)
        end
    elseif self.ImpactDamage > 0 and IsValid(data.HitEntity) and (engine.ActiveGamemode() != "terrortown" or !data.HitEntity:IsPlayer()) then
        local dmg = DamageInfo()
        dmg:SetAttacker(IsValid(self:GetOwner()) and self:GetOwner() or self.Attacker)
        dmg:SetInflictor(self)
        dmg:SetDamage(Lerp((data.OurOldVelocity:Length() - 0.6 * self.ImpactDamageSpeed) / 0.4 * self.ImpactDamageSpeed, self.ImpactDamage / 5, self.ImpactDamage))
        dmg:SetDamageType(DMG_CRUSH + DMG_CLUB)
        dmg:SetDamageForce(data.OurOldVelocity)
        dmg:SetDamagePosition(data.HitPos)
        data.HitEntity:TakeDamageInfo(dmg)
    elseif !self.ImpactFuse then
        self:Impact(data, collider)
    end

    if self.Sticky then
        self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
        self:SetPos(data.HitPos)
        self:SetAngles(self:GetAngles())
        self.Attacker = self:GetOwner()
        self:SetOwner(NULL)

        if data.HitEntity:IsWorld() or data.HitEntity:GetSolid() == SOLID_BSP then
            self:SetMoveType(MOVETYPE_NONE)
            self:SetPos(data.HitPos)
        else
            self:SetPos(data.HitPos)
            self:SetParent(data.HitEntity)
        end

        self:EmitSound("weapons/cod2019/shared/blt_imp_flesh_plr_04.ogg",75, 100, 1, CHAN_AUTO)

        if self.StickyFuse and !self.Armed then
            self.ArmTime = CurTime()
            self.Armed = true
        end

        self:Stuck()
		self:SetNWBool("HasDetonated",true)
    end
	
    if self.NoBounce then
	  timer.Simple(0, function()
       self:SetPos(self:GetPos())
	   self:GetPhysicsObject():SetVelocityInstantaneous(data.OurNewVelocity * 0.1)
	  end)
	  self:SetNWBool("HasDetonated",true)
    end

    if data.DeltaTime < 0.1 then return end
    if !self.BounceSounds then return end

    local s = table.Random(self.BounceSounds)
    self:EmitSound(s)
end

function ENT:OnThink()
end

function ENT:OnInitialize()
end

function ENT:DoSmokeTrail()
    if CLIENT and self.SmokeTrail then
        local emitter = ParticleEmitter(self:GetPos())

        local smoke = emitter:Add(GetSmokeImage(), self:GetPos())

        smoke:SetStartAlpha(50)
        smoke:SetEndAlpha(0)

        smoke:SetStartSize(10)
        smoke:SetEndSize(math.Rand(50, 75))

        smoke:SetRoll(math.Rand(-180, 180))
        smoke:SetRollDelta(math.Rand(-1, 1))

        smoke:SetPos(self:GetPos())
        smoke:SetVelocity(-self:GetAngles():Forward() * 400 + (VectorRand() * 10))

        smoke:SetColor(self.SmokeColor)
        smoke:SetLighting(true)

        smoke:SetDieTime(math.Rand(0.75, 1.25))

        smoke:SetGravity(Vector(0, 0, 0))

        emitter:Finish()
		
       if self:GetNWBool("HasDetonated") then
          self.SmokeTrail = false
       end
    end
end

function ENT:Think(data)
    if !IsValid(self) or self:GetNoDraw() then return end

    if !self.SpawnTime then
        self.SpawnTime = CurTime()
    end

    if !self.Armed and isnumber(self.TimeFuse) and self.SpawnTime + self.TimeFuse < CurTime() then
        self.ArmTime = CurTime()
        self.Armed = true
    end

    if self.Armed and self.ArmTime + self.Delay < CurTime() then
        self:PreDetonate(data)
    end
	
    if self.ExplodeUnderwater and self:WaterLevel() > 0 then
        self:PreDetonate(data)
		elseif self:WaterLevel() > 0 then
		local phys = self:GetPhysicsObject()
	    if phys:IsValid() then
		   phys:EnableGravity(true)
		   phys:EnableMotion(true)
		   phys:EnableDrag(false)
		   phys:SetMass(10)
	    end
		self:SetNWBool("HasDetonated",true)
		self:StopParticles()
    end
	
	if (self:WaterLevel() > 0) then
		self:StopParticles()
	end
	
    local gunship = {["npc_combinegunship"] = true,["npc_combinedropship"] = true}

    if SERVER and self.GunshipWorkaround and (self.GunshipCheck or 0 < CurTime()) then
            self.GunshipCheck = CurTime() + 0.33
            local tr = util.TraceLine({
                start = self:GetPos(),
                endpos = self:GetPos() + (self:GetVelocity() * 6 * engine.TickInterval()),
                filter = {self:GetOwner(), self},
                mask = MASK_SHOT_PORTAL,
                collisiongroup = COLLISION_GROUP_PROJECTILE,
            })
        if IsValid(tr.Entity) and gunship[tr.Entity:GetClass()] then
           self:SetPos(tr.HitPos)
           self:PreDetonate(data)
        end
    end

    self:DoSmokeTrail()
    self:OnThink()
end

function ENT:Use(ply)
    if !self.Defusable then return end

    self:EmitSound("TacRP/weapons/rifle_jingle-1.wav")

    if self.PickupAmmo then
        ply:GiveAmmo(1, self.PickupAmmo, true)
    end

    self:Remove()
end

function ENT:RemoteDetonate()
    self:EmitSound("TacRP/weapons/c4/relay_switch-1.wav")

    self.ArmTime = CurTime()
    self.Armed = true
end

function ENT:PreDetonate(data)
    if CLIENT then return end

    if !self.Detonated then
        self.Detonated = true

        if !IsValid(self.Attacker) and !IsValid(self:GetOwner()) then self.Attacker = game.GetWorld() end

        self:Detonate(data)
		self:SetNWBool("HasDetonated",true)
  end
end

function ENT:Detonate(data)
    -- fill this in :)
end

function ENT:Impact()
end

function ENT:Stuck()

end

function ENT:DrawTranslucent()
    self:Draw()
end

local mat = Material("mw19/flair_sprite_01")

function ENT:Draw()
    self:DrawModel()
   if self.Flare then
    if self.FlareColor then
        local mult = self.SafetyFuse and math.Clamp((CurTime() - (self.SpawnTime + self.SafetyFuse)) / self.SafetyFuse, 0.1, 1) or 1
        render.SetMaterial(mat)
        render.DrawSprite(self:GetPos() + (self:GetAngles():Forward() * -20), mult * math.Rand(self.FlareSizeMin, self.FlareSizeMax), mult * math.Rand(self.FlareSizeMin, self.FlareSizeMax), self.FlareColor)
    end
	 if self:GetNWBool("HasDetonated") then
     self.Flare = false
     end
   end
end

hook.Add("EntityTakeDamage", "cod2019_proj_collision", function(ent, dmginfo)
    if IsValid(dmginfo:GetInflictor())
            and scripted_ents.IsBasedOn(dmginfo:GetInflictor():GetClass(), "arc9_cod2019_proj_base")
            and dmginfo:GetDamageType() == DMG_CRUSH then dmginfo:SetDamage(0) return true end
end)
--PATH lua/entities/arccw_smoke/shared.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/entities/arccw_ubgl_flash.lua:
return gluapack()()
--PATH lua/entities/aura_hangar_console/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_hangar_console/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
	self.playerProp = nil
end

function ENT:Initialize()
  self.debugMode = false
end


surface.CreateFont( "Aura_Hangar_Font_1", {
	    font = "roboto",
	    italic = true,
	    size = 14,
	    weight = 700,
	    antialias = true,
} )

surface.CreateFont( "Aura_Hangar_Font_Menu4", {
      font = "roboto",
      italic = true,
      size = 14 * (ScrW() / 1920),
      weight = 400,
      antialias = true,
} )

surface.CreateFont( "Aura_Hangar_Font_Main", {
	    font = "roboto",
	    bold = true,
	    size = 18,
	    weight = 400,
	    antialias = true,
} )

surface.CreateFont( "Aura_Hangar_Font_Main2", {
      font = "Verdana",
      size = 15,
      weight = 1000,
      antialias = true,
} )

surface.CreateFont( "Aura_Hangar_Font_Menu1", {
	    font = "roboto",
	    italic = false,
	    size = 20 * (ScrW() / 1920),
	    weight = 400,
	    antialias = true,
} )

surface.CreateFont( "Aura_Hangar_Font_Menu2", {
	    font = "roboto",
	    italic = false,
	    size = 16 * (ScrW() / 1920),
	    weight = 400,
	    antialias = true,
} )

surface.CreateFont( "Aura_Hangar_Font_3", {
      font = "roboto",
      bold = true,
      size = 11 * (ScrW() / 1920),
      weight = 400,
      antialias = true,
} )

surface.CreateFont( "Aura_Hangar_Font_Debug", {
      font = "roboto",
      bold = true,
      size = 75 * (ScrW() / 1920),
      weight = 300 * (ScrW() / 1920),
      antialias = true,
} )

surface.CreateFont( "Aura_Hangar_Font_Debug2", {
      font = "roboto",
      bold = true,
      size = 20 * (ScrW() / 1920),
      weight = 300 * (ScrW() / 1920),
      antialias = true,
} )

net.Receive(("Aura_Hangar_Draw_Console"), function()
  local displayMaterial = Material("sprites/hangar_terminal_background_original2.png")
  local lineMaterial = Material("sprites/hangar_line_separater.png")
  
	local ent = net.ReadEntity()
	if (!IsValid(ent)) then return end

	local hangars = net.ReadTable()

	local displayX = 450
	local displayY = 300

	local yellowColor = Color(194, 194, 165,220)
	local darkColor = Color(19,34,41,220)

	hook.Add("PostDrawTranslucentRenderables","Aura_Hangar_Console_Hook" .. ent:EntIndex(), function()
		if (!IsValid(ent)) then return end

		  local up = 85 + (math.max(0,(#hangars - 13)) * 2)
		  local pos = ent:GetPos() + ent:GetUp() * up + ent:GetForward() * 20 + ent:GetRight() * (displayX / 20)

		  local ang = ent:GetAngles()
		  ang:RotateAroundAxis(ang:Forward(), 90)

      ang = ang + Angle(0,90,0)

     	cam.Start3D2D(pos, ang, .1)

      	surface.SetDrawColor(Color(255,255,255,255))
        surface.SetMaterial(displayMaterial)
      	surface.DrawTexturedRect(0,0,displayX,displayY)

        draw.DrawText("Fleet Manager","Aura_Hangar_Font_Main",displayX / 2,5,Color(255,255,255,255),TEXT_ALIGN_CENTER)

      	draw.DrawText("HANGAR","Aura_Hangar_Font_Main2",15,25,Color(0, 0, 0, 255),TEXT_ALIGN_LEFT)

      	draw.DrawText("SHIP","Aura_Hangar_Font_Main2",displayX - 32,25,Color(0, 0, 0, 255),TEXT_ALIGN_RIGHT)

        draw.DrawText("OWNER","Aura_Hangar_Font_Main2",displayX / 2,35,Color(0, 0, 0, 255),TEXT_ALIGN_CENTER)

      	if (hangars != nil) then
      		local height = 60
          surface.SetDrawColor(0,0,0,255)
          surface.SetMaterial(lineMaterial)
          surface.DrawTexturedRect(8,height - 6,displayX - 16,9)

      		for i=1,#hangars do

      			-----------------Formatting------------------

            surface.DrawTexturedRect(8,height + 15,displayX - 16,9)

      			local hangar = hangars[i]

      			surface.SetFont( "Aura_Hangar_Font_1" )
      			surface.SetTextColor(Color(255,255,255,255))

              	local num = hangar.number
                local ply = "None"
                if (IsValid(hangar.player) and hangar.player != nil and hangar.player:IsPlayer()) then
                  ply = hangar.player:Nick()
                end
              	local ship = hangar.ship
              	local name = "None"
                if (ship != nil) then
                	if (type(ship) == "string") then
                		ship = "None"
                	else
                		name = ship.PrintName or "None"
                	end
                end

              	draw.DrawText("Hangar " .. num,"Aura_Hangar_Font_1",10,height,Color(darkColor.r, darkColor.g, darkColor.b, 255),TEXT_ALIGN_LEFT)

              	draw.DrawText(name,"Aura_Hangar_Font_1",displayX - 10,height,Color(darkColor.r, darkColor.g, darkColor.b, 255),TEXT_ALIGN_RIGHT)
                draw.DrawText(ply,"Aura_Hangar_Font_1",displayX / 2,height,Color(darkColor.r, darkColor.g, darkColor.b, 255),TEXT_ALIGN_CENTER)

              	height = height + 20
              	---------------------------------------------
      		end

      	end
     	cam.End3D2D()
	end)
end)

net.Receive("Aura_Hangar_Open_Menu", function()

	local self = net.ReadEntity()
	local hangars = net.ReadTable()
  local shipSelection = net.ReadTable()
  local jobTable = net.ReadTable()
  local adminRanks = net.ReadTable()
	local hangarNum = #hangars

  function Aura_PermcheckAdmin()
    return table.HasValue(adminRanks.admin,LocalPlayer():GetUserGroup())
  end

  function Aura_PermcheckSuperadmin()
    return table.HasValue(adminRanks.superAdmin,LocalPlayer():GetUserGroup()) or LocalPlayer():IsSuperAdmin()
  end

	local xScale = (ScrW() / 1920)
	local yScale = (ScrH() / 1080)

	local xSize = 310 * xScale
	local ySize = 405 * yScale
  if (!Aura_PermcheckSuperadmin() and !Aura_PermcheckAdmin()) then
    ySize = 109 * yScale
  end

	local xPos = ScrW() / 2
	local yPos = ScrH() / 2

  local shipInfoStart = 98

	local adminMat = Material( "icon16/shield.png" )

	local frame = vgui.Create("DFrame") 
  frame:SetSize(xSize,ySize) 
  frame:ShowCloseButton(true)
  frame:Center()
  frame:MakePopup()
  frame:SetScreenLock(false)
  frame:SetTitle("")

  function frame:Paint( w, h )
      draw.RoundedBox(0,5 * xScale,30 * yScale,w,h,Color(10,10,10, 240))
      draw.RoundedBox(0,5 * xScale,5 * yScale,w,35 * yScale,Color(10,10,10, 240))
      draw.RoundedBox(0,10 * xScale,30 * yScale,w - 15 * xScale,h - 35 * yScale,Color(200,200,200, 150))
      draw.RoundedBox(0,10 * xScale,105 * yScale,w - 15 * xScale,ySize - (105 * yScale) - 5 * yScale,Color(255,255,255, 150))
  end

  -- TITLE STUFF
  if (true) then

    local titleText = vgui.Create("DLabel", frame)
    titleText:SetText("Hangar Settings")
    titleText:SetPos(90 * xScale, 2 * yScale)
    titleText:SetFont("Aura_Hangar_Font_Menu1")
    titleText:SetColor(Color(255,255,255,255))
    titleText:SetSize(1000 * xScale, 30 * yScale)

    local hangarCountText = vgui.Create("DLabel", frame)
    hangarCountText:SetText("Hangars: " .. hangarNum)
    hangarCountText:SetPos(15 * xScale, 25 * yScale)
    hangarCountText:SetFont("Aura_Hangar_Font_Menu2")
    hangarCountText:SetColor(Color(255,255,255,255))
    hangarCountText:SetSize(1000 * xScale, 30 * yScale)
  end

   -- Spawning of ships
  local firstAvailableHangar = Aura_GetAvailableHangar(hangars)
  local currentHangar = firstAvailableHangar or 1
  local hangarSelector
  local radiusSelector
  local radiusChangeText = vgui.Create("DLabel", frame)
  radiusChangeText:SetText("")

  if (true) then

      local shipInfoStartReal = (shipInfoStart * yScale) - (48 * yScale)
      
      local hangarCountText = vgui.Create("DLabel", frame)
      hangarCountText:SetText("  Please select a hangar")
      hangarCountText:SetPos(10 * xScale,shipInfoStartReal)
      hangarCountText:SetFont("Aura_Hangar_Font_Menu2")
      hangarCountText:SetColor(Color(255,255,255,255))
      hangarCountText:SetSize(xSize - 20 * xScale, 20 * yScale)
      function hangarCountText:Paint( w, h )
        draw.RoundedBox( 0, 4 * xScale, 1 * yScale, w, h, Color( 0,150,150,255 ) )
      end

      hangarSelector = vgui.Create("DComboBox", frame)
      hangarSelector:SetValue(firstAvailableHangar or 1)
      hangarSelector:SetSize(80 * xScale,15 * yScale)
      hangarSelector:SetPos(xSize - 95 * xScale, shipInfoStartReal + (2.7 * yScale))
      hangarSelector:SetFont("Aura_Hangar_Font_Menu4")
      for i=1,#hangars do
        hangarSelector:AddChoice("Hangar " .. i)
      end

      hangarSelector.OnSelect = function( self, index, value )
          currentHangar = index
          if (Aura_PermcheckSuperadmin() or Aura_PermcheckAdmin()) then
            radiusChangeText:SetText("  Set Radius of hangar " .. currentHangar)
            radiusSelector:SetValue(hangars[index].radius)
          end
      end

      local spawnShip = vgui.Create("DButton", frame)
      spawnShip:SetSize(xSize - (20 * xScale), 20 * yScale)
      spawnShip:SetPos(10 * xScale, shipInfoStartReal + (30 * yScale))
      spawnShip:SetTextColor(Color(255,255,255,255))
      if (firstAvailableHangar != nil) then
          spawnShip:SetText("Spawn Ship")
      else
          spawnShip:SetText("There are no open hangars!")
      end
      spawnShip:SetFont("Aura_Hangar_Font_Menu2")
      spawnShip.DoClick = function()
        if (firstAvailableHangar != nil) then
          if (RPExtraTeams) then
            local job = RPExtraTeams[LocalPlayer():Team()].name
            local jobExists = nil
            for i=1,#jobTable do
              if (jobTable[i].job == job) then
                jobExists = i
              end
            end
            if (jobExists != nil) then
              local menu = DermaMenu() 
              for i=1,#jobTable[jobExists].ships do
                local class = Aura_Find_Class_From_Name(jobTable[jobExists].ships[i]) or ""
                menu:AddOption(jobTable[jobExists].ships[i], function() Aura_SendHangarShipInformation(class) end)
              end
              menu:Open()
              if (#jobTable[jobExists].ships == 0) then
                LocalPlayer():ChatPrint("Your job has no vehicles to spawn!")
              end
              return
            else
              LocalPlayer():ChatPrint("Your job is not set up in the config")
              return
            end
          end
          if (!hangars[currentHangar].isTaken) then 
            Aura_Hangar_Draw_Ship_Selection()
          else
            LocalPlayer():ChatPrint("That hangar is already in use!")
          end
        else

        end
      end
      function spawnShip:Paint( w, h )
        draw.RoundedBox( 0, 4 * xScale, 2 * yScale, w, h, Color( 0,150,0,255 ) )
      end

      function Aura_Hangar_Draw_Ship_Selection()
          local menu = DermaMenu() 
          for i=1,#shipSelection do
            menu:AddOption(shipSelection[i].name, function() Aura_SendHangarShipInformation(shipSelection[i].class) end)
          end
          menu:Open()
      end

      function Aura_SendHangarShipInformation(class)
          net.Start("Aura_Hangar_Client_Spawn_Ship")
            net.WriteEntity(self)
            net.WriteEntity(LocalPlayer())
            net.WriteInt(currentHangar,8)
            net.WriteString(class)
          net.SendToServer()
          frame:Close()
      end

      function Aura_Find_Class_From_Name(name)
          for k=1,#shipSelection do
            if (shipSelection[k].name == name and class == nil) then
              return shipSelection[k].class
            end 
          end
          return nil
      end
  end

  -- Anything that requires admin perms to see
  if (Aura_PermcheckSuperadmin() or Aura_PermcheckAdmin()) then
    -- Add or remove hangars
    if (true) then
        local addHangar = vgui.Create("DButton", frame)
        addHangar:SetSize(xSize - (20 * xScale), 20 * yScale)
        addHangar:SetPos(10 * xScale, 110 * yScale)
        addHangar:SetTextColor(Color(255,255,255,255))
        addHangar:SetText("Add Hangar")
        addHangar:SetFont("Aura_Hangar_Font_Menu2")
        addHangar.DoClick = function() 
          	if (Aura_PermcheckSuperadmin() or Aura_PermcheckAdmin()) then
      	    	net.Start("Aura_Hangar_Client_Add_Hangar")
      	    	net.WriteEntity(self)
      	    	net.WriteEntity(LocalPlayer())
      	    	net.SendToServer()
      	        frame:Close()
      	    else
      	    	chat.AddText(Color(150,0,0,255), LocalPlayer():Nick() .. ", you do not have permission to add a hangar!")
      	    end
        end
        function addHangar:Paint( w, h )
          draw.RoundedBox( 0, 4 * xScale, 2 * yScale, w, h, Color( 0,150,0,255 ) )

        	surface.SetDrawColor( 255, 255, 255, 255 )
    		  surface.SetMaterial( adminMat )
        	surface.DrawTexturedRect( 10 * xScale, 2.5 * yScale, 16 * xScale, 16 * yScale )
        end

        local removeHangar = vgui.Create("DButton", frame)
        removeHangar:SetSize(xSize - (20 * xScale), 20 * yScale)
        removeHangar:SetPos(10 * xScale, 140 * yScale)
        removeHangar:SetTextColor(Color(255,255,255,255))
        removeHangar:SetText("Remove Hangar")
        removeHangar:SetFont("Aura_Hangar_Font_Menu2")
        removeHangar.DoClick = function() 
            if (Aura_PermcheckSuperadmin() or Aura_PermcheckAdmin()) then
                net.Start("Aura_Hangar_Client_Remove_Hangar")
                net.WriteEntity(self)
                net.WriteEntity(LocalPlayer())
                net.SendToServer()
                frame:Close()
            else
                chat.AddText(Color(150,0,0,255), LocalPlayer():Nick() .. ", you do not have permission to remove a hangar!")
            end
        end

        function removeHangar:Paint( w, h )
            draw.RoundedBox( 0, 4 * xScale, 2 * yScale, w, h, Color( 150,0,0,255 ) )

            surface.SetDrawColor( 255, 255, 255, 255 )
            surface.SetMaterial( adminMat )
            surface.DrawTexturedRect( 10 * xScale, 2.5 * yScale, 16 * xScale, 16 * yScale )
        end
    end

    -- Hide / show hangar blocks
    if (true) then
      local hideHangarBlocks = vgui.Create("DButton", frame)
      hideHangarBlocks:SetSize(xSize - (20 * xScale), 20 * yScale)
      hideHangarBlocks:SetPos(10 * xScale, 170 * yScale)
      hideHangarBlocks:SetTextColor(Color(255,255,255,255))
      hideHangarBlocks:SetText("Hide Hangar Blocks")
      hideHangarBlocks:SetFont("Aura_Hangar_Font_Menu2")
      hideHangarBlocks.DoClick = function()
        if (Aura_PermcheckSuperadmin() or Aura_PermcheckAdmin()) then
          net.Start("Aura_Hangar_Hide_Blocks")
          net.WriteEntity(self)
          net.SendToServer()
        else
          chat.AddText(Color(150,0,0,255), LocalPlayer():Nick() .. ", you do not have permission to hide hangar blocks!")
        end
      end
      function hideHangarBlocks:Paint( w, h )
        draw.RoundedBox( 0, 4 * xScale, 1 * yScale, w, h, Color( 0,150,0,255 ) )

        surface.SetDrawColor( 255, 255, 255, 255 )
      surface.SetMaterial( adminMat )
        surface.DrawTexturedRect( 10 * xScale, 2.5 * yScale, 16 * xScale, 16 * yScale )
      end

      local showHangarBlocks = vgui.Create("DButton", frame)
      showHangarBlocks:SetSize(xSize - (20 * xScale), 20 * yScale)
      showHangarBlocks:SetPos(10 * xScale, 200 * yScale)
      showHangarBlocks:SetTextColor(Color(255,255,255,255))
      showHangarBlocks:SetText("Show Hangar Blocks")
      showHangarBlocks:SetFont("Aura_Hangar_Font_Menu2")
      showHangarBlocks.DoClick = function()
        if (Aura_PermcheckSuperadmin() or Aura_PermcheckAdmin()) then
          net.Start("Aura_Hangar_Show_Blocks")
          net.WriteEntity(self)
          net.SendToServer()
        else
          chat.AddText(Color(150,0,0,255), LocalPlayer():Nick() .. ", you do not have permission to show hangar blocks!")
        end
      end
      function showHangarBlocks:Paint( w, h )
        draw.RoundedBox( 0, 2 * xScale, 2 * yScale, w, h, Color( 0,150,0,255 ) )

        surface.SetDrawColor( 255, 255, 255, 255 )
        surface.SetMaterial( adminMat )
        surface.DrawTexturedRect( 10 * xScale, 2.5 * yScale, 16 * xScale, 16 * yScale )
      end
    end

    -- Adding of ships
    if (true) then
        local subFrameIsOpen = false

        local addShip = vgui.Create("DButton", frame)
        addShip:SetSize(xSize / 2 - (20 * xScale), 20 * yScale)
        addShip:SetPos(10 * xScale, ySize - (145 * yScale))
        addShip:SetTextColor(Color(255,255,255,255))
        addShip:SetText("Add Ship")
        addShip:SetFont("Aura_Hangar_Font_Menu2")
        addShip.DoClick = function() 
            if (Aura_PermcheckSuperadmin() or Aura_PermcheckAdmin()) then
                if (true and !subFrameIsOpen) then
                    subFrameIsOpen = true
                    local xs = 200 * xScale
                    local ys = 100 * yScale
                    local subFrame = vgui.Create("DFrame") 
                    subFrame:SetSize(0,ys) 
                    subFrame:ShowCloseButton(true)
                    subFrame:SetPos(xPos + xSize / 2 - (4 * xScale), yPos - ySize / 2 + (100 * yScale))
                    subFrame:MakePopup()
                    subFrame:SetScreenLock(false)
                    subFrame:SetTitle("")
                    if (IsValid(subFrame) and subFrame != nil) then
                        subFrame:SizeTo(xs,ys,.3,0,1, function() end)
                    end

                    function subFrame:OnClose()
                        subFrameIsOpen = false
                    end

                    function subFrame:Paint( w, h )
                        draw.RoundedBox(0,0,0,w,h,Color(50,50,50, 255))
                        draw.RoundedBox(0,5 * xScale,5 * yScale,w - 10 * xScale,h - 10 * yScale,Color(100,100,100, 255))
                    end

                    local TextEntry = vgui.Create( "DTextEntry", subFrame ) -- create the form as a child of frame
                    TextEntry:SetPos( 10 * xScale, 20 * yScale )
                    TextEntry:SetSize( 180 * xScale, 20 * yScale )
                    TextEntry:SetValue( "Class (right click and copy in Q menu)" )
                    
                    local TextEntry2 = vgui.Create( "DTextEntry", subFrame ) -- create the form as a child of frame
                    TextEntry2:SetPos( 10 * xScale, 50 * yScale )
                    TextEntry2:SetSize( 180 * xScale, 20 * yScale )
                    TextEntry2:SetValue( "Name (whatever you want to show as)" )
                    
                    local addButton = vgui.Create("DButton", subFrame)
                    addButton:SetSize(100 * xScale, 20 * yScale)
                    addButton:SetPos(45 * xScale, 75 * yScale)
                    addButton:SetTextColor(Color(255,255,255,255))
                    addButton:SetText("Add")
                    addButton:SetFont("Aura_Hangar_Font_Menu2")
                    addButton.DoClick = function() 
                      subFrame:Close()
                      Aura_AddShipToHangarList(TextEntry:GetValue(), TextEntry2:GetValue())
                    end
                    function addButton:Paint( w, h )
                      draw.RoundedBox( 0, 4 * xScale, 2 * yScale, w, h, Color( 0,150,0,255 ) )
                    end
                end
            else
              chat.AddText(Color(150,0,0,255), LocalPlayer():Nick() .. ", you do not have permission to add a ship!")
            end
        end
        function addShip:Paint( w, h )
          draw.RoundedBox( 0, 4 * xScale, 2 * yScale, w, h, Color( 0,150,0,255 ) )

          surface.SetDrawColor( 255, 255, 255, 255 )
          surface.SetMaterial( adminMat )
          surface.DrawTexturedRect( 10 * xScale, 2.5 * yScale, 16 * xScale, 16 * yScale)
        end

        local subFrameIsOpen = false

        local removeShip = vgui.Create("DButton", frame)
        removeShip:SetSize(xSize / 2 - (20 * xScale), 20 * yScale)
        removeShip:SetPos(xSize / 2 + (10 * xScale), ySize - (145 * yScale))
        removeShip:SetTextColor(Color(255,255,255,255))
        removeShip:SetText("Remove Ship")
        removeShip:SetFont("Aura_Hangar_Font_Menu2")
        removeShip.DoClick = function() 
            if (Aura_PermcheckSuperadmin() or Aura_PermcheckAdmin()) then
              if (true and !subFrameIsOpen) then
                  subFrameIsOpen = true
                  local xs = 200 * xScale
                  local ys = 220 * yScale

                  local subFrame = vgui.Create("DFrame") 
                  subFrame:SetSize(0,ys) 
                  subFrame:ShowCloseButton(true)
                  subFrame:SetPos(xPos + xSize / 2 - (4 * xScale), yPos - ySize / 2 + (100 * yScale))
                  subFrame:MakePopup()
                  subFrame:SetScreenLock(false)
                  subFrame:SetTitle("")
                  if (IsValid(subFrame) and subFrame != nil) then
                      subFrame:SizeTo(xs,ys,.3,0,1, function() end)
                  end

                  function subFrame:OnClose()
                      subFrameIsOpen = false
                  end

                  function subFrame:Paint( w, h )
                      draw.RoundedBox(0,0,0,w,h,Color(50,50,50, 255))
                      draw.RoundedBox(0,5 * xScale,5 * yScale,w - 10 * xScale,h - 10 * yScale,Color(100,100,100, 255))
                  end

                  local removeShipText = vgui.Create("DLabel", subFrame)
                  removeShipText:SetPos(10 * xScale, 5 * yScale)
                  removeShipText:SetTextColor(Color(255,255,255,255))
                  removeShipText:SetFont("Aura_Hangar_Font_Menu2")
                  removeShipText:SetText("Removing ships")
                  removeShipText:SizeToContents()

                  local shipList = vgui.Create("DListView",subFrame)
                  shipList:Dock( FILL )
                  shipList:DockMargin( 10 * xScale, 0, 25 * yScale, 10 * xScale)
                  shipList:SetSize(xs - 20 * xScale, 150 * yScale)
                  shipList:SetMultiSelect( false )
                  shipList:AddColumn( "Click on a ship to remove" )

                  function shipList:OnRowSelected(index,line)
                    local ship = line:GetValue(1)
                    Aura_HangarRemoveShip(ship)
                    shipList:RemoveLine(index)
                  end

                  -- Remove jobs we already added and insert into list
                  for i=1,#shipSelection do
                    shipList:AddLine(shipSelection[i].name)
                  end
                  
                end
            else
              chat.AddText(Color(150,0,0,255), LocalPlayer():Nick() .. ", you do not have permission to remove a ship!")
            end
        end
        function removeShip:Paint( w, h )
          draw.RoundedBox( 0, 4 * xScale, 2 * yScale, w, h, Color( 150,0,0,255 ) )

          surface.SetDrawColor( 255, 255, 255, 255 )
          surface.SetMaterial( adminMat )
          surface.DrawTexturedRect( 10 * xScale, 2.5 * yScale, 16 * xScale, 16 * yScale )
        end

        function Aura_AddShipToHangarList(c, n)
          for i=1,#shipSelection do
            if (shipSelection[i].class == c) then
              LocalPlayer():ChatPrint("That ship class is already in the list!")
              return
            end
            if (shipSelection[i].name == n) then
              LocalPlayer():ChatPrint("There is already a ship with that name in the list, you may want to change the name...")
              return
            end
          end
          net.Start("Aura_Hangar_Add_Ship")
          net.WriteEntity(self)
          net.WriteString(c)
          net.WriteString(n)
          net.WriteEntity(LocalPlayer())
          net.SendToServer()
          table.insert(shipSelection,{class = c .. "", name = n .. ""})
          table.SortByMember(shipSelection,"name",true)
        end

        function Aura_HangarRemoveShip(ship)
            local index

            for i=1,#shipSelection do
              if (shipSelection[i].name == ship) then
                index = i
              end
            end

            net.Start("Aura_Hangar_Remove_Ship")
            net.WriteEntity(self)
            net.WriteEntity(LocalPlayer())
            net.WriteInt(index,5)
            net.SendToServer()
            table.remove(shipSelection,index)
        end
    end

    -- Adding / removing of jobs
    if (true) then

        local subFrameIsOpen = false

        local addJob = vgui.Create("DButton", frame)
        addJob:SetSize(xSize / 2 - (20 * xScale), 20 * yScale)
        addJob:SetPos(10 * xScale, ySize - (115 * yScale))
        addJob:SetTextColor(Color(255,255,255,255))
        addJob:SetText("Add Job")
        addJob:SetFont("Aura_Hangar_Font_Menu2")
        addJob.DoClick = function() 
            if (Aura_PermcheckSuperadmin() or Aura_PermcheckAdmin()) then
              if (RPExtraTeams) then
                if (true and !subFrameIsOpen) then
                  subFrameIsOpen = true
                  local xs = 200 * xScale
                  local ys = 220 * yScale

                  local subFrame = vgui.Create("DFrame") 
                  subFrame:SetSize(0,ys) 
                  subFrame:ShowCloseButton(true)
                  subFrame:SetPos(xPos + xSize / 2 - (4 * xScale), yPos - ySize / 2 + (100 * yScale))
                  subFrame:MakePopup()
                  subFrame:SetScreenLock(false)
                  subFrame:SetTitle("")
                  if (IsValid(subFrame) and subFrame != nil) then
                      subFrame:SizeTo(xs,ys,.3,0,1, function() end)
                  end

                  function subFrame:OnClose()
                      subFrameIsOpen = false
                  end

                  function subFrame:Paint( w, h )
                      draw.RoundedBox(0,0,0,w,h,Color(50,50,50, 255))
                      draw.RoundedBox(0,5 * xScale,5 * yScale,w - 10 * xScale,h - 10 * yScale,Color(100,100,100, 255))
                  end

                  local addJobText = vgui.Create("DLabel", subFrame)
                  addJobText:SetPos(10 * xScale, 5 * yScale)
                  addJobText:SetTextColor(Color(255,255,255,255))
                  addJobText:SetFont("Aura_Hangar_Font_Menu2")
                  addJobText:SetText("Adding Jobs")
                  addJobText:SizeToContents()

                  local groupList = vgui.Create("DListView",subFrame)
                  groupList:Dock( FILL )
                  groupList:DockMargin( 10 * xScale, 0, 25 * yScale, 10 * xScale)
                  groupList:SetSize(xs - 20 * xScale, 150 * yScale)
                  groupList:SetMultiSelect( false )
                  groupList:AddColumn( "Click on a job to add" )

                  function groupList:OnRowSelected(index,line)
                    local job = line:GetValue(1)
                    Aura_AddJobToHangarList(job)
                    groupList:RemoveLine(index)
                  end

                  -- Remove jobs we already added and insert into list
                  for i=1,#RPExtraTeams do
                    local shouldAdd = true
                    for k=1,#jobTable do
                      if (jobTable[k].job == RPExtraTeams[i].name and shouldAdd) then
                        shouldAdd = false
                      end
                    end
                    if (shouldAdd) then
                      groupList:AddLine(RPExtraTeams[i].name)
                    end
                  end
                  
                end
              else
                if (true and !subFrameIsOpen) then
                    subFrameIsOpen = true
                    local xs = 200 * xScale
                    local ys = 100 * yScale
                    local subFrame = vgui.Create("DFrame") 
                    subFrame:SetSize(0,ys) 
                    subFrame:ShowCloseButton(true)
                    subFrame:SetPos(xPos + xSize / 2 - (4 * xScale), yPos - ySize / 2 + (100 * yScale))
                    subFrame:MakePopup()
                    subFrame:SetScreenLock(false)
                    subFrame:SetTitle("")
                    if (IsValid(subFrame) and subFrame != nil) then
                        subFrame:SizeTo(xs,ys,.3,0,1, function() end)
                    end

                    function subFrame:OnClose()
                        subFrameIsOpen = false
                    end

                    function subFrame:Paint( w, h )
                        draw.RoundedBox(0,0,0,w,h,Color(50,50,50, 255))
                        draw.RoundedBox(0,5,5,w - 10,h - 10,Color(100,100,100, 255))
                    end

                    local TextEntry = vgui.Create( "DTextEntry", subFrame ) -- create the form as a child of frame
                    TextEntry:SetPos( 10 * xScale, 20 * yScale )
                    TextEntry:SetSize( 180 * xScale, 20 * yScale )
                    TextEntry:SetValue( "Job Name (Must be same as F4 menu)" )

                    local addJobLabel = vgui.Create( "DLabel", subFrame )
                    addJobLabel:SetPos(10 * xScale, 50 * xScale)
                    addJobLabel:SetTextColor(Color(255,255,255,255))
                    addJobLabel:SetFont("Aura_Hangar_Font_3")
                    addJobLabel:SetText("Make sure it matches spelling in F4 menu\nbut capitalization DOES matter")
                    addJobLabel:SizeToContents()
                    
                    local addButton = vgui.Create("DButton", subFrame)
                    addButton:SetSize(100 * xScale, 20 * yScale)
                    addButton:SetPos(45 * xScale, 75 * yScale)
                    addButton:SetTextColor(Color(255,255,255,255))
                    addButton:SetText("Add")
                    addButton:SetFont("Aura_Hangar_Font_Menu2")
                    addButton.DoClick = function() 
                      subFrame:Close()
                      Aura_AddJobToHangarList(TextEntry:GetValue())
                    end
                    function addButton:Paint( w, h )
                      draw.RoundedBox( 0, 2 * xScale, 2 * yScale, w, h, Color( 0,150,0,255 ) )
                    end
                end
              end
            else
              chat.AddText(Color(150,0,0,255), LocalPlayer():Nick() .. ", you do not have permission to add a ship!")
            end
        end

        function addJob:Paint( w, h )
          draw.RoundedBox( 0, 4 * xScale, 2 * yScale, w, h, Color( 0,150,0,255 ) )

          surface.SetDrawColor( 255, 255, 255, 255 )
          surface.SetMaterial( adminMat )
          surface.DrawTexturedRect( 10 * xScale, 2.5 * yScale, 16 * xScale, 16 * yScale )
        end

        local subFrame2IsOpen = false

        local removeJob = vgui.Create("DButton", frame)
        removeJob:SetSize(xSize / 2 - (20 * xScale), 20 * yScale)
        removeJob:SetPos(xSize / 2 + (10 * xScale), ySize - (115 * yScale))
        removeJob:SetTextColor(Color(255,255,255,255))
        removeJob:SetText("Remove Job")
        removeJob:SetFont("Aura_Hangar_Font_Menu2")
        removeJob.DoClick = function() 
            if (true and !subFrame2IsOpen) then
              subFrame2IsOpen = true
              local xs = 200 * xScale
              local ys = 220 * yScale

              local subFrame = vgui.Create("DFrame") 
              subFrame:SetSize(0,ys) 
              subFrame:ShowCloseButton(true)
              subFrame:SetPos(xPos + xSize / 2 - (4 * xScale), yPos - ySize / 2 + (100 * yScale))
              subFrame:MakePopup()
              subFrame:SetScreenLock(false)
              subFrame:SetTitle("")
              if (IsValid(subFrame) and subFrame != nil) then
                  subFrame:SizeTo(xs,ys,.3,0,1, function() end)
              end

              function subFrame:OnClose()
                  subFrame2IsOpen = false
              end

              function subFrame:Paint( w, h )
                  draw.RoundedBox(0,0,0,w,h,Color(50,50,50, 255))
                  draw.RoundedBox(0,5 * xScale,5 * yScale,w - 10 * xScale,h - 10 * yScale,Color(100,100,100, 255))
              end

              local addJobText = vgui.Create("DLabel", subFrame)
              addJobText:SetPos(10 * xScale, 5 * yScale)
              addJobText:SetTextColor(Color(255,255,255,255))
              addJobText:SetFont("Aura_Hangar_Font_Menu2")
              addJobText:SetText("Removing Jobs")
              addJobText:SizeToContents()

              local groupList = vgui.Create("DListView",subFrame)
              groupList:Dock( FILL )
              groupList:DockMargin( 10 * xScale, 0, 25 * xScale, 10 * yScale )
              groupList:SetSize(xs - 20 * xScale, 150 * yScale)
              groupList:SetMultiSelect( false )
              groupList:AddColumn( "Click on a job to remove" )

              function groupList:OnRowSelected(index,line)
                local job = line:GetValue(1)
                Aura_RemoveJobFromHangarList(job)
                groupList:RemoveLine(index)
              end

              -- Remove jobs we already added and insert into list
              for i=1,#jobTable do
                groupList:AddLine(jobTable[i].job)
              end
              
            end
        end
        function removeJob:Paint( w, h )
          draw.RoundedBox( 0, 4 * xScale, 2 * xScale, w, h, Color( 150,0,0,255 ) )

          surface.SetDrawColor( 255, 255, 255, 255 )
          surface.SetMaterial( adminMat )
          surface.DrawTexturedRect( 10 * xScale, 2.5 * yScale, 16 * xScale, 16 * yScale )
        end

        function Aura_AddJobToHangarList(job)
          if (DarkRP) then
              net.Start("Aura_Hangar_Add_Job")
              net.WriteEntity(self)
              net.WriteEntity(LocalPlayer())
              net.WriteString(job)
              net.SendToServer()
              table.insert(jobTable, {job = job, ships = {}})
              table.SortByMember(jobTable,"job",true)
              return
          else
            local tempJob = string.lower(job)
            for i=1,#jobTable do
              local jobName = jobTable[i].job
              if (string.lower(jobName) == tempJob) then
                LocalPlayer():ChatPrint("That job is already in the job list!")
                return
              end
            end
            net.Start("Aura_Hangar_Add_Job")
            net.WriteEntity(self)
            net.WriteEntity(LocalPlayer())
            net.WriteString(job)
            net.SendToServer()
            table.insert(jobTable, {job = job, ships = {}})
            table.SortByMember(jobTable,"job",true)
          end
        end

        function Aura_RemoveJobFromHangarList(job)
            local num = 0
            for i=1,#jobTable do
              if (jobTable[i].job == job) then
                num = i
              end
            end
            net.Start("Aura_Hangar_Remove_Job")
            net.WriteEntity(self)
            net.WriteEntity(LocalPlayer())
            net.WriteInt(num,5)
            net.SendToServer()
            table.remove(jobTable,num)
        end
    end

    -- Debug mode
    if (true) then
      local debug = self.debugMode
      local debugMode = vgui.Create("DButton", frame)
        debugMode:SetSize(xSize / 2, 20 * yScale)
        debugMode:SetPos(xSize / 4, ySize - (58 * yScale))
        debugMode:SetTextColor(Color(255,255,255,255))
        if (self.debugMode) then
          debugMode:SetText("Debug Mode -- ON")
        else
          debugMode:SetText("Debug Mode -- OFF")
        end
        debugMode:SetFont("Aura_Hangar_Font_Menu2")
        debugMode.DoClick = function() 
            if (Aura_PermcheckSuperadmin() or Aura_PermcheckAdmin()) then
              self.debugMode = !self.debugMode
              debug = self.debugMode
            else
              chat.AddText(Color(150,0,0,255), LocalPlayer():Nick() .. ", you do not have permission to enable debug mode!")
            end
            frame:Close()
        end
        function debugMode:Paint( w, h )
          if (debug) then
            draw.RoundedBox( 0, 2 * xScale, 2 * yScale, w, h, Color( 0,150,0,255 ) )
          else
            draw.RoundedBox( 0, 2 * xScale, 2 * xScale, w, h, Color( 150,0,0,255 ) )
          end
          surface.SetDrawColor( 255, 255, 255, 255 )
          surface.SetMaterial( adminMat )
          surface.DrawTexturedRect( 5 * xScale, 2.5 * yScale, 16 * xScale, 16 * yScale )
        end
    end

    -- Change radius of hangar
    if (true) then
        radiusChangeText:SetText("  Set Radius of hangar " .. currentHangar)
        radiusChangeText:SetPos(10 * xScale,230 * yScale)
        radiusChangeText:SetFont("Aura_Hangar_Font_Menu2")
        radiusChangeText:SetColor(Color(255,255,255,255))
        radiusChangeText:SetSize(xSize - 20 * xScale, 20 * yScale)
        function radiusChangeText:Paint( w, h )
          draw.RoundedBox( 0, 2 * xScale, 2 * yScale, w, h, Color( 0,150,150,255 ) )
        end

        radiusSelector = vgui.Create("DNumberWang", frame)
        local rad = 0
        if (#hangars > 0) then
          rad = hangars[currentHangar].radius
        end
        radiusSelector:SetMin(10)
        radiusSelector:SetMax(100000)
        radiusSelector:SetValue(rad)
        radiusSelector:SetSize(70 * xScale,15 * yScale)
        radiusSelector:SetPos(xSize - 140 * xScale, 230 * yScale + (3 * yScale))
        radiusSelector:SetFont("Aura_Hangar_Font_Menu2")
        radiusSelector.OnValueChanged = function( self, val )
        end

        local setRadius = vgui.Create("DButton", frame)
        setRadius:SetSize(50 * xScale, 15 * yScale)
        setRadius:SetPos(xSize - (70 * xScale), 232 * yScale)
        setRadius:SetTextColor(Color(255,255,255,255))
        setRadius:SetText("   Set")
        setRadius:SetFont("Aura_Hangar_Font_Menu2")
        setRadius.DoClick = function() 
            if (Aura_PermcheckSuperadmin() or Aura_PermcheckAdmin()) then
              net.Start("Aura_Hangar_Change_Radius")
              net.WriteEntity(self)
              net.WriteEntity(LocalPlayer())
              net.WriteInt(currentHangar,8)
              net.WriteInt(radiusSelector:GetValue(),16)
              net.SendToServer()
            else
              chat.AddText(Color(150,0,0,255), LocalPlayer():Nick() .. ", you do not have permission to change radius!")
            end
            frame:Close()
        end
        function setRadius:Paint( w, h )
          draw.RoundedBox( 0, 2 * xScale, 2 * yScale, w, h, Color( 150,0,0,255 ) )
          surface.SetDrawColor( 255, 255, 255, 255 )
          surface.SetMaterial( adminMat )
          surface.DrawTexturedRect( 5 * xScale, 2 * yScale, 12 * xScale, 12 * yScale )
        end
    end

    -- Edit jobs
    if (true) then
      local subFrameIsOpen = false

      local jobEdit = vgui.Create("DButton", frame)
        jobEdit:SetSize(xSize / 2, 20 * yScale)
        jobEdit:SetPos(xSize / 4, ySize - (30 * yScale))
        jobEdit:SetTextColor(Color(255,255,255,255))
        jobEdit:SetText("Edit Jobs")
        jobEdit:SetFont("Aura_Hangar_Font_Menu2")
        jobEdit.DoClick = function() 
            if (true and !subFrameIsOpen) then
                local currentJob = nil
                local currentJobIndex = nil
                subFrameIsOpen = true
                local xs = 200 * xScale
                local ys = 50 * yScale
                local secondYSize = 200 * yScale
                local shipList

                local subFrame = vgui.Create("DFrame") 
                subFrame:SetSize(0,ys) 
                subFrame:ShowCloseButton(true)
                subFrame:SetPos(xPos + xSize / 2 - (4 * xScale), yPos - ySize / 2 + (100 * yScale))
                subFrame:MakePopup()
                subFrame:SetScreenLock(false)
                subFrame:SetTitle("")
                if (IsValid(subFrame) and subFrame != nil) then
                    subFrame:SizeTo(xs,ys,.3,0,1, function() end)
                end

                function subFrame:OnClose()
                    subFrameIsOpen = false
                end

                function subFrame:Paint( w, h )
                    draw.RoundedBox(0,0,0,w,h,Color(50,50,50, 255))
                    draw.RoundedBox(0,5 * xScale,5 * yScale,w - 10,h - 10,Color(100,100,100, 255))
                end

                local jobSelector = vgui.Create( "DComboBox", subFrame )
                jobSelector:SetPos( 10 * xScale, 20 * yScale )
                jobSelector:SetSize( xs - 20 * xScale, 20 * yScale )
                jobSelector:SetValue( "Please select a job" )
                for i=1,#jobTable do
                    jobSelector:AddChoice(jobTable[i].job)
                end
                jobSelector.OnSelect = function( s, index, value )
                    currentJob = value
                    currentJobIndex = index

                    if (IsValid(subFrame) and subFrame != nil) then
                      subFrame:SizeTo(xs,secondYSize,.3,0,1, function() end)
                    end

                    local addShipToJob = vgui.Create("DButton", subFrame)
                    addShipToJob:SetSize(xs - (20 * xScale), 20 * yScale)
                    addShipToJob:SetPos(10 * xScale, 45 * yScale)
                    addShipToJob:SetTextColor(Color(255,255,255,255))
                    addShipToJob:SetText("Add ship to job")
                    addShipToJob:SetFont("Aura_Hangar_Font_Menu2")
                    addShipToJob.DoClick = function() 
                        local menu = DermaMenu() 
                        for i=1,#shipSelection do
                          if (!table.HasValue(jobTable[currentJobIndex].ships,shipSelection[i].name)) then
                            menu:AddOption(shipSelection[i].name, function()
                                net.Start("Aura_Hangar_Add_Ship_To_Job")
                                net.WriteEntity(self)
                                net.WriteInt(currentJobIndex, 8)
                                net.WriteString(shipSelection[i].name)
                                net.SendToServer()

                                table.insert(jobTable[currentJobIndex].ships, shipSelection[i].name)
                                table.sort(jobTable[currentJobIndex].ships, function(a, b) return a < b end)
                                shipList:AddLine(shipSelection[i].name)
                                shipList:SortByColumn(1)
                            end)
                          end
                        end
                        menu:Open()
                    end
                    function addShipToJob:Paint( w, h )
                      draw.RoundedBox( 0, 2 * xScale, 2 * yScale, w, h, Color( 0,150,0,255 ) )
                    end

                    shipList = vgui.Create("DListView",subFrame)
                    shipList:Dock( FILL )
                    shipList:DockMargin( 10 * xScale, 50 * yScale, 10 * xScale, 10  * yScale)
                    shipList:SetSize(xs - 20 * xScale, 120 * yScale)
                    shipList:SetMultiSelect( false )
                    shipList:AddColumn( "Ship Name -- Click to remove" )

                    local tempSelf = self

                    function shipList:OnRowSelected(index,line)
                      net.Start("Aura_Hangar_Remove_Ship_From_Job")
                      net.WriteEntity(tempSelf)
                      net.WriteInt(currentJobIndex, 7)
                      net.WriteString(line:GetValue(1))
                      net.SendToServer()
                      table.RemoveByValue(jobTable[currentJobIndex].ships,line:GetValue(1))
                      shipList:RemoveLine(index)
                    end

                    for i=1,#jobTable[currentJobIndex].ships do
                        shipList:AddLine( jobTable[currentJobIndex].ships[i])
                    end

                    shipList:SortByColumn(1)

                end
            else
              chat.AddText(Color(150,0,0,255), LocalPlayer():Nick() .. ", you do not have permission to edit jobs!")
            end
        end
        function jobEdit:Paint( w, h )
          if (debug) then
            draw.RoundedBox( 0, 2 * xScale, 2 * yScale, w, h, Color( 0,150,0,255 ) )
          else
            draw.RoundedBox( 0, 2, 2, w, h, Color( 150,0,0,255 ) )
          end
          surface.SetDrawColor( 255, 255, 255, 255 )
          surface.SetMaterial( adminMat )
          surface.DrawTexturedRect( 10 * xScale, 2.5 * yScale, 16 * xScale, 16 * yScale)
        end
    end

     -- Edit permissions
    if (true) then
      local subFrameIsOpen = false

      local permEdit = vgui.Create("DButton", frame)
        permEdit:SetSize(xSize / 2, 20 * yScale)
        permEdit:SetPos(xSize / 4, ySize - (85 * yScale))
        permEdit:SetTextColor(Color(255,255,255,255))
        permEdit:SetText("Edit Permissions")
        permEdit:SetFont("Aura_Hangar_Font_Menu2")
        permEdit.DoClick = function() 
          if (Aura_PermcheckSuperadmin()) then
            if (true and !subFrameIsOpen) then
                local currentRole = nil
                subFrameIsOpen = true
                local xs = 200 * xScale
                local ys = 50 * yScale
                local secondYSize = 230 * yScale
                local shipList

                local subFrame = vgui.Create("DFrame") 
                subFrame:SetSize(0,ys) 
                subFrame:ShowCloseButton(true)
                subFrame:SetPos(xPos + xSize / 2 - (4 * xScale), yPos - ySize / 2 + (100 * yScale))
                subFrame:MakePopup()
                subFrame:SetScreenLock(false)
                subFrame:SetTitle("")
                if (IsValid(subFrame) and subFrame != nil) then
                    subFrame:SizeTo(xs,ys,.3,0,1, function() end)
                end

                function subFrame:OnClose()
                    subFrameIsOpen = false
                end

                function subFrame:Paint( w, h )
                    draw.RoundedBox(0,0,0,w,h,Color(50,50,50, 255))
                    draw.RoundedBox(0,5 * xScale,5 * yScale,w - 10 * xScale,h - 10 * yScale,Color(100,100,100, 255))
                end

                local textDesc = vgui.Create("DLabel",subFrame)
                textDesc:SetText("")

                local roleSelector = vgui.Create( "DComboBox", subFrame )
                roleSelector:SetPos( 10 * xScale, 20 * yScale )
                roleSelector:SetSize( xs - 20 * xScale, 20 * yScale )
                roleSelector:SetValue( "Please select a role" )
                roleSelector:AddChoice("Superadmin")
                roleSelector:AddChoice("Admin")
                roleSelector.OnSelect = function( s, index, value )
                    currentRole = value

                    if (IsValid(subFrame) and subFrame != nil) then
                      subFrame:SizeTo(xs,secondYSize,.3,0,1, function() end)
                    end
                    textDesc:SetText("")
                    textDesc:SetPos(10 * xScale, 70 * yScale)
                    textDesc:SetFont("Aura_Hangar_Font_3")
                    if (currentRole == "Superadmin") then
                      textDesc:SetText("Superadmins can set ranks in this\nthey also have all admin perms")
                    end
                    if (currentRole == "Admin") then
                      textDesc:SetText("Admins can see / use all admin\ncommands in this menu")
                    end
                    textDesc:SizeToContents()


                    local subFrame2Open = false
                    local addUserGroup = vgui.Create("DButton", subFrame)
                    addUserGroup:SetSize(xs - (20 * xScale), 20 * yScale)
                    addUserGroup:SetPos(10 * xScale, 45 * yScale)
                    addUserGroup:SetTextColor(Color(255,255,255,255))
                    addUserGroup:SetText("Add usergroup")
                    addUserGroup:SetFont("Aura_Hangar_Font_Menu2")
                    addUserGroup.DoClick = function() 
                        if (CAMI) then
                          local userGroups = CAMI.GetUsergroups()

                          local menu = DermaMenu() 
                          for group, data in pairs(userGroups) do
                            local canAdd = true
                            if (currentRole == "Superadmin") then
                              canAdd = !table.HasValue(adminRanks.superAdmin,data.Name)
                            end

                            if (currentRole == "Admin") then
                              canAdd = !table.HasValue(adminRanks.admin,data.Name)
                            end

                            if (canAdd) then
                              menu:AddOption(data.Name, function()
                                  Aura_AddUSG_ToCategory(currentRole, data.Name)
                              end)
                            end
                          end
                          menu:Open()

                        else
                          if (true and !subFrame2Open) then
                            subFrame2Open = true
                            local xs = 200 * xScale
                            local ys = 100 * yScale
                            local subFrameTwo = vgui.Create("DFrame") 
                            subFrameTwo:SetSize(0,ys) 
                            subFrameTwo:ShowCloseButton(true)
                            subFrameTwo:SetPos(xPos + xSize / 2 - (4 * xScale) + (xs - 5 * xScale), yPos - ySize / 2 + (100 * yScale))
                            subFrameTwo:MakePopup()
                            subFrameTwo:SetScreenLock(false)
                            subFrameTwo:SetTitle("")
                            if (IsValid(subFrameTwo) and subFrameTwo != nil) then
                                subFrameTwo:SizeTo(xs,ys,.3,0,1, function() end)
                            end

                            function subFrameTwo:OnClose()
                                subFrame2Open = false
                            end

                            function subFrameTwo:Paint( w, h )
                                draw.RoundedBox(0,0,0,w,h,Color(50,50,50, 255))
                                draw.RoundedBox(0,5 * xScale,5 * yScale,w - 10 * xScale,h - 10 * yScale,Color(100,100,100, 255))
                            end

                            local TextEntry = vgui.Create( "DTextEntry", subFrameTwo ) -- create the form as a child of frame
                            TextEntry:SetPos( 10 * xScale, 20 * yScale )
                            TextEntry:SetSize( 180 * xScale, 20 * yScale )
                            TextEntry:SetValue( "Usergroup" )

                            local addUsgLabel = vgui.Create( "DLabel", subFrameTwo )
                            addUsgLabel:SetPos(10 * xScale, 50 * xScale)
                            addUsgLabel:SetTextColor(Color(255,255,255,255))
                            addUsgLabel:SetFont("Aura_Hangar_Font_3")
                            addUsgLabel:SetText("Make sure spelling is right\nbut capitalization DOES matter")
                            addUsgLabel:SizeToContents()
                            
                            local addButton = vgui.Create("DButton", subFrameTwo)
                            addButton:SetSize(100 * xScale, 20 * yScale)
                            addButton:SetPos(45 * xScale, 75 * yScale)
                            addButton:SetTextColor(Color(255,255,255,255))
                            addButton:SetText("Add")
                            addButton:SetFont("Aura_Hangar_Font_Menu2")
                            addButton.DoClick = function() 
                              subFrameTwo:Close()
                              Aura_AddUSG_ToCategory(currentRole, TextEntry:GetValue())
                            end
                            function addButton:Paint( w, h )
                              draw.RoundedBox( 0, 2 * xScale, 2 * yScale, w, h, Color( 0,150,0,255 ) )
                            end
                          end
                        end
                    end
                    function addUserGroup:Paint( w, h )
                      draw.RoundedBox( 0, 4 * xScale, 4 * xScale, w, h, Color( 0,150,0,255 ) )
                    end

                    groupList = vgui.Create("DListView",subFrame)
                    groupList:Dock( FILL )
                    groupList:DockMargin( 10 * xScale, 70 * yScale, 10 * xScale, 10  * yScale)
                    groupList:SetSize(xs - 20 * xScale, 150 * yScale)
                    groupList:SetMultiSelect( false )
                    groupList:AddColumn( "Usergroups" )

                    local tempSelf = self

                    function groupList:OnRowSelected(index,line)
                      if (Aura_PermcheckSuperadmin()) then
                        if (line:GetValue(1) == "superadmin") then
                            LocalPlayer():ChatPrint("You may not want to remove superadmin perms...")
                            return
                        end
                        if (currentRole == "Superadmin") then
                            table.RemoveByValue(adminRanks.superAdmin,line:GetValue(1))
                        end
                        if (currentRole == "Admin") then
                          table.RemoveByValue(adminRanks.admin,line:GetValue(1))
                        end
                        groupList:RemoveLine(index)
                        net.Start("Aura_Hangar_Remove_Rank")
                        net.WriteEntity(tempSelf)
                        net.WriteString(currentRole)
                        net.WriteString(line:GetValue(1))
                        net.SendToServer()
                      else
                        LocalPlayer():ChatPrint("You must be superadmin to remove ranks!")
                      end
                    end

                    if (currentRole == "Superadmin") then
                      for i=1,#adminRanks.superAdmin do
                          groupList:AddLine(adminRanks.superAdmin[i])
                      end
                    end
                    if (currentRole == "Admin") then
                      for i=1,#adminRanks.admin do
                          groupList:AddLine( adminRanks.admin[i])
                      end
                    end

                    groupList:SortByColumn(1)

                    function Aura_AddUSG_ToCategory(category, usg)
                      if (category == "Superadmin") then
                        table.insert(adminRanks.superAdmin,usg)
                      end
                      if (category == "Admin") then
                        table.insert(adminRanks.admin,usg)
                      end
                      net.Start("Aura_Hangar_Add_Rank")
                      net.WriteEntity(self)
                      net.WriteString(category)
                      net.WriteString(usg)
                      net.SendToServer()
                      groupList:AddLine(usg)
                      groupList:SortByColumn(1)
                    end
                  end
                end
          else
            chat.AddText(Color(150,0,0,255), LocalPlayer():Nick() .. ", you do not have permission to edit permissions!")
          end
        end
        function permEdit:Paint( w, h )
          if (debug) then
            draw.RoundedBox( 0, 2, 2, w, h, Color( 0,150,0,255 ) )
          else
            draw.RoundedBox( 0, 2, 2, w, h, Color( 150,0,0,255 ) )
          end
          surface.SetDrawColor( 255, 255, 255, 255 )
          surface.SetMaterial( adminMat )
          surface.DrawTexturedRect( 10 * xScale, 2.5 * yScale, 16 * xScale, 16 * yScale )
        end
    end

    hook.Add("PostDrawTranslucentRenderables","Aura_Hangar_Debug_Hook" .. self:EntIndex(), function()
        if (self.debugMode) then
            for i=1,#hangars do
                local hangar = hangars[i]
                local pos = hangar.node:GetPos() + Vector(0,0, 30)

                local ang = LocalPlayer():GetAngles()
                ang:RotateAroundAxis(ang:Forward(), 90)

                ang = ang + Angle(0,270,0)

                ang.x = 0 

                local dist = hangar.radius * 10

                local ang2 = Angle(0,0,0)
                ang2 = ang2 + Angle(0,180,0)

                cam.Start3D2D(pos - Vector(0,0,35), ang2, .1)
                    draw.NoTexture()
                    surface.SetDrawColor(0,0,0,150)
                    draw.Circle(0,0,dist, 20)

                    surface.SetDrawColor(255,0,0,255)
                cam.End3D2D()

                render.DrawLine(hangar.node:GetPos(),hangar.node:GetPos() + hangar.node:GetForward() * 35,Color(255,0,0,255),true)

                cam.Start3D2D(pos, ang, .1)
                    draw.DrawText("Hangar " .. i,"Aura_Hangar_Font_Debug",0,0,Color(255, 255, 255, 255),TEXT_ALIGN_CENTER)
                cam.End3D2D()

                cam.Start3D2D(pos + hangar.node:GetForward() * 20 - Vector(0,0,25), Angle(hangar.node:GetAngles().x,LocalPlayer():GetAngles().y - 90, 90), .1)
                    draw.DrawText("Ships spawn facing this way↓","Aura_Hangar_Font_Debug2",0,0,Color(255, 255, 255, 255),TEXT_ALIGN_CENTER)
                cam.End3D2D()
            end
        end
    end) 
  end
end)

function draw.Circle( x, y, radius, seg )
  local cir = {}

  table.insert( cir, { x = x, y = y, u = 0.5, v = 0.5 } )
  for i = 0, seg do
    local a = math.rad( ( i / seg ) * -360 )
    table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) / 2 + 0.5, v = math.cos( a ) / 2 + 0.5 } )
  end

  local a = math.rad( 0 ) -- This is needed for non absolute segment counts
  table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) / 2 + 0.5, v = math.cos( a ) / 2 + 0.5 } )

  surface.DrawPoly( cir )
end

function Aura_GetAvailableHangar(hangars)
  if (hangars != nil) then
    for i=1,#hangars do
      local hangar = hangars[i]

      if (hangar.isTaken != nil and !hangar.isTaken) then
        return i
      end
    end
    -- If we don't find any, just return nil so we can use that to tell later what error we should throw
    return nil
  end
end
--PATH lua/entities/aura_lvs_acclamator_mk2/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_acclamator_mk2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "REP | Acclamator"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/salty/acclamator-class-ship.mdl"
ENT.AITEAM 					= 2

ENT.Mass 					= 700

ENT.HealthVal 				= 1000000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = -1000, right = 0, up = 0}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_blue_laser"
ENT.SHOOTSOUND				= Sound("weapons/big_canon.wav")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 3
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{
	[1] = Vector(-400,-170,1680),
	[2] = Vector(-850,-2450,1200),
	[3] = Vector(-850,2160,1200),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(0,0,0),
	[2] = Angle(90,-90,0),
	[3] = Angle(90,90,0)
}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 1800},
	{forward = 1000, right = 0, up = 1600},
	{forward = 2000, right = 0, up = 1400},
		{forward = 0, right = 2000, up = 1400},
			{forward = 0, right = -2000, up = 1200},
	{forward = 3000, right = 0, up = 1800},
	{forward = -1000, right = 0, up = 1600},
	{forward = -2500, right = 0, up = 1800},
}
--PATH lua/entities/aura_lvs_bulwark/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_capital_ship_base_mk2/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cargo/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cargo8/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_consular/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cr90_neu/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cr90_rep/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_dh_omni/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_dh_omni/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_diamond/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_gozanti/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_providence_mk2/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_recusant/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_rtt04/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "REP | R.T.T 04"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/star_wars/the_clone_wars/vehicles/rep_tank_gtrans.mdl"
ENT.AITEAM 					= 2

ENT.Mass 					= 700

ENT.HealthVal 				= 50000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_blue_laser"
ENT.SHOOTSOUND				= Sound("weapons/corvette_fire.mp3")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 3
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{
	[1] = Vector(-250,0,290),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(0,180,0),
}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 0},
	{forward = 700, right = 0, up = 0},
	{forward = 0, right = 0, up = 0},
	{forward = -300, right = 0, up = 0},
}
--PATH lua/entities/aura_lvs_satellite_csi_1/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_satellite_csi_2/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_satellite_csi_2/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH addons/[miecze] moce i hilty/lua/entities/boulder/cl_init.lua:
include("shared.lua")
--PATH addons/[miecze] moce i hilty/lua/entities/boulder/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"
ENT.PrintName		= "Boulder"
ENT.Category		= "WOS_Powers"

ENT.Spawnable		= false
--PATH addons/[technik] darkrp-city-worker/lua/entities/cityworker_hydrant/shared.lua:
return gluapack()()
--PATH addons/[technik] darkrp-city-worker/lua/entities/cityworker_rubble/shared.lua:
return gluapack()()
--PATH lua/entities/claimboard/cl_init.lua:
include("shared.lua")

AddCSLuaFile()

function ENT:Draw()
    self:DrawModel()

    local pos = self:LocalToWorld(Vector(-23, 0, 90))
    local ang = self:LocalToWorldAngles(Angle(0, 0, 90))

    local BAT = self:GetClaimBoardBat()
    local CFG = RDV.CLAIMBOARDS.CFG.BATTALIONS
    local COL = Color(255,255,255)

    if CFG[BAT] and CFG[BAT].Col then
        COL = CFG[BAT].Col
    end

    cam.Start3D2D(pos, ang, 0.1)
        draw.RoundedBox(0, 0, 0, 510, 745, Color(0, 0, 0))
        draw.RoundedBox(0, 0, 0, 510, 100, Color(144, 0, 255))

        if self:GetClaimBoardClaimed() then
            draw.SimpleText(EPS_ShortenString(self:GetClaimBoardTitle(), 13), "RD_CLAIM_BOARD_TITLE", 510 / 2, 50, Color(255, 255, 255), 1, 1)
            draw.SimpleText(RDV.LIBRARY.GetLang(nil, "CLAIMB_claimedByLabel"), "RD_CLAIM_BOARD_BODY", 510 / 2, 250, Color(255, 255, 255, 255), 1, 1)
            draw.SimpleText(EPS_ShortenString(BAT, 13), "RD_CLAIM_BOARD_TITLE", 510 / 2, 315, COL, 1, 1)
            draw.SimpleText(RDV.LIBRARY.GetLang(nil, "CLAIMB_statusLabel"), "RD_CLAIM_BOARD_BODY", 510 / 2, 400, Color(255, 255, 255, 255), 1, 1)

            if self:GetClaimBoardOpen() then
                draw.SimpleText(RDV.LIBRARY.GetLang(nil, "CLAIMB_openToAll"), "RD_CLAIM_BOARD_TITLE", 510 / 2, 460, Color(0, 255, 0, 255), 1, 1)
            else
                draw.SimpleText(RDV.LIBRARY.GetLang(nil, "CLAIMB_ClosedLabel"), "RD_CLAIM_BOARD_TITLE", 510 / 2, 460, Color(255, 0, 0, 255), 1, 1)
                draw.SimpleText(RDV.LIBRARY.GetLang(nil, "CLAIMB_AOSOnEntry"), "RD_CLAIM_BOARD_BODY", 510 / 2, 520, Color(255, 0, 0, 255), 1, 1)
            end
        else
            draw.SimpleText(RDV.LIBRARY.GetLang(nil, "CLAIMB_UnclaimedLabel"), "RD_CLAIM_BOARD_TITLE", 510 / 2, 50, Color(255, 255, 255), 1, 1)
        end

    cam.End3D2D()
end
--PATH lua/entities/decs_loader/shared.lua:
ENT.Type = "anim"
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Loader"
ENT.Author = "Dec"
ENT.Information = ""
ENT.Category = "[LVS] SW-Vehicles"

ENT.Spawnable = true

ENT.MDL = "models/loader/ships/loader.mdl"

ENT.AITEAM = 2


ENT.MaxHealth = 1000

ENT.MaxVelocityX = 400
ENT.BoostAddVelocitX = 500

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 2

ENT.ForceLinearMultiplier = 2
ENT.ForceLinearRate = 2

ENT.MaxVelocityY = 150
ENT.BoostAddVelocitY = 150



ENT.IgnoreWater = false

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "LightsOn" )
end

function ENT:CalcMainActivityPassenger( ply )
end

function ENT:CalcMainActivity( ply )
    if ply ~= self:GetDriver() then return self:CalcMainActivityPassenger( ply ) end

    if ply.m_bWasNoclipping then 
        ply.m_bWasNoclipping = nil 
        ply:AnimResetGestureSlot( GESTURE_SLOT_CUSTOM ) 
        
        if CLIENT then 
            ply:SetIK( true )
        end 
    end 

    ply.CalcIdeal = ACT_STAND
    ply.CalcSeqOverride = ply:LookupSequence( "idle_all_02" )

    return ply.CalcIdeal, ply.CalcSeqOverride
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/iftx/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/iftx/loop_hi.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/iftx/dist.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 90,
	},
}

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)


function ENT:InitWeapons()

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		if self.lighton == true then
			self:SetLightsOn(false)
			self.lighton = false
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		else
			self.lighton = true
			self:SetLightsOn(true)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		end
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dropship_grabber.png")
	weapon.Ammo = -1
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		if self.loaded then
			self.loaded = false
			print("removed")
			constraint.RemoveConstraints( self, "Weld" )
		else
			self.posibleentities = ents.FindInBox( self:LocalToWorld(Vector(136,65,32)), self:LocalToWorld(Vector(-134,-66,105)) ) 
			for _, entity in ipairs(self.posibleentities) do
				if entity:GetClass() == "player" then
				elseif entity:GetClass() == "prop_physics" or "anim" then
					self.loaded = true
					constraint.Weld(self, entity, 0, 0, 0, true, false)
				end
			end
		end
	end
	self:AddWeapon( weapon )

    local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 0.5
	weapon.HeatRateUp = 5
	weapon.HeatRateDown = 5
	weapon.Attack = function( ent )

		if self.FiredRope then
			if self.HookedEnt != nil && IsValid(self.HookedEnt) then
				self:UnRagdoll(self.HookedEnt)
				self.HookedEnt = nil
			end

			constraint.RemoveConstraints( self, "Rope" )
			self.FiredRope = false
			
			return
		end

		local trace = self:GetEyeTrace()


		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( Vector(440.93,-256.45,105.48) )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_nil"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 0
		bullet.SplashDamage = 0
		bullet.SplashDamageRadius = 0
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			if !tr.Hit or (self:LocalToWorld(Vector(136,0,16)) - tr.HitPos):Length() > 1000 then return false end

			if tr.Entity:IsPlayer() then
				self.HookedEnt = tr.Entity
				self:Ragdoll(tr.Entity)
				tr.Entity = tr.Entity.tw_Ragdoll
            end

            self.CurRope = constraint.Rope(self, tr.Entity, 0, 0, Vector(136,0,16), tr.Entity:WorldToLocal(tr.HitPos), (self:LocalToWorld(Vector(136,0,16)) - tr.HitPos):Length() + 100, 0, 0, 5, 'cable/cable2', false)
			
            if IsValid(self.CurRope) then
                self.FiredRope = true
                if tr.Entity == lvs then 
                    self:StartEngine(true)
                end
            end
            
		end
        local effectdata = EffectData()
        effectdata:SetStart( Vector(0,0,0) )
        effectdata:SetOrigin( bullet.Src )
        effectdata:SetNormal( ent:GetForward() )
        effectdata:SetEntity( ent )
        util.Effect( "lvs_muzzle_colorable", effectdata )

        ent:LVSFireBullet( bullet )

		ent:TakeAmmo()
	end
    weapon.HudPaint = function( ent, X, Y, ply )
        local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 60) and COLOR_RED or COLOR_WHITE

        local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

        local base = ent:GetVehicle()
        base:PaintCrosshairCenter( Pos2D, Col )
        base:PaintCrosshairOuter( Pos2D, Col )
        base:LVSPaintHitMarker( Pos2D )
    end
    self:AddWeapon( weapon )

    local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 1
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0.9
	weapon.Attack = function( ent )
        self:EmitSound( "lvs/vehicles/iftx/fire_missile.mp3" )

        local trace = ent:GetEyeTrace()

        local Driver = self:GetDriver()

        local projectile = ents.Create( "lvs_missile" )
        projectile:SetPos( self:LocalToWorld(Vector(130.31,-70.35,32.27)) )
        projectile:SetAngles( self:GetAngles() )
        projectile:SetParent( ent )
        projectile:Spawn()
        projectile:Activate()
        projectile.GetTargetPos = function( projectile )
            return projectile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-5,5) )
        end
        projectile:SetAttacker(Driver)
        projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
        projectile:SetDamage( 2500 )
        projectile:SetRadius( 450 )
        projectile:Enable()

        ent:SetHeat( 1 )
        ent:SetOverheated( true )
        ent:TakeAmmo()

        local effectdata = EffectData()
        effectdata:SetOrigin(  self:LocalToWorld(Vector(130.31,-70.35,32.27)) - Vector(0,0,30)) 
        effectdata:SetRadius(80 * 80)
        effectdata:SetScale(10 * 10)
        util.Effect( "ThumperDust", effectdata, true, true )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 30) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnSelect = function( ent )
	end
	self:AddWeapon( weapon )
end


function ENT:MakeInvisible(player, invisible)
	player:SetNoDraw(invisible)
	player:SetNotSolid(invisible)

	player:DrawViewModel(!invisible)
	player:DrawWorldModel(!invisible)

	if (invisible) then
		player:GodEnable()
	else
		player:GodDisable()
	end
end

function ENT:UnRagdoll(target)
    if IsValid(target) then 
	    self:MakeInvisible(target, false)

	    local position = target.tw_Ragdoll:GetPos()

	    target:UnSpectate()
        target.tw_Ragdoll:Remove()

        target:SetParent(NULL)
        target:Spawn()
        timer.Simple(0.1, function()
            target:SetPos(position +Vector(0, 0, 5))
        end)

        for k, weapon in pairs(target.tw_Weapons) do
            target:Give(weapon)
        end

        target.tw_Weapons = nil
    else
        self.CurRag:Remove()
        self.CurRag = nil
    end
end

function ENT:Ragdoll(target)

	target.tw_Weapons = {}

	for k, weapon in pairs(target:GetWeapons()) do
		if IsValid(weapon) then
			table.insert(target.tw_Weapons, weapon:GetClass())
		end
	end

	target.tw_Ragdoll = ents.Create("prop_ragdoll")
	target.tw_Ragdoll:SetPos(target:GetPos())
	target.tw_Ragdoll:SetModel(target:GetModel())
	target.tw_Ragdoll:SetAngles(target:GetAngles())
	target.tw_Ragdoll:SetSkin(target:GetSkin())
	target.tw_Ragdoll:SetMaterial(target:GetMaterial())
	target.tw_Ragdoll:Spawn()

    self.CurRag = target.tw_Ragdoll


	target.tw_Ragdoll:CallOnRemove("UnragdollPlayer", function(ragdoll)
		if IsValid(target) then
			self:MakeInvisible(target, false)

			local position = ragdoll:GetPos()

			target:SetParent(NULL)
			target:Spawn()
			timer.Simple(0.1, function()
				target:SetPos(position + Vector(0, 0, 5))
			end)

			if (target.tw_Weapons) then
				for k, weapon in pairs(target.tw_Weapons) do
					target:Give(weapon)
				end
			end

			target.tw_Weapons = nil
		end
	end)

	target.tw_Ragdoll:SetCollisionGroup(COLLISION_GROUP_WEAPON)

	local velocity = target:GetVelocity()
	local physObjects = target.tw_Ragdoll:GetPhysicsObjectCount() - 1

	for i = 0, physObjects do
		local bone = target.tw_Ragdoll:GetPhysicsObjectNum(i)

		if IsValid(bone) then
			local position, angle = target:GetBonePosition(target.tw_Ragdoll:TranslatePhysBoneToBone(i))

			if (position and angle) then
				bone:SetPos(position)
				bone:SetAngles(angle)
			end

			bone:AddVelocity(velocity)
		end
	end

	target:StripWeapons()
	target:SetMoveType(MOVETYPE_OBSERVER)
	target:Spectate(OBS_MODE_CHASE)
	target:SpectateEntity(target.tw_Ragdoll)
	target:SetParent(target.tw_Ragdoll)

	self:MakeInvisible(target, true)
end
--PATH addons/[misc] szachy/lua/entities/ent_chess_board.lua:

if SERVER then
	AddCSLuaFile()
	
	--From client
	util.AddNetworkString( "Chess ClientRequestMove" )
	util.AddNetworkString( "Chess ClientWager" )
	util.AddNetworkString( "Chess ClientCallDraw" )
	
	util.AddNetworkString( "Chess ClientResign" )
	util.AddNetworkString( "Chess RequestSeat" )
	
	--2-way
	util.AddNetworkString( "Chess DrawOffer" )
	util.AddNetworkString( "Chess PromotionSelection" )
	util.AddNetworkString( "Chess Update" )
	--From server
	util.AddNetworkString( "Chess GameOver" )
end

ENT.Type = "anim"
ENT.Model = Model("models/weapons/w_slam.mdl")

-- This is a quick swap to alternate settings so you don't need to configure it yourself
-- Set to `true` if your users aren't expected to have CS:S mounted
local UseHL2Model = false

ENT.Models = {
	["board"] = Model("models/props_phx/games/chess/board.mdl"),
	["table"] = (UseHL2Model and Model( "models/props_c17/furnituretable001a.mdl" ) or Model("models/props/de_tides/restaurant_table.mdl")),
	["hl2table"] = Model( "models/props_c17/furnituretable001a.mdl" ),
	
	["BlackPawn"] = Model("models/props_phx/games/chess/black_pawn.mdl"),      ["WhitePawn"] = Model("models/props_phx/games/chess/white_pawn.mdl"),
	["BlackRook"] = Model("models/props_phx/games/chess/black_rook.mdl"),      ["WhiteRook"] = Model("models/props_phx/games/chess/white_rook.mdl"),
	["BlackKnight"] = Model("models/props_phx/games/chess/black_knight.mdl"),  ["WhiteKnight"] = Model("models/props_phx/games/chess/white_knight.mdl"),
	["BlackBishop"] = Model("models/props_phx/games/chess/black_bishop.mdl"),  ["WhiteBishop"] = Model("models/props_phx/games/chess/white_bishop.mdl"),
	["BlackQueen"] = Model("models/props_phx/games/chess/black_queen.mdl"),    ["WhiteQueen"] = Model("models/props_phx/games/chess/white_queen.mdl"),
	["BlackKing"] = Model("models/props_phx/games/chess/black_king.mdl"),      ["WhiteKing"] = Model("models/props_phx/games/chess/white_king.mdl"),
	
	["dama"] = Model("models/props_phx/games/chess/white_dama.mdl"),
}

-- 2D mode icons
ENT.Characters = {
	["BlackPawn"] = "♟",    ["WhitePawn"] = "♙",
	["BlackRook"] = "♜",    ["WhiteRook"] = "♖",
	["BlackKnight"] = "♞",	["WhiteKnight"] = "♘",
	["BlackBishop"] = "♝",	["WhiteBishop"] = "♗",
	["BlackQueen"] = "♛",   ["WhiteQueen"] = "♕",
	["BlackKing"] = "♚",    ["WhiteKing"] = "♔",
}

-- Board position (Offset from ground)
ENT.BoardHeight = Vector(0, 0, (UseHL2Model and 17 or 30))

-- Table position
ENT.TableOffset = Vector(0, 0, (UseHL2Model and 10 or 0))

-- Table phys box
ENT.PhysBox = {
	mins = Vector(-30, -30, -0),
	maxs = Vector(30, 30, 33)
}

ENT.PrintName		= "Chess"
ENT.Author			= "my_hat_stinks"
ENT.Information		= "A chess board"
ENT.Category		= "Game boards"

ENT.Game = "Chess"
ENT.Spawnable = true
ENT.AdminOnly = true
ENT.AdminSpawnable = true

ENT.IsChessBoard = true


ENT.TopLeft = Vector(2.5,-15.5,-16) --Local pos of the board's corner (Used for alignment)
ENT.SquareH = 78.5 ENT.SquareW = 80.2 --For drawing square highlights
ENT.RealH = 4 ENT.RealW = 3.9 --For vector positions

ENT.MoveTime = 0.3 --Time it takes to complete a move
ENT.MoveSound = Sound( "physics/wood/wood_solid_impact_soft1.wav" )
ENT.CheckSound = Sound( "physics/concrete/rock_impact_hard1.wav" )

local NumToLetter = {"a", "b", "c", "d", "e", "f", "g", "h", ["a"]=1, ["b"]=2, ["c"]=3, ["d"]=4, ["e"]=5, ["f"]=6, ["g"]=7, ["h"]=8} --Used extensively for conversions
local PassantFlags = {1,2,4,8,16,32,64,128} --Bitflags, translate to board positions 1-8. For En Passant rule

--Status
local CHESS_INACTIVE = 0
local CHESS_WHITEMOVE = 1
local CHESS_BLACKMOVE = 2
local CHESS_WHITEPROMO = 3
local CHESS_BLACKPROMO = 4
local CHESS_WAGER = 5

--Captured piece squares
local CHESS_WCAP1 = 10
local CHESS_WCAP2 = 11
local CHESS_BCAP1 = 12
local CHESS_BCAP2 = 13

-- Draw Offer
local PLAYER_NONE  = 0 -- Nobody offering to draw
local PLAYER_WHITE = 1 -- White offering to draw
local PLAYER_BLACK = 2 -- Black offering to draw

--Draws
local CHESS_DRAW_50 = 0
local CHESS_DRAW_3 = 1

ENT.StartState = CHESS_WHITEMOVE

function ENT:SetupDataTables()
	self:NetworkVar( "Int", 0, "BlackPassant" )
	self:NetworkVar( "Int", 1, "WhitePassant" )
	
	self:NetworkVar( "Int", 2, "ChessState" )
	self:NetworkVar( "Bool", 0, "Playing" )
	self:NetworkVar( "Int", 3, "DrawOffer" )
	
	self:NetworkVar( "Float", 0, "WhiteWager" )
	self:NetworkVar( "Float", 1, "BlackWager" )
	
	self:NetworkVar( "Entity", 0, "WhitePlayer" )
	self:NetworkVar( "Entity", 1, "BlackPlayer" )
	self:NetworkVar( "Entity", 2, "TableEnt" )
	
	self:NetworkVar( "Int", 4, "MoveCount" )
	self:NetworkVar( "Bool", 1, "Repetition" )
	
	self:NetworkVar( "Bool", 2, "PSWager" )
	
	self:NetworkVar( "Float", 2, "WhiteTime" )
	self:NetworkVar( "Float", 3, "BlackTime" )
end
local ChessScale = Matrix({
	{0.1225,0,0,0},
	{0,0.1225,0,0},
	{0,0,0.1225,0},
	{0,0,0,0},
})

local SpawnedEnts = {}
function ENT:SpawnFunction( ply, tr, ClassName )
	if (not tr.Hit) then return end
	
	local SpawnPos = tr.HitPos --+ (tr.HitNormal*16)
	
	local board = (IsValid(self) and self) or ents.Create( ClassName )
	board.SavePos = SpawnPos
	board:SetPos( SpawnPos )
	board:Spawn()
	
	SpawnedEnts[board]=true
	
	return board
end
function ENT:Initialize()
	if SERVER then
		local pos,ang = self:GetPos(),self:GetAngles()
		
		local tbl = ents.Create( "prop_physics" )
		tbl:SetModel(self.Models["table"])
		tbl:SetPos(pos + self.TableOffset)
		tbl:Spawn()
		tbl:SetCollisionGroup(COLLISION_GROUP_PLAYER)
		tbl:PhysicsInitBox(self.PhysBox.mins - self.TableOffset, self.PhysBox.maxs - self.TableOffset)
		tbl:SetMoveType(MOVETYPE_NONE)
		tbl:SetMaxHealth(1000000)
		tbl.IsChessEntity = true
		
		if not self.SkipBlackChair then
			local BlackSeat = ents.Create( "prop_vehicle_prisoner_pod" )
			BlackSeat:SetModel( "models/nova/chair_plastic01.mdl" )
			BlackSeat:SetPos( self.BlackChairPos or (pos+ (self:GetRight()*60)) )
			BlackSeat:SetAngles( self.BlackChairAng or ang )
			BlackSeat:Spawn()
			BlackSeat:SetMoveType( MOVETYPE_NONE )
			BlackSeat:SetCollisionGroup( COLLISION_GROUP_WORLD )
			BlackSeat.IsChessEntity = true
			
			self.BlackSeat = BlackSeat
			BlackSeat:SetNWBool("IsChessSeat", true)
			BlackSeat:SetNWEntity( "ChessBoard", self )
			
			BlackSeat.DoorData = {NonOwnable = true}
			if BlackSeat.setKeysNonOwnable then BlackSeat:setKeysNonOwnable( true ) end
		end
		if not self.SkipWhiteChair then
			local WhiteSeat = ents.Create( "prop_vehicle_prisoner_pod" )
			WhiteSeat:SetModel( "models/nova/chair_plastic01.mdl" )
			WhiteSeat:SetPos( self.WhiteChairPos or (pos+ (self:GetRight()*-60)) )
			ang:RotateAroundAxis( self:GetUp(),180 )
				WhiteSeat:SetAngles( self.WhiteChairAng or ang )
			ang:RotateAroundAxis( self:GetUp(),180 )
			WhiteSeat:Spawn()
			WhiteSeat:SetMoveType( MOVETYPE_NONE )
			WhiteSeat:SetCollisionGroup( COLLISION_GROUP_WORLD )
			WhiteSeat.IsChessEntity = true
		
			--Set some stuff up so we can see it's for chess
			self.WhiteSeat = WhiteSeat
			WhiteSeat:SetNWBool("IsChessSeat", true)
			WhiteSeat:SetNWEntity( "ChessBoard", self )
			
			--Darkrp lets people steal seats...
			WhiteSeat.DoorData = {NonOwnable = true}
			if WhiteSeat.setKeysNonOwnable then WhiteSeat:setKeysNonOwnable( true ) end
		end
		
		self.IsChessEntity = true
		
		ang:RotateAroundAxis(self:GetRight(), 90)
		self:SetPos(pos + self.BoardHeight + self.TableOffset)
		self:SetAngles(ang)
		
		self.TableEnt = tbl self:SetTableEnt( tbl )
		self:SetParent( tbl )
		
		self:SetChessState( CHESS_INACTIVE )
		self:SetPlaying( false )
		
	
		timer.Simple( 1, function()
			if not IsValid(self) then return end
			
			local phys = self:GetPhysicsObject()
			if IsValid(phys) then
				phys:EnableCollisions( false )
				phys:Sleep()
			end
			
			local phys = IsValid(tbl) and tbl:GetPhysicsObject()
			if IsValid(phys) then
				phys:EnableCollisions( false )
				phys:Sleep()
			end
			
			local phys = IsValid(WhiteSeat) and WhiteSeat:GetPhysicsObject()
			if IsValid(phys) then
				phys:EnableCollisions( false )
				phys:Sleep()
			end
			
			local phys = IsValid(BlackSeat) and BlackSeat:GetPhysicsObject()
			if IsValid(phys) then
				phys:EnableCollisions( false )
				phys:Sleep()
			end
		end)
	end
	
	self.Pieces = { ["a"] = {}, ["b"] = {}, ["c"] = {}, ["d"] = {}, ["e"] = {}, ["f"] = {}, ["g"] = {}, ["h"] = {} }
	
	self:SetModel( self.Models["board"] )
	//self:SetModelScale( 0.35, 0 )
	
	self:DrawShadow( false )
	
	local mins = self:OBBMins()*0.1
	local maxs = self:OBBMaxs()*0.1
	-- self:PhysicsInitBox( mins, maxs )
	self:PhysicsInit(SOLID_NONE)
	if CLIENT then
		self:EnableMatrix( "RenderMultiply", ChessScale )
		hook.Add( "KeyPress", self, self.GetSpectateUse )
		hook.Add( "PrePlayerDraw", self, self.PrePlayerDraw )
	end
	
	self:ResetBoard()
end
function ENT:OnRemove()
	if SERVER then
		local WhitePly = self:GetPlayer( "White" )
		local BlackPly = self:GetPlayer( "Black" )
		
		if IsValid(WhitePly) then
			WhitePly:SetNWBool( "IsInChess", false )
			WhitePly:SetNWEntity( "ActiveChessBoard", NULL )
		end
		if IsValid(BlackPly) then
			BlackPly:SetNWBool( "IsInChess", false )
			BlackPly:SetNWEntity( "ActiveChessBoard", NULL )
		end
		
		if self:GetPlaying() then
			local WhiteName = IsValid(WhitePly) and WhitePly:Nick() or "[Anonymous White]"
			local BlackName = IsValid(BlackPly) and BlackPly:Nick() or "[Anonymous Black]"
			net.Start( "Chess GameOver" )
				net.WriteTable( {Color(150,255,150), "Chess removed! ", Color(255,255,255), WhiteName, Color(150,255,150), " vs ", Color(100,100,100), BlackName, Color(150,255,150)," ended prematurely!"} )
			net.Broadcast()
			self:EndGame( "Error" )
		end
		
		if IsValid( self.WhiteSeat ) then self.WhiteSeat:Remove() end
		if IsValid( self.BlackSeat ) then self.BlackSeat:Remove() end
		if IsValid( self.TableEnt ) then self.TableEnt:Remove() end
		
		for GridLet,column in pairs( self.Pieces ) do
			for GridNum,square in pairs( column ) do
				if IsValid( square.Ent ) then
					square.Ent:Remove()
				end
			end
		end
	end
	if CLIENT then
		if IsValid( self.PiecesEnt ) then self.PiecesEnt:Remove() end
		if IsValid( self:GetTableEnt() ) and IsValid( self:GetTableEnt().ClientChessTable ) then
			self:GetTableEnt().ClientChessTable:Remove()
		end
	end
end
if SERVER then
	hook.Add( "ShutDown", "Chess Server Shutdown", function()
		local Ents = ents.FindByClass( "ent_chess_board" )
		for _,v in pairs( Ents ) do
			if IsValid(v) then
				v:EndGame( "Error" )
			end
		end
		local Ents = ents.FindByClass( "ent_draughts_board" )
		for _,v in pairs( Ents ) do
			if IsValid(v) then
				v:EndGame( "Error" )
			end
		end
	end)
end

function ENT:GetTableGrid( tbl, key1, key2 )
	if type(key1)=="number" then key1=NumToLetter[key1+1] end
	return tbl and tbl[key1] and tbl[key1][8-key2]
end
function ENT:GetTableKey( tbl, key1, key2 )
	if type(key1)=="string" then key1=NumToLetter[key1]-1 end
	return tbl and tbl[key1] and tbl[key1][8-key2]
end

function ENT:GetSquare( GridLet, GridNum, tbl )
	tbl = tbl or self.Pieces
	return tbl[GridLet] and tbl[GridLet][GridNum]
end
function ENT:SquareTeam( square )
	if square.Team then return square.Team end
	
	return (IsValid(square.Ent) and (square.Ent:GetWhite() and "White" or "Black"))
end
function ENT:SquareMoved( square )
	if square.Moved~=nil then return square.Moved end
	
	return (IsValid(square.Ent) and square.Ent:GetMoved())
end
function ENT:SquareClass( square )
	if square.Class~=nil then return square.Class end
	
	return (IsValid(square.Ent) and square.Ent:GetRole())
end
function ENT:SquareColor( GridLet, GridNum )
	local NumEven = ((GridNum/2) == math.floor(GridNum/2))
	local LetEven = ((NumToLetter[GridLet]/2) == math.floor(NumToLetter[GridLet]/2))
	
	return (NumEven==LetEven) and "Black" or "White"
end

function ENT:GetRookMoves( tbl, GridLet, GridNum, IsWhite, limit, CheckTable )
	limit = limit or 8
	local count = 0
	for TargetRow = GridNum+1,8 do
		local target = self:GetSquare( GridLet, TargetRow, CheckTable )
		if target then
			if ((self:SquareTeam(target)=="White")~=IsWhite) then
				tbl[GridLet][TargetRow] = true
			end
			break
		end
		tbl[GridLet][TargetRow] = true
		count = count+1 if count>=limit then break end
	end
	count = 0
	for TargetRow = GridNum-1,1,-1 do
		local target = self:GetSquare( GridLet, TargetRow, CheckTable )
		if target then
			if ((self:SquareTeam(target)=="White")~=IsWhite) then
				tbl[GridLet][TargetRow] = true
			end
			break
		end
		tbl[GridLet][TargetRow] = true
		count = count+1 if count>=limit then break end
	end
	count = 0
	for TargetColumn = NumToLetter[GridLet]+1,8 do
		local target = self:GetSquare( NumToLetter[TargetColumn], GridNum, CheckTable )
		if target then
			if ((self:SquareTeam(target)=="White")~=IsWhite) then
				tbl[NumToLetter[TargetColumn]][GridNum] = true
			end
			break
		end
		tbl[NumToLetter[TargetColumn]][GridNum] = true
		count = count+1 if count>=limit then break end
	end
	count = 0
	for TargetColumn = NumToLetter[GridLet]-1,1,-1 do
		local target = self:GetSquare( NumToLetter[TargetColumn], GridNum, CheckTable )
		if target then
			if ((self:SquareTeam(target)=="White")~=IsWhite) then
				tbl[NumToLetter[TargetColumn]][GridNum] = true
			end
			break
		end
		tbl[NumToLetter[TargetColumn]][GridNum] = true
		count = count+1 if count>=limit then break end
	end
end
function ENT:GetBishopMoves( tbl, GridLet, GridNum, IsWhite, limit, CheckTable )
	limit = limit or 8
	local TargetColumn, count = NumToLetter[GridLet], 0
	for TargetRow = GridNum+1,8 do
		TargetColumn = TargetColumn+1 if TargetColumn>8 then break end
		local target = self:GetSquare( NumToLetter[TargetColumn], TargetRow, CheckTable )
		if target then
			if ((self:SquareTeam(target)=="White")~=IsWhite) then tbl[NumToLetter[TargetColumn]][TargetRow] = true end
			break
		end
		tbl[NumToLetter[TargetColumn]][TargetRow] = true
		count = count+1 if count>=limit then break end
	end
	local TargetColumn, count = NumToLetter[GridLet], 0
	for TargetRow = GridNum+1,8 do
		TargetColumn = TargetColumn-1 if TargetColumn<1 then break end
		local target = self:GetSquare( NumToLetter[TargetColumn], TargetRow, CheckTable )
		if target then
			if ((self:SquareTeam(target)=="White")~=IsWhite) then tbl[NumToLetter[TargetColumn]][TargetRow] = true end
			break
		end
		tbl[NumToLetter[TargetColumn]][TargetRow] = true
		count = count+1 if count>=limit then break end
	end
	local TargetColumn, count = NumToLetter[GridLet], 0
	for TargetRow = GridNum-1,1,-1 do
		TargetColumn = TargetColumn+1 if TargetColumn>8 then break end
		local target = self:GetSquare( NumToLetter[TargetColumn], TargetRow, CheckTable )
		if target then
			if ((self:SquareTeam(target)=="White")~=IsWhite) then tbl[NumToLetter[TargetColumn]][TargetRow] = true end
			break
		end
		tbl[NumToLetter[TargetColumn]][TargetRow] = true
		count = count+1 if count>=limit then break end
	end
	local TargetColumn, count = NumToLetter[GridLet], 0
	for TargetRow = GridNum-1,1,-1 do
		TargetColumn = TargetColumn-1 if TargetColumn<1 then break end
		local target = self:GetSquare( NumToLetter[TargetColumn], TargetRow, CheckTable )
		if target then
			if ((self:SquareTeam(target)=="White")~=IsWhite) then tbl[NumToLetter[TargetColumn]][TargetRow] = true end
			break
		end
		tbl[NumToLetter[TargetColumn]][TargetRow] = true
		count = count+1 if count>=limit then break end
	end
end
function ENT:GetMove( GridLet, GridNum, IgnoreCheck, CheckTable )
	if not (GridLet and GridNum) then return {} end
	if not NumToLetter[GridLet] then return {} end
	if NumToLetter[GridLet]<1 or NumToLetter[GridLet]>8 then return {} end
	if GridNum<1 or GridNum>8 then return {} end
	
	local square = self:GetSquare( GridLet, GridNum, CheckTable )
	if not square then return {} end
	
	local class = square.Class or (IsValid(square.Ent) and square.Ent:GetRole())
	if not class then return {} end
	
	local IsWhite = self:SquareTeam(square)=="White"
	local Moved = self:SquareMoved(square)
	
	local ChecksPerformed = false --Castling checks for check differently, flag it as done here
	local tbl = { ["a"] = {}, ["b"] = {}, ["c"] = {}, ["d"] = {}, ["e"] = {}, ["f"] = {}, ["g"] = {}, ["h"] = {} }
	if class=="Pawn" then
		local TargetRow = IsWhite and GridNum+1 or GridNum-1
		
		local CapOne = self:GetSquare( NumToLetter[NumToLetter[GridLet]-1], TargetRow, CheckTable )
		if CapOne then --There's a unit here
			local TargetWhite = self:SquareTeam(CapOne)=="White"
			if TargetWhite~=IsWhite then
				tbl[NumToLetter[NumToLetter[GridLet]-1]][TargetRow] = true
			end
		elseif (IsWhite and TargetRow==6) or ((not IsWhite) and TargetRow==3) then --Clear, EnPasse check
			local PassantCheck = IsWhite and self:GetBlackPassant() or self:GetWhitePassant()
			if (NumToLetter[GridLet]>1) and bit.band(PassantCheck, PassantFlags[ NumToLetter[GridLet]-1 ])==PassantFlags[NumToLetter[GridLet]-1]  then
				tbl[NumToLetter[NumToLetter[GridLet]-1]][TargetRow] = "ENPASSANT"
			end
		end
		
		local CapTwo = self:GetSquare( NumToLetter[NumToLetter[GridLet]+1], TargetRow, CheckTable )
		if CapTwo then
			local TargetWhite = self:SquareTeam(CapTwo)=="White"
			if TargetWhite~=IsWhite then
				tbl[NumToLetter[NumToLetter[GridLet]+1]][TargetRow] = true
			end
		elseif (IsWhite and TargetRow==6) or ((not IsWhite) and TargetRow==3) then --Clear, EnPasse check
			local PassantCheck = IsWhite and self:GetBlackPassant() or self:GetWhitePassant()
			if (NumToLetter[GridLet]<8) and bit.band(PassantCheck, PassantFlags[ NumToLetter[GridLet]+1 ])==PassantFlags[NumToLetter[GridLet]+1] then
				tbl[NumToLetter[NumToLetter[GridLet]+1]][TargetRow] = "ENPASSANT"
			end
		end
		
		local FrontOne = self:GetSquare( GridLet, TargetRow, CheckTable )
		if (not FrontOne) then --It's clear, we can move
			tbl[GridLet][TargetRow] = true
			if not Moved then
				TargetRow = IsWhite and TargetRow+1 or TargetRow-1
				if (TargetRow>0 and TargetRow<9) and (not self:GetSquare( GridLet, TargetRow, CheckTable )) then tbl[GridLet][TargetRow] = "PAWNDOUBLE" end
			end
		end
	elseif class=="Rook" then
		self:GetRookMoves( tbl, GridLet, GridNum, IsWhite, 8, CheckTable )
	elseif class=="Bishop" then
		self:GetBishopMoves( tbl, GridLet, GridNum, IsWhite, 8, CheckTable )
	elseif class=="Queen" then
		self:GetRookMoves( tbl, GridLet, GridNum, IsWhite, 8, CheckTable )
		self:GetBishopMoves( tbl, GridLet, GridNum, IsWhite, 8, CheckTable )
	elseif class=="King" then
		self:GetRookMoves( tbl, GridLet, GridNum, IsWhite, 1, CheckTable )
		self:GetBishopMoves( tbl, GridLet, GridNum, IsWhite, 1, CheckTable )
		
		ChecksPerformed = true --King performs it's own checks for Check
		
		local InCheck = true
		if not IgnoreCheck then
			for CheckLet,File in pairs(tbl) do
				for CheckNum,v in pairs(File) do
					local Positions = table.Copy( self.Pieces )
					Positions[GridLet][GridNum] = nil
					Positions[CheckLet][CheckNum] = {Team = IsWhite and "White" or "Black", Class = class, Moved = true}
					if self:CheckForCheck( Positions, IsWhite ) then
						tbl[CheckLet][CheckNum] = nil --Puts us in check, remove it
					end
				end
			end
			
			InCheck = self:CheckForCheck( self.Pieces, IsWhite )
		end
		
		if (not Moved) and (not InCheck) then --Castling
			local Kingside = self:GetSquare( "h", GridNum, CheckTable )
			local Queenside = self:GetSquare( "a", GridNum, CheckTable )
			if Kingside and not self:SquareMoved(Kingside) then
				if not (self:GetSquare( "f", GridNum, CheckTable ) or self:GetSquare( "g", GridNum, CheckTable )) then
					local Positions = table.Copy( self.Pieces ) Positions[GridLet][GridNum] = nil Positions["f"][GridNum] = {Team = IsWhite and "White" or "Black", Class = class, Moved = true}
					local FSafe = not self:CheckForCheck( Positions, IsWhite )
					local Positions = table.Copy( self.Pieces ) Positions[GridLet][GridNum] = nil Positions["g"][GridNum] = {Team = IsWhite and "White" or "Black", Class = class, Moved = true}
					local GSafe = not self:CheckForCheck( Positions, IsWhite )
					if FSafe and GSafe then
						tbl["g"][GridNum] = "CASTLEKINGSIDE"
					end
				end
			end
			if Queenside and not self:SquareMoved(Queenside) then
				if not (self:GetSquare( "b", GridNum, CheckTable ) or self:GetSquare( "c", GridNum, CheckTable ) or self:GetSquare( "d", GridNum, CheckTable )) then
					local Positions = table.Copy( self.Pieces ) Positions[GridLet][GridNum] = nil Positions["c"][GridNum] = {Team = IsWhite and "White" or "Black", Class = class, Moved = true}
					local CSafe = not self:CheckForCheck( Positions, IsWhite )
					local Positions = table.Copy( self.Pieces ) Positions[GridLet][GridNum] = nil Positions["d"][GridNum] = {Team = IsWhite and "White" or "Black", Class = class, Moved = true}
					local DSafe = not self:CheckForCheck( Positions, IsWhite )
					if CSafe and DSafe then
						tbl["c"][GridNum] = "CASTLEQUEENSIDE"
					end
				end
			end
		end
	elseif class=="Knight" then
		local Up = NumToLetter[GridLet] + 2
		if Up and Up >=1 and Up<=8 then
			local Pos1 = self:GetSquare( NumToLetter[Up], GridNum-1, CheckTable )
			local Pos2 = self:GetSquare( NumToLetter[Up], GridNum+1, CheckTable )
			if (GridNum-1>=1) and ((not Pos1) or (self:SquareTeam(Pos1)==(IsWhite and "Black" or "White"))) then
				tbl[NumToLetter[Up]][GridNum-1] = true
			end
			if (GridNum+1<=8) and ((not Pos2) or (self:SquareTeam(Pos2)==(IsWhite and "Black" or "White"))) then
				tbl[NumToLetter[Up]][GridNum+1] = true
			end
		end
		
		local Down = NumToLetter[GridLet] - 2
		if Down and Down>=1 and Down<=8 then
			local Pos1 = self:GetSquare( NumToLetter[Down], GridNum-1, CheckTable )
			local Pos2 = self:GetSquare( NumToLetter[Down], GridNum+1, CheckTable )
			if (GridNum-1>=1) and ((not Pos1) or (self:SquareTeam(Pos1)==(IsWhite and "Black" or "White"))) then
				tbl[NumToLetter[Down]][GridNum-1] = true
			end
			if (GridNum+1<=8) and ((not Pos2) or (self:SquareTeam(Pos2)==(IsWhite and "Black" or "White"))) then
				tbl[NumToLetter[Down]][GridNum+1] = true
			end
		end
		
		local Let = NumToLetter[GridLet]
		
		local Left = GridNum - 2
		if Left and Left>=1 and Left<=8 then
			local Pos1 = self:GetSquare( NumToLetter[Let-1], Left, CheckTable )
			local Pos2 = self:GetSquare( NumToLetter[Let+1], Left, CheckTable )
			if Let>1 and ((not Pos1) or (self:SquareTeam(Pos1)==(IsWhite and "Black" or "White"))) then
				tbl[NumToLetter[Let-1]][Left] = true
			end
			if Let<8 and ((not Pos2) or (self:SquareTeam(Pos2)==(IsWhite and "Black" or "White"))) then
				tbl[NumToLetter[Let+1]][Left] = true
			end
		end
		
		local Right = GridNum + 2
		if Right and Right>=1 and Right<=8 then
			local Pos1 = self:GetSquare( NumToLetter[Let-1], Right, CheckTable )
			local Pos2 = self:GetSquare( NumToLetter[Let+1], Right, CheckTable )
			if Let>1 and ((not Pos1) or (self:SquareTeam(Pos1)==(IsWhite and "Black" or "White"))) then
				tbl[NumToLetter[Let-1]][Right] = true
			end
			if Let<8 and ((not Pos2) or (self:SquareTeam(Pos2)==(IsWhite and "Black" or "White"))) then
				tbl[NumToLetter[Let+1]][Right] = true
			end
		end
	end
	
	if not IgnoreCheck then
		for CheckLet,File in pairs(tbl) do
			for CheckNum,v in pairs(File) do
				local Positions = table.Copy( self.Pieces )
				Positions[GridLet][GridNum] = nil
				Positions[CheckLet][CheckNum] = {Team = IsWhite and "White" or "Black", Class = class, Moved = true}
				if self:CheckForCheck( Positions, IsWhite ) then
					tbl[CheckLet][CheckNum] = nil --Puts us in check, remove it
				end
			end
		end
	end
	
	return tbl
end

function ENT:CastlingCheck( square, IsWhite )
	if not square then return false,false end
	
	local GridNum = IsWhite and 1 or 8
	local moved = self:SquareMoved( square )
	local InCheck = self:CheckForCheck( self.Pieces, IsWhite )
	local Queenside, Kingside = false, false
	if (not Moved) and (not InCheck) then --Castling
		local Kingside = self:GetSquare( "h", GridNum, CheckTable )
		local Queenside = self:GetSquare( "a", GridNum, CheckTable )
		if Kingside and not self:SquareMoved(Kingside) then
			if not (self:GetSquare( "f", GridNum, CheckTable ) or self:GetSquare( "g", GridNum, CheckTable )) then
				local Positions = table.Copy( self.Pieces ) Positions["d"][GridNum] = nil Positions["f"][GridNum] = {Team = IsWhite and "White" or "Black", Class = class, Moved = true}
				local FSafe = not self:CheckForCheck( Positions, IsWhite )
				local Positions = table.Copy( self.Pieces ) Positions["d"][GridNum] = nil Positions["g"][GridNum] = {Team = IsWhite and "White" or "Black", Class = class, Moved = true}
				local GSafe = not self:CheckForCheck( Positions, IsWhite )
				if FSafe and GSafe then
					Kingside = true
				end
			end
		end
		if Queenside and not self:SquareMoved(Queenside) then
			if not (self:GetSquare( "b", GridNum, CheckTable ) or self:GetSquare( "c", GridNum, CheckTable ) or self:GetSquare( "d", GridNum, CheckTable )) then
				local Positions = table.Copy( self.Pieces ) Positions["d"][GridNum] = nil Positions["c"][GridNum] = {Team = IsWhite and "White" or "Black", Class = class, Moved = true}
				local CSafe = not self:CheckForCheck( Positions, IsWhite )
				local Positions = table.Copy( self.Pieces ) Positions["d"][GridNum] = nil Positions["d"][GridNum] = {Team = IsWhite and "White" or "Black", Class = class, Moved = true}
				local DSafe = not self:CheckForCheck( Positions, IsWhite )
				if CSafe and DSafe then
					Queenside = true
				end
			end
		end
	end
	return Queenside, Kingside
end

function ENT:RefreshSquares()
	self.Squares = {}
	self.LastSquaresUpdatePos = self:GetPos()
	
	local pos = self:LocalToWorld( self.TopLeft )
	
	local forward = -self:GetRight() * self.RealH
	local right = self:GetUp() * self.RealW
	
	for i=0,7 do
		self.Squares[i] = {}
		for n=0,7 do
			local offsetX = ((right*i)+(right*0.5))
			local offsetY = ((forward*n)+(forward*0.5))
			
			self.Squares[i][n] = pos + (offsetX + offsetY)
		end
	end
	local HalfW = (self:GetRight() * self.RealW/2)
	self.Squares[CHESS_WCAP1] = {}
	self.Squares[CHESS_WCAP2] = {}
	self.Squares[CHESS_BCAP1] = {}
	self.Squares[CHESS_BCAP2] = {}
	for n=0,7 do
		local offsetXOne = ((right*8.5)+(right*0.5))
		local offsetXTwo = ((right*9.3)+(right*0.5))
		local offsetY = ((HalfW*-(7+n))+(forward*0.5))
		
		self.Squares[CHESS_WCAP1][n] = pos + (offsetXOne + offsetY)
		self.Squares[CHESS_WCAP2][n] = pos + (offsetXTwo + offsetY)
	end
	for n=0,7 do
		local offsetXOne = ((right*-1.4)+(right*0.5))
		local offsetXTwo = ((right*-2.2)+(right*0.5))
		local offsetY = ((HalfW*(n-7))+(forward*0.5))
		
		self.Squares[CHESS_BCAP1][n] = pos + (offsetXOne + offsetY)
		self.Squares[CHESS_BCAP2][n] = pos + (offsetXTwo + offsetY)
	end
end
function ENT:GetSquarePos( GridLetter, GridNumber)
	return self:GetTableKey( self.Squares, GridLetter, GridNumber )
end
function ENT:ResetBoard()
	if SERVER then
		self:SetDrawOffer( PLAYER_NONE )
		
		self:SetWhiteWager( -1 )
		self:SetBlackWager( -1 )
		
		self:SetWhitePassant( 0 )
		self:SetBlackPassant( 0 )
		
		self:SetWhiteTime( 600 )
		self:SetBlackTime( 600 )
		
		self:SetMoveCount( 0 )
		self:SetRepetition( false )
		self.RepetitionTable = {}
	end
	self:RefreshSquares()
	
	if self.Pieces then
		for _,File in pairs( self.Pieces ) do
			for _,Square in pairs(File) do
				if IsValid(Square.Ent) then Square.Ent:SetGridNum(-1) Square.Ent:Remove() end
			end
		end
	end
	self.Pieces = {
		["a"] = {
			[1] = {Team="White",Class="Rook",Moved=false}, [2] = {Team="White",Class="Pawn",Moved=false}, [7] = {Team="Black",Class="Pawn",Moved=false}, [8] = {Team="Black",Class="Rook",Moved=false},
		},
		["b"] = {
			[1] = {Team="White",Class="Knight",Moved=false}, [2] = {Team="White",Class="Pawn",Moved=false}, [7] = {Team="Black",Class="Pawn",Moved=false}, [8] = {Team="Black",Class="Knight",Moved=false},
		},
		["c"] = {
			[1] = {Team="White",Class="Bishop",Moved=false}, [2] = {Team="White",Class="Pawn",Moved=false}, [7] = {Team="Black",Class="Pawn",Moved=false}, [8] = {Team="Black",Class="Bishop",Moved=false},
		},
		["d"] = {
			[1] = {Team="White",Class="Queen",Moved=false}, [2] = {Team="White",Class="Pawn",Moved=false}, [7] = {Team="Black",Class="Pawn",Moved=false}, [8] = {Team="Black",Class="Queen",Moved=false},
		},
		["e"] = {
			[1] = {Team="White",Class="King",Moved=false}, [2] = {Team="White",Class="Pawn",Moved=false}, [7] = {Team="Black",Class="Pawn",Moved=false}, [8] = {Team="Black",Class="King",Moved=false},
		},
		["f"] = {
			[1] = {Team="White",Class="Bishop",Moved=false}, [2] = {Team="White",Class="Pawn",Moved=false}, [7] = {Team="Black",Class="Pawn",Moved=false}, [8] = {Team="Black",Class="Bishop",Moved=false},
		},
		["g"] = {
			[1] = {Team="White",Class="Knight",Moved=false}, [2] = {Team="White",Class="Pawn",Moved=false}, [7] = {Team="Black",Class="Pawn",Moved=false}, [8] = {Team="Black",Class="Knight",Moved=false},
		},
		["h"] = {
			[1] = {Team="White",Class="Rook",Moved=false}, [2] = {Team="White",Class="Pawn",Moved=false}, [7] = {Team="Black",Class="Pawn",Moved=false}, [8] = {Team="Black",Class="Rook",Moved=false},
		},
		[CHESS_WCAP1] = {}, [CHESS_WCAP2] = {}, [CHESS_BCAP1] = {}, [CHESS_BCAP2] = {},
	}
	self:Update()
end

function ENT:Update( Move1, Move2 )
	if CLIENT then return end
	Move1,Move2 = Move1 or {},Move2 or {}
	net.Start( "Chess Update" )
		net.WriteEntity( self )
		net.WriteTable( self.Pieces )
		if Move1 then
			net.WriteTable( Move1 )
			if Move2 then net.WriteTable( Move2 ) end
		end
	net.Broadcast()
end

ENT.LastTick = 0
ENT.LastTickTeam = ""
function ENT:Think()
	if SERVER then
		if self.Removing then return end
		-- if not (IsValid(self.TableEnt) and IsValid(self.WhiteSeat) and IsValid(self.BlackSeat)) then -- Make sure entities exist
		if not (IsValid(self.TableEnt)) then -- Make sure entities exist
			self.Removing = true
			self:Remove()
			return
		end
		
		self.TableEnt:SetHealth( 1000000 ) -- If the table's a breakable model this should prevent destruction.
		self.TableEnt:SetVelocity( Vector(0,0,0) )
		
		if (not self.NextUnlock) or (CurTime()>self.NextUnlock) then -- Force unlock seats
			if IsValid(self.WhiteSeat) then self.WhiteSeat:Fire( "Unlock", "", 0 ) end
			if IsValid(self.BlackSeat) then self.BlackSeat:Fire( "Unlock", "", 0 ) end
			
			self.NextUnlock = CurTime()+10
			
			if self:GetChessState()~=CHESS_WAGER then
				self:SetWhiteWager( -1 )
				self:SetBlackWager( -1 )
			end
		end
		
		if self:GetChessState()==CHESS_WHITEMOVE or self:GetChessState()==CHESS_WHITEPROMO then
			if self.LastTickTeam=="White" then self:SetWhiteTime( math.max(0,self:GetWhiteTime()-(CurTime()-self.LastTick)) ) end
			self.LastTickTeam = "White"
			
			if self:GetWhiteTime()<=0 then
				local WhitePly = self:GetPlayer( "White" )
				local BlackPly = self:GetPlayer( "Black" )
				
				local WhiteName = IsValid(WhitePly) and WhitePly:Nick() or "[Anonymous White]"
				local BlackName = IsValid(BlackPly) and BlackPly:Nick() or "[Anonymous Black]"
				
				self:EndGame( "Black" )
				net.Start( "Chess GameOver" )
					net.WriteTable( {Color(150,255,150), "Time's up! ", Color(100,100,100), BlackName, Color(150,255,150), self:GetElo(BlackPly), " won against ", Color(255,255,255), WhiteName, Color(150,255,150), self:GetElo(WhitePly),"."} )
					net.WriteString( "icon16/clock.png" )
				net.Broadcast()
			end
		elseif self:GetChessState()==CHESS_BLACKMOVE or self:GetChessState()==CHESS_BLACKPROMO then
			if self.LastTickTeam=="Black" then self:SetBlackTime( math.max(0,self:GetBlackTime()-(CurTime()-self.LastTick)) ) end
			self.LastTickTeam = "Black"
			
			if self:GetBlackTime()<=0 then
				local WhitePly = self:GetPlayer( "White" )
				local BlackPly = self:GetPlayer( "Black" )
				
				local WhiteName = IsValid(WhitePly) and WhitePly:Nick() or "[Anonymous White]"
				local BlackName = IsValid(BlackPly) and BlackPly:Nick() or "[Anonymous Black]"
				
				self:EndGame( "White" )
				net.Start( "Chess GameOver" )
					net.WriteTable( {Color(150,255,150), "Time's up! ", Color(255,255,255), WhiteName, Color(150,255,150), self:GetElo(BlackPly), " won against ", Color(100,100,100), BlackName, Color(150,255,150), self:GetElo(WhitePly),"."} )
					net.WriteString( "icon16/clock.png" )
				net.Broadcast()
			end
		else
			self.LastTickTeam = ""
		end
		self.LastTick = CurTime()
	else --if CLIENT then
		local tbl = self:GetTableEnt()
		if IsValid(tbl) then
			if tbl.ChessIsErrorModel or tbl:GetModel()=="models/error.mdl" then --Much cheaper than a file.Find
				tbl.ChessIsErrorModel = true
				self:SetParent( nil )
				tbl:SetNoDraw( true )
				
				tbl.ClientChessTable = IsValid(tbl.ClientChessTable) and tbl.ClientChessTable or ClientsideModel( self.Models["hl2table"] )
				local ent = tbl.ClientChessTable
				
				if not tbl.PerformedChessTableSetup then
					ent:SetPos( tbl:GetPos()+Vector(0,0,13) )
					
					tbl:SetMoveType( MOVETYPE_NONE )
					tbl:PhysicsInit( SOLID_NONE )
					tbl:SetCollisionGroup( COLLISION_GROUP_WORLD )
					
					ent:SetMoveType( MOVETYPE_NONE )
					ent:PhysicsInit( SOLID_VPHYSICS )
					ent:SetCollisionGroup( COLLISION_GROUP_WEAPON )
					
					self:SetMoveType( MOVETYPE_NONE )
					self:PhysicsInit( SOLID_NONE )
					self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
					
					tbl.PerformedChessTableSetup = true
				end
				
				tbl:SetModel( self.Models["hl2table"] )
				tbl:SetPos( ent:GetPos() )
				tbl:SetNoDraw( true )
				self:SetPos( ent:GetPos()+Vector(0,0,17) )
			elseif IsValid( tbl.ClientChessTable ) then
				tbl.ClientChessTable:Remove()
				tbl.PerformedChessTableSetup = nil
			end
		end
	end
end

function ENT:GetPlayer( team )
	if (team=="White" or team==true) then
		return (self:GetWhitePlayer())
	else
		return (self:GetBlackPlayer())
	end
end
function ENT:EndGame( winner, HideMsg )
	self:SetChessState( CHESS_INACTIVE )
	self:SetPlaying( false )
	
	local White = self:GetPlayer( "White" )
	local Black = self:GetPlayer( "Black" )
	timer.Simple( 0.5, function()
		if IsValid(White) then
			White:SetNWBool( "IsInChess", false )
			White:SetNWEntity( "ActiveChessBoard", NULL )
			
			if IsValid(self) and White:GetVehicle()==self.WhiteSeat then White:ExitVehicle() end
		end
		if IsValid(Black) then
			Black:SetNWBool( "IsInChess", false )
			Black:SetNWEntity( "ActiveChessBoard", NULL )
			
			if IsValid(self) and Black:GetVehicle()==self.BlackSeat then Black:ExitVehicle() end
		end
	end)
	
	self:SetWhitePlayer( NULL )
	self:SetBlackPlayer( NULL )
	
	local winnings = (self.WagerValue or 0)*2
	if IsValid( White ) then
		if winner=="White" then
			if IsValid(Black) then White:ChessWin( Black ) end
			if self.WagerValue then
				if self:GetPSWager() then
					White:PS_GivePoints( winnings )
				else
					if White.addMoney then White:addMoney( winnings ) else White:SetDarkRPVar( "money", (White:getDarkRPVar( "money" ) or 0) + winnings ) end
				end
			end
		elseif winner~="Black" then
			if winner~="Error" and IsValid(Black) then White:ChessDraw( Black ) end
			if self.WagerValue then
				if self:GetPSWager() then
					White:PS_GivePoints( self.WagerValue )
				else
					if White.addMoney then White:addMoney( self.WagerValue ) else White:SetDarkRPVar( "money", (White:getDarkRPVar( "money" ) or 0) + self.WagerValue ) end
				end
			end
		end
	end
	if IsValid( Black ) then
		if winner=="Black" then
			if IsValid(White) then Black:ChessWin( White ) end
			if self.WagerValue then
				if self:GetPSWager() then
					Black:PS_GivePoints( winnings )
				else
					if Black.addMoney then Black:addMoney( winnings ) else Black:SetDarkRPVar( "money", (Black:getDarkRPVar( "money" ) or 0) + winnings ) end
				end
			end
		elseif winner~="White" then
			if self.WagerValue then
				if self:GetPSWager() then
					Black:PS_GivePoints( self.WagerValue )
				else
					if Black.addMoney then Black:addMoney( self.WagerValue ) else Black:SetDarkRPVar( "money", (Black:getDarkRPVar( "money" ) or 0) + self.WagerValue ) end
				end
			end
		end
	end
end
function ENT:DoCapture( square, EndLet, EndNum )
	if not square then return end
	
	table.Empty( self.RepetitionTable ) --When it's gone, it's gone for good
	self:SetRepetition( false )
	
	self:SetMoveCount( 0 )
	
	local class = square.Class
	
	local made = false
	local CapLet,CapNum
	if square.Team=="White" then --Black captured
		for i=CHESS_BCAP1,CHESS_BCAP2 do
			for n=1,8 do
				local CapSq = self:GetSquare( i, n )
				if not CapSq then
					self.Pieces[i][n] = {Team="White", Class=class, Moved=false}
					CapSq = self.Pieces[i][n]
					
					made = true
					CapLet,CapNum = i,n
					break
				end
			end
			if made then break end
		end
	else
		for i=CHESS_WCAP1,CHESS_WCAP2 do
			for n=1,8 do
				local CapSq = self:GetSquare( i, n )
				if not CapSq then
					self.Pieces[i][n] = {Team="Black", Class=class, Moved=false}
					CapSq = self.Pieces[i][n]
					
					made = true
					CapLet,CapNum = i,n
					break
				end
			end
			if made then break end
		end
	end
	
	return {From={EndLet,EndNum}, To={CapLet,CapNum}}
end

function ENT:CheckForCheck( tbl, CheckWhite )
	if not tbl then return true end --Assume invalid move
	
	local king, KingLet, KingNum
	for GridLet,File in pairs(tbl) do
		for GridNum,square in pairs(File) do
			if square and self:SquareClass(square)=="King" and ((CheckWhite and self:SquareTeam(square)=="White") or ((not CheckWhite) and self:SquareTeam(square)=="Black")) then
				king = square
				KingLet = GridLet
				KingNum = GridNum
				break
			end
		end
		if king then break end
	end
	if not king then return true end --Assume invalid
	
	for GridLet,File in pairs(tbl) do
		for GridNum,square in pairs(File) do
			if square and ((CheckWhite and self:SquareTeam(square)=="Black") or ((not CheckWhite) and self:SquareTeam(square)=="White")) then
				local Moves = self:GetMove( GridLet, GridNum, true, tbl )
				if Moves[KingLet] and Moves[KingLet][KingNum] then return true end --Something can take the king
			end
		end
	end
	
	return false --King is safe
end
function ENT:IsCheckmate( CheckWhite )
--	local IsCheck = self:CheckForCheck( self.Pieces, CheckWhite ) --We no longer check for check here, this is also a stalemate check
--	if not IsCheck then return false end
	
	for GridLet,File in pairs(self.Pieces) do
		for GridNum,square in pairs(File) do
			if square and ((CheckWhite and self:SquareTeam(square)=="White") or ((not CheckWhite) and self:SquareTeam(square)=="Black")) then
				local Moves = self:GetMove( GridLet, GridNum, false, tbl )
				for MoveLet,File in pairs(Moves) do
					if table.Count(File)>0 then return false end --There's a valid move, it's fine
				end
			end
		end
	end
	
	return true
end
function ENT:NoMaterialCheck()
	local BlackMat = {}
	local WhiteMat = {}
	
	for GridLet,File in pairs(self.Pieces) do
		if GridLet==CHESS_WCAP1 or GridLet==CHESS_WCAP2 or GridLet==CHESS_BCAP1 or GridLet==CHESS_BCAP2 then continue end
		for GridNum,square in pairs(File) do
			if square then
				local IsWhite = self:SquareTeam(square)=="White"
				local Class = self:SquareClass(square)
				if Class=="Queen" or Class=="Rook" or Class=="Pawn" then return false end --Always sufficient material
				if Class=="King" then continue end --Don't count king
				
				if IsWhite then
					table.insert( WhiteMat, {Square=square, Class=Class, GridLet=GridLet, GridNum=GridNum} )
				else
					table.insert( BlackMat, {square=square, Class=Class, GridLet=GridLet, GridNum=GridNum} )
				end
			end
		end
	end
	
	if #BlackMat==0 and #WhiteMat==0 then return true end --Kings only, draw
	if #BlackMat==1 and #WhiteMat==0 and (BlackMat[1].Class=="Bishop" or BlackMat[1].Class=="Knight") then return true end --King versus King+Bishop/Knight
	if #BlackMat==0 and #WhiteMat==1 and (WhiteMat[1].Class=="Bishop" or WhiteMat[1].Class=="Knight") then return true end --King versus King+Bishop/Knight
	
	local BishopCol
	for i=1,#BlackMat do
		if BlackMat[i].Class~="Bishop" then return false end --Has non-bishops, it's fine
		if not BishopCol then BishopCol = self:SquareColor(BlackMat[i].GridLet,BlackMat[i].GridNum) end
		if BishopCol~=self:SquareColor(BlackMat[i].GridLet,BlackMat[i].GridNum) then return false end --Bishops are on different colours, it's fine
	end
	for i=1,#WhiteMat do
		if WhiteMat[i].Class~="Bishop" then return false end
		if not BishopCol then BishopCol = self:SquareColor(WhiteMat[i].GridLet,WhiteMat[i].GridNum) end
		if BishopCol~=self:SquareColor(WhiteMat[i].GridLet,WhiteMat[i].GridNum) then return false end --Even if it's the enemy on a different colour, checkmate is possible
	end
	
	return true
end

function table.EqualsTable( CheckTable, MatchTable, depth )
	if not (CheckTable and MatchTable) then return false end
	depth = depth or 1
	if depth>=15 then error("Unable to match tables: Tables too deep!") end
	
	if table.Count( CheckTable ) ~= table.Count( MatchTable ) then return false end
	for k,v in pairs( CheckTable ) do
		if type(v)=="table" then
			if type(MatchTable[k])~="table" then return false end
			if not table.EqualsTable( v, MatchTable[k], depth+1 ) then return false end
		elseif type(v)=="Entity" then
		else
			if MatchTable[k]~=v then return false end
		end
	end
	return true
end
function ENT:DoRepetition()
	local Pieces = self.Pieces
	local WKing = self:GetSquare( "d", 1 )
	local BKing = self:GetSquare( "d", 8 )
	local WCQ, WCK = self:CastlingCheck( WKing, true ) --WhiteCastleQueenside, Kingside
	local BCQ, BCK = self:CastlingCheck( BKing, false ) --BlackCastleQueenside, Kingside
	for _,Saved in pairs( self.RepetitionTable ) do
		if table.EqualsTable( Saved.Pieces, Pieces ) and Saved.WCQ==WCQ and Saved.WCK==WCK and Saved.BCQ==BCQ and Saved.BCK==BCK then
			Saved.Count = Saved.Count+1
			if Saved.Count>=3 then self:SetRepetition( true ) end
			return
		end
	end
	self:SetRepetition( false )
	--No match
	table.insert( self.RepetitionTable, {
		WCQ = WCQ, WCK = WCK, BCQ = BCQ, BCK = BCK,
		Pieces = table.Copy( Pieces ), Count = 1
	})
end

function ENT:DoMove( StartLet, StartNum, EndLet, EndNum )
	if CLIENT then return end
	if not (StartLet and EndLet and StartNum and EndNum) then return end
	if (StartLet==EndLet) and (StartNum==EndNum) then return end
	
	local Start = self:GetSquare( StartLet, StartNum )
	if not Start then return end
	
	local Moves = self:GetMove( StartLet, StartNum )
	if not Moves[EndLet][EndNum] then return end
	local Move = Moves[EndLet][EndNum]
	
	self:SetWhitePassant( 0 ) --Reset after the move verified
	self:SetBlackPassant( 0 )
	self:SetRepetition( false )
	
	self:SetMoveCount( ((Start.Class=="Pawn") and 0) or self:GetMoveCount()+1 )
	local IgnoreRepetition
	
	local CapMove
	if Move=="PAWNDOUBLE" then
		if Start.Team=="White" then
			self:SetWhitePassant( PassantFlags[NumToLetter[StartLet]] )
		else
			self:SetBlackPassant( PassantFlags[NumToLetter[StartLet]] )
		end
	elseif Move=="ENPASSANT" then
		local Take = self:GetSquare( EndLet, StartNum )
		if Take and Take.Class then
			CapMove = self:DoCapture( Take, EndLet, StartNum )
		end
		self.Pieces[EndLet][StartNum] = nil
		IgnoreRepetition = true --Passant state is counted, and is never the same
	elseif Move=="CASTLEKINGSIDE" then
		CapMove = self:DoMove( "h", StartNum, "f", StartNum )
	elseif Move=="CASTLEQUEENSIDE" then
		CapMove = self:DoMove( "a", StartNum, "d", StartNum )
	end
	
	local End = self:GetSquare( EndLet, EndNum )
	if not End then
		self.Pieces[EndLet] = self.Pieces[EndLet] or {}
		self.Pieces[EndLet][EndNum] = self.Pieces[EndLet][EndNum] or {}
		End = self.Pieces[EndLet][EndNum]
	end
	if End.Class then
		CapMove = self:DoCapture( End, EndLet, EndNum )
	end
	
	End.Team=Start.Team
	End.Class=Start.Class
	End.Moved=true
	
	self.Pieces[StartLet][StartNum] = nil
	
	local ply = self:GetPlayer( End.Team )
	if (EndNum==1 or EndNum==8) and End.Class=="Pawn" and IsValid(ply) then --End of the board
		net.Start( "Chess PromotionSelection" )
			net.WriteInt( NumToLetter[EndLet], 5 )
		net.Send( ply )
		self:SetChessState( End.Team=="White" and CHESS_WHITEPROMO or CHESS_BLACKPROMO )
	else
		self:SetChessState( End.Team=="White" and CHESS_BLACKMOVE or CHESS_WHITEMOVE )
	end
	
	local move = {From={StartLet,StartNum},To={EndLet,EndNum}}
	self:Update( move, CapMove )
	
	local IsCheck = self:CheckForCheck( self.Pieces, End.Team~="White" )
	local Checkmate = self:IsCheckmate( End.Team~="White" )
	if IsCheck and Checkmate then
		local WhitePly = self:GetPlayer( "White" )
		local BlackPly = self:GetPlayer( "Black" )
		
		local WhiteName = IsValid(WhitePly) and WhitePly:Nick() or "[Anonymous White]"
		local BlackName = IsValid(BlackPly) and BlackPly:Nick() or "[Anonymous Black]"
		self:EndGame( End.Team )
		net.Start( "Chess GameOver" )
			if End.Team=="White" then
				net.WriteTable( {Color(255,255,255), WhiteName, Color(150,255,150), self:GetElo(WhitePly), " has checkmated ", Color(100,100,100), BlackName, Color(150,255,150), self:GetElo(BlackPly),"!"} )
			else
				net.WriteTable( {Color(100,100,100), BlackName, Color(150,255,150), self:GetElo(BlackPly), " has checkmated ", Color(255,255,255), WhiteName, Color(150,255,150), self:GetElo(WhitePly),"!"} )
			end
			net.WriteString( "icon16/medal_gold_2.png" )
		net.Broadcast()
		
		return
	elseif Checkmate then
		local WhitePly = self:GetPlayer( "White" )
		local BlackPly = self:GetPlayer( "Black" )
		
		local WhiteName = IsValid(WhitePly) and WhitePly:Nick() or "[Anonymous White]"
		local BlackName = IsValid(BlackPly) and BlackPly:Nick() or "[Anonymous Black]"
		self:EndGame()
		net.Start( "Chess GameOver" )
			net.WriteTable( {Color(150,255,150), "Stalemate! ", Color(255,255,255), WhiteName, Color(150,255,150), self:GetElo(WhitePly), " drew with ", Color(100,100,100), BlackName, Color(150,255,150), self:GetElo(BlackPly),"!"} )
			net.WriteString( "icon16/medal_silver_1.png" )
		net.Broadcast()
		
		return
	end
	
	local NoMaterial = self:NoMaterialCheck()
	if NoMaterial then
		local WhitePly = self:GetPlayer( "White" )
		local BlackPly = self:GetPlayer( "Black" )
		
		local WhiteName = IsValid(WhitePly) and WhitePly:Nick() or "[Anonymous White]"
		local BlackName = IsValid(BlackPly) and BlackPly:Nick() or "[Anonymous Black]"
		self:EndGame()
		net.Start( "Chess GameOver" )
			net.WriteTable( {Color(150,255,150), "Insufficient material! ", Color(255,255,255), WhiteName, Color(150,255,150), " drew with ", Color(100,100,100), BlackName, Color(150,255,150),"!"} )
			net.WriteString( "icon16/medal_silver_1.png" )
		net.Broadcast()
		
		return
	end
	
	if IgnoreRepetition then
		self:SetRepetition( false )
	else
		self:DoRepetition()
	end
	return move
end
function ENT:GetElo( ply )
	return IsValid(ply) and " ("..ply:GetChessElo()..")" or ""
end
function ENT:GameName()
	return self.Game or "a board game"
end

if CLIENT then
	-- Stop spectating --
	local function EndSpec(board)
		if IsValid(LocalPlayer()) then
			if LocalPlayer().Chess_Spectating==board then
				LocalPlayer().Chess_Spectating = nil
			end
		end
		
		if not IsValid(board) then return end
		
		if board.SpectatingTable then chat.AddText( HatsChat and {"LINEICON", Icon=Material( "icon16/controller.png" )} or "", Color(150,255,150), "You are no longer spectating this game." ) end
		board.SpectatingTable = false
	end
	function ENT:EndSpectating()
		EndSpec(self)
	end
	
	-- Reset Board --
	local ChessPanel, WagerPanel
	function ENT:Refresh()
		for GridLet,column in pairs( self.Pieces ) do
			for GridNum,square in pairs( column ) do
				if (not IsValid( square.Ent )) or (NumToLetter[square.Ent:GetGridLet()]~=GridLet) or (square.Ent:GetGridNum()~=GridNum) then
					column[GridNum] = nil
				end
			end
		end
	end
	
	-- Do Move --
	function ENT:RequestMove( StartLet, StartNum, EndLet, EndNum)
		if not (StartLet and StartNum and EndLet and EndNum) then return end
		
		net.Start( "Chess ClientRequestMove" )
			net.WriteInt( StartLet+1, 5 )
			net.WriteInt( 8-StartNum, 5 )
			net.WriteInt( EndLet+1, 5 )
			net.WriteInt( 8-EndNum, 5 )
		net.SendToServer()
	end
	
	-- In-Game VGUI --
	local PanelCol = {
		Main = Color(0,0,0,200), ToMove = Color(200,200,200,20), Text = Color(180,180,180),
		White = Color(255,255,255), Black = Color(20,20,20,255),
	}
	surface.CreateFont( "ChessTextSmall", { font = "Arial", size = 16, weight = 600})
	surface.CreateFont( "ChessText", { font = "Arial", size = 24, weight = 600})
	surface.CreateFont( "ChessTextLarge", { font = "Arial", size = 32, weight = 600})
	function ENT:CreateChessPanel()
		EndSpec(self)
		
		local frame = vgui.Create( "DFrame" )
		frame:SetSize(400,155)
		frame:SetPos( (ScrW()/2)-150, ScrH()-170 )
		--frame:SetDraggable( false )
		frame:SetTitle( "" )
		frame:ShowCloseButton( false )
		frame:SetDeleteOnClose( true )
		frame.Paint = function( s,w,h )
			if not IsValid(self) then
				s:Remove()
				gui.EnableScreenClicker( false )
				
				return
			end
			
			draw.RoundedBox( 8, 0, 0, w, h, PanelCol.Main )
		end
		frame:DockMargin( 0,0,0,0 )
		frame:DockPadding( 5,6,5,5 )
		
		-- Panels --
		local IconsPanel = vgui.Create("DPanel", frame)
		IconsPanel:Dock(RIGHT)
		IconsPanel:SetWide(20)
		IconsPanel.Paint = function() end
		
		local TimePnl = vgui.Create( "DPanel", frame )
		TimePnl:Dock( RIGHT )
		TimePnl:SetWide( 90 )
		TimePnl:DockMargin( 2,2,2,2 )
		TimePnl.Paint = function(s,w,h)
			if not IsValid(self) then return end
			
			draw.RoundedBox( 16, 0, 0, w, (h/2)-1, PanelCol.ToMove )
			draw.RoundedBox( 16, 0, (h/2)+1, w, (h/2)-1, PanelCol.ToMove )
			
			draw.SimpleText( string.FormattedTime( math.Round(self:GetWhiteTime() or 300,1), "%02i:%02i" ), "ChessText", w/2, h/4, PanelCol.White, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			draw.SimpleText( string.FormattedTime( math.Round(self:GetBlackTime() or 300,1), "%02i:%02i" ), "ChessText", w/2, (h/4)+(h/2), PanelCol.Black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		
		local ButtonPanel = vgui.Create( "DPanel", frame )
		ButtonPanel:SetSize( 100, 20 )
		ButtonPanel:Dock( LEFT )
		ButtonPanel:DockMargin( 4,4,4,4 )
		ButtonPanel.Paint = function() end
		
		local MidPanel = vgui.Create("DPanel", frame)
		MidPanel:SetSize(200,125)
		MidPanel:Dock( FILL )
		MidPanel:DockMargin( 4,4,4,4 )
		MidPanel.Paint = function() end
		
		-- Playing As --
		local PlayingAs = vgui.Create( "DPanel", MidPanel )
		PlayingAs:SetTall( 55 )
		PlayingAs:Dock( BOTTOM )
		PlayingAs:DockMargin( 0,0,0,0 )
		PlayingAs.Paint = function( s,w,h )
			draw.RoundedBox( 8, 0, 0, w, h, PanelCol.ToMove )
			draw.SimpleText( "Playing as", "ChessTextSmall", 5, 0, PanelCol.Text )
			
			if not IsValid(self) then return end
			
			local p = LocalPlayer()
			if p==self:GetWhitePlayer() then
				draw.SimpleText( "White", "ChessText", w/2, h/2+5, PanelCol.White, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			elseif p==self:GetBlackPlayer() then
				draw.SimpleText( "Black", "ChessText", w/2, h/2+5, PanelCol.Black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			else
				draw.SimpleText( "Spectator", "ChessText", w/2, h/2+5, PanelCol.Text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			end
		end
		
		-- Current Move --
		local ToMove = vgui.Create( "DPanel", MidPanel )
		ToMove:SetSize(200,125)
		ToMove:Dock( FILL )
		ToMove:DockMargin( 0,0,0,5 )
		ToMove.Paint = function( s,w,h )
			draw.RoundedBox( 8, 0, 0, w, h, PanelCol.ToMove )
			draw.SimpleText( "To move", "ChessTextSmall", 5, 0, PanelCol.Text )
			local state = IsValid(self) and self:GetChessState()
			if not (IsValid( self ) and state) then
				draw.SimpleText( "[N/A]", "ChessTextSmall", w/2, h/2, PanelCol.Text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			else
				local str = (state==CHESS_WAGER and "Wagers") or (state==CHESS_INACTIVE and "Waiting") or ((state==CHESS_WHITEMOVE or state==CHESS_WHITEPROMO) and "White") or ((state==CHESS_BLACKMOVE or state==CHESS_BLACKPROMO) and "Black") or "N/A"
				local col = (str=="White" and PanelCol.White) or (str=="Black" and PanelCol.Black) or PanelCol.Text
				draw.SimpleText( str, "ChessTextLarge", w/2, h/2+3, col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			end
		end
		
		-- Buttons Sidebar --
		---------------------
		
		frame.OfferDraw = vgui.Create( "DButton", ButtonPanel)
		frame.OfferDraw:SetSize(94,25)
		frame.OfferDraw:Dock( TOP )
		frame.OfferDraw:SetText( "Offer Draw" )
		frame.OfferDraw.DoClick = function( s )
			if (IsValid(self)) and not (self:GetPlaying()) then
				chat.AddText( Color(150,255,150), "You can't offer a draw before the game starts!" )
				return
			end
			net.Start( "Chess DrawOffer" ) net.SendToServer()
		end
		frame.OfferDraw.Think = function(s)
			if IsValid(self) and self:GetDrawOffer()~=PLAYER_NONE then
				if s.TextChanged then return end
				s.TextChanged = true
				
				if LocalPlayer()==self:GetWhitePlayer() then
					if self:GetDrawOffer()==PLAYER_WHITE then
						s:SetText( "Draw Offered" )
					elseif self:GetDrawOffer()==PLAYER_BLACK then
						s:SetText( "Accept Draw Offer" )
					end
				elseif LocalPlayer()==self:GetBlackPlayer() then
					if self:GetDrawOffer()==PLAYER_WHITE then
						s:SetText( "Accept Draw Offer" )
					elseif self:GetDrawOffer()==PLAYER_BLACK then
						s:SetText( "Draw Offered" )
					end
				end
			elseif s.TextChanged then
				s.TextChanged = false
				s:SetText( "Offer Draw" )
			end
		end
		
		local Resign = vgui.Create( "DButton", ButtonPanel)
		Resign:SetSize(94,25)
		Resign:Dock( TOP )
		Resign:SetText( "Resign" )
		Resign.DoClick = function( s )
			net.Start( "Chess ClientResign" ) net.SendToServer()
		end
		
		
		local MoveLimit = vgui.Create( "DButton", ButtonPanel)
		MoveLimit:SetSize(94,25)
		MoveLimit:Dock( TOP )
		--MoveLimit:Dock( FILL )
		MoveLimit:SetText( "Draw (50 moves)" )
		MoveLimit.DoClick = function( s )
			net.Start( "Chess ClientCallDraw" )
				net.WriteUInt( CHESS_DRAW_50, 2 )
			net.SendToServer()
		end
		MoveLimit:SetEnabled( false )
		MoveLimit.Think = function( s )
			MoveLimit:SetEnabled( IsValid(self) and self:GetMoveCount()>=50 )
		end
		
		local Repetition = vgui.Create( "DButton", ButtonPanel)
		Repetition:SetSize(94,25)
		Repetition:Dock( TOP )
		Repetition:SetText( "Draw (Repetition)" )
		Repetition.DoClick = function( s )
			net.Start( "Chess ClientCallDraw" )
				net.WriteUInt( CHESS_DRAW_3, 2 )
			net.SendToServer()
		end
		Repetition:SetEnabled( false )
		Repetition.Think = function( s )
			Repetition:SetEnabled( IsValid(self) and self:GetRepetition() )
		end
		
		local DermaMode = vgui.Create( "DButton", ButtonPanel)
		DermaMode:SetSize(94,25)
		DermaMode:Dock( TOP )
		DermaMode:SetText( "Toggle 2D Mode" )
		DermaMode.DoClick = function( s )
			if IsValid(Chess_2DDermaPanel) then
				Chess_2DDermaPanel:Remove()
			else
				Chess_Open2DBoard( self )
			end
		end
		
		-- Icons sidebar --
		-------------------
		
		local resignIcon = vgui.Create( "DButton", IconsPanel )
		resignIcon:SetImage( "icon16/door_in.png" )
		resignIcon:SetSize( 16,20 )
		-- resignIcon:SetPos( 377,0 )
		resignIcon:Dock(TOP)
		resignIcon:SetText( "" )
		resignIcon.DoClick = function(s)
			net.Start( "Chess ClientResign" ) net.SendToServer()
		end
		resignIcon.Paint = function() end
		resignIcon:SetTooltip( "Resign" )
		
		local toggleSide = vgui.Create( "DButton", IconsPanel )
		toggleSide:SetImage( "icon16/arrow_rotate_clockwise.png" )
		toggleSide:Dock(TOP)
		toggleSide:SetSize( 16,20 )
		toggleSide:SetPos( 377,20 )
		toggleSide:SetText( "" )
		toggleSide.DoClick = function(s)
			self.FlipView = not self.FlipView
		end
		toggleSide.Paint = function() end
		toggleSide:SetTooltip( "Rotate View" )
		
		local toggleGridLetters = vgui.Create( "DCheckBox", IconsPanel )
		toggleGridLetters:SetImage( "icon16/font.png" )
		toggleGridLetters:Dock(TOP)
		toggleGridLetters:SetSize( 16,20 )
		toggleGridLetters:SetPos( 377,20 )
		toggleGridLetters:SetText( "" )
		toggleGridLetters:SetConVar( "chess_gridletters" )
		toggleGridLetters.OnChange = function(s,newvalue)
			s:SetAlpha( s:GetChecked() and 255 or 100 )
		end
		toggleGridLetters.Paint = function() end
		toggleGridLetters.PerformLayout = function(s) -- DCheckBox overwrites DButton's PerformLayout, re-apply it
			if IsValid(s.m_Image) then
				s.m_Image:SetPos( 4, ( s:GetTall() - s.m_Image:GetTall() ) * 0.5 )
				s:SetTextInset( s.m_Image:GetWide() + 16, 0 )
			end
			
			DLabel.PerformLayout( s )
		end
		toggleGridLetters:SetTooltip( "Toggle Coordinates" )
		
		return frame
	end
	local function CreateWagerPanel( board )
		local frame = vgui.Create( "DFrame" )
		frame:SetSize(200,70)
		frame:SetPos( (ScrW()/2)-100, (ScrH()/2)-75 )
		--frame:SetDraggable( false )
		frame:SetTitle( "" )
		frame:ShowCloseButton( false )
		frame:SetDeleteOnClose( true )
		frame.Paint = function( s,w,h )
			draw.RoundedBox( 8, 0, 0, w, h, PanelCol.Main )
		end
		frame.Think = function( s )
			if board:GetChessState()~=CHESS_WAGER then
				s:Remove()
			end
		end
		frame:DockMargin( 0,0,0,0 )
		frame:DockPadding( 5,6,5,5 )
		
		local SliderPanel = vgui.Create( "DPanel", frame )
		SliderPanel:SetSize(200,20)
		SliderPanel:Dock( TOP )
		SliderPanel:DockPadding( 2,2,2,2 )
		SliderPanel.Paint = function( s,w,h )
			draw.RoundedBox( 4, 0, 0, w, h, PanelCol.ToMove )
		end
		
		local WagerNum = vgui.Create( "DNumSlider", SliderPanel )
		WagerNum:SetSize(200,20)
		WagerNum:Dock( FILL )
		WagerNum:SetText( "Wager" )
		WagerNum.Label:SizeToContents()
		WagerNum:SetMinMax( 0, math.Clamp(
			((board:GetPSWager() and LocalPlayer():PS_GetPoints()) or ((not board:GetPSWager()) and LocalPlayer():getDarkRPVar( "money" ))) or 0,
			0, 16777215) )
		WagerNum:SetDark( true )
		WagerNum:SetDecimals( 0 )
		WagerNum:SetValue( 0 )
		--WagerNum.Slider:SetLockY( 10 )
		WagerNum:SizeToContents()
		
		local ButtonPanel = vgui.Create( "DPanel", frame )
		ButtonPanel:SetSize(200, 30)
		ButtonPanel:Dock( BOTTOM )
		ButtonPanel.Paint = function() end
		
		local AcceptButton = vgui.Create( "DButton", ButtonPanel )
		AcceptButton:SetWide( 61 )
		AcceptButton:SetText( "Accept" )
		AcceptButton:SetEnabled( false )
		AcceptButton:Dock( LEFT )
		AcceptButton.WagerVal = -1
		AcceptButton.Think = function( s )
			if LocalPlayer()==board:GetWhitePlayer() then
				if board:GetBlackWager() and board:GetBlackWager()>=0 then
					s:SetEnabled( true )
					s:SetText( tostring(board:GetBlackWager()) )
					s.WagerVal = board:GetBlackWager()
				end
			elseif LocalPlayer()==board:GetBlackPlayer() then
				if board:GetWhiteWager() and board:GetWhiteWager()>=0 then
					s:SetEnabled( true )
					s:SetText( tostring(board:GetWhiteWager()) )
					s.WagerVal = board:GetWhiteWager()
				end
			end
		end
		AcceptButton.DoClick = function()
			net.Start( "Chess ClientWager" )
				net.WriteUInt( math.Clamp(AcceptButton.WagerVal, 0, 16777215), 24 )
			net.SendToServer()
		end
		
		local ExitButton = vgui.Create( "DButton", ButtonPanel )
		ExitButton:SetWide( 61 )
		ExitButton:SetText( "Exit" )
		ExitButton:Dock( RIGHT )
		ExitButton.DoClick = function( s )
			net.Start( "Chess ClientResign" ) net.SendToServer()
		end
		
		local WagerButton = vgui.Create( "DButton", ButtonPanel )
		WagerButton:SetText( "Wager" )
		WagerButton:Dock( FILL )
		WagerButton:DockMargin(5,0,5,0)
		WagerButton.DoClick = function( s )
			net.Start( "Chess ClientWager" )
				net.WriteUInt( WagerNum:GetValue() or 0, 24 )
			net.SendToServer()
		end
		frame:MakePopup()
		
		return frame
	end
	
	-- Camera control --
	local IsInChess, ScreenPos, ScreenAng, ActiveBoard
	local function ChessSeatCam( ply, pos, ang, fov, nearz, farz )
		if ply:GetNWBool( "IsInChess", false ) or IsValid(ply.Chess_Spectating) then
			ActiveBoard = nil
			if ply:GetNWBool( "IsInChess", false ) then
				ActiveBoard = ply:GetNWEntity( "ActiveChessBoard", nil )
			else
				ActiveBoard = ply.Chess_Spectating
			end
			if not IsValid(ActiveBoard) then return end
			
			if ply:GetNWBool( "IsInChess", false ) then
				if not IsValid(ChessPanel) then
					ChessPanel = IsValid(ActiveBoard.ChessPanel) and ActiveBoard.ChessPanel or ActiveBoard:CreateChessPanel() --Autorefresh fix
					ActiveBoard.ChessPanel = ChessPanel
				end
				if ActiveBoard:GetChessState()==CHESS_WAGER then
					if not IsValid(WagerPanel) then
						WagerPanel = IsValid(ActiveBoard.WagerPanel) and ActiveBoard.WagerPanel or CreateWagerPanel( ActiveBoard ) --Autorefresh fix
						ActiveBoard.WagerPanel = WagerPanel
					end
				elseif IsValid( WagerPanel ) then
					WagerPanel:Remove()
				end
			end
			
			local ViewPos = ActiveBoard:GetPos() + Vector(0,0,30)
			if ply.Chess_Spectating then
				ply.Chess_ViewAngle = ply.Chess_ViewAngle or ActiveBoard:GetRight()*-20
				
				local ctime = RealTime()
				local delta = ctime - (ActiveBoard.LastCameraUpdate or ctime)
				ActiveBoard.LastCameraUpdate = ctime
				
				ply.Chess_ViewMomentum = ply.Chess_ViewMomentum or math.random(-100,100)
				
				
				ply.Chess_ViewAngle:Rotate( Angle(0,ply.Chess_ViewMomentum*delta,0) )
				ply.Chess_ViewMomentum = math.Approach( ply.Chess_ViewMomentum, 0, delta*150 )
				
				local IsMouseDown = input.IsMouseDown( MOUSE_LEFT )
				local MouseClick = IsMouseDown and (not ActiveBoard.WasMouseDown)
				
				local mouseX = gui.MouseX()
				
				if IsMouseDown and not MouseClick then
					ply.Chess_ViewMomentum = ((ActiveBoard.LastX or mouseX) - mouseX) * delta * 500
				end
				
				ActiveBoard.LastX = mouseX
				ActiveBoard.WasMouseDown = IsMouseDown
				
				ViewPos = ViewPos + ply.Chess_ViewAngle
			elseif ply==ActiveBoard:GetBlackPlayer() then
				ViewPos = ViewPos + ActiveBoard:GetRight() * (ActiveBoard.FlipView and (-20) or 20)
			else
				ViewPos = ViewPos + ActiveBoard:GetRight() * (ActiveBoard.FlipView and 20 or (-20))
			end
			
			local ViewAng = (ActiveBoard:GetPos()-ViewPos):Angle()
			if input.IsKeyDown( KEY_LALT ) then
				ViewAng = ang
				gui.EnableScreenClicker(false)
			else
				gui.EnableScreenClicker(true)
			end
			local view = {
				origin = ViewPos,
				angles = ViewAng,
				fov = fov,
				znear = nearz,
				zfar = farz,
				drawviewer = true,
			}
			
			IsInChess = true
			ScreenPos = ViewPos
			ScreenAng = ViewAng
			
			return view
		elseif IsInChess then --Exit
			gui.EnableScreenClicker(false)
			
			IsInChess = false
			ScreenPos = nil
			ScreenAng = nil
			ActiveBoard = nil
		else --Not in seat, and not just exited. Don't disable mouse here
			if IsValid( ChessPanel ) then ChessPanel:Remove() end
			if IsValid( WagerPanel ) then WagerPanel:Remove() end
			IsInChess = false
			ScreenPos = nil
			ScreenAng = nil
			ActiveBoard = nil
		end
	end
	hook.Add( "CalcView", "ChessBoardSeatCam", ChessSeatCam )
	
	function ENT:ResetHighlights()
		self.Highlight = {-1,-1}
		self.Selected = {-1,-1}
		self.Moves = {}
	end
	
	function ENT:GetTraceFilter()
		local tbl = player.GetAll()--{self}
		
		for GridLet,column in pairs( self.Pieces ) do
			for GridNum,square in pairs( column ) do
				if (IsValid( square.Ent )) then table.insert( tbl, square.Ent ) end
			end
		end
		
		return tbl
	end
	
	local ColHover,ColText,ColSel = Color(0,255,0,50),Color(50,50,50,200),Color(150,50,50,150)
	local ColBlack,ColWhite,ColMove = Color(0,0,0,120),Color(255,255,255,10),Color(50,50,150,150)
	function ENT:Draw()
		if self.IsInCheck then
			if not self.PlayedCheckSound then
				sound.Play( self.CheckSound, self:GetPos() )
				self.PlayedCheckSound = true
			end
		else
			self.PlayedCheckSound = nil
		end
		
		if IsValid(Chess_2DDermaPanel) then return end -- In 2D mode, skip 3D rendering
		local ctime = CurTime()
		
		-- Scale model
		if (self.LastReScaleTime or 0)+10<ctime then self:EnableMatrix("RenderMultiply", ChessScale) self.LastReScaleTime=ctime end
		
		-- Scale pieces
		if not self.PiecesEnts then
			self.PiecesEnts = {}
			for i=1,16 do
				self.PiecesEnts[i] = ClientsideModel( self.Models["WhitePawn"] )
				self.PiecesEnts[i]:SetNoDraw( true )
				self.PiecesEnts[i]:EnableMatrix( "RenderMultiply", ChessScale )
			end
		end
		
		-- Track framerate so we can skip during lag
		if FrameTime()>=0.33 and not self.SpectatingTable then --Less than 30 fps
			if self.FPSFailTimeout and self.FPSFailTimeout<ctime then
				self.FPSFailCount = 0
			end
			
			if (not self.FPSNextCheck) or self.FPSNextCheck<=ctime then
				self.FPSNextCheck = ctime+0.1
				self.FPSFailTimeout = ctime+2
				self.FPSFailCount = (self.FPSFailCount or 0)+1
				if self.FPSFailCount>=30 then
					self.LowFPSCheck = ctime+5
				end
			end
		end
		local InChessGame = LocalPlayer():GetNWBool("IsInChess",false)
		
		if self:GetPos()~=self.LastSquaresUpdatePos then
			self:RefreshSquares()
		end
		
		-- Draw pieces if in game, spectating, or high enough FPS
		if InChessGame or self.SpectatingTable or (not (self.LowFPSCheck and self.LowFPSCheck>ctime)) then
			local i=0
			for let,column in pairs( self.Pieces ) do
				for num,square in pairs( column ) do
					if not (square.Team and square.Class) then continue end
					i=(i or 0)+1
					local pos = self:GetSquarePos( let, num )
					
					if square.Moving and square.MoveStart then
						local delta = math.Clamp( (RealTime()-square.MoveStart)/self.MoveTime, 0,1 )
						if delta==1 or (not delta) then
							square.Moving = false
							sound.Play( self.MoveSound, pos )
						else
							local Height = (delta*6)>=3 and (6-(delta*6)) or (delta*6)
							pos = Vector(
								square.MoveFrom[1] + (pos[1]-square.MoveFrom[1])*delta,
								square.MoveFrom[2] + (pos[2]-square.MoveFrom[2])*delta,
								pos[3] + Height
							)
						end
					end
					
					if not IsValid( self.PiecesEnts[i] ) then
						self.PiecesEnts[i] = ClientsideModel( self.Models["WhitePawn"] )
						self.PiecesEnts[i]:SetNoDraw( true )
						self.PiecesEnts[i]:EnableMatrix( "RenderMultiply", ChessScale )
					end
					if self.PiecesEnts[i]:GetPos()~=pos then self.PiecesEnts[i]:SetPos( pos ) end
					if self.PiecesEnts[i]:GetModel()~=self.Models[ square.Team .. square.Class ] then
						self.PiecesEnts[i]:SetModel( self.Models[ square.Team .. square.Class ] )
					end
					self.PiecesEnts[i]:DrawModel()
					if self.DrawDouble and self.DrawDouble[ square.Class ] then
						self.PiecesEnts[i]:SetModel( self.Models[ "dama" ] ) --Prevents invisible pieces
						self.PiecesEnts[i]:SetModel( self.Models[ square.Team .. square.Class ] ) 
						self.PiecesEnts[i]:SetPos( pos + Vector(0,0,(self.PiecesEnts[i]:OBBMaxs()[3]-self.PiecesEnts[i]:OBBMins()[3])*0.1225) )
						self.PiecesEnts[i]:DrawModel()
					end
				end
			end
		end
		self:DrawModel()
		
		-- Remove highlights
		if not InChessGame then
			self.Highlight = nil
			self.Selected = nil
			self.Moves = nil
			
			self.FlipView = false
			
			if not cvars.Bool("chess_debug") then return end
		end
		
		self.Highlight = self.Highlight or {-1,-1}
		self.Selected = self.Selected or {-1,-1}
		self.Moves = self.Moves or {}
		local IsMouseDown = input.IsMouseDown( MOUSE_LEFT )
		local MouseClick = IsMouseDown and (not self.WasMouseDown)
		if ActiveBoard==self then
			self.Highlight[1]=(-1) self.Highlight[2]=(-1)
			local x,y = gui.MouseX(), gui.MouseY()
			
			local Target = ScreenPos + (gui.ScreenToVector( x, y )*10000)
			
			local tr = util.TraceLine( {start=ScreenPos, endpos=Target, filter=self:GetTraceFilter()} )
			
			local pos = self:WorldToLocal( tr.HitPos )
			local x,y = -1,-1
			if pos[2]>self.TopLeft[2] and pos[3]>self.TopLeft[3] then
				for i=0,8 do --Fall off the top
					if pos[2]<(self.TopLeft[2]+(self.RealW*i)) then break end
					y = i
				end
				for i=0,8 do
					if pos[3]<(self.TopLeft[3]+(self.RealH*i)) then break end
					x = i
				end
			end
			self.Highlight = {x,y}
			if self.Highlight[1]==8 then self.Highlight[1] = -1 end
			if self.Highlight[2]==8 then self.Highlight[2] = -1 end
			
			if MouseClick then
				if self.Selected and self:GetTableGrid( self.Moves, x, y ) then
					self:RequestMove( self.Selected[1], self.Selected[2], x, y )
					self:ResetHighlights()
				else
					self:ResetHighlights()
					self.Selected = {x,y}
					self.Moves = self:GetMove( NumToLetter[x+1], 8-y )
				end
			end
		else
			self.Selected[1]=(-1) self.Selected[2]=(-1)
			self.Highlight[1]=(-1) self.Highlight[2]=(-1)
			self.Moves = {}
			
			if not cvars.Bool("chess_debug") then return end
		end
		
		local pos = self:LocalToWorld( self.TopLeft )
		local ang = self:GetUp():Angle()
		
		cam.Start3D2D( pos, ang, 0.05 )
			for i=0,7 do
				for n=0,7 do
					local xpos = self.SquareW*i
					local ypos = self.SquareH*n
					
					local square = self:GetTableGrid( self.Pieces, i,n )
					if square and IsValid(square.Ent) then
						draw.RoundedBox( 0, xpos, ypos, self.SquareW, self.SquareH, square.Ent:GetWhite() and ColWhite or ColBlack )
					end
					if self.Highlight[1]==i and self.Highlight[2]==n then
						draw.RoundedBox( 0, xpos, ypos, self.SquareW, self.SquareH, ColHover )
					end
					if self:GetTableGrid( self.Moves, i, n ) then
						draw.RoundedBox( 0, xpos, ypos, self.SquareW, self.SquareH, ColMove )
					end
					if self.Selected[1]==i and self.Selected[2]==n then
						draw.RoundedBox( 0, xpos, ypos, self.SquareW, self.SquareH, ColSel )
					end
					if cvars.Bool("chess_debug") then
						draw.RoundedBox( 0, xpos, ypos, self.SquareW, self.SquareH, Color(255,255,255, 50) )
					end
					
					if cvars.Bool("chess_gridletters") then
						ypos = ypos + self.SquareH - 20
						local str = NumToLetter[i+1]..tostring(8-n)
						draw.SimpleText( str, "ChessTextSmall", xpos+6, ypos+1, PanelCol.Black )
						draw.SimpleText( str, "ChessTextSmall", xpos+5, ypos,   PanelCol.White )
					end
				end
			end
		cam.End3D2D()
		
		self.WasMouseDown = input.IsMouseDown( MOUSE_LEFT )
	end
	
	-- Start Spectating --
	function ENT:GetSpectateUse(ply,key)
		if ply~=LocalPlayer() then return end
		if key~=IN_USE then return end
		if input.IsMouseDown( MOUSE_LEFT ) then return end
		
		if CurTime()<(self.Spec_LastPoll or 0)+1 then return end
		self.Spec_LastPoll = CurTime()
		
		if ply==self:GetWhitePlayer() or ply==self:GetBlackPlayer() then
			EndSpec(self)
			return
		end
		
		local tr = util.TraceLine( {start=ply:EyePos(), endpos=ply:EyePos()+(ply:GetAimVector()*150), filter=ply} )
		if not (tr.Hit and IsValid(tr.Entity)) then EndSpec(self) return end
		if (tr.Entity~=self:GetTableEnt()) then EndSpec(self) return end
		
		if not self.SpectatingTable then
			chat.AddText( HatsChat and {"LINEICON", Icon=Material( "icon16/controller.png" )} or "", Color(150,255,150), "You are now spectating this game." )
		end
		self.SpectatingTable = true
		ply.Chess_Spectating = self
		
		local frame = vgui.Create( "DFrame" )
		frame:SetSize(300,135)
		frame:SetPos( (ScrW()/2)-100, ScrH()-150 )
		frame:SetTitle( "" )
		frame:ShowCloseButton( false )
		frame:SetDeleteOnClose( true )
		frame.Paint = function( s,w,h )
			if (not (IsValid(self) and self.SpectatingTable)) then
				s:Remove()
				gui.EnableScreenClicker( false )
				
				return
			end
			
			draw.RoundedBox( 8, 0, 0, w, h, PanelCol.Main )
		end
		frame:DockMargin( 0,0,0,0 )
		frame:DockPadding( 5,6,5,5 )
		-- frame:MakePopup()
		
		-- Turn Timer --
		local TimePnl = vgui.Create( "DPanel", frame )
		TimePnl:Dock( RIGHT )
		TimePnl:SetWide( 100 )
		TimePnl:DockMargin( 2,2,2,2 )
		TimePnl.Paint = function(s,w,h)
			if not IsValid(self) then return end
			
			draw.RoundedBox( 16, 0, 0, w, (h/2)-1, PanelCol.ToMove )
			draw.RoundedBox( 16, 0, (h/2)+1, w, (h/2)-1, PanelCol.ToMove )
			
			draw.SimpleText( string.FormattedTime( math.Round(self:GetWhiteTime() or 300,1), "%02i:%02i" ), "ChessText", w/2, h/4, PanelCol.White, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			draw.SimpleText( string.FormattedTime( math.Round(self:GetBlackTime() or 300,1), "%02i:%02i" ), "ChessText", w/2, (h/4)+(h/2), PanelCol.Black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		
		-- Layout --
		local JoinGamePanel = vgui.Create( "DPanel", frame )
		JoinGamePanel:SetSize( 100, 20 )
		JoinGamePanel:Dock( BOTTOM )
		JoinGamePanel.Paint = function() end
		local ButtonPanel = vgui.Create( "DPanel", frame )
		ButtonPanel:SetSize( 100, 20 )
		ButtonPanel:Dock( BOTTOM )
		ButtonPanel.Paint = function() end
		
		-- Move Info --
		local ToMove = vgui.Create( "DPanel", frame )
		ToMove:SetSize(200,80)
		ToMove:Dock( FILL )
		ToMove.Paint = function( s,w,h )
			draw.RoundedBox( 4, 0, 0, w, h, PanelCol.ToMove )
			draw.SimpleText( "To move", "ChessTextSmall", 5, 0, PanelCol.Text )
			local state = IsValid(self) and self:GetChessState()
			if not (IsValid( self ) and state) then
				draw.SimpleText( "[N/A]", "ChessTextSmall", w/2, h/2, PanelCol.Text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			else
				local str = (state==CHESS_WAGER and "Wagers") or (state==CHESS_INACTIVE and "Waiting") or ((state==CHESS_WHITEMOVE or state==CHESS_WHITEPROMO) and "White") or ((state==CHESS_BLACKMOVE or state==CHESS_BLACKPROMO) and "Black") or "N/A"
				local col = (str=="White" and PanelCol.White) or (str=="Black" and PanelCol.Black) or PanelCol.Text
				draw.SimpleText( str, "ChessTextLarge", w/2, h/2, col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			end
		end
		
		-- Toggle 2D
		local DermaMode = vgui.Create( "DButton", ButtonPanel)
		DermaMode:SetSize(94,20)
		DermaMode:Dock( LEFT )
		DermaMode:SetText( "Toggle 2D Mode" )
		DermaMode.DoClick = function( s )
			if IsValid(Chess_2DDermaPanel) then
				Chess_2DDermaPanel:Remove()
			else
				Chess_Open2DBoard( self )
			end
		end
		
		-- Leave Spectating --
		local StopSpec = vgui.Create( "DButton", ButtonPanel)
		StopSpec:SetSize(94,20)
		StopSpec:Dock( RIGHT )
		StopSpec:SetText( "Stop Spectating" )
		StopSpec.DoClick = function( s )
			EndSpec(self)
		end
		
		-- Join Game --
		local JoinWhite = vgui.Create( "DButton", JoinGamePanel)
		JoinWhite:SetSize(94,20)
		JoinWhite:Dock( LEFT )
		JoinWhite:SetText( "Play as White" )
		JoinWhite.DoClick = function( s )
			net.Start( "Chess RequestSeat" )
				net.WriteEntity( self )
				net.WriteBool( true )
			net.SendToServer()
		end
		local JoinBlack = vgui.Create( "DButton", JoinGamePanel)
		JoinBlack:SetSize(94,20)
		JoinBlack:Dock( RIGHT )
		JoinBlack:SetText( "Play as Black" )
		JoinBlack.DoClick = function( s )
			net.Start( "Chess RequestSeat" )
				net.WriteEntity( self )
				net.WriteBool( false )
			net.SendToServer()
		end
	end
	
	-- Render Stuff --
	local function CleanupPlayerDraw(ply)
		if ply.Chess_OldCol then
			ply:SetColor( ply.Chess_OldCol )
			ply.Chess_OldCol = nil
		end
		if ply.Chess_OldRenderMode then
			ply:SetRenderMode( ply.Chess_OldRenderMode )
			ply.Chess_OldRenderMode = nil
		end
	end
	function ENT:PrePlayerDraw(ply)
		if not IsValid(ply) then return end
		
		local client = LocalPlayer()
		if not client:GetNWBool( "IsInChess", false ) then return CleanupPlayerDraw(ply) end
		
		local board = ply:GetNWEntity( "ActiveChessBoard", nil )
		if board~=self then return end
		
		local c = ply:GetColor()
		ply.Chess_OldCol = ply.Chess_OldCol or c
		ply.Chess_OldRenderMode = ply.Chess_OldRenderMode or ply:GetRenderMode()
		
		ply:SetColor( Color(c.r, c.g, c.b, 50) )
		ply:SetRenderMode( RENDERMODE_TRANSALPHA )
	end
	
	-- net.Receive( "Chess DrawOffer", function()
		-- if IsValid( ChessPanel ) and IsValid( ChessPanel.OfferDraw ) then
			-- ChessPanel.OfferDraw:SetText( "Accept Draw Offer" )
		-- end
	-- end)
	net.Receive( "Chess GameOver", function() -- Now used for all messages
		local tbl = net.ReadTable()
		local emote = net.ReadString()
		if HatsChat then
			local Mat
			if emote and emote~="" then
				Mat = Material(emote)
			end
			if (not Mat) then
				Mat = Material( "icon16/controller.png" )
			end
			if not Mat:IsError() then
				table.insert(tbl, 1, {"LINEICON", Icon=Mat} )
			end
		end
		chat.AddText( unpack( tbl ) )
	end)
	net.Receive( "Chess PromotionSelection", function()
		local File = net.ReadInt( 5 )
		local Frame = vgui.Create( "DFrame" )
		Frame:SetSize( 100, 225 )
		Frame:SetPos( (ScrW()/2) - 50, (ScrH()/2)-112 )
		Frame:SetDraggable( false )
		Frame:ShowCloseButton( false )
		Frame:DockMargin( 5,5,5,5 )
		Frame:DockPadding( 5,5,5,5 )
		Frame:MakePopup()
		Frame:SetTitle( "" )
		Frame.Paint = function( s,w,h )
			draw.RoundedBox( 4, 0, 0, w, h, Color(0,0,0,150) )
		end
		
		local Queen = vgui.Create( "DButton", Frame )
		Queen.DoClick = function( s )
			net.Start( "Chess PromotionSelection" )
				net.WriteString( "Queen" )
				net.WriteInt( File, 5 )
			net.SendToServer()
			Frame:Remove()
		end
		Queen:SetText( "Queen" )
		Queen:Dock( TOP )
		Queen:SetSize( 90, 50 )
		Queen:DockMargin( 0,0,0,0 )
		
		local Rook = vgui.Create( "DButton", Frame )
		Rook.DoClick = function( s )
			net.Start( "Chess PromotionSelection" )
				net.WriteString( "Rook" )
				net.WriteInt( File, 5 )
			net.SendToServer()
			Frame:Remove()
		end
		Rook:SetText( "Rook" )
		Rook:Dock( TOP )
		Rook:SetSize( 90, 50 )
		Rook:DockMargin( 0,5,0,0 )
		
		local Bishop = vgui.Create( "DButton", Frame )
		Bishop.DoClick = function( s )
			net.Start( "Chess PromotionSelection" )
				net.WriteString( "Bishop" )
				net.WriteInt( File, 5 )
			net.SendToServer()
			Frame:Remove()
		end
		Bishop:SetText( "Bishop" )
		Bishop:Dock( TOP )
		Bishop:SetSize( 90, 50 )
		Bishop:DockMargin( 0,5,0,0 )
		
		local Knight = vgui.Create( "DButton", Frame )
		Knight.DoClick = function( s )
			net.Start( "Chess PromotionSelection" )
				net.WriteString( "Knight" )
				net.WriteInt( File, 5 )
			net.SendToServer()
			Frame:Remove()
		end
		Knight:SetText( "Knight" )
		Knight:Dock( TOP )
		Knight:SetSize( 90, 50 )
		Knight:DockMargin( 0,5,0,0 )
	end)
	
	net.Receive( "Chess Update", function()
		local board = net.ReadEntity()
		local pieces = net.ReadTable()
		
		local Move1 = net.ReadTable()
		local Move2 = net.ReadTable()
		
		if IsValid(board) and pieces then
			board.Pieces = pieces
			if Move1.To then
				if Move1.From then
					board.Pieces[Move1.To[1]][Move1.To[2]].Moving = true
					board.Pieces[Move1.To[1]][Move1.To[2]].MoveStart = RealTime()
					board.Pieces[Move1.To[1]][Move1.To[2]].MoveFrom = board:GetSquarePos( Move1.From[1],Move1.From[2] )
				else
					sound.Play( board.MoveSound, board:GetSquarePos( Move1.To[1],Move1.To[2]) or board:GetPos() )
				end
			end
			if Move2.To then
				if Move2.From then
					board.Pieces[Move2.To[1]][Move2.To[2]].Moving = true
					board.Pieces[Move2.To[1]][Move2.To[2]].MoveStart = RealTime()
					board.Pieces[Move2.To[1]][Move2.To[2]].MoveFrom = board:GetSquarePos( Move2.From[1],Move2.From[2] )
				else
					sound.Play( board.MoveSound, board:GetSquarePos( Move2.To[1],Move2.To[2]) or board:GetPos()  )
				end
			end
			
			if Move1.To and board.Pieces and board.Pieces[Move1.To[1]] and board.Pieces[Move1.To[1]][Move1.To[2]] then
				board.IsInCheck = board:CheckForCheck( board.Pieces, Move1.To and board.Pieces[Move1.To[1]][Move1.To[2]].Team~="White" )
			else
				board.IsInCheck = false
			end
		end
	end)
end
if SERVER then
	net.Receive( "Chess ClientRequestMove", function(len, ply)
		if not IsValid(ply) then return end
		if not (ply:GetNWBool( "IsInChess", false )) then return end
		
		local board = ply:GetNWEntity( "ActiveChessBoard", nil )
		if not IsValid(board) then return end
		
		local IsWhite = (ply==board:GetWhitePlayer())
		if (not IsWhite) and ply~=board:GetBlackPlayer() then return end
		
		if (not cvars.Bool( "chess_debug" )) and ((IsWhite and board:GetChessState()~=CHESS_WHITEMOVE) or ((not IsWhite) and board:GetChessState()~=CHESS_BLACKMOVE)) then return end
		
		local StartLet, StartNum =	NumToLetter[math.Clamp(net.ReadInt(5),1,8)], math.Clamp(net.ReadInt(5),1,8)
		local EndLet, EndNum =		NumToLetter[math.Clamp(net.ReadInt(5),1,8)], math.Clamp(net.ReadInt(5),1,8)
		
		local StartSquare = board:GetSquare( StartLet, StartNum )
		if not StartSquare then return end
		
		if (not cvars.Bool( "chess_debug" )) and ((IsWhite and board:SquareTeam(StartSquare)~="White") or ((not IsWhite) and board:SquareTeam(StartSquare)~="Black")) then return end
		
		if IsWhite and board:GetDrawOffer()==PLAYER_WHITE then
			board:SetDrawOffer( PLAYER_NONE )
		elseif (not IsWhite) and board:GetDrawOffer()==PLAYER_BLACK then
			board:SetDrawOffer( PLAYER_NONE )
		end
		
		board:DoMove( StartLet, StartNum, EndLet, EndNum )
	end)
	
	net.Receive( "Chess DrawOffer", function( len,ply )
		if not IsValid(ply) then return end
		if not (ply:GetNWBool( "IsInChess", false )) then return end
		
		local board = ply:GetNWEntity( "ActiveChessBoard", nil )
		if not IsValid(board) then return end
		
		local IsWhite = (ply==board:GetWhitePlayer())
		if (not IsWhite) and ply~=board:GetBlackPlayer() then return end
		
		if board:GetDrawOffer()==(IsWhite and PLAYER_BLACK or PLAYER_WHITE) then
			local WhitePly = board:GetPlayer( "White" )
			local BlackPly = board:GetPlayer( "Black" )
			
			local WhiteName = IsValid(WhitePly) and WhitePly:Nick() or "[Anonymous White]"
			local BlackName = IsValid(BlackPly) and BlackPly:Nick() or "[Anonymous Black]"
			board:EndGame()
			net.Start( "Chess GameOver" )
				net.WriteTable( {Color(255,255,255), WhiteName, Color(150,255,150), board:GetElo(WhitePly), " and ", Color(100,100,100), BlackName, Color(150,255,150), board:GetElo(BlackPly), " have agreed to draw."} )
				net.WriteString( "icon16/medal_silver_1.png" )
			net.Broadcast()
		else
			board:SetDrawOffer( IsWhite and PLAYER_WHITE or PLAYER_BLACK )
			-- board.DrawOffer = IsWhite and "White" or "Black"
			-- net.Start( "Chess DrawOffer" )
			-- net.Send( board:GetPlayer( IsWhite and "Black" or "White" ) )
		end
	end)
	net.Receive( "Chess ClientCallDraw", function( len,ply )
		if not IsValid(ply) then return end
		if not (ply:GetNWBool( "IsInChess", false )) then return end
		
		local board = ply:GetNWEntity( "ActiveChessBoard", nil )
		if not IsValid(board) then return end
		
		local IsWhite = (ply==board:GetWhitePlayer())
		if (not IsWhite) and ply~=board:GetBlackPlayer() then return end
		
		local DrawType = net.ReadUInt( 2 )
		if DrawType==CHESS_DRAW_50 then
			if not cvars.Bool("chess_limitmoves") then ply:ChatPrint( "This option is disabled on this server." ) return end
			if board:GetMoveCount()<50 then ply:ChatPrint( "This option is available when 50 moves pass without a pawn move or capture." ) return end
			local WhitePly = board:GetPlayer( "White" )
			local BlackPly = board:GetPlayer( "Black" )
			
			local WhiteName = IsValid(WhitePly) and WhitePly:Nick() or "[Anonymous White]"
			local BlackName = IsValid(BlackPly) and BlackPly:Nick() or "[Anonymous Black]"
			board:EndGame()
			net.Start( "Chess GameOver" )
				if IsWhite then
					net.WriteTable( {Color(150,255,150), "50 moves! ", Color(255,255,255), WhiteName, Color(150,255,150), board:GetElo(WhitePly), " has called a draw against ", Color(100,100,100), BlackName, Color(150,255,150), board:GetElo(BlackPly),"!"} )
				else
					net.WriteTable( {Color(150,255,150), "50 moves! ", Color(100,100,100), BlackName, Color(150,255,150), board:GetElo(BlackPly), " has called a draw against ", Color(255,255,255), WhiteName, Color(150,255,150), board:GetElo(WhitePly),"!"} )
				end
				net.WriteString( "icon16/medal_bronze_1.png" )
			net.Broadcast()
		elseif DrawType==CHESS_DRAW_3 then
			if not board:GetRepetition() then ply:ChatPrint( "This option is available when the board is in the same position three times." ) return end
			local WhitePly = board:GetPlayer( "White" )
			local BlackPly = board:GetPlayer( "Black" )
			
			local WhiteName = IsValid(WhitePly) and WhitePly:Nick() or "[Anonymous White]"
			local BlackName = IsValid(BlackPly) and BlackPly:Nick() or "[Anonymous Black]"
			board:EndGame()
			net.Start( "Chess GameOver" )
				if IsWhite then
					net.WriteTable( {Color(150,255,150), "Threefold repetition! ", Color(255,255,255), WhiteName, Color(150,255,150), board:GetElo(WhitePly), " has called a draw against ", Color(100,100,100), BlackName, Color(150,255,150), board:GetElo(BlackPly),"!"} )
				else
					net.WriteTable( {Color(150,255,150), "Threefold repetition! ", Color(100,100,100), BlackName, Color(150,255,150), board:GetElo(BlackPly), " has called a draw against ", Color(255,255,255), WhiteName, Color(150,255,150), board:GetElo(WhitePly),"!"} )
				end
				net.WriteString( "icon16/medal_bronze_1.png" )
			net.Broadcast()
		end
	end)
	net.Receive( "Chess ClientWager", function( len,ply )
		if not IsValid(ply) then return end
		if not (ply:GetNWBool( "IsInChess", false )) then return end
		
		local board = ply:GetNWEntity( "ActiveChessBoard", nil )
		if not IsValid(board) then return end
		
		local IsWhite = (ply==board:GetWhitePlayer())
		if (not IsWhite) and ply~=board:GetBlackPlayer() then return end
		
		if board:GetChessState()~=CHESS_WAGER then return end
		
		local wager = net.ReadUInt( 24 )
		if (not wager) or wager<0 then return end
		if board:GetPSWager() then
			if not ply:PS_HasPoints( wager ) then return end
		else
			if wager>(ply:getDarkRPVar( "money" ) or 0) then return end
		end
		
		if IsWhite then
			if board:GetBlackWager()>=0 and wager==board:GetBlackWager() then
				board:SetPlaying( true )
				board:SetChessState( board.StartState )
				
				local PlyName = ply:Nick() or "[N/A]"
				local OtherPly = board:GetPlayer( "Black" )
				local OtherName = IsValid(OtherPly) and OtherPly:Nick() or "[N/A]"
				net.Start( "Chess GameOver" )
					if IsWhite then
						net.WriteTable( {Color(255,255,255), PlyName, Color(150,255,150), board:GetElo(ply), " has challenged ", Color(100,100,100), OtherName, Color(150,255,150), board:GetElo(OtherPly)," to "..board:GameName().."!"} )
					else
						net.WriteTable( {Color(100,100,100), PlyName, Color(150,255,150), board:GetElo(ply), " has challenged ", Color(255,255,255), OtherName, Color(150,255,150), board:GetElo(OtherPly)," to "..board:GameName().."!"} )
					end
				net.Broadcast()
				
				board.WagerValue = wager
				
				if board:GetPSWager() then
					OtherPly:PS_TakePoints( board.WagerValue )
					ply:PS_TakePoints( board.WagerValue )
				else
					if OtherPly.addMoney then OtherPly:addMoney( -board.WagerValue ) else OtherPly:SetDarkRPVar( "money", (OtherPly:getDarkRPVar( "money" ) or 0) - board.WagerValue ) end
					if ply.addMoney then ply:addMoney( -board.WagerValue ) else ply:SetDarkRPVar( "money", (ply:getDarkRPVar( "money" ) or 0) - board.WagerValue ) end
				end
			else
				board:SetWhiteWager( wager )
			end
		else
			if board:GetWhiteWager()>=0 and wager==board:GetWhiteWager() then
				board:SetPlaying( true )
				board:SetChessState( board.StartState )
				
				local PlyName = ply:Nick() or "[N/A]"
				local OtherPly = board:GetPlayer( "White" )
				local OtherName = IsValid(OtherPly) and OtherPly:Nick() or "[N/A]"
				net.Start( "Chess GameOver" )
					if IsWhite then
						net.WriteTable( {Color(255,255,255), PlyName, Color(150,255,150), board:GetElo(ply), " has challenged ", Color(100,100,100), OtherName, Color(150,255,150), board:GetElo(OtherPly)," to "..board:GameName().."!"} )
					else
						net.WriteTable( {Color(100,100,100), PlyName, Color(150,255,150), board:GetElo(ply), " has challenged ", Color(255,255,255), OtherName, Color(150,255,150), board:GetElo(OtherPly)," to "..board:GameName().."!"} )
					end
				net.Broadcast()
				
				board.WagerValue = wager
				
				if board:GetPSWager() then
					OtherPly:PS_TakePoints( board.WagerValue )
					ply:PS_TakePoints( board.WagerValue )
				else
					if OtherPly.addMoney then OtherPly:addMoney( -board.WagerValue ) else OtherPly:SetDarkRPVar( "money", (OtherPly:getDarkRPVar( "money" ) or 0) - board.WagerValue ) end
					if ply.addMoney then ply:addMoney( -board.WagerValue ) else ply:SetDarkRPVar( "money", (ply:getDarkRPVar( "money" ) or 0) - board.WagerValue ) end
				end
			else
				board:SetBlackWager( wager )
			end
		end
	end)
	
	local PromotionClass = {["Queen"] = true, ["Bishop"] = true, ["Rook"] = true, ["Knight"] = true}
	net.Receive( "Chess PromotionSelection", function( len, ply )
		if not IsValid(ply) then return end
		if not (ply:GetNWBool( "IsInChess", false )) then return end
		
		local board = ply:GetNWEntity( "ActiveChessBoard", nil )
		if not IsValid(board) then return end
		
		local IsWhite = (ply==board:GetWhitePlayer())
		if (not IsWhite) and ply~=board:GetBlackPlayer() then return end
		if (IsWhite and board:GetChessState()~=CHESS_WHITEPROMO) or ((not IsWhite) and board:GetChessState()~=CHESS_BLACKPROMO) then return end
		
		local GridNum = (IsWhite and 8) or 1
		
		local Class = net.ReadString()
		local GridLetter = NumToLetter[net.ReadInt(5)]
		if not (GridLetter and Class) then return end
		if not PromotionClass[Class] then return end
		
		local square = board:GetSquare( GridLetter, GridNum )
		if not square then return end
		if (IsWhite and board:SquareTeam( square )~="White") or ((not IsWhite) and board:SquareTeam( square )~="Black") then return end
		if square.Class~="Pawn" then return end
		
		if IsValid(square.Ent) then square.Ent:SetGridNum(-1) square.Ent:Remove() end
		
		square.Class = Class
		
		board:Update( {To={GridLet,GridNum}} )
		
		local IsCheck = board:CheckForCheck( board.Pieces, square.Team~="White" )
		local Checkmate = board:IsCheckmate( square.Team~="White" )
		if IsCheck and Checkmate then
			local WhitePly = board:GetPlayer( "White" )
			local BlackPly = board:GetPlayer( "Black" )
			
			local WhiteName = IsValid(WhitePly) and WhitePly:Nick() or "[Anonymous White]"
			local BlackName = IsValid(BlackPly) and BlackPly:Nick() or "[Anonymous Black]"
			board:EndGame( square.Team )
			net.Start( "Chess GameOver" )
				if square.Team=="White" then
					net.WriteTable( {Color(255,255,255), WhiteName, Color(150,255,150), board:GetElo(WhitePly), " has checkmated ", Color(100,100,100), BlackName, Color(150,255,150), board:GetElo(BlackPly),"!"} )
				else
					net.WriteTable( {Color(100,100,100), BlackName, Color(150,255,150), board:GetElo(BlackPly), " has checkmated ", Color(255,255,255), WhiteName, Color(150,255,150), board:GetElo(WhitePly),"!"} )
				end
				net.WriteString( "icon16/medal_gold_2.png" )
			net.Broadcast()
		elseif Checkmate then
			local WhitePly = board:GetPlayer( "White" )
			local BlackPly = board:GetPlayer( "Black" )
			
			local WhiteName = IsValid(WhitePly) and WhitePly:Nick() or "[Anonymous White]"
			local BlackName = IsValid(BlackPly) and BlackPly:Nick() or "[Anonymous Black]"
			board:EndGame()
			net.Start( "Chess GameOver" )
				net.WriteTable( {Color(150,255,150), "Stalemate! ", Color(255,255,255), WhiteName, Color(150,255,150), board:GetElo(WhitePly), " drew with ", Color(100,100,100), BlackName, Color(150,255,150), board:GetElo(BlackPly),"!"} )
				net.WriteString( "icon16/medal_silver_1.png" )
			net.Broadcast()
		else
			board:SetChessState( IsWhite and CHESS_BLACKMOVE or CHESS_WHITEMOVE )
		end
	end)
	
	----------------
	-- Start Game --
	----------------
	
	local function GameStart( ply, board )
		local IsWhite = (ply==board:GetWhitePlayer())
		local OtherPly = IsWhite and board:GetBlackPlayer() or board:GetWhitePlayer()
		
		if (board:GetPlaying() or not IsValid(OtherPly)) and not cvars.Bool( "chess_debug" ) then return end
		
		board:ResetBoard()
		local IsDarkRP = gmod.GetGamemode().Name=="DarkRP"
		if (not cvars.Bool( "chess_debug" )) and IsDarkRP and cvars.Bool( "chess_darkrp_wager" ) and cvars.Bool( "chess_wagers" ) then
			board:SetPlaying( false )
			board:SetChessState( CHESS_WAGER )
			board:SetPSWager( false )
			
			if IsValid(OtherPly) and OtherPly:IsBot() then if IsWhite then board:SetBlackWager(0) else board:SetWhiteWager(0) end end
			if IsValid(ply) and ply:IsBot() then if IsWhite then board:SetWhiteWager(0) else board:SetBlackWager(0) end end
		elseif (not cvars.Bool( "chess_debug" )) and cvars.Bool( "chess_wagers" ) and PS and PS.Items then
			board:SetPlaying( false )
			board:SetPSWager( true )
			board:SetChessState( CHESS_WAGER )
			
			if IsValid(OtherPly) and OtherPly:IsBot() then if IsWhite then board:SetBlackWager(0) else board:SetWhiteWager(0) end end
			if IsValid(ply) and ply:IsBot() then if IsWhite then board:SetWhiteWager(0) else board:SetBlackWager(0) end end
		else
			board:SetPlaying( true )
			board:SetChessState( board.StartState )
			board:SetPSWager( false )
			board.WagerValue = nil
			
			local PlyName = ply:Nick() or "[N/A]"
			local OtherName = IsValid(OtherPly) and OtherPly:Nick() or "[N/A]"
			net.Start( "Chess GameOver" )
				if IsWhite then
					net.WriteTable( {Color(255,255,255), PlyName, Color(150,255,150), board:GetElo(ply), " has challenged ", Color(100,100,100), OtherName, Color(150,255,150), board:GetElo(OtherPly)," to "..board:GameName().."!"} )
				else
					net.WriteTable( {Color(100,100,100), PlyName, Color(150,255,150), board:GetElo(ply), " has challenged ", Color(255,255,255), OtherName, Color(150,255,150), board:GetElo(OtherPly)," to "..board:GameName().."!"} )
				end
			net.Broadcast()
		end
	end
	
	hook.Add( "PlayerEnteredVehicle", "Chess PlayerEnter BeginGame", function( ply, seat )
		if not seat:GetNWBool("IsChessSeat", false) then return end
		
		local board = seat:GetNWEntity( "ChessBoard" )
		if not IsValid(board) then return end
		
		ply.CanExitChess = false
		ply:GodEnable()
		
		ply:SetNWBool( "IsInChess", true )
		ply:SetNWEntity( "ActiveChessBoard", board )
		
		local IsWhite = (seat==board.WhiteSeat)
		if (not IsWhite) and seat~=board.BlackSeat then return end
		if IsWhite then board:SetWhitePlayer( ply ) else board:SetBlackPlayer( ply ) end
		
		GameStart( ply, board )
	end)
	net.Receive( "Chess RequestSeat", function(l,ply)
		if not IsValid(ply) then return end
		
		local board = net.ReadEntity()
		local IsWhite = net.ReadBool()
		if not (IsValid(board) and board.IsChessBoard) then return end
		
		if ply:GetPos():DistToSqr(board:GetPos()) > 20000 then
			ply:ChatPrint( "Too far away." )
			return
		end
		
		if ply:GetNWBool("IsInChess", false) then -- Already in a game?
			local onBoard = ply:GetNWEntity( "ActiveChessBoard", nil )
			if IsValid(onBoard) and (ply==onBoard:GetWhitePlayer() or ply==onBoard:GetBlackPlayer()) then
				ply:ChatPrint( "You are already on a table." )
				return
			end
		end
		
		local seat
		if IsWhite then
			if IsValid( board:GetWhitePlayer() ) then
				ply:ChatPrint( "This seat is taken." )
				return
			end
			
			seat = board.WhiteSeat
			board:SetWhitePlayer( ply )
			
			if board:GetBlackPlayer()==ply then board:SetBlackPlayer( NULL ) end
		else
			if IsValid( board:GetBlackPlayer() ) then
				ply:ChatPrint( "This seat is taken." )
				return
			end
			
			seat = board.BlackSeat
			board:SetBlackPlayer( ply )
			
			if board:GetWhitePlayer()==ply then board:SetWhitePlayer( NULL ) end
		end
		
		ply:SetNWBool( "IsInChess", true )
		ply:SetNWEntity( "ActiveChessBoard", board )
		
		if IsValid(seat) then
			local driver = seat:GetDriver()
			if IsValid(driver) and driver~=ply then
				driver.CanExitChess = true
				ply:ExitVehicle()
			end
			
			ply:EnterVehicle( seat )
		end
		
		GameStart( ply, board )
	end)
	
	--------------
	-- End Game --
	--------------
	
	hook.Add( "CanExitVehicle", "Chess CanExitVehicle Anti-minge", function( seat, ply )
		if not (IsValid(ply) and IsValid(seat)) then return end
		if not (ply:GetNWBool( "IsInChess", false )) then return end
		if not seat:GetNWBool("IsChessSeat", false) then return end
		
		local board = ply:GetNWEntity( "ActiveChessBoard", nil )
		if not IsValid(board) then return end
		
		if board:GetPlaying() and (not ply.CanExitChess) then return false end
	end)
	local function LeaveGame( ply, seat, board )
		local IsWhite = (ply==board:GetWhitePlayer())
		if (not IsWhite) and ply~=board:GetBlackPlayer() then return end
		
		ply:SetNWBool( "IsInChess", false )
		ply:SetNWEntity( "ActiveChessBoard", NULL )
		
		local OtherPly = IsWhite and board:GetBlackPlayer() or board:GetWhitePlayer()
		
		board:SetChessState( CHESS_INACTIVE )
		if not board:GetPlaying() then
			if IsWhite then
				board:SetWhitePlayer( NULL )
			else
				board:SetBlackPlayer( NULL )
			end
			return
		end
		board:SetPlaying( false )
		
		local PlyName = IsValid(ply) and ply:Nick() or "[N/A]"
		local OtherName = IsValid(OtherPly) and OtherPly:Nick() or (IsWhite and "[Anonymous Black]" or "[Anonymous White]")
		
		board:EndGame( IsWhite and "Black" or "White", true )
		net.Start( "Chess GameOver" )
			if IsWhite then
				net.WriteTable( {Color(255,255,255), PlyName, Color(150,255,150), board:GetElo(ply), " has surrendered to ", Color(100,100,100), OtherName, Color(150,255,150), board:GetElo(OtherPly),"!"} )
			else
				net.WriteTable( {Color(100,100,100), PlyName, Color(150,255,150), board:GetElo(ply), " has surrendered to ", Color(255,255,255), OtherName, Color(150,255,150), board:GetElo(OtherPly),"!"} )
			end
			net.WriteString( "icon16/medal_bronze_3.png" )
		net.Broadcast()
		
		board:SetChessState( CHESS_INACTIVE )
		board:SetPlaying( false )
		
		if IsValid(OtherPly) then
			OtherPly:ExitVehicle()
			
			OtherPly:SetNWBool( "IsInChess", false )
			OtherPly:SetNWEntity( "ActiveChessBoard", NULL )
		end
	end
	hook.Add( "PlayerLeaveVehicle", "Chess PlayerLeave ResignGame", function( ply, seat )
		if not (IsValid(ply) and IsValid(seat)) then return end
		if not seat:GetNWBool("IsChessSeat", false) then return end
		
		ply:SetPos( seat:GetPos() - (seat:GetForward()*10) )
		--ply:SetAngles( seat:GetAngles() ) --Doesn't work?
		ply:GodDisable()
		
		ply:SetNWBool( "IsInChess", false )
		ply:SetNWEntity( "ActiveChessBoard", nil )
		
		local board = seat:GetNWEntity( "ChessBoard" )
		if not IsValid(board) then return end
		
		if board:GetPlaying() and (not ply.CanExitChess) then
			timer.Simple(0, function() if IsValid(ply) and IsValid(seat) then ply:EnterVehicle(seat) end end)
			return
		end
		
		LeaveGame( ply, seat, board )
	end)
	net.Receive( "Chess ClientResign", function( len,ply )
		if not IsValid(ply) then return end
		if not ply:GetNWBool( "IsInChess", false ) then return end
		
		local board = ply:GetNWEntity( "ActiveChessBoard" )
		if not IsValid(board) then return end
		
		LeaveGame( ply, seat, board )
		
		local seat = ply:GetVehicle()
		if IsValid(seat) then
			ply.CanExitChess = true
			ply:ExitVehicle()
		end
	end)
	
	hook.Add( "PlayerDisconnected", "Chess PlayerDisconnect ResignGame", function( ply )
		if not (IsValid(ply)) then return end
		
		-- local seat = ply:GetVehicle()
		-- if not (IsValid(seat) and seat:GetNWBool("IsChessSeat", false)) then return end
		if not ply:GetNWBool( "IsInChess", false ) then return end
		local board = ply:GetNWEntity( "ActiveChessBoard" )
		
		ply:SetNWBool( "IsInChess", false )
		ply:SetNWEntity( "ActiveChessBoard", nil )
		
		if not IsValid(board) then return end
		
		local IsWhite = (ply==board:GetWhitePlayer())
		if (not IsWhite) and ply~=board:GetBlackPlayer() then return end
		if IsWhite then board:SetWhitePlayer( NULL ) else board:SetBlackPlayer( NULL ) end
		
		board:SetChessState( CHESS_INACTIVE )
		if not board:GetPlaying() then return end
		board:SetPlaying( false )
		
		local OtherPly 
		if IsWhite then OtherPly = board:GetBlackPlayer() else OtherPly = board:GetWhitePlayer() end
		
		local PlyName = IsValid(ply) and ply:Nick() or "[N/A]"
		local OtherName = IsValid(OtherPly) and OtherPly:Nick() or (IsWhite and "[Anonymous Black]" or "[Anonymous White]")
		
		board:EndGame( IsWhite and "Black" or "White", true )
		net.Start( "Chess GameOver" )
			if IsWhite then
				net.WriteTable( {Color(255,255,255), PlyName, Color(150,255,150), board:GetElo(ply), " rage quit against ", Color(100,100,100), OtherName, Color(150,255,150), board:GetElo(OtherPly),"!"} )
			else
				net.WriteTable( {Color(100,100,100), PlyName, Color(150,255,150), board:GetElo(ply), " rage quit against ", Color(255,255,255), OtherName, Color(150,255,150), board:GetElo(OtherPly),"!"} )
			end
			net.WriteString( "icon16/medal_gold_2.png" )
		net.Broadcast()
		
		board:SetChessState( CHESS_INACTIVE )
		board:SetPlaying( false )
		
		if IsValid( OtherPly ) then OtherPly:ExitVehicle() end
	end)
	hook.Add( "CanPlayerSuicide", "Chess PlayerSuicide Prevention", function( ply )
		if not (IsValid(ply)) then return end
		
		if not ply:GetNWBool( "IsInChess", false ) then return end
		
		return false
	end)
	
	
	-------------------------------
	-- Save/Load Board Positions --
	-------------------------------
	
	local SaveSystem = {}
	local SaveFile = game.GetMap()
	SaveSystem.Load = function( self )
		if not SaveFile then SaveFile=game.GetMap() end
		if not file.IsDir( "chessboard", "DATA" ) then file.CreateDir( "chessboard", "DATA" ) end
		local data = file.Read( "chessboard/"..SaveFile..".txt", "DATA" )
		
		if data then
			local tbl = util.JSONToTable(data) or {}
			for _,v in pairs(tbl) do
				local ent = ents.Create( v.class )
				if IsValid(ent) then
					ent.SavePos = SpawnPos
					ent:SetPos( v.pos )
					
					if v.ang then ent:SetAngles( v.ang ) end
					
					if v.skipWhite then
						ent.SkipWhiteChair = true
					else
						ent.WhiteChairPos = v.posWhite
						ent.WhiteChairAng = v.angWhite
					end
					if v.skipBlack then
						ent.SkipBlackChair = true
					else
						ent.BlackChairPos = v.posBlack
						ent.BlackChairAng = v.angBlack
					end
					
					ent:Spawn()
				end
			end
		end
		
		if file.Exists( "chessboard/savedata.txt", "DATA" ) then --Read old system
			local data = file.Read( "chessboard/savedata.txt", "DATA" )
			
			if data then
				local tbl = util.JSONToTable(data) or {}
				for _,v in pairs(tbl) do
					local ent = ents.Create( v.class )
					if IsValid(ent) then ent.SavePos = SpawnPos ent:SetPos( v.pos ) ent:Spawn() end
				end
			end
			
			file.Delete( "chessboard/savedata.txt", "DATA" )
			self:Save()
		end
		return true
	end
	
	local function GetSaveData(board)
		local ang = board:GetAngles()
		ang:RotateAroundAxis(board:GetRight(),-90)
		
		local pos
		if (board.BoardHeight and board.TableOffset) then
			pos = board:GetPos() - board.BoardHeight - board.TableOffset
		elseif (board.SavePos) then
			pos = board.SavePos
		else
			pos = board:GetPos()
		end
		
		local data = {
			class=board:GetClass(),
			pos = pos,
			ang = ang
		}
		if IsValid(board.WhiteSeat) then
			data.posWhite = board.WhiteSeat:GetPos()
			data.angWhite = board.WhiteSeat:GetAngles()
		else
			data.skipWhite = true
		end
		if IsValid(board.BlackSeat) then
			data.posBlack = board.BlackSeat:GetPos()
			data.angBlack = board.BlackSeat:GetAngles()
		else
			data.skipBlack = true
		end
		
		return data
	end
	SaveSystem.Save = function( self )
		if not SaveFile then SaveFile=game.GetMap() end
		
		local SaveTbl = {}
		local Ents = ents.FindByClass( "ent_chess_board" )
		for _,v in pairs( Ents ) do
			if IsValid(v) then
				table.insert(SaveTbl, GetSaveData(v))
			end
		end
		local Ents = ents.FindByClass( "ent_draughts_board" )
		for _,v in pairs( Ents ) do
			if IsValid(v) then
				table.insert(SaveTbl, GetSaveData(v))
			end
		end
		
		if not file.IsDir( "chessboard", "DATA" ) then file.CreateDir( "chessboard", "DATA" ) end
		file.Write( "chessboard/"..SaveFile..".txt", util.TableToJSON(SaveTbl) )
		return true
	end
	hook.Add( "InitPostEntity", "Chess InitPostEntity LoadBoards", function() SaveSystem:Load() end)
	hook.Add( "PostCleanupMap", "Chess PostCleanup LoadBoards", function() SaveSystem:Load() end)
	
	local SaveCommands = {
		["/chesssave"] = true, ["/savechess"] = true, ["!chesssave"] = true, ["!savechess"] = true,
		["/draughtssave"] = true, ["/savedraughts"] = true, ["!draughtssave"] = true, ["!savedraughts"] = true,
		["/checkerssave"] = true, ["/savecheckers"] = true, ["!checkerssave"] = true, ["!savecheckers"] = true,
	}
	hook.Add( "PlayerSay", "Chess PlayerSay SaveBoards", function( ply, str, tm )
		if not IsValid(ply) then return end
		if not ply:IsSuperAdmin() then return end
		
		if SaveCommands[str:lower()] then
			local saved = SaveSystem:Save()
			ply:ChatPrint( saved and "Saved game board positions" or "Save failed!" )
		end
	end)
	local function ChessSave( ply, c, a )
		if IsValid(ply) and not ply:IsSuperAdmin() then ply:ChatPrint( "You can't do this" ) end
		
		local saved = SaveSystem:Save()
		if IsValid(ply) then
			ply:ChatPrint( saved and "Saved game board positions" or "Save failed!" )
		else
			print( saved and "Saved game board positions" or "Save failed!" )
		end
	end
	concommand.Add( "chess_save", ChessSave ) concommand.Add( "draughts_save", ChessSave ) concommand.Add( "checkers_save", ChessSave )
end

hook.Add( "GravGunPickupAllowed", "Chess PreventGrav", function( ply, ent )
	if IsValid(ent) and ent.IsChessEntity then return false end
end)
hook.Add( "canPocket", "Chess DarkRP PreventPocket", function( ply, ent )
	if IsValid(ent) and ent.IsChessEntity then return false,"Please do not interfere with Chess." end
end)


-- Override Movement --

local function CancelMovement( ply, mvData )
	if (not IsValid(ply)) or not (ply:GetNWBool("IsInChess", false) or IsValid(ply.Chess_Spectating)) then return end -- Not in chess
	
	local board = ply:GetNWEntity( "ActiveChessBoard", nil )
	if (not IsValid(board)) or (ply~=board:GetWhitePlayer() and ply~=board:GetBlackPlayer()) then -- Invalid board
		if SERVER or (not IsValid(ply.Chess_Spectating)) then -- Not a client in spectate mode
			return
		end
	end
	
	local zero = Vector()
	mvData:SetButtons( 0 )
	mvData:SetVelocity( zero )
	mvData:SetMaxSpeed( 0 )
	mvData:SetMaxClientSpeed( 0 )
	mvData:SetForwardSpeed( 0 )
	mvData:SetSideSpeed( 0 )
	
	return mvData
end
hook.Add( "SetupMove",  "Chess_CancelMovement", CancelMovement )
hook.Add( "Move",       "Chess_CancelMovement", CancelMovement )
hook.Add( "FinishMove", "Chess_CancelMovement", CancelMovement )

if CLIENT then
	-- Prevent movement while spectating
	-- This is clientside only so easily overridden,
	-- but that's not a big deal in this case
	local function CancelCommands( ply, cUserCmd )
		if not (IsValid(ply) and IsValid(ply.Chess_Spectating)) then return end
		
		-- local zero = Vector()
		cUserCmd:ClearMovement()
	end
	hook.Add( "CreateMove", "Chess_CancelMovement", function(cUserCmd) CancelCommands(LocalPlayer(), cUserCmd) end)
end

--PATH addons/[misc] szachy/lua/entities/ent_draughts_board.lua:
return gluapack()()
--PATH lua/entities/ent_realistic_hook.lua:
AddCSLuaFile()

ENT.Type = "anim"

ENT.Spawnable = false
ENT.AdminSpawnable = true

ENT.Model = "models/props_c17/TrapPropeller_Lever.mdl"
ENT.HitSound = Sound( "physics/metal/metal_barrel_impact_hard7.wav" )

local ServerConvarFlags = {FCVAR_ARCHIVE, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE}
CreateConVar( "hatshook_hookplayers", "1", ServerConvarFlags, "Allows the Grappling Hook to grab players" )
CreateConVar( "hatshook_physics", "1", ServerConvarFlags, "Grappling hook is launched as a projectile" )
CreateConVar( "hatshook_speed", "1000", ServerConvarFlags, "Launch velocity of the grappling hook (Max range for non-physics hooks)" )

CreateConVar( "hatshook_breakpower", "3", ServerConvarFlags, "Strength of each breakout attempt" )
CreateConVar( "hatshook_breakregen", "1", ServerConvarFlags, "Breakout depletion rate" )

CreateConVar( "hatshook_ammo", "-1", ServerConvarFlags, "Number of uses each grappling hook has. -1 is infinite." )

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "HasHit" )
	
	self:NetworkVar( "Entity", 0, "Wep" )
	self:NetworkVar( "Entity", 1, "TargetEnt" )
	
	self:NetworkVar( "Int", 0, "Dist" )
	self:NetworkVar( "Int", 1, "Durability" )
	
	self:NetworkVar( "Int", 2, "FollowBone" )
	self:NetworkVar( "Vector", 1, "FollowOffset" )
	self:NetworkVar( "Angle", 0, "FollowAngle" )
	
	self:NetworkVar( "Vector", 0, "ShootDir" )
end

function ENT:Initialize()
	self:SetModel( self.Model )
	
	--self:SetMoveType( MOVETYPE_VPHYSICS )
	self:PhysicsInit( SOLID_VPHYSICS )
	if not cvars.Bool( "hatshook_hookplayers" ) then
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
	end
	
	self:PhysWake()
	local phys = self:GetPhysicsObject()
	if IsValid(phys) then
		if SERVER then
			self:SetShootDir( self.Owner:GetAimVector() * cvars.Number( "hatshook_speed" ) )
		end
		phys:SetVelocity( self:GetShootDir() )
	end
	
	self.HookHealth = 100
	
	hook.Add( "AllowPlayerPickup", self, self.AllowPlayerPickup )
	if CLIENT then hook.Add( "HUDPaint", self, self.HUDPaint ) end
	
	if SERVER then
		local timerName = tostring(self).." Hook Durability Restore"
		timer.Create( timerName, 0.1, 0, function()
			if not IsValid(self) then timer.Destroy(timerName) return end
			self:SetDurability( math.Approach(self:GetDurability(), 0, cvars.Number("hatshook_breakregen") ) )
		end)
		hook.Add( "KeyPress", self, self.PlayerKeyPress )
	end
end

function ENT:Destroyed( NoCooldown )
	if CLIENT then return end
	
	local ef = EffectData()
	ef:SetStart( self:GetPos() )
	ef:SetOrigin( self:GetPos() )
	ef:SetScale( 1 )
	ef:SetRadius( 1 )
	ef:SetMagnitude( 1 )
	ef:SetNormal( self:GetRight() )
	
	util.Effect( "Sparks", ef, true, true )
	sound.Play( self.HitSound, self:GetPos(), 75, 100 )
	
	if IsValid( self:GetWep() ) and self:GetWep().SetCooldown then
		self:GetWep():SetCooldown( NoCooldown and self:GetWep():GetCooldown()+10 or 100 )
	end
	
	self:Remove()
end
function ENT:OnTakeDamage( DmgInfo )
	self.HookHealth = (self.HookHealth or 0) - DmgInfo:GetDamage()
	if self.HookHealth<=0 then
		self:Destroyed()
	end
end

function ENT:DoParent( target, obj )
	if IsValid( target ) and target~=self and target~=self.Owner and (not (target:IsWeapon() and target:GetOwner()==self.Owner)) then
		self:SetParent( target )
		
		if target:GetClass():sub(1,5)~="func_" then
			for i=0,target:GetPhysicsObjectCount()-1 do
				local p = target:GetPhysicsObjectNum( i )
				if p==obj then
					--self:SetParentPhysNum( target:TranslatePhysBoneToBone(i) )
					--self:FollowBone( target, target:TranslatePhysBoneToBone(i) )
					--print(i,target:TranslatePhysBoneToBone(i))
					
					self:SetFollowBone( target:TranslatePhysBoneToBone(i) )
					local pos, ang = target:GetBonePosition( self:GetFollowBone() )
					if pos and ang then
						self:SetFollowOffset( self:GetPos() - pos )
						self:SetFollowAngle( self:GetAngles()-ang )
					end
					break
				end
			end
		end
		
		self:SetTargetEnt( target )
	end
end

local NoHitEnts = { ["func_breakable_surf"] = true, ["ent_realistic_hook"] = true, } // This is stuff we shouldn't attach to, glitches out
function ENT:PhysicsCollide( data, phys )
	if self:GetHasHit() then return end // Already hit
	
	if IsValid(data.HitEntity) and NoHitEnts[data.HitEntity:GetClass()] then // Something that'll bug out, eg a window
		self:Destroyed( true )
		return
	end
	if not IsValid(self:GetWep()) and IsValid(self:GetWep().Owner) and self:GetWep().Owner:IsPlayer() then self:Destroyed( true ) return end
	
	local tr = util.TraceLine( {start = (data.HitPos - (data.HitNormal*10)), endpos = (data.HitPos+data.HitNormal*10), filter = self} )
	if tr.HitSky then return end
	
	timer.Simple(0,function()
		if not IsValid(self) then return end
		if not (IsValid(self:GetWep()) and IsValid(self:GetWep().Owner)) then self:Destroyed( true ) return end
		
		self:SetCollisionGroup( COLLISION_GROUP_WORLD )
		
		self:SetPos( data.HitPos )
		local ang = data.HitNormal:Angle()
		ang:RotateAroundAxis( ang:Up(), 90 )
		self:SetAngles( ang )
		self:SetMoveType( MOVETYPE_NONE )
		
		self:SetDist( data.HitPos:Distance( self:GetWep().Owner:GetShootPos() ) )
		self:DoParent( data.HitEntity, data.HitObject )
	end)
	
	self:SetDist( data.HitPos:Distance( self:GetWep().Owner:GetShootPos() ) )
	
	local ef = EffectData()
	ef:SetOrigin( data.HitPos )
	ef:SetNormal( data.HitNormal )
	ef:SetStart( data.HitPos )
	ef:SetMagnitude( 2 )
	ef:SetScale( 1 )
	ef:SetRadius( 1 )
	
	util.Effect( "Sparks", ef, true, true )
	sound.Play( self.HitSound, data.HitPos, 75, 100 )
	
	self:SetHasHit( true )
end

-- Misc hooks --
----------------
function ENT:Think()
	if SERVER and (not (IsValid(self:GetWep()) and self:GetWep()==self.Owner:GetActiveWeapon()) ) then self:Remove() return end
	
	local phys = self:GetPhysicsObject()
	if IsValid(phys) and self:GetHasHit() then // This stuff doesn't work in the collision hook
		phys:EnableMotion( false )
		phys:SetPos( self:GetPos() )
		phys:SetAngles( self:GetAngles() )
	end
end

function ENT:AllowPlayerPickup( ply, ent )
	if ply==self.Owner then return false end // They're currently hooked to something, if we let them pick it up they can exploit and fly
end

-- 3D Drawing --
----------------
local HookCable = Material( "cable/cable2" )
function ENT:Draw()
	if IsValid( self:GetTargetEnt() ) then
		local bpos, bang = self:GetTargetEnt():GetBonePosition( self:GetFollowBone() )
		local npos, nang = self:GetFollowOffset(), self:GetFollowAngle()
		if npos and nang and bpos and bang then
			npos:Rotate( nang )
			nang = nang+bang
			
			npos = bpos+npos
			
			self:SetPos( npos )
			self:SetAngles( nang )
		end
	end
	
	self:DrawModel()
	
	// We'll draw the beam from both the weapon and the hook, less likely to move out of rendering when it should be visible
	if not IsValid( self:GetWep() ) then return end
	if self.Owner==LocalPlayer() and not hook.Call("ShouldDrawLocalPlayer", GAMEMODE, self.Owner) then return end // Badly aligned, the rope will always be visible from the ViewModel draw anyway
	
	if IsValid(self.Owner) then
		local att = self:GetWep():GetAttachment( 1 )
		
		render.SetMaterial( HookCable )
		if att and att.Pos then
			render.DrawBeam( self:GetPos(), att.Pos, 1, 0, 2, Color(255,255,255,255) )
		else
			render.DrawBeam( self:GetPos(), self:GetWep():GetPos(), 1, 0, 2, Color(255,255,255,255) )
		end
	end
end

-- HUD stuff --
---------------
local ChargeBarCol = { White = Color(255,255,255), DefCol1 = Color(255,50,50), DefCol2 = Color(50,255,50) }
local Gradient = Material( "gui/gradient" )
local function DrawChargeBar( xpos, ypos, width, height, charge, col1, col2 )
	draw.NoTexture()
	
	surface.SetDrawColor( ChargeBarCol.White )
	surface.DrawOutlinedRect( xpos, ypos, width, height )
	
	charge = math.Clamp( charge or 50, 0, 100)
	barLen = (width-2)*(charge/100)
	render.SetScissorRect( xpos+1, ypos+1, xpos+1+barLen, (ypos+height)-1, true )
		surface.SetDrawColor( col2 or ChargeBarCol.DefCol2 )
		surface.DrawRect( xpos+1, ypos+1, width-1, height-2 )
		
		surface.SetMaterial( Gradient )
		surface.SetDrawColor( col1 or ChargeBarCol.DefCol1 )
		surface.DrawTexturedRect( xpos+1, ypos+1, width-1, height-2 )
	render.SetScissorRect( xpos+1, ypos+1, xpos+1+barLen, (ypos+height)-1, false )
	
	draw.NoTexture()
end
local function ShadowText( txt, x, y, col )
	draw.DrawText( txt, "Default", x+1, y+1, Color(0,0,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
	draw.DrawText( txt, "Default", x, y, col or Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
end
function ENT:HUDPaint()
	if not (LocalPlayer()==self:GetTargetEnt()) then return end
	
	ShadowText( "Rope length: "..tostring(self:GetDist()), ScrW()/2, ScrH()/2-60 )
	ShadowText( "You have been hooked!", ScrW()/2, ScrH()/2-75, Color(255,100,100) )
	ShadowText( (input.LookupBinding("+use") or "[USE]"):upper() .. " - Break free", ScrW()/2, ScrH()/2-40 )
	DrawChargeBar( (ScrW()/2)-70, (ScrH()/2)-20, 140, 15, self:GetDurability() )
end

if SERVER then
	function ENT:PlayerKeyPress( ply, key )
		if (ply~=self:GetTargetEnt() or key~=IN_USE) then return end
		
		self:SetDurability( self:GetDurability()+cvars.Number("hatshook_breakpower") )
		if self:GetDurability()>=100 then self:Destroyed() end
	end
end

--PATH lua/entities/hmp_concussionmissile.lua:
return gluapack()()
--PATH lua/entities/kingpommes_swv_patroltransport_imp.lua:

util.PrecacheModel( "models/KingPommes/starwars/patrol_transport/main.mdl" )
if (!util.IsValidModel( "models/KingPommes/starwars/patrol_transport/main.mdl" )) then return end

ENT.RenderGroup = RENDERGROUP_OPAQUE
ENT.Base = "fighter_base"
ENT.Type = "vehicle"
 
ENT.PrintName = "Imperial Patrol Transport"
ENT.Author = "KingPommes, Mattzi"
ENT.Category = "Star Wars Vehicles: Empire"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false
ENT.AdminSpawnable = false
 
ENT.EntModel = "models/KingPommes/starwars/patrol_transport/main.mdl"
ENT.Vehicle = "IMP_PATROL"
ENT.StartHealth = 4500
ENT.Allegiance = "Empire"
list.Set("SWVehicles", ENT.PrintName, ENT)
if SERVER then
   
    ENT.FireSound = Sound("weapons/tie_shoot.wav")
   
    AddCSLuaFile()
    function ENT:SpawnFunction(pl, tr)
        local e = ents.Create("kingpommes_swv_patroltransport_imp")
        e:SetPos(tr.HitPos + Vector(0,0,2))
        e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0))
        e:Spawn()
        e:Activate()
        e:PrecacheGibs()
        return e
    end
 
    function ENT:SpawnLauncher()
        local pos = self:GetPos()
        local ang1 = self:GetAngles()
        local ang2 = self:GetAngles() + Angle(90, 0, 0)
 
        local e = ents.Create("info_target")
        e:SetPos(pos)
        e:SetAngles(ang1)
        e:SetParent(self)
        e:Spawn()
        e:Fire("AddOutput", "targetname target", 0)
        self.Target = e
 
        local e1 = ents.Create("npc_launcher")
        e1:SetPos(pos)
        e1:SetAngles(ang2)
        e1:SetParent(self)
        e1:Spawn()
        e1:Activate()
        e1:Fire("SetEnemyEntity", "target")
        e1:Fire("AddOutput", "damage 1000")
        e1:Fire("AddOutput", "DamageRadius 300")
        --e1:Fire("AddOutput", "FlySound weapons/rpg/rocket1.wav")
        e1:Fire("AddOutput", "Gravity 0")
        e1:Fire("AddOutput", "HomingDelay 0")
        e1:Fire("AddOutput", "HomingDuration 0")
        e1:Fire("AddOutput", "HomingStrength 0")
        e1:Fire("AddOutput", "LaunchSmoke 1")
        e1:Fire("AddOutput", "SmokeTrail 1")
        e1:Fire("AddOutput", "LaunchSound weapons/stinger_fire1.wav")
        e1:Fire("AddOutput", "LaunchSpeed 5000")
        e1:Fire("AddOutput", "MaxRange 99999")
        e1:Fire("AddOutput", "MinRange 100")
        e1:Fire("AddOutput", "MissileModel models/kingpommes/starwars/tie/missile.mdl")
        e1:Fire("AddOutput", "SpinMagnitude 0")
        e1:Fire("AddOutput", "SpinSpeed 0")
        self.Launcher = e1
    end
   
    function ENT:SpawnTurrets()
        self.Turrets = {}
        for k,v in pairs(self.WeaponLocations) do
            local e = ents.Create("base_anim")
            e:SetModel("models/KingPommes/starwars/patrol_transport/turret.mdl")
            e:SetPos(v)
            e:SetParent(self)
            e:Spawn()
            e:Activate()
            self.Turrets[k] = e
        end
    end
 
    function ENT:SpawnDoors()
        local e = ents.Create("prop_dynamic")
        e:SetModel("models/KingPommes/starwars/patrol_transport/doors.mdl")
        e:SetPos(self:GetPos())
        e:SetAngles(self:GetAngles())
        e:SetParent(self)
        e:PhysicsInit(SOLID_VPHYSICS)
        e:Spawn()
        e:Activate()
        self.Doors = e
    end
   
    function ENT:SpawnSeats()
        self.Seats = {}
        for k,v in pairs(self.SeatPos) do
            local e = ents.Create(self.SeatClass or "prop_vehicle_prisoner_pod")
            e:SetPos(v[1] or self:GetPos())
            e:SetAngles(v[2] or self:GetAngles())
            e:SetParent(self)
            e:SetModel("models/nova/airboat_seat.mdl")
            e:SetRenderMode(RENDERMODE_TRANSALPHA)
            e:SetColor(Color(255,255,255,0))
            e:Spawn()
            e:Activate()
            e:SetUseType(USE_OFF)
            e:GetPhysicsObject():EnableMotion(false)
            e:GetPhysicsObject():EnableCollisions(false)
            e:SetCollisionGroup(COLLISION_GROUP_WEAPON)
            e._ExitPos = v[3] or Vector(0,0,0)
            e._ExitAngles = v[4] or Angle(0,180,0)
            if (k == "Gunner") then
                e:SetVehicleClass("phx_seat2")
                e:SetName("Gunner")
            else
                e:SetVehicleClass("pommes_patrol_seat")
                e:SetName("Passenger")
            end
            self.Seats[k] = e
        end
    end
   
    function ENT:Initialize()
        self.FireGroup = {"Laser1","Laser2"}
        self:SetModel(self.EntModel);
 
        self.WeaponLocations = {
            self:GetAttachment(self:LookupAttachment("turret_L")).Pos,
            self:GetAttachment(self:LookupAttachment("turret_R")).Pos,
        }
 
        self.Flashlights = {
        {Vector(174,0,15),Angle(90,0,0)},
        }
 
        self.HasFlashlight = false;
        self.FlashlightDistance = 4000;
       
        self:SetNWInt("Health",self.StartHealth)
       
        self.CanShoot = false
        self.Cooldown = 2
        self.Overheat = 0
        self.Overheated = false
        self.Bullet = CreateBulletStructure(60,"green")
        self.FireDelay = 0.05
        self.AlternateFire = true
 
        self.WeaponsTable = {}
       
        self.Gunner = nil
        self.BoostSpeed = 1500
        self.ForwardSpeed = 600
        self.UpSpeed = 500
        self.AccelSpeed = 12
        self.CanBack = true
        self.CanRoll = false
        self.CanStrafe = true
        self.HasWings = true
        self.CanEject = false       
       
        self:SetSkin(0)
        self.rocketnum = 1
        self.al = 1
       
        self.ExitModifier = {x=0,y=250,z=4}
        self.LandOffset = Vector(0,0, 1)
 
		self.PilotPosition =  Vector(0,102,87)
        self.PilotVisible = true
        self.PilotAnim = "drive_jeep"
        self.HasLookaround = true
       
        self.HasSeats = true
        self.SeatPos = {
            Gunner = {self:GetPos()+self:GetForward()*145+self:GetRight()*1+self:GetUp()*39,self:GetAngles()+Angle(0,-90,0),Vector(0,95,4)},

            {self:GetPos()+self:GetForward()*26+self:GetRight()*16+self:GetUp()*26,self:GetAngles()+Angle(0,180,0),Vector(0,95,4)},
            {self:GetPos()+self:GetForward()*26+self:GetRight()*-16+self:GetUp()*26,self:GetAngles()+Angle(0,0,0),Vector(0,95,4)},
            {self:GetPos()+self:GetForward()*-6+self:GetRight()*16+self:GetUp()*26,self:GetAngles()+Angle(0,180,0),Vector(0,95,4)},
            {self:GetPos()+self:GetForward()*-6+self:GetRight()*-16+self:GetUp()*26,self:GetAngles()+Angle(0,0,0),Vector(0,95,4)},
            {self:GetPos()+self:GetForward()*-38+self:GetRight()*16+self:GetUp()*26,self:GetAngles()+Angle(0,180,0),Vector(0,95,4)},
            {self:GetPos()+self:GetForward()*-38+self:GetRight()*-16+self:GetUp()*26,self:GetAngles()+Angle(0,0,0),Vector(0,95,4)},
            {self:GetPos()+self:GetForward()*58+self:GetRight()*16+self:GetUp()*26,self:GetAngles()+Angle(0,90,0),Vector(-95,0,4), Angle(0,90,0)},
            {self:GetPos()+self:GetForward()*58+self:GetRight()*-16+self:GetUp()*26,self:GetAngles()+Angle(0,90,0),Vector(95,0,4), Angle(0,90,0)},
        }
		
		self.NextUse.ToogleSirens = CurTime()
        self.NextUse.FireRockets = CurTime()
        self.NextUse.ToogleDoors = CurTime()
        self:SpawnLauncher()
        self.BaseClass.Initialize(self)

        self.Filter = {self:GetChildEntities()}

        self:SpawnDoors()
        self:SpawnTurrets()

        self.Turrets[1]:Fire( "SetParentAttachment", "turret_L")
        self.Turrets[2]:Fire( "SetParentAttachment", "turret_R")

        self.Seats["Gunner"]:Fire( "Addoutput", "limitview 0")

        self.Doors:ResetSequence(self.Doors:LookupSequence("DoorsOpen"))
        self.Doors:SetSolid(SOLID_NONE)
        self:SetNWEntity("IMP_PATROL_DOORS", self.Doors)
    end

    function ENT:Think()
        self:NextThink(CurTime())
        if(self.Inflight) then
            if IsValid(self.Pilot) then
				if(self.Pilot:KeyDown(IN_ATTACK2)) then
					self:FireLauncher()
				elseif(!IsValid(self.Gunner) and self.Pilot:KeyDown(IN_ATTACK)) then
					self:FireWeapons(self:GetPos() +  self:GetAngles():Forward()*100000)
				elseif(self.Pilot:KeyDown(IN_RELOAD)) then
					self:ToggleSiren()
				end
            end
            if (IsValid(self.Gunner)) then
                if IsValid(self.Gunner) and self.Gunner:KeyDown(IN_ATTACK) then
                    self:FireWeapons()
                end
                if IsValid(self.Gunner) and self.Gunner:KeyDown(IN_ATTACK2) then
                    if(self.FlashlightOn) then
						self.Doors:SetSkin(0)
                        self.BaseClass.RemoveFlashlight(self)
						self:EmitSound("buttons/lightswitch2.wav")
                        --self:SetNWEntity("IMPPATROL_Flashlight", NULL)
                    else
						self.Doors:SetSkin(1)
                        self.BaseClass.CreateFlashlight(self)
                        self.Flashlight[1]:SetParent(self.Doors)
						self:EmitSound("buttons/lightswitch2.wav")
                        --self:SetNWEntity("IMPPATROL_Flashlight", self.Flashlight[1])
                        self.Flashlight[1]:Fire("SetParentAttachment", "spotlight")
                    end
                end
            end
           
            if(self.Land) then
                self:ToggleDoors(true)
            end
           
            if(self.Wings) then
                self:ToggleDoors(false)
            elseif(!self.Wings) then
                self:ToggleDoors(true)
            end
 
            self:NextThink(CurTime())
        end
        self.BaseClass.Think(self)
    end
   
    function ENT:GetChildEntities()
        return self
    end
   
    function ENT:Passenger(p)
        if(self.NextUse.Use > CurTime()) then return end;
        for k,v in pairs(self.Seats) do
            if v:GetPassenger(1) == NULL and k ~= "Gunner" then
                p:EnterVehicle(v)
                return
            end
        end
    end
 
    function ENT:EnterGunner(p)
        if not self.Pilot then self:SetSkin(1) self.BaseClass.Enter(self, p) return end
        if self.Gunner == p then return end
        if(self.NextUse.Use > CurTime()) then return end
        for k,v in pairs(self.Seats) do
            if v:GetPassenger(1) == NULL and k == "Gunner" then
                p:EnterVehicle(v)
                p:CrosshairEnable()
                return       
            end
        end
    end
   
    function ENT:Use(p)
        if(not self.Inflight) then
            if !p:KeyDown(IN_WALK) then
                self:EnterGunner(p)
            elseif p ~= self.Pilot and p ~= self.Gunner then
                self:Passenger(p)
            end
        else
            if(!p:KeyDown(IN_WALK)) then
                self:EnterGunner(p)
            elseif p ~= self.Pilot and p ~= self.Gunner then
                self:Passenger(p)
            end
        end
    end
   
    function ENT:Exit(kill)
        if not IsValid(self) then return end
        self.BaseClass.Exit(self,kill)
       
        self:ToggleDoors(true)
        self:SetSkin(0)
		self:StopSound("siren")
        if self.Gunner then
            local p = self.Gunner
            self:GunnerLeftVehicle(self.Gunner, self.Gunner:GetVehicle())
            p:ExitVehicle()
            self:SetSkin(1)
            timer.Simple(0, function()
                self.BaseClass.Enter(self, p)
            end)
        end
        self.Pilot = nil
    end
   
    function ENT:Bang()
        self.BaseClass.Bang(self)
        self:GibBreakClient(self:GetVelocity())
		self:StopSound("siren")
        self:Remove()
    end
   
    function ENT:ToggleDoors(bol)
        if(self.NextUse.ToogleDoors < CurTime()) then
       
            if (bol and self.Doors:GetSequence() ~= self.Doors:LookupSequence("DoorsOpen")) then
                self:ResetSequence(self:LookupSequence("WingClose"))
                self.Doors:ResetSequence(self.Doors:LookupSequence("DoorsOpen"))
                self.Doors:SetSolid(SOLID_NONE)
                self.NextUse.ToogleDoors = CurTime()+2
               
            elseif (!bol and self.Doors:GetSequence() ~= self.Doors:LookupSequence("DoorsClose")) then
                self:ResetSequence(self:LookupSequence("WingOpen"))
                self.Doors:ResetSequence(self.Doors:LookupSequence("DoorsClose"))
                self.Doors:SetSolid(SOLID_VPHYSICS)
                self.NextUse.ToogleDoors = CurTime()+2
            end
        end
    end
   
	sound.Add( {
		name = "siren",
		channel = CHAN_STATIC,
		volume = 1.0,
		level = 80,
		pitch = 100,
		sound = "KingPommes/starwars/patrol/siren.wav"
	} )
   
    function ENT:ToggleSiren()
        if self.NextUse.ToogleSirens < CurTime()  then
            if self:GetSkin() == 1 then
                self:SetSkin(2)
				self:EmitSound("siren")
            elseif self:GetSkin() == 2 then
                self:SetSkin(1)
				self:StopSound("siren")
            end
        self.NextUse.ToogleSirens = CurTime()+1
        end
    end
   
    function ENT:FireLauncher()
        if(self.NextUse.FireRockets < CurTime()) then
            if (self.rocketnum % 2 == 1) then
                self.Launcher:SetPos(self:GetPos() + self:GetForward()*250 + self:GetUp()*50 + self:GetRight()*32)
                self.Launcher:Fire("FireOnce")
                self.rocketnum = self.rocketnum + 1
            elseif (self.rocketnum %2 == 0) then
                self.Launcher:SetPos(self:GetPos() + self:GetForward()*250 + self:GetUp()*50 + self:GetRight()*-32)
                self.Launcher:Fire("FireOnce")
                self.rocketnum = self.rocketnum + 1
            end
            if (self.rocketnum == 6) then
                self.rocketnum = 0
                self.NextUse.FireRockets = CurTime()+15
                self:SetNWInt("FireBlast",self.NextUse.FireRockets)
            end
        end
    end
 
    function ENT:FireWeapons()
        if(self.NextUse.Fire < CurTime()) then
        local aim
        if IsValid(self.Gunner) then
            --aim = self.Gunner:EyeAngles()
            --aim = self:WorldToLocalAngles(self.Gunner:GetAimVector():Angle())
            aim = self.Gunner:GetAimVector():Angle()
        end
            for k,v in pairs(self.Weapons) do
                if(!IsValid(v)) then return end;
                local tr
                if IsValid(self.Gunner) then
                    tr = util.TraceLine({
                        start = v:GetPos(),
                        --endpos = self.Gunner:GetPos() + Angle(math.Clamp(aim.x,-15,90),math.Clamp(aim.y,-68,68),0):Forward() * 100000,
                        endpos = self.Gunner:GetPos() + Angle(aim.x,aim.y):Forward() * 100000,
                        filter = {self,self.Gunner},
                    })
                elseif IsValid(self.Pilot) then
                    tr = util.TraceLine({
                        start = v:GetPos(),
                        endpos = self:GetPos()+self:GetForward()*10000,
                        filter = {self},
                    })                    
                end
                local angPos = (tr.HitPos - v:GetPos())
               
                if(self.ShouldLock) then
                    local e = self:FindTarget();
                    if(IsValid(e)) then
                        local tr = util.TraceLine( {
                            start = v:GetPos(),
                            endpos = e:GetPos(),
                            filter = {self, v},
                        } )
                        if(!tr.HitWorld) then
                            angPos = (e:GetPos() + e:GetUp()*(e:GetModelRadius()/3) + (self.LockOnOverride or Vector(0,0,0))) - v:GetPos();
                        end
                    end
                end
               
                self.Bullet.Attacker = self.Gunner or self.Pilot or self;
                self.Bullet.Src     = v:GetPos();
                local spread = self.Accel.FWD/1000;
                self.Bullet.Spread = Vector(spread,spread,spread);
                self.Bullet.IgnoreEntity = self, v
   
                self.Bullet.Dir = angPos
               
                if(self.AlternateFire) then
                    if (self.al == 1 and (v == self.Weapons[1])) then
                        v:FireBullets(self.Bullet)
                    elseif (self.al == 2 and (v == self.Weapons[2])) then
                        v:FireBullets(self.Bullet)
                    end
                else
                    v:FireBullets(self.Bullet)
                end
            end
            self.al = self.al + 1
            if(self.al == 3) then
                self.al = 1
            end
            self:EmitSound(self.FireSound,100,math.random(90,110))
            self.NextUse.Fire = CurTime() + (self.FireDelay)
        end
    end
 
    hook.Add("CanPlayerEnterVehicle", "PatrolTransport.PreventEnter", function(p,v)
        if(IsValid(p) and IsValid(v)) then
            local e = v:GetParent();
            if e.IsSWVehicle and e:GetClass() == "kingpommes_swv_patroltransport_imp" then
                if p == e.Gunner or p == e.Pilot then return false end
                return
            end
        end
    end)
 
    hook.Add("PlayerEnteredVehicle","PatrolTransport.GunnerEnterVehicle", function(p,v)
        if(IsValid(p) and IsValid(v)) then
            local e = v:GetParent();
            if e.IsSWVehicle and e:GetClass() == "kingpommes_swv_patroltransport_imp" and v:GetName() == "Gunner" then
                e.Gunner = p
                e:SetNWEntity("IMP_PATROL_GUNNER",p)
                p:SetNWEntity("IMP_PATROL", e)
                p:SetNWBool("GunnerIMP_Patrol", true)
                p:SetNWVector("Weapon1IMP_Patrol", e.WeaponLocations[1])
                p:SetNWVector("Weapon2IMP_Patrol", e.WeaponLocations[2])
            end
        end
    end)
	
	function ENT:GunnerLeftVehicle(p, v)
        if(IsValid(p) and IsValid(v)) then
            local e = v:GetParent();
            if e.IsSWVehicle and e:GetClass() == "kingpommes_swv_patroltransport_imp" then
                e.Gunner = nil
                e:SetNWEntity("IMP_PATROL_GUNNER", NULL)
                p:SetNWEntity("IMP_PATROL", nil)
                p:SetNWBool("GunnerIMP_Patrol", false)
                if v then
                    local pos = v:LocalToWorld(v._ExitPos)
                    p:SetPos(pos);
                end
            end
        end
    end

    hook.Add("PlayerLeaveVehicle", "PatrolTransport.GunnerLeaveVehicle", function(p, v)
        if(IsValid(p) and IsValid(v)) then
            local e = v:GetParent()
            if e.IsSWVehicle and e:GetClass() == "kingpommes_swv_patroltransport_imp" and v:GetName() == "Gunner" then
                e.Gunner = nil
                e:SetNWEntity("IMP_PATROL_GUNNER", NULL)
                p:SetNWEntity("IMP_PATROL", nil)
                p:SetNWBool("GunnerIMP_Patrol", false)
                local pos = v:LocalToWorld(v._ExitPos)
                p:SetPos(pos)
                if(e.FlashlightOn) then
				    e.Doors:SetSkin(0)
                    e.BaseClass.RemoveFlashlight(e)
					--e:EmitSound("items\flashlight1.wav")
                    --e:SetNWEntity("IMPPATROL_Flashlight", e)
                --else
				--	print("test")
				--	e.Doors:SetSkin(1)
                --    e.BaseClass.CreateFlashlight(e)
                --    e.Flashlight[1]:SetParent(e.Doors)
                --    e:SetNWEntity("IMPPATROL_Flashlight", e.Flashlight[1])
                --    e.Flashlight[1]:Fire("SetParentAttachment", "spotlight")
                end
            elseif e.IsSWVehicle and e:GetClass() == "kingpommes_swv_patroltransport_imp" and v:GetName() == "Passenger" then
                local pos = v:LocalToWorld(v._ExitPos)
                p:SetPos(pos)
                p:SetEyeAngles(v._ExitAngles)
            end
        end
    end)
       
end
 
 
 
if CLIENT then
 
    function ENT:Draw() self:DrawModel() end
 
    ENT.Sounds={
        Engine=Sound("vehicles/laat/laat_fly2.wav"),
    }
    ENT.CanFPV = true
	
	ENT.SpritePos = {}
 
    local Health = 0
    function ENT:Think()
        self.BaseClass.Think(self)

		--self:SetRenderBoundsWS(Vector(-9999999, -9999999, -9999999),Vector(9999999, 9999999, 9999999))
		
		local p = LocalPlayer()
        local IsDriver = p:GetNWEntity(self.Vehicle) == self.Entity
        local IsFlying = p:GetNWBool("Flying"..self.Vehicle)
		
		if(IsFlying and IsDriver) then
            Health = self:GetNWInt("Health")
        end     
 
        self.Gunner = self:GetNWEntity("IMP_PATROL_GUNNER")
        self.Doors = self:GetNWEntity("IMP_PATROL_DOORS")
		
        -- Dafuck, I need to do this because the Guns are always looking in one Direction when you are using global angles and are not the Localplayer
        -- If you use local angles its right for others but for the Localplayer its broken
		
        if IsValid(self.Gunner) and self.Gunner == LocalPlayer() then
            local aim = self.Gunner:EyeAngles()
            local x = math.Clamp(aim.x,-15,90)
            local y = math.Clamp(aim.y,22,158)
 
			self:ManipulateBoneAngles(self:LookupBone("turret_L"), Angle(0,-y + 90,x))
			self:ManipulateBoneAngles(self:LookupBone("turret_R"), Angle(0,-y + 90,x))
            if not IsValid(self.Doors) then return end
            self.Doors:ManipulateBoneAngles(self.Doors:LookupBone("spotlight"), Angle(0,-aim.x + 90,-aim.y + 90))
           
        elseif IsValid(self.Gunner) and self.Gunner ~= LocalPlayer() then
            local aim = self:WorldToLocalAngles(self.Gunner:EyeAngles())
			local x = math.Clamp(aim.x,-15,90)
            local y = math.Clamp(aim.y,-68,68)
 
            self:ManipulateBoneAngles(self:LookupBone("turret_L"), Angle(0,-y,x))
            self:ManipulateBoneAngles(self:LookupBone("turret_R"), Angle(0,-y,x))
 
            if not IsValid(self.Doors) then return end
            self.Doors:ManipulateBoneAngles(self.Doors:LookupBone("spotlight"), Angle(0,-aim.x + 90,-aim.y ))
           
        else
            self:ManipulateBoneAngles(self:LookupBone("turret_L"), Angle(0,0,0))
            self:ManipulateBoneAngles(self:LookupBone("turret_R"), Angle(0,0,0))
            if not IsValid(self.Doors) then return end
            self.Doors:ManipulateBoneAngles(self.Doors:LookupBone("spotlight"), Angle(0,0,0))
        end
    end
	
	ENT.ViewDistance = 700
	ENT.ViewHeight = 300
	ENT.FPVPos = Vector(115,0,121)
	ENT.HasCustomCalcView = true
	hook.Add("CalcVehicleView", "ImpPatrol.CalcVehicleView", function(veh, p, view)
		local e = LocalPlayer():GetVehicle()
		local Piloting = p:GetViewEntity() != p and p:GetViewEntity().IsSWVehicle;
		if IsValid(e) and e:GetParent().IsSWVehicle and e:GetParent():GetClass() == "kingpommes_swv_patroltransport_imp" then
			if p:GetNWBool("GunnerIMP_Patrol") and e:GetThirdPersonMode() then
                local view = {}
				view.origin = e:LocalToWorld(Vector(0,5,-30))
				view.angles = angles
				view.fov = fov
				view.drawviewer = true
				return view
			elseif not e:GetThirdPersonMode() and not p:GetNWBool("GunnerIMP_Patrol") then
                --Player View Height
				view.origin = view.origin + Vector(0,0, 40)
			elseif not p:GetNWBool("GunnerIMP_Patrol") then
                --Third Person View Height
                view.origin = view.origin + Vector(0,0, 40)
            end
		end
	end)

	hook.Add("CalcView", "ImpPatrol.CalcView", function(p, origin, ang)
		local view = {}
		local e = LocalPlayer():GetVehicle()
		local Piloting = p:GetViewEntity() != p and p:GetViewEntity().IsSWVehicle;
		if Piloting and p:GetViewEntity():GetClass() == "kingpommes_swv_patroltransport_imp" then
			self = p:GetViewEntity();
			local pos = self:LocalToWorld(self.FPVPos or Vector(0,0,0));
			View = SWVehicleView(self,self.ViewDistance or 800,self.ViewHeight or 250,pos,self:GetNWBool("HasLookaround"))
			return View;
		end
	end)
	
	
	--TESTING RENDERBOUNDS
	
	--hook.Add("HUDPaint", "TestingAoroundMF", function()
	--	for k, v in pairs(ents.GetAll()) do
	--		if v:GetClass() == "kingpommes_swv_patroltransport_imp" then
	--			local vec1, vec2 = v:GetRenderBounds()
	--			cam.Start3D()
	--				render.DrawWireframeBox(v:GetPos(), Angle(), vec1, vec2, Color(0, 0, 255, 255))
	--			cam.End3D()
	--		end
	--	end
	--end)
	
	

	function IMP_PATROLOfDoomReticle()
		local p = LocalPlayer()
		local Flying = p:GetNWBool("FlyingIMP_PATROL")
		local self = p:GetNWEntity("IMP_PATROL")
		local Gunner = p:GetNWBool("GunnerIMP_Patrol")
		local Weapon1 = p:GetNWVector("Weapon1IMP_PATROL")
		local Weapon2 = p:GetNWVector("Weapon2IMP_PATROL")

		if Flying and IsValid(self) then
			local x = ScrW()/4*0.1
			local y = ScrH()/4*2.5
			if(self:GetFPV()) then         
			end
			SW_HUD_DrawHull(self.StartHealth)
			SW_WeaponReticles(self)
			--SW_HUD_DrawOverheating(self)
			local pos = self:GetPos()+self:GetForward()*100+self:GetUp()*-45+self:GetRight()*0
			local x,y = SW_XYIn3D(pos)
			SW_HUD_Compass(self,x,y)
			SW_HUD_DrawSpeedometer()
			SW_HUD_WingsIndicator("patrol",x,y)
			SW_BlastIcon(self,15)
		end
	end
	hook.Add("HUDPaint", "IMP_PATROLReticle", IMP_PATROLOfDoomReticle)
end
--PATH lua/entities/lvs_base/sh_weapons.lua:
return gluapack()()
--PATH lua/entities/lvs_base/cl_boneposeparemeter.lua:

function ENT:CreateBonePoseParameter( name, bone, ang_min, ang_max, pos_min, pos_max )
	if not istable( self._BonePoseParameters ) then self._BonePoseParameters = {} end

	self._BonePoseParameters[ name ] = {
		bone = (bone or -1),
		ang_min = ang_min or angle_zero,
		ang_max = ang_max or angle_zero,
		pos_min = pos_min or vector_origin,
		pos_max = pos_max or vector_origin,
	}
end

function ENT:SetBonePoseParameter( name, value )
	if name and string.StartsWith( name, "!" ) then
		name = string.Replace( name, "!", "" )
	end

	local EntTable = self:GetTable()

	if not istable( EntTable._BonePoseParameters ) or not EntTable._BonePoseParameters[ name ] then return end

	local data = EntTable._BonePoseParameters[ name ]

	local ang = LerpAngle( value, data.ang_min, data.ang_max )
	local pos = LerpVector( value, data.pos_min, data.pos_max )

	self:ManipulateBoneAngles( data.bone, ang )
	self:ManipulateBonePosition( data.bone, pos )
end
--PATH lua/entities/lvs_base_doorhandler.lua:
AddCSLuaFile()

ENT.Type            = "anim"
ENT.DoNotDuplicate = true

ENT.RenderGroup = RENDERGROUP_BOTH 

ENT.UseRange = 75

ENT._UseTargetAllowed = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )

	self:NetworkVar( "Bool",0, "Active" )

	self:NetworkVar( "String",0, "PoseName" )

	self:NetworkVar( "Vector",0, "Mins" )
	self:NetworkVar( "Vector",1, "Maxs" )

	self:NetworkVar( "Float",0, "Rate" )
	self:NetworkVar( "Float",1, "RateExponent" )

	self:NetworkVar( "Float",2, "PoseMin" )
	self:NetworkVar( "Float",3, "PoseMax" )

	if SERVER then
		self:SetRate( 10 )
		self:SetRateExponent( 2 )

		self:SetPoseMax( 1 )
	end
end

function ENT:IsServerSide()
	local EntTable = self:GetTable()

	if isbool( EntTable._IsServerSide ) then return EntTable._IsServerSide end

	local PoseName = self:GetPoseName()

	if PoseName == "" then return false end

	local IsServerSide = string.StartsWith( PoseName, "^" )

	EntTable._IsServerSide = IsServerSide

	return IsServerSide
end

function ENT:IsOpen()
	return self:GetActive()
end

function ENT:InRange( ply, Range )
	local boxOrigin = self:GetPos()
	local boxAngles = self:GetAngles()
	local boxMins = self:GetMins()
	local boxMaxs = self:GetMaxs()

	local HitPos, _, _ = util.IntersectRayWithOBB( ply:GetShootPos(), ply:GetAimVector() * Range, boxOrigin, boxAngles, boxMins, boxMaxs )

	return isvector( HitPos )
end

if SERVER then
	AccessorFunc(ENT, "soundopen", "SoundOpen", FORCE_STRING)
	AccessorFunc(ENT, "soundclose", "SoundClose", FORCE_STRING)

	AccessorFunc(ENT, "maxsopen", "MaxsOpen", FORCE_VECTOR)
	AccessorFunc(ENT, "minsopen", "MinsOpen", FORCE_VECTOR)

	AccessorFunc(ENT, "maxsclosed", "MaxsClosed", FORCE_VECTOR)
	AccessorFunc(ENT, "minsclosed", "MinsClosed", FORCE_VECTOR)


	util.AddNetworkString( "lvs_doorhandler_interact" )

	net.Receive( "lvs_doorhandler_interact", function( length, ply )
		if not IsValid( ply ) then return end

		local ent = net.ReadEntity()

		if not IsValid( ent ) or not ent._UseTargetAllowed or not ent.UseRange or ply:InVehicle() then return end

		local Range = ent.UseRange * 2

		if (ply:GetPos() - ent:GetPos()):Length() > Range then return end

		if not ent:InRange( ply, Range ) then return end

		ent:Use( ply, ply )
	end)

	function ENT:LinkToSeat( ent )
		if not IsValid( ent ) or not ent:IsVehicle() then

			ErrorNoHalt( "[LVS] Couldn't link seat to doorsystem. Entity expected, got "..tostring( ent ).."\n" )

			return
		end

		self._LinkedSeat = ent
	end

	function ENT:GetLinkedSeat()
		return self._LinkedSeat
	end

	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:SetUseType( SIMPLE_USE )
		self:DrawShadow( false )
		debugoverlay.Cross( self:GetPos(), 15, 5, Color( 255, 223, 127 ) )
	end

	function ENT:Use( ply )
		if not IsValid( ply ) then return end

		local Base = self:GetBase()

		if not IsValid( Base ) then return end

		if not Base:IsUseAllowed( ply ) then return end

		if self:IsOpen() then
			self:Close( ply )
		else
			self:Open( ply )
		end
	end

	function ENT:OnOpen( ply )
	end

	function ENT:OnClosed( ply )
	end

	function ENT:OpenAndClose( ply )
		self:Open( ply )

		self._PreventClosing = true

		timer.Simple(0.5, function()
			if not IsValid( self ) then return end

			self:Close( ply )

			self._PreventClosing = false
		end )
	end

	function ENT:DisableOnBodyGroup( group, subgroup )
		self._BodyGroupDisable = group
		self._BodySubGroupDisable = subgroup
	end

	function ENT:IsBodyGroupDisabled()
		if not self._BodyGroupDisable or not self._BodySubGroupDisable then return false end

		local base = self:GetBase()

		if not IsValid( base ) then return false end

		return base:GetBodygroup( self._BodyGroupDisable ) == self._BodySubGroupDisable
	end

	function ENT:Open( ply )
		if self:IsOpen() then return end

		self:SetActive( true )
		self:SetMins( self:GetMinsOpen() )
		self:SetMaxs( self:GetMaxsOpen() )

		if self:IsBodyGroupDisabled() then return end

		self:OnOpen( ply )

		local snd = self:GetSoundOpen()

		if not snd then return end

		self:EmitSound( snd )
	end

	function ENT:Close( ply )
		if not self:IsOpen() then
			if self:IsBodyGroupDisabled() then
				self:Open( ply )
			end

			return
		end

		if self:IsBodyGroupDisabled() then return end

		self:SetActive( false )
		self:SetMins( self:GetMinsClosed() )
		self:SetMaxs( self:GetMaxsClosed() )

		self:OnClosed( ply )

		local snd = self:GetSoundClose()

		if not snd then return end

		self:EmitSound( snd )
	end

	function ENT:OnDriverChanged( oldDriver, newDriver, pod )
		if self._PreventClosing then return end

		if IsValid( newDriver ) then
			if self:IsOpen() then
				self:Close( newDriver )
			end
		else
			timer.Simple( FrameTime() * 2, function()
				if not IsValid( self ) or not IsValid( oldDriver ) or IsValid( self._Driver ) then return end

				if oldDriver:lvsGetVehicle() == self:GetBase() then return end

				if not self:IsOpen() then
					self:OpenAndClose()
				end
			end )
		end
	end

	function ENT:SetPoseParameterSV()
		local Base = self:GetBase()

		if not IsValid( Base ) then return end

		local Target = self:GetActive() and self:GetPoseMax() or self:GetPoseMin()
		local poseName = self:GetPoseName()

		if poseName == "" then return end

		local EntTable = self:GetTable()

		EntTable.sm_pp = EntTable.sm_pp and EntTable.sm_pp + (Target - EntTable.sm_pp) * FrameTime() * self:GetRate() or 0

		local value = EntTable.sm_pp ^ self:GetRateExponent()

		Base:SetPoseParameter( string.Replace(poseName, "^", ""), value )
	end

	function ENT:Think()
		if IsValid( self._LinkedSeat ) then
			local Driver = self._LinkedSeat:GetDriver()
	
			if self._Driver ~= Driver then
			
				self:OnDriverChanged( self._Driver, Driver, self._LinkedSeat )

				self._Driver = Driver
			end
		end

		if self:IsServerSide() then
			self:SetPoseParameterSV()

			self:NextThink( CurTime() )
		else
			self:NextThink( CurTime() + 0.25 )
		end

		return true
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	return
end

function ENT:Initialize()
end

function ENT:Think()
	if self:IsServerSide() then return end

	local Base = self:GetBase()

	if not IsValid( Base ) then return end

	local Target = self:GetActive() and self:GetPoseMax() or self:GetPoseMin()
	local poseName = self:GetPoseName()

	if poseName == "" then return end

	local EntTable = self:GetTable()

	EntTable.sm_pp = EntTable.sm_pp and EntTable.sm_pp + (Target - EntTable.sm_pp) * RealFrameTime() * self:GetRate() or 0

	local value = EntTable.sm_pp ^ self:GetRateExponent()

	if string.StartsWith( poseName, "!" ) then
		Base:SetBonePoseParameter( poseName, value )
	else
		Base:SetPoseParameter( poseName, value )
	end
end

function ENT:OnRemove()
end

function ENT:Draw()
end

local LVS = LVS
ENT.ColorSelect = Color(127,255,127,150)
ENT.ColorNormal = Color(255,0,0,150)
ENT.ColorTransBlack = Color(0,0,0,150)
ENT.OutlineThickness = Vector(0.5,0.5,0.5)

function ENT:DrawTranslucent()
	local ply = LocalPlayer()

	if not IsValid( ply ) or ply:InVehicle() or not ply:KeyDown( IN_SPEED ) then return end

	local InRange = self:InRange( ply, self.UseRange )

	if InRange then
		local EntTable = self:GetTable()

		local Use = ply:KeyDown( IN_USE )

		if EntTable.old_Use ~= Use then
			EntTable.old_Use = Use

			if Use then
				net.Start( "lvs_doorhandler_interact" )
					net.WriteEntity( self )
				net.SendToServer()
			end
		end
	end

	if not LVS.DeveloperEnabled then return end

	local boxOrigin = self:GetPos()
	local boxAngles = self:GetAngles()
	local boxMins = self:GetMins()
	local boxMaxs = self:GetMaxs()

	local EntTable = self:GetTable()

	local Col = InRange and EntTable.ColorSelect or EntTable.ColorNormal

	render.SetColorMaterial()
	render.DrawBox( boxOrigin, boxAngles, boxMins, boxMaxs, Col )
	render.DrawBox( boxOrigin, boxAngles, boxMaxs + EntTable.OutlineThickness, boxMins - EntTable.OutlineThickness, EntTable.ColorTransBlack )
end

--PATH lua/entities/lvs_base_gunner/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_base_starfighter/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_base_turret/shared.lua:

ENT.Base = "lvs_base"

ENT.PrintName = "[LVS] Base Starfighter"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

ENT.MaxVelocity = 3000
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.ThrottleRateUp = 0.6
ENT.ThrottleRateDown = 0.6

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

function ENT:SetupDataTables()
	self:CreateBaseDT()

	self:AddDT( "Vector", "Steer" )
	self:AddDT( "Vector", "AIAimVector" )
	self:AddDT( "Vector", "NWVtolMove" )
	self:AddDT( "Float", "NWThrottle" )
	self:AddDT( "Float", "MaxThrottle" )

	if SERVER then
		self:SetMaxThrottle( 1 )
	end
end

function ENT:PlayerDirectInput( ply, cmd )--[[
	local Pod = self:GetDriverSeat()

	local Delta = FrameTime()

	local KeyLeft = ply:lvsKeyDown( "-ROLL_SF" )
	local KeyRight = ply:lvsKeyDown( "+ROLL_SF" )
	local KeyPitchUp = ply:lvsKeyDown( "+PITCH_SF" )
	local KeyPitchDown = ply:lvsKeyDown( "-PITCH_SF" )

	local MouseX = cmd:GetMouseX()
	local MouseY = cmd:GetMouseY()

	if ply:lvsKeyDown( "FREELOOK" ) and not Pod:GetThirdPersonMode() then
		MouseX = 0
		MouseY = 0
	else
		ply:SetEyeAngles( Angle(0,90,0) )
	end

	local SensX, SensY, ReturnDelta = ply:lvsMouseSensitivity()

	if KeyPitchDown then MouseY = 10 * ReturnDelta end
	if KeyPitchUp then MouseY = -10 * ReturnDelta end

	local Input = Vector( MouseX * 0.4 * SensX, MouseY * SensY, 0 )

	local Cur = self:GetSteer()

	local Rate = Delta * 3 * ReturnDelta

	local New = Vector(Cur.x, Cur.y, 0) - Vector( math.Clamp(Cur.x * Delta * 5 * ReturnDelta,-Rate,Rate), math.Clamp(Cur.y * Delta * 5 * ReturnDelta,-Rate,Rate), 0)

	local Target = New + Input * Delta * 0.8

	local Fx = math.Clamp( Target.x, -1, 1 )
	local Fy = math.Clamp( Target.y, -1, 1 )

	local TargetFz = (KeyLeft and 1 or 0) - (KeyRight and 1 or 0)
	local Fz = Cur.z + math.Clamp(TargetFz - Cur.z,-Rate * 3,Rate * 3)

	local F = Cur + (Vector( Fx, Fy, Fz ) - Cur) * math.min(Delta * 100,1)

	self:SetSteer( F )]]
end

function ENT:PlayerMouseAim( ply, cmd )--[[
	if CLIENT then return end

	local Pod = self:GetDriverSeat()

	local PitchUp = ply:lvsKeyDown( "+PITCH_SF" )
	local PitchDown = ply:lvsKeyDown( "-PITCH_SF" )
	local YawRight = ply:lvsKeyDown( "+YAW_SF" )
	local YawLeft = ply:lvsKeyDown( "-YAW_SF" )
	local RollRight = ply:lvsKeyDown( "+ROLL_SF" )
	local RollLeft = ply:lvsKeyDown( "-ROLL_SF" )

	local FreeLook = ply:lvsKeyDown( "FREELOOK" )

	local EyeAngles = Pod:WorldToLocalAngles( ply:EyeAngles() )

	if FreeLook then
		if isangle( self.StoredEyeAngles ) then
			EyeAngles = self.StoredEyeAngles
		end
	else
		self.StoredEyeAngles = EyeAngles
	end

	local OverridePitch = 0
	local OverrideYaw = 0
	local OverrideRoll = (RollRight and 1 or 0) - (RollLeft and 1 or 0)

	if PitchUp or PitchDown then
		EyeAngles = self:GetAngles()

		self.StoredEyeAngles = Angle(EyeAngles.p,EyeAngles.y,0)

		OverridePitch = (PitchUp and 1 or 0) - (PitchDown and 1 or 0)
	end

	if YawRight or YawLeft then
		EyeAngles = self:GetAngles()

		self.StoredEyeAngles = Angle(EyeAngles.p,EyeAngles.y,0)

		OverrideYaw = (YawRight and 1 or 0) - (YawLeft and 1 or 0) 
	end

	self:ApproachTargetAngle( EyeAngles, OverridePitch, OverrideYaw, OverrideRoll, FreeLook )]]
end

function ENT:CalcThrottle( ply, cmd )--[[
	if CLIENT then return end

	local Delta = FrameTime()

	local ThrottleUp =  ply:lvsKeyDown( "+THRUST_SF" ) and self.ThrottleRateUp or 0
	local ThrottleDown = ply:lvsKeyDown( "-THRUST_SF" ) and -self.ThrottleRateDown or 0

	local Throttle = (ThrottleUp + ThrottleDown) * Delta

	self:SetThrottle( self:GetThrottle() + Throttle )]]
end

function ENT:CalcVtolThrottle( ply, cmd )--[[
	local Delta = FrameTime()

	local ThrottleZero = self:GetThrottle() <= 0

	local VtolX = ThrottleZero and (ply:lvsKeyDown( "-VTOL_X_SF" ) and -1 or 0) or 0
	local VtolY = ((ply:lvsKeyDown( "+VTOL_Y_SF" ) and 1 or 0) - (ply:lvsKeyDown( "-VTOL_Y_SF" ) and 1 or 0))
	local VtolZ = ((ply:lvsKeyDown( "+VTOL_Z_SF" ) and 1 or 0) - (ply:lvsKeyDown( "-VTOL_Z_SF" ) and 1 or 0))

	local DesiredVtol = Vector(VtolX,VtolY,VtolZ)
	local NewVtolMove = self:GetNWVtolMove() + (DesiredVtol - self:GetNWVtolMove()) * self.ThrustRateVtol * Delta

	if not ThrottleZero or self:WorldToLocal( self:GetPos() + self:GetVelocity() ).x > 100 then
		NewVtolMove.x = 0
	end

	self:SetVtolMove( NewVtolMove )]]
end

function ENT:SetVtolMove( NewMove )--[[
	if self:GetEngineActive() then
		self:SetNWVtolMove( NewMove )
	else
		self:SetNWVtolMove( Vector(0,0,0) )
	end]]
end

function ENT:SetThrottle( NewThrottle )--[[
	if self:GetEngineActive() then
		self:SetNWThrottle( math.Clamp(NewThrottle,0,self:GetMaxThrottle()) )
	else
		self:SetNWThrottle( 0 )
	end]]
end

function ENT:GetThrottle()--[[
	if self:GetEngineActive() then
		return self:GetNWThrottle()
	else
		return 0
	end]]
end

function ENT:GetVtolMove()--[[
	if self:GetEngineActive() and not self:GetAI() then
		return self:GetNWVtolMove() * self.ThrustVtol * (1 - math.min( self:GetThrottle(), 1 ))
	else
		return Vector(0,0,0)
	end]]
end

function ENT:StartCommand( ply, cmd )--[[
	if self:GetDriver() ~= ply then return end

	if SERVER then
		local KeyJump = ply:lvsKeyDown( "VSPEC" )

		if self._lvsOldKeyJump ~= KeyJump then
			self._lvsOldKeyJump = KeyJump

			if KeyJump then
				self:ToggleVehicleSpecific()
			end
		end
	end

	if ply:lvsMouseAim() then
		self:PlayerMouseAim( ply, cmd )
	else
		self:PlayerDirectInput( ply, cmd )
	end

	self:CalcThrottle( ply, cmd )
	self:CalcVtolThrottle( ply, cmd )]]
end

function ENT:GetThrustStrenght()--[[
	local ForwardVelocity = self:WorldToLocal( self:GetPos() + self:GetVelocity() ).x

	return (self.MaxVelocity * self:GetThrottle() - ForwardVelocity) / self.MaxVelocity]]
end

--PATH lua/entities/lvs_base_turret/cl_camera.lua:

ENT._lvsSmoothFreeLook = 0

function ENT:CalcViewDirectInput( ply, pos, angles, fov, pod )
	local ViewPosL = pod:WorldToLocal( pos )

	local view = {}
	view.fov = fov
	view.drawviewer = true
	view.angles = self:GetAngles()

	local FreeLook = ply:lvsKeyDown( "FREELOOK" )
	local Zoom = ply:lvsKeyDown( "ZOOM" )

	if not pod:GetThirdPersonMode() then

		if FreeLook then
			view.angles = pod:LocalToWorldAngles( ply:EyeAngles() )
		end

		local velL = self:WorldToLocal( self:GetPos() + self:GetVelocity() )

		local Dividor = math.abs( velL.x )
		local SideForce = math.Clamp( velL.y / Dividor, -1, 1)
		local UpForce = math.Clamp( velL.z / Dividor, -1, 1)

		local ViewPunch = Vector(0,math.Clamp(SideForce * 10,-1,1),math.Clamp(UpForce * 10,-1,1))
		if Zoom then
			ViewPunch = Vector(0,0,0)
		end

		pod._lerpPosOffset = pod._lerpPosOffset and pod._lerpPosOffset + (ViewPunch - pod._lerpPosOffset) * RealFrameTime() * 5 or Vector(0,0,0)
		pod._lerpPos = pos

		view.origin = pos + pod:GetForward() *  -pod._lerpPosOffset.y * 0.5 + pod:GetUp() *  pod._lerpPosOffset.z * 0.5
		view.angles.p = view.angles.p - pod._lerpPosOffset.z * 0.1
		view.angles.y = view.angles.y + pod._lerpPosOffset.y * 0.1
		view.drawviewer = false

		return view
	end

	pod._lerpPos = pod._lerpPos or self:GetPos()

	local radius = 550
	radius = radius + radius * pod:GetCameraDistance()

	if FreeLook then
		local velL = self:WorldToLocal( self:GetPos() + self:GetVelocity() )

		local SideForce = math.Clamp(velL.y / 10,-250,250)
		local UpForce = math.Clamp(velL.z / 10,-250,250)

		pod._lerpPosL = pod._lerpPosL and (pod._lerpPosL + (Vector(radius, SideForce,150 + radius * 0.1 + UpForce) - pod._lerpPosL) * RealFrameTime() * 12) or Vector(0,0,0)
		pod._lerpPos = self:LocalToWorld( pod._lerpPosL )

		view.origin = pod._lerpPos
		view.angles = self:LocalToWorldAngles( Angle(0,180,0) )
	else
		local TargetPos = self:LocalToWorld( Vector(500,0,150 + radius * 0.1) )

		local Sub = TargetPos - pod._lerpPos
		local Dir = Sub:GetNormalized()
		local Dist = Sub:Length()

		local DesiredPos = TargetPos - self:GetForward() * (300 + radius) - Dir * 100

		pod._lerpPos = pod._lerpPos + (DesiredPos - pod._lerpPos) * RealFrameTime() * (Zoom and 30 or 12)
		pod._lerpPosL = self:WorldToLocal( pod._lerpPos )

		local vel = self:GetVelocity()

		view.origin = pod._lerpPos
		view.angles = self:GetAngles()
	end

	view.origin = view.origin + ViewPosL

	return view
end

function ENT:CalcViewMouseAim( ply, pos, angles, fov, pod )
	local cvarFocus = math.Clamp( LVS.cvarCamFocus:GetFloat() , -1, 1 )

	self._lvsSmoothFreeLook = self._lvsSmoothFreeLook + ((ply:lvsKeyDown( "FREELOOK" ) and 0 or 1) - self._lvsSmoothFreeLook) * RealFrameTime() * 10

	local view = {}
	view.origin = pos
	view.fov = fov
	view.drawviewer = true
	view.angles = (self:GetForward() * (1 + cvarFocus) * self._lvsSmoothFreeLook * 0.8 + ply:EyeAngles():Forward() * math.max(1 - cvarFocus, 1 - self._lvsSmoothFreeLook)):Angle()

	if cvarFocus >= 1 then
		view.angles = LerpAngle( self._lvsSmoothFreeLook, ply:EyeAngles(), self:GetAngles() )
	else
		view.angles.r = 0
	end

	if not pod:GetThirdPersonMode() then

		view.drawviewer = false

		return view
	end

	local radius = 550
	radius = radius + radius * pod:GetCameraDistance()

	local TargetOrigin = view.origin - view.angles:Forward() * radius  + view.angles:Up() * radius * 0.2
	local WallOffset = 4

	local tr = util.TraceHull( {
		start = view.origin,
		endpos = TargetOrigin,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.origin = tr.HitPos

	if tr.Hit and not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	return pos, angles, fov
end

function ENT:CalcViewDriver( ply, pos, angles, fov, pod )
	if ply:lvsMouseAim() then
		return self:CalcViewMouseAim( ply, pos, angles, fov, pod )
	else
		return self:CalcViewDirectInput( ply, pos, angles, fov, pod )
	end
end

function ENT:CalcViewPassenger( ply, pos, angles, fov, pod )
	return LVS:CalcView( self, ply, pos, angles, fov, pod )
end

function ENT:LVSCalcView( ply, original_pos, original_angles, original_fov, pod )
	local pos, angles, fov = self:CalcViewOverride( ply, original_pos, original_angles, original_fov, pod )

	if self:GetDriverSeat() == pod then
		return self:CalcViewDriver( ply, pos, angles, fov, pod )
	else
		return self:CalcViewPassenger( ply, pos, angles, fov, pod )
	end
end
--PATH lua/entities/lvs_concussionmissile.lua:
return gluapack()()
--PATH lua/entities/lvs_destruction.lua:
AddCSLuaFile()

ENT.Type            = "anim"

local gibs = {
	"models/gibs/manhack_gib01.mdl",
	"models/gibs/manhack_gib02.mdl",
	"models/gibs/manhack_gib03.mdl",
	"models/gibs/manhack_gib04.mdl",
	"models/props_c17/canisterchunk01a.mdl",
	"models/props_c17/canisterchunk01d.mdl",
	"models/props_c17/oildrumchunk01a.mdl",
	"models/props_c17/oildrumchunk01b.mdl",
	"models/props_c17/oildrumchunk01c.mdl",
	"models/props_c17/oildrumchunk01d.mdl",
	"models/props_c17/oildrumchunk01e.mdl",
}

for _, modelName in ipairs( gibs ) do
	util.PrecacheModel( modelName )
end

if SERVER then
	function ENT:Initialize()
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false ) 

		self.Vel = isvector( self.Vel ) and self.Vel or Vector(0,0,0)

		local fxPos = self:LocalToWorld( self:OBBCenter() )
	
		local effectdata = EffectData()
			effectdata:SetOrigin( fxPos )
		util.Effect( "lvs_explosion", effectdata )

		self.GibModels = istable( self.GibModels ) and self.GibModels or gibs

		self.Gibs = {}
		self.DieTime = CurTime() + 5

		local Speed = self.Vel:Length()

		for _, v in pairs( self.GibModels ) do
			local ent = ents.Create( "prop_physics" )

			if not IsValid( ent ) then continue end

			table.insert( self.Gibs, ent ) 

			ent:SetPos( self:GetPos() )
			ent:SetAngles( self:GetAngles() )
			ent:SetModel( v )
			ent:Spawn()
			ent:Activate()
			ent:SetRenderMode( RENDERMODE_TRANSALPHA )
			ent:SetCollisionGroup( COLLISION_GROUP_WORLD )

			local PhysObj = ent:GetPhysicsObject()
			if IsValid( PhysObj ) then
				if Speed <= 250 then
					local GibDir = Vector( math.Rand(-1,1), math.Rand(-1,1), 1.5 ):GetNormalized()
					PhysObj:SetVelocityInstantaneous( GibDir * math.random(800,1300)  )
				else
					PhysObj:SetVelocityInstantaneous( VectorRand() * math.max(300,self.Vel:Length() / 3) + self.Vel  )
				end

				PhysObj:AddAngleVelocity( VectorRand() * 500 ) 
				PhysObj:EnableDrag( false ) 

				local effectdata = EffectData()
					effectdata:SetOrigin( fxPos )
					effectdata:SetStart( PhysObj:GetMassCenter() )
					effectdata:SetEntity( ent )
					effectdata:SetScale( math.Rand(0.3,0.7) )
					effectdata:SetMagnitude( math.Rand(0.5,2.5) )
				util.Effect( "lvs_firetrail", effectdata )
			end

			timer.Simple( 4.5 + math.Rand(0,0.5), function()
				if not IsValid( ent ) then return end

				ent:SetRenderMode( RENDERMODE_TRANSCOLOR )
				ent:SetRenderFX( kRenderFxFadeFast  )
			end )
		end
	end

	function ENT:Think()
		if self.DieTime < CurTime() then
			self:Remove()
		end

		self:NextThink( CurTime() + 1 )

		return true
	end

	function ENT:OnRemove()
		if istable( self.Gibs ) then
			for _, v in pairs( self.Gibs ) do
				if IsValid( v ) then
					v:Remove()
				end
			end
		end
	end
else
	function ENT:Draw()
	end
end
--PATH lua/entities/lvs_dwarfdroid/shared.lua:

ENT.Base = "lvs_walker_atte_hoverscript"

ENT.PrintName = "Dwarf Droid"
ENT.Author = "JohnyReaper"
ENT.Information = "Assault Walker of the CIS"
ENT.Category = "[LVS] - Johny's Star Wars"

ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.MDL = "models/macieg/starwars/spider.mdl"
ENT.GibModels = {
}

ENT.AITEAM = 3

ENT.MaxHealth = 1000

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.HoverHeight = 62.5
ENT.HoverTraceLength = 400
ENT.HoverHullRadius = 5

ENT.TurretTurnRate = 100

ENT.LAATC_PICKUPABLE = false
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-220,0,-145)
ENT.LAATC_PICKUP_Angle = Angle(0,180,0)

ENT.CanMoveOn = {
	["func_door"] = true,
	["func_movelinear"] = true,
	["prop_physics"] = true,
}

ENT.lvsShowInSpawner = true

function ENT:OnSetupDataTables()
	self:AddDT( "Entity", "TurretEnt" )
	self:AddDT( "Entity", "TurretSeat" )
	self:AddDT( "Entity", "GunnerSeat" )

	self:AddDT( "Float", "Move" )
	self:AddDT( "Bool", "IsMoving" )
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Bool", "IsRagdoll" )
	self:AddDT( "Vector", "AIAimVector" )

	self:AddDT( "Float", "TurretPitch" )
	self:AddDT( "Float", "TurretYaw" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:GetContraption()
	return {self}
end

function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( Vector(0,0,33) )
	end

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetAIAimVector()
	end

	local Driver = self:GetDriver()

	if IsValid( Driver ) then
		return Driver:GetAimVector()
	else
		return self:GetForward()
	end
end

function ENT:GetMainAimAngles()
	local trace = self:GetEyeTrace()

	local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,100)) ):GetNormalized():Angle() )

	local ID = self:LookupAttachment( "barrel" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return AimAngles, trace.HitPos, false end

	local DirAng = self:WorldToLocalAngles( (trace.HitPos - self:GetDriverSeat():LocalToWorld( Vector(0,0,33) ) ):Angle() )

	-- print(DirAng.p)

	return AimAngles, trace.HitPos, (math.abs( DirAng.p ) < 30)-- and math.abs( DirAng.y ) < 80)
end

-- function ENT:GetAimAngles( ent, base, RearEnt )
-- 	local trace = self:GetEyeTrace()

-- 	local Pos = self:LocalToWorld( Vector(208,0,170) )
-- 	local wAng = (trace.HitPos - Pos):GetNormalized():Angle()

-- 	local _, Ang = WorldToLocal( Pos, wAng, Pos, self:LocalToWorldAngles( Angle(0,0,0) ) )

-- 	return Ang, trace.HitPos, (Ang.p < 30 and Ang.p > -10 and math.abs( Ang.y ) < 60)
-- end

function ENT:ShootBottomWep(ent)

	-- if (!self:GetTurretEnt()) then return end

	local ID1 = self:LookupAttachment( "barrel" )

	local Muzzle1 = self:GetAttachment( ID1 )

	if not Muzzle1 then return end

	local AimAngles, AimPos, InRange = ent:GetMainAimAngles()

	local Pos = Muzzle1.Pos
	local Dir = (AimPos - Pos):GetNormalized()

	if not InRange then return true end

	local bullet = {}
	bullet.Src 	= Pos
	bullet.Dir 	= Dir
	bullet.Spread 	= Vector( 0.01,  0.01, 0 )
	bullet.TracerName = "lvs_laser_red_short"
	bullet.Force	= 10
	bullet.HullSize 	= 30
	bullet.Damage	= 100
	bullet.SplashDamage = 200
	bullet.SplashDamageRadius = 200
	bullet.Velocity = 8000
	bullet.Attacker 	= ent:GetDriver()
	bullet.Callback = function(att, tr, dmginfo)
		local effectdata = EffectData()
			effectdata:SetStart( Vector(255,50,50) ) 
			effectdata:SetOrigin( tr.HitPos )
		util.Effect( "lvs_laser_explosion", effectdata )
	end
	ent:LVSFireBullet( bullet )

	local effectdata = EffectData()
	effectdata:SetStart( Vector(255,50,50) )
	effectdata:SetOrigin( bullet.Src )
	effectdata:SetNormal( Dir )
	effectdata:SetEntity( ent )
	util.Effect( "lvs_muzzle_colorable", effectdata )

	ent:TakeAmmo()

	-- self:GetTurretEnt():PlayAnimation( "idle" )

	if not IsValid( ent.SNDPrimary ) then return end

	ent.SNDPrimary:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )

end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 400
	weapon.Delay = 0.6
	weapon.HeatRateUp = 0.2
	weapon.HeatRateDown = 0.2
	weapon.Attack = function( ent )
		if ent:GetIsCarried() then ent:SetHeat( 0 ) return true end

		-- if (self:GetDriverGunAngles() == 1) then return end
		-- 	ent:GetDriver():PrintMessage( HUD_PRINTCENTER, "NAJPIERW WYŁĄCZ TRYB STACJONARNY ABY STRZELAĆ Z TEJ BRONI" )
		-- return end

		return self:ShootBottomWep(ent)

		
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if IsValid( base ) and base:GetIsCarried() then return end

		-- if (self:GetDriverGunAngles() == 1) then return end

		local AimAngles = ent:GetMainAimAngles()

		-- print(AimAngles)

		local p = math.Clamp(AimAngles.p, -25, 35)
		-- local y = math.Clamp(AimAngles.y, -78, 78)

		ent:ManipulateBoneAngles(2,Angle(AimAngles.y,0,0))
		ent:ManipulateBoneAngles(3,Angle(0,0,p))

	end

	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	-- self:InitTurret()
	-- self:InitGunner()




	-- self.LegRotate = 0
	-- self.KnockbackAnim = 0

end
--PATH lua/entities/lvs_fakehover_aat/cl_prediction.lua:
return gluapack()()
--PATH lua/entities/lvs_fakehover_aat/cl_prediction.lua:

function ENT:PredictPoseParamaters()
	local pod = self:GetGunnerSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if ply ~= plyL then return end

	self:SetPoseParameterTurret( pod:lvsGetWeapon() )

	self:InvalidateBoneCache()
end

--PATH lua/entities/lvs_laatle_patrolgunship_imp/cl_init.lua:
include("shared.lua")


ENT.LightGlow = Material( "sprites/light_glow02_add" )
ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )

function ENT:OnSpawn()
end

function ENT:OnFrame()
	self:AnimFins()
end

function ENT:StartWindSounds()
    self:StopWindSounds()

    if LocalPlayer():lvsGetVehicle() ~= self then return end

    self._WaterSFX = CreateSound( self, "LVS.Physics.Water" )
    self._WaterSFX:PlayEx(0,100)
end

function ENT:AnimFins()
end

function ENT:RemoveLight()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end
end

function ENT:OnRemoved()
	self:RemoveLight()
end

function ENT:PreDrawTranslucent()
	if self:GetSpotlightToggle() == false then 
		self:RemoveLight()
		return false
	end

	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 10 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( false ) 
		thelamp:SetFarZ( 5000 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 40 )
		self.projector = thelamp
	end

	local attachment = {
		Pos = Vector(170,0,30),
		Ang = Angle(135, 0, 0)
	}

	if attachment then
		local StartPos = self:LocalToWorld(attachment.Pos)
		local Dir = self:LocalToWorldAngles(attachment.Ang):Up()

		render.SetMaterial( self.LightGlow )
		render.DrawSprite( StartPos + Dir * 20, 200, 200, Color( 255, 255, 255, 255) )

		render.SetMaterial( self.LightMaterial )
		render.DrawBeam(  StartPos - Dir * 10,  StartPos + Dir * 1500, 350, 0, 0.99, Color( 255, 255, 255, 10) ) 
		
		if IsValid( self.projector ) then
			self.projector:SetPos( StartPos )
			self.projector:SetAngles( Dir:Angle() )
			self.projector:Update()
		end
	end

	return false
end

function ENT:CalcViewOverride(ply, pos, angles, fov, pod)

	if pod ~= self:GetDriverSeat() and pod ~= self:GetGunnerSeat() and not pod:GetThirdPersonMode() then
		return pod:LocalToWorld(Vector(0, 0, 68)), angles, fov
	end

	return pos, angles, fov
end 

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 0, 80, 255 )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "^lvs/vehicles/laat/boost_"..math.random(1,2)..".wav", 85 )
end

function ENT:OnStopBoost()
end
--PATH lua/entities/lvs_laatle_patrolgunship_imp/shared.lua:
ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "LAAT/le Gunship"
ENT.Author = "Durian"
ENT.Information = ""
ENT.Category = "[LVS] - Imperial Vehicles"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/kingpommes/starwars/patrol_transport/main.mdl"
ENT.GibModels = {
}

ENT.AITEAM = 1

ENT.MaxVelocity = 1250
ENT.MaxThrust = 1250

ENT.MaxPitch = 60

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 2

ENT.TurnRatePitch = 0.7
ENT.TurnRateYaw = 0.7
ENT.TurnRateRoll = 0.66

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 700
ENT.MaxShield = 400

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "WingsDown" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Bool", "SpotlightToggle" )
	self:AddDT( "Bool", "DoorsClose")

	if SERVER or CLIENT then
		self:NetworkVarNotify( "WingsDown", self.OnWingsChanged )
	end
end

function ENT:InitWeapons()

	local weapon = {}
		weapon.Icon = Material("lvs/weapons/concussionmissile.png")
		weapon.Ammo = 20
		weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
		weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
		weapon.HeatRateDown = 0.25
		weapon.Attack = function( ent )
			local T = CurTime()

			if IsValid( ent._ConcussionMissile ) then
				if (ent._nextMissleTracking or 0) > T then return end

				ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

				ent._ConcussionMissile:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

				return
			end

			if (ent._nextMissle or 0) > T then return end

			ent._nextMissle = T + 0.5

			ent._swapMissile = not ent._swapMissile

			local Pos = Vector( 180, (ent._swapMissile and -35 or 35), 20 )Vector(180.79,35.9,22.68)

			local Driver = self:GetDriver()

			local projectile = ents.Create( "lvs_concussionmissile" )
			projectile:SetPos( ent:LocalToWorld( Pos ) )
			projectile:SetAngles( ent:GetAngles() )
			projectile:SetParent( ent )
			projectile:Spawn()
			projectile:Activate()
			projectile:SetAttacker( IsValid( Driver ) and Driver or self )
			projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
			projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )
			projectile:SetDamage( 800 )
			projectile:SetRadius( 300 )

			ent._ConcussionMissile = projectile

			ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
		end
		weapon.FinishAttack = function( ent )
			if not IsValid( ent._ConcussionMissile ) then return end

			local projectile = ent._ConcussionMissile

			projectile:Enable()
			projectile:EmitSound( "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
			ent:TakeAmmo()

			ent._ConcussionMissile = nil

			local NewHeat = ent:GetHeat() + 0.75

			ent:SetHeat( NewHeat )
			if NewHeat >= 1 then
				ent:SetOverheated( true )
			end
		end
		weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
		weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/vehicles/imperial/overheat.wav") end
	self:AddWeapon( weapon )

	local weapon = {}		
		weapon.Icon = Material("lvs/weapons/dual_hmg.png")
		weapon.Ammo = 1250
		weapon.Delay = 0.25
		weapon.HeatRateUp = 0.3
		weapon.HeatRateDown = 0.3
		weapon.Attack = function( ent )
			local pod = ent:GetDriverSeat()

			if not IsValid( pod ) then return end

			if ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= 61 then return true end

			ent.FirePositions = {
				Vector(180.79,-35.9,22.68),
				Vector(180.79,35.9,22.68)
,
			}
			
			
			ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
			if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

			local startpos = pod:LocalToWorld( pod:OBBCenter() )
			local trace = ent:GetEyeTrace()

			local bullet = {}
			bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
			bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
			bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
			bullet.TracerName = "lvs_laser_green"
			bullet.Force	= 10
			bullet.HullSize 	= 25
			bullet.Damage	= 60
			bullet.SplashDamage = 200
			bullet.SplashDamageRadius = 70
			bullet.Velocity = 60000
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
					effectdata:SetStart( Vector(50,255,50) ) 
					effectdata:SetOrigin( tr.HitPos )
					effectdata:SetNormal( tr.HitNormal )
				util.Effect( "lvs_laser_impact", effectdata )
			end
			ent:LVSFireBullet( bullet )

			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:TakeAmmo()

			veh = ent:GetVehicle()

			veh.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
		weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
		weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/vehicles/imperial/overheat.wav") end
		weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
			local base = ent:GetVehicle()

			if not IsValid( base ) then 
				return LVS:CalcView( ent, ply, pos, angles, fov, pod )
			end

			if pod:GetThirdPersonMode() then
				pos = pos + base:GetUp() * 100
			end

			return LVS:CalcView( base, ply, pos, angles, fov, pod )
		end
		weapon.HudPaint = function( ent, X, Y, ply )
			local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 60) and COLOR_RED or COLOR_WHITE

			local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

			local base = ent:GetVehicle()
			base:PaintCrosshairCenter( Pos2D, Col )
			base:PaintCrosshairOuter( Pos2D, Col )
			base:LVSPaintHitMarker( Pos2D )
		end
		weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
			local view = {}
			view.origin = pos
			view.angles = angles
			view.fov = fov
			view.drawviewer = false

			local mn = self:OBBMins()
			local mx = self:OBBMaxs()
			local radius = ( mn - mx ):Length()
			local radius = radius + radius * pod:GetCameraDistance()

			local clamped_angles = pod:WorldToLocalAngles( angles )
			clamped_angles.p = math.max( clamped_angles.p, -20 )
			clamped_angles = pod:LocalToWorldAngles( clamped_angles )

			local StartPos = self:LocalToWorld( Vector(-150,0,150) ) + clamped_angles:Up() * 150
			local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * radius * 0.2

			local WallOffset = 4

			local tr = util.TraceHull( {
				start = StartPos,
				endpos = EndPos,
				filter = function( e )
					local c = e:GetClass()
					local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

					return collide
				end,
				mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
				maxs = Vector( WallOffset, WallOffset, WallOffset ),
			} )

			view.angles = angles + Angle(5,0,0)
			view.origin = tr.HitPos
			view.drawviewer = true

			if tr.Hit and  not tr.StartSolid then
				view.origin = view.origin + tr.HitNormal * WallOffset
			end

			return view
		end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		if self:GetSpotlightToggle() == true then
			self:SetSpotlightToggle(false)
		else
			self:SetSpotlightToggle(true)
		end
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_sidedoor.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function( ent )
		if self:GetAI() then return end
	
		if self.t1 > CurTime() then return end
		if(self.Doors:GetSequence() == self.Doors:LookupSequence("DoorsOpen")) then
			self.Doors:ResetSequence(self.Doors:LookupSequence("DoorsClose"))
			self:SetDoorsClose(false)
		else				
			self.Doors:ResetSequence(self.Doors:LookupSequence("DoorsOpen"))
			self:SetDoorsClose(true)
		end
		self.t1 = CurTime() + 0.5
	end
	self:AddWeapon( weapon )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/laat/flyby"..math.random(1,2,3,4,5)..".wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/laat/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
	{
		sound = "^lvs/vehicles/laat/dist.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0.35,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		VolumeMin = 0,
		VolumeMax = 1,
		SoundLevel = 110,
	},
}

function ENT:CalcMainActivity( ply )
	local Pod = ply:GetVehicle()

	if Pod == self:GetDriverSeat() or Pod == self:GetGunnerSeat() then return end

	if ply.m_bWasNoclipping then 
		ply.m_bWasNoclipping = nil 
		ply:AnimResetGestureSlot( GESTURE_SLOT_CUSTOM ) 

		if CLIENT then 
			ply:SetIK( true )
		end 
	end 

	ply.CalcIdeal = ACT_STAND
	ply.CalcSeqOverride = ply:LookupSequence( "idle_all_02" )

	if ply:GetAllowWeaponsInVehicle() and IsValid( ply:GetActiveWeapon() ) then

		local holdtype = ply:GetActiveWeapon():GetHoldType()

		if holdtype == "smg" then 
			holdtype = "smg1"
		end

		local seqid = ply:LookupSequence( "idle_" .. holdtype )

		if seqid ~= -1 then
			ply.CalcSeqOverride = seqid
		end
	end

	return ply.CalcIdeal, ply.CalcSeqOverride
end
--PATH lua/entities/lvs_repulsorlift_dropship/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_repulsorlift_dropship/cl_init.lua:
include("shared.lua")

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if pod == self:GetDriverSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 200, angles, fov
		end

		return pos, angles, fov
	end

	return pos, angles, fov
end

function ENT:OnSpawn()
end

function ENT:OnFrame()
	local HeldEntity = self:GetHeldEntity()

	local IsHeld = IsValid( HeldEntity )

	if IsHeld ~= self._oldHeldEntity then
		self._oldHeldEntity = IsHeld

		if IsHeld then
			self:BuildFilter()
		else
			self:ResetFilters()
		end
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "^lvs/vehicles/laat/boost_"..math.random(1,2)..".wav", 85 )
end

function ENT:OnStopBoost()
end

--PATH lua/entities/lvs_repulsorlift_gunship/cl_drawing.lua:

function ENT:PreDraw()
	self:DrawDriverBTL()
	self:DrawDriverBTR()

	return true
end

function ENT:DrawDriverBTL()
	local pod = self:GetBTPodL()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if not IsValid( ply ) or (ply == plyL and plyL:GetViewEntity() == plyL) then return end

	local ID = self:LookupAttachment( "muzzle_ballturret_left" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local _,Ang = LocalToWorld( Vector(0,0,0), Angle(-90,0,-90), Muzzle.Pos, Muzzle.Ang )

	ply:SetSequence( "drive_jeep" )
	ply:SetRenderAngles( Ang )
	ply:DrawModel()
end

function ENT:DrawDriverBTR()
	local pod = self:GetBTPodR()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if not IsValid( ply ) or (ply == plyL and plyL:GetViewEntity() == plyL) then return end

	local ID = self:LookupAttachment( "muzzle_ballturret_right" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local _,Ang = LocalToWorld( Vector(0,0,0), Angle(-90,0,-90), Muzzle.Pos, Muzzle.Ang )

	ply:SetSequence( "drive_jeep" )
	ply:SetRenderAngles( Ang )
	ply:DrawModel()
end
--PATH lua/entities/lvs_space_laat_arc/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_starfighter_arc170/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_starfighter_droidtrifighter/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Droid Tri-Fighter"
ENT.Author = "Luna"
ENT.Information = "Droid Starfighter of the Separatists"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Starfighters"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/salza/droidtrifighter.mdl"
ENT.GibModels = {
	"models/salza/tridroid_gib1.mdl",
	"models/salza/tridroid_gib2.mdl",
	"models/salza/tridroid_gib3.mdl",
	"models/salza/tridroid_gib4.mdl",
	"models/salza/tridroid_gib5.mdl",
}

ENT.AITEAM = 1

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1.25

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 250

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(114.58,0,86.08),
		Vector(112.54,74.47,-42.69),
		Vector(112.54,-74.47,-42.69),
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 1200
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 40
		bullet.Damage	= 10
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 200
	weapon.Delay = 0.1
	weapon.HeatRateUp = 1.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( Vector(152.24,0,0) )
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 40
		bullet.SplashDamage = 40
		bullet.SplashDamageRadius = 200
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,0,0) ) 
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		ent.SecondarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) end
	self:AddWeapon( weapon )

	self:AddWeapon( LVS:GetWeaponPreset( "TURBO" ) )
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/droidtrifighter/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
	{
		sound = "^lvs/vehicles/vulturedroid/dist.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0.35,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		VolumeMin = 0,
		VolumeMax = 1,
		SoundLevel = 100,
	},
}
--PATH lua/entities/lvs_starfighter_vulturedroid/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_starfighter_vulturedroid/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_sw_transport/shared.lua:

ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Transport"
ENT.Author = "senfauge"
ENT.Information = "A Star Wars transport vehicle."
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Transports"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/theinvisibleman/transport/transportpersonel_01.mdl"
ENT.GibModels = {}

ENT.AITEAM = 2

ENT.MaxHealth = 1000

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 180
ENT.MaxVelocityY = 180

ENT.MaxTurnRate = 0.5

ENT.BoostAddVelocityX = 120
ENT.BoostAddVelocityY = 120

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

function ENT:OnSetupDataTables()
	self:AddDT("Bool","LightOn")
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		self:EmitSound( "lvs_sw_transporter/horn.mp3", 75, 105 )
	end
	self:AddWeapon( weapon )
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/iftx/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/iftx/loop_hi.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "^lvs/vehicles/iftx/dist.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 90,
	},
}
--PATH lua/entities/lvs_turret_aa_red/cl_init.lua:
include("shared.lua")

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )

	if self:GetGunnerSeat() == ply:GetVehicle() then
		if pod:GetThirdPersonMode() then
			return pos + self:GetUp() * 100, angles, fov
		end
	end

	return pos, angles, fov
end

function ENT:OnSpawn()
end

function ENT:OnFrame()
end

function ENT:PostDrawTranslucent()
end

function ENT:EngineEffects()
end

function ENT:AnimGunner()
end

function ENT:AnimAstromech()
end

function ENT:AnimCockpit()
end

function ENT:OnStartBoost()
end

function ENT:OnStopBoost()
end

--PATH lua/entities/lvs_turret_av/cl_init.lua:
include("shared.lua")

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )

	if self:GetGunnerSeat() == ply:GetVehicle() then
		if pod:GetThirdPersonMode() then
			return pos + self:GetUp() * 100, angles, fov
		end
	end

	return pos, angles, fov
end

function ENT:OnSpawn()
end

function ENT:OnFrame()
end

function ENT:PostDrawTranslucent()
end

function ENT:EngineEffects()
end

function ENT:AnimGunner()
end

function ENT:AnimAstromech()
end

function ENT:AnimCockpit()
end

function ENT:OnStartBoost()
end

function ENT:OnStopBoost()
end

--PATH lua/entities/lvs_vehicle_spammer.lua:

AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "AI Vehicle Spammer"
ENT.Author = "Luna"
ENT.Information = "AI Vehicle Spawner. Spammer in the hands of a Minge."
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= true
ENT.Editable = true

function ENT:SetupDataTables()
	local AllSents = scripted_ents.GetList() 
	local SpawnOptions = {}

	for _, v in pairs( AllSents ) do
		if not v or not istable( v.t ) or not v.t.Spawnable then continue end

		if v.t.Base and v.t.Base:lower() == "lvs_base_wheeldrive" and not v.t.lvsShowInSpawner then continue end

		if v.t.lvsShowInSpawner == false then continue end

		if v.t.lvsShowInSpawner or (v.t.Base and (string.StartWith( v.t.Base:lower(), "lvs_base" ) or string.StartWith( v.t.Base:lower(), "lunasflightschool" ))) then
			if v.t.Category and v.t.PrintName then
				local nicename = v.t.Category.." - "..v.t.PrintName
				if not table.HasValue( SpawnOptions, nicename ) then
					SpawnOptions[nicename] = v.t.ClassName
				end
			end
		end
	end

	self:NetworkVar( "String",0, "Type",	{ KeyName = "Vehicle Type",Edit = { type = "Combo",	order = 1,values = SpawnOptions,category = "Vehicle-Options"} } )
	self:NetworkVar( "Int",3, "TeamOverride", { KeyName = "AI Team", Edit = { type = "Int", order = 4,min = -1, max = 3, category = "Vehicle-Options"} } )
	self:NetworkVar( "Int",4, "RespawnTime", { KeyName = "spawntime", Edit = { type = "Int", order = 5,min = 1, max = 120, category = "Vehicle-Options"} } )
	self:NetworkVar( "Int",5, "Amount", { KeyName = "amount", Edit = { type = "Int", order = 6,min = 1, max = 10, category = "Vehicle-Options"} } )
	self:NetworkVar( "Int",6, "SpawnWithSkin", { KeyName = "spawnwithskin", Edit = { type = "Int", order = 8,min = 0, max = 16, category = "Vehicle-Options"} } )
	self:NetworkVar( "Int",7, "SpawnWithHealth", { KeyName = "spawnwithhealth", Edit = { type = "Int", order = 9,min = 0, max = 50000, category = "Vehicle-Options"} } )
	self:NetworkVar( "Int",8, "SpawnWithShield", { KeyName = "spawnwithshield", Edit = { type = "Int", order = 10,min = 0, max = 50000, category = "Vehicle-Options"} } )

	self:NetworkVar( "Int",10, "SelfDestructAfterAmount", { KeyName = "selfdestructafteramount", Edit = { type = "Int", order = 22,min = 0, max = 100, category = "Spawner-Options"} } )
	self:NetworkVar( "Bool",2, "MasterSwitch" )

	if SERVER then
		self:NetworkVarNotify( "Type", self.OnTypeChanged )

		self:SetRespawnTime( 2 )
		self:SetAmount( 1 )
		self:SetSelfDestructAfterAmount( 0 )
		self:SetSpawnWithHealth( 0 )
		self:SetSpawnWithShield( 0 )
		self:SetTeamOverride( -1 )
	end
end

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal * 1 )
		ent:Spawn()
		ent:Activate()

		return ent

	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:Initialize()	
		self:SetModel( "models/hunter/plates/plate8x8.mdl" )
		
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetUseType( SIMPLE_USE )
		self:DrawShadow( false )

		self:SetCollisionGroup( COLLISION_GROUP_WORLD )
		
		self.NextSpawn = 0
	end

	function ENT:Use( ply )
		if not IsValid( ply ) then return end

		if not IsValid( self.Defusor ) then
			self.Defusor = ply
			self.DefuseTime = CurTime()
		end
	end
	
	function ENT:Think()
		if IsValid( self.Defusor ) and isnumber( self.DefuseTime ) then
			if self.Defusor:KeyDown( IN_USE ) then
				if CurTime() - self.DefuseTime > 1 then
					self:SetMasterSwitch( not self:GetMasterSwitch() )

					for k, v in pairs( ents.FindByClass( "lvs_vehicle_spammer" ) ) do
						if v ~= self and IsValid( v ) then
							v:SetMasterSwitch( self:GetMasterSwitch() )
						end
					end

					if self:GetMasterSwitch() then
						self.Defusor:PrintMessage( HUD_PRINTTALK, "ALL AI-Spawners Enabled")
					else
						self.Defusor:PrintMessage( HUD_PRINTTALK, "ALL AI-Spawners Disabled")
					end

					self.Defusor = nil
				end
			else
				self:SetMasterSwitch( not self:GetMasterSwitch() )

				if self:GetMasterSwitch() then
					self.Defusor:PrintMessage( HUD_PRINTTALK, "AI-Spawner Enabled")
				else
					self.Defusor:PrintMessage( HUD_PRINTTALK, "AI-Spawner Disabled")
				end

				self.Defusor = nil
			end
		end

		if not self:GetMasterSwitch() then return end

		self.spawnedvehicles = self.spawnedvehicles or {}

		if self.ShouldSpawn then
			if self.NextSpawn < CurTime() then
				
				self.ShouldSpawn = false
				
				local pos = self:LocalToWorld( Vector( 0, 0, 150 ) )
				local ang = self:LocalToWorldAngles( Angle( 0, 90, 0 ) )
				
				local Type = self:GetType()
				
				if Type ~= "" then
					local spawnedvehicle = ents.Create( Type )
					
					if IsValid( spawnedvehicle ) then
						if spawnedvehicle.SpawnNormalOffsetSpawner then
							spawnedvehicle:SetPos( self:LocalToWorld( Vector(0,0,spawnedvehicle.SpawnNormalOffsetSpawner) ) )
						else
							spawnedvehicle:SetPos( pos + Vector(0,0,spawnedvehicle.SpawnNormalOffset or 0) )
						end
						spawnedvehicle:SetAngles( ang )
						spawnedvehicle:Spawn()
						spawnedvehicle:Activate()
						spawnedvehicle:SetAI( true )
						spawnedvehicle:SetSkin( self:GetSpawnWithSkin() )
						spawnedvehicle.SpawnedByAISpawner = true

						if self:GetTeamOverride() >= 0 then
							spawnedvehicle:SetAITEAM( self:GetTeamOverride() )
						end

						if self:GetSpawnWithHealth() > 0 then
							spawnedvehicle.MaxHealth = self:GetSpawnWithHealth()
							spawnedvehicle:SetHP( self:GetSpawnWithHealth() )
						end
	
						if self:GetSpawnWithShield() > 0 then
							spawnedvehicle.MaxShield = self:GetSpawnWithShield()
							spawnedvehicle:SetShield( self:GetSpawnWithShield() )
						end

						if spawnedvehicle.LFS and not spawnedvehicle.DontPushMePlease then
							local PhysObj = spawnedvehicle:GetPhysicsObject()
							
							if IsValid( PhysObj ) then
								PhysObj:SetVelocityInstantaneous( -self:GetRight() * 1000 )
							end
						end

						table.insert( self.spawnedvehicles, spawnedvehicle )

						if self:GetSelfDestructAfterAmount() > 0 then
							self.RemoverCount = isnumber( self.RemoverCount ) and self.RemoverCount + 1 or 1

							if self.RemoverCount >= self:GetSelfDestructAfterAmount() then
								self:Remove()
							end
						end
					end
				end
			end
		else
			local AmountSpawned = 0
			for k,v in pairs( self.spawnedvehicles ) do
				if IsValid( v ) then
					AmountSpawned = AmountSpawned + 1
				else
					self.spawnedvehicles[k] = nil
				end
			end

			if AmountSpawned < self:GetAmount() then
				self.ShouldSpawn = true
				self.NextSpawn = CurTime() + self:GetRespawnTime()
			end
		end

		self:NextThink( CurTime() )

		return true
	end
end

if CLIENT then
	local WhiteList = {
		["weapon_physgun"] = true,
		["weapon_physcannon"] = true,
		["gmod_tool"] = true,
	}

	local TutorialDone = false
	local mat = Material( "models/wireframe" )
	local FrameMat = Material( "lvs/3d2dmats/frame.png" )
	local ArrowMat = Material( "lvs/3d2dmats/arrow.png" )

	function ENT:Draw()
		local ply = LocalPlayer()

		if not IsValid( ply ) then return end

		if TutorialDone then
			if GetConVarNumber( "cl_draweffectrings" ) == 0 then return end

			local wep = ply:GetActiveWeapon()

			if not IsValid( wep ) then return end

			local weapon_name = wep:GetClass()

			if not WhiteList[ weapon_name ] then
				return
			end
		else
			local wep = ply:GetActiveWeapon()

			if not IsValid( wep ) then return end

			local weapon_name = wep:GetClass()

			if not WhiteList[ weapon_name ] then
				if weapon_name == "gmod_camera" then return end

				local Trace = ply:GetEyeTrace()
				if Trace.Entity ~= self or (ply:GetShootPos() - Trace.HitPos):Length() > 800 then return end
			end
		end

		local Pos = self:GetPos()
		local R = 190
		render.SetMaterial( mat )
		render.DrawBox( Pos, self:GetAngles(), Vector(-R,-R,0), Vector(R,R,200), color_white )

		for i = 0, 180, 180 do
			cam.Start3D2D( Pos, self:LocalToWorldAngles( Angle(i,0,0) ), 0.185 )
				if self:GetMasterSwitch() then
					local T4 = CurTime() * 4

					local OY = math.cos( T4 )
					local A = math.max( math.sin( T4 ), 0 )
		
					surface.SetMaterial( ArrowMat )

					if self:GetType() == "" then
						surface.SetDrawColor( 255, 0, 0, A * 255 )
						surface.DrawTexturedRect( -512, -512 + OY * 512, 1024, 1024 )

						surface.SetDrawColor( 255, 0, 0, math.abs( math.cos( T4 ) ) ^ 2 * 255  )
					else
						surface.SetDrawColor( 0, 127, 255, A * 255 )
						surface.DrawTexturedRect( -512, -512 + OY * 512, 1024, 1024 )

						surface.SetDrawColor( 0, 127, 255, 255 )
					end
				else
					surface.SetDrawColor( 255, 0, 0, 255 )
		
					surface.SetMaterial( ArrowMat )
					surface.DrawTexturedRect( -512, -512, 1024, 1024 )
				end

				surface.SetMaterial( FrameMat )
				surface.DrawTexturedRect( -1024, -1024, 2048, 2048 )
			cam.End3D2D()
		end
	end

	hook.Add( "HUDPaint", "!!!!!!!11111lvsvehiclespammer_tutorial", function()
		if TutorialDone then
			hook.Remove( "HUDPaint", "!!!!!!!11111lvsvehiclespammer_tutorial" )
		end

		local ply = LocalPlayer()

		if ply:InVehicle() then return end

		local trace = ply:GetEyeTrace()
		local Dist = (ply:GetShootPos() - trace.HitPos):Length()

		if Dist > 800 then return end

		local Ent = trace.Entity

		if not IsValid( Ent ) then return end

		if Ent:GetClass() ~= "lvs_vehicle_spammer" then return end

		local pos = Ent:GetPos()
		local scr = pos:ToScreen()
		local Alpha = 255

		if Ent:GetType() == "" then
			draw.SimpleText( "Hold C => Right Click on me => Edit Properties => Choose a Type", "LVS_FONT", scr.x, scr.y - 10, Color(255,255,255,Alpha), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		else
			if not Ent:GetMasterSwitch() then
				local Key = input.LookupBinding( "+use" )
				if not isstring( Key ) then Key = "+use is not bound to a key" end

				draw.SimpleText( "Now press ["..Key.."] to enable!", "LVS_FONT", scr.x, scr.y - 10, Color(255,255,255,Alpha), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				draw.SimpleText( "or hold ["..Key.."] to enable globally!", "LVS_FONT", scr.x, scr.y + 10, Color(255,255,255,Alpha), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			else
				TutorialDone = true
			end
		end
	end )
end
--PATH lua/entities/lvs_vwing_advanced/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Alpha-3 Nimbus-Class V-Wing Starfighter"
ENT.Author = "Dec"
ENT.Information = "Starfighter of the Galactic Republic"
ENT.Category = "[LVS] SW-Vehicles"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Starfighters"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/vanilla/vwing/vwing_landed.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.TurnRatePitch = 1.5
ENT.TurnRateYaw = 1.5
ENT.TurnRateRoll = 1.5


ENT.AITEAM = 2

ENT.MaxHealth = 1000
ENT.MaxShield = 600

ENT.MaxVelocity = 2850
ENT.MaxThrust = 2850

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3


ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.FlyByAdvance = 0.6
ENT.FlyBySound = "lvs/vehicles/vwing/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 3000
	weapon.Delay = 0.07
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.7
	weapon.Attack = function( ent )

		if not ent:GetFoils() then
			ent:SetHeat(ent:GetHeat() + 0.6 )
		end

		local pod = ent:GetDriverSeat()
		if not IsValid( pod ) then return end

		local fP = {Vector(40,68,-13.5),Vector(40,-68,-23.5),Vector(40,68,-13.5),Vector(40,-68,-23.5)}

		self.NumPrim = self.NumPrim and self.NumPrim + 1 or 1
		if self.NumPrim > 4 then self.NumPrim = 1 end

		local Driver = self:GetDriver()

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld(fP[self.NumPrim])
		bullet.Dir 	= self:GetForward()
		bullet.Spread 	= Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 80
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		self:EmitSound( "VANILLA_VWING_FIRE" )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")

		if ent.SetFoils then ent:SetFoils( true ) end
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 3
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )

		if not ent:GetFoils() then
			ent:SetHeat( ent:GetHeat() + 1 )
		end
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		local Driver = self:GetDriver()

		local fP = {Vector(40,68,-13.5),Vector(40,-68,-23.5),Vector(40,68,-13.5),Vector(40,-68,-23.5)}

		self.NumPrim = self.NumPrim and self.NumPrim + 1 or 1
		if self.NumPrim > 4 then self.NumPrim = 1 end

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( self:LocalToWorld(fP[self.NumPrim]) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:SetDamage(1200)
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/nos.png")
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.1
	weapon.UseableByAI = false
	weapon.Attack = function( ent )
		if ent:GetFoils() == false then return end
		local PhysObj = ent:GetPhysicsObject()
		if not IsValid( PhysObj ) then return end
		local THR = ent:GetThrottle()
		local FT = FrameTime()

		local Vel = ent:GetVelocity():Length()

		PhysObj:ApplyForceCenter( ent:GetForward() * math.Clamp(ent.MaxVelocity + 500 - Vel,0,1) * PhysObj:GetMass() * THR * FT * 150 ) -- increase speed
		PhysObj:AddAngleVelocity( PhysObj:GetAngleVelocity() * FT * 0.5 * THR ) -- increase turn rate
	end
	weapon.StartAttack = function( ent )
		ent.TargetThrottle = 1.3
		ent:EmitSound("lvs/vehicles/generic/boost.wav")
	end
	weapon.FinishAttack = function( ent )
		ent.TargetThrottle = 1
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("buttons/lever5.wav")
	end
	weapon.OnThink = function( ent, active )
		
		if not ent.TargetThrottle then return end

		local Rate = FrameTime() * 0.5

		ent:SetMaxThrottle( ent:GetMaxThrottle() + math.Clamp(ent.TargetThrottle - ent:GetMaxThrottle(),-Rate,Rate) )

		local MaxThrottle = ent:GetMaxThrottle()

		ent:SetThrottle( MaxThrottle )

		if MaxThrottle == ent.TargetThrottle then
			ent.TargetThrottle = nil
		end
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat_boost.wav") end

	self:AddWeapon( weapon )
end



ENT.EngineSounds = {
	{
		sound = "VANILLA_VWING_ENGINE",
		sound_int = "lvs/vehicles/vwing/loop_interior.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 90,
	},
	{
		sound = "VANILLA_VWING_HUM",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 90,
	},
}

sound.Add( {
	name = "VANILLA_VWING_ENGINE",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 125,
	sound = "vanilla/vwing/vanilla_vwing_engine.wav"
} )

sound.Add( {
	name = "VANILLA_VWING_HUM",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 125,
	sound = "vanilla/vwing/vanilla_vwing_hum.wav"
} )

sound.Add( {
	name = "VANILLA_VWING_FIRE",
	channel = CHAN_WEAPON,
	volume = 0.8,
	level = 125,
	pitch = {95, 98},
	sound = "vanilla/vwing/vanilla_vwing_fire.wav"
} )
--PATH lua/entities/lvs_walker_atrt_flamethrower/shared.lua:

ENT.Base = "lvs_walker_atte_hoverscript"

ENT.PrintName = "AT-RT (Flamethrower)"
ENT.Author = "Luna, Foranox"
ENT.Information = "Assault Walker of the Galactic Republic"
ENT.Category = "[LVS] - The Outer Rim"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Walkers"

ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.MDL = "models/astartes/atrt/body.mdl"
ENT.GibModels = {
	"models/astartes/atrt/body.mdl",
	"models/astartes/atrt/leg2.mdl",
	"models/astartes/atrt/leg3.mdl",
	"models/astartes/atrt/leg0.mdl",
}

ENT.AITEAM = 2

ENT.MaxHealth = 2000

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.HoverHeight = 92
ENT.HoverTraceLength = 137
ENT.HoverHullRadius = 10

ENT.LAATC_PICKUPABLE = false
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-220,0,-200)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)


ENT.CanMoveOn = {
	["func_door"] = true,
	["func_movelinear"] = true,
	["prop_physics"] = true,
}

ENT.lvsShowInSpawner = true

function ENT:OnSetupDataTables()

	self:AddDT( "Float", "Move" )
	self:AddDT( "Bool", "FlashlightStatus" )
	self:AddDT( "Bool", "IsMoving" )
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Bool", "IsRagdoll" )
	self:AddDT( "Vector", "AIAimVector" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:ShootTurret(ent)
	local muzzle = self:GetAttachment( self:LookupAttachment( "turret" ) )

	if not muzzle then return end

	local AimAngles, AimPos, InRange = self:GetMainAimAngles()

	local Pos = muzzle.Pos
	local Dir = (AimPos - Pos):GetNormalized()

	if not InRange then return true end

	local bullet = {}
	bullet.Src 	= Pos
	bullet.Dir 	= Dir
	bullet.Spread 	= Vector( 0.01,  0.01, 0 )
	bullet.TracerName = "lvs_laser_blue_short"
	bullet.Force	= 10
	bullet.HullSize 	= 30
	bullet.Damage	= 80
	bullet.SplashDamage = 40
	bullet.SplashDamageRadius = 100
	bullet.Velocity = 8000
	bullet.Attacker 	= ent:GetDriver()
	bullet.Callback = function(att, tr, dmginfo)
		local effectdata = EffectData()
			effectdata:SetStart( Vector(50,50,255) ) 
			effectdata:SetOrigin( tr.HitPos )
			effectdata:SetNormal( tr.HitNormal )
		util.Effect( "lvs_laser_explosion", effectdata )
	end
	ent:LVSFireBullet( bullet )

	local effectdata = EffectData()
	effectdata:SetStart( Vector(50,50,250) )
	effectdata:SetOrigin( bullet.Src )
	effectdata:SetNormal( Dir )
	effectdata:SetEntity( ent )
	util.Effect( "lvs_muzzle_colorable", effectdata )

	ent:TakeAmmo()

	if not IsValid( ent.SNDPrimary ) then return end

	ent.SNDPrimary:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
end

function ENT:GetContraption()
	return {self}
end


function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( Vector(0,0,33) )
	end

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetAIAimVector()
	end

	local Driver = self:GetDriver()

	if IsValid( Driver ) then
		return Driver:GetAimVector()
	else
		return self:GetForward()
	end
end


function ENT:GetMainAimAngles()
	local trace = self:GetEyeTrace()
	
	--[[
	local Driver = self:GetDriver()
	if Driver:IsPlayer() then
		trace = Driver:GetEyeTrace()
	end ]]--


	local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,100)) ):GetNormalized():Angle() )

	local ID = self:LookupAttachment( "turret" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return AimAngles, trace.HitPos, false end

	local DirAng = self:WorldToLocalAngles( (trace.HitPos - self:GetDriverSeat():LocalToWorld( Vector(0,0,33) ) ):Angle() )

	return AimAngles, trace.HitPos, (math.abs( DirAng.p ) < 100) and math.abs( DirAng.y ) < 60
end


function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 1500
	weapon.Delay = .08
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.5
	weapon.HudPaint = function( ent, X, Y, ply )
		local AimAngles, AimPos, InRange = self:GetMainAimAngles()
		
		if InRange then 

			local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

			local base = ent:GetVehicle()
			base:PaintCrosshairCenter( Pos2D, Col )
			base:PaintCrosshairOuter( Pos2D, Col )
			base:LVSPaintHitMarker( Pos2D )
		end
	end
	weapon.Attack = function(ent)
		if ent:GetIsCarried() then return true end
		if self.Ammo == 0 then return false end

		local muzzle = self:GetAttachment( self:LookupAttachment( "turret" ) )
		if (not muzzle) then return end

		local AimAngles, AimPos, InRange = self:GetMainAimAngles()
		if (not InRange) then return end
		
		local trace = util.TraceLine( {
			start = muzzle.Pos,
			endpos = AimPos,
			filter = self:GetCrosshairFilterEnts()
		} )
		local distance = trace.HitPos:Distance(muzzle.Pos)

		local flameFx = EffectData()
		flameFx:SetOrigin(trace.HitPos)
		flameFx:SetStart(muzzle.Pos)
		-- flameFx:SetAttachment(1)
		flameFx:SetEntity(ent)
		util.Effect("atrt_flamethrower_flame", flameFx, true, true)
		self:EmitSound( "atrt/flamethrower_start.wav", 75, 105, 0.5 )
		ent:TakeAmmo()

		if (distance > 520) then return end

		local function ignite()
			if (not IsValid(ent)) then return end
			local flame = ents.Create("point_hurt")
			flame:SetPos(trace.HitPos)
			flame:SetOwner(self:GetDriver())
			flame:SetKeyValue("DamageRadius", 128)
			flame:SetKeyValue("Damage", 4)
			flame:SetKeyValue("DamageDelay", 0.32)
			flame:SetKeyValue("DamageType", DMG_BURN)
			flame:Spawn()

			flame:Fire("TurnOn", "", 0)
			flame:Fire("kill", "", 0.72)

			if (trace.HitWorld) then
				local nearby = ents.FindInSphere(trace.HitPos, 100)

				for _, target in ipairs(nearby) do
					if (target == self:GetDriver()) then continue end
					if (not target:IsNPC() and not target:IsPlayer() and not target:IsOnFire()) then
						target:Ignite(math.random(16, 32), 100)
					end
					if (target:IsPlayer() and target:GetPhysicsObject():IsValid()) then
						target:Ignite(1, 100)
					end
					if (target:IsNPC() and target:GetPhysicsObject():IsValid()) then
							target:Ignite(math.random(12, 16), 100)
					end
				end
			elseif (trace.Entity and IsValid(trace.Entity)) then
				local target = trace.Entity

				if (target:GetPhysicsObject():IsValid()) then
					if (not target:IsNPC() and not target:IsPlayer() and not target:IsOnFire()) then
						target:Ignite(math.random(16, 32), 100)
					elseif (target:IsPlayer()) then
						target:Ignite(math.random(1, 2), 100)
					elseif (target:IsNPC()) then
							target:Ignite(math.random(12, 16), 100)
					end
				end
			end

			if (SERVER) then
				local fireFx = EffectData()
				fireFx:SetOrigin(trace.HitPos)
				util.Effect("atrt_flamethrower_explosion", fireFx)
			end
		end
		timer.Simple(distance / 1520, ignite)
	end

	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()
		if IsValid( base ) and base:GetIsCarried() then return end

		local AimAngles = ent:GetMainAimAngles()

		local p = math.Clamp(AimAngles.p, -25, 35)
		local y = math.Clamp(AimAngles.y, -78, 78)

		ent:ManipulateBoneAngles(2, Angle(0,0,p))
		ent:ManipulateBoneAngles(1, Angle(y,0,0))
	end

	self:AddWeapon( weapon )

	
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/light.png")
	weapon.Ammo = -1
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		if self:GetFlashlightStatus(false) then
			self:SetFlashlightStatus(false)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		else
			self:SetFlashlightStatus(true)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		end
	end
	self:AddWeapon( weapon )
end

--PATH lua/entities/lvs_walker_atrt_rotary/cl_ikfunctions.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atrt_rotary/cl_camera.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atrt_standart/cl_camera.lua:

function ENT:CalcViewDriver( ply, pos, angles, fov, pod )
	if pod:GetThirdPersonMode() then
			local view = {}
			view.origin = pos
			view.angles = angles
			view.fov = fov
			view.drawviewer = true
	
		local mn = self:OBBMins()
		local mx = self:OBBMaxs()
		local radius = ( mn - mx ):Length()
		local radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )

		local StartPos = self:LocalToWorld( self:OBBCenter() ) + clamped_angles:Up() * 40
		local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * (radius * 0.2 + radius * pod:GetCameraHeight())

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.angles = angles + Angle(5,0,0)
		view.origin = tr.HitPos
		view.drawviewer = true

		if tr.Hit and  not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
end

function ENT:LVSCalcView( ply, pos, angles, fov, pod )

	local view = {}
	view.origin = pos
	view.angles = angles
	view.fov = fov
	view.drawviewer = false
	--view.origin = self:LocalToWorld( Vector(0,0,0) )
		
	if pod:GetThirdPersonMode() then
		return self:CalcViewDriver( ply, pos, angles, fov, pod )
	else 
		return view
	end
end
--PATH lua/entities/lvs_walker_hsd/cl_camera.lua:

function ENT:CalcViewDriver( ply, pos, angles, fov, pod )
	local view = {}
	view.origin = pos
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	if not pod:GetThirdPersonMode() then return view end

	local mn = self:OBBMins()
	local mx = self:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local clamped_angles = pod:WorldToLocalAngles( angles )
	clamped_angles.p = math.max( clamped_angles.p, -20 )
	clamped_angles = pod:LocalToWorldAngles( clamped_angles )

	local StartPos = self:LocalToWorld( self:OBBCenter() ) + clamped_angles:Up() * 100
	local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * (radius * 0.2 + radius * pod:GetCameraHeight())

	local WallOffset = 4

	local tr = util.TraceHull( {
		start = StartPos,
		endpos = EndPos,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.angles = angles + Angle(5,0,0)
	view.origin = tr.HitPos
	view.drawviewer = true

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

function ENT:LVSCalcView( ply, pos, angles, fov, pod )
	if self:GetDriver() == ply then
		return self:CalcViewDriver( ply, pos, angles, fov, pod )
	end

	local view = {}
	view.origin = self:LocalToWorld( Vector(0,0,200) )
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	local mn = self:OBBMins()
	local mx = self:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local TargetOrigin = view.origin + ( view.angles:Forward() * -radius )
	local WallOffset = 4

	local tr = util.TraceHull( {
		start = view.origin,
		endpos = TargetOrigin,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.origin = tr.HitPos

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end
--PATH lua/entities/lvs_walker_hsd/sh_weapons.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atte/cl_ikfunctions.lua:

function ENT:OnRemoved()
	self:LegClearAll()
end

local debugred = Color(255,0,0,255)
local debugblue = Color(0,0,255,255)
local debuggreen = Color(0,255,0,255)

function ENT:LegClearAll()
	if istable( self.IK_Joints ) then 
		for _, tab in pairs( self.IK_Joints ) do
			for _,prop in pairs( tab ) do
				if IsValid( prop ) then
					prop:Remove()
				end
			end
		end
		
		self.IK_Joints = nil
	end
end

function ENT:GetLegEnts( index, L1, L2, JOINTANG, STARTPOS, ENDPOS, ATTACHMENTS )
	if not istable( self.IK_Joints ) then self.IK_Joints = {} end

	if self.IK_Joints[ index ] then
		if IsValid( self.IK_Joints[ index ].LegBaseRot ) and IsValid( self.IK_Joints[ index ].LegRotCalc ) then
			if (self.IK_Joints[ index ].LegBaseRot:GetPos() - STARTPOS):Length() > 1 or (self.IK_Joints[ index ].LegRotCalc:GetPos() - STARTPOS):Length() > 1 then
				for k, v in pairs( self.IK_Joints[ index ] ) do
					if IsValid( v ) then
						v:Remove()
					end
				end
				self.IK_Joints[ index ] = nil
			end
		end
	end

	if not self.IK_Joints[ index ] then
		self.IK_Joints[ index ] = {}

		local BaseProp = ents.CreateClientProp()
		BaseProp:SetPos( STARTPOS )
		BaseProp:SetAngles( JOINTANG )
		BaseProp:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		BaseProp:SetParent( self )
		BaseProp:Spawn()

		local LegRotCalc = ents.CreateClientProp()
		LegRotCalc:SetPos( STARTPOS )
		LegRotCalc:SetAngles( JOINTANG )
		LegRotCalc:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		LegRotCalc:SetParent( self )
		LegRotCalc:Spawn()

		local prop1 = ents.CreateClientProp()
		prop1:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 * 0.5) ) )
		prop1:SetAngles( JOINTANG )
		prop1:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop1:SetParent( self )
		prop1:Spawn()

		local prop2 = ents.CreateClientProp()
		prop2:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 + L2) ) )
		prop2:SetAngles( JOINTANG )
		prop2:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop2:SetParent( self )
		prop2:Spawn()

		local prop3 = ents.CreateClientProp()
		prop3:SetPos( STARTPOS )
		prop3:SetAngles( JOINTANG )
		prop3:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop3:SetParent( LegRotCalc )
		prop1:SetParent( prop3 )
		prop3:Spawn()

		local prop4 = ents.CreateClientProp()
		prop4:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1) ) )
		prop4:SetAngles( JOINTANG )
		prop4:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop4:SetParent( prop1 )
		prop2:SetParent( prop4 )
		prop4:Spawn()
		
		self.IK_Joints[ index ].LegBaseRot = BaseProp
		self.IK_Joints[ index ].LegRotCalc = LegRotCalc
		self.IK_Joints[ index ].LegEnt1 = prop1
		self.IK_Joints[ index ].LegEnt2 = prop2
		self.IK_Joints[ index ].LegEnt3 = prop3
		self.IK_Joints[ index ].LegEnt4 = prop4

		for _, v in pairs( self.IK_Joints[ index ] ) do
			v:SetColor( Color( 0, 0, 0, 0 ) )
			v:SetRenderMode( RENDERMODE_TRANSALPHA )
		end

		if ATTACHMENTS then
			if ATTACHMENTS.Leg1 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop3:LocalToWorld( ATTACHMENTS.Leg1.Pos ) )
				prop:SetAngles( prop3:LocalToWorldAngles( ATTACHMENTS.Leg1.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg1.MDL )
				prop:SetParent( prop3 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment1 = prop
			end
			if ATTACHMENTS.Leg2 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop4:LocalToWorld( ATTACHMENTS.Leg2.Pos ) )
				prop:SetAngles( prop4:LocalToWorldAngles( ATTACHMENTS.Leg2.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg2.MDL )
				prop:SetParent( prop4 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment2 = prop
			end
			if ATTACHMENTS.Foot then
				local prop = ents.CreateClientProp()
				prop:SetModel( ATTACHMENTS.Foot.MDL )
				prop:SetParent( prop2 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment3 = prop
			end
		end
	end

	if not IsValid( self.IK_Joints[ index ].LegRotCalc ) or not IsValid( self.IK_Joints[ index ].LegBaseRot ) or not IsValid( self.IK_Joints[ index ].LegEnt1 ) or not IsValid( self.IK_Joints[ index ].LegEnt2 ) or not IsValid( self.IK_Joints[ index ].LegEnt3 ) or not IsValid( self.IK_Joints[ index ].LegEnt4 ) then
		self:LegClearAll()

		return
	end

	self.IK_Joints[ index ].LegRotCalc:SetAngles(self.IK_Joints[ index ].LegBaseRot:LocalToWorldAngles( self.IK_Joints[ index ].LegBaseRot:WorldToLocal( ENDPOS ):Angle() ) )

	local LegRotCalcPos = self.IK_Joints[ index ].LegRotCalc:GetPos()

	local Dist = math.min( (LegRotCalcPos - ENDPOS ):Length(), L1 + L2)
	local Angle1 = 90 - math.deg( math.acos( (Dist ^ 2 + L1 ^ 2 - L2 ^ 2) / (2 * Dist * L1) ) )
	local Angle2 = math.deg( math.acos( (Dist ^ 2 + L2 ^ 2 - L1 ^ 2) / (2 * Dist * L2) ) ) + 90

	self.IK_Joints[ index ].LegEnt3:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle1,180,180) ) )
	self.IK_Joints[ index ].LegEnt4:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle2,180,180) ) )

	if self.IK_Joints[ index ].Attachment3 then
		self.IK_Joints[ index ].Attachment3:SetAngles( self:LocalToWorldAngles( ATTACHMENTS.Foot.Ang ) )
		self.IK_Joints[ index ].Attachment3:SetPos(self.IK_Joints[ index ].LegEnt2:GetPos() + self:GetForward() * ATTACHMENTS.Foot.Pos.x  + self:GetRight() * ATTACHMENTS.Foot.Pos.y + self:GetUp() * ATTACHMENTS.Foot.Pos.z )
	end


	--debug code
	local RFT = RealFrameTime()
	debugoverlay.Cross( self.IK_Joints[ index ].LegBaseRot:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegRotCalc:GetPos(), self.IK_Joints[ index ].LegEnt4:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt4:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegEnt4:GetPos(), self.IK_Joints[ index ].LegEnt2:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt2:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt1:GetPos(), 4, RFT, debugblue, true )
	debugoverlay.Sphere( self.IK_Joints[ index ].LegEnt3:GetPos(), 10, RFT, debugblue, true )
end

--PATH lua/entities/mediaplayer_base/shared.lua:
return gluapack()()
--PATH lua/entities/mk1.lua:
AddCSLuaFile()

if SERVER then
	resource.AddFile( "materials/entities/jetpack2.png" )
end

DEFINE_BASECLASS( "jetpack_base" )

ENT.Spawnable = false
ENT.PrintName = "Jetpack"

if CLIENT then
	ENT.MatHeatWave		= Material( "sprites/heatwave" )
	ENT.MatFire			= Material( "effects/fire_cloud1" )


	AccessorFunc( ENT , "NextParticle" , "NextParticle" )
	AccessorFunc( ENT , "LastActive" , "LastActive" )
	AccessorFunc( ENT , "LastFlameTrace" , "LastFlameTrace" )
	AccessorFunc( ENT , "NextFlameTrace" , "NextFlameTrace" )

	ENT.MaxEffectsSize = 0.25
	ENT.MinEffectsSize = 0.1



	ENT.JetpackFireBlue = Color( 0 , 0 , 255 , 128 )
	ENT.JetpackFireWhite = Color( 255 , 255 , 255 , 128 )
	ENT.JetpackFireNone = Color( 255 , 255 , 255 , 0 )
	ENT.JetpackFireRed = Color( 255 , 128 , 128 , 255 )

else

	ENT.StandaloneApeShitAngular = Vector( 0 , 10 , 10 )	--do a corkscrew
	ENT.StandaloneApeShitLinear = Vector( 0 , 0 , 0 )

	ENT.StandaloneAngular = vector_origin
	ENT.StandaloneLinear = Vector( 0 , 0 , 0 )

	ENT.ShowPickupNotice = true
	ENT.SpawnOnGroundConVar = CreateConVar(
		"sv_spawnjetpackonground" ,
		"0",
		{
			FCVAR_SERVER_CAN_EXECUTE,
			FCVAR_ARCHIVE
		},
		"When true, it will spawn the jetpack on the ground, otherwise it will try equipping it right away, if you already have one equipped it will not do anything"
	)
end

--use this to calculate the position on the parent because I can't be arsed to deal with source's parenting bullshit with local angles and position
--plus this is also called during that parenting position recompute, so it's perfect

ENT.AttachmentInfo = {
	BoneName = "ValveBiped.Bip01_Spine2",
	OffsetVec = Vector( 9 , -6 , -0.2 ),
	OffsetAng = Angle( 180 , 90 , -91 ),
}

sound.Add( {
	name = "jetpack.thruster_loop",
	channel = CHAN_ITEM,
	volume = 1.0,
	level = 75,
	sound = "^thrusters/jet02.wav"
})

local sv_gravity = GetConVar "sv_gravity"

function ENT:SpawnFunction( ply, tr, ClassName )

	if not tr.Hit then return end

	local SpawnPos = tr.HitPos + tr.HitNormal * 36

	local ent = ents.Create( ClassName )
	ent:SetSlotName( ClassName )	--this is the best place to set the slot, only modify it ingame when it's not equipped
	ent:SetPos( SpawnPos )
	ent:SetAngles( Angle( 90 , 0 , 0 ) )
	ent:Spawn()

	--try equipping it, if we can't we'll just remove it
	if not self.SpawnOnGroundConVar:GetBool() then
		--forced should not be set here, as we still kinda want the equip logic to work as normal
		if not ent:Attach( ply , false ) then
			ent:Remove()
			return
		end
	end

	return ent

end

function ENT:Initialize()
	BaseClass.Initialize( self )
	if SERVER then
		self:SetModel( "models/jetpack/jetpack.mdl" )
		self:InitPhysics()

		self:SetMaxHealth( 100 )
		self:SetHealth( self:GetMaxHealth() )

		self:SetInfiniteFuel( false )
		self:SetMaxFuel(100)
		self:SetFuel( self:GetMaxFuel() )
		self:SetFuelDrain(12)	--drain in seconds
		self:SetFuelRecharge( 17 )	--recharge in seconds
		self:SetActive( false )
		self:SetCanStomp( false )
		self:SetDoGroundSlam( false )
		self:SetAirResistance( 3.5 )
		self:SetRemoveGravity( true )
		self:SetJetpackSpeed( 2500 )
		self:SetJetpackStrafeSpeed( 600 )
		self:SetJetpackVelocity( 900 )
		self:SetJetpackStrafeVelocity( 5000 )
	else
		self:SetLastActive( false )
		self:SetNextParticle( 0 )
		self:SetNextFlameTrace( 0 )
		self:SetLastFlameTrace( nil )
	end
end

function ENT:SetupDataTables()
	BaseClass.SetupDataTables( self )

	self:DefineNWVar( "Bool" , "Active" )
	self:DefineNWVar( "Bool" , "GoneApeshit" , true )	--set either when the owner dies with us active, or when we're being shot at
	self:DefineNWVar( "Bool" , "RemoveGravity" )
	self:DefineNWVar( "Bool" , "InfiniteFuel" , true , "Infinite Fuel" )
	self:DefineNWVar( "Bool" , "DoGroundSlam" )
	self:DefineNWVar( "Bool" , "CanStomp" , true , "Can stomp" )

	self:DefineNWVar( "Float" , "Fuel" )
	self:DefineNWVar( "Float" , "MaxFuel" )	--don't modify the max amount, the drain scales anyway, set to -1 to disable the fuel drain
	self:DefineNWVar( "Float" , "FuelDrain" , true , "Seconds to drain fuel" , 1 , 60 ) --how many seconds it's gonna take to drain all the fuel
	self:DefineNWVar( "Float" , "FuelRecharge" , true , "Seconds to recharge the fuel" , 1 , 60 ) --how many seconds it should take to fully recharge this
	self:DefineNWVar( "Float" , "AirResistance" , true , "Air Resistance" , 0 , 10 )
	self:DefineNWVar( "Float" , "GoneApeshitTime" ) --only used if infinite fuel is on

	self:DefineNWVar( "Int" , "Key" )	--override it to disallow people from editing the key since it's unused
	self:DefineNWVar( "Int" , "JetpackSpeed" , true , "Jetpack idle upward speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackStrafeSpeed" , true , "Jetpack idle side speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackVelocity" , true , "Jetpack active upward speed" , 1 , 3000 )
	self:DefineNWVar( "Int" , "JetpackStrafeVelocity" , true , "Jetpack active side speed" , 1 , 3000 )

end

function ENT:HandleFly( predicted , owner , movedata , usercmd )
	self:SetActive( self:CanFly( owner , movedata ) )

	--we have infinite fuel and the apeshit timeout hasn't been set, do it now
	--this is most useful because I CBA to do that everytime ok?
	--also it's serverside only because we only set the apeshit on the server anyway

	if SERVER then
		if self:GetGoneApeshit() and self:GetGoneApeshitTime() == 0 and self:GetInfiniteFuel() then
			self:SetGoneApeshitTime( CurTime() + 5 )
		end
	end

	--the check below has to be done with prediction on the client!

	if CLIENT and not predicted then
		return
	end

	--fixes a bug where if you set goneapeshit manually via the contextmenu and the physobj is asleep it wouldn't apply the simulated forces
	if SERVER and not predicted and self:GetGoneApeshit() then
		local physobj = self:GetPhysicsObject()
		if IsValid( physobj ) and physobj:IsAsleep() then
			physobj:Wake()
		end
	end

	--if we have an apeshit timeout, calm us down ( this doesn't check for infinite fuel, in case we did this manually )
	if self:GetGoneApeshit() and self:GetGoneApeshitTime() ~= 0 and self:GetGoneApeshitTime() <= CurTime() then
		self:SetGoneApeshit( false )
		self:SetGoneApeshitTime( 0 )
	end
end

function ENT:HandleFuel( predicted )

	--like with normal rules of prediction, we don't want to run on the client if we're not in the simulation

	if not predicted and CLIENT then
		return
	end

	--we set the think rate on the entity to the tickrate on the server, we could've done NextThink() - CurTime(), but it's only a setter, not a getter
	local ft = engine.TickInterval()

	--screw that, during prediction we need to recharge with FrameTime()
	if predicted then
		ft = FrameTime()
	end

	local fueltime = self:GetActive() and self:GetFuelDrain() or self:GetFuelRecharge()

	local fuelrate = self:GetMaxFuel() / ( fueltime / ft )

	if self:GetActive() then
		fuelrate = fuelrate * -1

		if self:GetGoneApeshit() then
			--drain twice as much fuel if we're going craaaazy
			fuelrate = fuelrate * 2
		end

		--don't drain any fuel when infinite fuel is on, but still allow recharge
		if self:GetInfiniteFuel() then
			fuelrate = 0
		end
	else
		--recharge in different ways if we have an owner or not, because players might drop and reequip the jetpack to exploit the recharging
		if IsValid( self:GetControllingPlayer() ) then
			--can't recharge until our owner is on the ground!
			--prevents the player from tapping the jump button to fly and recharge at the same time
			if not self:GetControllingPlayer():OnGround() then
				fuelrate = 0
			end
		else
			--only recharge if our physobj is sleeping and it's valid ( should never be invalid in the first place )
			local physobj = self:GetPhysicsObject()
			if not IsValid( physobj ) or not physobj:IsAsleep() then
				fuelrate = 0
			end
		end
	end

	--holy shit, optimization??
	if fuelrate ~= 0 then
		self:SetFuel( math.Clamp( self:GetFuel() + fuelrate , 0 , self:GetMaxFuel() ) )
	end

	--we exhausted all of our fuel, chill out if we're crazy
	if not self:HasFuel() and self:GetGoneApeshit() then
		self:SetGoneApeshit( false )
	end
end

function ENT:HandleLoopingSounds()

	--create the soundpatch if it doesn't exist, it might happen on the client sometimes since it's garbage collected

	if not self.JetpackSound then
		self.JetpackSound = CreateSound( self, "jetpack.thruster_loop" )
	end

	if self:GetActive() then
		local pitch = 125

		if self:GetGoneApeshit() then
			pitch = 175
		end

		self.JetpackSound:PlayEx( 0.5  , pitch )
	else
		self.JetpackSound:FadeOut( 0.1 )
	end
end

function ENT:HasFuel()
	return self:GetFuel() > 0
end

function ENT:GetFuelFraction()
	return self:GetFuel() / self:GetMaxFuel()
end

function ENT:CanFly( owner , mv )


	if IsValid( owner ) then

		--don't care about player inputs in this case, the player's jetpack is going craaazy

		if self:GetGoneApeshit() then
			return owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and self:HasFuel()
		end

		return ( mv:KeyDown( IN_JUMP ) or mv:KeyDown( IN_DUCK ) or mv:KeyDown( IN_SPEED ) ) and not owner:OnGround() and owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and owner:Alive() and self:HasFuel()
	end

	--making it so the jetpack can also fly on its own without an owner ( in the case we want it go go nuts if the player dies or some shit )
	if self:GetGoneApeshit() then
		return self:WaterLevel() == 0 and self:HasFuel()
	end

	return false
end

function ENT:Think()

	--still act if we're not being held by a player
	if not self:IsCarried() then
		self:HandleFly( false )
		self:HandleFuel( false )
	end

	--animation related stuff should be fine to call here



	return BaseClass.Think( self )
end

function ENT:PredictedSetupMove( owner , mv , usercmd )

	self:HandleFly( true , owner , mv , usercmd )
	self:HandleFuel( true )

	if self:GetActive() then

		local vel = mv:GetVelocity()

		if mv:KeyDown( IN_JUMP ) and vel.z < self:GetJetpackSpeed() then

			-- Apply constant jetpack_velocity

			vel.z = vel.z + self:GetJetpackVelocity() * FrameTime()

		elseif mv:KeyDown( IN_SPEED ) and vel.z < 0 then

			-- Apply just the right amount of thrust

			vel.z = math.Approach( vel.z , 0 , self:GetJetpackVelocity() * FrameTime() )

		end



		-- Quickly descend to do a ground slam, don't check for the velocity cap, we want to slam down as fast as we can
		if self:GetCanStomp() then
			self:SetDoGroundSlam( mv:KeyDown( IN_DUCK ) )
		end

		--even if the user can't stomp, we still allow him to go down by crouching

		if mv:KeyDown( IN_DUCK ) then
			vel.z = vel.z - self:GetJetpackVelocity() * FrameTime()
		end

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--

		if vel.z == 0 then

			self:SetRemoveGravity( true )

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

		end

		--
		-- Apply movement velocity
		--

		local move_vel = Vector( 0, 0, 0 )

		local ang = mv:GetMoveAngles()
		ang.p = 0

		move_vel:Add( ang:Right() * mv:GetSideSpeed() )
		move_vel:Add( ang:Forward() * mv:GetForwardSpeed() )

		move_vel:Normalize()
		move_vel:Mul( self:GetJetpackStrafeVelocity() * FrameTime() )

		if vel:Length2D() < self:GetJetpackStrafeSpeed() then

			vel:Add( move_vel )

		end

		--TODO: goneapeshit stuff, do it before air resistance

		if self:GetGoneApeshit() then
			--boost us in the direction the jetpack is facing in the world ( actual third person angles )
			--ragdolling the user and attaching us to the ragdoll would be quite expensive and wouldn't be worth it
			--as cool as that might look, that might also break stuff in other gamemodes

			local addvel = self:GetAngles():Up() * -1 * self:GetJetpackVelocity() * FrameTime()
			vel:Add( addvel )
		end

		--
		-- Apply air resistance
		--
		vel.x = math.Approach( vel.x, 0, FrameTime() * self:GetAirResistance() * vel.x )
		vel.y = math.Approach( vel.y, 0, FrameTime() * self:GetAirResistance() * vel.y )

		--
		-- Write our calculated velocity back to the CMoveData structure
		--
		mv:SetVelocity( vel )

		mv:SetForwardSpeed( 0 )
		mv:SetSideSpeed( 0 )
		mv:SetUpSpeed( 0 )

		-- Removes the crouch button from the movedata, effectively disabling the crouching behaviour

		mv:SetButtons( bit.band( mv:GetButtons(), bit.bnot( IN_DUCK ) ) )

	end
end

function ENT:PredictedThink( owner , movedata )
end

function ENT:PredictedMove( owner , data )
	if self:GetActive() and self:GetGoneApeshit() then
		owner:SetGroundEntity( NULL )
	end
end

function ENT:PredictedFinishMove( owner , movedata )
	if self:GetActive() then

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--
		if self:GetRemoveGravity() then
			local vel = movedata:GetVelocity()

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

			movedata:SetVelocity( vel )

			self:SetRemoveGravity( false )
		end

	end
end

local	SF_PHYSEXPLOSION_NODAMAGE			=	0x0001
local	SF_PHYSEXPLOSION_PUSH_PLAYER		=	0x0002
local	SF_PHYSEXPLOSION_RADIAL				=	0x0004
local	SF_PHYSEXPLOSION_TEST_LOS			=	0x0008
local	SF_PHYSEXPLOSION_DISORIENT_PLAYER	=	0x0010

function ENT:PredictedHitGround( ply , inwater , onfloater , speed )

	local dogroundslam = self:GetDoGroundSlam()
	self:SetDoGroundSlam( false )

	if dogroundslam and speed > 500 then

		self:EmitPESound( "Player.FallDamage" , nil , nil , nil , nil , true )
		--ply:EmitSound( "Player.FallDamage" )
		--self:EmitPESound( "" , nil , nil , nil , nil , true )	--find the sound smod uses when the player hits the ground in smod

		local fraction = self:GetJetpackStrafeVelocity() / speed	--because the fall speed might be higher than the jetpack one

		local effect = EffectData()
		effect:SetEntity( ply )
		effect:SetOrigin( ply:WorldSpaceCenter() )	--apparently the player is considered in the ground in this hook and stuff doesn't spawn
		effect:SetScale( 128 )
		util.Effect( "ThumperDust" , effect , true )	--todo, make our own effect where the particles start from the player and expand in a circle
														--can even copy the code from c_thumper_dust
		if SERVER then
			--TODO: get the code from the sdk and replicate this on my own
			ply:LagCompensation( true )

			--[[
			local physexpl = ents.Create( "env_physexplosion" )

			if IsValid( physexpl ) then
				physexpl:SetPos( ply:WorldSpaceCenter() )
				physexpl:SetKeyValue( "spawnflags" , bit.bor( SF_PHYSEXPLOSION_NODAMAGE , SF_PHYSEXPLOSION_RADIAL , SF_PHYSEXPLOSION_TEST_LOS ) )
				physexpl:SetKeyValue( "magnitude" , 500 * fraction )
				physexpl:SetKeyValue( "radius" , 250 )
				physexpl:Spawn()
				physexpl:Fire( "Explode" , "" , 0 )
				physexpl:Fire( "Kill" , "" , 0.1 )
			end
			]]



			--this is kind of shit but it's needed to make prediction actually work properly on this screenshake shit
			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( ply )
			end

			util.ScreenShake( self:GetPos() , 1.5 , 250 , 1 , 500 )

			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( NULL )
			end

			ply:LagCompensation( false )
		end

		ply:AnimRestartGesture( GESTURE_SLOT_JUMP, ACT_LAND, true )
		return true	--override the fall damage and other hooks
	end
end

if SERVER then

	function ENT:OnTakeDamage( dmginfo )
		--we're already dead , might happen if multiple jetpacks explode at the same time
		if self:Health() <= 0 then
			return
		end

		self:TakePhysicsDamage( dmginfo )

		local oldhealth = self:Health()

		local newhealth = math.Clamp( self:Health() - dmginfo:GetDamage() , 0 , self:GetMaxHealth() )
		self:SetHealth( newhealth )

		if self:Health() <= 0 then
			--maybe something is relaying damage to the jetpack instead, an explosion maybe?
			if IsValid( self:GetControllingPlayer() ) then
				self:Remove( true )
			end
			self:Detonate( dmginfo:GetAttacker() )
			return
		end

		--roll a random, if we're not being held by a player and the random succeeds, go apeshit
		if dmginfo:GetDamage() > 3 and not self:GetGoneApeshit() then
			local rand = math.random( 1 , 10 )
			if rand <= 2 then
				if IsValid( self:GetControllingPlayer() ) then
					self:Remove( true )
				end
				self:SetGoneApeshit( true )
			end
		end
	end

	function ENT:OnAttach( ply )
		self:SetDoGroundSlam( false )
		--self:SetSolid( SOLID_BBOX )	--we can still be hit when on the player's back
	end

	function ENT:CanAttach( ply )
		if self:GetGoneApeshit() then
			return false
		end
	end

	function ENT:OnDrop( ply , forced )
		if IsValid( ply ) and not ply:Alive() then
			--when the player dies while still using us, keep us active and let us fly with physics until
			--our fuel runs out
			if self:GetActive() then
				self:SetGoneApeshit( true )
			end
		else
			self:SetActive( false )
		end

	end

	function ENT:OnInitPhysics( physobj )
		if IsValid( physobj ) then
			physobj:SetMass( 75 )
			self:StartMotionController()
		end
		self:SetCollisionGroup( COLLISION_GROUP_NONE )
		--self:SetCollisionGroup( COLLISION_GROUP_WEAPON )	--set to COLLISION_GROUP_NONE to reenable collisions against players and npcs
	end

	function ENT:OnRemovePhysics( physobj )
		self:StopMotionController()
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS_TRIGGER )
		--self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
	end

	function ENT:PhysicsSimulate( physobj , delta )

		--no point in applying forces and stuff if something is holding our physobj

		if self:GetActive() and not self:GetBeingHeld() then
			physobj:Wake()
			local force = self.StandaloneLinear
			local angular = self.StandaloneAngular

			if self:GetGoneApeshit() then
				force = self.StandaloneApeShitLinear
				angular = self.StandaloneApeShitAngular
			end

			--yes I know we're technically modifying the variable stored in ENT.StandaloneApeShitLinear and that it might fuck up other jetpacks
			--but it won't because we're simply using it as a cached vector_origin and overriding the z anyway
			force.z = -self:GetJetpackVelocity()

			return angular * physobj:GetMass() , force * physobj:GetMass() , SIM_LOCAL_FORCE
		end
	end

	function ENT:PhysicsCollide( data , physobj )
		--taken straight from valve's code, it's needed since garry overwrote VPhysicsCollision, friction sound is still there though
		--because he didn't override the VPhysicsFriction
		if data.DeltaTime >= 0.05 and data.Speed >= 70 then
			local volume = data.Speed * data.Speed * ( 1 / ( 320 * 320 ) )
			if volume > 1 then
				volume = 1
			end

			--TODO: find a better impact sound for this model
			self:EmitSound( "SolidMetal.ImpactHard" , nil , nil , volume , CHAN_BODY )
		end

		if self:CheckDetonate( data , physobj ) then
			self:Detonate()
		end
	end

	--can't explode on impact if we're not active
	function ENT:CheckDetonate( data , physobj )
		return self:GetActive() and data.Speed > 500 and not self:GetBeingHeld()
	end

	function ENT:Detonate( attacker )
		--you never know!
		if self:IsEFlagSet( EFL_KILLME ) then
			return
		end

		self:Remove()

		local fuel = self:GetFuel()
		local atk = IsValid( attacker ) and attacker or self

		--check how much fuel was left when we impacted
		local dmg = 1.5 * fuel
		local radius = 2.5 * fuel

		util.BlastDamage( self , atk , self:GetPos() , radius , dmg )
		util.ScreenShake( self:GetPos() , 1.5 , dmg , 0.25 , radius * 2 )

		local effect = EffectData()
		effect:SetOrigin( self:GetPos() )
		effect:SetMagnitude( dmg )	--this is actually the force of the explosion
		effect:SetFlags( bit.bor( 0x80 , 0x20 ) ) --NOFIREBALLSMOKE, ROTATE
		util.Effect( "Explosion" , effect )
	end



else

	function ENT:Draw( flags )
		if GetViewEntity() == self:GetOwner() and !self:GetOwner():ShouldDrawLocalPlayer() then return end
		local pos , ang = self:GetCustomParentOrigin()

		--even though the calcabsoluteposition hook should already prevent this, it doesn't on other players
		--might as well not give it the benefit of the doubt in the first place
		if pos and ang then
			self:SetPos( pos )
			self:SetAngles( ang )
			self:SetupBones()
		end

		self:DrawModel( flags )

		local atchpos , atchang = self:GetEffectsOffset()

		local effectsscale = self:GetEffectsScale()

		--technically we shouldn't draw the fire from here, it should be done in drawtranslucent
		--but since we draw from the player and he's not translucent this won't get called despite us being translucent
		--might as well just set us to opaque

		if self:GetActive() then	-- and bit.band( flags , STUDIO_TRANSPARENCY ) ~= 0 then
			self:DrawJetpackFire( atchpos , atchang , effectsscale )
		end

		self:DrawJetpackSmoke( atchpos  , atchang , effectsscale )
	end

	--the less fuel we have, the smaller our particles will be
	function ENT:GetEffectsScale()
		return Lerp( self:GetFuel() / self:GetMaxFuel() , self.MinEffectsSize , self.MaxEffectsSize )
	end

	function ENT:GetEffectsOffset()
		local angup = self:GetAngles():Up()
		return self:GetPos() + angup * 5, angup
	end


	end



	--copied straight from the thruster code
	function ENT:DrawJetpackFire( pos , normal , scale )
		local scroll = 1000 + UnPredictedCurTime() * -10

		--the trace makes sure that the light or the flame don't end up inside walls
		--although it should be cached somehow, and only do the trace every tick

		local tracelength = 148 * scale


		if self:GetNextFlameTrace() < UnPredictedCurTime() or not self:GetLastFlameTrace() then
			local tr = {
				start = pos,
				endpos = pos + normal * tracelength,
				mask = MASK_OPAQUE,
				filter = {
					self:GetControllingPlayer(),
					self
				},
			}

			self:SetLastFlameTrace( util.TraceLine( tr ) )
			self:SetNextFlameTrace( UnPredictedCurTime() +  engine.TickInterval() )
		end

		local traceresult = self:GetLastFlameTrace()

		--what
		if not traceresult then
			return
		end

		-- traceresult.Fraction * ( 60 * scale ) / tracelength


		--TODO: fix the middle segment not being proportional to the tracelength ( and Fraction )

		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 32 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()


		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 100 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 40 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()

		scroll = scroll * 0.5

		render.UpdateRefractTexture()
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 32 * scale, 32 * scale , scroll + 2, color_white )
			render.AddBeam( traceresult.HitPos, 48 * scale , scroll + 5, self.JetpackFireNone )
		render.EndBeam()


		scroll = scroll * 1.3
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos , 8 * scale , scroll, self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 16 * scale , scroll + 1 , self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 16 * scale , scroll + 3 , self.JetpackFireNone )
		render.EndBeam()

		local light = DynamicLight( self:EntIndex() )

		if not light then
			return
		end

		light.Pos = traceresult.HitPos
		light.r = self.JetpackFireRed.r
		light.g = self.JetpackFireRed.g
		light.b = self.JetpackFireRed.b
		light.Brightness = 3
		light.Dir = normal
		light.InnerAngle = -45 --light entities in a cone
		light.OuterAngle = 45 --
		light.Size = 250 * scale -- 125 when the scale is 0.25
		light.Style = 1	--this should do the flicker for us
		light.Decay = 1000
		light.DieTime = UnPredictedCurTime() + 1
	end

	function ENT:DrawJetpackSmoke( pos , normal , scale )

		if not self.JetpackParticleEmitter then
			local emittr = ParticleEmitter( pos )
			if not emittr then
				return
			end
			self.JetpackParticleEmitter = emittr
		end

		--to prevent the smoke from drawing inside of the player when he's looking at a mirror, draw it manually if he's the local player
		--this behaviour is disabled if he's not the one actually using the jetpack ( this also happens when the jetpack is dropped and flies off )

		local particlenodraw = self:IsCarriedByLocalPlayer( true )

		self.JetpackParticleEmitter:SetNoDraw( particlenodraw )

		if self:GetNextParticle() < UnPredictedCurTime() and self:GetActive() then
			local particle = self.JetpackParticleEmitter:Add( "particle/particle_noisesphere", pos )
			if particle then
				--only increase the time on a successful particle
				self:SetNextParticle( UnPredictedCurTime() + 0.01 )
				particle:SetLighting( true )
				particle:SetCollide( true )
				particle:SetBounce( 0.25 )
				particle:SetVelocity( normal * self:GetJetpackSpeed() )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( 15 )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( 16 * scale )
				particle:SetEndSize( 64 * scale )
				particle:SetRoll( math.Rand( -10 , 10  ) )
				particle:SetRollDelta( math.Rand( -0.2 , 0.2 ) )
				particle:SetColor( 255 , 255 , 255 )
			end
		end

		if particlenodraw then
			self.JetpackParticleEmitter:Draw()
		end
	end



function ENT:HandleMainActivityOverride( ply , velocity )
	if self:GetActive() then
		local vel2d = velocity:Length2D()
		local idealact = ACT_INVALID

		if IsValid( ply:GetActiveWeapon() ) then
			idealact = ACT_MP_SWIM	--vel2d >= 10 and ACT_MP_SWIM or ACT_MP_SWIM_IDLE
		else
			idealact = ACT_HL2MP_IDLE + 9
		end

		if self:GetDoGroundSlam() then
			idealact = ACT_MP_CROUCH_IDLE
		end

		return idealact , ACT_INVALID
	end
end

function ENT:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed )
	if self:GetActive() then
		ply:SetPlaybackRate( 0 )	--don't do the full swimming animation
		return true
	end
end

function ENT:OnRemove()

	if CLIENT then

		--if stopping the soundpatch doesn't work, stop the sound manually
		if self.JetpackSound then
			self.JetpackSound:Stop()
			self.JetpackSound = nil
		else
			self:StopSound( "jetpack.thruster_loop" )
		end


		if self.JetpackParticleEmitter then
			self.JetpackParticleEmitter:Finish()
			self.JetpackParticleEmitter = nil
		end
	end

	BaseClass.OnRemove( self )
end

--PATH lua/entities/mk2.lua:
return gluapack()()
--PATH lua/entities/mk5.lua:
AddCSLuaFile()

if SERVER then
	resource.AddFile( "materials/entities/jetpack2.png" )
end

DEFINE_BASECLASS( "jetpack_base" )

ENT.Spawnable = false
ENT.PrintName = "Jump Pack"

if CLIENT then
	ENT.MatHeatWave		= Material( "sprites/heatwave" )
	ENT.MatFire			= Material( "effects/fire_cloud1" )


	AccessorFunc( ENT , "NextParticle" , "NextParticle" )
	AccessorFunc( ENT , "LastActive" , "LastActive" )
	AccessorFunc( ENT , "LastFlameTrace" , "LastFlameTrace" )
	AccessorFunc( ENT , "NextFlameTrace" , "NextFlameTrace" )

	ENT.MaxEffectsSize = 0.25
	ENT.MinEffectsSize = 0.1



	ENT.JetpackFireBlue = Color( 0 , 0 , 255 , 128 )
	ENT.JetpackFireWhite = Color( 255 , 255 , 255 , 128 )
	ENT.JetpackFireNone = Color( 255 , 255 , 255 , 0 )
	ENT.JetpackFireRed = Color( 255 , 128 , 128 , 255 )

else

	ENT.StandaloneApeShitAngular = Vector( 0 , 10 , 10 )	--do a corkscrew
	ENT.StandaloneApeShitLinear = Vector( 0 , 0 , 0 )

	ENT.StandaloneAngular = vector_origin
	ENT.StandaloneLinear = Vector( 0 , 0 , 0 )

	ENT.ShowPickupNotice = true
	ENT.SpawnOnGroundConVar = CreateConVar(
		"sv_spawnjetpackonground" ,
		"0",
		{
			FCVAR_SERVER_CAN_EXECUTE,
			FCVAR_ARCHIVE
		},
		"When true, it will spawn the jetpack on the ground, otherwise it will try equipping it right away, if you already have one equipped it will not do anything"
	)
end

--use this to calculate the position on the parent because I can't be arsed to deal with source's parenting bullshit with local angles and position
--plus this is also called during that parenting position recompute, so it's perfect

ENT.AttachmentInfo = {
	BoneName = "ValveBiped.Bip01_Spine2",
	OffsetVec = Vector( 3.5 , -6 , -0.2 ),
	OffsetAng = Angle( 180 , 90 , -91 ),
}

sound.Add( {
	name = "jetpack.thruster_loop",
	channel = CHAN_ITEM,
	volume = 1.0,
	level = 75,
	sound = "^thrusters/jet02.wav"
})

local sv_gravity = GetConVar "sv_gravity"

function ENT:SpawnFunction( ply, tr, ClassName )

	if not tr.Hit then return end

	local SpawnPos = tr.HitPos + tr.HitNormal * 36

	local ent = ents.Create( ClassName )
	ent:SetSlotName( ClassName )	--this is the best place to set the slot, only modify it ingame when it's not equipped
	ent:SetPos( SpawnPos )
	ent:SetAngles( Angle( 90 , 0 , 0 ) )
	ent:Spawn()

	--try equipping it, if we can't we'll just remove it
	if not self.SpawnOnGroundConVar:GetBool() then
		--forced should not be set here, as we still kinda want the equip logic to work as normal
		if not ent:Attach( ply , false ) then
			ent:Remove()
			return
		end
	end

	return ent

end

function ENT:Initialize()
	BaseClass.Initialize( self )
	if SERVER then
		self:SetModel( "models/hunter/plates/plate.mdl" )
		self:SetMaterial ( "Models/effects/vol_light001" )
		self:InitPhysics()

		self:SetMaxHealth( 100 )
		self:SetHealth( self:GetMaxHealth() )

		self:SetInfiniteFuel( false )
		self:SetMaxFuel(100)
		self:SetFuel( self:GetMaxFuel() )
		self:SetFuelDrain(12)	--drain in seconds
		self:SetFuelRecharge( 17 )	--recharge in seconds
		self:SetActive( false )
		self:SetCanStomp( false )
		self:SetDoGroundSlam( false )
		self:SetAirResistance( 3.5 )
		self:SetRemoveGravity( true )
		self:SetJetpackSpeed( 2500 )
		self:SetJetpackStrafeSpeed( 600 )
		self:SetJetpackVelocity( 900 )
		self:SetJetpackStrafeVelocity( 5000 )
	else
		self:SetLastActive( false )
		self:SetNextParticle( 0 )
		self:SetNextFlameTrace( 0 )
		self:SetLastFlameTrace( nil )
	end
end

function ENT:SetupDataTables()
	BaseClass.SetupDataTables( self )

	self:DefineNWVar( "Bool" , "Active" )
	self:DefineNWVar( "Bool" , "GoneApeshit" , true )	--set either when the owner dies with us active, or when we're being shot at
	self:DefineNWVar( "Bool" , "RemoveGravity" )
	self:DefineNWVar( "Bool" , "InfiniteFuel" , true , "Infinite Fuel" )
	self:DefineNWVar( "Bool" , "DoGroundSlam" )
	self:DefineNWVar( "Bool" , "CanStomp" , true , "Can stomp" )

	self:DefineNWVar( "Float" , "Fuel" )
	self:DefineNWVar( "Float" , "MaxFuel" )	--don't modify the max amount, the drain scales anyway, set to -1 to disable the fuel drain
	self:DefineNWVar( "Float" , "FuelDrain" , true , "Seconds to drain fuel" , 2 , 80 ) --how many seconds it's gonna take to drain all the fuel
	self:DefineNWVar( "Float" , "FuelRecharge" , true , "Seconds to recharge the fuel" , 1 , 60 ) --how many seconds it should take to fully recharge this
	self:DefineNWVar( "Float" , "AirResistance" , true , "Air Resistance" , 0 , 10 )
	self:DefineNWVar( "Float" , "GoneApeshitTime" ) --only used if infinite fuel is on

	self:DefineNWVar( "Int" , "Key" )	--override it to disallow people from editing the key since it's unused
	self:DefineNWVar( "Int" , "JetpackSpeed" , true , "Jetpack idle upward speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackStrafeSpeed" , true , "Jetpack idle side speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackVelocity" , true , "Jetpack active upward speed" , 1 , 3000 )
	self:DefineNWVar( "Int" , "JetpackStrafeVelocity" , true , "Jetpack active side speed" , 1 , 3000 )

end

function ENT:HandleFly( predicted , owner , movedata , usercmd )
	self:SetActive( self:CanFly( owner , movedata ) )

	--we have infinite fuel and the apeshit timeout hasn't been set, do it now
	--this is most useful because I CBA to do that everytime ok?
	--also it's serverside only because we only set the apeshit on the server anyway

	if SERVER then
		if self:GetGoneApeshit() and self:GetGoneApeshitTime() == 0 and self:GetInfiniteFuel() then
			self:SetGoneApeshitTime( CurTime() + 5 )
		end
	end

	--the check below has to be done with prediction on the client!

	if CLIENT and not predicted then
		return
	end

	--fixes a bug where if you set goneapeshit manually via the contextmenu and the physobj is asleep it wouldn't apply the simulated forces
	if SERVER and not predicted and self:GetGoneApeshit() then
		local physobj = self:GetPhysicsObject()
		if IsValid( physobj ) and physobj:IsAsleep() then
			physobj:Wake()
		end
	end

	--if we have an apeshit timeout, calm us down ( this doesn't check for infinite fuel, in case we did this manually )
	if self:GetGoneApeshit() and self:GetGoneApeshitTime() ~= 0 and self:GetGoneApeshitTime() <= CurTime() then
		self:SetGoneApeshit( false )
		self:SetGoneApeshitTime( 0 )
	end
end

function ENT:HandleFuel( predicted )

	--like with normal rules of prediction, we don't want to run on the client if we're not in the simulation

	if not predicted and CLIENT then
		return
	end

	--we set the think rate on the entity to the tickrate on the server, we could've done NextThink() - CurTime(), but it's only a setter, not a getter
	local ft = engine.TickInterval()

	--screw that, during prediction we need to recharge with FrameTime()
	if predicted then
		ft = FrameTime()
	end

	local fueltime = self:GetActive() and self:GetFuelDrain() or self:GetFuelRecharge()

	local fuelrate = self:GetMaxFuel() / ( fueltime / ft )

	if self:GetActive() then
		fuelrate = fuelrate * -1

		if self:GetGoneApeshit() then
			--drain twice as much fuel if we're going craaaazy
			fuelrate = fuelrate * 2
		end

		--don't drain any fuel when infinite fuel is on, but still allow recharge
		if self:GetInfiniteFuel() then
			fuelrate = 0
		end
	else
		--recharge in different ways if we have an owner or not, because players might drop and reequip the jetpack to exploit the recharging
		if IsValid( self:GetControllingPlayer() ) then
			--can't recharge until our owner is on the ground!
			--prevents the player from tapping the jump button to fly and recharge at the same time
			if not self:GetControllingPlayer():OnGround() then
				fuelrate = 0
			end
		else
			--only recharge if our physobj is sleeping and it's valid ( should never be invalid in the first place )
			local physobj = self:GetPhysicsObject()
			if not IsValid( physobj ) or not physobj:IsAsleep() then
				fuelrate = 0
			end
		end
	end

	--holy shit, optimization??
	if fuelrate ~= 0 then
		self:SetFuel( math.Clamp( self:GetFuel() + fuelrate , 0 , self:GetMaxFuel() ) )
	end

	--we exhausted all of our fuel, chill out if we're crazy
	if not self:HasFuel() and self:GetGoneApeshit() then
		self:SetGoneApeshit( false )
	end
end

function ENT:HandleLoopingSounds()

	--create the soundpatch if it doesn't exist, it might happen on the client sometimes since it's garbage collected

	if not self.JetpackSound then
		self.JetpackSound = CreateSound( self, "jetpack.thruster_loop" )
	end

	if self:GetActive() then
		local pitch = 125

		if self:GetGoneApeshit() then
			pitch = 175
		end

		self.JetpackSound:PlayEx( 0.5  , pitch )
	else
		self.JetpackSound:FadeOut( 0.1 )
	end
end

function ENT:HasFuel()
	return self:GetFuel() > 0
end

function ENT:GetFuelFraction()
	return self:GetFuel() / self:GetMaxFuel()
end

function ENT:CanFly( owner , mv )


	if IsValid( owner ) then

		--don't care about player inputs in this case, the player's jetpack is going craaazy

		if self:GetGoneApeshit() then
			return owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and self:HasFuel()
		end

		return ( mv:KeyDown( IN_JUMP ) or mv:KeyDown( IN_DUCK ) or mv:KeyDown( IN_SPEED ) ) and not owner:OnGround() and owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and owner:Alive() and self:HasFuel()
	end

	--making it so the jetpack can also fly on its own without an owner ( in the case we want it go go nuts if the player dies or some shit )
	if self:GetGoneApeshit() then
		return self:WaterLevel() == 0 and self:HasFuel()
	end

	return false
end

function ENT:Think()

	--still act if we're not being held by a player
	if not self:IsCarried() then
		self:HandleFly( false )
		self:HandleFuel( false )
	end

	--animation related stuff should be fine to call here



	return BaseClass.Think( self )
end

function ENT:PredictedSetupMove( owner , mv , usercmd )

	self:HandleFly( true , owner , mv , usercmd )
	self:HandleFuel( true )

	if self:GetActive() then

		local vel = mv:GetVelocity()

		if mv:KeyDown( IN_JUMP ) and vel.z < self:GetJetpackSpeed() then

			-- Apply constant jetpack_velocity

			vel.z = vel.z + self:GetJetpackVelocity() * FrameTime()

		elseif mv:KeyDown( IN_SPEED ) and vel.z < 0 then

			-- Apply just the right amount of thrust

			vel.z = math.Approach( vel.z , 0 , self:GetJetpackVelocity() * FrameTime() )

		end



		-- Quickly descend to do a ground slam, don't check for the velocity cap, we want to slam down as fast as we can
		if self:GetCanStomp() then
			self:SetDoGroundSlam( mv:KeyDown( IN_DUCK ) )
		end

		--even if the user can't stomp, we still allow him to go down by crouching

		if mv:KeyDown( IN_DUCK ) then
			vel.z = vel.z - self:GetJetpackVelocity() * FrameTime()
		end

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--

		if vel.z == 0 then

			self:SetRemoveGravity( true )

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

		end

		--
		-- Apply movement velocity
		--

		local move_vel = Vector( 0, 0, 0 )

		local ang = mv:GetMoveAngles()
		ang.p = 0

		move_vel:Add( ang:Right() * mv:GetSideSpeed() )
		move_vel:Add( ang:Forward() * mv:GetForwardSpeed() )

		move_vel:Normalize()
		move_vel:Mul( self:GetJetpackStrafeVelocity() * FrameTime() )

		if vel:Length2D() < self:GetJetpackStrafeSpeed() then

			vel:Add( move_vel )

		end

		--TODO: goneapeshit stuff, do it before air resistance

		if self:GetGoneApeshit() then
			--boost us in the direction the jetpack is facing in the world ( actual third person angles )
			--ragdolling the user and attaching us to the ragdoll would be quite expensive and wouldn't be worth it
			--as cool as that might look, that might also break stuff in other gamemodes

			local addvel = self:GetAngles():Up() * -1 * self:GetJetpackVelocity() * FrameTime()
			vel:Add( addvel )
		end

		--
		-- Apply air resistance
		--
		vel.x = math.Approach( vel.x, 0, FrameTime() * self:GetAirResistance() * vel.x )
		vel.y = math.Approach( vel.y, 0, FrameTime() * self:GetAirResistance() * vel.y )

		--
		-- Write our calculated velocity back to the CMoveData structure
		--
		mv:SetVelocity( vel )

		mv:SetForwardSpeed( 0 )
		mv:SetSideSpeed( 0 )
		mv:SetUpSpeed( 0 )

		-- Removes the crouch button from the movedata, effectively disabling the crouching behaviour

		mv:SetButtons( bit.band( mv:GetButtons(), bit.bnot( IN_DUCK ) ) )

	end
end

function ENT:PredictedThink( owner , movedata )
end

function ENT:PredictedMove( owner , data )
	if self:GetActive() and self:GetGoneApeshit() then
		owner:SetGroundEntity( NULL )
	end
end

function ENT:PredictedFinishMove( owner , movedata )
	if self:GetActive() then

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--
		if self:GetRemoveGravity() then
			local vel = movedata:GetVelocity()

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

			movedata:SetVelocity( vel )

			self:SetRemoveGravity( false )
		end

	end
end

local	SF_PHYSEXPLOSION_NODAMAGE			=	0x0001
local	SF_PHYSEXPLOSION_PUSH_PLAYER		=	0x0002
local	SF_PHYSEXPLOSION_RADIAL				=	0x0004
local	SF_PHYSEXPLOSION_TEST_LOS			=	0x0008
local	SF_PHYSEXPLOSION_DISORIENT_PLAYER	=	0x0010

function ENT:PredictedHitGround( ply , inwater , onfloater , speed )

	local dogroundslam = self:GetDoGroundSlam()
	self:SetDoGroundSlam( false )

	if dogroundslam and speed > 500 then

		self:EmitPESound( "Player.FallDamage" , nil , nil , nil , nil , true )
		--ply:EmitSound( "Player.FallDamage" )
		--self:EmitPESound( "" , nil , nil , nil , nil , true )	--find the sound smod uses when the player hits the ground in smod

		local fraction = self:GetJetpackStrafeVelocity() / speed	--because the fall speed might be higher than the jetpack one

		local effect = EffectData()
		effect:SetEntity( ply )
		effect:SetOrigin( ply:WorldSpaceCenter() )	--apparently the player is considered in the ground in this hook and stuff doesn't spawn
		effect:SetScale( 128 )
		util.Effect( "ThumperDust" , effect , true )	--todo, make our own effect where the particles start from the player and expand in a circle
														--can even copy the code from c_thumper_dust
		if SERVER then
			--TODO: get the code from the sdk and replicate this on my own
			ply:LagCompensation( true )

			--[[
			local physexpl = ents.Create( "env_physexplosion" )

			if IsValid( physexpl ) then
				physexpl:SetPos( ply:WorldSpaceCenter() )
				physexpl:SetKeyValue( "spawnflags" , bit.bor( SF_PHYSEXPLOSION_NODAMAGE , SF_PHYSEXPLOSION_RADIAL , SF_PHYSEXPLOSION_TEST_LOS ) )
				physexpl:SetKeyValue( "magnitude" , 500 * fraction )
				physexpl:SetKeyValue( "radius" , 250 )
				physexpl:Spawn()
				physexpl:Fire( "Explode" , "" , 0 )
				physexpl:Fire( "Kill" , "" , 0.1 )
			end
			]]



			--this is kind of shit but it's needed to make prediction actually work properly on this screenshake shit
			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( ply )
			end

			util.ScreenShake( self:GetPos() , 1.5 , 250 , 1 , 500 )

			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( NULL )
			end

			ply:LagCompensation( false )
		end

		ply:AnimRestartGesture( GESTURE_SLOT_JUMP, ACT_LAND, true )
		return true	--override the fall damage and other hooks
	end
end

if SERVER then

	function ENT:OnTakeDamage( dmginfo )
		--we're already dead , might happen if multiple jetpacks explode at the same time
		if self:Health() <= 0 then
			return
		end

		self:TakePhysicsDamage( dmginfo )

		local oldhealth = self:Health()

		local newhealth = math.Clamp( self:Health() - dmginfo:GetDamage() , 0 , self:GetMaxHealth() )
		self:SetHealth( newhealth )

		if self:Health() <= 0 then
			--maybe something is relaying damage to the jetpack instead, an explosion maybe?
			if IsValid( self:GetControllingPlayer() ) then
				self:Remove( true )
			end
			self:Detonate( dmginfo:GetAttacker() )
			return
		end

		--roll a random, if we're not being held by a player and the random succeeds, go apeshit
		if dmginfo:GetDamage() > 3 and not self:GetGoneApeshit() then
			local rand = math.random( 1 , 10 )
			if rand <= 2 then
				if IsValid( self:GetControllingPlayer() ) then
					self:Remove( true )
				end
				self:SetGoneApeshit( true )
			end
		end
	end

	function ENT:OnAttach( ply )
		self:SetDoGroundSlam( false )
		--self:SetSolid( SOLID_BBOX )	--we can still be hit when on the player's back
	end

	function ENT:CanAttach( ply )
		if self:GetGoneApeshit() then
			return false
		end
	end

	function ENT:OnDrop( ply , forced )
		if IsValid( ply ) and not ply:Alive() then
			--when the player dies while still using us, keep us active and let us fly with physics until
			--our fuel runs out
			if self:GetActive() then
				self:SetGoneApeshit( true )
			end
		else
			self:SetActive( false )
		end

	end

	function ENT:OnInitPhysics( physobj )
		if IsValid( physobj ) then
			physobj:SetMass( 75 )
			self:StartMotionController()
		end
		self:SetCollisionGroup( COLLISION_GROUP_NONE )
		--self:SetCollisionGroup( COLLISION_GROUP_WEAPON )	--set to COLLISION_GROUP_NONE to reenable collisions against players and npcs
	end

	function ENT:OnRemovePhysics( physobj )
		self:StopMotionController()
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS_TRIGGER )
		--self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
	end

	function ENT:PhysicsSimulate( physobj , delta )

		--no point in applying forces and stuff if something is holding our physobj

		if self:GetActive() and not self:GetBeingHeld() then
			physobj:Wake()
			local force = self.StandaloneLinear
			local angular = self.StandaloneAngular

			if self:GetGoneApeshit() then
				force = self.StandaloneApeShitLinear
				angular = self.StandaloneApeShitAngular
			end

			--yes I know we're technically modifying the variable stored in ENT.StandaloneApeShitLinear and that it might fuck up other jetpacks
			--but it won't because we're simply using it as a cached vector_origin and overriding the z anyway
			force.z = -self:GetJetpackVelocity()

			return angular * physobj:GetMass() , force * physobj:GetMass() , SIM_LOCAL_FORCE
		end
	end

	function ENT:PhysicsCollide( data , physobj )
		--taken straight from valve's code, it's needed since garry overwrote VPhysicsCollision, friction sound is still there though
		--because he didn't override the VPhysicsFriction
		if data.DeltaTime >= 0.05 and data.Speed >= 70 then
			local volume = data.Speed * data.Speed * ( 1 / ( 320 * 320 ) )
			if volume > 1 then
				volume = 1
			end

			--TODO: find a better impact sound for this model
			self:EmitSound( "SolidMetal.ImpactHard" , nil , nil , volume , CHAN_BODY )
		end

		if self:CheckDetonate( data , physobj ) then
			self:Detonate()
		end
	end

	--can't explode on impact if we're not active
	function ENT:CheckDetonate( data , physobj )
		return self:GetActive() and data.Speed > 500 and not self:GetBeingHeld()
	end

	function ENT:Detonate( attacker )
		--you never know!
		if self:IsEFlagSet( EFL_KILLME ) then
			return
		end

		self:Remove()

		local fuel = self:GetFuel()
		local atk = IsValid( attacker ) and attacker or self

		--check how much fuel was left when we impacted
		local dmg = 1.5 * fuel
		local radius = 2.5 * fuel

		util.BlastDamage( self , atk , self:GetPos() , radius , dmg )
		util.ScreenShake( self:GetPos() , 1.5 , dmg , 0.25 , radius * 2 )

		local effect = EffectData()
		effect:SetOrigin( self:GetPos() )
		effect:SetMagnitude( dmg )	--this is actually the force of the explosion
		effect:SetFlags( bit.bor( 0x80 , 0x20 ) ) --NOFIREBALLSMOKE, ROTATE
		util.Effect( "Explosion" , effect )
	end



else

	function ENT:Draw( flags )
		if GetViewEntity() == self:GetOwner() and !self:GetOwner():ShouldDrawLocalPlayer() then return end
		local pos , ang = self:GetCustomParentOrigin()

		--even though the calcabsoluteposition hook should already prevent this, it doesn't on other players
		--might as well not give it the benefit of the doubt in the first place
		if pos and ang then
			self:SetPos( pos )
			self:SetAngles( ang )
			self:SetupBones()
		end

		self:DrawModel( flags )

		local atchpos , atchang = self:GetEffectsOffset()

		local effectsscale = self:GetEffectsScale()

		--technically we shouldn't draw the fire from here, it should be done in drawtranslucent
		--but since we draw from the player and he's not translucent this won't get called despite us being translucent
		--might as well just set us to opaque

		if self:GetActive() then	-- and bit.band( flags , STUDIO_TRANSPARENCY ) ~= 0 then
			self:DrawJetpackFire( atchpos , atchang , effectsscale )
		end

		self:DrawJetpackSmoke( atchpos  , atchang , effectsscale )
	end

	--the less fuel we have, the smaller our particles will be
	function ENT:GetEffectsScale()
		return Lerp( self:GetFuel() / self:GetMaxFuel() , self.MinEffectsSize , self.MaxEffectsSize )
	end

	function ENT:GetEffectsOffset()
		local angup = self:GetAngles():Up()
		return self:GetPos() + angup * 5, angup
	end


	end



	--copied straight from the thruster code
	function ENT:DrawJetpackFire( pos , normal , scale )
		local scroll = 1000 + UnPredictedCurTime() * -10

		--the trace makes sure that the light or the flame don't end up inside walls
		--although it should be cached somehow, and only do the trace every tick

		local tracelength = 148 * scale


		if self:GetNextFlameTrace() < UnPredictedCurTime() or not self:GetLastFlameTrace() then
			local tr = {
				start = pos,
				endpos = pos + normal * tracelength,
				mask = MASK_OPAQUE,
				filter = {
					self:GetControllingPlayer(),
					self
				},
			}

			self:SetLastFlameTrace( util.TraceLine( tr ) )
			self:SetNextFlameTrace( UnPredictedCurTime() +  engine.TickInterval() )
		end

		local traceresult = self:GetLastFlameTrace()

		--what
		if not traceresult then
			return
		end

		-- traceresult.Fraction * ( 60 * scale ) / tracelength


		--TODO: fix the middle segment not being proportional to the tracelength ( and Fraction )

		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 32 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()


		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 100 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 40 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()

		scroll = scroll * 0.5

		render.UpdateRefractTexture()
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 32 * scale, 32 * scale , scroll + 2, color_white )
			render.AddBeam( traceresult.HitPos, 48 * scale , scroll + 5, self.JetpackFireNone )
		render.EndBeam()


		scroll = scroll * 1.3
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos , 8 * scale , scroll, self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 16 * scale , scroll + 1 , self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 16 * scale , scroll + 3 , self.JetpackFireNone )
		render.EndBeam()

		local light = DynamicLight( self:EntIndex() )

		if not light then
			return
		end

		light.Pos = traceresult.HitPos
		light.r = self.JetpackFireRed.r
		light.g = self.JetpackFireRed.g
		light.b = self.JetpackFireRed.b
		light.Brightness = 3
		light.Dir = normal
		light.InnerAngle = -45 --light entities in a cone
		light.OuterAngle = 45 --
		light.Size = 250 * scale -- 125 when the scale is 0.25
		light.Style = 1	--this should do the flicker for us
		light.Decay = 1000
		light.DieTime = UnPredictedCurTime() + 1
	end

	function ENT:DrawJetpackSmoke( pos , normal , scale )

		if not self.JetpackParticleEmitter then
			local emittr = ParticleEmitter( pos )
			if not emittr then
				return
			end
			self.JetpackParticleEmitter = emittr
		end

		--to prevent the smoke from drawing inside of the player when he's looking at a mirror, draw it manually if he's the local player
		--this behaviour is disabled if he's not the one actually using the jetpack ( this also happens when the jetpack is dropped and flies off )

		local particlenodraw = self:IsCarriedByLocalPlayer( true )

		self.JetpackParticleEmitter:SetNoDraw( particlenodraw )

		if self:GetNextParticle() < UnPredictedCurTime() and self:GetActive() then
			local particle = self.JetpackParticleEmitter:Add( "particle/particle_noisesphere", pos )
			if particle then
				--only increase the time on a successful particle
				self:SetNextParticle( UnPredictedCurTime() + 0.01 )
				particle:SetLighting( true )
				particle:SetCollide( true )
				particle:SetBounce( 0.25 )
				particle:SetVelocity( normal * self:GetJetpackSpeed() )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( 15 )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( 16 * scale )
				particle:SetEndSize( 64 * scale )
				particle:SetRoll( math.Rand( -10 , 10  ) )
				particle:SetRollDelta( math.Rand( -0.2 , 0.2 ) )
				particle:SetColor( 255 , 255 , 255 )
			end
		end

		if particlenodraw then
			self.JetpackParticleEmitter:Draw()
		end
	end



function ENT:HandleMainActivityOverride( ply , velocity )
	if self:GetActive() then
		local vel2d = velocity:Length2D()
		local idealact = ACT_INVALID

		if IsValid( ply:GetActiveWeapon() ) then
			idealact = ACT_MP_SWIM	--vel2d >= 10 and ACT_MP_SWIM or ACT_MP_SWIM_IDLE
		else
			idealact = ACT_HL2MP_IDLE + 9
		end

		if self:GetDoGroundSlam() then
			idealact = ACT_MP_CROUCH_IDLE
		end

		return idealact , ACT_INVALID
	end
end

function ENT:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed )
	if self:GetActive() then
		ply:SetPlaybackRate( 0 )	--don't do the full swimming animation
		return true
	end
end

function ENT:OnRemove()

	if CLIENT then

		--if stopping the soundpatch doesn't work, stop the sound manually
		if self.JetpackSound then
			self.JetpackSound:Stop()
			self.JetpackSound = nil
		else
			self:StopSound( "jetpack.thruster_loop" )
		end


		if self.JetpackParticleEmitter then
			self.JetpackParticleEmitter:Finish()
			self.JetpackParticleEmitter = nil
		end
	end

	BaseClass.OnRemove( self )
end

--PATH gamemodes/starwarsrp/entities/entities/money_printer/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
    self:initVars()
    if not self.DisplayName or self.DisplayName == "" then
        self.DisplayName = DarkRP.getPhrase("money_printer")
    end
end

local camStart3D2D = cam.Start3D2D
local camEnd3D2D = cam.End3D2D
local drawWordBox = draw.WordBox
local IsValid = IsValid

local color_red = Color(140,0,0,100)
local color_white = color_white

function ENT:Draw()
    self:DrawModel()

    local Pos = self:GetPos()
    local Ang = self:GetAngles()

    local owner = self:Getowning_ent()
    owner = (IsValid(owner) and owner:Nick()) or DarkRP.getPhrase("unknown")

    surface.SetFont("HUDNumber5")
    local text = self.DisplayName
    local TextWidth = surface.GetTextSize(text)
    local TextWidth2 = surface.GetTextSize(owner)

    Ang:RotateAroundAxis(Ang:Up(), 90)

    camStart3D2D(Pos + Ang:Up() * 11.5, Ang, 0.11)
        drawWordBox(2, -TextWidth * 0.5, -30, text, "HUDNumber5", color_red, color_white)
        drawWordBox(2, -TextWidth2 * 0.5, 18, owner, "HUDNumber5", color_red, color_white)
    camEnd3D2D()
end

function ENT:Think()
end

--PATH lua/entities/mortar_fire_shell/shared.lua:
ENT.Type			=	"anim"
ENT.Base			=	"base_entity"
ENT.PrintName		=	"[DU] Mortar Fire Shell"
ENT.Spawnable		=	false
ENT.Category 		=   "DolUnity"
--PATH lua/entities/mortar_shell/shared.lua:
ENT.Type			=	"anim"
ENT.Base			=	"base_entity"
ENT.PrintName		=	"[DU] Mortar Shell"
ENT.Spawnable		=	false
ENT.Category 		=   "DolUnity"


--PATH lua/entities/mvp_simpledefcons_display.lua:
return gluapack()()
--PATH lua/entities/mvp_simpledefcons_manager.lua:
return gluapack()()
--PATH lua/entities/n-1.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_antitankmine/shared.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_c14.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "arc9_nade_base"
ENT.PrintName = "C14 Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.CollisionGroup = COLLISION_GROUP_DEBRIS

ENT.Model = "models/arccw/kraken/sw/explosives/world/w_c14.mdl"
ENT.Armed = false

ENT.BlastDamage = {
    [0] = 60,
    [1] = 140,
    [2] = 70,
}

function ENT:Initialize()
    if SERVER then
        self:SetModel(self.Model)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetSkin(self.Skin or 0)

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.SpawnTime = CurTime()
        self:SetPhysicsAttacker(self:GetOwner(), 5)
    end
    
    util.PrecacheSound("kraken/shared/beeps4.wav")
    self:EmitSound("kraken/shared/beeps4.wav")
    
end

function ENT:PhysicsCollide(data, physobj)
    local tgt = data.HitEntity
    local dmginfo = DamageInfo()
    dmginfo:SetDamageType(DMG_GENERIC)
    dmginfo:SetDamage(10)
    dmginfo:SetAttacker(self:GetOwner())
    dmginfo:SetInflictor(self)
    dmginfo:SetDamageForce(data.OurOldVelocity * 0.5)
    tgt:TakeDamageInfo(dmginfo)
    if (IsValid(tgt) and (tgt:IsNPC() or tgt:IsPlayer() or tgt:IsNextBot()) and tgt:Health() <= 0) or (not tgt:IsWorld() and not IsValid(tgt)) or string.find(tgt:GetClass(), "breakable") then
        local pos, ang, vel = self:GetPos(), self:GetAngles(), data.OurOldVelocity
        timer.Simple(0, function()
            if IsValid(self) then
                self:SetAngles(ang)
                self:SetPos(pos)
                self:GetPhysicsObject():SetVelocityInstantaneous(vel)
            end
        end)
    else
        self:Detonate(data.HitEntity)
    end
end

function ENT:Think()
    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
        self:Detonate()
    end
end

function ENT:Detonate()
    if SERVER then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect("WaterSurfaceExplosion", effectdata)
            self:EmitSound("weapons/underwater_explode3.wav", 120, 100, 1, CHAN_AUTO)
        else
            local explode = ents.Create( "info_particle_system" )
            explode:SetKeyValue( "effect_name", "grenade_final" )
            explode:SetOwner( self.Owner )
            explode:SetPos( self:GetPos() )
            explode:Spawn()
            explode:Activate()
            explode:Fire( "start", "", 0 )
            explode:Fire( "kill", "", 30 )
            --util.Effect("Explosion", effectdata)
            --util.Effect("hl2mmod_explosion_grenade", effectdata)
            self:EmitSound("ArcCW_Kraken.Explosives.Explosion", 120, 100, 1, CHAN_AUTO)
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        local hit = false
        
    
        local pos = self:GetPos()

        for _, ent in pairs(ents.FindInSphere(pos, 400)) do
           
            local distSqr = ent:GetPos():DistToSqr(pos)
            local f = 1
            if distSqr > 9216 then -- 96 * 96
                f = Lerp((distSqr - 9216) / (122500 - 9216), 1, 0.25)
            end
            local dmginfo = DamageInfo()
            dmginfo:SetDamageType(DMG_BLAST)
            dmginfo:SetAttacker(attacker)
            dmginfo:SetDamage(125 * f)
            dmginfo:SetDamageForce((ent:WorldSpaceCenter() - pos):GetNormalized() * 9001 * f)
            dmginfo:SetInflictor(self)
            ent:TakeDamageInfo(dmginfo)
        end

        for k, v in pairs(ents.FindInSphere(pos, 400)) do
            if IsValid(v) and (v.LFS or v.LVS) then
                if v.LFS then
					v:StopEngine()
					v:SetShield(0)
					v:SetHP( v:GetHP()/ 4 )
				end
				if v.LVS then
					v:StopEngine()
					v:SetShield(0)
					v:SetHP( v:GetHP()/ 4 )
				end
            end
        end

        self:Remove()
        util.Decal("Scorch", pos, pos - Vector(0, 0, 16))
        util.ScreenShake(self:GetPos(), 25, 4, 1, self.Radius * 4)
    end
end

function ENT:DrawTranslucent()
    self:Draw()
end

function ENT:Draw()
    self:DrawModel()
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_decoy/shared.lua:
-- Made by Matsilagi

ENT.Type = "anim"
ENT.PrintName			= "Decoy Grenade"
ENT.Author			= ""
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions			= ""
ENT.DoNotDuplicate = true 
ENT.DisableDuplicator = true
ENT.Zombies = {}
ENT.VJExists = false
ENT.HasShot = false

/*---------------------------------------------------------
OnRemove
---------------------------------------------------------*/
function ENT:OnRemove()
end

/*---------------------------------------------------------
PhysicsUpdate
---------------------------------------------------------*/
function ENT:PhysicsUpdate()
end

/*---------------------------------------------------------
PhysicsCollide
---------------------------------------------------------*/

function ENT:PhysicsCollide(data,phys)
	if data.Speed > 60 then

            local tgt = data.HitEntity
            if IsValid(tgt) and not tgt:IsWorld() and (self.NextHit or 0) < CurTime() then
                self.NextHit = CurTime() + 0.1
                local dmginfo = DamageInfo()
                dmginfo:SetDamageType(DMG_GENERIC)
                dmginfo:SetDamage(10)
                dmginfo:SetAttacker(self:GetOwner())
                dmginfo:SetInflictor(self)
                dmginfo:SetDamageForce(data.OurOldVelocity * 0.5)
                tgt:TakeDamageInfo(dmginfo)
                if (IsValid(tgt) and (tgt:IsNPC() or tgt:IsPlayer() or tgt:IsNextBot()) and tgt:Health() <= 0) or (not tgt:IsWorld() and not IsValid(tgt)) or string.find(tgt:GetClass(), "breakable") then
                    local pos, ang, vel = self:GetPos(), self:GetAngles(), data.OurOldVelocity
                    timer.Simple(0, function()
                        if IsValid(self) then
                            self:SetAngles(ang)
                            self:SetPos(pos)
                            self:GetPhysicsObject():SetVelocityInstantaneous(vel)
                        end
                    end)
                end
            end

		self.Entity:EmitSound(Sound("kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"))
	
		local impulse = (data.OurOldVelocity - 2 * data.OurOldVelocity:Dot(data.HitNormal) * data.HitNormal)*0.25
		phys:ApplyForceCenter(impulse)
	end
	
end

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_dioxis/shared.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_molotov/shared.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_sonar/shared.lua:
-- Made by Matsilagi

AddCSLuaFile()

if SERVER then
	util.AddNetworkString("ARC9_GSR_SONAR_EXPLODE")
end

ENT.Type      = "anim"
ENT.Spawnable = false

ENT.FindRadius = 500
ENT.Model = "models/arccw/kraken/sw/explosives/world/w_impact.mdl"

function ENT:Initialize()
	if SERVER then
		self:SetModel(self.Model)

		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_NONE)
		self:DrawShadow( false )

		local phys = self:GetPhysicsObject()
		if IsValid(phys) then
			phys:Wake()
		end
	end
    util.PrecacheSound("kraken/explosives/sonicimploder/active.wav")
    self:EmitSound("kraken/explosives/sonicimploder/active.wav")
end

function ENT:Think()
	if CLIENT then
		local CT = CurTime()
		local FT = FrameTime()
		local attach = self:LookupAttachment("Wick")
		local data = self:GetAttachment(attach)
	end
end

function ENT:Use(activator, caller)
	return false
end

function ENT:OnRemove()
	return false
end

local function EntityFacingFactor(ent1, ent2)
	local dir       = ent2:EyeAngles():Forward()
	local facingdir = (ent1:GetPos() - (ent2.EyePos and ent2:EyePos() or ent2:GetPos())):GetNormalized()
	return (facingdir:Dot(dir) + 1) / 2
end

if SERVER then
	local tr = {}

	function ENT:Detonate()
		local origin = self:GetPos()

		if IsValid(self.Owner) then
			local _ents = ents.FindInSphere(origin, self.FindRadius)
			local tab   = {}

			for k, v in pairs(_ents) do
				if v:IsNPC() or v:IsPlayer() or v:IsNextBot() then
					if v ~= self.Owner then
						table.insert(tab, v)
					end
				end
			end

			net.Start("ARC9_GSR_SONAR_EXPLODE")
			net.WriteTable(tab)
			net.Send(self.Owner)
		end

		tr.start = origin
		tr.mask  = MASK_SOLID

		for k, v in pairs(player.GetAll()) do
			tr.endpos = v:EyePos()
			tr.filter = { self, v, v:GetActiveWeapon() }

			local trace = util.TraceLine(tr)
			if not trace.Hit or trace.Fraction >= 1 or trace.Fraction <= 0 then
				v:SetNWFloat("ARC9_GSR_LastFlash", CurTime() - 4)
				v:SetNWFloat("ARC9_GSR_FlashDistance", tr.endpos:Distance(origin))
				v:SetNWFloat("ARC9_GSR_FlashFactor", EntityFacingFactor(self, v) * 0.5)
			end
		end

		self:EmitSound( "kraken/explosives/sensorgrenade/sensor_explode.wav", 75, 100, 1, CHAN_AUTO )

		local explode = ents.Create( "info_particle_system" )
		explode:SetKeyValue( "effect_name", "weapon_sensorgren_detonate" )
		explode:SetOwner( self.Owner )
		explode:SetPos( self:GetPos() )
		explode:Spawn()
		explode:Activate()
		explode:Fire( "start", "", 0 )
		explode:Fire( "kill", "", 30 )

		SafeRemoveEntity(self)
	end

	function ENT:Fuse(ent)
		if SERVER then
			self.WeldEnt = constraint.Weld(self, ent, 0, 0, 0, true, false)

			self:EmitSound( "kraken/explosives/sensorgrenade/sensor_arm.wav", 75, 100, 1, CHAN_AUTO )
			timer.Simple(3, function()
				if IsValid(self) then
					self:StopParticles()
					self:Detonate()
				end
			end)
		end
	end

	function ENT:PhysicsCollide(data, physObj)
		if not self:GetNWBool("Fused") then
			if data.HitEntity then
				if not (data.HitEntity:IsNPC() or data.HitEntity:IsPlayer() or data.HitEntity:IsNextBot()) then
					self:SetNWBool("Fused", true)

					timer.Simple(0, function()
						if IsValid(self) then
							self:EmitSound( "kraken/explosives/sensorgrenade/sensor_land.wav", 75, 100, 1, CHAN_AUTO )
							self:Fuse(data.HitEntity)
						end
					end)
				end
			end
		end
		orient_angles(physObj,data)
	end

	function orient_angles(obj, data) --this function juts takes in the hitnormal of the collision and rotates the angles accordingly
		if data.HitNormal.z < -.5 then
			obj:SetAngles((data.HitNormal + Vector(0,90,0) ):Angle())
			return
		end
		if data.HitNormal.z > .5 then
			obj:SetAngles((data.HitNormal + Vector(-90,0,0) ):Angle())
			return
		end
		if data.HitNormal.y < -.5 then
			obj:SetAngles((data.HitNormal + Vector(0,0,90) ):Angle())
			return
		end
		if data.HitNormal.y > .5 then
			obj:SetAngles((data.HitNormal + Vector(0,0,90) ):Angle())
			return
		end
		if data.HitNormal.x < -.5 then
			obj:SetAngles((data.HitNormal + Vector(0,0,90) ):Angle())
			return
		end
		if data.HitNormal.x > .5 then
			obj:SetAngles((data.HitNormal + Vector(0,0,90) ):Angle())
			return
		end
	end
end



if CLIENT then

	local tr, col = {}, Color(255, 25, 25)
	local glow = Material("csgo/sprites/flare_sprite_02")

	function ENT:Draw()
		local ply = LocalPlayer()
		local attach = self:LookupAttachment("Wick")
		local data = self:GetAttachment(attach)

		self:DrawModel()

		local CT = CurTime()

		if self.NextBeep then
			if self.NextBeep > 0 then
				tr.start  = self:GetPos()
				tr.endpos = ply:EyePos()
				tr.mask   = MASK_SOLID
				tr.filter = { self, ply, ply:GetActiveWeapon() }

				local trace    = util.TraceLine(tr)
				local fraction = trace.Fraction

				if self.DetonateTime > CT then
					self:StopParticles()
				end
			end
		end
	end

	local ARC9_HaloManager = {}
	ARC9_HaloManager.EVENT_NAME = "ARC9_GSR_SONAR"

	local function ARC9_GSR_SONAR_CREATE_HALOS(len, ply)
		local _ents = net.ReadTable()

		timer.Simple(0.5, function()
			if istable(_ents) then
				for k, v in pairs(_ents) do
					if IsValid(v) then
						ARC9_HaloManager:Add(v, 3)
					end
				end
			end
		end)
	end

	-- Taken from Sakarias88's Intelligent HUD
	local function GetEntityAABB(ent)
		local mins = ent:OBBMins()
		local maxs = ent:OBBMaxs()

		local pos = {
			ent:LocalToWorld(Vector(maxs.x, maxs.y, maxs.z)):ToScreen(),
			ent:LocalToWorld(Vector(maxs.x, mins.y, maxs.z)):ToScreen(),
			ent:LocalToWorld(Vector(maxs.x, maxs.y, mins.z)):ToScreen(),
			ent:LocalToWorld(Vector(maxs.x, mins.y, mins.z)):ToScreen(),
			ent:LocalToWorld(Vector(mins.x, maxs.y, maxs.z)):ToScreen(),
			ent:LocalToWorld(Vector(mins.x, mins.y, maxs.z)):ToScreen(),
			ent:LocalToWorld(Vector(mins.x, maxs.y, mins.z)):ToScreen(),
			ent:LocalToWorld(Vector(mins.x, mins.y, mins.z)):ToScreen()
		}

		local minX = pos[1].x
		local minY = pos[1].y

		local maxX = pos[1].x
		local maxY = pos[1].y

		for k = 2, 8 do
			if pos[k].x > maxX then
				maxX = pos[k].x
			end

			if pos[k].y > maxY then
				maxY = pos[k].y
			end

			if pos[k].x < minX then
				minX = pos[k].x
			end

			if pos[k].y < minY then
				minY = pos[k].y
			end
		end

		return Vector(minX, minY), Vector(maxX, maxY)
	end

	net.Receive("ARC9_GSR_SONAR_EXPLODE", ARC9_GSR_SONAR_CREATE_HALOS)

	function ARC9_HaloManager:Add(ent, t)
		table.insert(self, {ent = ent, t = CurTime() + t})
		self:Enable()
	end

	local _ents = {}
	local halo_color = Color(255, 0, 0)

	function ARC9_HaloManager:Enable()
		local events = hook.GetTable()

		local tab = events["PreDrawHalos"]

		if tab and not tab[self.EVENT_NAME] or not tab then
			hook.Add("PreDrawHalos", self.EVENT_NAME, function()
				self:DrawHalo()
			end)
		end

		local tab = events["PostDrawOpaqueRenderables"]

		if tab and not tab[self.EVENT_NAME] or not tab then
			hook.Add("PostDrawOpaqueRenderables", self.EVENT_NAME, function()
				self:Draw()
			end)
		end
	end

	function ARC9_HaloManager:Disable()
		hook.Remove("PreDrawHalos", self.EVENT_NAME)
		hook.Remove("PostDrawOpaqueRenderables", self.EVENT_NAME)
	end

	local mat1 = Material("models/debug/debugwhite")
	function ARC9_HaloManager:Draw()
		for k, v in ipairs(self) do
			if not IsValid(v.ent) then self[k] = nil continue end
			render.ClearStencil()
			render.SetStencilEnable(true)

			render.SetStencilWriteMask(255)
			render.SetStencilTestMask(255)
			render.SetStencilReferenceValue(1)

			render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_ALWAYS)
			render.SetStencilFailOperation(STENCILOPERATION_KEEP)
			render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
			render.SetStencilZFailOperation(STENCILOPERATION_REPLACE)

			v.ent:DrawModel()

			render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)

			local mins, maxs = GetEntityAABB(v.ent)

			cam.Start2D()
				local health    = v.ent:Health()
				local maxHealth = v.ent:GetMaxHealth()

				local mul = math.Clamp(health / maxHealth, 0, 1)

				local x = mins.x
				local y = mins.y + (maxs.y - mins.y) * mul

				local w = maxs.x - x
				local h = maxs.y - y

				surface.SetDrawColor(255, 0, 0, 32)
				surface.DrawRect(x, y, w, h)
			cam.End2D()

			render.SetStencilEnable(false)
		end
	end

	function ARC9_HaloManager:DrawHalo()
		local CT = CurTime()

		for i = 1, #_ents do
			_ents[i] = nil
		end

		for k, v in ipairs(self) do
			if (not IsValid(v.ent) or v.ent:Health() <= 0) or v.t <= CT then
				table.remove(self, k)
			else
				table.insert(_ents, v.ent)
			end
		end

		halo.Add(_ents, halo_color, 2, 2, 2, true, true )

		if #self <= 0 then
			self:Disable()
		end
	end
end
--PATH lua/entities/npc_vj_sbdnew2/shared.lua:
ENT.Base 			= "npc_vj_creature_base" -- List of all base types: https://github.com/DrVrej/VJ-Base/wiki/Base-Types
ENT.Type 			= "ai"
ENT.PrintName 		= "Боевой ультрадроид"
ENT.Author 			= ""
ENT.Contact 		= ""
ENT.Purpose 		= ""
ENT.Instructions 	= "Click on the spawnicon to spawn it."
ENT.Category		= "[66] NPC's"

if (CLIENT) then
	local Name = "B3"
	local LangName = "npc_vj_sbdnew2"
	language.Add(LangName, Name)
	killicon.Add(LangName,"",Color(255,0,0,0))
	language.Add("#"..LangName, Name)
	killicon.Add("#"..LangName,"",Color(255,0,0,0))
end
--PATH lua/entities/npc_vj_sbdnew_crowl/shared.lua:
ENT.Base 			= "npc_vj_creature_base" -- List of all base types: https://github.com/DrVrej/VJ-Base/wiki/Base-Types
ENT.Type 			= "ai"
ENT.PrintName 		= "Супер боевой дроид"
ENT.Author 			= "Orion, Sirius, Zmaj"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "NPC/SNPC Battles or any other things"
ENT.Instructions 	= "Click on the spawnicon to spawn it."
ENT.Category		= "[HC] NPC's"

if (CLIENT) then
	local Name = "SBD"
	local LangName = "npc_vj_sbdnew"
	language.Add(LangName, Name)
	killicon.Add(LangName,"",Color(255,0,0,0))
	language.Add("#"..LangName, Name)
	killicon.Add("#"..LangName,"",Color(255,0,0,0))
end
--PATH lua/entities/npc_vj_tridroid/shared.lua:
return gluapack()()
--PATH lua/entities/obj_vj_gib/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

ENT.Base 			= "base_gmodentity"
ENT.Type 			= "anim"
ENT.PrintName		= "Gib Base"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Information		= "Gibs for SNPCs"
ENT.Category		= "VJ Base"

ENT.Spawnable		= false
ENT.AdminSpawnable	= false

ENT.IsVJBase_Gib = true
ENT.IsVJBaseCorpse = true

if CLIENT then
	function ENT:Draw() self:DrawModel() end
end
--PATH lua/entities/obj_vj_grenade_rifle.lua:
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
AddCSLuaFile()
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

ENT.Type 			= "anim"
ENT.Base 			= "obj_vj_projectile_base"
ENT.PrintName		= "Rifle Grenade"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Information		= "Projectiles for my addons"
ENT.Category		= "VJ Base"

ENT.Spawnable = false
ENT.AdminOnly = false

ENT.VJ_IsDetectableDanger = true

if CLIENT then
	local Name = "Rifle Grenade"
	local LangName = "obj_vj_grenade_rifle"
	language.Add(LangName, Name)
	killicon.Add(LangName,"HUD/killicons/default",Color(255,80,0,255))
	language.Add("#"..LangName, Name)
	killicon.Add("#"..LangName,"HUD/killicons/default",Color(255,80,0,255))
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if !SERVER then return end

ENT.Model = {"models/weapons/ar2_grenade.mdl"} -- The models it should spawn with | Picks a random one from the table
ENT.DoesRadiusDamage = true -- Should it do a blast damage when it hits something?
ENT.RadiusDamageRadius = 150 -- How far the damage go? The farther away it's from its enemy, the less damage it will do | Counted in world units
ENT.RadiusDamage = 80 -- How much damage should it deal? Remember this is a radius damage, therefore it will do less damage the farther away the entity is from its enemy
ENT.RadiusDamageUseRealisticRadius = true -- Should the damage decrease the farther away the enemy is from the position that the projectile hit?
ENT.RadiusDamageType = DMG_BLAST -- Damage type
ENT.RadiusDamageForce = 90 -- Put the force amount it should apply | false = Don't apply any force
ENT.DecalTbl_DeathDecals = {"Scorch"} -- Decals that paint when the projectile dies | It picks a random one from this table
ENT.SoundTbl_OnRemove = {""}
ENT.OnRemoveSoundLevel = 100
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:CustomOnInitializeBeforePhys()
	self:PhysicsInitSphere(5, "metal_bouncy")
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:CustomOnInitialize()
	ParticleEffectAttach("smoke_gib_01", PATTACH_ABSORIGIN_FOLLOW, self, 0)
	ParticleEffectAttach("Rocket_Smoke_Trail", PATTACH_ABSORIGIN_FOLLOW, self, 0)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:CustomPhysicsObjectOnInitialize(phys)
	phys:Wake()
	phys:SetMass(1)
	phys:EnableGravity(true)
	phys:EnableDrag(false)
	phys:SetBuoyancyRatio(0)
	phys:AddAngleVelocity(Vector(0,math.random(300,400),0))
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:DeathEffects()
	local effectData = EffectData()
	effectData:SetOrigin(self:GetPos())
	//effectData:SetScale( 500 )
	util.Effect( "HelicopterMegaBomb", effectData )
	util.Effect( "ThumperDust", effectData )
	util.Effect( "Explosion", effectData )
	util.Effect( "VJ_Small_Explosion1", effectData )

	local ExplosionLight1 = ents.Create("light_dynamic")
	ExplosionLight1:SetKeyValue("brightness", "4")
	ExplosionLight1:SetKeyValue("distance", "300")
	ExplosionLight1:SetLocalPos(self:GetPos())
	ExplosionLight1:SetLocalAngles( self:GetAngles() )
	ExplosionLight1:Fire("Color", "255 150 0")
	ExplosionLight1:SetParent(self)
	ExplosionLight1:Spawn()
	ExplosionLight1:Activate()
	ExplosionLight1:Fire("TurnOn", "", 0)
	self:DeleteOnRemove(ExplosionLight1)
	util.ScreenShake(self:GetPos(), 100, 200, 1, 2500)
end
--PATH lua/entities/obj_vj_sbdshoot1.lua:
/*--------------------------------------------------
	*** Copyright (c) 2012-2020 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
AddCSLuaFile()
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

ENT.Type 			= "anim"
ENT.Base 			= "obj_vj_projectile_base"
ENT.PrintName		= "Blaster Rod"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Information		= "Projectiles for my addons"
ENT.Category		= "Projectiles"
---------------------------------------------------------------------------------------------------------------------------------------------
if (CLIENT) then
	local Name = "Blaster Rod"
	local LangName = "obj_vj_blasterrod"
	language.Add(LangName, Name)
	killicon.Add(LangName,"HUD/killicons/default",Color(255,80,0,255))
	language.Add("#"..LangName, Name)
	killicon.Add("#"..LangName,"HUD/killicons/default",Color(255,80,0,255))
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if !(SERVER) then return end

ENT.Model = {"models/weapons/w_missile_launch.mdl"} -- The models it should spawn with | Picks a random one from the table
/*ENT.DoesRadiusDamage = true -- Should it do a blast damage when it hits something?
ENT.RadiusDamageRadius = 10 -- How far the damage go? The farther away it's from its enemy, the less damage it will do | Counted in world units
ENT.RadiusDamage = 10 -- How much damage should it deal? Remember this is a radius damage, therefore it will do less damage the farther away the entity is from its enemy
ENT.RadiusDamageUseRealisticRadius = true -- Should the damage decrease the farther away the enemy is from the position that the projectile hit?
ENT.RadiusDamageType = DMG_SHOCK -- Damage type
ENT.RadiusDamageForce = 30 -- Put the force amount it should apply | false = Don't apply any force
ENT.RadiusDamageForceTowardsPhysics = 1000 -- How much force should it deal to props?*/
ENT.DoesDirectDamage = true -- Should it do a direct damage when it hits something?
ENT.DirectDamage = 20 -- How much damage should it do when it hits something
ENT.DirectDamageType = DMG_SHOCK -- Damage type
ENT.DecalTbl_DeathDecals = {"fadingscorch"}
ENT.SoundTbl_OnCollide = {""}
ENT.SoundTbl_Startup = {"sbd/wep_GEN_sbdRocket_01.wav"}
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:CustomOnInitialize()
	self:SetMaterial("models/effects/vol_light001.mdl")
	self:DrawShadow(false)
	self:SetColor(Color(255,0,0))
	
	util.SpriteTrail(self, 0, Color(255,0,0,255), false, 255, 255, 0.3, 1/(10+1)*0.5, "VJ_Base/sprites/vj_trial1.vmt") //cable/redlaser.vmt
	//util.SpriteTrail(self,6,Color(200,0,0),true,6,6,0.1,1/(6+6)*0.5,"VJ_Base/sprites/vj_trial1.vmt")
	//ParticleEffectAttach("vj_rpg1_smoke", PATTACH_ABSORIGIN_FOLLOW, self, 0)
	
	local eyeglow2 = ents.Create("env_sprite")
	eyeglow2:SetKeyValue("model","vj_base/sprites/vj_glow1.vmt")
	eyeglow2:SetKeyValue("scale","0.04")
	eyeglow2:SetKeyValue("rendermode","5")
	eyeglow2:SetKeyValue("rendercolor","255 0 0")
	eyeglow2:SetKeyValue("spawnflags","1") -- If animated
	eyeglow2:SetPos(self:GetPos())
	eyeglow2:SetParent(self)
	//eyeglow2:Fire("SetParentAttachment","eye2",0)
	eyeglow2:Spawn()
	eyeglow2:Activate()
	self:DeleteOnRemove(eyeglow2)

	/*self.StartLight1 = ents.Create("light_dynamic")
	self.StartLight1:SetKeyValue("brightness", "1")
	self.StartLight1:SetKeyValue("distance", "200")
	self.StartLight1:SetLocalPos(self:GetPos())
	self.StartLight1:SetLocalAngles( self:GetAngles() )
	self.StartLight1:Fire("Color", "255 0 0")
	self.StartLight1:SetParent(self)
	self.StartLight1:Spawn()
	self.StartLight1:Activate()
	self.StartLight1:Fire("TurnOn", "", 0)
	self:DeleteOnRemove(self.StartLight1)*/
	
	/*self.StartLight2 = ents.Create("light_dynamic")
	self.StartLight2:SetKeyValue("brightness", "1")
	self.StartLight2:SetKeyValue("distance", "200")
	self.StartLight2:SetLocalPos(self:GetPos())
	self.StartLight2:SetLocalAngles( self:GetAngles() )
	self.StartLight2:Fire("Color", "255 0 0")
	self.StartLight2:SetParent(self)
	self.StartLight2:Spawn()
	self.StartLight2:Activate()
	self.StartLight2:Fire("TurnOn", "", 0)
	self:DeleteOnRemove(self.StartLight2)*/
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:DeathEffects(data,phys)
	local effectdata = EffectData()
	effectdata:SetOrigin(data.HitPos)
	//effectdata:SetMagnitude(500)
	util.Effect("StunstickImpact", effectdata)

	

	/*self.ExplosionLight1 = ents.Create("light_dynamic")
	self.ExplosionLight1:SetKeyValue("brightness", "1")
	self.ExplosionLight1:SetKeyValue("distance", "100")
	self.ExplosionLight1:SetLocalPos(data.HitPos)
	self.ExplosionLight1:SetLocalAngles(self:GetAngles())
	self.ExplosionLight1:Fire("Color", "255 0 0")
	self.ExplosionLight1:SetParent(self)
	self.ExplosionLight1:Spawn()
	self.ExplosionLight1:Activate()
	self.ExplosionLight1:Fire("TurnOn", "", 0)
	self:DeleteOnRemove(self.ExplosionLight1)*/
end
/*-----------------------------------------------
	*** Copyright (c) 2012-2020 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
-----------------------------------------------*/
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_roulette_table/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Roulette Table"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "LastRoundNumber")
	self:NetworkVar("Int", 1, "StartRoundIn")
end

-- This is a lot of confusing math and took me ages to actually get right on the grid. Just accept it for what it is, I cache it, so it's not really a big deal... right? :/
-- I essentially map each bet "type" based on some math, because they're all in a grid. Best way I could think of without manually mapping every button.
function ENT:GetCurrentPad(pos)
	if not self.padCache then
		self.padCache = {}
		-- Set priority
		self.padCache[1] = {} -- The outer buttons, they don't overlap and there's not many of them, so we can do them first.
		self.padCache[2] = {} -- The 2x2 overlaps, they overlap the most so they should be done second.
		self.padCache[3] = {} -- The 1x2 or 2x1 crossovers, they also overlap so they should be done before the base numbers. We put the row bets in here too.
		self.padCache[4] = {} -- The base numbers

		local startPos = Vector(4.1, -13.3, 14)
		local sizeW, sizeH = -6.2, 4.4
		-- 1 to 36 numbers
		for i=1, 36 do
			self.padCache[4]["num_"..i] = {
				boundsA = {x = (startPos.x + (sizeW*((i-1)%3))), y = (startPos.y + (sizeH*math.floor((i-1)/3)))},
				boundsB = {x = (startPos.x + (sizeW*(((i-1)%3)+1))), y = (startPos.y + (sizeH*(math.floor((i-1)/3)+1)))}
			}

			-- Add the numbers it covers
			self.padCache[4]["num_"..i].numbers = {[i] = true}

			-- Add the payout if won
			self.padCache[4]["num_"..i].payout = 35
		end

		local startPos = Vector(-1.1, -10.2, 14)
		local sizeW, sizeH = -2, 2.21
		local row = 0
		local newI
		-- The 2x2 bets
		for i=1, 22 do
			self.padCache[2]["2x2_"..i] = {
				boundsA = {x = (startPos.x + (sizeW*((i-1)%2))) + ((sizeW*2.15)*((i-1)%2)), y = (startPos.y + (sizeH*math.floor((i-1)/2))) + (sizeH*math.floor((i-1)/2))},
				boundsB = {x = (startPos.x + (sizeW*(((i-1)%2)+1))) + ((sizeW*2.15)*((i-1)%2)), y = (startPos.y + (sizeH*(math.floor((i-1)/2)+1))) + (sizeH*math.floor((i-1)/2))}
			}

			-- Add the numbers it covers
			newI = i + row
			self.padCache[2]["2x2_"..i].numbers = {}
			self.padCache[2]["2x2_"..i].numbers[newI] = true
			self.padCache[2]["2x2_"..i].numbers[newI+1] = true
			self.padCache[2]["2x2_"..i].numbers[newI+3] = true
			self.padCache[2]["2x2_"..i].numbers[newI+4] = true
			
			-- The end of a row
			if i%2 == 0 then
				row = row + 1
			end

			-- Add the payout if won
			self.padCache[2]["2x2_"..i].payout = 8
		end

		local startPos = Vector(-1.1, -12.4, 14)
		local sizeW, sizeH = -2, 2.21
		local row = 0
		local newI
		-- The horizontal bets
		for i=1, 24 do
			self.padCache[3]["hrztl_"..i] = {
				boundsA = {x = (startPos.x + (sizeW*((i-1)%2))) + ((sizeW*2.15)*((i-1)%2)), y = (startPos.y + (sizeH*math.floor((i-1)/2))) + (sizeH*math.floor((i-1)/2))},
				boundsB = {x = (startPos.x + (sizeW*(((i-1)%2)+1))) + ((sizeW*2.15)*((i-1)%2)), y = (startPos.y + (sizeH*(math.floor((i-1)/2)+1))) + (sizeH*math.floor((i-1)/2))}
			}

			-- Add the numbers it covers
			newI = i + row
			self.padCache[3]["hrztl_"..i].numbers = {}
			self.padCache[3]["hrztl_"..i].numbers[newI] = true
			self.padCache[3]["hrztl_"..i].numbers[newI+1] = true

			-- The end of a row
			if i%2 == 0 then
				row = row + 1
			end

			-- Add the payout if won
			self.padCache[3]["hrztl_"..i].payout = 17
		end

		local startPos = Vector(2.1, -10.2, 14)
		local sizeW, sizeH = -2, 2.21
		-- The vertical bets
		for i=1, 33 do
			self.padCache[3]["vrtcl_"..i] = {
				boundsA = {x = (startPos.x + (sizeW*((i-1)%3))) + ((sizeW*2.15)*((i-1)%3)), y = (startPos.y + (sizeH*math.floor((i-1)/3))) + (sizeH*math.floor((i-1)/3))},
				boundsB = {x = (startPos.x + (sizeW*(((i-1)%3)+1))) + ((sizeW*2.15)*((i-1)%3)), y = (startPos.y + (sizeH*(math.floor((i-1)/3)+1))) + (sizeH*math.floor((i-1)/3))}
			}

			-- Add the numbers it covers
			self.padCache[3]["vrtcl_"..i].numbers = {}
			self.padCache[3]["vrtcl_"..i].numbers[i] = true
			self.padCache[3]["vrtcl_"..i].numbers[i+3] = true

			-- Add the payout if won
			self.padCache[3]["vrtcl_"..i].payout = 17
		end

		local startPos = Vector(5.3, -13.3, 14)
		local sizeW, sizeH = -2, 4.4
		local start
		-- Row bets
		for i=1, 12 do
			self.padCache[3]["row_"..i] = {
				boundsA = {x = startPos.x, y = (startPos.y + (sizeH*(i-1)))},
				boundsB = {x = (startPos.x + sizeW), y = (startPos.y + (sizeH*(i)))},
			}

			-- Add the numbers it covers
			start = (i-1)*3
			self.padCache[3]["row_"..i].numbers = {[start+1] = true, [start+2] = true, [start+3] = true}

			-- Add the payout if won
			self.padCache[3]["row_"..i].payout = 11
		end

		-- 0 is bigger, so we gotta do it manually
		self.padCache[4]["num_0"] = {
			boundsA = {x = 4.3, y = -18.6},
			boundsB = {x = -14.3, y = -13.6}
		}
		-- Add the numbers it covers
		self.padCache[4]["num_0"].numbers = {[0] = true}
		-- Add the payout if won
		self.padCache[4]["num_0"].payout = 35

		local startPos = Vector(4.1, 39.5, 14)
		local sizeW, sizeH = -6.2, 4.4
		-- Sets of 12
		for i=1, 3 do
			self.padCache[1]["2to1_"..i] = {
				boundsA = {x = (startPos.x + (sizeW*(i-1))), y = startPos.y},
				boundsB = {x = (startPos.x + (sizeW*(i))), y = (startPos.y + sizeH)}
			}

			-- Add the numbers it covers
			self.padCache[1]["2to1_"..i].numbers = {}
			for n=i, 36, 3 do
				self.padCache[1]["2to1_"..i].numbers[n] = true
			end

			-- Add the payout if won
			self.padCache[1]["2to1_"..i].payout = 2
		end

		local startPos = Vector(9.3, -13.4, 14.6)
		local sizeW, sizeH = -5, 17.7
		local start
		-- Sets of 12
		for i=1, 3 do
			self.padCache[1]["12s_"..i] = {
				boundsA = {x = startPos.x, y = (startPos.y + (sizeH*(i-1)))},
				boundsB = {x = (startPos.x + sizeW), y = (startPos.y + (sizeH*(i)))},
			}

			-- Add the numbers it covers
			self.padCache[1]["12s_"..i].numbers = {}
			start = 12*(i-1)+1
			for n=start, start+11 do
				self.padCache[1]["12s_"..i].numbers[n] = true
			end

			-- Add the payout if won
			self.padCache[1]["12s_"..i].payout = 2
		end

		local startPos = Vector(14.5, -13.4, 14.6)
		local sizeW, sizeH = -5, 8.85
		local types = {"1to18", "even", "red", "black", "odd", "19to36"}
		for k, v in ipairs(types) do
			self.padCache[1][v] = {
				boundsA = {x = startPos.x, y = (startPos.y + (sizeH*(k-1)))},
				boundsB = {x = (startPos.x + sizeW), y = (startPos.y + (sizeH*(k)))},
			}

			-- Add the numbers it covers
			self.padCache[1][v].numbers = {}
			for i=1, 36 do
				if (v == "1to18") and (i <= 18) then
					self.padCache[1][v].numbers[i] = true
				elseif (v == "19to36") and (i >= 19) then 
					self.padCache[1][v].numbers[i] = true
				elseif (v == "even") and (i%2 == 0) then 
					self.padCache[1][v].numbers[i] = true
				elseif (v == "odd") and (i%2 == 1) then 
					self.padCache[1][v].numbers[i] = true
				elseif (v == "red") and table.HasValue({1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36}, i) then 
					self.padCache[1][v].numbers[i] = true
				elseif (v == "black") and table.HasValue({2, 4, 6, 8, 10, 11, 13, 15, 17, 20, 22, 24, 26, 28, 29, 31, 33, 35}, i) then 
					self.padCache[1][v].numbers[i] = true
				end
			end

			-- Add the payout if won
			self.padCache[1][v].payout = 1
		end

		-- Raise bet
		self.padCache[1]["bet_raise"] = {
			boundsA = {x = -20, y = -5.2},
			boundsB = {x = -23.7, y = -0.567747},
		}
		-- Lower bet
		self.padCache[1]["bet_lower"] = {
			boundsA = {x = -20, y = 10.5},
			boundsB = {x = -23.7, y = 15.5},
		}

		-- Find the center point of all the 3d2d inputs
		for i, _ in ipairs(self.padCache) do
			for k, v in pairs(_) do
				self.padCache[i][k].origin = {x = v.boundsA.x+((v.boundsB.x - v.boundsA.x)/2), y = v.boundsA.y+((v.boundsB.y - v.boundsA.y)/2)}
			end
		end
	end
	for i, _ in ipairs(self.padCache) do
		for k, v in pairs(_) do
			if (pos.x < v.boundsA.x) and (pos.x > v.boundsB.x) and (pos.y > v.boundsA.y) and (pos.y < v.boundsB.y) and (pos.z > 13) and (pos.z < 15) then
				return k, v
			end
		end
	end

	return false
end
function ENT:GetPadByName(padName)
	if not self.padCache then
		self:GetCurrentPad(Vector(0, 0, 0)) -- Generate the cache
	end

	for i, _ in ipairs(self.padCache) do
		for k, v in pairs(_) do
			if k == padName then
				return k, v
			end
		end
	end
end
function ENT:GetPadsFromNumber(number)
	local pads = {}

	for i, _ in ipairs(self.padCache) do
		for k, v in pairs(_) do
			if v.numbers and v.numbers[number] then
				table.insert(pads, k)
			end
		end
	end

	return pads
end

PerfectCasino.Core.RegisterEntity("pcasino_roulette_table", {
	-- Bet data
	bet = {
		betLimit = {d = 3000, t = "num"},
		default = {d = 500, t = "num"},
		max = {d = 1000, t = "num"},
		min = {d = 100, t = "num"},
		iteration = {d = 100, t = "num"}
	},
	general = {
		betPeriod = {d = 30, t = "num"} -- The default bet
	}
},
"models/freeman/owain_roulette_table.mdl")
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_sign_interior_standing/cl_init.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_sign_plaque/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Sign Plaque"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false

PerfectCasino.Core.RegisterEntity("pcasino_sign_plaque", {
	-- General data
	general = {
		text = {d = "Cool Casino", t = "string"} -- The text to show
	}
},
"models/freeman/owain_casinosign_text.mdl")
--PATH lua/entities/pfx1_03~.lua:
return gluapack()()
--PATH lua/entities/pfx1_05.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Ground Burst"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]groundflame"
--PATH lua/entities/pfx1_08#.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire [Pink]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_campfire_pink"
--PATH lua/entities/pfx1_08#_l.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Fire [Pink]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_large_campfire_pink"
--PATH lua/entities/pfx1_08_.lua:
return gluapack()()
--PATH lua/entities/pfx1_08_~a_l.lua:
return gluapack()()
--PATH lua/entities/pfx1_0c.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Medium fire"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]ground_fire_1"
--PATH lua/entities/pfx2_02.lua:
return gluapack()()
--PATH lua/entities/pfx2_02.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Gushing Blood [Large]"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]gushing_blood*"



--PATH lua/entities/pfx2_02_a_s.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Gushing Alien Blood [Alien]"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]gushing_blood_alien"
--PATH lua/entities/pfx2_06.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Dripping blood"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]blood_leak"
--PATH lua/entities/pfx3_01.lua:
return gluapack()()
--PATH lua/entities/pfx4_01_s~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Blue Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_b_s*"

--PATH lua/entities/pfx4_02~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Red Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_r*"

--PATH lua/entities/pfx4_03_s~.lua:
return gluapack()()
--PATH lua/entities/pfx4_04.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "PFX:Purple Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_v"
--PATH lua/entities/pfx4_04_s~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Purple Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_v_s*"
--PATH lua/entities/pfx4_07.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "BFG Projectile"
ENT.Category         = "PPE: Weapons" -- too lazy to move this to different entity category.
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]bfg_*proj"
--PATH lua/entities/pfx5_00_s.lua:
return gluapack()()
--PATH lua/entities/pfx5_03.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Simple Galaxy Model"
ENT.Category         = "PPE: Cosmic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[5]simple_galaxy"
--PATH lua/entities/pfx6_02.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Bullet Tracer"
ENT.Category         = "PPE: Weapons"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[6]bullet_tracer_generic"
--PATH lua/entities/pfx7_04.lua:
return gluapack()()
--PATH lua/entities/pfx8_01.lua:
return gluapack()()
--PATH lua/entities/pfx8_03_alt.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Green Portal"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]magic_portal*"
--PATH lua/entities/pfx8_04.lua:
return gluapack()()
--PATH lua/entities/pfx8_05.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Magic Orb 1"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]ball_core"
--PATH lua/entities/pfx8_07.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Frostbeam"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]frostbeam"
--PATH lua/entities/pfx9_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Colorful Trail"
ENT.Category         = "PPE: Trails"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[9]colorful_trail_1"
--PATH lua/entities/prop_vj_animatable/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

ENT.Base 			= "base_gmodentity"
ENT.Type 			= "anim"
ENT.PrintName 		= "VJ Prop Animatable"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "Used to make simple props and animate them, since prop_dynamic doesn't work properly in Garry's Mod."
ENT.Instructions 	= "Don't change anything."
ENT.Category		= "VJ Base"

ENT.Spawnable = false
ENT.AdminOnly = false
ENT.AutomaticFrameAdvance = true
//ENT.RenderGroup = RENDERGROUP_BOTH
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	function ENT:Draw()
		self:DrawModel()
	end
	
	function ENT:DrawTranslucent()
		self:Draw()
	end
end

--PATH lua/entities/rw_sw_dispencer_grenade/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

local dispencer_health = GetConVar("rw_sw_dispenser_health"):GetInt()
ENT.BaseHealth = dispencer_health

ENT.PrintName		= "Grenade Dispenser"
ENT.Author			= "ChanceSphere574"
ENT.Category		= "StarWars Reworked Armory"
ENT.Spawnable 		= true
ENT.AdminSpawnable	= false

ENT.UseTimer = CurTime()
ENT.Status   = 0

ENT.LoadingSkin = 3
ENT.CurSkin = 2
--PATH lua/entities/rw_sw_dispencer_rocket/cl_init.lua:
return gluapack()()
--PATH lua/entities/sent_vj_ply_spawnpoint.lua:
return gluapack()()
--PATH lua/entities/slave.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/spawned_shipment/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Shipment"
ENT.Author = "philxyz"
ENT.Spawnable = false
ENT.IsSpawnedShipment = true

function ENT:SetupDataTables()
    self:NetworkVar("Int",0,"contents")
    self:NetworkVar("Int",1,"count")
    self:NetworkVar("Float", 0, "gunspawn")
    self:NetworkVar("Entity", 0, "owning_ent")
    self:NetworkVar("Entity", 1, "gunModel")
end

DarkRP.declareChatCommand{
    command = "splitshipment",
    description = "Split the shipment you're looking at.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "makeshipment",
    description = "Create a shipment from a dropped weapon.",
    delay = 1.5
}

--PATH addons/[bronie] republic-essentials-v2d/lua/entities/tfa_battlefront_ent_nade_impact.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.Spawnable = false

function ENT:Draw()
    self:DrawModel()
end

function ENT:Initialize()
    if SERVER then
        self:SetModel( "models/forrezzur/impactgrenade.mdl" )
        self:PhysicsInit(SOLID_VPHYSICS)
    self:SetSolid(SOLID_VPHYSICS)

    local phys = self:GetPhysicsObject()
    if (IsValid(phys)) then
        phys:SetMass(1)
    end
        self:DrawShadow( true )
    end
    self.ExplodeTimer = CurTime() + 100000
end

function ENT:PhysicsCollide( data, phys )
    if  (20 < data.Speed and 0.25 < data.DeltaTime) then
    self.ExplodeTimer = 0
    end
end

function ENT:Think()
    if SERVER and (self.ExplodeTimer and self.ExplodeTimer <= CurTime()) then
        self:Explode()
    end
    self:NextThink(CurTime())
    return true
end

function ENT:Explode()
	local effectdata = EffectData()
    effectdata:SetOrigin( self:GetPos() )
    util.Effect("Explosion", effectdata)
    util.BlastDamage( self, self.Owner, self:GetPos(), 150, 100 )
    local spos = self:GetPos()
    local trs = util.TraceLine({start=spos + Vector(0,0,64), endpos=spos + Vector(0,0,-32), filter=self})
    util.Decal("Scorch", trs.HitPos + trs.HitNormal, trs.HitPos - trs.HitNormal)    
    self:Remove()
end

function ENT:OnRemove()
end
--PATH lua/entities/tfbow_arrow/shared.lua:
local vector_origin = Vector()

ENT.Type = "anim"
ENT.PrintName = "TFBow Arrow"
ENT.Author = "TheForgottenArchitect"
ENT.Contact = "Don't"
ENT.Purpose = "Arrow Entity"
ENT.Instructions = "Spawn this with a velocity, get rich"

local function GetBoneCenter(ent, bone)
	local bonechildren = ent:GetChildBones(bone)

	if #bonechildren <= 0 then
		return ent:GetBonePosition(bone)
	else
		local bonepos = ent:GetBonePosition(bone)
		local tmppos = bonepos

		if tmppos then
			for i = 1, #bonechildren do
				local childpos = ent:GetBonePosition(bonechildren[i])

				if childpos then
					tmppos = (tmppos + childpos) / 2
				end
			end
		else
			return ent:GetPos()
		end

		return tmppos
	end
end

function ENT:GetClosestBonePos(ent, pos)
	local i, count, dist, ppos, cbone
	i = 1
	count = ent:GetBoneCount()
	cbone = 0
	dist = 99999999
	ppos = ent:GetPos()

	while (i < count) do
		local bonepos = GetBoneCenter(ent, i)

		if bonepos:Distance(pos) < dist then
			dist = bonepos:Distance(pos)
			cbone = i
			ppos = bonepos
		end

		i = i + 1
	end

	return ppos, cbone
end

local cv_al = GetConVar("sv_tfa_arrow_lifetime")
local cv_ht = GetConVar("host_timescale")

function ENT:Initialize()
	if SERVER then
		if not IsValid(self.myowner) then
			self.myowner = self:GetOwner()

			if not IsValid(self.myowner) then
				self.myowner = self
			end
		end

		timer.Simple(0, function()
			if self.model then
				self:SetModel(self.model)
			end
		end)

		if cv_al:GetInt() ~= -1 then
			timer.Simple( cv_al:GetFloat() + 5, function()
				if IsValid(self) then
					self:Remove()
				end
			end)
		end

		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		local phys = self:GetPhysicsObject()

		if (phys:IsValid()) then
			phys:Wake()

			if self.velocity then
				phys:SetVelocityInstantaneous(self.velocity)
			end

			phys:EnableCollisions(false)
			self:StartMotionController()
			self:PhysicsUpdate(phys, 0.1 * cv_ht:GetFloat() )
		end
	end

	self:SetNW2Vector("lastpos", self:GetPos())

	if not self.mydamage then
		self.mydamage = 60
	end

	if not self.gun then
		if IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() then
			self:UpdateGun()
		else
			timer.Simple(0, function()
				if IsValid(self) and IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() then
					self:UpdateGun()
				end
			end)
		end
	end
end

function ENT:UpdateGun()
	local wep = self:GetOwner():GetActiveWeapon()

	if IsValid(wep) then
		self.gun = wep:GetClass()
	end
end

local wl,tracedata,tr

local cv_fm = GetConVar("sv_tfa_force_multiplier")

function ENT:HitCB(a,b,c)
	c:SetDamageType(bit.bor(DMG_NEVERGIB, DMG_CLUB))

	if IsValid(self) and IsValid(self:GetOwner()) then
		if b.HitWorld then
			local arrowstuck = ents.Create("tfbow_arrow_stuck")
			arrowstuck:SetModel(self:GetModel())
			arrowstuck.gun = self.gun
			arrowstuck:SetPos(tr.HitPos)
			local phys = self:GetPhysicsObject()
			arrowstuck:SetAngles((phys:GetVelocity()):Angle())
			arrowstuck:Spawn()
		else
			if IsValid(b.Entity) then
				if (not b.Entity:IsWorld()) then
					local arrowstuck = ents.Create("tfbow_arrow_stuck_clientside")
					arrowstuck:SetModel(self:GetModel())
					arrowstuck:SetPos(tr.HitPos)
					local ang = self:GetAngles()
					arrowstuck.gun = self.gun
					arrowstuck:SetAngles(ang)
					arrowstuck.targent = tr.Entity
					arrowstuck.targphysbone = tr.PhysicsBone
					arrowstuck:Spawn()
				else
					local arrowstuck = ents.Create("tfbow_arrow_stuck")
					arrowstuck:SetModel(self:GetModel())
					arrowstuck.gun = self.gun
					arrowstuck:SetPos(tr.HitPos)
					arrowstuck:SetAngles(self:GetAngles())
					arrowstuck:Spawn()
				end
			end
		end

		self:Remove()
	elseif IsValid(self) then
		self:Remove()
	end
end

function ENT:Think()
	wl = self:WaterLevel()

	if not self.prevwaterlevel then
		self.prevwaterlevel = wl
	end

	if self.prevwaterlevel ~= wl and wl - self.prevwaterlevel >= 1 then
		--print(wl)
		local ef = EffectData()
		ef:SetOrigin(self:GetPos())
		util.Effect("watersplash", ef)
	end

	self.prevwaterlevel = wl

	if wl >= 2 then
		local phys = self:GetPhysicsObject()

		if IsValid(phys) then
			phys:SetVelocity(phys:GetVelocity() * math.sqrt(9 / 10))
		end
	end

	tracedata = {}
	tracedata.start = self:GetNW2Vector("lastpos", self:GetPos())
	tracedata.endpos = self:GetPos()
	tracedata.mask = MASK_SOLID
	tracedata.filter = {self.myowner, self:GetOwner(), self}
	tr = util.TraceLine(tracedata)

	--self:SetAngles((((tracedata.endpos-tracedata.start):GetNormalized()+self:GetAngles():Forward())/2):Angle())
	if (tr.Hit and tr.Fraction < 1 and tr.Fraction > 0) then
		debugoverlay.Line(tracedata.start, tr.HitPos, 10, Color(255, 0, 0, 255), true)
		debugoverlay.Cross(tr.HitPos, 5, 10, Color(255, 0, 0, 255), true)

		if SERVER then
			--[[
			local bul ={}
			bul.Attacker=self:GetOwner() and self:GetOwner() or self:GetOwner()
			bul.Spread=vector_origin
			bul.Src=tracedata.start
			bul.Force=self.mydamage*0.25*GetConVarNumber("sv_tfbow_force_multiplier",1)
			bul.Damage=self.mydamage
			bul.Tracer	= 0							-- Show a tracer on every x bullets
			bul.TracerName = "None"
			bul.Dir=((tr.HitPos-bul.Src):GetNormalized())

			bul.Attacker:FireBullets( bul )
			]]
			--
			local bul = {}
			bul.Attacker = self:GetOwner() and self:GetOwner() or self:GetOwner()
			bul.Spread = vector_origin
			bul.Src = tracedata.start
			bul.Force = self.mydamage * 0.25 * cv_fm:GetFloat()
			bul.Damage = self.mydamage
			bul.Tracer = 0 -- Show a tracer on every x bullets
			bul.TracerName = "None"
			bul.Dir = (tr.HitPos - bul.Src):GetNormalized()

			bul.Callback = function(a, b, c)
				self:HitCB(a,b,c)
			end

			bul.Attacker:FireBullets(bul)
		end

		return
	end

	self:SetNW2Vector("lastpos", self:GetPos())
end

--PATH addons/[tfres] datapad/lua/entities/tfres_arrests/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Tablica Aresztów"
ENT.Category = "[Tfres] Datapad"
ENT.Author = "Troy"
ENT.Spawnable = true

if CLIENT then
    function ENT:Initialize()
        if IsValid(self.Panel) then return end
        self.Panel = vgui.Create("DHTML")
        self.Panel:SetSize(500, 700)
        self.Panel:SetPaintedManually(true)
        self.Panel:SetHTML([[
<!DOCTYPE html>
<html>
<head>
    <style>
        html, body {
            margin: 0;
            padding: 20px;
            font-family: 'Orbitron', sans-serif;
            background-color: #300000;
            color: white;
            overflow: hidden;
        }
        h1 {
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 24px;
            color: #ff4444;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .entry {
            background-color: rgba(255, 50, 50, 0.15);
            border: 1px solid #cc0000;
            border-radius: 10px;
            margin-bottom: 15px;
            padding: 10px 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            margin-right: 10px;
        }
        .text {
            flex: 1;
            text-align: left;
        }
        .time {
            font-weight: bold;
            font-size: 16px;
            color: #ffaaaa;
        }
    </style>
</head>
<body>
    <h1>Lista aresztów</h1>
    <div id="list"></div>

    <script>
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return minutes + ':' + (secs < 10 ? '0' + secs : secs);
        }

        function updateList(data, ostime = Date.now() / 1000) {
            const list = document.getElementById('list');
            list.innerHTML = '';

            data.forEach(entry => {
                const div = document.createElement('div');
                div.className = 'entry';

                const avatar = document.createElement('div');
                avatar.className = 'avatar';
                avatar.style.backgroundImage = 'url(' + entry.avatar + ')';

                const text = document.createElement('div');
                text.className = 'text';
                text.textContent = entry.nick;

                const time = document.createElement('div');
                time.className = 'time';
                time.textContent = '';

                div.appendChild(avatar);
                div.appendChild(text);
                div.appendChild(time);

                list.appendChild(div);

                const startTime = entry.start;
                const duration = entry.duration;
                const clientOffset = Date.now() / 1000 - ostime;
                const arrestEnd = startTime + duration;

                function updateCountdown() {
                    const now = Date.now() / 1000 - clientOffset;
                    const remaining = Math.max(0, Math.floor(arrestEnd - now));
                    time.textContent = formatTime(remaining);
                    if (remaining <= 0) clearInterval(interval);
                }

                updateCountdown();
                const interval = setInterval(updateCountdown, 1000);
            });
        }

        window.gmod = window.gmod || {};

        window.gmod.setArrests = function(data) {
            const arrests = data.map(item => ({
                nick: item.nick,
                avatar: item.avatar,
                start: item.start,
                duration: item.czas
            }));
            const ostime = data.OSTIME || Date.now() / 1000;
            updateList(arrests, ostime);
        };

        if (!window.gmod.__inGMod) {
            updateList([
                {
                    nick: "CypherX",
                    avatar: "https://i.pravatar.cc/32?u=cypherx",
                    start: Math.floor(Date.now() / 1000) - 30,
                    duration: 150
                },
                {
                    nick: "NovaBlade",
                    avatar: "https://i.pravatar.cc/32?u=novablade",
                    start: Math.floor(Date.now() / 1000) - 60,
                    duration: 300
                },
                {
                    nick: "Echo22",
                    avatar: "https://i.pravatar.cc/32?u=echo22",
                    start: Math.floor(Date.now() / 1000) - 10,
                    duration: 90
                }
            ]);
        }
    </script>
</body>
</html>

        ]])
    end

    function ENT:Draw()
        --self:DrawModel()

        if not IsValid(self.Panel) then self:Initialize() return end

        local ang = self:GetAngles()
        local pos = self:GetPos() + self:GetRight() * 25

        --ang:RotateAroundAxis(ang:Right(), 90)
        ang:RotateAroundAxis(ang:Up(), 90)

        cam.Start3D2D(pos, ang, 0.1)
            self.Panel:PaintManual()
        cam.End3D2D()
    end

    function ENT:Think()
        if not IsValid(self.Panel) then return end

        local data = {}
        for sid64, info in pairs(tfres["Datapad"].ArrestTable or {}) do
            local timeLeft = math.max(0, info.start +info.czas - CurTime())
            local mins = math.floor(timeLeft / 60)
            local secs = math.floor(timeLeft % 60)
            local ply = player.GetBySteamID64(sid64)
            --if !ply then continue end
            table.insert(data, {
                nick = info.nick or "Nieznany",
                start = info.start,
                czas = info.czas,
                avatar = ""
            })
        end

        local json = util.TableToJSON(data)
        json = string.Replace(json, "\\", "\\\\")
        json = string.Replace(json, "\"", "\\\"")

        self.Panel:Call("gmod.setArrests(JSON.parse(\"" .. json .. "\"))")
        self:NextThink(CurTime() + 1)
        return true
    end

    function ENT:OnRemove()
        if IsValid(self.Panel) then
            self.Panel:Remove()
        end
    end
end
--PATH lua/entities/tie_interceptor.lua:

ENT.RenderGroup = RENDERGROUP_OPAQUE
ENT.Base = "fighter_base"
ENT.Type = "vehicle"

ENT.PrintName = "TIE Interceptor"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Empire"
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.EntModel = "models/tieinter/tieinterceptor.mdl"
ENT.Vehicle = "TIEInterceptor"
ENT.StartHealth = 2250;
ENT.Allegiance = "Empire";
list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then

ENT.FireSound = Sound("weapons/tie_shoot.wav");
ENT.NextUse = {Wings = CurTime(),Use = CurTime(),Fire = CurTime(),};


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("tie_interceptor");
	e:SetPos(tr.HitPos + Vector(0,0,-50));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()


	self:SetNWInt("Health",self.StartHealth);
	
	self.WeaponLocations = {
		BottomRight = self:GetPos()+self:GetUp()*142.5+self:GetRight()*112.5+self:GetForward()*175,
		TopRight = self:GetPos()+self:GetUp()*217.5+self:GetRight()*112.5+self:GetForward()*175,
		BottomLeft = self:GetPos()+self:GetUp()*142.5+self:GetRight()*-142.5+self:GetForward()*175,
		TopLeft = self:GetPos()+self:GetUp()*217.5+self:GetRight()*-142.5+self:GetForward()*175,
	}
	self.WeaponsTable = {};
	self.BoostSpeed = 2500;
	self.ForwardSpeed = 1250;
	self.UpSpeed = 500;
	self.AccelSpeed = 7;
	self.CanBack = true;
	self.CanRoll = true;
	self.CanStandby = true;
	self.Cooldown = 2;

	self.CanShoot = true;
	self.Bullet = CreateBulletStructure(60,"green");
	self.FireDelay = 0.15;
	self.AlternateFire = true;
	self.FireGroup = {"BottomLeft","TopLeft","BottomRight","TopRight"};

	self.LandOffset = Vector(0,0,-50);
	
	self.ExitModifier = {x=0,y=225,z=100};
	
	self.BaseClass.Initialize(self);
end


end

if CLIENT then
	
	ENT.CanFPV = true;
	ENT.Sounds={
		Engine=Sound("vehicles/tie/tie_interceptor4.wav"),
	}
	
    ENT.ViewDistance = 700;
    ENT.ViewHeight = 300;
    ENT.FPVPos = Vector(50,15,180);
	
	local HUD = surface.GetTextureID("vgui/tie_cockpit");
	function TIEInterceptorReticle()
		
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingTIEInterceptor");
		local self = p:GetNWEntity("TIEInterceptor");
		if(Flying and IsValid(self)) then
			local FPV = self:GetFPV();
			if(FPV) then
				SW_HUD_FPV(HUD);
			end
			SW_HUD_DrawHull(2250);
			SW_WeaponReticles(self);
			SW_HUD_DrawOverheating(self);
			
			local x = ScrW()/4*0.6;
			local y = ScrH()/4*0.825;
			SW_HUD_Compass(self,x,y);
			SW_HUD_DrawSpeedometer();
		end
	end
	hook.Add("HUDPaint", "TIEInterceptorReticle", TIEInterceptorReticle)

end
--PATH lua/entities/trace2/cl_init.lua:
include('shared.lua')

local matBeam                   = Material( "cable/steel" )

function ENT:Initialize()              
	self.Size = 0
	self.MainStart = self.Entity:GetPos()
	self.MainEnd = self:GetEndPos()
	self.dAng = (self.MainEnd - self.MainStart):Angle()
	self.speed = GetConVarNumber("grapple_latch_speed") --5000
	self.startTime = CurTime()
	self.endTime = CurTime() + self.speed
	self.dt = -1   
end

function ENT:Think()
	self.Entity:SetRenderBoundsWS( self:GetEndPos(), self.Entity:GetPos(), Vector()*8 )

	self.Size = math.Approach( self.Size, 1, 10*FrameTime() )
end

function ENT:DrawMainBeam( StartPos, EndPos, dt, dist )

	local TexOffset = 0
	--local ca = Color(255,255,255,255)
	local lcolor = render.ComputeLighting( StartPos, Vector( 0, 0, 1 ) )
	lcolor.x = 1 * ( math.Clamp( lcolor.x, 0, 1 ) + 0.01 ) * 255
	lcolor.y = 1 * ( math.Clamp( lcolor.y, 0, 1 ) + 0.01 ) * 255
	lcolor.z = 1 * ( math.Clamp( lcolor.z, 0, 1 ) + 0.01 ) * 255
	local newcolor = Color(lcolor.x, lcolor.y, lcolor.z, 255)

	EndPos = StartPos + (self.dAng * ((1 - dt)*dist))

	-- Beam effect
	render.SetMaterial( matBeam )
	render.DrawBeam( EndPos, StartPos,2,TexOffset*-0.4, TexOffset*-0.4 + StartPos:Distance(EndPos) / 256,newcolor )
	
	self.proj = ClientsideModel("models/weapons/c_models/c_grapple_proj/c_grapple_proj.mdl")
	self.proj:SetNoDraw(true)
	--self.proj:SetParent(self)
	self.proj:SetPos(EndPos)  
	self.proj:SetAngles(gbAngle + Angle(0,0,0))  
	self.proj:SetModelScale(1, 0) 
	self.proj:DrawModel()
	self.proj:Remove()
end

function ENT:Draw()

	local Owner = self.Entity:GetOwner()
	if (!Owner || Owner == NULL) then return end

	local StartPos          = self.Entity:GetPos()
	local EndPos            = self:GetEndPos()
	local ViewModel         = Owner == LocalPlayer()
     
	if (EndPos == Vector(0,0,0)) then return end

	if ( ViewModel ) then
		local vm = Owner:GetViewModel()
		if (!vm || vm == NULL) then return end
		local attachment = vm:GetAttachment( 1 )
		StartPos = attachment.Pos
	else
		local vm = Owner:GetActiveWeapon()
		if (!vm || vm == NULL) then return end
		local attachment = vm:GetAttachment( 1 )
		StartPos = attachment and attachment.Pos
	end
     
	if not StartPos then return end

	local TexOffset = CurTime() * -2
	local Distance = EndPos:Distance( StartPos ) * self.Size
	local et = (self.startTime + (Distance/self.speed))
	
	if self.dt != 0 then
		self.dt = (et - CurTime()) / (et - self.startTime)
	end
	
	if self.dt < 0 then
		self.dt = 0
	end
	self.dAng = (EndPos - StartPos):Angle():Forward()

	gbAngle = (EndPos - StartPos):Angle()
	local Normal = gbAngle:Forward()

	self:DrawMainBeam( StartPos, StartPos + Normal * Distance, self.dt, Distance )
end

function ENT:IsTranslucent()
	return true
end
--PATH lua/entities/training_orb/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
 
ENT.PrintName= "Training orb"
ENT.Author= "Eternal"
ENT.Contact= "Via steam"
ENT.Purpose= "A jedi training orb to perfection your deflecting skills"
ENT.Instructions= "Press E to start training"
ENT.Category= "Eternal's miscellaneous"
ENT.Spawnable = true
ENT.AdminSpawnable = true

local function DoFlying( self , activator)
	local radius = 100
	local name = tostring(math.Rand(0,100))
	self:SetVar("timername", name)
	local plypos = 0
	local angle = 0
	local Xmovement = 0
	local Ymovement = 0
	local position = Vector(0,0,0)
	local dest = Vector(0,0,0)
	local tabbullet = {}
	tabbullet.Src=self:GetPos()
	tabbullet.Dir=self:GetAngles():Forward()
	tabbullet.Spread=Vector(0,0,0)
	tabbullet.Tracer=1	
	tabbullet.Force=0
	tabbullet.Damage=10
	tabbullet.Num=1
	self:SetVelocity(Vector(0,0,50))
	timer.Simple(1.5, function()
    	self:SetVelocity(Vector(0,0,-50))
    	timer.Create(name, 1.5, 0, function()
    		angle = math.random(1,360)
    		plypos = activator:GetPos()
			Xmovement = (plypos.x + (math.cos(angle) * radius)) - self:GetPos().x
			Ymovement = (plypos.y + (math.sin(angle) * radius)) - self:GetPos().y
			self:SetVelocity(Vector(Xmovement,Ymovement,0))
			timer.Simple(math.Rand(0.5,1), function()
				if (self:IsValid()) then
					self:SetVelocity(Vector(-self:GetVelocity().x, -self:GetVelocity().y, 0))
					self:PointAtEntity(activator)
					tabbullet.Src=self:GetPos() + self:GetAngles():Forward()*5
					tabbullet.Dir=self:GetAngles():Forward()*10 + activator:GetAngles():Up()*3
					self:EmitSound("heavy_blaster")
					self:FireBullets(tabbullet, false)
				end
			end)
    	end)
    end)
end

function ENT:Use( activator, caller )
	if (self:IsValid()) then
    	DoFlying(self, activator)
	end
end
--PATH lua/entities/tx-ex/shared.lua:
ENT.Type = "anim"
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "TX-130 / TX-130-T"
ENT.Author = "Dec"
ENT.Information = "Republic Fighter Tank"
ENT.Category = "[LVS] SW-Vehicles"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/tkaro/starwars/vehicle/tx130/tx130.mdl"
ENT.GibModels = {
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_charge_gib.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_flap_gib.mdl",
    "models/tkaro/starwars/vehicle/tx130/gibs/tx130_hatch_gib.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_main_gib.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_sidegun_gib_1.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_sidegun_gib_2.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_model_turret_gib.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_wing_gib_1.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_wing_gib_2.mdl",
}

ENT.AITEAM = 2

ENT.ForceAngleMultiplier = 3
ENT.ForceAngleDampingMultiplier = 3

ENT.ForceLinearMultiplier = 3
ENT.ForceLinearRate = 3

ENT.SpawnNormalOffset = 50

ENT.MaxHealth = 3000
ENT.MaxShield = 0
ENT.MaxVelocityX = 400
ENT.BoostAddVelocitX = 500
ENT.IgnoreWater = false

ENT.MaxTurnRate = 1
ENT.RotorPos = Vector(-68,0,18)

ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100


function ENT:OnSetupDataTables()

	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Entity", "SecondGunnerSeat" )

	self:NetworkVar( "Int",18, "DoorMode" )
	self:NetworkVar( "Bool",19, "BTLFire" )
	self:NetworkVar( "Bool",21, "RearHatch" )
	self:NetworkVar( "Bool",22, "WeaponOutOfRange" )
	self:NetworkVar( "Bool",23, "FrontInRange" )

end

function ENT:CalcMainActivityPassenger( ply )
end

function ENT:CalcMainActivity( ply )
	local guner = self:GetGunnerSeat()

    if ply ~= guner:GetDriver() then return self:CalcMainActivityPassenger( ply ) end

    if ply.m_bWasNoclipping then 
        ply.m_bWasNoclipping = nil 
        ply:AnimResetGestureSlot( GESTURE_SLOT_CUSTOM ) 
        
        if CLIENT then 
            ply:SetIK( true )
        end 
    end 

    ply.CalcIdeal = ACT_STAND
    ply.CalcSeqOverride = ply:LookupSequence( "idle_all_02" )

    return ply.CalcIdeal, ply.CalcSeqOverride
end


ENT.EngineSounds = {
	{
		channel = CHAN_STATIC,
		volume = 1.1,
		level = 100,
		sound = "lfs/tx130/engine.wav"
	},
	{
		channel = CHAN_STATIC,
		volume = 1,
		level = 90,
		sound = "lfs/tx130/interior.wav"
	},
	{
		sound = "lvs/vehicles/iftx/dist.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 85,
	},
}

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,30)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)


function ENT:InitWeapons()
	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)
	self.curfire = false

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0.40
	weapon.HeatRateDown = 0.8
	weapon.Attack = function( ent )

		local ID_L = self:LookupAttachment( "muzzle_left" )
		local ID_R = self:LookupAttachment( "muzzle_right" )
		local MuzzleL = self:GetAttachment( ID_L )
		local MuzzleR = self:GetAttachment( ID_R )
		
		if not MuzzleL or not MuzzleR then return end
			
		
		self:EmitSound( "lfs/tx130/twincannonlaser.wav" )
	
		self.MirrorPrimary = not self.MirrorPrimary
	
		local Pos = self.MirrorPrimary and MuzzleL.Pos or MuzzleR.Pos
		local Dir = (self.MirrorPrimary and MuzzleL.Ang or MuzzleR.Ang):Up()

		print(Dir)
		--if Dir < 150 then
			--local Pos = self:WorldToLocal(Pos) + Vector(0,0,10)
		--end

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_green_short"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 150
		bullet.SplashDamage	= 100
		bullet.SplashDamageRadius	= 200
		bullet.Velocity = 	9000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,0,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_concussion_explosion", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,50,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:LVSFireBullet( bullet )
		util.ScreenShake(self:GetPos(), 35, 10, 0.5, 550, true )
	end
	weapon.OnThink = function( ent, active )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 360) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 20
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0.9
	weapon.Attack = function( ent )
		timer.Simple( 0, function()
			if self:GetDoorMode() == 0 then return end
		
			local ID1 = self:LookupAttachment( "left_launch_tube_1" )
			local ID2 = self:LookupAttachment( "right_launch_tube_1" )
			local ID3 = self:LookupAttachment( "left_launch_tube_2" )
			local ID4 = self:LookupAttachment( "right_launch_tube_2" )
			local ID5 = self:LookupAttachment( "left_launch_tube_3" )
			local ID6 = self:LookupAttachment( "right_launch_tube_3" )
			local ID7 = self:LookupAttachment( "left_launch_tube_4" )
			local ID8 = self:LookupAttachment( "right_launch_tube_4" )
			local ID9 = self:LookupAttachment( "left_launch_tube_5" )
			local ID10 = self:LookupAttachment( "right_launch_tube_5" )
		
			local Muzzle1 = self:GetAttachment( ID1 )
			local Muzzle2 = self:GetAttachment( ID2 )
			local Muzzle3 = self:GetAttachment( ID3 )
			local Muzzle4 = self:GetAttachment( ID4 )
			local Muzzle5 = self:GetAttachment( ID5 )
			local Muzzle6 = self:GetAttachment( ID6 )
			local Muzzle7 = self:GetAttachment( ID7 )
			local Muzzle8 = self:GetAttachment( ID8 )
			local Muzzle9 = self:GetAttachment( ID9 )
			local Muzzle10 = self:GetAttachment( ID10 )
			
			local FirePos = {
				[1] = Muzzle1,
				[2] = Muzzle2,
				[3] = Muzzle3,
				[4] = Muzzle4,
				[5] = Muzzle5,
				[6] = Muzzle6,
				[7] = Muzzle7,
				[8] = Muzzle8,
				[9] = Muzzle9,
				[10] = Muzzle10,
			}
			
			if not FirePos then return end
			self.FireIndex2 = self.FireIndex2 and self.FireIndex2 + 1 or 1
			if self.FireIndex2 > 10 then
				self.FireIndex2 = 1
			end
			self:EmitSound( "lfs/tx130/rocket.wav" )

		
			local Pos = FirePos[self.FireIndex2].Pos
			if not IsValid( ent ) then return end

			if ent:GetAmmo() <= 0 then ent:SetHeat( 1 ) return end
			ent:TakeAmmo()
			local Dir =  FirePos[self.FireIndex2].Angle

			local trace = ent:GetEyeTrace()

			local Driver = self:GetDriver()

			local Pos = self:WorldToLocal( Pos ) + Vector(25,0,10)	
			local projectile = ents.Create( "lvs_protontorpedo" )
			projectile:SetPos( self:LocalToWorld(Pos) )
			projectile:SetAngles( self:GetAngles() )
			projectile:SetParent( ent )
			projectile:Spawn()
			projectile:Activate()
			projectile.GetTargetPos = function( projectile )
				return projectile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-5,5) )
			end
			projectile:SetAttacker(Driver)
			projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
			projectile:SetDamage( 1500 )
			projectile:SetRadius( 300 )
			projectile:Enable()

			ent:SetHeat( 1 )
			ent:SetOverheated( true )

			for i=1,2 do
				local effectdata = EffectData()
				effectdata:SetOrigin(  self:LocalToWorld(Pos - Vector(0,0,30)) )
				effectdata:SetRadius(80 * 80)
				effectdata:SetScale(10 * 10)
				util.Effect( "ThumperDust", effectdata, true, true )
			end

		end)
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 30) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = 20
	weapon.Delay = 0
	weapon.HeatRateUp = 0.8
	weapon.HeatRateDown = 0.4
	weapon.Attack = function( ent )
		local Pod = self:GetGunnerSeat()
		local Driver = Pod:GetDriver()
		if self:GetBodygroup(1) == 1 then
			if IsValid( Driver ) and IsValid( Pod ) then
				local veh = ent:GetVehicle()
				self:SetBTLFire( true )
				if self.curfire == false then
					veh.SecSND:PlayOnce()
					self.curfire = true
				end
				
				local ID = self:LookupAttachment( "lazer_cannon_muzzle" )
				local Muzzle = self:GetAttachment( ID )
							
				local Dir = Muzzle.Ang:Up()
				local startpos = Muzzle.Pos
						
				local Trace = util.TraceLine( {
					start = startpos,
					endpos = (startpos + Dir * 50000),
				} )
					
				self:BallturretDamage( Trace.Entity, Driver, Trace.HitPos, Dir )
			end
		end
	end
	weapon.FinishAttack = function( ent )
		self:SetBTLFire( false )
		self.curfire = false
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if self:GetBodygroup(1) == 1 then

			local Pos2D = base:TraceBTL().HitPos:ToScreen()

			base:PaintCrosshairCenter( Pos2D, color_white )
			base:PaintCrosshairOuter( Pos2D, color_white )
			base:LVSPaintHitMarker( Pos2D )
		end
	end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.4
	weapon.StartAttack = function( ent )
		if (self.turmount) then
			self.turmount = false
			self:SetBodygroup(1, 0)
		else
			self:SetBodygroup(1, 1)
			self.turmount = true
		end
	end
	self:AddWeapon( weapon, 3 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		if self.lighton == true then
			self:SetBodygroup(9, 0)
			self.lighton = false
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		else
			self.lighton = true
			self:SetBodygroup(9, 1)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		end
	end
	self:AddWeapon( weapon, 3 )
end

function ENT:TraceBTL()
	local ID = self:LookupAttachment( "lazer_cannon_muzzle" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end
--PATH lua/entities/unitys-lvs-tx-2112/cl_init.lua:
return gluapack()()
--PATH lua/entities/v-wing.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/ar2tracer_custom.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/ar2tracer_custom.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

EFFECT.Mat = Material( "effects/gunshiptracer" )

function EFFECT:Init( data )
	self.StartPos = data:GetStart()
	self.EndPos = data:GetOrigin()
	
	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 15000 )
	self.Length = 0.3

	self.DieTime = CurTime() + self.TracerTime
end

function EFFECT:Think()

	if CurTime() > self.DieTime then
		return false
	end

	return true

end

function EFFECT:Render()

	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 )

	local sinWave = math.sin( fDelta * math.pi )
	
	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )
	
	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
		8, 1, 0, color_white )
end

--PATH lua/effects/arc9_magdropeffect.lua:
return gluapack()()
--PATH lua/effects/arc9_shelleffect.lua:
return gluapack()()
--PATH lua/effects/asa6_tracer_noattach.lua:
return gluapack()()
--PATH lua/effects/astw2_muzzleflash_swrc_red/init.lua:
return gluapack()()
--PATH lua/effects/astw2_muzzleflash_swrc_tran/init.lua:
local AddVel = Vector()

function EFFECT:Init(data)
    local quality = GetConVar("astw2_quality"):GetInt()
    if GetConVar("astw2_force_effect_minlevel_1"):GetBool() and quality == 0 then
        quality = 1
    end

    if quality == 0 then return end

    self.WeaponEnt = data:GetEntity()
    if !IsValid(self.WeaponEnt) then return end
    self.Owner = self.WeaponEnt:GetOwner()
    if !IsValid(self.Owner) then return end
    local dir = data:GetNormal()
    local scale = self.WeaponEnt.Primary.Damage
    scale = scale * 0.07

    self.vOffset = self.WeaponEnt:GetBorePos()

    AddVel = self.WeaponEnt.Owner:GetVelocity()

    local emitter = ParticleEmitter(self.vOffset)

    if !self.WeaponEnt.Suppressed then
        local particle = emitter:Add("effects/swrc/a_FLASHORANGE", self.vOffset)

        if (particle) then
            particle:SetVelocity(AddVel)
            particle:SetLifeTime(0)
            particle:SetDieTime(math.Rand(0.07 ,0.1))
            particle:SetStartAlpha(255)
            particle:SetEndAlpha(155)
            particle:SetStartSize(math.Rand(5, 10))
            particle:SetEndSize(scale * math.Rand(40, 60))
            particle:SetLighting(false)
            particle:SetRoll(math.random(0, 0))
            particle:SetColor(255, 200, 155)
        end
	        local particle2 = emitter:Add("effects/swrc/shotgun_frontal", self.vOffset)

        if (particle2) then
            particle2:SetVelocity(AddVel)
            particle2:SetLifeTime(0)
            particle2:SetDieTime(math.Rand(0.07 ,0.1))
            particle2:SetStartAlpha(255)
            particle2:SetEndAlpha(155)
            particle2:SetStartSize(math.Rand(5, 10))
            particle2:SetEndSize(scale * math.Rand(40, 60))
            particle2:SetLighting(false)
            particle2:SetRoll(math.random(0, 0))
            particle2:SetColor(255, 255, 255)
        end
	        local particle3 = emitter:Add("effects/swrc/radial_sparks", self.vOffset)

        if (particle3) then
            particle3:SetVelocity(AddVel)
            particle3:SetLifeTime(0)
            particle3:SetDieTime(math.Rand(0.07 ,0.1))
            particle3:SetStartAlpha(255)
            particle3:SetEndAlpha(155)
            particle3:SetStartSize(math.Rand(5, 10))
            particle3:SetEndSize(scale * math.Rand(40, 60))
            particle3:SetLighting(false)
            particle3:SetRoll(math.random(0, 0))
            particle3:SetColor(255, 255, 200)
        end
    end

    local particlecount = quality * 2


    if quality >= 3 then
        local particle = emitter:Add("sprites/heatwave", self.vOffset)

        if (particle) then
            particle:SetVelocity((dir * 25) + 1.05 * AddVel)
            particle:SetLifeTime(0)
            particle:SetDieTime(0.1)
            particle:SetStartAlpha(255)
            particle:SetEndAlpha(0)
            particle:SetStartSize(math.Rand(80, 100))
            particle:SetEndSize(0)
            particle:SetRoll(math.Rand(0, 360))
            particle:SetRollDelta(math.Rand(-2, 2))
            particle:SetAirResistance(5)
            particle:SetGravity(Vector(0, 0, 40))
            particle:SetColor(255, 255, 255)
        end
    end

    emitter:Finish()
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/astw2_swrc_explosion_geo_grenade/init.lua:
return gluapack()()
--PATH lua/effects/astw2_swrc_explosion_thermal_detonator/init.lua:
return gluapack()()
--PATH lua/effects/astw2_swrc_wookie_rl_explosion/init.lua:
return gluapack()()
--PATH lua/effects/blue_tracer.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 6500
EFFECT.Length				= 64
EFFECT.WhizDistance			= 72

local MaterialMain			= Material( "effects/sw_laser_blue_main" )
local MaterialFront			= Material( "effects/sw_laser_blue_front" )

function EFFECT:GetTracerOrigin( data )

	local start = data:GetStart()

	if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity()

		if ( not IsValid( entity ) ) then return start end
		if ( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start end

		if ( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then

			local pl = entity:GetOwner()
			if ( IsValid( pl ) ) then
				local vm = pl:GetViewModel()
				if ( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm
				else
					if ( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel )
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() )
		if ( attachment ) then
			start = attachment.Pos
		end

	end

	return start
end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )

	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed

	local weapon = data:GetEntity()
	if ( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then
		util.DistanceToLine( self.StartPos, self.EndPos, EyePos() )
	end

end


function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end


function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length

	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * (endDistance * 1.2)

	render.SetMaterial( MaterialFront )
	render.DrawSprite( endPos, 32, 24, color_white )

	render.SetMaterial( MaterialMain )
	render.DrawBeam( startPos, endPos, 20, 0, 1, color_white )
end

--PATH lua/effects/ca3_tracer.lua:
return gluapack()()
--PATH lua/effects/celest_dissolve.lua:
return gluapack()()
--PATH lua/effects/celest_dissolve.lua:
local mat_glow = Material( "models/elemental/celest_dissolve" )

local cmd_sunbeams = GetConVar( "sfw_fx_individualsunbeams" )

function EFFECT:Init( data )

	self.Time = 2.2
	self.LifeTime = CurTime() + self.Time
	
	local ent = data:GetEntity()
	
	if ( !IsValid( ent ) ) then return end
	if ( !ent:GetModel() ) then return end
	
	self.ParentEntity = ent
	
	self:SetModel( ent:GetModel() )	
	self:SetPos( ent:GetPos() )
	self:SetAngles( ent:GetAngles() )
	self:SetParent( ent )
	
	self.ParentEntity.RenderOverride = self.RenderParent
	self.ParentEntity.SpawnEffect = self

end

function EFFECT:Think( )

	if ( !IsValid( self.ParentEntity ) ) then return false end
	
	local PPos = self.ParentEntity:GetPos()
	self:SetPos( PPos + (EyePos() - PPos):GetNormal() )
	
	if ( self.LifeTime > CurTime() ) then
		return true
	end
	
	self.ParentEntity.RenderOverride = nil
	self.ParentEntity.SpawnEffect = nil
			
	return false
	
end

function EFFECT:Render()

end

function EFFECT:RenderOverlay( entity )
		
	local Fraction = ( self.LifeTime - CurTime() ) / self.Time
	local ColFrac = ( Fraction - 0.5 ) * 2
	
	Fraction = math.Clamp( Fraction, 0, 1 )
	ColFrac =  math.Clamp( ColFrac, 0, 1 )

	local EyeNormal = entity:GetPos() - EyePos()
	local Distance = EyeNormal:Length()
	EyeNormal:Normalize()
	
	local Pos = EyePos() + EyeNormal * Distance * 0.01
	local bClipping = self:StartClip( entity, 1 )

	local amount = math.Clamp( -0.2 + Fraction, 0, 1 )
	render.SetColorModulation( amount, amount, amount )
	
	cam.Start3D( Pos, EyeAngles() )
		render.MaterialOverride()
		entity:DrawModel()
	cam.End3D()

	render.PopCustomClipPlane()
	render.EnableClipping( bClipping )

end

function EFFECT:RenderParent()

	local bClipping = self.SpawnEffect:StartClip( self, 0.7 )
	
	render.SetColorModulation( 6, 8, 12 )
	render.MaterialOverride( mat_glow )
	
	self:DrawModel()
	
	render.PopCustomClipPlane()
	render.EnableClipping( bClipping )
	
	self.SpawnEffect:RenderOverlay( self )

end

function EFFECT:StartClip( model, spd )

	local mn, mx = model:GetRenderBounds()
	local Up = (mx-mn):GetNormal()
	local Bottom =  model:EyePos() + mn
	local Top = model:EyePos() + mx
	
	local Fraction = ( self.LifeTime - CurTime() ) / self.Time
	Fraction = math.Clamp( Fraction / spd, 0, 1 )
	
	local Lerped = LerpVector( Fraction, Top, Bottom )
	
	local normal = Up 
	local distance = normal:Dot( Lerped )
	local bEnabled = render.EnableClipping( true )
	render.PushCustomClipPlane( normal, distance )
	
	local bSunBeams = cmd_sunbeams:GetBool()
	if ( !bSunBeams ) then return bEnabled end 
	
	local screen = Lerped
	local vNormal = screen - EyePos()
	
	local dot = ( vNormal:Dot( EyeVector() ) - 0.8 ) * 5
	if ( dot <= 0 ) then return bEnabled end

	screen = screen + ( vNormal * 16384 )
	screen = screen:ToScreen()
	
	local glowSize = math.max( mn:Length() * 0.0005, 0.01 )
	
	local w, h = ScrW(), ScrH()

	local glowX, glowY = screen.x, screen.y
	DrawSunbeams( 0.95, 0.1, glowSize, glowX / w, glowY / h )

	return bEnabled
	
end
--PATH lua/effects/celest_dissolve_wrath.lua:
return gluapack()()
--PATH lua/effects/cod2019_muzzle_he2/init.lua:
function EFFECT:Init(data, weapon, dmgInfo, tr)
    local pos = data:GetOrigin()
    local ang = data:GetAngles()
	ParticleEffect("muzzleflash_ar", pos, ang, nil)
    --sound.Play("COD2019.HE_ExplosiveHit", data:GetOrigin(), SNDLVL_75dB, 100, 1)
    local dynlight = DynamicLight(0)
    dynlight.Pos = pos
    dynlight.Size = 32
    dynlight.Decay = 20
    dynlight.R = 255
    dynlight.G = 150
    dynlight.B = 0
    dynlight.Brightness = 3
    dynlight.DieTime = CurTime() + 0.05
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH addons/[miecze] moce i hilty/lua/effects/corvinus_ignite_effect.lua:
return gluapack()()
--PATH lua/effects/csgo_muzzle_assaultrifle/init.lua:
local ang

EFFECT.WeaponEnt = nil

local lighconvar = GetConVar("arc9_muzzle_light")
local otherconvar = GetConVar("arc9_muzzle_others")

EFFECT.ParticleName = "weapon_muzzle_flash_assaultrifle"

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	
    if !otherconvar:GetBool() and LocalPlayer() != self.WeaponEnt:GetOwner() then
        self:Remove()
        return
    end	

	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if not self.WeaponEnt:IsFirstPerson() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	
	if !self.WeaponEnt:GetProcessedValue("Silencer") and !self.WeaponEnt:GetProcessedValue("NoFlash", true) and lighconvar:GetBool() then
		local dlight = DynamicLight(self.WeaponEnt:EntIndex())
		if (dlight) then
			dlight.pos = self.Position + self.Angle:Up() * 3 + self.Angle:Right() * -2
			dlight.r = 255
			dlight.g = 192
			dlight.b = 64
			dlight.brightness = 5
			dlight.Size = math.Rand(32, 64)
			dlight.Decay = math.Rand(32, 64) / 0.05
			dlight.DieTime = CurTime() + 0.05
		end
	end

	local pcf = CreateParticleSystem(self.WeaponEnt, self.ParticleName, PATTACH_POINT_FOLLOW, self.Attachment)
	if IsValid(pcf) then
		pcf:StartEmission()
	end
	timer.Simple(3.0, function()
		if IsValid(pcf) then
			pcf:StopEmissionAndDestroyImmediately()
		end
	end)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/csgo_muzzle_huntingrifle/init.lua:
return gluapack()()
--PATH lua/effects/csgo_muzzle_huntingrifle_ssg/init.lua:
local ang

EFFECT.WeaponEnt = nil

local lighconvar = GetConVar("arc9_muzzle_light")
local otherconvar = GetConVar("arc9_muzzle_others")

EFFECT.ParticleName = "weapon_muzzle_flash_huntingrifle_FP"

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	
    if !otherconvar:GetBool() and LocalPlayer() != self.WeaponEnt:GetOwner() then
        self:Remove()
        return
    end	

	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if not self.WeaponEnt:IsFirstPerson() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	
	if !self.WeaponEnt:GetProcessedValue("Silencer") and !self.WeaponEnt:GetProcessedValue("NoFlash", true) and lighconvar:GetBool() then
		local dlight = DynamicLight(self.WeaponEnt:EntIndex())
		if (dlight) then
			dlight.pos = self.Position + self.Angle:Up() * 3 + self.Angle:Right() * -2
			dlight.r = 255
			dlight.g = 192
			dlight.b = 64
			dlight.brightness = 5
			dlight.Size = math.Rand(32, 64)
			dlight.Decay = math.Rand(32, 64) / 0.05
			dlight.DieTime = CurTime() + 0.05
		end
	end

	local pcf = CreateParticleSystem(self.WeaponEnt, self.ParticleName, PATTACH_POINT_FOLLOW, self.Attachment)
	if IsValid(pcf) then
		pcf:StartEmission()
	end
	timer.Simple(3.0, function()
		if IsValid(pcf) then
			pcf:StopEmissionAndDestroyImmediately()
		end
	end)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/csgo_muzzle_shotgun/init.lua:
return gluapack()()
--PATH lua/effects/csgo_muzzle_smg/init.lua:
return gluapack()()
--PATH lua/effects/csgo_nade_flashbang_light/init.lua:
function EFFECT:Init(data)
	self.Entity = data:GetEntity()
	pos = data:GetOrigin()
	local dlight = DynamicLight(pos)

	if (dlight) then
		dlight.pos = pos
		dlight.r = 255
		dlight.g = 255
		dlight.b = 255
		dlight.brightness = 2
		dlight.Size = 400
		dlight.Decay = 768
		dlight.DieTime = CurTime() + 0.1
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/csgo_nade_smokenade/init.lua:
--Thanks Inconceivable/Generic Default
function EFFECT:Init(data)
	self.Entity = data:GetEntity()
	pos = data:GetOrigin()
	self.Emitter = ParticleEmitter(pos)

	for i = 1, 100 do
		local particle = self.Emitter:Add("csgo/particle/particle_smokegrenade", pos)

		if (particle) then
			particle:SetVelocity(VectorRand():GetNormalized() * math.Rand(150, 300))

			if i <= 5 then
				particle:SetDieTime(60)
			else
				particle:SetDieTime(math.Rand(45, 65))
			end

			particle:SetStartAlpha(math.Rand(250, 450))
			particle:SetEndAlpha(0)
			particle:SetStartSize(160)
			particle:SetEndSize(220)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-1, 1) / 3)
			particle:SetColor(65, 65, 65)
			particle:SetAirResistance(100)
			particle:SetCollide(true)
			particle:SetBounce(1)
		end
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/effect_bactanade/init.lua:
return gluapack()()
--PATH lua/effects/effect_smokenade_smoke/init.lua:
function EFFECT:Init(data)

	local emitter = ParticleEmitter(data:GetOrigin())

		for i = 0, 128 do

			if !emitter then return end

			local Pos = (data:GetOrigin() + Vector( math.Rand(-32,32), math.Rand(-32,32), math.Rand(-32,32) ) + Vector(0,0,64))

			local particle = emitter:Add( "particle/particle_smokegrenade", Pos )
			if (particle) then

				particle:SetVelocity(VectorRand() * math.Rand(1420,5200))

				particle:SetLifeTime(0)
				particle:SetDieTime(math.Rand(16, 18))

				local rand = math.random(242,255)
				if math.random(1,10) == 10 then rand = math.random(210,232) end
				particle:SetColor(rand,rand,rand)

				particle:SetStartAlpha(math.Rand(242,255))
				particle:SetEndAlpha(0)

				local Size = math.Rand(132,162)
				particle:SetStartSize(Size)
				particle:SetEndSize(Size)

				particle:SetRoll(math.Rand(-360, 360))
				particle:SetRollDelta(math.Rand(-0.21, 0.21))

				particle:SetAirResistance(math.Rand(520,620))

				particle:SetGravity( Vector(0, 0, math.Rand(-42, -82)) )

				particle:SetCollide(true)
				particle:SetBounce(0.42)

				particle:SetLighting(1)

			end

		end

	emitter:Finish()

end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/effect_sw_laser_green_long/init.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/effects/electric_spark.lua:
return gluapack()()
--PATH lua/effects/emg_tracer.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/emg_tracer_hybrid.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/extinguish_effect.lua:
function EFFECT:Init(data)
    self.Ent = data:GetEntity()

    self.LifeTime = 0.2
    self.DieTime = CurTime() + self.LifeTime

    if IsValid(self.Ent) then
        local Dir = self.Ent:GetAimVector()
        local StartPos = self.Ent:GetShootPos() - Dir * 25
        local EndPos = StartPos + Dir * 625
        self:SetRenderBoundsWS(StartPos, EndPos)
    end
end

function EFFECT:Think()
    if self.DieTime < CurTime() or not IsValid(self.Ent) then
        return false
    end

    return true
end

local BeamMat = Material("particle/water/waterdrop_001a")
local mat = Material("particle/water/waterdrop_001a_additive")

function EFFECT:Render()
    if IsValid(self.Ent) then
        local boneID = self.Ent:LookupBone("ValveBiped.Bip01_L_Hand")

        if boneID then
            local T = CurTime() * 10

            local X = math.cos(T) * math.cos(T * 10) * 4
            local Y = math.sin(T) * math.cos(T * 10) * 4
            local pos, ang = self.Ent:GetBonePosition(boneID)
            local StartPos = pos + ang:Up() * 2 + ang:Forward() * 5 + ang:Right() * 2

            if not self.TargetPos then
                self.TargetPos = self.Ent:GetEyeTrace().HitPos

                local dlight = DynamicLight(self.Ent:EntIndex() + math.random(0, 99))
                if dlight then
                    dlight.pos = StartPos
                    dlight.r = 255
                    dlight.g = 255
                    dlight.b = 255
                    dlight.brightness = 3
                    dlight.Decay = 2000
                    dlight.Size = 150
                    dlight.DieTime = CurTime() + 0.1
                end
            end

            local Dir = ((self.TargetPos - StartPos):Angle() + Angle(X, Y, 0)):Forward()
            local EndPos = StartPos + Dir * math.random(200, 600)

            local trace = util.TraceLine({start = StartPos, endpos = EndPos, filter = self.Ent})

            if (self.HitFX or 0) < CurTime() then
                self.HitFX = CurTime() + 0.01

                if trace.Hit then
                    local effectdata = EffectData()
                    effectdata:SetOrigin(trace.HitPos + trace.HitNormal)
                    effectdata:SetNormal(-trace.HitNormal)
                    util.Effect("force_lightning_hit", effectdata)

                    if math.random(1, 3) == 3 then
                        local dlight = DynamicLight(self.Ent:EntIndex() + math.random(100, 9999))
                        if dlight then
                            dlight.pos = trace.HitPos + trace.HitNormal
                            dlight.r = 255
                            dlight.g = 150
                            dlight.b = 255
                            dlight.brightness = 3
                            dlight.Decay = 2000
                            dlight.Size = 100
                            dlight.DieTime = CurTime() + 0.01
                        end

                        --self:EmitSound("vehicles/Airboat/pontoon_fast_water_loop1.wav" .. math.random(1, 3) .. ".mp3")
                    end
                end
            end

            render.SetMaterial(mat)
            render.DrawSprite(StartPos, 64, 64, Color(191, 223, 243, 255))
            render.DrawSprite(StartPos, 16, 16, Color(255, 255, 255, 255))

            local BeamStart = StartPos
            local BeamPrevious = BeamStart
            local BeamEnd = trace.HitPos
            local BeamSub = BeamEnd - BeamStart
            local BeamDir = BeamSub:GetNormalized()
            local BeamDistance = (BeamSub):Length()
            local SegmentLength = 50

            render.SetMaterial(BeamMat)

            render.DrawBeam(BeamStart, BeamEnd, 18, 0, 1, Color(255, 255, 255, 255))

            for SegmentStart = 0, BeamDistance, SegmentLength do
                local SegmentEnd = BeamPrevious + (BeamDir:Angle() + Angle(math.Rand(-8, 8), math.Rand(-8, 8), 0)):Forward() * SegmentLength

                local Width = (SegmentStart / BeamDistance)
                if SegmentStart + SegmentLength >= BeamDistance then
                    SegmentEnd = BeamEnd
                end

                render.DrawBeam(BeamPrevious, SegmentEnd, 16 * (1 - Width), Width, Width + 0.15, Color(255, 150 + 155 * Width, 255, 255))

                local BranchEnd1 = SegmentEnd + (BeamDir:Angle() + Angle(math.Rand(-20, 20), math.Rand(-20, 20), 0)):Forward() * SegmentLength * 0.5

                render.DrawBeam(SegmentEnd, BranchEnd1, math.Rand(8, 16) * (1 - Width), 0, 0.2, Color(255, 255, 255, 255))
                render.DrawBeam(BranchEnd1, BranchEnd1 + (BeamDir:Angle() + Angle(math.Rand(-6, 6), math.Rand(-6, 6), 0)):Forward() * SegmentLength * 1.5, math.Rand(4, 8) * (1 - Width), 0, 1.5, Color(255, 255, 255, 255))

                BeamPrevious = SegmentEnd
            end
        end
    end
end
--PATH addons/[miecze] moce i hilty/lua/effects/force_blast_effect.lua:
function EFFECT:Init(data)
    self.Ent = data:GetEntity()

    self.LifeTime = 0.2
    self.DieTime = CurTime() + self.LifeTime

    if IsValid(self.Ent) then
        local Dir = self.Ent:GetAimVector()
        local StartPos = self.Ent:GetShootPos() - Dir * 25
        local EndPos = StartPos + Dir * 625
        self:SetRenderBoundsWS(StartPos, EndPos)
    end
end

function EFFECT:Think()
    if self.DieTime < CurTime() or not IsValid(self.Ent) then
        return false
    end

    return true
end

local BeamMat = Material("trails/electric")
local mat = Material("sprites/light_glow02_add")

function EFFECT:Render()
    if IsValid(self.Ent) then
        local boneID = self.Ent:LookupBone("ValveBiped.Bip01_L_Hand")

        if boneID then
            local T = CurTime() * 10

            local X = math.cos(T) * math.cos(T * 10) * 4
            local Y = math.sin(T) * math.cos(T * 10) * 4
            local pos, ang = self.Ent:GetBonePosition(boneID)
            local StartPos = pos + ang:Up() * 2 + ang:Forward() * 5 + ang:Right() * 2

            if not self.TargetPos then
                self.TargetPos = self.Ent:GetEyeTrace().HitPos

                local dlight = DynamicLight(self.Ent:EntIndex() + math.random(0, 99))
                if dlight then
                    dlight.pos = StartPos
                    dlight.r = 255
                    dlight.g = 255
                    dlight.b = 255
                    dlight.brightness = 3
                    dlight.Decay = 2000
                    dlight.Size = 150
                    dlight.DieTime = CurTime() + 0.1
                end
            end

            local Dir = ((self.TargetPos - StartPos):Angle() + Angle(X, Y, 0)):Forward()
            local EndPos = StartPos + Dir * math.random(200, 600)

            local trace = util.TraceLine({start = StartPos, endpos = EndPos, filter = self.Ent})

            if (self.HitFX or 0) < CurTime() then
                self.HitFX = CurTime() + 0.01

                if trace.Hit then
                    local effectdata = EffectData()
                    effectdata:SetOrigin(trace.HitPos + trace.HitNormal)
                    effectdata:SetNormal(-trace.HitNormal)
                    util.Effect("force_lightning_hit", effectdata)

                    if math.random(1, 3) == 3 then
                        local dlight = DynamicLight(self.Ent:EntIndex() + math.random(100, 9999))
                        if dlight then
                            dlight.pos = trace.HitPos + trace.HitNormal
                            dlight.r = 255
                            dlight.g = 150
                            dlight.b = 255
                            dlight.brightness = 3
                            dlight.Decay = 2000
                            dlight.Size = 100
                            dlight.DieTime = CurTime() + 0.01
                        end

                        self:EmitSound("lscs/force/lightninghit" .. math.random(1, 3) .. ".mp3")
                    end
                end
            end

            render.SetMaterial(mat)
            render.DrawSprite(StartPos, 64, 64, Color(0, 50, 255, 255))
            render.DrawSprite(StartPos, 16, 16, Color(255, 255, 255, 255))

            local BeamStart = StartPos
            local BeamPrevious = BeamStart
            local BeamEnd = trace.HitPos
            local BeamSub = BeamEnd - BeamStart
            local BeamDir = BeamSub:GetNormalized()
            local BeamDistance = (BeamSub):Length()
            local SegmentLength = 50

            render.SetMaterial(BeamMat)

            render.DrawBeam(BeamStart, BeamEnd, 18, 0, 1, Color(255, 255, 255, 255))

            for SegmentStart = 0, BeamDistance, SegmentLength do
                local SegmentEnd = BeamPrevious + (BeamDir:Angle() + Angle(math.Rand(-8, 8), math.Rand(-8, 8), 0)):Forward() * SegmentLength

                local Width = (SegmentStart / BeamDistance)
                if SegmentStart + SegmentLength >= BeamDistance then
                    SegmentEnd = BeamEnd
                end

                render.DrawBeam(BeamPrevious, SegmentEnd, 16 * (1 - Width), Width, Width + 0.15, Color(255, 150 + 155 * Width, 255, 255))

                local BranchEnd1 = SegmentEnd + (BeamDir:Angle() + Angle(math.Rand(-20, 20), math.Rand(-20, 20), 0)):Forward() * SegmentLength * 0.5

                render.DrawBeam(SegmentEnd, BranchEnd1, math.Rand(8, 16) * (1 - Width), 0, 0.2, Color(255, 255, 255, 255))
                render.DrawBeam(BranchEnd1, BranchEnd1 + (BeamDir:Angle() + Angle(math.Rand(-6, 6), math.Rand(-6, 6), 0)):Forward() * SegmentLength * 1.5, math.Rand(4, 8) * (1 - Width), 0, 1.5, Color(255, 255, 255, 255))

                BeamPrevious = SegmentEnd
            end
        end
    end
end
--PATH addons/[miecze] moce i hilty/lua/effects/force_groundslam.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_judgementiii.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_judgementiii_hit.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

local DecalMat = Material( util.DecalMaterial( "FadingScorch" ) )
function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.mat = Material( "sprites/light_glow02_add" )
	
	self.LifeTime = 0.5
	self.DieTime = CurTime() + self.LifeTime
	self.DieTimeGlow = CurTime() + 0.2

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()
	
	local emitter = ParticleEmitter( Pos, false )

	local trace = util.TraceLine( {
		start = Pos - Dir * 5,
		endpos = Pos + Dir * 5,
	} )

	if trace.Hit and not trace.HitNonWorld then
		util.DecalEx( DecalMat, trace.Entity, trace.HitPos + trace.HitNormal, trace.HitNormal, Color(255,255,255,255), math.Rand(0.4,0.8), math.Rand(0.4,0.8) )
	end

	for i = 0, 3 do
		local particle = emitter:Add( "sprites/rico1", Pos )
		
		local vel = VectorRand() * 100 + Dir * math.Rand(120,140)
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(1,2) )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 1 )
			particle:SetEndSize( 0.5 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 255, 255, 255 )
			particle:SetGravity( Vector(0,0,-600) )
		end
	end

	self.Emitter = emitter
end

function EFFECT:Think()
	if self.DieTime < CurTime() then 
		if self.Emitter then
			self.Emitter:Finish()
		end

		if self.snd then
			self.snd:Stop()
		end

		return false
	end

	return true
end

local Mat = Material("particle/particle_glow_05_addnofog")
function EFFECT:Render()
	local Scale = (self.DieTimeGlow - CurTime()) / 0.2
	if Scale > 0 then
		render.SetMaterial( self.mat )
		render.DrawSprite( self.Pos, 24 * Scale, 24 * Scale, Color( 255, 255, 255) ) -- DEĞİŞTİRİLECEK RENK
	end
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_replenish.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/laser_hit.lua:
return gluapack()()
--PATH lua/effects/lfs_fb_wingturret_projector.lua:
EFFECT.Mat = Material( "effects/lvs/ballturret_projectorbeam" )
EFFECT.HitMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Entity = data:GetEntity()
	
	self.DownPos = Vector(-55, 350, 90)
	self.UpPos = Vector(-55, 370, 125)
	self.StartPos = self.DownPos
	self.EndPos = self.Entity:GetWingTurretTarget()
end

function EFFECT:Think()
	if not IsValid( self.Entity ) or not self.Entity:GetWingTurretFire() then
		return false
	end
	
	self.EndPosDesired = self.Entity:GetWingTurretTarget() 
	self:SetRenderBoundsWS( self.Entity:GetPos(), self.EndPosDesired )
	
	return true
end

local color_white = Color(255, 255, 255, 255)
local color_green = Color(0, 255, 0, 255)
local trData = {}
function EFFECT:Render()
	if not self.EndPosDesired then return end
	
	self.EndPos = self.EndPos + (self.EndPosDesired - self.EndPos) * FrameTime() * 10
	
	for i = -1, 1, 2 do
		local StartPos = self.Entity:LocalToWorld(self.StartPos * Vector(1, i, 1))
		
		trData.start = StartPos
		trData.endpos = self.EndPos
		local Trace = util.TraceLine(trData)
		local EndPos = Trace.HitPos
		
		if self.Entity:WorldToLocal( EndPos ).z < 0 then
			self.StartPos = self.DownPos
		else
			self.StartPos = self.UpPos
		end
		
		if Trace.Entity ~= self.Entity then
			render.SetMaterial(self.Mat)
			render.DrawBeam(StartPos, EndPos, 14 + math.random(0, 4), 1, 0, color_green)
			render.DrawBeam(StartPos, EndPos, 3 + math.random(0, 4), 1, 0, color_white)
			
			render.SetMaterial( self.HitMat )
			local A = 150 + math.random(0, 20)
			local B = 70 + math.random(0, 20)
			render.DrawSprite(StartPos, A, A, color_green)
			render.DrawSprite(StartPos, B, B, color_white)
			
			render.DrawSprite(EndPos, A, A, color_green)
			render.DrawSprite(EndPos + VectorRand() * 10, B, B, color_white)
			
			if math.random(0,5) == 1 then
				local emitter = ParticleEmitter(EndPos, false)
				local dir = (self.Entity:GetPos() - EndPos):GetNormalized()
				
				for i = 0, 10 do
					local particle = emitter:Add("sprites/rico1", EndPos)
					local vel = VectorRand() * 100 + dir * 40
					
					if particle then
						particle:SetVelocity(vel)
						particle:SetAngles(vel:Angle() + Angle(0, 90, 0))
						particle:SetDieTime(math.Rand(0.1, 0.3) * 0.5)
						particle:SetStartAlpha(math.Rand( 200, 255 ))
						particle:SetEndAlpha(0)
						particle:SetStartSize(math.Rand(1, 30))
						particle:SetEndSize(0)
						particle:SetRoll(math.Rand(-100, 100))
						particle:SetRollDelta(math.Rand(-100, 100))
						particle:SetAirResistance(0)
					end
				end
				
				emitter:Finish()
			end
		end
	end
end
--PATH lua/effects/lvs_capital_blue_laser.lua:
EFFECT.MatBeam = Material( "effects/lvs_base/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1500 * bullet:GetLength()

	render.SetMaterial( self.MatBeam )

	render.DrawBeam( endpos - dir * len, endpos + dir * len * 0.1, 10, 1, 0, Color( 0, 0, 255, 255 ) )
	render.DrawBeam( endpos - dir * len * 0.5, endpos + dir * len * 0.1, 5, 1, 0, Color( 0, 20, 0, 255 ) )

	render.SetMaterial( self.MatSprite ) 
	render.DrawSprite( endpos, 400, 400, Color( 0, 0, 255, 255 ) )
end
--PATH lua/effects/lvs_capital_red_laser.lua:
return gluapack()()
--PATH lua/effects/lvs_concussion_explosion.lua:

local GlowMat = Material( "sprites/light_glow02_add" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	local emitter = ParticleEmitter( self.Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,30 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 800 )
			particle:SetDieTime( math.Rand(4,6) )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( math.Rand(30,60) )
			particle:SetEndSize( math.Rand(100,150) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 50,50,50 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/light_glow02_add", self.Pos )
		
		local vel = VectorRand() * 400
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.4,0.8) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(24,48) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetColor( 255, 40, 100 )
			particle:SetGravity( Vector(0,0,-600) )

			particle:SetAirResistance( 0 )
			
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
		end
	end
	
	for i = 0, 40 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( 0.14 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 )
			particle:SetEndSize( math.Rand(30,60) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local Pos = self.Pos
	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		if delay <= 0.11 then
			sound.Play( "ambient/explosions/explode_9.wav", Pos, 85, 100, 1 - delay * 8 )
		end

		timer.Simple( delay, function()
			sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( GlowMat )
	render.DrawSprite( self.Pos, 400 * Scale, 400 * Scale, Color( 255, 40, 100, 255) )
	render.DrawSprite( self.Pos, 100 * Scale, 100 * Scale, Color( 255, 255, 255, 255) )
end

--PATH lua/effects/lvs_exhaust_fire.lua:

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Dir = data:GetNormal()
	local Ent = data:GetEntity()
	local Scale = data:GetMagnitude()

	if not IsValid( Ent ) then return end

	local emitter = Ent:GetParticleEmitter( Pos )

	if not IsValid( emitter ) then return end

	local particle = emitter:Add( "effects/lvs_base/fire", Pos )

	if particle then
		particle:SetVelocity( Dir * 70 )
		particle:SetDieTime( 0.2 )
		particle:SetAirResistance( 0 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 10 + 18 * Scale )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand(-1,1) * 180 )
		particle:SetColor( 255,255,255 )
		particle:SetGravity( Vector( 0, 0, 100 ) )
		particle:SetCollide( false )
	end
	
	for i = 1, 3 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), Pos )
		
		if particle then
			particle:SetVelocity( Dir * 40 * i )
			particle:SetDieTime( 0.2 )
			particle:SetAirResistance( 0 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( (5 + 5 * Scale) - i )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-1,1) * 180 )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH lua/effects/lvs_laser_blue.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1000 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 4, endpos + dir * len * 4, 200, 1, 0, Color( 0, 0, 255, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 0, 0, 255, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--PATH lua/effects/lvs_laser_blue_long.lua:
return gluapack()()
--PATH lua/effects/lvs_laser_red.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1000 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 4, endpos + dir * len * 4, 200, 1, 0, Color( 255, 0, 0, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 255, 0, 0, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--PATH lua/effects/lvs_laser_red_aat.lua:
return gluapack()()
--PATH lua/effects/lvs_physics_water.lua:
return gluapack()()
--PATH lua/effects/lvs_tracer_missile.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

EFFECT.MatSmoke = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )

	self.emitter = ParticleEmitter( pos, false )

	self.OldPos = pos
	self.Dir = dir
end

function EFFECT:doFX( pos, curpos )
	if not IsValid( self.emitter ) then return end

	local particle = self.emitter:Add( self.MatSmoke[ math.random(1, #self.MatSmoke ) ], pos )
	if particle then
		particle:SetGravity( Vector(0,0,100) + VectorRand() * 50 ) 
		particle:SetVelocity( -self.Dir * 200  )
		particle:SetAirResistance( 600 ) 
		particle:SetDieTime( math.Rand(1.5,2) )
		particle:SetStartAlpha( 50 )
		particle:SetStartSize( 20 )
		particle:SetEndSize( 60 )
		particle:SetRoll( math.Rand( -1, 1 ) )
		particle:SetRollDelta( math.Rand( -1, 1 ) )
		particle:SetColor(40,40,40)
		particle:SetCollide( false )
	end

	local particle = self.emitter:Add( "particles/flamelet"..math.random(1,5), pos )
	if particle then
		particle:SetVelocity( -self.Dir * math.Rand(250,800) + self.Dir * 1500 )
		particle:SetDieTime( math.Rand(0.2,0.4) )
		particle:SetAirResistance( 0 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 8 )
		particle:SetEndSize( 1 )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 255,255,255 )
		particle:SetGravity( Vector( 0, 0, 0 ) )
		particle:SetCollide( false )
	end

	local particle = self.emitter:Add( "particles/flamelet"..math.random(1,5), curpos )
	if particle then
		particle:SetVelocity( -self.Dir * 200 + VectorRand() * 50 )
		particle:SetDieTime( 0.25 )
		particle:SetAirResistance( 600 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 6 )
		particle:SetEndSize( 2 )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 255,255,255 )
		particle:SetGravity( Vector( 0, 0, 0 ) )
		particle:SetCollide( false )
	end
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then
		if self.emitter then
			self.emitter:Finish()
		end

		return false
	end

	if not self.emitter then return true end

	local T = CurTime()

	if (self.nextDFX or 0) <= T then
		self.nextDFX = T + 0.02
		
		local bullet = LVS:GetBullet( self.ID )

		local Pos = bullet:GetPos()

		local Sub = self.OldPos - Pos
		local Dist = Sub:Length()
		local Dir = Sub:GetNormalized()

		for i = 0, Dist, 45 do
			local cur_pos = self.OldPos + Dir * i

			self:doFX( cur_pos, Pos )
		end

		self.OldPos = Pos
	end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local pos = bullet:GetPos()

	render.SetMaterial( self.MatSprite )
	render.DrawSprite( pos, 100, 100, Color( 255, 200, 150, 255 ) )
end

--PATH lua/effects/meridian_tracer_noattach.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/pulsar_tracer_noattach.lua:
return gluapack()()
--PATH lua/effects/rw_sw_dual_laser_aqua.lua:
return gluapack()()
--PATH lua/effects/rw_sw_dual_laser_grey.lua:
return gluapack()()
--PATH lua/effects/rw_sw_laser_lightblue.lua:
return gluapack()()
--PATH lua/effects/rw_sw_laser_orange.lua:

TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD 			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 175

local MaterialMain 			= Material("effects/sw_l/rw_sw_laser_m_orange")
local MaterialFront 		= Material("effects/sw_l/rw_sw_laser_f_orange")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin()
			-- if( origin ) then
			-- 	return origin, angle, entity
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

--concommand.Add("sv_dlight")
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 90
			dlight.b = 0
			dlight.brightness = 5
			dlight.Decay = 1000
			dlight.Size = 200
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 6, 6, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 6, 0, 1, color_white)
end
--PATH lua/effects/rw_sw_stunwave_green.lua:
return gluapack()()
--PATH lua/effects/rw_sw_stunwave_orange.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4500;
EFFECT.Length				= 64;

local MaterialFront			= Material( "cs574/stun_tracers/sw_stunwave_orange" );

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

EFFECT.WaveSize = 0

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if (self.WaveSize < 45) then
		self.WaveSize = self.WaveSize + 1
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(startPos, 1 + self.WaveSize, 1 + self.WaveSize, color_white)
end
--PATH addons/[miecze] moce i hilty/lua/effects/saber_hit_generic.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	self:Spark( self.Pos )
	self:Smoke( self.Pos )
end


function EFFECT:Smoke( pos )
	local emitter = ParticleEmitter( pos, false )
	
	for i = 0,1 do
		local particle = emitter:Add( Materials[ math.random(1,table.Count( Materials )) ], pos )
		
		local vel = VectorRand() * math.Rand(10,30)
		
		if particle then			
			particle:SetVelocity( vel )
			particle:SetDieTime( math.Rand(0.5,1.5) )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 50 )
			particle:SetStartSize( 10 )
			particle:SetEndSize( 25 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 40,40,40 )
			particle:SetGravity( Vector(0,0,200) )
			particle:SetCollide( false )
		end
	end
	
	emitter:Finish()
end

function EFFECT:Spark( pos )
	local emitter = ParticleEmitter( pos, false )
	
	for i = 0, 10 do
		local particle = emitter:Add( "sprites/rico1", pos )
		
		local vel = VectorRand() * 100
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( 0.5 )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 1 )
			particle:SetEndSize( 0.25 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 255, 150, 0 )
			particle:SetGravity( Vector(0,0,-600) )
		end
	end
	
	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end
	
	return true
end

local mat = Material( "sprites/light_glow02_add" )

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( mat )
	render.DrawSprite( self.Pos, 25 * Scale, 25 * Scale, Color( 255, 100, 0, 255) ) 
end

--PATH addons/[miecze] moce i hilty/lua/effects/saber_hitwall.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

local DecalMat = Material( util.DecalMaterial( "FadingScorch" ) )
function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.Col = data:GetStart() or Vector(255,100,0)
	
	self.mat = Material( "sprites/light_glow02_add" )
	
	self.LifeTime = 0.6
	self.DieTime = CurTime() + self.LifeTime

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()
	
	local emitter = ParticleEmitter( Pos, false )

	local trace = util.TraceLine( {
		start = Pos + Dir * 5,
		endpos = Pos - Dir * 5,
		filter = function( ent ) 
			if ent.GetOwningEnt then return false end
			return true
		end
	} )

	if LSCS.ImpactEffects then
		if trace.Hit and not trace.HitNonWorld then
			self.RenderGlow = {
				Pos = trace.HitPos,
				Normal = trace.HitNormal,
				Angle = trace.HitNormal:Angle() + Angle(90,0,0),
				RandomAng = math.random(0,360),
			}

			util.DecalEx( DecalMat, trace.Entity, trace.HitPos + trace.HitNormal, trace.HitNormal, Color(255,255,255,255), math.Rand(0.3,0.6), math.Rand(0.3,0.6) )
		end
	end

	if not trace.Hit then return end

	local particle = emitter:Add( Materials[ math.random(1,table.Count( Materials )) ], Pos )
	
	local vel = VectorRand() * 100 + Dir * 40
	
	if particle then			
		particle:SetVelocity( vel )
		particle:SetDieTime( 0.5 )
		particle:SetAirResistance( 1000 ) 
		particle:SetStartAlpha( 50 )
		particle:SetStartSize( 2 )
		particle:SetEndSize( 6 )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 40,40,40 )
		particle:SetGravity( Dir * 10 )
		particle:SetCollide( false )
	end

	local particle = emitter:Add( "sprites/rico1", Pos )
	
	local vel = VectorRand() * 100 + Dir * 40
	
	if particle then
		particle:SetVelocity( vel )
		particle:SetAngles( vel:Angle() + Angle(0,90,0) )
		particle:SetDieTime( 0.5 )
		particle:SetStartAlpha( math.Rand( 200, 255 ) )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( 1 )
		particle:SetEndSize( 0.25 )
		particle:SetRoll( math.Rand(-100,100) )
		particle:SetRollDelta( math.Rand(-100,100) )
		particle:SetCollide( true )
		particle:SetBounce( 0.5 )
		particle:SetAirResistance( 0 )
		particle:SetColor( 255, 150, 0 )
		particle:SetGravity( Vector(0,0,-600) )
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then 
		return false
	end

	return true
end

local Mat = Material("particle/particle_glow_05_addnofog")

function EFFECT:Render()
	if LSCS.ImpactEffects then
		if self.RenderGlow then
			local Timed = 1 - (self.DieTime - CurTime()) / self.LifeTime
			local Scale = math.max(math.min(2 - Timed * 2,1),0)

			cam.Start3D2D( self.RenderGlow.Pos + self.RenderGlow.Normal * 0.5, self.RenderGlow.Angle, 0.1 )
				surface.SetMaterial( Mat )
				surface.SetDrawColor( 255, 93 + 60 * Scale, 60 * Scale, 200 * Scale )
				surface.DrawTexturedRectRotated( 0, 0, 300 , 300 , self.RenderGlow.RandomAng )
			cam.End3D2D()
		end
	else
		local Scale = (self.DieTime - CurTime()) / self.LifeTime
		render.SetMaterial( Mat )
		render.DrawSprite( self.Pos, 32, 32, Color( 255, 93 + 60 * Scale, 60 * Scale, 200 * Scale) ) 
	end
end

--PATH lua/effects/seraph_tracer.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/sfw_muzzle_generic.lua:
AddCSLuaFile()

SCIFI_INTEGRITY_FLAG_FX = 20210727213519

local cmd_fx_forceclient = GetConVar( "sfw_fx_forceclientmuzzle" )
local cmd_fx_muzzlelights = GetConVar( "sfw_fx_muzzlelights" )
local cmd_fx_cinematic = GetConVar( "sfw_fx_cinematicmuzzles" )

EFFECT.ParticleName = ""
EFFECT.Light = nil
EFFECT.LightInfo = nil
EFFECT.LightRule = 0
EFFECT.LifeTime = 0.04
EFFECT.DieTime = 0
EFFECT.World = false
EFFECT.Origin = Vector()
EFFECT.Rotation = Angle()

local mBloom = Material( "bloom/halo_static_2" )

EFFECT.CheckVis = nil
EFFECT.CheckVisInfo = {
	start = Vector( 0, 0, 0 ),
	endpos = Vector( 0, 0, 0 ),
	mask = MASK_VISIBLE_AND_NPCS
}

function EFFECT:GetMuzzleParent()

	if ( CLIENT ) then
		local pEntity = self.Owner || LocalPlayer()
		local vmEntity = self.Weapon
		
		if( !IsValid( vmEntity ) ) then return pEntity end
		if( !game.SinglePlayer() && vmEntity:IsEFlagSet( EFL_DORMANT ) ) then return end

		local vmOwner = vmEntity:GetOwner()

		if( IsValid( vmOwner ) ) then
			if( !pEntity:ShouldDrawLocalPlayer() && vmOwner == pEntity ) then
				vmEntity = vmOwner:GetViewModel()
			else
				vmEntity = vmOwner:GetActiveWeapon()
				self.World = true
			end
		end
			
		return vmEntity
	end

end

function EFFECT:GetParticleName()

	if ( !IsValid( self.Weapon ) ) then return end

	local name = self.Weapon.VfxMuzzleParticle
	
	if ( !name || !isstring( name ) ) then
		name = "ngen_muzzle" 
	end
	
	return name
	
end

function EFFECT:GetParticleAttach()

	if ( !IsValid( self.Weapon ) ) then print("defaulting...") return "muzzle" end

	if ( self.World && self.Weapon.VfxMuzzleAttachment2 ) then
		return self.Weapon.VfxMuzzleAttachment2
	end

	return self.Weapon.VfxMuzzleAttachment
	
end

function EFFECT:GetLightInfo( data )

	local wEntity = self.Weapon

	if ( !IsValid( wEntity ) ) then return end

	local lightinfo = {}
	lightinfo.rule = wEntity.VfxMuzzleRule
	lightinfo.color = wEntity.VfxMuzzleColor
	lightinfo.brightness = wEntity.VfxMuzzleBrightness
	lightinfo.farz = wEntity.VfxMuzzleFarZ
	lightinfo.fov = wEntity.VfxMuzzleFOV
	lightinfo.texture = wEntity.VfxMuzzleProjexture
	
	return lightinfo
	
end

function EFFECT:Init( data )
	
	if ( !IsValid( self ) ) || ( !IsValid( data:GetEntity() ) ) then return end

	self.Owner = LocalPlayer()
	self.Weapon = data:GetEntity()
	self.Parent = self:GetMuzzleParent()
	self.ParticleName = self:GetParticleName()

	if ( !IsValid( self.Parent ) ) then return false end
	if ( !isstring( self.ParticleName ) ) then return false end
	
	local iLightSetting = cmd_fx_muzzlelights:GetInt()
	self.LightRule = math.min( iLightSetting, self.Weapon.VfxMuzzleRule )
	
	if ( !isnumber( self.LightRule ) ) then
		self.LightRule = 0
	end

	if ( self.LightRule > 0 ) then
		self.LightInfo = self:GetLightInfo()
	end

	local vmAttach = self.Parent:LookupAttachment( self:GetParticleAttach() )
	
	if ( vmAttach == 0 ) then
		self.Attach = "1"
	else
		self.Attach = vmAttach
	end	

	local att = self.Parent:GetAttachment( self.Attach )
			
	if ( !att ) then return end

	local ang = att.Ang
	local pos = att.Pos
	
	self.Rotation = ang
	self.Origin = pos
	
	self.StartTime = 0
	
	if ( !game.SinglePlayer() && self.Weapon:GetOwner() == self.Owner ) then -- cheat
		self.LifeTime = self.LifeTime * 0.006
		
		if ( self.LightInfo ) then
			self.LightInfo.brightness = self.LightInfo.brightness * 0.15
		end
	end
	
	self.DieTime = CurTime() + self.LifeTime

	local bForceClient = cmd_fx_forceclient:GetBool()

	if ( bForceClient ) then
		local vfxMuzzleFlash = CreateParticleSystem( self.Parent, self.ParticleName, PATTACH_POINT_FOLLOW, self.Attach, nil ) 
		
		if ( self.Owner == LocalPlayer() ) && ( !self.Owner:ShouldDrawLocalPlayer() && self.Parent == LocalPlayer():GetViewModel() ) then
			vfxMuzzleFlash:SetIsViewModelEffect( true )
			vfxMuzzleFlash:Restart()
		end
	else
		-- For some reason, Source reduces particle systems that are attached to the player or a player-owned entity when in 3rd person. This is a work-around.
		if ( self.Owner == LocalPlayer() ) && ( self.Owner:ShouldDrawLocalPlayer() ) then
			ParticleEffect( self.ParticleName, self.Origin, self.Rotation, NULL )
		else
			ParticleEffectAttach( self.ParticleName, PATTACH_POINT_FOLLOW, self.Parent, self.Attach )
		end
	end

end

function EFFECT:Think()

	if ( !IsValid( self.Parent ) ) then return false end
	if ( !isstring( self.ParticleName ) ) then return false end

	if ( self.LightRule > 0 ) && ( self.LightInfo ) && ( self.Attach ) then
		local ang = self.Rotation
		local pos = self.Origin + ang:Forward() * 4 + VectorRand()
	
		if ( self.LightRule > 1 ) && ( !self.Light ) then
			self.Light = ProjectedTexture()
		end
		
		local fScale = ( self.DieTime - CurTime() ) / ( self.LifeTime * 0.6 )
		fScale = math.Clamp( fScale, 0, 1 )
		
		local fBrightness = self.LightInfo.brightness * fScale

		if ( self.LightRule > 1 ) && ( self.Light:IsValid() ) then
			self.Light:SetPos( pos )
			self.Light:SetAngles( ang )
			self.Light:SetColor( self.LightInfo.color )
			self.Light:SetBrightness( fBrightness )
			self.Light:SetFOV( self.LightInfo.fov )
			self.Light:SetNearZ( 16 )
			self.Light:SetFarZ( self.LightInfo.farz )
			self.Light:SetTexture( self.LightInfo.texture )
			
			if ( self.LightRule > 2 ) then
				self.Light:SetEnableShadows( true )
			else
				self.Light:SetEnableShadows( false )
			end
			
			self.Light:Update()
		else
			local dlight = DynamicLight( -1 )
			if ( dlight ) then
				dlight.pos = pos
				dlight.r = self.LightInfo.color.r
				dlight.g = self.LightInfo.color.g
				dlight.b = self.LightInfo.color.b
				dlight.brightness = fBrightness * 2
				dlight.Decay = 2048
				dlight.Size = self.LightInfo.farz
				dlight.DieTime = CurTime() + self.LifeTime
			end
		end
	end

	if ( self.DieTime > CurTime() ) then
		return true
	end
	
	if ( self.Light ) && ( self.Light:IsValid() ) then
		self.Light:Remove()
	end

	return false

end

function EFFECT:Render()

	if ( !cmd_fx_cinematic:GetBool() ) then return end
	if ( !self.LightInfo ) then return end

	local fBloomScale = self.LightInfo.brightness
	
	if ( fBloomScale <= 0 ) then return end

	local ply = GetViewEntity()
	local pos = self.Origin
	
	local plyview = ply:EyeAngles():Forward()
	local eyeview = ply:EyePos()
	local entview = pos - eyeview

	if ( !self.CheckVis ) then
		self.CheckVisInfo.start = pos
		self.CheckVisInfo.endpos = eyeview
		
		self.CheckVis = util.TraceLine( self.CheckVisInfo )
	end

	if ( self.CheckVis.HitWorld ) then return end

	local isvisible	= ( self.DieTime - CurTime() ) / self.LifeTime

	local color_1 = self.LightInfo.color
	local alpha = color_1.a * 0.6 * isvisible
	local bscale = 64
	local iscale = math.Clamp( math.tan( plyview:Dot( entview:GetNormalized() ) ) - 0.4, 0, 1 )

	render.SetMaterial( mBloom )

	local size = fBloomScale * isvisible * ( bscale * iscale )
	local color = Color( color_1.r, color_1.g, color_1.b, alpha * iscale )
	
	if !( self.Parent:GetOwner() == ply ) then
		size = size * 2.4
		alpha = alpha * 4
	end

	render.DrawSprite( pos, size * 1.2, size * 1, Color( color.r * 0.1, color.b * 0.1, color.b * 0.4, color.a ) )
	render.DrawSprite( pos, size * 0.8, size * 1.2, color )

end
--PATH addons/[miecze] moce i hilty/lua/effects/sl_force_lightning.lua:
return gluapack()()
--PATH lua/effects/spectra_blast.lua:
AddCSLuaFile()

local cmd_fx_forceclient = GetConVarNumber( "sfw_fx_forceclientmuzzle" )
local cmd_fx_muzzlelights = GetConVar( "sfw_fx_muzzlelights" )

EFFECT.ParticleName = "spectra_blast"
EFFECT.Light = nil
EFFECT.LightInfo = nil
EFFECT.LightRule = 0
EFFECT.LifeTime = 0.032
EFFECT.DieTime = 0
EFFECT.World = false

function EFFECT:GetMuzzleParent()

	if ( CLIENT ) then
		local pEntity = self.Owner || LocalPlayer()
		local vmEntity = self.Weapon
		
		if( !IsValid( vmEntity ) ) then return pEntity end
		if( !game.SinglePlayer() && vmEntity:IsEFlagSet( EFL_DORMANT ) ) then return end

		local vmOwner = vmEntity:GetOwner()

		if( IsValid( vmOwner ) ) then
			if( !pEntity:ShouldDrawLocalPlayer() && vmOwner == pEntity ) then
				vmEntity = vmOwner:GetViewModel()
				self.World = true
			else
				vmEntity = vmOwner:GetActiveWeapon()
			end
		end
			
		return vmEntity
	end

end

function EFFECT:GetParticleName()

	local name = self.Weapon.VfxMuzzleParticle

	if ( !IsValid( self.Weapon ) ) then 
		name = "ngen_muzzle" 
	end
	
	return name
	
end

function EFFECT:GetParticleAttach()

	local wEntity = self.Weapon
	
	if ( !IsValid( wEntity ) ) then return "muzzle" end

	if ( self.World && wEntity.VfxMuzzleAttachment2 ) then
		return wEntity.VfxMuzzleAttachment2
	end

	return wEntity.VfxMuzzleAttachment
	
end

function EFFECT:Init( data )
	
	if ( !IsValid( self ) ) || ( !IsValid( data:GetEntity() ) ) then return end

	self.Owner = LocalPlayer()
	self.Weapon = data:GetEntity()
	self.Parent = self:GetMuzzleParent()

	if ( !IsValid( self.Parent ) ) then return false end
	if ( !isstring( self.ParticleName ) ) then return false end
	
	local IsAds = ( self.Weapon.SciFiState == SCIFI_STATE_ADS )

	local vmAttach = self.Parent:LookupAttachment( self:GetParticleAttach() )
	
	if ( vmAttach == 0 ) then
		self.Attach = "1"
	else
		self.Attach = vmAttach
	end
	
	self.StartTime = 0
	
	self.DieTime = CurTime() + self.LifeTime

	if ( cmd_fx_forceclient == 1 ) then
		CreateParticleSystem( self.Parent, self.ParticleName, PATTACH_POINT_FOLLOW, self.Attach, nil ) 
	else
		ParticleEffectAttach( self.ParticleName, PATTACH_POINT_FOLLOW, self.Parent, self.Attach )
	end

end

function EFFECT:Think()

	if ( !IsValid( self.Parent ) ) then return false end
	if ( !isstring( self.ParticleName ) ) then return false end

	if ( self.DieTime > CurTime() ) then
		return true
	end
	
	if ( self.Light ) && ( self.Light:IsValid() ) then
		self.Light:Remove()
	end

	return false

end

function EFFECT:Render()
	
end
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/tfa_muzzleflash_cryo/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.5
EFFECT.HeatSize = 1.5
EFFECT.Color = Color(162,192,255)
EFFECT.ColorSprites = true

--PATH lua/effects/tfa_muzzleflash_fubar/init.lua:
return gluapack()()
--PATH lua/effects/tfa_muzzleflash_gauss/init.lua:
return gluapack()()
--PATH lua/effects/tfa_muzzleflash_generic/init.lua:
return gluapack()()
--PATH lua/tfa/muzzleflash_base.lua:
return gluapack()()
--PATH lua/effects/tfa_penetrate/init.lua:
local PenetColor = Color(255, 255, 255, 255)
local PenetMat = Material("trails/smoke")
local PenetMat2 = Material("effects/yellowflare")
local cv_gv = GetConVar("sv_gravity")
local cv_sl = GetConVar("cl_tfa_fx_impact_ricochet_sparklife")

--local cv_sc = GetConVar("cl_tfa_fx_impact_ricochet_sparks")
local DFX = {
	["AR2Tracer"] = true,
	["Tracer"] = true,
	["GunshipTracer"] = true,
	["GaussTracer"] = true,
	["AirboatGunTracer"] = true,
	["AirboatGunHeavyTracer"] = true
}

function EFFECT:Init(data)
	self.StartPos = data:GetOrigin()
	self.Dir = data:GetNormal()
	self.Dir:Normalize()
	self.Len = 32
	self.EndPos = self.StartPos + self.Dir * self.Len
	self.LifeTime = 0.75
	self.DieTime = CurTime() + self.LifeTime
	self.Thickness = 1
	self.Grav = Vector(0, 0, -cv_gv:GetFloat())
	self.PartMult = data:GetRadius()
	self.SparkLife = cv_sl:GetFloat()
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end

	if self.WeaponEnt.TracerPCF then
		local traceres = util.QuickTrace(self.StartPos, self.Dir * 9999999, Entity(math.Round(data:GetScale())))
		self.EndPos = traceres.HitPos or self.StartPos
		local efn = self.WeaponEnt.TracerName
		local spos = self.StartPos
		local cnt = math.min(math.Round(data:GetMagnitude()), 6000)

		timer.Simple(cnt / 1000000, function()
			TFA.ParticleTracer(efn, spos, traceres.HitPos or spos, false)
		end)

		return
	end

	local tn = self.WeaponEnt.BulletTracerName

	if tn and tn ~= "" and not DFX[tn] then
		local fx = EffectData()
		fx:SetStart(self.StartPos)
		local traceres = util.QuickTrace(self.StartPos, self.Dir * 9999999, Entity(math.Round(data:GetScale())))
		self.EndPos = traceres.HitPos or self.StartPos
		fx:SetOrigin(self.EndPos)
		fx:SetEntity(self.WeaponEnt)
		fx:SetMagnitude(1)
		util.Effect(tn, fx)
		SafeRemoveEntityDelayed(self, 0)
		--Sparks
		--Impact

		return
	else
		local emitter = ParticleEmitter(self.StartPos)
		--[[
		for i = 1, cv_sc:GetFloat() * self.PartMult * 0.1 do
			local part = emitter:Add("effects/yellowflare", self.StartPos)
			part:SetVelocity((self.Dir + VectorRand() * 0.5) * math.Rand(75, 185))
			part:SetDieTime(math.Rand(0.25, 1) * self.SparkLife)
			part:SetStartAlpha(255)
			part:SetStartSize(math.Rand(2, 4))
			part:SetEndSize(0)
			part:SetRoll(0)
			part:SetGravity(self.Grav)
			part:SetCollide(true)
			part:SetBounce(0.55)
			part:SetAirResistance(0.5)
			part:SetStartLength(0.2)
			part:SetEndLength(0)
			part:SetVelocityScale(true)
			part:SetCollide(true)
		end
		]]
		--
		local part = emitter:Add("effects/select_ring", self.StartPos)
		part:SetStartAlpha(225)
		part:SetStartSize(1)
		part:SetDieTime(self.LifeTime / 5)
		part:SetEndSize(0)
		part:SetEndAlpha(0)
		part:SetRoll(math.Rand(0, 360))
		part:SetColor(200, 200, 200)
		part = emitter:Add("effects/select_ring", self.StartPos)
		part:SetStartAlpha(255)
		part:SetStartSize(1.5 * self.PartMult)
		part:SetDieTime(self.LifeTime / 6)
		part:SetEndSize(0)
		part:SetEndAlpha(0)
		part:SetRoll(math.Rand(0, 360))
		part:SetColor(200, 200, 200)
		emitter:Finish()
	end
end

function EFFECT:Think()
	if self.DieTime and (CurTime() > self.DieTime) then return false end

	return true
end

function EFFECT:Render()
	if self.DieTime then
		local fDelta = (self.DieTime - CurTime()) / self.LifeTime
		fDelta = math.Clamp(fDelta, 0, 1)
		render.SetMaterial(PenetMat)
		local color = ColorAlpha(PenetColor, 32 * fDelta)
		local precision = 16
		local i = 1

		while i <= precision do
			render.DrawBeam(self.StartPos + self.Dir * self.Len * ((i - 1) / precision), self.StartPos + self.Dir * self.Len * (i / precision), self.Thickness * fDelta * (1 - i / precision), 0.5, 0.5, color)
			i = i + 1
		end

		render.SetMaterial(PenetMat2)
		i = 1

		while i <= precision do
			render.DrawBeam(self.StartPos + self.Dir * self.Len * ((i - 1) / precision), self.StartPos + self.Dir * self.Len * (i / precision), self.Thickness / 3 * 2 * fDelta * (1 - i / precision), 0.5, 0.5, color)
			i = i + 1
		end
	end
end
--PATH lua/effects/tfa_shell/init.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tfa_tracer_green/init.lua:
return gluapack()()
--PATH lua/effects/tfa_tracer_incendiary/init.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tracer_blue/init.lua:
-- Credits: Meeks, Xan, Matsil
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(0, 0, 255)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(0, 0, 250)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 0
        dlight.g = 102
        dlight.b = 255
        dlight.brightness = 7
        dlight.Decay = 1000
        dlight.Size = 500
        dlight.DieTime = CurTime() + 3
    end
end
end
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tracer_purple/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(148, 0, 211)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(148, 0, 211)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 148
        dlight.g = 0
        dlight.b = 211
        dlight.brightness = 7
        dlight.Decay = 1000
        dlight.Size = 500
        dlight.DieTime = CurTime() + 3
    end
end
end
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tracer_stun/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "star/effects/blue_shockwave" );
local MaterialFront			= Material( "star/effects/blue_shockwave" );

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 35, 35, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--PATH lua/effects/vj_blood1/init.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/

/*-- Information ---------------------
	-- Common Blood Types --
	Red 		= Color(130, 19, 10)
	Yellow 		= Color(255, 221, 35)

	-- Code Implementation --
	local blcolor = Color(130, 19, 10)
	effectBlood:SetColor(VJ_Color2Byte(Color(r, g, b)))
-------------------------------------- */
function EFFECT:Init(data)
	local origin = data:GetOrigin()
	local scale = data:GetScale()
	local color = VJ_Color8Bit2Color(data:GetColor())
	
	self.Emitter = ParticleEmitter(origin)
	for _ = 0,6 do
		local mist = self.Emitter:Add("particle/smokesprites_000"..math.random(1, 9), origin)
		if (mist) then
			mist:SetVelocity(Vector(math.random(-30, 30), math.random(-30, 30), math.random(-50, 50)))
			mist:SetDieTime(math.Rand(1.8, 2))
			mist:SetStartAlpha(150)
			mist:SetEndAlpha(0)
			mist:SetStartSize(scale / 2)
			mist:SetEndSize(scale)
			mist:SetRoll(1)
			mist:SetRollDelta(0)
			mist:SetAirResistance(1)
			mist:SetGravity(Vector(math.Rand(-10, 10), math.Rand(-10, 10), math.Rand(-100, -100)))
			mist:SetColor(color.r, color.g, color.b)
		end
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function EFFECT:Think()
	return false
end
---------------------------------------------------------------------------------------------------------------------------------------------
function EFFECT:Render()
end

--PATH lua/effects/vj_medium_explosion1/init.lua:
return gluapack()()
--PATH lua/effects/vp_binary_tracer.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH addons/[tfres] frest_levels/lua/fstands2/levels/config.lua:
fstands = fstands or {}
fstands.Config = fstands.Config or {}
fstands.Config.Levels = {}

fstands.Config.Levels.hard = 1

fstands.Config.Levels.contexp = true

fstands.Config.Levels.weekendexpboost = 2 -- Ile razy ma dawać expa w weekendy (piątek-niedziela), wszystko po niżej włącznie z 1 wyłączy tą funkcję!



fstands.Config.Levels.exp = 10

fstands.Config.Levels.lvlconfig = {
    ["76561198146699133"] = true, -- DODAJ TUTAJ SWOJE STEAMID BY MÓC KOŻYSTAĆ Z EDYTORA W GRZE (Musisz mieć superadmina i byc tutaj dodany by edytować)

}

fstands.Config.Levels.multexp = {
    ["Vip"] = 2,
    ["Vip2"] = 2.5,
}

fstands.Config.Levels.showcustom = false

-- If you want to make custom display then grab some functions
-- ply:GetLevel(type) -- type = ALL will give all levels combined
-- ply:GetExp(type)


fstands.Config.Levels.Type = {
    ["global"] = true,
}


for k,v in pairs(fstands.Config.Levels.Type) do
    DarkRP.registerDarkRPVar(k.."_lvl",net.WriteDouble, net.ReadDouble)
    DarkRP.registerDarkRPVar(k.."_xp", net.WriteDouble, net.ReadDouble)
end

print("CONFIG LOADED")
--PATH lua/rd_claim_boards/core/sh_config.lua:
return gluapack()()
--PATH lua/rd_claim_boards/core/client/cl_main.lua:
surface.CreateFont("RD_CLAIM_BOARD_TITLE", {
    font = "Roboto",
    extended = false,
    size = 75,
    weight = 500,
    antialias = true
})

surface.CreateFont("RD_CLAIM_BOARD_BODY", {
    font = "Roboto",
    extended = false,
    size = 50,
    weight = 500,
    antialias = true
})
--PATH addons/[tfres] datapad/lua/tfres/datapad/cl_core.lua:
return gluapack()()
--PATH addons/[tfres] datapad/lua/tfres/datapad/apps/posw.lua:
return gluapack()()