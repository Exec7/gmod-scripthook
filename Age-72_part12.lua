--Stealed clientside server code by exechack.cc
--Hostname: Age of Clones | Clone Wars Roleplay | Eigener Spielmodus - Part 12/12 - 06/04/2025


--PATH addons/z_anticrash_v1.4.6/lua/includes/modules/constraint.lua:
-- [[ MODIFIED BY ZOMBIE EXTINGUISHER ]]

/*
	Add more valid ent checks to avoid constraint errors crashing servers
*/

if ( SERVER ) then

	-- If you're a server admin and you want your physics to spazz out less you can
	-- use the convar. The higher you set it the more accurate physics will be.
	-- This is set to 4 by default, since we are a physics mod.

	CreateConVar( "gmod_physiterations", "4", { FCVAR_REPLICATED, FCVAR_ARCHIVE } )

end

module( "constraint", package.seeall )

-- Clients don't need this module.
if ( CLIENT ) then return end

-- I think 128 constraints is around the max that causes the crash
-- So at this number we'll refuse to add more to the system
local MAX_CONSTRAINTS_PER_SYSTEM = 100
local CurrentSystem = nil
local SystemLookup = {}

hook.Add( "EntityRemoved", "Constraint Library - ConstraintRemoved", function( Ent )
	local System = SystemLookup[ Ent ]
	if ( !IsValid( System ) ) then return end

	System.__ConstraintCount = ( System.__ConstraintCount or 0 ) - 1

	if System.__ConstraintCount <= 0 then
		System.__BadConstraintSystem = true
		System:Remove()
	end
end )

local invalidConstraints = 0
local function ConstraintCreated( Constraint )
	
	-- Zombie: Some more checks in case CreateConstraintSystem fails
	if IsValid( CurrentSystem, Constraint ) then
		SystemLookup[ Constraint ] = CurrentSystem
		CurrentSystem.__ConstraintCount = ( CurrentSystem.__ConstraintCount or 0 ) + 1
	else
		invalidConstraints = invalidConstraints + 1
		-- print('DEBUG - INVALID CONSTRAINTS', invalidConstraints)
	end
	
end

--[[----------------------------------------------------------------------
	CreateConstraintSystem
------------------------------------------------------------------------]]
local function CreateConstraintSystem()

	local iterations = GetConVarNumber( "gmod_physiterations" )

	local System = ents.Create( "phys_constraintsystem" )
	
	-- Zombie: why no check here either? :)
	if !IsValid(System) then return end
	
	System:SetKeyValue( "additionaliterations", iterations )
	System:Spawn()
	System:Activate()
	System.__ConstraintCount = 0

	return System

end


--[[----------------------------------------------------------------------
	FindOrCreateConstraintSystem

	Takes 2 entities. If the entities don't have a constraint system
	associated with them it creates one and associates it with them.

	It then returns the constraint system
------------------------------------------------------------------------]]
local function FindOrCreateConstraintSystem( Ent1, Ent2 )

	local System = nil

	Ent2 = Ent2 or Ent1

	-- Does Ent1 have a constraint system?
	if ( !Ent1:IsWorld() && IsValid( Ent1.ConstraintSystem ) && !Ent1.ConstraintSystem.__BadConstraintSystem ) then
		System = Ent1.ConstraintSystem
	end

	-- Don't add to this system - we have too many constraints on it already.
	if ( IsValid( System ) && ( System.__ConstraintCount or 0 ) >= MAX_CONSTRAINTS_PER_SYSTEM ) then System = nil end

	-- Does Ent2 have a constraint system?
	if ( !IsValid( System ) && !Ent2:IsWorld() && IsValid( Ent2.ConstraintSystem ) && !Ent2.ConstraintSystem.__BadConstraintSystem ) then
		System = Ent2.ConstraintSystem
	end

	-- Don't add to this system - we have too many constraints on it already.
	if ( IsValid( System ) && ( System.__ConstraintCount or 0 ) >= MAX_CONSTRAINTS_PER_SYSTEM ) then System = nil end

	-- No constraint system yet (Or they're both full) - make a new one
	if ( !IsValid( System ) ) then

		--Msg( "New Constrant System\n" )
		System = CreateConstraintSystem()

	end

	Ent1.ConstraintSystem = System
	Ent2.ConstraintSystem = System

	return System

end


--[[----------------------------------------------------------------------
	onStartConstraint( Ent1, Ent2 )
	Should be called before creating a constraint
------------------------------------------------------------------------]]
local function onStartConstraint( Ent1, Ent2 )

	-- Get constraint system
	CurrentSystem = FindOrCreateConstraintSystem( Ent1, Ent2 )

	-- Any constraints called after this call will use this system
	SetPhysConstraintSystem( CurrentSystem )

end

--[[----------------------------------------------------------------------
	onFinishConstraint( Ent1, Ent2 )
	Should be called before creating a constraint
------------------------------------------------------------------------]]
local function onFinishConstraint( Ent1, Ent2 )

	-- Turn off constraint system override
	CurrentSystem = nil
	SetPhysConstraintSystem( NULL )

end

local function SetPhysicsCollisions( Ent, b )

	if ( !IsValid( Ent ) or !IsValid( Ent:GetPhysicsObject() ) ) then return end

	Ent:GetPhysicsObject():EnableCollisions( b )

end

--[[----------------------------------------------------------------------
	RemoveConstraints( Ent, Type )
	Removes all constraints of type from entity
------------------------------------------------------------------------]]
function RemoveConstraints( Ent, Type )

	if ( !Ent.Constraints ) then return end

	local c = Ent.Constraints
	local i = 0

	for k, v in pairs( c ) do

		if ( !IsValid( v ) ) then

			c[ k ] = nil

		elseif ( v.Type == Type ) then

			-- Make sure physics collisions are on!
			-- If we don't the unconstrained objects will fall through the world forever.
			SetPhysicsCollisions( v.Ent1, true )
			SetPhysicsCollisions( v.Ent2, true )

			c[ k ] = nil
			v:Remove()

			i = i + 1
		end

	end

	if ( table.IsEmpty( c ) ) then
		-- Update the network var and clear the constraints table.
		Ent:IsConstrained()
	end

	local bool = i != 0
	return bool, i

end


--[[----------------------------------------------------------------------
	RemoveAll( Ent )
	Removes all constraints from entity
------------------------------------------------------------------------]]
function RemoveAll( Ent )

	if ( !Ent.Constraints ) then return end

	local c = Ent.Constraints
	local i = 0
	for k, v in pairs( c ) do

		if ( IsValid( v ) ) then

			-- Make sure physics collisions are on!
			-- If we don't the unconstrained objects will fall through the world forever.
			SetPhysicsCollisions( v.Ent1, true )
			SetPhysicsCollisions( v.Ent2, true )

			v:Remove()
			i = i + 1
		end
	end

	-- Update the network var and clear the constraints table.
	Ent:IsConstrained()

	local bool = i != 0
	return bool, i

end

--[[----------------------------------------------------------------------
	Find( Ent1, Ent2, Type, Bone1, Bone2 )
	Returns a constraint of given type between the two entities, if one exists
------------------------------------------------------------------------]]
function Find( Ent1, Ent2, Type, Bone1, Bone2 )

	if ( !Ent1.Constraints ) then return end

	for k, v in pairs( Ent1.Constraints ) do

		if ( IsValid( v ) && v.Type == Type ) then

			if ( v.Ent1 == Ent1 && v.Ent2 == Ent2 && v.Bone1 == Bone1 && v.Bone2 == Bone2 ) then
				return v
			end

			if ( v.Ent2 == Ent1 && v.Ent1 == Ent2 && v.Bone2 == Bone1 && v.Bone1 == Bone2 ) then
				return v
			end

		end

	end

	return nil

end

--[[----------------------------------------------------------------------
	CanConstrain( Ent, Bone )
	Returns false if we shouldn't be constraining this entity
------------------------------------------------------------------------]]
function CanConstrain( Ent, Bone )

	if ( !Ent ) then return false end
	if ( !isnumber( Bone ) ) then return false end
	if ( !Ent:IsWorld() && !Ent:IsValid() ) then return false end
	if ( !IsValid( Ent:GetPhysicsObjectNum( Bone ) ) ) then return false end

	return true

end

--[[----------------------------------------------------------------------
	CalcElasticConsts( ... )
	This attempts to scale the elastic constraints such as the winch
	to keep a stable but responsive constraint..
------------------------------------------------------------------------]]
local function CalcElasticConsts( Phys1, Phys2, Ent1, Ent2, iFixed )

	local minMass = 0

	if ( Ent1:IsWorld() ) then minMass = Phys2:GetMass()
	elseif ( Ent2:IsWorld() ) then minMass = Phys1:GetMass()
	else
		minMass = math.min( Phys1:GetMass(), Phys2:GetMass() )
	end

	-- const, damp
	local const = minMass * 100
	local damp = const * 0.2

	if ( iFixed == 0 ) then

		const = minMass * 50
		damp = const * 0.1

	end

	return const, damp

end


--[[----------------------------------------------------------------------
	CreateKeyframeRope( ... )
	Creates a rope without any constraint
------------------------------------------------------------------------]]
function CreateKeyframeRope( Pos, width, material, Constraint, Ent1, LPos1, Bone1, Ent2, LPos2, Bone2, kv )

	-- No rope if 0 or minus
	if ( width <= 0 ) then return nil end

	-- Clamp the rope to a sensible width
	width = math.Clamp( width, 0.2, 100 )

	local rope = ents.Create( "keyframe_rope" )
	
	-- Zombie: Why was this check not here? :)
	if !IsValid(rope) then 
		return
	end
	
	rope:SetPos( Pos )
	rope:SetKeyValue( "Width", width )

	if ( isstring( material ) ) then
		local mat = Material( material )
		if ( material && !string.find( mat:GetShader():lower(), "spritecard" ) ) then rope:SetKeyValue( "RopeMaterial", material ) end
	end

	-- Attachment point 1
	rope:SetEntity( "StartEntity", Ent1 )
	rope:SetKeyValue( "StartOffset", tostring( LPos1 ) )
	rope:SetKeyValue( "StartBone", Bone1 )

	-- Attachment point 2
	rope:SetEntity( "EndEntity", Ent2 )
	rope:SetKeyValue( "EndOffset", tostring( LPos2 ) )
	rope:SetKeyValue( "EndBone", Bone2 )

	if ( kv ) then
		for k, v in pairs( kv ) do

			rope:SetKeyValue( k, tostring( v ) )

		end
	end

	rope:Spawn()
	rope:Activate()

	-- Delete the rope if the attachments get killed
	Ent1:DeleteOnRemove( rope )
	Ent2:DeleteOnRemove( rope )
	if ( IsValid( Constraint ) ) then Constraint:DeleteOnRemove( rope ) end

	return rope

end

--[[----------------------------------------------------------------------
	AddConstraintTable( Ent, Constraint, Ent2, Ent3, Ent4 )
	Stores info about the constraints on the entity's table
------------------------------------------------------------------------]]
function AddConstraintTable( Ent, Constraint, Ent2, Ent3, Ent4 )

	if ( !IsValid( Constraint ) ) then return end

	if ( IsValid( Ent ) ) then

		Ent.Constraints = Ent.Constraints or {}
		table.insert( Ent.Constraints, Constraint )
		Ent:DeleteOnRemove( Constraint )

	end

	if ( Ent2 && Ent2 != Ent ) then
		AddConstraintTable( Ent2, Constraint, Ent3, Ent4 )
	end

end

--[[----------------------------------------------------------------------
	AddConstraintTableNoDelete( Ent, Constraint, Ent2, Ent3, Ent4 )
	Stores info about the constraints on the entity's table
------------------------------------------------------------------------]]
function AddConstraintTableNoDelete( Ent, Constraint, Ent2, Ent3, Ent4 )

	if ( !IsValid( Constraint ) ) then return end

	if ( IsValid( Ent ) ) then

		Ent.Constraints = Ent.Constraints or {}
		table.insert( Ent.Constraints, Constraint )

	end

	if ( Ent2 && Ent2 != Ent ) then
		AddConstraintTableNoDelete( Ent2, Constraint, Ent3, Ent4 )
	end

end


--[[----------------------------------------------------------------------
	Weld( ... )
	Creates a solid weld constraint
------------------------------------------------------------------------]]
function Weld( Ent1, Ent2, Bone1, Bone2, forcelimit, nocollide, deleteonbreak )

	if ( Ent1 == Ent2 && Bone1 == Bone2 ) then return false end
	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	if ( Find( Ent1, Ent2, "Weld", Bone1, Bone2 ) ) then

		-- A weld already exists between these two physics objects.
		-- There's totally no point in re-creating it. It doesn't make
		-- the weld any stronger - that's just an urban legend.
		return false

	end

	-- Don't weld World to objects, weld objects to World!
	-- Prevents crazy physics on some props
	if ( Ent1:IsWorld() ) then
		Ent1 = Ent2
		Ent2 = game.GetWorld()
	end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )

	onStartConstraint( Ent1, Ent2 )

		-- Create the constraint
		local Constraint = ents.Create( "phys_constraint" )
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(Constraint) then 
			onFinishConstraint( Ent1, Ent2 )
			return
		end
		
		ConstraintCreated( Constraint )
		if ( forcelimit ) then Constraint:SetKeyValue( "forcelimit", forcelimit ) end
		if ( nocollide ) then Constraint:SetKeyValue( "spawnflags", 1 ) end
		Constraint:SetPhysConstraintObjects( Phys2, Phys1 )
		Constraint:Spawn()
		Constraint:Activate()

	onFinishConstraint( Ent1, Ent2 )
	AddConstraintTable( Ent1, Constraint, Ent2 )

	-- Optionally delete Ent1 when the weld is broken
	-- This is to fix bug #310
	if ( deleteonbreak ) then
		Ent2:DeleteOnRemove( Ent1 )
	end

	-- Make a constraints table
	local ctable = {
		Type = "Weld",
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
		forcelimit = forcelimit,
		nocollide = nocollide,
		deleteonbreak = deleteonbreak
	}

	Constraint:SetTable( ctable )

	Phys1:Wake()
	Phys2:Wake()

	_G.C = Constraint

	return Constraint

end
duplicator.RegisterConstraint( "Weld", Weld, "Ent1", "Ent2", "Bone1", "Bone2", "forcelimit", "nocollide", "deleteonbreak" )


--[[----------------------------------------------------------------------
	Rope( ... )
	Creates a rope constraint - with rope!
------------------------------------------------------------------------]]
function Rope( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, length, addlength, forcelimit, width, material, rigid )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )
	local WPos1 = Phys1:LocalToWorld( LPos1 )
	local WPos2 = Phys2:LocalToWorld( LPos2 )
	local addlength = math.Clamp( addlength or 0, -56756, 56756 )
	local Constraint = nil

	-- Make Constraint
	if ( Phys1 != Phys2 ) then

		onStartConstraint( Ent1, Ent2 )

			-- Create the constraint
			Constraint = ents.Create( "phys_lengthconstraint" )
			
			-- Zombie: Why was this check not here? :)
			if !IsValid(Constraint) then 
				onFinishConstraint( Ent1, Ent2 )
				return
			end
		
			ConstraintCreated( Constraint )
			Constraint:SetPos( WPos1 )
			Constraint:SetKeyValue( "attachpoint", tostring( WPos2 ) )
			Constraint:SetKeyValue( "minlength", "0.0" )
			Constraint:SetKeyValue( "length", length + addlength )
			if ( forcelimit ) then Constraint:SetKeyValue( "forcelimit", forcelimit ) end
			if ( rigid ) then Constraint:SetKeyValue( "spawnflags", 2 ) end
			Constraint:SetPhysConstraintObjects( Phys1, Phys2 )
			Constraint:Spawn()
			Constraint:Activate()

		onFinishConstraint( Ent1, Ent2 )

	end

	-- Make Rope
	local kv = {
		Length = length + addlength,
		Collide = 1
	}
	if ( rigid ) then kv.Type = 2 end

	local rope = CreateKeyframeRope( WPos1, width, material, Constraint, Ent1, LPos1, Bone1, Ent2, LPos2, Bone2, kv )

	-- What the fuck
	if ( !Constraint ) then Constraint, rope = rope, nil end

	local ctable = {
		Type = "Rope",
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
		LPos1 = LPos1,
		LPos2 = LPos2,
		length = length,
		addlength = addlength,
		forcelimit = forcelimit,
		width = width,
		material = material,
		rigid = rigid
	}

	if ( IsValid( Constraint ) ) then
		Constraint:SetTable( ctable )
		AddConstraintTable( Ent1, Constraint, Ent2 )
	end

	return Constraint, rope

end
duplicator.RegisterConstraint( "Rope", Rope, "Ent1", "Ent2", "Bone1", "Bone2", "LPos1", "LPos2", "length", "addlength", "forcelimit", "width", "material", "rigid" )

--[[----------------------------------------------------------------------
	Elastic( ... )
	Creates an elastic constraint
------------------------------------------------------------------------]]
function Elastic( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, constant, damping, rdamping, material, width, stretchonly )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )
	local WPos1 = Phys1:LocalToWorld( LPos1 )
	local WPos2 = Phys2:LocalToWorld( LPos2 )

	local Constraint = nil
	local rope = nil

	-- Make Constraint
	if ( Phys1 != Phys2 ) then

		onStartConstraint( Ent1, Ent2 )

			Constraint = ents.Create( "phys_spring" )
			
			-- Zombie: Why was this check not here? :)
			if !IsValid(Constraint) then 
				onFinishConstraint( Ent1, Ent2 )
				return
			end
			
			ConstraintCreated( Constraint )
			Constraint:SetPos( WPos1 )
			Constraint:SetKeyValue( "springaxis", tostring( WPos2 ) )
			Constraint:SetKeyValue( "constant", constant )
			Constraint:SetKeyValue( "damping", damping )
			Constraint:SetKeyValue( "relativedamping", rdamping )
			Constraint:SetPhysConstraintObjects( Phys1, Phys2 )
			if ( stretchonly == 1 or stretchonly == true ) then
				Constraint:SetKeyValue( "spawnflags", 1 )
			end

			Constraint:Spawn()
			Constraint:Activate()

		onFinishConstraint( Ent1, Ent2 )
		AddConstraintTable( Ent1, Constraint, Ent2 )

		local ctable = {
			Type = "Elastic",
			Ent1 = Ent1,
			Ent2 = Ent2,
			Bone1 = Bone1,
			Bone2 = Bone2,
			LPos1 = LPos1,
			LPos2 = LPos2,
			constant = constant,
			damping = damping,
			rdamping = rdamping,
			material = material,
			width = width,
			length = ( WPos1 - WPos2 ):Length(),
			stretchonly = stretchonly,
		}

		Constraint:SetTable( ctable )

		-- Make Rope
		local kv = {
			Collide = 1,
			Type = 0
		}

		rope = CreateKeyframeRope( WPos1, width, material, Constraint, Ent1, LPos1, Bone1, Ent2, LPos2, Bone2, kv )
	end

	return Constraint, rope
end
duplicator.RegisterConstraint("Elastic", Elastic, "Ent1", "Ent2", "Bone1", "Bone2", "LPos1", "LPos2", "constant", "damping", "rdamping", "material", "width", "stretchonly")


--[[----------------------------------------------------------------------
	Keepupright( ... )
	Creates a KeepUpright constraint
------------------------------------------------------------------------]]
function Keepupright( Ent, Ang, Bone, angularlimit )

	if ( !CanConstrain( Ent, Bone ) ) then return false end
	if ( Ent:GetClass() != "prop_physics" && Ent:GetClass() != "prop_ragdoll" ) then return false end
	if ( !angularlimit or angularlimit < 0 ) then return end

	local Phys = Ent:GetPhysicsObjectNum(Bone)

	-- Remove any KU's already on entity
	RemoveConstraints( Ent, "Keepupright" )

	onStartConstraint( Ent )

		local Constraint = ents.Create( "phys_keepupright" )
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(Constraint) then 
			onFinishConstraint( Ent )
			return
		end
		
		ConstraintCreated( Constraint )
		Constraint:SetAngles( Ang )
		Constraint:SetKeyValue( "angularlimit", angularlimit )
		Constraint:SetPhysConstraintObjects( Phys, Phys )
		Constraint:Spawn()
		Constraint:Activate()

	onFinishConstraint( Ent )
	AddConstraintTable( Ent, Constraint )

	local ctable = {
		Type = "Keepupright",
		Ent1 = Ent,
		Ang = Ang,
		Bone = Bone,
		angularlimit = angularlimit
	}
	Constraint:SetTable( ctable )

	--
	-- This is a hack to keep the KeepUpright context menu in sync..
	--
	Ent:SetNWBool( "IsUpright", true )

	return Constraint

end
duplicator.RegisterConstraint( "Keepupright", Keepupright, "Ent1", "Ang", "Bone", "angularlimit" )


function CreateStaticAnchorPoint( Pos )

	-- Creates an invisible frozen, not interactive prop.
	local Anchor = ents.Create( "gmod_anchor" )

	Anchor:SetPos( Pos )
	Anchor:Spawn()
	Anchor:Activate()

	return Anchor, Anchor:GetPhysicsObject(), 0, Vector( 0, 0, 0 )

end


--[[----------------------------------------------------------------------
	Slider( ... )
	Creates a slider constraint
------------------------------------------------------------------------]]
function Slider( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, width, material )

	-- TODO: If we get rid of sliders we can get rid of gmod_anchor too!

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )
	local WPos1 = Phys1:LocalToWorld( LPos1 )
	local WPos2 = Phys2:LocalToWorld( LPos2 )
	local StaticAnchor = nil

	-- Make Constraint
	if ( Phys1 == Phys2 ) then return end

	-- Make Rope
	local kv = {
		Collide = 0,
		Type = 2,
		Subdiv = 1,
	}

	-- Start World Hack.
	-- Attaching a slider to the world makes it really sucks so we make
	-- a prop and attach to that.

	if ( Ent1:IsWorld() ) then

		Ent1, Phys1, Bone1, LPos1 = CreateStaticAnchorPoint( WPos1 )
		StaticAnchor = Ent1

	end

	if ( Ent2:IsWorld() ) then

		Ent2, Phys2, Bone2, LPos2 = CreateStaticAnchorPoint( WPos2 )
		StaticAnchor = Ent2

	end

	-- End World Hack.

	onStartConstraint( Ent1, Ent2 )

		local Constraint = ents.Create("phys_slideconstraint")
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(Constraint) then 
			onFinishConstraint( Ent1, Ent2 )
			return
		end
		
		ConstraintCreated( Constraint )
		Constraint:SetPos( WPos1 )
		Constraint:SetKeyValue( "slideaxis", tostring( WPos2 ) )
		Constraint:SetPhysConstraintObjects( Phys1, Phys2 )
		Constraint:Spawn()
		Constraint:Activate()

	onFinishConstraint( Ent1, Ent2 )
	AddConstraintTable( Ent1, Constraint, Ent2 )

	local rope = CreateKeyframeRope( WPos1, width, material, Constraint, Ent1, LPos1, Bone1, Ent2, LPos2, Bone2, kv )

	-- If we have a static anchor - delete it when we die.
	if ( StaticAnchor ) then

		Constraint:DeleteOnRemove( StaticAnchor )

	end

	local ctable = {
		Type = "Slider",
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
		LPos1 = LPos1,
		LPos2 = LPos2,
		width = width,
		material = material
	}

	Constraint:SetTable( ctable )

	return Constraint, rope

end
duplicator.RegisterConstraint( "Slider", Slider, "Ent1", "Ent2", "Bone1", "Bone2", "LPos1", "LPos2", "width", "material" )

--[[----------------------------------------------------------------------
	Axis( ... )
	Creates an axis constraint
------------------------------------------------------------------------]]
function Axis( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, forcelimit, torquelimit, friction, nocollide, LocalAxis, DontAddTable )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )
	local WPos1 = Phys1:LocalToWorld( LPos1 )
	local WPos2 = Phys2:LocalToWorld( LPos2 )

	if ( Phys1 == Phys2 ) then return false end

	-- If we have a LocalAxis, use that
	if ( LocalAxis ) then
		WPos2 = Phys1:LocalToWorld( LocalAxis )
	end

	onStartConstraint( Ent1, Ent2 )

		local Constraint = ents.Create("phys_hinge")
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(Constraint) then 
			onFinishConstraint( Ent1, Ent2 )
			return
		end
		
		ConstraintCreated( Constraint )
		Constraint:SetPos( WPos1 )
		Constraint:SetKeyValue( "hingeaxis", tostring( WPos2 ) )
		if ( forcelimit && forcelimit > 0 ) then Constraint:SetKeyValue( "forcelimit", forcelimit ) end
		if ( torquelimit && torquelimit > 0 ) then Constraint:SetKeyValue( "torquelimit", torquelimit ) end
		if ( friction && friction > 0 ) then Constraint:SetKeyValue( "hingefriction", friction ) end
		if ( nocollide && nocollide > 0 ) then Constraint:SetKeyValue( "spawnflags", 1 ) end
		Constraint:SetPhysConstraintObjects( Phys1, Phys2 )
		Constraint:Spawn()
		Constraint:Activate()

	onFinishConstraint( Ent1, Ent2 )

	if ( !DontAddTable ) then
		AddConstraintTable( Ent1, Constraint, Ent2 )
	end

	local ctable = {
		Type = "Axis",
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
		LPos1 = LPos1,
		LPos2 = LPos2,
		forcelimit = forcelimit,
		torquelimit = torquelimit,
		friction = friction,
		nocollide = nocollide,
		LocalAxis = Phys1:WorldToLocal( WPos2 )
	}

	Constraint:SetTable( ctable )

	return Constraint

end
duplicator.RegisterConstraint( "Axis", Axis, "Ent1", "Ent2", "Bone1", "Bone2", "LPos1", "LPos2", "forcelimit", "torquelimit", "friction", "nocollide", "LocalAxis", "DontAddTable" )


--[[----------------------------------------------------------------------
	AdvBallsocket( ... )
	Creates an advanced ballsocket (ragdoll) constraint
------------------------------------------------------------------------]]
function AdvBallsocket( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, forcelimit, torquelimit, xmin, ymin, zmin, xmax, ymax, zmax, xfric, yfric, zfric, onlyrotation, nocollide )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )
	local WPos1 = Phys1:LocalToWorld( LPos1 )
	-- local WPos2 = Phys2:LocalToWorld( LPos2 )

	if ( Phys1 == Phys2 ) then return false end

	-- Make Constraint
	onStartConstraint( Ent1, Ent2 )

		local flags = 0
		if ( onlyrotation && onlyrotation > 0 ) then flags = flags + 2 end
		if ( nocollide && nocollide > 0 ) then flags = flags + 1 end

		local Constraint = ents.Create("phys_ragdollconstraint")
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(Constraint) then 
			onFinishConstraint( Ent1, Ent2 )
			return
		end
		
		ConstraintCreated( Constraint )
		Constraint:SetPos( WPos1 )
		Constraint:SetKeyValue( "xmin", xmin )
		Constraint:SetKeyValue( "xmax", xmax )
		Constraint:SetKeyValue( "ymin", ymin )
		Constraint:SetKeyValue( "ymax", ymax )
		Constraint:SetKeyValue( "zmin", zmin )
		Constraint:SetKeyValue( "zmax", zmax )
		if ( xfric && xfric > 0 ) then Constraint:SetKeyValue( "xfriction", xfric ) end
		if ( yfric && yfric > 0 ) then Constraint:SetKeyValue( "yfriction", yfric ) end
		if ( zfric && zfric > 0 ) then Constraint:SetKeyValue( "zfriction", zfric ) end
		if ( forcelimit && forcelimit > 0 ) then Constraint:SetKeyValue( "forcelimit", forcelimit ) end
		if ( torquelimit && torquelimit > 0 ) then Constraint:SetKeyValue( "torquelimit", torquelimit ) end
		Constraint:SetKeyValue( "spawnflags", flags )
		Constraint:SetPhysConstraintObjects( Phys1, Phys2 )
		Constraint:Spawn()
		Constraint:Activate()

	onFinishConstraint( Ent1, Ent2 )
	AddConstraintTable( Ent1, Constraint, Ent2 )

	local ctable = {
		Type = "AdvBallsocket",
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
		LPos1 = LPos1,
		LPos2 = LPos2,
		forcelimit = forcelimit,
		torquelimit = torquelimit,
		xmin = xmin,
		ymin = ymin,
		zmin = zmin,
		xmax = xmax,
		ymax = ymax,
		zmax = zmax,
		xfric = xfric,
		yfric = yfric,
		zfric = zfric,
		onlyrotation = onlyrotation,
		nocollide = nocollide
	}

	Constraint:SetTable( ctable )

	return Constraint

end
duplicator.RegisterConstraint( "AdvBallsocket", AdvBallsocket, "Ent1", "Ent2", "Bone1", "Bone2", "LPos1", "LPos2", "forcelimit", "torquelimit", "xmin", "ymin", "zmin", "xmax", "ymax", "zmax", "xfric", "yfric", "zfric", "onlyrotation", "nocollide")


--[[----------------------------------------------------------------------
	NoCollide( ... )
	Creates an nocollide `constraint'
------------------------------------------------------------------------]]
function NoCollide( Ent1, Ent2, Bone1, Bone2 )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )

	if ( Phys1 == Phys2 ) then return false end

	if ( Find( Ent1, Ent2, "NoCollide", Bone1, Bone2 ) ) then

		return false

	end

	-- Make Constraint
	onStartConstraint( Ent1, Ent2 )

		local Constraint = ents.Create("logic_collision_pair")
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(Constraint) then 
			onFinishConstraint( Ent1, Ent2 )
			return
		end
		
		ConstraintCreated( Constraint )
		Constraint:SetKeyValue( "startdisabled", 1 )
		Constraint:SetPhysConstraintObjects( Phys1, Phys2 )
		Constraint:Spawn()
		Constraint:Activate()
		Constraint:Input( "DisableCollisions", nil, nil, nil )

	onFinishConstraint( Ent1, Ent2 )
	AddConstraintTable( Ent1, Constraint, Ent2 )

	local ctable = {
		Type = "NoCollide",
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
	}

	Constraint:SetTable( ctable )

	return Constraint

end
duplicator.RegisterConstraint( "NoCollide", NoCollide, "Ent1", "Ent2", "Bone1", "Bone2" )


--[[----------------------------------------------------------------------
	MotorControl( pl, motor, onoff, dir )
	Numpad controls for the motor constraints
------------------------------------------------------------------------]]
local function MotorControl( pl, motor, onoff, dir )

	if ( !IsValid( motor ) ) then return false end

	local activate = false

	if ( motor.toggle == 1 ) then

		-- Toggle mode, only do something when the key is pressed
		-- if the motor is off, turn it on, and vice-versa.
		-- This only happens if the same key as the current
		-- direction is pressed, otherwise the direction is changed
		-- with the motor being left on.

		if ( onoff ) then

			if ( motor.direction == dir or !motor.is_on ) then

				-- Direction is the same, Activate if the motor is off
				-- Deactivate if the motor is on.

				motor.is_on = !motor.is_on

				activate = motor.is_on

			else

				-- Change of direction, make sure it's activated

				activate = true

			end

		else

			return

		end

	else

		-- normal mode: activate is based on the key status
		-- (down = on, up = off)

		activate = onoff

	end

	if ( activate ) then

		motor:Fire( "Activate", "", 0 ) -- Turn on the motor
		motor:Fire( "Scale", dir, 0 ) -- This makes the direction change

	else
		motor:Fire( "Deactivate", "", 0 ) -- Turn off the motor
	end

	motor.direction = dir

	return true

end
numpad.Register( "MotorControl", MotorControl )

--[[----------------------------------------------------------------------
	Motor( ... )
	Creates a motor constraint
------------------------------------------------------------------------]]
function Motor( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, friction, torque, forcetime, nocollide, toggle, pl, forcelimit, numpadkey_fwd, numpadkey_bwd, direction, LocalAxis )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	-- Get information we're about to use
	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )
	local WPos1 = Phys1:LocalToWorld( LPos1 )
	local WPos2 = Phys2:LocalToWorld( LPos2 )

	if ( Phys1 == Phys2 ) then return false end

	if ( LocalAxis ) then
		WPos2 = Phys1:LocalToWorld( LocalAxis )
	end

	-- The true at the end stops it adding the axis table to the entity's count stuff.
	local axis = Axis( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0, 0, friction, nocollide, LocalAxis, true )

	-- Delete the axis when either object dies
	Ent1:DeleteOnRemove( axis )
	Ent2:DeleteOnRemove( axis )

	-- Create the constraint
	onStartConstraint( Ent1, Ent2 )

		local Constraint = ents.Create( "phys_torque" )
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(Constraint) then 
			onFinishConstraint( Ent1, Ent2 )
			return
		end
		
		ConstraintCreated( Constraint )
		Constraint:SetPos( WPos1 )
		Constraint:SetKeyValue( "axis", tostring( WPos2 ) )
		Constraint:SetKeyValue( "force", torque )
		Constraint:SetKeyValue( "forcetime", forcetime )
		Constraint:SetKeyValue( "spawnflags", 4 )
		Constraint:SetPhysConstraintObjects( Phys1, Phys1 )
		Constraint:Spawn()
		Constraint:Activate()

	onFinishConstraint( Ent1, Ent2 )

	AddConstraintTableNoDelete( Ent1, Constraint, Ent2 )

	direction = direction or 1

	LocalAxis = Phys1:WorldToLocal( WPos2 )

	-- Delete the phys_torque too!
	axis:DeleteOnRemove( Constraint )

	-- Delete the axis constrain if phys_torque is deleted, with something like Motor tools reload
	Constraint:DeleteOnRemove( axis )

	local ctable = {
		Type = "Motor",
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
		LPos1 = LPos1,
		LPos2 = LPos2,
		friction = friction,
		torque = torque,
		forcetime = forcetime,
		nocollide = nocollide,
		toggle = toggle,
		pl = pl,
		forcelimit = forcelimit,
		forcescale = 0,
		direction = direction,
		is_on = false,
		numpadkey_fwd = numpadkey_fwd,
		numpadkey_bwd = numpadkey_bwd,
		LocalAxis = LocalAxis
	}

	Constraint:SetTable( ctable )

	if ( numpadkey_fwd ) then

		numpad.OnDown( pl, numpadkey_fwd, "MotorControl", Constraint, true, 1 )
		numpad.OnUp( pl, numpadkey_fwd, "MotorControl", Constraint, false, 1 )
	end

	if ( numpadkey_bwd ) then

		numpad.OnDown( pl, numpadkey_bwd, "MotorControl", Constraint, true, -1 )
		numpad.OnUp( pl, numpadkey_bwd, "MotorControl", Constraint, false, -1 )

	end

	return Constraint, axis

end
duplicator.RegisterConstraint( "Motor", Motor, "Ent1", "Ent2", "Bone1", "Bone2", "LPos1", "LPos2", "friction", "torque", "forcetime", "nocollide", "toggle", "pl", "forcelimit", "numpadkey_fwd", "numpadkey_bwd", "direction", "LocalAxis" )


--[[----------------------------------------------------------------------
	Pulley( ... )
	Creates a pulley constraint
------------------------------------------------------------------------]]
function Pulley( Ent1, Ent4, Bone1, Bone4, LPos1, LPos4, WPos2, WPos3, forcelimit, rigid, width, material )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent4, Bone4 ) ) then return false end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys4 = Ent4:GetPhysicsObjectNum( Bone4 )
	local WPos1 = Phys1:LocalToWorld( LPos1 )
	local WPos4 = Phys4:LocalToWorld( LPos4 )

	if ( Phys1 == Phys4 ) then return false end

	-- Make Constraint
	onStartConstraint( Ent1, Ent4 )

		local Constraint = ents.Create( "phys_pulleyconstraint" )
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(Constraint) then 
			onFinishConstraint( Ent1, Ent4 )
			return
		end
		
		ConstraintCreated( Constraint )
		Constraint:SetPos( WPos2 )
		Constraint:SetKeyValue( "position2", tostring( WPos3 ) )
		Constraint:SetKeyValue( "ObjOffset1", tostring( LPos1 ) )
		Constraint:SetKeyValue( "ObjOffset2", tostring( LPos4 ) )
		Constraint:SetKeyValue( "forcelimit", forcelimit )
		Constraint:SetKeyValue( "addlength", ( WPos3 - WPos4 ):Length() )
		if ( rigid ) then Constraint:SetKeyValue( "spawnflags", 2 ) end
		Constraint:SetPhysConstraintObjects( Phys1, Phys4 )
		Constraint:Spawn()
		Constraint:Activate()

	onFinishConstraint( Ent1, Ent4 )
	AddConstraintTable( Ent1, Constraint, Ent4 )

	local ctable = {
		Type = "Pulley",
		Ent1 = Ent1,
		Ent4 = Ent4,
		Bone1 = Bone1,
		Bone4 = Bone4,
		LPos1 = LPos1,
		LPos4 = LPos4,
		WPos2 = WPos2,
		WPos3 = WPos3,
		forcelimit = forcelimit,
		rigid = rigid,
		width = width,
		material = material
	}
	Constraint:SetTable( ctable )

	-- make Rope
	local World = game.GetWorld()

	local kv = {
		Collide = 1,
		Type = 2,
		Subdiv = 1,
	}

	CreateKeyframeRope( WPos1, width, material, Constraint, Ent1, LPos1, Bone1, World, WPos2, 0, kv )
	CreateKeyframeRope( WPos1, width, material, Constraint, World, WPos3, 0, World, WPos2, 0, kv )
	CreateKeyframeRope( WPos1, width, material, Constraint, World, WPos3, 0, Ent4, LPos4, Bone4, kv )

	return Constraint

end
duplicator.RegisterConstraint( "Pulley", Pulley, "Ent1", "Ent4", "Bone1", "Bone4", "LPos1", "LPos4", "WPos2", "WPos3", "forcelimit", "rigid", "width", "material" )


--[[----------------------------------------------------------------------
	Ballsocket( ... )
	Creates a Ballsocket constraint
------------------------------------------------------------------------]]
function Ballsocket( Ent1, Ent2, Bone1, Bone2, LPos, forcelimit, torquelimit, nocollide )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	-- Get information we're about to use
	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )
	local WPos = Phys2:LocalToWorld( LPos )

	if ( Phys1 == Phys2 ) then return false end

	onStartConstraint( Ent1, Ent2 )

		local Constraint = ents.Create("phys_ballsocket")
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(Constraint) then 
			onFinishConstraint( Ent1, Ent2 )
			return
		end
		
		ConstraintCreated( Constraint )
		Constraint:SetPos( WPos )
		if ( forcelimit && forcelimit > 0 ) then Constraint:SetKeyValue( "forcelimit", forcelimit ) end
		if ( torquelimit && torquelimit > 0 ) then Constraint:SetKeyValue( "torquelimit", torquelimit ) end
		if ( nocollide && nocollide > 0 ) then Constraint:SetKeyValue( "spawnflags", 1 ) end
		Constraint:SetPhysConstraintObjects( Phys1, Phys2 )
		Constraint:Spawn()
		Constraint:Activate()

	onFinishConstraint( Ent1, Ent2 )
	AddConstraintTable( Ent1, Constraint, Ent2 )

	local ctable = {
		Type = "Ballsocket",
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
		LPos = LPos,
		forcelimit = forcelimit,
		torquelimit = torquelimit,
		nocollide = nocollide
	}

	Constraint:SetTable( ctable )

	return Constraint

end
duplicator.RegisterConstraint( "Ballsocket", Ballsocket, "Ent1", "Ent2", "Bone1", "Bone2", "LPos", "forcelimit", "torquelimit", "nocollide" )


--[[----------------------------------------------------------------------
	Winch( ... )
	Creates a Winch constraint
------------------------------------------------------------------------]]
function Winch( pl, Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, width, fwd_bind, bwd_bind, fwd_speed, bwd_speed, material, toggle )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )
	-- local WPos1 = Phys1:LocalToWorld( LPos1 )
	-- local WPos2 = Phys2:LocalToWorld( LPos2 )

	if ( Phys1 == Phys2 ) then return false end

	local const, dampen = CalcElasticConsts( Phys1, Phys2, Ent1, Ent2, false )

	local Constraint, rope = Elastic( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, const, dampen, 0, material, width, true )

	if ( !Constraint ) then return nil, rope end

	local ctable = {
		Type = "Winch",
		pl = pl,
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
		LPos1 = LPos1,
		LPos2 = LPos2,
		width = width,
		fwd_bind = fwd_bind,
		bwd_bind = bwd_bind,
		fwd_speed = fwd_speed,
		bwd_speed = bwd_speed,
		material = material,
		toggle = toggle
	}
	Constraint:SetTable( ctable )

	-- Attach our Controller to the Elastic constraint
	local controller = ents.Create( "gmod_winch_controller" )
	
	-- Zombie: Why was this check not here? :)
	if !IsValid(controller) then 
		return
	end
	
	controller:SetConstraint( Constraint )
	controller:SetRope( rope )
	controller:Spawn()

	Constraint:DeleteOnRemove( controller )
	Ent1:DeleteOnRemove( controller )
	Ent2:DeleteOnRemove( controller )

	if ( toggle ) then

		numpad.OnDown( pl, fwd_bind, "WinchToggle", controller, 1 )
		numpad.OnDown( pl, bwd_bind, "WinchToggle", controller, -1 )

	else

		numpad.OnDown( pl, fwd_bind, "WinchOn", controller, 1 )
		numpad.OnUp( pl, fwd_bind, "WinchOff", controller )
		numpad.OnDown( pl, bwd_bind, "WinchOn", controller, -1 )
		numpad.OnUp( pl, bwd_bind, "WinchOff", controller )

	end

	return Constraint, rope, controller

end
duplicator.RegisterConstraint( "Winch", Winch, "pl", "Ent1", "Ent2", "Bone1", "Bone2", "LPos1", "LPos2", "width", "fwd_bind", "bwd_bind", "fwd_speed", "bwd_speed", "material", "toggle" )


--[[----------------------------------------------------------------------
	Hydraulic( ... )
	Creates a Hydraulic constraint
------------------------------------------------------------------------]]
function Hydraulic( pl, Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, Length1, Length2, width, key, fixed, speed, material, toggle )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )
	-- local WPos1 = Phys1:LocalToWorld( LPos1 )
	-- local WPos2 = Phys2:LocalToWorld( LPos2 )

	if ( Phys1 == Phys2 ) then return false end
	if ( toggle == nil ) then toggle = true end -- Retain original behavior

	local const, dampn = CalcElasticConsts( Phys1, Phys2, Ent1, Ent2, fixed )

	local Constraint, rope = Elastic( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, const, dampn, 0, material, width, false )
	local ctable = {
		Type = "Hydraulic",
		pl = pl,
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
		LPos1 = LPos1,
		LPos2 = LPos2,
		Length1 = Length1,
		Length2 = Length2,
		width = width,
		key = key,
		fixed = fixed,
		fwd_speed = speed,
		bwd_speed = speed,
		toggle = toggle,
		material = material
	}
	Constraint:SetTable( ctable )

	if ( Constraint && Constraint != rope ) then

		local slider

		if ( fixed == 1 ) then
			slider = Slider( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0 )
			
			-- Zombie: Why was this check not here? :)
			if !IsValid(slider) then 
				return
			end
		
			slider:SetTable( {} )
			Constraint:DeleteOnRemove( slider )
		end

		local controller = ents.Create( "gmod_winch_controller" )
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(controller) then 
			return
		end
		
		if ( Length2 > Length1 ) then
			controller:SetKeyValue( "minlength", Length1 )
			controller:SetKeyValue( "maxlength", Length2 )
		else
			controller:SetKeyValue( "minlength", Length2 )
			controller:SetKeyValue( "maxlength", Length1 )
		end

		controller:SetConstraint( Constraint )
		controller:Spawn()

		Ent1:DeleteOnRemove( controller )
		Ent2:DeleteOnRemove( controller )

		Constraint:DeleteOnRemove( controller )

		if ( toggle ) then
			numpad.OnDown( pl, key, "HydraulicToggle", controller )
		else
			numpad.OnUp( pl, key, "HydraulicDir", controller, -1 )
			numpad.OnDown( pl, key, "HydraulicDir", controller, 1 )
		end

		return Constraint, rope, controller, slider
	else
		return Constraint, rope
	end

end
duplicator.RegisterConstraint( "Hydraulic", Hydraulic, "pl", "Ent1", "Ent2", "Bone1", "Bone2", "LPos1", "LPos2", "Length1", "Length2", "width", "key", "fixed", "fwd_speed", "material", "toggle" )


--[[----------------------------------------------------------------------
	Muscle( ... )
	Creates a Muscle constraint
------------------------------------------------------------------------]]
function Muscle( pl, Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, Length1, Length2, width, key, fixed, period, amplitude, starton, material )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )
	-- local WPos1 = Phys1:LocalToWorld( LPos1 )
	-- local WPos2 = Phys2:LocalToWorld( LPos2 )

	if ( Phys1 == Phys2 ) then return false end

	local const, dampn = CalcElasticConsts( Phys1, Phys2, Ent1, Ent2, fixed )

	local Constraint, rope = Elastic( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, const, dampn, 0, material, width, false )
	if ( !Constraint ) then return false end

	local ctable = {
		Type = "Muscle",
		pl = pl,
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
		LPos1 = LPos1,
		LPos2 = LPos2,
		Length1 = Length1,
		Length2 = Length2,
		width = width,
		key = key,
		fixed = fixed,
		period = period,
		amplitude = amplitude,
		toggle = true,
		starton = starton,
		material = material
	}
	Constraint:SetTable( ctable )

	local slider = nil

	if ( fixed == 1 ) then
		slider = Slider( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0 )
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(slider) then 
			return
		end
		
		slider:SetTable( {} ) -- ??
		Constraint:DeleteOnRemove( slider )
	end

	local controller = ents.Create( "gmod_winch_controller" )
	
	-- Zombie: Why was this check not here? :)
	if !IsValid(controller) then 
		return
	end
	
	if ( Length2 > Length1 ) then
		controller:SetKeyValue( "minlength", Length1 )
		controller:SetKeyValue( "maxlength", Length2 )
	else
		controller:SetKeyValue( "minlength", Length2 )
		controller:SetKeyValue( "maxlength", Length1 )
	end
	controller:SetKeyValue( "type", 1 )
	controller:SetConstraint( Constraint )
	controller:Spawn()

	Ent1:DeleteOnRemove( controller )
	Ent2:DeleteOnRemove( controller )

	Constraint:DeleteOnRemove( controller )

	numpad.OnDown( pl, key, "MuscleToggle", controller )

	if ( starton ) then
		controller:SetDirection( 1 )
	end

	return Constraint, rope, controller, slider

end
duplicator.RegisterConstraint( "Muscle", Muscle, "pl", "Ent1", "Ent2", "Bone1", "Bone2", "LPos1", "LPos2", "Length1", "Length2", "width", "key", "fixed", "period", "amplitude", "starton", "material" )


--[[----------------------------------------------------------------------
	Returns true if this entity has valid constraints
------------------------------------------------------------------------]]
function HasConstraints( ent )

	if ( !ent ) then return false end
	if ( !ent.Constraints ) then return false end

	local count = 0
	for key, Constraint in pairs( ent.Constraints ) do

		if ( !IsValid( Constraint ) ) then

			ent.Constraints[ key ] = nil

		else

			count = count + 1

		end

	end

	return count != 0

end


--[[----------------------------------------------------------------------
	Returns this entities constraints table
	This is for the future, because ideally the constraints table will eventually look like this - and we won't have to build it every time.
------------------------------------------------------------------------]]
function GetTable( ent )

	if ( !HasConstraints( ent ) ) then return {} end

	local RetTable = {}

	for key, ConstraintEntity in pairs( ent.Constraints ) do

		local con = {}

		table.Merge( con, ConstraintEntity:GetTable() )

		con.Constraint = ConstraintEntity
		con.Entity = {}

		for i = 1, 6 do

			if ( con[ "Ent" .. i ] && ( con[ "Ent" .. i ]:IsWorld() or con[ "Ent" .. i ]:IsValid() ) ) then

				con.Entity[ i ] = {}
				con.Entity[ i ].Index = con[ "Ent" .. i ]:EntIndex()
				con.Entity[ i ].Entity = con[ "Ent" .. i ]
				con.Entity[ i ].Bone = con[ "Bone" .. i ]
				con.Entity[ i ].LPos = con[ "LPos" .. i ]
				con.Entity[ i ].WPos = con[ "WPos" .. i ]
				con.Entity[ i ].Length = con[ "Length" .. i ]
				con.Entity[ i ].World = con[ "Ent" .. i ]:IsWorld()

			end

		end

		table.insert( RetTable, con )

	end

	return RetTable

end

--[[----------------------------------------------------------------------
	Make this entity forget any constraints it knows about
------------------------------------------------------------------------]]
function ForgetConstraints( ent )

	ent.Constraints = {}

end


--[[----------------------------------------------------------------------
	Returns a list of constraints, by name
------------------------------------------------------------------------]]
function FindConstraints( ent, name )

	local ConTable = GetTable( ent )

	local Found = {}

	for k, con in ipairs( ConTable ) do

		if ( con.Type == name ) then
			table.insert( Found, con )
		end

	end

	return Found

end

--[[----------------------------------------------------------------------
	Returns the first constraint found by name
------------------------------------------------------------------------]]
function FindConstraint( ent, name )

	local ConTable = GetTable( ent )

	for k, con in ipairs( ConTable ) do

		if ( con.Type == name ) then
			return con
		end

	end

	return nil

end

--[[----------------------------------------------------------------------
	Returns the first constraint found by name
------------------------------------------------------------------------]]
function FindConstraintEntity( ent, name )

	local ConTable = GetTable( ent )

	for k, con in ipairs( ConTable ) do

		if ( con.Type == name ) then
			return con.Constraint
		end

	end

	return NULL

end

--[[----------------------------------------------------------------------
	Returns a table of all the entities constrained to ent
------------------------------------------------------------------------]]
function GetAllConstrainedEntities( ent, ResultTable )

	local ResultTable = ResultTable or {}

	if ( !IsValid( ent ) ) then return end
	if ( ResultTable[ ent ] ) then return end

	ResultTable[ ent ] = ent

	local ConTable = GetTable( ent )

	for k, con in ipairs( ConTable ) do

		for EntNum, Ent in pairs( con.Entity ) do
			GetAllConstrainedEntities( Ent.Entity, ResultTable )
		end

	end

	return ResultTable

end

--addons/arccw_weapons/lua/arccw/shared/attachments/15a_top_stabilizer.lua:
att.PrintName = "15a Stabilizer"
att.Description = "Stabilizer designed for better accurancy at long-range combat."
att.SortOrder = 40
att.Icon = Material("interfaz/armas/swrp_att_e11_grip1.png")
att.Desc_Pros = {}
att.Desc_Cons = {}

att.AutoStats = true

att.Slot = "15a_top"
att.ActivateElements = {"15a_top_stabilizer"}

att.Mult_Range = 1.58
att.Mult_Recoil = 0.50
att.Mult_SightTime = 1.2
att.Mult_AccuracyMOA = 1
att.Mult_ShootPitch = 0.87
--addons/arccw_weapons/lua/arccw/shared/attachments/a280cfe_barrel_sniper.lua:
att.PrintName = "Sniper Barrel"
att.Description = "Improves ranged performance, but at the cost of mobility."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "cfe_barrel"
att.ActivateElements = {"a280cfe_sniper"}

att.Mult_MoveSpeed = 0.9
att.Mult_MoveDispersion = 1.25
att.Mult_SightTime = 1.15
att.Mult_AccuracyMOA = 0.5
att.Mult_ShootPitch = 0.90

att.Mult_Range = 2.7
att.Mult_Damage = 1.9
att.Mult_DamageMin = 1.4

att.Mult_RPM = 0.75

--addons/arccw_weapons/lua/arccw/shared/attachments/a280cfe_powerpack.lua:
att.PrintName = "Extended-power"
att.Description = "More tibanna compression. More damage at the cost of less magazine capacity."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "cfe_powerpack"
att.ActivateElements = {"a280cfe_powerpack"}

att.Override_ClipSize = 12
att.Mult_Range = 1.25
att.Mult_Damage = 1.1
att.Mult_DamageMin = 1.1
att.Mult_Recoil = 1.2
att.Mult_RPM = 0.75
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_gl_impact.lua:
att.PrintName = "Impact Grenade Launcher"
att.Icon = Material("interfaz/armas/sw_highenergyclip.png")
att.Description = "Throwable grenade with impact capacity."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.AutoStats = true
att.Slot = "ammo_rocket"

att.SortOrder = 1738
att.Override_ShootEntity = "tfa_battlefront_ent_nade_impact"
att.Mult_SightTime = 1.25
att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_high.lua:
att.PrintName = "High Tibanna Density"
att.Icon = Material("entities/acwatt_go_ammo_blanks.png", "mips smooth")
att.Description = "Cycle the potency of the platform to allow for its chambering in High Density Tibanna."
att.Desc_Pros = {
}
att.Desc_Cons = {
}

att.AutoStats = true
att.Slot = "ammo"

att.Reload = 1
att.Mult_DamageMin = 1.15
att.Mult_Recoil = 1.25
att.Mult_SightTime = 1
att.Mult_RPM = 0.65
att.NotForNPCs = true
att.Mult_Damage = 1.25
att.Mult_MuzzleVelocity = 1.25
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_rocket_smoke.lua:
att.PrintName = "Smokescreen"
att.Icon = Material("entities/acwatt_ammo_rpg7_smoke.png")
att.Description = "Smoke rockets that produce a wide smokescreen on impact. Also does light damage."
att.Desc_Pros = {
    "Smoke Screen"
}
att.Desc_Cons = {
    "Splash Damage",
}
att.AutoStats = true
att.Slot = "ammo_rocket"

att.Mult_SightTime = 0.9
att.Mult_MoveSpeed = 1.15

att.Override_ShootEntity = "arccw_rocket_smoke"
--addons/arccw_weapons/lua/arccw/shared/attachments/aocrp_ubgl.lua:
att.PrintName = "Granatwerfer"
att.AbbrevName = "Granatwerfer"
att.Icon = Material("interfaz/iconos/jedi/453218427_4064545516.png", "mips smooth")
att.Description = "Single-shot underbarrel grenade launcher designed to Special Infantry."

att.SortOrder = -100000

att.AutoStats = true
att.Desc_Pros = {
}
att.Slot = "aocrp_ubgl"
att.ExcludeFlags = {"uc_noubgl"}
att.LHIK = true
att.ModelOffset = Vector(0, 0, 0)
att.Model = "models/weapons/arccw/atts/uc_ubgl_m203.mdl"
att.SelectUBGLSound =  ""
att.ExitUBGLSound = ""
att.UBGL = true
att.UBGL_PrintName = "UBGL"
att.UBGL_Automatic = false
--att.UBGL_MuzzleEffect = "wpn_muzzleflash_dc17_orange"
att.UBGL_Ammo = "Grenade"
att.UBGL_RPM = 120
att.UBGL_Recoil = 2
att.UBGL_Capacity = 1
att.UBGL_ClipSize = 1
att.LHIK_GunDriver = 2
att.LHIK_CamDriver = 3

local function Ammo(wep)
    return (wep:GetOwner():GetAmmoCount("Grenade"))
end

att.Hook_LHIK_TranslateAnimation = function(wep, key)
    if key == "idle" then
        if wep:GetInUBGL() then
            return "idle_armed"
        else
            return "idle"
        end
    end
end

att.Hook_ShouldNotSight = function(wep)
    if wep:GetInUBGL() then
        return true
    end
end

att.Hook_OnSelectUBGL = function(wep)
    wep:SetNextSecondaryFire(CurTime() + 0.7)
    if (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoLHIKAnimation("to_armed", 0.7)
        wep:PlaySoundTable({
            {s = "arccw_uc/common/rattle_b2i_rifle.ogg", t = 0},
            {s = "arccw_uc/common/raise.ogg", t = 0.2},
            {s = "arccw_uc/common/grab.ogg", t = 0.5},
        })
    end
end

att.Hook_OnDeselectUBGL = function(wep)
    wep:SetNextSecondaryFire(CurTime() + 0.7)
    if (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoLHIKAnimation("to_idle", 0.7)
        wep:PlaySoundTable({
            {s = "arccw_uc/common/rattle_b2i_rifle.ogg", t = 0},
            {s = "arccw_uc/common/shoulder.ogg", t = 0.4},
        })
    end
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    local owner = wep:GetOwner()
    local class = wep:GetBuff_Override("UBGL_Entity") or "tfa_battlefront_ent_nade_impact"

    if class == "BUCKSHOT" then
        local dir = (owner:EyeAngles() + wep:GetFreeAimOffset()):Forward()

        local bullet = {
            DamageMax = 18,
            DamageMin = 6,
            Range = 50,
            RangeMin = 5,
            DamageType = DMG_BUCKSHOT + DMG_BULLET,
            Penleft = 0,
            Penetration = 0,
            Num = 1,
            Damaged = {},
            Weapon = wep,
        }

        local data = {
            Attacker = owner,
            Dir        = dir,
            Src        = wep:GetShootSrc(),
            Spread     = Vector(0, 0, 0),
            Damage     = 0,
            Num        = 1,
            Force      = 5,
            HullSize   = 4,
            Weapon     = wep,
            Callback = function(attacker, tr, dmg)
                -- HACK: Pass a fake bullet table instead of ourselves so we don't use the weapon's attributes unintentionally
                bullet.Travelled = (tr.HitPos - tr.StartPos):Length()
                ArcCW:BulletCallback(att, tr, dmg, bullet)
            end
        }

        if wep:GetOwner():IsPlayer() then
            for n = 1, 20 do
                local dirry = Vector(dir.x, dir.y, dir.z)
                math.randomseed(math.Round(util.SharedRandom(n, -1337, 1337, !game.SinglePlayer() and wep:GetOwner():GetCurrentCommand():CommandNumber() or CurTime()) * (wep:EntIndex() % 30241)))
                wep:ApplyRandomSpread(dirry, ArcCW.MOAToAcc * 50)
                data.Dir = dirry
                if GetConVar("arccw_bullet_enable"):GetBool() then
                    ArcCW:ShootPhysBullet(wep, data.Src, (250 / ArcCW.HUToM) * data.Dir:GetNormalized(), 0, bullet)
                else
                    owner:FireBullets(data, true)
                end
            end
        else
            data.Spread = Vector(ArcCW.MOAToAcc * 50, ArcCW.MOAToAcc * 50, 0)
            data.Num = 20
            owner:FireBullets(data, true)
        end
        wep:MyEmitSound(")^/arccw_uc/common/gl_fire_buck.ogg", 100, 100, 1, CHAN_WEAPON )
        wep:MyEmitSound(")^/arccw_uc/common/gl_fire_buck_dist.ogg", 149, 100, 0.5, CHAN_WEAPON + 1)
    else
        local proj = wep:FireRocket(class, 2500)
        if SERVER then
            proj.Damage = 130 -- lower than the m79 (200) for balance reasons
        end
        wep:MyEmitSound(")^/arccw_uc/common/40mm/fire-0" .. math.random(1, 6) .. ".ogg", 100, 100, 1, CHAN_WEAPON)
        wep:MyEmitSound(")^/arccw_uc/common/40mm/fire-dist-0" .. math.random(1, 6) .. ".ogg", 149, 100, 0.5, CHAN_BODY)
        wep:MyEmitSound(")^/arccw_uc/common/40mm/mech-0" .. math.random(1, 6) .. ".ogg", 149, 100, 0.5, CHAN_AUTO)
    end

    if game.SinglePlayer() and SERVER or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoEffects()
        wep:DoLHIKAnimation("fire")
    end
    wep:SetClip2(wep:Clip2() - 1)
    wep:DoEffects()
end

local casing = {"arccw_uc/common/40mm/casing-40mm-01.ogg", "arccw_uc/common/40mm/casing-40mm-02.ogg", "arccw_uc/common/40mm/casing-40mm-03.ogg", "arccw_uc/common/40mm/casing-40mm-04.ogg", "arccw_uc/common/40mm/casing-40mm-05.ogg", "arccw_uc/common/40mm/casing-40mm-06.ogg"}

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end
    if Ammo(wep) <= 0 then return end

    wep:SetNextSecondaryFire(CurTime() + 2.75)

    local holy = (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted())
    if holy then
        wep:DoLHIKAnimation("reload", 2.75)
        wep:PlaySoundTable({
            {s = { "arccw_uc/common/rattle1.ogg", "arccw_uc/common/rattle2.ogg", "arccw_uc/common/rattle3.ogg" }, t = 0},
            {s = "arccw_uc/common/40mm/203open.ogg", t = 0.2},
            {s = casing, t = 0.7},
            {s = "arccw_uc/common/magpouch_replace_small.ogg", t = 0.9},
            {s = "arccw_uc/common/40mm/203insert.ogg", t = 1.2},
            {s = "arccw_uc/common/shoulder.ogg", t = 1.5},
            {s = "arccw_uc/common/40mm/203close.ogg", t = 1.7},
            {s = "arccw_uc/common/shoulder.ogg", t = 2.3},
        })
    end

    local reserve = Ammo(wep)

 
    wep:GetOwner():RemoveAmmo( 1, "Grenade" )
    wep:SetClip2(1)

end

att.Mult_SightTime = 1.2
att.Mult_SpeedMult = 0.9
att.Mult_SightedSpeedMult = 0.85
att.ToggleLockDefault = false
att.ToggleStats = {
    {
        PrintName = "Impact V1",
        UBGL_Entity = "tfa_battlefront_ent_nade_impact"
    },
    {
        PrintName = "Impact V2",
        UBGL_Entity = "arccw_thr_impact"
    },
    {
        PrintName = "Ping",
        UBGL_Entity = "rw_sw_nade"
    },
    {
        PrintName = "Smoke",
        UBGL_Entity = "tfa_battlefront_ent_nade_smoke"
    },
    {
        PrintName = "Droidenmongo",
        UBGL_Entity = "rw_sw_ent_nade_emp"
    },
}
--addons/arccw_weapons/lua/arccw/shared/attachments/muzzle_heavy_dc15a_mod.lua:
att.PrintName = "Heavy DC15-A Muzzle Mod"
att.Description = "Bulky and heavy, but provides better ballistic performance.\n\n\"By the time you figured it out, it would be too late.\""

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/atts/dlt19_heavyrifle_muzzle1.mdl"
att.ModelOffset = Vector(0, 0, 0)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = false
att.IsMuzzleDevice = false

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 1


att.Mult_RecoilSide = 0.75

att.Mult_ShootSpeedMult = 1.05
att.Mult_Sway = 1

att.Add_BarrelLength = 6
att.Mult_SightTime = 1.1
att.Mult_HipDispersion = 1.1
att.Mult_Range = 1
--addons/arccw_weapons/lua/arccw/shared/attachments/optic_dlt19_scope.lua:
att.PrintName = "DLT-19x Magnifying Optic"
att.Icon = Material("entities/dlt19x_icon.png")
att.Description = "High-magnification sniper rifle scope for long range combat."

att.SortOrder = 9

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/weapons/arccw/DLT19X_scope.mdl"
att.ModelOffset = Vector(0, 0, -0.1)
att.AdditionalSights = {
    {
        Pos = Vector(0, 14, -1.6),
        Ang = Angle(0, 0, 0),
        Magnification = 1.5,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 10,
        ZoomSound = "weapons/arccw/fiveseven/fiveseven_slideback.wav",
        IgnoreExtra = true
    }
}

att.ScopeGlint = false

att.Holosight = true
att.HolosightReticle = Material("scope/star_ret.png", "smooth")
att.HolosightNoFlare = true
att.HolosightSize = 8.5
att.HolosightBone = "holosight"
att.HolosightPiece = "models/weapons/arccw/DLT19X_scope_HSP.mdl"
att.Colorable = false

att.HolosightMagnification = 0
att.HolosightBlackbox = true

att.HolosightConstDist = 64

att.HolosightMagnificationMin = 2
att.HolosightMagnificationMax = 3
att.HoloSightColorable = false

att.Mult_SightTime = 1.35
att.Mult_SightedSpeedMult = 0.8
att.Mult_SpeedMult = 0.9
--addons/arccw_weapons/lua/arccw/shared/attachments/optic_e11_scope.lua:
att.PrintName = "E-11 Magnifying Optic"
att.Icon = Material("entities/dlt19x_icon.png")
att.Description = "High-magnification sniper rifle scope for long range combat."

att.SortOrder = 9

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/atts/e11_scope.mdl"
att.ModelOffset = Vector(0, 0, -0)
att.AdditionalSights = {
    {
        Pos = Vector(0.01, 9, -1.165),
        Ang = Angle(0, 0, 0),
        Magnification = 1.5,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 10,
        ZoomSound = "weapons/arccw/fiveseven/fiveseven_slideback.wav",
        IgnoreExtra = true
    }
}

att.ScopeGlint = false

att.Holosight = true
att.HolosightReticle = Material("scope/star_ret.png", "smooth")
att.HolosightNoFlare = true
att.HolosightSize = 9
att.HolosightBone = "holosight"
att.HolosightPiece = "models/atts/e11_scope_hsp.mdl"
att.Colorable = false

att.HolosightMagnification = 0
att.HolosightBlackbox = true

att.HolosightConstDist = 44

att.HolosightMagnificationMin = 2
att.HolosightMagnificationMax = 3
att.HoloSightColorable = false

att.Mult_SightTime = 1.35
att.Mult_SightedSpeedMult = 0.8
att.Mult_SpeedMult = 0.9
--addons/arccw_weapons/lua/arccw/shared/attachments/optic_valken38_scope.lua:
att.PrintName = "Valken 38x Magnifying Optic"
att.Icon = Material("entities/dlt19x_icon.png")
att.Description = "High-magnification sniper rifle scope for long range combat."

att.SortOrder = 9

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/atts/valken_scope.mdl"
att.ModelOffset = Vector(0, 0, -0)
att.AdditionalSights = {
    {
        Pos = Vector(-0.01, 9, -1.8),
        Ang = Angle(0, 0, 0),
        Magnification = 1.5,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 10,
        ZoomSound = "weapons/arccw/fiveseven/fiveseven_slideback.wav",
        IgnoreExtra = true
    }
}

att.ScopeGlint = false

att.Holosight = true
att.HolosightReticle = Material("scope/star_ret.png", "smooth")
att.HolosightNoFlare = true
att.HolosightSize = 7.6
att.HolosightBone = "holosight"
att.HolosightPiece = "models/atts/valken_scope_hsp.mdl"
att.Colorable = false

att.HolosightMagnification = 0
att.HolosightBlackbox = true

att.HolosightConstDist = 64

att.HolosightMagnificationMin = 2
att.HolosightMagnificationMax = 3
att.HoloSightColorable = false

att.Mult_SightTime = 1.35
att.Mult_SightedSpeedMult = 0.8
att.Mult_SpeedMult = 0.9
--addons/arccw_weapons/lua/arccw/shared/attachments/perk_basic.lua:
att.PrintName = "Basic Training"

att.Icon = Material("interfaz/iconos/kraken/jedi comm assault specialist/3099160832_1788285497.png")
att.Description = [[Clone troopers, also known as Republic troopers, Republic troops, Republic soldiers, Regs, and nicknamed the "Boys in White," were highly trained soldiers in the Grand Army of the Republic. Representing the future of galactic warfare, clones were designed to be far superior to battle droids.]]
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"perk"}

att.AutoStats = true
att.NotForNPC = true

att.Mult_MoveSpeed = 1.1
att.Mult_JumpDispersion = 0.85

att.Mult_AccuracyMOA = 0.95
att.Mult_HipDispersion = 0.95
att.Mult_MoveDispersion = 0.95

att.Mult_DrawTime = 0.9
att.Mult_HolsterTime = 0.9
att.Mult_SightTime = 0.9

att.Mult_SpeedMult = 1.05
att.Mult_SightedSpeedMult = 1.1

att.Mult_ReloadTime = 0.95

att.Mult_Recoil = 0.85
att.Mult_RecoilSide = 0.85
att.Mult_VisualRecoilMult = 0.8
att.Mult_Sway = 0.9

--addons/arccw_weapons/lua/arccw/shared/attachments/perk_comando.lua:
att.PrintName = "Commando Training"

att.Icon = Material("interfaz/iconos/kraken/jedi comm assault specialist/543062217_3838188846.png")
att.Description = [[Clone commandos, also known as Republic commandos while serving under the Galactic Republic, were elite clone troopers that served in the Grand Army of the Republic's Special Operations Brigade during the Clone Wars. A result of the Kaminoans' genetic experimentation with the Jango Fett template, they were special forces soldiers noted for their training and elite status in the clone army.]]
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"perk"}

att.AutoStats = true
att.NotForNPC = true

att.Mult_MoveSpeed = 1.4
att.Mult_JumpDispersion = 0.97

att.Mult_AccuracyMOA = 0.90
att.Mult_HipDispersion = 0.90
att.Mult_MoveDispersion = 0.90

att.Mult_DrawTime = 0.7
att.Mult_HolsterTime = 0.9
att.Mult_SightTime = 0.7
att.Mult_SpeedMult = 1.10
att.Mult_SightedSpeedMult = 1.1
att.Mult_ReloadTime = 0.90
att.Mult_Recoil = 0.80
att.Mult_RecoilSide = 0.80
att.Mult_VisualRecoilMult = 0.7
att.Mult_Sway = 0.87

--addons/arccw_weapons/lua/arccw/shared/attachments/sw_imperial_stun.lua:
att.PrintName = "[ Starwars ] Stun Rounds"
att.AbbrevName = "Stun round (5 seconds)"
att.SortOrder = -2
att.Icon = Material("")
att.Description = "Stun round."

att.Desc_Pros = {
    "Causes stun for 5 seconds!"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}

att.Slot = {"sw_imp_ammo"}

att.SortOrder = -9001
att.AutoStats = true

att.Override_AmmoPerShot = 5
att.Override_Num_Priority = 9001
att.Mult_RPM = 0.5
att.Override_Tracer = "effect_sw_laser_blue_stun"

att.Hook_BulletHit = function(wep, data)
	GMSERV:AddStatus(data.tr.Entity, data.att, "stun", 5, 5, true) --Entity,Owner,Status Effect Type (Yes, you can add the others),Duration, Damage, ParticleEffect
end

att.Hook_GetShootSound = function(wep, sound)
    return false
end

att.Hook_AddShootSound = function(wep, data)
    wep:MyEmitSound("w/e11_stun.wav", data.volume, data.pitch, 1, CHAN_WEAPON - 1)
end
--addons/arccw_weapons/lua/arccw/shared/attachments/sw_stock_e11r.lua:
att.PrintName = "SW-Stock E-11R"
att.AbbrevName = "E11-r Stock"
att.SortOrder = 100
att.Icon = nil
att.Description = "Better control."
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "e11r_stock"

att.Model = "models/arccw/sw_battlefront/props/e11r_stock/e11r_stock.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(-90, 0, 0)
att.ModelOffset = Vector(-0.1, -12, -0.3)
att.ModelScale = Vector(1, 1, 1)

att.AutoStats = true

att.HideIfBlocked = true

att.Mult_SightTime = 1.05
att.Mult_Sway = 1.1

att.Mult_SpeedMult = 1.1

att.Mult_DrawTime = 1.1
att.Mult_HolsterTime = 1.05

att.Mult_HipDispersion = 1.05

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--addons/arccw_weapons/lua/arccw/shared/attachments/sw_stun10.lua:
att.PrintName = "Betubung - 10s"
att.AbbrevName = "Betubung - 10s"
att.Icon = Material("interfaz/iconos/dpsicon4.png")
att.Description = "Replace the main-fire for stun rounds."

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"aocrp_ammo"}

att.AutoStats = true
att.Override_AmmoPerShot = 5
att.Override_Tracer = "effect_sw_laser_blue_stun"
att.Hook_BulletHit = function(wep, data)
	GMSERV:AddStatus(data.tr.Entity, data.att, "stun", 10, 1, true) --Entity,Owner,Status Effect Type (Yes, you can add the others),Duration, Damage, ParticleEffect
end
att.Hook_GetShootSound = function(wep, sound)
    return false
end
att.Hook_AddShootSound = function(wep, data)
    wep:MyEmitSound("everfall/weapons/republic/stun.wav", data.volume, data.pitch, 1, CHAN_WEAPON - 1)
end
--lua/arccw/shared/attachments/uc_40mm_buckshot.lua:
att.PrintName = "40mm Buckshot Grenades"
att.AbbrevName = "Buckshot"
att.Icon = Material("entities/att/arccw_uc_40mm_generic.png", "mips smooth")
att.Description = "Officially desginated the 'Multiple Projectile Anti Personnel' ammunition, these grenades are effectively large buckshot rounds containing 20 pellets.\nIntended to be used when the enemy is too close to use explosives."
att.Desc_Pros = {
    "uc.40mm.buckshot"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_40mm"

att.AutoStats = true

att.Override_ShootEntity = false
att.Override_Num = 20

att.Override_Damage = 18 * 20
att.Override_DamageMin = 6 * 20

att.Override_Range = 50
att.Override_RangeMin = 5
att.Override_HullSize = 0.5

att.Override_AccuracyMOA = 50

att.ActivateElements = {"40mm_buckshot"}

att.Hook_SelectReloadAnimation = function(wep, anim)
    return anim .. "_shotgun"
end

att.Hook_GetShootSound = function(wep, fsound)
    if fsound == wep.ShootSound then return ")^/arccw_uc/common/gl_fire_buck.ogg" end
end

att.Hook_GetDistantShootSound = function(wep, distancesound)
    if distancesound == wep.DistantShootSound then
        return ")^/arccw_uc/common/gl_fire_buck_dist.ogg" end
end

if engine.ActiveGamemode() == "urbanstrife" then
    att.PenetrationAmmoType = "buckshot"
end
--lua/arccw/shared/attachments/uc_40mm_dp.lua:
att.PrintName = "40mm Dual Purpose Grenades"
att.AbbrevName = "Dual Purpose"
att.Icon = Material("entities/att/arccw_uc_40mm_generic.png", "mips smooth")
att.Description = "Grenades with a shaped charge for armor penetration, allowing it to punch through thin walls or deal massive impact damage to enemies or vehicles."
att.Desc_Pros = {
    "uc.40mm.hedp",
    "uc.40mm.impact"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_40mm"

att.Override_ShootEntity = "arccw_uc_40mm_dp"

att.AutoStats = true

att.Mult_Damage = 0.6
att.Mult_DamageMin = 0.6

att.ActivateElements = {"40mm_dp"}
--lua/arccw/shared/attachments/uc_40mm_hv.lua:
att.PrintName = "40mm High Velocity Grenades"
att.AbbrevName = "High Velocity"
att.Icon = Material("entities/att/arccw_uc_40mm_generic.png", "mips smooth")
att.Description = "Fin-stabilized, lightweight grenade with explosive payload.\nFlies fast and with low drag, but creates a smaller and less lethal explosion."
att.Desc_Pros = {
    "uc.40mm.drag.low"
}
att.Desc_Cons = {
    "uc.40mm.blast.low"
}
att.Desc_Neutrals = {
}
att.Slot = "uc_40mm"

att.Override_ShootEntity = "arccw_uc_40mm_hv"

att.AutoStats = true

att.Mult_Damage = 0.85
att.Mult_DamageMin = 0.85

att.Mult_MuzzleVelocity = 2

att.Mult_ShootPitch = 1.15

att.ActivateElements = {"40mm_hv"}
--lua/arccw/shared/attachments/uc_40mm_smoke.lua:
att.PrintName = "40mm Smoke Grenades"
att.AbbrevName = "Smoke"
att.Icon = Material("entities/att/arccw_uc_40mm_generic.png", "mips smooth")
att.Description = "Less-than-lethal grenades that create a ring of smoke, obscuring vision."
att.Desc_Pros = {
    "uc.40mm.smoke"
}
att.Desc_Cons = {
    "uc.40mm.nodmg"
}
att.Desc_Neutrals = {
}
att.Slot = "uc_40mm"

att.Override_ShootEntity = "arccw_uc_40mm_smoke"

att.AutoStats = true

att.ActivateElements = {"40mm_smoke"}
--lua/arccw/shared/attachments/uc_ammo_blank.lua:
att.PrintName = "\"BLNK\" Blank Cartridges"
att.AbbrevName = "\"BLNK\" Blanks"
att.SortOrder = -2
att.Icon = Material("entities/att/arccw_uc_ammo_blank.png", "mips smooth")
att.Description = [[Cartridges sealed without a solid projectile. Performance is otherwise identical. Used when the muzzle report of a gunshot is necessary without the bullet, such as in filming, ceremonies, sports, and combat training.

In real life, blanks are not harmless. The muzzle shockwave or discharged wadding can and have killed people who do not exercise standard firearm precautions.]]
att.Desc_Pros = {
    "uc.infiniteammo"
}
att.Desc_Cons = {
    "uc.noprojectile"
}
att.Desc_Neutrals = {
}
att.Slot = {"uc_ammo","ud_ammo_shotgun"}

att.SortOrder = -9001
att.AutoStats = true
att.NotForNPCs = true

att.Override_Num = 0
att.Override_Num_Priority = 9001
att.Override_InfiniteAmmo = true

att.Override_UC_ShellColor = Color(0.3 * 255, 0.3 * 255, 0.3 * 255)

--lua/arccw/shared/attachments/uc_ammo_sg_confetti.lua:
att.PrintName = "\"PARTY\" Confetti"
att.Icon = Material("entities/att/arccw_uc_ammo_shotgun_generic.png", "mips smooth")
att.Description = [[Joke ammunition filled with tiny pieces of colorful paper. Produces a celebratory puff instead of anything reasonably lethal, allowing your weapon to double as a party popper.

Shotguns are truly the most versatile firearms.]]
att.Desc_Pros = {
    "uc.confetti",
    "uc.infiniteammo"
}
att.Desc_Cons = {
    "uc.noprojectile"
}
att.Desc_Neutrals = {
    "uc.manualonly"
}
att.Slot = {"ud_ammo_shotgun","uc_ammo"}
att.ActivateElements = {"uc_manualonly"}
att.SortOrder = -9001
att.AutoStats = true

att.NotForNPCs = true
att.Mult_Recoil = .2
att.Override_Num = 0
att.Override_Num_Priority = 9001
att.Override_InfiniteAmmo = true


local path = ")^arccw_uc/common/"
att.Hook_GetShootSound = function(wep, fsound)
    if fsound == wep.ShootSound or fsound == wep.FirstShootSound then return {path .. "confetti-01.ogg", path .. "confetti-02.ogg", path .. "confetti-03.ogg", path .. "confetti-04.ogg", path .. "confetti-05.ogg", path .. "confetti-06.ogg"} end
    --if fsound == wep.ShootSoundSilenced then return path .. "confetti_sup.ogg" end
end
att.Hook_GetDistantShootSound = function(wep, distancesound)
    if distancesound == wep.DistantShootSound then return false
    end
end
att.UC_NoInnyOuty = true

att.Hook_AddShootSound = function(wep, data)
    -- wep:EmitSound("garrysmod/balloon_pop_cute.wav", data.volume,data.pitch * math.random(80,115) / 100,1,CHAN_WEAPON - 1)

    local owner = wep:GetOwner()
    local effectdata = EffectData()
	effectdata:SetOrigin(owner:EyePos() + owner:GetAimVector() * 32)
    effectdata:SetStart(owner:GetAimVector())
    util.Effect("arccw_uc_confetti", effectdata)
end

att.Override_UC_ShellColor = Color(255, 127, 182)

att.Hook_Compatible = function(wep)
    if (!wep.ManualAction and !wep.UC_CanManualAction) or !wep:GetIsShotgun() or wep:GetBuff_Override("UC_Shotshell") then return false end
end
--lua/arccw/shared/attachments/uc_ammo_tmj.lua:
att.PrintName = "\"TMJ\" Total Metal Jacket Rounds"
att.AbbrevName = "\"TMJ\" Total Metal Jacket"

att.SortOrder = 2
att.Icon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth")
att.Description = "Bullet entirely encased in a thin jacket of metal over a core of different metal to protect it from abrasion or corrosion.\nProtecting the base of a lead-core bullet from burning powder gas may prevent molten lead from being released as a fine spray in turbulent gas leaving the muzzle of a firearm."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_ammo"

att.AutoStats = true

att.Mult_DamageMin = 1.2

att.Mult_Damage = 0.9
--att.Mult_RangeMin = 0.75

att.Hook_Compatible = function(wep)
    if wep:GetIsShotgun() then
        return false
    end
end
--lua/arccw/shared/attachments/uc_charm_urbancharm_decay.lua:
att.PrintName = "Urban Charm - Decay"
att.Description = "The icon of a Garry's Mod addon."

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "charm"

att.Free = true

att.Model = "models/weapons/arccw/atts/charmbase.mdl"

att.DroppedModel = "models/Items/BoxSRounds.mdl"

att.Charm = true
att.CharmModel = "models/weapons/arccw/atts/uc_urbancharm.mdl"
att.CharmAtt = "Charm"
att.CharmScale = Vector(0.5, 0.5, 0.5)
att.CharmOffset = Vector(0, -1.1, -0.2)
att.CharmAngle = Angle(20, 0, 80)
att.CharmSkin = 1

--lua/arccw/shared/attachments/uc_fg_civvy.lua:
att.PrintName = "Competition Internals"

att.Icon = Material("entities/att/arccw_uc_fg_civvy.png", "smooth mips")
att.Description = "High quality, precision manufactured aftermarket parts that improve weapon performance. Because of the parts' civilian origin, the fire control group doesn't support automatic fire."
att.Desc_Pros = {
}
att.Desc_Cons = {
    "uc.semionly"
}
att.Desc_Neutrals = {
}
att.Slot = "uc_fg"
att.AutoStats = true

att.Hook_Compatible = function(wep)
    if wep:GetIsShotgun() or wep:GetBuff_Override("Override_ManualAction", wep.ManualAction) then
        return false
    end
    for i, v in pairs(wep.Firemodes) do
        if !v then continue end
        if v.Mode and v.Override_ManualAction then
            return false
        end
    end
end

att.Override_Firemodes = {
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}
att.Override_Firemodes_Priority = 10

att.Mult_Range = 1.25
att.Mult_AccuracyMOA = 0.75
att.Mult_RPM = 0.75
att.Mult_MalfunctionMean = 1.5

att.AttachSound = "arccw_uc/common/gunsmith/internal_modification.ogg"
--lua/arccw/shared/attachments/uc_tac_laser_red.lua:
att.PrintName = "Rail-Mounted Laser Sight (Red)"
att.AbbrevName = "Red Laser Sight"
att.Icon = Material("entities/att/acwatt_uc_tac_flashlight2.png", "mips smooth")
att.Description = "Projects a laser in the direction of the target, assisting the user to line up shots without iron sights."
att.Desc_Pros = {
}
att.Desc_Cons = {
    "con.light"
}
att.Desc_Neutrals = {}
att.AutoStats = true

att.Slot = {"tac","tac_pistol"}
att.SortOrder = 29

att.Model = "models/weapons/arccw/atts/ud_flashlight_1.mdl"
att.ModelOffset = Vector(0,0,0)
att.OffsetAng = Angle(0,0,180)
att.ModelScale = Vector(1.2,1.2,1.2)
att.Laser = false
att.LaserStrength = 2 / 5
att.LaserBone = "light"

att.ColorOptionsTable = {Color(255, 0, 0, 150)}

att.ToggleStats = {
    {
        PrintName = "On",
        Laser = true,
        Mult_HipDispersion = 0.8,
        Mult_MoveDispersion = 0.8,
    },
    {
        PrintName = "Off",
        Laser = false,
    }
}
--lua/arccw/shared/attachments/uc_tp_bruiser.lua:
att.PrintName = "Bruiser"

att.Icon = Material("entities/att/arccw_uc_tp_bruiser.png", "smooth mips")
att.Description = "With the proper technique and upper body strength, you can more quickly and effectively use your weapon as a bludgeon."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_tp"

att.AutoStats = true
att.SortOrder = 19

att.Mult_MeleeDamage = 1.35
att.Mult_MeleeTime = .67

att.NotForNPCs = true
--addons/arccw_weapons/lua/arccw/shared/attachments/wepamo_digital.lua:
att.PrintName = "Digital Camo"
att.Icon = nil
att.Description = "Digital Camouflage"
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Slot = "rep_vibrocamo"
att.Free = true

att.ActivateElements = {"wepcamo-camo"}

att.SortOrder = 8 *-1
--addons/arccw_base_modified/lua/arccw/shared/sh_penetration.lua:
local mth      = math
local m_rand   = mth.Rand
local m_lerp   = Lerp

local function draw_debug()
    return (CLIENT or game.SinglePlayer()) and ArcCW.ConVars["dev_shootinfo"]:GetInt() >= 2
end

function ArcCW:GetRicochetChance(penleft, tr)
    if !ArcCW.ConVars["enable_ricochet"]:GetBool() then return 0 end
    local degree = tr.HitNormal:Dot((tr.StartPos - tr.HitPos):GetNormalized())

    local ricmult = ArcCW.PenTable[tr.MatType] or 1

    -- 0 at 1
    -- 100 at 0

    local c = Lerp(degree, math.min(penleft * ricmult * 2, 45), 0)

    -- c = c * ArcCW.ConVars["ricochet_mult"]:GetFloat()

    -- c = 100

    return math.Clamp(c, 0, 100)
end

function ArcCW:IsPenetrating(ptr, ptrent)
    if ptrent:IsWorld() then
        return ptr.Contents != CONTENTS_EMPTY
    elseif IsValid(ptrent) then

        local withinbounding = false
        local hboxset = ptrent:GetHitboxSet()
        local hitbone = ptrent:GetHitBoxBone(ptr.HitBox, hboxset)
        if hitbone then
            -- If we hit a hitbox, compare against that hitbox only
            local mins, maxs = ptrent:GetHitBoxBounds(ptr.HitBox, hboxset)
            local bonepos, boneang = ptrent:GetBonePosition(hitbone)
            mins = mins * 1.1
            maxs = maxs * 1.1
            local lpos = WorldToLocal(ptr.HitPos, ptr.HitNormal:Angle(), bonepos, boneang)

            withinbounding = lpos:WithinAABox(mins, maxs)
            if draw_debug() then
                debugoverlay.BoxAngles(bonepos, mins, maxs, boneang, 5, Color(255, 255, 255, 10))
            end
        elseif util.PointContents(ptr.HitPos) != CONTENTS_EMPTY then
            -- Otherwise default to rotated OBB
            local mins, maxs = ptrent:OBBMins(), ptrent:OBBMaxs()
            withinbounding = ptrent:WorldToLocal(ptr.HitPos):WithinAABox(mins, maxs)
            if draw_debug() then
                debugoverlay.BoxAngles(ptrent:GetPos(), mins, maxs, ptrent:GetAngles(), 5, Color(255, 255, 255, 10))
            end
        end
        if draw_debug() then
            debugoverlay.Cross(ptr.HitPos, withinbounding and 4 or 6, 5, withinbounding and Color(255, 255, 0) or Color(128, 255, 0), true)
        end


        return withinbounding
    end
    return false
end

function ArcCW:DoPenetration(tr, damage, bullet, penleft, physical, alreadypenned)
    local hitpos, startpos = tr.HitPos, tr.StartPos
    local dir    = (hitpos - startpos):GetNormalized()

    -- Added in e5adb54: "temporarily disable visual pen bullet until a solution is found"
    -- i don't remember the issue though
    -- if CLIENT then
    --     return
    -- end

    if tr.HitSky then return end

    if penleft <= 0 then return end

    alreadypenned = alreadypenned or {}

    local skip = false

    local trent = tr.Entity

    local penmult     = ArcCW.PenTable[tr.MatType] or 1
    local pentracelen = 4
    local curr_ent    = trent
    local startpen = penleft

    if !tr.HitWorld then penmult = penmult * 1.5 end

    if trent.mmRHAe then penmult = trent.mmRHAe end

    penmult = penmult * m_rand(0.9, 1.1) * m_rand(0.9, 1.1)

    local endpos = hitpos

    local td  = {}
    td.start  = endpos
    td.endpos = endpos + (dir * pentracelen)
    td.mask   = MASK_SHOT

    local ptr = util.TraceLine(td)

    local ptrent = ptr.Entity

    if ArcCW:GetRicochetChance(penleft, tr) > math.random(0, 100) then
        local degree = tr.HitNormal:Dot((tr.StartPos - tr.HitPos):GetNormalized())
        if degree == 0 or degree == 1 then return end
        sound.Play(ArcCW.RicochetSounds[math.random(#ArcCW.RicochetSounds)], tr.HitPos)
        if (tr.Normal:Length() == 0) then return end
        -- ACT3_ShootPBullet(tr.HitPos, ((2 * degree * tr.HitNormal) + tr.Normal) * (vel * math.Rand(0.25, 0.75)), owner, inflictor, bulletid, false, 1, penleft, dist)
        -- return

        dir = (2 * degree * tr.HitNormal) + tr.Normal
        ang = dir:Angle()
        ang = ang + (AngleRand() * (1 - degree) * 15 / 360)
        dir = ang:Forward()

        local d = math.Rand(0.25, 0.95)

        penleft = penleft * d

        skip = true
    end

    if !ArcCW.ConVars["enable_penetration"]:GetBool() then return end

    local factor = 1
    while !skip and penleft > 0 and ArcCW:IsPenetrating(ptr, ptrent) and ptr.Fraction < 1 and ptrent == curr_ent do
        penleft = penleft - (pentracelen * penmult) * factor

        -- Prevent extremely long penetrations (such as with glass)
        factor = factor * 1.05

        td.start  = endpos
        td.endpos = endpos + (dir * pentracelen)
        td.mask   = MASK_SHOT

        ptr = util.TraceLine(td)

        -- This is never called because curr_ent is never updated, genius
        -- Damage is handled in abullet.Callback anyways
        --[[]
        if ptrent != curr_ent then
            ptrent = ptr.Entity

            curr_ent = ptrent

            local ptrhp  = ptr.HitPos
            -- local dist   = (ptrhp - tr.StartPos):Length() * ArcCW.HUToM
            local pdelta = penleft / bullet.Penetration

            local dmg = DamageInfo()
            dmg:SetDamageType(bullet.DamageType)
            dmg:SetDamage(damage * pdelta)
            dmg:SetDamagePosition(ptrhp)

            if IsValid(ptrent) and !alreadypenned[ptrent:EntIndex()] then ptrent:TakeDamageInfo(dmg) end

            penmult = ArcCW.PenTable[ptr.MatType] or 1

            if !ptr.HitWorld then penmult = penmult * 1.5 end

            if ptrent.mmRHAe then penmult = ptrent.mmRHAe end

            penmult = penmult * m_rand(0.9, 1.1) * m_rand(0.9, 1.1)

            debugoverlay.Line(endpos, endpos + (dir * pentracelen), 10, Color(0, 0, 255), true)
        end
        ]]

        if draw_debug() then
            local pdeltap = penleft / bullet.Penetration
            local colorlr = m_lerp(pdeltap, 0, 255)

            debugoverlay.Line(endpos, endpos + (dir * pentracelen), 10, Color(255, colorlr, colorlr), true)
        end

        endpos = endpos + (dir * pentracelen)

        dir = dir + (VectorRand() * 0.025 * penmult)
    end

    if penleft > 0 then
        if (dir:Length() == 0) then return end

        -- Recover penetration lost from extra distance in the trace
        --penleft = penleft + ptr.Fraction * pentracelen / penmult

        if draw_debug() then
            debugoverlay.Text(endpos + Vector(0, 0, 2), "(" .. math.Round(penleft, 2) .. "mm)", 5)
        end

        local pdelta = penleft / bullet.Penetration

        local attacker = bullet.Attacker

        if !IsValid(attacker) then
            attacker = game.GetWorld()
        end

        if physical then
            if !ptr.HitWorld then
                alreadypenned[ptrent:EntIndex()] = true
            end

            local newbullet = {}
            newbullet.DamageMin = bullet.DamageMin or 1
            newbullet.DamageMax = bullet.DamageMax or 10
            newbullet.Range = bullet.Range or 100
            newbullet.DamageType = bullet.DamageType or DMG_BULLET
            newbullet.Penleft = penleft
            newbullet.Penetration = bullet.Penetration
            newbullet.Num = bullet.Num or 1
            newbullet.Pos = endpos
            local spd = bullet.Vel:Length()
            newbullet.Attacker = bullet.Attacker
            newbullet.Vel = dir * spd * (penleft / startpen)
            newbullet.Drag = bullet.Drag or 1
            newbullet.Travelled = bullet.Travelled + (endpos - hitpos):Length()
            newbullet.Damaged = alreadypenned
            newbullet.Profile = bullet.Profile or 1
            newbullet.Gravity = bullet.Gravity or 1
            newbullet.StartTime = bullet.StartTime or CurTime()
            newbullet.PhysBulletImpact = bullet.PhysBulletImpact or true
            newbullet.Weapon = bullet.Weapon

            if bit.band( util.PointContents( endpos ), CONTENTS_WATER ) == CONTENTS_WATER then
                newbullet.Underwater = true
            end

            table.insert(ArcCW.PhysBullets, newbullet)

            ArcCW:SendBullet(newbullet)
        else
            local abullet = {}
            abullet.Attacker = owner
            abullet.Dir      = dir
            abullet.Src      = endpos
            abullet.Spread   = Vector(0, 0, 0)
            abullet.Damage   = 0
            abullet.Num      = 1
            abullet.Force    = 0
            abullet.Distance = 33000
            abullet.Tracer   = 0
            --abullet.IgnoreEntity = ptr.Entity
            abullet.Callback = function(att, btr, dmg)
                local dist = bullet.Travelled * ArcCW.HUToM
                bullet.Travelled = bullet.Travelled + (btr.HitPos - endpos):Length()

                if alreadypenned[btr.Entity:EntIndex()] then
                    dmg:SetDamage(0)
                else
                    dmg:SetDamageType(bullet.DamageType)
                    dmg:SetDamage(bullet.Weapon:GetDamage(dist, true) * pdelta, true)
                end

                if draw_debug() then
                    local e = endpos + dir * (btr.HitPos - endpos):Length()
                    debugoverlay.Line(endpos, e, 10, Color(150, 150, 150), true)
                    debugoverlay.Cross(e, 3, 10, alreadypenned[btr.Entity:EntIndex()] and Color(0, 128, 255) or Color(255, 128, 0), true)
                    debugoverlay.Text(e, math.Round(penleft, 1) .. "mm", 10)
                end
                if (CLIENT or game.SinglePlayer()) and ArcCW.ConVars["dev_shootinfo"]:GetInt() >= 1 and IsValid(btr.Entity) and !alreadypenned[btr.Entity:EntIndex()] then
                    local str = string.format("%ddmg/%dm(%d%%)", math.floor(bullet.Weapon:GetDamage(dist)), dist, math.Round((1 - bullet.Weapon:GetRangeFraction(dist)) * 100))
                    debugoverlay.Text(btr.Entity:WorldSpaceCenter(), str, 5)
                end

                alreadypenned[btr.Entity:EntIndex()] = true

                ArcCW:DoPenetration(btr, damage, bullet, penleft, false, alreadypenned)

                -- if !game.SinglePlayer() and CLIENT then
                    local fx = EffectData()
                    fx:SetStart(tr.HitPos)
                    fx:SetOrigin(btr.HitPos)
                    util.Effect("arccw_ricochet", fx)
                -- end
            end

            attacker:FireBullets(abullet)
        end

        --[[
        local atk = bullet.Attacker

        local supbullet = {}
            supbullet.Src      = hitpos
            supbullet.Dir      = -dir
            supbullet.Damage   = 0
            supbullet.Distance = 8
            supbullet.Tracer   = 0
            supbullet.Force    = 0

            attacker:FireBullets(supbullet, true)
        ]]

    end
end

function ArcCW:BulletCallback(att, tr, dmg, bullet, phys)

    local wep = phys and bullet.Weapon or bullet
    local hitpos, hitnormal = tr.HitPos, tr.HitNormal
    local trent = tr.Entity

    local dist = (phys and bullet.Travelled or (hitpos - tr.StartPos):Length() ) * ArcCW.HUToM
    local pen  = IsValid(wep) and wep:GetBuff("Penetration") or bullet.Penleft

    if ArcCW.ConVars["dev_shootinfo"]:GetInt() >= 1 then
        debugoverlay.Cross(hitpos, 1, 5, SERVER and Color(255, 0, 0) or Color(0, 0, 255), true)
    end

    local randfactor = IsValid(wep) and wep:GetBuff("DamageRand") or 0
    local mul = 1
    if randfactor > 0 then
        mul = mul * math.Rand(1 - randfactor, 1 + randfactor)
    end

    local delta = !IsValid(wep) and math.Clamp(bullet.Travelled / (bullet.Range / ArcCW.HUToM), 0, 1) or wep:GetRangeFraction(dist)
    local calc_damage = (!IsValid(wep) and Lerp(delta, bullet.DamageMax, bullet.DamageMin) or wep:GetDamage(dist, true)) * mul
    local dmgtyp = !IsValid(wep)  and bullet.DamageType or wep:GetBuff_Override("Override_DamageType", wep.DamageType) or DMG_BULLET

    local hit   = {}
    hit.att     = att
    hit.tr      = tr
    hit.dmg     = dmg
    hit.range   = dist
    hit.damage  = calc_damage
    hit.dmgtype = dmgtyp
    hit.penleft = pen

    if IsValid(wep) then
        hit = wep:GetBuff_Hook("Hook_BulletHit", hit)

        if !hit then return end
    end

    if bullet.Damaged and bullet.Damaged[tr.Entity:EntIndex()] then
        dmg:SetDamage(0)
    else
        dmg:SetDamageType(hit.dmgtype)
        dmg:SetDamage(hit.damage)
    end

    local dmgtable
    if phys and IsValid(bullet.Weapon) then
        dmgtable = bullet.Weapon:GetBuff_Override("Override_BodyDamageMults", bullet.Weapon.BodyDamageMults)
    elseif IsValid(wep) then
        dmgtable = wep:GetBuff_Override("Override_BodyDamageMults", wep.BodyDamageMults)
    else
        dmgtable = bullet.BodyDamageMults
    end

    if dmgtable then
        local hg = tr.HitGroup
        local gam = ArcCW.LimbCompensation[engine.ActiveGamemode()] or ArcCW.LimbCompensation[1]
        if dmgtable[hg] then
            dmg:ScaleDamage(dmgtable[hg])

            -- cancelling gmod's stupid default values (but only if we have a multiplier)
            if ArcCW.ConVars["bodydamagemult_cancel"]:GetBool() and gam[hg] then dmg:ScaleDamage(gam[hg]) end
        end
    end

    if IsValid(att) and att:IsNPC() then
        dmg:ScaleDamage(wep:GetBuff_Mult("Mult_DamageNPC") or 1)
    end

    local effect = phys and bullet.ImpactEffect or (IsValid(wep) and wep:GetBuff_Override("Override_ImpactEffect", wep.ImpactEffect))
    local decal  = phys and bullet.ImpactDecal or (IsValid(wep) and wep:GetBuff_Override("Override_ImpactDecal", wep.ImpactDecal))

    -- Do our handling of damage types, if not ignored by the gun or some attachment
    if IsValid(wep) and !wep:GetBuff_Override("Override_DamageTypeHandled", wep.DamageTypeHandled) then
        local _, maxrng = wep:GetMinMaxRange()
        -- ignite target
        if dmg:IsDamageType(DMG_BURN) then
            if maxrng <= hit.range then
                dmg:SetDamageType(DMG_BULLET)
            else
                effect = "arccw_incendiaryround"
                decal  = "FadingScorch"

                if SERVER then
                    if vFireInstalled then
                        CreateVFire(trent, hitpos, hitnormal, hit.damage * 0.02)
                    else
                        trent:Ignite(1, 0)
                    end
                end
            end
        end
        -- explode target
        if dmg:IsDamageType(DMG_BLAST) then
            if dmg:GetDamage() >= 200 then
                effect = "Explosion"
                decal  = "Scorch"
            else
                effect = "arccw_incendiaryround"
                decal  = "FadingScorch"
            end
            dmg:ScaleDamage(0.5) -- half applied as explosion and half done to hit target
            util.BlastDamageInfo(dmg, tr.HitPos, math.Clamp(dmg:GetDamage(), 48, 256))
            dmg:SetDamageType(dmg:GetDamageType() - DMG_BLAST)
        end
        -- damage helicopters
        if dmg:IsDamageType(DMG_BULLET) and !dmg:IsDamageType(DMG_AIRBOAT)
                and IsValid(hit.tr.Entity) and hit.tr.Entity:GetClass() == "npc_helicopter" then
            dmg:SetDamageType(dmg:GetDamageType() + DMG_AIRBOAT)
            dmg:ScaleDamage(0.1) -- coostimizable?
        elseif dmg:GetDamageType() != DMG_BLAST and IsValid(hit.tr.Entity) and hit.tr.Entity:GetClass() == "npc_combinegunship" then
            dmg:SetDamageType(DMG_BLAST)
            dmg:ScaleDamage(0.05)
            -- there is a damage threshold of 50 for damaging gunships
            if dmg:GetDamage() < 50 and dmg:GetDamage() / 200 >= math.random() then
                dmg:SetDamage(50)
            end
        end

        -- pure DMG_BUCKSHOT do not create blood decals, somehow
        if dmg:GetDamageType() == DMG_BUCKSHOT then
            dmg:SetDamageType(dmg:GetDamageType() + DMG_BULLET)
        end
    end

    if SERVER and IsValid(wep) then wep:TryBustDoor(trent, dmg) end

    -- INCONSISTENCY: For physbullet, the entire bullet is copied; hitscan bullets reset some attributes in SWEP:DoPenetration (most notably damage)
    -- For now, we just reset some changes as a temporary workaround
    if !IsValid(wep) then
        bullet.Damage = calc_damage
        bullet.DamageType = dmgtyp
        ArcCW:DoPenetration(tr, hit.damage, bullet, bullet.Penleft, true, bullet.Damaged)
    else
        wep:DoPenetration(tr, hit.penleft, { [trent:EntIndex()] = true })
    end

    if effect then
        local ed = EffectData()
        ed:SetOrigin(hitpos)
        ed:SetNormal(hitnormal)
        util.Effect(effect, ed)
    end

    if decal then
        util.Decal(decal, tr.StartPos, hitpos - (hitnormal * 16), wep:GetOwner())
    end

    if (CLIENT or game.SinglePlayer()) and (!phys or SERVER) and ArcCW.ConVars["dev_shootinfo"]:GetInt() >= 1 then
        local str = string.format("%ddmg/%dm(%d%%)", math.floor(dmg:GetDamage()), dist, math.Round((1 - delta) * 100))
        debugoverlay.Text(hitpos, str, 10)
        print(str)
    end

    if IsValid(wep) then
        wep:GetBuff_Hook("Hook_PostBulletHit", hit)
    end
end
--addons/arccw_base_modified/lua/arccw/client/cl_binds.lua:
ArcCW.KEY_FIREMODE        = "+zoom"
ArcCW.KEY_FIREMODE_ALT    = "arccw_firemode"
ArcCW.KEY_ZOOMIN          = "invnext"
ArcCW.KEY_ZOOMIN_ALT      = "arccw_zoom_in"
ArcCW.KEY_ZOOMOUT         = "invprev"
ArcCW.KEY_ZOOMOUT_ALT     = "arccw_zoom_out"
ArcCW.KEY_TOGGLEINV       = "+menu_context"
ArcCW.KEY_TOGGLEINV_ALT   = "arccw_toggle_inv"
ArcCW.KEY_SWITCHSCOPE     = "+use"
ArcCW.KEY_SWITCHSCOPE_ALT = "arccw_switch_scope"
ArcCW.KEY_TOGGLEUBGL      = "arccw_toggle_ubgl"
ArcCW.KEY_TOGGLEATT       = "arccw_toggle_att"
ArcCW.KEY_MELEE           = "arccw_melee"

ArcCW.BindToEffect = {
    [ArcCW.KEY_FIREMODE]    = "firemode",
    [ArcCW.KEY_ZOOMIN]      = "zoomin",
    [ArcCW.KEY_ZOOMOUT]     = "zoomout",
    [ArcCW.KEY_TOGGLEINV]   = "inv",
    [ArcCW.KEY_SWITCHSCOPE] = "switchscope_dtap",
}

ArcCW.BindToEffect_Unique = {
    [ArcCW.KEY_TOGGLEUBGL]      = "ubgl",
    [ArcCW.KEY_SWITCHSCOPE_ALT] = "switchscope",
    [ArcCW.KEY_FIREMODE_ALT]    = "firemode",
    [ArcCW.KEY_ZOOMIN_ALT]      = "zoomin",
    [ArcCW.KEY_ZOOMOUT_ALT]     = "zoomout",
    [ArcCW.KEY_TOGGLEINV_ALT]   = "inv",
    [ArcCW.KEY_TOGGLEATT]       = "toggleatt",
    [ArcCW.KEY_MELEE]           = "melee",
}

local lastpressZ = 0
local lastpressE = 0

function ArcCW:GetBind(bind)
    local button = input.LookupBinding(bind)

    return button == "no value" and bind .. " unbound" or button
end

local function ArcCW_TranslateBindToEffect(bind)
    local alt = ArcCW.ConVars["altbindsonly"]:GetBool()
    if alt then
        return ArcCW.BindToEffect_Unique[bind], true
    else
        return ArcCW.BindToEffect_Unique[bind] or ArcCW.BindToEffect[bind] or bind, ArcCW.BindToEffect_Unique[bind] != nil
    end
end

local function SendNet(string, bool)
    net.Start(string)
    if bool != nil then net.WriteBool(bool) end
    net.SendToServer()
end

local function DoUbgl(wep)
    if wep:GetInUBGL() then
        SendNet("arccw_ubgl", false)

        wep:DeselectUBGL()
    else
        SendNet("arccw_ubgl", true)

        wep:SelectUBGL()
    end
end

local debounce = 0
local function ToggleAtts(wep)
    if debounce > CurTime() then return end -- ugly hack for double trigger
    debounce = CurTime() + 0.15
    local sounds = {}
    for k, v in pairs(wep.Attachments) do
        local atttbl = v.Installed and ArcCW.AttachmentTable[v.Installed]
        if atttbl and atttbl.ToggleStats and !v.ToggleLock then
            if atttbl.ToggleSound then sounds[atttbl.ToggleSound] = true
            else sounds["weapons/arccw/firemode.wav"] = true end
            wep:ToggleSlot(k, nil, true)
        end
    end
    for snd, _ in pairs(sounds) do
        surface.PlaySound(snd)
    end
end

local function ArcCW_PlayerBindPress(ply, bind, pressed)
    if !(ply:IsValid() and pressed) then return end

    local wep = ply:GetActiveWeapon()

    if !wep.ArcCW then return end

    local block = false

    if GetConVar("arccw_nohl2flash"):GetBool() and bind == "impulse 100" then
        ToggleAtts(wep)

        if ply:FlashlightIsOn() then return false end -- if hl2 flahslight is on we will turn it off as expected

        return true -- we dont want hl2 flashlight
     end

    local alt
    bind, alt = ArcCW_TranslateBindToEffect(bind)

    if bind == "firemode" and (alt or true) and !ply:KeyDown(IN_USE) then
		SendNet("arccw_firemode")
		wep:ChangeFiremode()

        block = true
    elseif bind == "inv" and !ply:KeyDown(IN_USE) and ArcCW.ConVars["enable_customization"]:GetInt() > -1 then

        local state = wep:GetState() != ArcCW.STATE_CUSTOMIZE

        SendNet("arccw_togglecustomize", state)

        wep:ToggleCustomizeHUD(state)

        block = true
    elseif bind == "ubgl" then
        DoUbgl(wep)
    elseif bind == "toggleatt" then
        ToggleAtts(wep)
    end

    if wep:GetState() == ArcCW.STATE_SIGHTS then
        if bind == "zoomin" then
            wep:Scroll(1)
            block = true
        elseif bind == "zoomout" then
            wep:Scroll(-1)
            block = true
        elseif bind == "switchscope_dtap" then
            if lastpressE >= CurTime() - 0.25 then
                wep:SwitchActiveSights()
                lastpressE = 0
            else
                lastpressE = CurTime()
            end
        elseif bind == "switchscope" then
            wep:SwitchActiveSights()
            block = true
        end
    end

    if bind == "melee" and wep:GetState() != ArcCW.STATE_SIGHTS then
        wep:Bash()
    end

    if block then return true end
end

hook.Add("PlayerBindPress", "ArcCW_PlayerBindPress", ArcCW_PlayerBindPress)

-- Actually register the damned things so they can be bound
for k, v in pairs(ArcCW.BindToEffect_Unique) do
    concommand.Add(k, function(ply) ArcCW_PlayerBindPress(ply, k, true) end, nil, v, 0)
end

-- ArcCW.CaptureKeys = {
--     KEY_G
-- }
-- ArcCW.LastInputs = {}
-- ArcCW.Inputs = {}

-- local function ArcCW_CustomInputs()
--     local inputs = {}

--     for _, i in pairs(ArcCW.CaptureKeys) do
--         -- local conv = GetConVar(i)

--         -- if !conv then continue end
--         -- if !IsValid(conv) then continue end

--         local kc = i

--         inputs[kc] = input.IsKeyDown(kc)
--     end

--     ArcCW.LastInputs = ArcCW.Inputs
--     ArcCW.Inputs = inputs

--     if ArcCW:KeyPressed(KEY_G) then
--         ArcCW:QuickNade("frag")
--     end
-- end

-- hook.Add("Think", "ArcCW_CustomInputs", ArcCW_CustomInputs)

-- function ArcCW:KeyPressed(key)
--     if !ArcCW.LastInputs[key] and ArcCW.Inputs[key] then
--         return true
--     end

--     return false
-- end
--addons/auralvsradar/lua/aura_lvs_radar/aura_lvs_radar_util.lua:
aura_lfs_fight_display_ent_list = aura_lfs_fight_display_ent_list or {}
-- Set up local clientside variables
aura_lfs_fight_display_ent_list = ents.FindByClass("aura_lfs_fight_display_panel")
aura_lfs_fight_display_ship_list = aura_lfs_fight_display_ship_list or {}
aura_lvs_radar_entity_models = aura_lvs_radar_entity_models or {}
aura_lfs_fight_displaybaseWidth = 850
aura_lfs_fight_displaybaseHeight = 850
aura_lfs_fight_displaymapScale = aura_lfs_fight_displaybaseWidth / aura_lfs_fight_displaybaseHeight
aura_lfs_fight_displaymapAspect = aura_lfs_fight_displaymapAspect or 0

function AuraRadarGenerateMapScalar()
	local world = game.GetWorld()
	if (world) then
		-- Used for scaling radar models based on the map size
		mapX = world:GetModelBounds().x / aura_lfs_fight_displaymapScale
		mapY = world:GetModelBounds().y / aura_lfs_fight_displaymapScale
		mapZ = world:GetModelBounds().z / aura_lfs_fight_displaymapScale
		aura_lfs_fight_displaymapAspect = math.abs((mapX * mapY) / (aura_lfs_fight_displaybaseWidth * aura_lfs_fight_displaybaseHeight))
		aura_lfs_fight_displaymult = aura_lfs_fight_displaymapAspect + 30
	end
end

-- Check if the entity should be rendered on a specific table (currently supports LVS, LFS, SWVehicles, Players, and NPCs)
function AuraRadarShouldDrawEntity(table_ent, ent)
	return ((table_ent:GetShowPlayers() and ent:IsPlayer()) or (table_ent:GetShowNPCs() and ent:IsNPC()) or (table_ent:GetShowShips() and (ent.LFS or ent.LVS or ent.IsSWVehicle)))
end

-- check if an entity should be added to the general entity logged table
function AuraRadarShouldAddEntityToTable(ent)
	return (ent:IsPlayer() or ent:IsNPC() or ent.LFS or ent.LVS)
end

-- Remove all radar models for all tables
function Aura_Radar_CleanUpAllShipEnts()
	for i=1,#aura_lvs_radar_entity_models do
		local sp = aura_lvs_radar_entity_models[i]
		SafeRemoveEntityDelayed(sp,0)
	end
	for k,v in ipairs(aura_lfs_fight_display_ent_list) do
		v.aura_radar_loaded_entities = {}
	end
	aura_lfs_fight_display_ship_list = {}
end

function Aura_Radar_Remove_Model(table_ent, model)
	if (IsValid(table_ent) and model) then
		for k,v in pairs(table_ent.aura_radar_loaded_entities) do
			if (v == model.original_ent) then
				table.remove(table_ent.aura_radar_loaded_entities,k)
			end
		end

		for k,v in pairs(table_ent.aura_radar_models) do
			if (!IsValid(v) or !IsValid(v.original_ent)) then
				table.remove(table_ent.aura_radar_models,k)
			end
		end
	end
	SafeRemoveEntityDelayed(model,0)
end
--addons/sh_lounge_chatbox/lua/chatbox_config.lua:
/**
* General configuration
**/

-- Title of the chatbox.
-- Here are special titles:
-- %hostname% : Shows the server's name
-- %players% : Shows the player count on the server
-- %uptime% : Uptime of the server
LOUNGE_CHAT.ChatTitle = ""

-- Show the player's avatar when sending a message
LOUNGE_CHAT.ShowPlayerAvatar = true

-- Message display style
-- 0: Default
-- 1: Discord-like (enable ShowPlayerAvatar for better effect)
LOUNGE_CHAT.MessageStyle = 1

-- Name to display when the console sends a message
-- Parsers are allowed.
LOUNGE_CHAT.ConsoleName = "Console"

-- Whether to use Workshop or the FastDl for the custom content used by the add-on
LOUNGE_CHAT.UseWorkshop = true

-- Prevent players from using parsers in their name?
LOUNGE_CHAT.DisallowParsersInName = false

/**
* Profanity filter
**/

-- Which usergroups are allowed to bypass the profanity filter?
LOUNGE_CHAT.ProfanityBypass = {
	["admin"] = true,
	["superadmin"] = true,
}

-- Words filtered out by the profanity filter. Case insensitive.
-- Do keep in mind that this profanity filter iS CLIENTSIDE. It will not kick out players for saying banned words.
-- Use a dedicated script for that.
-- You can also use lua patterns to have better detection: http://lua-users.org/wiki/PatternsTutorial
LOUNGE_CHAT.ProfanityFilter = {
	"EGM",
}

-- Character to use when censoring banned words.
-- Example: shit -> ****
LOUNGE_CHAT.CensorCharacter = "*"

/**
* Advanced configuration
* Only modify these if you know what you're doing.
**/

-- How the <timestamp=...> markup should be formatted.
-- See https://msdn.microsoft.com/en-us/library/fe06s4ak.aspx for a list of available mappings
LOUNGE_CHAT.TimestampFormat = "%T"

-- Where downloaded images should be in GMod's data folder.
LOUNGE_CHAT.ImageDownloadFolder = "lounge_chat_downloads"

-- Whether to use UTF-8 mode for character wrapping and parsing.
-- You can set this to false if your server's main language is Roman script only (English, etc)
LOUNGE_CHAT.UseUTF8 = true

-- Maximum messages allowed in the chatbox before deletion of the oldest messages.
LOUNGE_CHAT.MaxMessages = 1000

-- Disable having to wrap an emoticon's name in : (like :thumb_up: becomes thumb_up)
-- This option has not been fully tested in all the possible cases so some text might look bad, or might straight up crash
-- the client. Change at your own risk.
LOUNGE_CHAT.EmoticonsNoColon = false

/**
* Style configuration
**/

-- Font to use for normal text throughout the chatbox.
LOUNGE_CHAT.FontName = "Circular Std Medium"

-- Font to use for bold text throughout the chatbox.
LOUNGE_CHAT.FontNameBold = "Circular Std Bold"

-- Color sheet.
LOUNGE_CHAT.Style = {
	header = Color(0,0,0,200),
	bg = Color(0,0,0, 200),
	inbg = Color(0,0,0, 200),

	close_hover = Color(231, 76, 60),
	hover = Color(255, 255, 255, 10),
	hover2 = Color(255, 255, 255, 5),

	text = Color(255, 255, 255),
	text_down = Color(255, 255, 255),

	url = Color(52, 152, 219),
	url_hover = Color(62, 206, 255),
	timestamp = Color(255, 255, 255),

	menu = Color(0,0,0,200),
}

LOUNGE_CHAT.Anims = {
	FadeInTime = 0.15,
	FadeOutTime = 0.07,
	TextFadeOutTime = 1,
}

-- Size of the <glow> parser.
LOUNGE_CHAT.BlurSize = 2

/**
* Language configuration
**/

-- Various strings used throughout the chatbox. Change them to your language here.
-- %s and %d are special strings replaced with relevant info, keep them in the string!

-- FRENCH Translation: https://pastebin.com/pnQfQ82k

LOUNGE_CHAT.Language = {
	players_online = "Players online",
	server_uptime = "Server uptime",
	click_to_load_image = "Klicke hier, um das Bild zu laden",
	failed_to_load_image = "Bild konnte nicht geladen werden...",
	click_here_to_view_x_profile = "Klicke hier, um %s's Profil anzusehen",

	chat_options = "Chat Optionen",
	clear_chat = "Chat leeren",
	reset_position = "Position zurcksetzen",
	reset_size = "Gre zurcksetzen",

	chat_parsers = "Chat parsers",
	usage = "Nutzung",
	example = "Beispiel",

	send = "Senden",
	copy_message = "Nachricht kopieren",
	copy_url = "URL kopieren",

	-- options
	general = "General",
	chat_x = "X position",
	chat_y = "Y position",
	chat_width = "Chatbox width",
	chat_height = "Chatbox height",
	time_before_messages_hide = "Time before messages fade out",
	show_timestamps = "Display timestamps",
	clear_downloaded_images = "Clear downloaded images folder (%s)",
	dont_scroll_chat_while_open = "Do not automatically scroll chat down while open",

	display = "Display",
	hide_images = "Hide images",
	hide_avatars = "Hide avatars",
	use_rounded_avatars = "Use circular avatars (disable if FPS is low)",
	disable_flashes = "Disable flashes",
	no_url_parsing = "Do not parse URLs",
	autoload_external_images = "Auto-load external images",
	hide_options_button = "Hide options button",
}
--addons/aoc_fire_system/lua/ch_fire_system/shared/fire_metas.lua:
local PMETA = FindMetaTable( "Player" )
local EMETA = FindMetaTable( "Entity" )

function PMETA:IsFireFighter()
	return true
end

function EMETA:IsFireTruck()
	return table.HasValue( CH_FireSystem.Config.FiretruckModels, self:GetModel() )
end
--addons/gm_express_binding/lua/gm_express_bindings/pac3/cl_init.lua:
local table_Merge = table.Merge
local table_insert = table.insert

return function( Module )
    function Module.Enable()
        local pace_IsPartSendable = pace.IsPartSendable
        local pace_CreateWearFilter = pace.CreateWearFilter

        Module.ogWearOnServer = Module.ogWearOnServer or pace.WearOnServer
        Module.ogSendPartToServer = Module.ogSendPartToServer or pace.SendPartToServer

        pace.WearOnServer = function( filter )
            local allowed, reason = pac.CallHook( "CanWearParts", pac.LocalPlayer )
            if allowed == false then
                pac.Message( reason or "the server doesn't want you to wear parts for some reason" )
                return false
            end

            local parts = {}

            pace.SendPartToServer = function( part, extra )
                if not pace_IsPartSendable( part ) then
                    return false
                end

                local data = { part = part:ToTable() }
                if extra then
                    table_Merge( data, extra )
                end

                data.owner = part:GetPlayerOwner()
                data.wear_filter = pace_CreateWearFilter()

                table_insert( parts, data )
            end

            -- This will put all of the parts into the parts table
            Module.ogWearOnServer( filter )
            pace.SendPartToServer = Module.ogSendPartToServer

            if #parts == 0 then return end

            express.Send( "pac_submit", parts )
        end

        express.ReceivePreDl( "pac_submit_multi", function()
            if not pac.IsEnabled() then return false end
        end )

        express.Receive( "pac_submit_multi", function( parts )
            local partCount = #parts

            for i = 1, partCount do
                local data = parts[i]
                local owner = data.owner
                local ownerType = type( owner )

                if ownerType ~= "Player" or not owner:IsValid() then
                    pac.Message( "received message from server but owner is not valid!? typeof " .. ownerType .. " || ", owner )
                    return
                end

                if pac.IsPacOnUseOnly() and owner ~= pac.LocalPlayer then
                    pace.HandleOnUseReceivedData( data )
                else
                    pace.HandleReceiveData( data, true )
                end
            end
        end )
    end

    function Module.Disable()
        pace.WearOnServer = Module.ogWearOnServer
        pace.SendPartToServer = Module.ogSendPartToServer
        express.ClearReceiver( "pac_submit_multi" )
    end
end

--addons/aocrp_map/lua/gmaps/cl_dgmapsicons.lua:
--[[   _                                
    ( )                               
   _| |   __   _ __   ___ ___     _ _ 
 /'_` | /'__`\( '__)/' _ ` _ `\ /'_` )
( (_| |(  ___/| |   | ( ) ( ) |( (_| |
`\__,_)`\____)(_)   (_) (_) (_)`\__,_) 

	DIconBrowser
	
--]]

local local_IconList = nil

local PANEL = {}

AccessorFunc( PANEL, "m_strSelectedIcon", 		"SelectedIcon" )
AccessorFunc( PANEL, "m_bManual", 				"Manual" )
AccessorFunc( PANEL, "m_tColor", 				"Color" )
AccessorFunc( PANEL, "m_iIconSize", 			"IconSize", FORCE_NUMBER )
AccessorFunc( PANEL, "m_tIcons", 				"Icons" )

function PANEL:SelectIcon( name )

	self.m_strSelectedIcon = name
	
	for k, v in pairs( self.IconLayout:GetChildren() ) do
	
		if ( v.img == name ) then
			self.m_pSelectedIcon = v 
			break
		end
	
	end

end

function PANEL:ScrollToSelected()

	if ( !IsValid(self.m_pSelectedIcon) ) then return end
	
	self:ScrollToChild( self.m_pSelectedIcon )

end

--[[---------------------------------------------------------
   Name: Init
-----------------------------------------------------------]]
function PANEL:Init()
	
	self.m_strSelectedIcon = ""
	
	self:GetCanvas():DockPadding(2,2,0,0)
	self.IconLayout = self:GetCanvas():Add( "DIconLayout" )
	self.IconLayout:SetSpaceX( 2 )
	self.IconLayout:SetSpaceY( 5 )
	self.IconLayout:SetBorder( 5 )
	self.IconLayout:Dock( TOP )
	
	self:SetPaintBackground( true )
	
end

function PANEL:Fill()
	
	local size = self:GetIconSize()
	
	self.Filled = true
	if ( self.m_bManual ) then return end
	
	local_IconList = self:GetIcons()
	-- if ( !local_IconList ) then
		 -- local_IconList = file.Find( gmaps.Config.POIIconPath.."/*.png", "GAME" )
	-- end
	
	for k, v in SortedPairs( local_IconList ) do
					
		-- timer.Simple( k * 0.001, function()
		
				if ( !IsValid( self ) ) then return end
				if ( !IsValid( self.IconLayout ) ) then return end
		
				local btn = self.IconLayout:Add( "DImageButton" )
				btn.FilterText = string.lower( v )
				btn:SetMaterial( Material(v, "unlitgeneric smooth" ) )
				btn:SetSize( size, size )
				btn:SetPos( -size, -size )
				btn:SetColor(self:GetColor())
				btn.img = v
				btn:SetStretchToFit( true )
				
				btn.DoClick = function()
				
					self.m_pSelectedIcon = btn
					self.m_strSelectedIcon = btn.img
					self:OnChangeInternal(btn.img)
				
				end
				
				btn.Paint = function( btn, w, h )
				
					if ( self.m_pSelectedIcon != btn ) then return end
					
					derma.SkinHook( "Paint", "Selection", btn, w, h )
				
				end
				
				if ( !self.m_pSelectedIcon || self.m_strSelectedIcon == btn:GetImage() ) then
					self.m_pSelectedIcon = btn
					--self:ScrollToChild( btn )
				end
				
				self.IconLayout:Layout()
			
			-- end )
		
	end

end

function PANEL:FilterByText( text )

	local text = string.lower( text )
	
	for k, v in pairs( self.IconLayout:GetChildren() ) do
	
		v:SetVisible( v.FilterText:find( text ) != nil )
	
	end
	
	self.IconLayout:Layout()

end

function PANEL:Paint( w, h )

	if ( !self.Filled ) then self:Fill() end
	
	derma.SkinHook( "Paint", "Tree", self, w, h )

end

function PANEL:OnChangeInternal(new)

	self:OnChange(new)

end

function PANEL:Clear()
	self.IconLayout:Clear()
end

function PANEL:Add( name )
	return self.IconLayout:Add( name )
end


function PANEL:OnChange()

end

--[[---------------------------------------------------------
   Name: GenerateExample
-----------------------------------------------------------]]
function PANEL:GenerateExample( ClassName, PropertySheet, Width, Height )

	local ctrl = vgui.Create( ClassName )
		ctrl:SetSize( 300, 300 )
		ctrl:SelectIcon( "icon16/heart.png" )
		
	PropertySheet:AddSheet( ClassName, ctrl, nil, true, true )

end

derma.DefineControl( "DGMapsIcons", "", PANEL, "DScrollPanel" )
--addons/billy_gas/lua/gmodadminsuite_config.lua:
--[[

	   ______                    _____       __          _      _____       _ __     
	  / ____/___ ___  ____  ____/ /   | ____/ /___ ___  (_)___ / ___/__  __(_) /____ 
	 / / __/ __ `__ \/ __ \/ __  / /| |/ __  / __ `__ \/ / __ \\__ \/ / / / / __/ _ \
	/ /_/ / / / / / / /_/ / /_/ / ___ / /_/ / / / / / / / / / /__/ / /_/ / / /_/  __/
	\____/_/ /_/ /_/\____/\__,_/_/  |_\__,_/_/ /_/ /_/_/_/ /_/____/\__,_/_/\__/\___/ 
	                                                                                 
	Welcome to the main config.
	You may have noticed that it's a bit small - but no worries; this is because most configuration
	for GmodAdminSuite is in the menu itself.

]]

-- What chat command should open the GmodAdminSuite main menu?
GAS.Config.ChatCommand = "!gas"

-- In seconds, how long until an inactive player is marked AFK?
GAS.Config.AFKTime = 300

-- Should GmodAdminSuite content (sounds, materials, etc.) be downloaded by users through the Workshop when they join the server?
GAS.Config.WorkshopDL = true

-- Should GmodAdminSuite content be downloaded by users directly from the server when they join? (this is unnecessary if you are using WorkshopDL)
GAS.Config.ServerDL = false

-- Do not delete the following line; your config will break.
return true

--addons/billy_gas/lua/gmodadminsuite/lang/english.lua:
return {
	Name = "English",
	Flag = "flags16/gb.png",
	Phrases = function() return {

		open_menu                 = "Open Menu",
		menu_nopermission         = "Sorry, but you do not have permission to access the GmodAdminSuite menu.",
		menu_unknown_module       = "Sorry, but a module with that name is not installed or does not exist.",
		menu_disabled_module      = "Sorry, but that module is disabled.",
		menu_module_nopermission  = "Sorry, you don't have permission to access this module.",
		open_gas                  = "Open GmodAdminSuite",
		module_shortcut           = "Module Shortcut",
		module_reset_data		  = "Reset Module Position/Size",
		module_shortcut_info      = [[You can quickly access this GmodAdminSuite module through console and chat commands.

		To access the module through your console, type: %s
		To access the module through chat, type: %s

		Additionally, you can bind a key on your keyboard to a specific module.
		To do this, in your console, type: %s

		Make sure to replace KEY with a key on your keyboard of your choice.
		%s]],
		close                     = "Close",
		wiki                      = "Wiki",
		licensee                  = "Licensee",
		support                   = "Support",
		module_shop               = "Module Shop",
		welcome                   = "Welcome",
		operator                  = "Operator",
		script_page               = "Script Page",
		wiki                      = "Wiki",
		no_modules_available      = "No modules available!",
		no_modules_available_info = [[Sorry, but there aren't any GmodAdminSuite modules available for you to use.
		You may have insufficient permissions to use any, or none are enabled.]],
		custom_ellipsis           = "Custom...",
		usergroup_ellipsis        = "Usergroup...",
		steamid_ellipsis          = "SteamID...",
		enter_steamid_ellipsis    = "Enter SteamID...",
		by_distance               = "By Distance",
		by_usergroup              = "By Usergroup",
		by_team                   = "By Team",
		by_name                   = "By Name",
		right_click_to_focus      = "Right click to focus",
		unknown                   = "Unknown",
		utilities                 = "Utilities",
		player_management         = "Player Management",
		administration            = "Administration",
		s_second                  = "1 second",
		s_seconds                 = "%d seconds",
		s_minute                  = "1 minute",
		s_minutes                 = "%d minutes",
		s_hour                    = "1 hour",
		s_hours                   = "%d hours",
		second_ago                = "1 second ago",
		seconds_ago               = "%d seconds ago",
		minute_ago                = "1 minute ago",
		minutes_ago               = "%d minutes ago",
		hour_ago                  = "1 hour ago",
		hours_ago                 = "%d hours ago",
		just_now                  = "Just now",
		click_to_focus            = "Click to focus",
		right_click_to_focus      = "Right click to focus",
		add_steamid               = "Custom SteamID",
		copied                    = "Copied!",
		settings                  = "Settings",
		add_steamid_help          = [[Enter a SteamID or SteamID64. Examples:
		SteamID: %s
		SteamID64: %s]],

		setting_default_module = "Default Module",
		setting_default_module_tip = "What module should be opened when the GmodAdminSuite main menu is opened?",
		none = "None",
		general = "General",
		localization = "Localization",
		setting_menu_voicechat = "Allow speaking (voice chat)\nwhen GAS menus are open",
		setting_menu_voicechat_tip = "GmodAdminSuite's menus do not block your voice chat key. If this option is on, just press your voice chat key to talk whilst in a menu.",
		use_gas_language = "Use GmodAdminSuite language",
		default_format = "Default Format",
		short_date_format = "Short Date Format",
		long_date_format = "Long Date Format",
		short_date_format_tip = "Date format used for shorter date formats\n\nThe default format automatically matches the date format of your region (North America, Europe, etc.)",
		long_date_format_tip = "Date format used for longer date formats",
		permissions = "Permissions",
		module_enable_switch_tip = "Changes to this will only apply after a server restart/map change",
		enabled = "Enabled",
		modules = "Modules",
		permissions_help = [[GmodAdminSuite utilizes an open-source permissions library called OpenPermissions, which was developed by Billy for GAS. It provides optimized permissions handling for advanced systems running on any sized server.
		
		OpenPermissions is where you will control what groups can access what modules, and what they can do with those modules.
		It can be opened at any time by typing "!openpermissions" in chat or "openpermissions" in console.

		For help & info, click the "Help" tab in the OpenPermissions menu.]],
		website = "Website",
		fun = "Fun",

		bvgui_copied               = "Copied!",
		bvgui_open_context_menu    = "Open Context Menu",
		bvgui_open_steam_profile   = "Open Steam Profile",
		bvgui_right_click_to_focus = "Right click to focus",
		bvgui_click_to_focus       = "Click to focus",
		bvgui_unknown              = "Unknown",
		bvgui_no_data              = "No data",
		bvgui_no_results_found     = "No results found",
		bvgui_done                 = "Done",
		bvgui_enter_text_ellipsis  = "Enter text...",
		bvgui_loading_ellipsis     = "Loading...",
		bvgui_pin_tip              = "Press ESC to click the menu again",
		bvgui_click_to_render      = "Click to render",
		bvgui_teleport             = "Teleport",
		bvgui_inspecting           = "Inspecting",
		bvgui_inspect              = "Inspect",
		bvgui_screenshot           = "Screenshot",
		bvgui_ok                   = "OK",
		bvgui_screenshot_saved     = "Screenshot Saved",
		bvgui_screenshot_saved_to  = "The screenshot has been saved to %s on your computer",
		bvgui_reset                = "Reset",
		bvgui_right_click_to_stop_rendering = "Right click to stop rendering",

		settings_player_popup_close 		= "Close Player Popups when\nthey lose focus",
		settings_player_popup_close_tip	 	= "Should Player Popups close when you click on a different menu?"
} end }
--addons/billy_gas/lua/gmodadminsuite/modules/secondaryusergroups/_gas_info.lua:
return {
	DefaultEnabled = true,
	Name = "Secondary Usergroups",
	Category = GAS.MODULE_CATEGORY_PLAYER_MANAGEMENT,
	Wiki = "https://gmodsto.re/gmodadminsuite-secondaryusergroups-wiki",
	Icon = "icon16/group.png",
}
--addons/tools/lua/autorun/init_improvedstacker.lua:
if ( SERVER ) then
	
	-- needed for custom vgui controls in the menu
	AddCSLuaFile( "vgui/stackercontrolpresets.lua" )
	AddCSLuaFile( "vgui/stackerdnumslider.lua" )
	AddCSLuaFile( "vgui/stackerpreseteditor.lua" )
	
	-- convenience modules
	AddCSLuaFile( "improvedstacker/improvedstacker.lua" )
	AddCSLuaFile( "improvedstacker/localify.lua" )
	
else

	-- needed for custom vgui controls in the menu
	include( "vgui/stackercontrolpresets.lua" )
	include( "vgui/stackerdnumslider.lua" )
	include( "vgui/stackerpreseteditor.lua" )

end
--addons/tools/lua/vgui/stackerpreseteditor.lua:
--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

local PANEL = {}

--[[--------------------------------------------------------------------------
-- 	Localized Functions & Variables
--------------------------------------------------------------------------]]--

local vgui = vgui
local pairs = pairs
local AccessorFunc = AccessorFunc
local GetConVarString = GetConVarString

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

AccessorFunc( PANEL, "m_ConCommands", "ConCommands" )

--[[--------------------------------------------------------------------------
--
--	PANEL:Add()
--
--]]--
function PANEL:Add()
	if ( not self.m_ConVars ) then return end
	
	local ToName = self.txtName:GetValue()
	if ( not ToName or ToName == "" ) then return end
	
	-- Todo, Handle name collision
	local tabValues = {}
	
	for k, v in pairs( self.m_ConVars ) do
		tabValues[ v.CCmd ] = GetConVarString( v.CVar )
	end
		
	presets.Add( self.m_strType, ToName, tabValues )
	self:Update()
	self.PresetList:SelectByName( ToName )
	self.txtName:SetText( "" )
	
	if ( self.m_PresetControl ) then
		self.m_PresetControl:Update()
	end
end

vgui.Register( "StackerPresetEditor", PANEL, "PresetEditor" )
--addons/weapon_jedi/lua/lscs/autorun/lscs_forcepowers.lua:

if SERVER then
	util.AddNetworkString( "lscs_force_anims" )
	util.AddNetworkString( "lscs_force_use" )
	util.AddNetworkString( "lscs_start_jump" )

	function LSCS:PlayVCDSequence( ply, anim, start )
		start = start or 0

		if not IsValid( ply ) then return end

		net.Start( "lscs_force_anims" ) 
			net.WriteEntity( ply )
			net.WriteString( anim )
			net.WriteFloat( start )
		net.Broadcast()

		ply:AddVCDSequenceToGestureSlot( GESTURE_SLOT_GRENADE, ply:LookupSequence( anim ), start, true )
	end

	function LSCS:ForceApply( Ent, Vel, att )
		if Ent.Alive and not Ent:Alive() then return end
		if Ent.GetObserverMode and Ent:GetObserverMode() ~= OBS_MODE_NONE then return end

		if hook.Run( "LSCS:PlayerCanManipulate", att, Ent ) then return end

		local StartPos = att:GetShootPos()
		local EndPos = Ent:LocalToWorld( Ent:OBBCenter() )

		local tr = util.TraceLine( {
			start = StartPos,
			endpos = EndPos,
			mask = MASK_SHOT,
			filter = att,
		} )

		if tr.Entity ~= Ent then return end

		if Ent.loco then
			Ent:SetPos(Ent:GetPos() + Vector(0, 0, 150))
			Ent:SetVelocity(Vel)

			local effectdata = EffectData()
			effectdata:SetOrigin( Ent:GetPos() )
			effectdata:SetEntity( Ent )
			util.Effect("force_effects", effectdata, true, true)

            Ent:TakeDamage(1000)
		else
			local Phys = Ent:GetPhysicsObject()

			if IsValid( Phys ) and not Ent:IsPlayer() then
				Ent:SetPhysicsAttacker( att, 5 )

				if Phys:IsMotionEnabled() and Ent:GetMoveType() ~= MOVETYPE_NONE then
					Phys:Wake()

					if Ent:GetClass() == "prop_ragdoll" then
						for i = 1, Ent:GetPhysicsObjectCount() do
							local bone = Ent:GetPhysicsObjectNum( i )

							if bone and bone.IsValid and bone:IsValid() then
								bone:AddVelocity(  Vel )
							end
						end
					else
						if Ent:IsNPC() and Ent:GetMoveType() == MOVETYPE_STEP then
							local d = DamageInfo()
							d:SetDamage( 50 )
							d:SetDamageForce( Vel * 100 )
							d:SetAttacker( att )
							d:SetDamageType( DMG_CRUSH ) 
							d:SetDamagePosition( EndPos )

							Ent:TakeDamageInfo( d )
						else
							Phys:SetVelocity( Vel )
						end
					end

					local effectdata = EffectData()
						effectdata:SetOrigin( Ent:GetPos() )
						effectdata:SetEntity( Ent )
					util.Effect( "force_effects", effectdata, true, true )
				end
			else
				if Ent.IsPlayer and Ent:IsPlayer() then
					local effectdata = EffectData()
					effectdata:SetOrigin( Ent:GetPos() )
					effectdata:SetEntity( Ent )
					util.Effect("force_effects", effectdata, true, true)

					if Ent:OnGround() then
						Ent:SetPos(Ent:GetPos() + Vector(0, 0, 10))
					end

                    LSCS:PlayVCDSequence(Ent, "wos_bs_shared_falling")
                    timer.Simple(0.5, function()
                        if not IsValid(Ent) then return end
                        LSCS:PlayVCDSequence(Ent, "idle")
                    end)

					Ent:SetVelocity(Vel)
				end
			end
		end
	end

	hook.Add( "StartCommand", "!!!!!!lscs_forcejumpforcer", function( ply, cmd )
		if (ply._lscsForceJumpTime or 0) > CurTime() then
			cmd:SetButtons( bit.bor( cmd:GetButtons(), IN_JUMP ) )
		end
	end )

	local TICK_MIN = 1/14
	local NEXT_THINK = 0

	hook.Add( "Think", "!!!!lscs_unforgiveable_playerGetAll_loop_in_think_hook", function()
		local TIME = CurTime()

		if FrameTime() <= TICK_MIN then -- below this tickrate we run risk skipping the correct timing...
			if NEXT_THINK > TIME then return end

			NEXT_THINK = TIME + 0.1 -- slow it down to be nice to the server. The HUD is specifically designed to mask this slow updating.
		end

		for _, ply in ipairs( player.GetAll() ) do
			hook.Run( "LSCS:PlayerForcePowerThink", ply, TIME )

			if (ply._lscsNextForceRegen or 0) > TIME then continue end

			if not ply:InVehicle() then
				if not ply:OnGround() and ply:GetMoveType() ~= MOVETYPE_NOCLIP then continue end
			end

			ply:lscsSetForce( math.min(ply:lscsGetForce() + ply:lscsGetForceRegenAmount(),ply:lscsGetMaxForce()) )
		end
	end )

	net.Receive( "lscs_force_use", function( len, ply )
		if not IsValid( ply ) then return end
		if not ply:Alive() then return end

		if ply:InVehicle() and not ply:GetAllowWeaponsInVehicle() then return end

		local ID = net.ReadInt( 8 )
		local Activate = net.ReadBool()
		local ForcePowers = ply:lscsGetForceAbilities()

		local selectedF = ForcePowers[ ID ]

		if not selectedF then return end

		local item = selectedF.item

		if not item then return end

		if not ply._lscsUsedPowers then
			ply._lscsUsedPowers = {}
		end

		if Activate then
			ply._lscsUsedPowers[ ID ] = true

			ProtectedCall( function() LSCS.Force[ item.id ].StartUse( ply ) end )
		else
			if ply._lscsUsedPowers[ ID ] then
				ply._lscsUsedPowers[ ID ] = nil

				ProtectedCall( function() LSCS.Force[ item.id ].StopUse( ply ) end )
			end
		end
	end )

	hook.Add( "LSCS:OnPlayerEquippedItem", "!!!!lscs_forcepower_equip_handler", function( ply, item )
		if not IsValid( ply ) or not item then return end

		if item.type == "force" then
			ProtectedCall( function() LSCS.Force[ item.id ].Equip( ply ) end )
		end
	end)

	hook.Add( "LSCS:OnPlayerUnEquippedItem", "!!!!lscs_forcepower_unequip_handler", function( ply, item )
		if not IsValid( ply ) or not item then return end

		if item.type == "force" then
			ProtectedCall( function() LSCS.Force[ item.id ].UnEquip( ply ) end )
		end
	end)

	hook.Add( "PlayerDeath", "!!!!lscs_forcepower_playerdeath", function( ply )
		if not ply._lscsUsedPowers then return end

		local ForcePowers = ply:lscsGetForceAbilities()

		net.Start("lscs_force_use")
			net.WriteInt( table.Count( ply._lscsUsedPowers ), 9 )

			for ID, _ in pairs( ply._lscsUsedPowers ) do

				ProtectedCall( function() LSCS.Force[ ForcePowers[ ID ].item.id ].StopUse( ply ) end )

				net.WriteInt( ID, 8 )

				ply._lscsUsedPowers[ ID ]= nil
			end

		net.Send( ply )
	end )
else
	local X = ScrW() - 110
	local Y = ScrH() - 100

	local circles = include("includes/circles/circles.lua") -- i love this thing

	-- removed for performance optimization
	--local FP_BG = circles.New(CIRCLE_OUTLINED, 86, 0, 0, 22)
	--FP_BG:SetX( X )
	--FP_BG:SetY( Y )

	local FP = circles.New(CIRCLE_OUTLINED, 85, 0, 0, 20)
	FP:SetX( X )
	FP:SetY( Y )

	local smAlpha = 0

	local ForceIcon = Material( "lscs/ui/force_hud.png" )
	local ForceBG = Material( "lscs/ui/hud_fp.png" ) -- added for performance optimization

	hook.Add( "InitPostEntity", "!!!lscs_bullshit", function()
		local ply = LocalPlayer()
		ply._lscsOldIsMax = CurTime() - 1
	end )

	hook.Add( "HUDPaint", "!!!!lscs_ShowForceMana", function()
		-- if LSCS:HUDShouldHide( LSCS_HUD_POINTS_FORCE ) then return end

		-- local ply = LocalPlayer()

		-- if ply:InVehicle() and not ply:GetAllowWeaponsInVehicle() then return end

		-- local Time = CurTime()

		-- local F = ply:lscsGetForce()
		-- local Fmax = ply:lscsGetMaxForce()
		-- local wep = ply:GetActiveWeapon()

		-- local IsMax = F == Fmax

		-- if IsMax then
		-- 	if not ply._lscsOldIsMax then
		-- 		ply._lscsOldIsMax = Time + 5 -- fade out in 5 seconds
		-- 	end
		-- else
		-- 	ply._lscsOldIsMax = nil
		-- end

		-- local smRate = RealFrameTime()
		-- local tAlpha = (IsMax and ply._lscsOldIsMax < Time) and 0 or 1

		-- smAlpha = smAlpha + math.Clamp(tAlpha - smAlpha,-smRate * 3,smRate * 6)

		-- if IsValid( wep ) and wep.LSCS then
		-- 	if ply:InVehicle() then
		-- 		if ply:GetAllowWeaponsInVehicle() then
		-- 			smAlpha = 1
		-- 		end
		-- 	else
		-- 		smAlpha = 1
		-- 	end
		-- end

		-- if smAlpha == 0 then return end

		-- local segmentLength = 5
		-- local segmentSpace = 15
		-- local segmentDist = segmentLength + segmentSpace
		-- local segmentActiveValue = (260 / Fmax) * F

		-- surface.SetMaterial( ForceIcon )
		-- surface.SetDrawColor( Color( 0, 0, 0, 200 * smAlpha ) )
		-- surface.DrawTexturedRectRotated( X + 5, Y + 15, 124,124, 0 )
		-- surface.DrawTexturedRectRotated( X + 5, Y + 15, 132,132, 0 )
		-- surface.SetDrawColor( Color( 255, 255, 255, 255 * smAlpha ) )
		-- surface.DrawTexturedRectRotated( X + 5, Y + 15, 128,128, 0 )

		-- -- added for performance optimization
		-- surface.SetMaterial( ForceBG )
		-- surface.SetDrawColor( Color( 0, 0, 0, 200 * smAlpha ) )
		-- surface.DrawTexturedRect( X - 146, Y - 156, 256,256, 0 )

		-- draw.NoTexture()

		-- --FP_BG:SetColor( Color(0, 0, 0, 200 * smAlpha) ) -- removed for performance optimization
		-- FP:SetColor( Color(0, 127, 255, 255 * smAlpha) )

		-- -- the way im using circles is probably not ideal...  but fuck it, it looks so awesome.  This is probably the thing that will pop up in your profiler
		-- local Offset = 150
		-- for A = 0, 260 - segmentDist, segmentDist do
		-- 	local Start = Offset + A
		-- 	-- removed for performance optimization
		-- 	--FP_BG:SetStartAngle( Start - 1 )
		-- 	--FP_BG:SetEndAngle( Start  + segmentLength + 1 )
		-- 	--FP_BG()

		-- 	if A < segmentActiveValue then
		-- 		FP:SetStartAngle( Start  )
		-- 		FP:SetEndAngle( Start  + segmentLength )
		-- 		FP()
		-- 	end
		-- end
	end )

	net.Receive( "lscs_start_jump", function( len )
		local ply = LocalPlayer()

		ply.m_bJumping = true

		ply.m_bFirstJumpFrame = true
		ply.m_flJumpStartTime = CurTime()

		ply:AnimRestartMainSequence()
	end )

	net.Receive( "lscs_force_anims", function( len )
		local ply = net.ReadEntity()
		
		if not IsValid( ply ) then return end

		local seq = net.ReadString()
		local start = net.ReadFloat()

		ply:AddVCDSequenceToGestureSlot( GESTURE_SLOT_GRENADE, ply:LookupSequence( seq ), start, true )
	end )
end
--addons/weapon_jedi/lua/lscs/autorun/lscs_movement.lua:
-- alternative to ply:SetVelocity. Much smoother client experience

local meta = FindMetaTable( "Player" )

if CLIENT then
	hook.Add( "CreateMove", "!!!lscs_movementoverride", function( cmd )
		local ply = LocalPlayer()

		if not ply._lscsTimedMove then ply._lscsTimedMove = {} end

		local Time = CurTime()

		if ply._lscsWalkTime then
			if ply._lscsWalkTime < CurTime() then
				ply._lscsWalkTime = nil
			else
				local max = ply:GetSlowWalkSpeed()

				cmd:SetForwardMove( math.Clamp( cmd:GetForwardMove(), -max, max ) )
				cmd:SetUpMove( math.Clamp( cmd:GetUpMove(), -max, max ) )
				cmd:SetSideMove( math.Clamp( cmd:GetSideMove(), -max, max ) )

				return
			end
		end

		if ply:InVehicle() or table.IsEmpty( ply._lscsTimedMove ) then return end

		local Move

		for id, obj in pairs( ply._lscsTimedMove ) do
			if (obj.start + obj.duration) <= Time then
				ply._lscsTimedMove[id] = nil
				continue
			end

			if obj.start <= Time then
				if not Move then
					Move = obj.move
				else
					Move = Move + obj.move
				end
			end
		end

		if not Move then return end

		if ply:GetMoveType() ~= MOVETYPE_WALK then return end

		cmd:ClearMovement()

		cmd:SetForwardMove( Move.x )
		cmd:SetUpMove( Move.z )
		cmd:SetSideMove( Move.y )
	end )

	function meta:lscsSetTimedMove( ID, time_start, time_duration, movement )
		self._lscsTimedMove[ ID ] = {
			start = time_start,
			duration = time_duration,
			move = movement,
		}
	end

	net.Receive( "lscs_nw_movement", function( len )
		local DoWhat = net.ReadBool()

		if DoWhat then
			LocalPlayer():lscsSetTimedMove( -1, CurTime(), 0.5, Vector(0,0,0) )
		else
			local DoHowLong = net.ReadFloat()

			LocalPlayer()._lscsWalkTime = CurTime() + DoHowLong
		end
	end)
else
	util.AddNetworkString( "lscs_nw_movement" )

	function meta:lscsSetTimedMove( ID )
		if ID then return end

		net.Start( "lscs_nw_movement" )
			net.WriteBool( true )
		net.Send( self )
	end

	function meta:lscsForceWalk( seconds )
		net.Start( "lscs_nw_movement" )
			net.WriteBool( false )
			net.WriteFloat( seconds )
		net.Send( self )
	end
end

hook.Add( "PlayerFootstep", "!!!lscs_CustomFootstep", function( ply, pos, foot, sound, volume, rf )
	local weapon = ply:GetActiveWeapon()

	if IsValid( weapon ) and weapon.LSCS then
		if weapon:GetGestureTime() > CurTime() then
			return true
		end
	end
end )

function meta:lscsClearTimedMove()
	if not self._lscsTimedMove then self._lscsTimedMove = {} end

	for ID, _ in pairs( self._lscsTimedMove ) do
		if ID ~= -1 then
			self._lscsTimedMove[ ID ] = nil
		end
	end
end

--addons/lvs_addons/lua/lvs_framework/autorun/sh_starwars_keybinding.lua:

hook.Add( "LVS:Initialize", "[LVS] - Star Wars - Keys", function()
	local KEYS = {
		{
			name = "+THRUST_SF",
			category = "LVS-Starfighter",
			name_menu = "Thrust Increase",
			default = "+forward",
			cmd = "lvs_starfighter_throttle_up"
		},
		{
			name = "-THRUST_SF",
			category = "LVS-Starfighter",
			name_menu = "Thrust Decrease",
			default = "+back",
			cmd = "lvs_starfighter_throttle_down"
		},
		{
			name = "+PITCH_SF",
			category = "LVS-Starfighter",
			name_menu = "Pitch Up",
			default = "+speed",
			cmd = "lvs_starfighter_pitch_up"
		},
		{
			name = "-PITCH_SF",
			category = "LVS-Starfighter",
			name_menu = "Pitch Down",
			cmd = "lvs_starfighter_pitch_down"
		},
		{
			name = "-YAW_SF",
			category = "LVS-Starfighter",
			name_menu = "Yaw Left [Roll in Direct Input]",
			cmd = "lvs_starfighter_yaw_left"
		},
		{
			name = "+YAW_SF",
			category = "LVS-Starfighter",
			name_menu = "Yaw Right [Roll in Direct Input]",
			cmd = "lvs_starfighter_yaw_right"
		},
		{
			name = "-ROLL_SF",
			category = "LVS-Starfighter",
			name_menu = "Roll Left [Yaw in Direct Input]",
			default = "+moveleft",
			cmd = "lvs_starfighter_roll_left"
		},
		{
			name = "+ROLL_SF",
			category = "LVS-Starfighter",
			name_menu = "Roll Right [Yaw in Direct Input]",
			default = "+moveright",
			cmd = "lvs_starfighter_roll_right"
		},
		{
			name = "+VTOL_Z_SF",
			category = "LVS-Starfighter",
			name_menu = "VTOL Up",
			cmd = "lvs_starfighter_vtol_up"
		},
		{
			name = "-VTOL_Z_SF",
			category = "LVS-Starfighter",
			name_menu = "VTOL Down",
			cmd = "lvs_starfighter_vtol_dn"
		},
		{
			name = "-VTOL_Y_SF",
			category = "LVS-Starfighter",
			name_menu = "VTOL Right",
			cmd = "lvs_starfighter_vtol_right"
		},
		{
			name = "+VTOL_Y_SF",
			category = "LVS-Starfighter",
			name_menu = "VTOL Left",
			cmd = "lvs_starfighter_vtol_left"
		},
		{
			name = "-VTOL_X_SF",
			category = "LVS-Starfighter",
			name_menu = "VTOL Reverse",
			default = "+back",
			cmd = "lvs_starfighter_vtol_reverse"
		},
	}

	for _, v in pairs( KEYS ) do
		LVS:AddKey( v.name, v.category, v.name_menu, v.cmd, v.default )
	end
end )

LVS:AddWeaponPreset( "TURBO", {
	Icon = Material("lvs/weapons/nos.png"),
	HeatRateUp = 0.1,
	HeatRateDown = 0.1,
	UseableByAI = false,
	Attack = function( ent )
		local PhysObj = ent:GetPhysicsObject()
		if not IsValid( PhysObj ) then return end
		local THR = ent:GetThrottle()
		local FT = FrameTime()

		local Vel = ent:GetVelocity():Length()

		PhysObj:ApplyForceCenter( ent:GetForward() * math.Clamp(ent.MaxVelocity + 500 - Vel,0,1) * PhysObj:GetMass() * THR * FT * 150 ) -- increase speed
		PhysObj:AddAngleVelocity( PhysObj:GetAngleVelocity() * FT * 0.5 * THR ) -- increase turn rate
	end,
	StartAttack = function( ent )
		ent.TargetThrottle = 1.3
		ent:EmitSound("lvs/vehicles/generic/boost.wav")
	end,
	FinishAttack = function( ent )
		ent.TargetThrottle = 1
	end,
	OnSelect = function( ent )
		ent:EmitSound("buttons/lever5.wav")
	end,
	OnThink = function( ent, active )
		if not ent.TargetThrottle then return end

		local Rate = FrameTime() * 0.5

		ent:SetMaxThrottle( ent:GetMaxThrottle() + math.Clamp(ent.TargetThrottle - ent:GetMaxThrottle(),-Rate,Rate) )

		local MaxThrottle = ent:GetMaxThrottle()

		ent:SetThrottle( MaxThrottle )

		if MaxThrottle == ent.TargetThrottle then
			ent.TargetThrottle = nil
		end
	end,
	OnOverheat = function( ent ) ent:EmitSound("lvs/overheat_boost.wav") end,
} )

if CLIENT then return end

resource.AddWorkshop("2919757295")
--addons/billy_gas/lua/openpermissions/sh.lua:
function OpenPermissions:CreatePermissionsRegistry()
	local registry = {}
	for _, enum in pairs(OpenPermissions.ACCESS_GROUP) do registry[enum] = {} end
	return registry
end

OpenPermissions.REGISTRY = {}
OpenPermissions.REGISTRY.NETWORKED = 0
OpenPermissions.REGISTRY.FLAT_FILE = 1
function OpenPermissions:SerializeRegistry(dataType)
	if (dataType == OpenPermissions.REGISTRY.NETWORKED) then

		if (file.Exists("openpermissions_v2.dat", "DATA")) then
			-- Lazy but still probably quicker
			local data = file.Read("openpermissions_v2.dat", "DATA")
			net.WriteUInt(#data, 32)
			net.WriteData(data, #data)
		else
			net.WriteUInt(0, 32)
		end

	elseif (dataType == OpenPermissions.REGISTRY.FLAT_FILE) then

		local f = file.Open("openpermissions_v2.dat", "wb", "DATA")

		-- Write file header
		f:Write("OPENPERMISSIONS")

		local ids = {}
		local id = 0
		local ids_pos = f:Tell()
		f:Seek(ids_pos + (32 / 8)) -- Allocate a UShort for seeker position of IDs

		-- Write permissions registry
		local access_group_count = 0
		local access_group_pos = f:Tell()
		f:Seek(access_group_pos + (32 / 8))
		for access_group, accessors in pairs(OpenPermissions.PermissionsRegistry) do
			f:WriteUShort(access_group)
			access_group_count = access_group_count + 1

			local accessors_count = 0
			local accessors_pos = f:Tell()
			f:Seek(accessors_pos + (32 / 8))
			for accessor, permissions in pairs(accessors) do
				if (isnumber(accessor)) then
					f:WriteBool(false)
					f:WriteULong(accessor)
				elseif (isstring(accessor)) then
					f:WriteBool(true)
					f:WriteUShort(#accessor)
					f:Write(accessor)
				else
					error("Invalid accessor key type! (" .. type(accessor) .. ")")
				end
				accessors_count = accessors_count + 1

				local permissions_count = 0
				local permissions_pos = f:Tell()
				f:Seek(permissions_pos + (32 / 8))
				for permission_id, access in pairs(permissions) do
					if (not ids[permission_id]) then
						id = id + 1
						ids[permission_id] = id
					end
					f:WriteUShort(ids[permission_id])
					f:WriteBool(access == OpenPermissions.CHECKBOX.INHERIT)
					f:WriteBool(access == OpenPermissions.CHECKBOX.TICKED)
					permissions_count = permissions_count + 1
				end
				local pos = f:Tell()
				f:Seek(permissions_pos)
				f:WriteULong(permissions_count)
				f:Seek(pos)
			end
			local pos = f:Tell()
			f:Seek(accessors_pos)
			f:WriteULong(accessors_count)
			f:Seek(pos)
		end
		local pos = f:Tell()
		f:Seek(access_group_pos)
		f:WriteULong(access_group_count)
		f:Seek(pos)

		-- Write IDs
		local count = 0
		local countPos = f:Tell()
		f:Seek(countPos + (32 / 8)) -- We can seek back and write the count here
		for str, id in pairs(ids) do
			f:WriteUShort(#str)
			f:Write(str)
			f:WriteUShort(id)
			count = count + 1
		end
		f:Seek(countPos)
		f:WriteULong(count)

		f:Seek(ids_pos)
		f:WriteULong(countPos)

		f:Close()

		file.Write("openpermissions_v2.dat", util.Compress(file.Read("openpermissions_v2.dat", "DATA")))

	end
end
function OpenPermissions:DeserializeRegistry(dataType, stream)
	if (dataType == OpenPermissions.REGISTRY.NETWORKED) then
		
		-- Lazy but still probably quicker
		local data_len = net.ReadUInt(32)
		if (data_len == 0) then return end

		local data = net.ReadData(data_len)

		file.Write("openpermissions_networked.dat", data)
		OpenPermissions:DeserializeRegistry(OpenPermissions.REGISTRY.FLAT_FILE, "openpermissions_networked.dat")
		file.Delete("openpermissions_networked.dat")

	elseif (dataType == OpenPermissions.REGISTRY.FLAT_FILE) then
		
		local data = file.Read(stream or "openpermissions_v2.dat", "DATA")
		file.Write("openpermissions_stream.dat", util.Decompress(data))
		local f = file.Open("openpermissions_stream.dat", "rb", "DATA")

		assert(f:Read(#("OPENPERMISSIONS")) == "OPENPERMISSIONS", "Error! OpenPermissions data corrupted!")

		OpenPermissions.IDs = { Int = {}, Str = {} }
		OpenPermissions.PermissionsRegistry = OpenPermissions:CreatePermissionsRegistry()

		local ids = {}

		local pointer = f:ReadULong()
		local pos = f:Tell()
		f:Seek(pointer)

		-- Read permission IDs
		for i = 1, f:ReadULong() do
			local permission_str = f:Read(f:ReadUShort())
			local permission_id = f:ReadUShort()
			ids[permission_id] = permission_str
		end
		
		f:Seek(pos)

		-- Read permission registry
		for i = 1, f:ReadULong() do
			local access_group = f:ReadUShort()
			OpenPermissions.PermissionsRegistry[access_group] = {}
			
			for j = 1, f:ReadULong() do
				local accessor = f:ReadBool() and f:Read(f:ReadUShort()) or f:ReadULong()
				OpenPermissions.PermissionsRegistry[access_group][accessor] = {}

				for k = 1, f:ReadULong() do
					OpenPermissions.PermissionsRegistry[access_group][accessor][ids[f:ReadUShort()]] = f:ReadBool() and OpenPermissions.CHECKBOX.INHERIT or (f:ReadBool() and OpenPermissions.CHECKBOX.TICKED or OpenPermissions.CHECKBOX.CROSSED)
				end
			end
		end

		f:Close()
		file.Delete("openpermissions_stream.dat")

		return OpenPermissions.PermissionsRegistry

	end
end

function OpenPermissions:SerializeTable(tbl)
	return OpenPermissions.pon.encode(tbl)
end

function OpenPermissions:DeserializeTable(tbl)
	return OpenPermissions.pon.decode(tbl)
end

local NetworkedTblCache = {}
function OpenPermissions:ClearNetworkCache(tbl)
	NetworkedTblCache[tostring(tbl)] = nil
end
function OpenPermissions:StartNetworkTable(tbl, cache, clear_cache)
	if (tbl == OpenPermissions.PermissionsRegistry) then
		return OpenPermissions:SerializeRegistry(OpenPermissions.REGISTRY.NETWORKED)
	end

	local tbl_enc
	if (cache and not clear_cache and NetworkedTblCache[tostring(tbl)] ~= nil) then
		tbl_enc = NetworkedTblCache[tostring(tbl)]
	else
		tbl_enc = util.Compress(OpenPermissions:SerializeTable(tbl))
		if (cache) then
			NetworkedTblCache[tostring(tbl)] = tbl_enc
		end
	end
	net.WriteUInt(#tbl_enc, 32)
	net.WriteData(tbl_enc, #tbl_enc)
end
function OpenPermissions:ReceiveNetworkTable()
	local tbl_enc_len = net.ReadUInt(32)
	local tbl_dec = OpenPermissions:DeserializeTable(util.Decompress(net.ReadData(tbl_enc_len)))
	return tbl_dec
end

--## SteamIDs ##--

function OpenPermissions:SteamID64ToAccountID(steamid64)
	return OpenPermissions:SteamIDToAccountID(util.SteamIDFrom64(steamid64))
end

function OpenPermissions:SteamIDToAccountID(steamid)
	local acc32 = tonumber(steamid:sub(11))
	return (acc32 * 2) + tonumber(steamid:sub(9,9))
end

function OpenPermissions:AccountIDToSteamID(account_id)
	local sid32 = tonumber(account_id) / 2
	if (sid32 % 1 > 0) then
		return "STEAM_0:1:" .. math.floor(sid32)
	else
		return "STEAM_0:0:" .. sid32
	end
end

function OpenPermissions:AccountIDToSteamID64(account_id)
	return util.SteamIDTo64(OpenPermissions:AccountIDToSteamID(account_id))
end

--## Usergroup Management ##--

function OpenPermissions:IsUserGroup(ply, ...)
	local vararg = {...}
	if (#vararg == 1) then
		return ply:IsUserGroup(vararg[1]) or (not ply:IsBot() and hook.Run("OpenPermissions:IsUserGroup", ply, vararg[1]) == true) or false
	else
		for _,ug in ipairs(vararg) do
			if (ply:IsUserGroup(ug) or (not ply:IsBot() and hook.Run("OpenPermissions:IsUserGroup", ply, ug) == true)) then
				return true
			end
		end
		return false
	end
end

function OpenPermissions:IsUsergroups(ply, usergroups)
	local ply_usergroups = OpenPermissions:GetUserGroups(ply)
	for _,usergroup in ipairs(usergroups) do
		if (ply_usergroups[usergroup]) then
			return true
		end
	end
	return false
end

function OpenPermissions:GetUserGroups(ply)
	local usergroups_tbl = {[ply:GetUserGroup()] = true}
	if (not ply:IsBot()) then
		hook.Run("OpenPermissions:GetUserGroups", ply, usergroups_tbl)
	end
	return usergroups_tbl
end

--## Internal Operators Indexing ##--
OpenPermissions.IndexedOperators = {}
for _,_s in ipairs(OpenPermissions.Operators.SteamIDs) do
	local s = string.Trim(_s)
	if (s:find("^STEAM_%d:%d:%d+$")) then
		OpenPermissions.IndexedOperators[OpenPermissions:SteamIDToAccountID(s)] = true
	elseif (s:find("^7656119%d+$")) then
		OpenPermissions.IndexedOperators[OpenPermissions:SteamID64ToAccountID(s)] = true
	else
		OpenPermissions:Print("Invalid SteamID in config file; not a SteamID/SteamID64: \"" .. _s .. "\"", "[ERROR]", OpenPermissions.COLOR_RED)
	end
end

function OpenPermissions:IsOperator(ply)
	if (ply:IsBot()) then return false end
	if (OpenPermissions.IndexedOperators[ply:AccountID()]) then
		return true
	end
	for _,u in ipairs(OpenPermissions.Operators.Usergroups) do
		if (OpenPermissions:IsUserGroup(ply, u)) then
			return true
		end
	end
	if (hook.Run("OpenPermissions:IsOperator", ply) == true) then
		return true
	end
	return false
end

--## HasPermission, GetPermission ##--

function OpenPermissions:GetPermission(ply, permission_id, is_operator)
	if (type(ply) ~= "Player" or ply:AccountID() == nil) then
		OpenPermissions:Print("Tried to do a permission check on a non-player or a player without an assigned account ID?", "[ERROR]", OpenPermissions.COLOR_RED)
		debug.Trace()
		return false
	end
	if (ply:IsBot()) then return false end
	if (is_operator == true or (is_operator ~= false and OpenPermissions:IsOperator(ply))) then return true end
	
	local has_permission = OpenPermissions.CHECKBOX.INHERIT

	if (type(permission_id) == "table") then
		for _,v in ipairs(permission_id) do
			local r = OpenPermissions:GetPermission(ply, v)
			if (r ~= OpenPermissions.CHECKBOX.INHERIT) then
				return r
			end
		end
		return OpenPermissions.CHECKBOX.INHERIT
	end

	for usergroup in pairs(OpenPermissions:GetUserGroups(ply)) do
		local ply_usergroup_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.USERGROUP][usergroup]
		if (ply_usergroup_registry) then
			if (ply_usergroup_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_usergroup_registry[permission_id] == true) then
				has_permission = OpenPermissions.CHECKBOX.TICKED
			elseif (ply_usergroup_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
				return OpenPermissions.CHECKBOX.CROSSED
			end
		end
	end

	local ply_steamid_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.STEAMID][ply:AccountID()]
	if (ply_steamid_registry) then
		if (ply_steamid_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_steamid_registry[permission_id] == true) then
			has_permission = OpenPermissions.CHECKBOX.TICKED
		elseif (ply_steamid_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
			return OpenPermissions.CHECKBOX.CROSSED
		end
	end

	if (ply:Team()) then
		local ply_team_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.TEAM][OpenPermissions:GetTeamIdentifier(ply:Team())]
		if (ply_team_registry) then
			if (ply_team_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_team_registry[permission_id] == true) then
				has_permission = OpenPermissions.CHECKBOX.TICKED
			elseif (ply_team_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
				return OpenPermissions.CHECKBOX.CROSSED
			end
		end

		if (OpenPermissions.IsDarkRP and RPExtraTeams[ply:Team()]) then
			local ply_category_name = RPExtraTeams[ply:Team()].category
			local ply_category
			for i,category in ipairs(DarkRP.getCategories().jobs) do
				if (category.name == ply_category_name) then
					ply_category = i
					break
				end
			end
			if (ply_category) then
				local ply_category_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY][OpenPermissions:DarkRP_GetCategoryIdentifier(ply_category)]
				if (ply_category_registry) then
					if (ply_category_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_category_registry[permission_id] == true) then
						has_permission = OpenPermissions.CHECKBOX.TICKED
					elseif (ply_category_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
						return OpenPermissions.CHECKBOX.CROSSED
					end
				end
			end
		end
	end

	for name, func in pairs(OpenPermissions.LuaFunctions) do
		local lua_function_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.LUA_FUNCTION][name]
		if (lua_function_registry) then
			if (func(ply, permission_id) == true) then
				if (lua_function_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or lua_function_registry[permission_id] == true) then
					has_permission = OpenPermissions.CHECKBOX.TICKED
				elseif (lua_function_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
					return OpenPermissions.CHECKBOX.CROSSED
				end
			end
		end
	end

	if (has_permission == OpenPermissions.CHECKBOX.INHERIT and OpenPermissions.DefaultPermissions[permission_id] == OpenPermissions.CHECKBOX.TICKED) then
		has_permission = OpenPermissions.CHECKBOX.TICKED
	end

	return has_permission
end

function OpenPermissions:HasPermission(ply, permission_id, is_operator)
	if (type(ply) ~= "Player" or ply:AccountID() == nil) then
		OpenPermissions:Print("Tried to do a permission check on a non-player or a player without an assigned account ID?", "[ERROR]", OpenPermissions.COLOR_RED)
		debug.Trace()
		return false
	end
	if (ply:IsBot()) then return false end
	if (is_operator == true or (is_operator ~= false and OpenPermissions:IsOperator(ply))) then return true end

	local has_permission = false

	if (type(permission_id) == "table") then
		for _,v in ipairs(permission_id) do
			if (OpenPermissions:HasPermission(ply, v)) then
				return true
			end
		end
		return false
	end

	for usergroup in pairs(OpenPermissions:GetUserGroups(ply)) do
		local ply_usergroup_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.USERGROUP][usergroup]
		if (ply_usergroup_registry) then
			if (ply_usergroup_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_usergroup_registry[permission_id] == true) then
				has_permission = true
			elseif (ply_usergroup_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
				return false
			end
		end
	end

	local ply_steamid_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.STEAMID][ply:AccountID()]
	if (ply_steamid_registry) then
		if (ply_steamid_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_steamid_registry[permission_id] == true) then
			has_permission = true
		elseif (ply_steamid_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
			return false
		end
	end

	if (ply:Team()) then
		local ply_team_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.TEAM][OpenPermissions:GetTeamIdentifier(ply:Team())]
		if (ply_team_registry) then
			if (ply_team_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_team_registry[permission_id] == true) then
				has_permission = true
			elseif (ply_team_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
				return false
			end
		end

		if (OpenPermissions.IsDarkRP and RPExtraTeams[ply:Team()]) then
			local ply_category_name = RPExtraTeams[ply:Team()].category
			local ply_category
			for i,category in ipairs(DarkRP.getCategories().jobs) do
				if (category.name == ply_category_name) then
					ply_category = i
					break
				end
			end
			if (ply_category) then
				local ply_category_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY][OpenPermissions:DarkRP_GetCategoryIdentifier(ply_category)]
				if (ply_category_registry) then
					if (ply_category_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_category_registry[permission_id] == true) then
						has_permission = true
					elseif (ply_category_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
						return false
					end
				end
			end
		end
	end

	for name, func in pairs(OpenPermissions.LuaFunctions) do
		local lua_function_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.LUA_FUNCTION][name]
		if (lua_function_registry) then
			if (func(ply, permission_id) == true) then
				if (lua_function_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or lua_function_registry[permission_id] == true) then
					has_permission = true
				elseif (lua_function_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
					return false
				end
			end
		end
	end

	if (has_permission == false and OpenPermissions.DefaultPermissions[permission_id] == OpenPermissions.CHECKBOX.TICKED) then
		has_permission = true
	end

	return has_permission
end

--## Teams ##--

local team_identifier_index = {}
function OpenPermissions:GetTeamIdentifier(team_index)
	local team_identifier = hook.Run("OpenPermissions:GetTeamIdentifier", team_index)
	if (team_identifier) then
		team_identifier_index[team_identifier] = team_index
		return team_identifier
	end
	if (OpenPermissions.IsDarkRP and RPExtraTeams and team_index ~= 0) then
		if (RPExtraTeams[team_index]) then
			local team_identifier = RPExtraTeams[team_index].OPENPERMISSIONS_IDENTIFIER or RPExtraTeams[team_index].GAS_IDENTIFIER or RPExtraTeams[team_index].command
			team_identifier_index[team_identifier] = team_index
			return team_identifier
		end
	else
		local team_identifier = team.GetName(team_index)
		team_identifier_index[team_identifier] = team_index
		return team_identifier
	end
end

function OpenPermissions:GetTeamFromIdentifier(team_identifier)
	if (team_identifier == "Joining/Connecting") then return TEAM_CONNECTING end
	if (team_identifier == "Unassigned") then return TEAM_UNASSIGNED end
	if (team_identifier == "Spectator") then return TEAM_SPECTATOR end
	if (team_identifier_index[team_identifier]) then return team_identifier_index[team_identifier] end

	local team_index = hook.Run("OpenPermissions:GetTeamFromIdentifier", team_identifier)
	if (team_index) then
		team_identifier_index[team_identifier] = team_index
		return team_index
	end
	if (OpenPermissions.IsDarkRP and RPExtraTeams) then
		for _,job in ipairs(RPExtraTeams) do
			if (job.OPENPERMISSIONS_IDENTIFIER == team_identifier or job.command == team_identifier) then
				team_identifier_index[team_identifier] = job.team
				return job.team
			end
		end
	else
		for i,t in ipairs(team.GetAllTeams()) do
			if (t.Name == team_identifier) then
				team_identifier_index[team_identifier] = i
				return i
			end
		end
	end
end

local category_identifier_index = {}
function OpenPermissions:DarkRP_GetCategoryIdentifier(category_index)
	local category_identifier = hook.Run("OpenPermissions:DarkRP_GetCategoryIdentifier", category_index)
	if (category_identifier) then
		category_identifier_index[category_identifier] = category_index
		return category_identifier
	end

	local category = DarkRP.getCategories().jobs[category_index]
	local category_identifier = category.OPENPERMISSIONS_IDENTIFIER or category.GAS_IDENTIFIER or category.name

	category_identifier_index[category_identifier] = category_index
	return category_identifier
end

function OpenPermissions:DarkRP_GetCategoryFromIdentifier(category_identifier)
	if (category_identifier_index[category_identifier]) then return category_identifier_index[category_identifier] end

	local category_index = hook.Run("OpenPermissions:DarkRP_GetCategoryFromIdentifier", category_identifier)
	if (category_index) then
		category_identifier_index[category_index] = category_identifier
		return category_index
	end

	for i,category in pairs(DarkRP.getCategories().jobs) do
		local category_id = category.OPENPERMISSIONS_IDENTIFIER or category.GAS_IDENTIFIER or category.name
		if (category_id == category_identifier) then
			category_identifier_index[category_id] = i
			return i
		end
	end
end

--## Misc ##--

function OpenPermissions:table_IsEmpty(tbl)
	return next(tbl) == nil
end

function OpenPermissions:table_IsIdentical(tbl1, tbl2)
	local function r(tbl1, tbl2)
		for key, val in pairs(tbl1) do
			if (tbl2[key] == nil) then
				return false
			elseif (type(val) == "table") then
				if (r(val, tbl2[key]) == false) then
					return false
				end
			elseif (tbl2[key] ~= val) then
				return false
			end
		end
		for key, val in pairs(tbl2) do
			if (tbl1[key] == nil) then
				return false
			elseif (type(val) == "table") then
				if (r(val, tbl1[key]) == false) then
					return false
				end
			elseif (tbl1[key] ~= val) then
				return false
			end
		end
	end
	return r(tbl1, tbl2) ~= false
end

--## Enums ##--

OpenPermissions.ADDON = 0
OpenPermissions.PERMISSION = 1
OpenPermissions.CATEGORY = 2
OpenPermissions.SUBPERMISSION = 3

OpenPermissions.PermissionsRegistry = OpenPermissions:CreatePermissionsRegistry()
OpenPermissions.DefaultPermissions = {}

--## Networking ##--

if (SERVER) then
	-- Convert old file format to new
	if (file.Exists("openpermissions.dat", "DATA") and not file.Exists("openpermissions_v2.dat", "DATA")) then
		local read_file = file.Read("openpermissions.dat", "DATA")
		if (not read_file) then
			OpenPermissions:Print("Failed to read saved permissions data", "[ERROR]", OpenPermissions.COLOR_RED)
		else
			read_file = util.Decompress(read_file)
			if (not read_file) then
				OpenPermissions:Print("Failed to decompress saved permissions data", "[ERROR]", OpenPermissions.COLOR_RED)
			else
				local no_errors, deserialized = pcall(OpenPermissions.pon.decode, read_file)
				if (not no_errors) then
					OpenPermissions:Print("Failed to deserialize decompressed saved permissions data", "[ERROR]", OpenPermissions.COLOR_RED)
				else
					--OpenPermissions:Print("Saved permissions data successfully loaded", "[INFO]", OpenPermissions.COLOR_GREEN)

					-- Restructure
					for access_group_str, permissions in pairs(deserialized) do
						local access_group, accessor = access_group_str:match("(%d) (.+)")
						OpenPermissions.PermissionsRegistry[access_group] = OpenPermissions.PermissionsRegistry[access_group] or {}
						OpenPermissions.PermissionsRegistry[access_group][accessor] = {}
						for permission_id_str, permission in pairs(permissions) do
							OpenPermissions.PermissionsRegistry[access_group][accessor][permission_id_str] = permission
						end
					end

					-- Save new data
					OpenPermissions:SerializeRegistry(OpenPermissions.REGISTRY.FLAT_FILE)

					file.Rename("openpermissions.dat", "openpermissions_v1.dat")
				end
			end
		end
	end

	if (file.Exists("openpermissions_v2.dat", "DATA")) then
		local no_errors = xpcall(OpenPermissions.DeserializeRegistry, function(err)
			OpenPermissions:Print("Failed to deserialize decompressed saved permissions data", "[ERROR]", OpenPermissions.COLOR_RED)

			print(err)
			debug.Trace()
		end, OpenPermissions, OpenPermissions.REGISTRY.FLAT_FILE)

		if (no_errors) then
			OpenPermissions:Print("Saved permissions data successfully loaded", "[INFO]", OpenPermissions.COLOR_GREEN)
		end
	end
	net.Receive("OpenPermissions.SavePermissions", function(_, ply)
		if (not OpenPermissions:IsOperator(ply)) then return end
		OpenPermissions:DeserializeRegistry(OpenPermissions.REGISTRY.NETWORKED)
		OpenPermissions:SerializeRegistry(OpenPermissions.REGISTRY.FLAT_FILE)

		net.Start("OpenPermissions.PermissionsRegistry")
			OpenPermissions:StartNetworkTable(OpenPermissions.PermissionsRegistry, true, true)
			OpenPermissions:StartNetworkTable(OpenPermissions.DefaultPermissions, true)
		net.SendOmit(ply)
	end)
	net.Receive("OpenPermissions.PermissionsRegistry", function(_, ply)
		net.Start("OpenPermissions.PermissionsRegistry")
			OpenPermissions:StartNetworkTable(OpenPermissions.PermissionsRegistry, true)
			OpenPermissions:StartNetworkTable(OpenPermissions.DefaultPermissions, true)
		net.Send(ply)
	end)
else
	net.Receive("OpenPermissions.PermissionsRegistry", function()
		OpenPermissions:DeserializeRegistry(OpenPermissions.REGISTRY.NETWORKED)
		OpenPermissions.DefaultPermissions = OpenPermissions:ReceiveNetworkTable()
		OpenPermissions:Print("Received permissions registry", "[INFO]")
	end)
	if (OpenPermissions_PermissionsRegistry_InitPostEntity) then
		net.Start("OpenPermissions.PermissionsRegistry")
		net.SendToServer()
	else
		hook.Add("InitPostEntity", "OpenPermissions.PermissionsRegistry", function()
			OpenPermissions_PermissionsRegistry_InitPostEntity = true
			net.Start("OpenPermissions.PermissionsRegistry")
			net.SendToServer()
		end)
	end
end
--lua/autorun/priest_pm.lua:
player_manager.AddValidModel( "priest_01", 					"models/humans/group01/Priest_01.mdl" )
list.Set( "PlayerOptionsModel",  "priest_01", 					"models/humans/group01/Priest_01.mdl" ) 

player_manager.AddValidModel( "priest_02", 					"models/humans/group01/Priest_02.mdl" )
list.Set( "PlayerOptionsModel",  "priest_02", 					"models/humans/group01/Priest_02.mdl" ) 

player_manager.AddValidModel( "priest_03", 					"models/humans/group01/Priest_03.mdl" )
list.Set( "PlayerOptionsModel",  "priest_03", 					"models/humans/group01/Priest_03.mdl" ) 

player_manager.AddValidModel( "priest_04", 					"models/humans/group01/Priest_04.mdl" )
list.Set( "PlayerOptionsModel",  "priest_04", 					"models/humans/group01/Priest_04.mdl" ) 

player_manager.AddValidModel( "priest_05", 					"models/humans/group01/Priest_05.mdl" )
list.Set( "PlayerOptionsModel",  "priest_05", 					"models/humans/group01/Priest_05.mdl" ) 

player_manager.AddValidModel( "priest_06", 					"models/humans/group01/Priest_06.mdl" )
list.Set( "PlayerOptionsModel",  "priest_06", 					"models/humans/group01/Priest_06.mdl" ) 

player_manager.AddValidModel( "priest_07", 					"models/humans/group01/Priest_07.mdl" )
list.Set( "PlayerOptionsModel",  "priest_07", 					"models/humans/group01/Priest_07.mdl" ) 

player_manager.AddValidModel( "priest_08", 					"models/humans/group01/Priest_08.mdl" )
list.Set( "PlayerOptionsModel",  "priest_08", 					"models/humans/group01/Priest_08.mdl" ) 

player_manager.AddValidModel( "priest_09", 					"models/humans/group01/Priest_09.mdl" )
list.Set( "PlayerOptionsModel",  "priest_09", 					"models/humans/group01/Priest_09.mdl" ) 
--addons/admin_sam/lua/sam/libs/sh_netstream.lua:
if SAM_LOADED then return end

--[[
	NetStream - 2.0.1
	https://github.com/alexgrist/NetStream/blob/master/netstream2.lua

	Alexander Grist-Hucker
	http://www.revotech.org
]]--

--[[
	if SERVER then
		netstream.Hook("Hi", function(ply, ...) -- Third argument is called to check if the player has permission to send the net message before decoding
			print(...)
		end, function(ply)
			if not ply:IsAdmin() then
				return false
			end
		end)
		-- OR
		netstream.Hook("Hi", function(ply, ...)
			print(...)
		end)
		netstream.Start(Entity(1), "Hi", "a", 1, {}, true, false, nil, "!") -- First argument player or table of players or any other argument to send to all players
		netstream.Start({Entity(1), Entity(2)}, "Hi", "a", 1, {}, true, false, nil, "!")
		netstream.Start(nil, "Hi", "a", 1, {}, true, false, nil, "!")
	end
	if CLIENT then
		netstream.Hook("Hi", function(...)
			print(...)
		end)
		netstream.Start("Hi", "a", 1, {}, true, false, nil, "!")
	end
]]--

-- Config

local addonName = "SAM"
local mainTable = sam -- _G.netstream = netstream

local sfs = sam.sfs
local encode_array = sfs.encode_array
local decode = sfs.decode

--

local type = sam.type
local unpack = unpack

local net = net
local compress = util.Compress
local decompress = util.Decompress

local netStreamSend = addonName .. ".NetStreamDS.Sending"

local netstream = {}
if istable(mainTable) then
	mainTable.netstream = netstream
end

local checks = {}
local receivers = {}

if SERVER then
	util.AddNetworkString(netStreamSend)

	local player_GetAll = player.GetAll
	function netstream.Start(ply, name, ...)
		if #name > 31 then
			error("netstream.Start name too long")
		end

		local ply_type = type(ply)
		if ply_type ~= "Player" and ply_type ~= "table" then
			ply = player_GetAll()
		end

		local array_length = select("#", ...)
		local encoded_data = encode_array({name, array_length, ...}, array_length + 2)

		net.Start(netStreamSend)
			net.WriteBool(false)
			net.WriteData(encoded_data)
		net.Send(ply)
	end

	function netstream.StartCompressed(ply, name, ...)
		if #name > 31 then
			error("netstream.Start name too long")
		end

		local ply_type = type(ply)
		if ply_type ~= "Player" and ply_type ~= "table" then
			ply = player_GetAll()
		end

		local array_length = select("#", ...)
		local encoded_data = encode_array({name, array_length, ...}, array_length + 2)

		local compressed_data = compress(encoded_data)

		net.Start(netStreamSend)
			net.WriteBool(true)
			net.WriteData(compressed_data)
		net.Send(ply)
	end

	function netstream.Hook(name, callback, check)
		if #name > 31 then
			error("netstream.Hook name too long")
		end

		receivers[name] = callback
		if type(check) == "function" then
			checks[name] = check
		end
	end

	net.Receive(netStreamSend, function(_, ply)
		local name = net.ReadString()

		local callback = receivers[name]
		if not callback then return end

		local length = net.ReadUInt(16)

		local check = checks[name]
		if check and check(ply, length) == false then return end

		local binary_data = net.ReadData(length)

		local decoded_data = decode(binary_data)
		if type(decoded_data) ~= "table" then return end

		local array_length = decoded_data[1]
		if type(array_length) ~= "number" then return end
		if array_length < 0 then return end

		callback(ply, unpack(decoded_data, 2, array_length + 1))
	end)
else
	checks = nil

	function netstream.Start(name, ...)
		if #name > 31 then
			error("netstream.Start name too long")
		end

		local array_length = select("#", ...)
		local encoded_data = encode_array({array_length, ...}, array_length + 1)

		local length = #encoded_data

		net.Start(netStreamSend)
			net.WriteString(name)
			net.WriteUInt(length, 16)
			net.WriteData(encoded_data, length)
		net.SendToServer()
	end

	function netstream.Hook(name, callback)
		receivers[name] = callback
	end

	net.Receive(netStreamSend, function(len)
		local compressed = net.ReadBool()
		local binary_data = net.ReadData((len - 1) / 8)

		if compressed then
			binary_data = decompress(binary_data)
			if not binary_data then return end
		end

		local decoded_data, err, err2 = decode(binary_data)
		if err ~= nil then
			sam.print("NetStream error: " .. err .. err2)
			return
		end

		local name = decoded_data[1]

		local callback = receivers[name]
		if not callback then return end

		callback(unpack(decoded_data, 3, decoded_data[2] + 2))
	end)
end

return netstream

--addons/admin_sam/lua/sam/command/arguments/rank.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

local is_good_rank = function(rank, arg, ply)
	if arg.check and not arg.check(rank, ply) then
		return false
	end
	return true
end

command.new_argument("rank")
	:OnExecute(function(arg, input, ply, _, result, i)
		if not input and arg.optional then
			result[i] = nil
			return
		end

		if not sam.ranks.is_rank(input) or not is_good_rank(input, arg, ply) then
			ply:sam_send_message("invalid", {
				S = arg.hint or "rank", S_2 = input
			})
			return false
		end

		result[i] = input
	end)

	:Menu(function(set_result, body, buttons, arg)
		local current_rank = arg.hint or "select rank"

		local ranks = buttons:Add("SAM.ComboBox")
		ranks:SetValue(current_rank)
		ranks:SetTall(25)

		function ranks:OnSelect(_, value)
			set_result(value)
			current_rank = value
		end

		function ranks:DoClick()
			if self:IsMenuOpen() then
				return self:CloseMenu()
			end

			self:Clear()
			self:SetValue(current_rank)

			for rank_name in SortedPairsByMemberValue(sam.ranks.get_ranks(), "immunity", true) do
				if is_good_rank(rank_name, arg, LocalPlayer()) then
					self:AddChoice(rank_name)
				end
			end

			self:OpenMenu()
		end

		return ranks
	end)

	:AutoComplete(function(arg, result, name)
		for rank_name in SortedPairsByMemberValue(sam.ranks.get_ranks(), "immunity", true) do
			if rank_name:lower():find(name, 1, true) and is_good_rank(rank_name, arg, LocalPlayer()) then
				table.insert(result, rank_name)
			end
		end
	end)
:End()
--addons/admin_sam/lua/sam/menu/tabs/config.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

local tabs = {}
if CLIENT then
	function config.add_tab(name, func, check, pos)
		local tab = {
			name = name,
			func = func,
			check = check,
			pos = pos
		}
		for k, v in ipairs(tabs) do
			if v.name == name then
				tabs[k] = tab
				return
			end
		end
		table.insert(tabs, tab)
	end
end

for _, f in ipairs(file.Find("sam/menu/tabs/config/*.lua", "LUA")) do
	sam.load_file("sam/menu/tabs/config/" .. f, "cl_")
end

if SERVER then return end

local SUI = sam.SUI
local GetColor = SUI.GetColor
local Line = sui.TDLib.LibClasses.Line

sam.menu.add_tab("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/config.png", function(column_sheet)
	local tab_body = column_sheet:Add("Panel")
	tab_body:Dock(FILL)
	tab_body:DockMargin(0, 1, 0, 0)

	do
		local title = tab_body:Add("SAM.Label")
		title:Dock(TOP)
		title:DockMargin(10, 10, 0, 0)
		title:SetFont(SAM_TAB_TITLE_FONT)
		title:SetText("Config")
		title:SetTextColor(GetColor("menu_tabs_title"))
		title:SizeToContents()

		local total = tab_body:Add("SAM.Label")
		total:Dock(TOP)
		total:DockMargin(10, 6, 0, 0)
		total:SetFont(SAM_TAB_DESC_FONT)
		total:SetText("Some settings may require a server restart")
		total:SetTextColor(GetColor("menu_tabs_title"))
		total:SetPos(10, SUI.Scale(40))
		total:SizeToContents()
	end

	local body = tab_body:Add("Panel")
	body:Dock(FILL)
	body:DockMargin(10, 5, 10, 10)

	Line(body, nil, 0, 0, 0, 10)

	local sheet = body:Add("SAM.PropertySheet")
	sheet:Dock(FILL)
	sheet:InvalidateParent(true)
	sheet:InvalidateLayout(true)

	local sheets = {}
	for _, v in SortedPairsByMemberValue(tabs, "pos") do
		sheets[v.name] = sheet:AddSheet(v.name, v.func)
	end

	local tab_scroller = sheet.tab_scroller:GetCanvas()
	function tab_body.Think()
		for _, v in ipairs(tabs) do
			local tab = sheets[v.name]
			if v.check and not v.check() then
				if tab:IsVisible() then
					tab:SetVisible(false)
					if sheet:GetActiveTab() == tab then
						sheet:SetActiveTab(sheet.tabs[1])
					end
					tab_scroller:InvalidateLayout()
				end
			elseif not tab:IsVisible() then
				tab:SetVisible(true)
				tab_scroller:InvalidateLayout()
			end
		end
	end

	return tab_body
end, function()
	return LocalPlayer():HasPermission("manage_config")
end, 5)
--addons/admin_sam/lua/sam/menu/tabs/ranks.lua:
if SAM_LOADED then return end
if SERVER then return end

local sam = sam
local SUI = sam.SUI

local GetColor = SUI.GetColor
local Line = sui.TDLib.LibClasses.Line
local AnimatedSetVisible = sui.TDLib.LibClasses.AnimatedSetVisible

local RANK_NAME = SUI.CreateFont("RankName", "Roboto Bold", 18)
local RANK_INFO = SUI.CreateFont("RankInfo", "Roboto Medium", 12)

local CREATE_RANK = SUI.CreateFont("CreateRank", "Roboto Bold", 16, 200)
local RANK_TITLE = SUI.CreateFont("RankTitle", "Roboto Bold", 20)

local rank_menu = function(rank, data)
	local valid = sui.valid_options()

	local imm, banlim
	if rank then
		imm, banlim = data.immunity, data.ban_limit
	end

	local edit_rank = vgui.Create("SAM.QueryBox")
	edit_rank:SetWide(470)
	edit_rank:SetTitle(rank and string.format("Edit Rank '%s'", rank) or "Create Rank")

	local new_name = rank
	if not sam.ranks.is_default_rank(rank) then
		local name = edit_rank:Add("SAM.LabelPanel")
		name:SetLabel("Rank Name")

		local entry = name:Add("SAM.TextEntry")
		entry:SetSize(210, 28)
		entry:SetNoBar(false)
		entry:SetPlaceholder("")
		entry:SetValue(rank or "")
		entry:SetCheck(function(_name)
			new_name = _name

			if _name == rank then return end
			if _name == "" or sam.ranks.is_rank(_name) then
				return false
			end
		end)

		valid.Add(entry)
	end

	local new_immunity = imm
	do
		local immunity = edit_rank:Add("SAM.LabelPanel")
		immunity:SetLabel("Immunity (2~99)")
		immunity:DockMargin(0, 5, 0, 0)

		local entry = immunity:Add("SAM.TextEntry")
		entry:SetSize(210, 28)
		entry:SetNumeric(true)
		entry:DisallowFloats(true)
		entry:DisallowNegative(true)
		entry:SetPlaceholder("")
		entry:SetValue(imm or "2")
		entry:SetCheck(function(_immunity)
			new_immunity = _immunity

			if _immunity == "" then
				return false
			end

			_immunity = tonumber(_immunity)
			new_immunity = _immunity
			if _immunity < 2 or _immunity > 99 then
				return false
			end
		end)

		valid.Add(entry)
	end

	local new_banlimit = banlim
	do
		local banlimit = edit_rank:Add("SAM.LabelPanel")
		banlimit:SetLabel("Ban Limit (1y 1mo 1w 1d 1h 1m)")
		banlimit:DockMargin(0, 5, 0, 0)

		local entry = banlimit:Add("SAM.TextEntry")
		entry:SetSize(210, 28)
		entry:SetNoBar(false)
		entry:SetPlaceholder("")
		entry:SetValue(banlim and sam.reverse_parse_length(banlim) or "2w")
		entry:SetCheck(function(_banlimit)
			new_banlimit = sam.parse_length(_banlimit)
			if not new_banlimit and _banlimit ~= banlim then
				return false
			end
		end)

		valid.Add(entry)
	end

	local inherit = rank and sam.ranks.get_rank(rank).inherit or "user"
	local new_inherit = inherit
	do
		local inherits_from = edit_rank:Add("SAM.LabelPanel")
		inherits_from:SetLabel("Inherits From")
		inherits_from:DockMargin(0, 5, 0, 0)

		local entry = inherits_from:Add("SAM.ComboBox")
		entry:SetSize(210, 28)
		entry:SetValue(inherit)

		for name in SortedPairsByMemberValue(sam.ranks.get_ranks(), "immunity", true) do
			if name ~= rank and not sam.ranks.inherits_from(name, rank) then
				entry:AddChoice(name)
			end
		end

		function entry:OnSelect(_, value)
			new_inherit = value
		end
	end


	edit_rank:Done()
	edit_rank.save:SetEnabled(true)
	edit_rank.save:SetText("SAVE")

	if rank then
		edit_rank:SetCallback(function()
			local to_run = {}

			if new_immunity ~= imm then
				table.insert(to_run, {"changerankimmunity", rank, new_immunity})
			end

			if new_banlimit ~= banlim then
				table.insert(to_run, {"changerankbanlimit", rank, new_banlimit})
			end

			if new_inherit ~= inherit then
				table.insert(to_run, {"changeinherit", rank, new_inherit})
			end

			if new_name ~= rank then
				table.insert(to_run, {"renamerank", rank, new_name})
			end
			sam.command.run_commands(to_run)
		end)
	else
		edit_rank:SetCallback(function()
			RunConsoleCommand("sam", "addrank", new_name, new_inherit, new_immunity, new_banlimit)
		end)
	end

	function edit_rank.save:Think()
		self:SetEnabled(valid.IsValid())
	end
end

sam.menu.add_tab("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/military_rank.png", function(column_sheet)
	local current_rank

	local parent = column_sheet:Add("Panel")
	parent:Dock(FILL)
	parent:DockMargin(0, 1, 0, 0)

	local title = parent:Add("SAM.Label")
	title:Dock(TOP)
	title:DockMargin(10, 10, 0, 0)
	title:SetFont(SAM_TAB_TITLE_FONT)
	title:SetText("Ranks")
	title:SetTextColor(GetColor("menu_tabs_title"))
	title:SizeToContents()

	local total = parent:Add("SAM.Label")
	total:Dock(TOP)
	total:DockMargin(10, 6, 0, 0)
	total:SetFont(SAM_TAB_DESC_FONT)
	total:SetText(table.Count(sam.ranks.get_ranks()) .. " total ranks")
	total:SetTextColor(GetColor("menu_tabs_title"))
	total:SizeToContents()

	local search_entry
	do
		local container = parent:Add("SAM.Panel")
		container:Dock(TOP)
		container:DockMargin(10, 6, 10, SUI.Scale(15))
		container:SetTall(30)

		search_entry = container:Add("SAM.TextEntry")
		search_entry:Dock(LEFT)
		search_entry:SetNoBar(true)
		search_entry:SetPlaceholder("Search...")
		search_entry:SetRadius(4)
		search_entry:SetWide(220)
	end

	local create_rank = parent:Add("SAM.Button")
	create_rank:SetFont(CREATE_RANK)
	create_rank:SetText("Create Rank")
	create_rank:Dock(BOTTOM)
	create_rank:DockMargin(10, 0, 10, 10)

	create_rank:On("DoClick", function()
		rank_menu()
	end)

	local right_body = parent:Add("Panel")
	right_body:Dock(RIGHT)
	right_body:DockMargin(0, 5, 10, 10)
	right_body:SetWide(0)
	right_body:SetZPos(-1)

	local rank_title = right_body:Add("SAM.Label")
	rank_title:Dock(TOP)
	rank_title:DockMargin(0, 0, 0, 5)
	rank_title:SetFont(RANK_TITLE)
	rank_title:SetTextColor(GetColor("menu_tabs_title"))

	local permissions_body = right_body:Add("SAM.CollapseCategory")
	permissions_body:Dock(FILL)
	permissions_body:GetCanvas():DockPadding(0, 0, 5, 0)

	local function refresh_access()
		if not IsValid(current_rank) then return end

		for k, v in ipairs(permissions_body.items) do
			AnimatedSetVisible(v.img, sam.ranks.has_permission(current_rank.name, v.name))
		end
	end

	for k, v in ipairs({"SAM.ChangedInheritRank", "SAM.RankPermissionGiven", "SAM.RankPermissionTaken"}) do
		hook.Add(v, "SAM.Menu.RefreshPermissions ", refresh_access)
	end

	local function refresh_permissions()
		permissions_body:GetCanvas():Clear()
		table.Empty(permissions_body.items)
		table.Empty(permissions_body.categories)

		local item_click = function(s)
			local rank = current_rank.name
			if not sam.ranks.has_permission(rank, s.name) then
				RunConsoleCommand("sam", "givepermission", rank, s.name)
			else
				RunConsoleCommand("sam", "takepermission", rank, s.name)
			end
		end

		for k, v in ipairs(sam.permissions.get()) do
			local item = permissions_body:add_item(v.name, v.category)
			item:SetContentAlignment(4)
			item:SetTextInset(6, 0)
			item:SizeToContentsY(SUI.Scale(10))
			item:SetZPos(k)
			item.name = v.name
			item.DoClick = item_click

			local img = item:Add("SAM.Image")
			img:Dock(RIGHT)
			img:DockMargin(4, 4, 4, 4)
			img:InvalidateParent(true)
			img:SetWide(img:GetTall())
			img:SetImageColor(Color(52, 161, 224))
			img:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/check_mark.png")

			item.img = img
		end
	end

	local limits_body

	do
		local permissions_search = right_body:Add("SAM.TextEntry")
		permissions_search:Dock(TOP)
		permissions_search:DockMargin(0, 0, 5, 10)
		permissions_search:SetNoBar(true)
		permissions_search:SetPlaceholder("Search...")
		permissions_search:SetRadius(4)
		permissions_search:SetTall(30)

		function permissions_search:OnValueChange(text)
			if limits_body and limits_body:IsVisible() then
				local children = limits_body:GetCanvas():GetChildren()
				for k, v in ipairs(children) do
					v:AnimatedSetVisible(v.title:find(text, nil, true) ~= nil)
				end
				limits_body:InvalidateLayout(true)
			else
				permissions_body:Search(text:lower())
			end
		end

		Line(right_body):SetZPos(2)
	end

	local function load_limits()
		if sam.limit_types then
			if limits_body then return end
		else
			if limits_body then
				limits_body:SetVisible(false)
				permissions_body:AnimatedSetVisible(true)
				limits_body:Remove()
				limits_body = nil
			end
			return
		end

		limits_body = right_body:Add("SAM.ScrollPanel")
		limits_body:Dock(FILL)
		limits_body:GetCanvas():DockPadding(0, 0, 5, 0)
		limits_body:SetVisible(false)

		local item_enter = function(s)
			if not IsValid(current_rank) then return end

			local rank = current_rank.name

			local limit = math.Clamp(s:GetValue(), -1, 1000)
			if limit ~= sam.ranks.get_limit(rank, s.limit_type) then
				RunConsoleCommand("sam", "changeranklimit", rank, s.limit_type, limit)
			else
				s:SetText(tostring(sam.ranks.get_limit(rank, s.limit_type)))
			end
		end

		local not_empty = function(s)
			return s and s ~= ""
		end

		local limit_values = {}
		for k, v in ipairs(sam.limit_types) do
			local immunity = limits_body:Add("SAM.LabelPanel")
			immunity:SetLabel(v)
			immunity:DockMargin(5, 0, 0, 5)

			local entry = immunity:Add("SAM.TextEntry")
			entry:SetSize(60, 26)
			entry:SetNumeric(true)
			entry:DisallowFloats(true)
			entry:SetPlaceholder("")
			entry:SetCheck(not_empty)
			entry.limit_type = v
			entry.OnEnter = item_enter

			table.insert(limit_values, entry)
		end

		function limits_body:Refresh()
			if not IsValid(current_rank) then return end

			local rank = current_rank.name
			for k, v in ipairs(limit_values) do
				v:SetValue(tostring(sam.ranks.get_limit(rank, v.limit_type)))
			end
		end

		local right_current_rank = right_body:Add("SAM.Button")
		right_current_rank:Dock(BOTTOM)
		right_current_rank:DockMargin(0, 5, 0, 0)
		right_current_rank:SetFont(CREATE_RANK)
		right_current_rank:SetText("Switch to Limits")
		right_current_rank:On("DoClick", function()
			limits_body:AnimatedToggleVisible()
			permissions_body:AnimatedToggleVisible()

			if permissions_body:AnimatedIsVisible() then
				right_current_rank:SetText("Switch to Limits")
			else
				right_current_rank:SetText("Switch to Permissions")
			end
		end)

		limits_body:On("OnRemove", function()
			right_current_rank:Remove()
		end)
		limits_body:Refresh()
	end

	local function refresh_all()
		timer.Create("SAM.Menu.Ranks.Refresh", 1, 1, function()
			load_limits()
			refresh_permissions()
			refresh_access()
		end)
	end

	sam.config.hook({"Restrictions.Limits"}, refresh_all)

	for k, v in ipairs({"SAM.AddedPermission", "SAM.PermissionModified", "SAM.RemovedPermission"}) do
		hook.Add(v, "SAM.Menu.RefreshPermissions", refresh_all)
	end

	local body = parent:Add("SAM.ScrollPanel")
	body:Dock(FILL)
	body:DockMargin(10, 0, 5, 10)
	body:SetVBarPadding(6)

	body:Line():SetZPos(-101)

	local select_rank = function(s)
		if not IsValid(s) then
			current_rank = nil
			right_body:SizeTo(0, -1, 0.3)
			return
		end

		if IsValid(current_rank) then
			current_rank.Selected = false

			if current_rank == s then
				current_rank = nil
				right_body:SizeTo(0, -1, 0.3)
				return
			end
		end

		s.Selected = true
		current_rank = s
		refresh_access()
		if limits_body then
			limits_body:Refresh()
		end
		right_body:SizeTo(SUI.Scale(300), -1, 0.3)

		rank_title:SetText(s.name)
		rank_title:SizeToContents()
	end

	local ranks = {}

	function search_entry:OnValueChange()
		local value = self:GetValue()
		for k, v in pairs(ranks) do
			local show = k:find(value, nil, true)
			show = show ~= nil
			v.line:AnimatedSetVisible(show)
			v:GetParent():AnimatedSetVisible(show)
		end
	end

	local add_rank = function(rank_name, data)
		if rank_name == "superadmin" then return end
		if not IsValid(body) then return end

		local line = body:Add("SAM.Panel")
		line:Dock(TOP)
		line:DockMargin(0, 0, 0, 10)
		line:SetTall(34)
		line:SetZPos(-data.immunity)
		line:InvalidateLayout(true)

		local container = line:Add("SAM.Button")
		container:Dock(FILL)
		container:DockMargin(0, 0, 5, 0)
		container:DockPadding(5, 5, 0, 5)
		container:SetText("")
		container:SetContained(false)
		container.name = rank_name

		ranks[rank_name] = container

		container:On("DoClick", select_rank)

		function container:DoRightClick()
			rank_name = container.name

			if rank_name == "user" then return end

			local dmenu = vgui.Create("SAM.Menu")
			dmenu:SetSize(w, h)
			dmenu:SetInternal(container)

			dmenu:AddOption("Edit Rank", function()
				rank_menu(rank_name, sam.ranks.get_rank(rank_name))
			end)

			if not sam.ranks.is_default_rank(rank_name) then
				dmenu:AddSpacer()

				dmenu:AddOption("Remove Rank", function()
					local remove_rank = vgui.Create("SAM.QueryBox")
					remove_rank:SetWide(350)

					local check = remove_rank:Add("SAM.Label")
					check:SetText("Are you sure that you want to remove '" .. rank_name .. "'?")
					check:SetFont("SAMLine")
					check:SetWrap(true)
					check:SetAutoStretchVertical(true)

					remove_rank:Done()
					remove_rank.save:SetEnabled(true)
					remove_rank.save:SetText("REMOVE")
					remove_rank.save:SetContained(false)
					remove_rank.save:SetColors(GetColor("query_box_cancel"), GetColor("query_box_cancel_text"))

					remove_rank.cancel:SetContained(true)
					remove_rank.cancel:SetColors()

					remove_rank:SetCallback(function()
						RunConsoleCommand("sam", "removerank", rank_name)
					end)
				end)
			end

			dmenu:Open()
			dmenu:SetPos(input.GetCursorPos())
		end

		do
			local name = container:Add("SAM.Label")
			name:Dock(TOP)
			name:DockMargin(0, 0, 0, 2)
			name:SetTextColor(GetColor("player_list_names"))
			name:SetFont(RANK_NAME)
			name:SetText(rank_name)
			name:SizeToContents()

			local immunity = container:Add("SAM.Label")
			immunity:Dock(TOP)
			immunity:SetTextColor(GetColor("player_list_steamid"))
			immunity:SetFont(RANK_INFO)
			immunity:SetText("Immunity: " .. data.immunity)
			immunity:SizeToContents()

			local banlimit = container:Add("SAM.Label")
			banlimit:Dock(TOP)
			banlimit:SetTextColor(GetColor("player_list_steamid"))
			banlimit:SetFont(RANK_INFO)
			banlimit:SetText("Ban limit: " .. sam.reverse_parse_length(sam.parse_length(data.ban_limit)))
			banlimit:SizeToContents()

			local inherit = container:Add("SAM.Label")
			inherit:Dock(TOP)
			inherit:SetTextColor(GetColor("player_list_steamid"))
			inherit:SetFont(RANK_INFO)
			inherit:SetText("Inherits from: " .. (sam.isstring(data.inherit) and data.inherit or "none"))
			inherit:SizeToContents()
		end

		container:InvalidateLayout(true)
		container:SizeToChildren(false, true)
		line:SizeToChildren(false, true)

		local _line = body:Line()
		_line:SetZPos(-data.immunity)

		container.line = _line
		container.data = data
	end

	for rank_name, v in pairs(sam.ranks.get_ranks()) do
		add_rank(rank_name, v)
	end

	hook.Add("SAM.AddedRank", "SAM.RefreshRanksList", function(name, rank)
		add_rank(name, rank)
	end)

	hook.Add("SAM.RemovedRank", "SAM.RefreshRanksList", function(name)
		local line = ranks[name]
		if not IsValid(line) then return end

		line.line:Remove()
		line:GetParent():Remove()
		ranks[name] = nil

		if line == current_rank then
			select_rank()
		end
	end)

	-- This is just better than caching panels for stuff that ain't gonna be called a lot
	hook.Add("SAM.RankNameChanged", "SAM.RefreshRanksList", function(name, new_name)
		local line = ranks[name]
		if not IsValid(line) then return end

		-- if current_rank == name then
		-- 	rank_name:SetText(new_name)
		-- end

		line:GetChildren()[1]:SetText(new_name)

		ranks[new_name], ranks[name] = line, nil
		line.name = new_name
	end)

	hook.Add("SAM.RankImmunityChanged", "SAM.RefreshRanksList", function(name, immunity)
		local line = ranks[name]
		if not IsValid(line) then return end

		line:GetChildren()[2]:SetText("Immunity: " .. immunity)
		line:GetParent():SetZPos(-immunity)

		-- SetZPos is kinda weird to deal with
		line.line:SetZPos(-immunity + 1)
		line.line:SetZPos(-immunity)
	end)

	hook.Add("SAM.RankBanLimitChanged", "SAM.RefreshRanksList", function(name, new_limit)
		local line = ranks[name]
		if IsValid(line) then
			line:GetChildren()[3]:SetText("Ban limit: " .. sam.reverse_parse_length(new_limit))
		end
	end)

	hook.Add("SAM.ChangedInheritRank", "SAM.RefreshRanksList", function(name, new_inherit)
		local line = ranks[name]
		if IsValid(line) then
			line:GetChildren()[4]:SetText("Inherits from: " .. new_inherit)
		end
	end)

	return parent
end, function()
	return LocalPlayer():HasPermission("manage_ranks")
end, 3)
--addons/admin_sam/lua/sam/modules/support_cami.lua:
if SAM_LOADED then return end

local ranks_loaded
if SERVER then
	ranks_loaded = sam.ranks.ranks_loaded()
else
	ranks_loaded = sam.ranks.get_ranks() ~= nil
end

do
	local load_ranks = function()
		for name, rank in pairs(sam.ranks.get_ranks()) do
			if not sam.ranks.is_default_rank(name) then
				CAMI.RegisterUsergroup({Name = name, Inherits = rank.inherit}, "SAM")
			end
		end
	end

	if ranks_loaded then
		load_ranks()
	else
		hook.Add("SAM.LoadedRanks", "SAM.CAMI.LoadRanksToCAMI", load_ranks)
	end
end

hook.Add("SAM.AddedRank", "SAM.CAMI.AddedRank", function(name, rank)
	if not sam.ranks.is_default_rank(name) then
		CAMI.RegisterUsergroup({Name = name, Inherits = rank.inherit}, "SAM")
	end
end)

hook.Add("SAM.RemovedRank", "SAM.CAMI.RemovedRank", function(name)
	CAMI.UnregisterUsergroup(name, "SAM")
end)

hook.Add("SAM.RankNameChanged", "SAM.CAMI.RankNameChanged", function(old, new)
	CAMI.UnregisterUsergroup(old, "SAM")
	CAMI.RegisterUsergroup({Name = new, Inherits = sam.ranks.get_rank(new).inherit}, "SAM")
end)

hook.Add("SAM.ChangedPlayerRank", "SAM.CAMI.ChangedPlayerRank", function(ply, new_rank, old_rank)
	CAMI.SignalUserGroupChanged(ply, old_rank, new_rank, "SAM")
end)

hook.Add("SAM.ChangedSteamIDRank", "SAM.CAMI.ChangedSteamIDRank", function(steamid, new_rank, old_rank)
	CAMI.SignalSteamIDUserGroupChanged(steamid, old_rank, new_rank, "SAM")
end)

----------------------------------------------------------------------------------------------------------------------------------------------------------

if SERVER then
	do
		local on_user_group_registered = function(rank, source)
			if source ~= "SAM" then
				sam.ranks.add_rank(rank.Name, sam.ranks.is_rank(rank.Inherits) and rank.Inherits or "user")
			end
		end

		local load_ranks = function()
			for _, rank in pairs(CAMI.GetUsergroups()) do
				on_user_group_registered(rank, "CAMI")
			end
			hook.Add("CAMI.OnUsergroupRegistered", "SAM.CAMI.OnUsergroupRegistered", on_user_group_registered)
		end

		if ranks_loaded then
			load_ranks()
		else
			hook.Add("SAM.LoadedRanks", "SAM.CAMI.LoadRanksFromCAMI", load_ranks)
		end
	end

	hook.Add("CAMI.OnUsergroupUnregistered", "SAM.CAMI.OnUsergroupUnregistered", function(rank, source)
		if source ~= "SAM" then
			sam.ranks.remove_rank(rank.Name)
		end
	end)

	hook.Add("CAMI.PlayerUsergroupChanged", "SAM.CAMI.PlayerUsergroupChanged", function(ply, _, new_rank, source)
		if ply and IsValid(ply) and source ~= "SAM" then
			sam.player.set_rank(ply, new_rank)
		end
	end)

	hook.Add("CAMI.SteamIDUsergroupChanged", "SAM.CAMI.SteamIDUsergroupChanged", function(steamid, _, new_rank, source)
		if sam.is_steamid(steamid) and source ~= "SAM" then
			sam.player.set_rank_id(steamid, new_rank)
		end
	end)
end

do
	local on_privilege_registered = function(privilege)
		sam.permissions.add(privilege.Name, "CAMI", privilege.MinAccess)
	end

	local load_privileges = function()
		for _, privilege in pairs(CAMI.GetPrivileges()) do
			on_privilege_registered(privilege)
		end
		hook.Add("CAMI.OnPrivilegeRegistered", "SAM.CAMI.OnPrivilegeRegistered", on_privilege_registered)
	end

	if ranks_loaded then
		load_privileges()
	else
		hook.Add("SAM.LoadedRanks", "SAM.CAMI.LoadPrivileges", load_privileges)
	end
end

hook.Add("CAMI.OnPrivilegeUnregistered", "SAM.CAMI.OnPrivilegeUnregistered", function(privilege)
	sam.permissions.remove(privilege.Name)
end)

hook.Add("CAMI.PlayerHasAccess", "SAM.CAMI.PlayerHasAccess", function(ply, privilege, callback, target)
	if sam.type(ply) ~= "Player" then return end

	local has_permission = ply:HasPermission(privilege)
	if sam.type(target) == "Player" then
		callback(has_permission and ply:CanTarget(target))
	else
		callback(has_permission)
	end

	return true
end)
--addons/joes_stuff/lua/autorun/sh_joe_base_autoload.lua:
JoeBase = JoeBase or {}

local mainfolder = "joe_base/"
-- sh files
for k,v in pairs(file.Find(mainfolder .. "sh_*", "LUA")) do
    include(mainfolder .. tostring(v))
    if SERVER then AddCSLuaFile(mainfolder .. tostring(v)) end
end
-- sv files
if SERVER then
    for k,v in pairs(file.Find(mainfolder .. "sv_*", "LUA")) do
        include(mainfolder .. tostring(v))
    end
end
-- cl files
for k,v in pairs(file.Find(mainfolder .. "cl_*", "LUA")) do
    if SERVER then AddCSLuaFile(mainfolder ..  tostring(v))
    else include(mainfolder .. tostring(v))
    end
end
--addons/aocrp_pixelui/lua/pixelui/core/cl_imgur.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local materials = {}

file.CreateDir("pixel")

function PIXEL.GetImgur(id, callback, useproxy, matSettings)
    if materials[id] then return callback(materials[id]) end

    if file.Exists("pixel/" .. id .. ".png", "DATA") then
        materials[id] = Material("../data/pixel/" .. id .. ".png", matSettings or "noclamp smooth mips")
        return callback(materials[id])
    end

    http.Fetch(useproxy and "https://proxy.duckduckgo.com/iu/?u=https://i.imgur.com" or "https://i.imgur.com/" .. id .. ".png",
        function(body, len, headers, code)
            if len > 2097152 then
                materials[id] = Material("nil")
                return callback(materials[id])
            end

            file.Write("pixel/" .. id .. ".png", body)
            materials[id] = Material("../data/pixel/" .. id .. ".png", matSettings or "noclamp smooth mips")

            return callback(materials[id])
        end,
        function(error)
            if useproxy then
                materials[id] = Material("nil")
                return callback(materials[id])
            end
            return PIXEL.GetImgur(id, callback, true)
        end
    )
end

--addons/aocrp_pixelui/lua/pixelui/drawing/cl_circle.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

do
    local materials = {
        "4c5f5nk", --8
        "mONPuyy", --16
        "icx1Qbq", --32
        "TpwrpKe", --64
        "E8QbV5i", --128
        "wAr5H1x", --256
        "g52zxtK", --512
        "9tHAUp6", --1024
        "XAYX2uH" --2048
    }

    local max = math.max
    function PIXEL.DrawCircle(x, y, w, h, col)
        local size = max(w, h)
        local id = materials[1]

        local curSize = 8
        for i = 1, #materials do
            if size <= curSize then break end
            id = materials[i + 1] or id
            curSize = curSize + curSize
        end

        PIXEL.DrawImgur(x, y, w, h, id, col)
    end
end

do
    local insert = table.insert
    local rad, sin, cos = math.rad, math.sin, math.cos

    function PIXEL.CreateCircle(x, y, ang, seg, pct, radius)
        local circle = {}

        insert(circle, {x = x, y = y})

        for i = 0, seg do
            local segAngle = rad(((i / seg) * -pct + ang))
            insert(circle, {x = x + sin(segAngle) * radius, y = y + cos(segAngle) * radius})
        end

        return circle
    end
end

local createCircle = PIXEL.CreateCircle
local drawPoly = surface.DrawPoly
function PIXEL.DrawCircleUncached(x, y, ang, seg, pct, radius)
    drawPoly(createCircle(x, y, ang, seg, pct, radius))
end
--addons/aocrp_pixelui/lua/pixelui/elements/cl_button.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

AccessorFunc(PANEL, "IsToggle", "IsToggle", FORCE_BOOL)
AccessorFunc(PANEL, "Toggle", "Toggle", FORCE_BOOL)

function PANEL:Init()
    self:SetIsToggle(false)
    self:SetToggle(false)
    self:SetMouseInputEnabled(true)

    self:SetCursor("hand")

    local btnSize = PIXEL.Scale(30)
    self:SetSize(btnSize, btnSize)

    self.NormalCol = PIXEL.CopyColor(PIXEL.Colors.Primary)
    self.HoverCol = PIXEL.OffsetColor(self.NormalCol, -15)
    self.ClickedCol = PIXEL.OffsetColor(self.NormalCol, 15)
    self.DisabledCol = PIXEL.CopyColor(PIXEL.Colors.Disabled)

    self.BackgroundCol = self.NormalCol
end

function PANEL:DoToggle(...)
    if not self:GetIsToggle() then return end

    self:SetToggle(not self:GetToggle())
    self:OnToggled(self:GetToggle(), ...)
end

local localPly
function PANEL:OnMousePressed(mouseCode)
    if not self:IsEnabled() then return end

    if not localPly then
        localPly = LocalPlayer()
    end

    if self:IsSelectable() and mouseCode == MOUSE_LEFT and (input.IsShiftDown() or input.IsControlDown()) and not (localPly:KeyDown(IN_FORWARD) or localPly:KeyDown(IN_BACK) or localPly:KeyDown(IN_MOVELEFT) or localPly:KeyDown(IN_MOVERIGHT)) then
        return self:StartBoxSelection()
    end

    self:MouseCapture(true)
    self.Depressed = true
    self:OnPressed(mouseCode)

    self:DragMousePress(mouseCode)
end

function PANEL:OnMouseReleased(mouseCode)
    self:MouseCapture(false)

    if not self:IsEnabled() then return end
    if not self.Depressed and dragndrop.m_DraggingMain ~= self then return end

    if self.Depressed then
        self.Depressed = nil
        self:OnReleased(mouseCode)
    end

    if self:DragMouseRelease(mouseCode) then
        return
    end

    if self:IsSelectable() and mouseCode == MOUSE_LEFT then
        local canvas = self:GetSelectionCanvas()
        if canvas then
            canvas:UnselectAll()
        end
    end

    if not self.Hovered then return end

    self.Depressed = true

    if mouseCode == MOUSE_RIGHT then
        self:DoRightClick()
    elseif mouseCode == MOUSE_LEFT then
        self:DoClick()
    elseif mouseCode == MOUSE_MIDDLE then
        self:DoMiddleClick()
    end

    self.Depressed = nil
end

function PANEL:PaintExtra(w, h) end

function PANEL:Paint(w, h)
    if not self:IsEnabled() then
        PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, 0, w, h, self.DisabledCol)
        self:PaintExtra(w, h)
        return
    end

    local bgCol = self.NormalCol

    if self:IsDown() or self:GetToggle() then
        bgCol = self.ClickedCol
    elseif self:IsHovered() then
        bgCol = self.HoverCol
    end

    self.BackgroundCol = PIXEL.LerpColor(FrameTime() * 12, self.BackgroundCol, bgCol)

    PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, 0, w, h, self.BackgroundCol)

    self:PaintExtra(w, h)
end

function PANEL:IsDown() return self.Depressed end
function PANEL:OnPressed(mouseCode) end
function PANEL:OnReleased(mouseCode) end
function PANEL:OnToggled(enabled) end
function PANEL:DoClick(...) self:DoToggle(...) end
function PANEL:DoRightClick() end
function PANEL:DoMiddleClick() end

vgui.Register("PIXEL.Button", PANEL, "Panel")
--addons/aocrp_pixelui/lua/pixelui/elements/cl_combo_box.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

Derma_Install_Convar_Functions(PANEL)

AccessorFunc(PANEL, "bSizeToText", "SizeToText", FORCE_BOOL)
AccessorFunc(PANEL, "m_bDoSort", "SortItems", FORCE_BOOL)

function PANEL:Init()
    self:SetSizeToText(true)

    self:Clear()

    self:SetTextAlign(TEXT_ALIGN_LEFT)
    self:SetSortItems(true)
end

function PANEL:PerformLayout(w, h)
    if not self:GetSizeToText() then return end
    self:SizeToText()
    self:SetWide(self:GetWide() + PIXEL.Scale(14))
end

function PANEL:Clear()
    self:SetText("")
    self.Choices = {}
    self.Data = {}
    self.ChoiceIcons = {}
    self.selected = nil

    if not self.Menu then return end
    self.Menu:Remove()
    self.Menu = nil
end

function PANEL:GetOptionText(id)
    return self.Choices[id]
end

function PANEL:GetOptionData(id)
    return self.Data[id]
end

function PANEL:GetOptionTextByData(data)
    for id, dat in pairs(self.Data) do
        if dat == data then
            return self:GetOptionText(id)
        end
    end

    for id, dat in pairs(self.Data) do
        if dat == tonumber(data) then
            return self:GetOptionText(id)
        end
    end

    return data
end

function PANEL:ChooseOption(value, index)
    if self.Menu then
        self.Menu:Remove()
        self.Menu = nil
    end

    self:SetText(value)

    self.selected = index
    self:OnSelect(index, value, self.Data[index])

    if not self:GetSizeToText() then return end
    self:SizeToText()
    self:SetWide(self:GetWide() + PIXEL.Scale(10))
end

function PANEL:ChooseOptionID(index)
    local value = self:GetOptionText(index)
    self:ChooseOption(value, index)
end

function PANEL:GetSelectedID()
    return self.selected
end

function PANEL:GetSelected()
    if not self.selected then return end
    return self:GetOptionText(self.selected), self:GetOptionData(self.selected)
end

function PANEL:OnSelect(index, value, data) end

function PANEL:AddChoice(value, data, select, icon)
    local i = table.insert(self.Choices, value)

    if data then
        self.Data[i] = data
    end

    if icon then
        self.ChoiceIcons[i] = icon
    end

    if select then
        self:ChooseOption(value, i)
    end

    return i
end

function PANEL:IsMenuOpen()
    return IsValid(self.Menu) and self.Menu:IsVisible()
end

function PANEL:OpenMenu(pControlOpener)
    if pControlOpener and pControlOpener == self.TextEntry then return end

    if #self.Choices == 0 then return end

    if IsValid(self.Menu) then
        self.Menu:Remove()
        self.Menu = nil
    end

    CloseDermaMenus()
    self.Menu = vgui.Create("PIXEL.Menu", self)

    if self:GetSortItems() then
        local sorted = {}
        for k, v in pairs(self.Choices) do
            local val = tostring(v)
            if string.len(val) > 1 and not tonumber(val) and val:StartWith("#") then val = language.GetPhrase(val:sub(2)) end
            table.insert(sorted, {id = k, data = v, label = val})
        end

        for k, v in SortedPairsByMemberValue(sorted, "label") do
            local option = self.Menu:AddOption(v.data, function() self:ChooseOption(v.data, v.id) end)
            if self.ChoiceIcons[v.id] then
                option:SetIcon(self.ChoiceIcons[v.id])
            end
        end
    else
        for k, v in pairs(self.Choices) do
            local option = self.Menu:AddOption(v, function() self:ChooseOption(v, k) end)
            if self.ChoiceIcons[k] then
                option:SetIcon(self.ChoiceIcons[k])
            end
        end
    end

    local x, y = self:LocalToScreen(0, self:GetTall())
    self.Menu:SetMinimumWidth(self:GetWide())
    self.Menu:Open(x, y + PIXEL.Scale(6), false, self)

    self:SetToggle(true)

    self.Menu.OnRemove = function(s)
        if not IsValid(self) then return end
        self:SetToggle(false)
    end
end

function PANEL:CloseMenu()
    if not IsValid(self.Menu) then return end
    self.Menu:Remove()
end

function PANEL:CheckConVarChanges()
    if not self.m_strConVar then return end

    local strValue = GetConVar(self.m_strConVar):GetString()
    if self.m_strConVarValue == strValue then return end

    self.m_strConVarValue = strValue
    self:SetValue(self:GetOptionTextByData(self.m_strConVarValue))
end

function PANEL:Think()
    self:CheckConVarChanges()
end

function PANEL:SetValue(strValue)
    self:SetText(strValue)
end

function PANEL:DoClick()
    if self:IsMenuOpen() then return self:CloseMenu() end
    self:OpenMenu()
end

function PANEL:PaintOver(w, h)
    local dropBtnSize = PIXEL.Scale(8)
    PIXEL.DrawImgur(w - dropBtnSize - PIXEL.Scale(8), h / 2 - dropBtnSize / 2, dropBtnSize, dropBtnSize, "30Bvuwi", PIXEL.Colors.PrimaryText)
end

vgui.Register("PIXEL.ComboBox", PANEL, "PIXEL.TextButton")
--addons/sit_everywhere/lua/autorun/sitanywhere.lua:
if SERVER then
	AddCSLuaFile("sitanywhere/client/sit.lua")
	AddCSLuaFile("sitanywhere/helpers.lua")
	include("sitanywhere/helpers.lua")
	include("sitanywhere/server/sit.lua")

	AddCSLuaFile("sitanywhere/ground_sit.lua")
	include("sitanywhere/server/unstuck.lua")
	include("sitanywhere/ground_sit.lua")
else
	include("sitanywhere/helpers.lua")
	include("sitanywhere/client/sit.lua")

	include("sitanywhere/ground_sit.lua")
end
--lua/autorun/venator_hdrenabler.lua:

--Created by Mattzi
--Oninoni helped too

if game.GetMap() ~= "rp_venator_extensive_v1_4" then
	return
end

if SERVER then 
	AddCSLuaFile()
end

if CLIENT then
	timer.Simple(5, function()
	local deathstar_mat_hdr_level = GetConVar( "mat_hdr_level" ):GetInt()
		if deathstar_mat_hdr_level < 2 then
			local HDRFrame = vgui.Create("DFrame")
			HDRFrame:SetSize(ScrW()*0.2, ScrH()*0.1)
			HDRFrame:Center()
			HDRFrame:MakePopup()
			HDRFrame:SetTitle("Change HDR Level?")
			HDRFrame:ShowCloseButton(false)
		
			local RichTextHDR = vgui.Create("RichText", HDRFrame)
			RichTextHDR:InsertColorChange(255,70,70,255)
			RichTextHDR:Dock(FILL)
			RichTextHDR:SetVerticalScrollbarEnabled(false)
			RichTextHDR:AppendText("This map only supports HDR. Enable it or live with this horrid mess.")
			function RichTextHDR:PerformLayout()
				self:SetFontInternal( "DermaLarge" )
			end
		
			local acceptbutton = vgui.Create("DButton", HDRFrame)
			acceptbutton:SetText("Activate and reconnect")
			acceptbutton:Dock(BOTTOM)
			acceptbutton.DoClick = function()
				RunConsoleCommand( "mat_hdr_level", "2" )
				timer.Simple( 3, function() RunConsoleCommand( "retry" ) end )
			end
		
			local leavebutton = vgui.Create("DButton", HDRFrame)
			leavebutton:SetText("I dont care")
			leavebutton:Dock(BOTTOM)
			leavebutton.DoClick = function()
				-- RunConsoleCommand("disconnect")
				HDRFrame:Remove()
			end
		end
	end)
end
--addons/vyhub-gmod/lua/vyhub/lib/json.lua:
VyHub.Lib.json = VyHub.Lib.json or {}

--
-- json.lua
--
-- Copyright (c) 2020 rxi
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files (the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
--

local json = { _version = "0.1.2" }

-------------------------------------------------------------------------------
-- Encode
-------------------------------------------------------------------------------

local encode

local escape_char_map = {
  [ "\\" ] = "\\",
  [ "\"" ] = "\"",
  [ "\b" ] = "b",
  [ "\f" ] = "f",
  [ "\n" ] = "n",
  [ "\r" ] = "r",
  [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
  escape_char_map_inv[v] = k
end


local function escape_char(c)
  return "\\" .. (escape_char_map[c] or string.format("u%04x", c:byte()))
end


local function encode_nil(val)
  return "null"
end


local function encode_table(val, stack)
  local res = {}
  stack = stack or {}

  -- Circular reference?
  if stack[val] then error("circular reference") end

  stack[val] = true

  if rawget(val, 1) ~= nil or next(val) == nil then
    -- Treat as array -- check keys are valid and it is not sparse
    local n = 0
    for k in pairs(val) do
      if type(k) ~= "number" then
        error("invalid table: mixed or invalid key types")
      end
      n = n + 1
    end
    if n ~= #val then
      error("invalid table: sparse array")
    end
    -- Encode
    for i, v in ipairs(val) do
      table.insert(res, encode(v, stack))
    end
    stack[val] = nil
    return "[" .. table.concat(res, ",") .. "]"

  else
    -- Treat as an object
    for k, v in pairs(val) do
      if type(k) ~= "string" then
        error("invalid table: mixed or invalid key types")
      end
      table.insert(res, encode(k, stack) .. ":" .. encode(v, stack))
    end
    stack[val] = nil
    return "{" .. table.concat(res, ",") .. "}"
  end
end


local function encode_string(val)
  return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
end


local function encode_number(val)
  -- Check for NaN, -inf and inf
  if val ~= val or val <= -math.huge or val >= math.huge then
    error("unexpected number value '" .. tostring(val) .. "'")
  end
  return string.format("%.14g", val)
end


local type_func_map = {
  [ "nil"     ] = encode_nil,
  [ "table"   ] = encode_table,
  [ "string"  ] = encode_string,
  [ "number"  ] = encode_number,
  [ "boolean" ] = tostring,
}


encode = function(val, stack)
  local t = type(val)
  local f = type_func_map[t]
  if f then
    return f(val, stack)
  end
  error("unexpected type '" .. t .. "'")
end


function json.encode(val)
  return ( encode(val) )
end


-------------------------------------------------------------------------------
-- Decode
-------------------------------------------------------------------------------

local parse

local function create_set(...)
  local res = {}
  for i = 1, select("#", ...) do
    res[ select(i, ...) ] = true
  end
  return res
end

local space_chars   = create_set(" ", "\t", "\r", "\n")
local delim_chars   = create_set(" ", "\t", "\r", "\n", "]", "}", ",")
local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")
local literals      = create_set("true", "false", "null")

local literal_map = {
  [ "true"  ] = true,
  [ "false" ] = false,
  [ "null"  ] = nil,
}


local function next_char(str, idx, set, negate)
  for i = idx, #str do
    if set[str:sub(i, i)] ~= negate then
      return i
    end
  end
  return #str + 1
end


local function decode_error(str, idx, msg)
  local line_count = 1
  local col_count = 1
  for i = 1, idx - 1 do
    col_count = col_count + 1
    if str:sub(i, i) == "\n" then
      line_count = line_count + 1
      col_count = 1
    end
  end
  error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
  -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
  local f = math.floor
  if n <= 0x7f then
    return string.char(n)
  elseif n <= 0x7ff then
    return string.char(f(n / 64) + 192, n % 64 + 128)
  elseif n <= 0xffff then
    return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
  elseif n <= 0x10ffff then
    return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                       f(n % 4096 / 64) + 128, n % 64 + 128)
  end
  error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
  local n1 = tonumber( s:sub(1, 4),  16 )
  local n2 = tonumber( s:sub(7, 10), 16 )
   -- Surrogate pair?
  if n2 then
    return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
  else
    return codepoint_to_utf8(n1)
  end
end


local function parse_string(str, i)
  local res = ""
  local j = i + 1
  local k = j

  while j <= #str do
    local x = str:byte(j)

    if x < 32 then
      decode_error(str, j, "control character in string")

    elseif x == 92 then -- `\`: Escape
      res = res .. str:sub(k, j - 1)
      j = j + 1
      local c = str:sub(j, j)
      if c == "u" then
        local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                 or str:match("^%x%x%x%x", j + 1)
                 or decode_error(str, j - 1, "invalid unicode escape in string")
        res = res .. parse_unicode_escape(hex)
        j = j + #hex
      else
        if not escape_chars[c] then
          decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
        end
        res = res .. escape_char_map_inv[c]
      end
      k = j + 1

    elseif x == 34 then -- `"`: End of string
      res = res .. str:sub(k, j - 1)
      return res, j + 1
    end

    j = j + 1
  end

  decode_error(str, i, "expected closing quote for string")
end


local function parse_number(str, i)
  local x = next_char(str, i, delim_chars)
  local s = str:sub(i, x - 1)
  local n = tonumber(s)
  if not n then
    decode_error(str, i, "invalid number '" .. s .. "'")
  end
  return n, x
end


local function parse_literal(str, i)
  local x = next_char(str, i, delim_chars)
  local word = str:sub(i, x - 1)
  if not literals[word] then
    decode_error(str, i, "invalid literal '" .. word .. "'")
  end
  return literal_map[word], x
end


local function parse_array(str, i)
  local res = {}
  local n = 1
  i = i + 1
  while 1 do
    local x
    i = next_char(str, i, space_chars, true)
    -- Empty / end of array?
    if str:sub(i, i) == "]" then
      i = i + 1
      break
    end
    -- Read token
    x, i = parse(str, i)
    res[n] = x
    n = n + 1
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "]" then break end
    if chr ~= "," then decode_error(str, i, "expected ']' or ','") end
  end
  return res, i
end


local function parse_object(str, i)
  local res = {}
  i = i + 1
  while 1 do
    local key, val
    i = next_char(str, i, space_chars, true)
    -- Empty / end of object?
    if str:sub(i, i) == "}" then
      i = i + 1
      break
    end
    -- Read key
    if str:sub(i, i) ~= '"' then
      decode_error(str, i, "expected string for key")
    end
    key, i = parse(str, i)
    -- Read ':' delimiter
    i = next_char(str, i, space_chars, true)
    if str:sub(i, i) ~= ":" then
      decode_error(str, i, "expected ':' after key")
    end
    i = next_char(str, i + 1, space_chars, true)
    -- Read value
    val, i = parse(str, i)
    -- Set
    res[key] = val
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "}" then break end
    if chr ~= "," then decode_error(str, i, "expected '}' or ','") end
  end
  return res, i
end


local char_func_map = {
  [ '"' ] = parse_string,
  [ "0" ] = parse_number,
  [ "1" ] = parse_number,
  [ "2" ] = parse_number,
  [ "3" ] = parse_number,
  [ "4" ] = parse_number,
  [ "5" ] = parse_number,
  [ "6" ] = parse_number,
  [ "7" ] = parse_number,
  [ "8" ] = parse_number,
  [ "9" ] = parse_number,
  [ "-" ] = parse_number,
  [ "t" ] = parse_literal,
  [ "f" ] = parse_literal,
  [ "n" ] = parse_literal,
  [ "[" ] = parse_array,
  [ "{" ] = parse_object,
}


parse = function(str, idx)
  local chr = str:sub(idx, idx)
  local f = char_func_map[chr]
  if f then
    return f(str, idx)
  end
  decode_error(str, idx, "unexpected character '" .. chr .. "'")
end


function json.decode(str)
  if type(str) ~= "string" then
    error("expected argument of type string, got " .. type(str))
  end
  local res, idx = parse(str, next_char(str, 1, space_chars, true))
  idx = next_char(str, idx, space_chars, true)
  if idx <= #str then
    decode_error(str, idx, "trailing garbage")
  end
  return res
end

VyHub.Lib.json = json
--lua/wos/anim_extension/holdtypes/g_combo2.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "g_combo2"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "combo2" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "combo2" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--addons/z_anticrash_v1.4.6/lua/z_anticrash/settings.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

// SETTINGS
SH_ANTICRASH.SETTINGS = {}

// ADMINS
SH_ANTICRASH.SETTINGS.ADMINS = { -- Ranks that have access to the menu and its commands
	["superadmin"] = {"stats","users","global"}, -- Rank needs to be lowercase!
	["admin"] = {"stats","users","global"}, -- ["rank name"] = { permissions },
	["moderator"] = {"stats","users"},
}

// VARIOUS
SH_ANTICRASH.SETTINGS.SYSTEMLANG = "EN" -- The language of server console messages (this is automatically detected for players)

SH_ANTICRASH.SETTINGS.REMHIGHCOLENTITIES = true -- Automatically remove entities that have dangerous collision counts
SH_ANTICRASH.SETTINGS.COLLISIONINTENSITY = 250 -- Amount of collisions within 0.5 seconds before the entity is considered dangerous
SH_ANTICRASH.SETTINGS.HIGHCOLENTBLACKLIST = { -- Entities that will not be removed when exceeding collision intensity
	["prop_ragdoll"] = true, -- Entity class name
}

SH_ANTICRASH.SETTINGS.NOCOLLISIONSAMEOWNER = true -- Disable collisions only between entities owned by the same player
SH_ANTICRASH.SETTINGS.NOCOLLISIONENTITIES = { -- Entities that will never collide with each other
	["prop_vehicle_jeep"] = true,
	["prop_vehicle_airboat"] = true,
}

SH_ANTICRASH.SETTINGS.BLOCKEDENTITIES = { -- Entities that can't be created by any means
	["sent_ball"] = true, // Balls can be used to create instant lag, and give the player infinite HP
	["phys_magnet"] = true, // Magnets can bypass entity limit and can be used to seg fault crash the server
}

SH_ANTICRASH.SETTINGS.FIXNPCSEGMENTATIONCRASH = true -- Block faulty npcs from being spawn (can cause seg fault)
SH_ANTICRASH.SETTINGS.BLOCKROPESPAMMING = true -- Block ropes from being connected to the world
SH_ANTICRASH.SETTINGS.BLOCKSPAMMERS = false -- Block spammers by adding a small delay between spawning entities and toolgunning
SH_ANTICRASH.SETTINGS.BLOCKSPAMMERDELAY = 0.3 -- Delay in seconds between spawning entities and toolgunning

SH_ANTICRASH.SETTINGS.BLOCKINVALIDMODELS = true -- Block unprecached/error models
SH_ANTICRASH.SETTINGS.FREEZEOBJECTSONSPAWN = false -- Freeze objects when spawned
SH_ANTICRASH.SETTINGS.GHOSTOBJECTSONSPAWN = false -- Ghost objects when spawned
SH_ANTICRASH.SETTINGS.GHOSTOBJECTSONPICKUP = true -- Ghost objects when picked up

SH_ANTICRASH.SETTINGS.AUTOFREEZE = false -- Freeze all entities every X minutes
SH_ANTICRASH.SETTINGS.AUTOFREEZEDELAY = 10 -- Delay between freezes in minutes
SH_ANTICRASH.SETTINGS.FREEZEVEHICLES = false -- Should vehicles be frozen?
SH_ANTICRASH.SETTINGS.FREEZEALLDELAY = true -- Should unfreeze all be delayed for large contraptions?
SH_ANTICRASH.SETTINGS.FREEZEONDROP = false -- Should an entity be frozen when let go by the physgun?
SH_ANTICRASH.SETTINGS.FREEZEBLACKLIST = { -- Entities that should never be frozen by any means
	["example_classname"] = true, -- Entity class name
}
SH_ANTICRASH.SETTINGS.FREEZEBLACKLISTREG = {"example_"} -- Same as above but compares using the start of the class name

SH_ANTICRASH.SETTINGS.PHYSPERFMODE = true -- Reduces phys calculation impact on the server. (some mods like sligwolfs trains will break when this is enabled)
 
// Exploits
SH_ANTICRASH.SETTINGS.EXPLOITS = {}
SH_ANTICRASH.SETTINGS.EXPLOITS.CHATCLEAR = true -- Patch the chat clear exploit
SH_ANTICRASH.SETTINGS.EXPLOITS.CHATCLEARKICK = true -- Kick repeating offenders
SH_ANTICRASH.SETTINGS.EXPLOITS.CHATCLEARKICKAMOUNT = 5 -- Kick after X
SH_ANTICRASH.SETTINGS.EXPLOITS.NETRATELIMITER = true -- Enable netrate limiting

// Graph (menu)
SH_ANTICRASH.SETTINGS.GRAPH = {}
SH_ANTICRASH.SETTINGS.GRAPH.UPDATEDELAY = 0.5 -- Delay between graph updates in seconds (lower = less performant)
SH_ANTICRASH.SETTINGS.GRAPH.TIMEWINDOW = 60 -- Timewindow of the graph
SH_ANTICRASH.SETTINGS.GRAPH.ALWAYSUPDATE = false -- Update graph data even when the menu is closed (smoother, less performant)

SH_ANTICRASH.SETTINGS.GRAPH.SCALE = {}
SH_ANTICRASH.SETTINGS.GRAPH.SCALE.MAXPROPS = 1000 -- Estimate of props before the server start lagging (if value = -1 then "sbox_maxprops" x playercount is used)
SH_ANTICRASH.SETTINGS.GRAPH.SCALE.MAXNPCS = 150 -- Estimate of nps before the server starts lagging
SH_ANTICRASH.SETTINGS.GRAPH.SCALE.MAXVEHICLES = 100 -- Estimate of vehicles that are being driven before the server start lagging

// Auto Cleaner (client side)
SH_ANTICRASH.SETTINGS.CLEANER = {}
SH_ANTICRASH.SETTINGS.CLEANER.ENABLE = true
SH_ANTICRASH.SETTINGS.CLEANER.DELAY = 600 -- Delay in seconds between cleaning
SH_ANTICRASH.SETTINGS.CLEANER.CMDS = { -- Commands/Functions that the cleaner should run
	"r_cleardecals",
	"stopsound",
	game.RemoveRagdolls
}

// Lag Fix Measures
SH_ANTICRASH.SETTINGS.LAG = {}
SH_ANTICRASH.SETTINGS.LAG.Delay = 3 -- Amount of time in seconds before the lag should be fixed (higher number = less likable to recover)
SH_ANTICRASH.SETTINGS.LAG.CLEANMAP = false -- Reset the map completely (Entities,Decals,Gibs,Effects,NPC's,...)
SH_ANTICRASH.SETTINGS.LAG.REMOVEENTS = false -- Remove all player created entities
SH_ANTICRASH.SETTINGS.LAG.FREEZEENTS = true -- Freeze all player created entities
SH_ANTICRASH.SETTINGS.LAG.NOCOLLIDEENTS = true -- No Collide all ents created by the same player

SH_ANTICRASH.SETTINGS.LAG.REVERTCHANGES = true -- Remove all entities created X amount of minutes before the server lag
SH_ANTICRASH.SETTINGS.LAG.REVERTCHANGESTIME = 5 -- All entities placed in the last X amount of minutes will be removed

SH_ANTICRASH.SETTINGS.LAG.STUCK = 3 -- Amount of lag fixes before the lag is considered stuck
SH_ANTICRASH.SETTINGS.LAG.STUCKTIME = 120 -- Time window for the lag stuck in seconds
SH_ANTICRASH.SETTINGS.LAG.STUCKCLEANMAP = true -- Should the map be reset if the lag is stuck

SH_ANTICRASH.SETTINGS.CRASHOFFENDERTIMEWINDOW = 3 -- Time window in seconds to search for offenders before the anti-lag measures kick in

// Crazy Physics
SH_ANTICRASH.SETTINGS.CRAZYPHYSICS = {}
SH_ANTICRASH.SETTINGS.CRAZYPHYSICS.FREEZE = true -- Freeze entities with crazy physics
SH_ANTICRASH.SETTINGS.CRAZYPHYSICS.REMOVEAFTERFREEZE = true -- Remove entities that have been frozen before
SH_ANTICRASH.SETTINGS.CRAZYPHYSICS.REMOVEAFTERFREEZENUM = 1 -- After how many tries should the entity be removed?

// Out Of Bounds
SH_ANTICRASH.SETTINGS.OUTOFBOUNDS = {}
SH_ANTICRASH.SETTINGS.OUTOFBOUNDS.REMOVE = true -- Remove out of bounds entities
SH_ANTICRASH.SETTINGS.OUTOFBOUNDS.DELAY = 60 -- Delay in seconds to check for out of bounds entities
SH_ANTICRASH.SETTINGS.OUTOFBOUNDS.BLACKLIST = { -- Entities that will not be removed when out of bounds
	["keyframe_rope"] = true,
	["player"] = true,
	["predicted_viewmodel"] = true,
	["physgun_beam"] = true,
	["gmod_hands"] = true,
	["manipulate_bone"] = true,
	["phys_constraintsystem"] = true,
	["prop_door_rotating"] = true,
	["phys_bone_follower"] = true,
	["logic_auto"] = true,
	["shadow_control"] = true,
	["trigger_teleport"] = true,
	["trigger_hurt"] = true,
	["player_manager"] = true,
	["scene_manager"] = true,
	["instanced_scripted_scene"] = true,
	["gmod_sw_wheel"] = true,
    ["turret_eweb"] = true,
    ["laat_hatch"] = true,
    ["laat_rocketlauncher"] = true
}
SH_ANTICRASH.SETTINGS.OUTOFBOUNDS.BLACKLISTREG = {"prop_","func_","env_","info_","phys_", "lvs_", "sheld_", "bkeypads_", "shield_"} -- Same as above but compares using the start of the class name

// Workshop Dupes
SH_ANTICRASH.SETTINGS.DUPES = {}
SH_ANTICRASH.SETTINGS.DUPES.ENABLE = true -- Can players spawn workshop dupes?
SH_ANTICRASH.SETTINGS.DUPES.GHOST = false -- Ghost entities when spawned
SH_ANTICRASH.SETTINGS.DUPES.FREEZE = true -- Freeze all entities when spawned
SH_ANTICRASH.SETTINGS.DUPES.NOCOLLIDE = true -- No Collide all entities when spawned
SH_ANTICRASH.SETTINGS.DUPES.REPLACEINVALIDMODELS = true -- Prevents dupes with error models
SH_ANTICRASH.SETTINGS.DUPES.INVALIDMODELREPLACEMENT = "models/props_junk/PopCan01a.mdl" -- Replaces errors with this model if REPLACEINVALIDMODELS is enabled
SH_ANTICRASH.SETTINGS.DUPES.SIZELIMITPROPSONLY = false -- Should only props be included in the size limit? (e.g no thrusters, lamps, wheels, ...)
SH_ANTICRASH.SETTINGS.DUPES.SIZELIMIT = 200 -- Limit the amount of entities a dupe can have
SH_ANTICRASH.SETTINGS.DUPES.ROPELIMIT = 100 -- Limits the amount of ropes a dupe can have

// Advanced Duplicator
SH_ANTICRASH.SETTINGS.ADVDUPES = {}
SH_ANTICRASH.SETTINGS.ADVDUPES.ENABLE = true -- Can players spawn adv dupes?
SH_ANTICRASH.SETTINGS.ADVDUPES.GHOST = false -- Ghost entities when spawned
SH_ANTICRASH.SETTINGS.ADVDUPES.FREEZE = true -- Freeze all entities when spawned
SH_ANTICRASH.SETTINGS.ADVDUPES.NOCOLLIDE = true -- No Collide all entities when spawned
SH_ANTICRASH.SETTINGS.ADVDUPES.REPLACEINVALIDMODELS = true -- Prevents dupes with error models
SH_ANTICRASH.SETTINGS.ADVDUPES.INVALIDMODELREPLACEMENT = "models/props_junk/PopCan01a.mdl" -- Replaces errors with this model if REPLACEINVALIDMODELS is enabled
SH_ANTICRASH.SETTINGS.ADVDUPES.CONTRAPTIONSPAWNER = false -- Enable contraption spawner? (Can be used to easily crash a server)
SH_ANTICRASH.SETTINGS.ADVDUPES.SIZELIMITPROPSONLY = false -- Should only props be included in the size limit? (e.g no thrusters, lamps, wheels, ...)
SH_ANTICRASH.SETTINGS.ADVDUPES.SIZELIMIT = 200 -- Limit the amount of entities a dupe can have
SH_ANTICRASH.SETTINGS.ADVDUPES.ROPELIMIT = 100 -- Limits the amount of ropes a dupe can have

// DarkRP
SH_ANTICRASH.SETTINGS.DARKRP = {}
SH_ANTICRASH.SETTINGS.DARKRP.AFFECTF4ENTITIES = false -- Should entities spawned from the f4 menu be affected by the anti-crash?
SH_ANTICRASH.SETTINGS.DARKRP.F4SPAWNHOOKS = { -- The entities in these hooks will be affected
	"playerBoughtAmmo",
	"playerBoughtCustomEntity",
	"playerBoughtCustomVehicle",
	"playerBoughtDoor",
	"playerBoughtFood",
	"playerBoughtPistol",
	"playerBoughtShipment",
	"playerBoughtVehicle",
}
--addons/z_anticrash_v1.4.6/lua/z_anticrash/client/cl_cleaner.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

local nextCleanTime = SH_ANTICRASH.SETTINGS.CLEANER.DELAY

local function AutoCleaner()

	if !SH_ANTICRASH.SETTINGS.CLEANER.ENABLE then return end

    if nextCleanTime < CurTime() then
		
		for i=1, #SH_ANTICRASH.SETTINGS.CLEANER.CMDS do
			
			local cmd = SH_ANTICRASH.SETTINGS.CLEANER.CMDS[i]
			
			if isstring(cmd) then
		
				RunConsoleCommand(cmd)
				
			else
			
				cmd()
				
			end
			
		end
		
        nextCleanTime = CurTime() + SH_ANTICRASH.SETTINGS.CLEANER.DELAY
		
    end
	
end
hook.Add("Think", "z_anticrash_AutoCleaner", AutoCleaner)
--addons/z_anticrash_v1.4.6/lua/z_anticrash/client/cl_userdata.lua:

CL_ANTICRASH.USERDATA = {}

CL_ANTICRASH.USERDATA.COL = {
	ENTITIES = SH_ANTICRASH.VARS.COLOR.LIGHTYDARK,
	SPAWNEDENTS = SH_ANTICRASH.VARS.COLOR.LIGHTYDARK,
	PROPS = SH_ANTICRASH.VARS.COLOR.LIGHTYDARK,
	CONSTRAINTS = SH_ANTICRASH.VARS.COLOR.LIGHTYDARK,
}

function CL_ANTICRASH.USERDATA.GetEntityCount(ply)
	
	local entTbl = ents.GetAll()
	local entCount = 0
	
	for i=1, #entTbl do
		
		local ent = entTbl[i]
		
		if ent:z_anticrashGetCreator() == ply then
			entCount = entCount + 1
		end
	
	end
			
	return entCount
			
end

function CL_ANTICRASH.USERDATA.GetSpawnedEntitiesCount(ply)
	return ply:z_anticrashGetSpawnCount()
end

function CL_ANTICRASH.USERDATA.GetPropCount(ply)

	local entTbl = ents.GetAll()
	local propCount = 0
	
	for i=1, #entTbl do
		
		local ent = entTbl[i]
		local class = ent:GetClass()
		
		if ent:z_anticrashGetCreator() == ply and !ent:IsVehicle() and string.StartWith(class, "prop_") then
			propCount = propCount + 1
		end
	
	end
			
	return propCount

end

function CL_ANTICRASH.USERDATA.GetConstraintCount(ply)
	return ply:z_anticrashGetConstraintCount()
end

--addons/z_anticrash_v1.4.6/lua/z_anticrash/panels/p_extra.lua:
local tex_corner8	= surface.GetTextureID( "gui/corner8" )
local tex_corner16	= surface.GetTextureID( "gui/corner16" )
local tex_corner32	= surface.GetTextureID( "gui/corner32" )
local tex_corner64	= surface.GetTextureID( "gui/corner64" )
local tex_corner512	= surface.GetTextureID( "gui/corner512" )

function CL_ANTICRASH.RoundedTopRect(bordersize, x, y, w, h, color)
	
	if color == nil then return end

	surface.SetDrawColor( color )

	-- Do not waste performance if they don't want rounded corners
	if ( bordersize <= 0 ) then
		surface.DrawRect( x, y, w, h )
		return
	end

	x = math.Round( x )
	y = math.Round( y )
	w = math.Round( w )
	h = math.Round( h )
	bordersize = math.min( math.Round( bordersize ), math.floor( w / 2 ) )

	-- Draw lines between corners
	
	-- Left to right ( top )
	surface.DrawRect( x+bordersize, y, w-bordersize*2, bordersize )
	-- Right to bottom
	surface.DrawRect( x+w-bordersize, y+bordersize, bordersize, h-bordersize )
	-- Left to bottom  
	surface.DrawRect( x, y+bordersize, bordersize, h-bordersize )
	-- Fill gap
	surface.DrawRect( x+bordersize, y, w-bordersize*2, h )

	-- Draw corners
	local tex = tex_corner8
	if ( bordersize > 8 ) then tex = tex_corner16 end
	if ( bordersize > 16 ) then tex = tex_corner32 end
	if ( bordersize > 32 ) then tex = tex_corner64 end
	if ( bordersize > 64 ) then tex = tex_corner512 end

	-- Top corners
	surface.SetTexture( tex )
	surface.DrawTexturedRectUV( x, y, bordersize, bordersize, 0, 0, 1, 1 )
	surface.DrawTexturedRectUV( x + w - bordersize, y, bordersize, bordersize, 1, 0, 0, 1 )

end

function CL_ANTICRASH.RoundedOutlinedRect(bordersize, x, y, w, h, color)
	
	if color == nil then return end

	surface.SetDrawColor( color )

	-- Do not waste performance if they don't want rounded corners
	if ( bordersize <= 0 ) then
		surface.DrawRect( x, y, w, h )
		return
	end

	x = math.Round( x )
	y = math.Round( y )
	w = math.Round( w )
	h = math.Round( h )
	bordersize = math.min( math.Round( bordersize ), math.floor( w / 2 ) )

	-- Draw lines between corners
	
	-- Left to right ( top )
	surface.DrawRect( x+bordersize, y, w-bordersize*2, bordersize )
	-- Left to right ( bottom ) 
	surface.DrawRect( x+bordersize, y+h-bordersize, w-bordersize*2, bordersize )
	-- Right to bottom
	surface.DrawRect( x+w-bordersize, y+bordersize, bordersize, h-bordersize*2 )
	-- Left to bottom  
	surface.DrawRect( x, y+bordersize, bordersize, h-bordersize*2 )

	-- Draw corners
	local tex = tex_corner8
	if ( bordersize > 8 ) then tex = tex_corner16 end
	if ( bordersize > 16 ) then tex = tex_corner32 end
	if ( bordersize > 32 ) then tex = tex_corner64 end
	if ( bordersize > 64 ) then tex = tex_corner512 end

	surface.SetTexture( tex )
	surface.DrawTexturedRectUV( x, y, bordersize, bordersize, 0, 0, 1, 1 )
	surface.DrawTexturedRectUV( x + w - bordersize, y, bordersize, bordersize, 1, 0, 0, 1 )
	surface.DrawTexturedRectUV( x, y + h -bordersize, bordersize, bordersize, 0, 1, 1, 0 )
	surface.DrawTexturedRectUV( x + w - bordersize, y + h - bordersize, bordersize, bordersize, 1, 1, 0, 0 )

end
--addons/wos-passiveevent-ageo/lua/wos/pes/loader/loader.lua:
wOS = wOS || {}
wOS.PES = wOS.PES || {}

if SERVER then
    //TEMPP RRESOURCE ADD TTILL ALL OTHHER ICONSS ARRE REAADY
    resource.AddSingleFile( "materials/wos/pes/bg.png" )
end

local base_dir = "wos/pes"

if SERVER then
    AddCSLuaFile( base_dir .. "/config/general/sh_config.lua")
	AddCSLuaFile( base_dir .. "/config/general/sh_permissions.lua")
    include( base_dir .. "/config/general/sv_config.lua" )
end

include( base_dir .. "/config/general/sh_config.lua")
include( base_dir .. "/config/general/sh_permissions.lua")

if SERVER then

	AddCSLuaFile( base_dir .. "/core/sh_sfs_extern.lua")

    AddCSLuaFile( base_dir .. "/vgui/wos_nodebackground.lua" )
    AddCSLuaFile( base_dir .. "/vgui/wos_node.lua" )
	AddCSLuaFile( base_dir .. "/vgui/wos_viewnodes.lua")
	AddCSLuaFile( base_dir .. "/vgui/wos_calendar.lua")
	AddCSLuaFile( base_dir .. "/vgui/wos_datacopy_editor.lua")

    AddCSLuaFile( base_dir .. "/core/sh_mod_mount.lua")
    AddCSLuaFile( base_dir .. "/core/sh_var_mount.lua")

    AddCSLuaFile( base_dir .. "/core/cl_core.lua")
	AddCSLuaFile( base_dir .. "/core/cl_admin_menu.lua")
    AddCSLuaFile( base_dir .. "/core/cl_net.lua")
	AddCSLuaFile( base_dir .. "/core/sh_net.lua")
    AddCSLuaFile( base_dir .. "/core/cl_accessors.lua")
	AddCSLuaFile( base_dir .. "/core/sh_settings.lua")

    include( base_dir .. "/core/sh_var_mount.lua" )
    include( base_dir .. "/core/sh_mod_mount.lua" )
	
    wOS.PES:ServerInclude( base_dir .. "/core/sv_node_mount.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_trigger_mount.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_obj_trigger.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_obj_node.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_obj_event.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_net.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_core.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_permission.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_url_importer.lua")
else

    include( base_dir .. "/vgui/wos_nodebackground.lua" )
    include( base_dir .. "/vgui/wos_node.lua" )

	include( base_dir .. "/vgui/wos_viewnodes.lua")
	include( base_dir .. "/vgui/wos_calendar.lua")

    include( base_dir .. "/vgui/wos_datacopy_editor.lua")

    include( base_dir .. "/core/sh_mod_mount.lua")
    include( base_dir .. "/core/sh_var_mount.lua")
	
	include( base_dir .. "/core/cl_core.lua")
	include( base_dir .. "/core/cl_admin_menu.lua")
    include( base_dir .. "/core/cl_net.lua")
    include( base_dir .. "/core/cl_accessors.lua")

end

include( base_dir .. "/core/sh_sfs_extern.lua")
include( base_dir .. "/core/sh_settings.lua")
include( base_dir .. "/core/sh_net.lua")

hook.Call( "wOS.PES.OnLoaded" )
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/float.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}
VAR.Name = "Float"

VAR.IsValid = function(varTable, value)
    if not isnumber(value) then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local numSlider = vgui.Create("DNumSlider")
    numSlider.Label:SetColor( Color( 125, 0, 255 ) )

    if isnumber(varTable.Min) then
        numSlider:SetMin(varTable.Min)
    end

    if isnumber(varTable.Max) then
        numSlider:SetMax(varTable.Max)
    end

    if isnumber(value) then
        numSlider:SetValue(value)
    else
        numSlider:SetValue(varTable.Default)
    end

    return numSlider
end

VAR.GetValue = function(numSlider)
    return numSlider:GetValue()
end

return VAR

--addons/wos-passiveevent-ageo/lua/wos/pes/vars/scene.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Scene"
VAR.DirtyValidate = true
VAR.IsValid = function(varTable, value)
	value = value or {}
	local a = {}
	for index, data in ipairs(value or {}) do
		// If we have old data, keep it.
		if istable(data) then 
			a[#a+1] = data 
			continue 
		end

		local ent = ents.GetByIndex(data)
		if not IsValid(ent) then continue end

		local data = wOS.PES.ReadEntity(ent)
		a[#a+1] = data
		ent:Remove()
	end

	-- who know that variable overrides don't update
	-- value = a doesn't work
	table.CopyFromTo( a, value )
	return true
end

VAR.DermaElement = function(varTable, value)
	local pnl = vgui.Create("DPanel")
	pnl.Paint = function() end
	local button = vgui.Create("DButton", pnl)

	button.data = value or {}
	button:SetText("Record") // Want to localise two variables here in the future to make maintaining easier

	pnl.button = button

	button:Dock(LEFT)
	
	button.DoClick = function(self)

		local scenemodule = wOS.PES.Modules:Get("scene")

		if button:GetText() == "Record" then
			button:SetText("Recording ...")
			wOS.PES:GetActiveMenu():Hide()
			if scenemodule and scenemodule.StartRecording then
				scenemodule.StartRecording(button)
				button.data = {}
			end
		else
			button:SetText("Record")
			if scenemodule and scenemodule.StopRecording then
				scenemodule.StopRecording(button)
			end
		end
	end

	local wipe = vgui.Create("DButton", pnl)
	wipe:Dock(LEFT)
	wipe:SetText("Reset")
	wipe.DoClick = function()
		button.data = {}
		if button:GetText() != "Record" then
			button:SetText("Record")
			if scenemodule and scenemodule.StopRecording then
				scenemodule.StopRecording(button)
			end
		end
	end

	return pnl
end

VAR.GetValue = function(dermaElement)
	return dermaElement.button.data
end

return VAR

--addons/wos-passiveevent-ageo/lua/wos/pes/vars/tentity.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--



local VAR = {}

VAR.Name = "TableEntity"
VAR.DirtyValidate = true

VAR.ToolTips = {
    { text = "Add the entity you are aiming at to the list", key = "gui/lmb.png", },
    { text = "Remove the last added entity from the list", key = "gui/rmb.png", },
}

VAR.IsValid = function(varTable, value)

    if varTable.Internal then return false end
    if not value or #value < 1 then
        return false
    end
    
    for index, data in pairs(value) do
        if not data.Index then continue end
        local ent = ents.GetByIndex(data.Index)
        if IsValid(ent) then
            if ent:CreatedByMap() then
                value[index] = {
                    mapID = data.Index,
                }
            else
                value[index] = wOS.PES.ReadEntity(ent)
            end
        end
    end

    return true
end

VAR.UseTool = true

VAR.DermaElement = function(varTable, varData)
    varData = varData or {}
    local element = vgui.Create("DModelPanel")
    
    element.Data = {}
    for index, data in pairs( varData ) do
        if data.mapID then
            local ent = ents.GetByIndex( data.mapID )
            element.Data[ index ] =  {
                Position =  ent:GetPos(),
                Index = data.mapID,
            }
            continue
        end
        element.Data[ index ] = data
    end

    return element -- make multiple of these through a base panel
end

VAR.GetValue = function(dermaElement)
    if dermaElement.Data then
        local ent = dermaElement.Data[1]
        --if IsValid(ent) then dermaElement:SetEntity(ent) end
        return dermaElement.Data
    end
end

VAR.PrimaryAttack = function(wep, ply, dermaElement)
    dermaElement.Data = dermaElement.Data || {}

    local ent = ply:GetEyeTrace().Entity
    if IsValid(ent) then
        local allowed = hook.Call( "wOS.CombatSim.CanPlaceEntity", nil, wep, ply, ent:GetPos() )
        if isbool( allowed ) and allowed == false then return end
        dermaElement.Data[#dermaElement.Data + 1] = {
            Position = ent:GetPos(),
            Index = ent:EntIndex()
        }
        ply:ChatPrint( "Entity Added: " .. ent:GetClass() )
    end
end

VAR.SecondaryAttack = function(wep, ply, dermaElement)
    dermaElement.Data = dermaElement.Data || {}
    dermaElement.Data[#dermaElement.Data] = nil
end

VAR.OnStart = function(node, varData, var)
    local tEnts = {}
    for index, entData in ipairs(varData || {}) do
        local ent
        if entData.mapID then
            ent = ents.GetByIndex(entData.mapID)
        else
            ent = wOS.PES:SpawnEntity(entData)
        end

        if not ent then continue end 

        if not istable( ent ) then
            tEnts[#tEnts + 1] = ent
            continue
        end

        -- for _, entity in pairs( ent ) do
        --     if not IsValid( entity ) then continue end
        --     tEnts[#tEnts + 1] = entity
        -- end

    end
    
    node:SetVar(var.Name, tEnts)

    return #tEnts != 0

end

VAR.OnEnd = function(node, varData, var)
    if not node:ShouldCleanAll() then return end
    for index, ent in ipairs(varData || {}) do
        if IsValid(ent) and !ent:CreatedByMap() then
            ent:SetSaveValue( "m_bFadingOut", true )
            ent:Remove()
        end
    end
end

/*
		Angles	=	-0.125 104.219 0.125
		Class	=	prop_physics
		Color:
				a	=	255
				b	=	255
				g	=	255
				r	=	255
		Model	=	models/props_borealis/bluebarrel001.mdl
		Pos	=	-3299.468750 -2135.687500 90.125000
		SubMaterials:
*/

VAR.Draw3D = function(wep, ply, element)
    local tVec = element.Data || {}

    for index, ent in ipairs(tVec) do
        if not isvector(ent.Position) then continue end

        local vec = ent.Position

        local top = Vector(vec.x, vec.y, vec.z + 200)
        render.DrawLine(vec, top, Color(255, 255, 255), false)
    end
end

return VAR

--addons/wos-passiveevent-ageo/lua/wos/pes/core/cl_admin_menu.lua:

// This is the admin config in game editor
function wOS.PES:OpenAdminSettings()
	local cur_pan = self:GetActiveMenu()
	if IsValid(cur_pan) then
		cur_pan:Remove()
	end

	local pnl = vgui.Create("DFrame")
	pnl:SetTitle( "PES Admin Menu" )
	local size = ScrH()*(512/1080)
	pnl:SetSize(size, size)
	pnl:Center()
	pnl:MakePopup()
    pnl:SetDraggable(false)
	pnl.Paint = function(self, w , h)
		surface.SetDrawColor(0,0,0)
		surface.DrawRect(0,0, w, h)
	end

	local txtentry = vgui.Create("DTextEntry", pnl)
	txtentry:Dock(TOP)
	txtentry:DockMargin(10, 5, 10, 0)

	local scroll = vgui.Create("DScrollPanel", pnl)
	scroll:Dock(FILL)
	scroll:DockMargin(5,5,5,5)

	local savebutton = vgui.Create("DButton", pnl)
	savebutton:Dock(BOTTOM)
	savebutton:SetText("Save Settings")
	savebutton:DockMargin(5,5,5,5)

	local varDerma = {}

	savebutton.DoClick = function()
		local changes = {}

		for name, data in pairs(wOS.PES.Settings.GetList()) do
			local varType = wOS.PES.Vars:Get(data.Type)
			if not varType then continue end
			local oldValue = wOS.PES.Settings.Get(name)
			local element = varDerma[name]
			local value = varType.GetValue(element)
			if value == oldValue then continue end
			changes[name] = value
		end

		local maxAmount = table.Count(changes)
		if maxAmount == 0 then
			ErrorNoHalt("Something went wrong no changes found, are you sure you changed something?")
		end
		
		net.Start("wOS.PES.RequestSettings")
			net.WriteUInt(table.Count(changes), 8)
			-- record the changes in a table

			for name, value in pairs(changes) do
				net.WriteString(name)
				net.WriteType(value) // might want to be changed to Table?
			end
		net.SendToServer()
	end

	for name, data in pairs(wOS.PES.Settings.GetList()) do
		local dbutton = vgui.Create("DButton", scroll)
		dbutton:Dock(TOP)
		dbutton:SetText(name)

		local varType = wOS.PES.Vars:Get(data.Type)
		local value = wOS.PES.Settings.Get(name)

		local element = varType.DermaElement(data, value)

        local back = vgui.Create("DPanel", scroll)

        if !IsValid(element) then
            element = vgui.Create("DPanel")
        end

        element:SetParent(back)
        element:Dock(TOP)
        element:DockMargin(2,2,2,2)
        element._catderma = cat
        element.varTable = varTable

        back.element = element

		varDerma[name] = element

		back:Dock(TOP)
		back:DockMargin(0, 0,0,30)

        if varType.UseTool then
            local useTool = vgui.Create("DButton", back)
            useTool:Dock(TOP)
            useTool:DockMargin(8,2,8,2)
            useTool:SetTall(30)
            useTool:SetText("Sadly we don't support this yet")
            useTool.DoClick = function() end
        end

		dbutton.DoClick = function()
			if back:GetTall() <= 0 then
				back:SetTall(back._OldSize)
			else
				back._OldSize = back:GetTall()
				back:SetTall(0)
			end
		end
	end

	return pnl
end

// Scheduled event manager
function wOS.PES:OpenScheduledMenu()
	local cur_pan = self:GetActiveMenu()
	if IsValid(cur_pan) then
		cur_pan:Remove()
	end

	local pnl = vgui.Create("DFrame")
	pnl:SetTitle( "PES Admin Menu" )
	local size = 512*(ScrH()/1080)
	pnl:SetSize(size, size)
	pnl:Center()
	pnl:MakePopup()
    pnl:SetDraggable(false)
	pnl.Paint = function(self, w , h)
		surface.SetDrawColor(0,0,0)
		surface.DrawRect(0,0, w, h)
		
		if not self.Loaded then
			draw.SimpleText("Loading Data ...", "DermaDefault", w/2, h/2,  color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			return
		end
		if not self.NoData then return end
		draw.SimpleText("No events scheduled", "DermaDefault", w/2, h/2,  color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end

	wOS.PES.RequestSchedule(function(eventList)
		pnl.Selected = nil
		pnl.EventList = eventList
		if IsValid(pnl.Scroll) then
			pnl.Scroll:Remove()
		else
			if IsValid( pnl.selectButton ) then
				pnl.selectButton:Remove()
			end
			local selectButton = vgui.Create("DButton", pnl)
			selectButton:Dock(BOTTOM)
			selectButton:SetText("Remove Event")

			selectButton.DoClick = function()
				if not pnl.Selected then return end
				local id = pnl.Selected
				if not pnl.EventList then return end
				if not pnl.EventList[id] then return end
				net.Start("wOS.PES.RequestScheduleDelete")
					net.WriteString(pnl.EventList[id].Name)
					net.WriteDouble(pnl.EventList[id].Time)
				net.SendToServer()
			end
			pnl.selectButton = selectButton
		end

		pnl.Loaded = true
		if table.Count(pnl.EventList) == 0 then
			pnl.NoData = true
		else
			local scroll = vgui.Create("DScrollPanel", pnl)
			scroll:Dock(FILL)
			scroll:DockMargin(5,5,5,5)

			for index, data in SortedPairsByMemberValue(pnl.EventList, "Time", true) do
				local dbutton = vgui.Create("DButton", scroll)
				dbutton:Dock(TOP)
				dbutton:SetText(data.Name .. "    " .. data.Map .. "   " .. os.date( "%H:%M:%S - %d/%m/%Y" , data.Time ))
				dbutton.ID = index
				dbutton.DoClick = function( pan )
					pnl.Selected = pan.ID
				end
				dbutton.Paint = function(pan, w, h)
					if pnl.Selected != pan.ID then
						surface.SetDrawColor(255,255,255)
					else
						surface.SetDrawColor(200,200,200)
					end
					surface.DrawRect(0,0, w, h)
				end
			end
			pnl.Scroll = scroll
		end
	end)

	return pnl
end
--addons/wos-passiveevent-ageo/lua/wos/css/core/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.CombatSim = wOS.CombatSim or {}
wOS.CombatSim.GameTypes = wOS.CombatSim.GameTypes or {}

local w,h = ScrW(), ScrH()

surface.CreateFont( "wOS.CombatSim.MainFont", {
	font = "Bebas Neue",
	extended = false,
	size = 40*(h/1200),
	weight = 400,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.CombatSim.MainFontB", {
	font = "Bebas Neue",
	extended = false,
	size = 44*(h/1200),
	weight = 400,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.CombatSim.LeaderFont", {
	font = "Bebas Neue",
	extended = false,
	size = 36*(h/1200),
	weight = 400,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.CombatSim.MediumFont", {
	font = "Bebas Neue",
	extended = false,
	size = 32*(h/1200),
	weight = 400,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.CombatSim.SmallFont", {
	font = "Bebas Neue",
	extended = false,
	size = 30*(h/1200),
	weight = 400,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.CombatSim.DescFont", {
	font = "Bebas Neue",
	extended = false,
	size = 24*(h/1200),
	weight = 400,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )


local blur = Material("pp/blurscreen")

local function DrawBlur(panel, amount)
	local x, y = panel:LocalToScreen(0, 0)
	surface.SetDrawColor(255, 255, 255)
	surface.SetMaterial(blur)
	for i = 1, 3 do
		blur:SetFloat("$blur", (i / 3) * (amount or 6))
		blur:Recompute()
		render.UpdateScreenEffectTexture()
		surface.DrawTexturedRect(x * -1, y * -1, w, h)
	end
end

local createChallengeIcon = Material( "wos/css/wiltos.png", "unlitgeneric" )
local joinGameIcon = Material( "wos/css/wiltos.png", "unlitgeneric" )

function wOS.CombatSim:AddExitButton(backFunction)
	if not self.SimulatorMenu then return end
	
	local exitbutt = vgui.Create( "DButton", self.SimulatorMenu )
	exitbutt:SetSize( self.SimulatorMenu.SizeT.h * 0.08, h * 0.03 )
	exitbutt:SetPos(  self.SimulatorMenu.SizeT.w * 0.92, h * 0.0125 )
	exitbutt:SetText( "" )
	exitbutt.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			draw.SimpleText("X", "wOS.CombatSim.MainFont", ww*0.5, hh*0.5, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		else
			draw.SimpleText("X", "wOS.CombatSim.MainFont", ww*0.5, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	end
	exitbutt.DoClick = function( pan )
		if self.SimulatorMenu.Clicked then return end

		self.SimulatorMenu.Clicked = true
		self.SimulatorMenu:ToggleClose()
		
		net.Start("wOS.CombatSim.ResetTool")
		net.SendToServer()
	end
	
	if isfunction(backFunction) then
		local backButton = vgui.Create( "DButton", self.SimulatorMenu )
		backButton:SetSize( self.SimulatorMenu.SizeT.h * 0.08, h * 0.03 )
		backButton:SetPos(  self.SimulatorMenu.SizeT.w * 0.025 + w * 0.0125, h * 0.0125 )
		backButton:SetText( "" )
		backButton.Paint = function( pan, ww, hh )
			if pan:IsHovered() then
				draw.SimpleText("<", "wOS.CombatSim.MainFontB", ww*0.5, hh*0.5, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			else
				draw.SimpleText("<", "wOS.CombatSim.MainFontB", ww*0.5, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			end
		end
		backButton.DoClick = function( pan )
			if isfunction(backFunction) then
				backFunction()
			end
		end
	end
end

function wOS.CombatSim:OpenMenu(simulator)
	if IsValid(self.SimulatorMenu) then
		self.SimulatorMenu.Clicked = true
		self.SimulatorMenu:ToggleClose()
		return
	end

	self.SelectedSimulator = simulator
	
	gui.EnableScreenClicker( true )
	
	self.SimulatorMenu = vgui.Create( "DFrame" )
	self.SimulatorMenu:SetSize( 0, 0 )
	self.SimulatorMenu:SetTitle( "" )
	self.SimulatorMenu:SetDraggable( false )
	self.SimulatorMenu:ShowCloseButton( false )
	self.SimulatorMenu:Center()
	self.SimulatorMenu.SizeT = { w = w*0.66, h = h*0.33 }
	self.SimulatorMenu.LastSize = { w = w*0.66, h = 0 }
	self.SimulatorMenu.Title = ""
	self.SimulatorMenu.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.FrameColor )
		surface.DrawPoly( background )
		DrawBlur( pan, 2 )
		
		draw.SimpleText( pan.Title, "wOS.CombatSim.MainFont", ww/2, h*0.04, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
		surface.SetDrawColor( color_white )
		surface.DrawLine( ww*0.05, h*0.045, ww*0.95, h*0.045 )
	end
	self.SimulatorMenu.Think = function( pan )
		pan.LastSize.h = ( pan.LastSize.h == pan.SizeT.h and pan.LastSize.h ) or Lerp( FrameTime()*16, pan.LastSize.h, pan.SizeT.h )
		pan.LastSize.w = ( pan.LastSize.w == pan.SizeT.w and pan.LastSize.w ) or Lerp( FrameTime()*16, pan.LastSize.w, pan.SizeT.w )
		pan:SetSize( pan.LastSize.w, pan.LastSize.h )
		pan:Center()
	end
	self.SimulatorMenu.Clear = function( pan )
		local children = pan:GetChildren()
		for i=5, #children do
			children[i]:Remove()
		end
	end
	self.SimulatorMenu.ToggleClose = function( pan )
		pan:Clear()
		pan:SetKeyboardInputEnabled(false)
		pan:SetMouseInputEnabled(false)

		self.SimulatorMenu = nil

		gui.EnableScreenClicker( false )

		pan.SizeT.h = 8
		timer.Simple( 0.15, function()
			if not IsValid( pan ) then return end

			pan.SizeT.w = 0
			timer.Simple(0.15, function()
				if not IsValid( pan ) then return end
				pan:Remove()
			end)
		end )

		timer.Remove("WOS.CSS.LobbyTimer")
	end

	self.SimulatorMenu:MakePopup()
	
	self:AddExitButton()
end

function wOS.CombatSim:OpenSimulatorMenu(simulator, challenges)
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	self.SimulatorMenu.SizeT = { w = w*0.66, h = h*0.88 }
	self.SimulatorMenu.Title = "SIMULATOR: " .. simulator:GetSimulatorName()
	self.SimulatorMenu:Clear()
	timer.Simple(0, function() self:AddExitButton() end)
	
	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h

	self.InnerFrameCurrent = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	self.InnerFrameCurrent.XScroll = false
	self.InnerFrameCurrent:SetSize( rw*0.48, rh*0.9 )
	self.InnerFrameCurrent:SetPos( rw*0.01, rh*0.075 )
	self.InnerFrameCurrent:SetPanelSize(rw * 0.46, rh * 0.06)
	self.InnerFrameCurrent:SetPanelSpacing(rw * 0.01)
	self.InnerFrameCurrent.ChallengeName = ""
	self.InnerFrameCurrent.GameType = ""
	self.InnerFrameCurrent.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}

		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
		
		draw.SimpleText("Aktuell: " .. pan.ChallengeName, "wOS.CombatSim.LeaderFont", ww*0.5, hh*0.01, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		draw.SimpleText(pan.GameType, "wOS.CombatSim.LeaderFont", ww*0.5, hh*0.05, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	end
	
	self.InnerframeQueue = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	self.InnerframeQueue.XScroll = false
	self.InnerframeQueue:SetSize( rw*0.48, rh*0.8 )
	self.InnerframeQueue:SetPos( rw*0.51, rh*0.135 )
	self.InnerframeQueue:SetPanelSize(rw * 0.46, rh * 0.06)
	self.InnerframeQueue:SetPanelSpacing(rw * 0.01)
	self.InnerframeQueue.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
		
		draw.SimpleText("Warteschlange", "wOS.CombatSim.LeaderFont", ww*0.5, hh*0.01, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	end

	self.CreatePartyButton = vgui.Create("DButton", self.SimulatorMenu)
	self.CreatePartyButton:SetSize( rw*0.15, rh*0.05 )
	self.CreatePartyButton:SetPos( rw*0.8, rh*0.065 )
	self.CreatePartyButton:SetFont( "wOS.CombatSim.MediumFont" )
	self.CreatePartyButton:SetText( "Erstellen" )

	self.CreatePartyButton.DoClick = function(pan)
		local challengeName = self.ChallengeSelector:GetValue()
		if isstring(challengeName) and challengeName ~= "" then
			if challengeName == "Simulationswahl" then
				surface.PlaySound( "buttons/lightswitch2.wav" )
                AOCRP.HUD:Notification(LocalPlayer(), {text="Du musst zuerst eine Simulation auswhlen!", barcolor=Color(255,0,0)}) 
				return
			end

			net.Start("wOS.CombatSim.QueueParty")
				net.WriteEntity(simulator)
				net.WriteString(challengeName)
				net.WriteBool((self.OpenSelector:GetValue() or "") == "Offen")
			net.SendToServer()

			self.SimulatorMenu.Clicked = true
			self.SimulatorMenu:ToggleClose()
		end
	end

	self.LeaveQueueButton = vgui.Create("DButton", self.SimulatorMenu)
	self.LeaveQueueButton:SetSize( rw*0.15, rh*0.05 )
	self.LeaveQueueButton:SetPos( rw*0.55, rh*0.065 )
	self.LeaveQueueButton:SetFont( "wOS.CombatSim.LeaderFont" )
	self.LeaveQueueButton:SetText( "Leave Party" )
	self.LeaveQueueButton:SetVisible(false)
	self.LeaveQueueButton.DoClick = function(pan)
		if pan.PartyLeader then
			net.Start("wOS.CombatSim.DequeueParty")
				net.WriteEntity(simulator)
				net.WriteInt(pan.PartyId, 32)
			net.SendToServer()
		else
			net.Start("wOS.CombatSim.LeaveParty")
				net.WriteEntity(simulator)
				net.WriteInt(pan.PartyId, 32)
			net.SendToServer()
		end

		self.SimulatorMenu.Clicked = true
		self.SimulatorMenu:ToggleClose()
	end
	
	self.StartGameButton = vgui.Create("DButton", self.SimulatorMenu)
	self.StartGameButton:SetSize( rw*0.15, rh*0.05 )
	self.StartGameButton:SetPos( rw*0.8, rh*0.065 )
	self.StartGameButton:SetFont( "wOS.CombatSim.LeaderFont" )
	self.StartGameButton:SetText( "Starten" )
	self.StartGameButton:SetVisible(false)
	self.StartGameButton.DoClick = function(pan)
		net.Start("wOS.CombatSim.StartGame")
			net.WriteEntity(simulator)
		net.SendToServer()

		self.SimulatorMenu.Clicked = true
		self.SimulatorMenu:ToggleClose()
	end

	self.OpenSelector = vgui.Create("DComboBox", self.SimulatorMenu)
	self.OpenSelector:SetSize( rw*0.1, rh*0.05 )
	self.OpenSelector:SetPos( rw*0.7, rh*0.065 )
	self.OpenSelector:SetFont( "wOS.CombatSim.SmallFont" )
	self.OpenSelector:SetValue( "Offen" )
	self.OpenSelector:AddChoice("Offen")
	self.OpenSelector:AddChoice("Einladung")

	self.ChallengeSelector = vgui.Create("DComboBox", self.SimulatorMenu)
	self.ChallengeSelector:SetSize( rw*0.15, rh*0.05 )
	self.ChallengeSelector:SetPos( rw*0.55, rh*0.065 )
	self.ChallengeSelector:SetFont( "wOS.CombatSim.SmallFont" )
	self.ChallengeSelector:SetValue( "Simulationswahl" )

	self.RefreshButton = vgui.Create("DButton", self.SimulatorMenu)
	self.RefreshButton:SetSize( rw*0.15, rh*0.03 )
	self.RefreshButton:SetPos( rw*0.675, rh*0.95 ) -- TODO
	self.RefreshButton:SetFont( "wOS.CombatSim.MediumFont" )
	self.RefreshButton:SetText( "Refreshen" )
	self.RefreshButton.DoClick = function(pan)
		net.Start("wOS.CombatSim.GetGameInfo")
			net.WriteEntity(simulator)
		net.SendToServer()
	end

	for name, _ in pairs(challenges) do
		self.ChallengeSelector:AddChoice(name)
	end

	net.Start("wOS.CombatSim.GetGameInfo")
		net.WriteEntity(simulator)
	net.SendToServer()

	timer.Create("WOS.CSS.LobbyTimer", 10, 0,function()
		net.Start("wOS.CombatSim.GetGameInfo")
			net.WriteEntity(simulator)
		net.SendToServer()
	end)
end

function wOS.CombatSim:UpdateSimulatorMenuQueue(simulator, partyQueue)
	if not self.SimulatorMenu then
		-- TODO: Stop Auto Updating
		return
	end

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h

	self.InnerframeQueue:Clear()

	for partyId, partyData in pairs(partyQueue) do
		if table.HasValue(partyData.Players, LocalPlayer():SteamID64()) then
			if partyId == 1 and partyData.CreatorSteamId64 == LocalPlayer():SteamID64() then
				self.StartGameButton:SetVisible(true)
				self.LeaveQueueButton.PartyLeader = true
				self.LeaveQueueButton:SetText("Beenden")
				
				self.OpenSelector:SetText(partyData.Open and "Offen" or "Einladung")
				self.OpenSelector.OnSelect = function(pan, i, text, data)
					net.Start("wOS.CombatSim.ChangePartyOpen")
						net.WriteEntity(simulator)
						net.WriteInt(partyId, 32)
						net.WriteBool(text == "Open")
					net.SendToServer()
					
					self.SimulatorMenu.Clicked = true
					self.SimulatorMenu:ToggleClose()
				end
			else
				self.OpenSelector:SetVisible(false)
			end

			self.CreatePartyButton:SetVisible(false)
			self.ChallengeSelector:SetVisible(false)

			self.LeaveQueueButton:SetVisible(true)
			self.LeaveQueueButton.PartyId = partyId
		end
		
		local ply = player.GetBySteamID64(partyData.CreatorSteamId64)
		if IsValid(ply) then
			local plyPanel = self.InnerframeQueue:CreatePanel("DPanel")
			plyPanel.Paint = function( pan, ww, hh )
				local background = {
					{ x = 0           , y = hh*0.05 },
					{ x = 0  + hh*0.05, y = 0       },
					{ x = ww - hh*0.05, y = 0       },
					{ x = ww          , y = hh*0.05 },
					{ x = ww          , y = hh*0.95 },
					{ x = ww - hh*0.05, y = hh      },
					{ x = 0  + hh*0.05, y = hh      },
					{ x = 0           , y = hh*0.95 },		
				}
				draw.NoTexture()
				surface.SetDrawColor( wOS.CombatSim.FrameColor )
				surface.DrawPoly( background )		
				DrawBlur( pan, 1 )

				draw.SimpleText("Erstellt von: " .. ply:GetName(), "wOS.CombatSim.MediumFont", rw*0.01, rh*0.005, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)

				draw.SimpleText("Teilnehmer: " .. #partyData.Players, "wOS.CombatSim.SmallFont", rw*0.01, rh*0.035, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
				draw.SimpleText("Simulation: " .. partyData.QueuedChallenge, "wOS.CombatSim.SmallFont", rw*0.45, rh*0.035, white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP)

				if pan:IsHovered() then
					cam.Start2D()
						local x = gui.MouseX()
						local y = gui.MouseY()

						local n = #partyData.Players
						draw.RoundedBox(0, x, y, rw * 0.25, rh * 0.025 * n, Color(255, 255, 255))

						for i, plySteamId64 in pairs(partyData.Players) do
							local partyPly = player.GetBySteamID64(plySteamId64)
							if IsValid(partyPly) then
								draw.SimpleText(partyPly:GetName(), "wOS.CombatSim.SmallFont", x, y + rh * 0.025 * (i-1), Color(0, 0, 0), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
							end

						end
					cam.End2D()
				end
			end

			if partyData.CreatorSteamId64 == LocalPlayer():SteamID64() then
				local inviteButton = vgui.Create("DButton", plyPanel)
				inviteButton:SetPos(rw*0.35, rh*0.01)
                inviteButton:SetSize(rw*0.1, rh*0.03)
				inviteButton:SetFont( "wOS.CombatSim.SmallFont" )
				inviteButton:SetText( "Einladen" )
				inviteButton.DoClick = function(pan) 
					self:OpenSimulatorInviteMenu(simulator, partyId, partyData)
				end
			else
				if partyData.Open or table.HasValue(partyData.InvitedPlayers, LocalPlayer():SteamID64()) then
					if not table.HasValue(partyData.Players, LocalPlayer():SteamID64()) then 
						local joinButton = vgui.Create("DButton", plyPanel)
						joinButton:SetPos(rw*0.4, rh*0.01)
						joinButton:SetFont( "wOS.CombatSim.SmallFont" )
						joinButton:SetText( "Join" )
						joinButton.DoClick = function(pan) 
							net.Start("wOS.CombatSim.JoinParty")
								net.WriteEntity(simulator)
								net.WriteInt(partyId, 32)
							net.SendToServer()
							
							self.SimulatorMenu.Clicked = true
							self.SimulatorMenu:ToggleClose()
						end	
					end
				end
			end
		end
	end
end

function wOS.CombatSim:OpenSimulatorInviteMenu(simulator, partyId, partyData)
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	self.SimulatorMenu.SizeT = { w = w*0.33, h = h*0.66 }
	self.SimulatorMenu.Title = "Zur Simulation einladen"
	self.SimulatorMenu:Clear()
	timer.Simple(0, function() self:AddExitButton() end)
	
	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	local innerframe = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	innerframe.XScroll = false
	innerframe:SetSize( rw*0.95, rh*0.8 )
	innerframe:SetPos( rw*0.025, rh*0.1 )
	innerframe:SetPanelSize(rw * 0.85, rh * 0.05)
	innerframe:SetPanelSpacing(rw * 0.05)
	innerframe.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
	end
	
	for _, ply in pairs(player.GetHumans()) do
		if ply:SteamID64() == partyData.CreatorSteamId64 then continue end

		local isInvited = table.HasValue(partyData.InvitedPlayers, ply:SteamID64())

		local plyPanel = innerframe:CreatePanel("DPanel")
		plyPanel.Paint = function( pan, ww, hh )
			local background = {
				{ x = 0           , y = hh*0.05 },
				{ x = 0  + hh*0.05, y = 0       },
				{ x = ww - hh*0.05, y = 0       },
				{ x = ww          , y = hh*0.05 },
				{ x = ww          , y = hh*0.95 },
				{ x = ww - hh*0.05, y = hh      },
				{ x = 0  + hh*0.05, y = hh      },
				{ x = 0           , y = hh*0.95 },		
			}
			draw.NoTexture()
			surface.SetDrawColor( wOS.CombatSim.FrameColor )
			surface.DrawPoly( background )		
			DrawBlur( pan, 1 )

			draw.SimpleText(ply:GetName(), "wOS.CombatSim.MediumFont", rw*0.01, hh * 0.5, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end

		local selector = vgui.Create("DCheckBox", plyPanel)
		selector:SetSize(rh * 0.04, rh * 0.04)
		selector:SetPos(rw * 0.8, rh*0.0075)
		selector:SetValue(isInvited)
		selector.OnChange = function(pan, val)
			if val then
				table.insert(partyData.InvitedPlayers, ply:SteamID64())
			else
				table.RemoveByValue(partyData.InvitedPlayers, ply:SteamID64())
			end
		end
	end

	self.SetInviteButton = vgui.Create("DButton", self.SimulatorMenu)
	self.SetInviteButton:SetSize( rw*0.5, rh*0.05 )
	self.SetInviteButton:SetPos( rw*0.25, rh*0.925 )
	self.SetInviteButton:SetFont( "wOS.CombatSim.LeaderFont" )
	self.SetInviteButton:SetText( "Einladungen setzen" )
	self.SetInviteButton.DoClick = function(pan)

		net.Start("wOS.CombatSim.SetPartyInvites")
			net.WriteEntity(simulator)
			net.WriteInt(partyId, 32)
			net.WriteTable(partyData.InvitedPlayers)
		net.SendToServer()

		self.SimulatorMenu.Clicked = true
		self.SimulatorMenu:ToggleClose()
	end
end

function wOS.CombatSim:UpdateSimulatorMenuGameInfo(simulator, gameInfo)
	if not self.SimulatorMenu then
		-- TODO: Stop Auto Updating
		return
	end

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h

	self.InnerFrameCurrent.ChallengeName = gameInfo.ChallengeName
	self.InnerFrameCurrent.GameType = gameInfo.GameType

	self.InnerFrameCurrent:Clear()

	for _, plyName in pairs(gameInfo.PlayerNames) do
		local plyPanel = self.InnerFrameCurrent:CreatePanel("DPanel")
		plyPanel.Paint = function( pan, ww, hh )
			local background = {
				{ x = 0           , y = hh*0.05 },
				{ x = 0  + hh*0.05, y = 0       },
				{ x = ww - hh*0.05, y = 0       },
				{ x = ww          , y = hh*0.05 },
				{ x = ww          , y = hh*0.95 },
				{ x = ww - hh*0.05, y = hh      },
				{ x = 0  + hh*0.05, y = hh      },
				{ x = 0           , y = hh*0.95 },		
			}
			draw.NoTexture()
			surface.SetDrawColor( wOS.CombatSim.FrameColor )
			surface.DrawPoly( background )
			DrawBlur( pan, 1 )

			draw.SimpleText(plyName, "wOS.CombatSim.MediumFont", rw*0.01, hh*0.5, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end
	end
end

hook.Add("HUDPaint", "wOS.CombatSim.HUDPaint", function()
	local ply = LocalPlayer()

	-- if !ply:Alive() then
	-- 	local respawnTime = ply:GetNW2Float("wOS.CombatSim.RespawnTime", 0)
	-- 	if respawnTime == 0 then return end
	-- 	local diff = math.max(math.floor(respawnTime - CurTime()), 0)
	-- 	draw.SimpleText(diff .. "s until you can respawn!", "wOS.CombatSim.LeaderFont", ScrW() * 0.5, ScrH() * 0.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	-- 	return
	-- end

    if !ply:Alive() then return end

	local simulator = ply:GetNW2Entity("wOS.CombatSim.Entity")
	if !IsValid(simulator) then return end

	local endTime = simulator:GetEndTime()
	if endTime <= CurTime() then return end

	local diff = math.max(math.floor(endTime - CurTime()), 0)
	draw.SimpleText(diff .. "s bis zum Ende der Simulation!", "wOS.CombatSim.LeaderFont", ScrW() * 0.5, ScrH() * 0.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

end)
--addons/wos-passiveevent-ageo/lua/wos/css/core/cl_admin_menu.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.CombatSim = wOS.CombatSim or {}
wOS.CombatSim.GameTypes = wOS.CombatSim.GameTypes or {}

local w,h = ScrW(), ScrH()
local blur = Material("pp/blurscreen")

local function DrawBlur(panel, amount)
	local x, y = panel:LocalToScreen(0, 0)
	surface.SetDrawColor(255, 255, 255)
	surface.SetMaterial(blur)
	for i = 1, 3 do
		blur:SetFloat("$blur", (i / 3) * (amount or 6))
		blur:Recompute()
		render.UpdateScreenEffectTexture()
		surface.DrawTexturedRect(x * -1, y * -1, w, h)
	end
end

local createChallengeIcon = Material( "wos/css/wiltos.png", "unlitgeneric" )
local joinGameIcon = Material( "wos/css/wiltos.png", "unlitgeneric" )

function wOS.CombatSim:OpenSimulatorNameMenu(borderPoints, selectedHeight)
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end

	self.SimulatorMenu.SizeT = { w = w*0.25, h = h*0.2 }
	self.SimulatorMenu.Title = "SET SIMULATOR NAME"
	self.SimulatorMenu:Clear()

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	local nameField = vgui.Create("DPanel", self.SimulatorMenu)
	nameField:SetSize( rw*0.9, rh*0.2 )
	nameField:SetPos( rw*0.05, rh*0.25 )
	nameField.Paint = function( pan, ww, hh )
		draw.SimpleText("Simulator Name:", "wOS.CombatSim.LeaderFont", 0, hh * 0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end
	
	local nameEntryField = vgui.Create("DTextEntry", self.SimulatorMenu)
	nameEntryField:SetSize( rw*0.9, rh*0.15 )
	nameEntryField:SetPos( rw*0.05, rh*0.45 )
	nameEntryField:SetFont( "wOS.CombatSim.MediumFont" )
	nameEntryField:SetValue( istable(simulator) and simulator:GetSimulatorName() or "" )

	local saveButton = vgui.Create("DButton", self.SimulatorMenu)
	saveButton:SetSize( rw*0.8, rh*0.2 )
	saveButton:SetPos( rw*0.1, rh*0.7 )
	saveButton:SetFont( "wOS.CombatSim.LeaderFont" )
	saveButton:SetText( "Set Simulator Name" )
	saveButton.DoClick = function( pan )
		local name = nameEntryField:GetValue()
		
		net.Start("wOS.CombatSim.SetBorderPoints")
			net.WriteTable(borderPoints)
			net.WriteInt(selectedHeight, 32)
			net.WriteString(name)
		net.SendToServer()
	end
end

function wOS.CombatSim:OpenToolMenu( simulator )
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	if not simulator then
		local wep = LocalPlayer():GetActiveWeapon()
		if wep and wep:GetClass() == "wos_simulation_tool" then
			simulator = wep:GetSelectedSimulator()
		end
	end

	self.SimulatorMenu.SizeT = { w = w*0.66, h = h*0.33 }
	self.SimulatorMenu.Title = simulator:GetSimulatorName()
	self.SimulatorMenu:Clear()
	timer.Simple(0, function() self:AddExitButton() end)
	
	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	local innerframe = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	innerframe:SetSize( rw*0.98, rh*0.8 )
	innerframe:SetPos( rw*0.01, rh*0.15 )
	innerframe:SetPanelSize(rh * 0.7, rh * 0.7)
	innerframe:SetPanelSpacing(rh * 0.05)
	innerframe.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
	end

	local createChallengeButton = innerframe:CreatePanel("DButton")
	createChallengeButton:SetText("")
	createChallengeButton.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			surface.SetDrawColor(255, 255, 255, 255)
		else
			surface.SetDrawColor(63, 63, 63, 255)
		end
		
		surface.SetMaterial(createChallengeIcon)
		surface.DrawTexturedRect(0, 0, ww, hh)

		draw.SimpleText( "Add", "wOS.CombatSim.LeaderFont", ww/2, hh/2 - hh/12, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
		draw.SimpleText( "Simulation", "wOS.CombatSim.LeaderFont", ww/2, hh/2 + hh/12, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
	end
	createChallengeButton.DoClick = function( pan )
		self:OpenToolCreateSimulationMenu(simulator)
	end

	local editChallengesButton = innerframe:CreatePanel("DButton")
	editChallengesButton:SetText("")
	editChallengesButton.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			surface.SetDrawColor(255, 255, 255, 255)
		else
			surface.SetDrawColor(63, 63, 63, 255)
		end
		
		surface.SetMaterial(createChallengeIcon)
		surface.DrawTexturedRect(0, 0, ww, hh)

		draw.SimpleText( "Edit", "wOS.CombatSim.LeaderFont", ww/2, hh/2 - hh/12, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
		draw.SimpleText( "Simulation", "wOS.CombatSim.LeaderFont", ww/2, hh/2 + hh/12, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
	end
	editChallengesButton.DoClick = function( pan )
		net.Start( "wOS.CSS.GetEditableChallenges" )
		net.SendToServer()
	end

	local removeSimulatorButton = innerframe:CreatePanel("DButton")
	removeSimulatorButton:SetText("")
	removeSimulatorButton.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			surface.SetDrawColor(255, 255, 255, 255)
		else
			surface.SetDrawColor(63, 63, 63, 255)
		end
		
		surface.SetMaterial(createChallengeIcon)
		surface.DrawTexturedRect(0, 0, ww, hh)

		draw.SimpleText( "Remove", "wOS.CombatSim.LeaderFont", ww/2, hh/2 - hh/12, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
		draw.SimpleText( "Simulator", "wOS.CombatSim.LeaderFont", ww/2, hh/2 + hh/12, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
	end
	removeSimulatorButton.DoClick = function( pan )
		wOS.CombatSim:OpenRemoveSimulatorDerma(simulator)
	end
end

function wOS.CombatSim:OpenToolSettingsMenu( base_settings, settings )
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end

	self.SimulatorMenu.SizeT = { w = w*0.33, h = h*0.66 }
	self.SimulatorMenu.Title = "SETTINGS"
	self.SimulatorMenu:Clear()

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h

	local innerframe = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	innerframe.XScroll = false
	innerframe:SetSize( rw*0.95, rh*0.8 )
	innerframe:SetPos( rw*0.025, rh*0.1 )
	innerframe:SetPanelSize(rw * 0.85, rh * 0.1)
	innerframe:SetPanelSpacing(rw * 0.05)
	innerframe.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
	end

	innerframe.ObjectPanels = {}

	self:CreateSettingsList(innerframe, base_settings, settings, rw, rh)

	local saveButton = vgui.Create("DButton", self.SimulatorMenu)
	saveButton:SetSize( rw*0.6, rh*0.075 )
	saveButton:SetPos( rw*0.2, rh*0.9125 )
	saveButton:SetFont( "wOS.CombatSim.LeaderFont" )
	saveButton:SetText( "Save" )
	saveButton.DoClick = function( pan )
		local settings2 = {}
		for _, objectPanel in pairs(innerframe.ObjectPanels) do
			settings2[objectPanel.SettingName] = objectPanel.Value
		end
		local nMenu = wOS.PES:GetNodeMenu()
		if not nMenu then return end
		if not nMenu.menu then return end
		nMenu.menu:SaveGameSettings( settings2 )
		wOS.CombatSim:OpenMenu()
	end

	return self.SimulatorMenu
end

function wOS.CombatSim:OpenToolPreChallengeMenu( challenges )
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end

	self.SimulatorMenu.SizeT = { w = w*0.43, h = h*0.66 }
	self.SimulatorMenu.Title = "CHALLENGES"
	self.SimulatorMenu:Clear()

	timer.Simple( 0, function() self:AddExitButton( function() wOS.CombatSim:OpenToolMenu() end ) end )

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h

	local innerframe = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	innerframe.XScroll = false
	innerframe:SetSize( rw*0.95, rh*0.8 )
	innerframe:SetPos( rw*0.025, rh*0.1 )
	innerframe:SetPanelSize(rw * 0.85, rh * 0.1)
	innerframe:SetPanelSpacing(rw * 0.05)
	innerframe.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
	end

	innerframe.ObjectPanels = {}

	for name, data in pairs( challenges ) do
		local objectPanel = innerframe:CreatePanel("DPanel")
		objectPanel.Data = data
		objectPanel.Paint = function( pan, ww, hh )
			draw.RoundedBox( hh*0.1, 0, 0, ww, hh, wOS.CombatSim.FrameColor )
			DrawBlur( pan, 1 )

			draw.SimpleText(pan.Data.Name, "wOS.CombatSim.MediumFont", ww*0.01, hh*0.005, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
			draw.SimpleText("MAX PLAYERS: " .. pan.Data.Settings[ "Maximum Players" ], "wOS.CombatSim.SmallFont",  ww*0.99, hh*0.005, white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP)
			
			local word = wOS.PES.WrapText( pan.Data.Description, "wOS.CombatSim.DescFont", ww*0.8 )
			draw.DrawText( word, "wOS.CombatSim.DescFont", ww*0.01, hh*0.37, color_white, TEXT_ALIGN_LEFT ) 		
		end

		table.insert(innerframe.ObjectPanels, objectPanel)

		local ow, oh = objectPanel:GetSize()
		local button = vgui.Create("DButton", objectPanel)
		button:SetSize( ow*0.15, oh*0.45 )
		button:SetPos( ow*0.85, oh*0.55 )
		button.Data = data
		button:SetFont( "wOS.CombatSim.LeaderFont" )
		button:SetText( "Select" )
		button.DoClick = function(pan)
			wOS.CombatSim:OpenMenu()
			wOS.PES.RequestSimulationData(pan.Data.Name, function( simdata )
				wOS.CombatSim:OpenSimulationEditor( simdata )
			end )
		end
		
	end

	return self.SimulatorMenu
end

// Build editor menu
function wOS.CombatSim:OpenSimulationCreator(simulator)
	local nMenu = wOS.PES:GetNodeMenu()
    if IsValid(nMenu) then
		if nMenu.menu then
			if not nMenu.menu.CreationType or nMenu.menu.CreationType == WOS_PES.CREATOR.SIMULATION then 
				nMenu:Show()
				return
			end
		end
        nMenu:Remove()
    end

	local base = vgui.Create("DFrame")
	base:SetSize(ScrW(), ScrH())
	base:Center()
	base:MakePopup()
	base:SetDraggable(false)
	base:SetTitle("")
	base:ShowCloseButton(false)
	base.Paint = function(self, w, h)
		surface.SetDrawColor(35.5,35.5,35.5)
		surface.DrawRect(0,0, w, h)
	end

	local close = vgui.Create("DButton", base)
	close:SetSize(20,20)
	close:SetPos(ScrW()-20, 0)
	close:SetText("")
	close.Paint = function(self, w, h)
		local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

		surface.SetDrawColor(col)
		surface.DrawLine(0,0, w, h)
		surface.DrawLine(w,0, 0, h)
	end
	close.DoClick = function()
		net.Start("wOS.CombatSim.ResetTool")
		net.SendToServer()	
		hook.Call(  "wOS.PES.OnCreatorClose", nil, WOS_PES.CREATOR.SIMULATION )	
		base:Remove()  
	end

	local mini = vgui.Create("DButton", base)
	mini:SetSize(20,20)
	mini:SetPos(ScrW()-45, 0)
	mini:SetText("")
	mini.Paint = function(self, w, h)
		local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

		surface.SetDrawColor(col)
		surface.DrawLine(0,h/2, w, h/2)
	end
	mini.DoClick = function() base:Hide() end

	if IsValid(base.menu) then
		base.menu:Remove()
	end

	local menu = vgui.Create("WOS_CSS_NodeBG", base)
	menu:Dock(FILL)
	menu:DockMargin(0,0,0,0)
	base.menu = menu

	local start = menu:CreateStartNode()

	wOS.PES:SetNodeMenu( base )
	wOS.PES:SetActiveMenu( base )
end

function wOS.CombatSim:OpenSimulationEditor( simdata, dirty, imported )
	if IsValid( self.SimulatorMenu ) then wOS.CombatSim:OpenMenu() end
	local nMenu = wOS.PES:GetNodeMenu()
    if IsValid(nMenu) then
		if nMenu.menu then
			if not nMenu.menu.CreationType or nMenu.menu.CreationType == WOS_PES.CREATOR.SIMULATION then 
				nMenu:Show()
				return
			end
		end
        nMenu:Remove()
    end

	local event = simdata.Event or simdata
	local settings = simdata.Settings

	if imported and event then
		event.OldName = nil
	end

	local base = vgui.Create("DFrame")
	base:SetSize(ScrW(), ScrH())
	base:Center()
	base:MakePopup()
	base:SetDraggable(false)
	base:SetTitle("")
	base:ShowCloseButton(false)
	base.Paint = function(self, w, h)
		surface.SetDrawColor(35.5,35.5,35.5)
		surface.DrawRect(0,0, w, h)
	end

	local close = vgui.Create("DButton", base)
	close:SetSize(20,20)
	close:SetPos(ScrW()-20, 0)
	close:SetText("")
	close.Paint = function(self, w, h)
		local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

		surface.SetDrawColor(col)
		surface.DrawLine(0,0, w, h)
		surface.DrawLine(w,0, 0, h)
	end
	close.DoClick = function()
		net.Start("wOS.CombatSim.ResetTool")
		net.SendToServer()	
		hook.Call( "wOS.PES.OnCreatorClose", nil, WOS_PES.CREATOR.SIMULATION )	
		base:Remove()  
	end

	local mini = vgui.Create("DButton", base)
	mini:SetSize(20,20)
	mini:SetPos(ScrW()-45, 0)
	mini:SetText("")
	mini.Paint = function(self, w, h)
		local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

		surface.SetDrawColor(col)
		surface.DrawLine(0,h/2, w, h/2)
	end
	mini.DoClick = function() base:Hide() end

	if IsValid(base.menu) then
		base.menu:Remove()
	end

	local menu = vgui.Create("WOS_CSS_NodeBG", base)
	menu:Dock(FILL)
	menu:DockMargin(0,0,0,0)
	menu.Importable = simdata.Importable
	base.menu = menu

	menu:SaveGameSettings( settings )

	menu.Name = event.Name
	menu.DirtyNodes = dirty
	menu.Imported = imported
	menu.Description = event.Description
	menu.Importable = simdata.Importable

	for index, node in pairs(event.Nodes) do
		
		local pNode
		if index == 1 then
			pNode = menu:CreateStartNode()
		else
			pNode = menu:AddNode()
			pNode.Type = node.Type
		end

		pNode:SetPos(node.Pos.x, node.Pos.y )
		
		if pNode.Type != node.Type then continue end
		pNode:SetVars(node._vars, dirty)
		pNode:SetDisableVars(node._toggles, dirty)
	end

	for index, node in pairs(event.Nodes) do
		if node.Triggers then
			for triggerName, panelTable in pairs(node.Triggers) do
				for _, otherID in pairs(panelTable) do
					local pnl, oPnl = menu.Nodes[index], menu.Nodes[otherID]
					menu:MakeLink(pnl, oPnl, triggerName)
				end
			end
		end
	end

	for _, node in pairs(menu.Nodes) do
		node:CreateLinks()
	end

	local delin = vgui.Create("DButton", base )
	delin:SetText("Delete Simulation")
	delin:SetPos( 20, 3.5 )
	delin:SetWide( 100 )
	delin.DoClick = function( p )
		menu:OpenEventDeleter()
    end 

	wOS.PES:SetNodeMenu( base )
	wOS.PES:SetActiveMenu( base )
end

function wOS.CombatSim:CleanupAdminMenu()
	local node = wOS.PES:GetNodeMenu()
	if IsValid( node ) then node:Remove() end
	
	local cur_pan = wOS.PES:GetActiveMenu()
	if IsValid( cur_pan ) then cur_pan:Remove() end
end

//OLD CSS STUFF

function wOS.CombatSim:OpenRemoveSimulatorDerma(simulator)
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	self.SimulatorMenu.SizeT = { w = w*0.3, h = h*0.3 }
	self.SimulatorMenu.Title = "REMOVE SIMULATOR"
	self.SimulatorMenu:Clear()

	timer.Simple( 0, function() self:AddExitButton() end )

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	local innerframe = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	innerframe:SetSize( rw*0.9, rh*0.75 )
	innerframe:SetPos( rw*0.05, rh*0.2 )
	innerframe:SetPanelSize(rh * 0.7, rh * 0.7)
	innerframe:SetPanelSpacing(rh * 0.05)
	innerframe.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
	end

	local removeButton = innerframe:CreatePanel("DButton")
	removeButton:SetText("")
	removeButton.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			surface.SetDrawColor(255, 255, 255, 255)
		else
			surface.SetDrawColor(63, 63, 63, 255)
		end
		
		surface.SetMaterial(createChallengeIcon)
		surface.DrawTexturedRect(0, 0, ww, hh)

		draw.SimpleText( "YES", "wOS.CombatSim.LeaderFont", ww/2, hh/2, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
	end
	removeButton.DoClick = function( pan )
		if self.SimulatorMenu.Clicked then return end

		self.SimulatorMenu.Clicked = true
		self.SimulatorMenu:ToggleClose()
		
		net.Start("wOS.CombatSim.RemoveSelectedSimulator")
		net.SendToServer()
	end
	
	local abortButton = innerframe:CreatePanel("DButton")
	abortButton:SetText("")
	abortButton.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			surface.SetDrawColor(255, 255, 255, 255)
		else
			surface.SetDrawColor(63, 63, 63, 255)
		end
		
		surface.SetMaterial(createChallengeIcon)
		surface.DrawTexturedRect(0, 0, ww, hh)

		draw.SimpleText( "NO", "wOS.CombatSim.LeaderFont", ww/2, hh/2, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
	end
	abortButton.DoClick = function( pan )
		wOS.CombatSim:OpenToolMenu()
	end
end

function wOS.CombatSim:OpenToolCreateSimulationMenu()
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	self.SimulatorMenu.SizeT = { w = w*0.25, h = h*0.15 }
	self.SimulatorMenu.Title = "ADD SIMULATION"
	self.SimulatorMenu:Clear()

	timer.Simple( 0, function() self:AddExitButton( function() wOS.CombatSim:OpenToolMenu() end ) end )

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	-- local nameField = vgui.Create("DPanel", self.SimulatorMenu)
	-- nameField:SetSize( rw*0.4, rh*0.1 )
	-- nameField:SetPos( rw*0.05, rh*0.2 )
	-- nameField.Paint = function( pan, ww, hh )
	-- 	draw.SimpleText("Challenge Name:", "wOS.CombatSim.LeaderFont", 0, hh * 0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	-- end
	
	-- local nameEntryField = vgui.Create("DTextEntry", self.SimulatorMenu)
	-- nameEntryField:SetSize( rw*0.4, rh*0.1 )
	-- nameEntryField:SetPos( rw*0.05, rh*0.3 )
	-- nameEntryField:SetFont( "wOS.CombatSim.MediumFont" )

	local newbutt = vgui.Create("DButton", self.SimulatorMenu)
	newbutt:SetSize( rw*0.8, rh*0.22 )
	newbutt:SetPos( rw*0.1, rh*0.35 )
	newbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	newbutt:SetText( "Create New" )
	newbutt.DoClick = function( pan )
		net.Start( "wOS.CSS.CreateNewSimulation")
		net.SendToServer()		
		self.SimulatorMenu:ToggleClose()
	end

	local impbutt = vgui.Create("DButton", self.SimulatorMenu)
	impbutt:SetSize( rw*0.8, rh*0.22 )
	impbutt:SetPos( rw*0.1, rh*0.67 )
	impbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	impbutt:SetText( "Import From Existing" )
	impbutt.DoClick = function( pan )
		wOS.CombatSim:OpenToolImportSimulationMenu()
	end
end

function wOS.CombatSim:OpenToolImportSimulationMenu()
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	self.SimulatorMenu.SizeT = { w = w*0.25, h = h*0.2 }
	self.SimulatorMenu.Title = "IMPORT SIMULATION"
	self.SimulatorMenu:Clear()

	timer.Simple( 0, function() self:AddExitButton( function() wOS.CombatSim:OpenToolCreateSimulationMenu() end ) end )

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	-- local nameField = vgui.Create("DPanel", self.SimulatorMenu)
	-- nameField:SetSize( rw*0.4, rh*0.1 )
	-- nameField:SetPos( rw*0.05, rh*0.2 )
	-- nameField.Paint = function( pan, ww, hh )
	-- 	draw.SimpleText("Challenge Name:", "wOS.CombatSim.LeaderFont", 0, hh * 0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	-- end
	
	-- local nameEntryField = vgui.Create("DTextEntry", self.SimulatorMenu)
	-- nameEntryField:SetSize( rw*0.4, rh*0.1 )
	-- nameEntryField:SetPos( rw*0.05, rh*0.3 )
	-- nameEntryField:SetFont( "wOS.CombatSim.MediumFont" )

	local evbutt = vgui.Create("DButton", self.SimulatorMenu)
	evbutt:SetSize( rw*0.8, rh*0.15 )
	evbutt:SetPos( rw*0.1, rh*0.26 )
	evbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	evbutt:SetText( "Import From Event" )
	evbutt.DoClick = function( pan )
		wOS.PES.GetImportableEvents( function( events )
			wOS.CombatSim:OpenToolPreImportMenu( events, false )
		end )
	end

	local newbutt = vgui.Create("DButton", self.SimulatorMenu)
	newbutt:SetSize( rw*0.8, rh*0.15 )
	newbutt:SetPos( rw*0.1, rh*0.5 )
	newbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	newbutt:SetText( "Import From Simulator" )
	newbutt.DoClick = function( pan )
		wOS.PES.GetImportableSimulations( function( events )
			wOS.CombatSim:OpenToolPreImportMenu( events, true, true )
		end )
	end

	local impbutt = vgui.Create("DButton", self.SimulatorMenu)
	impbutt:SetSize( rw*0.8, rh*0.15 )
	impbutt:SetPos( rw*0.1, rh*0.74 )
	impbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	impbutt:SetText( "Import From URL" )
	impbutt.DoClick = function( pan )
		wOS.CombatSim:OpenToolURLImportMenu()
	end

end

function wOS.CombatSim:OpenToolURLImportMenu()
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	self.SimulatorMenu.SizeT = { w = w*0.25, h = h*0.4 }
	self.SimulatorMenu.Title = "IMPORT FROM URL"
	self.SimulatorMenu:Clear()

	timer.Simple( 0, function() self:AddExitButton( function() wOS.CombatSim:OpenToolImportSimulationMenu() end ) end )

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	-- local nameField = vgui.Create("DPanel", self.SimulatorMenu)
	-- nameField:SetSize( rw*0.4, rh*0.1 )
	-- nameField:SetPos( rw*0.05, rh*0.2 )
	-- nameField.Paint = function( pan, ww, hh )
	-- 	draw.SimpleText("Challenge Name:", "wOS.CombatSim.LeaderFont", 0, hh * 0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	-- end
	
	-- local nameEntryField = vgui.Create("DTextEntry", self.SimulatorMenu)
	-- nameEntryField:SetSize( rw*0.4, rh*0.1 )
	-- nameEntryField:SetPos( rw*0.05, rh*0.3 )
	-- nameEntryField:SetFont( "wOS.CombatSim.MediumFont" )

	local evbutt = vgui.Create("DPanel", self.SimulatorMenu)
	evbutt:SetSize( rw*0.8, rh*0.75 )
	evbutt:SetPos( rw*0.1, rh*0.13 )
	evbutt.Paint = function( pan, ww, hh )
		local text = "Input a URL below that leads DIRECTLY to the exported event text\n\n----------WARNING---------- \nVERIFY THAT ALL SOURCES ARE COMPLETELY TRUSTED BEFORE IMPORTING AN EVENT!"
		text = wOS.PES.WrapText( text, "wOS.CombatSim.LeaderFont", ww*0.95 )
		draw.DrawText(text, "wOS.CombatSim.LeaderFont", ww/2, 0, color_white, TEXT_ALIGN_CENTER )
	end

	local newbutt = vgui.Create("DTextEntry", self.SimulatorMenu)
	newbutt:SetSize( rw*0.8, rh*0.075 )
	newbutt:SetPos( rw*0.1, rh*0.8 )
	newbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	newbutt:SetText( "INPUT URL HERE" )

	local impbutt = vgui.Create("DButton", self.SimulatorMenu)
	impbutt:SetSize( rw*0.8, rh*0.075 )
	impbutt:SetPos( rw*0.1, rh*0.9 )
	impbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	impbutt:SetText( "IMPORT" )
	impbutt.DoClick = function( pan )
		local text = newbutt:GetText()
		if #text < 1 then return end
		wOS.PES.RequestURLImport(text, function( data ) 
			wOS.CombatSim:OpenSimulationImported( data )
		end )
	end

end

function wOS.CombatSim:OpenSimulationImported( simdata )
	local sim_struct = {}

	if not simdata.Event then
		if simdata.Nodes then
			sim_struct.Event = table.Copy( simdata )
		end
	else
		sim_struct = simdata
	end

	wOS.CombatSim:OpenSimulationEditor( sim_struct, true ) //Second argument is dirty which is always true for imports
end

function wOS.CombatSim:CreateSettingsList(innerframe, customSettings, settings, rw, rh)
	for name, setting in pairs(customSettings) do
		local objectPanel = innerframe:CreatePanel("DPanel")
		objectPanel.Paint = function( pan, ww, hh )
			local background = {
				{ x = 0           , y = hh*0.05 },
				{ x = 0  + hh*0.05, y = 0       },
				{ x = ww - hh*0.05, y = 0       },
				{ x = ww          , y = hh*0.05 },
				{ x = ww          , y = hh*0.95 },
				{ x = ww - hh*0.05, y = hh      },
				{ x = 0  + hh*0.05, y = hh      },
				{ x = 0           , y = hh*0.95 },		
			}
			draw.NoTexture()
			surface.SetDrawColor( wOS.CombatSim.FrameColor )
			surface.DrawPoly( background )		
			DrawBlur( pan, 1 )

			draw.SimpleText(name, "wOS.CombatSim.MediumFont", rw*0.01, rh*0.005, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		end

		table.insert(innerframe.ObjectPanels, objectPanel)

		local settingType = setting
		local minCount
		local maxCount
		local values = {}
		local default

		if istable(setting) then
			settingType = setting.Type
			minCount = setting.MinCount
			maxCount = setting.MaxCount
			values = setting.Values
			default = setting.Default
			if isfunction(values) then
				values = values()
			end
		end

		objectPanel.SettingName = name
		local value = settings[name]

		if settingType == WOS_CSS.CONFIG.BOOL then
			objectPanel.Value = value
			if objectPanel.Value == nil then
				objectPanel.Value = default or false
			end

			local button = vgui.Create("DButton", objectPanel)
			button:SetSize( rw*0.3, rh*0.05 )
			button:SetPos( rw*0.55, rh*0.05 )
			button:SetFont( "wOS.CombatSim.LeaderFont" )
			button:SetText( objectPanel.Value and "Yes" or "No" )
			button.DoClick = function(pan)
				objectPanel.Value = not objectPanel.Value
				pan:SetText( objectPanel.Value and "Yes" or "No" )
			end
		elseif settingType == WOS_CSS.CONFIG.NUMBER then
			objectPanel.Value = value or default or 0

			local wang = vgui.Create("DNumberWang", objectPanel)
			wang:SetSize( rw*0.3, rh*0.05 )
			wang:SetPos( rw*0.55, rh*0.05 )
			wang:SetFont( "wOS.CombatSim.LeaderFont" )
			wang:SetMin( minCount or 0 )
			wang:SetMax( maxCount or math.huge )
			wang:SetValue( objectPanel.Value )
			wang.Think = function( pan )
				objectPanel.Value = pan:GetValue()
			end
		elseif settingType == WOS_CSS.CONFIG.NSLIDER then
			objectPanel.Value = value or default or 0

			local panel = vgui.Create("DPanel", objectPanel)
			panel:SetSize( rw*0.3, rh*0.05 )
			panel:SetPos( rw*0.55, rh*0.05 )

			local slider = vgui.Create("DNumSlider", objectPanel)
			slider:SetSize( rw*0.45, rh*0.05 )
			slider:SetPos( rw*0.4, rh*0.05 )
			slider:SetMin( minCount or 0)
			slider:SetMax( maxCount or 10)
			slider:SetDecimals(0)
			slider:SetValue( objectPanel.Value )
			slider.Think = function( pan )
				pan:SetValue(math.Round(pan:GetValue()))
				objectPanel.Value = pan:GetValue()
			end
		elseif settingType == WOS_CSS.CONFIG.NSLIDERTOGGLE then
			if isbool( value ) && value == false then
				objectPanel.Value = false
			else
				objectPanel.Value = value or default or false
			end

			local panel = vgui.Create("DPanel", objectPanel)
			panel:SetSize( rw*0.3, rh*0.05 )
			panel:SetPos( rw*0.55, rh*0.05 )

			local slider = vgui.Create("DNumSlider", objectPanel)
			slider:SetSize( rw*0.45, rh*0.05 )
			slider:SetPos( rw*0.4, rh*0.05 )
			slider:SetMin( minCount or 0)
			slider:SetMax( maxCount or 10)
			slider:SetDecimals(0)

			local checkBox = vgui.Create("DCheckBox", objectPanel)
			checkBox:SetSize( rh*0.05, rh*0.05 )
			checkBox:SetPos( rw*0.55 - rh*0.1, rh*0.05 )

			if isbool(objectPanel.Value) and objectPanel.Value == false then
				checkBox:SetChecked(false)
				slider:SetValue( minCount )
				slider:SetMouseInputEnabled(false)
			else
				checkBox:SetChecked(true)
				slider:SetValue( objectPanel.Value )
			end
			
			function panel:Paint(ww, hh)
				if checkBox:GetChecked() then
					draw.RoundedBox(0, 0, 0, ww, hh, Color(255, 255, 255, 255))
				else
					draw.RoundedBox(0, 0, 0, ww, hh, Color(127, 127, 127, 127))
				end
			end
			
			slider.Think = function( pan )
				if checkBox:GetChecked() then
					pan:SetValue(math.Round(pan:GetValue()))
					objectPanel.Value = pan:GetValue()
					pan:SetMouseInputEnabled(true)
				else
					objectPanel.Value = false
					pan:SetMouseInputEnabled(false)
				end
			end
		elseif settingType == WOS_CSS.CONFIG.STRING then
			objectPanel.Value = value or default or ""

			local entry = vgui.Create("DTextEntry", objectPanel)
			entry:SetSize( rw*0.6, rh*0.05 )
			entry:SetPos( rw*0.25, rh*0.05 )
			entry:SetFont( "wOS.CombatSim.SmallFont" )
			entry:SetValue( objectPanel.Value )
			entry.Think = function( pan )
				objectPanel.Value = pan:GetValue()
			end
		elseif settingType == WOS_CSS.CONFIG.SDROPDOWN then
			objectPanel.Value = value or default or ""

			local comboBox = vgui.Create("DComboBox", objectPanel)
			comboBox:SetSize( rw*0.3, rh*0.05 )
			comboBox:SetPos( rw*0.55, rh*0.05 )
			comboBox:SetFont( "wOS.CombatSim.LeaderFont" )
			comboBox:SetValue( objectPanel.Value )
			for _, choice in pairs(values) do
				comboBox:AddChoice(choice)
			end
			comboBox.OnSelect = function( pan, index, value )
				objectPanel.Value = value
			end
		elseif settingType == WOS_CSS.CONFIG.COLOR then
			-- TODO: Implement Color Selector UI (Problem: Height)
		elseif settingType == WOS_CSS.CONFIG.MTABLE then
			objectPanel.Value = value or default or {}

			local listView = vgui.Create("DListView", objectPanel)
			listView:SetSize( rw*0.45, rh*0.1 )
			listView:SetPos( rw*0.4, 0 )
			listView:SetHeaderHeight(rh*0.02)
			listView:SetDataHeight(rh * 0.02)
			listView:AddColumn("Weapons")
			listView:SetMultiSelect(true)
			for _, weapon in pairs(weapons.GetList()) do
				if weapon.Spawnable then
					local line = listView:AddLine(weapon.ClassName)
					line:SetSelected(table.HasValue(objectPanel.Value, weapon.ClassName))
				end
			end
			function listView:OnRowRightClick(index, line)
                line:SetSelected(false)

				table.RemoveByValue(objectPanel.Value, line:GetValue(1))
			end
			function listView:OnRowSelected(index, line)
				line:SetSelected(true)

				table.insert(objectPanel.Value, line:GetValue(1))
				
				for k, line in pairs(self:GetLines()) do
					line:SetSelected(table.HasValue(objectPanel.Value, line:GetValue(1)))
				end
			end
		end
	end
end


function wOS.CombatSim:OpenToolPreImportMenu( events, is_sim, imported )
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end

	self.SimulatorMenu.SizeT = { w = w*0.43, h = h*0.66 }
	self.SimulatorMenu.Title = "IMPORT SELECTION"
	self.SimulatorMenu:Clear()

	timer.Simple( 0, function() self:AddExitButton( function() wOS.CombatSim:OpenToolImportSimulationMenu() end ) end )

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h

	local innerframe = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	innerframe.XScroll = false
	innerframe:SetSize( rw*0.95, rh*0.8 )
	innerframe:SetPos( rw*0.025, rh*0.1 )
	innerframe:SetPanelSize(rw * 0.85, rh * 0.1)
	innerframe:SetPanelSpacing(rw * 0.05)
	innerframe.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
	end

	innerframe.ObjectPanels = {}

	for _, data in pairs( events ) do
		local objectPanel = innerframe:CreatePanel("DPanel")
		objectPanel.Data = data
		objectPanel.Paint = function( pan, ww, hh )
			draw.RoundedBox( hh*0.1, 0, 0, ww, hh, wOS.CombatSim.FrameColor )
			DrawBlur( pan, 1 )

			draw.SimpleText(pan.Data.Name, "wOS.CombatSim.MediumFont", ww*0.01, hh*0.005, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
			
			if pan.Data.Simulator then
				draw.SimpleText( pan.Data.Simulator, "wOS.CombatSim.SmallFont",  ww*0.99, hh*0.005, white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP)
			end

			local word = wOS.PES.WrapText( pan.Data.Description, "wOS.CombatSim.DescFont", ww*0.8 )
			draw.DrawText( word, "wOS.CombatSim.DescFont", ww*0.01, hh*0.37, color_white, TEXT_ALIGN_LEFT ) 		
		
		end

		table.insert(innerframe.ObjectPanels, objectPanel)

		local ow, oh = objectPanel:GetSize()
		local button = vgui.Create("DButton", objectPanel)
		button:SetSize( ow*0.15, oh*0.45 )
		button:SetPos( ow*0.85, oh*0.55 )
		button.Data = data
		button:SetFont( "wOS.CombatSim.LeaderFont" )
		button:SetText( "Select" )
		button.DoClick = function(pan)
			wOS.CombatSim:OpenMenu()
			if is_sim then
				wOS.PES.RequestSimulationData(pan.Data.Name, function( simdata )
					wOS.CombatSim:OpenSimulationEditor( simdata, true, imported )
				end, pan.Data.ID )
			else
				wOS.PES.RequestEventData(pan.Data.Name, function( simdata )
					wOS.CombatSim:OpenSimulationEditor( simdata, true, imported )
				end )
			end
		end
		
	end

	return self.SimulatorMenu
end






















local white = Color(255, 255, 255)
local green = Color(0, 255, 0)
local cyan = Color(0, 255, 255)

local function DrawBorders(points, height, color)
	local prev = nil
	local prevtop = nil
	local first = nil
	local firsttop = nil

	for _, vec in pairs(points) do
		if not first then first = vec end

		local top = Vector(vec.x, vec.y, first.z + height)
		vec.z = first.z
		if not firsttop then firsttop = top end

		render.DrawLine(vec, top, color, false)

		if prev then
			render.DrawLine(vec, prev, color, false)
		end
		
		if prevtop then
			render.DrawLine(top, prevtop, color, false)
		end

		prevtop = top
		prev = vec
	end

	if prev and first then 
		render.DrawLine(prev, first, color, false)
	end
	if prevtop and firsttop then
		render.DrawLine(prevtop, firsttop, color, false)
	end
end

local function DrawPoints(points)
	local ply = LocalPlayer()
	local plyPos = ply:GetPos()
	
	local dx = ply:GetUp()
	local dy = ply:GetRight()

	local closest
	local disT = math.huge
	local hPos = ply:GetEyeTrace().HitPos
	for i, point in pairs(points or {}) do
		local dis = point.Position:Distance(hPos)
		if dis < disT then
			closest = i
			disT = dis
		end
	end

	local angle = dx:AngleEx(dx:Cross(-dy))
	angle:RotateAroundAxis(ply:GetForward(), 90)

	for i, point in pairs(points or {}) do
		local pos = point.Position
		local name = point.Name

		local textPos = pos + Vector(0, 0, 100)

		local color = white
		if i == closest then
			color = green
		end

		render.DrawLine(pos, textPos, color, false)

		cam.Start3D2D(textPos, angle, 1)
			draw.SimpleText(name or "Missing", "DermaDefault", 0, 0, color, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
		cam.End3D2D()   
	end
end

hook.Add( "PostDrawOpaqueRenderables", "wOS.CombatSim.ToolVisualization", function()
	local ply = LocalPlayer()

	local weapon = ply:GetActiveWeapon()
	if not (IsValid(weapon) and weapon:GetClass() == "wos_simulation_tool") then return end
	
	local simulator = weapon:GetSelectedSimulator()
	if simulator == weapon then return end
	
	if IsValid(simulator) then
		-- Draw Current Operation Overlay
		local mode = weapon:GetToolMode()
		local step = weapon:GetToolStep()

		if mode == WOS_CSS.MODE.AREASELECT then
			local corners = table.Copy(weapon.SelectedBorderPoints)
			local height = weapon.SelectedHeight
			
			if step == WOS_CSS.AREASELECT.BORDER then
				table.insert(corners, ply:GetEyeTrace().HitPos)
			elseif step == WOS_CSS.AREASELECT.HEIGHT then
				height = ply:GetEyeTrace().HitPos.z - corners[1].z
				DrawBorders(corners, height, green)
			end
			
			DrawBorders(corners, weapon.SelectedHeight, white)
		else
			local borderPointCount = simulator:GetBorderPointCount()

			if borderPointCount and borderPointCount > 0 then
				local corners = {}
				for i=1, borderPointCount do
					local v = simulator:GetNW2Vector("BorderPoint" .. i)
					table.insert(corners, v)
				end

				local inside
				if mode == WOS_CSS.MODE.POINTSELECT then
					inside = simulator:CheckInBorders(ply:GetEyeTrace().HitPos + Vector(0, 0, 10)) -- Offset because the floor isn't 100% inside.
				else
					inside = simulator:CheckInBorders(EyePos())
				end

				DrawBorders(corners, simulator:GetBorderHeight(), inside and green or cyan)
			end
		end
	end
	

end)

hook.Add("PreDrawHalos", "wOS.CombatSim.PreDrawHalos", function()
	local ply = LocalPlayer()

	local weapon = ply:GetActiveWeapon()
	if not (IsValid(weapon) and weapon:GetClass() == "wos_simulation_tool") then return end

	local simulator = weapon:GetSelectedSimulator()
	if simulator == weapon then return end
	
	if IsValid(simulator) then
		halo.Add({simulator}, cyan, 5)
	end
end)
--addons/billy_gas/lua/vgui/bvgui/blankpanel.lua:
derma.DefineControl("bVGUI.BlankPanel", nil, {})
--addons/billy_gas/lua/vgui/bvgui/grid.lua:
local PANEL = {}

bVGUI.GRID_ALIGN_LEFT   = 0
bVGUI.GRID_ALIGN_CENTER = 1
bVGUI.GRID_ALIGN_RIGHT  = 2

function PANEL:Init()
	self.Items = {}
	self.ColumnPadding = 0
	self.RowPadding = 0
	self.Alignment = bVGUI.GRID_ALIGN_CENTER

	function self.pnlCanvas:PerformLayout()
		self:GetParent():LayoutItems()
	end

	self.BottomPadding = vgui.Create("bVGUI.BlankPanel", self)
	self.BottomPadding:Dock(BOTTOM)
	self.BottomPadding:SetTall(1)
end

function PANEL:SetAlignment(alignment)
	self.Alignment = alignment
end

function PANEL:SetPadding(c,r)
	self:SetColumnPadding(c)
	self:SetRowPadding(r)
end

function PANEL:SetColumnPadding(padding)
	self.ColumnPadding = padding
end

function PANEL:SetRowPadding(padding)
	self.RowPadding = padding
end

function PANEL:AddToGrid(item)
	table.insert(self.Items, item)
end

function PANEL:LayoutItems()
	self:CalculateGridSize()

	local columns = math.floor(self:GetWide() / self.MinColumnSize)
	local column_w = self:GetWide() / columns
	local column_i = 0
	local column_x = 0
	local row_y = 0
	for _,child in ipairs(self.Items) do
		if (self.Alignment == bVGUI.GRID_ALIGN_CENTER) then
			child:SetPos(column_x + (column_w / 2 - child:GetWide() / 2), row_y + (self.MinRowSize / 2 - child:GetTall() / 2))
		elseif (self.Alignment == bVGUI.GRID_ALIGN_LEFT) then
			child:SetPos(column_x, row_y + (self.MinRowSize / 2 - child:GetTall() / 2))
		elseif (self.Alignment == bVGUI.GRID_ALIGN_RIGHT) then
			child:SetPos(column_x + (column_w - child:GetWide()), row_y + (self.MinRowSize / 2 - child:GetTall() / 2))
		end
		column_x = column_x + column_w

		column_i = column_i + 1
		if (column_i >= columns) then
			column_i = 0
			column_x = 0
			row_y = row_y + self.MinRowSize + self.RowPadding
		end
	end

	self.BottomPadding:SetPos(0, row_y - 1)

	self:InvalidateLayout(true)
end

function PANEL:CalculateGridSize()
	local biggest_column = 0
	local biggest_row = 0
	for _,child in ipairs(self.Items) do
		if (child:GetWide() > biggest_column) then
			biggest_column = child:GetWide()
		end
		if (child:GetTall() > biggest_row) then
			biggest_row = child:GetTall()
		end
	end
	self.MinRowSize = biggest_row + (self.RowPadding * 2)
	self.MinColumnSize = biggest_column + (self.ColumnPadding * 2)
end

derma.DefineControl("bVGUI.Grid", nil, PANEL, "bVGUI.ScrollPanel")
--addons/billy_gas/lua/vgui/bvgui/infobar.lua:
bVGUI.INFOBAR_COLOR_GREY = Color(62, 62, 62)
bVGUI.INFOBAR_COLOR_PURPLE = Color(104, 0, 160)

local PANEL = {}

function PANEL:Init()
	self:SetTall(30)
	self:SetMouseInputEnabled(true)
	self:DockPadding(5,0,5,4)

	self.OriginalBarColor = bVGUI.INFOBAR_COLOR_GREY
	self.TargetBarColor = self.OriginalBarColor
	self.BorderColor = bVGUI.DarkenColor(self.OriginalBarColor, 0.2)

	self.Label = vgui.Create("DLabel", self)
	self.Label:Dock(FILL)
	self.Label:SetContentAlignment(5)
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
end

function PANEL:SetText(text)
	self.Text = text
	self.Label:SetText(text)
end
function PANEL:GetText()
	return self.Text
end

function PANEL:SetColor(col_enum)
	self.OriginalBarColor = col_enum
	self.TargetBarColor = self.OriginalBarColor
	self.BorderColor = bVGUI.DarkenColor(self.OriginalBarColor, 0.2)
	self.Label:SetTextColor(bVGUI.TextColorContrast(col_enum))
end

function PANEL:OnCursorEntered()
	if (self.AllowCopy) then
		self.TargetBarColor = bVGUI.LightenColor(self.OriginalBarColor, 0.2)
		self.ColorInterpolation = bVGUI.LerpColor(self.OriginalBarColor, self.TargetBarColor, 0.5)
	end
end
function PANEL:OnCursorExited()
	if (self.AllowCopy) then
		self.ColorInterpolation = bVGUI.LerpColor(self.TargetBarColor, self.OriginalBarColor, 0.5)
		self.TargetBarColor = self.OriginalBarColor
	end
end
function PANEL:OnMousePressed()
	if (self.AllowCopy) then
		self.ColorInterpolation = nil
		self.TargetBarColor = self.BorderColor
		self:DockPadding(5,0,5,0)
		self:InvalidateLayout(true)
	end
end
function PANEL:OnMouseReleased()
	if (self.AllowCopy) then
		if (GAS) then
			GAS:SetClipboardText(self:GetText())
		else
			SetClipboardText(self:GetText())
			bVGUI.MouseInfoTooltip.Create(bVGUI.L("copied"))
		end

		if (self:IsHovered()) then
			self.TargetBarColor = bVGUI.LightenColor(self.OriginalBarColor, 0.2)
		else
			self.TargetBarColor = self.OriginalBarColor
		end
		self:DockPadding(5,0,5,4)
		self:InvalidateLayout(true)
	end
end

function PANEL:Paint(w,h)
	if (self.ColorInterpolation) then
		self.ColorInterpolation:DoLerp()
		surface.SetDrawColor(self.ColorInterpolation:GetColor())
	else
		surface.SetDrawColor(self.TargetBarColor)
	end
	if (self.DrawBorder ~= false) then
		local col
		if (self.ColorInterpolation) then
			col = self.ColorInterpolation:GetColor()
		else
			col = self.TargetBarColor
		end
		draw.RoundedBox(4, 0, 0, w, h, self.BorderColor)
		draw.RoundedBoxEx(4, 0, 0, w, h - 4, col, true, true)
	else
		surface.DrawRect(0,0,w,h)
	end
end

function PANEL:SetDrawBorder(draw_border)
	self.DrawBorder = draw_border
	if (draw_border == false) then
		self:DockPadding(0,0,0,0)
	else
		self:DockPadding(0,0,0,4)
	end
end
function PANEL:GetDrawBorder()
	return self.DrawBorder
end

function PANEL:AllowCopy()
	self.AllowCopy = true
	self:SetCursor("hand")
end

derma.DefineControl("bVGUI.InfoBar", nil, PANEL, "DPanel")
--gamemodes/starwarsrp/gamemode/dermatemplate.lua:
--asas
AOCDerma = AOCDerma or {}

function AOCDerma:RegisterFont(name, font, size, weight)
    PIXEL.RegisterFont(name, font, size, weight)
    return AOCDerma:Font(name)
end



function AOCDerma:Font(fontname)
    return PIXEL.UI.RegisteredFonts[fontname]
end



AOCDerma:RegisterFont("AOCRP_DefaultFrame_CloseBtn", "Aurebesh", 50, 100)

AOCDerma:RegisterFont("AOCRP_DefaultFrame_Title", "Agency FB", 50, 1000)
AOCDerma:RegisterFont("AOCRP_DefaultFrame_Title_Aurebesh", "Aurebesh", 30, 100)


AOCDerma:RegisterFont("AOCRP_TextEntry_Placeholder", "Agency FB", 40, 100)

AOCDerma:RegisterFont("AOCRP_TemplateDefaultButton", "Agency FB", 40, 100)


function AOCDerma:DF(typ, size, weight)
    if !AOCRP.Config.Fonts[typ] then typ = AOCRP.Config.Fonts["l"] end 
    if !size then size = 20 end
    if !weight then weight = 100 end
    
    return self:xFont("!"..AOCRP.Config.Fonts[typ].."@"..size.."#"..weight)
end

function AOCDerma:HexToColor(hexString)
    local red = tonumber(hexString:sub(2,3), 16)
    local green = tonumber(hexString:sub(4,5), 16)
    local blue = tonumber(hexString:sub(6,7), 16)
    return Color(red, green, blue)
end

function AOCDerma:DrawTextShadow(string, font, x, y, color, align, shadowcolor)

    if shadowcolor then 
        if !IsColor(shadowcolor) then shadowcolor = Color(0,0,0) end
    else
        shadowcolor = Color(0,0,0) 
    end

    draw.DrawText(string,font, x+1, y+1, shadowcolor, align)
    draw.DrawText(string,font, x, y, color, align)
    
end



function AOCDerma:WrapText(text, font, maxWidth)
    surface.SetFont(font)

    local words = string.Explode(" ", text)
    local lines = {""}
    local currentLine = 1

    for i = 1, #words do
        local word = words[i]
        local line = lines[currentLine] .. " " .. word
        local lineWidth = surface.GetTextSize(line)

        if lineWidth > maxWidth then
            currentLine = currentLine + 1
            lines[currentLine] = word
        else
            lines[currentLine] = line
        end
    end

    return table.concat(lines, "\n")
end

local function IsUrl(str)
   local pattern = "https?://%S+"
   return string.match(str, pattern) ~= nil
end

function AOCDerma:PlayURL(url)

    if IsUrl(url) then
        local soundObject = sound.PlayURL(url, "", function(station) 
        
            if (IsValid(station)) then
                station:Play()
            end
        end)
    else
        surface.PlaySound( url )
    end

end


function AOCDerma:Panel(parent)
    local boardpanel = vgui.Create("DPanel",parent)
    
    function boardpanel:Paint(w,h)
        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))
       	surface.SetDrawColor( 255, 255, 255, 255 )
	    surface.DrawOutlinedRect( AOCW(4), AOCH(4), w-AOCW(8),h-AOCH(8), 2 )
    end

    return boardpanel
end

function AOCDerma:AddLineBreaks(str, maxLineLength)
  -- Initialize the modified string
  local modifiedStr = ""
  -- Split the string into words
  local words = string.Explode(" ", str)
  -- Keep track of the current line length
  local lineLength = 0
  -- Iterate through the words
  for _, word in pairs(words) do
    -- If the word will fit on the current line, add it to the modified string
    if lineLength + #word <= maxLineLength then
      modifiedStr = modifiedStr .. word .. " "
      lineLength = lineLength + #word + 1
    else
      -- If the word won't fit, add a line break and start a new line
      modifiedStr = modifiedStr .. "\n" .. word .. " "
      lineLength = #word + 1
    end
  end
  -- Return the modified string
  return modifiedStr
end

function AOCDerma:TextEntry(panel,placeholder)
	local TextEntry = vgui.Create( "DTextEntry", panel ) -- create the form as a child of frame

    TextEntry:SetFont(PIXEL.UI.RegisteredFonts["AOCRP_TextEntry_Placeholder"])
    TextEntry:SetPlaceholderText(placeholder)
    TextEntry:SetTextColor(Color(255,255,255,255))
    TextEntry:SetPlaceholderColor(Color(200,200,200))
    TextEntry:SetCursorColor(Color(255,255,255,255))
    TextEntry:SetDrawBackground(false)
    TextEntry:SetDrawBorder(true)
    function TextEntry:PaintOver(w,h) 
        surface.SetDrawColor( 255, 255, 255, 128 )
        surface.DrawOutlinedRect(0,0,w,h,1)
        return
    end
	return TextEntry
end

function AOCDerma:Button(panel, text, func, style)
    style = style or "b"
    local DButton = vgui.Create("DButton",panel)

    DButton:SetText("")
    DButton.textfont = PIXEL.UI.RegisteredFonts["AOCRP_TemplateDefaultButton"]
    surface.SetFont(DButton.textfont)
    local textW, textH = surface.GetTextSize(text)

    DButton:SetTall(textH+AOCH(10))
   DButton:SetWide(textW+AOCW(30))

    function DButton:SetNewText(text)
        self.printtext = text

        surface.SetFont(DButton.textfont)
        local textW, textH = surface.GetTextSize(text)
    
        DButton:SetTall(textH+AOCH(10))
        DButton:SetWide(textW+AOCW(30))
    end

    DButton.printtext = text
    DButton.btncolor = Color(0,0,0,210)
    DButton.akzent = Color(200,200,200,255)
    DButton.akzenthover = Color(255,255,255,255)
    DButton.textcolor = Color(200,200,200,255)
    DButton.textcolorhover = Color(255,255,255,255)
    DButton.akcl = DButton.akzent
    DButton.txtcl = DButton.textcolor
    DButton.akzentsize = 3
    DButton.fillcolor = Color(0,0,0,200)
    local top = false 
    local bot = false 
    local left = false 
    local right = false
    local fill = false
    if string.find(style, "t") then top = true end
    if string.find(style, "b") then bot = true end
    if string.find(style, "l") then left = true end
    if string.find(style, "r") then right = true end
    if string.find(style, "c") then fill = true end
    function DButton:Paint(w,h)


        if self:IsHovered() then
            self.akcl = self.akzenthover
            self.txtcl = self.textcolorhover
        else
            self.akcl = self.akzent
            self.txtcl = self.textcolor
        end
        if fill then
            draw.RoundedBox(0, 0, 0, w, h, DButton.fillcolor)
        end
        if top then
        draw.RoundedBox(0, 0, 0, w, self.akzentsize, DButton.akcl)
        end
        if bot then
        draw.RoundedBox(0, 0, h-self.akzentsize, w, self.akzentsize, DButton.akcl)
        end   

        if left then
            draw.RoundedBox(0, 0, 0, self.akzentsize, h, DButton.akcl)
        end

        if right then
            draw.RoundedBox(0, w-self.akzentsize, 0, self.akzentsize, h, DButton.akcl)
        end
    
        
        surface.SetFont(self.textfont)
        local txtW, txtH = surface.GetTextSize(text)


        draw.DrawText(self.printtext,self.textfont,w/2,h/2-txtH/2,self.txtcl, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    function DButton:OnCursorEntered()
        surface.PlaySound("everfall/miscellaneous/ux/navigation/navigation_slider_02.mp3")
    end
    function DButton:DoClickInternal()
        surface.PlaySound("everfall/miscellaneous/ux/navigation/navigation_activate_01.mp3")
	end

    function DButton:DoClick()
        func(self)
    end
    return DButton
end


function AOCDerma:FormatMoney(amount)
    local formatted = tostring(amount)
    local k = formatted:len() % 3
    if k == 0 then k = 3 end
    local result = formatted:sub(1, k)
    while k < formatted:len() do
        result = result .. "." .. formatted:sub(k + 1, k + 3)
        k = k + 3
    end
    return "$ " .. result
end

function AOCDerma:CreateLoadingScreen(text)

    --if self.WELCOMEFRAME then self.WELCOMEFRAME:Remove() end
    loadingscreen = vgui.Create("DFrame") -- The name of the panel we don't have to parent it.
    loadingscreen:SetSize(ScrW(), ScrH()) -- Set the size to 300x by 200y.
    loadingscreen:Center()
    loadingscreen:SetTitle("") -- Set the title in the top left to "Derma Frame".
    loadingscreen:MakePopup() -- Makes your mouse be able to move around.
    loadingscreen:SetDraggable(false)
    loadingscreen:SetSizable(false)
    loadingscreen:ShowCloseButton( false )
    loadingscreen.text = text


    local closeBtn = AOCDerma:Button(loadingscreen, "Abbrechen", function() RunConsoleCommand("retry") end, "tl")
    closeBtn:SetPos(0,0)
    closeBtn:SetVisible(false)

    local mat = Material("aoc/welcome/"..math.random(6)..".png")

    --if !IsValid(mat) then loadingscreen:Remove() AOCDerma:MissingContent() end

    lastTime = CurTime()
    local points = ""

    local startTime = CurTime() + 10

    function loadingscreen:Paint(w,h)

        if CurTime() > startTime then
            closeBtn:SetVisible(true)
        end

        if CurTime() > lastTime then
            lastTime = CurTime() + 0.2
            if #points > 30 then 
                points = ""
            else
                points = points .. string.char(math.random(97, 122))
            end

        end
 

        surface.SetMaterial( mat )
        surface.SetDrawColor( 255, 255, 255, 255 )
        surface.DrawTexturedRect( 0, 0, w, h )

            PIXEL.DrawBlur(self, 0, 0, w, h)
            PIXEL.DrawBlur(self, 0, 0, w, h)
            PIXEL.DrawBlur(self, 0, 0, w, h)
            PIXEL.DrawBlur(self, 0, 0, w, h)


                draw.DrawText(self.text, PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_Name"], w/2+2, h-AOCH(98), Color(0,0,0), TEXT_ALIGN_CENTER )

        draw.DrawText(self.text, PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_Name"], w/2, h-AOCH(100), Color(255,255,255), TEXT_ALIGN_CENTER )


        draw.DrawText(points, PIXEL.UI.RegisteredFonts["AOCRP_Loading_Aurebesh"], w/2+2, h-AOCH(48), Color(0,0,0), TEXT_ALIGN_CENTER )    
        draw.DrawText(points, PIXEL.UI.RegisteredFonts["AOCRP_Loading_Aurebesh"], w/2, h-AOCH(50), Color(255,255,255), TEXT_ALIGN_CENTER )

    end

    return loadingscreen

end



function AOCDerma:DefaultFrame(title)

    title = title or "Unbenanntes Fenster"


    local MainFrame = vgui.Create("DFrame")
      MainFrame:SetSize( AOCW(600), AOCH(400) )
    MainFrame:Center()
  
    MainFrame:SetDraggable(true)
    MainFrame:SetTitle("")
    MainFrame:ShowCloseButton(false)
    MainFrame:SetSizable(true)
    MainFrame:MakePopup()
    MainFrame:DockPadding(25, 25, 25, 25)
    MainFrame:SetMinimumSize( AOCW(400), AOCH(200) )
    surface.PlaySound("everfall/miscellaneous/ux/navigation/navigation_tab_02.mp3")

    local btnWide = 70
    local btnHeight = 25
    local lineColor = Color(255,255,255)
    function MainFrame:Paint(w,h)
        PIXEL.DrawBlur(self, 0, 0, w, h)
        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,210))

        draw.RoundedBox(0,10,10,5,h-20,lineColor)

        draw.RoundedBox(0,10,10,w- btnWide - 30,5,lineColor)


        draw.RoundedBox(0,10,h-15,w-20,5,lineColor)
        
        draw.RoundedBox(0,w-15,10+btnHeight+10,5,h-20-btnHeight-10,lineColor)
    end

    function MainFrame:Think()
        AOCRP_DefaultFrameOpen = self 

		if input.IsKeyDown( AOCRP_Binds:FindBindByID("quickclose") ) or input.IsKeyDown( KEY_ESCAPE ) then
            AOCRP_SUPRESS_ESCAPE_MENU = true 
            timer.Simple(2, function() AOCRP_SUPRESS_ESCAPE_MENU = false end)
			self:Remove()
		end
    end

    function MainFrame:OnRemove()
        AOCRP_DefaultFrameOpen = nil
    end

    
    local TitlePanel = vgui.Create("DPanel",MainFrame)
    TitlePanel:Dock(TOP)
      TitlePanel:SetTall(AOCH(55))
    TitlePanel:DockMargin(0,0,0,5)
      local textPadding = 20
      title = string.upper(title)

    function MainFrame:SetNewTitle(text)
        title = string.upper(text)
    end
      
    local currentFont = PIXEL.UI.RegisteredFonts["AOCRP_DefaultFrame_Title"]
    function TitlePanel:Paint(w,h)

        	--surface.SetTextColor( 255, 255, 255 ) -- Set text color
	--surface.SetTextPos( 10,0 ) -- Set text position, top left corner
	--surface.SetFont( PIXEL.UI.RegisteredFonts["AOCRP_DefaultFrame_Title"] ) -- Set the font
	--surface.DrawText( "Einheitsverwaltung" ) -- Draw the text

    surface.SetFont( currentFont ) -- Set the font
    local textW, textH = surface.GetTextSize( title )

        
        --draw.RoundedBox(0,textW+textPadding,0,1,h,lineColor)

        draw.RoundedBox(0,0,0,textW+textPadding,h-3,Color(255,255,255))

          draw.DrawText(title,currentFont,10,0,Color(0,0,0),TEXT_ALIGN_LEFT)

    end




    local CloseButton = vgui.Create("DButton",MainFrame)
    CloseButton:SetText("")

    function CloseButton:Paint(w,h)
        draw.RoundedBox(0,0,0,w,h,Color(155,0,0,255))
    end
    function CloseButton:OnCursorEntered()
        surface.PlaySound("everfall/miscellaneous/ux/navigation/navigation_slider_02.mp3")
    end

    function ResizeButtonToFrameSize(w,h)
        CloseButton:SetPos(w- btnWide - 10,10)
        CloseButton:SetSize( btnWide, btnHeight )
    end
    
    function CloseButton:DoClick()
             surface.PlaySound("everfall/miscellaneous/ux/navigation/navigation_activate_01.mp3")
        MainFrame:Remove()
    end
    
    ResizeButtonToFrameSize(MainFrame:GetWide(),MainFrame:GetTall())

    function MainFrame:OnSizeChanged( w, h )
        ResizeButtonToFrameSize(w,h)

    end



    return MainFrame
end

function AOCDerma:ScrollBar(parent) 
    local DScrollPanel = vgui.Create("DScrollPanel", parent)
    --DScrollPanel:SetSize(400, 250)
    --DScrollPanel:Center()

    local sbar = DScrollPanel:GetVBar()
    function sbar:Paint(w, h)
        draw.RoundedBox(0, AOCW(5), 0, AOCW(10), h, Color(0, 0, 0, 100))
    end
    function sbar.btnUp:Paint(w, h)
        --draw.RoundedBox(0, AOCW(5), 0, AOCW(10), h, Color(175, 175, 175))
    end
    function sbar.btnDown:Paint(w, h)
        --draw.RoundedBox(0, AOCW(5), 0, AOCW(10), h, Color(175, 175, 175))
    end
    function sbar.btnGrip:Paint(w, h)
        draw.RoundedBox(0, AOCW(5), 0, AOCW(10), h, Color(255, 255, 255))
    end

    return DScrollPanel
end




function AOCDerma:OpenWebPage(title,url)

    if ValidPanel(AOCRulesFrame) then AOCRulesFrame:Remove() end
    AOCRulesFrame = AOCDerma:DefaultFrame()
    AOCRulesFrame:SetSize(AOCW(1800),AOCH(1000))
    AOCRulesFrame:Center()
    AOCRulesFrame:SetNewTitle(title)
    AOCRulesFrame:SetSizable(false)
    AOCRulesFrame:SetDraggable(false)

    local html = vgui.Create("DHTML", AOCRulesFrame)
    html:Dock(FILL)
    html:OpenURL(url)

end



local NoChromium = [[
    Du wrdest jetzt eine Videosequenz sehen.
    Leider hast du nicht die Chromium Version von Garrys Mod.
    Viele unserer Features bentigen diese Version
    Besuche www.ageofclones.de/chromium fr mehr Infos.
]]

local SkipButton = KEY_E

local TopBlackBar = true
local BottomBlackBar = true
local SkipText = "Drcke [E] zum berspringen."

function AOCDerma:OpenYoutubeVideo( id, volume, startSeconds, endSeconds )
    
    volume = volume or 100
    startSeconds = startSeconds or 0
    endSeconds = endSeconds or -1



	if BRANCH == "x86-64" then

            local secondManipulation = "event.target.loadVideoById( { videoId: videoId, startSeconds: "..startSeconds.."});\n"

            if endSeconds != -1 then 
                secondManipulation = "event.target.loadVideoById( { videoId: videoId, startSeconds: "..startSeconds..", endSeconds: "..endSeconds.."});\n"
            end

            local VideoPlayer = [[

                    <div id="player"></div>
                    
                    <script src="https://www.youtube.com/player_api"></script>
                    
                    <script>
                        
                // create youtube player
                var player;
            
                const plywidth  = window.innerWidth || document.documentElement.clientWidth || 
                document.body.clientWidth;
                const plyheight = window.innerHeight|| document.documentElement.clientHeight|| 
                document.body.clientHeight;
            
                function onYouTubePlayerAPIReady() {
                    player = new YT.Player('player', {
                      height: '100%',
                      width: '100%',
                      playerVars: { 'autoplay': 1, 'controls': 0, 'disablekb': 1, 'iv_load_policy': 3, 'modestbranding': 1, 'showinfo': 0},
                      videoId: videoId,
                      events: {
                        'onReady': onPlayerReady,
                        'onStateChange': onPlayerStateChange,
                        'onError': onPlayerError
                      }
                    });
            
                }
            
                // autoplay video
                function onPlayerReady(event) {
                    ]]..secondManipulation..[[
                    event.target.setVolume(]] .. volume .. [[);
                    event.target.playVideo();
                }
            
                function onPlayerError(event) {
                    console.luaprint('ef');
                }
                // when video ends
                function onPlayerStateChange(event) {        
                    if(event.data === 0) {            
                        console.luaprint('vf');
                    }
                }
                
            </script>
            
            ]]


            if AOCVideoFrame then AOCVideoFrame:Remove() end
			AOCVideoFrame = vgui.Create("DFrame")
			AOCVideoFrame:SetSize(ScrW(), ScrH())
			AOCVideoFrame:SetTitle(" ")
			AOCVideoFrame:Center()
            AOCVideoFrame:SetDraggable(false)
            AOCVideoFrame:ShowCloseButton(false)
			AOCVideoFrame:MakePopup()

            function AOCVideoFrame:Paint(w,h)
                draw.RoundedBox(0, 0, 0, w, h, Color(0,0,0,255))
            end

			local html = vgui.Create("DHTML", AOCVideoFrame)
			html:Dock(FILL)


            local idCode = 'const videoId = "' .. id .. '";'

            local fullHTML = [[<script language="javascript">]] .. idCode .. [[</script>]] .. VideoPlayer

            html:SetHTML(fullHTML)

				html:AddFunction( "console", "luaprint", function( str )
					if str == "vf" then
						if AOCVideoFrame then
							AOCVideoFrame:Remove()
						end
					end
					if str == "ef" then
						if AOCVideoFrame then
							AOCVideoFrame:Remove()
							LocalPlayer():ChatPrint("*** Es gab einen Fehler beim Starten der Videosequenz.")
						end 
					end
				end)
            html:KillFocus()

            local DPanel = vgui.Create( "DPanel", AOCVideoFrame )
            DPanel:SetPos( 0, 0 ) -- Set the position of the panel
            DPanel:SetSize( AOCVideoFrame:GetWide(), AOCVideoFrame:GetTall() ) -- Set the size of the panel
            DPanel:SetBackgroundColor(Color(255, 64, 64, 100))
            function DPanel:Paint(w,h)
                    if BottomBlackBar then
                        draw.RoundedBox(0, 0, ScrH()*0.94, ScrW(), 57, Color(0,0,0,255))
                    end
                	draw.WordBox( 5, w*0.988, h*0.95, " " .. SkipText .. " ", "DermaLarge", Color( 0, 0, 0 ), Color( 255, 255, 255 ), TEXT_ALIGN_RIGHT )
                    if TopBlackBar then
                        draw.RoundedBox(0, 0, ScrH()*0.035, ScrW(), 57, Color(0,0,0,255))
                    end
           
                    if input.IsKeyDown( SkipButton ) then
                        if AOCVideoFrame then
                            AOCVideoFrame:Remove()
                        end
                    end

            end
	
	else
        AOCDerma:Derma_Message(NoChromium, "ACHTUNG", "Ok")
	end
end


function AOCDerma:MissingContent()
    local text = [[Dir fehlen wichtige Spielinhalte um Age of Clones spielen zu knnen.
Ohne diese Inhalte wird dein Erlebnis erheblich beeintrchtigt.
Besuche folgende Website fr mehr Hilfe:
www.ageofclones.de/content]]

    AOCDerma:Derma_Message(text, "ACHTUNG", "Ok cool")
end

AOCDerma:RegisterFont("AOCRP_MessageText", "Agency FB", 40, 100)
function AOCDerma:Derma_Message( strText, strTitle, strButtonText )

	local Window = AOCDerma:DefaultFrame()
	Window:SetNewTitle( strTitle or "Message" )
	Window:SetDraggable( true )
    Window:SetSizable(true)
	Window:ShowCloseButton( false )
	Window:SetBackgroundBlur( true )
	Window:SetDrawOnTop( true )


	local Text = vgui.Create( "DLabel", Window )
	Text:SetText( strText or "Message Text" )
    Text:SetFont(PIXEL.UI.RegisteredFonts["AOCRP_MessageText"])
	Text:SizeToContents()
	Text:SetTextColor( color_white )
    --Text:Dock(TOP)
	Text:SetContentAlignment( 5 )
    Text:SetPos(AOCW(25), AOCH(75))
	local Button =  AOCDerma:Button(Window, strButtonText or "Ok", function() Window:Close() end, "b")
    Button:Dock(BOTTOM)

	local w, h = Text:GetSize()

	Window:SetSize( w + 70, h + 150)
	Window:Center()


	Window:MakePopup()
	Window:DoModal()
	return Window


end

function AOCDerma:DermaApprove( strText, strTitle, approveFunc, denyFunc, approveText, denyText )

	local Window = AOCDerma:DefaultFrame()
	Window:SetNewTitle( strTitle or "Message" )
	Window:SetDraggable( true )
    Window:SetSizable(true)
	Window:ShowCloseButton( false )
	Window:SetBackgroundBlur( true )
	Window:SetDrawOnTop( true )


	local Text = vgui.Create( "DLabel", Window )
	Text:SetText( strText or "Message Text" )
    Text:SetFont(PIXEL.UI.RegisteredFonts["AOCRP_MessageText"])
	Text:SizeToContents()
	Text:SetTextColor( color_white )
    --Text:Dock(TOP)
	Text:SetContentAlignment( 5 )
    Text:SetPos(AOCW(25), AOCH(75))


    local btnPanel = vgui.Create("DPanel", Window)
    btnPanel:SetTall(AOCH(50))
    btnPanel:Dock(BOTTOM)
    btnPanel:SetPaintBackground(false)

	local Button =  AOCDerma:Button(btnPanel, approveText or "Ok", function() Window:Close() approveFunc() end, "bl")
    Button:Dock(LEFT)
    Button.akzent = Color(0,200,0,255)
    Button.akzenthover = Color(0,255,0,255)

    local Button =  AOCDerma:Button(btnPanel, denyText or "Nein", function() Window:Close() denyFunc() end, "br")
    Button:Dock(RIGHT)
    Button.akzent = Color(200,0,0,255)
    Button.akzenthover = Color(255,0,0,255)
	local w, h = Text:GetSize()

	Window:SetSize( w + 70, h + 200)
	Window:Center()


	Window:MakePopup()
	Window:DoModal()
	return Window


end


function AOCDerma:CreateMap()
    if ValidPanel(AOCDerma.MapFrame) then AOCDerma.MapFrame:Remove() end
    AOCDerma.MapFrame = AOCDerma:DefaultFrame()
    AOCDerma.MapFrame:SetSize(ScrW()*.75,ScrH()*.90)
    AOCDerma.MapFrame:SetNewTitle("bersichtskarte")
    AOCDerma.MapFrame:Center()

    local map = vgui.Create("DMap",AOCDerma.MapFrame )
	map:Dock(FILL)
end



function AOCDerma:Derma_RequestString( strTitle, strText, strButtonText, callback )

	local Window = AOCDerma:DefaultFrame()
	Window:SetNewTitle( strTitle or "Message" )
	Window:SetDraggable( true )
    Window:SetSizable(true)
	Window:ShowCloseButton( false )
	Window:SetBackgroundBlur( true )
	Window:SetDrawOnTop( true )


	local Text = vgui.Create( "DLabel", Window )
	Text:SetText( strText or "Message Text" )
    Text:SetFont(PIXEL.UI.RegisteredFonts["AOCRP_MessageText"])
	Text:SizeToContents()
	Text:SetTextColor( color_white )
    --Text:Dock(TOP)
	Text:SetContentAlignment( 5 )
    Text:Dock(TOP)

    local entry = AOCDerma:TextEntry(Window,"")
    entry:SetTall(AOCH(50))
    entry:Dock(TOP)
    entry:DockMargin(0,AOCH(5),0,0)


	local Button =  AOCDerma:Button(Window, strButtonText or "Ok", function() 
        Window:Close() 
    
        callback(entry:GetValue())
    end, "b")
    Button:Dock(BOTTOM)

	surface.SetFont(PIXEL.UI.RegisteredFonts["AOCRP_MessageText"])
    local w, h = surface.GetTextSize(strText)



	Window:SetSize( w + AOCW(70), h + AOCH(230))
	Window:Center()


	Window:MakePopup()
	Window:DoModal()
	return Window


end


function AOCDerma:SmallStringRequest( strText, callback, default, filter, callbackDeny )

    
    if !filter then filter = "[^%w%s]" end 
  

	local Window = vgui.Create("DFrame")
	--Window:SetNewTitle( strTitle or "Message" )

    Window:SetSize(AOCW(700), AOCH(200))
	Window:ShowCloseButton( false )
	Window:SetBackgroundBlur( true )
	Window:SetDrawOnTop( true )
    Window:SetTitle("")
    function Window:Paint(w,h)
        Derma_DrawBackgroundBlur( self, self.m_fCreateTime )
    end

    function Window:Think()
        AOCRP_DefaultFrameOpen = self 

		if input.IsKeyDown( AOCRP_Binds:FindBindByID("quickclose") ) or input.IsKeyDown( KEY_ESCAPE ) then
            AOCRP_SUPRESS_ESCAPE_MENU = true 
            timer.Simple(2, function() AOCRP_SUPRESS_ESCAPE_MENU = false end)
			self:Remove()
            callbackDeny()
		end
    end

	local Text = vgui.Create( "DLabel", Window )
	Text:SetText( strText or "Message Text" )
    Text:SetFont(PIXEL.UI.RegisteredFonts["AOCRP_MessageText"])
	Text:SizeToContents()
	Text:SetTextColor( color_white )
    --Text:Dock(TOP)
	Text:SetContentAlignment( 5 )
    Text:Dock(TOP)

    local entry = AOCDerma:TextEntry(Window,"")
    entry:SetTall(AOCH(50))
    entry:Dock(TOP)
    entry:DockMargin(0,AOCH(5),0,0)
    entry:RequestFocus()
    entry:SetUpdateOnType(true)
    entry:SetValue(default)

    function entry:OnEnter(val) 
        Window:Close() 
        callback(val)
    end

    if filter != "" then
            -- Function to filter text input
        local function FilterTextInput(str)
            -- Define pattern to allow only alphanumeric characters and spaces
            local pattern = "[^%w%s]"
            return string.gsub(str, pattern, "")
        end

        -- Event handler for text input
        entry.OnTextChanged = function(self)
            local currentText = self:GetValue()
            local filteredText = FilterTextInput(currentText)
            -- Set the filtered text back to the text entry
            if currentText ~= filteredText then
                self:SetText(filteredText)
            end
        end
    end

    local btnPanel = vgui.Create("DPanel", Window)
    btnPanel:Dock(BOTTOM)
    btnPanel:SetDrawBackground(false)
    btnPanel:SetTall(AOCH(50))

	local Button =  AOCDerma:Button(btnPanel, "Absenden", function() 
        Window:Close() 
        
    
        callback(entry:GetValue())
    end, "b")
    Button:Dock(RIGHT)
    Button:DockMargin(0,AOCH(10),0,0)
    Button.akzent = Color(0,200,0,255)
    Button.akzenthover = Color(0,255,0,255)

    local Button =  AOCDerma:Button(btnPanel, "Abbrechen", function() 
        Window:Close() 
        callbackDeny()
    end, "b")
    Button:Dock(LEFT)
    Button.akzent = Color(255,0,0,255)
    Button.akzenthover = Color(255,0,0,255)




	Window:Center()


	Window:MakePopup()
	Window:DoModal()

    Window.TextEntry = entry
	return Window


end


function AOCDerma:GetTextSize(text, font)
    surface.SetFont(font)
    return surface.GetTextSize( text )
end


function AOCDerma:DataPad()

    surface.PlaySound("aoc2/datapad_open.mp3")


    if ValidPanel(AOCRP_DefaultFrameOpen) then AOCRP_DefaultFrameOpen:Remove() end

    local frame = vgui.Create("DFrame")
    frame:SetSize( AOCW(1920), AOCH(1080) )
    frame:Center()
  
    frame:SetDraggable(false)
    frame:SetTitle("")
    frame:ShowCloseButton(false)
    frame:SetSizable(false)
    frame:MakePopup()
    frame:DockPadding(25, 25, 25, 25)



    local datapadMaterial = Material("ageofclones/datapad.png")

    function frame:Paint(w,h)
        --PIXEL.DrawBlur(self, 0, 0, w, h)


        surface.SetMaterial(datapadMaterial)
        surface.SetDrawColor(255,255,255,255)
        surface.DrawTexturedRect(0,0,w,h)
    end

    function frame:Think()
        AOCRP_DefaultFrameOpen = self 

		if input.IsKeyDown( AOCRP_Binds:FindBindByID("quickclose") ) or input.IsKeyDown( KEY_ESCAPE ) then
            AOCRP_SUPRESS_ESCAPE_MENU = true 
            timer.Simple(2, function() AOCRP_SUPRESS_ESCAPE_MENU = false end)
			self:Remove()
		end
    end

    function frame:OnRemove()
        AOCRP_DefaultFrameOpen = nil
    end

    local closeBtn = vgui.Create("DButton", frame)
    closeBtn:SetPos(AOCW(1790), AOCH(160))
    closeBtn:SetSize(AOCW(80),AOCH(150))
    closeBtn:SetText("")

    function closeBtn:DoClick(clr, btn)
        if ValidPanel(AOCRP_DefaultFrameOpen) then AOCRP_DefaultFrameOpen:Remove() end
    end
    function closeBtn:Paint(w,h)
    end

    return frame
end

AOCDerma:RegisterFont("QuickLabel", "Agency FB", 30, 10)

function AOCDerma:QuickLabel(text, panel, font, color)

    font = font or AOCDerma:Font("QuickLabel")
    color = color or Color(255,255,255)
    local loading = Label(text, panel)
    loading:Dock(TOP)
    loading:SetFont(font)
    loading:SetTextColor(color)
    loading:SizeToContents()

    return loading
end 


function AOCDerma:Scale(value)
    return math.max(value * (ScrH() / 1440), 1)
end

-- IMGUI FONT

-- String->Bool mappings for whether font has been created
local _createdFonts = {}

-- Cached IMGUIFontNamd->GModFontName
local _imguiFontToGmodFont = {}

local EXCLAMATION_BYTE = string.byte("!")
function AOCDerma:xFont(font, defaultSize)
	-- special font
	if string.byte(font, 1) == EXCLAMATION_BYTE then

		local existingGFont = _imguiFontToGmodFont[font]
		if existingGFont then
			return existingGFont
		end

		-- Font not cached; parse the font
		local name, size, weight = font:match("!([^@]+)@([^#]+)#(.+)")
		if size then size = tonumber(size) end
		if weight then weight = tonumber(weight) end

		if not size and defaultSize then
			name = font:match("^!([^@]+)$")
			size = defaultSize
		end

		weight = weight or 1  -- Default weight if not specified
        print(weight)

		local fontName = string.format("AOCNEW_%s_%d_%d", name, size, weight)
		_imguiFontToGmodFont[font] = fontName
		if not _createdFonts[fontName] then
			surface.CreateFont(fontName, {
				font = name,
				size = AOCDerma:Scale(size),
				weight = weight
			})
			_createdFonts[fontName] = true
		end

		return fontName
	end
	return font
end




local blurMat = Material("pp/blurscreen")
local scrW, scrH = ScrW, ScrH
function AOCDerma:DrawBlur(panel, localX, localY, w, h, blurNum)
    local x, y = panel:LocalToScreen(localX, localY)
    local scrw, scrh = scrW(), scrH()

    surface.SetMaterial(blurMat)
    surface.SetDrawColor(255, 255, 255)

    for i = 0, blurNum do
        blurMat:SetFloat("$blur", i * .33)
        blurMat:Recompute()
    end
    render.UpdateScreenEffectTexture()
    surface.DrawTexturedRect(x * -1, y * -1, scrw, scrh)
end



function AOCDerma:Menu()
    local menu = DermaMenu()
    menu.Paint = function(self, w, h)
        draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 200))
        surface.SetDrawColor(255, 255, 255, 255)
        surface.DrawOutlinedRect(0, 0, w, h)
    end

    menu.oldAddOption = menu.AddOption

    function menu:AddOption(text, func)
        local option = self:oldAddOption(text, func)
        option:SetFont(AOCDerma:DF("m", 25))
        option:SetTextColor(Color(255, 255, 255))
        option.Paint = function(self, w, h)
            if self:IsHovered() then
                draw.RoundedBox(0, 0, 0, w, h, Color(255, 255, 255, 50))
            else
                draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 200))
            end
        end

        function option:PerformLayout( w, h )

            self:SizeToContents()
            self:SetWide( self:GetWide() + 30 )
        
            w = math.max( self:GetParent():GetWide(), self:GetWide() )
        
            self:SetSize( w, 50 )
        
            if ( IsValid( self.SubMenuArrow ) ) then
        
                self.SubMenuArrow:SetSize( 15, 15 )
                self.SubMenuArrow:CenterVertical()
                self.SubMenuArrow:AlignRight( 4 )
        
            end
        
            DButton.PerformLayout( self, w, h )
        
        end
    end

    return menu
end



local AOCFramePanel = {}

AccessorFunc( AOCFramePanel, "m_bIsMenuComponent",	"IsMenu",			FORCE_BOOL )
AccessorFunc( AOCFramePanel, "m_bDraggable",		"Draggable",		FORCE_BOOL )
AccessorFunc( AOCFramePanel, "m_bSizable",			"Sizable",			FORCE_BOOL )
AccessorFunc( AOCFramePanel, "m_bScreenLock",		"ScreenLock",		FORCE_BOOL )
AccessorFunc( AOCFramePanel, "m_bDeleteOnClose",	"DeleteOnClose",	FORCE_BOOL )
AccessorFunc( AOCFramePanel, "m_bPaintShadow",		"PaintShadow",		FORCE_BOOL )

AccessorFunc( AOCFramePanel, "m_iMinWidth",			"MinWidth",			FORCE_NUMBER )
AccessorFunc( AOCFramePanel, "m_iMinHeight",		"MinHeight",		FORCE_NUMBER )

AccessorFunc( AOCFramePanel, "m_bBackgroundBlur",	"BackgroundBlur",	FORCE_BOOL )

function AOCFramePanel:Init()

	self:SetFocusTopLevel( true )

	--self:SetCursor( "sizeall" )

	self:SetPaintShadow( true )

	self.lineColor = Color(255,255,255)
    self.btnWide = 70
    self.btnHeight = 25

	self.btnClose = vgui.Create( "DButton", self )
	self.btnClose:SetText( "" )
	self.btnClose.DoClick = function ( button ) self:Close() end
	self.btnClose.Paint = function( panel, w, h ) draw.RoundedBox(0,0,0,w,h,Color(155,0,0,255)) end





	self.titlePanel = vgui.Create("DPanel",self)
    self.titlePanel:Dock(TOP)
	--self.titlePanel:SetTall(AOCH(55))
    self.titlePanel:DockMargin(0,0,0,5)
	self.titlePanel.Text = "Please set title"
	self.titlePanel.Font = AOCDerma:DF("l", 50)
	self.titlePanel.Paint = function( panel, w, h ) 
		surface.SetFont( panel.Font ) -- Set the font
		local textW, textH = surface.GetTextSize( panel.Text )

		draw.RoundedBox(0,0,0,textW+20,h-3,Color(255,255,255))
		draw.DrawText(panel.Text,panel.Font,10,-3,Color(0,0,0),TEXT_ALIGN_LEFT)
		panel:SetTall(textH)
	end

	self:SetDraggable( true )
	self:SetSizable( false )
	self:SetScreenLock( false )
	self:SetDeleteOnClose( true )
	self:SetTitle( "Window" )

	self:SetMinWidth( 50 )
	self:SetMinHeight( 50 )

	-- This turns off the engine drawing
	self:SetPaintBackgroundEnabled( false )
	self:SetPaintBorderEnabled( false )

	self.m_fCreateTime = SysTime()

	self:DockPadding(25, 25, 25, 25)

end

function AOCFramePanel:ShowCloseButton( bShow )

	self.btnClose:SetVisible( bShow )

end

function AOCFramePanel:GetTitle()

	return self.titlePanel.Text

end

function AOCFramePanel:SetTitle( strTitle )

	self.titlePanel.Text = strTitle

	if strTitle == "" then
		self.titlePanel:Remove()
	end

end

function AOCFramePanel:Close()

	self:SetVisible( false )

	if ( self:GetDeleteOnClose() ) then
		self:Remove()
	end

	self:OnClose()

end

function AOCFramePanel:OnClose()
end

function AOCFramePanel:Center()

	self:InvalidateLayout( true )
	self:CenterVertical()
	self:CenterHorizontal()

end

function AOCFramePanel:IsActive()

	if ( self:HasFocus() ) then return true end
	if ( vgui.FocusedHasParent( self ) ) then return true end

	return false

end

function AOCFramePanel:SetIcon( str )

	if ( !str && IsValid( self.imgIcon ) ) then
		return self.imgIcon:Remove() -- We are instructed to get rid of the icon, do it and bail.
	end

	if ( !IsValid( self.imgIcon ) ) then
		self.imgIcon = vgui.Create( "DImage", self )
	end

	if ( IsValid( self.imgIcon ) ) then
		self.imgIcon:SetMaterial( Material( str ) )
	end

end

function AOCFramePanel:Think()

	local mousex = math.Clamp( gui.MouseX(), 1, ScrW() - 1 )
	local mousey = math.Clamp( gui.MouseY(), 1, ScrH() - 1 )

	if ( self.Dragging ) then

		local x = mousex - self.Dragging[1]
		local y = mousey - self.Dragging[2]

		-- Lock to screen bounds if screenlock is enabled
		if ( self:GetScreenLock() ) then

			x = math.Clamp( x, 0, ScrW() - self:GetWide() )
			y = math.Clamp( y, 0, ScrH() - self:GetTall() )

		end

		self:SetPos( x, y )

	end

	if ( self.Sizing ) then

		local x = mousex - self.Sizing[1]
		local y = mousey - self.Sizing[2]
		local px, py = self:GetPos()

		if ( x < self.m_iMinWidth ) then x = self.m_iMinWidth elseif ( x > ScrW() - px && self:GetScreenLock() ) then x = ScrW() - px end
		if ( y < self.m_iMinHeight ) then y = self.m_iMinHeight elseif ( y > ScrH() - py && self:GetScreenLock() ) then y = ScrH() - py end

		self:SetSize( x, y )
		self:SetCursor( "sizenwse" )
		return

	end

	local screenX, screenY = self:LocalToScreen( 0, 0 )

	if ( self.Hovered && self.m_bSizable && mousex > ( screenX + self:GetWide() - 20 ) && mousey > ( screenY + self:GetTall() - 20 ) ) then

		self:SetCursor( "sizenwse" )
		return

	end

	if ( self.Hovered && self:GetDraggable() && mousey < ( screenY + 24 ) ) then
		self:SetCursor( "sizeall" )
		return
	end

	self:SetCursor( "arrow" )

	-- Don't allow the frame to go higher than 0
	if ( self.y < 0 ) then
		self:SetPos( self.x, 0 )
	end

end

function AOCFramePanel:Paint( w, h )

	if !self.btnClose:IsVisible() then 
		self.btnHeight = -10
		self.btnWide = -10
	end

	Derma_DrawBackgroundBlur( self, self.m_fCreateTime )

	draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))

	draw.RoundedBox(0,10,10,5,h-20,self.lineColor)

	draw.RoundedBox(0,10,10,w- self.btnWide - 30,5,self.lineColor)


	draw.RoundedBox(0,10,h-15,w-20,5,self.lineColor)
	
	draw.RoundedBox(0,w-15,10+self.btnHeight+10,5,h-20-self.btnHeight-10,self.lineColor)

	return true

end

function AOCFramePanel:OnMousePressed()

	local screenX, screenY = self:LocalToScreen( 0, 0 )

	if ( self.m_bSizable && gui.MouseX() > ( screenX + self:GetWide() - 20 ) && gui.MouseY() > ( screenY + self:GetTall() - 20 ) ) then
		self.Sizing = { gui.MouseX() - self:GetWide(), gui.MouseY() - self:GetTall() }
		self:MouseCapture( true )
		return
	end

	if ( self:GetDraggable() && gui.MouseY() < ( screenY + 24 ) ) then
		self.Dragging = { gui.MouseX() - self.x, gui.MouseY() - self.y }
		self:MouseCapture( true )
		return
	end

end

function AOCFramePanel:OnMouseReleased()

	self.Dragging = nil
	self.Sizing = nil
	self:MouseCapture( false )

end

function AOCFramePanel:PerformLayout()

	local titlePush = 0

	if ( IsValid( self.imgIcon ) ) then

		self.imgIcon:SetPos( 5, 5 )
		self.imgIcon:SetSize( 16, 16 )
		titlePush = 16

	end



	self.btnClose:SetPos(self:GetWide() - self.btnWide - 10,10)
	self.btnClose:SetSize( self.btnWide, self.btnHeight )

	self.btnClose:MoveToFront()
end

derma.DefineControl( "AOCFrame", "A simple window", AOCFramePanel, "EditablePanel" )




--gamemodes/starwarsrp/gamemode/modules/squad/sh_squad.lua:
AOCRP.Squad = AOCRP.Squad or {}



function AOCRP.Squad:GetMembers(squadid)
    local plys = {}

    for k, v in pairs(player.GetHumans()) do
        if v:GetSquad() == squadid then
            table.insert(plys, v)
        end
    end
    return plys
end

function AOCRP.Squad:InValidSquad(ply)
    return ply:GetSquad() != 0
end


function AOCRP.Squad:SquadBefehl(ply, befehl)
    if !AOCRP.Squad:InValidSquad(ply) then ply:ChatPrint("*** Du bist in keinem Squad") return end

    if SERVER then

        --AOCRP.HUD:CallNotify(AOCRP.Squad:GetMembers(ply:GetSquad()), befehl, Color(255,0,0), "SQUADBEFEHL", "everfall/miscellaneous/ux/purchase/lootbox_purchase_01.mp3")
        AOCRP.HUD:Notification(AOCRP.Squad:GetMembers(ply:GetSquad()), {title="SQUADBEFEHL", titlecolor=Color(255,0,0), text=befehl, barcolor=Color(255,0,0),sound="everfall/miscellaneous/ux/purchase/lootbox_purchase_01.mp3",delay=15}) 
        AOCRP.Chat:PlyTablePrint(AOCRP.Squad:GetMembers(ply:GetSquad()), "*** Neuer Squadbefehl von ".. ply:Nick())
    end
    if CLIENT then


        SquadBefehlCoolDown = SquadBefehlCoolDown or 0
        if CurTime() > SquadBefehlCoolDown then
            SquadBefehlCoolDown = CurTime() + 5
            net.Start("AOCRP.Squad.Squadbefehl")
            net.WriteString(befehl)
            net.SendToServer()
        else
            LocalPlayer():ChatPrint("*** Ok reicht doch mit deinen Befehlen...")
        end
    end
end


if SERVER then

util.AddNetworkString("AOCRP.Squad.Squadbefehl")

net.Receive("AOCRP.Squad.Squadbefehl", function(len, ply)
    local message = net.ReadString()
    AOCRP.Squad:SquadBefehl(ply, message)
end)    


util.AddNetworkString("AOCRP.Squad.SetSquad")

net.Receive("AOCRP.Squad.SetSquad", function(len, ply)
    local squad = net.ReadString()
    ply:SetSquad(tonumber(squad))
end)    


util.AddNetworkString("AOCRP.Squad.SetSquadPos")

net.Receive("AOCRP.Squad.SetSquadPos", function(len, ply)
    local squad = net.ReadString()
    ply:SetSquadPos(squad)
end)   


util.AddNetworkString("AOCRP.Squad.SetSquadTeam")

net.Receive("AOCRP.Squad.SetSquadTeam", function(len, ply)
    local color = net.ReadInt(5)

    if !AOCRP.Config.SquadTeams[color] then return end

    ply:ChatPrint(AOCRP.Config.SquadTeams[color].color,"*** Squad-Farbe gendert auf: "..AOCRP.Config.SquadTeams[color].name)
    ply:SetNetVar("AOCRP.SquadTeam", color)
end)   

end







if CLIENT then
    

    function AOCRP.Squad:SquadPosMenu()


        if !AOCRP.Squad:InValidSquad(LocalPlayer()) then LocalPlayer():ChatPrint("*** Du bist in keinem Squad") return end

        if ValidPanel(self.FRAME) then self.FRAME:Remove() end
        self.FRAME = AOCDerma:DefaultFrame("Squadposition")
        self.FRAME:SetSize(AOCW(500),AOCH(800))
        self.FRAME:Center()

        local suqadPosList = AOCDerma:ScrollBar(self.FRAME) 
        suqadPosList:Dock(FILL)

        for k, v in SortedPairs(AOCRP.Config.SquadPos) do

            local btn = AOCDerma:Button(suqadPosList, v, function() 
            
        
            net.Start("AOCRP.Squad.SetSquadPos")
                net.WriteString(k)
            net.SendToServer()

            if ValidPanel(AOCRP.Squad.FRAME) then AOCRP.Squad.FRAME:Remove() end

            end, "lc")
            btn:Dock(TOP)
            btn:DockMargin(0,0,0,AOCH(5))

            function btn:PaintOver(w,h)
                if LocalPlayer():GetSquadPos() != k then
                    self:SetEnabled(true)
                    self.akzent = Color(200,200,200,255)
                    self.akzenthover = Color(255,255,255,255)
                else
                    self:SetEnabled(true)
                    self.akzent = Color(0,200,0,255)
                    self.akzenthover = Color(0,255,0,255)
                end
            end


        end
    end

    concommand.Add( "aocrp_squadpos", function( ply, cmd, args )
        AOCRP.Squad:SquadPosMenu()
    end )


end





if CLIENT then 
    net.Receive("AOCRP.Squad.CreateMarker", function(len, ply)
        local marker = net.ReadInt(7)
        local sender = net.ReadEntity()
        local vector = net.ReadVector()
        local target = net.ReadEntity()

        local data = { id = marker, sender = sender, pos = vector, target = target, time = CurTime()+20 }
        table.insert(AOCRP.HUD.SquadMarkers, data)

        AOCRP.HUD:Notification(LocalPlayer(), {text = "Squadmarker von "..sender:Nick(), title = AOCRP.Config.SquadMarker[marker].title, titlecolor = AOCRP.Config.SquadMarker[marker].cl, barcolor = AOCRP.Config.SquadMarker[marker].cl}) 
        surface.PlaySound( "everfall/miscellaneous/ux/award/missions_award_star_01.mp3" )
    end)   
end 


if SERVER then

    util.AddNetworkString("AOCRP.Squad.CreateMarker")

    util.AddNetworkString("AOCRP.Squad.MapCreateMarker")


    net.Receive("AOCRP.Squad.MapCreateMarker", function(len, ply)
        local marker = net.ReadInt(7)
        local sender = net.ReadEntity()
        local vector = net.ReadVector()
        local target = net.ReadEntity()

        if !AOCRP.Squad:InValidSquad(sender) then sender:ChatPrint("*** Du bist in keinem Squad") return end
        if !AOCRP.Config.SquadMarker[marker] then return end 


        local trace = sender:GetEyeTrace()
        
        net.Start("AOCRP.Squad.CreateMarker")
        net.WriteInt(marker, 7)
        net.WriteEntity(sender)
        net.WriteVector(vector)
        net.WriteEntity(target)

        net.Send( AOCRP.Squad:GetMembers(sender:GetSquad()))
    end)  

    function AOCRP.Squad:CreateMarker(sender, marker)
        if !AOCRP.Squad:InValidSquad(sender) then sender:ChatPrint("*** Du bist in keinem Squad") return end
        if !AOCRP.Config.SquadMarker[marker] then return end 


        local trace = sender:GetEyeTrace()
        
        net.Start("AOCRP.Squad.CreateMarker")
        net.WriteInt(marker, 7)
        net.WriteEntity(sender)
        net.WriteVector(trace.HitPos)
        net.WriteEntity(trace.Entity)

        net.Send( AOCRP.Squad:GetMembers(sender:GetSquad()))

    
    end  

    concommand.Add( "aocrp_squadmarker", function( ply, cmd, args )
        ply.SquadMarkerCoolDown = ply.SquadMarkerCoolDown or 0
        if CurTime() > ply.SquadMarkerCoolDown then
            AOCRP.Squad:CreateMarker(ply, tonumber(args[1]))
            ply.SquadMarkerCoolDown = CurTime() + 5
        end
    end )
end
--gamemodes/starwarsrp/gamemode/modules/medic/sh_medic.lua:
AOCRP.Medic = AOCRP.Medic or {}





AOCRP.Medic.Verletzungen = {}
--gamemodes/starwarsrp/gamemode/modules/medic/cl_medic.lua:
AOCRP.Medic = AOCRP.Medic or {}



PIXEL.RegisterFont("AOCRP_MedicSystem_CallMedic", "Agency FB", 50, 1000)

PIXEL.RegisterFont("AOCRP_MedicSystem_CallMedicSmall", "Agency FB", 40, 10)


function AOCRP.Medic:OpenTempDeathScreen()
    if ValidPanel(AOCEscape_BaseFrame) then AOCEscape_BaseFrame:Remove() end
    if ValidPanel(AOCRP.ScoreBoard.FRAME) then AOCRP.ScoreBoard.FRAME:Remove() end 
    if ValidPanel(AOCRP_DefaultFrameOpen) then AOCRP_DefaultFrameOpen:Remove() end
    if ValidPanel(self.DeathScreen) then self.DeathScreen:Remove() end

    local medicCalled = false
    local inSimulation = LocalPlayer():GetNW2Entity("wOS.CombatSim.Entity", NULL)

    self.DeathScreen = vgui.Create("DFrame")
    self.DeathScreen:SetSize(ScrW(), ScrH())
    self.DeathScreen:SetPos(0,0)
    self.DeathScreen:MakePopup()
    self.DeathScreen:ShowCloseButton(false)
    self.DeathScreen:SetDraggable(false)
    self.DeathScreen:SetTitle("")
    
    local wait = CurTime() + 2
    function self.DeathScreen:Paint(w,h)

        PIXEL.DrawBlur(self, 0, 0, w, h)
        PIXEL.DrawBlur(self, 0, 0, w, h)
        PIXEL.DrawBlur(self, 0, 0, w, h)
        PIXEL.DrawBlur(self, 0, 0, w, h)

        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))
        AOCDerma:DrawTextShadow("VITALZUSTAND KRITISCH", PIXEL.UI.RegisteredFonts["AOCRP_MedicSystem"], w/2, AOCH(250), Color(255,0,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        AOCDerma:DrawTextShadow("VITALZUSTAND KRITISCH", PIXEL.UI.RegisteredFonts["AOCRP_MedicSystem_Aurebesh"], w/2, AOCH(230), Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                --draw.SimpleText("Whle die Aufgaben fr den Sanitter", PIXEL.UI.RegisteredFonts["AOCRP_MedicSystem_Choose_Tasks"], w/2+1, AOCH(250)+1, Color(0,0,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        --draw.SimpleText("Whle die Aufgaben fr den Sanitter", PIXEL.UI.RegisteredFonts["AOCRP_MedicSystem_Choose_Tasks"], w/2, AOCH(250), Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

        if medicCalled then
            AOCDerma:DrawTextShadow("Sanitter wurden informiert", PIXEL.UI.RegisteredFonts["AOCRP_MedicSystem_CallMedic"], w/2, AOCH(600), Color(0,255,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end

        if LocalPlayer():Alive() then 
            if CurTime() > wait then
                self:Remove()
            end
        end
    end

    local panel = vgui.Create("DButton",self.DeathScreen)
    local pnlW, pnlH = AOCW(500), AOCH(100)
    --panel:Dock(BOTTOM)
    panel:SetSize(pnlW, pnlH)
    panel:SetPos(ScrW()/2 -pnlW/2, AOCH(600) )
    panel:SetText("")
    panel:SetVisible(!IsValid(inSimulation))
    function panel:Paint(w,h)
        if panel:IsHovered() then
            draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))      
        else
            draw.RoundedBox(0,0,0,w,h,Color(0,0,0,100)) 
        end  
        --AOCDerma:DrawTextShadow("VITALZUSTAND KRITTISCH", PIXEL.UI.RegisteredFonts["AOCRP_MedicSystem"], w/2, AOCH(250), Color(255,0,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        AOCDerma:DrawTextShadow("SANITTER RUFEN", PIXEL.UI.RegisteredFonts["AOCRP_MedicSystem_CallMedic"], w/2, AOCH(8), Color(0,255,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        AOCDerma:DrawTextShadow("MEDIC RUFEN", PIXEL.UI.RegisteredFonts["AOCRP_MedicSystem_Aurebesh"], w/2, h-AOCH(40), Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)


    end
    function panel:DoClick()
        net.Start("AOCRP.Medic.CallMedic")
        net.SendToServer()
        self:SetVisible(false)
        medicCalled = true

        timer.Simple(30, function() 
            if ValidPanel(AOCRP.Medic.DeathScreen) then
                self:SetVisible(true)
                medicCalled = false
            end
        end)
    end

    Aufgebenpanel = vgui.Create("DButton",self.DeathScreen)
    local pnlW, pnlH = AOCW(350), AOCH(100)
    --panel:Dock(BOTTOM)
    Aufgebenpanel:SetText("")
    Aufgebenpanel:SetSize(pnlW, pnlH)
    Aufgebenpanel:SetPos(ScrW()/2 -pnlW/2, AOCH(720) )
    Aufgebenpanel:SetEnabled(false)
    if timer.Exists("AOCRP_MEDIC_SPAWNDELAY") then timer.Remove("AOCRP_MEDIC_SPAWNDELAY") end
    if LocalPlayer():GetUnitID() != 12 then
        timer.Create("AOCRP_MEDIC_SPAWNDELAY",AOCRP.Config.SpawnDelay,1, function() 
            if ValidPanel(Aufgebenpanel) then
                Aufgebenpanel:SetEnabled(true)
            end
        
        end)
    else
        Aufgebenpanel:SetEnabled(true)
    end

    -- CSS Compatibility
    function Aufgebenpanel:Think()
        if IsValid(inSimulation) then
            local respawnTime = LocalPlayer():GetNW2Float("wOS.CombatSim.RespawnTime", 0)
            local diff = math.max(math.floor(respawnTime - CurTime()), 0)
            if diff <= 0 then
                Aufgebenpanel:SetEnabled(true)
            end
        end
    end


    function Aufgebenpanel:Paint(w,h)
        if Aufgebenpanel:IsHovered() then
            draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))      
        else
            draw.RoundedBox(0,0,0,w,h,Color(0,0,0,100)) 
        end
   
        AOCDerma:DrawTextShadow("AUFGEBEN", PIXEL.UI.RegisteredFonts["AOCRP_MedicSystem_CallMedic"], w/2, AOCH(8), Color(255,0,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
 
        if IsValid(inSimulation) then
            local respawnTime = LocalPlayer():GetNW2Float("wOS.CombatSim.RespawnTime", 0)
            local diff = math.max(math.floor(respawnTime - CurTime()), 0)
            AOCDerma:DrawTextShadow("Warte ".. diff .. "s" , PIXEL.UI.RegisteredFonts["AOCRP_MedicSystem_CallMedicSmall"], w/2, h-AOCH(50), Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        elseif timer.Exists("AOCRP_MEDIC_SPAWNDELAY") then
            AOCDerma:DrawTextShadow("Warte ".. math.Round( timer.TimeLeft( "AOCRP_MEDIC_SPAWNDELAY" ) ).. "s" , PIXEL.UI.RegisteredFonts["AOCRP_MedicSystem_CallMedicSmall"], w/2, h-AOCH(50), Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end

    function Aufgebenpanel:DoClick()
        net.Start("AOCRP.Medic.GiveUp")
        net.SendToServer()
        if ValidPanel(AOCRP.Medic.DeathScreen) then AOCRP.Medic.DeathScreen:Remove() end
    end

    local panel = vgui.Create("DButton",self.DeathScreen)
    local pnlW, pnlH = AOCW(350), AOCH(100)
    panel:SetText("")
    panel:SetVisible(!IsValid(inSimulation))
    panel:SetSize(pnlW, pnlH)
    panel:SetPos(ScrW()/2 -pnlW/2, AOCH(900) )

    function panel:Paint(w,h) 
        if panel:IsHovered() then
            draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))      
        else
            draw.RoundedBox(0,0,0,w,h,Color(0,0,0,100)) 
        end
   
        -- AOCDerma:DrawTextShadow("VITALZUSTAND KRITTISCH", PIXEL.UI.RegisteredFonts["AOCRP_MedicSystem"], w/2, AOCH(250), Color(255,0,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        AOCDerma:DrawTextShadow("SOFORT AUFGEBEN", PIXEL.UI.RegisteredFonts["AOCRP_MedicSystem_CallMedic"], w/2, AOCH(8), Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        AOCDerma:DrawTextShadow("$ "..AOCRP.Config.InstantRespawnPrice, PIXEL.UI.RegisteredFonts["AOCRP_MedicSystem_Aurebesh"], w/2, h-AOCH(40), Color(0,255,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    function panel:DoClick()
        net.Start("AOCRP.Medic.GiveUpMoney")
        net.SendToServer()
        --if ValidPanel(AOCRP.Medic.DeathScreen) then AOCRP.Medic.DeathScreen:Remove() end
    end

    local btn = AOCDerma:Button(self.DeathScreen, "Chat", function()
        LOUNGE_CHAT:CloseChatbox()
        LOUNGE_CHAT:OpenChatbox(false)
    end, "bl")
    btn:SetPos(0, ScrH() - AOCH(50))  

    if AOCRP.Admin:IsTeamMember(LocalPlayer()) then
        local btn = AOCDerma:Button(self.DeathScreen, "Admin Revive", function()
            LocalPlayer():ConCommand("sam revive ^")
        end, "b")
        btn:SetPos(AOCW(100), ScrH() - AOCH(50))
    end  
end



net.Receive("AOCRP.Medic.OpenDeathMenu", function(len, ply)
    AOCRP.Medic:OpenTempDeathScreen()
end)


PIXEL.RegisterFont("AOCRP_MedicSystem", "Agency FB", 90, 1000)
PIXEL.RegisterFont("AOCRP_MedicSystem_Choose_Tasks", "Agency FB", 50, 10)
PIXEL.RegisterFont("AOCRP_MedicSystem_Aurebesh", "Aurebesh", 30, 100)
PIXEL.RegisterFont("AOCRP_MedicSystem_TasksTitle", "Agency FB", 25, 1000)






--[[ function AOCRP.Medic:OpenMedicRPChat(partner)

    if !ValidPanel( self.DeathScreen ) then return end
    self.ChatWindow = vgui.Create("DPanel",self.DeathScreen)
    self.ChatWindow:SetSize(AOCW(500),AOCH(600))
    self.ChatWindow:SetPos(AOCW(10),AOCH(10))

    self.ChatWindow.Chat = vgui.Create("DTextEntry",self.ChatWindow)
    self.ChatWindow.Chat:Dock(FILL)
    self.ChatWindow.Chat:SetMultiline(true)
    self.ChatWindow.Chat:SetFont(AOCDerma:Font("DataPad_Notizen"))
    self.ChatWindow.Chat:SetEditable(false)
    self.ChatWindow.Chat:SetPaintBackground(false)
    self.ChatWindow.Chat:SetTextColor(Color(255,255,255))
    self.ChatWindow.Chat:SetVerticalScrollbarEnabled(true)

    local textEntry = AOCDerma:TextEntry(self.ChatWindow.Chat," Nachricht tippen...")
    textEntry:Dock(BOTTOM)
    textEntry:SetTall(AOCH(50))
end
 ]]
--AOCRP.Medic:OpenMedicRPChat(partner)



net.Receive( "AOCRP.Medic.PlayHitSound", function( len, ply )
   
    surface.PlaySound("everfall/miscellaneous/damage_received/bullet/damage_received_bullet_hit_droid_var_02_0"..math.random(9)..".mp3")

    util.ScreenShake( Vector(0, 0, 0), 5, 5, 1, 0 )
end )

net.Receive( "AOCRP.Medic.PlayHurtSound", function( len, ply )

    LocalPlayer():AnimRestartGesture( GESTURE_SLOT_FLINCH, 119, true )

    util.ScreenShake( Vector(0, 0, 0), 5, 5, 1, 0 )
    LocalPlayer():ScreenFade( SCREENFADE.IN, Color( 94, 0, 0, 45), 0.3, 0 )

    surface.PlaySound("everfall/miscellaneous/damage_received/bullet/damage_received_bullet_hit_var_03_0"..math.random(5)..".mp3")
end )



AOCDerma:RegisterFont("AOCRP_MedicMenu_Aurebesh", "Aurebesh", 50, 10)


function AOCRP.Medic:MedicMenu(ply)

    if ValidPanel(self.FRAME) then self.FRAME:Remove() end

    self.FRAME = AOCDerma:DefaultFrame("Behandeln: "..ply:Nick())
    self.FRAME:SetSize(AOCW(1600),AOCH(900))
    self.FRAME:Center()


    local leftPane =  AOCDerma:ScrollBar(self.FRAME) 
    leftPane:Dock(LEFT)
    leftPane:SetWide(AOCW(450))

    local btn = AOCDerma:Button(leftPane, "HLW durchfhren", function() end, "b")
    btn:Dock(TOP)

    local middlePane = vgui.Create("DPanel", self.FRAME)
    middlePane:Dock(FILL)
    middlePane:SetPaintBackground(false)

    local rightPane = AOCDerma:ScrollBar(self.FRAME) 
    rightPane:Dock(RIGHT)
    rightPane:SetWide(AOCW(450))

    local btn = AOCDerma:Button(rightPane, "Groe Alvusion", function() end, "b")
    btn:Dock(TOP)
    local btn = AOCDerma:Button(rightPane, "Groe Alvusion", function() end, "b")
    btn:Dock(TOP)
    local btn = AOCDerma:Button(rightPane, "Groe Alvusion", function() end, "b")
    btn:Dock(TOP)
    local btn = AOCDerma:Button(rightPane, "Groe Alvusion", function() end, "b")
    btn:Dock(TOP)
    local btn = AOCDerma:Button(rightPane, "Groe Alvusion", function() end, "b")
    btn:Dock(TOP)
    local btn = AOCDerma:Button(rightPane, "Groe Alvusion", function() end, "b")
    btn:Dock(TOP)
    
    local pmodel = vgui.Create("DModelPanel", middlePane)
	pmodel:Dock(FILL)

	pmodel:SetModel( ply:GetModel() )

	for k, v in pairs(ply:GetMaterials()) do
		if ply:GetSubMaterial( k ) != "" then
			pmodel.Entity:SetSubMaterial(k, ply:GetSubMaterial( k ))
		end
	end 

    for k, v in pairs(ply:GetBodyGroups()) do
        pmodel.Entity:SetBodygroup(v.id, ply:GetBodygroup( v.id ))
    end

    -- Function to set a T-Pose animation
    local function SetTPoseAnimation(panel)
        local entity = panel:GetEntity()
        if IsValid(entity) then
            local seqCount = entity:GetSequenceCount()
            for i = 0, seqCount - 1 do
                local seqName = entity:GetSequenceName(i)
                if string.find(seqName:lower(), "aimlayer_camera_crouch") then
                    panel.Entity:ResetSequence(i)
                    break
                end
            end
        end
    end

    -- Function to initialize the model and play the T-Pose animation
    local function InitializeModelPanel(panel)
        if IsValid(panel:GetEntity()) then
            panel:SetCamPos(Vector(50, 50, 50))
            panel:SetLookAt(Vector(0, 0, 40))
            panel:SetFOV(55)
            SetTPoseAnimation(panel)


            local modelEntity = panel:GetEntity()
            modelEntity:SetAngles(Angle(0,135,0))
        end
    end
    InitializeModelPanel(pmodel)
    -- Set the model panel's callback for when the model is ready
    function pmodel:LayoutEntity()
    end

    local hurtIcon = "*"


    local function CreateBodyButton(pnl,x,y)
        local btn = vgui.Create("DButton",pnl)
        btn:SetSize(AOCW(100),AOCH(100))
        btn:SetPos(x,y)
        btn:SetText("")
        btn:SetVisible(false)
        function btn:Paint(w,h) 
        --draw.RoundedBox(0,0,0,w,h,Color(0,0,0,150))


            if self:IsHovered() then
                AOCDerma:DrawTextShadow("#", AOCDerma:Font("AOCRP_MedicMenu_Aurebesh"), w/2+AOCW(2), AOCH(28), Color(255,0,0,255), TEXT_ALIGN_CENTER, Color(0,0,0,255))
            else
                AOCDerma:DrawTextShadow("#", AOCDerma:Font("AOCRP_MedicMenu_Aurebesh"), w/2+AOCW(2), AOCH(28), Color(255,0,0,100), TEXT_ALIGN_CENTER, Color(0,0,0,0))
            end
        end
        function btn:OnCursorEntered()
            surface.PlaySound("everfall/miscellaneous/ux/navigation/navigation_slider_02.mp3")
        end
        function btn:DoClickInternal()
            surface.PlaySound("everfall/miscellaneous/ux/navigation/navigation_activate_01.mp3")
        end

        return head
    end   


    local function CreateTorniqueIcon(pnl,x,y)
        local btn = vgui.Create("DButton",pnl)
        btn:SetSize(AOCW(100),AOCH(100))
        btn:SetPos(x,y)
        btn:SetText("")
        btn:SetEnabled(false)
        btn:SetVisible(false)
        function btn:Paint(w,h) 

            AOCDerma:DrawTextShadow("%", AOCDerma:Font("AOCRP_MedicMenu_Aurebesh"), w/2+AOCW(2), AOCH(28), Color(0,255,0), TEXT_ALIGN_CENTER, Color(0,0,0,255))
  
        end


        return head
    end  

    local head = CreateBodyButton(pmodel,AOCW(275),AOCH(80))
    local body = CreateBodyButton(pmodel,AOCW(275),AOCH(250))
    local leftArm = CreateBodyButton(pmodel,AOCW(110),AOCH(280))
    local rightArm = CreateBodyButton(pmodel,AOCW(430),AOCH(280))
    local leftLeg = CreateBodyButton(pmodel,AOCW(225),AOCH(500))
    local rightLeg = CreateBodyButton(pmodel,AOCW(325),AOCH(500))

    local lArmTorniq = CreateTorniqueIcon(pmodel,AOCW(185),AOCH(200))
    local rArmTorniq = CreateTorniqueIcon(pmodel,AOCW(360),AOCH(200))
    
    local lLegTorniq = CreateTorniqueIcon(pmodel,AOCW(240),AOCH(420))
    local rLegTorniq = CreateTorniqueIcon(pmodel,AOCW(305),AOCH(420))
    

    local sichtung = vgui.Create("DButton", pmodel)
 
    sichtung:SetPos(AOCW(225),AOCH(760))
    sichtung:SetSize(AOCW(200), AOCH(25))
    sichtung:SetText("")
    function sichtung:Paint(w,h) 

        local sichtData = AOCRP.Medic.SKs[ply:GetSichtung()]
        draw.RoundedBox(5,0,0,w,h,sichtData.color)
    end

    function sichtung:DoClick() 

        local Menu = DermaMenu()

        for k, v in pairs(AOCRP.Medic.SKs) do
            Menu:AddOption( v.name, function() net.Start("AOCRP.Medic.SetSichtung") net.WriteEntity(ply) net.WriteInt(k,5) net.SendToServer() end )
        end
        Menu:Open()
    end
end




AOCDerma:RegisterFont("AOCRP_MedicChat", "Agency FB", 30, 100)

AOCDerma:RegisterFont("AOCRP_MedicChatBinds", "Agency FB", 15, 10)

function AOCRP.Medic:OpenMedicChat(partner) 
    if ValidPanel(self.MedicChat) then self.MedicChat:Remove() end

    AOCRP.RPBinds:LoadActionTable()

    self.MedicChat = AOCDerma:DefaultFrame("Medizinische Behandlung")
    self.MedicChat:SetSize(AOCW(700),AOCH(900))
    self.MedicChat:Center()
    self.MedicChat.Partner = partner

    function self.MedicChat:OnRemove()
        if IsValid(AOCRP.Medic.MedicChat.Partner) then
            net.Start("AOCRP.Medic.RequestEndChat")
            net.WriteEntity(AOCRP.Medic.MedicChat.Partner)
            net.SendToServer()
        end
        AOCRP_DefaultFrameOpen = nil
    end

    self.MedicChat.ActualChat = vgui.Create("RichText",self.MedicChat)
    self.MedicChat.ActualChat:Dock( FILL )

    self.MedicChat.ActualChat:InsertColorChange(192, 192, 192, 255)
    self.MedicChat.ActualChat:AppendText("Die Medizinische Behandlung beginnt..\n Du Interagierst mit "..partner:Nick()) 

    self.MedicChat.ActualChat:GotoTextEnd()

    function self.MedicChat.ActualChat:PerformLayout()

        self:SetFontInternal( AOCDerma:Font("AOCRP_MedicChat") )
        --self:SetFGColor( color_white )
       -- self:GotoTextEnd()

        
    end

    local inputEntry = AOCDerma:TextEntry(self.MedicChat," Tippen und Enter...")
    inputEntry:Dock(BOTTOM)
    inputEntry:SetTall(AOCH(50))
    inputEntry:DockMargin(0,AOCH(10),0,0)

    function inputEntry:OnEnter( value )		-- Alternative method, outputs DTextEntry object.

        AOCRP.Medic:SendChatMessage(value)
        self:SetText("")
        self:RequestFocus()
    end


    if istable(AOCRP.RPBinds.ActionTable) and #AOCRP.RPBinds.ActionTable > 0 then
        local binds = AOCDerma:Button(self.MedicChat, "RP-Binds", function() 
        
        

            local Menu = DermaMenu()
            function Menu:Paint(w,h)
                draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))
            end 
        
            local content = AOCDerma:ScrollBar(Menu) 
            content:SetSize(AOCW(500),AOCH(300))
        
            Menu:AddPanel( content )

            for k, v in pairs(AOCRP.RPBinds.ActionTable) do

                if v.cat != "MAKT" then continue end
                local btnWep = AOCDerma:Button(content, v.text, function() AOCRP.Medic:SendChatMessage(v.text) end, "b")
                btnWep:Dock(TOP)
                btnWep:DockMargin(AOCW(5),AOCH(5),AOCW(5),AOCH(5))
                btnWep.textfont = AOCDerma:Font("AOCRP_MedicChatBinds")
                btnWep:SetNewText(AOCDerma:WrapText(v.btn, btnWep.textfont, AOCW(400)))
            end

            Menu:Open()
        
        end, "b")
        binds:Dock(BOTTOM)
    end

end


function AOCRP.Medic:SendChatMessage(message)
    if !IsValid(AOCRP.Medic.MedicChat) then return end
    AOCRP.Medic.MedicChat.ActualChat:InsertColorChange(255, 255, 255, 255)
    AOCRP.Medic.MedicChat.ActualChat:AppendText("\n ".. LocalPlayer():Nick().. " ".. message) 
    AOCRP.Medic.MedicChat.ActualChat:GotoTextEnd()

    net.Start("AOCRP.Medic.RecieveMedicChat")
    net.WriteEntity(AOCRP.Medic.MedicChat.Partner)
    net.WriteString("\n ".. LocalPlayer():Nick().. " ".. message)
    net.SendToServer()
end

net.Receive("AOCRP.Medic.StartMedicChat", function(_, ply)

    local partner = net.ReadEntity()
    AOCRP.Medic:OpenMedicChat(partner) 

end)

net.Receive("AOCRP.Medic.SendMedicChat", function(_, ply)

    local message = net.ReadString()

    if !IsValid(AOCRP.Medic.MedicChat) then return end
    AOCRP.Medic.MedicChat.ActualChat:InsertColorChange(255, 255, 255, 255)
    AOCRP.Medic.MedicChat.ActualChat:AppendText(message) 
    AOCRP.Medic.MedicChat.ActualChat:GotoTextEnd()

end)

net.Receive("AOCRP.Medic.EndChat", function(_, ply)

    if ValidPanel(AOCRP.Medic.MedicChat) then AOCRP.Medic.MedicChat:Remove() end

end)

--gamemodes/starwarsrp/gamemode/modules/gui/cl_rpbinds.lua:

AOCRP.RPBinds = AOCRP.RPBinds or {}


AOCRP.RPBinds.ActionFile = "sammy/aoc_chatbinds.json"


    function AOCRP.RPBinds:RPBindsMenu()


        if ValidPanel(self.FRAME) then self.FRAME:Remove() end

        AOCRP.RPBinds:LoadActionTable()
        
        self.FRAME = AOCDerma:DefaultFrame("Roleplay Binds")
        self.FRAME:SetSize(AOCW(800),AOCH(800))
        self.FRAME:Center()


        local seEntry = AOCDerma:TextEntry(self.FRAME," Bind suchen..")
        seEntry:SetTall(AOCH(50))
        seEntry:Dock(TOP)


        seEntry.OnEnter = function( self )
--[[             table.insert(AOCRP.RPBinds.ActionTable, self:GetText())
            AOCRP.RPBinds:SaveActionTable()
            AOCRP.RPBinds:LoadActionTable()
            AOCRP.RPBinds:LoadActionButtons("")
            self:SetText("") ]]
        end
        seEntry:SetUpdateOnType( true )
        function seEntry:OnValueChange(text)
            AOCRP.RPBinds:LoadActionButtons(text)
        end



        self.FRAME.ButtonList = AOCDerma:ScrollBar(self.FRAME) 
        self.FRAME.ButtonList:Dock(FILL)



        local addPanel = vgui.Create("DCollapsibleCategory", self.FRAME)
        addPanel:Dock(BOTTOM)
        addPanel:SetTall(AOCH(110))
        addPanel:DockMargin(0,5,0,5)
        addPanel:SetPaintBackground(false)
        addPanel:SetExpanded(false)
        addPanel:SetLabel("Neuer Bind")


        local addEntry = AOCDerma:TextEntry(addPanel," Inhalt des Binds")
        addEntry:SetTall(AOCH(50))
        addEntry:Dock(TOP)


        local sndPanel = vgui.Create("DPanel", addPanel)
        sndPanel:Dock(TOP)
        sndPanel:SetTall(AOCH(50))
        sndPanel:DockMargin(0,5,0,5)
        sndPanel:SetPaintBackground(false)

        local catEntry = AOCDerma:TextEntry(sndPanel," Kategorie (darf leer)")
        catEntry:SetWide(AOCW(250))
     
        catEntry:Dock(LEFT)


        local btnEntry = AOCDerma:TextEntry(sndPanel," Knopfname")
        btnEntry:DockMargin(AOCW(20),0,0,0)
     
        btnEntry:Dock(FILL)

        local btn = AOCDerma:Button(sndPanel, "Anlegen", function()    

            if string.len(addEntry:GetText()) < 1 then return end 
            if string.len(btnEntry:GetText()) < 1 then return end 

            AOCRP.RPBinds.ActionTable[#AOCRP.RPBinds.ActionTable+1] = {btn=btnEntry:GetText(),text=addEntry:GetText(), cat=string.upper(catEntry:GetText())}
            --table.insert(AOCRP.RPBinds.ActionTable, self:GetText())
            AOCRP.RPBinds:SaveActionTable()
            AOCRP.RPBinds:LoadActionTable()
            AOCRP.RPBinds:LoadActionButtons("")
            addEntry:SetText("")
            catEntry:SetText("")
            btnEntry:SetText("")
        end, "br")
        btn:Dock(RIGHT)
        btn:DockMargin(AOCW(20),0,0,0)

        AOCRP.RPBinds:LoadActionButtons("")
    end



    concommand.Add( "aocrp_rpbinds", function( ply, cmd, args )
        AOCRP.RPBinds:RPBindsMenu()
    end )

    function AOCRP.RPBinds:LoadActionButtons(text)
        if ValidPanel(self.FRAME) then 


            self.FRAME.ButtonList:Clear()

            local catPanel = vgui.Create("DPanel", self.FRAME.ButtonList)
            catPanel:Dock(TOP)
            catPanel:SetTall(AOCH(40))
            catPanel:DockMargin(0,5,0,5)
            catPanel:SetPaintBackground(false)
    
            local btn = AOCDerma:Button(catPanel, "ALLE", function() 
                AOCRP.RPBinds.CATEGORY = nil
                AOCRP.RPBinds:LoadActionButtons("")
            end, "lb")
            btn:Dock(LEFT)
    
            local categorys = {}

            for k, v in pairs(AOCRP.RPBinds.ActionTable) do
                if v.cat != "" then 
                    if !table.HasValue(categorys, v.cat) then
                        table.insert(categorys, v.cat)
                    end
                end
            end 

            for k, v in pairs(categorys) do
                local btn = AOCDerma:Button(catPanel, v, function()    
                    AOCRP.RPBinds.CATEGORY = v
                    AOCRP.RPBinds:LoadActionButtons("")
                end, "lb")
                btn:Dock(LEFT)
            end

    

                for k, v in pairs(AOCRP.RPBinds.ActionTable) do
                    if string.find( v.text, text ) then

                        if AOCRP.RPBinds.CATEGORY then 
                            if !string.find( v.cat, AOCRP.RPBinds.CATEGORY ) then
                                continue
                            end
                        end

                        local btn = AOCDerma:Button(self.FRAME.ButtonList, v.btn, function() 

                            net.Start("LOUNGE_CHAT.SendChat")
                                net.WriteString(v.text)
                            net.SendToServer()
                            
                        end, "b")
                        btn:Dock(TOP)

                        btn.DoRightClick = function()	
                            table.remove(AOCRP.RPBinds.ActionTable, k)
                            --table.RemoveByValue(AOCRP.RPBinds.ActionTable, v)	
                            AOCRP.RPBinds:SaveActionTable()
                            AOCRP.RPBinds:LoadActionTable()
                            AOCRP.RPBinds:LoadActionButtons("")
                        end
                    end
                end
        end
    end

    function AOCRP.RPBinds:SaveActionTable()
        file.CreateDir("sammy")
        file.Write( self.ActionFile, util.TableToJSON(self.ActionTable) )
    end
    
    function AOCRP.RPBinds:LoadActionTable()
        self.ActionTable = {}
        if file.Exists(self.ActionFile, "DATA") then
            local file = file.Read(self.ActionFile, "DATA")
            local tbl = util.JSONToTable(file)
            if istable(tbl) then
                self.ActionTable = tbl
            end
        end
    end 

--gamemodes/starwarsrp/gamemode/modules/gtm/sh_gtm.lua:
AOCRP.GTM = AOCRP.GTM or {}

AOCRP.GTM.Items = {}

function AOCRP.GTM:ItemExists(item)
    if AOCRP.GTM.Items[item] then
        return true
    end
    return false
end

function AOCRP.GTM:GetItemData(item)
    return AOCRP.GTM.Items[item]
end

function AOCRP.GTM:HasItem(ply, item)

    if !ply.AOCRP_GTM then return false end
    if !AOCRP.GTM:ItemExists(item) then return ply.AOCRP_GTM[item] end
    local itemData = AOCRP.GTM:GetItemData(item)

    if itemData.vipFree and ply:GetAOCVIP() then
        return true
    end

    return ply.AOCRP_GTM[item]
end

function AOCRP.GTM:GetPurchasePrice(ply, item)
    if !ply.AOCRP_GTM then return false end
    return ply.AOCRP_GTM[item].purchaseprice
end


if SERVER then
    util.AddNetworkString("AOCRP.GTM.ReloadPurchaseData")
end

function AOCRP.GTM:ReloadPurchaseData(ply,item)
    item = item or "none"
    ply.AOCRP_GTM = {}
    if SERVER then
        AOCRP.GTM:PlayerLoadPurchaseData(ply)
        net.Start("AOCRP.GTM.ReloadPurchaseData")
        net.WriteString(item)
        net.Send(ply)
    end
    if CLIENT then
        AOCRP.API:Request("getgtmbyplayer", function(data) 
            for k, v in pairs(data) do
                ply.AOCRP_GTM[v.item] = v
            end
            if item != "none" then
                AOCRP.GTM:OpenItem(item)
            end
        end, {["steamid"] = ply:SteamID64()})
    end
end

if CLIENT then

    net.Receive( "AOCRP.GTM.ReloadPurchaseData", function( len, ply )
        local item = net.ReadString()
        AOCRP.GTM:ReloadPurchaseData(LocalPlayer(), item)
    end )


end









function AOCRP.GTM:doCrossHairIcon(panel,crosshair)

    local crossmat = Material(AOCRP.Config.Crosshair[crosshair].img)
    local crosscolor = AOCRP.Config.Crosshair[crosshair].cl
    function panel:Paint(w,h)
        surface.SetDrawColor(crosscolor)
        surface.SetMaterial(crossmat)
        surface.DrawTexturedRect(0,0, w, h )
    end
end


function AOCRP.GTM:doMaterialIcon(panel,material,color)

    color = color or Color(255,255,255)
    local crossmat = Material(material)

    function panel:Paint(w,h)
        surface.SetDrawColor(color)
        surface.SetMaterial(crossmat)
        surface.DrawTexturedRect(0,0, w, h )
    end
end

function AOCRP.GTM:doImgurIcon(panel,imgur)
    function panel:Paint(w,h)
        PIXEL.DrawImgur(0,0, w, h, imgur, Color(255,255,255,255) )
    end
end

function AOCRP.GTM:doRibbon(panel,imgur)
    function panel:Paint(w,h)
        PIXEL.DrawImgur(0,h/3, w, h/2.5, imgur, Color(255,255,255,255) )
    end
end

function AOCRP.GTM:doHelmetSkinIcon(panel,texture,submat)
    local icon = vgui.Create( "DModelPanel", panel )
    icon:Dock(FILL)
    icon:SetModel( LocalPlayer():GetModel() ) -- you can only change colors on playermodels

    campos = Vector(20,-5,65)
    camlookat = Vector(0,0,65)
    camfov = Vector(0,0,0)

    icon:SetCamPos(campos)
    icon:SetLookAt(camlookat)

    if !istable(texture) then
        icon.Entity:SetSubMaterial(submat,texture)
    else
        for k, v in pairs(texture) do
            icon.Entity:SetSubMaterial( k, v )
        end
    end

    function icon:LayoutEntity( Entity ) return end -- disables default rotation

    return icon
end


function AOCRP.GTM:doBodySkinIcon(panel,texture,submat)
    local icon = vgui.Create( "DModelPanel", panel )
    icon:Dock(FILL)
    icon:SetModel( LocalPlayer():GetModel() ) -- you can only change colors on playermodels

    campos = Vector(40,-5,35)
    camlookat = Vector(0,0,35)
    camfov = Vector(0,0,0)

    icon:SetCamPos(campos)
    icon:SetLookAt(camlookat)


    if !istable(texture) then
        icon.Entity:SetSubMaterial(submat,texture)
    else
        for k, v in pairs(texture) do
            icon.Entity:SetSubMaterial( k, v )
        end
    end

    function icon:LayoutEntity( Entity ) return end -- disables default rotation

    return icon
end

function AOCRP.GTM:doSpawnIcon(panel,model)
    local icon = vgui.Create( "SpawnIcon", panel )
    icon:Dock(FILL)
    icon:SetModel( model ) -- you can only change colors on playermodels

--[[     campos = Vector(40,-5,35)
    camlookat = Vector(0,0,35)
    camfov = Vector(0,0,0)

    icon:SetCamPos(campos)
    icon:SetLookAt(camlookat)

    icon.Entity:SetSubMaterial( submat, texture )

    function icon:LayoutEntity( Entity ) return end -- disables default rotation ]]
end

function AOCRP.GTM:doSkinPreview(panel,texture,submat)
    local icon = vgui.Create( "DModelPanel", panel )
    icon:Dock(FILL)
    icon:SetModel( LocalPlayer():GetModel() ) -- you can only change colors on playermodels

    campos = Vector(70,-5,40)
    camlookat = Vector(0,0,40)
    camfov = Vector(0,0,0)

    --icon:SetCamPos(campos)
    --icon:SetLookAt(camlookat)


    if !istable(texture) then
        icon.Entity:SetSubMaterial(submat,texture)
    else
        for k, v in pairs(texture) do
            icon.Entity:SetSubMaterial( k, v )
        end
    end

    -- Enable mouse rotation
    icon:SetMouseInputEnabled(true)

    -- Create a variable to store the current rotation
    local rotation = Angle(0, 0, 0)

    -- Override the DModelPanel's LayoutEntity function
    function icon:LayoutEntity(Entity)
    -- Rotate the entity using the current rotation
    Entity:SetAngles(rotation)
    end

    -- Create a function to handle mouse movement
    function icon:OnCursorMoved(x, y)

    if !input.IsMouseDown( MOUSE_LEFT ) then return end
    -- Calculate the mouse movement delta
    local dx = x - self.lastX
    local dy = y - self.lastY

    -- Update the rotation using the mouse movement delta
    rotation.yaw = rotation.yaw + dx
    --rotation.pitch = rotation.pitch + dy

    -- Update the last cursor position
    self.lastX = x
    self.lastY = y
    end

    -- Initialize the last cursor position
    icon.lastX = 0
    icon.lastY = 0

   --[[  function icon:DoClick()
        self:SetMouseInputEnabled(not self:IsMouseInputEnabled())
    end ]]
end

--[[ CreateClientConVar("aocrp_gtm_kopf", "default", true, false)
CreateClientConVar("aocrp_gtm_body", "default", true, false)
 ]]

function AOCRP.GTM:ApplyCrosshair(ply, crosshair)
    ply:ConCommand("aocrp_gtm_crosshair "..crosshair)
end


function AOCRP.GTM:ApplyGTMSkin(ply, wo, mat, kopfoderbody, item)


    if !istable(mat) then
        ply:SetSubMaterial(wo,mat)
    else
        for k, v in pairs(mat) do
            ply:SetSubMaterial( k, v )
        end
    end

    if !ply:IsPlayer() then return end

    if kopfoderbody == "kopf" then
        ply:ConCommand("aocrp_gtm_skin_kopf "..item)
    end
    if kopfoderbody == "body" then
        ply:ConCommand("aocrp_gtm_skin_body "..item)
    end
end


function AOCRP.GTM:DoActPreview(panel,act)
    local icon = vgui.Create( "DModelPanel", panel )
    icon:Dock(FILL)
    icon:SetModel( LocalPlayer():GetModel() ) -- you can only change colors on playermodels

    campos = Vector(70,-5,40)
    camlookat = Vector(0,0,40)
    camfov = Vector(0,0,0)

    --icon:SetCamPos(campos)
    --icon:SetLookAt(camlookat)


    icon:SetAnimated(true)
    local dance = icon:GetEntity():LookupSequence(act)

    -- Make both dance
    icon:GetEntity():SetSequence(dance)

    -- Enable mouse rotation
    icon:SetMouseInputEnabled(true)

    -- Create a variable to store the current rotation
    local rotation = Angle(0, 90, 0)

    -- Override the DModelPanel's LayoutEntity function
    function icon:LayoutEntity(Entity)
    -- Rotate the entity using the current rotation
        Entity:SetAngles(rotation)
        Entity:FrameAdvance( ( RealTime() - self.LastPaint ) * self.m_fAnimSpeed )

        if Entity:GetCycle() >= 0.99 then
            Entity:SetCycle(0)
            Entity:ResetSequence(dance)
        end
    end

    -- Create a function to handle mouse movement
    function icon:OnCursorMoved(x, y)

    if !input.IsMouseDown( MOUSE_LEFT ) then return end
    -- Calculate the mouse movement delta
    local dx = x - self.lastX
    local dy = y - self.lastY

    -- Update the rotation using the mouse movement delta
    rotation.yaw = rotation.yaw + dx
    --rotation.pitch = rotation.pitch + dy

    -- Update the last cursor position
    self.lastX = x
    self.lastY = y
    end

    -- Initialize the last cursor position
    icon.lastX = 0
    icon.lastY = 0

   --[[  function icon:DoClick()
        self:SetMouseInputEnabled(not self:IsMouseInputEnabled())
    end ]]
end


function AOCRP.GTM:DoWOSPreview(panel,act)
    local icon = vgui.Create( "DModelPanel", panel )
    icon:Dock(FILL)
    icon:SetModel( LocalPlayer():GetModel() ) -- you can only change colors on playermodels

    campos = Vector(70,-5,40)
    camlookat = Vector(0,0,40)
    camfov = Vector(0,0,0)

    --icon:SetCamPos(campos)
    --icon:SetLookAt(camlookat)


    icon:SetAnimated(true)

    local dance = icon:GetEntity():LookupSequence(act)
	--icon:GetEntity():AddVCDSequenceToGestureSlot(GESTURE_SLOT_CUSTOM, icon:GetEntity():LookupSequence(act), 0, true)
    local dance = icon:GetEntity():LookupSequence(act)

    -- Make both dance
    icon:GetEntity():SetSequence(dance)

    -- Enable mouse rotation
    icon:SetMouseInputEnabled(true)

    -- Create a variable to store the current rotation
    local rotation = Angle(0, 90, 0)

    -- Override the DModelPanel's LayoutEntity function
    function icon:LayoutEntity(Entity)
    -- Rotate the entity using the current rotation
        Entity:SetAngles(rotation)
        Entity:FrameAdvance( ( RealTime() - self.LastPaint ) * self.m_fAnimSpeed )

        if Entity:GetCycle() >= 0.99 then
            Entity:SetCycle(0)
            Entity:ResetSequence(dance)
            --Entity:AddVCDSequenceToGestureSlot(GESTURE_SLOT_CUSTOM, Entity:LookupSequence(act), 0, true)
        end
    end

    -- Create a function to handle mouse movement
    function icon:OnCursorMoved(x, y)

    if !input.IsMouseDown( MOUSE_LEFT ) then return end
    -- Calculate the mouse movement delta
    local dx = x - self.lastX
    local dy = y - self.lastY

    -- Update the rotation using the mouse movement delta
    rotation.yaw = rotation.yaw + dx
    --rotation.pitch = rotation.pitch + dy

    -- Update the last cursor position
    self.lastX = x
    self.lastY = y
    end

    -- Initialize the last cursor position
    icon.lastX = 0
    icon.lastY = 0

   --[[  function icon:DoClick()
        self:SetMouseInputEnabled(not self:IsMouseInputEnabled())
    end ]]
end


local function EntDoAnimation(ent,anim)
	if AOCRP.Animation.FreeAnims[anim] then
		for k, v in pairs(AOCRP.Animation.FreeAnims[anim].bones) do
			if ent:LookupBone(k) != nil then
				ent:ManipulateBoneAngles( ent:LookupBone(k), v.ang, true )
			end
		end
	end
end



function AOCRP.GTM:DoAnimationPreview(panel,anim)
    local icon = vgui.Create( "DModelPanel", panel )
    icon:Dock(FILL)
    icon:SetModel( LocalPlayer():GetModel() ) -- you can only change colors on playermodels

    campos = Vector(70,-5,40)
    camlookat = Vector(0,0,40)
    camfov = Vector(0,0,0)

    --icon:SetCamPos(campos)
    --icon:SetLookAt(camlookat)


    -- Make both dance
    EntDoAnimation( icon:GetEntity(),anim)
    -- Enable mouse rotation
    icon:SetMouseInputEnabled(true)

    -- Create a variable to store the current rotation
    local rotation = Angle(0, 90, 0)

    -- Override the DModelPanel's LayoutEntity function
    function icon:LayoutEntity(Entity)
    -- Rotate the entity using the current rotation
        Entity:SetAngles(rotation)
        Entity:FrameAdvance( ( RealTime() - self.LastPaint ) * self.m_fAnimSpeed )
    end

    -- Create a function to handle mouse movement
    function icon:OnCursorMoved(x, y)

    if !input.IsMouseDown( MOUSE_LEFT ) then return end
    -- Calculate the mouse movement delta
    local dx = x - self.lastX
    local dy = y - self.lastY

    -- Update the rotation using the mouse movement delta
    rotation.yaw = rotation.yaw + dx
    --rotation.pitch = rotation.pitch + dy

    -- Update the last cursor position
    self.lastX = x
    self.lastY = y
    end

    -- Initialize the last cursor position
    icon.lastX = 0
    icon.lastY = 0

   --[[  function icon:DoClick()
        self:SetMouseInputEnabled(not self:IsMouseInputEnabled())
    end ]]
end



-- ARCCW Waffen Charms
local GTM_Charms = {}
GTM_Charms["emotehappy"] = { name = "Happy", price = 10000, icon = "models/weapons/arccw/fml_charm/steamhappy.mdl",vipFree = true}
GTM_Charms["gigachad"] = { name = "Gigachad", price = 50000, icon = "models/weapons/arccw/gigacharm/gigachad.mdl",vipFree = true}
GTM_Charms["emotesalty"] = { name = "Salty", price = 10000, icon = "models/weapons/arccw/fml_charm/steamsalty.mdl", vipFree = true}
GTM_Charms["emotesad"] = { name = "Sad", price = 10000, icon = "models/weapons/arccw/fml_charm/steamsad.mdl",vipFree = true }
GTM_Charms["emotemocking"] = { name = "Mocking", price = 10000, icon = "models/weapons/arccw/fml_charm/steammocking.mdl", vipFree = true}
GTM_Charms["emotefacepalm"] = { name = "Facepalm", price = 10000, icon = "models/weapons/arccw/fml_charm/steamfacepalm.mdl", vipFree = true}
GTM_Charms["emotebored"] = { name = "Bored", price = 10000, icon = "models/weapons/arccw/fml_charm/steambored.mdl", vipFree = true}
GTM_Charms["logo"] = { name = "Age of Clones", price = 10000, icon = "models/starwars/grady/props/aoc/charms/aoc-logo.mdl", vipFree = true}
GTM_Charms["ph2helm"] = { name = "Phase 2 Helm", price = 10000, icon = "models/starwars/grady/props/aoc/charms/helmet_ph2.mdl", vipFree = true}

GTM_Charms["arccw_apex_proscreen"] = { name = "Killcounter Pro", price = 80000, icon = "models/weapons/attachments/pro_screen.mdl", vipFree = false}
GTM_Charms["arccw_apex_proscreen_alt"] = { name = "Killcounter Pro (Alt)", price = 50000, icon = "models/weapons/attachments/pro_screen_2.mdl", vipFree = false}
GTM_Charms["arccw_stattrak"] = { name = "Killcounter Stattrak", price = 150000, icon = "models/weapons/arccw/stattrack.mdl", vipFree = true}
GTM_Charms["arccw_heartsensor"] = { name = "Herzschlagsensor", price = 500000, icon = "models/weapons/arccw/atts/heartsensor.mdl", vipFree = false}






for k, v in pairs(GTM_Charms) do
    AOCRP.GTM.Items[k] = {
        name = v.name,
        desc = "Erst nach Respawn nutzbar",
        price = v.price,
        category = "Charms",
        apply = false,
        buyApply = true,
        permanent = true,
        canSell = true,
        canBuy = true,
        vipFree = v.vipFree,
        vipOnly =  false,
        limitFunc = function(ply) return true end,
        applyFunc = function(ply) ArcCW:PlayerGiveAtt(ply, k, 99)   ArcCW:PlayerSendAttInv(ply) end,
        applyOnSpawnFunc = function(ply) ArcCW:PlayerGiveAtt(ply, k, 99) end,
        iconFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,v.icon) end,
        previewFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,v.icon) end,
    }
end


--[[ 
hook.Add("ArcCW_PlayerCanAttach","GTM_ARCCW_ATTACH", function(ply, wep, attname, slot, detach) 

   if GTM_Charms[attname] then
       if AOCRP.GTM:HasItem(ply, attname) then
           return true
       else 
           ply:ChatPrint("*** Dieses Attachment gibt es im Galactic Trade Market zu kaufen!")
           return false
       end
   end
   return
end) ]]






local GTM_Scopes = {}
GTM_Scopes["uc_optic_acog"] = { name = "ACOG 4x", vip = true, price = 35000, icon = function(panel) end}
GTM_Scopes["uc_optic_hamr"] = { name = "HAMR 3x / Holo", vip = true, price = 50000, icon = function(panel) end}
GTM_Scopes["arccw_hcog"] = { name = "HCOG (1.85x)", vip = true, price = 10000, icon = function(panel) AOCRP.GTM:doMaterialIcon(panel,"entities/arccw_hcog.png",Color(255,255,255)) end}
GTM_Scopes["arccw_titholo"] = { name = "Wonyeon Holo (2.1x)", vip = true, price = 20000, icon = function(panel) AOCRP.GTM:doMaterialIcon(panel,"entities/arccw_titholo.png",Color(255,255,255)) end}
GTM_Scopes["arccw_fullholo"] = { name = "Full Holographic (RDS)", vip = true, price = 5000, icon = function(panel) AOCRP.GTM:doMaterialIcon(panel,"entities/arccw_fullholo.png",Color(255,255,255)) end}
GTM_Scopes["arccw_tracker"] = { name = "Ghost Tracker (RDS)", vip = false, price = 100000, icon = function(panel) AOCRP.GTM:doMaterialIcon(panel,"entities/arccw_tracker.png",Color(255,255,255)) end}

--[[ uc_optic_leupold_dppro
uc_optic_comp_m2
uc_optic_elcan
uc_optic_eotech552
uc_optic_eotech553
uc_optic_holosun2
uc_grip_bcmvfg
 ]]




for k, v in pairs(GTM_Scopes) do

    AOCRP.GTM.Items[k] = {
        name = v.name,
        desc = "Erst nach Respawn aktiv",
        price = v.price,
        category = "Waffenzubehr",
        apply = false,
        permanent = true,
        canSell = true,
        canBuy = true,
        vipFree = v.vip,
        vipOnly =  false,
        limitFunc = function(ply) return true end,
        applyFunc = function(ply) end,
        applyOnSpawnFunc = function(ply) ArcCW:PlayerGiveAtt(ply, k, 99) end,
        iconFunc = v.icon,
        previewFunc = v.icon,
    }

end







AOCRP.GTM.Items["crosshair_default"] = {
    name = "Standard",
    desc = "Setze das Crosshair zurck.",
    price = 1,
    category = "Crosshairs",
    apply = true,
    permanent = false,
    canSell = false,
    canBuy = true,
    vipFree = false,
    vipOnly =  false,
    limitFunc = function(ply) return true end,
    applyFunc = function(ply) AOCRP.GTM:ApplyCrosshair(ply, "default") end,
    iconFunc = function(panel) end,
    previewFunc = function(panel) end,
}

for k, v in pairs(AOCRP.Config.Crosshair) do

    AOCRP.GTM.Items[k] = {
        name = v.name,
        desc = "Ein benutzerdefiniertes Crosshair fr dein Helm-Overlay.",
        price = v.price,
        category = "Crosshairs",
        apply = true,
        permanent = true,
        canSell = true,
        canBuy = true,
        vipFree = true,
        vipOnly =  false,
        limitFunc = function(ply) return true end,
        applyFunc = function(ply) AOCRP.GTM:ApplyCrosshair(ply, k) end,
        iconFunc = function(panel) AOCRP.GTM:doCrossHairIcon(panel,k) end,
        previewFunc = function(panel) AOCRP.GTM:doCrossHairIcon(panel,k) end,
    }
        
end

--[[
AOCRP.GTM.Items["test_helmet"] = {
    name = "Testhelm",
    desc = "Ein benutzerdefiniertes Crosshair fr dein Helm-Overlay.",
    price = 187,
    category = "Skin",
    apply = true,
    permanent = true,
    limitFunc = function(ply) return true end,
    applyFunc = function(ply) end,
    iconFunc = function(panel) doHelmetSkinIcon(panel,"starwars/grady/stosstruppen/st_trooper/501st_helmet",3) end,
    previewFunc = function(panel) doSkinPreview(panel,"starwars/grady/stosstruppen/st_trooper/501st_helmet",3) end,
}
 ]]



local HeadSkins = {}

// 212TH LEGION //
-------------------
// GHOST COMPANY MAIN HELMET //
HeadSkins["ghc_helmet_1"] = {name = "Helm Clean", desc = "Clean", price = 20000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet1"}
HeadSkins["ghc_helmet_2"] = {name = "Helm Gelbschweif", desc = "Gelbschweif", price = 20000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet2"}
HeadSkins["ghc_helmet_3"] = {name = "Helm Balken", desc = "Balken", price = 20000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet3"}
HeadSkins["ghc_helmet_4"] = {name = "Helm Vollstrich", desc = "Vollstrich", price = 30000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet4"}
HeadSkins["ghc_helmet_5"] = {name = "Helm Pfeil!", desc = "Pfeil", price = 30000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet5"}
HeadSkins["ghc_helmet_6"] = {name = "Helm Graukinn", desc = "Graukinn", price = 50000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet6"}
HeadSkins["ghc_helmet_7"] = {name = "Helm Grauvisier", desc = "Grauvisier", price = 50000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet7"}
HeadSkins["ghc_helmet_8"] = {name = "Helm Vollstrich 2", desc = "Vollstrich 2", price = 35000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet8"}
HeadSkins["ghc_helmet_geonosis_1"] = {name = "Helm Geonosis", desc = "Ich hasse Sand.", price = 50000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet10"}
HeadSkins["ghc_helmet_geonosis_2"] = {name = "Helm Geo-Sandig", desc = "Ich hasse Sand.", price = 55000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet12"}
HeadSkins["ghc_helmet_geonosis_3"] = {name = "Helm Geo-Strich", desc = "Ich hasse Sand.", price = 60000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet11"}
HeadSkins["ghc_christmas_helm"] = {name = "Weihnachtsskin", desc = "Nur via Geschenk erhltlich.", price = -1, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_christmas", cantBuy = true}
HeadSkins["ghc_veteran_heln"] = {name = "GHC Veteran", desc = "", price = 35000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet9"}
HeadSkins["hc_veteran_heln"] = {name = "HC Veteran", desc = "", price = 35000, model = {"models/starwars/grady/212th/212th_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/heavys/helmet/helmet1"}
HeadSkins["ghc_order66_helmet"] = {name = "Helm Order", desc = "Limitiert erhltlich bis: 14.04.2022", price = -1, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_order66", cantBuy = true}
HeadSkins["212_foxtrot_helmet"] = {name = "Helm Foxtrot", desc = "Foxtrot!", price = 50000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_foxtrot"}
HeadSkins["212_ph1_helmet"] = {name = "Helm Classic", desc = "Die guten alten Zeiten...", price = 30000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_phase1"}
HeadSkins["212_triton_helmet"] = {name = "Helm Triton", desc = "Triton", price = 50000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_triton"}
HeadSkins["212_umbra_helmet"] = {name = "Helm Umbra", desc = "Umbra.", price = 50000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_umbra"}
HeadSkins["212_rallyhelmet"] = {name = "Helm Rallye", desc = "Umbra.", price = 50000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_rallye"}
HeadSkins["212_yodahelmet"] = {name = "Helm Yoda", desc = "", price = 65000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_yoda"}
HeadSkins["212_baymaxhelmet"] = {name = "Helm Baymax", desc = "", price = 50000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_baymax"}
HeadSkins["212_destinyhelmet"] = {name = "Helm Destiny", desc = "", price = 50000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_destiny"}
HeadSkins["212_heavyhelmet"] = {name = "Helm Heavy", desc = "OG Zeiten", price = 50000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_heavy"}
HeadSkins["212_helmetpointy"] = {name = "Helm Pointy", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_pointy"}
HeadSkins["gc_helm_relikt"] = {name = "Helm Relikt", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_old_republic"}
HeadSkins["gc_helm_moon"] = {name = "Helm Moon", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_moon"}
HeadSkins["gc_helm_origins"] = {name = "Helm Origins", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_origins"}
HeadSkins["gc_helm_tfu_cmd"] = {name = "Helm TFU Commander", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_tfu_commander"}
HeadSkins["gc_helm_wildcat"] = {name = "Helm Wildcat", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_wildcat"}
HeadSkins["gc_helm_2099"] = {name = "Helm 2099", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_2099", vipOnly = true }
HeadSkins["gc_helm_rook"] = {name = "Helm Rook", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_rook"}
HeadSkins["gc_helm_awen"] = {name = "Helm awen", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_awen"}
HeadSkins["gc_christmas24"] = {name = "Helm Christmas", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/special/christmas2024/clone/helmet_ph2"}



// GHOST COMPANY MAIN HELMET ENDE //

-------------------
-- NEUE EINHEIT! --
-------------------

// ARF HELME (NEXU) //
HeadSkins["arf_helm1"] = {name = "Helm Grey", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/arf/helmet/helmet1"}
HeadSkins["arf_helm2"] = {name = "Helm Orange", desc = "", price = 35000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/arf/helmet/helmet2"}
HeadSkins["arf_helm3"] = {name = "Helm Smack", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/arf/helmet/helmet3"}
HeadSkins["arf_helm4"] = {name = "Helm Y", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/arf/helmet/helmet4"}
HeadSkins["arf_helm5"] = {name = "Helm Leoj", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/arf/helmet/helmet5"}
HeadSkins["arf_helm6"] = {name = "Helm Wildcat", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/arf/helmet/helmet_wildcat"}
HeadSkins["arf_helm7"] = {name = "Helm Half", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/arf/helmet/helmet_half"}
HeadSkins["arf_helm8"] = {name = "Helm Ezra", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/arf/helmet/helmet_ezra"}
HeadSkins["arf_helm9"] = {name = "Helm Smack", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl", "models/starwars/grady/arc/aoc/212th_arc_nexu.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/arf/helmet/helmet_smack"}
HeadSkins["arf_helm10"] = {name = "Helm Camo Black", desc = "", price = 1000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/arf/helmet/helmet_camo_black"}
HeadSkins["arf_helm11"] = {name = "Helm Camo Felucia", desc = "", price = 1000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/arf/helmet/helmet_camo_felucia"}
HeadSkins["arf_helm12"] = {name = "Helm Camo Geonosis", desc = "", price = 1000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/arf/helmet/helmet_camo_geonosis"}
HeadSkins["arf_helm13"] = {name = "Helm Camo kashyyyk", desc = "", price = 1000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/arf/helmet/helmet_camo_kashyyyk"}
HeadSkins["arf_helm14"] = {name = "Helm Camo mimban", desc = "", price = 1000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/arf/helmet/helmet_camo_mimban"}
HeadSkins["arf_helm15"] = {name = "Helm Christmas", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/special/christmas2024/clone/helmet_arf"}



// ARF HELME (NEXU) ENDE! //

// ARF HELME (NEXU) //
HeadSkins["arf_cheek1"] = {name = "Cheek Black", desc = "", price = 5000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 8, mat = "starwars/grady/itemshop/212th/arf/cheek/full/black"}
HeadSkins["arf_cheek2"] = {name = "Cheek Brown", desc = "", price = 5000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 8, mat = "starwars/grady/itemshop/212th/arf/cheek/full/brown"}
HeadSkins["arf_cheek3"] = {name = "Cheek Grey", desc = "", price = 5000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 8, mat = "starwars/grady/itemshop/212th/arf/cheek/full/grey"}
HeadSkins["arf_cheek4"] = {name = "Cheek Hound", desc = "", price = 5000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 8, mat = "starwars/grady/itemshop/212th/arf/cheek/hound/grey"}
HeadSkins["arf_cheek5"] = {name = "Cheek Orange", desc = "", price = 5000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 8, mat = "starwars/grady/itemshop/212th/arf/cheek/full/orange"}
HeadSkins["arf_cheek6"] = {name = "Cheek Hound Black", desc = "", price = 5000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 8, mat = "starwars/grady/itemshop/212th/arf/cheek/hound/black"}
HeadSkins["arf_cheek7"] = {name = "Cheek Hound Brown", desc = "", price = 5000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 8, mat = "starwars/grady/itemshop/212th/arf/cheek/hound/brown"}
HeadSkins["arf_cheek8"] = {name = "Cheek Hound Orange", desc = "", price = 5000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl", "models/starwars/grady/arc/aoc/212th_arc_nexu.mdl"}, id = 8, mat = "starwars/grady/itemshop/212th/arf/cheek/hound/orange"}
HeadSkins["arf_cheek9"] = {name = "Cheek Hound Red", desc = "", price = 5000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 8, mat = "starwars/grady/itemshop/212th/arf/cheek/hound/red"}

// ARF HELME (NEXU) ENDE! //


-------------------
-- NEUE EINHEIT! --
-------------------

// ENGINEERING COMPANY HELM //
HeadSkins["ec_helmet_1"] = {name = "Unklar", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ec/helmet/helmet1"}
HeadSkins["ec_helmet_2"] = {name = "Pfeil", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ec/helmet/helmet2"}
HeadSkins["ec_helmet_4"] = {name = "38th", desc = "", price = 35000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ec/helmet/helmet4"}
HeadSkins["ec_veteran_helm"] = {name = "Veteran", desc = "", price = 35000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ec/helmet/helmet3"}
HeadSkins["ec_original_helm"] = {name = "Original", desc = "", price = 35000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ec/helmet/helmet5"}
HeadSkins["ec_invertiert_helm"] = {name = "Invertiert", desc = "", price = 15000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ec/helmet/helmet6"}
HeadSkins["ec_raptor_helm"] = {name = "Raptor", desc = "", price = 15000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ec/helmet/helmet_raptor"}
HeadSkins["ec_operator_helm"] = {name = "Operator", desc = "", price = 15000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ec/helmet/helmet_operator"}
HeadSkins["ec_upgrade_helm"] = {name = "Upgrade", desc = "", price = 15000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ec/helmet/helmet_upgrade"}
HeadSkins["ec_raute_helm"] = {name = "raute", desc = "", price = 15000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ec/helmet/helmet_raute"}
HeadSkins["ec_raute_inverted_helm"] = {name = "raute inverted", desc = "", price = 15000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ec/helmet/helmet_raute_inverted"}
HeadSkins["ec_203rd_helm"] = {name = "raute inverted", desc = "", price = 15000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ec/helmet/helmet_203rd"}
HeadSkins["ft_helmet_flame"] = {name = "Flame", desc = "", price = 15000, model = {"models/starwars/grady/aoc/212th/ec/212th_flametrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ft/helmet/helmet_flame"}
HeadSkins["ec_fixer_helm"] = {name = "Fixer inverted", desc = "", price = 15000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ec/helmet/helmet_fixer"}
HeadSkins["ec_metal_helm"] = {name = "Metal inverted", desc = "", price = 15000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ec/helmet/helmet_metal"}
HeadSkins["ec_christmas24"] = {name = "Helm Christmas", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/special/christmas2024/clone/helmet_ph2"}

// !! ENGINEERING COMPANY HELM ENDE !! //

-------------------
-- NEUE EINHEIT! --
-------------------

// AIRBORNE COMPANY HELM //
HeadSkins["ac_helmet_1"] = {name = "Helm Pfeile", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet1"}
HeadSkins["ac_helmet_2"] = {name = "Helm Split", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet2"}
HeadSkins["ac_helmet_3"] = {name = "Helm V", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet3"}
HeadSkins["ac_helmet_4"] = {name = "Helm Eyestripe", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet4"}
HeadSkins["ac_helmet_5"] = {name = "Helm Doublestripe", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet5"}
HeadSkins["ac_helmet_6"] = { name = "Helm Sidestripe", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet6"}
HeadSkins["ac_helmet_7"] = { name = "Helm Fatline", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet7"}
HeadSkins["ac_helmet_8"] = { name = "Helm T", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet8"}
HeadSkins["ac_helmet_9"] = { name = "Helm T Rustikal", desc = "", price = 45000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet9"}
HeadSkins["ac_helmet_trio"] = { name = "Helm Trio", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet_trio"}
HeadSkins["ac_helmet_curves"] = { name = "Helm Curves", desc = "", price = 25000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet_curves"}
HeadSkins["ac_helmet_triangle"] = {name = "Helm Triangle", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet_triangle"}
HeadSkins["ac_helmet_yirt"] = {name = "Helm Yirt", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet_yirt"}
HeadSkins["ac_helmet_dragonfighter"] = {name = "Helm Dragonfighter", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet_dragon"}
HeadSkins["ac_helmet_stripes"] = {name = "Helm Stripes", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet_stripes"}
HeadSkins["ac_helmet_Order"] = {name = "Helm Order", desc = "Limitiert erhltlich gewesen bis 13.05.2022", price = -1, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet_order66", cantBuy = true}
HeadSkins["ac_helmet_recon"] = {name = "Helm Recon", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet_recon"}
HeadSkins["ac_helmet_christmas24"] = {name = "Helm Christmas", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/special/christmas2024/clone/helmet_airborne"}

// !! AIRBORNE COMPANY HELM ENDE !! //


-------------------
-- NEUE LEGION! --
-------------------

-------------------
// 501st LEGION //
-------------------
// TORRENT COMPANY MAIN HELM //
HeadSkins["tc_helmet_2"] = {name = "Helm V", desc = "V wie Vandetta", price = 30000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet2"}
HeadSkins["tc_helmet_3"] = {name = "Helm Asym", desc = "Weier Strich auf blauen Grund", price = 50000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet3"}
HeadSkins["tc_helmet_4"] = {name = "Helm Stumgrau", desc = "Strmischer Kmpfer", price = 50000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet4"}
HeadSkins["tc_helmet_5"] = {name = "Helm Zorn", desc = "Zorn der Torrent Company", price = 35000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet5"}
HeadSkins["tc_helmet_6"] = {name = "Helm Malerei", desc = "Sieht aus wie Hhlenmalerei", price = 60000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet6"}
HeadSkins["tc_helmet_7"] = {name = "Helm Poseidon", desc = "Mit der Macht von Poseidon", price = 60000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet7"}
HeadSkins["tc_helmet_8"] = {name = "Helm I", desc = "Illuminati confirmed", price = 20000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet8"}
HeadSkins["tc_christmas_helm"] = {name = "Weihnachtsskin", desc = "Nur via Geschenk erhltlich.", price = -1, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_christmas", cantBuy = true}
HeadSkins["tc_veteran_heln"] = {name = "Veteran", desc = "Teil des Veteran-Packs.", price = 35000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet1"}
HeadSkins["tc_order_helm"] = {name = "Helm Order", desc = "Limitiert erhltlich bis: 14.04.2022", price = -1, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_order66", cantBuy = true}
HeadSkins["501st_tano_helm"] = {name = "Helm Tano", desc = "Commander Tano ist stolz.", price = 50000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_332nd"}
HeadSkins["501st_ph1_helmet"] = {name = "Helm Classic", desc = "Die guten alten Zeiten...", price = 30000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_phase1"}
HeadSkins["501st_triton_helmet"] = {name = "Helm Triton", desc = "Triton", price = 50000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_triton"}
HeadSkins["501st_umbra_helmet"] = {name = "Helm Umbra", desc = "Umbra.", price = 50000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_umbra"}
HeadSkins["501st_elite_helmet"] = {name = "Helm Elite", desc = "Umbra.", price = 50000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_elite"}
HeadSkins["501st_rallyhelmet"] = {name = "Helm Rallye", desc = "Umbra.", price = 50000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_rallye"}
HeadSkins["501st_yodahelmet"] = {name = "Helm Yoda", desc = "", price = 65000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_yoda"}
HeadSkins["501st_baymaxhelmet"] = {name = "Helm Baymax", desc = "", price = 50000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_baymax"}
HeadSkins["501st_destinyhelmet"] = {name = "Helm Destiny", desc = "", price = 50000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_destiny"}
HeadSkins["501st_pointyhelmet"] = {name = "Helm Pointy", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_pointy"}
HeadSkins["tc_helm_relikt"] = {name = "Helm Relikt", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_old_republic"}
HeadSkins["tc_helm_moon"] = {name = "Helm Moon", desc = "", price = 30000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_moon"}
HeadSkins["tc_helm_origins"] = {name = "Helm Origins", desc = "", price = 30000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_origins"}
HeadSkins["tc_helm_tfu_commander"] = {name = "Helm Commander", desc = "", price = 30000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_tfu_commander"}
HeadSkins["tc_helm_2099"] = {name = "Helm 2099", desc = "", price = 30000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_2099", vipOnly = true }
HeadSkins["tc_helm_rook"] = {name = "Helm Rook", desc = "", price = 30000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_rook"}
HeadSkins["tc_helm_awen"] = {name = "Helm awen", desc = "", price = 30000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_awen"}
HeadSkins["tc_helm_christmas24"] = {name = "Helm Christmas", desc = "", price = 20000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/special/christmas2024/clone/helmet_ph2"}


// TORRENT COMPANY MAIN HELM ENDE! //

-------------------
-- NEUE EINHEIT! --
-------------------

// TORRENT COMPANY JAIG HELM //
HeadSkins["JP_Helmet_1"] = {name = "Helm Jaig Arrows", desc = "Der Pfeil geht nach oben wie Lauch Fabian", price = 40000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/jaig/helmet/helmet_arrow"}
HeadSkins["JP_Helmet_2"] = {name = "Helm Lowkey", desc = "Der ist Lowkey geil", price = 40000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/jaig/helmet/helmet_lowkey"}
HeadSkins["JP_Helmet_3"] = {name = "Helm Wirbel", desc = "Wirbel wie beim Stress mit der ST", price = 40000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/jaig/helmet/helmet_wirbel"}
HeadSkins["JP_Helmet_4"] = {name = "Helm Crescent", desc = "Der Halbmond ist schn", price = 50000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/jaig/helmet/helmet_crescent"}
HeadSkins["JP_Helmet_Umbra"] = {name = "Helm Umbra", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 30000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/jaig/helmet/helmet_umbra"}
HeadSkins["JP_Helmet_Rallye"] = {name = "Helm Rallye", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 30000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/jaig/helmet/helmet_rallye"}
HeadSkins["JP_Helmet_Dagger"] = {name = "Helm Dagger", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 30000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/jaig/helmet/helmet_dagger"}
HeadSkins["JP_Helmet_332nd"] = {name = "Helm Tano", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 30000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/jaig/helmet/helmet_332nd"}
HeadSkins["JP_Helmet_Cabo"] = {name = "Helm Cabo", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 30000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/jaig/helmet/helmet_cabo"}
HeadSkins["JP_Helmet_tfu_commander"] = {name = "Helm TFU Commander", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 30000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/jaig/helmet/helmet_tfu_commander"}
HeadSkins["JP_Helmet_rook"] = {name = "Helm Rook", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 30000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/jaig/helmet/helmet_rook"}
HeadSkins["JP_Helmet_assassine"] = {name = "Helm Assassine", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 30000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/jaig/helmet/helmet_assassine"}
HeadSkins["JP_Helmet_2099"] = {name = "Helm 2099", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 30000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/jaig/helmet/helmet_2099"}
HeadSkins["JP_Helmet_bad-batch"] = {name = "Helm Bad Batch", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 30000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/jaig/helmet/helmet_bad-batch"}
HeadSkins["JP_Helmet_awen"] = {name = "Helm Awen", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 30000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/jaig/helmet/helmet_awen"}
HeadSkins["JP_Helmet_christmas24"] = {name = "Helm Christmas", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 20000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/special/christmas2024/clone/helmet_barc"}


// TORRENT COMPANY JAIG HELM ENDE ! //

//DP HELME
HeadSkins["DP_Helmet_Skeleton"] = {name = "Helm Skeleton", desc = "Wumgabadamdingo", price = 30000, model = {"smodels/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/dp/helmet/helmet_halloween_skeleton"}
HeadSkins["DP_Helmet_koeniglich"] = {name = "Helm koeniglich", desc = "Wumgabadamdingo", price = 30000, model = {"models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/dp/helmet/helmet_koeniglich"}
HeadSkins["DP_Helmet_Tano"] = {name = "Helm Tano", desc = "Wumgabadamdingo", price = 30000, model = {"models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/dp/helmet/helmet_332nd"}
HeadSkins["DP_Helmet_Umbra"] = {name = "Helm Umbra", desc = "Wumgabadamdingo", price = 30000, model = {"models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/dp/helmet/helmet_umbra"} 
HeadSkins["DP_Helmet_2099"] = {name = "Helm 2099", desc = "Wumgabadamdingo", price = 30000, model = {"models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/dp/helmet/helmet_2099"} 
HeadSkins["DP_Helmet_awen"] = {name = "Helm Awen", desc = "Wumgabadamdingo", price = 30000, model = {"models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/dp/helmet/helmet_awen"} 
HeadSkins["DP_Helmet_for-hevy"] = {name = "Helm For-hevy", desc = "Wumgabadamdingo", price = 30000, model = {"models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/dp/helmet/helmet_for-hevy"} 
HeadSkins["DP_Helmet_nexos"] = {name = "Helm Definitivnichtvonnexos", desc = "Wumgabadamdingo", price = 30000, model = {"models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/dp/helmet/helmet_nexos"} 
HeadSkins["DP_Helmet_rook"] = {name = "Helm rook", desc = "Wumgabadamdingo", price = 30000, model = {"models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/dp/helmet/helmet_rook"} 
HeadSkins["DP_Helmet_phase1"] = {name = "Helm phase1", desc = "Wumgabadamdingo", price = 30000, model = {"models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/dp/helmet/helmet_phase1"} 
HeadSkins["DP_Helmet_tfu_commander"] = {name = "Helm TFU COMMANDER", desc = "Wumgabadamdingo", price = 30000, model = {"models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/dp/helmet/helmet_tfu_commander"} 
HeadSkins["DP_Helmet_triton"] = {name = "Helm Triton", desc = "Wumgabadamdingo", price = 30000, model = {"models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/dp/helmet/helmet_triton"} 
HeadSkins["DP_Helmet_yoda"] = {name = "Helm Yoda", desc = "Wumgabadamdingo", price = 30000, model = {"models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/dp/helmet/helmet_yoda"} 


-------------------
-- NEUE EINHEIT! --
-------------------

// MEDICAL PLATOON HELM //
HeadSkins["mp_helmet_1"] = {name = "Helm 1", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 20000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/medics/helmet/helmet1"}
HeadSkins["mp_helmet_2"] = {name = "Helm 2", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 30000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/medics/helmet/helmet2"}
HeadSkins["mp_helmet_3"] = {name = "Helm 3", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 45000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/medics/helmet/helmet3"}
HeadSkins["mp_helmet_4"] = {name = "Helm 4", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 20000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/medics/helmet/helmet4"}
HeadSkins["mp_helmet_5"] = {name = "Helm 5", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 20000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/medics/helmet/helmet5"}
HeadSkins["mp_helmet_6"] = {name = "Helm 6", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 20000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/medics/helmet/helmet6"}
HeadSkins["mp_helmet_7"] = {name = "Helm 7", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 20000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/medics/helmet/helmet7"}
HeadSkins["mp_helmet_8"] = {name = "Helm 8", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 20000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/medics/helmet/helmet8"}
HeadSkins["mp_helmet_9"] = {name = "Helm 9", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 20000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/medics/helmet/helmet9"}
HeadSkins["mp_helmet_10"] = {name = "Helm 10", desc = "Wer das liest muss Grady schreiben dass er bld ist", price = 20000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/medics/helmet/helmet10"}
HeadSkins["mp_helmet_vest"] = {name = "Helm Vest", desc = "Vest", price = 20000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/medics/helmet/helmet_vest"}
HeadSkins["mp_helmet_front"] = {name = "Helm Front", desc = "Front", price = 20000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/medics/helmet/helmet_frontkaempfer"}
HeadSkins["mp_helmet_skull"] = {name = "Helm Skull", desc = "i forgor", price = 15000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/medics/helmet/helmet_skull"}
HeadSkins["mp_helmet_sigil"] = {name = "Helm Sigil", desc = "Sigil", price = 20000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/medics/helmet/helmet_sigil"}
HeadSkins["jumptrooper_helmetjet"] = {name = "Helm Jet", desc = "Sigil", price = 20000, model = {"models/starwars/grady/501st_medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/medics-jumptrooper/helmet/helmet_jet"}
HeadSkins["mp_helmet_divine-wings"] = {name = "Helm Divine-Wings", desc = "Bro", price = 20000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/medics/helmet/helmet_divine-wings"}
HeadSkins["mp_helmet_dok"] = {name = "Helm Dok", desc = "Bro", price = 20000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/medics/helmet/helmet_dok"}
HeadSkins["mp_helmet_orion"] = {name = "Helm Orion", desc = "Bro", price = 20000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/medics/helmet/helmet_orion"}
HeadSkins["mp_helmet_minos"] = {name = "Helm Minos", desc = "Bro", price = 20000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/medics/helmet/helmet_minos"}
HeadSkins["mp_helmet_stratos"] = {name = "Helm Stratos", desc = "Bro", price = 20000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/medics/helmet/helmet_stratos"}
HeadSkins["mp_christmas24"] = {name = "Helm Christmas", desc = "Bro", price = 20000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/special/christmas2024/clone/helmet_ph2"}


// MEDICAL PLATOON HELM ENDE ! //

-------------------
-- NEUE LEGION! --
-------------------


// SCHOCKTRUPPEN HELM //
HeadSkins["ST_ph1_helmet"] = {name = "Helm Classic", desc = "Die guten alten Zeiten...", price = 30000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_phase1"}
HeadSkins["ST_triton_helmet"] = {name = "Helm Triton", desc = "Triton", price = 50000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_triton"}
HeadSkins["ST_umbra_helmet"] = {name = "Helm Umbra", desc = "Umbra.", price = 50000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_umbra"}
HeadSkins["ST_imp_helmet"] = {name = "Helm Imp", desc = "Irgendwie kommt mir das bekannt vor..", price = 30000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_imperial"}
HeadSkins["ST_senat_helmet"] = {name = "Helm Senat", desc = "I am the Senate.", price = 30000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_coruscant_guard"}
HeadSkins["ST_rallyhelmet"] = {name = "Helm Rallye", desc = "Umbra.", price = 50000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_rallye"}
HeadSkins["ST_yodahelmet"] = {name = "Helm Yoda", desc = "", price = 65000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_yoda"}
HeadSkins["ST_baymaxhelmet"] = {name = "Helm Baymex", desc = "", price = 50000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_baymax"}
HeadSkins["ST_destinyhelmet"] = {name = "Helm Destiny", desc = "", price = 50000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_destiny"}
HeadSkins["ST_pointyhelmet"] = {name = "Helm Pointy", desc = "", price = 30000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_pointy"}
HeadSkins["st_helm_aurek"] = {name = "Helm Rotbacke", desc = "", price = 40000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet3"}
HeadSkins["st_helm_besh"] = {name = "Helm Thor", desc = "", price = 30000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet2"}
HeadSkins["st_helm_cresh"] = {name = "Helm Glnzer", desc = "", price = 30000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet1"}
HeadSkins["st_helm_relikt"] = {name = "Helm Relikt", desc = "", price = 30000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_old_republic"}
HeadSkins["st_helm_moon"] = {name = "Helm Moon", desc = "", price = 30000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_moon"}
HeadSkins["st_helm_origins"] = {name = "Helm Origins", desc = "", price = 30000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_origins"}
HeadSkins["st_helm_tfu_commander"] = {name = "Helm TFU Commander", desc = "", price = 30000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_tfu_commander"}
HeadSkins["st_helm_2099"] = {name = "Helm 2099", desc = "", price = 30000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_2099", vipOnly = true }
HeadSkins["st_helm_rook"] = {name = "Helm Rook", desc = "", price = 30000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_rook"}
HeadSkins["st_helm_awen"] = {name = "Helm awen", desc = "", price = 30000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_awen"}
HeadSkins["st_helm_christmas"] = {name = "Helm Christmas", desc = "", price = 20000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/special/christmas2024/clone/helmet_ph2"}

// SCHOCKTRUPPEN HELM ENDE! //

// AVP HELME //
HeadSkins["avp_helm1"] = {name = "Helm Eagle GOLD", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/helmet/helmet_eagle"}
HeadSkins["avp_helm2"] = {name = "Helm Eagle SHADOW", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/helmet/helmet_eagle"}
HeadSkins["avp_helm3"] = {name = "Helm Eagle BLUE", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/helmet/helmet_eagle"}
HeadSkins["avp_helm4"] = {name = "Helm Hazard GOLD", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/helmet/helmet_hazard"}
HeadSkins["avp_helm5"] = {name = "Helm Hazard SHADOW", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/helmet/helmet_hazard"}
HeadSkins["avp_helm6"] = {name = "Helm Hazard BLUE", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/helmet/helmet_hazard"}
HeadSkins["avp_helm7"] = {name = "Helm Outline GOLD", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/helmet/helmet_outline"}
HeadSkins["avp_helm8"] = {name = "Helm Outline SHADOW", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/helmet/helmet_outline"}
HeadSkins["avp_helm9"] = {name = "Helm Outline BLUE", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/helmet/helmet_outline"}
HeadSkins["avp_helm10"] = {name = "Helm Outline", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/helmet/helmet_outline"}
HeadSkins["avp_helm11"] = {name = "Helm eagle", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/helmet/helmet_eagle"}
HeadSkins["avp_helm12"] = {name = "Helm hazard", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/helmet/helmet_hazard"}
--
HeadSkins["avp_helm13"] = {name = "Helm Contrast", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/helmet/helmet_contrast"}
HeadSkins["avp_helm14"] = {name = "Helm Contrast GOLD", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/helmet/helmet_contrast"}
HeadSkins["avp_helm15"] = {name = "Helm Contrast SHADOW", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/helmet/helmet_contrast"}
HeadSkins["avp_helm16"] = {name = "Helm Contrast BLUE", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/helmet/helmet_contrast"}
--
HeadSkins["avp_helm17"] = {name = "Helm Hower", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/helmet/helmet_hower"}
HeadSkins["avp_helm18"] = {name = "Helm Hower GOLD", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/helmet/helmet_hower"}
HeadSkins["avp_helm19"] = {name = "Helm Hower SHADOW", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/helmet/helmet_hower"}
HeadSkins["avp_helm20"] = {name = "Helm Hower BLUE", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/helmet/helmet_hower"}
--
HeadSkins["avp_helm21"] = {name = "Helm Hunter", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/helmet/helmet_hunter"}
HeadSkins["avp_helm22"] = {name = "Helm Hunter GOLD", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/helmet/helmet_hunter"}
HeadSkins["avp_helm23"] = {name = "Helm Hunter SHADOW", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/helmet/helmet_hunter"}
HeadSkins["avp_helm24"] = {name = "Helm Hunter BLUE", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/helmet/helmet_hunter"}
--
HeadSkins["avp_helm25"] = {name = "Helm Original", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/helmet/helmet_original"}
HeadSkins["avp_helm26"] = {name = "Helm Original GOLD", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/helmet/helmet_original"}
HeadSkins["avp_helm27"] = {name = "Helm Original SHADOW", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/helmet/helmet_original"}
HeadSkins["avp_helm28"] = {name = "Helm Original BLUE", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/helmet/helmet_original"}
--
HeadSkins["avp_helm29"] = {name = "Helm Stripes", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/helmet/helmet_stripes"}
HeadSkins["avp_helm30"] = {name = "Helm Stripes GOLD", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/helmet/helmet_stripes"}
HeadSkins["avp_helm31"] = {name = "Helm Stripes SHADOW", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/helmet/helmet_stripes"}
HeadSkins["avp_helm32"] = {name = "Helm Stripes BLUE", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/helmet/helmet_stripes"}
--
HeadSkins["avp_helm33"] = {name = "Helm Sunrise", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/helmet/helmet_sunrise"}
HeadSkins["avp_helm34"] = {name = "Helm Sunrise GOLD", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/helmet/helmet_sunrise"}
HeadSkins["avp_helm35"] = {name = "Helm Sunrise SHADOW", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/helmet/helmet_sunrise"}
HeadSkins["avp_helm36"] = {name = "Helm Sunrise BLUE", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/helmet/helmet_sunrise"}
--
HeadSkins["avp_helm37"] = {name = "Helm Sutekh", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/helmet/helmet_sutekh"}
HeadSkins["avp_helm38"] = {name = "Helm Sutekh GOLD", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/helmet/helmet_sutekh"}
HeadSkins["avp_helm39"] = {name = "Helm Sutekh SHADOW", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/helmet/helmet_sutekh"}
HeadSkins["avp_helm40"] = {name = "Helm Sutekh BLUE", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/helmet/helmet_sutekh"}

HeadSkins["avp_christmas24"] = {name = "Helm Christmas", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl","models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl","models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl","models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/special/christmas2024/clone/helmet_pilot"}

// AVP HELMET ENDE! //

local BodySkins = {}

// AVP BODY //
BodySkins["avp_body1"] = {name = "Body Eagle GOLD", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/body/body_eagle"}
BodySkins["avp_body2"] = {name = "Body Eagle SHADOW", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/body/body_eagle"}
BodySkins["avp_body3"] = {name = "Body Eagle BLUE", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/body/body_eagle"}
BodySkins["avp_body4"] = {name = "Body Hazard GOLD", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/body/body_hazard"}
BodySkins["avp_body5"] = {name = "Body Hazard SHADOW", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/body/body_hazard"}
BodySkins["avp_body6"] = {name = "Body Hazard BLUE", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/body/body_hazard"}
BodySkins["avp_body7"] = {name = "Body Outline GOLD", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/body/body_outline"}
BodySkins["avp_body8"] = {name = "Body Outline SHADOW", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/body/body_outline"}
BodySkins["avp_body9"] = {name = "Body Outline BLUE", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/body/body_outline"}
BodySkins["avp_body10"] = {name = "Body Outline", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/body/body_outline"}
BodySkins["avp_body11"] = {name = "Body eagle", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/body/body_eagle"}
BodySkins["avp_body12"] = {name = "Body hazard", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/body/body_hazard"}
--
BodySkins["avp_body13"] = {name = "Body Bigchill", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/body/body_bigchill"}
BodySkins["avp_body14"] = {name = "Body Bigchill Gold", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/body/body_bigchill"}
BodySkins["avp_body15"] = {name = "Body Bigchill Schatten", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/body/body_bigchill"}
BodySkins["avp_body16"] = {name = "Body Bigchill Blau", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/body/body_bigchill"}
--
BodySkins["avp_body17"] = {name = "Body Contrast", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/body/body_contrast"}
BodySkins["avp_body18"] = {name = "Body Contrast Gold", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/body/body_contrast"}
BodySkins["avp_body19"] = {name = "Body Contrast Schatten", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/body/body_contrast"}
BodySkins["avp_body20"] = {name = "Body Contrast Blau", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/body/body_contrast"}
--
BodySkins["avp_body21"] = {name = "Body Contrast", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/body/body_contrast"}
BodySkins["avp_body22"] = {name = "Body Contrast Gold", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/body/body_contrast"}
BodySkins["avp_body23"] = {name = "Body Contrast Schatten", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/body/body_contrast"}
BodySkins["avp_body24"] = {name = "Body Contrast Blau", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/body/body_contrast"}
--
BodySkins["avp_body21"] = {name = "Body Hower", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/body/body_hower"}
BodySkins["avp_body22"] = {name = "Body Hower Gold", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/body/body_hower"}
BodySkins["avp_body23"] = {name = "Body Hower Schatten", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/body/body_hower"}
BodySkins["avp_body24"] = {name = "Body Hower Blau", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/body/body_hower"}
--
BodySkins["avp_body25"] = {name = "Body Hunter", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/body/body_hunter"}
BodySkins["avp_body26"] = {name = "Body Hunter Gold", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/body/body_hunter"}
BodySkins["avp_body27"] = {name = "Body Hunter Schatten", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/body/body_hunter"}
BodySkins["avp_body28"] = {name = "Body Hunter Blau", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/body/body_hunter"}
--
BodySkins["avp_body29"] = {name = "Body Original", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/body/body_original"}
BodySkins["avp_body30"] = {name = "Body Original Gold", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/body/body_original"}
BodySkins["avp_body31"] = {name = "Body Original Schatten", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/body/body_original"}
BodySkins["avp_body32"] = {name = "Body Original Blau", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/body/body_original"}
--
BodySkins["avp_body33"] = {name = "Body Stripes", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/body/body_stripes"}
BodySkins["avp_body34"] = {name = "Body Stripes Gold", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/body/body_stripes"}
BodySkins["avp_body35"] = {name = "Body Stripes Schatten", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/body/body_stripes"}
BodySkins["avp_body36"] = {name = "Body Stripes Blau", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/body/body_stripes"}
--
BodySkins["avp_body37"] = {name = "Body Sunrise", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/body/body_sunrise"}
BodySkins["avp_body38"] = {name = "Body Sunrise Gold", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/body/body_sunrise"}
BodySkins["avp_body39"] = {name = "Body Sunrise Schatten", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/body/body_sunrise"}
BodySkins["avp_body40"] = {name = "Body Sunrise Blau", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/body/body_sunrise"}
--
BodySkins["avp_body41"] = {name = "Body Sutekh", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/standard/body/body_sutekh"}
BodySkins["avp_body42"] = {name = "Body Sutekh Gold", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/gold/body/body_sutekh"}
BodySkins["avp_body43"] = {name = "Body Sutekh Schatten", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/schatten/body/body_sutekh"}
BodySkins["avp_body44"] = {name = "Body Sutekh Blau", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/piloten/blau/body/body_sutekh"}

BodySkins["avp_body_christmas24"] = {name = "Body Christmas", desc = "", price = 20000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl","models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl","models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl","models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/special/christmas2024/clone/body"}


// AVP BODY ENDE! //

// 212TH LEGION //
-------------------
// GHOST COMPANY BODY //

BodySkins["ghc_body_1"] = {name = "Krper Dreieck 1", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body1"}
BodySkins["ghc_body_2"] = {name = "Krper Grtel", desc = "", price = 50000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body2"}
BodySkins["ghc_body_3"] = {name = "Krper Patriot", desc = "", price = 60000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body3"}
BodySkins["ghc_body_4"] = {name = "Krper Dreieck 2", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body4"}
BodySkins["ghc_body_5"] = {name = "Krper Brust", desc = "", price = 45000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body5"}
BodySkins["ghc_body_geonosis_1"] = {name = "Krper Geonosis", desc = "Ich hasse Sand.", price = 70000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body7"}
BodySkins["ghc_body_geonosis_2"] = {name = "Krper Geo-Sandig", desc = "Ich hasse Sand.", price = 80000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body8"}
BodySkins["ghc_christmas_body"] = {name = "Weihnachtsskin", desc = "Nur via Geschenk erhltlich.", price = -1, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_christmas", cantBuy = true}
BodySkins["ghc_veteran_body"] = {name = "GHC Veteran", desc = "", price = 50000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body6"}
BodySkins["hc_veteran_body"] = {name = "HC Veteran", desc = "", price = 50000, model = {"models/starwars/grady/212th/heavys/212th_heavy.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/heavys/body/body1"}
BodySkins["ghc_order66_body"] = {name = "Body Order", desc = "Limitiert erhltlich bis: 14.04.2022", price = -1, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_order66", cantBuy = true}
BodySkins["212_foxtrot_body"] = {name = "Krper Foxtrot", desc = "Foxtrot!", price = 30000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_foxtrot"}
BodySkins["212_ph1_body"] = {name = "Krper Classic", desc = "Die guten alten Zeiten...", price = 50000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_phase1"}
BodySkins["212_triton_body"] = {name = "Krper Triton", desc = "Triton.", price = 30000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_triton"}
BodySkins["212_umbra_body"] = {name = "Krper Umbra", desc = "Umbra.", price = 80000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_umbra"}
BodySkins["212_bodyrallye"] = {name = "Krper Rallye", desc = "Umbra.", price = 70000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_rallye"}
BodySkins["212_bodyyoda"] = {name = "Krper Yoda", desc = "", price = 90000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_yoda"}
BodySkins["212_baymaxbody"] = {name = "Krper Baymax", desc = "", price = 65000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_baymax"}
BodySkins["212_destinybody"] = {name = "Krper Destiny", desc = "", price = 70000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_destiny"}
BodySkins["212_heavybody"] = {name = "Krper Heavy", desc = "OG Zeiten", price = 65000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_heavy"}
BodySkins["212_bodypointy"] = {name = "Krper Pointy", desc = "", price = 50000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_pointy"}
BodySkins["gc_body_relikt"] = {name = "Krper Relikt", desc = "", price = 50000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_old_republic"}
BodySkins["gc_body_moon"] = {name = "Krper Moon", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_moon"}
BodySkins["gc_body_origins"] = {name = "Krper Origins", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_origins"}
BodySkins["gc_body_tfu_cmd"] = {name = "Krper TFU Commander", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_tfu_commander"}
BodySkins["gc_body_wildcat"] = {name = "Krper Wildcat", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_wildcat"}
BodySkins["gc_arf_body_wildcat"] = {name = "Krper Wildcat", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/arf/body/body_wildcat"}
BodySkins["gc_body_2099"] = {name = "Krper 2099", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_2099", vipOnly = true }
BodySkins["gc_body_rook"] = {name = "Krper Rook", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_rook"}
BodySkins["gc_arf_body_halft"] = {name = "Krper Half", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/arf/body/body_half"}
BodySkins["gc_arf_body_ezra"] = {name = "Krper ezra", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/arf/body/body_ezra"}
BodySkins["gc_arf_body_smack"] = {name = "Krper smack", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/arf/body/body_smack"}
BodySkins["gc_body_awen"] = {name = "Krper awen", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_awen"}
BodySkins["gc_arf_body_black"] = {name = "Krper camo black", desc = "", price = 1000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/arf/body/body_camo_black"}
BodySkins["gc_arf_body_felucia"] = {name = "Krper camo felucia", desc = "", price = 1000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/arf/body/body_camo_felucia"}
BodySkins["gc_arf_body_geonosis"] = {name = "Krper camo geonosis", desc = "", price = 1000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/arf/body/body_camo_geonosis"}
BodySkins["gc_arf_body_kashyyyk"] = {name = "Krper camo kashyyyk", desc = "", price = 1000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/arf/body/body_camo_kashyyyk"}
BodySkins["gc_arf_body_mimban"] = {name = "Krper camo mimban", desc = "", price = 1000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/arf/body/body_camo_mimban"}
BodySkins["gc_christmas24_body"] = {name = "Krper Christmas", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/special/christmas2024/clone/body"}




// !! GHOST COMPANY BODY ENDE !! //

-------------------
-- NEUE EINHEIT! --
-------------------

// ENGINEERING COMPANY BODY //
BodySkins["ec_body_1"] = {name = "Rcken", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ec/body/body1"}
BodySkins["ec_body_2"] = {name = "Unklar", desc = "", price = 30000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ec/body/body2"}
BodySkins["ec_body_4"] = {name = "38th", desc = "", price = 50000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ec/body/body4"}
BodySkins["ec_veteran_body"] = {name = "Veteran", desc = "", price = 50000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ec/body/body3"}
BodySkins["ec_original_body"] = { name = "Original", desc = "", price = 50000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ec/body/body5" }
BodySkins["ec_invertiert_body"] = { name = "Invertiert", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ec/body/body6" }
BodySkins["ec_raptor_body"] = { name = "Raptor", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ec/body/body_raptor" }
BodySkins["ec_operator_body"] = { name = "Operator", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ec/body/body_operator" }
BodySkins["ec_upgrade_body"] = { name = "upgrade", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ec/body/body_upgrade" }
BodySkins["ec_raute_body"] = { name = "raute", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ec/body/body_raute" }
BodySkins["ec_raute_inverted_body"] = { name = "raute", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ec/body/body_raute_inverted" }
BodySkins["ec_203rd_body"] = { name = "203rd", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ec/body/body_203rd" }
BodySkins["ft_body_flame"] = { name = "Flame", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/ec/212th_flametrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ft/body/body_flame" }
BodySkins["ec_body_fixer"] = { name = "Body Fixer", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ec/body/body_fixer" }
BodySkins["ec_body_metal"] = { name = "Body Metal", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ec/body/body_metal" }
BodySkins["ec_body_christmas24"] = { name = "Body Christmas", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/special/christmas2024/clone/body" }


// !! ENGINEERING COMPANY BODY ENDE !! //

-------------------
-- NEUE EINHEIT! --
-------------------

// 2nd AIRBORNE COMPANY BODY //
BodySkins["ac_body_1"] = { name = "Krper T", desc = "", price = 45000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/airborne/body/body1_airborne", [2] = "starwars/grady/itemshop/212th/airborne/body/body1"} }
BodySkins["ac_body_2"] = { name = "Krper Fatline", desc = "", price = 45000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/airborne/body/body2_airborne", [2] = "starwars/grady/itemshop/212th/airborne/body/body2"} }
BodySkins["ac_body_3"] = { name = "Krper Y", desc = "", price = 45000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/airborne/body/body3_airborne", [2] = "starwars/grady/itemshop/212th/airborne/body/body3"} }
BodySkins["ac_body_4"] = { name = "Krper Brust", desc = "", price = 45000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/airborne/body/body4_airborne", [2] = "starwars/grady/itemshop/212th/airborne/body/body4"} }
BodySkins["ac_body_5"] = { name = "Krper Arrow", desc = "", price = 45000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/airborne/body/body5_airborne", [2] = "starwars/grady/itemshop/212th/airborne/body/body5"} }
BodySkins["ac_body_trio"] = { name = "Krper Trio", desc = "", price = 45000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/airborne/body/body_trio_airborne", [2] = "starwars/grady/itemshop/212th/airborne/body/body_trio"} }
BodySkins["ac_body_curves"] = { name = "Krper Curves", desc = "", price = 45000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/airborne/body/body_curves_airborne", [2] = "starwars/grady/itemshop/212th/airborne/body/body_curves"} }
BodySkins["ac_body_triangle"] = { name = "Krper Triangle", desc = "", price = 45000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/airborne/body/body_triangle_airborne", [2] = "starwars/grady/itemshop/212th/airborne/body/body_triangle"} }
BodySkins["ac_body_yirt"] = { name = "Krper Yirt", desc = "", price = 45000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/airborne/body/body_yirt_airborne", [2] = "starwars/grady/itemshop/212th/airborne/body/body_yirt"} }
BodySkins["ac_body_stripes"] = { name = "Krper Stripes", desc = "", price = 45000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/airborne/body/body_stripes_airborne", [2] = "starwars/grady/itemshop/212th/airborne/body/body_stripes"} }
BodySkins["ac_body_Order"] = { name = "Krper Order", desc = "", price = 45000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/airborne/body/body_order66_airborne", [2] = "starwars/grady/itemshop/212th/airborne/body/body_order66"}, cantBuy = true}
BodySkins["ac_body_recon"] = { name = "Krper Recon", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/airborne/body/body_recon", [2] = "starwars/grady/itemshop/212th/airborne/body/body_recon"} }
BodySkins["ac_body_christmas24"] = { name = "Krper Christmas", desc = "", price = 20000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl", "models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/sonstiges/special/christmas2024/clone/body", [2] = "starwars/grady/itemshop/sonstiges/special/christmas2024/clone/body"} }


// 2nd AIRBORNE COMPANY BODY ENDE !! //


-------------------
-- NEUE LEGION! --
-------------------


-------------------
// 501st LEGION //
-------------------
// TORRENT COMPANY MAIN BODY //
BodySkins["tc_body_2"] = { name = "Krper Arrow", desc = "Einige Pfeile", price = 60000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body2" }
BodySkins["tc_body_3"] = { name = "Krper Asym", desc = "Blauer Strich auf weien Grund", price = 50000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body3" }
BodySkins["tc_body_4"] = { name = "Krper Sturmgrau", desc = "Strmischer Kmpfer", price = 70000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body4" }
BodySkins["tc_body_5"] = { name = "Krper Zorn", desc = "Zorn der Torrent Company", price = 50000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body5" }
BodySkins["tc_body_6"] = { name = "Krper Malerei", desc = "Sieht aus wie Hhlenmalerei", price = 80000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body6" }
BodySkins["tc_body_7"] = { name = "Krper Poseidon", desc = "Mit der Macht vqon Poseidon", price = 70000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body7" }
BodySkins["tc_body_8"] = { name = "Krper I", desc = "Illuminati confirmed", price = 60000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body8" }
BodySkins["tc_christmas_body"] = {name = "Weihnachtsskin", desc = "Nur via Geschenk erhltlich.", price = -1, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_christmas", cantBuy = true}
BodySkins["tc_veteran_body"] = {name = "Veteran", desc = "Teil des Veteran-Packs", price = 50000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body1"}
BodySkins["tc_order_body"] = {name = "Body Order", desc = "Limitiert erhltlich bis: 14.04.2022", price = -1, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_order66", cantBuy = true}
BodySkins["501st_tano_body"] = {name = "Krper Tano", desc = "Commander Tano ist stolz.", price = 50000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_332nd"}
BodySkins["501st_ph1_body"] = {name = "Krper Classic", desc = "Die guten alten Zeiten...", price = 50000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_phase1"}
BodySkins["501st_triton_body"] = {name = "Krper Triton", desc = "Triton.", price = 30000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_triton"}
BodySkins["501st_umbra_body"] = {name = "Krper Umbra", desc = "Umbra.", price = 80000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_umbra"}
BodySkins["501st_elite_body"] = { name = "Krper Elite", desc = "Fr die Elite.", price = 80000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_elite" }
BodySkins["501st_bodyrallye"] = { name = "Krper Rallye", desc = "Umbra.", price = 70000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_rallye" }
BodySkins["501st_bodyyoda"] = { name = "Krper Yoda", desc = "", price = 90000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_yoda" }
BodySkins["501st_baymaxbody"] = { name = "Krper Baymax", desc = "", price = 65000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_baymax" }
BodySkins["501st_destinybody"] = { name = "Krper Destiny", desc = "", price = 70000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_destiny" }
BodySkins["501st_pointybody"] = { name = "Krper Pointy", desc = "", price = 50000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_pointy" }
BodySkins["tc_body_relikt"] = { name = "Krper Relikt", desc = "", price = 50000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_old_republic" }
BodySkins["tc_body_moon"] = { name = "Krper Moon", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_moon" }
BodySkins["tc_body_origins"] = { name = "Krper Origins", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_origins" }
BodySkins["tc_body_tfu_commander"] = { name = "Krper TFU Commander", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_tfu_commander" }
BodySkins["tc_body_2099"] = { name = "Krper 2099", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_2099", vipOnly = true }
BodySkins["tc_body_rook"] = { name = "Krper Rook", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_rook" }
BodySkins["tc_body_awen"] = { name = "Krper awen", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_awen" }
BodySkins["dp_body_forheavy"] = { name = "Krper forheavy", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/dp/body/body_for-hevy" }
BodySkins["dp_body_nexos"] = { name = "Krper nexos", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/dp/body/body_nexos" }
BodySkins["tc_body_christmas24"] = { name = "Krper Christmas", desc = "", price = 20000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/special/christmas2024/clone/body" }


// TORRENT COMPANY BODY MAIN ENDE! //

-------------------
-- NEUE EINHEIT! --
-------------------

// TORRENT COMPANY JAIG BODY //
BodySkins["JP_Body_1"] = {name = "Krper Jaig Arrows", desc = "Der Pfeil geht nach oben wie Lauch Fabian", price = 60000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/jaig/body/body_arrow"}
BodySkins["JP_Body_2"] = {name = "Krper Lowkey", desc = "Der ist Lowkey geil", price = 60000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/jaig/body/body_lowkey"}
BodySkins["JP_Body_3"] = {name = "Krper Wirbel", desc = "Wirbel wie beim Stress mit der ST", price = 60000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/jaig/body/body_wirbel"}
BodySkins["JP_Body_4"] = {name = "Krper Crescent", desc = "Der Halbmond ist schn", price = 60000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/jaig/body/body_crescent"}
BodySkins["JP_Body_Umbra"] = {name = "Krper Umbra", desc = "Wer das liest muss Grady schreiben das er bld ist", price = 40000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/jaig/body/body_umbra"}
BodySkins["JP_Body_Rallye"] = {name = "Krper Rallye", desc = "Wer das liest muss Grady schreiben das er bld ist", price = 40000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/jaig/body/body_rallye"}
BodySkins["JP_Body_Dagger"] = {name = "Krper Dagger", desc = "Wer das liest muss Grady schreiben das er bld ist", price = 40000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/jaig/body/body_dagger"}
BodySkins["JP_Body_332nd"] = {name = "Krper Tano", desc = "Wer das liest muss Grady schreiben das er bld ist", price = 40000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/jaig/body/body_332nd"}
BodySkins["JP_Body_Cabo"] = {name = "Krper Cabo", desc = "Wer das liest muss Grady schreiben das er bld ist", price = 35000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/jaig/body/body_cabo"}
BodySkins["JP_Body_tfu_commander"] = {name = "Krper TFU Commander", desc = "Wer das liest muss Grady schreiben das er bld ist", price = 35000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/jaig/body/body_tfu_commander"}
BodySkins["JP_Body_rook"] = {name = "Krper Rook", desc = "Wer das liest muss Grady schreiben das er bld ist", price = 35000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/jaig/body/body_rook"}
BodySkins["JP_Body_asssassine"] = {name = "Krper Assassine", desc = "Wer das liest muss Grady schreiben das er bld ist", price = 35000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/jaig/body/body_assassine"}
BodySkins["JP_Body_2099"] = {name = "Krper 2099", desc = "Wer das liest muss Grady schreiben das er bld ist", price = 35000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/jaig/body/body_2099"}
BodySkins["JP_Body_bad_batch"] = {name = "Krper Bad Batch", desc = "Wer das liest muss Grady schreiben das er bld ist", price = 35000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/jaig/body/body_bad-batch"}
BodySkins["JP_Body_awen"] = {name = "Krper Awen", desc = "Wer das liest muss Grady schreiben das er bld ist", price = 35000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/jaig/body/body_awen"}
BodySkins["JP_Body_christmas24"] = {name = "Krper Christmas", desc = "Wer das liest muss Grady schreiben das er bld ist", price = 20000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/special/christmas2024/clone/body"}

// TORRENT COMPANY JAIG BODY ENDE ! //

-------------------
-- NEUE EINHEIT! --
-------------------

// MEDICAL PLATOON BODY //
BodySkins["jumptrooper_Bodyjet"] = {name = "Krper Jet", desc = "", price = 60000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics-jumptrooper/body/body_jet"}
BodySkins["mp_body_1"] = {name = "Krper Bluechest", desc = "", price = 50000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics/body/body1"}
BodySkins["mp_body_2"] = {name = "Krper Bizeps", desc = "", price = 30000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics/body/body2"}
BodySkins["mp_body_3"] = {name = "Krper Armstreifen", desc = "", price = 30000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics/body/body3"}
BodySkins["mp_body_4"] = {name = "Krper Bluesocks", desc = "", price = 30000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics/body/body4"}
BodySkins["mp_body_5"] = {name = "Krper Kraftpaket", desc = "", price = 60000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics/body/body5"}
BodySkins["mp_body_6"] = {name = "Krper Patriot", desc = "", price = 30000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics/body/body6"}
BodySkins["mp_body_7"] = {name = "Krper Lauch", desc = "", price = 45000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics/body/body7"}
BodySkins["mp_body_8"] = {name = "Krper Grey", desc = "", price = 70000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics/body/body8"}
BodySkins["mp_body_9"] = {name = "Krper Spuren", desc = "", price = 50000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics/body/body9"}
BodySkins["mp_body_10"] = {name = "Krper Attention", desc = "", price = 50000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics/body/body10"}
BodySkins["mp_body_10"] = {name = "Krper Attention", desc = "", price = 50000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics/body/body10"}
BodySkins["mp_body_sigil"] = {name = "Krper Sigil", desc = "", price = 50000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics/body/body_Sigil"}
BodySkins["mp_body_skull"] = {name = "Krper Skull", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics/body/body_skull"}
BodySkins["mp_body_vest"] = {name = "Krper Vest", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics/body/body_vest"}
BodySkins["mp_body_front"] = {name = "Krper Front", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics/body/body_frontkaempfer"}
BodySkins["mp_body_divine-wings"] = {name = "Krper Divine-Wings", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics/body/body_divine-wings"}
BodySkins["mp_body_dok"] = {name = "Krper Dok", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics/body/body_dok"}
BodySkins["mp_body_orion"] = {name = "Krper Orion", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics/body/body_orion"}
BodySkins["mp_body_minos"] = {name = "Krper Minos", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics/body/body_minos"}
BodySkins["mp_body_stratos"] = {name = "Krper Stratos", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/medics/body/body_stratos"}
BodySkins["mp_body_christmas24"] = {name = "Krper Christmas", desc = "", price = 20000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl","models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/special/christmas2024/clone/body"}


// MEDICAL PLATOON BODY ENDE! //


-------------------
-- NEUE LEGION! --
-------------------


// SCHOCKTRUPPEN BODY //
BodySkins["ST_ph1_body"] = { name = "Krper Classic", desc = "Die guten alten Zeiten...", price = 50000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_phase1"}
BodySkins["ST_triton_body"] = { name = "Krper Triton", desc = "Triton.", price = 30000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_triton"}
BodySkins["ST_umbra_body"] = { name = "Krper Umbra", desc = "Umbra.", price = 80000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_umbra"}
BodySkins["ST_imp_body"] = { name = "Krper Imp", desc = "Irgendwie kommt mir das bekannt vor..", price = 20000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_imperial"}
BodySkins["ST_senat_body"] = { name = "Krper Senat", desc = "I am the Senate.", price = 30000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_coruscant_guard"}
BodySkins["ST_bodyrallye"] = { name = "Krper Rallye", desc = "Umbra.", price = 70000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_rallye"}
BodySkins["ST_bodyyoda"] = { name = "Krper Yoda", desc = "", price = 90000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_yoda"}
BodySkins["ST_baymaxbody"] = { name = "Krper Baymex", desc = "", price = 65000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_baymax"}
BodySkins["ST_destinybody"] = { name = "Krper Destiny", desc = "", price = 70000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_destiny"}
BodySkins["ST_pointy"] = { name = "Krper Pointy", desc = "", price = 50000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_pointy"}
BodySkins["st_body_aurek"] = { name = "Krper Strich", desc = "", price = 50000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body3"}
BodySkins["st_body_besh"] = { name = "Krper Politic", desc = "", price = 50000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body2"}
BodySkins["st_body_cresh"] = { name = "Krper Glnzer", desc = "", price = 20000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body1"}
BodySkins["st_body_relikt"] = { name = "Krper Relikt", desc = "", price = 50000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_old_republic"}
BodySkins["st_body_moon"] = { name = "Krper Moon", desc = "", price = 50000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_moon"}
BodySkins["st_body_origins"] = { name = "Krper Origins", desc = "", price = 50000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_origins"}
BodySkins["st_body_tfu_commander"] = { name = "Krper TFU Commander", desc = "", price = 50000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_tfu_commander"}
BodySkins["st_body_2099"] = { name = "Krper 2099", desc = "", price = 40000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_2099", vipOnly = true }
BodySkins["st_body_rook"] = { name = "Krper Rook", desc = "", price = 40000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_rook"}
BodySkins["st_body_awen"] = { name = "Krper Awen", desc = "", price = 40000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_awen"}
BodySkins["st_body_christmas24"] = { name = "Krper Christmas", desc = "", price = 20000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/special/christmas2024/clone/body"}



// SCHOCKTRUPPEN BODY ENDE! //


---- ARC SKINS GESONDERT WEIL SO VIEL HUSOBULLSHITZEUG ----

// TORRENT COMPANY ARC ARMA //
HeadSkins["501_arc_arma_helm"] = {name = "Helm Arma", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/arma/arc_helmet"}
BodySkins["501_arc_arma_body"] = {name = "Body Arma", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 1, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/arma/ct_body"}
BodySkins["501_arc_arma_gear"] = {name = "Gear Arma", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 12, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/arma/arc_gear"}
BodySkins["501_arc_arma_kama"] = {name = "Kama Arma", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 13, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/arma/arc_kama"}

// TORRENT COMPANY ARC UMBRA //
HeadSkins["501_arc_umbra_helm"] = {name = "Helm umbra", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/umbra/arc_helmet"}
BodySkins["501_arc_umbra_body"] = {name = "Body umbra", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 1, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/umbra/ct_body"}
BodySkins["501_arc_umbra_gear"] = {name = "Gear umbra", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 12, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/umbra/arc_gear"}
BodySkins["501_arc_umbra_kama"] = {name = "Kama umbra", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 13, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/umbra/arc_kama"}

// TORRENT COMPANY ARC SLICK (NICHT FR SLICK HEISST EINFACH SO KP) //
HeadSkins["501_arc_slick_helm"] = {name = "Helm slick", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/slick/arc_helmet"}
BodySkins["501_arc_slick_body"] = {name = "Body slick", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 1, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/slick/ct_body"}
BodySkins["501_arc_slick_gear"] = {name = "Gear slick", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 12, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/slick/arc_gear"}
BodySkins["501_arc_slick_kama"] = {name = "Kama slick", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 13, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/slick/arc_kama"}

// TORRENT COMPANY ARC KNIGLICH //
HeadSkins["501_arc_kniglicher_helm"] = {name = "Helm Kniglich", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/koeniglich/arc_helmet"}
BodySkins["501_arc_kniglicher_Body"] = {name = "Body Kniglich", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 1, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/koeniglich/ct_body"}
BodySkins["501_arc_kniglicher_Gear"] = {name = "Gear Kniglich", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 12, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/koeniglich/arc_gear"}
BodySkins["501_arc_kniglicher_Kama"] = {name = "Kama Kniglich", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 13, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/koeniglich/arc_kama"}
BodySkins["501_arc_kniglicher_Jetpack"] = {name = "Jetpack fick dich Kniglich", desc = "", price = 50000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 11, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/koeniglich/ct_jetpack"}

// TORRENT COMPANY ARC KNIGLICH ENDE! //

// TORRENT COMPANY ARC redemption //
HeadSkins["501_arc_redemption_helm"] = {name = "Helm redemption", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/redemption/arc_helmet"}
BodySkins["501_arc_redemption_Body"] = {name = "Body redemption", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 1, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/redemption/ct_body"}
BodySkins["501_arc_redemption_Gear"] = {name = "Gear redemption", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 12, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/redemption/arc_gear"}
BodySkins["501_arc_redemption_Kama"] = {name = "Kama redemption", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 13, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/redemption/arc_kama"}
BodySkins["501_arc_redemption_Jetpack"] = {name = "Jetpack fick dich redemption", desc = "", price = 50000, model = {"models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 11, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/tc/redemption/ct_jetpack"}

// TORRENT COMPANY ARC redemption ENDE! //

// MEDICAL PLATOON ARC PEAK //
HeadSkins["501_arc_mp_peak_helm"] = {name = "Helm Peak", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/501st_arc_medic.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/medic/peak/arc_helmet"}
BodySkins["501_arc_mp_peak_Body"] = {name = "Body Peak", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/501st_arc_medic.mdl"}, id = 1, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/medic/peak/ct_body"}
BodySkins["501_arc_mp_peak_Gear"] = {name = "Gear Peak", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/501st_arc_medic.mdl"}, id = 12, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/medic/peak/arc_gear"}
BodySkins["501_arc_mp_peak_Kama"] = {name = "Kama Peak", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/501st_arc_medic.mdl"}, id = 13, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/medic/peak/arc_kama"}
BodySkins["501_arc_mp_peak_Jetpack"] = {name = "Jetpack Peak", desc = "", price = 50000, model = {"models/starwars/grady/arc/aoc/501st_arc_medic.mdl"}, id = 11, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/medic/peak/ct_jetpack"}

// MEDICAL PLATOON ARC PEAK ENDE! //

// MEDICAL PLATOON ARC redemption //
HeadSkins["501_arc_mp_redemption_helm"] = {name = "Helm redemption", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/501st_arc_medic.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/medic/redemption/arc_helmet"}
BodySkins["501_arc_mp_redemption_Body"] = {name = "Body redemption", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/501st_arc_medic.mdl"}, id = 1, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/medic/redemption/ct_body"}
BodySkins["501_arc_mp_redemption_Gear"] = {name = "Gear redemption", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/501st_arc_medic.mdl"}, id = 12, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/medic/redemption/arc_gear"}
BodySkins["501_arc_mp_redemption_Kama"] = {name = "Kama redemption", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/501st_arc_medic.mdl"}, id = 13, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/medic/redemption/arc_kama"}
BodySkins["501_arc_mp_redemption_Jetpack"] = {name = "Jetpack redemption", desc = "", price = 50000, model = {"models/starwars/grady/arc/aoc/501st_arc_medic.mdl"}, id = 11, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/medic/redemption/ct_jetpack"}

// MEDICAL PLATOON ARC PEAK ENDE! //

// TORRENT COMPANY ARC FRAKTAL //
HeadSkins["501_arc_fraktal_Helm"] = {name = "Helm fraktal", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/501st_arc_jaig.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/jaig/fraktal/barc_helmet"}
BodySkins["501_arc_fraktal_body"] = {name = "Body fraktal", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/501st_arc_jaig.mdl"}, id = 1, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/jaig/fraktal/ct_body"}
BodySkins["501_arc_fraktal_gear"] = {name = "Gear fraktal", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/501st_arc_jaig.mdl"}, id = 12, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/jaig/fraktal/arc_gear"}
BodySkins["501_arc_fraktal_Kama"] = {name = "Kama fraktal", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/501st_arc_jaig.mdl"}, id = 13, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/jaig/fraktal/arc_kama"}
BodySkins["501_arc_fraktal_jetpack"] = {name = "Jetpack fraktal", desc = "", price = 50000, model = {"models/starwars/grady/arc/aoc/501st_arc_jaig.mdl"}, id = 11, mat = "starwars/grady/itemshop/sonstiges/arcs/501st/jaig/fraktal/ct_jetpack"}

// TORRENT COMPANY ARC FRAKTAL ENDE!//


------------------------------------

// GHOST COMPANY ARC BRANCOS //
HeadSkins["212th_arc_brancos_Helmet"] = {name = "Helm Arma", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/broncas/arc_helmet"}
BodySkins["212th_arc_brancos_Body"] = {name = "Body Brancos", desc = "", price = 50000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl"}, id = 1, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/broncas/ct_body"}
BodySkins["212_arc_Broncas_Gear"] = {name = "Gear Brancos", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl"}, id = 12, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/broncas/arc_gear"}
BodySkins["212_arc_broncas_Kama"] = {name = "Kama Brancos", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl", "models/starwars/grady/arc/aoc/212th_arc_airborne.mdl"}, id = 13, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/broncas/arc_kama"}

// GHOST COMPANY ARC BRANCOS //
HeadSkins["212th_arc_redemption_Helmet"] = {name = "Helm redemption", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl", "models/starwars/grady/arc/aoc/212th_arc_nexu.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/redemption/arc_helmet"}
BodySkins["212th_arc_redemption_Body"] = {name = "Body redemption", desc = "", price = 50000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl", "models/starwars/grady/arc/aoc/212th_arc_nexu.mdl"}, id = 1, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/redemption/ct_body"}
BodySkins["212_arc_redemption_Gear"] = {name = "Gear redemption", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl", "models/starwars/grady/arc/aoc/212th_arc_nexu.mdl"}, id = 12, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/redemption/arc_gear"}
BodySkins["212_arc_redemption_Kama"] = {name = "Kama redemption", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl", "models/starwars/grady/arc/aoc/212th_arc_nexu.mdl"}, id = 13, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/redemption/arc_kama"}
BodySkins["212_arc_redemption_jetpack"] = {name = "Jetpack fickdichredemption", desc = "", price = 50000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl", "models/starwars/grady/arc/aoc/212th_arc_nexu.mdl"}, id = 11, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/redemption/ct_jetpack"}


// GHOST COMPANY ARC UMBRA //
HeadSkins["212th_arc_umbra_Helmet"] = {name = "Helm Umbra", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/umbra/arc_helmet"}
BodySkins["212th_arc_umbra_Body"] = {name = "Body Umbra", desc = "", price = 50000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl"}, id = 1, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/umbra/ct_body"}
BodySkins["212_arc_umbra_Gear"] = {name = "Gear Umbra", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl"}, id = 12, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/umbra/arc_gear"}
BodySkins["212_arc_umbra_Kama"] = {name = "Kama Umbra", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl"}, id = 13, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/umbra/arc_kama"}

// GHOST COMPANY ARC TALLY //
HeadSkins["212th_arc_tally_Helmet"] = {name = "Helm Tally", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/tally/arc_helmet"}
BodySkins["212th_arc_tally_Body"] = {name = "Body Tally", desc = "", price = 50000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl"}, id = 1, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/tally/ct_body"}
BodySkins["212_arc_tally_Gear"] = {name = "Gear Tally", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl", "models/starwars/grady/arc/aoc/212th_arc_nexu.mdl"}, id = 12, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/tally/arc_gear"}
BodySkins["212_arc_tally_Kama"] = {name = "Kama Tally", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl"}, id = 13, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/tally/arc_kama"}
BodySkins["212_arc_tally_jetpack"] = {name = "Jetpack fickdich", desc = "", price = 50000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl"}, id = 11, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/tally/ct_jetpack"}

// GHOST COMPANY ARC VECTOR //
HeadSkins["212th_arc_Vector_Helmet"] = {name = "Helm Vector", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/Vector/arc_helmet"}
BodySkins["212th_arc_Vector_Body"] = {name = "Body Vector", desc = "", price = 50000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl"}, id = 1, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/Vector/ct_body"}
BodySkins["212_arc_Vector_Gear"] = {name = "Gear Vector", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl"}, id = 12, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/Vector/arc_gear"}
BodySkins["212_arc_Vector_Kama"] = {name = "Kama Vector", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl"}, id = 13, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/Vector/arc_kama"}
BodySkins["212_arc_Vector_jetpack"] = {name = "Jetpack Vector", desc = "", price = 50000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl"}, id = 11, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/ghc/Vector/ct_jetpack"}

// AIRBORNE COMPANY ARC DISRUPTION //
HeadSkins["212th_airborne_disruption_helmet"] = {name = "Helm Disruption", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/212th_arc_airborne.mdl"}, id = 4, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/airborne/disruption/arc_helmet"}
BodySkins["212th_airborne_disruption_body"] = { name = "Krper Disruption", desc = "", price = 45000, model = {"models/starwars/grady/arc/aoc/212th_arc_airborne.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/sonstiges/arcs/212th/airborne/disruption/ct_body2", [1] = "starwars/grady/itemshop/sonstiges/arcs/212th/airborne/disruption/ct_body"} }
BodySkins["212th_airborne_disruption_gear"] = {name = "Gear Disruption", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/212th_arc_airborne.mdl"}, id = 12, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/airborne/disruption/arc_gear"}
BodySkins["212th_airborne_disruption_kama"] = {name = "Kama Disruption", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/212th_arc_airborne.mdl"}, id = 13, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/airborne/disruption/arc_kama"}
BodySkins["212_airborne_disruption_jetpack"] = {name = "Jetpack fickdich", desc = "", price = 50000, model = {"models/starwars/grady/arc/aoc/212th_arc_airborne.mdl"}, id = 11, mat = "starwars/grady/itemshop/sonstiges/arcs/212th/airborne/disruption/ct_jetpack"}

----------------

// ARC RANGEFINDER //
HeadSkins["arc_rangefinder_white"] = {name = "Rangefinder Wei", desc = "", price = 5000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl", "models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_jaig.mdl"}, id = 8, mat = "starwars/grady/itemshop/sonstiges/arcs/attachments-neutral/rangefinder/rangefinder_white"}
HeadSkins["arc_rangefinder_black"] = {name = "Rangefinder Schwarz", desc = "", price = 5000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl", "models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_jaig.mdl"}, id = 8, mat = "starwars/grady/itemshop/sonstiges/arcs/attachments-neutral/rangefinder/rangefinder_black"}
HeadSkins["arc_rangefinder_grey"] = {name = "Rangefinder Grau", desc = "", price = 5000, model = {"models/starwars/grady/arc/aoc/212th_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_heavy.mdl", "models/starwars/grady/arc/aoc/501st_arc_trooper.mdl", "models/starwars/grady/arc/aoc/501st_arc_jaig.mdl"}, id = 8, mat = "starwars/grady/itemshop/sonstiges/arcs/attachments-neutral/rangefinder/rangefinder_grey"}
// ARC RANGEFINDER ENDE! //

-------------------------------------------------------------

// GM ARC TWONK //
HeadSkins["lyrahelmet"] = {name = "Helm huren", desc = "", price = 20000, model = {"models/starwars/grady/arc/aoc/gm_arc_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/arcs/navy/marine/lyra/arc_helmet"}
BodySkins["lyrabody"] = {name = "Body sohn", desc = "", price = 50000, model = {"models/starwars/grady/arc/aoc/gm_arc_trooper.mdl"}, id = 1, mat = "starwars/grady/itemshop/sonstiges/arcs/navy/marine/lyra/ct_body"}
BodySkins["lyragear"] = {name = "Gear denkt", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/gm_arc_trooper.mdl"}, id = 12, mat = "starwars/grady/itemshop/sonstiges/arcs/navy/marine/lyra/arc_gear"}
BodySkins["lyrakama"] = {name = "Kama er", desc = "", price = 10000, model = {"models/starwars/grady/arc/aoc/gm_arc_trooper.mdl"}, id = 13, mat = "starwars/grady/itemshop/sonstiges/arcs/navy/marine/lyra/arc_kama"}
BodySkins["lyrajetpack"] = {name = "Jetpack fickdich", desc = "", price = 50000, model = {"models/starwars/grady/arc/aoc/gm_arc_trooper.mdl"}, id = 11, mat = "starwars/grady/itemshop/sonstiges/arcs/navy/marine/lyra/ct_jetpack"}

 -- 


-- Poison Skins


        
    HeadSkins["st_helm_arrow"] = { name = "Helm Arrow", desc = "", price = 40000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_arrow"}
    HeadSkins["st_helm_aurek"] = { name = "Helm Aurek", desc = "", price = 40000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_aurek"}
    HeadSkins["st_helm_blaze"] = { name = "Helm Blaze", desc = "", price = 40000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_blaze"}
    HeadSkins["st_helm_fleet"] = { name = "Helm Fleet", desc = "", price = 40000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_fleet"}
    HeadSkins["st_helm_flotille"] = { name = "Helm Flotille", desc = "", price = 40000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_flotille"}
    HeadSkins["st_helm_keeli"] = { name = "Helm Keeli", desc = "", price = 40000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_keeli"}
    HeadSkins["st_helm_loyalty"] = { name = "Helm Loyalty", desc = "", price = 40000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_loyalty"}
    HeadSkins["st_helm_nord"] = { name = "Helm Nord", desc = "", price = 40000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_nord"}
    HeadSkins["st_helm_sentinel"] = { name = "Helm Sentinel", desc = "", price = 40000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_sentinel"}
    HeadSkins["st_helm_sun"] = { name = "Helm Sun", desc = "", price = 40000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_sun"}




    BodySkins["st_body_arrow"] = { name = "Krper Arrow", desc = "", price = 60000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_arrow"}
    BodySkins["st_body_aurek"] = { name = "Krper Aurek", desc = "", price =  60000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_aurek"}
    BodySkins["st_body_blaze"] = { name = "Krper Blaze", desc = "", price =  60000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_blaze"}
    BodySkins["st_body_fleet"] = { name = "Krper Fleet", desc = "", price =  60000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_fleet"}
    BodySkins["st_body_flotille"] = { name = "Krper Flotille", desc = "", price =  60000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_flotille"}
    BodySkins["st_body_keeli"] = { name = "Krper Keeli", desc = "", price =  60000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_keeli"}
    BodySkins["st_body_loyalty"] = { name = "Krper Loyalty", desc = "", price =  60000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_loyalty"}
    BodySkins["st_body_nord"] = { name = "Krper Nord", desc = "", price =  60000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_nord"}
    BodySkins["st_body_sentinel"] = { name = "Krper Sentinel", desc = "", price =  60000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_sentinel"}
    BodySkins["st_body_sun"] = { name = "Krper Sun", desc = "", price =  60000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/sonstiges/st/body/body_sun"}










    HeadSkins["tc_helm_aurek"] = { name = "Helm Aurek", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_aurek"}
    HeadSkins["tc_helm_blaze"] = { name = "Helm Blaze", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_blaze"}
    HeadSkins["tc_helm_dra"] = { name = "Helm Dra", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_dra"}
    HeadSkins["tc_helm_keeli"] = { name = "Helm Keeli", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_keeli"}
    HeadSkins["tc_helm_nord"] = { name = "Helm Nord", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_nord"}
    HeadSkins["tc_helm_sentinel"] = { name = "Helm Sentinel", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_sentinel"}
    HeadSkins["tc_helm_sun"] = { name = "Helm Sun", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 3, mat = "starwars/grady/itemshop/501st/tc/helmet/helmet_sun"}




    BodySkins["tc_body_aurek"] = { name = "Krper Aurek", desc = "", price =  60000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_aurek"}
    BodySkins["tc_body_blaze"] = { name = "Krper Blaze", desc = "", price =  60000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_blaze"}
    BodySkins["tc_body_dra"] = { name = "Krper Dra", desc = "", price =  60000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_dra"}
    BodySkins["tc_body_keeli"] = { name = "Krper Keeli", desc = "", price =  60000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_keeli"}
    BodySkins["tc_body_nord"] = { name = "Krper Nord", desc = "", price =  60000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_nord"}
    BodySkins["tc_body_sentinel"] = { name = "Krper Sentinel", desc = "", price =  60000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_sentinel"}
    BodySkins["tc_body_sun"] = { name = "Krper Sun", desc = "", price =  60000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/501st/dp/501st_dp_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/tc/body/body_sun"}









    HeadSkins["ghc_helm_aurek"] = { name = "Helm Aurek", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_aurek"}
    HeadSkins["ghc_helm_blaze"] = { name = "Helm Blaze", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_blaze"}
    HeadSkins["ghc_helm_keeli"] = { name = "Helm Keeli", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_keeli"}
    HeadSkins["ghc_helm_nord"] = { name = "Helm Nord", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_nord"}
    HeadSkins["ghc_helm_sentinel"] = { name = "Helm Sentinel", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_sentinel"}
    HeadSkins["ghc_helm_sun"] = { name = "Helm Sun", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 3, mat = "starwars/grady/itemshop/212th/ghc/helmet/helmet_sun"}




    BodySkins["ghc_body_aurek"] = { name = "Krper Aurek", desc = "", price =  60000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_aurek"}
    BodySkins["ghc_body_blaze"] = { name = "Krper Blaze", desc = "", price =  60000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_blaze"}
    BodySkins["ghc_body_keeli"] = { name = "Krper Keeli", desc = "", price =  60000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_keeli"}
    BodySkins["ghc_body_nord"] = { name = "Krper Nord", desc = "", price =  60000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_nord"}
    BodySkins["ghc_body_sentinel"] = { name = "Krper Sentinel", desc = "", price =  60000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_sentinel"}
    BodySkins["ghc_body_sun"] = { name = "Krper Sun", desc = "", price =  60000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/ghc/body/body_sun"}



    HeadSkins["tc_airborne_helm_blaze"] = { name = "Helm Blaze", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/airborne/501st_airborne.mdl"}, id = 4, mat = "starwars/grady/itemshop/501st/501st-airborne/helmet/helmet_blaze"}
    BodySkins["tc_airborne_body_blaze"] = { name = "Krper Blaze", desc = "", price =  60000, model = {"models/starwars/grady/aoc/501st/airborne/501st_airborne.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/501st-airborne/body/body_blaze"}
    HeadSkins["tc_airborne_helm_crawl"] = { name = "Helm Crawl", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/airborne/501st_airborne.mdl"}, id = 4, mat = "starwars/grady/itemshop/501st/501st-airborne/helmet/helmet_crawl"}
    BodySkins["tc_airborne_body_crawl"] = { name = "Krper Crawl", desc = "", price =  60000, model = {"models/starwars/grady/aoc/501st/airborne/501st_airborne.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/501st-airborne/body/body_crawl"}
    HeadSkins["tc_airborne_helm_keeli"] = { name = "Helm Keeli", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/airborne/501st_airborne.mdl"}, id = 4, mat = "starwars/grady/itemshop/501st/501st-airborne/helmet/helmet_keeli"}
    BodySkins["tc_airborne_body_keeli"] = { name = "Krper Keeli", desc = "", price =  60000, model = {"models/starwars/grady/aoc/501st/airborne/501st_airborne.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/501st-airborne/body/body_keeli"}
    HeadSkins["tc_airborne_helm_nord"] = { name = "Helm Nord", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/airborne/501st_airborne.mdl"}, id = 4, mat = "starwars/grady/itemshop/501st/501st-airborne/helmet/helmet_nord"}
    BodySkins["tc_airborne_body_nord"] = { name = "Krper Nord", desc = "", price =  60000, model = {"models/starwars/grady/aoc/501st/airborne/501st_airborne.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/501st-airborne/body/body_nord"}
    HeadSkins["tc_airborne_helm_sentinel"] = { name = "Helm Sentinel", desc = "", price = 40000, model = {"models/starwars/grady/aoc/501st/airborne/501st_airborne.mdl"}, id = 4, mat = "starwars/grady/itemshop/501st/501st-airborne/helmet/helmet_sentinel"}
    BodySkins["tc_airborne_body_sentinel"] = { name = "Krper Sentinel", desc = "", price =  60000, model = {"models/starwars/grady/aoc/501st/airborne/501st_airborne.mdl"}, id = 2, mat = "starwars/grady/itemshop/501st/501st-airborne/body/body_sentinel"}


    HeadSkins["ghc_airborne_helm_blaze"] = { name = "Helm Blaze", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl","models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet_blaze"}
    BodySkins["ghc_airborne_body_blaze"] = { name = "Krper Blaze", desc = "", price =  60000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl","models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/airborne/body/body_blaze"}
    HeadSkins["ghc_airborne_helm_crawl"] = { name = "Helm Crawl", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl","models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet_crawl"}
    BodySkins["ghc_airborne_body_crawl"] = { name = "Krper Crawl", desc = "", price =  60000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl","models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/airborne/body/body_crawl"}
    HeadSkins["ghc_airborne_helm_keeli"] = { name = "Helm Keeli", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl","models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet_keeli"}
    BodySkins["ghc_airborne_body_keeli"] = { name = "Krper Keeli", desc = "", price =  60000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl","models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/airborne/body/body_keeli"}
    HeadSkins["ghc_airborne_helm_nord"] = { name = "Helm Nord", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl","models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet_nord"}
    BodySkins["ghc_airborne_body_nord"] = { name = "Krper Nord", desc = "", price =  60000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl","models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/airborne/body/body_nord"}
    HeadSkins["ghc_airborne_helm_sentinel"] = { name = "Helm Sentinel", desc = "", price = 40000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl","models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 4, mat = "starwars/grady/itemshop/212th/airborne/helmet/helmet_sentinel"}
    BodySkins["ghc_airborne_body_sentinel"] = { name = "Krper Sentinel", desc = "", price =  60000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl","models/starwars/grady/aoc/212th/2nd_airborne/2nd_trooper.mdl"}, id = 2, mat = "starwars/grady/itemshop/212th/airborne/body/body_sentinel"}



BundleSkins = {}
//
// BAD BATCH BUNDLES //
BundleSkins["212th_Airborne_BB"] = { name = "Badbatch Bundle", desc = "Zeige deine Liebe zum Bad Batch", price = 70000, model = {"models/starwars/grady/212th_airborne/212th_airborne2_parjai.mdl", "models/starwars/grady/212th_airborne/212th_airborne2.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/airborne/body/body_bad-batch", [4] = "starwars/grady/itemshop/212th/airborne/helmet/helmet_bad-batch", [2] = "starwars/grady/itemshop/212th/airborne/body/body_bad-batch"} }
BundleSkins["212th_GC_BB"] = { name = "Badbatch Bundle", desc = "Zeige deine Liebe zum Bad Batch", price = 70000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/ghc/helmet/helmet_bad-batch", [2] = "starwars/grady/itemshop/212th/ghc/body/body_bad-batch"} }
BundleSkins["212th_EC_BB"] = { name = "Badbatch Bundle", desc = "Zeige deine Liebe zum Bad Batch", price = 70000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/ec/helmet/helmet_bad-batch", [2] = "starwars/grady/itemshop/212th/ec/body/body_bad-batch"} }
BundleSkins["212th_ARF_BB"] = { name = "Badbatch Bundle", desc = "Zeige deine Liebe zum Bad Batch", price = 70000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/arf/helmet/helmet_bad-batch", [2] = "starwars/grady/itemshop/212th/arf/body/body_bad-batch"} }
BundleSkins["501_TC_BB"] = { name = "Badbatch Bundle", desc = "Zeige deine Liebe zum Bad Batch", price = 70000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/501st/tc/helmet/helmet_bad-batch", [2] = "starwars/grady/itemshop/501st/tc/body/body_bad-batch"} }
BundleSkins["ST_BB"] = { name = "Badbatch Bundle", desc = "Zeige deine Liebe zum Bad Batch", price = 70000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_bad-batch", [2] = "starwars/grady/itemshop/sonstiges/st/body/body_bad-batch"} }
BundleSkins["fivesrotidingi"] = { name = "Rot Bundle", desc = "Zeige deine Liebe zum Bad Batch", price = 90000, model = {"models/starwars/grady/arc/aoc/501st_arc_fives.mdl"}, id = 2, mat = {[1] = "rino/bodyfivesrot", [3] = "rino/helmetfivesrot", [11] = "rino/arckamafivesrot", [10] = "rino/arcgearfivesrot"}  }
BundleSkins["fivesorangeidingi"] = { name = "Orange Bundle", desc = "Zeige deine Liebe zum Bad Batch", price = 90000, model = {"models/starwars/grady/arc/aoc/501st_arc_fives.mdl"}, id = 2, mat = {[1] = "rino/fivesbodyorange", [3] = "rino/fiveshelmorange", [11] = "rino/fiveskamaorange", [10] = "rino/fivesgearorange"}  }

// BAD BATCH BUNDLES ENDE !//

-------------------
-- NEUES BUNDLE! --
-------------------

// PREDATOR BUNDLE //
BundleSkins["TC_Predator"] = { name = "Predator Bundle", desc = "Hunt", price = -1, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/501st/tc/helmet/helmet_predator", [2] = "starwars/grady/itemshop/501st/tc/body/body_predator"}, cantBuy = true }
BundleSkins["TC_Jaig_Predator"] = { name = "Predator Bundle", desc = "Hunt", price = -1, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/501st/jaig/helmet/helmet_predator", [2] = "starwars/grady/itemshop/501st/jaig/body/body_predator"}, cantBuy = true }
BundleSkins["MP_Predator"] = { name = "Predator Bundle", desc = "Hunt", price = -1, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/501st/medics/helmet/helmet_predator", [2] = "starwars/grady/itemshop/501st/medics/body/body_predator"}, cantBuy = true }
BundleSkins["GC_Predator"] = { name = "Predator Bundle", desc = "Hunt", price = -1, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/ghc/helmet/helmet_predator", [2] = "starwars/grady/itemshop/212th/ghc/body/body_predator"}, cantBuy = true }
BundleSkins["GC_Arf_Predator"] = { name = "Predator Bundle", desc = "Hunt", price = -1, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/arf/helmet/helmet_predator", [2] = "starwars/grady/itemshop/212th/arf/body/body_predator"}, cantBuy = true }
BundleSkins["EC_Predator"] = { name = "Predator Bundle", desc = "Hunt", price = -1, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/ec/helmet/helmet_predator", [2] = "starwars/grady/itemshop/212th/ec/body/body_predator"}, cantBuy = true }
BundleSkins["AC_Predator"] = { name = "Predator Bundle", desc = "Hunt", price = -1, model = {"models/starwars/grady/212th_airborne/212th_airborne2.mdl"}, id = 2, mat = {[4] = "starwars/grady/itemshop/212th/airborne/helmet/helmet_predator", [3] = "starwars/grady/itemshop/212th/airborne/body/body_predator", [2] = "starwars/grady/itemshop/212th/airborne/body/body_predator"}, cantBuy = true }
BundleSkins["ST_Predator"] = { name = "Predator Bundle", desc = "Hunt", price = -1, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_predator", [2] = "starwars/grady/itemshop/sonstiges/st/body/body_predator"}, cantBuy = true }
// PREDATOR BUNDLE ENDE ! //

-------------------
-- NEUES BUNDLE! --
-------------------

// HALLOWEEN BUNDLE //
BundleSkins["212th_Halloween_Airborne"] = { name = "Halloween Bundle", desc = "Spooky", price = -1, model = {"models/starwars/grady/212th_airborne/212th_airborne2.mdl"}, id = 2, mat = {[4] = "starwars/grady/itemshop/212th/airborne/helmet/helmet_halloween",[3] = "starwars/grady/itemshop/212th/airborne/body/body_halloween", [2] = "starwars/grady/itemshop/212th/airborne/body/body_halloween"}, cantBuy = true }
BundleSkins["212th_Halloween_arf"] = { name = "Halloween Bundle", desc = "Spooky", price = -1, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/arf/helmet/helmet_halloween", [2] = "starwars/grady/itemshop/212th/arf/body/body_halloween"}, cantBuy = true }
BundleSkins["212th_Halloween_gc"] = { name = "Halloween Bundle", desc = "Spooky", price = -1, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/ghc/helmet/helmet_halloween", [2] = "starwars/grady/itemshop/212th/ghc/body/body_halloween"}, cantBuy = true }
BundleSkins["212th_Halloween_ec"] = { name = "Halloween Bundle", desc = "Spooky", price = -1, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/ec/helmet/helmet_halloween", [2] = "starwars/grady/itemshop/212th/ec/body/body_halloween"}, cantBuy = true }
BundleSkins["501_halloween_heavy"] = { name = "Halloween Bundle", desc = "Spooky", price = -1, model = {"models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/501st/heavy/helmet/helmet_halloween", [2] = "starwars/grady/itemshop/501st/heavy/body/body_halloween"}, cantBuy = true }
BundleSkins["501_halloween_jaig"] = { name = "Halloween Bundle", desc = "Spooky", price = -1, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/501st/jaig/helmet/helmet_halloween", [2] = "starwars/grady/itemshop/501st/jaig/body/body_halloween"}, cantBuy = true }
BundleSkins["501_halloween_medic"] = { name = "Halloween Bundle", desc = "Spooky", price = -1, model = {"models/starwars/grady/501st_medic/501st_medic2.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/501st/medics/helmet/helmet_halloween", [2] = "starwars/grady/itemshop/501st/medics/body/body_halloween"}, cantBuy = true }
BundleSkins["501_halloween_tc"] = { name = "Halloween Bundle", desc = "Spooky", price = -1, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/501st/tc/helmet/helmet_halloween", [2] = "starwars/grady/itemshop/501st/tc/body/body_halloween"}, cantBuy = true }
BundleSkins["halloween_st"] = { name = "Halloween Bundle", desc = "Spooky", price = -1, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_halloween", [2] = "starwars/grady/itemshop/sonstiges/st/body/body_halloween"}, cantBuy = true }

// HALLOWEEN BUNDLE ENDE! //

// HALLOWEEN BUNDLE 2 //
BundleSkins["212th_Halloween23_gc"] = { name = "Halloween 23 Bundle", desc = "Spooky", price = 30000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/ghc/helmet/helmet_halloween_skeleton", [2] = "starwars/grady/itemshop/212th/ghc/body/body_halloween_skeleton"}, cantBuy = false }
BundleSkins["212th_Halloween23_ec"] = { name = "Halloween 23 Bundle", desc = "Spooky", price = 30000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/ghc/helmet/helmet_halloween_skeleton", [2] = "starwars/grady/itemshop/212th/ghc/body/body_halloween_skeleton"}, cantBuy = false }
BundleSkins["501_halloween23_heavy"] = { name = "Halloween 23 Bundle", desc = "Spooky", price = 30000, model = {"models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/501st/tc/helmet/helmet_halloween_skeleton", [2] = "starwars/grady/itemshop/501st/tc/body/body_halloween_skeleton"}, cantBuy = false }
BundleSkins["501_halloween23_medic"] = { name = "Halloween 23 Bundle", desc = "Spooky", price = 30000, model = {"models/starwars/grady/501st_medic/501st_medic2.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/501st/tc/helmet/helmet_halloween_skeleton", [2] = "starwars/grady/itemshop/501st/tc/body/body_halloween_skeleton"}, cantBuy = false }
BundleSkins["501_halloween23_tc"] = { name = "Halloween 23 Bundle", desc = "Spooky", price = 30000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/501st/tc/helmet/helmet_halloween_skeleton", [2] = "starwars/grady/itemshop/501st/tc/body/body_halloween_skeleton"}, cantBuy = false }
BundleSkins["halloween23_st"] = { name = "Halloween 23 Bundle", desc = "Spooky", price = 30000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_halloween_skeleton", [2] = "starwars/grady/itemshop/sonstiges/st/body/body_halloween_skeleton"}, cantBuy = false }

// HALLOWEEN BUNDLE ENDE! //

BundleSkins["Halloween_24_PH2"] = { name = "Halloween 24 Bundle", desc = "Spooky", price = 30000, model = {"models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl", "models/starwars/grady/aoc/212th/ec/212th_engineer.mdl", "models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl", "models/starwars/grady/501st_medic/501st_medic2.mdl", "models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/sonstiges/unassigned/halloween2024/helmet_ph2", [2] = "starwars/grady/itemshop/sonstiges/unassigned/halloween2024/body"}, cantBuy = false }
BundleSkins["Halloween_24_PILOT"] = { name = "Halloween 24 Bundle", desc = "Spooky", price = 30000, model = {"models/starwars/grady/aoc/avp/piloten/avp_pilot.mdl", "models/starwars/grady/aoc/avp/piloten/avp_schattenstaffel.mdl", "models/starwars/grady/aoc/avp/piloten/avp_goldstaffel.mdl", "models/starwars/grady/aoc/avp/piloten/avp_blaustaffel.mdl"}, id = 2, mat = {[4] = "starwars/grady/itemshop/sonstiges/unassigned/halloween2024/helmet_pilot_ph2", [2] = "starwars/grady/itemshop/sonstiges/unassigned/halloween2024/body"}, cantBuy = false }
BundleSkins["Halloween_24_ARF"] = { name = "Halloween 24 Bundle", desc = "Spooky", price = 30000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/sonstiges/unassigned/halloween2024/helmet_arf", [2] = "starwars/grady/itemshop/sonstiges/unassigned/halloween2024/body"}, cantBuy = false }
BundleSkins["Halloween_24_JAIG"] = { name = "Halloween 24 Bundle", desc = "Spooky", price = 30000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/sonstiges/unassigned/halloween2024/helmet_barc", [2] = "starwars/grady/itemshop/sonstiges/unassigned/halloween2024/body"}, cantBuy = false }
-- BundleSkins["Halloween_24_HEAVY"] = { name = "Halloween 24 Bundle", desc = "Spooky", price = 30000, model = {"models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/sonstiges/unassigned/halloween2024/helmet_barc", [2] = "starwars/grady/itemshop/sonstiges/unassigned/halloween2024/body"}, cantBuy = false }

-------------------
-- NEUES BUNDLE! --
-------------------

// Christmas navy BUNDLE ENDE! //

--BundleSkins["Fleetcrewchristmas24"] = { name = "Christmas 24 Bundle", desc = "Spooky", price = 40000, model = {"models/starwars/grady/aoc/navy/republic_navy_clone.mdl", "models/starwars/grady/aoc/navy/republic_navy_human1.mdl", "models/starwars/grady/aoc/navy/republic_navy_human2.mdl", "models/starwars/grady/aoc/navy/republic_navy_human3.mdl", "models/starwars/grady/aoc/navy/republic_navy_human4.mdl", "models/starwars/grady/aoc/navy/republic_navy_human5.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/sonstiges/unassigned/halloween2024/helmet_ph2", [2] = "starwars/grady/itemshop/sonstiges/unassigned/halloween2024/body"}, cantBuy = false }

-------------------
-- NEUES BUNDLE! --
-------------------

// ARF GC REAPER BUNDLE //
BundleSkins["GC_Reaper"] = { name = "Reaper", desc = "Reaper", price = 75000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/arf/helmet/helmet_reaper", [2] = "starwars/grady/itemshop/212th/arf/body/body_reaper"} }
// ARF GC REAPER BUNDLE ENDE !//

-------------------
-- NEUES BUNDLE! --
-------------------

//  //
BundleSkins["tc_jet_shiny"] = { name = "Jet SHINY Bundle", desc = "STRENG LIMITIERT", price = 80000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/501st/tc/helmet/helmet_jet_shiny", [2] = "starwars/grady/itemshop/501st/tc/body/body_jet_shiny"}, cantBuy = false }
BundleSkins["st_jet_shiny"] = { name = "Jet SHINY Bundle", desc = "STRENG LIMITIERT", price = 80000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_jet_shiny", [2] = "starwars/grady/itemshop/sonstiges/st/body/body_jet_shiny"}, cantBuy = false }
BundleSkins["gc_jet_shiny"] = { name = "Jet SHINY Bundle", desc = "STRENG LIMITIERT", price = 80000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/ghc/helmet/helmet_jet_shiny", [2] = "starwars/grady/itemshop/212th/ghc/body/body_jet_shiny"}, cantBuy = false }
BundleSkins["tc_jet"] = { name = "Jet  Bundle", desc = " ", price = 50000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/501st/tc/helmet/helmet_jet", [2] = "starwars/grady/itemshop/501st/tc/body/body_jet"}, cantBuy = false }
BundleSkins["st_jet"] = { name = "Jet  Bundle", desc = " ", price = 50000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_jet", [2] = "starwars/grady/itemshop/sonstiges/st/body/body_jet"}, cantBuy = false }
BundleSkins["gc_jet"] = { name = "Jet  Bundle", desc = " ", price = 50000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/ghc/helmet/helmet_jet", [2] = "starwars/grady/itemshop/212th/ghc/body/body_jet"}, cantBuy = false }
-------------------
-- NEUES BUNDLE! --
-------------------

// KNIGLICH BUNDLES (INAKTIV?) //
BundleSkins["501st_koeniglich"] = { name = "Eine knigliche Mischung!", desc = "Zeige deine Liebe zum Bad Batch ", price = 175000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl", "models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/501st/tc/helmet/helmet_koeniglich", [2] = "starwars/grady/itemshop/501st/tc/body/body_koeniglich"} }
BundleSkins["501st_koeniglich_Arc"] = { name = "Eine knigliche Mischung!", desc = "Zeige deine Liebe zum Bad Batch", price = 175000, model = {"models/starwars/grady/arc/aoc/501st_arc_heavy.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/501st/heavy/helmet/helmet_koeniglich", [2] = "starwars/grady/itemshop/501st/heavy/body/body_koeniglich"} }
// KNIGLICH BUNDLES ENDE ! //

// DRAGONSTONE BUNDLE //
BundleSkins["TC_Dragonstone"] = { name = "Dragonstone Bundle", desc = "Hunt", price = 50000, model = {"models/starwars/grady/aoc/501st/tc/501st_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/501st/tc/helmet/helmet_dragonstone", [2] = "starwars/grady/itemshop/501st/tc/body/body_dragonstone"}, cantBuy = false }
BundleSkins["TC_Heavy_Dragonstone"] = { name = "Dragonstone Bundle", desc = "Hunt", price = 50000, model = {"models/starwars/grady/aoc/501st/heavy/501st_heavy.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/501st/heavy/helmet/helmet_dragonstone", [2] = "starwars/grady/itemshop/501st/heavy/body/body_dragonstone"}, cantBuy = false }
-- BundleSkins["TC_JAIG_DRAGONSTONE"] = { name = "Dragonstone Bundle", desc = "Hunt", price = 50000, model = {"models/starwars/grady/aoc/501st/jaig/501st_jaig.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/501st/jaig/helmet/helmet_predator", [2] = "starwars/grady/itemshop/501st/jaig/body/body_predator"}, cantBuy = true }
BundleSkins["MP_DRAGONSTONE"] = { name = "Dragonstone Bundle", desc = "Hunt", price = 50000, model = {"models/starwars/grady/aoc/501st/medic/501st_medic.mdl", "models/starwars/grady/aoc/501st/medic/501st_medic_jumptrooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/501st/tc/helmet/helmet_dragonstone", [2] = "starwars/grady/itemshop/501st/tc/body/body_dragonstone"}, cantBuy = false }
BundleSkins["GC_DRAGONSTONE"] = { name = "Dragonstone Bundle", desc = "Hunt", price = 50000, model = {"models/starwars/grady/aoc/212th/ghc/212th_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/ghc/helmet/helmet_dragonstone", [2] = "starwars/grady/itemshop/212th/ghc/body/body_dragonstone"}, cantBuy = false }
BundleSkins["GC_Arf_Dragonstone"] = { name = "Dragonstone Bundle", desc = "Hunt", price = 50000, model = {"models/starwars/grady/aoc/212th/arf/212th_arf.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/arf/helmet/helmet_dragonstone", [2] = "starwars/grady/itemshop/212th/arf/body/body_dragonstone"}, cantBuy = false }
BundleSkins["EC_Dragonstone"] = { name = "Dragonstone Bundle", desc = "Hunt", price = 50000, model = {"models/starwars/grady/aoc/212th/ec/212th_engineer.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/212th/ghc/helmet/helmet_dragonstone", [2] = "starwars/grady/itemshop/212th/ghc/body/body_dragonstone"}, cantBuy = false }
BundleSkins["TRITON_Dragonstone"] = { name = "Dragonstone Bundle", desc = "Hunt", price = 50000, model = {"models/starwars/grady/aoc/501st/airborne/501st_airborne.mdl"}, id = 2, mat = {[4] = "starwars/grady/itemshop/501st/airborne/helmet/helmet_dragonstone", [3] = "starwars/grady/itemshop/501st/airborne/body/body_dragonstone", [2] = "starwars/grady/itemshop/501st/airborne/body/body_dragonstone"}, cantBuy = false }
BundleSkins["PARJAI_DRAGONSTONE"] = { name = "Dragonstone Bundle", desc = "Fick Delta", price = 50000, model = {"models/starwars/grady/aoc/212th/2nd_airborne/2nd_parjai.mdl"}, id = 2, mat = {[4] = "starwars/grady/itemshop/212th/airborne/helmet/helmet_dragonstone", [3] = "starwars/grady/itemshop/212th/airborne/body/body_dragonstone", [2] = "starwars/grady/itemshop/212th/airborne/body/body_dragonstone"}, cantBuy = false }
-- BundleSkins["ST_Dragonstone"] = { name = "Dragonstone Bundle", desc = "Hunt", price = 50000, model = {"models/starwars/grady/aoc/st/st/st_trooper.mdl"}, id = 2, mat = {[3] = "starwars/grady/itemshop/sonstiges/st/helmet/helmet_predator", [2] = "starwars/grady/itemshop/sonstiges/st/body/body_predator"}, cantBuy = false }
// PREDATOR BUNDLE ENDE ! //

CustomSkins = {}
--CustomSkins["76561198879798564_1"] = { name = "Tom Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198879798564"}, id = 2, mat = {[3] = "starwars/grady/itemshop/501st/tc/helmet/helmet_jet_shiny", [2] = "starwars/grady/itemshop/501st/tc/body/body_jet_shiny"}, cantBuy = false }
CustomSkins["76561198421239333_1"] = { name = "Pita Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198421239333"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/06_48_pita/helmet", [2] = "starwars/grady/itemshop/custom/06_48_pita/body"}, cantBuy = false }
CustomSkins["76561197995228042_1"] = { name = "Benni Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561197995228042"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/02_49_breaker/helmet", [2] = "starwars/grady/itemshop/custom/02_49_breaker/body"}, cantBuy = false }
CustomSkins["76561198450281238_1"] = { name = "Midnight Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198450281238"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/01_51_midnight/helmet", [2] = "starwars/grady/itemshop/custom/01_51_midnight/body"}, cantBuy = false }
CustomSkins["76561198979991069_1"] = { name = "Attie Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198979991069"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/04_57_baghira/helmet", [2] = "starwars/grady/itemshop/custom/04_57_baghira/body"}, cantBuy = false }
CustomSkins["76561198273696005_1"] = { name = "Nexos Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198273696005"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/03_67_nexos/helmet", [2] = "starwars/grady/itemshop/custom/03_67_nexos/body"}, cantBuy = false }
CustomSkins["76561198124373784_1"] = { name = "Kraw Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198124373784"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/08_69_riboflavin/helmet", [2] = "starwars/grady/itemshop/custom/08_69_riboflavin/body"}, cantBuy = false }
CustomSkins["76561199167552823_1"] = { name = "Kira Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561199167552823"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/05_27_kira/helmet", [2] = "starwars/grady/itemshop/custom/05_27_kira/body"}, cantBuy = false }
CustomSkins["76561198410324827_1"] = { name = "Kotu Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198410324827"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/07_68_kotu/helmet", [2] = "starwars/grady/itemshop/custom/07_68_kotu/body"}, cantBuy = false }
CustomSkins["76561199204492653_1"] = { name = "Wave Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561199204492653"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/10_74_wave/helmet", [2] = "starwars/grady/itemshop/custom/10_74_wave/body"}, cantBuy = false }
CustomSkins["76561198353985180_1"] = { name = "Thatch Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198353985180"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/09_75_thatch/helmet", [2] = "starwars/grady/itemshop/custom/09_75_thatch/body"}, cantBuy = false }
CustomSkins["76561199055369098_1"] = { name = "Reapzz Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561199055369098"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/11_77_reapzz/helmet", [2] = "starwars/grady/itemshop/custom/11_77_reapzz/body"}, cantBuy = false }
CustomSkins["76561199230131345_1"] = { name = "Stormer Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561199230131345"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/12_80_stormer/body", [4] = "starwars/grady/itemshop/custom/12_80_stormer/helmet", [2] = "starwars/grady/itemshop/custom/12_80_stormer/body"} }
CustomSkins["76561198979991069_2"] = { name = "Baghira Custom Skin 2", desc = "Dein eigener Custom Skin x2 bro!", price = 0, steamid = {"76561198979991069"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/13_57_baghira/body", [4] = "starwars/grady/itemshop/custom/13_57_baghira/helmet", [2] = "starwars/grady/itemshop/custom/13_57_baghira/body"} }
CustomSkins["76561199062255854_1"] = { name = "Burner Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561199062255854"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/15_108_burner/helmet", [2] = "starwars/grady/itemshop/custom/15_108_burner/body"}, cantBuy = false }
CustomSkins["76561199121789698_1"] = { name = "Viper Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561199121789698"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/14_81_tigerviper/helmet", [2] = "starwars/grady/itemshop/custom/14_81_tigerviper/body"}, cantBuy = false }
CustomSkins["76561198410324827_1"] = { name = "Kotu Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198410324827"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/17_112_kotu/helmet", [2] = "starwars/grady/itemshop/custom/17_112_kotu/body"}, cantBuy = false }
CustomSkins["76561199403340981_1"] = { name = "May Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561199403340981"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/18_103_may/helmet", [2] = "starwars/grady/itemshop/custom/18_103_may/body"}, cantBuy = false }
CustomSkins["76561198365870079_1"] = { name = "Law Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198365870079"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/19_105_max/helmet", [2] = "starwars/grady/itemshop/custom/19_105_max/body"}, cantBuy = false }
CustomSkins["76561198799175456_1"] = { name = "Oneshot Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198799175456"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/20_110_oneshot/helmet", [2] = "starwars/grady/itemshop/custom/20_110_oneshot/body"}, cantBuy = false }
CustomSkins["76561198410324827_1"] = { name = "Kotu 2 Custom Skin", desc = "Dein eigener Custom Skin x2 !", price = 0, steamid = {"76561198410324827"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/17_112_kotu/helmet", [2] = "starwars/grady/itemshop/custom/17_112_kotu/body"}, cantBuy = false }
CustomSkins["76561198837558657_2"] = { name = "Zerek Custom Skin 2", desc = "Dein eigener Custom Skin x2 bro!", price = 0, steamid = {"76561198837558657"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/16_114_zerek/body", [4] = "starwars/grady/itemshop/custom/16_114_zerek/helmet", [2] = "starwars/grady/itemshop/custom/16_114_zerek/body"} }
CustomSkins["76561198979991069_3"] = { name = "Baghira Custom Skin 3", desc = "Dein eigener Custom Skin x3 !", price = 0, steamid = {"76561198979991069"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/22_57_baghira/helmet", [2] = "starwars/grady/itemshop/custom/22_57_baghira/body"}, cantBuy = false }
CustomSkins["76561199189617635_1"] = { name = "Axe Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561199189617635"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/26_192_axe/body", [4] = "starwars/grady/itemshop/custom/26_192_axe/helmet", [2] = "starwars/grady/itemshop/custom/26_192_axe/body"} }
CustomSkins["76561198156716789_1"] = { name = "Nitro Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198156716789"}, id = 2, mat = {[4] = "starwars/grady/itemshop/custom/25_173_nitro/helmet", [2] = "starwars/grady/itemshop/custom/25_173_nitro/body"}, cantBuy = false }
CustomSkins["76561198450281238_2"] = { name = "Midnight Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198450281238"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/21_51_midnight/helmet", [2] = "starwars/grady/itemshop/custom/21_51_midnight/body"}, cantBuy = false }
CustomSkins["76561198417817201_1"] = { name = "Hammer Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198417817201"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/24_167_hammer/helmet", [2] = "starwars/grady/itemshop/custom/24_167_hammer/body"}, cantBuy = false }
CustomSkins["76561199378792328_1"] = { name = "Tone Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561199378792328"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/33_198_tone/helmet", [2] = "starwars/grady/itemshop/custom/33_198_tone/body"}, cantBuy = false }
CustomSkins["76561198078686237_1"] = { name = "Skirmish Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198078686237"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/31_197_skirmish/helmet", [2] = "starwars/grady/itemshop/custom/31_197_skirmish/body"}, cantBuy = false }
CustomSkins["76561199022200778_1"] = { name = "Shade Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561199022200778"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/30_195_shade/helmet", [2] = "starwars/grady/itemshop/custom/30_195_shade/body"}, cantBuy = false }
CustomSkins["76561199015929301_1"] = { name = "Lyks Custom Skin 2", desc = "Dein eigener Custom Skin x2 bro!", price = 0, steamid = {"76561199015929301"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/28_178_lux/body", [4] = "starwars/grady/itemshop/custom/28_178_lux/helmet", [2] = "starwars/grady/itemshop/custom/28_178_lux/body"} }
CustomSkins["76561198076228255_1"] = { name = "Coldeye Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198076228255"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/29_174_slidecurry/helmet", [2] = "starwars/grady/itemshop/custom/29_174_slidecurry/body"}, cantBuy = false }
CustomSkins["76561199230131345_2"] = { name = "Stormer Custom Skin 2", desc = "Dein eigener Custom Skin x2 bro!", price = 0, steamid = {"76561199230131345"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/27_80_stormer/body", [4] = "starwars/grady/itemshop/custom/27_80_stormer/helmet", [2] = "starwars/grady/itemshop/custom/27_80_stormer/body"} }
CustomSkins["76561198096084263_1"] = { name = "Jumpi Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198096084263"}, id = 2, mat = {[4] = "starwars/grady/itemshop/custom/37_202_jumpi/helmet", [2] = "starwars/grady/itemshop/custom/37_202_jumpi/body"}, cantBuy = false }
CustomSkins["76561198445305250_1"] = { name = "Nylar Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198445305250"}, id = 2, mat = {[4] = "starwars/grady/itemshop/custom/36_93_nylar/helmet", [2] = "starwars/grady/itemshop/custom/36_93_nylar/body"}, cantBuy = false }
CustomSkins["76561198100419508_1"] = { name = "Hammerhead Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198100419508"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/68_437_hammerhead/helmet", [2] = "starwars/grady/itemshop/custom/34_200_hammerhead/body"}, cantBuy = false }
CustomSkins["76561198388606711_1"] = { name = "Chip Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198388606711"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/32_199_chip/helmet", [2] = "starwars/grady/itemshop/custom/32_199_chip/body"}, cantBuy = false }
CustomSkins["76561198943547080_1"] = { name = "Grandle Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198943547080"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/23_139_grandle/helmet", [2] = "starwars/grady/itemshop/custom/23_139_grandle/body"}, cantBuy = false }
CustomSkins["76561199161270771_1"] = { name = "HAWKEYE Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561199161270771"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/35_97_hawkeye/helmet", [2] = "starwars/grady/itemshop/custom/35_97_hawkeye/body"}, cantBuy = false }
CustomSkins["76561198164545482_1"] = { name = "Quanit Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198164545482"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/39_79_quanite/helmet", [2] = "starwars/grady/itemshop/custom/39_79_quanite/body"}, cantBuy = false }
CustomSkins["76561198277529992_1"] = { name = "Theckray Custom Skin", desc = "Dein eigener Custom Skin bro!", price = 0, steamid = {"76561198277529992"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/38_21_theckray/body", [4] = "starwars/grady/itemshop/custom/38_21_theckray/helmet", [2] = "starwars/grady/itemshop/custom/38_21_theckray/body"} }
CustomSkins["76561198220313240_1"] = { name = "Sabaton Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198220313240"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/40_92_sabaton/helmet", [2] = "starwars/grady/itemshop/custom/40_92_sabaton/body"}, cantBuy = false }
CustomSkins["76561198979991069_4"] = { name = "Baghira Custom Skin 4", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198979991069"}, id = 2, mat = {[4] = "starwars/grady/itemshop/custom/42_111_akaanir/helmet", [2] = "starwars/grady/itemshop/custom/42_111_akaanir/body"}, cantBuy = false }
CustomSkins["76561198372429376_1"] = { name = "Faid Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198372429376"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/43_124_faid/helmet", [2] = "starwars/grady/itemshop/custom/43_124_faid/body"}, cantBuy = false }
CustomSkins["76561199229864836_1"] = { name = "SYconsti Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561199229864836"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/46_162_syconsti/helmet", [2] = "starwars/grady/itemshop/custom/46_162_syconsti/body"}, cantBuy = false }
CustomSkins["76561197995228042_2"] = { name = "Breaker Custom Skin x2", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561197995228042"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/41_138_breaker/helmet", [2] = "starwars/grady/itemshop/custom/41_138_breaker/body"}, cantBuy = false }
CustomSkins["76561198803370161_1"] = { name = "Dark Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198803370161"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/44_154_dark/body", [4] = "starwars/grady/itemshop/custom/44_154_dark/helmet", [2] = "starwars/grady/itemshop/custom/44_154_dark/body"} }
CustomSkins["76561199167552823_2"] = { name = "Lukas Custom Skin x2", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561199167552823"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/47_160_lukas/helmet", [2] = "starwars/grady/itemshop/custom/47_160_lukas/body"}, cantBuy = false }
CustomSkins["76561198448840888_1"] = { name = "Caide Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198448840888"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/45_153_caide/helmet", [2] = "starwars/grady/itemshop/custom/45_153_caide/body"}, cantBuy = false }
CustomSkins["76561198356715191_1"] = { name = "Poison Custom Skin 2", desc = "Dein eigener Custom Skin bro!", price = 0, steamid = {"76561198356715191"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/50_199_poison/body", [4] = "starwars/grady/itemshop/custom/50_199_poison/helmet", [2] = "starwars/grady/itemshop/custom/50_199_poison/body"} }
CustomSkins["76561198169861555_1"] = { name = "Ghost Custom Skin", desc = "Dein eigener Custom Skin bro!", price = 0, steamid = {"76561198169861555"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/48_179_ghost/body", [4] = "starwars/grady/itemshop/custom/48_179_ghost/helmet", [2] = "starwars/grady/itemshop/custom/48_179_ghost/body"} }
CustomSkins["76561198273696005_2"] = { name = "Nexos Custom Skin 2", desc = "Dein eigener Custom Skin bro!", price = 0, steamid = {"76561198273696005"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/49_189_Nexos/body", [4] = "starwars/grady/itemshop/custom/49_189_Nexos/helmet", [2] = "starwars/grady/itemshop/custom/49_189_Nexos/body"} }
CustomSkins["76561198415146805_1"] = { name = "Unknock Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198415146805"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/51_208_unknockname/helmet", [2] = "starwars/grady/itemshop/custom/51_208_unknockname/body"}, cantBuy = false }
CustomSkins["76561199068471591_1"] = { name = "Kenner Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561199068471591"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/53_257_keck25/helmet", [2] = "starwars/grady/itemshop/custom/53_257_keck25/body"}, cantBuy = false }
CustomSkins["76561198134492877_1"] = { name = "Schneider Custom Skin", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198134492877"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/54_320_schneider/arc_helmet", [1] = "starwars/grady/itemshop/custom/54_320_schneider/ct_body", [12] = "starwars/grady/itemshop/custom/54_320_schneider/arc_gear", [13] = "starwars/grady/itemshop/custom/54_320_schneider/arc_kama"}, cantBuy = false }
CustomSkins["76561199015929301_2"] = { name = "Luke Custom Skin 2", desc = "Dein eigener Custom Skin bro!", price = 0, steamid = {"76561199015929301"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/55_307_luke/helmet", [2] = "starwars/grady/itemshop/custom/55_307_luke/body"} }
CustomSkins["76561198388606711_2"] = { name = "Yesgo Custom Skin x2", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198388606711"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/56_226_yesgo/helmet", [2] = "starwars/grady/itemshop/custom/56_226_yesgo/body"}, cantBuy = false }
CustomSkins["76561198095563011_1"] = { name = "Trace Custom Skin x2", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561198095563011"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/60_305_trace/helmet", [2] = "starwars/grady/itemshop/custom/60_305_trace/body"}, cantBuy = false }
CustomSkins["76561199179713072_1"] = { name = "Gamma Custom Skin x2", desc = "Dein eigener Custom Skin!", price = 0, steamid = {"76561199179713072"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/59_313_pilz/helmet", [2] = "starwars/grady/itemshop/custom/59_313_pilz/body"}, cantBuy = false }
CustomSkins["76561198277529992_2"] = { name = "Theckray Custom Skinx2", desc = "Dein eigener Custom Skin bro!", price = 0, steamid = {"76561198277529992"}, id = 2, mat = {[2] = "starwars/grady/itemshop/custom/62_276_liasgeist/body", [3] = "starwars/grady/itemshop/custom/62_276_liasgeist/helmet"}, cantBuy = false }
CustomSkins["76561199091742350_1"] = { name = "Dyr Custom Skin", desc = "Dein eigener Custom Skin bro!", price = 0, steamid = {"76561199091742350"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/57_302_dyrr/body", [4] = "starwars/grady/itemshop/custom/57_302_dyrr/helmet", [2] = "starwars/grady/itemshop/custom/57_302_dyrr/body"} }
CustomSkins["76561199390128572_1"] = { name = "Fireblast Custom Skin", desc = "Dein eigener Custom Skin bro!", price = 0, steamid = {"76561199390128572"}, id = 2, mat = {[3] = "starwars/grady/itemshop/custom/58_311_fireblast/body", [4] = "starwars/grady/itemshop/custom/58_311_fireblast/helmet", [2] = "starwars/grady/itemshop/custom/58_311_fireblast/body"} }
CustomSkins["76561198413402694_1"] = { name = "Dreamz Custom Skinx2", desc = "Dein eigener Custom Skin bro!", price = 0, steamid = {"76561198413402694"}, id = 2, mat = {[2] = "starwars/grady/itemshop/custom/64_343_dreamz/body", [3] = "starwars/grady/itemshop/custom/64_343_dreamz/helmet"}, cantBuy = false }
CustomSkins["76561199091742350_2"] = { name = "Dyr Custom Skinx2", desc = "Dein eigener Custom Skin bro!", price = 0, steamid = {"76561199091742350"}, id = 2, mat = {[2] = "starwars/grady/itemshop/custom/65_397_dyrr/body", [3] = "starwars/grady/itemshop/custom/65_397_dyrr/helmet"}, cantBuy = false }
CustomSkins["76561199437896680_1"] = { name = "Raphi Custom Skinx2", desc = "Dein eigener Custom Skin bro!", price = 0, steamid = {"76561199437896680"}, id = 2, mat = {[2] = "starwars/grady/itemshop/custom/66_402_raphi/body", [3] = "starwars/grady/itemshop/custom/66_402_raphi/helmet"}, cantBuy = false }

CustomAttachments = {}
CustomAttachments["76561199167552823_attachment_1"] = { name = "Lukas Custom Attachment", desc = "Skibedi Toilet", price = 0, steamid = {"76561199167552823"}, id = 2, mat = {[13] = "starwars/grady/itemshop/custom/_attachments/02_20_lukas/ct_heavy", [8] = "starwars/grady/itemshop/custom/_attachments/02_20_lukas/ct_arf_helmet_attachments"}, cantBuy = false }
CustomAttachments["76561198450281238_attachment_1"] = { name = "Wils Custom Attachment", desc = "Wils Custom Skin", price = 0, steamid = {"76561198450281238"}, id = 2, mat = {[10] = "starwars/grady/itemshop/custom/_attachments/03_25_wils/ct_heavy", [8] = "starwars/grady/itemshop/custom/_attachments/03_25_wils/ct_specialist"}, cantBuy = false }
CustomAttachments["76561198421239333_attachment_1"] = { name = "Pita Custom Attachment", desc = "Pita Custom Skin", price = 0, steamid = {"76561198421239333"}, id = 2, mat = {[10] = "starwars/grady/itemshop/custom/_attachments/01_42_pita/ct_heavy", [8] = "starwars/grady/itemshop/custom/_attachments/01_42_pita/ct_specialist"}, cantBuy = false }
CustomAttachments["76561199121789698_attachment_1"] = { name = "Tiger Custom Attachment", desc = "Tiger Custom Skin", price = 0, steamid = {"76561199121789698"}, id = 2, mat = {[10] = "starwars/grady/itemshop/custom/_attachments/06_35_tiger/ct_heavy", [8] = "starwars/grady/itemshop/custom/_attachments/06_35_tiger/ct_specialist"}, cantBuy = false }
CustomAttachments["76561198329012755_attachment_1"] = { name = "Admirallp Custom Attachment", desc = "Tiger Custom Skin", price = 0, steamid = {"76561198329012755"}, id = 2, mat = {[10] = "starwars/grady/itemshop/custom/_attachments/07_14_admirallp/ct_heavy", [8] = "starwars/grady/itemshop/custom/_attachments/07_14_admirallp/ct_specialist"}, cantBuy = false }
CustomAttachments["76561199161270771_attachment_1"] = { name = "Lxonix Custom Attachment", desc = "Lxonix Custom Skin", price = 0, steamid = {"76561199161270771"}, id = 2, mat = {[10] = "starwars/grady/itemshop/custom/_attachments/08_72_lxonix/ct_heavy"}, cantBuy = false }
CustomAttachments["76561199041243146_attachment_1"] = { name = "Dec Custom Attachment", desc = "Dec Custom Skin", price = 0, steamid = {"76561199041243146"}, id = 2, mat = {[10] = "starwars/grady/itemshop/custom/_attachments/05_28_dec/ct_heavy", [8] = "starwars/grady/itemshop/custom/_attachments/05_28_dec/ct_specialist"}, cantBuy = false }
CustomAttachments["76561198076228255S_attachment_1"] = { name = "Slidecurry Custom Attachment", desc = "Slidecurry Custom Skin", price = 0, steamid = {"76561198076228255"}, id = 2, mat = {[12] = "starwars/grady/itemshop/custom/_attachments/04_23_slidecurry/ct_heavy", [10] = "starwars/grady/itemshop/custom/_attachments/04_23_slidecurry/ct_specialist"}, cantBuy = false }
CustomAttachments["76561198372429376_attachment_1"] = { name = "Faid Custom Attachment", desc = "Faid Custom Skin", price = 0, steamid = {"76561198372429376"}, id = 2, mat = {[10] = "starwars/grady/itemshop/custom/_attachments/10_124_faid/ct_heavy", [8] = "starwars/grady/itemshop/custom/_attachments/10_124_faid/ct_specialist"}, cantBuy = false }
CustomAttachments["76561197995228042_attachment_1"] = { name = "Breaker Custom Attachment", desc = "Breaker Custom Skin", price = 0, steamid = {"76561197995228042"}, id = 2, mat = {[13] = "starwars/grady/itemshop/custom/_attachments/09_139_breaker/ct_heavy", [8] = "starwars/grady/itemshop/custom/_attachments/09_139_breaker/ct_arf_helmet_attachments"}, cantBuy = false }
CustomAttachments["76561198943547080_attachment_1"] = { name = "Mulmrius Custom Attachment", desc = "Mulmrius Custom Skin", price = 0, steamid = {"76561198943547080"}, id = 2, mat = {[10] = "starwars/grady/itemshop/custom/_attachments/11_145_mulmrius/ct_heavy", [8] = "starwars/grady/itemshop/custom/_attachments/11_145_mulmrius/ct_specialist"}, cantBuy = false }
CustomAttachments["76561198220313240_attachment_1"] = { name = "Sabaton Custom Attachment", desc = "Sabaton Custom Skin", price = 0, steamid = {"76561198220313240"}, id = 2, mat = {[10] = "starwars/grady/itemshop/custom/_attachments/13_92_sabaton/ct_heavy", [8] = "starwars/grady/itemshop/custom/_attachments/13_92_sabaton/ct_specialist"}, cantBuy = false }
CustomAttachments["76561198078846517_attachment_1"] = { name = "Aura Custom Attachment", desc = "Aura Custom Skin", price = 0, steamid = {"76561198078846517"}, id = 2, mat = {[10] = "starwars/grady/itemshop/custom/_attachments/12_47_Aura/ct_heavy", [8] = "starwars/grady/itemshop/custom/_attachments/12_47_Aura/ct_specialist"}, cantBuy = false }
CustomAttachments["76561198365870079_attachment_1"] = { name = "Max Custom Attachment", desc = "Max Custom Skin", price = 0, steamid = {"76561198365870079"}, id = 2, mat = {[12] = "starwars/grady/itemshop/custom/_attachments/14_167_law/ct_heavy", [10] = "starwars/grady/itemshop/custom/_attachments/14_167_law/ct_specialist"}, cantBuy = false }
CustomAttachments["76561198273696005_attachment_1"] = { name = "Nexos Custom Attachment", desc = "Nexos Custom Skin", price = 0, steamid = {"76561198273696005"}, id = 2, mat = {[11] = "starwars/grady/itemshop/custom/_attachments/15_108_nexos/ct_heavy"}, cantBuy = false }
CustomAttachments["76561199230131345_attachment_1"] = { name = "Stormer Custom Attachment", desc = "Stormer Custom Skin", price = 0, steamid = {"76561199230131345"}, id = 2, mat = {[11] = "starwars/grady/itemshop/custom/_attachments/17_006_stormer/ct_heavy", [9] = "starwars/grady/itemshop/custom/_attachments/17_006_stormer/ct_specialist"}, cantBuy = false } --gcpj
CustomAttachments["76561198450281238_attachment_2"] = { name = "Wils Custom Attachment 2", desc = "Wils Custom Skin", price = 0, steamid = {"76561198450281238"}, id = 2, mat = {[10] = "starwars/grady/itemshop/custom/_attachments/16_322_wils/ct_heavy", [8] = "starwars/grady/itemshop/custom/_attachments/16_322_wils/ct_specialist"}, cantBuy = false } --?kp
CustomAttachments["76561198388606711_attachment_1"] = { name = "Yesgo Custom Attachment", desc = "Yesgo Custom Skin", price = 0, steamid = {"76561198388606711"}, id = 2, mat = {[13] = "starwars/grady/itemshop/custom/_attachments/18_226_yesgo/ct_heavy", [8] = "starwars/grady/itemshop/custom/_attachments/18_226_yesgo/ct_arf_helmet_attachments"}, cantBuy = false }
CustomAttachments["76561199068471591_attachment_1"] = { name = "Biba Custom Attachment", desc = "biba Custom Skin", price = 0, steamid = {"76561199068471591"}, id = 2, mat = {[10] = "starwars/grady/itemshop/custom/_attachments/20_394_chaoskenner/ct_heavy", [8] = "starwars/grady/itemshop/custom/_attachments/20_394_chaoskenner/ct_specialist"}, cantBuy = false }
for k, v in pairs(HeadSkins) do

    local buy = true
    if v.cantBuy then
        buy = false 
    end

    AOCRP.GTM.Items[k] = {
        name = v.name,
        desc = v.desc,
        price = v.price,
        category = "Helmskins",
        apply = true,
        permanent = true,
        canSell = true,
        canBuy = buy,
        vipFree = true,
        vipOnly =  false,
        limitFunc = function(ply) return table.HasValue(v.model,ply:GetModel()) end,
        applyFunc = function(ply) AOCRP.GTM:ApplyGTMSkin(ply, v.id, v.mat, "kopf", k) end,
        iconFunc = function(panel)  AOCRP.GTM:doHelmetSkinIcon(panel,v.mat,v.id) end,
        previewFunc = function(panel)  AOCRP.GTM:doSkinPreview(panel,v.mat,v.id) end,
    }
end

for k, v in pairs(BodySkins) do

    local buy = true
    if v.cantBuy then
        buy = false 
    end

    AOCRP.GTM.Items[k] = {
        name = v.name,
        desc = v.desc,
        price = v.price,
        category = "Krperskins",
        apply = true,
        permanent = true,
        canSell = true,
        canBuy = buy,
        vipFree = true,
        vipOnly =  false,
        limitFunc = function(ply) return table.HasValue(v.model,ply:GetModel()) end,
        applyFunc = function(ply) AOCRP.GTM:ApplyGTMSkin(ply, v.id, v.mat, "body", k) end,
        iconFunc = function(panel)  AOCRP.GTM:doBodySkinIcon(panel,v.mat,v.id) end,
        previewFunc = function(panel)  AOCRP.GTM:doSkinPreview(panel,v.mat,v.id) end,
    }
end


for k, v in pairs(BundleSkins) do

    local buy = true
    if v.cantBuy then
        buy = false 
    end

    AOCRP.GTM.Items[k] = {
        name = v.name,
        desc = v.desc,
        price = v.price,
        category = "Skinbundles",
        apply = true,
        permanent = true,
        canSell = true,
        canBuy = buy,
        vipFree = true,
        vipOnly =  false,
        limitFunc = function(ply) return table.HasValue(v.model,ply:GetModel()) end,
        applyFunc = function(ply) AOCRP.GTM:ApplyGTMSkin(ply, v.id, v.mat, "body", k) AOCRP.GTM:ApplyGTMSkin(ply, v.id, v.mat, "kopf", k) end,
        iconFunc = function(panel)  AOCRP.GTM:doBodySkinIcon(panel,v.mat,v.id) end,
        previewFunc = function(panel)  AOCRP.GTM:doSkinPreview(panel,v.mat,v.id) end,
    }
end

for k, v in pairs(CustomSkins) do

    local buy = true
    if v.cantBuy then
        buy = false 
    end

    AOCRP.GTM.Items[k] = {
        name = v.name,
        desc = v.desc,
        price = v.price,
        category = "CustomSkins",
        apply = true,
        permanent = true,
        canSell = false,
        canBuy = buy,
        vipFree = false,
        vipOnly =  false,
        limitFunc = function(ply) return table.HasValue(v.steamid,ply:SteamID64()) end,
        applyFunc = function(ply) AOCRP.GTM:ApplyGTMSkin(ply, v.id, v.mat, "body", k) AOCRP.GTM:ApplyGTMSkin(ply, v.id, v.mat, "kopf", k) end,
        iconFunc = function(panel)  AOCRP.GTM:doBodySkinIcon(panel,v.mat,v.id) end,
        previewFunc = function(panel)  AOCRP.GTM:doSkinPreview(panel,v.mat,v.id) end,
    }
end

for k, v in pairs(CustomAttachments) do

    local buy = true
    if v.cantBuy then
        buy = false 
    end

    AOCRP.GTM.Items[k] = {
        name = v.name,
        desc = v.desc,
        price = v.price,
        category = "CustomAttachments",
        apply = true,
        permanent = true,
        canSell = false,
        canBuy = buy,
        vipFree = false,
        vipOnly =  false,
        limitFunc = function(ply) return table.HasValue(v.steamid,ply:SteamID64()) end,
        applyFunc = function(ply) AOCRP.GTM:ApplyGTMSkin(ply, v.id, v.mat, "body", k) AOCRP.GTM:ApplyGTMSkin(ply, v.id, v.mat, "kopf", k) end,
        iconFunc = function(panel)  AOCRP.GTM:doBodySkinIcon(panel,v.mat,v.id) end,
        previewFunc = function(panel)  AOCRP.GTM:doSkinPreview(panel,v.mat,v.id) end,
    }
end


    AOCRP.GTM.Items["animation_flugzeug"] = {
        name = "Flugzeug",
        desc = "Ich heb ab..",
        price = 125000,
        category = "Animationen",
        apply = false,
        permanent = true,
        canSell = true,
        canBuy = true,
        vipFree = true,
        vipOnly =  false,
        limitFunc = function(ply) return true end,
        applyFunc = function(ply) end,
        iconFunc = function(panel) AOCRP.GTM:DoAnimationPreview(panel,"flugzeug") end,
        previewFunc = function(panel) AOCRP.GTM:DoAnimationPreview(panel,"flugzeug") end,
    }

    

    AOCRP.GTM.Items["animation_middlefinger"] = {
        name = "Mittelfinger",
        desc = "Zeige deinen Hass.",
        price = 300000,
        category = "Animationen",
        apply = false,
        permanent = true,
        canSell = true,
        canBuy = true,
        vipFree = false,
        vipOnly =  true,
        limitFunc = function(ply) return true end,
        applyFunc = function(ply) end,
        iconFunc = function(panel) AOCRP.GTM:DoAnimationPreview(panel,"middle") end,
        previewFunc = function(panel) AOCRP.GTM:DoAnimationPreview(panel,"middle") end,
    }



    local GTM_ACTS = {}
--[[     GTM_ACTS["act_dance"] = { name = "Act Dance", price = 10000, icon = "BTZqdvS"}
    GTM_ACTS["act_laugh"] = { name = "Act Laugh", price = 5000, icon = "ouFyVyC"}
    GTM_ACTS["act_forward"] = { name = "Act Forward", price = 1000, icon = "sQw1bzg"}
    GTM_ACTS["act_group"] = { name = "Act Group", price = 1000, icon = "b5YEj1p"}
    GTM_ACTS["act_halt"] = { name = "Act Halt", price = 1000, icon = "Tkfic8D"}
    GTM_ACTS["act_agree"] = { name = "Act Agree", price = 5000, icon = "JGZQQZQ"}
    GTM_ACTS["act_becon"] = { name = "Act Becon", price = 2000, icon = "djRzfdT"}
    GTM_ACTS["act_bow"] = { name = "Act Bow", price = 5000, icon = "o8Ern3j"}
    GTM_ACTS["act_disagree"] = { name = "Act Disagree", price = 2000, icon = "UNOkaZo"}
    GTM_ACTS["act_salute"] = { name = "Act Salute", price = 1000, icon = "dX1cSuQ"}
    GTM_ACTS["act_wave"] = { name = "Act Wave", price = 2000, icon = "BIWZYlE"}
    GTM_ACTS["act_pers"] = { name = "Act Pers", price = 10000, icon = "dFxpxgj"}
    GTM_ACTS["act_cheer"] = { name = "Act Cheer", price = 2000, icon = "uBkqpKq"}
    GTM_ACTS["act_zombie"] = { name = "Act Zombie", price = 10000, icon = "qieILw8"}
    GTM_ACTS["act_robot"] = { name = "Act Robot", price = 10000, icon = "GyzImhs"} ]]

    --GTM_ACTS["act_dance"] = { name = "Act Dance", price = 10000, sequence = "taunt_dance" }
    --GTM_ACTS["act_laugh"] = { name = "Act Laugh", price = 5000, sequence = "taunt_laugh" }
    GTM_ACTS["act_forward"] = { name = "Act Forward", price = 1000, sequence = "gesture_signal_forward" }
    GTM_ACTS["act_group"] = { name = "Act Group", price = 1000, sequence = "gesture_signal_group" }
    GTM_ACTS["act_halt"] = { name = "Act Halt", price = 1000, sequence = "gesture_signal_halt" }
    GTM_ACTS["act_agree"] = { name = "Act Agree", price = 5000, sequence = "gesture_agree" }
    GTM_ACTS["act_becon"] = { name = "Act Beacon", price = 2000, sequence = "gesture_becon" }
    GTM_ACTS["act_bow"] = { name = "Act Bow", price = 5000, sequence = "gesture_bow" }
    GTM_ACTS["act_disagree"] = { name = "Act Disagree", price = 2000, sequence = "gesture_disagree" }
    GTM_ACTS["act_salute"] = { name = "Act Salute", price = 1000, sequence = "gesture_salute" }
    GTM_ACTS["act_wave"] = { name = "Act Wave", price = 2000, sequence = "gesture_wave" }
    GTM_ACTS["act_pers"] = { name = "Act Pers", price = 10000, sequence = "taunt_persistence" }
    GTM_ACTS["act_cheer"] = { name = "Act Cheer", price = 2000, sequence = "taunt_cheer" }
    GTM_ACTS["act_zombie"] = { name = "Act Zombie", price = 10000, sequence = "taunt_zombie" }
    GTM_ACTS["act_robot"] = { name = "Act Robot", price = 10000, sequence = "taunt_robot" }
    GTM_ACTS["act_muscle"] = { name = "Act Muscle", price = 10000, sequence = "taunt_muscle" }
    



    for k, v in pairs(GTM_ACTS) do
        AOCRP.GTM.Items[k] = {
            name = v.name,
            desc = "Nach Kauf ber Konsole nutzbar.",
            price = v.price,
            category = "Acts",
            apply = false,
            permanent = true,
            canSell = true,
            canBuy = true,
            vipFree = true,
            vipOnly =  false,
            limitFunc = function(ply) return true end,
            applyFunc = function(ply) end,
            iconFunc = function(panel) AOCRP.GTM:DoActPreview(panel,v.sequence) end,
            previewFunc = function(panel) AOCRP.GTM:DoActPreview(panel,v.sequence)  end,
        }
    end




    


    AOCRP.GTM.Items["vibroknife"] = {
        name = "Vibromesser",
        desc = "Schlitze deine Gegner auf",
        price = 350000,
        category = "Waffen",
        apply = false,
        permanent = true,
        canSell = true,
        canBuy = false,
        vipFree = false,
        vipOnly =  false,
        limitFunc = function(ply) return true end,
        applyOnSpawnFunc = function(ply) ply:Give("aocrp_vibroknife") end,
        applyFunc = function(ply) ply:Give("aocrp_vibroknife") end,
        iconFunc = function(panel) AOCRP.GTM:doMaterialIcon(panel,"entities/sopsmisc/vibroknife.png",Color(255,255,255)) end,
        previewFunc = function(panel) AOCRP.GTM:doMaterialIcon(panel,"entities/sopsmisc/vibroknife.png",Color(255,255,255)) end,
    }

    AOCRP.GTM.Items["dualdc17"] = {
        name = "Dual DC-17",
        desc = "Nimm dir doch einfach ne Zweite.",
        price = 1250000,
        category = "Waffen",
        apply = false,
        permanent = true,
        canSell = true,
        canBuy = true,
        vipFree = false,
        vipOnly =  false,
        limitFunc = function(ply) return true end,
        applyOnSpawnFunc = function(ply) ply:Give("aocrp_dual_dc17_ext") end,
        applyFunc = function(ply) ply:Give("aocrp_dual_dc17_ext") end,
        iconFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,"models/meeks/worldmodels/w_dc17_ext_dual.mdl") end,
        previewFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,"models/meeks/worldmodels/w_dc17_ext_dual.mdl") end,
    }


    AOCRP.GTM.Items["helmet_hud"] = {
        name = "Helm",
        desc = "Erlaubt Zugriff auff /helmoverlay",
        price = 30000,
        category = "HUDs",
        apply = false,
        permanent = true,
        canSell = true,
        canBuy = true,
        vipFree = true,
        vipOnly =  false,
        limitFunc = function(ply) return true end,
        applyFunc = function(ply) 
        end,
        iconFunc = function(panel)  end,
        previewFunc = function(panel) end,
    }


    AOCRP.GTM.Items["singletime_headcrab"] = {
        name = "Haustier",
        desc = "Du hast ein unbekanntes Wesen einfach mitgenommen.",
        price = 50000,
        category = "Aktionen",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  false,
        limitFunc = function(ply) return true end,
        applyFunc = function(ply) 
        
            local eyetracePos = ply:GetEyeTrace().HitPos

  

            timer.Simple(5, function() 
                local button = ents.Create( "npc_headcrab_fast" )
                button:SetPos( eyetracePos )
                button:Spawn() 
            end)


        end,
        iconFunc = function(panel) AOCRP.GTM:doMaterialIcon(panel,"entities/npc_headcrab.png") end,
        previewFunc = function(panel) AOCRP.GTM:doMaterialIcon(panel,"entities/npc_headcrab.png") end,
    }

    AOCRP.GTM.Items["singletime_guard"] = {
        name = "Groes Haustier",
        desc = "Du hast ein unbekanntes Wesen einfach mitgenommen.",
        price = 100000,
        category = "Aktionen",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  true,
        limitFunc = function(ply) return true end,
        applyFunc = function(ply) 
        
            local eyetracePos = ply:GetEyeTrace().HitPos


            timer.Simple(5, function() 
                local button = ents.Create( "npc_antlionguard" )
                button:SetPos( eyetracePos )
                button:Spawn() 
            end)


        end,
        iconFunc = function(panel) AOCRP.GTM:doMaterialIcon(panel,"entities/npc_antlionguard.png") end,
        previewFunc = function(panel) AOCRP.GTM:doMaterialIcon(panel,"entities/npc_antlionguard.png") end,
    }

    
--[[     AOCRP.GTM.Items["singletime_vip"] = {
        name = "Temporres VIP",
        desc = "Du erhlst VIP, aber nur bis zum \nnchsten Disconnect oder Mapchange",
        price = 100000,
        category = "Aktionen",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  false,
        limitFunc = function(ply) return true end,
        applyFunc = function(ply) 
    
           ply:SetAOCVIP(true)

        end,
        iconFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,"models/balloons/balloon_star.mdl") end,
        previewFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,"models/balloons/balloon_star.mdl") end,
    } ]]

    AOCRP.GTM.Items["singletime_training"] = {
        name = "Trainingsgranate",
        desc = "Macht nicht wirklich boom.",
        price = 1000,
        category = "Waffen",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = true,
        vipOnly =  false,
        limitFunc = function(ply) return true end,
        applyFunc = function(ply) 
    
           ply:Give("rw_sw_nade_training")

        end,
        iconFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,"models/cs574/explosif/grenade_train.mdl") end,
        previewFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,"models/cs574/explosif/grenade_train.mdl") end,
    }



    AOCRP.GTM.Items["singletime_soccerball"] = {
        name = "Fuball",
        desc = "Perfekt zum Basketballspielen.",
        price = 10000,
        category = "Aktionen",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  false,
        limitFunc = function(ply) return true end,
        applyFunc = function(ply) 
        
                local entit = ents.Create("prop_physics")
                entit:SetModel("models/props_phx/misc/soccerball.mdl")
                entit:SetPos(ply:GetEyeTrace().HitPos+Vector(0,0,10))
                entit:Spawn()
                undo.Create("prop")
                undo.AddEntity(entit)
                undo.SetPlayer(ply)
               undo.Finish()
                ply:ChatPrint("*** Du hast jetzt einen Fuball. Du kannst ihn mit (Z) entfernen.")

        end,
        iconFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,"models/props_phx/misc/soccerball.mdl") end,
        previewFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,"models/props_phx/misc/soccerball.mdl") end,
    }



    function AOCRP.GTM:GetDroidAmount()
        local currentCount = 0
        for k,v in ipairs(player.GetAll()) do 
            if v:GetNetVar("AOCRP_DroidEvchr", false) then
                currentCount = currentCount + 1
            end
        end 
        return currentCount
    end

    function AOCRP.GTM:GetEvchrMode()
        return GetGlobalNetVar( "AOCRP_EvchrMode", 1 )
    end

    function AOCRP.GTM:droidEvchr() 


        local count = 0
        local limit = GetGlobalNetVar( "AOCRP_EvchrDroid", 0 )
        local current = AOCRP.GTM:GetDroidAmount()


        if current >= limit then return false end

        return true
    end

    AOCRP.GTM.Items["eventchars_b1"] = {
        name = "B1 Kampfdroide",
        desc = "Spiele einen B1-Kampfdroiden (begrenzt)",
        price = 1000,
        category = "Eventcharaktere",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  false,
        limitFunc = function(ply) return AOCRP.GTM:droidEvchr() and AOCRP.GTM:GetEvchrMode() == 1  end,
        applyFunc = function(ply) AOCRP.GTM:DoDroidEventChar(ply, "b1", 1000) end,
        iconFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,"models/cis_npc/b1_battledroids/assault/b1_battledroid_assault.mdl") end,
        previewFunc = function(panel)  AOCRP.GTM:doSpawnIcon(panel,"models/cis_npc/b1_battledroids/assault/b1_battledroid_assault.mdl") end,
    }

    AOCRP.GTM.Items["eventchars_bx"] = {
        name = "BX Kommandodroide",
        desc = "Spiele einen BX Kommandodroiden (begrenzt)",
        price = 10000,
        category = "Eventcharaktere",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  true,
        limitFunc = function(ply) return AOCRP.GTM:droidEvchr() and AOCRP.GTM:GetEvchrMode() == 1  end,
        applyFunc = function(ply) AOCRP.GTM:DoDroidEventChar(ply, "bx", 10000) end,
        iconFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,"models/player/cheddar/commando_droid/bx_commando_droid.mdl") end,
        previewFunc = function(panel)  AOCRP.GTM:doSpawnIcon(panel,"models/player/cheddar/commando_droid/bx_commando_droid.mdl") end,
    }

    AOCRP.GTM.Items["eventchars_bxcpt"] = {
        name = "BX Captain",
        desc = "Spiele einen BX Captain (begrenzt)",
        price = 15000,
        category = "Eventcharaktere",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  true,
        limitFunc = function(ply) return AOCRP.GTM:droidEvchr() and AOCRP.GTM:GetEvchrMode() == 1  end,
        applyFunc = function(ply) AOCRP.GTM:DoDroidEventChar(ply, "bxcpt", 15000) end,
        iconFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,"models/player/cheddar/commando_droid/bx_commando_droid.mdl") end,
        previewFunc = function(panel)  AOCRP.GTM:doSpawnIcon(panel,"models/player/cheddar/commando_droid/bx_commando_droid.mdl") end,
    }


    AOCRP.GTM.Items["eventchars_droideka"] = {
        name = "Droideka",
        desc = "Spiele einen Droideka (begrenzt)",
        price = 18000,
        category = "Eventcharaktere",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  true,
        limitFunc = function(ply) return AOCRP.GTM:droidEvchr() and AOCRP.GTM:GetEvchrMode() == 1  end,
        applyFunc = function(ply) AOCRP.GTM:DoDroidEventChar(ply, "droideka", 18000) end,
        iconFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,"models/starwars/stan/droidekas/droideka.mdl") end,
        previewFunc = function(panel)  AOCRP.GTM:doSpawnIcon(panel,"models/starwars/stan/droidekas/droideka.mdl") end,
    }

    AOCRP.GTM.Items["eventchars_b2"] = {
        name = "B2 Kampfdroide",
        desc = "Spiele einen B2-Kampfdroiden (begrenzt)",
        price = 5000,
        category = "Eventcharaktere",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  true,
        limitFunc = function(ply) return AOCRP.GTM:droidEvchr() and AOCRP.GTM:GetEvchrMode() == 1 end,
        applyFunc = function(ply) AOCRP.GTM:DoDroidEventChar(ply, "b2", 5000) end,
        iconFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,"models/player/hydro/b2_battledroid/b2_battledroid.mdl") end,
        previewFunc = function(panel)  AOCRP.GTM:doSpawnIcon(panel,"models/player/hydro/b2_battledroid/b2_battledroid.mdl") end,
    }

    AOCRP.GTM.Items["eventchars_b1heavy"] = {
        name = "B1 Heavy Kampfdroide",
        desc = "Spiele einen B1-Kampfdroiden (begrenzt)",
        price = 5000,
        category = "Eventcharaktere",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  true,
        limitFunc = function(ply) return AOCRP.GTM:droidEvchr() and AOCRP.GTM:GetEvchrMode() == 1  end,
        applyFunc = function(ply) AOCRP.GTM:DoDroidEventChar(ply, "b1heavy", 5000) end,
        iconFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,"models/cis_npc/b1_battledroids/heavy/b1_battledroid_heavy.mdl") end,
        previewFunc = function(panel)  AOCRP.GTM:doSpawnIcon(panel,"models/cis_npc/b1_battledroids/heavy/b1_battledroid_heavy.mdl") end,
    }


    AOCRP.GTM.Items["eventchr_einwohner"] = {
        name = "Einwohner",
        desc = "Spiele einen Einwohner (begrenzt)",
        price = 1000,
        category = "Eventcharaktere",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  false,
        limitFunc = function(ply) return AOCRP.GTM:droidEvchr() and AOCRP.GTM:GetEvchrMode() == 2  end,
        applyFunc = function(ply) AOCRP.GTM:DoDroidEventChar(ply, "einwohner", 1000) end,
        iconFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,"models/npc_hcn/starwars/bf/weequay/weequay.mdl") end,
        previewFunc = function(panel)  AOCRP.GTM:doSpawnIcon(panel,"models/npc_hcn/starwars/bf/weequay/weequay.mdl") end,
    }
    
    AOCRP.GTM.Items["eventchr_aufstand"] = {
        name = "Bewaffneter Aufstndischer",
        desc = "Spiele einen Angreifer (begrenzt)",
        price = 1000,
        category = "Eventcharaktere",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  false,
        limitFunc = function(ply) return AOCRP.GTM:droidEvchr() and AOCRP.GTM:GetEvchrMode() == 3  end,
        applyFunc = function(ply) AOCRP.GTM:DoDroidEventChar(ply, "aufstndiger", 1000) end,
        iconFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,"models/npc_hcn/starwars/bf/weequay/weequay.mdl") end,
        previewFunc = function(panel)  AOCRP.GTM:doSpawnIcon(panel,"models/npc_hcn/starwars/bf/weequay/weequay.mdl") end,
    }
    AOCRP.GTM.Items["eventchr_schweraufstand"] = {
        name = "Bewaffneter Aufstndischer (MG)",
        desc = "Spiele einen Angreifer (begrenzt)",
        price = 5000,
        category = "Eventcharaktere",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  false,
        limitFunc = function(ply) return AOCRP.GTM:droidEvchr() and AOCRP.GTM:GetEvchrMode() == 3  end,
        applyFunc = function(ply) AOCRP.GTM:DoDroidEventChar(ply, "schwaufstand", 5000) end,
        iconFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,"models/npc_hcn/starwars/bf/weequay/weequay.mdl") end,
        previewFunc = function(panel)  AOCRP.GTM:doSpawnIcon(panel,"models/npc_hcn/starwars/bf/weequay/weequay.mdl") end,
    }

    AOCRP.GTM.Items["eventchar_zvk"] = {
        name = "Ziviler Kampfdroide",
        desc = "Spiele einen Droiden (begrenzt)",
        price = 10000,
        category = "Eventcharaktere",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  true,
        limitFunc = function(ply) return AOCRP.GTM:droidEvchr() and AOCRP.GTM:GetEvchrMode() == 3  end,
        applyFunc = function(ply) AOCRP.GTM:DoDroidEventChar(ply, "zivkampfdroid", 10000) end,
        iconFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,"models/player/swtor/droids/enforcerdroid.mdl") end,
        previewFunc = function(panel)  AOCRP.GTM:doSpawnIcon(panel,"models/player/swtor/droids/enforcerdroid.mdl") end,
    }


    if SERVER then
        util.AddNetworkString("AOCRP.GTM.RecieveCloneID")
        util.AddNetworkString("AOCRP.GTM.RequestCloneID")
        util.AddNetworkString("AOCRP.GTM.RequestZivName")
        util.AddNetworkString("AOCRP.GTM.RecieveZivName")

        net.Receive( "AOCRP.GTM.RecieveCloneID", function( len, ply )
            local idstr = net.ReadString()
            local cloneid = tonumber(idstr)

            if !isnumber(cloneid) then return end
            if cloneid < 111111 or cloneid > 999999 then ply:ChatPrint("*** Die neue ID muss zwischen 111111 und 999999 liegen.") return end

            AOCRP.CharSys:IsCloneIDFree(cloneid, function(free) 
                if free then
                    AOCRP.CharSys:PlayerChangeCloneID(ply, cloneid)
                else
                    ply:ChatPrint("*** Diese ID ist bereits vergeben.")
                    net.Start("AOCRP.GTM.RequestCloneID")
                    net.Send(ply)
                end
            end)
        end )

        net.Receive( "AOCRP.GTM.RecieveZivName", function( len, ply )
            
            local text = net.ReadString()

            if ply:GetNetVar("AOCRP_DroidEvchr", false) then
                ply:SetCloneName(text)
            end 
        end )
    end
    if CLIENT then
        
        
        net.Receive( "AOCRP.GTM.RequestCloneID", function( len, ply )
            AOCDerma:Derma_RequestString( "CloneID Anpassen", "Gebe deine Wunsch-ID an. Sie muss 6 Zahlen enthalten.", "Ok", function(text) 
            
                net.Start("AOCRP.GTM.RecieveCloneID")
                    net.WriteString(text)
                net.SendToServer()
                
            end )
        end )

        local function RequestZivName()
            AOCDerma:SmallStringRequest( "Whle einen Namen fr deinen Eventcharakter", function(text) 
                if #text < 3 then 
                    RequestZivName()
                    return
                end 

                net.Start("AOCRP.GTM.RecieveZivName")
                net.WriteString(text)
                net.SendToServer()
            end, "", "[^a-zA-Z%s]", function() 
                RequestZivName()
            end )
        end
                
        net.Receive( "AOCRP.GTM.RequestZivName", function( len, ply )

            RequestZivName()
    
        end )

   
    end

    AOCRP.GTM.Items["singletime_cloneid"] = {
        name = "Klon-ID ndern",
        desc = "ndere deine ID.",
        price = 1,
        category = "Aktionen",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  false,
        limitFunc = function(ply) return table.HasValue(AOCRP.Config.CloneID, ply:GetUserGroup()) or ply:GetAOCVIP() end,
        applyFunc = function(ply) 
    
           net.Start("AOCRP.GTM.RequestCloneID")
           net.Send(ply)

        end,
        iconFunc = function(panel) AOCRP.GTM:doImgurIcon(panel,"Fpr11IH") end,
        previewFunc = function(panel) AOCRP.GTM:doImgurIcon(panel,"Fpr11IH") end,
    }
 

    local GTM_Attachments_Color = {}
--[[     GTM_Attachments_Color["blaster_aqua"] = {vipfree = true, price = 80000, icon = "cs574/impacts/sw_laser_bit_aqua", name = "Aqua", tracer = "rw_sw_laser_aqua", impact = "rw_sw_impact_aqua"}
    GTM_Attachments_Color["blaster_black"] = {vipfree = false, price = 1000000, icon = "cs574/impacts/sw_laser_bit_black", name = "Unsichtbar", tracer = "rw_sw_laser_black", impact = "rw_sw_impact_black"}
    GTM_Attachments_Color["blaster_grey"] = {vipfree = true, price = 30000, icon = "cs574/impacts/sw_laser_bit_grey", name = "Grau", tracer = "rw_sw_laser_grey", impact = "rw_sw_impact_grey"}
    GTM_Attachments_Color["blaster_orange"] = {vipfree = true, price = 100000, icon = "cs574/impacts/sw_laser_bit_orange", name = "Orange", tracer = "rw_sw_laser_orange", impact = "rw_sw_impact_orange"}
    GTM_Attachments_Color["blaster_green"] = {vipfree = true, price = 100000, icon = "effects/sw_laser_green_front", name = "Grn", tracer = "effect_sw_laser_green", impact = "rw_sw_impact_blue"}
    GTM_Attachments_Color["blaster_white"] = {vipfree = true, price = 200000, icon = "effects/sw_laser_white_front", name = "Wei", tracer = "effect_sw_laser_white", impact = "rw_sw_impact_blue"}
    GTM_Attachments_Color["blaster_yellow"] = {vipfree = true, price = 200000, icon = "effects/sw_laser_yellow_front", name = "Gelb", tracer = "effect_sw_laser_yellow", impact = "rw_sw_impact_blue"}

 ]]


    
    for k, v in pairs(GTM_Attachments_Color) do
        local ATTACHMENT = {}


        ATTACHMENT.Name = v.name
        ATTACHMENT.ShortName = "BF" --Abbreviation, 5 chars or less please
        ATTACHMENT.Description = { 
            TFA.AttachmentColors["="],"Im GTM erhltlich",
        }
        ATTACHMENT.Icon = v.icon --Revers to label, please give it an icon though!  This should be the path to a png, like "entities/tfa_ammo_match.png"


        ATTACHMENT.WeaponTable = {
            ["TracerName"] = v.tracer,
            ["ImpactEffect"] = v.impact,
        }


        function ATTACHMENT:CanAttach(wep)
            return AOCRP.GTM:HasItem(wep:GetOwner(), k)
        end

        function ATTACHMENT:Attach(wep)
        end

        function ATTACHMENT:Detach(wep)
        end


        TFA.Attachments.Register(k, ATTACHMENT)
        ATTACHMENT = nil


        AOCRP.GTM.Items[k] = {
            name = v.name,
            desc = "ndert die Farbe deines Schusses. \n Muss im C-Men der Waffe ausgewhlt werden",
            price = v.price,
            category = "Blasterfarben",
            apply = false,
            permanent = true,
            canSell = true,
            canBuy = true,
            vipFree = v.vipfree,
            vipOnly =  false,
            limitFunc = function(ply) return true end,
            applyFunc = function(ply) end,
            iconFunc = function(panel) AOCRP.GTM:doMaterialIcon(panel,v.icon) end,
            previewFunc = function(panel) AOCRP.GTM:doMaterialIcon(panel,v.icon) end,
        }
    

    end


    local function IsInNewYearRange()
        -- Hole die aktuelle Zeit
        local currentTime = os.time()
        
        -- Erstelle die Zeitpunkte fr den Beginn und das Ende des Zeitraums
        local startRange = os.time({year = 2025, month = 1, day = 1, hour = 0, min = 1, sec = 0})
        local endRange = os.time({year = 2025, month = 1, day = 1, hour = 0, min = 10, sec = 0})
    
        -- Prfe, ob die aktuelle Zeit im Bereich liegt
        return currentTime >= startRange and currentTime <= endRange
    end

    AOCRP.GTM.Items["ribbon_2025"] = {
        name = "Tag des Lichts 2025",
        desc = "Nur innerhalb von 10min des Neujahres 2025 kaufbar.",
        price = 0,
        category = "Ribbons",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = false,
        vipFree = false,
        vipOnly =  false,
        limitFunc = function(ply) return true end,
        applyFunc = function(ply) 
            if IsInNewYearRange() then
                AOCRP.Ribbons:GTMGiveRibbon(ply, 46)
            else 
                local currentTime = os.time()

                -- Konvertiere den Zeitstempel in ein lesbares Format
                local readableTime = os.date("%d-%m-%Y %H:%M:%S", currentTime)
                ply:ChatPrint("*** Das Ribbon kannst du nur am 01.01.2025 von 00:01 bis 00:10 kaufen. Aktuell ist es der "..readableTime)
            end
        end,
        iconFunc = function(panel) AOCRP.GTM:doRibbon(panel,"T2vd1Ya") end,
        previewFunc = function(panel) AOCRP.GTM:doRibbon(panel,"T2vd1Ya") end,
    }



    AOCRP.GTM.Items["ribbon_fox"] = {
        name = "Sonderorden - Fox",
        desc = "Bestich Commander Fox fr einzigartiges Ribbon.",
        price = 10000000,
        category = "Ribbons",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  false,
        limitFunc = function(ply) return true end,
        applyFunc = function(ply) 

            AOCRP.Ribbons:GTMGiveRibbon(ply, 7)

        end,
        iconFunc = function(panel) AOCRP.GTM:doRibbon(panel,"m8qSjvH") end,
        previewFunc = function(panel) AOCRP.GTM:doRibbon(panel,"m8qSjvH") end,
    }


    AOCRP.GTM.Items["ribbon_vip"] = {
        name = "VIP",
        desc = "Claime diesen Ribbon fr dein aktuellen Char",
        price = 0,
        category = "Ribbons",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  false,
        limitFunc = function(ply) return ply:GetAOCVIP() end,
        applyFunc = function(ply) 
            AOCRP.Ribbons:GTMGiveRibbon(ply, 2)
        end,
        iconFunc = function(panel) AOCRP.GTM:doRibbon(panel,"pfyyO8H") end,
        previewFunc = function(panel) AOCRP.GTM:doRibbon(panel,"pfyyO8H") end,
    }

    AOCRP.GTM.Items["ribbon_old_dono"] = {
        name = "Veteran",
        desc = "Claime diesen Ribbon fr dein aktuellen Char",
        price = 0,
        category = "Ribbons",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  false,
        limitFunc = function(ply) local donators = {"Donator_T1", "Donator_T2", "Donator_T3"}
            return table.HasValue(donators, ply:GetUserGroup())  end,
        applyFunc = function(ply) 
            AOCRP.Ribbons:GTMGiveRibbon(ply, 3)
        end,
        iconFunc = function(panel) AOCRP.GTM:doRibbon(panel,"zrwHLS8") end,
        previewFunc = function(panel) AOCRP.GTM:doRibbon(panel,"zrwHLS8") end,
    }


    AOCRP.GTM.Items["ribbon_team"] = {
        name = "Teammitglied",
        desc = "Claime diesen Ribbon fr dein aktuellen Char",
        price = 0,
        category = "Ribbons",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  false,
        limitFunc = function(ply) return AOCRP.Admin:IsTeamMember(ply) end,
        applyFunc = function(ply) 
            AOCRP.Ribbons:GTMGiveRibbon(ply, 5)
        end,
        iconFunc = function(panel) AOCRP.GTM:doRibbon(panel,"QaTYavt") end,
        previewFunc = function(panel) AOCRP.GTM:doRibbon(panel,"QaTYavt") end,
    }


    AOCRP.GTM.Items["ribbon_ausbilder"] = {
        name = "Ausbilder",
        desc = "Claime diesen Ribbon fr dein aktuellen Char",
        price = 0,
        category = "Ribbons",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  false,
        limitFunc = function(ply) return ply:GetAusbilder() end,
        applyFunc = function(ply) 
            AOCRP.Ribbons:GTMGiveRibbon(ply, 4)
        end,
        iconFunc = function(panel) AOCRP.GTM:doRibbon(panel,"eWSR5tH") end,
        previewFunc = function(panel) AOCRP.GTM:doRibbon(panel,"eWSR5tH") end,
    }


    AOCRP.GTM.Items["ribbon_reich"] = {
        name = "Monopolorden",
        desc = "Claime diesen Ribbon fr dein aktuellen Char",
        price = 0,
        category = "Ribbons",
        apply = true,
        permanent = false,
        canSell = false,
        canBuy = true,
        vipFree = false,
        vipOnly =  false,
        limitFunc = function(ply) return ply:getMoney() > 999999 end,
        applyFunc = function(ply) 
            AOCRP.Ribbons:GTMGiveRibbon(ply, 15)
        end,
        iconFunc = function(panel) AOCRP.GTM:doRibbon(panel,"waWSdOj") end,
        previewFunc = function(panel) AOCRP.GTM:doRibbon(panel,"waWSdOj") end,
    }

--[[     AOCRP.Ribbons.HardCoded = {}
    AOCRP.Ribbons.HardCoded["vip"] = 2
    AOCRP.Ribbons.HardCoded["donator"] = 3
    AOCRP.Ribbons.HardCoded["ausbilder"] = 4
    AOCRP.Ribbons.HardCoded["team"] = 5
    AOCRP.Ribbons.HardCoded["richest"] = 15
    
    


        -- Feste Ribbons

        if ply:GetAOCVIP() then
            table.insert(ribbons, AOCRP.Ribbons.HardCoded["vip"])
        end

        if ply:GetAusbilder() then
            table.insert(ribbons, AOCRP.Ribbons.HardCoded["ausbilder"])
        end

        if ply == getRichestPlayer() then 
            table.insert(ribbons, AOCRP.Ribbons.HardCoded["richest"])
        end 

        local donators = {"Donator_T1", "Donator_T2", "Donator_T3"}
        if table.HasValue(donators, ply:GetUserGroup()) then
            table.insert(ribbons, AOCRP.Ribbons.HardCoded["donator"])
        end

        if AOCRP.Admin:IsTeamMember(ply) then
            table.insert(ribbons, AOCRP.Ribbons.HardCoded["team"])
        end

 ]]

--[[ function AOCRP.GTM:GetZivCount()

    local count = 0

    count = count + AOCRP.Gear:GetCurrentCount(259)
    count = count + AOCRP.Gear:GetCurrentCount(304)
    return count
end

function AOCRP.GTM:GetMaxZiv()
    return GetGlobalNetVar( "AOCRP_ZIVMAX", 0)
end

if SERVER then 

    function AOCRP.GTM:BecomeZiv(ply, gear)

        if AOCRP.GTM:GetZivCount() < AOCRP.GTM:GetMaxZiv() then


            ply:SetGearID(gear)
            ply:ApplyGear()
            ply:SetUnitID(10)

            ply:SetHideCloneID(true)
            ply:SetRankID(0)
            ply:Spawn()

            
            ply.KickOutOfCharOnRespawn = true 

        end
    end
end 

 AOCRP.GTM.Items["zivs"] = {
    name = "Zivilist",
    desc = "Spiele einen Zivilisten.",
    price = 5000,
    category = "Temporre Charaktere",
    apply = true,
    permanent = false,
    canSell = false,
    canBuy = true,
    vipFree = true,
    vipOnly =  false,
    limitFunc = function(ply) return AOCRP.GTM:GetZivCount() < AOCRP.GTM:GetMaxZiv() end,
    applyFunc = function(ply) AOCRP.GTM:BecomeZiv(ply, 259) end,
    iconFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,"models/hcn/starwars/bf/human/human_male_4.mdl") end,
    previewFunc = function(panel) AOCRP.GTM:doSpawnIcon(panel,"models/hcn/starwars/bf/human/human_male_4.mdl") end,
}
 ]]

--addons/wos-passiveevent-ageo/lua/wos/pes/vgui/wos_calendar.lua:

local PANEL = {}

local time = {
	Second = 1,
	Minute = 60,
	Hour = 60*60,
	Day = 60*60*24
}

function PANEL:Init()

	local dash = vgui.Create("DPanel", self)
	dash:Dock(TOP)
	dash:SetTall(60)

	timer.Simple(0, function()
		local size = math.floor(dash:GetWide() / (table.Count(time) *2))
		self:GetParent():SetWide(size*(table.Count(time) *2))
		self:GetParent():Center()
		for index, time in SortedPairsByValue(time, true) do
			local timebutton = vgui.Create("DButton", dash)
			timebutton:Dock(LEFT)
			timebutton:SetWide(size)
			timebutton:DockMargin(0,0,0,0)
			timebutton:SetText("-1 " .. index)
			timebutton.DoClick = function()
				self.time = math.max(self.time - time, 0)
			end
		end

		for index, time in SortedPairsByValue(time) do
			local timebutton = vgui.Create("DButton", dash)
			timebutton:SetWide(size)
			timebutton:Dock(LEFT)
			timebutton:DockMargin(0,0,0,0)
			
			timebutton:SetText("+1 " .. index)
			timebutton.DoClick = function()
				self.time = math.max(self.time + time, 0)
			end
		end
	end)

	self.time = 0
end

function PANEL:GetTime()
	return os.time() + self.time
end

function PANEL:Paint(w, h)
	surface.SetDrawColor(0,0,0)
	surface.DrawRect(0,0, w ,h)
	local date = os.date( "%Y/%m/%d  %H:%M:%S", self.time + os.time())

	draw.SimpleText(date, "DermaDefault", w/2, 60 + (h - 60)/2, color_white, 1, 1 )
end

vgui.Register( "wOSCalendar", PANEL, "Panel" )
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/list.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "List"
VAR.DirtyValidate = true
VAR.IsValid = function(varTable, value)
    if not istable(value) then
        return false
    end

    for _, entry in pairs(value) do
        if not isstring(entry) then
            return false
        end
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local listView = vgui.Create("DListView")
    listView:SetTall(200)
    listView:SetMultiSelect(true)
    
    if istable(value) then
        listView.SelectedValues = value
    elseif istable(varTable.Default) then
        listView.SelectedValues = varTable.Default
    else
        listView.SelectedValues = {}
    end

    if isstring(varTable.Header) then
        listView:AddColumn(varTable.Header)
    else
        listView:AddColumn("Multi-Select")
    end
    
    if isstring( varTable.Values ) and string.Left(varTable.Values, 6) == "FUNC::" then
        local func_name = string.Replace( varTable.Values, "FUNC::", "" )
        local layers = string.Split( func_name, "." )

        local func = _G
        for _, layer in ipairs( layers ) do
            func = func[ layer ] 
        end
        varTable.Values = func()

    end

    for _, entry in pairs(varTable.Values or {}) do
        local line = listView:AddLine(entry)
        if table.HasValue(listView.SelectedValues, entry) then
            line:SetSelected(true)
        end
    end

    function listView:OnRowRightClick(index, line)
        line:SetSelected(false)

        table.RemoveByValue(listView.SelectedValues, line:GetValue(1))
    end
    function listView:OnRowSelected(index, line)
        line:SetSelected(true)

        -- Keeping Everything active.
        for k, otherLine in pairs(self:GetLines()) do
            if table.HasValue(listView.SelectedValues, otherLine:GetValue(1)) then
                otherLine:SetSelected(true)
            end
        end

        if table.HasValue( listView.SelectedValues, line:GetValue(1) ) then return end
        table.insert(listView.SelectedValues, line:GetValue(1))
        
    end

    return listView
end

VAR.GetValue = function(listView)
    return listView.SelectedValues
end

return VAR
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/tentitydatacopy.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--



local VAR = {}

VAR.Name = "TableEntityData"
VAR.DirtyValidate = true

VAR.ToolTips = {
    { text = "Add the entity data of the entity you are aiming at to the list", key = "gui/lmb.png", },
    { text = "Remove the last added entity data from the list", key = "gui/rmb.png", },
}

VAR.IsValid = function(varTable, value)

    if varTable.Internal then return false end
    if not value or #value < 1 then
        return false
    end
    
    for index, data in pairs(value) do
        if not data.Index then continue end
        local ent = ents.GetByIndex(data.Index)
        if IsValid(ent) then
            if ent:CreatedByMap() then continue end
            value[index] = wOS.PES.ReadEntity(ent)
        end
    end

    return true
end

VAR.UseTool = true

local function OpenOverlayEditor( id, vardata, base_panel )
    local panel = vgui.Create("DPanel")
    panel:SetSize( ScrW(), ScrH() )
    panel.Think = function( pan ) if not IsValid( base_panel ) then pan:Remove() end end
    panel.Paint = function( pan, ww, hh )
        draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
    end
    panel:MakePopup()

    local frame = vgui.Create( "DFrame", panel )
    frame:ShowCloseButton( true )
    frame:SetTitle("")
    frame:SetDraggable( false )
    frame:SetSize( ScrW()*0.25, ScrH()*0.4 )
    frame:Center()
    frame.OnClose = function( pan )
        panel:Remove()
    end
	frame.Think = function( pan )
		pan:MoveToFront()
	end
 
    local editor = vgui.Create( "WOS_PES_DATACOPY_EDITOR", frame )
    editor:Dock( FILL )
    editor:SetVariableData( vardata )
    editor:SetBasePanel( base_panel )

    local delete_butt = vgui.Create( "DButton", frame )
    delete_butt:SetText( "Delete Entity" )
    delete_butt:Dock( BOTTOM )
    delete_butt.DoClick = function( pan )
        base_panel.Data[ id ] = nil
        base_panel:RefreshList()
        panel:Remove()
    end

    local save_butt = vgui.Create( "DButton", frame )
    save_butt:SetText( "Save Changes" )
    save_butt:Dock( BOTTOM )
    save_butt.DoClick = function( pan )
        base_panel.Data[ id ] = editor:GetVariableData()
        base_panel:RefreshList()
        panel:Remove()
    end

end

VAR.DermaElement = function(varTable, varData)
    varData = varData or {}
    local panel = vgui.Create("DPanel")
    panel:SetTall( 180 )
    
    panel.Data = {}
    for index, data in pairs( varData ) do
        panel.Data[ index ] = data
    end

    local listView = vgui.Create("DListView", panel)
    listView:Dock( FILL )
    listView:AddColumn("Entity")
    listView.RefreshList = function( pan )
        pan:Clear()
        if not panel.Data or #panel.Data < 1 then
            pan:AddLine( "Entities needs to be selected!" )
            return
        end

        for id, edata in pairs( panel.Data or {} ) do
            local name = edata.Class or ( "Entity " .. edata.Index )
            local line = pan:AddLine( name )
            line.ID = id
            line.Data = edata
        end
        
    end

    listView.OnRowRightClick = function( pan, id, line )
       OpenOverlayEditor( line.ID, line.Data, panel )
    end

    listView:RefreshList()
    panel.RefreshList = function() listView:RefreshList() end

    return panel -- make multiple of these through a base panel
end

VAR.GetValue = function(dermaElement)
    if dermaElement.Data then
        //local ent = dermaElement.Data[1]
        --if IsValid(ent) then dermaElement:SetEntity(ent) end
        return dermaElement.Data
    end
end

VAR.PrimaryAttack = function(wep, ply, dermaElement)
    dermaElement.Data = dermaElement.Data || {}

    local ent = ply:GetEyeTrace().Entity
    if IsValid(ent) then
        local allowed = hook.Call( "wOS.CombatSim.CanPlaceEntity", nil, wep, ply, ent:GetPos() )
        if isbool( allowed ) and allowed == false then return end
        dermaElement.Data[#dermaElement.Data + 1] = {
            Position = ent:GetPos(),
            Index = ent:EntIndex()
        }
        ply:ChatPrint( "Entity Added: " .. ent:GetClass() )
        dermaElement:RefreshList()
    end
end

VAR.SecondaryAttack = function(wep, ply, dermaElement)
    dermaElement.Data = dermaElement.Data || {}
    dermaElement.Data[#dermaElement.Data] = nil
end

/*
		Angles	=	-0.125 104.219 0.125
		Class	=	prop_physics
		Color:
				a	=	255
				b	=	255
				g	=	255
				r	=	255
		Model	=	models/props_borealis/bluebarrel001.mdl
		Pos	=	-3299.468750 -2135.687500 90.125000
		SubMaterials:
*/

VAR.Draw3D = function(wep, ply, element)
    local tVec = element.Data || {}

    for index, ent in ipairs(tVec) do
        if not isvector(ent.Position) then continue end

        local vec = ent.Position

        local top = Vector(vec.x, vec.y, vec.z + 200)
        render.DrawLine(vec, top, Color(255, 255, 255), false)
    end
end

return VAR

--addons/wos-passiveevent-ageo/lua/wos/pes/core/cl_net.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































wOS = wOS || {}
wOS.PES = wOS.PES || {}
wOS.PES.Triggers = wOS.PES.Triggers || {}
wOS.PES.Triggers.Data = wOS.PES.Triggers.Data || {}
wOS.PES.Nodes = wOS.PES.Nodes || {}
wOS.PES.Nodes.Data = wOS.PES.Nodes.Data || {}

local function QuickSort( a, b )
    return a[2] < b[2]
end

net.Receive("wOS.PES.Triggers.Sync",function()
    local size = net.ReadUInt( 32 )
    wOS.PES.Triggers.Data = wOS.SFS_EXTERN:Decompress( net.ReadData( size ) )
end)

net.Receive("wOS.PES.Nodes.Sync",function()

    local size = net.ReadUInt( 32 )
    wOS.PES.Nodes.Data = wOS.SFS_EXTERN:Decompress( net.ReadData( size ) )

	// We're gonna do the sorting clientside because really it only effects the client
	for name, data in pairs( wOS.PES.Nodes.Data ) do
		if not data.Vars then continue end

		local sort_tbl = {}

		for name, dat in pairs( data.Vars ) do
			table.insert( sort_tbl, { name, dat.ID } )
		end

		table.sort( sort_tbl, QuickSort )

		data.SortedVars = {}
        for _, dat in ipairs( sort_tbl ) do
            table.insert( data.SortedVars, dat[1] )
        end
	end

end)

/*
	Name: wOS.PES.NetworkEvent(event)
	Description: Networks an event in a header and body packets to the server
	Args: EventData event
	Returns: None
*/
function wOS.PES.NetworkEvent(event)
    if not event then return end

    event.Compressed = nil

    net.Start("wOS.PES.EventHeader")
        net.WriteString(event.Name)
        net.WriteString(event.oldname)
        net.WriteDouble(#event.Nodes)
		net.WriteString(event.Description)
        net.WriteBool(event.Importable)
        net.WriteBool(event.Export)
        net.WriteDouble(event.random or -1)
    net.SendToServer()

    local nodestring = wOS.SFS_EXTERN:Compress( event.Nodes )

    local NET_CAP = 55000
    if #nodestring < NET_CAP then
        net.Start( "wOS.PES.Node" )
            net.WriteString( event.Name )
            net.WriteUInt( 1, 32 )
            net.WriteUInt( 1, 32 )
            net.WriteUInt( #nodestring, 32 )
            net.WriteData( nodestring )
        net.SendToServer()
        return
    end

    local total_segments = math.ceil( #nodestring / NET_CAP )

    for i=1, total_segments do
        local lim
        if i != total_segments then
            lim = i*NET_CAP
        end
        local str = string.sub( nodestring, ( (i - 1)*NET_CAP ) + 1, lim )
        timer.Simple( (i-1)*0.5, function()
            net.Start( "wOS.PES.Node" )
                net.WriteString( event.Name )
                net.WriteUInt( total_segments, 32 )
                net.WriteUInt( i, 32 )
                net.WriteUInt( #str, 32 )
                net.WriteData( str )    
            net.SendToServer()
        end )    
    end

    -- net.Start("wOS.PES.Node")
    --     net.WriteString( event.Name )
    --     net.WriteUInt( #nodestring, 32 )
    --     net.WriteData( nodestring )
    -- net.SendToServer()

end

function wOS.PES.NetworkSimulation(event)
    if not event then return end

    event.Compressed = nil

    net.Start("wOS.CSS.SimulationHeader")
        net.WriteString(event.Name)
        net.WriteString(event.oldname)
        net.WriteDouble(#event.Nodes)
		net.WriteString(event.Description)
        net.WriteBool(event.Importable)
        net.WriteBool(event.Export)
		net.WriteTable(event.Settings)
    net.SendToServer()

    local nodestring = wOS.SFS_EXTERN:Compress( event.Nodes )

    local NET_CAP = 55000
    if #nodestring < NET_CAP then
        net.Start( "wOS.CSS.Node" )
            net.WriteString( event.Name )
            net.WriteUInt( 1, 32 )
            net.WriteUInt( 1, 32 )
            net.WriteUInt( #nodestring, 32 )
            net.WriteData( nodestring )
        net.SendToServer()
        return
    end

    local total_segments = math.ceil( #nodestring / NET_CAP )

    for i=1, total_segments do
        local lim
        if i != total_segments then
            lim = i*NET_CAP
        end
        local str = string.sub( nodestring, ( (i - 1)*NET_CAP ) + 1, lim )
        timer.Simple( (i-1)*0.5, function()
            net.Start( "wOS.CSS.Node" )
                net.WriteString( event.Name )
                net.WriteUInt( total_segments, 32 )
                net.WriteUInt( i, 32 )
                net.WriteUInt( #str, 32 )
                net.WriteData( str )    
            net.SendToServer()    
        end )
    end

    -- net.Start("wOS.CSS.Node")
    --     net.WriteString( event.Name )
    --     net.WriteUInt( #nodestring, 32 )
    --     net.WriteData( nodestring )
    -- net.SendToServer()

end

/*
	Name: wOS.PES.RequestEventList(callback)
	Description: Requests the event list from the server and calls the callback function
	Args: function callback
	Returns: None
*/
function wOS.PES.RequestEventList(callback)

    callback = callback or function() end

    net.Start("wOS.PES.EventList")
        net.WriteString("")
    net.SendToServer()

    net.Receive("wOS.PES.EventList",function()
        local missionNames = net.ReadTable()
        callback(missionNames)
    end)
end

function wOS.PES.RequestAdminSync(id, callback)
	net.Start("wOS.PES.Admin.Sync")
		net.WriteUInt( id, 32 )
	net.SendToServer()

	net.Receive("wOS.PES.Admin.Sync", callback)
end

function wOS.PES.RequestOpenAdminPreMenu()

	net.Start("wOS.PES.RequestPreAdminMenu")
	net.SendToServer()

	net.Receive("wOS.PES.RequestPreAdminMenu", function()
		local events = net.ReadTable()
		wOS.PES:OpenAdminActiveList( events )
	end)
end

function wOS.PES.RequestOpenAdminViewer( id )

	net.Start("wOS.PES.RequestAdminMenu")
		net.WriteUInt( id, 32 )
	net.SendToServer()

	net.Receive("wOS.PES.RequestAdminMenu", function()
		local nodes = net.ReadActivePESEvent()
		wOS.PES:OpenAdminEventViewer(id, nodes)
	end)
end

function wOS.PES.RequestSchedule(callback)
	net.Start("wOS.PES.RequestSchedule")
	net.SendToServer()

	net.Receive("wOS.PES.RequestSchedule", function()
		local eventCount = net.ReadUInt(16)

		local eventList = {}

		for x = 1, eventCount do
			local name = net.ReadString()
			local map = net.ReadString()
			local time = net.ReadUInt(32)

			eventList[x] = {
				Name = name,
				Time = time,
				Map = map,
			}
		end

		callback(eventList)
	end)
end

function wOS.PES.RequestStop( id )
	net.Start("wOS.PES.RequestStop")
		net.WriteUInt( id, 32 )
	net.SendToServer()
end

function wOS.PES.RequestEventData(name, callback)
    if not name then return end

    callback = callback or function() end

    local checksum = CurTime()

    net.Start("wOS.PES.RequestEventData")
        net.WriteString(name)
        net.WriteDouble(checksum)
    net.SendToServer()

    local event = {}

    local segments = {}

    net.Receive( "wOS.PES.EventDataNodes", function()

        if event.Processed then return end
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end

        local total_segments = net.ReadUInt( 32 )
        local current_segment = net.ReadUInt( 32 )

        local size = net.ReadUInt( 32 )
        local compressed = net.ReadData( size )
        segments[ current_segment ] = compressed

        if table.Count( segments ) < total_segments then return end

        local fcompressed = table.concat( segments )
        event, err = wOS.SFS_EXTERN:Decompress( fcompressed )

        event.Processed = true
        event.BackupNodeCount = nil

		callback(event)

    end )

    -- net.Receive("wOS.PES.EventDataPrepare",function()
    --     if event.Processed then return end
    --     local dChecksum = net.ReadDouble()
    --     if dChecksum != checksum then return end

    --     local header = net.ReadPESEventHeader()
    --     table.Merge( event, header )

    --     if not event.BackupNodeCount then return end
    --     if event.BackupNodeCount < event.NodeCount then return end
    --     event.Processed = true
    --     event.BackupNodeCount = nil
	-- 	callback(event)
    -- end)

end

function wOS.PES.GetImportableEvents(callback, full)

    local checksum = CurTime()
    net.Start( "wOS.PES.GetImportableEvents" )
        net.WriteBool( full or false )
        net.WriteDouble( checksum )
    net.SendToServer()

    net.Receive("wOS.PES.GetImportableEvents",function()
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end
        
		local events = net.ReadTable()
		callback(events)
    end)
end

function wOS.PES.GetImportableSimulations(callback)

    local checksum = CurTime()
    net.Start( "wOS.PES.GetImportableSimulations" )
        net.WriteDouble( checksum )
    net.SendToServer()

    net.Receive("wOS.PES.GetImportableSimulations",function()
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end
        
		local events = net.ReadTable()
		callback(events)
    end)
end

function wOS.PES.RequestSimulationData(name, callback, sim)
    if not name then return end

    callback = callback or function() end

    local checksum = CurTime()

    net.Start("wOS.CSS.RequestSimulationData")
        net.WriteUInt( sim or 0, 32 )
        net.WriteString(name)
        net.WriteDouble(checksum)
    net.SendToServer()

    local simdata = {
		Settings = {},
        Event = {},
    }

    local segments = {}
    
    net.Receive("wOS.CSS.SimDataNodes",function()
        if simdata.Processed then return end
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end

        local total_segments = net.ReadUInt( 32 )
        local current_segment = net.ReadUInt( 32 )

        local size = net.ReadUInt( 32 )
        local compressed = net.ReadData( size )
        segments[ current_segment ] = compressed

        if table.Count( segments ) < total_segments then return end

        local fcompressed = table.concat( segments )
        local eventz = wOS.SFS_EXTERN:Decompress( fcompressed )
        simdata.Event = eventz

        if table.Count( simdata.Settings ) < 1 then return end
        simdata.Processed = true
		callback(simdata)
    end)

    net.Receive( "wOS.CSS.SimDataPrepare", function()
        if simdata.Processed then return end
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end

        local header = net.ReadCSSSimulationHeader()
        table.Merge( simdata, header )

        if table.Count( simdata.Event ) < 1 then return end
        simdata.Processed = true
		callback(simdata)
    end )
    
end

function wOS.PES.RequestEventStart(eventName)
    if not eventName then return end
    net.Start("wOS.PES.RequestStart")
        net.WriteString(eventName)
    net.SendToServer()
end

function wOS.PES.RequestEventStartTime(eventName, time)
	net.Start("wOS.PES.RequestStartTime")
		net.WriteString(eventName)
		net.WriteDouble(time)
	net.SendToServer()
end

function wOS.PES.RequestTriggerStart(eventid, nodeid, triggerName)
	net.Start("wOS.PES.RequestTriggerStart")
		net.WriteUInt( eventid, 32 )
		net.WriteDouble(nodeid)
		net.WriteString(triggerName)
	net.SendToServer()
end

function wOS.PES.RequestURLImport(url, callback)
    if not url then return end

    callback = callback or function() end

    local checksum = CurTime()

    net.Start("wOS.PES.Import.RequestURLEvent")
        net.WriteString(url)
        net.WriteDouble(checksum)
    net.SendToServer()

    local event = {}
    local simdata = {
        Name = name,
		Description = "",
        Nodes = {},
		Settings = {},
        Count = 0,
    }

    local segments = {}

    net.Receive( "wOS.PES.EventDataNodes", function()

        if event.Processed then return end
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end

        local total_segments = net.ReadUInt( 32 )
        local current_segment = net.ReadUInt( 32 )

        local size = net.ReadUInt( 32 )
        local compressed = net.ReadData( size )
        segments[ current_segment ] = compressed

        if table.Count( segments ) < total_segments then return end

        local fcompressed = table.concat( segments )

        event = wOS.SFS_EXTERN:Decompress( fcompressed )
        event.Processed = true
        event.BackupNodeCount = nil

		callback(event)

    end )

    net.Receive("wOS.CSS.SimDataNodes",function()
        if simdata.Processed then return end
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end

        local total_segments = net.ReadUInt( 32 )
        local current_segment = net.ReadUInt( 32 )

        local size = net.ReadUInt( 32 )
        local compressed = net.ReadData( size )
        segments[ current_segment ] = compressed

        if table.Count( segments ) < total_segments then return end

        local fcompressed = table.concat( segments )
        local eventz = wOS.SFS_EXTERN:Decompress( fcompressed )
        simdata.Event = eventz

        if table.Count( simdata.Settings ) < 1 then return end
        simdata.Processed = true
		callback(simdata)
    end)

    net.Receive( "wOS.CSS.SimDataPrepare", function()
        if simdata.Processed then return end
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end

        local header = net.ReadCSSSimulationHeader()
        table.Merge( simdata, header )

        if table.Count( simdata.Event ) < 1 then return end
        simdata.Processed = true
		callback(simdata)
    end )

end

net.Receive( "wOS.PES.Import.URLError", function() 
    local msg = net.ReadString()
    surface.PlaySound( "buttons/button10.wav" )
    notification.AddLegacy( msg, NOTIFY_ERROR, 6 )
end )

net.Receive( "wOS.PES.Export.SendLink", function() 
    local msg = net.ReadString()
    surface.PlaySound( "buttons/button14.wav" )
    notification.AddLegacy( "[wOS-PES] Event was successfully exported to a URL! Check your chat for the link.", NOTIFY_GENERIC, 6 )
    chat.AddText( color_white, "[wOS-PES] Your event has been successfully exported to the following link: ", Color( 66, 117, 176 ), msg )
end )

net.Receive( "wOS.PES.Export.SendError", function() 
    local msg = net.ReadString()
    surface.PlaySound( "buttons/button10.wav" )
    notification.AddLegacy( "[wOS-PES] Event failed to be exported to URL. Check your chat for the error.", NOTIFY_ERROR, 6 )
    chat.AddText( color_white, "[wOS-PES] Your event failed to upload with the following error: ", Color( 255, 0, 0 ), msg )
end )



--addons/wos-passiveevent-ageo/lua/wos/css/entities/wos_simulation_wall/cl_wos_simulation_wall.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

local ENT = {}

ENT.Type 			= "anim"
ENT.Base 			= "base_anim"

ENT.Spawnable = false

-- Sets up the NetworkVars for the entity.
function ENT:SetupDataTables()
end

function ENT:ApplyCustomCollisions(vertices)
	self:SetSolid(SOLID_VPHYSICS)
	self:SetMoveType(MOVETYPE_NONE)

	self:EnableCustomCollisions(true)

	self:PhysicsInitMultiConvex(vertices)
end

hook.Add("PhysgunPickup", "wOS.CombatSim.PreventWallPickup", function(ply, ent)
	if IsValid(ent) and ent:GetClass() == "wos_simulation_wall" then
		return false
	end
end)

hook.Add("CanTool", "wOS.CombatSim.PreventWallToolgun", function(ply, tr)
	local ent = tr.Entity
	if IsValid(ent) and ent:GetClass() == "wos_simulation_wall" then
		return false
	end
end)

-- Clientside Initialize
function ENT:Initialize()
	net.Start("wOS.CombatSim.UpdateWallCollisions")
		net.WriteEntity(self)
	net.SendToServer()
end

-- Clientside Think
function ENT:Think()
end

-- Clientside OnRemove
function ENT:OnRemove()
end

-- Main Draw function.
function ENT:Draw()
end

scripted_ents.Register(ENT, "wos_simulation_wall")
--addons/wos-passiveevent-ageo/lua/wos/css/entities/wos_pes_basicobj/cl_wos_pes_basicobj.lua:
local ENT = {}

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.RenderGroup = RENDERGROUP_BOTH

ENT.PrintName		= "Generic Objective"
ENT.Author			= "wiltOS Technologies"
ENT.Contact			= "N/A"
ENT.Purpose			= "PES B"
ENT.Instructions	= "Grab and run"
ENT.Spawnable = false

function ENT:SetupDataTables()
    self:NetworkVar( "Entity", 0, "TargetPlayer" )
    self:NetworkVar( "String", 0, "FlagName" )

    if SERVER then
        self:SetTargetPlayer( NULL )
        self:SetFlagName( "Flag" )
    end
end

function ENT:Initialize()
	self:SetRenderBounds( vector_origin, vector_origin, Vector( 100, 100, 100 ) )
	self.HookName = "wOS.PES.FlagHalo." .. self:EntIndex()
	hook.Add("PreDrawHalos", self.HookName, function()
		if not IsValid( self ) then 
			hook.Remove( "PreDrawHalos", self.HookName )
			return
		end
		if !IsValid( self:GetTargetPlayer() ) then return end
		halo.Add( {self:GetTargetPlayer()}, Color( 255, 0, 0 ), 5, 5, 1 )
	end)

end

function ENT:OnRemove()
	hook.Remove( "PreDrawHalos", self.HookName )
end

function ENT:Draw()

	if IsValid(self:GetTargetPlayer()) then return end
	self:DrawModel()

end

function ENT:DrawTranslucent()
	if IsValid(self:GetTargetPlayer()) then return end

	local ang = EyeAngles()
	ang.p = 90
	ang.y = ang.y + 180
	ang.r = 0
	ang:RotateAroundAxis( ang:Up(), 90 )

	local mins, maxs = self:OBBMins(), self:OBBMaxs()
	local diff = maxs.z - mins.z

	cam.Start3D2D( self:GetPos() + self:GetUp()*diff*1.2, ang, 0.1 )
		draw.SimpleText( self:GetFlagName(), "wOS.PES.3DFont", 0, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	cam.End3D2D()
end

scripted_ents.Register(ENT, "wos_pes_basicobj")
--lua/weapons/antlion_katana/shared.lua:
SWEP.Author       = "Killua"
SWEP.PrintName    = "Antlion katana"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Ant"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack, Special +jump"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee2"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 50
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-47.778, 0, 0) }
}
SWEP.VElements = {
	["hils++"] = { type = "Model", model = "models/gibs/antlion_gib_large_2.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0.699, 0, 6), angle = Angle(90, 180, 0), size = Vector(0.1, 0.1, 0.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blade++"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-1.8, 0, 19), angle = Angle(165, 180, 90), size = Vector(0.029, 0.15, 0.029), color = Color(255, 255, 0, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(170, 170, 0, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-0.5, 0, 11), angle = Angle(175, 180, 90), size = Vector(0.029, 0.2, 0.029), color = Color(255, 255, 0, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/gibs/antlion_gib_large_2.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-0.7, 0, 6), angle = Angle(90, 0, 0), size = Vector(0.1, 0.1, 0.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, -45, 0), size = Vector(0.05, 0.039, 0.109), color = Color(170, 255, 0, 255), surpresslightning = false, material = "phoenix_storms/tiles2", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/tubes/tube1x1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-0.401, 0, 6), angle = Angle(5, 0, 0), size = Vector(0.019, 0.009, 0.15), color = Color(255, 255, 0, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["hils++"] = { type = "Model", model = "models/gibs/antlion_gib_large_2.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0.699, 0, 6), angle = Angle(90, 180, 0), size = Vector(0.1, 0.1, 0.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/gibs/antlion_gib_large_2.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-0.7, 0, 6), angle = Angle(90, 0, 0), size = Vector(0.1, 0.1, 0.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blade++"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-1.8, 0, 19), angle = Angle(165, 180, 90), size = Vector(0.029, 0.15, 0.029), color = Color(255, 255, 0, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(170, 170, 0, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-0.5, 0, 11), angle = Angle(175, 180, 90), size = Vector(0.029, 0.2, 0.029), color = Color(255, 255, 0, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(170, 180, 8), size = Vector(0.05, 0.039, 0.109), color = Color(170, 255, 0, 255), surpresslightning = false, material = "phoenix_storms/tiles2", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/tubes/tube1x1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-0.401, 0, 6), angle = Angle(5, 0, 0), size = Vector(0.019, 0.009, 0.15), color = Color(255, 255, 0, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} }
}






SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 31
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.26
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "Yellowblood"
SWEP.Primary.Range       = 16

SWEP.Secondary.Life        = true
SWEP.Secondary.Damage 	   = 62
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Antlion"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0
SWEP.SetJumpPower=205

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
self.Owner:SetJumpPower(self.SetJumpPower)
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Owner:SetJumpPower(self.SetJumpPower+20)
		self.SetJumpPower=self.SetJumpPower +25
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Owner:SetJumpPower(self.SetJumpPower+20)
		self.SetJumpPower=self.SetJumpPower +25
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--lua/weapons/antlion_knucle/shared.lua:
if CLIENT then
SWEP.DrawWeaponInfoBox = true
end

SWEP.Author       = "-CRY-minal-"
SWEP.Purpose      = "What did you do with him?"
SWEP.Instructions = "Kick their ass!"

SWEP.ShowWorldModel = false
SWEP.PrintName = "Antlion knuckle"
SWEP.Category = "Gluk Melee"
SWEP.Spawnable= true

SWEP.ViewModelFOV = 60
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip = false
SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.HoldType = "knife"

SWEP.AutoSwitchTo = true
SWEP.AutoSwitchFrom = false
SWEP.Weight = 0
SWEP.Slot = 0
SWEP.SlotPos = 0

SWEP.UseHands = true
SWEP.DrawAmmo = false
SWEP.Base = "weapon_base"

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Damage = 41
SWEP.Primary.DelayMiss = 0.7
SWEP.Primary.DelayHit = 0.9
SWEP.Primary.Force = 3000

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.ViewModelBoneMods = {
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}


SWEP.VElements = {
	["ant_gib"] = { type = "Model", model = "models/gibs/antlion_gib_large_1.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0.4, 2.5, 3.5), angle = Angle(0, 180, -90), size = Vector(0.039, 0.039, 0.039), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["ant_gib+++"] = { type = "Model", model = "models/gibs/antlion_gib_large_1.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 3.599, 0.8), angle = Angle(0, 180, -90), size = Vector(0.039, 0.039, 0.039), color = Color(165, 165, 165, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["part3"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 2.2, 2), angle = Angle(0, 180, 0), size = Vector(0.009, 0.009, 0.009), color = Color(150, 255, 165, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["ant_head"] = { type = "Model", model = "models/gibs/antlion_gib_large_3.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, 2.5), angle = Angle(145, 90, 0), size = Vector(0.07, 0.07, 0.07), color = Color(150, 150, 150, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["part5"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 2, -0.301), angle = Angle(0, 180, 0), size = Vector(0.009, 0.009, 0.009), color = Color(150, 255, 165, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["ant_gib+"] = { type = "Model", model = "models/gibs/antlion_gib_large_1.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0.28, 3.599, 2.299), angle = Angle(0, 180, -90), size = Vector(0.039, 0.039, 0.039), color = Color(215, 215, 215, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["ant_real_head"] = { type = "Model", model = "models/gibs/antlion_gib_large_2.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, 3.599), angle = Angle(0, 90, 0), size = Vector(0.059, 0.059, 0.059), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["part2"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 1.299, 3), angle = Angle(0, 180, 0), size = Vector(0.009, 0.009, 0.009), color = Color(150, 255, 165, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["ant_gib++"] = { type = "Model", model = "models/gibs/antlion_gib_large_1.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(-0, 3.599, 1.5), angle = Angle(0, 180, -90), size = Vector(0.039, 0.039, 0.039), color = Color(195, 195, 195, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["part4"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 2.599, 0.899), angle = Angle(0, 180, 0), size = Vector(0.009, 0.009, 0.009), color = Color(150, 255, 165, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} }
}




SWEP.WElements = {
	["part5"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4.9, 0, 0), angle = Angle(0, 90, 0), size = Vector(0.009, 0.009, 0.009), color = Color(145, 255, 145, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["part2"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4.9, 0, -1.5), angle = Angle(0, 90, 0), size = Vector(0.009, 0.009, 0.009), color = Color(145, 255, 145, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["part3"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.599, 0, 1.2), angle = Angle(0, 90, 0), size = Vector(0.009, 0.009, 0.009), color = Color(145, 255, 145, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["part1"] = { type = "Model", model = "models/props_c17/TrapPropeller_Lever.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.599, 0, 0), angle = Angle(0, 0, 90), size = Vector(0.3, 0.3, 0.3), color = Color(145, 255, 145, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["part4"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.599, 0, -2.3), angle = Angle(0, 90, 0), size = Vector(0.009, 0.009, 0.009), color = Color(145, 255, 145, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} }
}



function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 64,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 64,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if !tr.Hit then
self.Owner:EmitSound( "Weapon_HL_Crowbar.Miss" )
end
if tr.Hit then
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = 64
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = 0
bullet.Damage = 0
bullet.AmmoType = "none"
self.Owner:FireBullets( bullet )
if tr.Entity:IsNPC() || tr.Entity:IsPlayer() then
self.Owner:EmitSound( "Flesh.ImpactHard" )
else
self.Owner:EmitSound( "Weapon_HL_Crowbar.Hit" )
end
end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:SecondaryAttack()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end






/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end
--addons/arccw_weapons/lua/weapons/aocrp_dc15le.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-15le"
SWEP.Trivia_Class = "Heavy Long Range Battle-Rifle"
SWEP.Trivia_Desc = "The DC-15le blaster rifle, known simply as the DC-15 blaster rifle, was a heavy blaster rifle manufactured by BlasTech Industries, as part of the DC-15 family. It was one of the standard-issue weapons of the Galactic Republic's clone troopers, an army of cloned soldiers in the Grand Army of the Republic, during the Clone Wars against the Confederacy of Independent Systems."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15le.png"


-- Viewmodel & Entity Properties
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/everfall/weapons/viewmodels/c_dc15a.mdl"
SWEP.WorldModel = "models/everfall/weapons/worldmodels/w_dc15a.mdl"
SWEP.ViewModelFOV = 50
SWEP.WorldModelOffset = {
    pos = Vector(-13, 6, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.NoHideLeftHandInCustomization = true
SWEP.DefaultBodygroups = "000000011"

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.3,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 37
SWEP.RangeMin = 221
SWEP.DamageMin = 27
SWEP.Range = 573
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 427
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 55
SWEP.Recoil = 0.23
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.11
SWEP.Delay = 60 / 327
SWEP.Num = 1

SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },            
}

SWEP.AccuracyMOA = 0.59
SWEP.HipDispersion = 447
SWEP.MoveDispersion = 54

-- Speed Mult
SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.83
SWEP.SightTime = 0.2

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootSound = "armas/disparos/dc15le.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.987, -9.924, 0.939),
    Ang = Angle(0, 0, 0),
     Magnification = 1.4,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(15, -5, -1.321)
SWEP.CustomizeAng = Angle(18.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true
SWEP.BipodDispersion = 1 
SWEP.BipodRecoil = 1

-- Attachments
SWEP.Attachments = {      
    {
        PrintName = "Optic", 
        DefaultAttName = "Iron Sights", 
        Slot = "optic",
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(-0.5,-1.9,10),
            vang = Angle(90,0,-40),
            wpos = Vector(6, 0.4, -4.8),
            wang = Angle(-15, 0, 180)
        },
    },         
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },     
    {
        PrintName = "Magazine Capacity",
        DefaultAttName = "Standard",
        Bone = "dc-15a",
        Slot = {"dc15a_magazine_75"},
        Offset = {
            vpos = Vector(-0.7, -0.6, 2.5),
            vang = Angle(0, 0, 0),
        },
    },         
    {
        PrintName = "Werfeinrichtung",
        DefaultAttName = "None",
        Slot = "aocrp_ubgl",
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0, -1.4, 20.675),
            vang = Angle(90, 0, -90),
        },          
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical","tac_pistol"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0, -1.4, 20.7),
            vang = Angle(90, 0, 0),
        },
    },      
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0, -1.4, 30.675),
            vang = Angle(90, 0, 0),
        },
    },  
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0.830, -1.83, 10.273),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Idle"
    },
    ["fire"] = {
        Source = "shoot"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_lgequip.wav",
                p = 100, 
                v = 75,
                t = 0, 
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_medequip.wav",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_03.mp3", t = 2.2 },
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 0.1 / 30},
        },
    },
}


-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Damage = 35
SWEP.DamageMin = 15
SWEP.RangeMin = 530
SWEP.Range = 1200
SWEP.Delay = 60 / 327
SWEP.Primary.ClipSize = 55
SWEP.Category = 'REP'


--addons/arccw_weapons/lua/weapons/aocrp_dual_dc17_ext.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Eingestellte Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Dual DC-17 Ext."
SWEP.Trivia_Class = "Heavy Blaster Pistol"
SWEP.Trivia_Desc = "Heavy blaster pistol for CQB enviroments"
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/viewmodels/c_dc17_ext_1_dual.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 60
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.NoHideLeftHandInCustomization = true

SWEP.IconOverride = "materials/entities/rw_sw_dual_dc17ext.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 21
SWEP.RangeMin = 90
SWEP.DamageMin = 23
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 568
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = true -- disable light flash
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.DistantShootSound = "dc17/SW01_Weapons_Blasters_Shared_Corebass_Close_Tight_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "dc17/SW02_Weapons_Blasters_DC17_Laser_Close_VAR_07 0 0 0.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.IronSightStruct = {
    Pos = Vector(0, -0, 0),
    Ang = Angle(0, 0, 0),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
    },
    Magnification = 1,
    CrosshairInSights = false,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -10,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.ReloadPos = Vector(0, -4, 2)
SWEP.ReloadAng = Angle(-10, -0, -0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.DefaultElements = {"nil", "dc17ext+"}

SWEP.AttachmentElements = {
    ["nil"] = {
        WMElements = {
            {
                Model = "models/arccw/fisher/extendeddc17/extendeddc17.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(30, 15, -10),
                    ang = Angle(180, -90, 2)
                }
            },
            {
                Model = "models/arccw/fisher/extendeddc17/extendeddc17.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-50, 230, -55),
                    ang = Angle(180, -90, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    [2] = {
        PrintName = "Tactical",
        DefaultAttName = "No Attachment", 
        Slot = {"tactical","tac_pistol"},
        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-8, -4, 2),
            vang = Angle(170, 0, 0),
        },
    },
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
        Time = 2,
    },
    ["fire"] = {
        Source = {"fire_left", "fire_right"},
    },
    ["ready"] = {
        Source = "deploy",
    },
    ["enter_sight"] = {
        Source = "neutral",
    },
    ["draw"] = {
        Source = "idle",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        Time = 2,
        SoundTable = {
            -- {s = "dc17ext/untitled.ogg", t = 1 / 30},
            {s = "dc17ext/SCIMisc_Insert Ammo_04.ogg", t = 4 / 30},
            {s = "dc17ext/wfoly_pi_mike9_reload_fast_xmags_end.ogg", t = 30 / 30}, --s sound file
        },
    },
    ["bash"] = {
        Source = "melee",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 2,
    },
}
function SWEP:ChooseShootAnim(ifp, ...)
	if self:Clip1() == 2 then
		return self:PlayAnimation(self:GetStat("Animations.shoot1_empty"))
	elseif self:Clip1() == 1 then
		return self:PlayAnimation(self:GetStat("Animations.shoot2_empty"))
	end

	return BaseClass.ChooseShootAnim(self, ifp, ...)
end



-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Damage = 30
SWEP.DamageMin = 15
SWEP.RangeMin = 90
SWEP.Range = 350
SWEP.Delay = 60 / 586
SWEP.Primary.ClipSize = 46
SWEP.Category = 'REP'
--addons/arccw_weapons/lua/weapons/aocrp_stf5.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

-- Trivia
SWEP.Category = "AOCRP - Eingestellte Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "ST-F5"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "This is the ST-F5. The weapon could be used in a blaster rifle configuration or a blaster carbine configuration where the stock was removed for use in confined spaces. Each ST-F5 had a quarrel-bolt launcher installed below its barrel that used enhanced bowcaster technology for a powerful explosive attack. The rifle's power cell cartridge was located around the mid-point of the weapon's length, above the trigger. The weapon had an auto fire mode that provided a high rate of fire."
SWEP.IconOverride = "entities/sopsmisc/stw48.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops-v2/c_stw48.mdl"
SWEP.WorldModel = "models/arccw/kraken/sops-v2/w_stw48.mdl"
SWEP.ViewModelFOV = 58
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-11, 4, -3.3),
    ang = Angle(-10, 0, -180),
    scale = 1.2,
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 25
SWEP.DamageMin = 10
SWEP.Range = 1500
SWEP.RangeMin = 300
SWEP.Penetration = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 45
SWEP.ExtendedClipSize = 50
SWEP.ReducedClipSize = 25

SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 0.5

SWEP.Recoil = 0.68
SWEP.RecoilSide = 0.3
SWEP.RecoilRise = 0.62

SWEP.Delay = 60 / 525
SWEP.Num = 1
--SWEP.Firemode = -3
SWEP.Firemodes = {
    {
        Mode = 2
    },
    {
        Mode = 1
    },
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 110 
SWEP.ShootPitch = 120 
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "sops-v2/weapons/stw48.wav"
SWEP.ShootSound = "sops-v2/weapons/stw48.wav"
SWEP.ShootSoundSilenced = "weapon/venator/dc17_badbatch.wav"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.227, -1.923, 1),
    Ang = Angle(0,-0.7, 5),
     Magnification = 1.2,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 2, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.Attachments = {
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    {
        PrintName = "Optic",
        DefaultAttName = "None", 
        Slot = "optic", 
        Bone = "stw48",
        VMScale = Vector(0.8, 0.8, 0.8),
        Offset = {
            vpos = Vector(-0.250, -2, 2),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },      
    {
        PrintName = "Muzzle", 
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "stw48",
        VMScale = Vector(1, 1, 1),
        Offset = {
            vpos = Vector(-0.250, -1, 10.3),
            vang = Angle(90, 0, -90),
        },
    },   
    {
        PrintName = "Tactical", 
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.8, 0.8, 0.8),
        Bone = "stw48",
        Offset = {
            vpos = Vector(0.8, -1, 6),
            vang = Angle(90, 0, 0),
        },
    },        
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    }, 
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "stw48",
        Offset = {
            vpos = Vector(0.6, -1.0, -0.425),
            vang = Angle(90, 0, -90),
        },
    },       
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "stw48",
        Offset = {
            vpos = Vector(0.3, -2, -2),
            vang = Angle(90, 0, -70),
        },
    },        
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "neutral"
    },
    ["fire"] = {
        Source = "fire",
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_manualcooling_var_02.mp3", t = 5 / 30},
            {s = "weapon_hand/reload_gentle/mag_eject/023d-00001014.mp3", t = 5 / 30},
            {s = "weapon_hand/reload_gentle/mag_load/023d-00000dda.mp3", t = 30 / 30},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_04.mp3", t = 35 / 30},
        },
    },
}

-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Damage = 25
SWEP.DamageMin = 10
SWEP.RangeMin = 300
SWEP.Range = 1500
SWEP.Delay = 60 / 600
SWEP.Primary.ClipSize = 45
SWEP.Category = 'REP'

--addons/arccw_weapons/lua/weapons/aocrp_vibroknife.lua:
SWEP.Base = "arccw_base_melee"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Category = "REP"
SWEP.Credits = "Kraken"
SWEP.PrintName = "Vibromesser"
SWEP.Trivia_Class = "Knife"
SWEP.Trivia_Desc = "A vibroknife, or vibro-knife, was a blade that used an internal generator to make the blade vibrate. These vibrations could make even a glancing blow into a huge, gruesome slash, thus making it a far more effective weapon in close combat, or as a tool. These small weapons were openly used by all denizens of the Galactic Republic, from clone commandos to regular citizens."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/sopsmisc/vibroknife.png"

SWEP.Slot = 0

SWEP.NotForNPCs = true
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/sops-v2/v_vibroknife.mdl"
SWEP.WorldModel = "models/arccw/kraken/sops-v2/w_vibroknife.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-6.5, -18, -3),
    ang = Angle(-20, -20, -90 + 0)
}

SWEP.PrimaryBash = true

SWEP.MeleeDamage = 30
SWEP.MeleeRange = 32
SWEP.MeleeDamageType = DMG_SLASH
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = ACT_HL2MP_GESTURE_RANGE_ATTACK_KNIFE
SWEP.MeleeAttackTime = 0.1

SWEP.Melee2 = true
SWEP.Melee2Damage = 50
SWEP.Melee2Range = 32
SWEP.Melee2Time = 1
SWEP.Melee2Gesture = ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE
SWEP.Melee2AttackTime = 0.1

SWEP.NotForNPCs = true

SWEP.MeleeSwingSound = {
    "sopsv2/csgo_knife/knife_slash1.wav",
    "sopsv2/csgo_knife/knife_slash2.wav"
}
SWEP.MeleeHitSound = {
    "sopsv2/csgo_knife/knife_hitwall1.wav",
    "sopsv2/csgo_knife/knife_hitwall2.wav",
    "sopsv2/csgo_knife/knife_hitwall3.wav",
    "sopsv2/csgo_knife/knife_hitwall4.wav"
}
SWEP.MeleeHitNPCSound = {
    "sopsv2/csgo_knife/knife_hit1.wav",
    "sopsv2/csgo_knife/knife_hit2.wav",
    "sopsv2/csgo_knife/knife_hit3.wav",
    "sopsv2/csgo_knife/knife_hit4.wav",
}

SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "MESSER"
    },
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "knife"

SWEP.Primary.ClipSize = -1

SWEP.Animations = {
    ["idle"] = {
        Source = {"idle1", "idle2"},
    },
    ["draw"] = {
        Source = "draw",
        Time = 0.5,
    },
    ["bash"] = {
        Source = {"light_hit1", "light_hit2", "light_backstab", "light_backstab2"},
        Time = 1,
    },
    ["bash2"] = {
        Source = {"heavy_hit1", "heavy_backstab"},
        Time = 1.75
    }
}

SWEP.IronSightStruct = false

SWEP.ActivePos = Vector(0, -2, 0)

SWEP.BashPreparePos = Vector(0, 0, 0)
SWEP.BashPrepareAng = Angle(0, 5, 0)

SWEP.BashPos = Vector(0, 0, 0)
SWEP.BashAng = Angle(10, -10, 0)

SWEP.HolsterPos = Vector(0, -1, 2)
SWEP.HolsterAng = Angle(-15, 0, 0)

SWEP.AttachmentElements = {
    ["wepcamo-hyper"]		= { VMSkin = 1 },
    ["wepcamo-tiger"]		= { VMSkin = 2 },
    ["wepcamo-disarray"]		= { VMSkin = 5 },
    ["wepcamo-camo"]	= { VMSkin = 6 },
    ["wepcamo-digital"]	= { VMSkin = 7 },
    ["wepcamo-asimov"]		= { VMSkin = 8 },
}

SWEP.Attachments = {
    {
        PrintName = "Skin",
        DefaultAttName = "Standard",
        Slot = "rep_vibrocamo",
    },
}

--addons/arccw_weapons/lua/weapons/aocrp_westarm5.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Eingestellte Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Westar M5"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "High tech compact Westar M5 Blaster Carbine, preffered for CQB enviroments and general allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/v_westar_meeks.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_westar_v2.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(10, 0, -5),
    ang = Angle(170, 180, 0),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.IconOverride = "materials/entities/westarm5_m.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 50
SWEP.RangeMin = 180
SWEP.DamageMin = 27
SWEP.Range = 400
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50

SWEP.Recoil = 0.27
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.13

SWEP.Delay = 60 / 440
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2
    },
    {
        Mode = 1
    },
    {
        Mode = 0
    },
}
SWEP.AccuracyMOA = 0.5 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100


SWEP.DistantShootSound = "dc15a/SW02_Weapons_Blasters_Shared_Corebass_Tight_Close_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "westar/blasters_f-11aba_heavycannon_laser_close_var_01.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-2.845, -4, 0.8),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterrifle_08.mp3",
     ViewModelFOV = 50,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1.5, -2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, -10, 0)
SWEP.SprintAng = Angle(-10, 40, 0)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.Attachments = {
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.07, -1.7, 1),
            vang = Angle(90, 0, -90),
            wpos = Vector(9, 1.2, -6),
            wang = Angle(-10, 0, 180)
        },
    },
    {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment",
        NoVM = true,
        NoWM = true, -- used to display the "no attachment" text
        Slot = {"foregrip"},
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.2, 4.8, 6.5),
            vang = Angle(0, 0, -90),
            wpos = Vector(10, 1.5, -3),
            wang = Angle(170, 180, 0),
        },
    },          
    {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol","tac"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1.1, -0.5, 10),
            vang = Angle(90, 0, 0),
            wpos = Vector(16, 2, -6.5),
            wang = Angle(-10, 0, -90)
        },
    },
    {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle","dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.055, -0.4  , 13.8),
            vang = Angle(90, 0, -90),
            wpos = Vector(20, 1.1, -7.1),
            wang = Angle(-10, 0, -90)
        },
    },           
    {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(.9, -0.7, -3.3),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 1.8, -5),
            wang = Angle(-10 , 0, 190)
        },
    },     
    {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },      
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        LHIKOut = 0.6,
        Time = 3,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "reloads/heavy.wav", t = 4 / 30}, --s sound file
        },
    },

}


-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Damage = 50
SWEP.DamageMin = 27
SWEP.RangeMin = 700
SWEP.Range = 4000
SWEP.Delay = 60 / 440
SWEP.Primary.ClipSize = 50
SWEP.Category = 'REP'
--addons/arccw_weapons/lua/weapons/arccw_bacta_grenade.lua:
SWEP.Base = "arccw_grenade_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "Bacta Grenade"
SWEP.Trivia_Class = "Hand Grenade"
SWEP.Trivia_Desc = "Standard explosive ordnance with a timed fuse and a large blast radius."

SWEP.Slot = 4

SWEP.CamAttachment = 3

SWEP.NotForNPCs = true

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/nade_frag.mdl"
SWEP.WorldModel = "models/weapons/w_nade_frag.mdl"
SWEP.HideViewmodel = true
SWEP.MirrorVMWM = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/bacta_grenade_meeks.png"


SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "fcg.nade",
    },
}

SWEP.FuseTime = 20

SWEP.Primary.Ammo = "grenade"

SWEP.Primary.ClipSize = 1

SWEP.MuzzleVelocity = 1300
SWEP.MuzzleVelocityAlt = 500
SWEP.ShootEntity = "arccw_thr_bacta"

SWEP.PullPinTime = 0.5

SWEP.ViewModelFOV = 70

SWEP.DefaultElements = {"bacta_grenade"}

SWEP.AttachmentElements = {
    ["bacta_grenade"] = {
        VMElements = {
            {
                Model = "models/arccw/meeks/bacta_grenade.mdl",
                Bone = "def_c_base",
                Scale = Vector(.9, .9, .9),
                Offset = {
                    pos = Vector(-0.4, -.4, 0.2),
                    ang = Angle(-0, 0, -90)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/meeks/bacta_grenade.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.8, 0.8, 0.8),
                Offset = {
                    pos = Vector(35, 25, 0),
                    ang = Angle(0, 0, 0)
                }
            }
        },
    },
}

WMOverride = "models/arccw/meeks/bacta_grenade.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {Source = "sprint", Mult = 0.9},
    ["enter_sprint"] = {Source = "sprint_in", Mult = 0.1},
    ["exit_sprint"] = {Source = "sprint_out", Mult = 0.1},
    ["ready"] = {
        Source = "draw",
        SoundTable = {
           {s = "ArcCW_ThermalDet.firstdeploy1", t = 0 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = "misc/gunfoley_blaster_sheathe_var_03.mp3", t = 0 / 30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = "ArcCW_ThermalDet.holster1", t = 0 / 30}
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "ArcCW_primer.button", t = 0 / 30},
        },
        MinProgress = 0.5,
    },
    ["fire"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "ArcCW_primer.button", t = 0 / 30},
        },
    },
    ["throw"] = {
        Source = {"toss_overhead"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
    },
    ["throw_alt"] = {
        Source = {"underhand"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
    },
    ["enter_inspect"] = {
        Source = "inspect_in",
        LHIK = true,
    },
    ["exit_inspect"] = {
        Source = "inspect_out",
        LHIK = true,
    },
    ["idle_inspect"] = {
        Source = "inspect",
        LHIK = true,
    },

sound.Add({
    name =          "ArcCW_ThermalDet.holster1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/sw01_characters_gunfoley_draw_blaster_var21.mp3"
    }),
    
sound.Add({
    name =          "ArcCW_ThermalDet.deploy1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/gunfoley_blaster_sheathe_var_03.mp3"
    }),
       
sound.Add({
    name =          "ArcCW_ThermalDet.firstdeploy1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/sw01_characters_gunfoley_draw_blaster_var19.mp3"
    }),
        
sound.Add({
    name =          "ArcCW_primer.button",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "w/buttonpress.mp3"
    }),

sound.Add({
    name =          "ArcCW_Underhand.explosion2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "w/underhand.mp3"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_defender.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "'Defender'"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "A Blaster pistol for shooting enviroments"
SWEP.Trivia_Manufacturer = "Drearian Defense Conglomerate"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_d.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 80
SWEP.DamageMin = 14
SWEP.Range = 300
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_yellow"
SWEP.TracerCol = Color(255, 165, 18)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 18

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },    
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(255, 165, 18)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/dpst.wav"
SWEP.ShootSoundSilenced = "w/defender.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-3.945, -8, 2.2),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterpistol_04.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, -4, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -10,-20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(20.824, -16, 4.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"defender"}

SWEP.AttachmentElements = {
    ["defender"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/2019/defender_base.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(0, 0, 0),
                    ang = Angle(0, 90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/2019/defender_base.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(40, 20, -15.3),
                    ang = Angle(-15, 0, 180)
                }
            }
        },
    },
}
WMOverride = "models/arccw/sw_battlefront/weapons/2019/defender_base.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "swoptic_module",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0, -2, 2),
            vang = Angle(0, 180, 0),
            wpos = Vector(70, 20, -40),
            wang = Angle(-15, 90, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9), -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, -5, 1.3),
            vang = Angle(0, 90, 0),
            wpos = Vector(80, 20, -38),
            wang = Angle(-15, 0, 180)
        },
    },    
    [3] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        WMScale = Vector(9, 9, 9),
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 0.3, 8.6),
            vang = Angle(90, 0, -90),
            wpos = Vector(113, 20, -55),
            wang = Angle(-15, 0, 180)
        },
    },        
    [4] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [5] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [6] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(8, 8, 8),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.35, 0.9, 1),
            vang = Angle(90, 0, -90),
            wpos = Vector(60, 22, -35),
            wang = Angle(-10, 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
 --       Time = 3.35,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_dual_dc15s.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Dual DC-15s (V1 - WIP)"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "High tech compact DC15S Blaster Carbine, preffered for CQB enviroments and general allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dual_dc15s.png"

SWEP.DefaultBodygroups = "000000000000"
SWEP.NoHideLeftHandInCustomization = true
SWEP.Damage = 30
SWEP.RangeMin = 120
SWEP.DamageMin = 17
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.5
SWEP.RecoilPunch = 0.7
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 350
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 2
    },
    {
        Mode = 0
    },    
}

SWEP.AccuracyMOA = 0.55 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "dc15s/blasters_dc15_laser_close_var_02.mp3"

SWEP.MuzzleFlashColor = Color(0, 0, 255, 50)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)

SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)
SWEP.DrawCrosshair = true

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"dc15s", "dc15s+"}

SWEP.AttachmentElements = {
    ["dc15s"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/dc15s_carbine.mdl",
                Bone = "LeftHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(3, 2, -0.7),
                    ang = Angle(-4, -2, 90)
                }
            }
        },
    },
    ["dc15s+"] = {
         VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/dc15s_carbine.mdl",
                Bone = "RightHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),                
                Offset = {
                    pos = Vector(-3.5, -2.2, 1.2),
                    ang = Angle(2, 178, 90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/dc15s_carbine.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(30, 15, -10),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/sw_battlefront/weapons/dc15s_carbine.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-50, 230, -55),
                    ang = Angle(180, -180, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/sw_battlefront/weapons/dc15s_carbine.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-8, -4, 2),
            vang = Angle(170, 0, 0),
        },
    },    
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [3] = {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },    
    [4] = {
        PrintName = "Internal Modifications", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "uc_fg",
    },   
}   


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_lw", "shoot_rw"},
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_dual_defender.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Dual 'Defender'"
SWEP.Trivia_Class = "Dual Blaster Pistol"
SWEP.Trivia_Desc = "Dual Blaster pistols for shooting enviroments"
SWEP.Trivia_Manufacturer = "Drearian Defense Conglomerate"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel = "models/arccw/weapons/synbf3/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dual_d.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 110
SWEP.DamageMin = 17
SWEP.Range = 300
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_yellow"
SWEP.TracerCol = Color(255, 165, 18)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 26

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 0.6
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 330
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },    
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 460 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/dpst.wav"

SWEP.MuzzleFlashColor = Color(255, 165, 18, 50)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)

SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)
SWEP.DrawCrosshair = true

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"defender", "defender+"}

SWEP.AttachmentElements = {
    ["defender"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/2019/defender_base.mdl",
                Bone = "LeftHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(3, 2, -0.7),
                    ang = Angle(-0, -2, 90)
                }
            }
        },
    },
    ["defender+"] = {
         VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/2019/defender_base.mdl",
                Bone = "RightHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),                
                Offset = {
                    pos = Vector(-3.5, -2.2, 1.2),
                    ang = Angle(-180, -2, -90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/2019/defender_base.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(30, 15, -10),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/sw_battlefront/weapons/2019/defender_base.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-50, 230, -55),
                    ang = Angle(180, -180, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/sw_battlefront/weapons/2019/defender_base.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
--    [1] = {
--        PrintName = "Tactical", -- print name
--        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
--        Slot = {"tactical","tac_pistol"},
--        VMScale = Vector(0.8, 0.8, 0.8),
--        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
--        Offset = {
--            vpos = Vector(-8, -3.7, 1.3),
 --           vang = Angle(170, 0, 0),
--        },
--    },    
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    }
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_lw", "shoot_rw"},
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_dual_westar35.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "[P] Dual Westar 35"
SWEP.Trivia_Class = " Galactic Dual Blaster Pistol"
SWEP.Trivia_Desc = " Dual Blaster pistols for shooting enviroments"
SWEP.Trivia_Manufacturer = "Drearian Defense Conglomerate"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel = "models/arccw/weapons/synbf3/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dual_westar35.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 125
SWEP.DamageMin = 17
SWEP.Range = 335
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 1050


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_yellow"
SWEP.TracerCol = Color(255, 165, 18)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 16*2

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 0.6
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 290
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 460 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/westar35.wav"

SWEP.MuzzleFlashColor = Color(255, 165, 18, 50)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)

SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)
SWEP.DrawCrosshair = true

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"w35", "w35+"}

SWEP.AttachmentElements = {
    ["w35"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/westar_35_pistol.mdl",
                Bone = "LeftHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(4, 2, -1),
                    ang = Angle(80, -2, 90)
                }
            }
        },
    },
    ["w35+"] = {
         VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/westar_35_pistol.mdl",
                Bone = "RightHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),                
                Offset = {
                    pos = Vector(-4, -2, 1),
                    ang = Angle(-95, 178, 90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/westar_35_pistol.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(30, 15, -10),
                    ang = Angle(180, -90, 2)
                }
            },
            {
                Model = "models/arccw/sw_battlefront/weapons/westar_35_pistol.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-50, 230, -55),
                    ang = Angle(180, -90, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/sw_battlefront/weapons/westar_35_pistol.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
--    [1] = {
--        PrintName = "Tactical", -- print name
--        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
--        Slot = {"tactical","tac_pistol"},
--        VMScale = Vector(0.8, 0.8, 0.8),
--        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
--        Offset = {
--            vpos = Vector(-8, -3.7, 1.3),
 --           vang = Angle(170, 0, 0),
--        },
--    },    
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    }
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_lw", "shoot_rw"},
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_grenade_base.lua:
SWEP.Base = "arccw_base_nade"
SWEP.Spawnable = false
SWEP.Category = "[ ArcCW ] SW Explosives"
SWEP.AdminOnly = false

SWEP.PrintName = "Nade Base"
SWEP.DrawCrosshair = true

SWEP.IronSightStruct = false

SWEP.CrouchPos = Vector(0, -2, -0.5)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -2, 1)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(0, -2, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(0, -2, 0)
SWEP.CustomizeAng = Angle(0 , 0, 0)

SWEP.ThrowInertia = false

SWEP.CookPrimFire = false
SWEP.CookAltFire = false

SWEP.Lunge = true
SWEP.LungeLength = 72
SWEP.MeleeSwingSound = ""
SWEP.MeleeMissSound = ""
SWEP.MeleeHitSound = ""
SWEP.MeleeHitNPCSound = ""

SWEP.MeleeDamage = 50
SWEP.MeleeRange = 48
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 1
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.HipDispersion = 150
SWEP.MoveDispersion = 50

SWEP.Throwing = true
SWEP.Singleton = false

SWEP.WindupTime = 0
SWEP.WindupMinimum = 0.5

SWEP.ShootWhileSprint = false -- You cannot throw nades while sprinting on apex, so i thought it should be the same here

--addons/arccw_weapons/lua/weapons/arccw_impact_grenade.lua:
SWEP.Base = "arccw_grenade_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "Impact Grenade"
SWEP.Trivia_Class = "Hand Grenade"
SWEP.Trivia_Desc = "Impact explosive ordnance with a medium-sized blast radius."

SWEP.Slot = 4

SWEP.CamAttachment = 3

SWEP.NotForNPCs = true

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/nade_frag.mdl"
SWEP.WorldModel = "models/weapons/w_nade_frag.mdl"
SWEP.HideViewmodel = true
SWEP.MirrorVMWM = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/impact_grenade_meeks.png"

SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "fcg.nade",
    },
}

SWEP.Primary.Ammo = "grenade"

SWEP.Primary.ClipSize = 1

SWEP.MuzzleVelocity = 1300
SWEP.MuzzleVelocityAlt = 500
SWEP.ShootEntity = "arccw_thr_impact"

SWEP.PullPinTime = 0.5

SWEP.ViewModelFOV = 70

SWEP.DefaultElements = {"thermal_grenade"}

SWEP.AttachmentElements = {
    ["thermal_grenade"] = {
        VMElements = {
            {
                Model = "models/arccw/impact_grenade.mdl",
                Bone = "def_c_base",
                Scale = Vector(0.75, 0.75, 0.75),
                Offset = {
                    pos = Vector(-0.2, -.3, -0),
                    ang = Angle(-90, 0, -90)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/impact_grenade.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.8, 0.8, 0.8),
                Offset = {
                    pos = Vector(35, 25, 0),
                    ang = Angle(0, 0, 0)
                }
            }
        },
    },
}

WMOverride = "models/arccw/impact_grenade.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {Source = "sprint", Mult = 0.9},
    ["enter_sprint"] = {Source = "sprint_in", Mult = 0.1},
    ["exit_sprint"] = {Source = "sprint_out", Mult = 0.1},
    ["ready"] = {
        Source = "draw",
        SoundTable = {
           {s = "ArcCW_ThermalDet.firstdeploy1", t = 0 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = "misc/gunfoley_blaster_sheathe_var_03.mp3", t = 0 / 30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = "ArcCW_ThermalDet.holster1", t = 0 / 30}
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "ArcCW_primer.button", t = 0 / 30},
        },
        MinProgress = 0.5,
    },
    ["fire"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "ArcCW_primer.button", t = 0 / 30},
        },
    },
    ["throw"] = {
        Source = {"toss_overhead"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
    },
    ["throw_alt"] = {
        Source = {"underhand"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
    },
    ["enter_inspect"] = {
        Source = "inspect_in",
        LHIK = true,
    },
    ["exit_inspect"] = {
        Source = "inspect_out",
        LHIK = true,
    },
    ["idle_inspect"] = {
        Source = "inspect",
        LHIK = true,
    },

sound.Add({
    name =          "ArcCW_ThermalDet.holster1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/sw01_characters_gunfoley_draw_blaster_var21.mp3"
    }),
    
sound.Add({
    name =          "ArcCW_ThermalDet.deploy1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/gunfoley_blaster_sheathe_var_03.mp3"
    }),
       
sound.Add({
    name =          "ArcCW_ThermalDet.firstdeploy1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/sw01_characters_gunfoley_draw_blaster_var19.mp3"
    }),
        
sound.Add({
    name =          "ArcCW_Shock.explosion1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "w/SW02_Weapons_Grenades_Shared_Beeps_10.wav"
    }),

sound.Add({
    name =          "ArcCW_primer.button",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "w/buttonpress.mp3"
    }),

sound.Add({
    name =          "ArcCW_Underhand.explosion2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "w/underhand.mp3"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_sops_jawapistol.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = "Kraken"
SWEP.PrintName = "[P] Jawa Pistol"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "Heavy-Powered blaster produced by BlastTech Industries for the galactic citizens."
SWEP.IconOverride = "entities/sopsmisc/jawa.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/masita/viewmodels/blasterpistol_template.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 60
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 26
SWEP.RangeMin = 145
SWEP.DamageMin = 21
SWEP.Range = 265
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.76
SWEP.RecoilSide = 0.12
SWEP.RecoilRise = 0.98
SWEP.Delay = 60 / 280

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = -3
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/jawapistol.wav"
SWEP.ShootSound = "sops-v2/weapons/jawapistol.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-5.6, -10, 1.1),
    Ang = Angle(0, 0, 0),
     Magnification = 1.3,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(-4, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, -20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(10, -13, 0)
SWEP.CustomizeAng = Angle(12, 50.5, 45)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/jawa_pistol.mdl",
                Bone = "DC-15SA",
                Scale = Vector(1.2, 1.2, 1.2),
                Offset = {
                    pos = Vector(-1.5, 4.5, -5),
                    ang = Angle(0, 0, -90)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "DC-15SA",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-5, 5, 14),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/jawa_pistol.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.2, 1.2, 1.2),
                Offset = {
                    pos = Vector(60, 10, 25),
                    ang = Angle(-15, -90, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(115, 20, -50),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/jawa_pistol.mdl"

SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(11, 11, 11),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(-0.57, -2.2, -4),
            vang = Angle(90, 0, -90),
            wpos = Vector(40, 20, -47),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 0, 0)
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9),
        Bone = "DC-15SA", 
        Offset = {
            vpos = Vector(-0.57, -1, 1.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(110, 20, -53),
            wang = Angle(-15, 0, 180)
        },
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(7, 7, 7),
        Offset = {
            vpos = Vector(-0.2, -0.6, -1.8),
            vang = Angle(90, 0, -90),
            wpos = Vector(86, 24, -40),
            wang = Angle(-15, 0, 180)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(11, 11, 11),
        VMScale = Vector(1, 1, 1),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.1, -1.6, -1.8),
            vang = Angle(90, 0, -90),
            wpos = Vector(70, 27, -49),
            wang = Angle(-15, 0, 180)
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false
    },
    ["fire"] = {
        Source = {"Fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 105 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_mandorifle.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "Mandalorian Pulse Rifle"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The Amban phase-pulse blaster, also known as an Amban sniper rifle, was a type of disruptor sniper rifle used by the Mandalorian bounty hunter Din Djarin. The weapon was capable of electrocuting opponents as well as completely disintegrating targets. It was also capable of listening to conversations at least a house away. Djarin used the deadly weapon to great effect during his bounty hunting career."
SWEP.IconOverride = "entities/sopsmisc/mandopulse.png"

-- Viewmodel & Entity Properties
SWEP.HideViewmodel = false
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/masita/viewmodels/base_rifle_animations.mdl"
SWEP.WorldModel = "models/weapons/synbf3/w_t21.mdl"
SWEP.ViewModelFOV = 66
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 132
SWEP.RangeMin = 303
SWEP.DamageMin = 98
SWEP.Range = 602
SWEP.Penetration = 2
SWEP.DamageType = DMG_DISSOLVE
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_laser_big"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 8

SWEP.Recoil = 1.87
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.78
SWEP.Delay = 60 / 102

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 100

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 70
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/mandorifle.wav"
SWEP.ShootSound = "sops-v2/weapons/mandorifle.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.14, 0, 1.8),
    Ang = Angle(1, -0.5, -3),
     Magnification = 2,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 2, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/mando_sniper.mdl",
                Bone = "E11S_CONTR",
                ModelBodygroups = "00001",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(0.1, 6, -6),
                    ang = Angle(0, -90, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-3, 26, -8),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/mando_sniper.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.2, 1.2, 1.2),
                ModelBodygroups = "00001",
                Offset = {
                    pos = Vector(176, 10, -5),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(170, 15, -60),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/mando_sniper.mdl"


SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0, -3, 0.5),
            vang = Angle(0, -90, 0),
            wpos = Vector(52, 9.5, -55),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.07)
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR", 
        Offset = {
            vpos = Vector(0.5, 12, -0.3),
            vang = Angle(0, -90, 90),
            wpos = Vector(220, 15, -89),
            wang = Angle(-15, 0, -90)
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = "foregrip",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0, 2, -2),
            vang = Angle(0, -90, 0),
            wpos = Vector(110, 9, -33),
            wang = Angle(-15, 0, 180)
        },          
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.1, 26, -0.25),
            vang = Angle(0, -90, 0),
            wpos = Vector(400, 8, -138),
            wang = Angle(-15, 0, 180)
        },     
    },    
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(9, 9, 9),
        Offset = {
            vpos = Vector(0.5, -3, -0.45),
            vang = Angle(0, -90, 0),
            wpos = Vector(55, 15, -40),
            wang = Angle(-15, 0, 180)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(11, 11, 11),
        VMScale = Vector(1, 1, 1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.7, 2.5, -0.6),
            vang = Angle(0, -90, 0),
            wpos = Vector(120, 18, -60),
            wang = Angle(-15, 0, 180)
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 120 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_sx21.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "SX-21"
SWEP.Trivia_Class = "Pump-Action Scatter Blaster"
SWEP.Trivia_Desc = "The SX-21 pump-action scatter blaster, also known as the SX-21 scatterblaster, or the SX-21 blaster rifle, was a model of pump-action scatter blaster rifle made by Merr-Sonn Munitions, Inc., and proved invaluable to Imperial mudtroopers during the heavy fighting with the Mimbanese during the Mimban Campaign"
SWEP.IconOverride = "entities/sopsmisc/sx21.png"

-- Viewmodel & Entity Properties
SWEP.ViewModel = "models/arccw/masita/viewmodels/base_rifle_animations.mdl"
SWEP.WorldModel = "models/weapons/synbf3/w_t21.mdl"
SWEP.ViewModelFOV = 60
SWEP.UseHands = true
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.3,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 29 * 8
SWEP.RangeMin = 112
SWEP.DamageMin = 12 * 8
SWEP.Range = 256
SWEP.Penetration = 12
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_green"
SWEP.TracerCol = Color(0, 250, 0)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.76
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.56
SWEP.Delay = 60 / 201

SWEP.Num = 8
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 25
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 100

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 70
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/sx21.wav"
SWEP.ShootSound = "sops-v2/weapons/sx21.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_green"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3, -5, 0.5),
    Ang = Angle(1, 0, -3),
     Magnification = 2,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 4, -2)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/w_sx21.mdl",
                Bone = "E11S_CONTR",
                ModelBodygroups = "00000",
                Scale = Vector(0.9, 0.9, 0.9),
                Offset = {
                    pos = Vector(-1, 0.5, -1),
                    ang = Angle(0, 0, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-4, 26, -8),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/w_sx21.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                ModelBodygroups = "00000",
                Offset = {
                    pos = Vector(100, 0, -50),
                    ang = Angle(-15, -90, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(280, 15, -100),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/w_sx21.mdl"


SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.1, -3.3, 2.1),
            vang = Angle(0, -90, 0),
            wpos = Vector(45, 13, -73),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0)
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR", 
        Offset = {
            vpos = Vector(1, 10, 0.6),
            vang = Angle(0, -90, 90),
            wpos = Vector(200, 23, -100),
            wang = Angle(-15, 0, -90)
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = "foregrip",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.15, 6, -2.1),
            vang = Angle(0, -90, 0),
            wpos = Vector(150, 13, -51),
            wang = Angle(-15, 0, 180)
        },          
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        WMScale = Vector(18, 18, 18),
        VMScale = Vector(2, 2, 2),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.1, 19.7, 0.5),
            vang = Angle(0, -90, 0),
            wpos = Vector(315, 13, -128),
            wang = Angle(-15, 0, 180)
        },     
    },    
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(11, 11, 11),
        Offset = {
            vpos = Vector(0.65, -1.8, -1.2),
            vang = Angle(0, -90, 0),
            wpos = Vector(72, 21, -40),
            wang = Angle(-15, 0, 180)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(11, 11, 11),
        VMScale = Vector(1, 1, 1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.9, -8, 0),
            vang = Angle(0, -90, 0),
            wpos = Vector(10, 20, -35),
            wang = Angle(-15, 0, 180)
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 120 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_thexmechanica.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "'Thex Mechanica'"
SWEP.Trivia_Class = "Blaster Revolver"
SWEP.Trivia_Desc = "Yours, until the last flame dies and all words have been spoken."
SWEP.IconOverride = "entities/sopsmisc/thexmechanica.png"

SWEP.HideViewmodel = false
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops-v2/c_the_last_word_ex.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 58
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = true
SWEP.WorldModelOffset = {
    pos = Vector(-19, 6, -5),
    ang = Angle(-10, 0, 180)
}

-- Damage & Entity options
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 43
SWEP.RangeMin = 143
SWEP.DamageMin = 24
SWEP.Range = 298
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800

SWEP.TracerNum = 1
SWEP.TracerCol = Color(25, 125, 255)
SWEP.TracerWidth = 10
SWEP.PhysTracerProfile = "apex_bullet_energy"
SWEP.Tracer = "arccw_apex_tracer_energy_sniper"
SWEP.HullSize = 0.5
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 8
SWEP.AmmoPerShot = 1

SWEP.Recoil = 1.63
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.62

SWEP.Delay = 60 / 170
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
		Mode = 2
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false 

SWEP.MuzzleEffectAttachment = 1 
SWEP.ProceduralViewBobAttachment = 1
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ammo & Stuff
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 150
SWEP.ShootPitch = 120
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "weapons/duality/dualityfire2.wav"
SWEP.ShootSound = "weapons/duality/dualityfire2.wav"
SWEP.ShootSoundSilenced = "weapon/venator/dc17_badbatch.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-5.373, -11.532, 1.552),
    Ang = Angle(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 60,
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "revolver"
SWEP.HoldtypeSights = "revolver"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_REVOLVER

SWEP.ActivePos = Vector(-1, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, -20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(10, -13, 0)
SWEP.CustomizeAng = Angle(12, 50.5, 45)

-- Attachments 
SWEP.Attachments = {
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "ammo_masita"},
    },
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = {"perk", "mw3_pro"},
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },      
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot"},
        Time = 0.9,
    },
    ["fire_iron"] = {
        ShellEjectAt = 0,
        Source = {"shoot"}
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_REVOLVER,
        SoundTable = {
            {s = "sops-v2/weapons/revolver_reload.wav", t = 0.1 / 30},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_valken38x_v2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Valken 38x"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "High precision, powerful over long ranges."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/v_valken38x_nobipod.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_valken38x_v2.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(6, 0, -4),
    ang = Angle(165, 180, 0),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.IconOverride = "materials/entities/rw_sw_valken38x.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 65
SWEP.RangeMin = 230
SWEP.DamageMin = 28
SWEP.Range = 490
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 40


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.14
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.1

SWEP.Delay = 60 / 190
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.45 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 300 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100


SWEP.DistantShootSound = "dc15a/SW02_Weapons_Blasters_Shared_Corebass_Tight_Close_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "valken38x/valken.wav"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-2.74, -10, 0.2),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_05.mp3",
     ViewModelFOV = 75,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1.5, 1, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(0.2, -1, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"", ""}


--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        -- WMScale = Vector(111, 111, 111),
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, -0.7, -4.1),
            vang = Angle(90, 0, -90),
            wpos = Vector(4, 1, -4.8),
            wang = Angle(-15, 0, 180)
        },
        -- CorrectiveAng = Angle(-2.4, -0, 0)
    },
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"foregrip"},
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.2, 3.5, 14.5),
            vang = Angle(90, 0, -90),
            wang = Angle(160, 180, 0),
        },
        SlideAmount = {
            vmin = Vector(-0, 1, 2),
            vmax = Vector(-0, 1, 8),
            wmin = Vector(13, 1, -5.5),
            wmax = Vector(13, 1, -5.5)  -- how far this attachment can slide in both directions.
        },  
    },          
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol","tac"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 1.2, 16),
            vang = Angle(90, 0, -90),
            wpos = Vector(23, 1, -8),
            wang = Angle(-15, 0, 180)
        },
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        NoWM = true,
        Slot = {"muzzle","dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 0.1, 22.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(0, 0, -0),
            wang = Angle(-15, 0, -90)
        },
    },    
    [5] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, 2.3, -3),
            vang = Angle(0, 0, 0),
        },
    },         
    [6] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 0.2, 4),
            vang = Angle(90, 0, -90),
            wpos = Vector(10, 2, -5.5),
            wang = Angle(-10 , 0, 180)
        },
    },    
    [9] = {
        PrintName = "Killcounter", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"killcounter"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 0.2, 1.4),
            vang = Angle(90, 0, -90),
            wpos = Vector(10, 2, -5.5),
            wang = Angle(-15 , 0, 180)
        },
    },   
    [10] = {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },    
    [11] = {
        PrintName = "Internal Modifications", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "uc_fg",
    },   
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "shoot"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3,
        LHIK = true,
        LHIKOut = 0.6,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "reloads/heavy.wav", t = 4 / 30}, --s sound file
        },
    },

}

--lua/weapons/blood_dagger/shared.lua:
SWEP.Author       = "Segaretka"
SWEP.PrintName    = "Blood dagger"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Blood"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack, Special +vampirism"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "knife"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 40
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
["v_weapon.Knife_Handle"] = { scale = Vector(0.37, 0.37, 0.37), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["hils++"] = { type = "Model", model = "models/gibs/agibs.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.9), angle = Angle(0, 90, 0), size = Vector(0.3, 0.3, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/dav0r/thruster.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 11), angle = Angle(180, 0, 0), size = Vector(0.1, 0.1, 1), color = Color(160, 0, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 45, 0), size = Vector(0.05, 0.039, 0.109), color = Color(255, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/tiles2", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/hunter/triangles/trapezium.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 9), angle = Angle(-90, 90, 0), size = Vector(0.14, 0.009, 0.029), color = Color(255, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils++"] = { type = "Model", model = "models/gibs/agibs.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.9), angle = Angle(0, 90, 0), size = Vector(0.3, 0.3, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 50, 8), size = Vector(0.05, 0.039, 0.109), color = Color(255, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/tiles2", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/hunter/triangles/trapezium.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 9), angle = Angle(-90, 90, 0), size = Vector(0.14, 0.009, 0.029), color = Color(255, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/dav0r/thruster.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 11), angle = Angle(180, 0, 0), size = Vector(0.1, 0.1, 1), color = Color(160, 0, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}


SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 12
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.26
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 10

SWEP.Secondary.Damage 	   = 36
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 12

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		self.Owner:SetHealth(math.Clamp(self.Owner:Health()+3,0,100))
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		self.Owner:SetHealth(math.Clamp(self.Owner:Health()+3,0,100))
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/billy_gas/lua/weapons/gas_weapon_hands.lua:
AddCSLuaFile()

SWEP.PrintName = "Hands"
SWEP.Slot = 0
SWEP.SlotPos = 0

SWEP.DrawAmmo = false

SWEP.Spawnable = false

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawCrosshair = false

SWEP.WorldModel = ""

SWEP.Instructions = "You are temporarily restricted to this weapon only."

function SWEP:Initialize()
	self:SetHoldType("normal")
end

function SWEP:Deploy()
	if (CLIENT or not IsValid(self:GetOwner())) then return true end
	self:GetOwner():DrawWorldModel(false)
	return true
end

function SWEP:PreDrawViewModel()
	return true
end

function SWEP:PrimaryAttack() end
function SWEP:SecondaryAttack() end
function SWEP:Reload() end
--lua/weapons/ghost_sword/shared.lua:
SWEP.Author       = "Killua"
SWEP.PrintName    = "Ghost sword"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Ghost"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack, Special +speed"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee2"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 50
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-47.778, 0, 0) }
}
SWEP.VElements = {
	["hils++"] = { type = "Model", model = "models/props_phx2/garbage_metalcan001a.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 5), angle = Angle(0, 90, 90), size = Vector(0.699, 0.4, 0.699), color = Color(255, 255, 255, 159), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/hunter/triangles/trapezium.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 16), angle = Angle(-90, 90, 0), size = Vector(0.5, 0.009, 0.1), color = Color(255, 255, 255, 150), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_phx2/garbage_metalcan001a.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 5), angle = Angle(0, 90, 90), size = Vector(0.3, 0.2, 0.6), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 45, 0), size = Vector(0.05, 0.039, 0.109), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/dav0r/thruster.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 27), angle = Angle(180, 0, 0), size = Vector(0.1, 0.1, 3.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils++"] = { type = "Model", model = "models/props_phx2/garbage_metalcan001a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 5), angle = Angle(0, 90, 90), size = Vector(0.699, 0.4, 0.699), color = Color(255, 255, 255, 159), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_phx2/garbage_metalcan001a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 5), angle = Angle(0, 90, 90), size = Vector(0.3, 0.2, 0.6), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/hunter/triangles/trapezium.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 16), angle = Angle(-90, 90, 0), size = Vector(0.5, 0.009, 0.1), color = Color(255, 255, 255, 150), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/dav0r/thruster.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 27), angle = Angle(180, 0, 0), size = Vector(0.1, 0.1, 3.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 50, 8), size = Vector(0.05, 0.039, 0.109), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} }
}




SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 40
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.5
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 16

SWEP.Secondary.Life        = true
SWEP.Secondary.Damage 	   = 75
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.9
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0
SWEP.SetRunSpeed=505

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
self.Owner:SetRunSpeed(self.SetRunSpeed)
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Owner:SetRunSpeed(self.SetRunSpeed+50)
		self.SetRunSpeed=self.SetRunSpeed +5
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Owner:SetRunSpeed(self.SetRunSpeed+50)
		self.SetRunSpeed=self.SetRunSpeed +5
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/tools/lua/improvedstacker/localify.lua:
--[[--------------------------------------------------------------------------
	Localify Module
	
	Author:
		Mista-Tea ([IJWTB] Thomas)
	
	License:
		The MIT License (MIT)

		Copyright (c) 2015 Mista-Tea

		Permission is hereby granted, free of charge, to any person obtaining a copy
		of this software and associated documentation files (the "Software"), to deal
		in the Software without restriction, including without limitation the rights
		to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
		copies of the Software, and to permit persons to whom the Software is
		furnished to do so, subject to the following conditions:

		The above copyright notice and this permission notice shall be included in all
		copies or substantial portions of the Software.

		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
		AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
		LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
		OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
		SOFTWARE.
			
	Changelog:
----------------------------------------------------------------------------]]

--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

module( "localify", package.seeall )

languages = {
	bg        = "Bulgarian",
	cs        = "Czech",
	da        = "Danish",
	de        = "German",
	el        = "Greek",
	["en-pt"] = "Pirate",
	en        = "English",
	es        = "Spanish",
	et        = "Estonian",
	fi        = "Finnish",
	fr        = "French",
	he        = "Hebrew",
	hr        = "Croatian",
	hu        = "Hungarian",
	it        = "Italian",
	ja        = "Japanese",
	ko        = "Korean",
	lt        = "Lithuanian",
	nl        = "Dutch",
	no        = "Norwegian",
	pl        = "Polish",
	["pt-br"] = "Brazilian Portuguese",
	["pt-pt"] = "Portuguese",
	ru        = "Russian",
	sk        = "Slovak",
	["sv-se"] = "Swedish",
	th        = "Thai",
	tr        = "Turkish",
	uk        = "Ukranian",
	vi        = "Vietnamese",
	["zh-cn"] = "Simplified Chinese",
	["zh-tw"] = "Traditional Chinese",
}

localizations = localizations or {
	bg        = {},
	cs        = {},
	da        = {},
	de        = {},
	el        = {},
	["en-pt"] = {},
	en        = {},
	es        = {},
	et        = {},
	fi        = {},
	fr        = {},
	he        = {},
	hr        = {},
	hu        = {},
	it        = {},
	ja        = {},
	ko        = {},
	lt        = {},
	nl        = {},
	no        = {},
	pl        = {},
	["pt-br"] = {},
	["pt-pt"] = {},
	ru        = {},
	sk        = {},
	["sv-se"] = {},
	th        = {},
	tr        = {},
	uk        = {},
	vi        = {},
	["zh-cn"] = {},
	["zh-tw"] = {},
}

--[[--------------------------------------------------------------------------
-- 	Localized Functions & Variables
--------------------------------------------------------------------------]]--

local error = error
local include = include
local tostring = tostring
local GetConVar = GetConVar
local AddCSLuaFile = AddCSLuaFile

FALLBACK = FALLBACK or "en"

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
-- 	localify.Bind( string, string )
--
--	Binds the token (key) and localized phrase (value) to the given language (lang).
--
--	Example: localify.Bind( "en", "#Hello", "Hello" )
--	Example: localify.Bind( "es", "#Hello", "Hola" )
--	Example: localify.Bind( "fr", "#Hello", "Bonjour" )
--]]--
function Bind( lang, key, value )
	if ( not IsValidLanguage( lang ) ) then error( "Invalid language provided ('"..tostring(lang).."')" ) return end
	
	localizations[ lang:lower() ][ key ] = value
end

--[[--------------------------------------------------------------------------
-- 	localify.Localize( string, string )
--
--	Returns the localized phrase associated with the token (key).
--	If a language (lang) is provided, the phrase bound to that language will be returned.
--	If no language is provided, the language will default to the client or server's locale.
--	If a localized phrase is not found and returnKey is true-ful,  the key will be returned.
--	If a localized phrase is not found and returnKey is false-ful, the phrase associated with the fallback language (en' by default) will be returned, if any.
--	Otherwise, nil will be returned if no binding exists.
--
--	Example: local str = localify.Localize( "#Hello" )             -- Returns either the locale's binding or the default binding (if any)
--	Example: local str = localify.Localize( "#Hello", "es" )       -- Returns either a Spanish binding, the locale's binding, or the default binding (if any)
--	Example: local str = localify.Localize( "#Hello", "fr" )       -- Returns either a French  binding, the locale's binding, or the default binding (if any)
--	Example: local str = localify.Localize( "#Hello", "de", true ) -- Returns either a German  binding, the locale's binding, or the key
--	Example: local str = localify.Localize( "#Hello",  nil, true ) -- Returns either the locale's binding or the key
--]]--
function Localize( key, lang, returnKey )
	if ( lang and not IsValidLanguage( lang ) ) then error( "Invalid language provided ('"..tostring(lang).."')" ) return end
	
	local tbl = localizations[ (lang and lang:lower()) or GetLocale() ]

	return ( tbl and tbl[ key ] )                                             -- If there is a bind, return it
		or ( returnKey and key )                                              -- If there is no bind and we want to return the key on failure, return the key
		or ( localizations[ FALLBACK ] and localizations[ FALLBACK ][ key ] ) -- If there is a bind in the fallback language, return it
		or nil                                                                -- Otherwise return nil
end



--[[--------------------------------------------------------------------------
-- 	localify.AddLanguage( string, string )
--
--	Adds a non-GMod language to the table of valid languages.
--
--	Example: localify.AddLanguage( "zom", "Zombie" )
--	Example: localify.AddLanguage( "fil", "Filipino" )
--]]--
function AddLanguage( lang, name )
	if ( IsValidLanguage( lang ) ) then return end
	
	    languages[ lang:lower() ] = name
	localizations[ lang:lower() ] = {}
end

--[[--------------------------------------------------------------------------
-- 	localify.RemoveLanguage( string )
--
--	Removes a language from the table of valid languages.
--	If the removed language was the fallback language, "en" (English) will be
--	set as the new fallback language automatically.
--
--	Example: localify.RemoveLanguage( "zom" )
--	Example: localify.RemoveLanguage( "fil" )
--]]--
function RemoveLanguage( lang )
	if ( not IsValidLanguage( lang ) ) then return end
	
	    languages[ lang:lower() ] = nil
	localizations[ lang:lower() ] = nil
	
	if ( lang:lower() == FALLBACK ) then FALLBACK = "en" end
end

--[[--------------------------------------------------------------------------
-- 	localify.IsValidLanguage()
--
--	Checks if the passed 2- or 4-letter language code is supported by Localify.
--	Returns true if valid, false if invalid.
--
--	Example: localify.IsValidLanguage( "vi" ) --  true by default
--	Example: localify.IsValidLanguage( "zz" ) -- false by default
--]]--
function IsValidLanguage( lang )
	return lang and languages[ lang:lower() ]
end

--[[--------------------------------------------------------------------------
-- 	localify.SetFallbackLanguage()
--
--	Sets the fallback language to use when a localized phrase is unavailable.
--	This is set to "en" (English) by default.
--
--	Example: localify.SetFallbackLanguage( "de" ) -- fallback language is now German
--]]--
function SetFallbackLanguage( lang )
	if ( not IsValidLanguage( lang ) ) then error( "Invalid language provided ('"..tostring(lang).."')" ) return end
	
	FALLBACK = lang:lower()
end



--[[--------------------------------------------------------------------------
-- 	localify.GetLocale( player )
--
--	Returns the client or server's in-game locale (separate from system locale).
--	Returns the fallback language if the cvar is empty.
--	The cvar holding this value is "gmod_language".
--]]--
function GetLocale( ply )
	return ( SERVER and ply and ply:GetInfo( "localify_language" ):lower() )
	    or ( GetConVarString( "localify_language" ) == "" and FALLBACK or GetConVarString( "localify_language" ):lower() )
end

--[[--------------------------------------------------------------------------
-- 	localify.GetLanguages( string )
--
--	Returns the table of valid languages and their associated names.
--]]--
function GetLanguages()
	return languages
end

--[[--------------------------------------------------------------------------
-- 	localify.GetLocalizations( string )
--
--	Returns every bound localization, the bindings of the given language, or nil
--	if no language was found. If the language is valid but doesn't contain any bindings,
--	an empty table will be returned.
--
--	Example: localify.GetLocalizations()       -- returns bindings for every language
--	Example: localify.GetLocalizations( "en" ) -- returns all English bindings
--]]--
function GetLocalizations( lang )
	return ( not lang and localizations ) or ( lang and localizations[ lang:lower() ] ) or nil
end

--[[--------------------------------------------------------------------------
-- 	localify.GetFallbackLanguage()
--
--	Returns the current fallback language ("en" by default).
--]]--
function GetFallbackLanguage()
	return FALLBACK
end



--[[--------------------------------------------------------------------------
-- 	localify.LoadSharedFile( string )
--
--	Loads a file containing localization phrases onto the server and connecting clients.
--]]--
function LoadSharedFile( path )
	include( path )
	if ( SERVER ) then AddCSLuaFile( path ) end
end

--[[--------------------------------------------------------------------------
-- 	localify.LoadServerFile( string )
--
--	Loads a file containing localization phrases onto the server.
--]]--
function LoadServerFile( path )
	if ( CLIENT ) then return end
	include( path )
end

--[[--------------------------------------------------------------------------
-- 	localify.LoadClientFile( string )
--
--	Loads a file containing localization phrases onto connecting clients.
--]]--
function LoadClientFile( path )
	if ( SERVER ) then AddCSLuaFile( path ) return end
	include( path )
end



if ( CLIENT ) then

	-- Create a client cvar that copies the gmod_language cvar so that we can retrieve it from
	-- the server with ply:GetInfo( "localify_language" )
	CreateClientConVar( "localify_language", GetConVarString( "gmod_language" ), false, true )

	-- Check for changes to the gmod_language cvar and replicate them to localify_language
	cvars.AddChangeCallback( "gmod_language", function( name, old, new )
		if ( not IsValidLanguage( new ) ) then return end
		
		RunConsoleCommand( "localify_language", new )
	end, "localify" )

end
--addons/tools/lua/weapons/gmod_tool/stools/textscreen.lua:
TOOL.Category = "Construction"
TOOL.Name = "#tool.textscreen.name"
TOOL.Command = nil
TOOL.ConfigName = ""
local textBox = {}
local lineLabels = {}
local labels = {}
local sliders = {}
local rainbowCheckboxes = {}
local textscreenFonts = textscreenFonts
local rainbow_enabled = cvars.Number("ss_enable_rainbow", 1)
local max_characters = cvars.Number("ss_max_characters", 0)

for i = 1, 5 do
	TOOL.ClientConVar["text" .. i] = ""
	TOOL.ClientConVar["size" .. i] = 20
	TOOL.ClientConVar["r" .. i] = 255
	TOOL.ClientConVar["g" .. i] = 255
	TOOL.ClientConVar["b" .. i] = 255
	TOOL.ClientConVar["a" .. i] = 255
	TOOL.ClientConVar["font" .. i] = 1
	TOOL.ClientConVar["rainbow" .. i] = 0
end

cleanup.Register("textscreens")

if (CLIENT) then
	TOOL.Information = {
		{ name = "left" },
		{ name = "right" },
		{ name = "reload" },
	}
	-- Add default english language strings here, in case no localisation exists
	language.Add("tool.textscreen.name", "3D2D Textscreen")
	language.Add("tool.textscreen.desc", "Create a textscreen with multiple lines, font colours and sizes.")
	language.Add("tool.textscreen.left", "Spawn a textscreen.") -- Does not work with capital T in tool. Same with right and reload.
	language.Add("tool.textscreen.right", "Update textscreen with settings.")
	language.Add("tool.textscreen.reload", "Copy textscreen.")
	language.Add("Undone.textscreens", "Undone textscreen")
	language.Add("Undone_textscreens", "Undone textscreen")
	language.Add("Cleanup.textscreens", "Textscreens")
	language.Add("Cleanup_textscreens", "Textscreens")
	language.Add("Cleaned.textscreens", "Cleaned up all textscreens")
	language.Add("Cleaned_textscreens", "Cleaned up all textscreens")
	language.Add("SBoxLimit.textscreens", "You've hit the textscreen limit!")
	language.Add("SBoxLimit_textscreens", "You've hit the textscreen limit!")
end

function TOOL:LeftClick(tr)
	if (tr.Entity:GetClass() == "player") then return false end
	if (CLIENT) then return true end
	local ply = self:GetOwner()

	if hook.Run("PlayerSpawnTextscreen", ply, tr) == false then return false end

	if not (self:GetWeapon():CheckLimit("textscreens")) then return false end
	-- ensure at least 1 line of the textscreen has text before creating entity
	local hasText = false
	for i = 1, 5 do
		local text = self:GetClientInfo("text" .. i) or ""
		if text ~= "" then
			hasText = true
		end
	end
	if not hasText then return false end
	local textScreen = ents.Create("sammyservers_textscreen")
	textScreen:SetPos(tr.HitPos)
	local angle = tr.HitNormal:Angle()
	angle:RotateAroundAxis(tr.HitNormal:Angle():Right(), -90)
	angle:RotateAroundAxis(tr.HitNormal:Angle():Forward(), 90)
	textScreen:SetAngles(angle)
	textScreen:Spawn()
	textScreen:Activate()

	undo.Create("textscreens")
	undo.AddEntity(textScreen)
	undo.SetPlayer(ply)
	undo.Finish()
	ply:AddCount("textscreens", textScreen)
	ply:AddCleanup("textscreens", textScreen)

	for i = 1, 5 do
		local txt = self:GetClientInfo("text" .. i) or ""
		textScreen:SetLine(
			i, -- Line
			max_characters ~= 0 and string.Left(txt, max_characters) or txt, -- text
			Color( -- Color
				tonumber(self:GetClientInfo("r" .. i)) or 255,
				tonumber(self:GetClientInfo("g" .. i)) or 255,
				tonumber(self:GetClientInfo("b" .. i)) or 255,
				tonumber(self:GetClientInfo("a" .. i)) or 255
			),
			tonumber(self:GetClientInfo("size" .. i)) or 20,
			-- font
			tonumber(self:GetClientInfo("font" .. i)) or 1,

			rainbow_enabled == 1 and tonumber(self:GetClientInfo("rainbow" .. i)) or 0
		)
	end

	return true
end

function TOOL:RightClick(tr)
	if (tr.Entity:GetClass() == "player") then return false end
	if (CLIENT) then return true end
	local traceEnt = tr.Entity

	if (IsValid(traceEnt) and traceEnt:GetClass() == "sammyservers_textscreen") then
		for i = 1, 5 do
			local txt = tostring(self:GetClientInfo("text" .. i))
			traceEnt:SetLine(
				i, -- Line
				max_characters ~= 0 and string.Left(txt, max_characters) or txt, -- text
				Color( -- Color
					tonumber(self:GetClientInfo("r" .. i)) or 255,
					tonumber(self:GetClientInfo("g" .. i)) or 255,
					tonumber(self:GetClientInfo("b" .. i)) or 255,
					tonumber(self:GetClientInfo("a" .. i)) or 255
				),
				tonumber(self:GetClientInfo("size" .. i)) or 20,
				-- font
				tonumber(self:GetClientInfo("font" .. i)) or 1,

				rainbow_enabled and tonumber(self:GetClientInfo("rainbow" .. i)) or 0
			)
		end

		traceEnt:Broadcast()

		return true
	end
end

function TOOL:Reload(tr)
	if (SERVER) then return true end
	local traceEnt = tr.Entity
	if (not isentity(traceEnt) or traceEnt:GetClass() ~= "sammyservers_textscreen") then return false end

	for i = 1, 5 do
		local linedata = traceEnt.lines[i]
		RunConsoleCommand("textscreen_r" .. i, linedata.color.r)
		RunConsoleCommand("textscreen_g" .. i, linedata.color.g)
		RunConsoleCommand("textscreen_b" .. i, linedata.color.b)
		RunConsoleCommand("textscreen_a" .. i, linedata.color.a)
		RunConsoleCommand("textscreen_size" .. i, linedata.size)
		RunConsoleCommand("textscreen_text" .. i, linedata.text)
		RunConsoleCommand("textscreen_font" .. i, linedata.font)
		RunConsoleCommand("textscreen_rainbow" .. i, linedata.rainbow)
	end

	return true
end

local conVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel(CPanel)
	local logo = vgui.Create("DImage", CPanel)
	logo:SetSize(267, 134)
	logo:SetImage("textscreens/logo.png")
	CPanel:AddItem(logo)

	CPanel:AddControl("Header", {
		Text = "#tool.textscreen.name",
		Description = "#tool.textscreen.desc"
	})

	local analytics = vgui.Create("DCheckBoxLabel", CPanel)
	analytics:SetText("Anonymous Analytics")
	analytics:SetTextColor(Color(0,0,0,255))
	analytics:SetConVar("ss_call_to_home")
	analytics:SetTooltip("Enabling this will submit anonymous analytics to the author of this addon, including your Operating System, version of the addon, and anonymised IP address.")
	CPanel:AddItem(analytics)

	local function TrimFontName(fontnum)
		return string.Left(textscreenFonts[fontnum], 8) == "Screens_" and string.TrimLeft(textscreenFonts[fontnum], "Screens_") or textscreenFonts[fontnum]
	end

	local changefont
	local fontnum = textscreenFonts[GetConVar("textscreen_font1"):GetInt()] ~= nil and GetConVar("textscreen_font1"):GetInt() or 1

	cvars.AddChangeCallback("textscreen_font1", function(convar_name, value_old, value_new)
		fontnum = textscreenFonts[tonumber(value_new)] ~= nil and tonumber(value_new) or 1
		local font = TrimFontName(fontnum)
		changefont:SetText("Change font (" .. font .. ")")
	end)

	local function ResetFont(lines, text)
		if #lines >= 5 then
			fontnum = 1
			for i = 1, 5 do
				RunConsoleCommand("textscreen_font" .. i, 1)
			end
		end
		for k, i in pairs(lines) do
			if text then
				RunConsoleCommand("textscreen_text" .. i, "")
				labels[i]:SetText("")
			end
			labels[i]:SetFont(textscreenFonts[fontnum] .. "_MENU")
		end
	end

	resetall = vgui.Create("DButton", resetbuttons)
	resetall:SetSize(100, 25)
	resetall:SetText("Reset all")

	resetall.DoClick = function()
		local menu = DermaMenu()

		menu:AddOption("Reset colors", function()
			for i = 1, 5 do
				RunConsoleCommand("textscreen_r" .. i, 255)
				RunConsoleCommand("textscreen_g" .. i, 255)
				RunConsoleCommand("textscreen_b" .. i, 255)
				RunConsoleCommand("textscreen_a" .. i, 255)
			end
		end)

		menu:AddOption("Reset sizes", function()
			for i = 1, 5 do
				RunConsoleCommand("textscreen_size" .. i, 20)
				sliders[i]:SetValue(20)
				labels[i]:SetFont(textscreenFonts[fontnum] .. "_MENU")
			end
		end)

		menu:AddOption("Reset textboxes", function()
			for i = 1, 5 do
				RunConsoleCommand("textscreen_text" .. i, "")
				textBox[i]:SetValue("")
			end
		end)

		menu:AddOption("Reset fonts", function()
			ResetFont({1, 2, 3, 4, 5}, false)
		end)

		if rainbow_enabled == 1 then
			menu:AddOption("Reset rainbow", function()
				for i = 1, 5 do
					rainbowCheckboxes[i]:SetValue(0)
				end
			end)
		end

		menu:AddOption("Reset everything", function()
			for i = 1, 5 do
				RunConsoleCommand("textscreen_r" .. i, 255)
				RunConsoleCommand("textscreen_g" .. i, 255)
				RunConsoleCommand("textscreen_b" .. i, 255)
				RunConsoleCommand("textscreen_a" .. i, 255)
				RunConsoleCommand("textscreen_size" .. i, 20)
				sliders[i]:SetValue(20)
				RunConsoleCommand("textscreen_text" .. i, "")
				RunConsoleCommand("textscreen_font" .. i, 1)
				textBox[i]:SetValue("")
				if rainbow_enabled == 1 then
					rainbowCheckboxes[i]:SetValue(0)
				end
			end
			ResetFont({1, 2, 3, 4, 5}, true)
		end)

		menu:Open()
	end

	CPanel:AddItem(resetall)
	resetline = vgui.Create("DButton")
	resetline:SetSize(100, 25)
	resetline:SetText("Reset line")

	resetline.DoClick = function()
		local menu = DermaMenu()

		for i = 1, 5 do
			menu:AddOption("Reset line " .. i, function()
				RunConsoleCommand("textscreen_r" .. i, 255)
				RunConsoleCommand("textscreen_g" .. i, 255)
				RunConsoleCommand("textscreen_b" .. i, 255)
				RunConsoleCommand("textscreen_a" .. i, 255)
				RunConsoleCommand("textscreen_size" .. i, 20)
				sliders[i]:SetValue(20)
				RunConsoleCommand("textscreen_text" .. i, "")
				textBox[i]:SetValue("")
				ResetFont({i}, true)
			end)
		end

		menu:AddOption("Reset all lines", function()
			for i = 1, 5 do
				RunConsoleCommand("textscreen_r" .. i, 255)
				RunConsoleCommand("textscreen_g" .. i, 255)
				RunConsoleCommand("textscreen_b" .. i, 255)
				RunConsoleCommand("textscreen_a" .. i, 255)
				RunConsoleCommand("textscreen_size" .. i, 20)
				sliders[i]:SetValue(20)
				RunConsoleCommand("textscreen_text" .. i, "")
				RunConsoleCommand("textscreen_font" .. i, 1)
				textBox[i]:SetValue("")
			end
			ResetFont({1, 2, 3, 4, 5}, true)
		end)

		menu:Open()
	end

	CPanel:AddItem(resetline)

	-- Change font
	changefont = vgui.Create("DButton")
	changefont:SetSize(100, 25)
	changefont:SetText("Change font (" .. TrimFontName(fontnum) .. ")" )

	changefont.DoClick = function()
		local menu = DermaMenu()

		for i = 1, #textscreenFonts do
			local font = TrimFontName(i)
			menu:AddOption(font, function()
				fontnum = i
				for o = 1, 5 do
					RunConsoleCommand("textscreen_font" .. o, i)
					labels[o]:SetFont(textscreenFonts[fontnum] .. "_MENU")
				end
				changefont:SetText("Change font (" .. font .. ")")
			end)
		end

		menu:Open()
	end

	CPanel:AddItem(changefont)

	CPanel:AddControl("ComboBox", {
		MenuButton = 1,
		Folder = "textscreen",
		Options = {
			["#preset.default"] = conVarsDefault
		},
		CVars = table.GetKeys(conVarsDefault)
	})

	for i = 1, 5 do
		lineLabels[i] = CPanel:AddControl("Label", {
			Text = "Line " .. i,
			Description = "Line " .. i
		})

		lineLabels[i]:SetFont("Default")

		CPanel:AddControl("Color", {
			Label = "Line " .. i .. " font color",
			Red = "textscreen_r" .. i,
			Green = "textscreen_g" .. i,
			Blue = "textscreen_b" .. i,
			Alpha = "textscreen_a" .. i,
			ShowHSV = 1,
			ShowRGB = 1,
			Multiplier = 255
		})

		if rainbow_enabled == 1 then
			rainbowCheckboxes[i] = vgui.Create("DCheckBoxLabel")
			rainbowCheckboxes[i]:SetText("Rainbow Text")
			rainbowCheckboxes[i]:SetTextColor(Color(0,0,0,255))
			rainbowCheckboxes[i]:SetConVar("textscreen_rainbow" .. i)
			rainbowCheckboxes[i]:SetTooltip("Enable for rainbow text")
			rainbowCheckboxes[i]:SetValue(GetConVar("textscreen_rainbow" .. i):GetInt())
			CPanel:AddItem(rainbowCheckboxes[i])
		end

		sliders[i] = vgui.Create("DNumSlider")
		sliders[i]:SetText("Font size")
		sliders[i]:SetMinMax(20, 100)
		sliders[i]:SetDecimals(0)
		sliders[i]:SetValue(GetConVar("textscreen_size" .. i))
		sliders[i]:SetConVar("textscreen_size" .. i)

		CPanel:AddItem(sliders[i])
		textBox[i] = vgui.Create("DTextEntry")
		textBox[i]:SetUpdateOnType(true)
		textBox[i]:SetEnterAllowed(true)
		textBox[i]:SetConVar("textscreen_text" .. i)
		textBox[i]:SetValue(GetConVar("textscreen_text" .. i):GetString())

		textBox[i].OnTextChanged = function()
			labels[i]:SetText(textBox[i]:GetValue())
		end

		if max_characters ~= 0 then
			textBox[i].AllowInput = function()
				if string.len(textBox[i]:GetValue()) >= max_characters then return true end
			end
		end

		CPanel:AddItem(textBox[i])

		labels[i] = CPanel:AddControl("Label", {
			Text = #GetConVar("textscreen_text" .. i):GetString() >= 1 and GetConVar("textscreen_text" .. i):GetString() or "Line " .. i,
			Description = "Line " .. i
		})

		labels[i]:SetFont(textscreenFonts[fontnum] .. "_MENU")
		labels[i]:SetAutoStretchVertical(true)
		labels[i]:SetDisabled(true)
		labels[i]:SetHeight(50)

		labels[i].Think = function()
			labels[i]:SetColor(
				Color(
					GetConVar("textscreen_r" .. i):GetInt(),
					GetConVar("textscreen_g" .. i):GetInt(),
					GetConVar("textscreen_b" .. i):GetInt(),
					GetConVar("textscreen_a" .. i):GetInt()
				)
			)
		end
	end
end

--lua/weapons/katana/shared.lua:
SWEP.Author       = "Killua"
SWEP.PrintName    = " Katana"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Simple"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee2"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 50
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-47.778, 0, 0) }
}
SWEP.VElements = {
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 45, 0), size = Vector(0.05, 0.039, 0.109), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/bluemetal", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.8), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/triangles/1x1x1carved025.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 15), angle = Angle(0, 45, 0), size = Vector(0.014, 0.014, 0.5), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils1"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 50, 8), size = Vector(0.05, 0.039, 0.109), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/bluemetal", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils1", pos = Vector(0, 0, 4.8), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/triangles/1x1x1carved025.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils1", pos = Vector(0, 0, 18), angle = Angle(0, 45, 0), size = Vector(0.014, 0.014, 0.6), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
}

SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 30
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.26
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 16

SWEP.Secondary.Life        = true
SWEP.Secondary.Damage 	   = 60
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--lua/weapons/knuckle/shared.lua:
if CLIENT then
SWEP.DrawWeaponInfoBox = true
end

SWEP.Author       = "-CRY-minal-"
SWEP.Purpose      = "Knuckles, what did you think?"
SWEP.Instructions = "Kick their ass!"

SWEP.PrintName = " Knuckle"
SWEP.Category = "Gluk Melee"
SWEP.Spawnable= true

SWEP.ViewModelFOV = 60
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = ""
SWEP.ViewModelFlip = false
SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.HoldType = "knife"

SWEP.AutoSwitchTo = true
SWEP.AutoSwitchFrom = false
SWEP.Weight = 0
SWEP.Slot = 0
SWEP.SlotPos = 0

SWEP.UseHands = true
SWEP.DrawAmmo = false
SWEP.Base = "weapon_base"

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Damage = 41
SWEP.Primary.DelayMiss = 0.7
SWEP.Primary.DelayHit = 0.9
SWEP.Primary.Force = 3000

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.ViewModelBoneMods = {
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["part1"] = { type = "Model", model = "models/props_c17/TrapPropeller_Lever.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0.05, 0.2, 1.5), angle = Angle(180, 90, -90), size = Vector(0.3, 0.3, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["part2"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 1.299, 3), angle = Angle(0, 180, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["part3"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 2.2, 2), angle = Angle(0, 180, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["part5"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 2, -0.301), angle = Angle(0, 180, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["part4"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 2.599, 0.899), angle = Angle(0, 180, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["part5"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4.9, 0, 0), angle = Angle(0, 90, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["part2"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4.9, 0, -1.5), angle = Angle(0, 90, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["part3"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.599, 0, 1.2), angle = Angle(0, 90, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["part1"] = { type = "Model", model = "models/props_c17/TrapPropeller_Lever.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.599, 0, 0), angle = Angle(0, 0, 90), size = Vector(0.3, 0.3, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["part4"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.599, 0, -2.3), angle = Angle(0, 90, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} }
}

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 64,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 64,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if !tr.Hit then
self.Owner:EmitSound( "Weapon_HL_Crowbar.Miss" )
end
if tr.Hit then
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = 64
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = 0
bullet.Damage = 0
bullet.AmmoType = "none"
self.Owner:FireBullets( bullet )
if tr.Entity:IsNPC() || tr.Entity:IsPlayer() then
self.Owner:EmitSound( "Flesh.ImpactHard" )
else
self.Owner:EmitSound( "Weapon_HL_Crowbar.Hit" )
end
end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:SecondaryAttack()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end






/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end
--addons/arccw_weapons/lua/weapons/masita_dc17.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-17"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DC-17 hand blaster, also known as DC-17 blaster pistol, was a heavy blaster pistol wielded by the clone troopers of the Grand Army of the Galactic Republic during the Clone Wars. An advanced firearm, it was fielded to elite soldiers in the army, most notably Advanced Recon Commandos, clone trooper commanders, and clone jet troopers."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc17.png"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/venator/weapons/viewmodels/c_dc17.mdl"
SWEP.WorldModel = "models/venator/weapons/worldmodels/w_dc-17.mdl"
SWEP.ViewModelFOV = 58
SWEP.WorldModelOffset = {
    pos = Vector(-11.3, 4.3, -3),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 29
SWEP.RangeMin = 102
SWEP.DamageMin = 23
SWEP.Range = 299
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.98
SWEP.RecoilPunch = 0.8
SWEP.RecoilSide = 0.17
SWEP.RecoilRise = 0.24

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
		Mode = -2
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 
SWEP.HipDispersion = 530
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

---- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.922, -4.125, 0.237),
    Ang = Vector(0.158, -3.961, 0),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

SWEP.Primary.Ammo = "ar2"

-- Sound & Holdtype
SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "armas/disparos/dc17_2.wav"
SWEP.ShootSound = "armas/disparos/dc17_1.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(1, 6, 1)
SWEP.ActiveAng = Angle(-3.2, -3, 0)

SWEP.SprintPos = Vector(1, -6, -10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(10, 0, -1.08)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Attachments 
SWEP.AttachmentElements = {
    ["dc17_powerpack"] = {
        VMBodygroups = {
            {ind = 4, bg = 1},
        },
    },
    ["dc17_cooling"] = {
        VMBodygroups = {
            {ind = 3, bg = 1},
        },
    },
}


SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0, -2.3, 0),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(9, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        WMScale = Vector(0.7, 0.7, 0.7),
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0, -0.3, 2.7),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Muzzle", 
        DefaultAttName = "None", 
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0, -1.2, 3.442),
            vang = Angle(90, 0, -90),
        },
    }, 
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },        
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Cooling System",
        DefaultAttName = "None",
        Slot = "dc17_cooling",
    },
    {
        PrintName = "Powerpack",
        DefaultAttName = "None",
        Slot = "dc17_powerpack",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7,0.7,0.7),
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0.7, -0.848, 0.184),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0.7, -0.848, -3),
            vang = Angle(90, 0, -90),
        },
    },   
}


SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        SoundTable = {
            {s = "dc17_1", t = 1 / 60}, --s sound file
        },
    },


sound.Add({
    name =          "dc17_1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "armasclasicas/wpn_wristrocket_reload.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/masita_westarm5_alpha.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita/Meeks"
SWEP.PrintName = "Westar M-5 Alpha"
SWEP.Trivia_Class = "Modular Blaster"
SWEP.Trivia_Desc = "The WESTAR-M5 blaster rifle was a blaster rifle used during the Clone Wars by the Grand Army of the Republic. They were mainly used by the Alpha-class Advanced Recon Commandos during the later years of the conflict."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/westarm5_alpha.png"

SWEP.ViewModel = "models/ser/starwars/c_westarm5.mdl"
SWEP.WorldModel = "models/ser/starwars/w_westarm5.mdl"
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "111"
SWEP.DefaultWMBodygroups = "111"
SWEP.DefaultSkin = 3
SWEP.DefaultWMSkin = 3

SWEP.NoHideLeftHandInCustomization = false

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.7,
    [HITGROUP_CHEST] = 1.5,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 47
SWEP.DamageMin = 22 -- damage done at maximum range
SWEP.RangeMin = 172 -- how far bullets will retain their maximum damage for
SWEP.Range = 340 -- in METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false

SWEP.MuzzleVelocity = 472

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 3
SWEP.TracerNum = 1 
SWEP.TracerFinalMag = 0 
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 47, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 50 -- DefaultClip is automatically set.

SWEP.AmmoPerShot = 1

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.Recoil = 0.2
SWEP.RecoilSide = 0.1
SWEP.RecoilRise = 0
SWEP.MaxRecoilBlowback = 1
SWEP.VisualRecoilMult = 1

SWEP.RecoilDirection = Angle(0.2, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1.1, 0)

SWEP.Delay = 60 / 580 
SWEP.Num = 1 
SWEP.Firemode = 2 
SWEP.Firemodes = {
	{
		Mode = 2,
   	},
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.NotForNPCS = true
SWEP.NPCWeaponType = nil

SWEP.AccuracyMOA = 5 
SWEP.HipDispersion = 410 
SWEP.MoveDispersion = 65
SWEP.SightsDispersion = 150 
SWEP.JumpDispersion = 200

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50 
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "armas/disparos/westar_1.wav"
SWEP.ShootSound = "armas/disparos/westar_2.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"


SWEP.NoFlash = nil

SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false 

SWEP.MuzzleEffectAttachment = 1 
SWEP.ProceduralViewBobAttachment = 1
SWEP.MuzzleFlashColor = Color(0, 102, 255)

SWEP.SpeedMult = 0.87
SWEP.SightedSpeedMult = 0.77
SWEP.ShootSpeedMult = 1

SWEP.IronSightStruct = {
    Pos = Vector(-3.05, -0, 2.1),
    Ang = Angle(0, 0, 0),
    Midpoint = {
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
    },
    Magnification = 1.2,
    SwitchToSound = "armasclasicas/wpn_cis_medequip.wav",
    CrosshairInSights = false,
}


SWEP.SightTime = 0.13
SWEP.SprintTime = 0


SWEP.Malfunction = false
SWEP.MalfunctionJam = true 
SWEP.MalfunctionTakeRound = true 
SWEP.MalfunctionWait = 0.5 
SWEP.MalfunctionMean = nil 
SWEP.MalfunctionVariance = 0.25
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoldtypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2
SWEP.CanBash = true
SWEP.MeleeDamage = 27
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2
SWEP.SprintPos = Vector(.5, -6, -12)
SWEP.SprintAng = Angle(40, 0, 0)
SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)
SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)
SWEP.ActivePos = Vector(0, 3, 1)
SWEP.ActiveAng = Angle(0, 0, 0)
SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.CustomizePos = Vector(6.824, -7, 4.897)
SWEP.CustomizeAng = Angle(12.149, 45.547, 45)
SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.SightPlusOffset = true

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        WMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(15, 0.5, -8),
                    ang = Angle(0, 0, 0)
                },
                IsMuzzleDevice = true
            }
        }, 
    },
}

SWEP.Attachments = {
	{
		PrintName = "Sight",
		DefaultAttName = "Standard",
		Slot = "optic",
		Bone = "weapon",
		Offset = {
            vpos = Vector(0.02, -2.4, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 1, -7),
            wang = Angle(-10, 2, 180)
        },
	},
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
		Bone = "weapon",
        Offset = {
            vpos = Vector(0.8, -0.8, 4),
            vang = Angle(90, 0, -0),
            wpos = Vector(7, 2, -5.5),
            wang = Angle(-10, 5, -90)
        },
    },
    {
        PrintName = "Charms", 
        DefaultAttName = "None",
        Slot = {"charm"},
		Bone = "weapon",
        Offset = {
            vpos = Vector(1, -1, -3.2),
            vang = Angle(90, 0, -90),
            wpos = Vector(1.2, 2.2, -4.5),
            wang = Angle(0, 0, 180)
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "No Attachment", 
        Slot = "foregrip",
        Bone = "weapon",
        Offset = {
            vpos = Vector(0, 2.2, 2.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(9, .5, -1.5),
            wang = Angle(0, 0, 180)            
        },
        NoWM = true,
        NoVM = true,    
    },
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk", 
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
		Bone = "weapon",
        Offset = {
            vpos = Vector(0, -0.9, 8.1),
            vang = Angle(90, 0, 0),
            wpos = Vector(16, .5, -7.2),
            wang = Angle(-10, 0, -90)
        },
    },                              
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = "fire",
    },
	["idle_sights"] = {
        Source = "idle",
        Mult = 10000,
    },
	["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
		SoundTable = {
	        {s = "armas/misc/westar_reload.mp3", t = 0.1 }
        },
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_02.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "everfall/weapons/handling/023d-00000d8c.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
}
--addons/joes_stuff/lua/weapons/shield_deployer_5/shared.lua:
AddCSLuaFile()

SWEP.Base = "shield_deployer_base"
SWEP.PrintName = "Shield Level 5 Deployer"
SWEP.Category = "AOCRP - Schilde"

SWEP.Author = "Joe"
SWEP.Purpose = "Deploy Shields"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true


SWEP.ENT_CLASS = "shield_5"
--addons/aoc_fire_system/lua/weapons/weapon_extinguisher.lua:

--[[

If you want to override the default extinguishing action, or do something custom when something gets extinguished by this mod, use this hook

hook.Add( "ExtinguisherDoExtinguish", "", function( prop )
	print( prop ) -- The prop that is being extinguished, can be any entity
	return true -- true to prevent default action. Other values or no return will mean do default action.
end )

]]

AddCSLuaFile()
AddCSLuaFile( "effects/rb655_extinguisher_effect.lua" )

--if ( SERVER ) then resource.AddWorkshop( "104607228" ) end

SWEP.PrintName = "Feuerlscher"
SWEP.Author = "Robotboy655"
SWEP.Category = "AOCRP - Tools"
SWEP.Contact = "http://steamcommunity.com/profiles/76561197996891752"
SWEP.Purpose = "To extinguish fire!"
SWEP.Instructions = "Shoot into a fire, to extinguish it. Jump into water to get more ammo!"

SWEP.Slot = 5
SWEP.SlotPos = 35
SWEP.Weight = 1

SWEP.AutoSwitchTo = true
SWEP.AutoSwitchFrom = true

SWEP.DrawWeaponInfoBox = false
SWEP.Spawnable = true
SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/c_fire_extinguisher.mdl"
SWEP.ViewModelFOV = 55
SWEP.WorldModel = "models/weapons/w_fire_extinguisher.mdl"
SWEP.HoldType = "slam"

game.AddAmmoType( { name = "rb655_extinguisher" } )
if ( CLIENT ) then language.Add( "rb655_extinguisher_ammo", "Extinguisher Ammo" ) end

SWEP.MaxAmmo = 500

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = SWEP.MaxAmmo
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "rb655_extinguisher"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

function SWEP:SetupDataTables()
	self:NetworkVar( "Float", 0, "NextIdle" )
end

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
end

function SWEP:Deploy()
	self:SendWeaponAnim( ACT_VM_DRAW )
	self:SetNextPrimaryFire( CurTime() + self:SequenceDuration() )

	self:Idle()

	return true
end

function SWEP:Holster( weapon )
	if ( CLIENT ) then return end

	if ( self.Sound ) then
		self.Sound:Stop()
		self.Sound = nil
	end

	return true
end

function SWEP:OnDrop()
	if ( self.Sound ) then
		self.Sound:Stop()
		self.Sound = nil
	end

	-- Do not give any more extra ammo
	self.Primary.DefaultClip = 0
end

function SWEP:DoEffect( effectscale )

	local effectdata = EffectData()
	effectdata:SetAttachment( 1 )
	effectdata:SetEntity( self.Owner )
	effectdata:SetOrigin( self.Owner:GetShootPos() )
	effectdata:SetNormal( self.Owner:GetAimVector() )
	effectdata:SetScale( effectscale or 1 )
	util.Effect( "rb655_extinguisher_effect", effectdata )

end

function SWEP:DoExtinguish( pushforce, effectscale )

	if ( self:Ammo1() < 1 ) then return end

	if ( CLIENT ) then
		if ( self.Owner == LocalPlayer() ) then self:DoEffect( effectscale ) end -- FIXME
		return
	end

	if ( !self.IsInfinite ) then
		self:TakePrimaryAmmo( 1 )
	end

	effectscale = effectscale or 1
	pushforce = pushforce or 0

	local tr
	if ( self.Owner:IsNPC() ) then
		tr = util.TraceLine( {
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 16384,
			filter = self.Owner
		} )
	else
		tr = self.Owner:GetEyeTrace()
	end

	local pos = tr.HitPos

	for id, prop in pairs( ents.FindInSphere( pos, 80 ) ) do
		if ( !IsValid( prop ) or prop:GetPos():Distance( self:GetPos() ) > 256 ) then continue end
		if ( prop:IsWeapon() and IsValid( prop:GetOwner() ) ) then continue end -- Played equipped weapons
		if ( prop:GetClass():find( "viewmodel" ) ) then continue end -- View models

		if ( pushforce > 0 ) then
			local physobj = prop:GetPhysicsObject()
			if ( IsValid( physobj ) ) then
				physobj:ApplyForceOffset( self.Owner:GetAimVector() * pushforce, pos )
			end
		end

		-- Perhaps this random call should be replaced by a timer of sorts?
		if ( math.random( 0, 1000 ) > 500 ) then
			local retval = hook.Call( "ExtinguisherDoExtinguish", nil, prop )
			if ( retval == true ) then continue end

			if ( prop:IsOnFire() ) then prop:Extinguish() end

			local class = prop:GetClass()
			if ( string.find( class, "ent_minecraft_torch" ) and prop:GetWorking() ) then
				prop:SetWorking( false )
			elseif ( string.find( class, "env_fire" ) ) then -- Gas Can support. Should work in ravenholm too.
				prop:Fire( "Extinguish" )
			end
		end
	end

	self:DoEffect( effectscale )

end

function SWEP:PrimaryAttack()
	if ( self:GetNextPrimaryFire() > CurTime() ) then return end

	if ( IsFirstTimePredicted() ) then

		self:DoExtinguish( 196, 1 )

		if ( SERVER ) then

			if ( self.Owner:KeyPressed( IN_ATTACK ) or !self.Sound ) then
				self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )

				self.Sound = CreateSound( self.Owner, Sound( "weapons/extinguisher/fire1.wav" ) )

				self:Idle()
			end

			if ( self:Ammo1() > 0 and self.Sound ) then self.Sound:Play() end

		end

		if SERVER then
			local trace = {}
			trace.start = self.Owner:GetShootPos()
			trace.endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 150
			trace.filter = self.Owner
	
			local tr = util.TraceLine( trace )
			
			for k, v in ipairs( ents.FindInSphere( tr.HitPos, 50 ) ) do
				if v:GetClass() == "fire" then
					v:ExtinguishAttack( self.Owner, false )
				end
				
				if v:IsOnFire() then 
					v:Extinguish()
					v:SetColor( Color( 255, 255, 255, 255 ) )
				end
			end
		end

	end

	self:SetNextPrimaryFire( CurTime() + 0.05 )
end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
end

function SWEP:PlaySound()
	self:EmitSound( "weapons/extinguisher/release1.wav", 100, math.random( 95, 110 ) )
end

function SWEP:Think()

	if ( self:GetNextIdle() > 0 and CurTime() > self:GetNextIdle() ) then

		self:DoIdleAnimation()
		self:Idle()

	end

	if ( self:GetNextSecondaryFire() > CurTime() or CLIENT ) then return end

	if ( ( self.NextAmmoReplenish or 0 ) < CurTime() and self.Owner:WaterLevel() > 1 ) then
		if ( !self.IsInfinite && self:Ammo1() < self.MaxAmmo * 2 ) then
			self.Owner:SetAmmo( math.min( self:Ammo1() + 25, self.MaxAmmo * 2 ), self:GetPrimaryAmmoType() )
		end
		self.NextAmmoReplenish = CurTime() + 0.1
	end

	if ( self.Sound and self.Sound:IsPlaying() and self:Ammo1() < 1 ) then
		self.Sound:Stop()
		self.Sound = nil
		self:PlaySound()
		self:DoIdleAnimation()
		self:Idle()
	end

	if ( self.Owner:KeyReleased( IN_ATTACK ) or ( !self.Owner:KeyDown( IN_ATTACK ) and self.Sound ) ) then

		self:SendWeaponAnim( ACT_VM_SECONDARYATTACK )

		if ( self.Sound ) then
			self.Sound:Stop()
			self.Sound = nil
			if ( self:Ammo1() > 0 ) then
				self:PlaySound()
				if ( !game.SinglePlayer() ) then self:CallOnClient( "PlaySound", "" ) end
			end
		end

		self:SetNextPrimaryFire( CurTime() + self:SequenceDuration() )
		self:SetNextSecondaryFire( CurTime() + self:SequenceDuration() )

		self:Idle()

	end
end

function SWEP:DoIdleAnimation()
	if ( self.Owner:KeyDown( IN_ATTACK ) and self:Ammo1() > 0 ) then self:SendWeaponAnim( ACT_VM_IDLE_1 ) return end
	if ( self.Owner:KeyDown( IN_ATTACK ) and self:Ammo1() < 1 ) then self:SendWeaponAnim( ACT_VM_IDLE_EMPTY ) return end
	self:SendWeaponAnim( ACT_VM_IDLE )
end

function SWEP:Idle()

	self:SetNextIdle( CurTime() + self:GetAnimationTime() )

end

function SWEP:GetAnimationTime()
	local time = self:SequenceDuration()
	if ( time == 0 and IsValid( self.Owner ) and !self.Owner:IsNPC() and IsValid( self.Owner:GetViewModel() ) ) then time = self.Owner:GetViewModel():SequenceDuration() end
	return time
end

if ( SERVER ) then return end

SWEP.WepSelectIcon = Material( "icons/rb655_extinguisher_icon.png" )

function SWEP:DrawWeaponSelection( x, y, w, h, a )

	render.PushFilterMag( TEXFILTER.ANISOTROPIC )
	render.PushFilterMin( TEXFILTER.ANISOTROPIC )

	surface.SetDrawColor( 255, 255, 255, a )
	surface.SetMaterial( self.WepSelectIcon )

	local size = math.min( w, h ) - 32
	surface.DrawTexturedRect( x + w / 2 - size / 2, y + h * 0.05, size, size )

	render.PopFilterMag()
	render.PopFilterMin()

end

--addons/weapon_jedi/lua/weapons/weapon_lightsaber_dooku.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS("weapon_lscs")

SWEP.Category = "[LSCS]"
SWEP.PrintName = "Count Dooku"
SWEP.Author = "Deltaa"

SWEP.Slot = 0
SWEP.SlotPos = 3

SWEP.Spawnable = true
SWEP.AdminOnly = false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables(self)

	if SERVER then
		self:SetHiltR("dooku")
		self:SetBladeR("red")
	end
end

if CLIENT then return end 

function SWEP:ForcePowersGive(ply)
	ply:lscsWipeInventory()

	ply:lscsAddInventory("item_force_leap", true)
    ply:lscsAddInventory("item_force_push", true)
	ply:lscsAddInventory("item_force_pull", true)
	ply:lscsAddInventory("item_force_choke", true)
    ply:lscsAddInventory("item_force_lightning", true)
    ply:lscsAddInventory("item_force_throw", true)
    ply:lscsAddInventory("item_force_sprint", true)
    ply:lscsAddInventory("item_force_breach", true)
    ply:lscsAddInventory("item_force_mindtrick", true)
    ply:lscsAddInventory("item_force_unarm", true)
    ply:lscsAddInventory("item_force_whirlwind", true)

	ply:lscsAddInventory("item_stance_makashi", true)
    ply:lscsAddInventory("item_stance_niman", true)
	ply:lscsAddInventory("item_stance_shiicho", true)
end

function SWEP:Deploy() 
	BaseClass.Deploy(self)
	if not IsValid(self:GetOwner()) then return end

    self:GetOwner():lscsWipeInventory()

	self:ForcePowersGive(self:GetOwner())
end
--addons/weapon_jedi/lua/weapons/weapon_lightsaber_grievous.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS("weapon_lscs")

SWEP.Category = "[LSCS]"
SWEP.PrintName = "General Grievous"
SWEP.Author = "Deltaa"

SWEP.Slot = 0
SWEP.SlotPos = 3

SWEP.Spawnable = true
SWEP.AdminOnly = false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables(self)

	if SERVER then
        self:SetHiltL("jedicommon")
		self:SetHiltR("jedicommon")
		self:SetBladeL("blue")
        self:SetBladeR("green")

        self:SetStance("grievous")
	end
end

if CLIENT then return end 

function SWEP:ForcePowersGive(ply)
	ply:lscsWipeInventory()

	ply:lscsAddInventory("item_force_leap", true)
    ply:lscsAddInventory("item_force_push", true)
	ply:lscsAddInventory("item_force_pull", true)
	ply:lscsAddInventory("item_force_choke", true)
    ply:lscsAddInventory("item_force_sprint", true)
end

function SWEP:Deploy() 
	BaseClass.Deploy(self)
	if not IsValid(self:GetOwner()) then return end

    self:GetOwner():lscsWipeInventory()

	self:ForcePowersGive(self:GetOwner())
end
--addons/weapon_jedi/lua/weapons/weapon_lightsaber_solrac.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS("weapon_lscs")

SWEP.Category = "[LSCS]"
SWEP.PrintName = "Solrac Arslan"
SWEP.Author = "Deltaa"

SWEP.Slot = 0
SWEP.SlotPos = 3

SWEP.Spawnable = true
SWEP.AdminOnly = false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables(self)

	if SERVER then
		self:SetHiltR("guard")
		self:SetBladeR("green")
        self:SetStance("zephra")
	end
end

if CLIENT then return end

function SWEP:ForcePowersGive(ply)
	ply:lscsWipeInventory()

	ply:lscsAddInventory("item_force_leap", true)
    ply:lscsAddInventory("item_force_push", true)
	ply:lscsAddInventory("item_force_pull", true)
    ply:lscsAddInventory("item_force_throw", true)
    ply:lscsAddInventory("item_force_rockthrow", true)
    ply:lscsAddInventory("item_force_sprint", true)
    ply:lscsAddInventory("item_force_breach", true)
    ply:lscsAddInventory("item_force_mindtrick", true)
    ply:lscsAddInventory("item_force_unarm", true)
    ply:lscsAddInventory("item_force_whirlwind", true)
end

function SWEP:Deploy() 
	BaseClass.Deploy(self)
	if not IsValid(self:GetOwner()) then return end

    self:GetOwner():lscsWipeInventory()

	self:ForcePowersGive(self:GetOwner())
end
--addons/weapon_jedi/lua/weapons/weapon_lscs/shared.lua:

--SWEP.Base = "weapon_pvebase"
--DEFINE_BASECLASS( "weapon_pvebase" )
SWEP.Base = "weapon_base"

SWEP.Category			= "[LSCS]"

SWEP.PrintName		= "#lscsGlowstick"
SWEP.Author			= "Blu-x92 / Luna"

SWEP.ViewModel		= "models/weapons/c_arms.mdl"
SWEP.WorldModel		= "models/lscs/weapons/katarn.mdl"

SWEP.Spawnable		= true
SWEP.AdminOnly		= false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip		= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic		= false
SWEP.Secondary.Ammo		= "none"

SWEP.RenderGroup = RENDERGROUP_BOTH 

SWEP.AutoSwitchFrom = false

SWEP.LSCS = true

SWEP._tblHilt = {}
SWEP._tblBlade = {}

SWEP.HAND_RIGHT = 1
SWEP.HAND_LEFT = 2
SWEP.HAND_STRING = {
	[SWEP.HAND_RIGHT] = "RH",
	[SWEP.HAND_LEFT] = "LH",
}

SWEP.CachedSounds = {
	[SWEP.HAND_RIGHT]	= {
		AttackSound = "",
		AttackSound1 = "",
		AttackSound2 = "",
		AttackSound3 = "",
		ActivateSound = "",
		DisableSound = "",
		IdleSound = "",
	},
	[SWEP.HAND_LEFT] = {
		AttackSound = "",
		AttackSound1 = "",
		AttackSound2 = "",
		AttackSound3 = "",
		ActivateSound = "",
		DisableSound = "",
		IdleSound = "",
	},
}

function SWEP:SetupDataTables()
	self:NetworkVar( "Bool",0, "Active" )
	self:NetworkVar( "Bool",1, "NWDMGActive" )
	self:NetworkVar( "Bool",2, "AnimHasCancelAnim" )

	self:NetworkVar( "Float",0, "NWNextAttack" )
	self:NetworkVar( "Float",1, "NWGestureTime" )
	self:NetworkVar( "Float",2, "Length" )
	self:NetworkVar( "Float",3, "ComboHits" )

	self:NetworkVar( "Int",0, "NWStance" )
	self:NetworkVar( "Int",1, "BlockPoints" )

	self:NetworkVar( "Vector",0, "BlockPos" )

	self:NetworkVar( "String",0, "HiltR")
	self:NetworkVar( "String",1, "HiltL")
	self:NetworkVar( "String",2, "BladeR")
	self:NetworkVar( "String",3, "BladeL")

	self:NetworkVar( "Entity",0, "Projectile" )

	if SERVER then
		self:SetNWStance( 1 )
	end
end

function SWEP:IsThrown()
	return IsValid( self:GetProjectile() )
end

function SWEP:GetHiltData( hand )
	local HiltR = self:GetHiltR()
	local HiltL = self:GetHiltL()

	if self._oldHiltR ~= HiltR then
		self._oldHiltR = HiltR

		local _HiltR = LSCS:GetHilt( HiltR )

		self._tblHilt[self.HAND_RIGHT] = _HiltR

		if CLIENT then
			self:UpdateWorldModel(self.HAND_RIGHT, _HiltR)
		end
	end

	if self._oldHiltL ~= HiltL then
		self._oldHiltL = HiltL

		local _HiltL = LSCS:GetHilt( HiltL )

		self._tblHilt[self.HAND_LEFT] = _HiltL

		if CLIENT then
			self:UpdateWorldModel(self.HAND_LEFT, _HiltL)
		end
	end

	if hand then
		return self._tblHilt[ hand ]
	else
		return self._tblHilt
	end
end

function SWEP:GetBladeData( hand )
	local BladeR = self:GetBladeR()
	local BladeL = self:GetBladeL()

	if self._oldBladeR ~= BladeR then
		self._oldBladeR = BladeR
		self._tblBlade[1] = LSCS:GetBlade( BladeR )
	end

	if self._oldBladeL ~= BladeL then
		self._oldBladeL = BladeL
		self._tblBlade[2] = LSCS:GetBlade( BladeL )
	end

	if hand then
		return self._tblBlade[ hand ]
	else
		return self._tblBlade
	end
end

function SWEP:BuildSounds()
	if self:IsBrokenSaber() then return end

	for hand = 1, 2 do
		local data = self:GetBladeData()[ hand ]

		if data then
			local SND = data.sounds

			self.CachedSounds[ hand ] = {
				AttackSound = (SND.Attack or ""),
				AttackSound1 = (SND.Attack1 or ""),
				AttackSound2 = (SND.Attack2 or ""),
				AttackSound3 = (SND.Attack3 or ""),
				ActivateSound = (SND.Activate or ""),
				DisableSound = (SND.Disable or ""),
				IdleSound = (SND.Idle or ""),
			}
		else
			self.CachedSounds[ hand ] = {
				AttackSound = "",
				AttackSound1 = "",
				AttackSound2 = "",
				AttackSound3 = "",
				ActivateSound = "",
				DisableSound = "",
				IdleSound = "",
			}
		end
	end
end

function SWEP:SetDMGActive( active )
	if SERVER then
		self:SetNWDMGActive( active )
	else
		self.b_dmgActive = active
	end
end

function SWEP:GetDMGActive()
	if CLIENT and not self:IsThrown() then
		if self:GetOwner() ~= LocalPlayer() then
			return self:GetNWDMGActive()
		else
			return self.b_dmgActive
		end
	else
		return self:GetNWDMGActive()
	end
end

function SWEP:SetNextPrimaryAttack( time )
	self:SetNWNextAttack( time )
	self.f_NextAttack = time
end

function SWEP:GetNextPrimaryAttack()
	if game.SinglePlayer() then
		return (self.f_NextAttack or 0) -- singleplayer IS a prediction error
	else
		return math.max( (self.f_NextAttack or 0), self:GetNWNextAttack()) -- first variable is for prediction, second variable for correcting when the server responds.
	end
end

function SWEP:CanPrimaryAttack()
	return self:GetNextPrimaryAttack() < CurTime()
end

function SWEP:Initialize()
	self:SetHoldType( "normal" )
	self:DrawShadow( false )
	self:SetNextPrimaryAttack( CurTime() + 1 )
end

function SWEP:PrimaryAttack()
end

function SWEP:SecondaryAttack()
	if self:IsThrown() then return end

	local CurStance = self:GetNWStance()

	if CurStance == -1 then return end

	self:SetNWStance( CurStance + 1 )
end

function SWEP:DoAttackSound( N, hand )
	if not self:GetDMGActive() then return end

	if hand then
		if hand == self.HAND_LEFT and not self:GetCombo().LeftSaberActive then return end -- this is gay

		if N then
			if N == 1 then
				self:EmitSoundUnpredicted( self.CachedSounds[ hand ].AttackSound1 )
			elseif N == 2 then
				self:EmitSoundUnpredicted( self.CachedSounds[ hand ].AttackSound2 )
			elseif N == 3 then
				self:EmitSoundUnpredicted( self.CachedSounds[ hand ].AttackSound3 )
			else
				self:EmitSoundUnpredicted( self.CachedSounds[ hand ].AttackSound )
			end
		else
			self:EmitSoundUnpredicted( self.CachedSounds[ hand ].AttackSound )
		end
	else
		for hand = self.HAND_RIGHT, self.HAND_LEFT do
			if hand == self.HAND_LEFT and not self:GetCombo().LeftSaberActive then continue end -- this is gay

			if N then
				if N == 1 then
					self:EmitSoundUnpredicted( self.CachedSounds[ hand ].AttackSound1 )
				elseif N == 2 then
					self:EmitSoundUnpredicted( self.CachedSounds[ hand ].AttackSound2 )
				elseif N == 3 then
					self:EmitSoundUnpredicted( self.CachedSounds[ hand ].AttackSound3 )
				else
					self:EmitSoundUnpredicted( self.CachedSounds[ hand ].AttackSound )
				end
			else
				self:EmitSoundUnpredicted( self.CachedSounds[ hand ].AttackSound )
			end
		end
	end
end

function SWEP:Holster( wep )
	self:SetActive( false )
	self:SetLength( 0 )

	self:FinishCombo()

	self:Think()

	if SERVER then
		local ply = self:GetOwner()
		if IsValid( ply ) and ply:IsPlayer() then
			ply:lscsSetShouldBleed( true )
		end
	end

	return true
end

function SWEP:BeginAttack()
	self:SetDMGActive( true )
end

function SWEP:FinishAttack()
	self:SetDMGActive( false )

	local ply = self:GetOwner()
	if IsValid( ply ) then
		ply:lscsClearTimedMove()
		ply:Freeze( false )
	end

	self:SetBlockPos( Vector(0,0,0) )
end

function SWEP:Deploy()
	return true
end

function SWEP:OwnerChanged()
end

function SWEP:IsBrokenSaber()
	if not self._IsBroken then
		local Hilt1 = self:GetHiltR() == "" and 0 or 1
		local Hilt2 = self:GetHiltL() == "" and 0 or 1
		local Blade1 = self:GetBladeR() == "" and 0 or 1
		local Blade2 = self:GetBladeL() == "" and 0 or 1

		self._IsBroken = ((Hilt1 + Blade1) ~= 2 and (Hilt2 + Blade2) ~= 2)
	end

	return self._IsBroken
end

function SWEP:Think()
	self:ComboThink()

	local Active = self:GetActive()
	local Stance = self:GetStance()

	local FT = FrameTime()
	local Length = self:GetLength()

	self:SetLength( Length + math.Clamp((Active and 1 or 0) - Length,-FT * 1.5,FT * 3) )

	if Active ~= self.OldActive then
		self.OldActive = Active

		if Active then
			self:BuildSounds()

			self:SetHoldType( self:GetCombo().HoldType )

			self:EmitSoundUnpredicted( self.CachedSounds[1].ActivateSound )

			if self:GetCombo().LeftSaberActive then
				self:EmitSoundUnpredicted( self.CachedSounds[2].ActivateSound )
			end
		else
			self:SetHoldType( "normal" )

			self:EmitSoundUnpredicted( self.CachedSounds[1].DisableSound )

			if self:GetCombo().LeftSaberActive then
				self:EmitSoundUnpredicted( self.CachedSounds[2].DisableSound )
			end
		end

		self:OnActiveChanged( self.OldActive, Active )
	end

	if Stance ~= self.OldStance then
		if self:GetActive() then
			self:SetHoldType( self:GetCombo().HoldType )
		end

		self.OldStance = Stance
	end
	
	self:OnTick( Active )
end

function SWEP:AimDistanceTo( _pos )
	local ply = self:GetOwner()

	if not IsValid( ply ) then return 0 end

	local Pos = ply:lscsGetViewOrigin()
	local EndPos = Pos + ply:EyeAngles():Forward() * 500

	return util.DistanceToLine( Pos, EndPos, _pos )
end

function SWEP:GetBlockDistanceTo( _pos )
	local ply = self:GetOwner()

	if not IsValid( ply ) then return 100 end

	local BlockDistance = self:AimDistanceTo( _pos )

	if ply:WorldToLocal( _pos ).x < 0 then
		BlockDistance = 100
	end

	return BlockDistance
end
--addons/weapon_jedi/lua/weapons/weapon_lscs/sh_blockpoints.lua:

function SWEP:GetBPDrainPerHit()
	return (self:GetCombo().BPDrainPerHit or 25)
end

function SWEP:GetMaxBlockPoints()
	local combo = self:GetCombo()

	return (combo.MaxBlockPoints or 100)
end

function SWEP:GetBlockDistanceNormal()
	return (self:GetCombo().BlockDistanceNormal or 60)
end

function SWEP:GetBlockDistancePerfect()
	return (self:GetCombo().BlockDistancePerfect or 20)
end

function SWEP:DrainBP( amount )
	if amount then
		self:SetBlockPoints( math.Clamp( self:GetBlockPoints() - amount,0, self:GetMaxBlockPoints()) )

		if amount > 0 then
			self.NextBPr = CurTime() + 2
		end
	else
		self.NextBPr = CurTime() + 2
	end
end

if SERVER then
	function SWEP:CalcBPRegen( CurTime )
		local ply = self:GetOwner()

		if not IsValid( ply ) then return end

		if (self.NextBPr or 0) < CurTime then
			self.NextBPr = CurTime + 0.3

			local MaxVal = self:GetMaxBlockPoints()
			if self:GetGestureTime() < CurTime and ply:OnGround() and ply:GetVelocity():Length() < 225 then
				self:SetBlockPoints( self:GetBlockPoints() + math.min(MaxVal - self:GetBlockPoints(),3) )
			else
				if not ply:OnGround() then
					self:DrainBP( 1 )
				end
			end
		end

		if self._ResetHitTime and self._ResetHitTime < CurTime then
			self._ResetHitTime = CurTime + 1

			self:AddHit( -0.1 )
		end
	end
end
--addons/lvs_base/lua/weapons/weapon_lvsrepair.lua:
AddCSLuaFile()

SWEP.Category				= "[LVS]"
SWEP.Spawnable			= true
SWEP.AdminSpawnable		= false
SWEP.ViewModel			= "models/weapons/c_repairlvs.mdl"
SWEP.WorldModel			= "models/weapons/w_repairlvs.mdl"
SWEP.UseHands				= true

SWEP.HoldType				= "slam"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip		= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic		= false
SWEP.Secondary.Ammo		= "none"

SWEP.MaxRange = 250

function SWEP:SetupDataTables()
	self:NetworkVar( "Float",0, "FlameTime" )
end

function SWEP:GetLVS()
	local ply = self:GetOwner()

	if not IsValid( ply ) then return NULL end

	local ent = ply:GetEyeTrace().Entity

	if not IsValid( ent ) then return NULL end

	if ent._lvsRepairToolLabel or ent.LVS then return ent end

	if not ent.GetBase then return NULL end

	ent = ent:GetBase()

	if IsValid( ent ) and ent.LVS then return ent end

	return NULL
end

function SWEP:FindClosest()
	local lvsEnt = self:GetLVS()

	if not IsValid( lvsEnt ) then return NULL end

	local ply = self:GetOwner()

	if ply:InVehicle() then return end

	local ShootPos = ply:GetShootPos()
	local AimVector = ply:GetAimVector()

	local ClosestDist = self.MaxRange
	local ClosestPiece = NULL

	local tableEnts = lvsEnt:GetChildren()

	if isfunction( lvsEnt.GetCrosshairFilterEnts ) then
		tableEnts = lvsEnt:GetCrosshairFilterEnts()
	end

	for _, target in pairs( tableEnts ) do
		if not IsValid( target ) then continue end

		for _, entity in pairs( target:GetChildren() ) do
			if entity:GetClass() ~= "lvs_armor" then continue end

			local boxOrigin = entity:GetPos()
			local boxAngles = entity:GetAngles()
			local boxMins = entity:GetMins()
			local boxMaxs = entity:GetMaxs()

			local HitPos, _, _ = util.IntersectRayWithOBB( ShootPos, AimVector * 1000, boxOrigin, boxAngles, boxMins, boxMaxs )

			if isvector( HitPos ) then
				local Dist = (ShootPos - HitPos):Length()

				if Dist < ClosestDist then
					ClosestDist = Dist
					ClosestPiece = entity
				end
			end
		end
	end

	return ClosestPiece
end

local function IsEngineMode( AimPos, Engine )
	if not IsValid( Engine ) then return false end

	if not isfunction( Engine.GetDoorHandler ) then return (AimPos - Engine:GetPos()):Length() < 25 end

	local DoorHandler = Engine:GetDoorHandler()

	if IsValid( DoorHandler ) then
		if DoorHandler:IsOpen() then
			return (AimPos - Engine:GetPos()):Length() < 50
		end

		return false
	end

	return (AimPos - Engine:GetPos()):Length() < 25
end

if CLIENT then
	SWEP.PrintName		= "Repair Torch"
	SWEP.Author			= "Blu-x92"

	SWEP.Slot				= 5
	SWEP.SlotPos			= 1

	SWEP.Purpose			= "Repair Broken Armor"
	SWEP.Instructions		= "Primary to Repair\nHold Secondary to switch to Armor Repair Mode"
	SWEP.DrawWeaponInfoBox 	= true

	SWEP.WepSelectIcon 			= surface.GetTextureID( "weapons/lvsrepair" )

	local ColorSelect = Color(0,255,255,50)
	local ColorText = Color(255,255,255,255)

	local function DrawText( pos, text, col )
		cam.Start2D()
			local data2D = pos:ToScreen()

			if not data2D.visible then return end

			local font = "TargetIDSmall"

			local x = data2D.x
			local y = data2D.y

			draw.DrawText( text, font, x + 1, y + 1, Color( 0, 0, 0, 120 ), TEXT_ALIGN_CENTER )
			draw.DrawText( text, font, x + 2, y + 2, Color( 0, 0, 0, 50 ), TEXT_ALIGN_CENTER )
			draw.DrawText( text, font, x, y, col or color_white, TEXT_ALIGN_CENTER )
		cam.End2D()
	end

	function SWEP:DrawEffects( weapon, ply )
		local ID = weapon:LookupAttachment( "muzzle" )

		local Muzzle = weapon:GetAttachment( ID )

		if not Muzzle then return end

		local T = CurTime()

		if self:GetFlameTime() < T or (self._NextFX1 or 0) > T then return end

		self._NextFX1 = T + 0.02

		local effectdata = EffectData()
		effectdata:SetOrigin( Muzzle.Pos )
		effectdata:SetAngles( Muzzle.Ang )
		effectdata:SetScale( 0.5 )
		util.Effect( "MuzzleEffect", effectdata, true, true )

		if (self._NextFX2 or 0) > T then return end

		self._NextFX2 = T + 0.06

		local trace = ply:GetEyeTrace()
		local ShootPos = ply:GetShootPos()

		if (ShootPos - trace.HitPos):Length() > self.MaxRange then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( trace.HitPos )
			effectdata:SetNormal( trace.HitNormal * 0.15 )
		util.Effect( "manhacksparks", effectdata, true, true )

		local dlight = DynamicLight( self:EntIndex() )

		if not dlight then return end

		dlight.pos = (trace.HitPos + ShootPos) * 0.5
		dlight.r = 206
		dlight.g = 253
		dlight.b = 255
		dlight.brightness = 3
		dlight.decay = 1000
		dlight.size = 256
		dlight.dietime = CurTime() + 0.1
	end

	function SWEP:PostDrawViewModel( vm, weapon, ply )
		self:DrawEffects( vm, ply )
	end

	function SWEP:DrawWorldModel( flags )
		self:DrawModel( flags )
		self:DrawEffects( self, self:GetOwner() )
	end

	function SWEP:DrawHUD()
		local ply = self:GetOwner()

		if not IsValid( ply ) or not ply:KeyDown( IN_ATTACK2 ) then
			local lvsEnt = self:GetLVS()
			local Pos = ply:GetEyeTrace().HitPos

			if IsValid( lvsEnt ) and (Pos - ply:GetShootPos()):Length() < self.MaxRange and not ply:InVehicle() then
				local Label = lvsEnt._lvsRepairToolLabel or "Frame"

				if isfunction( lvsEnt.GetEngine ) then
					local Engine = lvsEnt:GetEngine()

					local AimPos = ply:GetEyeTrace().HitPos

					local EngineMode = IsEngineMode( AimPos, Engine )

					if IsValid( Engine ) and EngineMode then
						DrawText( AimPos, "Engine\nHealth: "..math.Round(Engine:GetHP()).."/"..Engine:GetMaxHP(), ColorText )
					else
						DrawText( AimPos, Label.."\nHealth: "..math.Round(lvsEnt:GetHP()).."/"..lvsEnt:GetMaxHP(), ColorText )
					end
				else
					DrawText( ply:GetEyeTrace().HitPos, Label.."\nHealth: "..math.Round(lvsEnt:GetHP()).."/"..lvsEnt:GetMaxHP(), ColorText )
				end
			end

			return
		end

		local Target = self:FindClosest()

		if IsValid( Target ) then
			local boxOrigin = Target:GetPos()
			local boxAngles = Target:GetAngles()
			local boxMins = Target:GetMins()
			local boxMaxs = Target:GetMaxs()

			cam.Start3D()
				render.SetColorMaterial()
				render.DrawBox( boxOrigin, boxAngles, boxMins, boxMaxs, ColorSelect )
			cam.End3D()

			DrawText( Target:LocalToWorld( (boxMins + boxMaxs) * 0.5 ), (Target:GetIgnoreForce() / 100).."mm "..Target:GetLabel().."\nHealth: "..math.Round(Target:GetHP()).."/"..Target:GetMaxHP(), ColorText )
		else
			local Pos = ply:GetEyeTrace().HitPos

			if IsValid( self:GetLVS() ) and (Pos - ply:GetShootPos()):Length() < self.MaxRange and not ply:InVehicle() then
				DrawText( Pos, "No Armor", ColorText )
			end
		end
	end
end

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
end

function SWEP:PrimaryAttack()
	local T = CurTime()

	self:SetNextPrimaryFire( T + 0.15 )

	self:SetFlameTime( T + 0.3 )

	local EngineMode = false
	local ArmorMode = true
	local Target = self:FindClosest()

	local ply = self:GetOwner()

	if IsValid( ply ) and not ply:KeyDown( IN_ATTACK2 ) then
		Target = self:GetLVS()

		if isfunction( Target.GetEngine ) then
			local Engine = Target:GetEngine()

			local AimPos = ply:GetEyeTrace().HitPos

			EngineMode = IsEngineMode( AimPos, Engine )

			if IsValid( Engine ) and EngineMode then
				Target = Engine
			end
		end

		ArmorMode = false
	end

	if not IsValid( Target ) then return end

	local HP = Target:GetHP()
	local MaxHP = Target:GetMaxHP()

	if IsFirstTimePredicted() then
		local trace = ply:GetEyeTrace()

		if HP ~= MaxHP then
			local effectdata = EffectData()
			effectdata:SetOrigin( trace.HitPos )
			effectdata:SetNormal( trace.HitNormal )
			util.Effect( "stunstickimpact", effectdata, true, true )
		end
	end

	if CLIENT then return end

	Target:SetHP( math.min( HP + 15, MaxHP ) )

	if EngineMode and Target:GetDestroyed() then
		Target:SetDestroyed( false )
	end

	if not ArmorMode then return end

	if Target:GetDestroyed() then Target:SetDestroyed( false ) end

	if HP < MaxHP then return end

	Target:OnRepaired()
end

function SWEP:SecondaryAttack()
end

function SWEP:Think()
	local ply = self:GetOwner()

	if not IsValid( ply ) then self:StopSND() return end

	local PlaySound = self:GetFlameTime() >= CurTime() and (ply:GetShootPos() - ply:GetEyeTrace().HitPos):Length() < self.MaxRange

	if PlaySound then
		self:PlaySND()
	else
		self:StopSND()
	end
end

function SWEP:StopSND()
	if CLIENT then return end

	if not self._snd then return end

	self._snd:Stop()
	self._snd = nil
end

function SWEP:PlaySND()
	if CLIENT then return end

	if self._snd then return end

	local ply = self:GetOwner()

	if not IsValid( ply ) then return end

	self._snd = CreateSound( ply, "lvs/weldingtorch_loop.wav" )
	self._snd:PlayEx(1, 70 )
end

function SWEP:OnRemove()
	self:StopSND()
end

function SWEP:OnDrop()
	self:StopSND()
end

function SWEP:Holster( wep )
	self:StopSND()
	return true
end

--addons/aoc_nextbots/lua/weapons/weapon_npc_aqua.lua:
AddCSLuaFile()

SWEP.Base   = "weapon_summes_npcbase"

SWEP.PrintName = "NPC: Aqua"
SWEP.Spawnable = false
SWEP.Author = "Summe"

SWEP.WorldModel = false
SWEP.Weight = 3

SWEP.NextShoot = 0.2
SWEP.Tracer = "effect_npc_laser_red"
SWEP.ImpactEffect = "rw_sw_impact_red"
SWEP.Sound = "everfall/weapons/ee-4/blasters_ee4_laser_close_var_01.mp3"
SWEP.ClipSize = 40
SWEP.Damage = 20
SWEP.Spread = 0.1
SWEP.Bullets = 1
--lua/weapons/wood_spanish_sword/shared.lua:
SWEP.Author       = "Killua"
SWEP.PrintName    = "Wood Spanish sword"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Wood"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "knife"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 50
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(15, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-47.778, 0, 0) }
}
SWEP.VElements = {
	["hils++++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, -2, 4.9), angle = Angle(0, 0, -90), size = Vector(0.025, 0.025, 0.07), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils+++++"] = { type = "Model", model = "models/hunter/tubes/tube1x1x1c.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 3), angle = Angle(0, -90, -90), size = Vector(0.09, 0.15, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 13.6), angle = Angle(0, 0, 0), size = Vector(0.014, 0.014, 0.4), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 2, 4.9), angle = Angle(0, 0, 90), size = Vector(0.025, 0.025, 0.07), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -1), angle = Angle(0, 90, 0), size = Vector(0.05, 0.039, 0.109), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/misc/shell2x2a.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.5), angle = Angle(0, 0, 0), size = Vector(0.048, 0.048, 0.048), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils++"] = { type = "Model", model = "models/hunter/misc/shell2x2a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.5), angle = Angle(0, 0, 0), size = Vector(0.048, 0.048, 0.048), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils++++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, -2, 4.9), angle = Angle(0, 0, -90), size = Vector(0.025, 0.025, 0.07), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 50, 8), size = Vector(0.05, 0.039, 0.109), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 2, 4.9), angle = Angle(0, 0, 90), size = Vector(0.025, 0.025, 0.07), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 13.6), angle = Angle(0, 0, 0), size = Vector(0.014, 0.014, 0.4), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils+++++"] = { type = "Model", model = "models/hunter/tubes/tube1x1x1c.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 3), angle = Angle(0, -90, -90), size = Vector(0.09, 0.15, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} }
}

SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 2
SWEP.Primary.DelayMiss	 = 1.2
SWEP.Primary.DelayHit 	 = 0.28
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 16

SWEP.Secondary.Life        = true
SWEP.Secondary.Damage 	   = 70
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/wos-passiveevent-ageo/lua/weapons/wos_pes_tool/shared.lua:


SWEP.PrintName      = "Passive Event Tool"
--SWEP.Author	        = "Oliver (wiltOS)" //Clean this from the menu but keep it in code because Oliver deserves credit
SWEP.Instructions   = "Reload: Open Menu"

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo		= "none"

SWEP.Slot = 5
SWEP.SlotPos = 7
SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= true
SWEP.Category = "[wOS] Passive Event"
SWEP.UseHands = true

SWEP.ViewModel			= "models/weapons/c_toolgun.mdl"
SWEP.WorldModel			= "models/weapons/w_toolgun.mdl"

SWEP.AlwaysRaised = true
--gamemodes/starwarsrp/entities/entities/aoc_jailmarker.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Gefgnismarker"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP - Spawns"
ENT.Spawnable       = true


if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/hunter/plates/plate1x1.mdl" )
        self:DrawShadow( false )
        self:SetColor(Color(255,0,255))
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_NONE)
        self:SetSolid(SOLID_VPHYSICS)
        self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
    end

end
-- test

if CLIENT then

    function ENT:Draw()
        if LocalPlayer():GetMoveType() == MOVETYPE_NOCLIP then
            self:DrawModel() 
        end
    end

end
--addons/arccw_weapons/lua/entities/arccw_ammo_chargepack.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Charge Pack"
ENT.Category = "ArcCW - Ammo"
ENT.Editable = true
ENT.Spawnable = true
ENT.AdminOnly = false
ENT.UseTimer = CurTime()

ENT.Model = "models/cs574/objects/ammo_box.mdl"

function ENT:SpawnFunction( ply, tr, ClassName )
if ( !tr.Hit ) then return end
    local SpawnPos = tr.HitPos + tr.HitNormal * 10
    pAngle = ply:GetAngles()
    pAngle.pitch = pAngle.pitch
    pAngle.roll = pAngle.roll 
    pAngle.yaw = pAngle.yaw + 180
    local ent = ents.Create( ClassName ) 
    ent:SetPos( SpawnPos - Vector(0,0,-10) )
    ent:SetAngles( pAngle )
    ent:Spawn()
    ent:Activate()
    return ent	
end

function ENT:Draw()
    self:DrawModel()
end

function ENT:Initialize()
    if SERVER then
        self:SetModel( "models/cs574/objects/ammo_box.mdl" )    
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:DrawShadow( true )
        local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end
        self:SetTrigger(true)
    end
end

function ENT:Use( activator, caller )
	local ammoType1 = activator:GetActiveWeapon():GetPrimaryAmmoType()
    local ammoType2 = activator:GetActiveWeapon():GetSecondaryAmmoType()
    local clip1 = activator:GetActiveWeapon():GetMaxClip1()
    if ammoType1 == -1 and ammoType2 == -1 and activator:IsPlayer() then
        activator:GiveAmmo(200, 2, false)
        self:Remove()
    elseif self.UseTimer <= CurTime() and activator:IsPlayer() then
        activator:GiveAmmo(clip1*4, ammoType1, false)
		activator:GiveAmmo(3 , ammoType2, false)
        self:Remove()
    end
end

function ENT:PhysicsCollide( data, phys )
end


--addons/arccw_weapons/lua/entities/arccw_ammo_chargepack_thr.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Charge Pack"
ENT.Category = "ArcCW - Ammo"
ENT.Editable = true
ENT.Spawnable = false
ENT.AdminOnly = false
ENT.UseTimer = CurTime()

ENT.Model = "models/cs574/objects/ammo_box.mdl"

function ENT:SpawnFunction( ply, tr, ClassName )
if ( !tr.Hit ) then return end
    local SpawnPos = tr.HitPos + tr.HitNormal * 10
    pAngle = ply:GetAngles()
    pAngle.pitch = pAngle.pitch
    pAngle.roll = pAngle.roll 
    pAngle.yaw = pAngle.yaw + 180
    local ent = ents.Create( ClassName ) 
    ent:SetPos( SpawnPos - Vector(0,0,-10) )
    ent:SetAngles( pAngle )
    ent:Spawn()
    ent:Activate()
    return ent	
end

function ENT:Draw()
    self:DrawModel()
end

function ENT:Initialize()
    if SERVER then
        self:SetModel( "models/cs574/objects/ammo_box.mdl" )    
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:DrawShadow( true )
        local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end
        self:SetTrigger(true)
        timer.Simple(0.5, function()
            local spawnPosition = self:GetPos()
            local spawnangle = self:GetAngles()

            local chargePack = ents.Create("arccw_ammo_chargepack")
            if IsValid(chargePack) then
                chargePack:SetPos(spawnPosition)
                chargePack:SetAngles(spawnangle)
                chargePack:SetModel("models/cs574/objects/ammo_box.mdl")
                chargePack:Spawn()
            end
            self:Remove()
        end)
    end
end

function ENT:PhysicsCollide( data, phys )
end


--addons/arccw_base_modified/lua/entities/arccw_ammo_pistol_large.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"

ENT.PrintName                 = "Pistol Ammo (Large)"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/pistol_ammo.mdl"
ENT.Scale = 1.5

ENT.AmmoType = "pistol"
ENT.AmmoCount = 200

ENT.DetonationDamage = 10
ENT.DetonationRadius = 256
ENT.DetonationSound = "weapons/pistol/pistol_fire3.wav"
--addons/arccw_base_modified/lua/entities/arccw_ammo_sniper_large.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"

ENT.PrintName                 = "Sniper Ammo (Large)"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/sniper_ammo.mdl"
ENT.Scale = 1.5

ENT.AmmoType = "SniperPenetratedRound"
ENT.AmmoCount = 50
ENT.MaxHealth = 20

ENT.DetonationDamage = 80
ENT.DetonationRadius = 128
ENT.DetonationSound = "npc/sniper/echo1.wav"
--addons/arccw_weapons/lua/entities/arccw_thr_bacta.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.PrintName = "Fragnade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE

ENT.Model = "models/arccw/meeks/bacta_grenade.mdl"
ENT.TrailColor = Color(0, 187, 255)
ENT.TrailTexture = "sprites/bluelaser1" -- this is exactly the one hl2 frag uses. Why blue? idk blame gaben

local regenInterval = 0.125 -- Regeneration interval in seconds
local regenDuration = 3 -- Regeneration duration in seconds
local playersInRegenRange = {} -- Store players in regeneration range

-- Function to handle player health regeneration
local function RegenerateHealth(ply)
    if IsValid(ply) and ply:Alive() then
        local maxHealth = ply:GetMaxHealth()
        local currentHealth = ply:Health()
        local regenAmount = maxHealth * 0.05
        
        if currentHealth < maxHealth then
            ply:SetHealth(math.min(currentHealth + regenAmount, maxHealth))
        end
    end
end

-- Hook to start player health regeneration
hook.Add("Think", "PlayerHealthRegen", function()
    for _, ply in ipairs(player.GetAll()) do
        if IsValid(ply) then
            local shouldRegenerate = playersInRegenRange[ply]
            
            if shouldRegenerate then
                if not ply.regenStartTime then
                    ply.regenStartTime = CurTime()
                end
                
                if CurTime() - ply.regenStartTime <= regenDuration then
                    if not ply.nextRegen or CurTime() >= ply.nextRegen then
                        RegenerateHealth(ply)
                        ply.nextRegen = CurTime() + regenInterval
                    end
                else
                    playersInRegenRange[ply] = nil
                    ply.regenStartTime = nil
                end
            end
        end
    end
end)

-- Hook to detect players entering and leaving regeneration range
hook.Add("PlayerEnteredRegenRadius", "PlayerEnteredRegenRadius", function(ply)
    if IsValid(ply) then
        playersInRegenRange[ply] = true
    end
end)

hook.Add("PlayerLeftRegenRadius", "PlayerLeftRegenRadius", function(ply)
    if IsValid(ply) then
        playersInRegenRange[ply] = nil
        ply.regenStartTime = nil
    end
end)



function ENT:Initialize()
	if SERVER then
		self:SetModel("models/forrezzur/bactagrenade.mdl") 
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
		
		local phys = self:GetPhysicsObject()
		if phys:IsValid() then
			phys:Wake()
			phys:SetBuoyancyRatio(0)
		end
		
		self.Delay = CurTime() + 1.7
		self.NextParticle = 0
		self.ParticleCount = 0
		self.First = true
		self.IsDetonated = false

        self.SpawnTime = CurTime()
        self.Trail = util.SpriteTrail(self, 0, self.TrailColor, false, 4, 0, 0.5, 4, self.TrailTexture or "sprites/bluelaser1")
        if IsValid(self.Trail) then
            self.Trail:SetRenderMode(RENDERMODE_TRANSADD)
            self.Trail:SetRenderFX(kRenderFxNone)
        end
        self:SetPhysicsAttacker(self:GetOwner(), 10)
	end
    util.PrecacheSound("misc/BEEPTimer_Anticipation Beeps_08.wav")

    -- Play the sound when the entity is spawned
    self:EmitSound("misc/BEEPTimer_Anticipation Beeps_08.wav")
end

function ENT:PhysicsCollide(data, physobj)
	if SERVER then
		self.HitP = data.HitPos
		self.HitN = data.HitNormal

		if self:GetVelocity():Length() > 60 then
			self:EmitSound(Sound("weapons/grenades/wpn_fraggrenade_1p_hardsurface_bounce_01_lr_v" .. math.random(1,2) .. ".wav"))
		end
		
		if self:GetVelocity():Length() < 5 then
			self:SetMoveType(MOVETYPE_NONE)
		end
		
	end
end

function ENT:Think()
    if SERVER then    
        if CurTime() > self.Delay then
            if self.IsDetonated == false then
                self:Detonate(self, self:GetPos())
                self.IsDetonated = true
                
                -- Player entered the regeneration radius after detonation
                for _, v in pairs(ents.FindInSphere(self:GetPos(), 216)) do
                    if v:IsPlayer() then
                        hook.Call("PlayerEnteredRegenRadius", nil, v)
                    end
                end
            end
        end
    end
end

function ENT:Detonate(self,pos)
	self.ParticleCreated = false
	self.ExtinguishParticleCreated = false
	if SERVER then
		if not self:IsValid() then return end
		self:SetNWBool("IsDetonated",true)
		self:EmitSound("misc/EXPLDsgn_Implode_02.wav", 120, 100, 1, CHAN_AUTO)
		local gas = EffectData()
		gas:SetOrigin(pos)
		gas:SetEntity(self.Owner)
		util.Effect("tfa_csgo_healnade", gas)
	end
	
	self:SetMoveType( MOVETYPE_NONE )
	
	if SERVER then
		SafeRemoveEntityDelayed(self,0.5)
	end
	
end

function ENT:DrawTranslucent()
    self:Draw()
end

function ENT:Draw()
    self:DrawModel()
end
--lua/entities/arccw_uc_40mm_incendiary.lua:
AddCSLuaFile()

ENT.Base = "arccw_uc_40mm_he"
ENT.PrintName = "40mm Incendiary"

ENT.GrenadeDamage = 50
ENT.GrenadeRadius = 150

function ENT:DoDetonation()
    local attacker = IsValid(self:GetOwner()) and self:GetOwner() or self
    util.BlastDamage(self, attacker, self:GetPos(), self.GrenadeRadius, self.GrenadeDamage)
    self:EmitSound("ambient/fire/gascan_ignite1.wav", 100, 100, 1)

    for i = 1, 5 do
        local cloud = ents.Create("arccw_uc_fire")
        cloud.FireTime = 20

        if !IsValid(cloud) then return end

        local vel = Vector(math.Rand(-1, 1), math.Rand(-1, 1), math.Rand(-1, 1)) * 1500

        cloud.Order = i
        cloud:SetPos(self:GetPos() - (self:GetVelocity() * FrameTime()) * 3 + VectorRand())
        cloud:SetAbsVelocity(vel + self:GetVelocity())
        cloud:SetOwner(self:GetOwner())
        cloud:Spawn()
    end
end

--[[att.Hook_FireBullets = function(wep, data)  this thing doesn't actually call firebullets lol
    wep:EmitSound("DB_ADD") -- lua/arccw/shared/sh_0_uc.lua
  end]]
--addons/auralvsradar/lua/entities/aura_lfs_fight_display_panel/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end

surface.CreateFont( "LFSFightDisplayFont", {
	    font = "roboto",
	    italic = true,
	    size = 20 * (ScrW() / 1920),
	    weight = 1000 * (ScrW() / 1920),
	    antialias = true,
} )

surface.CreateFont( "LFSFightDisplayFont2", {
	    font = "roboto",
	    size = 80 * (ScrW() / 1920),
	    weight = 1000 * (ScrW() / 1920),
	    antialias = true,
} )

net.Receive("SetPlayersVisible", function()
	LocalPlayer().canSeeLFSNames = !LocalPlayer().canSeeLFSNames
end)

--addons/arccw_weapons/lua/entities/emp_throwed/shared.lua:
ENT.Type 			= "anim"  
ENT.PrintName			= "EMP Throwed"  
ENT.Spawnable			= false
ENT.AdminSpawnable		= false

--local rSound = Sound("Missile.Accelerate")

if SERVER then
	AddCSLuaFile( "shared.lua" )

	function ENT:Initialize()   
		

		self.flightvector = self.Entity:GetForward() * ((90*15.5)/2)
		self.timeleft = CurTime() + 2
		self.Owner = self:GetOwner()
		self.Entity:SetModel( "models/weapons/star_wars_battlefront/thermaldetonator_thrown.mdl" )
		self.Entity:PhysicsInit( SOLID_VPHYSICS )	
		self.Entity:SetMoveType( MOVETYPE_NONE )
		self.Entity:SetSolid( SOLID_VPHYSICS )
		--self.Entity:EmitSound(rSound, 75, 100)
		self.Entity:SetNWBool("smoke", 10, true)
	end   

	function ENT:Think()

			if self.timeleft < CurTime() then
				self:Explosion()
				self.Entity:Remove()
			end

		Table	={} 			//Table name is table name
		Table[1]	=self.Owner 		//The person holding the gat
		Table[2]	=self.Entity 		//The cap

		local trace = {}
			trace.start = self.Entity:GetPos()
			trace.endpos = self.Entity:GetPos() + self.flightvector
			trace.filter = Table
		local tr = util.TraceLine( trace )
		

			if tr.HitSky then
				self:Explosion()
				self.Entity:Remove()
				return true
			end

			local dmg = math.Rand( 250, 275 )
			util.BlastDamage(self.Entity, self:OwnerGet(), tr.HitPos, 10, dmg)
		
			if tr.Hit then
					local effectdata = EffectData()
						effectdata:SetOrigin(tr.HitPos)
						effectdata:SetNormal(tr.HitNormal)
						--effectdata:SetEntity(self.Entity)
						effectdata:SetScale(3)
						effectdata:SetRadius(tr.MatType)
						effectdata:SetMagnitude(18)
						util.Effect( "emp_exp_effect", effectdata )
						--util.BlastDamage(self.Entity, self:OwnerGet(), tr.HitPos, 500, dmg)
						util.Decal("Scorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)
						self.Entity:SetNWBool("smoke", false)
				self:Explosion()
				self.Entity:Remove()	
			end
		
		self.Entity:SetPos(self.Entity:GetPos() + self.flightvector)
		self.flightvector = self.flightvector - (self.flightvector/1500)  + Vector(math.Rand(-0.2,0.2), math.Rand(-0.2,0.2),math.Rand(-0.2,0.2)) + Vector(0,0,-0.05)
		self.Entity:SetAngles(self.flightvector:Angle() + Angle(0,0,0))
		self.Entity:NextThink( CurTime() )
		return true
	end
	
	function ENT:Explosion()
		self:EmitSound("everfall/explosions/ion/destruction_explosions_modular_medium_bigion_discharge_close_var_01.mp3", 500, 100)	
		for k, v in pairs( ents.FindInSphere( self:GetPos(), 130 ) ) do
			if IsValid( v ) then
				if v.LFS then
					v:StopEngine()
					v:SetShield(0)
					v:SetHP( v:GetHP()/10 )
				end
				if v.LVS then
					v:StopEngine()
					v:SetShield(0)
					v:SetHP( v:GetHP()/10 )
				end
				if v:IsPlayer() or v:IsNPC() then
					damage = DamageInfo()
					damage:SetDamage( 5000000 )
					damage:SetAttacker( self:GetOwner() )
					damage:SetDamageType( DMG_DISSOLVE )
					v:TakeDamageInfo( damage )
				end
			end 
	end
end

function ENT:OwnerGet()
	if IsValid(self.Owner) then
		return self.Owner
	else
		return self.Entity
	end
end

end

if CLIENT then

    function ENT:Draw()
     pos = self:GetPos()
     render.SetMaterial(Material("particle/particle_glow_04_additive"))
     render.DrawSprite(pos, 30, 30, Color(50, 195, 255))
     render.SetMaterial(Material("particle/particle_glow_04_additive"))
     render.DrawSprite(pos, 15, 15, Color(50, 195, 255))
     render.SetMaterial(Material("particle/particle_glow_04_additive"))
     render.DrawSprite(pos, 5, 5, Color(50, 195, 255))
    end
 
    function ENT:Initialize()
        pos = self:GetPos()
        self.emitter = ParticleEmitter( pos )
    end
 
    function ENT:Think()
    end

end
--addons/aoc_fire_system/lua/entities/fire_molotov_object/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--addons/weapon_joe_fort/lua/entities/joefort_ressource_100/cl_init.lua:
include('shared.lua')

--addons/weapon_jedi/lua/entities/lscs_force_base.lua:
AddCSLuaFile()

ENT.Base = "lscs_holocron_base"
DEFINE_BASECLASS( "lscs_holocron_base" )

ENT.Spawnable		= false
ENT.AdminSpawnable		= false

ENT.BeamMat = Material( "trails/electric" )
ENT.GlowMat = Material( "sprites/light_glow02_add" )
ENT.GlowCol = Color(0,127,255,255)
ENT.GlowCol2 = Color(100,150,200,255)

if SERVER then
	function ENT:Initialize()
		BaseClass.Initialize( self )
		self:PhysicsInitBox( Vector(-11,-11,-11), Vector(11,11,11) )
		self:SetColor( Color(40,40,40,255) )
		self:PlayAnimation("open")
	end
else
	local HaloCount = 0
	local HaloEnts = {}

	function ENT:Think()
		for ID = 1, self:GetBoneCount() do
			self:ManipulateBoneAngles( ID, Angle(math.cos( CurTime() * 6 ),math.sin( CurTime() * 3 ), math.cos( CurTime() * 9 ) ) )
		end
	end

	function ENT:Initialize()
		self.smDist = CurTime() + 1
		table.insert( HaloEnts, self )

		HaloCount = table.Count( HaloEnts )
	end

	function ENT:DrawTranslucent()
		self:DrawModel()

		render.SetMaterial( self.GlowMat )
		render.DrawSprite( self:GetPos(), 64, 64, self.GlowCol )

		local D = math.Clamp(1 - (self.smDist - CurTime()),0,1)
		local Dist = 9 * D

		render.SetMaterial( self.BeamMat )
		
		for Z = -1, 1, 2 do
			for X = -1, 1, 2 do
				for Y = -1, 1, 2 do
					local Center =  self:LocalToWorld( Vector(X,Y,Z) )
					local Corner = self:LocalToWorld( Vector(X * Dist,Y * Dist,Z * Dist) )

					render.DrawBeam( Center, Corner, math.Rand(1,2), math.Rand(-1,0), math.Rand(1,1.5), Color( 255, 255, 255, 255 ) )
				end
			end
		end
	
		render.SetMaterial( self.GlowMat )
	end

	function ENT:Draw()
		self:DrawModel()
	end

	function ENT:OnRemove()
		for id, e in pairs( HaloEnts ) do
			if e == self or not IsValid( e ) then HaloEnts[ id ] = nil end
		end

		HaloCount = table.Count( HaloEnts )
	end

	local haloColor = Color(0,127,255,255)
	hook.Add( "PreDrawHalos", "lscs_holocron_halo", function()
		if HaloCount == 0 then return end

		halo.Add( HaloEnts, haloColor, 1, 1, math.Rand(0.8,1.2) )
	end )
end
--addons/lvs_base/lua/entities/lvs_base/cl_init.lua:
include("shared.lua")
include( "sh_weapons.lua" )
include( "cl_effects.lua" )
include( "cl_hud.lua" )
include( "cl_seatswitcher.lua" )
include( "cl_trailsystem.lua" )
include( "cl_boneposeparemeter.lua" )

local Zoom = 0

function ENT:LVSCalcFov( fov, ply )

	local TargetZoom = ply:lvsKeyDown( "ZOOM" ) and 0 or 1

	Zoom = Zoom + (TargetZoom - Zoom) * RealFrameTime() * 10

	local newfov = fov * Zoom + (self.ZoomFov or 40) * (1 - Zoom)

	return newfov
end

function ENT:LVSCalcView( ply, pos, angles, fov, pod )
	return LVS:CalcView( self, ply, pos, angles, fov, pod )
end

function ENT:PreDraw( flags )
	return true
end

function ENT:PreDrawTranslucent( flags )
	return true
end

function ENT:PostDraw( flags )
end

function ENT:PostDrawTranslucent( flags )
end

function ENT:Draw( flags )
	if self:PreDraw( flags ) then
		if self.lvsLegacyDraw then
			self:DrawModel() -- ugly, but required in order to fix old addons. Refract wont work on these.
		else
			self:DrawModel( flags )
		end
	end

	self:PostDraw( flags )
end

function ENT:DrawTranslucent( flags )
	self:DrawTrail()

	if self:PreDrawTranslucent( flags ) then
		self:DrawModel( flags )
	else
		self.lvsLegacyDraw = true -- insert puke simley
	end

	self:PostDrawTranslucent( flags )
end

function ENT:Initialize()
	self:OnSpawn()

	if not istable( self.GibModels ) then return end

	for _, modelName in ipairs( self.GibModels ) do
		util.PrecacheModel( modelName )
	end
end

function ENT:OnSpawn()
end

function ENT:OnFrameActive()
end

function ENT:OnFrame()
end

function ENT:OnEngineActiveChanged( Active )
end

function ENT:OnActiveChanged( Active )
end

ENT._oldActive = false
ENT._oldEnActive = false

function ENT:HandleActive()
	local EntTable = self:GetTable()

	local Active = self:GetActive()
	local EngineActive = self:GetEngineActive()
	local ActiveChanged = false

	if EntTable._oldActive ~= Active then
		EntTable._oldActive = Active
		EntTable:OnActiveChanged( Active )
		ActiveChanged = true
	end

	if EntTable._oldEnActive ~= EngineActive then
		EntTable._oldEnActive = EngineActive
		self:OnEngineActiveChanged( EngineActive )
		ActiveChanged = true
	end

	if ActiveChanged then
		if Active or EngineActive then
			self:StartWindSounds()
		else
			self:StopWindSounds()
		end
	end

	if Active or EngineActive then
		self:DoVehicleFX()
	end

	self:FlyByThink()

	return EngineActive
end

function ENT:Think()
	if not self:IsInitialized() then return end
 
	if self:HandleActive() then
		self:OnFrameActive()
	end

	self:HandleTrail()
	self:OnFrame()
end

function ENT:OnRemove()
	self:StopEmitter()
	self:StopWindSounds()
	self:StopFlyBy()
	self:StopDeathSound()

	self:OnRemoved()
end

function ENT:OnRemoved()
end

function ENT:CalcDoppler( Ent )
	if not IsValid( Ent ) then return 1 end

	if Ent:IsPlayer() then
		local ViewEnt = Ent:GetViewEntity()
		local Vehicle = Ent:lvsGetVehicle()

		if IsValid( Vehicle ) then
			if Ent == ViewEnt then
				Ent = Vehicle
			end
		else
			if IsValid( ViewEnt ) then
				Ent = ViewEnt
			end
		end
	end

	local sVel = self:GetVelocity()
	local oVel = Ent:GetVelocity()

	local SubVel = oVel - sVel
	local SubPos = self:GetPos() - Ent:GetPos()

	local DirPos = SubPos:GetNormalized()
	local DirVel = SubVel:GetNormalized()

	local A = math.acos( math.Clamp( DirVel:Dot( DirPos ) ,-1,1) )

	return (1 + math.cos( A ) * SubVel:Length() / 13503.9)
end

function ENT:GetCrosshairFilterEnts()
	if not self:IsInitialized() then return { self } end -- wait for the server to be ready

	if not istable( self.CrosshairFilterEnts ) then
		self.CrosshairFilterEnts = {self}

		-- lets ask the server to build the filter for us because it has access to constraint.GetAllConstrainedEntities() 
		net.Start( "lvs_player_request_filter" )
			net.WriteEntity( self )
		net.SendToServer()
	end

	return self.CrosshairFilterEnts
end

function ENT:FlyByThink()
end

function ENT:StopFlyBy()
end

function ENT:StopDeathSound()
end

function ENT:OnDestroyed()
end

net.Receive( "lvs_vehicle_destroy", function( len )
	local ent = net.ReadEntity()

	if not IsValid( ent ) or not isfunction( ent.OnDestroyed ) then return end

	ent:OnDestroyed()
end )

--addons/lvs_base/lua/entities/lvs_base/cl_effects.lua:

function ENT:StartWindSounds()
	if not LVS.ShowEffects then return end

	self:StopWindSounds()

	if LocalPlayer():lvsGetVehicle() ~= self then return end

	local EntTable = self:GetTable()

	EntTable._WindSFX = CreateSound( self, "LVS.Physics.Wind" )
	EntTable._WindSFX:PlayEx(0,100)

	EntTable._WaterSFX = CreateSound( self, "LVS.Physics.Water" )
	EntTable._WaterSFX:PlayEx(0,100)
end

function ENT:StopWindSounds()
	local EntTable = self:GetTable()

	if EntTable._WindSFX then
		EntTable._WindSFX:Stop()
		EntTable._WindSFX = nil
	end

	if EntTable._WaterSFX then
		EntTable._WaterSFX:Stop()
		EntTable._WaterSFX = nil
	end
end

ENT.DustEffectSurfaces = {
	["sand"] = true,
	["dirt"] = true,
	["grass"] = true,
}

ENT.GroundEffectsMultiplier = 1

function ENT:DoVehicleFX()
	local EntTable = self:GetTable()

	if EntTable.GroundEffectsMultiplier <= 0 or not LVS.ShowEffects then self:StopWindSounds() return end

	local Vel = self:GetVelocity():Length() * EntTable.GroundEffectsMultiplier

	if EntTable._WindSFX then EntTable._WindSFX:ChangeVolume( math.Clamp( (Vel - 1200) / 2800,0,1 ), 0.25 ) end

	if Vel < 1500 then
		if EntTable._WaterSFX then EntTable._WaterSFX:ChangeVolume( 0, 0.25 ) end

		return
	end

	if (EntTable.nextFX or 0) < CurTime() then
		EntTable.nextFX = CurTime() + 0.05

		local LCenter = self:OBBCenter()
		LCenter.z = self:OBBMins().z

		local CenterPos = self:LocalToWorld( LCenter )

		local trace = util.TraceLine( {
			start = CenterPos + Vector(0,0,25),
			endpos = CenterPos - Vector(0,0,450),
			filter = self:GetCrosshairFilterEnts(),
		} )

		local traceWater = util.TraceLine( {
			start = CenterPos + Vector(0,0,25),
			endpos = CenterPos - Vector(0,0,450),
			filter = self:GetCrosshairFilterEnts(),
			mask = MASK_WATER,
		} )

		if EntTable._WaterSFX then EntTable._WaterSFX:ChangePitch( math.Clamp((Vel / 1000) * 50,80,150), 0.5 ) end

		if traceWater.Hit and trace.HitPos.z < traceWater.HitPos.z then 
			local effectdata = EffectData()
				effectdata:SetOrigin( traceWater.HitPos )
				effectdata:SetEntity( self )
			util.Effect( "lvs_physics_water", effectdata )

			if EntTable._WaterSFX then EntTable._WaterSFX:ChangeVolume( 1 - math.Clamp(traceWater.Fraction,0,1), 0.5 ) end
		else
			if EntTable._WaterSFX then EntTable._WaterSFX:ChangeVolume( 0, 0.25 ) end
		end

		if trace.Hit and EntTable.DustEffectSurfaces[ util.GetSurfacePropName( trace.SurfaceProps ) ] then
			local effectdata = EffectData()
				effectdata:SetOrigin( trace.HitPos )
				effectdata:SetEntity( self )
			util.Effect( "lvs_physics_dust", effectdata )
		end
	end
end

function ENT:GetParticleEmitter( Pos )
	local EntTable = self:GetTable()

	local T = CurTime()

	if IsValid( EntTable.Emitter ) and (EntTable.EmitterTime or 0) > T then
		return EntTable.Emitter
	end

	self:StopEmitter()

	EntTable.Emitter = ParticleEmitter( Pos, false )
	EntTable.EmitterTime = T + 2

	return EntTable.Emitter
end

function ENT:StopEmitter()
	if IsValid( self.Emitter ) then
		self.Emitter:Finish()
	end
end
--addons/lvs_base/lua/entities/lvs_base/cl_seatswitcher.lua:

ENT.IconVehicleLocked = Material( "lvs/locked.png" )

LVS:AddHudEditor( "SeatSwitcher", ScrW() - 360, 10,  350, 60, 350, 60, "SEAT SWITCHER", 
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintSeatSwitcher then return end

		vehicle:LVSHudPaintSeatSwitcher( X, Y, W, 30, ScrX, ScrY, ply )
	end
)

function ENT:LVSHudPaintSeatSwitcher( X, Y, w, h, ScrX, ScrY, ply )
	local pSeats = table.Copy( self:GetPassengerSeats() )
	local SeatCount = table.Count( pSeats ) 

	if SeatCount <= 0 then return end

	pSeats[0] = self:GetDriverSeat()

	draw.NoTexture() 

	local HasAI = self:GetAI()
	local HasAIGunners = self:GetAIGunners()

	local MySeat = ply:GetVehicle():lvsGetPodIndex()

	local Passengers = {}
	for _, player in pairs( player.GetAll() ) do
		if player:lvsGetVehicle() == self then
			local Pod = player:GetVehicle()
			Passengers[ Pod:lvsGetPodIndex() ] = player:GetName()
		end
	end

	if HasAI then
		Passengers[1] = "[AI] "..self.PrintName
	end

	if HasAIGunners then
		for _, Pod in pairs( self:GetPassengerSeats() ) do
			if IsValid( Pod:GetDriver() ) then continue end
	
			local weapon = Pod:lvsGetWeapon()

			if not IsValid( weapon ) then continue end

			Passengers[ weapon:GetPodIndex() ] = "[AI] Gunner"
		end
	end

	ply.SwitcherTime = ply.SwitcherTime or 0
	ply._lvsoldPassengers = ply._lvsoldPassengers or {}

	local Time = CurTime()
	for k, v in pairs( Passengers ) do
		if ply._lvsoldPassengers[k] ~= v then
			ply._lvsoldPassengers[k] = v
			ply.SwitcherTime = Time + 2
		end
	end
	for k, v in pairs( ply._lvsoldPassengers ) do
		if not Passengers[k] then
			ply._lvsoldPassengers[k] = nil
			ply.SwitcherTime = Time + 2
		end
	end
	for _, v in pairs( LVS.pSwitchKeysInv ) do
		if input.IsKeyDown(v) then
			ply.SwitcherTime = Time + 2
		end
	end

	local Hide = ply.SwitcherTime > Time

	ply.smHider = ply.smHider and (ply.smHider + ((Hide and 1 or 0) - ply.smHider) * RealFrameTime() * 15) or 0

	local Alpha1 = 135 + 110 * ply.smHider 
	local HiderOffset = 270 * ply.smHider
	local xPos = w - 35
	local yPos = Y - (SeatCount + 1) * 30 + h + 5

	local SwapY = false
	local SwapX = false

	local xHider = HiderOffset

	if X < (ScrX * 0.5 - w * 0.5) then
		SwapX = true
		xPos = 0
		xHider = 0
	end

	if Y < (ScrY * 0.5 - h * 0.5) then
		SwapY = true
		yPos = Y - h
	end

	for _, Pod in pairs( pSeats ) do
		if not IsValid( Pod ) then continue end

		local I = Pod:lvsGetPodIndex()

		if I <= 0 then continue end

		if I == MySeat then
			draw.RoundedBox(5, X + xPos - xHider, yPos + I * 30, 35 + HiderOffset, 25, Color(LVS.ThemeColor.r, LVS.ThemeColor.g, LVS.ThemeColor.b,100 + 50 * ply.smHider) )
		else
			draw.RoundedBox(5, X + xPos - xHider, yPos + I * 30, 35 + HiderOffset, 25, Color(0,0,0,100 + 50 * ply.smHider) )
		end

		if Hide then
			if Passengers[I] then
				draw.DrawText( Passengers[I], "LVS_FONT_SWITCHER", X + 40 + xPos - xHider, yPos + I * 30 + 2.5, Color( 255, 255, 255,  Alpha1 ), TEXT_ALIGN_LEFT )
			else
				draw.DrawText( "-", "LVS_FONT_SWITCHER", X + 40 + xPos - xHider, yPos + I * 30 + 2.5, Color( 255, 255, 255,  Alpha1 ), TEXT_ALIGN_LEFT )
			end
			
			draw.DrawText( "["..I.."]", "LVS_FONT_SWITCHER", X + 17 + xPos - xHider, yPos + I * 30 + 2.5, Color( 255, 255, 255, Alpha1 ), TEXT_ALIGN_CENTER )
		else
			if Passengers[I] then
				draw.DrawText( "[^"..I.."]", "LVS_FONT_SWITCHER", X + 17 + xPos - xHider, yPos + I * 30 + 2.5, Color( 255, 255, 255, Alpha1 ), TEXT_ALIGN_CENTER )
			else
				draw.DrawText( "["..I.."]", "LVS_FONT_SWITCHER", X + 17 + xPos - xHider, yPos + I * 30 + 2.5, Color( 255, 255, 255, Alpha1 ), TEXT_ALIGN_CENTER )
			end
		end

		if not self:GetlvsLockedStatus() then continue end

		local xLocker = SwapX and 35 + HiderOffset or -25 - HiderOffset

		if SwapY then
			if I == 1 then
				surface.SetDrawColor( 255, 255, 255, 255 )
				surface.SetMaterial( self.IconVehicleLocked  )
				surface.DrawTexturedRect( X + xPos + xLocker, yPos + I * 30, 25, 25 )
			end
		else
			if I == SeatCount then
				surface.SetDrawColor( 255, 255, 255, 255 )
				surface.SetMaterial( self.IconVehicleLocked  )
				surface.DrawTexturedRect( X + xPos + xLocker, yPos + I * 30, 25, 25 )
			end
		end
	end
end

--addons/lvs_addons/lua/entities/lvs_base_turret/cl_deathsound.lua:

function ENT:OnDestroyed()
	if not self.DeathSound then return end

	if self:GetVelocity():Length() <= self.MaxVelocity * 0.5 then return end

	self._sndDeath = CreateSound( self, self.DeathSound )
	self._sndDeath:SetSoundLevel( 125 )
	self._sndDeath:PlayEx( 1, 50 + 50 * self:CalcDoppler( LocalPlayer() ) )
end

function ENT:StopDeathSound()
	if not self._sndDeath then return end

	self._sndDeath:Stop()
end


--addons/lvs_addons/lua/entities/lvs_fakehover_aat/cl_init.lua:
include("shared.lua")
include( "sh_turret.lua" )
include( "cl_prediction.lua" )

function ENT:OnSpawn()
	local mins, maxs = self:GetRenderBounds()
	self:SetRenderBounds( mins, maxs, Vector( 80, 0, 0 ) )
end

function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(11,0,46) ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(11,40,46) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(11,-40,46) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

function ENT:OnFrame()
	self:PredictPoseParamaters()
	self:DamageFX()
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if ply == self:GetDriver() and not pod:GetThirdPersonMode() then
		return pos + self:GetForward() * 60 - self:GetUp() * 30, angles, fov
	end

	return pos, angles, fov
end

local COLOR_RED = Color(255,0,0,255)
local COLOR_WHITE = Color(255,255,255,255)

function ENT:LVSPreHudPaint( X, Y, ply )
	if self:GetIsCarried() then return false end

	if ply == self:GetDriver() then
		local Col = self:WeaponsInRange() and COLOR_WHITE or COLOR_RED

		local Pos2D = self:GetEyeTrace().HitPos:ToScreen() 

		self:PaintCrosshairCenter( Pos2D, Col )
		self:PaintCrosshairOuter( Pos2D, Col )
		self:LVSPaintHitMarker( Pos2D )
	end

	return true
end

--addons/lvs_addons/lua/entities/lvs_gunship_hmp/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-306.32,-529.84,149.92), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-306.32,529.84,149.92), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-314.74,-474.83,234.39), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-314.74,474.83,234.39), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EngineFXColor = Color(255, 192, 0)
ENT.EngineFxPos = {
	--left
	Vector(-593,311.06,238.35),
	Vector(-597.54,305.85,238.09),
	Vector(-601.49,300.42,237.94),
	Vector(-607.29,295.7,238.21),
	Vector(-610.4,289.49,238.15),
	Vector(-614.91,284.03,238.38),
	Vector(-618.13,277.97,238.14),
	Vector(-622.7,272.94,238.44),
	Vector(-627.85,267.1,238.71),
	Vector(-631.05,261.81,238.38),
	Vector(-634.33,255.62,238.26),
	Vector(-637.66,249.51,238.26),
	Vector(-643.17,244.69,238.61),
	Vector(-646.48,237.98,238.58),
	Vector(-649.64,231.77,238.5),
	Vector(-652.27,225.64,238.41),
	Vector(-657.42,220.29,238.79),
	Vector(-659.51,213.81,238.67),
	Vector(-662.24,207.18,238.74),
	Vector(-664.73,200.6,238.56),
	Vector(-669.11,194.78,238.86),
	Vector(-671.12,188.14,238.84),
	Vector(-675.44,182.48,239.09),
	Vector(-677.48,175.8,239.05),
	Vector(-679.69,169.06,238.96),
	Vector(-681.83,162.54,238.87),
	Vector(-683.76,155.7,238.88),
	Vector(-687.69,149.68,239.16),
	Vector(-689.48,142.85,239.12),
	Vector(-691.1,136.2,239.11),
	Vector(-692.81,129.32,239.17),
	Vector(-694.47,122.47,239.13),
	Vector(-695.87,115.78,239.2),
	Vector(-697.42,108.81,239.11),
	Vector(-700.06,102.45,239.34),
	Vector(-701.45,95.67,239.25),
	Vector(-702.79,88.5,239.17),
	Vector(-703.67,81.94,239.08),
	Vector(-704.7,74.91,239.38),
	Vector(-622.7,272.94,238.44),
	--right
	Vector(-593,-311.06,238.35),
	Vector(-597.54,-305.85,238.09),
	Vector(-601.49,-300.42,237.94),
	Vector(-607.29,-295.7,238.21),
	Vector(-610.4,-289.49,238.15),
	Vector(-614.91,-284.03,238.38),
	Vector(-618.13,-277.97,238.14),
	Vector(-622.7,-272.94,238.44),
	Vector(-627.85,-267.1,238.71),
	Vector(-631.05,-261.81,238.38),
	Vector(-634.33,-255.62,238.26),
	Vector(-637.66,-249.51,238.26),
	Vector(-643.17,-244.69,238.61),
	Vector(-646.48,-237.98,238.58),
	Vector(-649.64,-231.77,238.5),
	Vector(-652.27,-225.64,238.41),
	Vector(-657.42,-220.29,238.79),
	Vector(-659.51,-213.81,238.67),
	Vector(-662.24,-207.18,238.74),
	Vector(-664.73,-200.6,238.56),
	Vector(-669.11,-194.78,238.86),
	Vector(-671.12,-188.14,238.84),
	Vector(-675.44,-182.48,239.09),
	Vector(-677.48,-175.8,239.05),
	Vector(-679.69,-169.06,238.96),
	Vector(-681.83,-62.54,238.87),
	Vector(-683.76,-155.7,238.88),
	Vector(-687.69,-149.68,239.16),
	Vector(-689.48,-142.85,239.12),
	Vector(-691.1,-136.2,239.11),
	Vector(-692.81,-129.32,239.17),
	Vector(-694.47,-122.47,239.13),
	Vector(-695.87,-115.78,239.2),
	Vector(-697.42,-108.81,239.11),
	Vector(-700.06,-102.45,239.34),
	Vector(-701.45,-95.67,239.25),
	Vector(-702.79,-88.5,239.17),
	Vector(-703.67,-81.94,239.08),
	Vector(-704.7,-74.91,239.38),
	Vector(-622.7,-272.94,238.44),
	Vector(-681.36,-159.23,238.58),

}

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 25 + self:GetThrottle() * 90 + self:GetBoost() * 0.9

	render.SetMaterial( self.EngineGlow )

	for _, v in pairs( self.EngineFxPos ) do
		local pos = self:LocalToWorld( v )
		render.DrawSprite( pos, Size, Size, self.EngineFXColor )

	end
end


function ENT:OnStartBoost()
	self:EmitSound( "hmp/throttlepunch_6.mp3", 85 )
end


--addons/lvs_addons/lua/entities/lvs_gunship_hmp/shared.lua:

ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "HMP Droid Gunship"
ENT.Author = "Salty"
ENT.Information = "Droid HMP Gunship of the Trade Federation"
ENT.Category = "AOCRP - KUS - Flugobjekte"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/salty/cis-hmp-gunship.mdl"
ENT.GibModels = {
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
	"models/salty/hmpgib1.mdl",
	"models/salty/hmpgib2.mdl",
}


ENT.AITEAM = 1

ENT.MaxVelocity = 2235
ENT.MaxThrust = 2235

ENT.ThrustVtol = 100
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1.25

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 4000
ENT.MaxShield = 1200

function ENT:OnSetupDataTables()
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Entity", "ThirdGunnerSeat" )
end

function ENT:GetAimAngles( ent )
    local trace = ent:GetEyeTrace()
    local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(100,300,30) ) ):GetNormalized():Angle() )

    return AimAngles
end

function ENT:WeaponsInRange( ent )
    local AimAngles = self:GetAimAngles( ent )

    return not (AimAngles.p >= 35 or AimAngles.p <= -35)
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(652.69,-1.53,37.35),
		Vector(-88.78,-512.76,133.99),
		Vector(-88.78,512.76,133.99),
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 1500
	weapon.Delay = 0.10
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 40
		bullet.Damage	= 35
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 125 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 1500
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.30 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.30
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.04

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( -0.54, (ent._swapMissile and -298.55 or 298.55), 170 )

		local Driver = self:GetDriver()

		local projectile = ents.Create( "hmp_concussionmissile" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 95000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "hmp/simple_oneshot_juggernaut_rocketlauncher_close_var_04.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.04

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
	
	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)

local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.10
	weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()
		
		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 65 then return true end
		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
		
		local bullet = {}
		bullet.Src = veh:LocalToWorld( ent.SwapTopBottom and Vector(457.33,241.02,59.64) or Vector(423.75,266.36,60.54) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255, 0, 0) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		if not IsValid( base ) then 
			return LVS:CalcView( ent, ply, pos, angles, fov, pod )
		end

		if pod:GetThirdPersonMode() then
			pos = pos + base:GetUp() * 100
		end

		return LVS:CalcView( base, ply, pos, angles, fov, pod )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 65) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.10
	weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()
		
		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 65 then return true end
		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
		
		local bullet = {}
		bullet.Src = veh:LocalToWorld( ent.SwapTopBottom and Vector(422.77,-265.56,59.79) or Vector(454.37,-242.29,59.55) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255, 0, 0) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		if not IsValid( base ) then 
			return LVS:CalcView( ent, ply, pos, angles, fov, pod )
		end

		if pod:GetThirdPersonMode() then
			pos = pos + base:GetUp() * 100
		end

		return LVS:CalcView( base, ply, pos, angles, fov, pod )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 65) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 3 )
end

ENT.FlyByAdvance = 0
ENT.FlyBySound = "LVS.VULTURE.FLYBY" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "hmp/hmp_gunship_engineidleing.wav",
		Pitch = 250,
		PitchMin = 0,
		PitchMax = 105,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/lvs_addons/lua/entities/lvs_repulsorlift_gunship/sh_mainweapons.lua:
function ENT:InitWeaponDriver()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 600
	weapon.Delay = 0.25
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		if math.abs( ent.frontgunYaw ) > 100 then return end

		local ID_L = self:LookupAttachment( "muzzle_frontgun_left" )
		local ID_R = self:LookupAttachment( "muzzle_frontgun_right" )
		local Muzzle = {
			[1] = self:GetAttachment( ID_L ),
			[2] = self:GetAttachment( ID_R ),
		}

		local NewHeat = ent:GetHeat()

		for id = 1, 2 do
			if id == 1 and ent.frontgunYaw > 5 then continue end
			if id == 2 and ent.frontgunYaw < -5 then continue end

			local att = Muzzle[ id ]

			local bullet = {}
			bullet.Src 	= att.Pos
			bullet.Dir 	= att.Ang:Up()
			bullet.Spread 	= Vector( 0.015,  0.015, 0 )
			bullet.TracerName = "lvs_laser_green"
			bullet.Force	= 10
			bullet.HullSize 	= 25
			bullet.Damage	= 40
			bullet.Velocity = 60000
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
					effectdata:SetStart( Vector(50,255,50) ) 
					effectdata:SetOrigin( tr.HitPos )
					effectdata:SetNormal( tr.HitNormal )
				util.Effect( "lvs_laser_impact", effectdata )
			end

			ent:LVSFireBullet( bullet )
			ent:TakeAmmo()

			NewHeat = NewHeat + 0.075
		end

		ent:SetHeat( NewHeat )

		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )
		local trace = ent:GetEyeTrace()

		local AimAngles = ent:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld(  Vector(256,0,36) ) ):GetNormalized():Angle() )

		ent.frontgunYaw = -AimAngles.y

		if math.abs( ent.frontgunYaw ) > 100 then
			ent:SetPoseParameter("frontgun_pitch", 0 )
			ent:SetPoseParameter("frontgun_yaw", 0 )

			return
		end

		ent:SetPoseParameter("frontgun_pitch", -AimAngles.p )
		ent:SetPoseParameter("frontgun_yaw", -AimAngles.y )
	end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 26
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			if IsValid( ent._ProtonTorpedo:GetTarget() ) then
				ent:SetBodygroup( 1, 1 )
			end

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local TypeA = self:GetBodygroup( 3 ) == 0
		local Pos = Vector( (TypeA and -20 or 206.07), (ent._swapMissile and -59 or 59), 286.88 )

		local Driver = self:GetDriver()

		local projectile = ents.Create( TypeA and "lvs_protontorpedo" or "lvs_concussionmissile" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )

		ent._ProtonTorpedo = projectile
		ent._TypeA = TypeA

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		ent:SetBodygroup( 1, 0 )

		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( self._TypeA and "lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3" or "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.33

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_sidedoor.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function( ent )
		local T = CurTime()

		if (ent.NextDoor or 0) > T then return end

		if ent:GetBodygroup( 2 ) == 0 then
			local DoorMode = ent:GetDoorMode() + 1

			ent:SetDoorMode( DoorMode )
			
			if DoorMode == 1 then
				ent:EmitSound( "lvs/vehicles/laat/door_open.wav" )
			end
			
			if DoorMode == 2 then
				ent.NextDoor = T + 1

				ent:PlayAnimation( "doors_open" )
				ent:EmitSound( "lvs/vehicles/laat/door_large_open.wav" )
			end
			
			if DoorMode == 3 then
				ent:PlayAnimation( "doors_close" )
				ent:EmitSound( "lvs/vehicles/laat/door_large_close.wav" )
			end
			
			if DoorMode >= 4 then
				ent:SetDoorMode( 0 )
				ent:EmitSound( "lvs/vehicles/laat/door_close.wav" )

				ent.NextDoor = T + 1
			end
		else
			ent.NextDoor = T + 1

			local DoorMode = ent:GetDoorMode() + 1

			ent:SetDoorMode( DoorMode )

			if DoorMode == 1 then
				ent:PlayAnimation( "doors_open" )
				ent:EmitSound( "lvs/vehicles/laat/door_large_open.wav" )
			end
			
			if DoorMode >= 2 then
				ent:PlayAnimation( "doors_close" )
				ent:EmitSound( "lvs/vehicles/laat/door_large_close.wav" )
				ent:SetDoorMode( 0 )
			end
		end

		ent:OnDoorsChanged()
	end
	self:AddWeapon( weapon )


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_reardoor.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function( ent )
		local T = CurTime()

		if (ent.NextDoor or 0) > T then return end

		ent.NextDoor = T + 1

		local ToggleHatch = not ent:GetRearHatch()

		ent:SetRearHatch( ToggleHatch )
		
		if ToggleHatch then
			ent:EmitSound( "lvs/vehicles/laat/door_open.wav" )
		else
			ent:EmitSound( "lvs/vehicles/laat/door_close.wav" )
		end

		ent:OnDoorsChanged()
	end
	self:AddWeapon( weapon )
end
--addons/lvs_addons/lua/entities/lvs_starfighter_hyenabomber/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-201.14,-178.05,101.58), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-201.14,178.05,101.58), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-269.82,-178.6,65.6), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-269.82,178.6,65.6), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EngineFXColor = Color( 0, 0, 255)
ENT.EngineFxPos = {
	Vector(0.16,-102.55,85.47),
	Vector(-1.33,-102.85,78.71),
	Vector(1.14,-109.51,78.55),
	Vector(0.28,-109.68,85.77),
	Vector(5.99,-116.13,85.42),
	Vector(5.82,-116.12,78.67),
	Vector(10.93,-122.51,84.96),
	Vector(10.56,-122.86,78.4),

	--left
	Vector(0.16,102.55,85.47),
	Vector(-1.33,102.85,78.71),
	Vector(1.14,109.51,78.55),
	Vector(0.28,109.68,85.77),
	Vector(5.99,116.13,85.42),
	Vector(5.82,116.12,78.67),
	Vector(10.93,122.51,84.96),
	Vector(10.56,122.86,78.4),
}

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 25 + self:GetThrottle() * 90 + self:GetBoost() * 0.9

	render.SetMaterial( self.EngineGlow )

	for _, v in pairs( self.EngineFxPos ) do
		local pos = self:LocalToWorld( v )
		render.DrawSprite( pos, Size, Size, self.EngineFXColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/hyena/VEH_STARHAWK_BOOST_ON.mp3", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vulturedroid/brake.wav", 85 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_kimogila/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "M12-L Kimogila"
ENT.Author = "Nashatok"
ENT.Information = "A Hutt heavy fighter built by MandalMotors"
ENT.Category = "[LVS] - Star Wars"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/kimogila/sfp_kimogila.mdl"

ENT.AITEAM = 1

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 750
ENT.MaxShield = 100

function ENT:InitWeapons()
	self.FirePositions= {
		Vector(50,410,145), Vector(50,-410,145),
		Vector(470,37,68),Vector(470,-37,68),
	}
	self.Dir= { 2, -2, 0.3, -0.3 }
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 800
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )

		for i = 1, 2 do
		self.NumPrim = self.NumPrim and self.NumPrim + 1 or 1
		if self.NumPrim > 4 then self.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

			local bullet = {}
		bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
			bullet.Spread 	= Vector( 0.02,  0.02, 0 )
			bullet.TracerName = "lvs_laser_red"
			bullet.Force	= 10
			bullet.HullSize 	= 25
			bullet.Damage	= 30
			bullet.Velocity = 50000
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
				util.Effect( "lvs_laser_explosion", effectdata )
			end

			local effectdata = EffectData()
			effectdata:SetStart( Vector(200,150,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )
			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo( 2 )

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
	
	--Weapon 3 - concussion Missiles
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.UseableByAI = false
	weapon.Ammo = 6
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile
		--(0,0,165)
		local Pos = Vector( -14,(ent._swapMissile and 228 or -228),150 )

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( ent:GetDriver() )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
end

ENT.FlyByAdvance = 0.75
ENT.FlyBySound = "lvs/vehicles/vwing/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/vwing/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_wwing/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "T-38 W-Wing"
ENT.Author = "Luna"
ENT.Information = "Starfighter of the Galactic Republic"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/wwing/rep_w-wing.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxVelocity = 2500
ENT.MaxThrust = 2500

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1.25
ENT.TurnRateYaw = 1.25
ENT.TurnRateRoll = 1.25

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 1000
ENT.MaxShield = 600

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(164,105,30),
		Vector(164,-105,30),
		Vector(164,105,10),
		Vector(164,-105,10),
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 3000
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end
	
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( CurPos )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 80
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,50,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		else
			ent.SNDRight:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")

		if ent.SetFoils then ent:SetFoils( true ) end
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 4
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( 6, (ent._swapMissile and -25 or 25), 10 )

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )


	self:AddWeapon( LVS:GetWeaponPreset( "TURBO" ) )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/vwing/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/vwing/loop.wav",
		sound_int = "lvs/vehicles/vwing/loop_interior.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_ywing/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Y-Wing"
ENT.Author = "KurtJQ"
ENT.Information = "BTL-B Y-Wing Starfighter of the Republic"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/ywing/BTL-B_Y-Wing.mdl"

ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxVelocity = 2350
ENT.MaxThrust = 2350

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 0.75

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 1400
ENT.MaxShield = 600

function ENT:OnSetupDataTables()
	self:AddDT( "Entity", "TopGunnerSeat")
end

function ENT:SetPoseParameterTopGun( weapon )
	if not IsValid( weapon:GetDriver() ) and not weapon:GetAI() then return end

	local AimAng = weapon:WorldToLocal( weapon:GetPos() + weapon:GetAimVector() ):Angle()
	AimAng:Normalize()

	self:SetPoseParameter("gunner_seat", AimAng.y)
	self:SetPoseParameter("turrets", -AimAng.p)
end

function ENT:TraceGunner()
	local IDL = self:LookupAttachment("turret_muzzle_L")
	local IDR = self:LookupAttachment("turret_muzzle_R")
	local MuzzleL = self:GetAttachment( IDL )
	local MuzzleR = self:GetAttachment( IDR )

	if not MuzzleL then return end
	if not MuzzleR then return end

	local dir = -MuzzleL.Ang:Up()
	local pos = MuzzleL.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = pos + dir * 50000,
	} )

	return trace
end

function ENT:InitWeapons()
	local COLOR_WHITE = Color(255,255,255,255)

	self.FirePositions = {
		Vector(517.48,-22.81,45.25),
		Vector(517.48,22.64,45.24)
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 1200
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_blue_long"
		bullet.Force	= 10
		bullet.HullSize 	= 30
		bullet.Damage	= 40
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0 ,0 ,255) )
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(0 , 0, 255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 12
	weapon.Delay = 0
	weapon.HeatRateUp = -0.5
	weapon.HeatRateDown = 0.1
	weapon.Attack = function( ent )

		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		if (ent._nextMissle or 0) > T then return end

		ent._nextMIssle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( 535, ent._swapMissile and -22.81 or 22.81, 46.04)

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_protontorpedo")
		projectile:SetPos( ent:LocalToWorld( Pos ))
		projectile:SetAngles( ent:LocalToWorldAngles( Angle(0, ent._swapMissile and 0, 0) ) )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 )
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.30

		ent:SetHeat(NewHeat)
		if NewHeat >= 1 then
			ent:SetOverheated(true)
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material( "lvs/weapons/bomb.png" )
	weapon.Ammo = 10
	weapon.HeatRateUp = -0.5
	weapon.HeatRateDown = 0.1
	weapon.StartAttack = function( ent )
		local Driver = ent:GetDriver()

		local bomb = ents.Create( "lvs_protonbomb" )
		bomb:SetPos( ent:LocalToWorld( Vector( -135, 0, -10) ) )
		bomb:SetAngles( ent:GetAngles() )
		bomb:SetParent( ent )
		bomb:Spawn()
		bomb:Activate()
		bomb:SetAttacker( IsValid( Driver ) and Driver or self )
		bomb:SetSpeed( ent:GetVelocity() )

		ent._ProtonBomb = bomb
	end
	weapon.FinishAttack = function( ent )
		if not IsValid ( ent._ProtonBomb ) then return end

		local bomb = ent._ProtonBomb
		bomb:Enable()
		ent:TakeAmmo()

		ent._ProtonBomb = nil
	end
	weapon.OnThink = function( ent )
		if not IsValid( ent._ProtonBomb ) then return end

		local bomb = ent._ProtonBomb
		bomb:SetSpeed( ent:GetVelocity() )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end

	self:AddWeapon(weapon)

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.2
	weapon.Attack = function( ent )
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local IDL = self:LookupAttachment( "turret_muzzle_L" )
		local IDR = self:LookupAttachment( "turret_muzzle_R" )
		local MuzzleL = self:GetAttachment( IDL )
		local MuzzleR = self:GetAttachment( IDR )

		if not MuzzleL then return end
		if not MuzzleR then return end

		local veh = ent:GetVehicle()

		veh.GunnerSND:PlayOnce( 100 + math.Rand(-3, 3), 1)

		ent.SwapLeftRight = not ent.SwapLeftRight

		local bullet = {}
		bullet.Src = ent.SwapLeftRight and MuzzleL.Pos or MuzzleR.Pos
		bullet.Dir = -MuzzleL.Ang:Up()
		bullet.Spread = Vector(0, 0, 0)
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force = 10
		bullet.HullSize = 25
		bullet.Damage = 50
		bullet.Velocity = 30000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0 ,0 ,255) )
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end

		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(0 , 0, 255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )
	end

	weapon.OnThink = function( ent, active)
		local base = ent:GetVehicle()

		if not IsValid ( base ) then return end

		base:SetPoseParameterTopGun( ent )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end

	weapon.CalcView = function( ent, ply, pos, angle, fov, pod)
		local base = ent:GetVehicle()

		if not IsValid( base ) then
			return LVS:CalcView( ent, ply, pos, angle, fov, pod )
		end

		if pod:GetThirdPersonMode() then
			pos = pos + (ent:GetUp() * 20)
		end

		return LVS:CalcView( ent, ply, pos, angle, fov, pod )
	end

	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceGunner().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, COLOR_WHITE )
		base:PaintCrosshairOuter( Pos2D, COLOR_WHITE )
		base:LVSPaintHitMarker( Pos2D )
	end

	self:AddWeapon( weapon, 2)
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/arc170/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "vanilla/ywing/vanilla_ywing_eng.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
	{
		sound = "vanilla/ywing/vanilla_ywing_dist.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0.35,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		VolumeMin = 0,
		VolumeMax = 1,
		SoundLevel = 100,
	}
}
--addons/lvs_addons/lua/entities/lvs_walker_atte/cl_camera.lua:

function ENT:CalcViewDriver( ply, pos, angles, fov, pod )
	local view = {}
	view.origin = pos
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	if not pod:GetThirdPersonMode() then return view end

	local mn = self:OBBMins()
	local mx = self:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local clamped_angles = pod:WorldToLocalAngles( angles )
	clamped_angles.p = math.max( clamped_angles.p, -20 )
	clamped_angles = pod:LocalToWorldAngles( clamped_angles )

	local StartPos = self:LocalToWorld( self:OBBCenter() ) + clamped_angles:Up() * 100
	local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * (radius * 0.2 + radius * pod:GetCameraHeight())

	local WallOffset = 4

	local tr = util.TraceHull( {
		start = StartPos,
		endpos = EndPos,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.angles = angles + Angle(5,0,0)
	view.origin = tr.HitPos
	view.drawviewer = true

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

function ENT:LVSCalcView( ply, pos, angles, fov, pod )
	if self:GetDriver() == ply then
		return self:CalcViewDriver( ply, pos, angles, fov, pod )
	end

	local view = {}
	view.origin = self:LocalToWorld( Vector(0,0,200) )
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	local mn = self:OBBMins()
	local mx = self:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local TargetOrigin = view.origin + ( view.angles:Forward() * -radius ) + view.angles:Up() * (80 + radius * pod:GetCameraHeight())
	local WallOffset = 4

	local tr = util.TraceHull( {
		start = view.origin,
		endpos = TargetOrigin,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.origin = tr.HitPos

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end
--addons/arccw_weapons/lua/entities/nade_mortar/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Mortal Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/ThermalDetonator.mdl"
ENT.FuseTime = 3.5
ENT.ArmTime = 0
ENT.ImpactFuse = true

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.kt = CurTime() + self.FuseTime
        self.at = CurTime() + self.ArmTime
    end
end

function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        if data.Speed > 75 then
            self:EmitSound(Sound("weapons/star_wars_battlefront/common/imp_grenade_stone_0" .. math.random(1,3) .. ".wav"))
        elseif data.Speed > 25 then
            self:EmitSound(Sound("weapons/star_wars_battlefront/common/imp_grenade_dirt_0" .. math.random(1,3) .. ".wav"))
        end

        if self.at <= CurTime() and self.ImpactFuse then
            self:Detonate()
        end
    end
end

function ENT:Think()
    if SERVER and CurTime() >= self.kt then
        self:Detonate()

    end
end

function ENT:Detonate()
    if SERVER then
        if not self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_imp_launcher", self:GetPos(), self:GetAngles() )
sound.Play( "weapons/star_wars_battlefront/common/exp_ord_thermalDetonator0" .. math.random(1,2) .. ".wav",  self:GetPos(), 100, 100 )

        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        util.BlastDamage(self, attacker, self:GetPos(), 200, 75)
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),4096,100,0.6,1024)
        self:Remove()

    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()
		
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/swbf/flare0") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(30, 40), math.random(30, 40), Color(155, 50, 50) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
      
    end
end
--addons/arccw_weapons/lua/entities/nade_radiation/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Radiation Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/ThermalDetonator.mdl"
ENT.FuseTime = 3.5
ENT.ArmTime = 0
ENT.ImpactFuse = true

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.kt = CurTime() + self.FuseTime
        self.at = CurTime() + self.ArmTime
    end
end

function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        if data.Speed > 75 then
            self:EmitSound(Sound("weapons/star_wars_battlefront/common/imp_grenade_stone_0" .. math.random(1,3) .. ".wav"))
        elseif data.Speed > 25 then
            self:EmitSound(Sound("weapons/star_wars_battlefront/common/imp_grenade_dirt_0" .. math.random(1,3) .. ".wav"))
        end

        if self.at <= CurTime() and self.ImpactFuse then
            self:Detonate()
        end
    end
end

function ENT:Think()
    if SERVER and CurTime() >= self.kt then
        self:Detonate()
				self:EmitSound(Sound("weapons/star_wars_battlefront/common/exp_ord_haywireGrenade.wav"))

    end
end

function ENT:Detonate()
    if SERVER then
        if not self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_cis_launcher", self:GetPos(), self:GetAngles() )
			sound.Play( "weapons/star_wars_battlefront/common/exp_ord_haywireGrenade.wav",  self:GetPos(), 100, 100 )

        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        util.BlastDamage(self, attacker, self:GetPos(), 200, 75)
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),4096,100,0.6,1024)
        self:Remove()

    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()
		
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/swbf/flare0") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(30, 40), math.random(30, 40), Color(125, 155, 50) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
      
    end
end
--addons/arccw_weapons/lua/entities/rocket_reb/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "HH Rocket"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/com_weap_missile.mdl"
ENT.FuseTime = 8
ENT.ArmTime = 0

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
			phys:SetMass(2)
            phys:SetBuoyancyRatio(0)
            phys:EnableGravity( false )
        end

        self.kt = CurTime() + self.FuseTime
        self.motorsound = CreateSound( self, "weapons/star_wars_battlefront/common/ammo_rocket_lp06.wav")
    end

    self.at = CurTime() + self.ArmTime
    self.Armed = false
end

function ENT:OnRemove()
    if SERVER then
        self.motorsound:Stop()
    end
end


function ENT:PhysicsCollide(data, physobj)
    if self.at <= CurTime() then
        self:Detonate()
    elseif self.at > CurTime() then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        util.Effect( "RPGShotDown", effectdata)
        util.Effect( "StunstickImpact", effectdata)
        self:Remove()
    end
end

function ENT:Arm()
    if SERVER then
        self.motorsound:Play()
    end
end

function ENT:Think()

    if CurTime() >= self.at and !self.Armed then
        self:Arm()
        self.Armed = true
    end

    if SERVER then

        if self.Armed then
            local phys = self:GetPhysicsObject()
            phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    end

    if CLIENT then
        if self.Armed then
		ParticleEffectAttach( "astw2_swbf_muzzle_reb_sniper", PATTACH_POINT_FOLLOW, self, 0 )
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end

            local smoke = emitter:Add("effects/swbf/thicksmoke", self:GetPos())
        smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
        smoke:SetVelocity( self:GetAngles():Forward() * 100 )
        smoke:SetDieTime( math.Rand(0.5,0.75) )
        smoke:SetStartAlpha( 65 )
        smoke:SetEndAlpha( 0 )
        smoke:SetStartSize( 15 )
        smoke:SetEndSize( 140 )
        smoke:SetRoll( math.Rand(-180, 180) )
        smoke:SetRollDelta( math.Rand(-0.2,0.2) )
        smoke:SetColor( 225, 225, 225 )
        smoke:SetAirResistance( 50 )
        smoke:SetPos( self:GetPos() )
        smoke:SetLighting( true )
        emitter:Finish()
        end
    end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_reb_rocket", self:GetPos(), self:GetAngles() )
	sound.Play( "weapons/star_wars_battlefront/common/exp_ord_rocket_large0" .. math.random(1,3) .. ".wav",  self:GetPos(), 100, 100 )
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        util.BlastDamage(self, attacker, self:GetPos(), 250, 300)
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),18000,500,1.2,2048)
        self:Remove()
    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()

        if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(200, 300), math.random(200, 300), Color(255, 225, 150) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
        end
    end
end
--addons/tools/lua/entities/sent_particle_def.lua:
AddCSLuaFile()
ENT.Base = "base_anim"
ENT.PrintName = "Particle Controller"
ENT.Category = "Other"
ENT.Spawnable = true
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
ENT.Editable = true
ENT.Points = {}
function ENT:SetupDataTables()
    self:NetworkVar(
        "String",
        0,
        "ParticleName",
        {
            KeyName = "particle_name",
            Edit = {
                title = "Particle Name",
                type = "String",
                order = 0
            }
        }
    )

    self:NetworkVar(
        "Int",
        0,
        "ControlPoints",
        {
            KeyName = "control_points",
            Edit = {
                title = "Control Points",
                type = "Int",
                min = 0,
                max = 32,
                order = 1
            }
        }
    )

    self:NetworkVar("Int", 1, "CP")
    self:NetworkVar("Int", 2, "Key")
    self:NetworkVar("Bool", 0, "IsChildren")
    self:NetworkVar("Bool", 1, "AutoKill")
    self:NetworkVar("Bool", 2, "IsOn")
    self:NetworkVar("Entity", 0, "Main")
    self:NetworkVar("Entity", 1, "Player")
    self:NetworkVar("Int", 2, "AttachmentSelected")
    self:SetIsOn(true)
    self:NetworkVarNotify("ParticleName", self.OnParticleNameChanged)
    self:NetworkVarNotify("ControlPoints", self.OnControlPointsChanged)
    self:NetworkVarNotify("AttachmentSelected", function(s, name, old, new)
        self:OnParticleNameChanged("", "", self:GetParticleName())
    end)
end

if SERVER then
    util.AddNetworkString("GPart.Restart")
    util.AddNetworkString("GPart.NotifyDead")
end

function ENT:Initialize()
    if SERVER then
        self:SetModel("models/maxofs2d/hover_basic.mdl")
        --self:SetSolid(SOLID_NONE)
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
        self:Activate()
        self:SetSkin(self:GetIsChildren() and 1 or 3)
        self:SetUseType(SIMPLE_USE)
        self:GetPhysicsObject():EnableGravity(false)
    else
        self:SetRenderBounds(Vector(-128, -128, -128) * 2, Vector(128, 128, 128) * 2)
    end

    self:DrawShadow(false)
end

function ENT:Use(act)
    if self:GetIsChildren() then return end
    net.Start("GPart.Restart")
    net.WriteEntity(self)
    net.SendPVS(self:GetPos())
end

function ENT:OnParticleNameChanged(name, old, new)
    if self:GetIsChildren() then return end
    if CLIENT then
        if self.Particle and self.Particle:IsValid() then
            self.Particle:StopEmissionAndDestroyImmediately()
        end

        self.Particle = CreateParticleSystem(self, new, PATTACH_CUSTOMORIGIN, self:GetAttachmentSelected())
        self.Particle:SetShouldDraw(false)
        self.DidCreate = true
    end
end

function ENT:OnControlPointsChanged(name, old, new)
    if self:GetIsChildren() then return end
    if CLIENT then return end
    for k, v in pairs(self.Points) do
        SafeRemoveEntity(v)
    end

    self.Points = {}
    local val = new or old
    if val <= 0 then return end
    for k = 1, new or old do
        local ent = ents.Create(self:GetClass())
        ent:SetPos(self:GetPos() + Vector(0, 0, 32) * k)
        ent:SetIsChildren(true)
        ent:SetMain(self)
        ent:SetCP(k)
        ent:Spawn()
        self:DeleteOnRemove(ent)
        table.insert(self.Points, ent)
    end
end

function ENT:Think()
    if IsValid(self:GetParent()) then
        local att = self:GetParent():GetAttachment(self:GetAttachmentSelected())
        if att then
            self:SetPos(att.Pos)
            self:SetAngles(att.Ang)
        end
    end
end

function ENT:OnRemove()
    if CLIENT and self.Particle and self.Particle:IsValid() then
        self.Particle:StopEmissionAndDestroyImmediately()
    end
end

if SERVER then
    numpad.Register(
        "Particle_Toggle",
        function(pl, ent)
            if not IsValid(ent) then return false end
            if not IsValid(pl) then return false end
            ent:SetIsOn(not ent:GetIsOn())
            if ent:GetIsOn() then
                net.Start("GPart.Restart")
                net.WriteEntity(ent)
                net.SendPVS(ent:GetPos())
            end
        end
    )
end

local allowed = {
    weapon_physgun = true,
    weapon_physcannon = true,
    gmod_tool = true
}

local beam = Material("trails/laser")
local forwardColor = Color(255, 0, 0)
local imgs = {}

for k = 0, 9 do
    imgs[k] = Material("sprites/key_" .. k)
end
function ENT:DrawGizmo(isDev)
    if not isDev then return end
    render.SetMaterial(beam)
    local r, f, u = self:GetRight(), self:GetForward(), self:GetUp()
    local a, b = self:GetPos(), self:GetPos() + f * 24
    render.DrawBeam(a, b, 8, 0, 1, forwardColor)
    render.DrawBeam(b, b + r * 8 - f * 8, 8, 0, 1, forwardColor)
    render.DrawBeam(b, b - r * 8 - f * 8, 8, 0, 1, forwardColor)

    render.DrawBeam(b, b + u * 8 - f * 8, 8, 0, 1, forwardColor)
    render.DrawBeam(b, b - u * 8 - f * 8, 8, 0, 1, forwardColor)

    if self:GetCP() > 9 then return end

    render.SetMaterial(imgs[self:GetCP()])
    render.DrawSprite(self:GetPos() + Vector(0, 0, 12), 8, 8, color_white)
end

function ENT:DrawTranslucent()
    local wep = LocalPlayer():GetActiveWeapon()
    local isDev = not self:GetAutoKill() and IsValid(wep) and allowed[wep:GetClass()]
    if isDev then
        render.SuppressEngineLighting(true)
        render.SetBlend(.5)
        self:DrawModel()
        render.SetBlend(1)
        render.SuppressEngineLighting(false)
    end

    if self:GetIsChildren() then
        local main = self:GetMain()
        if not IsValid(main) then return end
        if main.Particle and main.Particle:IsValid() then
            main.Particle:SetControlPointEntity(self:GetCP(), self)
            main.Particle:SetControlPointOrientation(self:GetCP(), self:GetAngles())
            main.Particle:SetControlPoint(self:GetCP(), self:GetPos())
        end

        self:DrawGizmo(isDev)

        return
    end

    if self.Particle and self.Particle:IsValid() then
        if not self:GetIsOn() then return end
        self.Particle:SetControlPointOrientation(0, self:GetAngles())
        if IsValid(self:GetParent()) then
            local att = self:GetParent():GetAttachment(self:GetAttachmentSelected())
            if att then
                local ang = att.Ang
                self.Particle:SetControlPointOrientation(0, ang)
                self.Particle:SetControlPoint(0, att.Pos)
            end
        else
            self.Particle:SetControlPoint(0, self:GetPos())
        end
        self.Particle:Render()
    elseif self:GetParticleName() ~= "" then
        if self:GetAutoKill() and self.DidCreate and not self.Notified then
            self.Notified = true
            net.Start("GPart.NotifyDead")
            net.WriteEntity(self)
            net.SendToServer()
        end

        if self:GetAutoKill() then return end
        self:OnParticleNameChanged("", "", self:GetParticleName())
    end

    self:DrawGizmo(isDev)
end

net.Receive(
    "GPart.NotifyDead",
    function(l, ply)
        local target = net.ReadEntity()
        if target:GetClass() == "sent_particle_def" then
            SafeRemoveEntity(target)
        end
    end
)

net.Receive(
    "GPart.Restart",
    function()
        local target = net.ReadEntity()
        if target:GetClass() == "sent_particle_def" then
            target:OnParticleNameChanged("ParticleName", "", target:GetParticleName())
        end
    end
)
--addons/joes_stuff/lua/entities/shield_4/cl_init.lua:
include('shared.lua')

--addons/joes_stuff/lua/entities/shield_5/cl_init.lua:
include('shared.lua')

--addons/joes_stuff/lua/entities/shield_bubble/cl_init.lua:
include('shared.lua')

function ENT:Initialize()
	self.StartTime = CurTime()
	self.height = 0
	self.buildtime = 1.5
	self.isshield = true
end

function ENT:Draw()
	if CurTime() >= self.StartTime + self.buildtime then
		self:DrawModel()
	else
		local min,max = self:GetRenderBounds()
		local center = self:GetPos() + self:OBBCenter()
		self.height = ( max.z / self.buildtime ) * ( CurTime() - self.StartTime )
		local normal = Vector(0,0,1)
		local pos = min + self:LocalToWorld(Vector(0, 0,max.z - self.height))
		local distance = normal:Dot(pos)
		
		render.EnableClipping(true)
		render.PushCustomClipPlane(normal, distance)
		self:DrawModel()
		render.PopCustomClipPlane()
	end
end
--addons/sse_101/lua/entities/sse_box_food.lua:
AddCSLuaFile()

ENT.Base = "sse_base"
ENT.Category        = "SSE"
ENT.PrintName		= "Food Supply (DarkRP)"
ENT.Spawnable       = true
ENT.ConfigName = "Foodbox"


if SERVER then
        

    function ENT:Use( activator, caller )

        if !DarkRP then return end
        if not DarkRP.disabledDefaults["modules"]["hungermod"] then
            if activator:IsPlayer() then
                local maxHunger = self:ConfigValue("MaxFood")
                local currentHunger = activator:getDarkRPVar("Energy") or 0
                local newHunger = currentHunger + self:ConfigValue("AddFood")

                if newHunger > maxHunger then
                newHunger = maxHunger
                end

                activator:SetSelfDarkRPVar("Energy", newHunger)
            end
        end
    end


end


--addons/sse_101/lua/entities/sse_eventspawn.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Eventspawnpoint"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "SSE"
ENT.Spawnable       = true


if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/hunter/plates/plate1x1.mdl" )
        self:DrawShadow( false )
        self:SetColor(Color(255,0,0))
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_NONE)
        self:SetSolid(SOLID_VPHYSICS)
        self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
    end

end
-- test

if CLIENT then

    function ENT:Draw()
        if LocalPlayer():GetMoveType() == MOVETYPE_NOCLIP then
            self:DrawModel() 
        end
    end

end


if SERVER then
    if SSE.Config.EventSpawnAlternative then
        hook.Add( "PlayerSpawn", "SSE_EVENTSPAWN", function(ply)  
            
            timer.Simple(0, function() 
            
                local eventSpawns = ents.FindByClass("sse_eventspawn")

                if #eventSpawns > 0 then
                    ply:SetPos(eventSpawns[math.random(#eventSpawns)]:GetPos())
                end
            end)
        
        end)
    else 
        hook.Add("PlayerSelectSpawn", "SSE_EVENTSPAWN", function(ply)
            local eventSpawns = ents.FindByClass("sse_eventspawn")
        
            if #eventSpawns > 0 then
                return eventSpawns[math.random(#eventSpawns)]
            end
        end)
    end
end
--addons/sse_101/lua/entities/sse_simple_atc.lua:
AddCSLuaFile()


ENT.Base = "sse_base"
ENT.PrintName		= "Radar Console"
ENT.Spawnable       = true
ENT.ConfigName = "RadarConsole"
ENT.ClientInteraction = true
ENT.Category        = "SSE"



if CLIENT then

    function ENT:ClientUse()
 
        if IsValid(SSE_SIMPLE_ATC_FRAME) then SSE_SIMPLE_ATC_FRAME:Remove() end
        SSE_SIMPLE_ATC_FRAME = SSE:DefaultFrame(self:ConfigValue("FrameTitle"))
        SSE_SIMPLE_ATC_FRAME:SetSize(ScrW() * 0.3, ScrH() * 0.8)
        SSE_SIMPLE_ATC_FRAME:Center()
        SSE_SIMPLE_ATC_FRAME:MakePopup()

        local scrollPanel = SSE:ScrollBar(SSE_SIMPLE_ATC_FRAME)
        scrollPanel:Dock( FILL )

        local function fetchEntities(parent)
            for k, v in pairs(ents.GetAll()) do
                if !IsValid(v) then continue end
                if !v.LVS then continue end
                if !v.PrintName then continue end
                if self:ConfigValue("IgnoreClasses")[v:GetClass()] then continue end
    
                local button = SSE:Button(parent, v.PrintName .. " #"..v:GetCreationID(), function()
                end)
                button:Dock(TOP)
            end
        end

        fetchEntities(scrollPanel)

        local bottomPanel = vgui.Create("DPanel", SSE_SIMPLE_ATC_FRAME)
        bottomPanel:Dock(BOTTOM)
        bottomPanel:SetTall(SSEH(40))
        bottomPanel:SetPaintBackground(false)

        local refreshButton = SSE:Button(bottomPanel, self:ConfigValue("Rescan"), function()
            scrollPanel:Clear()
            fetchEntities(scrollPanel)
        end, "bctlr")
        refreshButton:Dock(FILL)

    end




end


--addons/aoc_nextbots/lua/entities/summe_dispenser_flying/cl_init.lua:
include('shared.lua')

function ENT:Draw()
    self:DrawModel()
end
--addons/aoc_nextbots/lua/entities/summe_dispenser_landed/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end
--addons/arccw_weapons/lua/entities/tfa_battlefront_ent_nade_smoke.lua:
ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.PrintName = "explosive Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false 

ENT.BounceSound = Sound("TFA_CSGO_SmokeGrenade.Bounce")
ENT.ExplodeSound = Sound("weapons/tfa_starwars/Smoke_Explosive_Puff_01.wav")

AddCSLuaFile()

function ENT:Initialize()
	if SERVER then
		self:SetModel("models/weapons/tfa_starwars/w_smoke.mdl") 
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
		
		local phys = self:GetPhysicsObject()
		if phys:IsValid() then
			phys:Wake()
			phys:SetBuoyancyRatio(0)
		end
		
		self.Delay = CurTime() + 2
		self.NextParticle = 0
		self.ParticleCount = 0
		self.First = true
		self.IsDetonated = false
	end
	self:EmitSound("TFA_CSGO_SmokeGrenade.Throw")
end

function ENT:PhysicsCollide(data, physobj)
	if SERVER then
		self.HitP = data.HitPos
		self.HitN = data.HitNormal

		if self:GetVelocity():Length() > 60 then
			self:EmitSound(self.BounceSound)
		end
		
		if self:GetVelocity():Length() < 5 then
			self:SetMoveType(MOVETYPE_NONE)
		end
		
		for k, v in pairs( ents.FindInSphere( self:GetPos(), 155 ) ) do
			if v:GetClass() == "tfa_csgo_fire_1" or v:GetClass() == "tfa_csgo_fire_2" and self.IsDetonated == false then
				self:Detonate(self,self:GetPos())
				self.IsDetonated = true
			end
		end
			
	end
end

function ENT:Think()
	if SERVER then	
		if CurTime() > self.Delay then
			if self.IsDetonated == false then
				self:Detonate(self,self:GetPos())
				self.IsDetonated = true
			end
		end
	end
	
	if self.IsDetonated then
		for k, v in pairs( ents.FindInSphere( self:GetPos(), 155 ) ) do
			if (v:GetClass("tfa_csgo_fire_1") or v:GetClass("tfa_csgo_fire_2")) and v:IsValid() then
				v:SetNWBool("extinguished",true)
			end
			if v:GetNWBool("extinguished",true) and self.ParticleCreated == false then
				ParticleEffect( "extinguish_fire", self:GetPos(), self:GetAngles() )
				self.ExtinguishParticleCreated = true
			end
		end
	end
end

function ENT:Detonate(self,pos)
	self.ParticleCreated = false
	self.ExtinguishParticleCreated = false
	if SERVER then
		if not self:IsValid() then return end
		self:SetNWBool("IsDetonated",true)
		self:EmitSound(self.ExplodeSound)
		local gas = EffectData()
		gas:SetOrigin(pos)
		gas:SetEntity(self.Owner) //i dunno, just use it!
		util.Effect("tfa_csgo_smokenade", gas)
	end
	if self.ParticleCreated != true then
		ParticleEffectAttach("explosion_child_smoke03e",PATTACH_ABSORIGIN_FOLLOW,self,0)
		ParticleEffectAttach("explosion_child_core06b",PATTACH_POINT_FOLLOW,self,0)
		ParticleEffectAttach("explosion_child_smoke07b",PATTACH_ABSORIGIN_FOLLOW,self,0)
		ParticleEffectAttach("explosion_child_smoke07c",PATTACH_POINT_FOLLOW,self,0)
		ParticleEffectAttach("explosion_child_distort01c",PATTACH_POINT_FOLLOW,self,0)
		self.ParticleCreated = true
	end
	for k, v in pairs( ents.FindInSphere( self:GetPos(), 155 ) ) do
		if (v:GetClass("tfa_csgo_fire_1") or v:GetClass("tfa_csgo_fire_2")) and v:IsValid() then
			v:SetNWBool("extinguished",true)
		end
		if v:GetNWBool("extinguished",true) and self.ParticleCreated == false then
			ParticleEffect( "extinguish_fire", self:GetPos(), self:GetAngles() )
			self.ExtinguishParticleCreated = true
		end
	end
	
	self:SetMoveType( MOVETYPE_NONE )
	
	if SERVER then
		SafeRemoveEntityDelayed(self,20)
	end
	
end

function ENT:Draw()
	if CLIENT then
		self:DrawModel()
	end
end
--addons/arccw_weapons/lua/entities/tfa_exp_base/shared.lua:

-- Copyright (c) 2018-2020 TFA Base Devs

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

ENT.Type = "anim"
ENT.PrintName = "Base Explosive"
ENT.Author = ""
ENT.Contact = ""
ENT.Purpose = ""
ENT.Instructions = ""
ENT.DoNotDuplicate = true
ENT.DisableDuplicator = true

local sp = game.SinglePlayer()

function ENT:EmitSoundNet(sound)
	if CLIENT or sp then
		if sp and not IsFirstTimePredicted() then return end

		self:EmitSound(sound)

		return
	end

	local filter = RecipientFilter()
	filter:AddPAS(self:GetPos())
	if IsValid(self:GetOwner()) then
		filter:RemovePlayer(self:GetOwner())
	end

	net.Start("tfaSoundEvent", true)
	net.WriteEntity(self)
	net.WriteString(sound)
	net.Send(filter)
end

--addons/arccw_weapons/lua/entities/tfa_exp_timed.lua:

-- Copyright (c) 2018-2020 TFA Base Devs

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

AddCSLuaFile()

ENT.Base = "tfa_exp_base"
ENT.PrintName = "Timed Explosive"

ENT.BounceSound = Sound("HEGrenade.Bounce")

function ENT:PhysicsCollide(data, phys)
	if data.Speed > 60 then
		if self.BounceSound then
			self:EmitSoundNet(self.BounceSound)
		end

		local impulse = (data.OurOldVelocity - 2 * data.OurOldVelocity:Dot(data.HitNormal) * data.HitNormal) * 0.25
		phys:ApplyForceCenter(impulse)
	end
end
--addons/tools/lua/entities/vanilla_modelship2/shared.lua:
ENT.Type 		= "anim"
ENT.Base 		= "base_anim"
ENT.PrintName		= "Vanilla_Hyperspace2"
ENT.Author		= "VanillaNekoNYAN"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false

--addons/wos-passiveevent-ageo/lua/entities/wos_pes_capture_point/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"

ENT.PrintName		= "PES Capture Point"
ENT.Author			= "Oliver (wiltOS)"
ENT.Purpose			= "N/A"

ENT.RenderGroup     = RENDERGROUP_BOTH

function ENT:SetupDataTables()
    self:NetworkVar("Float", 0, "CaptureValue")
    self:NetworkVar("Float", 1, "MaxCaptureValue")
    self:NetworkVar("Float", 2, "CaptureRange")
    self:NetworkVar("Float", 3, "CaptureRate")

    if SERVER then
        self:SetCaptureValue(0)
        self:SetMaxCaptureValue(10)
        self:SetCaptureRange(60)
        self:SetCaptureRate(1)
    end
end

function ENT:SharedInit()
    local phys = self:GetPhysicsObject()
    if ( IsValid( phys ) ) then
        phys:EnableMotion( false )
        phys:EnableDrag( false )
        phys:EnableGravity( false )
        phys:Sleep()

        phys:AddGameFlag(FVPHYSICS_CONSTRAINT_STATIC)
        phys:AddGameFlag(FVPHYSICS_NO_IMPACT_DMG)
        phys:AddGameFlag(FVPHYSICS_NO_NPC_IMPACT_DMG)
        phys:AddGameFlag(FVPHYSICS_NO_PLAYER_PICKUP)
        phys:AddGameFlag(FVPHYSICS_NO_SELF_COLLISIONS)
    end

    self:AddEffects(EF_NORECEIVESHADOW)
    self:AddEffects(EF_NOINTERP)

    self:AddFlags(FL_STATICPROP)
    self:AddFlags(FL_DONTTOUCH)

    self:AddEFlags(EFL_NO_DAMAGE_FORCES)
    self:AddEFlags(EFL_NO_GAME_PHYSICS_SIMULATION)
    self:AddEFlags(EFL_NO_DISSOLVE)
    self:AddEFlags(EFL_NO_MEGAPHYSCANNON_RAGDOLL)
    self:AddEFlags(EFL_NO_PHYSCANNON_INTERACTION)
    self:AddEFlags(EFL_NO_ROTORWASH_PUSH)
    self:AddEFlags(EFL_NO_WATER_VELOCITY_CHANGE)
end

--addons/weapon_jedi/lua/effects/ar2tracer_custom.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

EFFECT.Mat = Material( "effects/gunshiptracer" )

function EFFECT:Init( data )
	self.StartPos = data:GetStart()
	self.EndPos = data:GetOrigin()
	
	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 15000 )
	self.Length = 0.3

	self.DieTime = CurTime() + self.TracerTime
end

function EFFECT:Think()

	if CurTime() > self.DieTime then
		return false
	end

	return true

end

function EFFECT:Render()

	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 )

	local sinWave = math.sin( fDelta * math.pi )
	
	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )
	
	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
		8, 1, 0, color_white )
end

--addons/arccw_weapons/lua/effects/arccw_apex_tracer_anvil/init.lua:
EFFECT.TracerName = "tfa_apex_tracer_anvil"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    --print(self.ParticleName)
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment() or 1
    self.Position = self:GetTracerShootPos(data:GetStart(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.EndPos = data:GetOrigin()
    -- util.ParticleTracerEx(self.ParticleName, self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_POINT, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(0,self.Position)
        pcf:SetControlPoint(1,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(5.0, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--addons/arccw_weapons/lua/effects/arccw_apex_tracer_havoc/init.lua:
EFFECT.TracerName = "tfa_apex_havoc_beam_charged"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    --print(self.ParticleName)
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment() or 1
    self.Position = self:GetTracerShootPos(data:GetStart(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.EndPos = data:GetOrigin()
    -- util.ParticleTracerEx(self.ParticleName, self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_POINT, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(0,self.Position)
        pcf:SetControlPoint(1,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(5.0, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--addons/arccw_weapons/lua/effects/arccw_apex_tracer_hmg_rampage/init.lua:
EFFECT.TracerName = "tfa_apex_tracer_hmg_rampage"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    --print(self.ParticleName)
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment() or 1
    self.Position = self:GetTracerShootPos(data:GetStart(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.EndPos = data:GetOrigin()
    -- util.ParticleTracerEx(self.ParticleName, self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_POINT, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(0,self.Position)
        pcf:SetControlPoint(1,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(5.0, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--addons/arccw_weapons/lua/effects/astw2_halo_3_explosion_spike/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 255
            light.g = 135
            light.b = 100
            light.Brightness = 3
            light.Decay = 10
            light.Size = 724
            light.DieTime = CurTime() + 0.3
        end
    local particle = emitter:Add("effects/halo3/8pt_ringed_star_flare", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.2 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(5,15) )
    particle:SetEndSize( math.Rand(125,150) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(0,0) )
    particle:SetColor( 255, 255, 255 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )
	

    for i= 0,2 do
   local particle = emitter:Add("effects/halo3/smoke_dark", self.Origin)

    particle:SetVelocity( Vector(math.Rand(-100, 100),math.Rand(-100, 100),math.Rand(250, 400)) )
    particle:SetDieTime( math.Rand(2,3) )
    particle:SetStartAlpha( 25 )
    particle:SetEndAlpha( 100 )
    particle:SetStartSize( math.Rand(45,50) )
    particle:SetEndSize( math.Rand(85,90) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(-0.5,0.5) )
    particle:SetColor( 155, 155, 155 )
    particle:SetAirResistance( 55 )
    particle:SetGravity( Vector( 0, 0, math.Rand(-325,-425) ) )
    particle:SetLighting( true )
    particle:SetCollide( false )
	end

		for i= 0,5 do
        particle = emitter:Add( "effects/halo3/explosion" .. math.random(2,4) , self.Origin )
        particle:SetVelocity( 7 * Vector(math.Rand(-25, 25),math.Rand(-25, 25),math.Rand(10, 25)) )
        particle:SetDieTime( math.Rand(0.5, 0.7) )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(30,50) )
        particle:SetEndSize( math.Rand(85,100) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,math.Rand( 200, 225 ),math.Rand( 175, 200 ) )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,25) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
	end

    for i = 0,5 do
        particle = emitter:Add( "effects/halo3/explosion1" , self.Origin )

        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.2, 0.3) )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(75,125) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,255,200 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
    end

    particle = emitter:Add( "effects/halo3/explosive_burst", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.25, 0.3) )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(175,300) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,155,50 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--addons/arccw_weapons/lua/effects/effect_astw2_halo2_tracer_beam_blue/init.lua:
EFFECT.InValid = false
EFFECT.ParticleName = "astw2_halo_2_sentinel_beam_blue_tracer"
--Thank you, GoodFishman for allowing me to steal this (Whilst stealing it from ArcCW yourself) <3

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	--print(self.ParticleName)
	if !IsValid(self.WeaponEnt) or !IsValid(self) then return end
	if not IsValid(self.WeaponEnt) then return end
	
	if (self.WeaponEnt.Akimbo) then
		self.Attachment = 1 + (game.SinglePlayer() and self.WeaponEnt:GetNW2Int("AnimCycle") or self.WeaponEnt.AnimCycle)
	else
		self.Attachment = data:GetAttachment()
	end
	
	self.Position = self:GetTracerShootPos(data:GetStart(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if not self.WeaponEnt.Owner:GetViewEntity() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				-- self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.EndPos = data:GetOrigin()
	--util.ParticleTracerEx(self.ParticleName, self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)
	local pcf = CreateParticleSystem(self.WeaponEnt, self.ParticleName, PATTACH_POINT, self.Attachment)
	if IsValid(pcf) then
		pcf:SetControlPoint(0,self.Position)
		pcf:SetControlPoint(1,self.EndPos)
		pcf:StartEmission()
	end
	timer.Simple(3.0, function()
		if IsValid(pcf) then
			pcf:StopEmissionAndDestroyImmediately()
		end
	end)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
	if self.InValid then return false end
end
--addons/arccw_weapons/lua/effects/effect_astw2_halo2_tracer_beamrifle/init.lua:

local Tracer = Material( "effects/halo2/plasma_contrail" )
local Tracer2  = Material( "effects/halo2/plasma_contrail" )
local Width = 15
local Width2 = 12

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.9
	self.LifeTime2 = 1.2
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 175, 255, v * 155 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( r, g, b, (v2 * 100)*3/2.5 ) )

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo2_tracer_plasmarifle/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 96;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo_spv3/flash/muzzle_flash/muzzle_flash_pr_side" );
local MaterialFront			= Material( "effects/halo_ce/flare_pr_overcharge" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 8, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_halo2_tracer_sniper/init.lua:

local Tracer = Material( "effects/halo3/trails/trail_sniper_ce" )
local Width = 8

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 2
	self.DieTime = CurTime() + self.LifeTime

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*1/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 225, 255, 255, v * 100 ) )
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_halo3_impact_plasmapistol/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/halo3/8pt_ringed_star_flare" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/flash_large", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.15 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 30 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(100, 255, 100);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
	for i = 1, 1 do

			local particle = emitter:Add( "effects/halo_reach/plasma_bolt_green", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.1, 0.15 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 20 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 255, 255);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
			for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/electric_arcs", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.1 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 20 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(125, 255, 100);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
	end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( rgb, 255, rgb, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo3_tracer_plasmarifle/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 48;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo_reach/trail_blue" );
local MaterialFront			= Material( "effects/halo_reach/plasma_bolt" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - 2* self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 10, 10, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 15, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_swbf_laser_blue/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 128;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/swbf/bluelaser_bolt" );
local MaterialFront			= Material( "effects/swbf/bluelaser" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 10, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_swbf_laser_green/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 128;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/swbf/greenlaser_bolt" );
local MaterialFront			= Material( "effects/swbf/greenlaser" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 10, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_swbf_laser_orange_sniper/init.lua:

local Tracer = Material( "effects/laser1" )
local Tracer2  = Material( "effects/swbf/yellow_beam" )
local Width = 15
local Width2 = 10

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.25
	self.LifeTime2 = 0.45
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 200, 155, v * 100 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 180, 155, (v2 * 100)*3/2.5 ) )

end

--lua/effects/laser_blue_short.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.EndPos = pos
	self.Dir = dir

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	-- if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = self.EndPos
	local dir = self.Dir

	local len = 300

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 2, endpos + dir * len * 2, 200, 1, 0, Color( 0, 0, 255, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 0, 0, 255, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end
--addons/lvs_addons/lua/effects/lvs_laser_green_short.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 300 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 2, endpos + dir * len * 2, 100, 1, 0, Color( 0, 255, 0, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 60, 1, 0, Color( 0, 255, 0, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--addons/lvs_addons/lua/effects/lvs_laser_red_short.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 300 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 2, endpos + dir * len * 2, 200, 1, 0, Color( 255, 0, 0, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 255, 0, 0, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--addons/lvs_base/lua/effects/lvs_physics_dust.lua:
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

local MatDebris = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Ent = data:GetEntity()

	if not IsValid( Ent ) then return end

	local Dir = Ent:GetForward()

	local emitter = Ent:GetParticleEmitter( Ent:GetPos() )

	local VecCol = render.GetLightColor( Pos + Vector(0,0,10) ) * 0.5 + Vector(0.3,0.25,0.15)

	if emitter and emitter.Add then
		for i = 1, 3 do
			local particle = emitter:Add( MatDebris[math.random(1,#MatDebris)], Pos + VectorRand(-10,10) )
			if particle then
				particle:SetVelocity( Vector(0,0,150) - Dir * 150 )
				particle:SetDieTime( 0.2 )
				particle:SetAirResistance( 60 ) 
				particle:SetStartAlpha( 255 )
				particle:SetEndAlpha( 255 )
				particle:SetStartSize( 15 )
				particle:SetEndSize( 50 )
				particle:SetRoll( math.Rand(-1,1) * 100 )
				particle:SetColor( VecCol.x * 130,VecCol.y * 100,VecCol.z * 60 )
				particle:SetGravity( Vector( 0, 0, -600 ) )
				particle:SetCollide( false )
			end
		end

		local Right = Ent:GetRight() 
		Right.z = 0
		Right:Normalize()

		for i = -1,1,2 do
			local particle = emitter:Add( Materials[math.random(1,#Materials)], Pos + Vector(0,0,10)  )
			if particle then
				particle:SetVelocity( -Dir * 400 + Right * 150 * i )
				particle:SetDieTime( math.Rand(0.5,1) )
				particle:SetAirResistance( 150 ) 
				particle:SetStartAlpha( 50 )
				particle:SetStartSize( -80 )
				particle:SetEndSize( 400 )
				particle:SetColor( VecCol.x * 255,VecCol.y * 255,VecCol.z * 255 )
				particle:SetGravity( Vector( 0, 0, 100 ) )
				particle:SetCollide( false )
			end
		end
	end
end


function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--addons/lvs_addons/lua/effects/lvs_tracer_proton.lua:

EFFECT.GlowColor = Color( 0, 127, 255, 255 )
EFFECT.GlowMat = Material( "sprites/light_glow02_add" )

EFFECT.MatSprite = Material( "effects/select_ring" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )

	self.emitter = ParticleEmitter( pos, false )

	self.OldPos = pos
	self.Dir = dir
end

function EFFECT:doFX( pos, curpos )
	if not IsValid( self.emitter ) then return end

	local particle = self.emitter:Add( "particles/flamelet"..math.random(1,5), pos )
	if particle then
		particle:SetVelocity( -self.Dir * math.Rand(250,800) + self.Dir * 5000 )
		particle:SetDieTime( math.Rand(0.2,0.4) )
		particle:SetAirResistance( 0 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 8 )
		particle:SetEndSize( 1 )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 0,0,255 )
		particle:SetGravity( Vector( 0, 0, 600 ) )
		particle:SetCollide( false )
	end

	local particle = self.emitter:Add( "particles/flamelet"..math.random(1,5), curpos )
	if particle then
		particle:SetVelocity( self.Dir * 5000 + VectorRand() * 50 )
		particle:SetDieTime( 1 )
		particle:SetAirResistance( 600 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 6 )
		particle:SetEndSize( 2 )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 0,0,255 )
		particle:SetGravity( Vector( 0, 0, 600 ) )
		particle:SetCollide( false )
	end
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then
		if self.emitter then
			self.emitter:Finish()
		end

		return false
	end

	if not self.emitter then return true end

	local T = CurTime()

	if (self.nextDFX or 0) <= T then
		self.nextDFX = T + 0.02
		
		local bullet = LVS:GetBullet( self.ID )

		local Pos = bullet:GetPos()

		local Sub = self.OldPos - Pos
		local Dist = Sub:Length()
		local Dir = Sub:GetNormalized()

		for i = 0, Dist, 45 do
			local cur_pos = self.OldPos + Dir * i

			self:doFX( cur_pos, Pos )
		end

		self.OldPos = Pos
	end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local pos = bullet:GetPos()

	render.SetMaterial( self.MatSprite )
	render.DrawSprite( pos, 100, 100, Color( 0, 127, 255, 50 ) )

	render.SetMaterial( self.GlowMat )

	for i = 0, 30 do
		local Size = ((30 - i) / 30) ^ 2 * 128

		render.DrawSprite( pos - self.Dir * i * 7, Size, Size, self.GlowColor )
	end
end

--addons/arccw_weapons/lua/effects/tfa_tracer_blue/init.lua:
-- Credits: Meeks, Xan, Matsil
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(0, 0, 255)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(0, 50, 255)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 0
        dlight.g = 102
        dlight.b = 255
        dlight.brightness = 3
        dlight.Decay = 1000
        dlight.Size = 200
        dlight.DieTime = CurTime() + 3
    end
end
end
--addons/arccw_weapons/lua/effects/tfa_tracer_orange/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(255, 140, 0)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(255, 120, 0)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 255
        dlight.g = 165
        dlight.b = 0
        dlight.brightness = 3
        dlight.Decay = 1000
        dlight.Size = 300
        dlight.DieTime = CurTime() + 3
    end
end
end
--addons/arccw_weapons/lua/effects/tfa_tracer_yellow/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(218, 165, 18)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(218, 165, 18)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 218
        dlight.g = 165
        dlight.b = 18
        dlight.brightness = 3
        dlight.Decay = 1000
        dlight.Size = 300
        dlight.DieTime = CurTime() + 3
    end
end
end
--addons/gm_prone/lua/prone/class_prone_statedata.lua:
-- The prone.PlayerStateData class simply stores some data about the given player's current prone state.
prone.PlayerStateDatas = prone.PlayerStateDatas or {}	-- Stores state data objects for players.

-- The class itself.
prone.PlayerStateData = {
	Player = 0,
	PlayerSteamID = "",
	OriginalViewOffset = Vector(0, 0, 64),
	OriginalViewOffsetDucked = Vector(0, 0, 28),
	StartTime = 0,
	GetDownTime = 0,
	EndTime = 0,
	GetUpTime = 0,
	EnterProneAnimLength = 0,
	EndProneAnimLength = 0
}

-- Generate simple getters and setters:
local preSettersGettersAdded = table.Copy(prone.PlayerStateData)
for k, v in pairs(preSettersGettersAdded) do
	prone.PlayerStateData["Get"..k] = function(self)
		return self[k]
	end
	prone.PlayerStateData["Set"..k] = function(self, newVal)
		self[k] = newVal
	end
end

function prone.PlayerStateData:__tostring()
	return "Prone state data for player '".. (IsValid(self.Player) and self.Player:Nick() or "INVALID PLAYER'")
end

------------------------------------------------
-- prone.PlayerStateData:UpdateDataOnProneEnter
------------------------------------------------
-- Desc:		Updates prone state data of a given player when they go to enter prone.
function prone.PlayerStateData:UpdateDataOnProneEnter()
	self.PlayerSteamID = self.Player:SteamID()
	self.OriginalViewOffset = self.Player:GetViewOffset()
	self.OriginalViewOffsetDucked = self.Player:GetViewOffsetDucked()
	self.StartTime = CurTime()

	local seq = prone.Animations.gettingdown

	self.EnterProneAnimLength = self.Player:SequenceDuration(self.Player:LookupSequence(seq))
	self.GetDownTime = self.EnterProneAnimLength + self.StartTime
end


------------------------------------------
-- prone.PlayerStateData:UpdateOnProneEnd
------------------------------------------
-- Desc:		Updates prone state data of a given player when they go to end prone.
-- Arg One:		Player.
function prone.PlayerStateData:UpdateOnProneEnd(ply)
	self.EndTime = CurTime()

	local seq = prone.Animations.gettingup

	self.EndProneAnimLength = self.Player:SequenceDuration(self.Player:LookupSequence(seq))
	self.GetUpTime = self.EndProneAnimLength + self.EndTime
end

-----------------------------
-- prone.PlayerStateData:New
-----------------------------
-- Desc:		Creates and returns a new prone.PlayerStateData object.
-- Arg One:		Player entity, whose state data this is.
-- Returns:		prone.PlayerStateData object.
function prone.PlayerStateData:New(ply)
	data = {Player = ply}
	setmetatable(data, self)
	self.__index = self
	return data
end
--addons/gm_prone/lua/prone/sh_prone.lua:
local PLAYER = FindMetaTable("Player")

---------------------------------
-- PLAYER.GetProneAnimationState
---------------------------------
-- Desc:		Gets the prone animation state of the given player.
-- Returns:		PRONE enum.
function PLAYER:GetProneAnimationState()
	return self:GetNetVar("prone.AnimationState", PRONE_NOTINPRONE)
	--return self:GetNW2Int("prone.AnimationState", PRONE_NOTINPRONE)
end

---------------------------------
-- PLAYER.SetProneAnimationState
---------------------------------
-- Desc:		Sets the prone animation state of the given player.
-- Arg One:		PRONE enum.
function PLAYER:SetProneAnimationState(state)
	--return self:SetNW2Int("prone.AnimationState", state)
	return self:SetNetVar("prone.AnimationState", state)
end

----------------------------------
-- PLAYER.GetProneAnimationLength
----------------------------------
-- Desc:		Returns the time when the current prone animation will end.
-- 				This value is: CurTime at start of anim + length of anim
-- Returns:		Number
function PLAYER:GetProneAnimationLength()
	return self:GetNetVar("prone.AnimationLength", 0)
	--return self:GetNW2Float("prone.AnimationLength", 0)
end

----------------------------------
-- PLAYER.SetProneAnimationLength
----------------------------------
-- Desc:		Sets at what time, relative to CurTime, the given prone animation will end.
-- Arg One:		Number, time.
function PLAYER:SetProneAnimationLength(length)
	self:SetNetVar("prone.AnimationLength", length)
	--self:SetNW2Float("prone.AnimationLength", length)
end

------------------
-- PLAYER.IsProne
------------------
-- Desc:		Is the player in prone.
-- Returns:		Boolean.
function PLAYER:IsProne()
	return self:GetProneAnimationState() ~= PRONE_NOTINPRONE
end

---------------------------
-- PLAYER.ProneIsGettingUp
---------------------------
-- Desc:		Is the player getting up out of prone.
-- Returns:		Boolean.
function PLAYER:ProneIsGettingUp()
	return self:GetProneAnimationState() == PRONE_GETTINGUP
end

-----------------------------
-- PLAYER.ProneIsGettingDown
-----------------------------
-- Desc:		Is the player getting down into prone.
-- Returns:		Boolean.
function PLAYER:ProneIsGettingDown()
	return self:GetProneAnimationState() == PRONE_GETTINGDOWN
end

------------------------
-- prone.HasRoomToGetUp
------------------------
-- Desc:		Does the player have enough room to get up, out of prone.
-- Arg One:		Player.
-- Returns:		Boolean.
function prone.HasRoomToGetUp(ply)
	if not ply:IsProne() then
		return true
	end

	local tr = util.TraceEntity({
		start = ply:GetPos(),
		endpos = ply:GetPos() + Vector(0, 0, 65 - prone.Config.HullHeight),
		filter = ply
	}, ply)
	
	if tr.Hit then
		if CLIENT and IsFirstTimePredicted() then
			prone.CantGetUpWarning()
		end
		return false
	else
		return true
	end
end

------------------
-- prone.CanEnter
------------------
-- Desc:		Can the given player enter prone.
-- Arg One:		Player
-- Returns:		Boolean
function prone.CanEnter(ply)
	-- prone.CanEnter hook takes precedence.
	local hookresult = hook.Run("prone.CanEnter", ply)
	if hookresult ~= nil then
		return hookresult

	-- Then check the player's state.
	elseif not ply:IsPlayer() or not ply:Alive() or ply:GetMoveType() == MOVETYPE_NOCLIP or not ply:OnGround() or ply:WaterLevel() > 1 then
		return false
	end

	return true
end

-----------------
-- prone.CanExit
-----------------
-- Desc:		Can the given player exit prone.
-- Arg One:		Player
-- Returns:		Boolean
function prone.CanExit(ply)
	if not (ply:IsPlayer() and ply:Alive()) then
		return false
	end

	local hookresult = hook.Run("prone.CanExit", ply)
	if hookresult ~= nil then
		return hookresult
	elseif not prone.HasRoomToGetUp(ply) then
		return false
	end

	return true
end

---------------
-- prone.Enter
---------------
-- Desc:		Begins the animation putting the given player into prone.
-- Arg One:		Player.
function prone.Enter(ply)
	local plyProneStateData = prone.PlayerStateData:New(ply)
	prone.PlayerStateDatas[ply:SteamID()] = plyProneStateData
	plyProneStateData:UpdateDataOnProneEnter()

	ply:SetHull(Vector(-16, -16, 0), Vector(16, 16, prone.Config.HullHeight))
	ply:SetHullDuck(Vector(-16, -16, 0), Vector(16, 16, prone.Config.HullHeight))

	local getDownTime = plyProneStateData:GetGetDownTime()
	ply:SetProneAnimationLength(getDownTime)

	-- Make sure they can't shoot while prone.
	local weapon = ply:GetActiveWeapon()
	if IsValid(weapon) then
		weapon:SetNextPrimaryFire(getDownTime)
		weapon:SetNextSecondaryFire(getDownTime)
	end

	ply:SetProneAnimationState(PRONE_GETTINGDOWN)
	ply:DoCustomAnimEvent(PLAYERANIMEVENT_CUSTOM, PRONE_CUSTOM_ANIM_EVENT_NUM)
	hook.Run("prone.OnPlayerEntered", ply, plyProneStateData:GetEnterProneAnimLength())
end

-------------
-- prone.End
-------------
-- Desc:		Begins the animation taking the given player out of prone.
-- Arg One:		Player.
function prone.End(ply)
	local plyProneStateData = prone.PlayerStateDatas[ply:SteamID()]
	if not plyProneStateData then
		plyProneStateData = prone.PlayerStateData:New(ply)
	end
	plyProneStateData:UpdateOnProneEnd()

	local getUpTime = plyProneStateData:GetGetUpTime()
	ply:SetProneAnimationLength(getUpTime)

	-- Make sure they can't shoot while getting up.
	local weapon = ply:GetActiveWeapon()
	if IsValid(weapon) then
		weapon:SetNextPrimaryFire(getUpTime)
		weapon:SetNextSecondaryFire(getUpTime)
	end

	-- Play the animation.
	ply:DoCustomAnimEvent(PLAYERANIMEVENT_CUSTOM, PRONE_CUSTOM_ANIM_EVENT_NUM)
	ply:SetProneAnimationState(PRONE_GETTINGUP)
end

--------------
-- prone.Exit
--------------
-- Desc:		Forces the player immediately out of prone with no animation.
-- Arg One:		Player.
function prone.Exit(ply)
	local plyProneStateData = prone.PlayerStateDatas[ply:SteamID()]

	if plyProneStateData then
		ply:SetViewOffset(plyProneStateData:GetOriginalViewOffset())
		ply:SetViewOffsetDucked(plyProneStateData:GetOriginalViewOffsetDucked())
	else
		-- Best guess in-case we somehow lose state data.
		ply:SetViewOffset(Vector(0, 0, 64))
		ply:SetViewOffsetDucked(Vector(0, 0, 28))
	end
	ply:ResetHull()

	prone.PlayerStateDatas[ply:SteamID()] = nil

	ply:SetProneAnimationState(PRONE_NOTINPRONE)
	hook.Run("prone.OnPlayerExitted", ply)
end

----------------
-- prone.Handle
----------------
-- Desc:		Toggles between the player entering and ending prone.
function prone.Handle(ply)
	if not IsValid(ply) then
		return
	end

	if ply:IsProne() then
		if prone.CanExit(ply) then
			prone.End(ply)
		end
	else
		if prone.CanEnter(ply) then
			prone.Enter(ply)
		end
	end
end

local proneMoveSpeed = CreateConVar("prone_movespeed", tostring(prone.Config.MoveSpeed), {FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Sets the move speed while prone.")


-- Disable jumping in prone, set prone movement speed, handle weapon fire.
hook.Add("SetupMove", "prone.Handle", function(ply, cmd, cuc)
	if ply:IsProne() then
		-- Disables jumping, thanks meep.
		if cmd:KeyDown(IN_JUMP) then
			cmd:SetButtons(bit.band(cmd:GetButtons(), bit.bnot(IN_JUMP)))
		end
		-- Disabled crouching.
		if cmd:KeyDown(IN_DUCK) then
			cmd:SetButtons(bit.band(cmd:GetButtons(), bit.bnot(IN_DUCK)))
		end

		-- If they are getting up or down then set their speed to TransitionSpeed
		if ply:GetProneAnimationLength() >= CurTime() then
			cmd:SetMaxClientSpeed(prone.Config.TransitionSpeed)
			cmd:SetMaxSpeed(prone.Config.TransitionSpeed)

			-- SetMaxClientSpeed doesn't work if you are setting it to 0 so also do this.
			if prone.Config.TransitionSpeed <= 0 and ply:IsOnGround() then
				cmd:SetForwardSpeed(0)
				cmd:SetSideSpeed(0)
				cmd:SetVelocity(Vector(0, 0, 0))
			end
			return
		else	-- If they are in prone set their speed to MoveSpeed
			local moveSpeed = proneMoveSpeed:GetInt()
			if not isnumber(moveSpeed) then
				moveSpeed = prone.Config.MoveSpeed
			end

			cmd:SetMaxClientSpeed(moveSpeed)
			cmd:SetMaxSpeed(moveSpeed)
		end

		-- Make sure they can't shoot while prone and moving if that setting is enabled.
		local attack1 = cmd:KeyDown(IN_ATTACK)
		if attack1 or cmd:KeyDown(IN_ATTACK2) and prone.Config.MoveShoot_Restrict then
			local weapon = ply:GetActiveWeapon()
			if not IsValid(weapon) then
				return
			end

			local weaponclass = weapon:GetClass()
			if not prone.Config.MoveShoot_Whitelist[weaponclass] then
				local shouldStopMovement = true
				if attack1 then
					shouldStopMovement = weapon:Clip1() > 0
				else
					shouldStopMovement = weapon:Clip2() > 0
				end

				if (shouldStopMovement or weaponclass == "weapon_crowbar") and ply:IsOnGround() then
					cmd:SetForwardSpeed(0)
					cmd:SetSideSpeed(0)
					cmd:SetVelocity(Vector(0, 0, 0))
				end
			end
		end

		if SERVER then
			if (
				(ply:WaterLevel() > 1 and not ply:ProneIsGettingUp())
				or ply:GetMoveType() == MOVETYPE_NOCLIP
				or ply:GetMoveType() == MOVETYPE_LADDER
			) then
				prone.Exit(ply)
			end
		end
	end

	if cuc:GetImpulse() == PRONE_IMPULSE and (ply:GetProneAnimationLength() < CurTime() + 0.5) then
		prone.Handle(ply)
	end


end)

-- Handles pose parameters and playback rates of animations.
hook.Add("UpdateAnimation", "prone.Animations", function(ply, velocity, maxSeqGroundSpeed)
	if ply:IsProne() then
		local length = velocity:Length()

		local rate = 1
		local plyAnimState = ply:GetProneAnimationState()
		if plyAnimState ~= PRONE_GETTINGDOWN and plyAnimState ~= PRONE_GETTINGUP then
			if not ply:IsOnGround() and length >= 750 then
				rate = 0.1
			else
				if length > 0.2 then
					rate = math.min(length / maxSeqGroundSpeed, 2)
				else
					rate = 1
				end
			end
		end

		if CLIENT then
			local EyeAngP = ply:EyeAngles().p
			if EyeAngP < 89 then
				ply:SetPoseParameter("body_pitch", math.Clamp(-EyeAngP, -10, 50))
				ply:SetPoseParameter("body_yaw", 0)
				ply:InvalidateBoneCache()
			end
		end

		-- Interesting code I saw in NutScript, doesn't seem to do anything in my case though.
		--local eyeAngles = ply:EyeAngles()
		--local yaw = velocity:Angle()[2]
		--local normalized = math.NormalizeAngle(yaw - eyeAngles[2])
		--ply:SetPoseParameter("move_yaw", normalized)

		ply:SetPlaybackRate(rate)
	end
end)

-- The animation handler of the addon.
local function GetSequenceForWeapon(holdtype, ismoving)
	return ismoving and prone.Animations.WeaponAnims.moving[holdtype] or prone.Animations.WeaponAnims.idle[holdtype]
end
local GetMainActivityAnimation = {
	[PRONE_GETTINGDOWN] = function(ply)
		if ply:GetProneAnimationLength() <= CurTime() then
			ply:SetViewOffset(prone.Config.View)
			ply:SetViewOffsetDucked(prone.Config.View)
			ply:SetProneAnimationState(PRONE_INPRONE)
		end
		
		return prone.Animations.gettingdown
	end,

	[PRONE_GETTINGUP] = function(ply)
		if ply:GetProneAnimationLength() <= CurTime() then
			local plyProneStateData = prone.PlayerStateDatas[ply:SteamID()]
			if plyProneStateData then
				ply:SetViewOffset(plyProneStateData:GetOriginalViewOffset())
				ply:SetViewOffsetDucked(plyProneStateData:GetOriginalViewOffsetDucked())
			else
				-- Best guess in-case we somehow lose state data.
				ply:SetViewOffset(Vector(0, 0, 64))
				ply:SetViewOffsetDucked(Vector(0, 0, 28))
			end

			prone.Exit(ply)

			-- If they get stuck in anything while exitting put them back in prone.
			local scanPos = ply:GetPos()
			local tr = util.TraceEntity({
				start = scanPos,
				endpos = scanPos,
				filter = ply
			}, ply)

			if tr.Hit then
				if CLIENT and ply == LocalPlayer() then
					prone.CantGetUpWarning()
				end
				prone.Enter(ply)
			end
		end

		return prone.Animations.gettingup
	end,

	[PRONE_INPRONE] = function(ply, velocity)
		local weapon = ply:GetActiveWeapon()
		local WeaponHoldType

		if IsValid(weapon) then
			WeaponHoldType = weapon:GetHoldType()
			if WeaponHoldType == "" then
				WeaponHoldType = weapon.HoldType
			end
		end

		return GetSequenceForWeapon(WeaponHoldType or "normal", velocity:LengthSqr() >= 225)
	end,

	-- Just in case this gets called for some reason.
	[PRONE_NOTINPRONE] = function()
		return prone.Animations.passive
	end
}
hook.Add("CalcMainActivity", "prone.Animations", function(ply, velocity)
	if IsValid(ply) and ply:IsProne() then
		local seq = GetMainActivityAnimation[ply:GetProneAnimationState()](ply, velocity)

		-- NEVER let this hook's second return parameter be a number less than 0.
		-- That crashes Linux servers for some reason.
		local seqid = ply:LookupSequence(seq or "")
		if seqid < 0 then
			return
		end

		return -1, seqid or nil
	end
end)

-- Fixes a bug where other players (not the one proning) might see the proning player's get up/down
-- animations starting at a random point in the animation.
hook.Add("DoAnimationEvent", "prone.ResetAnimation", function(ply, event, data)
	if event == PLAYERANIMEVENT_CUSTOM then
		if data == PRONE_CUSTOM_ANIM_EVENT_NUM then
			ply:AnimRestartMainSequence()
		end
	end
end)

------------------------------------------------------------
-- Check if the player should still be prone at these events
------------------------------------------------------------
hook.Add("PlayerNoClip", "prone.ExitOnNoclip", function(ply)
	if ply:IsProne() then
		prone.Exit(ply)
	end
end)
hook.Add("VehicleMove", "prone.ExitOnVehicleEnter", function(ply)
	if ply:IsProne() then
		prone.Exit(ply)
	end
end)
if timer.Exists("prone.Manage") then timer.Remove("prone.Manage") end
--[[ timer.Create("prone.Manage", 0.5, 0, function()
	for i, v in ipairs(player.GetAll()) do
		if v:IsProne() and (
			(v:WaterLevel() > 1 and not v:ProneIsGettingUp())
			or v:GetMoveType() == MOVETYPE_NOCLIP
			or v:GetMoveType() == MOVETYPE_LADDER
		) then
			prone.Exit(v)
		end
	end
end) ]]

----------------
-- API Functions
----------------
-- Notice: Any API functions should be called in or after the prone.Initialized hook has been called.
function prone.AddNewHoldTypeAnimation(holdtype, movingSequenceName, idleSequenceName)
	prone.Animations.WeaponAnims.moving[holdtype] = movingSequenceName
	prone.Animations.WeaponAnims.idle[holdtype] = idleSequenceName
end

function prone.GetIdleAnimation(holdtype)
	return prone.Animations.WeaponAnims.idle[holdtype]
end
function prone.GetMovingAnimation(holdtype)
	return prone.Animations.WeaponAnims.moving[holdtype]
end
--addons/reconnect_crash_screen/lua/crashmenu/vgui/reconnectpanel.lua:
local PANEL = {}

PANEL.CrashTime = 0
PANEL.ShowPanel = 0
PANEL.ShowInfoAnim = 0
PANEL.ShowPanelAnim = 0

local blur = Material("pp/blurscreen")
local function BlurScreen()
    local amount = 6
    local x, y = 0, 0
    local scrW, scrH = ScrW(), ScrH()

    surface.SetDrawColor(0, 0, 0, 192)
    surface.DrawRect(0, 0, scrW, scrH)

    surface.SetDrawColor(255, 255, 255, 127)
    surface.SetMaterial(blur)

    for i = 1, 5 do
        blur:SetFloat("$blur", (i / 3) * amount)
        blur:Recompute()
        render.UpdateScreenEffectTexture()
        surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
    end
end

local gradientU, gradientD = Material("vgui/gradient-u"), Material("vgui/gradient-d")
function PANEL:Init()
    self:SetSize(ScrW(), ScrH())
    self:Center()

    self:SetPaintedManually(true)
    self:SetVisible(false)
    self:MakePopup()
    self:SetKeyboardInputEnabled(true)
    self:SetMouseInputEnabled(true)



    local logo = vgui.Create("DHTML", self)
    logo:SetSize(self:GetWide() * 0.5, 192)
    logo:SetPos(self:GetWide() * 0.5 - logo:GetWide() * 0.5, self:GetTall() * 0.065)
    logo:SetMouseInputEnabled(false)
    function logo:ConsoleMessage(msg) end
    logo:SetHTML([[
    <!DOCTYPE html>
    <html>
        <head>
            <style>
            body, html {
                padding: 0;
                margin: 0;
                overflow: hidden;
            }
            img {
                position: absolute;
                -webkit-transform: translate(-50%, -50%);
                top: 50%;
                left: 50%;
                max-width: 100%;
                max-height: 100%;
                display: block;
            }
            </style>
        </head>
        <body>
            <img id="img"></img>
            <script>
                var url = "]] .. string.JavascriptSafe(crashmenu.Config.LogoURL) .. [[";
                document.getElementById("img").src = url;
            </script>
        </body>
    </html>
    ]])
    
    local chatboxContainer = self:Add("Panel")
    self.ChatboxContainer = chatboxContainer
    chatboxContainer:SetWide(self:GetWide() * 0.5)
    chatboxContainer:SetTall(self:GetTall() * 0.33)
    chatboxContainer:SetPos(self:GetWide() * 0.5 * 0.66, self:GetTall() * 0.5)

    local reconnect = self:Add("DButton")
    reconnect:SetFont("crashmenu_2")
    reconnect:SetTextColor(color_white)
    reconnect:SetWide(self:GetWide() * 0.5 * 0.33)
    reconnect:SetTall(48)
    reconnect:MoveAbove(chatboxContainer, -reconnect:GetTall())
    reconnect:MoveLeftOf(chatboxContainer, 8)
    local buttonPaint = function(btn, w, h)
        surface.SetDrawColor(btn.Color or color_white)
        surface.DrawRect(0, 0, w, h)

        surface.SetMaterial(gradientU)
        surface.SetDrawColor(255, 255, 255, 10)
        surface.DrawTexturedRect(0, 0, w, h)

        surface.SetDrawColor(0, 0, 0, 31.875)
        surface.DrawOutlinedRect(1, 1, w - 2, h - 2)

        surface.SetDrawColor(255, 255, 255, 31.875)
        surface.DrawOutlinedRect(2, 2, w - 4, h - 4)
        surface.DrawOutlinedRect(3, 3, w - 6, h - 6)

        if btn:IsHovered() and btn.Depressed then
            surface.SetDrawColor(0, 0, 0, 24)
            surface.DrawRect(0, 0, w, h)
        elseif btn:IsHovered() then
            surface.SetDrawColor(255, 255, 255, 4)
            surface.DrawRect(0, 0, w, h)
        end
    end
    reconnect.Paint = buttonPaint
    self.AutoDisabled = false
    function reconnect.Think()
        local dots = ("."):rep(math.floor(RealTime()) % 4)

        if reconnect:IsHovered() and not self.AutoDisabled then
            reconnect:SetText("Auto-Reconnect deaktivieren")
        elseif not self.AutoDisabled then
            reconnect:SetText("Autoreconnect kommt" .. dots)
        else
            reconnect:SetText("Reconnecten")
        end

        if self.Reconnecting then
            reconnect:SetText("Reconnecting" .. dots)
        end

        if self.AutoDisabled then
            reconnect.Color = Color(64, 127, 64, 255)
        else
            reconnect.Color = Color(127, 127, 64, 255)
        end

        if not self.AutoDisabled and self.NextTry and self.NextTry <= RealTime() and self.Reconnecting then
            RunConsoleCommand("retry")
        end
    end
    function reconnect.DoClick()
        if not self.AutoDisabled then
            self.AutoDisabled = true
        else
            RunConsoleCommand("retry")
        end
    end

    local prev
    for i, data in pairs(crashmenu.Config.Servers or {}) do
        local server = self:Add("DButton")
        server:SetFont("crashmenu_2")
        server:SetTextColor(color_white)
        server:SetText(data.Name)
        server:SetWide(self:GetWide() * 0.5 * 0.33)
        server:SetTall(48)
        server:MoveBelow(prev or reconnect, 8)
        server:MoveLeftOf(chatboxContainer, 8)
        server.Color = Color(96, 64, 127, 255)
        server.Paint = buttonPaint
        function server:DoClick()
            if data.IP then
                LocalPlayer():ConCommand("connect " .. data.IP)
            elseif data.URL then
                gui.OpenURL(data.URL)
            end
        end
        prev = server
    end

    local soundmute = self:Add("DButton")
    soundmute:SetFont("crashmenu_2")
    soundmute:SetTextColor(color_white)
    soundmute:SetText("Musik stoppen")
    soundmute:SetWide(self:GetWide() * 0.5 * 0.33)
    soundmute:SetTall(48)
    soundmute:MoveBelow(prev or reconnect, 8)
    soundmute:MoveLeftOf(chatboxContainer, 8)
    soundmute.Color = Color(127, 118, 64)
    soundmute.Paint = buttonPaint
    function soundmute:DoClick()
        RunConsoleCommand("stopsound")
    end

    local disconnect = self:Add("DButton")
    disconnect:SetFont("crashmenu_2")
    disconnect:SetTextColor(color_white)
    disconnect:SetText("Server verlassen")
    disconnect:SetWide(self:GetWide() * 0.5 * 0.33)
    disconnect:SetTall(48)
    disconnect:MoveBelow(prev or reconnect, 8)
    disconnect:MoveLeftOf(chatboxContainer, 8)
    disconnect.Color = Color(127, 64, 64, 255)
    disconnect.Paint = buttonPaint
    function disconnect:DoClick()
        RunConsoleCommand("disconnect")
    end

    hook.Add("PostRenderVGUI", self, function()
        self.ShowPanelAnim = Lerp(FrameTime() * 1.75, self.ShowPanelAnim, self.ShowPanel)
        if self.ShowPanel == 0 and self.ShowPanelAnim < 0.01 then
            self:SetVisible(false)
            return
        end

        if (RealTime() - self.CrashTime) >= 2.25 then
            self.ShowInfoAnim = Lerp(FrameTime() * 1.25, self.ShowInfoAnim, 1)
        end

        if self.ShowPanel == 1 then
            if gui.IsGameUIVisible() then
                self:SetKeyboardInputEnabled(false)
                self:SetMouseInputEnabled(false)
                return
            else
                self:SetKeyboardInputEnabled(true)
                self:SetMouseInputEnabled(true)
            end
        end

        surface.SetAlphaMultiplier(self.ShowPanelAnim)

        BlurScreen()

        surface.SetAlphaMultiplier(1)

        local progress = ScrW() * (0.5 * self.ShowPanelAnim)
        local scissorX = ScrW() * 0.5 - progress
        render.SetScissorRect(scissorX, 0, scissorX + progress * 2, ScrH(), true)
            self:PaintManual()
            if IsValid(self.ServerMenu) then self.ServerMenu:PaintManual() end
        render.SetScissorRect(0, 0, 0, 0, false)
    end)
    
    self:LoadChatboxCode()


end

-- You did this, Rubat. x86-64 only.
function PANEL:LoadChatboxCode()
    // TODO: Make this retry on failure?

    HTTP({
        method = "GET",
        url = ("%s/room/%s"):format(crashmenu.Host, crashmenu.Config.ChatRoomID),
        success = function(code, html)
            if (code >= 200 and code < 300) then
                self.ChatboxHTML = html
            else 
                print("Failed to load chatbox JS: error" .. code)
                print(html)
            end
        end,
        failed = function(err)
            print("Failed to load chatbox JS: " .. err)
        end
    })
    HTTP({
        method = "GET",
        url = ("%s/app.js"):format(crashmenu.Host),
        success = function(code, js)
            if (code >= 200 and code < 300) then
                self.ChatboxJS = js
            else 
                print("Failed to load chatbox JS: error" .. code)
                print(js)
            end
        end,
        failed = function(err)
            print("Failed to load chatbox JS: " .. err)
        end
    })
end

function PANEL:LoadChatbox()
    hook.Add("Think", self, function()
        if (not self.ChatboxHTML or not self.ChatboxJS) then return end
    
        if (self.Chatbox) then self.Chatbox:Remove() end

        local chatbox = self.ChatboxContainer:Add("DHTML")
        self.Chatbox = chatbox
        chatbox:Dock(FILL)
        chatbox:AddFunction("crashmenu", "chatTick", function() if self.ShowPanel == 1 then chat.PlaySound() end end)
        chatbox:AddFunction("crashmenu", "getData", function()    
            -- Maybe: add a separate value for this?
            local host = ("%s/room/%s"):format(crashmenu.Host:gsub("^[hH][tT][tT][pP]", "ws"), crashmenu.Config.ChatRoomID)
            local steamId = LocalPlayer():SteamID64()
            return host, steamId 
        end)
        chatbox:SetHTML(self.ChatboxHTML)
        chatbox:RunJavascript([[
            window._WebSocket = WebSocket;
        ]])
        
        -- hook.Add("Think", chatbox, function()
        --     if (not IsValid(chatbox)) then hook.Remove("Think", chatbox) end
        --     if (not chatbox:IsLoading()) then
        --         timer.Simple(0, function() 
        chatbox:AddFunction("crashmenu", "ready", function()                                                 
            chatbox:RunJavascript(self.ChatboxJS)
        end)
        chatbox:RunJavascript([[           
            // This is copium for if Awesomium was even going to work with WebSockets in the first place
            const fn = function(host, steamId) {
                window._host = host;
                window._steamId = steamId;
                
                crashmenu.ready();
            };
            const data = crashmenu.getData(fn);
            if (data) {
                const host = data.host
                const steamId = data.steamId;
                
                fn(host, steamId);
            };
        ]])
        --         end)
        --         hook.Remove("Think", chatbox)
        --     end
        -- end)
        
        hook.Remove("Think", self)
    end)
end

function PANEL:Show()
    if self.ShowPanel ~= 1 then
        --if crashmenu.Config.CrashSound then surface.PlaySound(crashmenu.Config.CrashSound) end
        AOCDerma:PlayURL("https://ageofclones.de/music/crash.mp3")
        self.CrashTime = RealTime()
        self.Reconnecting = false
        self.NextTry = RealTime() + 10
        self.ShowPanel = 1
        self:LoadChatbox()
    end

    self:SetVisible(true)
end

function PANEL:Hide()    
    self:SetKeyboardInputEnabled(false)
    self:SetMouseInputEnabled(false)
    if self.ShowPanel ~= 0 then
        surface.PlaySound("plats/hall_elev_door.wav")
        self.ShowPanel = 0
        self.ShowInfoAnim = 0
        self.ShowPanelAnim = 0
        self.AutoDisabled = false
    end
end

surface.CreateFont("crashmenu_1", {
    font = crashmenu.Config.BigFont or "Roboto Bk",
    size = ScreenScale(24),
})
surface.CreateFont("crashmenu_2", {
    font = crashmenu.Config.Font or "Roboto",
    size = ScreenScale(8),
})
function PANEL:Paint(w, h)
    local col1 = crashmenu.Config.Color1

    if crashmenu.Config.Gradient then
        surface.SetDrawColor(0, 0, 0, 192)
    else
        surface.SetDrawColor(col1)
    end
    surface.DrawRect(0, 0, w, h)

    if crashmenu.Config.Gradient then
        surface.SetDrawColor(col1)
        surface.SetMaterial(gradientD)
        surface.DrawTexturedRect(0, 0, w, h)
    end

    if crashmenu.Config.Gradient then
        surface.SetDrawColor(col1.r + 32, col1.g + 32, col1.b + 32, col1.a * 0.5)
    else
        surface.SetDrawColor(255, 255, 255, 31)
    end
    surface.DrawRect(math.floor(2 + w * 0.5 - w * (0.5 * self.ShowPanelAnim)), 0, 2, h)
    surface.DrawRect(math.ceil(w * 0.5 + w * (0.5 * self.ShowPanelAnim) - 4), 0, 2, h)

    surface.SetFont("crashmenu_1")

    local txt = crashmenu.Config.Title or "Uh oh, looks like the server gave up..?"
    local txtW, txtH = surface.GetTextSize(txt)
    local txtX, txtY = w * 0.5 - txtW * 0.5, h * 0.33 - (txtH * 0.66) * self.ShowInfoAnim
    local matrix = Matrix()
    matrix:Translate(Vector(self:GetPos()))
    matrix:Translate(Vector(txtX, txtY))
    matrix:Translate(Vector(txtW, txtH) * 0.5)
    matrix:Scale(Vector(1, 1) * self.ShowPanelAnim)
    matrix:Rotate(Angle(0, (math.sin(RealTime() * 0.5) * 27.5) * (1.125 - self.ShowPanelAnim), 0))
    matrix:Translate(-Vector(txtW, txtH) * 0.5)
    matrix:Translate(-Vector(self:GetPos()))
    render.PushFilterMag(TEXFILTER.ANISOTROPIC)
    render.PushFilterMin(TEXFILTER.ANISOTROPIC)
        cam.PushModelMatrix(matrix)
            if crashmenu.Config.FontShadows then
                surface.SetTextColor(0, 0, 0, 127)
                surface.SetTextPos(4, 4)
                surface.DrawText(txt)
            end

            surface.SetTextColor(255, 255, 255)
            surface.SetTextPos(0, 0)
            surface.DrawText(txt)
        cam.PopModelMatrix()
    render.PopFilterMag()
    render.PopFilterMin()

    surface.SetFont("crashmenu_2")

    local txt = crashmenu.Config.SubTitle
    surface.SetAlphaMultiplier(self.ShowInfoAnim)
    if crashmenu.Config.FontShadows then
        draw.DrawText(txt, "crashmenu_2", w * 0.5 + 2, h * 0.33 + (txtH * 0.66) * self.ShowInfoAnim + 2, Color(0, 0, 0, 127), TEXT_ALIGN_CENTER)
    end
    draw.DrawText(txt, "crashmenu_2", w * 0.5, h * 0.33 + (txtH * 0.66) * self.ShowInfoAnim, Color(192, 192, 192), TEXT_ALIGN_CENTER)
    surface.SetAlphaMultiplier(1)

    for _, child in pairs(self:GetChildren()) do
        child:SetAlpha(255 * self.ShowPanelAnim)
    end



end

vgui.Register("ReconnectPanel", PANEL, "EditablePanel")

if IsValid(crashmenu.Panel) then crashmenu.Panel:Remove() end
