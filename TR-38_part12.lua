--Stealed clientside server code by exechack.cc
--Hostname: [TR] Venom Roleplay | DarkRP #venom25 - discord.gg/eniyisi  - Part 12/12 - 06/04/2025


--PATH addons/advancedkillfeed/lua/includes/init.lua:

do
gluapack_gc = collectgarbage("count")
do
local DOWNLOADFILTER_IS_NONE = GetConVar("cl_downloadfilter"):GetString() == "none"

if (function()

local string_gsub = string.gsub
local debug_getinfo = debug.getinfo
local CompileString = CompileString
local __CompileFile = CompileFile

local vfs, vfsLCL = {}, {}
local autorefreshed = {"addons/ashop/lua/ashop/config/sh_config.lua"}

local flags = FCVAR_REPLICATED + FCVAR_DONTRECORD + FCVAR_PROTECTED + FCVAR_UNREGISTERED + FCVAR_UNLOGGED
local name = CreateConVar("gluapack_file", "", flags):GetString()
local md5 = CreateConVar("gluapack_md5", "", flags):GetString()
local key = CreateConVar("gluapack_key", "", flags):GetString()
local salt = util.Base64Decode(CreateConVar("gluapack_salt", "", flags):GetString())

print("\n" .. md5)
print("https://gluapack.com")
print("Made with <3 by Billy & friends\n")

local function helpLink()
	local function urlencode(str)
		str = string.gsub(str, "([^%w%-%_%.%~])", function(hex) return string.format("%%%02X", string.byte(hex)) end)
		return str
	end
	local sv_downloadurl = GetConVar("sv_downloadurl")
	if sv_downloadurl then
		sv_downloadurl = string.gsub(string.gsub(sv_downloadurl:GetString() or "", "^%s+", ""), "%s+$", "")
		return "https://gluapack.com/help/?u=" .. urlencode(sv_downloadurl:gsub("/$", "") .. "/data/gluapack/" .. name .. ".bsp.bz2")
	else
		return "https://gluapack.com/help/?u=EMPTY"
	end
end

local succ, halp = pcall(helpLink)
if not succ then
	halp = "https://gluapack.com/help/?u=LUAERROR"
end

local function failed(msg, disconnect, openhelp)
	if disconnect then
		function gluapack() return function() end end
		ErrorNoHalt(msg .. "\n" .. "You have been disconnected from the server because " .. disconnect .. "\n" .. halp .. "\n")
		if openhelp then gui.OpenURL(halp) end
	else
		function gluapack()
			ErrorNoHalt(msg .. "\n" .. halp .. "\n")
			if openhelp then gui.OpenURL(halp) end
			_G.gluapack = function() end
			return function() end
		end
	end
end

if #md5 == 0 or #name == 0 then
	failed("gluapack isn't active (the server didn't send us the ConVars) but a script still tried to invoke gluapack - bug?")
	print("gluapack ABORTED - looks like gluapack isn't active")
	return
end

-- https://github.com/philanc/plc/blob/master/plc/rc4.lua
local function rc4(key, plain)
	local function step(s, i, j)
		i = bit.band(i + 1, 0xff)
		local ii = i + 1
		j = bit.band(j + s[ii], 0xff)
		local jj = j + 1
		s[ii], s[jj] = s[jj], s[ii]
		local k = s[ bit.band(s[ii] + s[jj], 0xff) + 1 ]
		return s, i, j, k
	end
	local s do
		assert(#key == 16, "Key is not a 16-byte string")
		s = {}
		local j,ii,jj
		for i = 0, 255 do s[i+1] = i end
		j = 0
		for i = 0, 255 do
			ii = i+1
			j = bit.band(j + s[ii] + string.byte(key, (i % 16) + 1), 0xff)
			jj = j+1
			s[ii], s[jj] = s[jj], s[ii]
		end
	end
	local i, j = 0, 0
	local k
	local t = {}
	for n = 1, #plain do
		s, i, j, k = step(s, i, j)
		t[n] = string.char(bit.bxor(string.byte(plain, n), k))
	end
	return table.concat(t)
end

local keyBin do
	keyBin = {}
	assert(#key % 2 == 0)
	for i = 1, #key, 2 do
		keyBin[#keyBin + 1] = string.char(tonumber(key:sub(i, i + 1), 16))
	end
	keyBin = table.concat(keyBin)
end

do
	local now = SysTime()

	local path = ("download/data/gluapack/%s.bsp"):format(name)

	if not file.Exists(path, "GAME") then
		if DOWNLOADFILTER_IS_NONE then
			failed(
				"You have cl_downloadfilter set to none! It must be a minimum of mapsonly to join this server!",
				"the clientside Lua state cannot be initialized"
			)
		else
			failed(
				"gluapack fatal error - pack file not found (did it fail to download? check your network settings!)",
				"the clientside Lua state cannot be initialized",
				true
			)
		end
		return true
	end

	local contents do
		local f = file.Open(path, "rb", "GAME")
		contents = f:Read(f:Size())
		f:Close()

		contents = rc4(keyBin, contents, 0):sub(257)
		assert(contents ~= nil and #contents > 0, "Decryption failed")

		contents = util.Decompress(contents)
		assert(contents ~= nil and #contents > 0, "Decompression failed")

		local fileMD5 = util.MD5(contents)
		if fileMD5 ~= md5 then
			failed(
				("gluapack fatal error - pack MD5 does not match up (%s (yours) != %s (server's))\n"):format(fileMD5, md5),
				"for security reasons"
			)
			return true
		end

		contents = contents:sub(2) -- Skip the version byte
	end

	local function hex(bytes)
		local hex = {}
		for i = 1, #bytes do
			hex[i] = string.format("%02x", string.byte(bytes, i, i))
		end
		return table.concat(hex)
	end

	local count = 0
	local i = 1
	while i < #contents do
		local vfs1 = hex(contents:sub(i, i + 15))
		i = i + 16

		local lcl1 = hex(contents:sub(i, i + 15))
		i = i + 16

		local lcl2 = hex(contents:sub(i, i + 15))
		i = i + 16

		local len = tonumber(hex(contents:sub(i, i + 3)), 16)
		assert(len < #contents, "u32 decoding error")
		i = i + 4

		local contents = contents:sub(i, i + (len - 1))
		i = i + len

		vfs[vfs1] = contents
		vfsLCL[lcl1] = contents
		vfsLCL[lcl2] = contents

		count = count + 1
	end

	print(("gluapack: loaded %d files in %.3fs"):format(count, (SysTime() - now)))
end

local function saltedMD5(val)
	return util.MD5(salt .. val)
end

function gluapack()
	local info = debug_getinfo(2, "S")
	info = string_gsub(info.source, "^@", "")
	local md5 = saltedMD5(info)
	if vfs[md5] then
		return CompileString(vfs[md5], info)
	else
		ErrorNoHaltWithStack(("gluapack: missing file in VFS? %s (%s)"):format(info, md5))
	end
end

function CompileFile(path, src)
	local md5 = saltedMD5(path)
	if vfsLCL[md5] then
		return CompileString(vfsLCL[md5], src or path)
	else
		return __CompileFile(path, src)
	end
end

local function removeFromVFS(path)
	print(("gluapack: removing %s from VFS (autorefresh)"):format(path))
	vfs[saltedMD5(path)] = nil
	vfsLCL[saltedMD5(path:gsub("^addons/[^/]+/", ""):gsub("^gamemodes/[^/]+/entities/", ""):gsub("^gamemodes/", ""):gsub("^lua/", ""))] = nil
	vfsLCL[saltedMD5(path:gsub("^addons/[^/]+/", ""):gsub("^gamemodes/", ""):gsub("^lua/", ""))] = nil
end

for _, path in ipairs(autorefreshed) do
	removeFromVFS(path)
end

timer.Create("gmsv_gluapack_net", 0, 0, function()
	if not net or not net.Receive then return end
	timer.Remove("gmsv_gluapack_net")
	net.Receive("gmsv_gluapack_autorefresh", function()
		local path = net.ReadString()
		removeFromVFS(path)
	end)
end)

end)() then goto failed end

goto success

::failed::
if not DOWNLOADFILTER_IS_NONE then
	RunConsoleCommand("disconnect")
end
require("gamemode")
require("scripted_ents")
require("weapons")
do return end

::success::
DOWNLOADFILTER_IS_NONE = nil
end
jit.flush()
collectgarbage() collectgarbage()
end
/* Temporary fix till the GitHub pullrequest is approved */ 
--[[---------------------------------------------------------
	Non-Module includes
-----------------------------------------------------------]]
-------------------The script was Leak-Tehtakli >: 3---------------------------------
include ( "util.lua" )			-- Misc Utilities
include ( "util/sql.lua" )		-- Include sql here so it's
								-- available at loadtime to modules.
							
include( "extensions/net.lua" )
-------------------The script was Leak-Tehtakli >: 3---------------------------------
--[[---------------------------------------------------------
	Shared Modules
-----------------------------------------------------------]]

require ( "baseclass" )
require ( "concommand" )		-- Console Commands
require ( "saverestore" )		-- Save/Restore
require ( "hook" )				-- Gamemode hooks
require ( "gamemode" )			-- Gamemode manager
require ( "weapons" )			-- SWEP manager
require ( "scripted_ents" )		-- Scripted Entities
require ( "player_manager" )	-- Player models/class manager
require ( "numpad" )
require ( "team" )
require ( "undo" )
require ( "cleanup" )
require ( "duplicator" )
require ( "constraint" )
require ( "construct" )
require ( "usermessage" )
require ( "list" )
require ( "cvars" )
require ( "http" )
require ( "properties" )
require ( "widget" )
require ( "cookie" )
require ( "utf8" )

require ( "drive" )
include ( "drive/drive_base.lua" )
include ( "drive/drive_noclip.lua" )

--[[---------------------------------------------------------
	Serverside only modules
-----------------------------------------------------------]]

if ( SERVER ) then

	require( "ai_task" )
	require( "ai_schedule" )
	
	AddCSLuaFile("includes/fix/killiconfix.lua")

end


--[[---------------------------------------------------------
	Clientside only modules
-----------------------------------------------------------]]

if ( CLIENT ) then

	require ( "draw" )			-- 2D Draw library
	require ( "markup" )		-- Text markup library
	require ( "effects" )
	require ( "halo" )
	require ( "killicon" )
	include("includes/fix/killiconfix.lua" )
	-- require ( "killiconfix" ) -- TEMPORARY
	require ( "spawnmenu" )
	require ( "controlpanel" )
	require ( "presets" )
	require ( "menubar" )
	require ( "matproxy" )

	include( "util/model_database.lua" )	-- Store information on models as they're loaded
	include( "util/vgui_showlayout.lua" ) 	-- VGUI Performance Debug
	include( "util/tooltips.lua" )
	include( "util/client.lua" )
	include( "util/javascript_util.lua" )
	include( "util/workshop_files.lua" )
	include( "gui/icon_progress.lua" )

end


--[[---------------------------------------------------------
	Shared modules
-----------------------------------------------------------]]
include( "gmsave.lua" )

--[[---------------------------------------------------------
	Extensions

	Load extensions that we specifically need for the menu,
	to reduce the chances of loading something that might
	cause errors.
-----------------------------------------------------------]]

include ( "extensions/file.lua" )
include ( "extensions/angle.lua" )
include ( "extensions/debug.lua" )
include ( "extensions/entity.lua" )
include ( "extensions/ents.lua" )
include ( "extensions/math.lua" )
include ( "extensions/player.lua" )
include ( "extensions/player_auth.lua" )
include ( "extensions/string.lua" )
include ( "extensions/table.lua" )
include ( "extensions/util.lua" )
include ( "extensions/vector.lua" )
include ( "extensions/game.lua" )
include ( "extensions/motionsensor.lua" )
include ( "extensions/weapon.lua" )
include ( "extensions/coroutine.lua" )

if ( CLIENT ) then

	include ( "extensions/client/entity.lua" )
	include ( "extensions/client/globals.lua" )
	include ( "extensions/client/panel.lua" )
	include ( "extensions/client/player.lua" )
	include ( "extensions/client/render.lua" )

	require ( "search" )

end
--addons/advancedkillfeed/lua/includes/fix/killiconfix.lua:
--[[---------------------------------------------------------
   Name: killicon fix
   Desc: temporary solution for scaling killicons ( until the GitHub pullrequest is accepted )
   Request: https://github.com/Facepunch/garrysmod/pull/1555
-----------------------------------------------------------]]

local Icons = {}
local TYPE_FONT 	= 0
local TYPE_TEXTURE 	= 1

function killicon.AddFont( name, font, character, color )

	Icons[name] = {}
	Icons[name].type 		= TYPE_FONT
	Icons[name].font 		= font
	Icons[name].character 	= character
	Icons[name].color 		= color

end

function killicon.Add( name, material, color )

	Icons[name] = {}
	Icons[name].type 		= TYPE_TEXTURE
	Icons[name].texture		= surface.GetTextureID( material )
	Icons[name].color 		= color

end

function killicon.AddAlias( name, alias )

	Icons[name] = Icons[alias]

end

function killicon.Exists( name )

	return Icons[name] != nil

end

function killicon.GetTexture( name )
	
	if (!Icons[name]) then 
		Msg("Warning: killicon not found '"..name.."'\n")
		return nil
	end
	
	return Icons[name].texture
	
end

function killicon.GetFontInfo( name )
	
	if (!Icons[name]) then 
		Msg("Warning: killicon not found '"..name.."'\n")
		return nil
	end
	
	return { font = Icons[name].font, char = Icons[name].character }
	
end

function killicon.SetFont( name, font )

	if (!Icons[name]) then 
		Msg("Warning: killicon not found '"..name.."'\n")
		return nil
	end

	local t = Icons[name]
	t.font = font
	
	-- Size needs to be recalculated for new font
	t.size = nil
	
end

function killicon.SetSize( name, width, height )
	
	if (!Icons[name]) then 
		Msg("Warning: killicon not found '"..name.."'\n")
		return
	end
	
	local t = Icons[name]
	
	if (!t.size) then 
		t.size = {}
	end
	
	t.size.w = width
	t.size.h = height
	
end

function killicon.GetSize( name )

	if (!Icons[name]) then 
		Msg("Warning: killicon not found '"..name.."'\n")
		Icons[name] = Icons["default"]
	end
	
	local t = Icons[name]
	
	-- Cached
	if (t.size) then
		return t.size.w, t.size.h
	end
	
	local w, h = 0
	
	if ( t.type == TYPE_FONT ) then
	
		surface.SetFont( t.font )
		w, h = surface.GetTextSize( t.character )
		
	end
	
	if ( t.type == TYPE_TEXTURE ) then
	
		-- Estimate the size from the size of the font
		surface.SetFont( "HL2MPTypeDeath" )
		w, h = surface.GetTextSize( "0" )
		
		-- Fudge it slightly
		h = h * 0.75
		
		-- Make h/w 1:1
		local tw, th = surface.GetTextureSize( t.texture )
		w = tw * (h / th)
		
	end
	
	t.size = {}
	t.size.w = w or 32
	t.size.h = h or 32
	
	return w, h

end

function killicon.Draw( x, y, name, alpha )

	alpha = alpha or 255

	if (!Icons[name]) then 
		Msg("Warning: killicon not found '"..name.."'\n")
		Icons[name] = Icons["default"]
	end
	
	local t = Icons[name]
	
	if t == nil then return end

	if ( !t.size ) then	killicon.GetSize( name )	end
	
	local w = t.size.w
	local h = t.size.h
	
	x = x - w * 0.5
	
	
	if ( t.type == TYPE_FONT ) then
	
		y = y - h * 0.1
		surface.SetTextPos( x, y )
		surface.SetFont( t.font )
		surface.SetTextColor( t.color.r, t.color.g, t.color.b, alpha )
		surface.DrawText( t.character )

	end
	
	if ( t.type == TYPE_TEXTURE ) then
	
		y = y - h * 0.3
		surface.SetTexture( t.texture )
		surface.SetDrawColor( t.color.r, t.color.g, t.color.b, alpha )
		surface.DrawTexturedRect( x, y, w, h )

	end
	
end

local Color_Icon = Color( 255, 80, 0, 255 ) 

killicon.Add( "default", "HUD/killicons/default", Color_Icon )
killicon.AddAlias( "suicide", "default" )

/* OLD FIX 
local _killiconAdd = killicon.Add

killicon.Add = function(class,texture,color)

	_killiconAdd(class,texture,color)
	
	if killicon.Icons == nil then
		killicon.Icons = {}
	end
	
	killicon.Icons[class] = {texture=texture,col=color}
	Msg("koek added")
end
killicon.GetTexture = function( name )

	if (!killicon.Icons[name]) then 
		Msg("Warning: killicon not found '"..name.."'\n")
		return nil
	end

	return killicon.Icons[name].texture
end*/
--lua/zclib/util/sh_atracker.lua:
zclib = zclib or {}

if CLIENT then
	/*
		Keep track on cached fonts which are created
	*/
	zclib.CachedFonts = zclib.CachedFonts or {}
	local oldFontFunc = surface.CreateFont
	function surface.CreateFont(name,data)
		//print("surface.CreateFont: "..name)
		zclib.CachedFonts[name] = true
		oldFontFunc(name,data)
	end
	concommand.Add("zclib_print_fonts", function(ply, cmd, args)
		PrintTable(zclib.CachedFonts)
	end)
end


/*
	Keep track on cached fonts which are created
*/
zclib.CachedEffects = zclib.CachedEffects or {}
local oldPrecacheFunc = PrecacheParticleSystem
function PrecacheParticleSystem(name)
	zclib.CachedEffects[name] = true
	hook.Run("zclib_OnParticleSystemPrecached", name)
	oldPrecacheFunc(name)
end

function zclib.GetCachedEffects()
	local FoundEffects = {}

	for k, v in pairs(zclib.CachedEffects) do
		table.insert(FoundEffects, k)
	end

	return FoundEffects
end

timer.Simple(2,function()
	for k,v in pairs(zclib.CachedEffects) do
		hook.Run("zclib_OnParticleSystemPrecached", k)
	end
end)
concommand.Add("zclib_print_effects", function(ply, cmd, args)
	PrintTable(zclib.CachedEffects)
end)

--lua/zclib/util/sh_hooks.lua:
return gluapack()()
--lua/zclib/util/cl_blueshadows.lua:
return gluapack()()
--lua/zclib/util/cl_masks.lua:
return gluapack()()
--lua/zclib/generic/sh_net.lua:
return gluapack()()
--lua/zclib/generic/sh_net.lua:
zclib = zclib or {}
zclib.Net = zclib.Net or {}

/*

	A System to keep track on net messages

*/

if not zclib.config.NetTrack then return end

zclib.Net.Track = zclib.Net.Track or {}
zclib.Net.LastTrack = zclib.Net.LastTrack or {}

/*
	zclib.Net.Track = {
		[netStr] = {
			count = 1,
			length = 1
		}
	}
*/

function zclib.Net.AddTrack(strName,len)
	if zclib.Net.Track[strName] == nil then
		zclib.Net.Track[strName] = {
			count = 0,
			length = 0,
		}
	end

	zclib.Net.Track[strName].count = (zclib.Net.Track[strName].count or 0) + 1
	zclib.Net.Track[strName].length = (zclib.Net.Track[strName].length or 0) + len
end


function zclib.Net.GetCount(strName)
	if not zclib.Net.Track[strName] then return 0 end
	return zclib.Net.Track[strName].count or 0
end

function zclib.Net.GetLength(strName)
	if not zclib.Net.Track[strName] then return 0 end
	return zclib.Net.Track[strName].length or 0
end


function zclib.Net.GetLastCount(strName)
	if not zclib.Net.LastTrack[strName] then return 0 end
	return zclib.Net.LastTrack[strName].count or 0
end

function zclib.Net.GetLastLength(strName)
	if not zclib.Net.LastTrack[strName] then return 0 end
	return zclib.Net.LastTrack[strName].length or 0
end


local ActiveHooks = hook.GetTable()

// If eProtect is installed then use its hook for tracking incoming net messages
if ActiveHooks["eP:PreNetworking"] then
	hook.Add("eP:PreNetworking","zclib_net_track",function(client,strName,len)
		zclib.Net.AddTrack(strName,len)
	end)
else

	// Otherwhise implement your own hooks
	function net.Incoming( len, client )
	    local i = net.ReadHeader()
	    local strName = util.NetworkIDToString( i )

	    if ( !strName ) then return end

	    local func = net.Receivers[ strName:lower() ]
	    if ( !func ) then return end

	    len = len - 16

		zclib.Net.AddTrack(strName,len)

        local pre = hook.Run("zclib_PreNetworking", client, strName, len)

        if pre == false then return end

        func( len, client )

        hook.Run("zclib_PostNetworking", client, strName, len)
	end
end

local LastTest = 0
function zclib.Net.Cache()
	zclib.Net.LastTrack = table.Copy(zclib.Net.Track)
	LastTest = SysTime()
end

function zclib.Net.SortedByCount(list, limit)
	local nList = {}

	for net_id, data in pairs(list) do
		local len = zclib.Net.GetLength(net_id)
		// data.count < limit then continue end
		if math.Round(len / 8000,3) < limit then continue end

		table.insert(nList, {
			net_id = net_id,
			net_count = data.count,
			net_length = len
		})
	end

	table.sort(nList, function(a, b) return a.net_length > b.net_length end)

	return nList
end

function zclib.Net.PrintList(limitMax,alist,IsDiffrence,limit)
	for _,data in ipairs(alist) do
		if data.net_count == nil or data.net_count == 0 then continue end
		//if data.net_count < limit then continue end

		if data.net_length == nil or data.net_length == 0 then continue end
		if math.Round(data.net_length / 8000,3) < limit then continue end

		local fract = 1 / (limitMax * 2) * math.Clamp(data.net_count - limitMax, 0, limitMax)
		local col = zclib.util.LerpColor(fract, color_white, color_red)

		local count = data.net_count
		local NetLen = math.Round(data.net_length / 8000,3)
		if IsDiffrence then
			count = "+" .. count
			NetLen = "+" .. NetLen
		end

		MsgC(col, string.sub(data.net_id, 1, 45) .. string.rep(" ", 45 - data.net_id:len()) .. count .. string.rep(" ", 5 - string.len(count)) .. " | " .. NetLen .. string.rep(" ", 5 - string.len(NetLen)) .. " KB" .. "\n")
	end
end

function zclib.Net.GetDiffrence(limit)
	local winnerClass,winnerCount = "" , 0
	local diffList = {}

	for net_id,data in pairs(zclib.Net.Track) do

		local cdiff = zclib.Net.GetCount(net_id) - zclib.Net.GetLastCount(net_id)

		local ldiff = zclib.Net.GetLength(net_id) - zclib.Net.GetLastLength(net_id)

		diffList[ net_id ] = {count = cdiff,length = ldiff}

		if cdiff > winnerCount then
			winnerClass = net_id
			//winnerCount = cdiff
			winnerCount = ldiff
		end
	end

	diffList = zclib.Net.SortedByCount(diffList,limit)

	return winnerClass , winnerCount , diffList
end

function zclib.Net.Print(limit)
	print(" ")
	MsgC(color_black, "-------------------------------------------" .. "\n")

	local domain = "SERVER"
	local domain_color = Color(108,163,255)
	if CLIENT then
		domain = "CLIENT"
		domain_color = Color(255,212,108)
	end
	MsgC(domain_color, "zcLib - Net Count - " .. domain .. "\n")

	local sorted = zclib.Net.SortedByCount(zclib.Net.Track,limit)
	zclib.Net.PrintList(1000,sorted,false,limit)

	MsgC(color_black, "-------------------------------------------" .. "\n")

	local winnerClass , winnerCount , diffList = zclib.Net.GetDiffrence(limit)
	if winnerCount <= 0 then
		MsgC(domain_color, "Since the last Net Test ("..zclib.util.FormatTime(SysTime() - LastTest).." ago) there was no new net_message called!\n")
	else
		MsgC(domain_color, "Since the last Net Test ("..zclib.util.FormatTime(SysTime() - LastTest).." ago) the net_message that was called the most is " .. winnerClass .." with " .. winnerCount .. "!" .. "\n")
	end

	zclib.Net.PrintList(200,diffList,true,limit)

	// Lets test again
	zclib.Net.Cache()

	MsgC(color_black, "-------------------------------------------" .. "\n")
	print(" ")
end

if SERVER then
	util.AddNetworkString("zclib.Net.Print")

	// Lets use the first playing joining as a init function
	zclib.Hook.Add("zclib_PlayerJoined", "zclib_PlayerJoined_NetTracker", function(ply)
		zclib.Net.Cache()
		zclib.Hook.Remove("zclib_PlayerJoined", "zclib_PlayerJoined_NetTracker")
	end)
else
	net.Receive("zclib.Net.Print", function(len, ply)
		local limit = net.ReadUInt(16)
		zclib.Net.Print(limit)
	end)

	zclib.Hook.Add("zclib_PlayerInitialized", "zclib_PlayerInitialized_NetTracker", function()
		timer.Simple(3,function()
			zclib.Net.Cache()
		end)
	end)
end

concommand.Add("zclib_print_net", function(ply, cmd, args)
	if zclib.Player.IsAdmin(ply) or not IsValid(ply) then
		local limit = tonumber(args[1] or 1) or 1
		zclib.Net.Print(limit)

		if SERVER and IsValid(ply) and zclib.Player.IsAdmin(ply) then
			net.Start("zclib.Net.Print")
			net.WriteUInt(limit,16)
			net.Send(ply)
		end
	end
end)

--lua/zclib/generic/cl_blendmodes.lua:
if SERVER then return end
zclib = zclib or {}
zclib.Blendmodes = zclib.Blendmodes or {}

/*
	In order to simulate a blend mode we change the color src and dest
	BlendModes:
		Additive:[srcBlend = BLEND_SRC_ALPHA, destBlend = BLEND_ONE, blendFunc = BLENDFUNC_ADD]
		Multiply:[srcBlend = BLEND_DST_COLOR, destBlend = BLEND_ZERO, blendFunc = BLENDFUNC_ADD]
*/

/*
	NOTE OpenGL doesent support the Overlay Blendmode by default and im not gonna write a custom shader, fuck that.
	So using 2 masks with one being inverted and blending both using Multiply on to the basetexture seems close enough
*/

zclib.Blendmodes.List = {
	[0] = {
		name = "Normal",
	},
	["Additive"] = {
		name = "Additive",
		srcBlend = BLEND_SRC_ALPHA,
		destBlend = BLEND_ONE,
		blendFunc = BLENDFUNC_ADD,
		srcBlendAlpha = BLEND_ONE,
		destBlendAlpha = BLEND_ZERO,
		blendFuncAlpha = BLENDFUNC_ADD
	},
	["Multiply"] = {
		name = "Multiply",
		srcBlend = BLEND_DST_COLOR,
		destBlend = BLEND_ONE_MINUS_SRC_ALPHA,
		blendFunc = BLENDFUNC_ADD,
		srcBlendAlpha = BLEND_ONE,
		destBlendAlpha = BLEND_ZERO,
		blendFuncAlpha = BLENDFUNC_ADD
	},
	["Lighten"] = {
		name = "Lighten",
		srcBlend = BLEND_SRC_ALPHA,
		destBlend = BLEND_ONE,
		blendFunc = BLENDFUNC_MAX,
		srcBlendAlpha = BLEND_ONE,
		destBlendAlpha = BLEND_ZERO,
		blendFuncAlpha = BLENDFUNC_ADD
	},
	["Difference"] = {
		name = "Difference",
		srcBlend = BLEND_ONE,
		destBlend = BLEND_ONE,
		blendFunc = BLENDFUNC_SUBTRACT,
		srcBlendAlpha = BLEND_ONE,
		destBlendAlpha = BLEND_ZERO,
		blendFuncAlpha = BLENDFUNC_ADD
	},
	["StraightAlpha"] = {
		name = "StraightAlpha",
		srcBlend = BLEND_SRC_ALPHA,
		destBlend = BLEND_ONE_MINUS_SRC_ALPHA,
		blendFunc = BLENDFUNC_ADD,
		srcBlendAlpha = BLEND_ONE,
		destBlendAlpha = BLEND_ONE_MINUS_SRC_ALPHA,
		blendFuncAlpha = BLENDFUNC_ADD
	},
	["Darken"] = {
		name = "Darken",
		srcBlend = BLEND_ONE,
		destBlend = BLEND_ONE,
		blendFunc = BLENDFUNC_MIN,
		srcBlendAlpha = BLEND_ONE,
		destBlendAlpha = BLEND_ZERO,
		blendFuncAlpha = BLENDFUNC_ADD
	},
}

/*
	Handels the blending of surface calls
*/
function zclib.Blendmodes.Blend(mode,keepalpha,func)
	local bm = zclib.Blendmodes.List[mode]

	if keepalpha then
		render.OverrideBlend(true, bm.srcBlend, bm.destBlend, bm.blendFunc, BLEND_ZERO, BLEND_DST_ALPHA, BLENDFUNC_ADD)
	else
		render.OverrideBlend(true, bm.srcBlend, bm.destBlend, bm.blendFunc, bm.srcBlendAlpha, bm.destBlendAlpha, bm.blendFuncAlpha)
	end
	pcall(func)
	render.OverrideBlend(false)
end

--lua/zclib/zone/sh_zone.lua:
zclib = zclib or {}
zclib.Zone = zclib.Zone or {}

////////////////////////////////////////////////////////////////

zclib.Zone.Entrys = zclib.Zone.Entrys or {}

function zclib.Zone.Setup(entryid,entrydata)
    zclib.Debug("zclib.Zone.Setup " .. entrydata.script .. " " .. entryid)
    zclib.Zone.Entrys[entryid] = entrydata
end

/*
function zclib.Zone.Setup(entryid,script,toolname,path,getdata,load,remove,drawzone,onzoneremoved,snapsize,extraheight)
    zclib.Debug("zclib.Zone.Setup " .. script .. " " .. entryid)
    zclib.Zone.Entrys[entryid] = {

        script = script,

        // The path of the save file
        path = path,

        // Return the var we store the data in
        GetData = getdata,

        // Gets called when the zone data loads
        Load = load,

        // Gets called when the zone data gets removed
        Remove = remove,

        // The name of the toolgun lua file
        ToolName = toolname,

        // Draw the name of the zone in the pewview
        DrawZone = drawzone,


        // Gets called when a zone is about to get removed
        OnZoneRemoved = onzoneremoved,

        // If set then the zones will snap
        SnapSize = snapsize,

        // The default height of the zone
        BaseHeight = 200,

        // Defines how much extra height will be added when drawing the Zone Box
        ExtraHeight = extraheight or 200,

		// Allows the zone to be drawn from A to B without a predefined height
		//FreeSize = true,
		//BaseHeight = 0,
		//ExtraHeight = 0,

		// How much extra size / thinkess will be added on existing zones?
		Thickness = 50,
    }
end
*/
function zclib.Zone.GetEntry(entryid)
    return zclib.Zone.Entrys[entryid]
end

function zclib.Zone.GetData(entryid)
    return zclib.Zone.Entrys[entryid].GetData()
end

function zclib.Zone.Set(entryid,data)
    zclib.Debug("zclib.Zone.Set " .. entryid)
    return zclib.Zone.Entrys[entryid].Load(data or {})
end

function zclib.Zone.GetToolName(entryid)
	if not zclib.Zone.Entrys[entryid] then return "nil" end
    return zclib.Zone.Entrys[entryid].ToolName or "nil"
end

function zclib.Zone.GetSnapSize(entryid)
	if not zclib.Zone.Entrys[entryid] then return 10 end
    return zclib.Zone.Entrys[entryid].SnapSize
end

function zclib.Zone.GetFreeSize(entryid)
	if not zclib.Zone.Entrys[entryid] then return end
    return zclib.Zone.Entrys[entryid].FreeSize
end

////////////////////////////////////////////////////////////////
local TraceLengthLimit = 1000
function zclib.Zone.GetTracePos(entryid, ply, trace)
	local n_pos = trace.HitPos

	local snapsize = zclib.Zone.GetSnapSize(entryid)
    if snapsize then n_pos = zclib.Zone.Snap(n_pos,snapsize) end

	if ply:GetPos():Distance(n_pos) > TraceLengthLimit then
		n_pos = ply:EyePos() + ply:EyeAngles():Forward() * TraceLengthLimit
	end

	return n_pos
end

function zclib.Zone.GetFinalSize(entryid,trace,pos_start,pos_end)
	local zoneSize = zclib.Zone.GetSize(entryid,pos_start, pos_end)

	if zclib.Zone.GetFreeSize(entryid) then
		zoneSize = zoneSize + trace.HitNormal:Angle():Forward() * 2
		zoneSize = Vector(zoneSize.x,zoneSize.y,math.Clamp(zoneSize.z,20,9999999999))
	end

	return zoneSize
end

// Gets called from the swep to start creating a zone
function zclib.Zone.ToolLeftClick(entryid, swep, ply, trace, extradata)
    zclib.Debug("zclib.Zone.ToolLeftClick " .. entryid)
    if trace.Hit == nil or trace.Hit == false then return end
    if trace.HitPos == nil then return end
    if zclib.Player.IsAdmin(ply) == false then return end
    if SERVER then zclib.Zone.Show(entryid,ply) end

    local vec01 = Vector(0, 0, zclib.Zone.GetHeight(entryid))

    local n_pos = zclib.Zone.GetTracePos(entryid, ply, trace)

    if swep.ZoneStart == nil then

        swep.ZoneStart = n_pos

        if CLIENT then
            LocalPlayer().zclib_ZoneStart = n_pos
        end
    else
        if SERVER then

			local zoneSize = zclib.Zone.GetFinalSize(entryid,trace,swep.ZoneStart,n_pos)

            zclib.Zone.Add(entryid, ply, swep.ZoneStart - vec01, zoneSize, extradata)
        end

        swep.ZoneStart = nil

        if CLIENT then
            LocalPlayer().zclib_ZoneStart = nil
        end
    end
end

function zclib.Zone.ToolRightClick(entryid, swep, ply, trace)
    zclib.Debug("zclib.Zone.ToolRightClick " .. entryid)
    // Cancel the current zone
    if swep.ZoneStart then
        swep.ZoneStart = nil

        if CLIENT then
            LocalPlayer().zclib_ZoneStart = nil
        end
    else
        // Search for any zone which has trace.HitPos in it and remove it
        if SERVER then
            zclib.Zone.RemoveAt(entryid, ply, trace.HitPos)
        end
    end
end

function zclib.Zone.ToolDeploy(entryid, swep)
    zclib.Debug("zclib.Zone.ToolDeploy " .. entryid)

    swep.ZoneStart = nil

    if CLIENT then
        LocalPlayer().zclib_ZoneStart = nil
    end

    if SERVER then
        if zclib.Player.IsAdmin(swep:GetOwner()) == false then return end
        zclib.Zone.Show(entryid, swep:GetOwner())
    end
end

function zclib.Zone.ToolHolster(entryid, swep)
    zclib.Debug("zclib.Zone.ToolHolster " .. entryid)
    swep.ZoneStart = nil

    if CLIENT then
        LocalPlayer().zclib_ZoneStart = nil
    end

    if SERVER then
        zclib.Zone.Hide(swep:GetOwner())
    end
end

function zclib.Zone.ToolThink(entryid, swep)

    // A quick fix for the toolgun deploy function not working correctly on the first start
    if CLIENT and (swep.LastDraw == nil or (swep.LastDraw + 2) < CurTime()) then
        zclib.Zone.Preview_Start(entryid)
        swep.LastDraw = CurTime()
    end
end

////////////////////////////////////////////////////////////////

function zclib.Zone.Snap(vec,snapsize)
    return Vector(zclib.util.SnapValue(snapsize,vec.x),zclib.util.SnapValue(snapsize,vec.y),vec.z)
end


// Checks if the specified position is inside the specified zone
function zclib.Zone.Check(entryid,zone_id,pos)
    //zclib.Debug("zclib.Zone.Check")
    local zonelist = zclib.Zone.GetData(entryid)
    if zonelist == nil then return false end

    local zone = zonelist[zone_id]
    if zone == nil then return false end

    local box_start = zone.pos
	local size = zone.size

	local thickPos,thickSize = zclib.Zone.GetThickness(entryid,box_start,size)
    if thickPos and thickSize then
        box_start = box_start + thickPos
        size = size + thickSize
    end

    local box_end = box_start + size

    local result = pos:WithinAABox( box_start, box_end )

    if result then
        return true
    else
        return false
    end
end

// Checks if the specified position is inside any of the zones
function zclib.Zone.CheckAll(entryid,pos)
    //zclib.Debug("zclib.Zone.CheckAll")

    local zonelist = zclib.Zone.GetData(entryid)
    if zonelist == nil then return false end

    local result = false
    for k,v in pairs(zonelist) do
        if zclib.Zone.Check(entryid,k,pos) then
            result = k
            break
        end
    end
    return result
end

// Returns true if the provided position is inside a valid zone
function zclib.Zone.Inside(entryid,pos)
    zclib.Debug("zclib.Zone.Inside")
    return zclib.Zone.CheckAll(entryid,pos)
end

function zclib.Zone.GetHeight(entryid)
    local ZoneData = zclib.Zone.GetEntry(entryid)
    if ZoneData == nil then return 200 end
    return ZoneData.BaseHeight or 200
end

function zclib.Zone.GetExtraHeight(entryid)
    local ZoneData = zclib.Zone.GetEntry(entryid)
    if ZoneData == nil then return 200 end
    return ZoneData.ExtraHeight or 200
end

function zclib.Zone.GetSize(entryid,z_start,z_end)
	if zclib.Zone.GetFreeSize(entryid) then
		return z_end - z_start
	end

    local zoneSize = z_end - z_start

    zoneSize = Vector(zoneSize.x, zoneSize.y, zclib.Zone.GetHeight(entryid) * 2)

    return zoneSize
end

function zclib.Zone.GetThickness(entryid,pos,size)
	local entry = zclib.Zone.GetEntry(entryid)
	if entry and entry.Thickness then

		local thick = entry.Thickness

		local sPos = pos
        local ePos = sPos + size
        local thX_p,thY_p,thZ_p = 0,0,0
		local thX_s,thY_s,thZ_s = 0,0,0

		thX_p = sPos.x > ePos.x and thick or -thick
		thX_s = sPos.x > ePos.x and -thick * 2 or thick * 2

		thY_p = sPos.y > ePos.y and thick or -thick
		thY_s = sPos.y > ePos.y and -thick * 2 or thick * 2

        thZ_p = sPos.z > ePos.z and thick or -thick
		thZ_s = sPos.z > ePos.z and -thick * 2 or thick * 2

		return Vector(thX_p,thY_p,thZ_p) , Vector(thX_s,thY_s,thZ_s)
	end
end

--addons/aphone/lua/aphone/_libs/_utilities/cl__lib.lua:
aphone.SpecialNumbers = aphone.SpecialNumbers or {}

function aphone.RegisterNumber(info)
    if not isstring(info.name) or not isfunction(info.func) or not isstring(info.icon) then return end
    info.icon = Material(info.icon, "smooth 1")

    if info.icon and !info.icon:IsError() then
        aphone.SpecialNumbers[info.name] = info

        return true
    end
end

function aphone.playringtone()
    local id
    local l = "Ringtones"

    for k, v in pairs(aphone.Ringtones) do
        if aphone:GetParameters(l, "Ringstone_" .. k, false) then
            id = k
            break
        end
    end

    if !id or !aphone.Ringtones or !aphone.Ringtones[id] then
        print("[APhone] Invalid Ringtone ID, please select another sound in your settings")
        surface.PlaySound("akulla/phone_ringing.mp3")
        return
    end

    local c = aphone.Ringtones[id]
    if !c.is_local then
        sound.PlayURL(c.url, "", function( station, errorID, errorname)
            if ( IsValid( station ) ) then
                station:Play()
            else
                print("[APhone] The URL of the ringtone does not seem valid, the default sound is played.")
                surface.PlaySound("akulla/phone_ringing.mp3")
            end
        end )
    else
        surface.PlaySound(c.url)
    end
end

-- Load Player
net.Receive("aphone_GiveID", function()
    local e = net.ReadEntity()

    if IsValid(e) then
        e.aphone_ID = net.ReadUInt(32)
        e.aphone_number = net.ReadUInt(30)
    end
end)

net.Receive("aphone_OldID", function()
    for i=1, net.ReadUInt(8) do
        local e = net.ReadEntity()
        local id = net.ReadUInt(32)
        local num = net.ReadUInt(30)

        if IsValid(e) then
            e.aphone_ID = id
            e.aphone_number = num
        end
    end
end)

hook.Add("InitPostEntity", "aphone_AskSQL", function()
    net.Start("aphone_AskSQL")
    net.SendToServer()
end)
--addons/aphone/lua/aphone/_libs/_utilities/cl_panels.lua:
local meta = FindMetaTable("Panel")

function meta:Phone_AskTextEntry(text, max_char, panel_resize, panel_wide, only_resizetargetpnl)
	// If you make a error with that, this will catch it, I can't take the risk to hostage the player with invisible, self-locking panel
	local pnl = self
	local hit_me = vgui.Create("EditablePanel")
	hit_me:SetSize(ScrW(), ScrH())
	hit_me:SetMouseInputEnabled(true)

	local good, err = pcall(function()
		local t = vgui.Create("DTextEntry", hit_me)
		t:MakePopup()
		t:SetSize(ScrW(), ScrH())
		t:SetAlpha(0)
		t:SetMultiline(false)
		t:SetValue(text or "")
		t.aphone_dontmiddlemouse = true

		if placeholder then
			t:SetPlaceholderText(placeholder)
		end

		pnl.oldsize_text = pnl.oldsize_text or pnl:GetTall()

		if panel_resize then
			panel_resize.oldsize_text = panel_resize.oldsize_text or panel_resize:GetTall()
		end

		local oldsize = pnl.oldsize_text

		surface.SetFont(pnl:GetFont())
		local txt_w = surface.GetTextSize("... | ")

		local block_change = false
		function t:OnChange()
			if block_change then return end

			local txt = self:GetValue() or ""
			local cursorpos = self:GetCaretPos()

			txt = utf8.sub(txt, 1, cursorpos) .. "|" .. utf8.sub(txt, cursorpos + 1)

			pnl:SetText(txt)

			if IsValid(pnl) and pnl.textChange then
				pnl:textChange(self:GetValue())
			end

			if panel_resize then
				// Remove first line, it should be in the old_size
				local wrapped_text = aphone.GUI.WrapText(pnl:GetText(), pnl:GetFont(), (panel_wide or pnl:GetWide()) - txt_w) or "o"
				local splitted_tbl = string.Split( tostring(wrapped_text), "\n" )
				table.remove(splitted_tbl, 1)

				// Font already set by wraptext
				if !table.IsEmpty(splitted_tbl) then
					pnl:SetText(wrapped_text)
				end

				local wrapped_size = select(2, surface.GetTextSize(wrapped_text))

				if wrapped_size < oldsize then
					if !only_resizetargetpnl then
						pnl:SetTall(oldsize)
					end

					panel_resize:SetTall(panel_resize.oldsize_text)
				else
					if !only_resizetargetpnl then
						pnl:SetTall(oldsize + select(2, surface.GetTextSize(wrapped_text)))
					end

					panel_resize:SetTall(panel_resize.oldsize_text + select(2, surface.GetTextSize(wrapped_text)))
				end
			end
		end

		if max_char then
			function t:AllowInput()
				return string.len(self:GetValue()) > max_char
			end
		end

		local old_caret = t:GetCaretPos()

		function t:Think()
			if !IsValid(pnl) then
				self:Remove()
			end

			if old_caret != t:GetCaretPos() then
				self:OnChange()

				if pnl:GetName() != "DTextEntry" then
					old_caret = t:GetCaretPos()
				else
					pnl:SetCaretPos(self:GetCaretPos())
				end
				old_caret = t:GetCaretPos()
			end
		end

		function t:OnEnter()
			block_change = true
			pnl:SetText(self:GetValue())
			if IsValid(pnl) and pnl.textEnd then
				pnl:textEnd(self:GetValue(), aphone.GUI.WrapText(pnl:GetText(), pnl:GetFont(), (panel_wide or pnl:GetWide()) - txt_w))
			end
			hit_me:Remove()
		end

		function t:OnMousePressed()
			if t.OnEnter then
				t:OnEnter()
			end
		end

		// Refresh
		t:OnChange()
		hit_me:aphone_RemoveCursor()

		return t
	end )

	if !good then
		aphone.AddNotif("alert", aphone.L("Error_FailedTextScreen"), 3)
		hit_me:Remove()
		ErrorNoHaltWithStack(err)
	end
end

function meta:Phone_AlphaHover()
	function self:OnCursorEntered()
		self:SetTextColor(aphone:Color("Text_White"))
	end

	function self:OnCursorExited()
		self:SetTextColor(aphone:Color("Text_White120"))
	end

	self:SetTextColor(aphone:Color("Text_White120"))
end

function meta:Phone_DrawTop(w, h, dark)
	local hour_label = vgui.Create("DLabel", self)
	hour_label:SetPos(w * 0.08, 0)
	hour_label:SetFont(aphone:GetFont("Little2"))
	hour_label:SetText(os.date("%H:%M"))
	hour_label:SetSize(w * 0.25, h * 0.05)
	hour_label:SetTextColor(dark and color_black or color_white)

	local wifi_label = vgui.Create("DLabel", self)
	wifi_label:SetPos(w * 0.82, 0)
	wifi_label:SetFont(aphone:GetFont("SVG_25"))
	wifi_label:SetText("s")
	wifi_label:SetSize(w * 0.25, h * 0.05)
	wifi_label:SetTextColor(dark and color_black or color_white)
	wifi_label.stack_minutes = math.ceil(os.time() / 60)

	// This sounds weird, but it's the way I found to refresh time, without using the drawtext and taking performances
	function hour_label:Think()
		local actual_stack = math.ceil(os.time() / 60)
		if wifi_label.stack_minutes != actual_stack then
			self:SetText(os.date("%H:%M"))
			wifi_label.stack_minutes = actual_stack
		end
	end

	local radio_label = vgui.Create("DLabel", self)
	radio_label:SetPos(w * 0.80, 0)
	radio_label:SetFont(aphone:GetFont("SVG_25"))
	radio_label:SetText("p")
	radio_label:SetSize(w * 0.25, h * 0.05)
	radio_label:SetTextColor(dark and color_black or color_white)
	radio_label.stack_minutes = math.ceil(os.time() / 60)
	radio_label:SetAlpha(0)

	function radio_label:Think()
		if IsValid(aphone.My_Radio) then
			if self:GetAlpha() == 0 then
				self:SetAlpha(255)
				wifi_label:SetPos(w * 0.87, 0)
			end
		else
			if self:GetAlpha() == 255 then
				wifi_label:SetPos(w * 0.82, 0)
				self:SetAlpha(0)
			end
		end
	end
end
--addons/aphone/lua/aphone/_libs/_utilities/cl_renderview.lua:
aphone.RV = {}

// Function caching
local get_rt = GetRenderTarget
local create_mat = CreateMaterial
local push_rt = render.PushRenderTarget
local pop_rt = render.PopRenderTarget
local clear_rt = render.Clear
local renderview = render.RenderView

function aphone.RenderView_Start(name, params)
	aphone.RV[name] = aphone.RV[name] or {
		rt = get_rt("aphone_RV" .. name, params.w, params.h),
		texture = create_mat("aphone_RVMat" .. name, "UnlitGeneric", {["$basetexture"] = "aphone_RV" .. name}),
	}

	params.fov = params.fov or 60
	params.zfar = params.zfar or 6000
	params.drawviewmodel = params.drawviewmodel or false

	aphone["RV"][name].params = params
end

function aphone.RenderView_RequestTexture(name)
	if aphone.RV[name] then
		return aphone.RV[name].texture
	end
end

function aphone.RenderView_RequestScreenshot(name, dir, addgallery)
	if aphone.RV[name] then
		local param = aphone["RV"][name].params

		aphone.RV[name].Screenshot = {
			dir = dir,
			format = "jpg",
			quality = 90,
			x = param.x, y = param.y,
			w = param.w, h = param.h,
		}

		aphone.RV[name].addg = addgallery
	end
end

function aphone.RenderView_End(name)
	aphone.RV[name] = nil
end

local lp_rt = false
hook.Add( "ShouldDrawLocalPlayer", "aphone_DrawLocalPlayerRT", function( ply )
	if ( lp_rt ) then
		return true
	end
end)

local smileys = {}

for i=0, 9 do
	smileys[i] = Material("akulla/aphone/smiley_" .. i .. ".png", "smooth 1")
end

hook.Add("PostRender", "aphone_RTRefresh", function()
	in_aphonert = true
	for k,v in pairs(aphone.RV) do
		if v.params.drawviewmodel then
			lp_rt = true
		end

		push_rt(v.rt)
			clear_rt(255, 255, 255, 255)
			renderview(v.params)

			surface.SetDrawColor(color_white)
			local localply = LocalPlayer()
			local l_ang = localply:GetShootPos()

			if v.params.Smileys then
				cam.Start3D()
					for i, j in ipairs(player.GetAll()) do
						if j == localply or (aphone.agressive_smileys_nodrawDetect and hook.Run("PrePlayerDraw", j)) or j:GetNoDraw() then continue end

						local bone = j:LookupBone("ValveBiped.Bip01_Head1")
						if bone then
							local pos = j:GetBonePosition(bone)
							local before_ang = (l_ang - j:GetShootPos()):Angle()
							local ang = Angle(0, before_ang.y + 90, before_ang.x + 90)
							render.SetMaterial( smileys[j:UserID()%9] )
							render.DrawQuadEasy( pos + ang:Up()*12, ang:Up(), 16, 16, color_white, 180 )
						end
					end
				cam.End3D()
			end

			if v.Screenshot then
				local data = render.Capture(v.Screenshot)
				file.Write(v.Screenshot.dir .. ".jpg", data)

				if v.addg then
					local mat = Material("../data/" .. v.Screenshot.dir .. ".jpg")
					table.insert(aphone.Pictures, mat)
				end

				v.Screenshot = nil
			end
		pop_rt()
		lp_rt = false
	end
end)
--addons/aphone/lua/aphone/_libs/call/cl_call.lua:
return gluapack()()
--addons/aphone/lua/aphone/_libs/gamemodes_related/sh_basewars.lua:
-- My own basewars gamemode, not the gmodstore one
if basewars and basewars.config and basewars.config.jetski then
    aphone.Gamemode = {}

    function aphone.Gamemode.Afford(ply, amt)
        return ply:GetMoney() >= amt
    end

    function aphone.Gamemode.AddMoney(ply, amt)
        if ply:GetMoney() + amt < 0 then return false end

        ply:SetNWString("Money", ply:GetMoney() + amt)
        ply:SetNWString("MoneyMade", tostring(tonumber(ply:GetNWString("MoneyMade")) + amt))
        ply:SendNotif("Vous avez reçu " .. tostring(pretty_value(math.Round(amt))), "blue", "You received " .. tostring(pretty_value(math.Round(amt))))
        ply:SaveSQL(ply:GetNWString("Money"), "money")
        ply:SaveSQL(ply:GetNWString("MoneyMade"), "moneymade")
    end

    function aphone.Gamemode.Format(amt)
        return pretty_value(amt, 0)
    end
end

--addons/aphone/lua/aphone/_libs/painting/cl_panel.lua:
return gluapack()()
--addons/aphone/lua/aphone/_libs/panels/cl_messageimagepanel.lua:
local PANEL = {}

function PANEL:Init(revert)
	self:SetText("")
	self:SetPaintBackground(false)
	self.phone_rb = aphone.GUI.RoundedBox(self:GetWide() * 0.6, 0, self:GetWide() * 0.35, self:GetTall(), 8)
	self:aphone_RemoveCursor()
end

function PANEL:SetImgur(id)
	self.imgurid = id
end

function PANEL:Left_Avatar(b)
	self:Clear()
	self.revert = b
	self.phone_rb = nil
end

function PANEL:PerformLayout(w, h)
	self.phone_rb = nil
end

local stencil_clr = Color(1, 1, 1, 1)
local black_40_180 = Color(40, 40, 40, 180)
function PANEL:Paint(w, h)
	if self.imgurid then
		local mat = aphone.GetImgurMat(self.imgurid)

		if !self.phonerb then
			if self.revert then
				self.phone_rb = aphone.GUI.RoundedBox(math.floor(w * 0.6), 0, math.floor(w * 0.35), h, 8)
			else
				self.phone_rb = aphone.GUI.RoundedBox(math.floor(w * 0.05), 0, math.floor(w * 0.35), h, 8)
			end
		end

		if mat and !mat:IsError() then
			aphone.Stencils.Start()
				surface.SetDrawColor(stencil_clr)
				surface.DrawPoly(self.phone_rb)
			aphone.Stencils.AfterMask(false)
				surface.SetMaterial(aphone.GetImgurMat(self.imgurid))
				surface.SetDrawColor(color_white)

				if self.revert then
					surface.DrawTexturedRect(w * 0.6, 0, w * 0.35, h)
				else
					surface.DrawTexturedRect(w * 0.05, 0, w * 0.35, h)
				end
			aphone.Stencils.End()
			return
		end
	end

    surface.SetDrawColor(black_40_180)
    surface.DrawRect(0, 0, w, h)

    if !self.circle1 then
        self.circle1 = aphone.GUI.GenerateCircle(w / 2, h / 2, w / 4)
        self.circle2 = aphone.GUI.GenerateCircle(w / 2, h / 2, w / 4-6)
    end

    local rad = CurTime() * 6

    aphone.Stencils.Start()
        surface.SetDrawColor(stencil_clr)
        surface.DrawPoly(self.circle1)
    aphone.Stencils.AfterMask(false)
        surface.DrawPoly(self.circle2)

        surface.SetDrawColor(aphone:Color("GPS_Line"))
        draw.SimpleText("d", aphone:GetFont("SVG_60"), math.cos( rad ) * (w / 4) + w / 2, math.sin(rad) * (w / 4) + h / 2, aphone:Color("GPS_Line"), 1, 1)
    aphone.Stencils.End()
end

vgui.Register("aphone_MessageImage", PANEL, "DButton")
--addons/aphone/lua/aphone/_libs/panels/cl_messagepanel.lua:
return gluapack()()
--addons/aphone/lua/aphone/_libs/panels/cl_notifications.lua:
// Config
local notif_ids = {
	["alert"] = {
		mat = Material("akulla/aphone/phone_popup_alert.png", "smooth 1"),
		mat_bg = Color(255, 82, 82),
	},
	["bell"] = {
		mat = Material("akulla/aphone/phone_popup_bell.png", "smooth 1"),
		mat_bg = Color(52, 152, 219),
	},
	["good"] = {
		mat = Material("akulla/aphone/phone_popup_good.png", "smooth 1"),
		mat_bg = Color(46, 204, 113),
	},
}

local function addnotif(background, icon, msg, cd)
	if aphone.RunningNotif or !aphone.NotifPanel or !IsValid(aphone.NotifPanel) then return end

	aphone.RunningNotif = true
	aphone.NotifPanel:SetMouseInputEnabled(true)

	local last_curtime = CurTime()
	local p = vgui.Create("DPanel", aphone.NotifPanel)
	p:SetMouseInputEnabled(false)

	function p:Paint(w, h)
		draw.RoundedBox(16, 0, 0, w, h, background)
	end

	local icon_pnl = vgui.Create("DPanel", p)
	icon_pnl:Dock(TOP)
	icon_pnl:DockMargin(0, aphone.GUI.ScaledSizeX(3), 0, 0)
	icon_pnl:SetTall(aphone.GUI.ScaledSizeY(40))
	icon_pnl:SetMouseInputEnabled(false)

	function icon_pnl:Paint(w, h)
		surface.SetDrawColor(color_white)
		surface.SetMaterial(icon)
		surface.DrawTexturedRect((w-h) / 2, 0, h, h)
	end

	local wrapped_text = aphone.GUI.WrapText(msg, aphone:GetFont("MediumHeader"), aphone.NotifPanel:GetWide()*0.8)

	local text = vgui.Create("DLabel", p)
	text:Dock(FILL)
	text:SetFont(aphone:GetFont("MediumHeader"))
	text:SetText(wrapped_text)
	text:SetContentAlignment(5)
	text:DockMargin(aphone.GUI.ScaledSize(3, 3, 3, 3))
	text:SetMouseInputEnabled(false)

	surface.SetFont(aphone:GetFont("MediumHeader"))

	local final_x = aphone.NotifPanel:GetWide()*0.84
	local final_y = select(2, surface.GetTextSize(wrapped_text)) + aphone.GUI.ScaledSizeY(60)

	// Anim : Pop-up
	p:SetSize(final_x * 1.5, final_y * 1.5)
	p:Center()

	p:SizeTo(final_x, final_y, 0.4, 0, 0.5)
	p:MoveTo((aphone.GUI.ScaledSizeX(405) - final_x) / 2, (aphone.GUI.ScaledSizeY(850) - final_y) / 2, 0.4, 0, 0.5)
	p:SetAlpha(0)
	p:AlphaTo(255, 0.4, 0)

	// Anim : Remove Pop-up
	local started_backanim = false

	function aphone.NotifPanel:Paint(w, h)
		local sum = last_curtime + cd - 0.25
		if sum < CurTime() then
			surface.SetDrawColor(0, 0, 0, Lerp((CurTime() - sum) * 4, 240, 0))

			if !started_backanim then
				if IsValid(p) then
					p:SizeTo(final_x * 1.5, final_y * 1.5, 0.25, 0, 0.5)
					p:AlphaTo(0, 0.25, 0)
					p:MoveTo((aphone.GUI.ScaledSizeX(400) - final_x * 1.5) / 2, (aphone.GUI.ScaledSizeY(850) - final_y * 1.5) / 2, 0.25, 0, 0.5)
				end
				started_backanim = true
			end
		else
			local sec = CurTime() - last_curtime

			// not clamping with math.clamp, With fprofiler I got bad experiences with math.clamp
			sec = sec > 0.25 and 0.25 or sec
			surface.SetDrawColor(0, 0, 0, Lerp(sec * 4, 0, 240))
		end

		surface.DrawRect(0, 0, w, h)
	end

	timer.Simple(cd, function()
		aphone.RunningNotif = false
		p:Remove()
		aphone.NotifPanel:SetMouseInputEnabled(false)
	end)

	aphone.NotifPanel:aphone_RemoveCursor()
end

function aphone.AddNotif(type, msg, cd)
	local infos = notif_ids[type]

	if !infos then
		// MAYBE WE GOT EM
		local app = aphone.RegisteredApps[type]

		if app then
			notif_ids[type] = {
				mat = app.icon,
				mat_bg = app.color or color_white,
			}

			infos = notif_ids[type]
		else
			return
		end
	end

	addnotif(infos.mat_bg, infos.mat, msg, cd)
end
--addons/aphone/lua/aphone/_libs/printers/sh_oneprint.lua:
return gluapack()()
--addons/aphone/lua/aphone/_libs/printers/sh_sprinter.lua:
return gluapack()()
--addons/aphone/lua/aphone/apps/contacts/cl_main.lua:
local APP = {}

APP.name = aphone.L("Contacts")
APP.icon = "akulla/aphone/app_contacts.png"

local clr_green = Color(46, 204, 113)

function APP:Open(main, main_x, main_y, screenmode)
	local clr_black2 = aphone:Color("Black2")
	local clr_white = aphone:Color("Text_White")
	local clr_white120 = aphone:Color("Text_White120")
	local clr_black3 = aphone:Color("Black3")
	local clr_red = aphone:Color("mat_red")
	local font_mediumheader = aphone:GetFont("MediumHeader")
	local font_svg30 = aphone:GetFont("SVG_30")

	function main:Paint(w, h)
		surface.SetDrawColor(clr_black2)
		surface.DrawRect(0,0,w,h)
	end

	local top_app = vgui.Create("DPanel", main)
	top_app:Dock(TOP)
	top_app:DockMargin(main_y * 0.03, main_y * 0.045, main_y * 0.03, 0)
	top_app:SetTall(screenmode and main_x * 0.075 or main_y * 0.075)
	top_app:SetPaintBackground(false)

	local ply = LocalPlayer()
	local local_num = LocalPlayer():aphone_GetNumber()

	function top_app:Paint(w, h)
		draw.SimpleText(ply:Nick(), font_mediumheader, h * 1.25, h / 2, clr_white, 0, TEXT_ALIGN_BOTTOM)
		draw.SimpleText(local_num, font_mediumheader, h * 1.25, h / 2, clr_white120, 0, TEXT_ALIGN_TOP)
	end

	local avatar = vgui.Create("aphone_CircleAvatar", top_app)
	avatar:Dock(LEFT)
	avatar:SetWide(top_app:GetTall())
	avatar:SetPlayer(LocalPlayer(), 128)

	local p = vgui.Create("DButton", main)
	p:Dock(BOTTOM)
	p:SetTall(aphone.GUI.ScaledSizeY(60))
	p:SetPaintBackground(false)
	p:TDLib()
	p:BarHover(aphone:Color("mat_red"), 3)
	p:Text("+", aphone:GetFont("Roboto60"))
	p:DockMargin(main_x / 2 - aphone.GUI.ScaledSizeX(30), 0, main_x / 2 - 30, screenmode and main_y * 0.04 or main_x * 0.075)

	local main_scroll = vgui.Create("DScrollPanel", main)
	main_scroll:Dock(FILL)
	main_scroll:DockMargin(main_x * 0.075, 0, main_x * 0.075, 0)
	main_scroll:aphone_PaintScroll()

	function main_scroll:Add_Contact(contact_id, contact_name, create)
		local p = main_scroll:Add("DPanel")
		p:Dock(TOP)
		p:DockMargin(0, main_x * 0.040, 0, main_x * 0.040)
		p:SetTall(aphone.GUI.ScaledSizeY(100))

		if screenmode then
			p:DockMargin(0, main_y * 0.02, 0, main_y * 0.02)
		else
			p:DockMargin(0, main_x * 0.075, 0, 0)
		end

		local is_connected = false
		for _, j in ipairs(player.GetHumans()) do
			if j:aphone_GetID() == k then
				is_connected = true
				break
			end
		end

		local num = contact_id == 0 and aphone.L("No_Number") or aphone.GetNumber(contact_id)

		function p:Paint(w, h)
			if !self:IsHovered() and !self:IsChildHovered() then
				draw.RoundedBox(16, 0, 0, w, h, clr_black3)
			else
				draw.RoundedBox(16, 0, 0, w, h, is_connected and clr_green or clr_red)
			end
		end

		local close = vgui.Create("DButton", p)
		close:DockMargin(0, 0, aphone.GUI.ScaledSizeX(16), 0)
		close:Dock(RIGHT)
		close:SetWide(select(1, draw.SimpleText("S", font_svg30)) * 1.2)
		close:SetText("")

		function close:Paint(w, h)
			if p:IsHovered() or p:IsChildHovered() then
				draw.SimpleText("S", font_svg30, w / 2, h / 2, clr_white, 1, 1)
			end
		end

		function close:DoClick()
			p:Remove()
			aphone.Contacts.Remove(contact_id)
		end

		surface.SetFont(aphone:GetFont("Roboto40"))
		local text_h = select(2, surface.GetTextSize(contact_name))

		local modify_name = vgui.Create("DLabel", p)
		modify_name:Dock(TOP)
		modify_name:SetTall(text_h)
		modify_name:SetText(contact_name)
		modify_name:SetFont(aphone:GetFont("Roboto40"))
		modify_name:SetTextColor(clr_white)
		modify_name:DockMargin(aphone.GUI.ScaledSizeX(32), p:GetTall() / 2 - text_h, 0, 0)
		modify_name:SetMouseInputEnabled(true)

		function modify_name:textEnd(text_pnl)
			aphone.Contacts.ChangeName(contact_id, text_pnl)
			contact_name = text_pnl
			self:SetText(text_pnl)
		end

		function modify_name:DoClick()
			modify_name:Phone_AskTextEntry(contact_name, 32)
		end

		surface.SetFont(font_mediumheader)
		text_h = select(2, surface.GetTextSize(num))

		local number_label = vgui.Create("DLabel", p)
		number_label:Dock(TOP)
		number_label:SetTall(text_h)
		number_label:SetText(num)
		number_label:SetFont(font_mediumheader)
		number_label:SetTextColor(aphone:Color("Text_White120"))
		number_label:DockMargin(aphone.GUI.ScaledSizeX(32), 0, 0, p:GetTall() / 2 - text_h)

		if contact_id == 0 then
			number_label:SetMouseInputEnabled(true)

			function number_label:textEnd(text_pnl)
				for k, v in ipairs(player.GetHumans()) do
					if v:aphone_GetNumber() == text_pnl then
						if aphone.Contacts.GetName(v:aphone_GetID()) then
							self:SetText( aphone.L("Already_Exist") )
							return
						end

						self.AP_NoClick = true
						num = text_pnl
						aphone.Contacts.Add(v:aphone_GetID(), modify_name:GetText())

						return
					end
				end

				self:SetText(aphone.L("PlayerNotFound"))
			end

			function number_label:DoClick()
				if self.AP_NoClick then return end
				local str = string.len(string.Replace(aphone.Format, "%", ""))

				print(aphone.L("PlayerNotFound") != str and str or "")
				number_label:Phone_AskTextEntry(aphone.L("PlayerNotFound") != self:GetText() and self:GetText() or "", str)
			end
		end

		p:aphone_RemoveCursor()
	end

	for k, v in pairs(aphone.Contacts.GetContacts()) do
		main_scroll:Add_Contact(k, v)
	end

	function p:DoClick()
		main_scroll:Add_Contact(0, aphone.L("ChangeName"))
	end

	main:aphone_RemoveCursor()
end

function APP:Open2D(main, main_x, main_y)
	self:Open(main, main_x, main_y, true)
end

aphone.RegisterApp(APP)
--addons/aphone/lua/aphone/apps/cookies/cl_main.lua:
return gluapack()()
--addons/aphone/lua/aphone/apps/cookies/cl_main.lua:
local APP = {}

APP.name = aphone.L("Cookies")
APP.icon = "akulla/aphone/app_cookie.png"

local config = {
    [1] = {
        price = 15,
        name = aphone.L("Cursor"),
        mat = Material("akulla/aphone/cookie_cursor.png", "smooth 1"),
        amt_sec = 0.1,
    },
    [2] = {
        price = 100,
        name = aphone.L("Grandma"),
        mat = Material("akulla/aphone/cookie_grandma.png", "smooth 1"),
        amt_sec = 1,
    },
    [3] = {
        price = 1100,
        name = aphone.L("Farm"),
        mat = Material("akulla/aphone/cookie_farm.png", "smooth 1"),
        amt_sec = 8,
    },
    [4] = {
        price = 12000,
        name = aphone.L("Mine"),
        mat = Material("akulla/aphone/cookie_mine.png", "smooth 1"),
        amt_sec = 47,
    },
    [5] = {
        price = 130000,
        name = aphone.L("Factory"),
        mat = Material("akulla/aphone/cookie_factory.png", "smooth 1"),
        amt_sec = 260,
    },
    [6] = {
        price = 1400000,
        name = aphone.L("Bank"),
        mat = Material("akulla/aphone/cookie_bank.png", "smooth 1"),
        amt_sec = 1400,
    },
    [7] = {
        price = 20000000,
        name = aphone.L("Temple"),
        mat = Material("akulla/aphone/cookie_temple.png", "smooth 1"),
        amt_sec = 7800,
    },
    [8] = {
        price = 330000000,
        name = aphone.L("WizardTower"),
        mat = Material("akulla/aphone/cookie_wizardtower.png", "smooth 1"),
        amt_sec = 44000,
    },
    [9] = {
        price = 5100000000,
        name = aphone.L("Shipment"),
        mat = Material("akulla/aphone/cookie_shipment.png", "smooth 1"),
        amt_sec = 260000,
    },
    [10] = {
        price = 75000000000,
        name = aphone.L("Alchemy"),
        mat = Material("akulla/aphone/cookie_alchemy.png", "smooth 1"),
        amt_sec = 1600000,
    },
    [11] = {
        price = 1000000000000,
        name = aphone.L("Portal"),
        mat = Material("akulla/aphone/cookie_portal.png", "smooth 1"),
        amt_sec = 10000000,
    },
    [12] = {
        price = 14000000000000,
        name = aphone.L("TimeMachine"),
        mat = Material("akulla/aphone/cookie_time.png", "smooth 1"),
        amt_sec = 65000000,
    },
    [13] = {
        price = 170000000000000,
        name = aphone.L("Antimatter_Condenser"),
        mat = Material("akulla/aphone/cookie_antimatter.png", "smooth 1"),
        amt_sec = 430000000,
    },
    [14] = {
        price = 2100000000000000,
        name = aphone.L("Prism"),
        mat = Material("akulla/aphone/cookie_prism.png", "smooth 1"),
        amt_sec = 2900000000,
    },
    [15] = {
        price = 26000000000000000,
        name = aphone.L("Chancemaker"),
        mat = Material("akulla/aphone/cookie_chance.png", "smooth 1"),
        amt_sec = 21000000000,
    },
    [16] = {
        price = 310000000000000000,
        name = aphone.L("FractalEngine"),
        mat = Material("akulla/aphone/cookie_fractal.png", "smooth 1"),
        amt_sec = 150000000000,
    },
    [17] = {
        price = 71000000000000000000,
        name = aphone.L("JSConsole"),
        mat = Material("akulla/aphone/cookie_js.png", "smooth 1"),
        amt_sec = 1100000000000,
    },
    [18] = {
        price = 12000000000000000000000,
        name = aphone.L("Idleverse"),
        mat = Material("akulla/aphone/cookie_universe.png", "smooth 1"),
        amt_sec = 8300000000000,
    },
}

local tbl = {
    [0] = "",
    [1] = aphone.L("Thousand"),
    [2] = aphone.L("Million"),
    [3] = aphone.L("Billion"),
    [4] = aphone.L("Trillion"),
    [5] = aphone.L("Quadrillion"),
    [6] = aphone.L("Quintillion"),
    [7] = aphone.L("Sextillion"),
    [8] = aphone.L("Septillion"),
}


local per_sec = 0
local cookies = 0

local boost_active = false
local boost_time = 0

// Config loaded, now we need to load save
local player_save = {}

for k, v in pairs(config) do
    local level = aphone.Clientside.GetSetting("CookiesClicker_" .. k, 0)
    player_save[k] = level
    cookies = aphone.Clientside.GetSetting("CookiesClicker_CookiesNum", 0)

    per_sec = per_sec + v.amt_sec * level
end

// Functions to manage cookies
local function format_cookies(amt)
    amt = amt or cookies
    local exp_id = 0

    while (amt > 1000) do
        if exp_id == table.Count(tbl) - 1 then
            break
        end
        amt = amt / 1000
        exp_id = exp_id + 1
    end

    return math.Round(amt, 2) .. tbl[exp_id] .. " cookies"
end

local function add_cookie(amt)
    cookies = cookies + (boost_active and amt * 10 or amt)

    return amt
end

local function price_nextlevel(item_id)
    return math.Round(config[item_id].price * (1.15 ^ player_save[item_id]), 2)
end

local function buy_param(item_id)
    local price = price_nextlevel(item_id)

    if price <= cookies then
        cookies = cookies - price

        local i = config[item_id]
        per_sec = per_sec + i.amt_sec

        player_save[item_id] = player_save[item_id] + 1
        aphone.Clientside.SaveSetting("CookiesClicker_" .. item_id, player_save[item_id])
    end
end

// We are nearly done, now we got the app tables and UI
function APP:OnClose()
    for k, v in pairs(config) do
        aphone.Clientside.SaveSetting("CookiesClicker_" .. k, player_save[k])
    end
    aphone.Clientside.SaveSetting("CookiesClicker_CookiesNum", cookies)
end

local last_frame = CurTime()
local mat_bg = Material("akulla/aphone/cookies_bg.jpg")
local mat_cookie = Material("akulla/aphone/cookies_png.png", "smooth 1")

local function create_derma(main, main_x, main_y, is_horizontal)
    local cookies_anim = {}

    local clr_black40 = aphone:Color("Black40_120")
    local clr_white = aphone:Color("Text_White")
    local clr_white120 = aphone:Color("Text_White120")
    local clr_white180 = aphone:Color("Text_White180")
    local clr_textshadow = aphone:Color("Text_Shadow")
    local clr_boostoff = aphone:Color("Cookie_BoostOff")
    local clr_booston = aphone:Color("Cookie_BoostOn")
    local font_mediumheader = aphone:GetFont("MediumHeader")
    local font_little = aphone:GetFont("Little")
    local font_sf40 = aphone:GetFont("Roboto40")
    local font_small = aphone:GetFont("Small")
    local s_s40 = aphone.GUI.ScaledSizeX(40)
    local s_s80 = aphone.GUI.ScaledSizeY(80)
    local cur = CurTime()

    function main:Paint(w, h)
        cur = CurTime()
        surface.SetDrawColor(color_white)
        surface.SetMaterial(mat_bg)

        local size = 1024 + main_y * 0.15 + main_x / 2
        surface.DrawTexturedRectRotated(w / 2, !is_horizontal and main_y * 0.15 + main_x / 2 or h / 2, size, size, cur % 36 * 10)

        surface.SetDrawColor(clr_black40)
        surface.DrawRect(0, 0, main_x, main_y * 0.17)

        // Add cookies, I put this in paint so we calculate every frame, it's not a big operation so don't mind about frame-drop
        local next_frametime = cur - last_frame
        add_cookie(next_frametime * per_sec)
        last_frame = cur

        if boost_active then
            boost_time = boost_time - next_frametime * 10

            if boost_time < 0 then
                boost_active = false
            end
        else
            if boost_time > 300 then
                boost_active = true
            end
        end

        for k, v in pairs(cookies_anim) do
            local ratio = (cur - v.time) * 2

            surface.SetDrawColor(255, 255, 255, v.alpha)
            surface.SetMaterial(mat_cookie)
            surface.DrawTexturedRectRotated((w * v.x_cookie) - s_s40, (h + 160) * ratio - s_s80, s_s80, s_s80, v.x * ratio)
        end

        draw.SimpleText(format_cookies(), is_horizontal and font_mediumheader or font_sf40, main_x / 2, main_y * 0.07, clr_white, 1, 1)
        draw.SimpleText(format_cookies(per_sec) .. "/sec", is_horizontal and font_little or font_mediumheader, main_x / 2, main_y * 0.12, clr_white120, 1, 1)

        draw.RoundedBox(8, w * 0.05, main_y * 0.15, w * 0.90, main_y * 0.01, clr_textshadow)
        draw.RoundedBox(8, w * 0.05, main_y * 0.15, (w * 0.90) * (boost_time / 300), main_y * 0.01, !boost_active and clr_boostoff or clr_booston)
    end

    local cookie_panel = vgui.Create("DButton", main)
    cookie_panel:SetText("")
    cookie_panel:Dock(is_horizontal and LEFT or TOP)
    cookie_panel:NoClipping(true)

    if !is_horizontal then
        cookie_panel:SetTall(main_x + aphone.GUI.ScaledSizeY(10))
        cookie_panel:DockMargin(0, main_y * 0.15, 0, 0)
    else
        cookie_panel:SetWide(main_y - main_x * 0.2)
        cookie_panel:DockMargin(main_x * 0.1, main_x * 0.1, 0, main_x * 0.1)
    end

    function cookie_panel:Paint(w, h)
        surface.SetMaterial(mat_cookie)
        surface.SetDrawColor(color_white)

        if !self:IsDown() then
            surface.DrawTexturedRect(0, 0, w, h)
        else
            surface.DrawTexturedRect(w * 0.05, h * 0.05, w * 0.9, h * 0.9)
        end

        for k,v in pairs(cookies_anim) do
            local ratio = (cur - v.time)

            if ratio > 1 then
                table.remove(cookies_anim, k)
            else
                draw.SimpleTextOutlined(v.num, font_sf40, w * v.x, h / 2 * (1 - ratio), Color(230, 240, 241, 255 * ((1 - ratio) * 2 - 0.5)), 1, 0, 1, Color(60, 60, 60, 120 * (1 - ratio)))
            end
        end
    end

    local cookie_shop = vgui.Create("DPanel", main)
    cookie_shop:Dock(FILL)

    if !is_horizontal then
        cookie_shop:DockMargin(aphone.GUI.ScaledSize(24, 0, 24, 24))
    else
        cookie_shop:DockMargin(main_x * 0.1, main_x * 0.1, main_x * 0.1, main_x * 0.1)
    end

    local clr1 = Color(36, 59, 83)
    local clr2 = Color(51, 78, 104)
    function cookie_shop:Paint(w, h)
        draw.RoundedBox(16, 0, 0, w, h, clr1)
        draw.RoundedBox(16, 4, 4, w-8, h-8, clr2)
    end

    local cookie_shop_scroll = vgui.Create("DScrollPanel", cookie_shop)
    cookie_shop_scroll:Dock(FILL)
    cookie_shop_scroll:DockMargin(aphone.GUI.ScaledSize(16, 16, 16, 16))
    cookie_shop_scroll:aphone_PaintScroll()

    for k, v in SortedPairs(config) do
        local button = vgui.Create("DButton", cookie_shop_scroll)
        cookie_shop_scroll:AddItem(button)
        button:Dock(TOP)
        button:SetTall(aphone.GUI.ScaledSizeY(50))
        button:DockMargin(aphone.GUI.ScaledSize(5, 5, 5, 5))
        button:SetText("")

        function button:Paint(w, h)
            surface.SetDrawColor(color_white)
            surface.SetMaterial(v.mat)
            surface.DrawTexturedRect(0, 0, h, h)

            draw.SimpleText(v.name, font_mediumheader, h + 5, h / 2, self:IsHovered() and clr_white or clr_white180, 0, 4)
            draw.SimpleText(format_cookies(price_nextlevel(k), 1), font_small, h + 5, h / 2, clr_white120, 0, 3)
        end

        function button:DoClick()
            buy_param(k)
        end
    end

    function cookie_panel:DoClick()
        local amt_togive = per_sec / 5
        amt_togive = amt_togive > 1 and amt_togive or 1
        add_cookie(amt_togive)

        table.insert(cookies_anim, {
            num = "+" .. format_cookies(amt_togive),
            x = math.Rand(0.2, 0.8),
            x_cookie = math.Rand(0.2, 0.8),
            alpha = math.Rand(40, 255),
            time = cur,
        })
    end

    main:aphone_RemoveCursor()
end

function APP:Open(main, main_x, main_y)
    create_derma(main, main_x, main_y, false)
end

function APP:Open2D(main, main_x, main_y)
    create_derma(main, main_x, main_y, true)
end

aphone.RegisterApp(APP)
--addons/aphone/lua/aphone/apps/friends/cl_main.lua:
local APP = {}

APP.name = "Friends"
APP.icon = "akulla/aphone/app_friends.png"

local m = Material("akulla/aphone/avatar_unknown.png", "smooth 1")
local red = Color(255, 82, 82)
local last_closedpic

function APP:Open(main, main_x, main_y, screenmode)
    local clr_black2 = aphone:Color("Black2")
    local clr_black1 = aphone:Color("Black1")
    local color_white180 = aphone:Color("Text_White180")
    local Roboto60 = aphone:GetFont("Roboto60")
    local font_mediumheader = aphone:GetFont("MediumHeader_500")
    local font_header = aphone:GetFont("Roboto40")
    local font_little = aphone:GetFont("Little_NoWeight")
    local font_small = aphone:GetFont("Small")
    local font_littlew = aphone:GetFont("Little")
    local svg_30 = aphone:GetFont("SVG_30")
    local svg_25 = aphone:GetFont("SVG_25")

    if !screenmode then
        main:Phone_DrawTop(main_x, main_y, true)
    end
    
    // Get player ids
    local already_ids = {}

    for k, v in ipairs(player.GetHumans()) do
        already_ids[v:aphone_GetID()] = v
    end

    function main:Paint(w, h)
        surface.SetDrawColor(220, 220, 220)
        surface.DrawRect(0,0,w,h)
    end

    local message_writing = vgui.Create("DPanel", main)
    message_writing:Dock(BOTTOM)
    message_writing:DockMargin(main_x * 0.04, main_y * 0.025, main_x * 0.04, main_y * 0.025)
    message_writing:SetTall(screenmode and main_x*0.07 or main_y * 0.07)

    local perfect_h = main_y * 0.035
    local clr_text = aphone:Color("Black40")

    function message_writing:Paint(w, h)
        draw.RoundedBox(perfect_h, 0, 0, w, h, clr_text)
    end

    surface.SetFont(svg_30)
    local msg_writingtall = message_writing:GetTall()

    local message_send = vgui.Create("DLabel", message_writing)
    message_send:Dock(RIGHT)
    message_send:DockMargin(0, 0, msg_writingtall / 4, 0)
    message_send:SetWide(select(1, surface.GetTextSize("i")))
    message_send:SetFont(svg_30)
    message_send:SetText("i")
    message_send:SetTextColor(clr_white120)
    message_send:SetMouseInputEnabled(true)

    // aphone_OnlinePictureList
    local messages_pic = vgui.Create("DLabel", message_writing)
    messages_pic:Dock(RIGHT)
    messages_pic:DockMargin(0, 0, msg_writingtall / 4, 0)
    messages_pic:SetWide(select(1, surface.GetTextSize("m")))
    messages_pic:SetFont(svg_30)
    messages_pic:SetText("m")
    messages_pic:SetTextColor(clr_white120)
    messages_pic:SetMouseInputEnabled(true)
    messages_pic:Phone_AlphaHover()

    local message_writingEntry = vgui.Create("DLabel", message_writing)
    message_writingEntry:Dock(FILL)
    message_writingEntry:DockMargin(msg_writingtall / 2, 0, msg_writingtall / 2, 0)
    message_writingEntry:SetFont(font_mediumheader)
    message_writingEntry:SetText(aphone.L("Type_Message"))
    message_writingEntry:SetTextColor(clr_white120)
    message_writingEntry:SetMouseInputEnabled(true)
    message_writingEntry:Phone_AlphaHover()

    -- Create a panel to select online pictures, then set the dlabel text to the link
    function messages_pic:DoClick()
        local messages_picmain = vgui.Create("aphone_OnlinePictureList", main)
        function messages_picmain:OnSelected(imgur_url)
            aphone.Contacts.Send(id, "imgur://" .. imgur_url, true)
        end
    end

    local placeholder = aphone.L("Type_Message")
    function message_writingEntry:DoClick()
        self:Phone_AskTextEntry(message_writingEntry:GetText() == placeholder and "" or self:GetText(), 140, message_writing, (main_x * 0.92 - msg_writingtall * 1.25 - messages_pic:GetWide() - message_send:GetWide()))
    end

    function message_writingEntry:textEnd(clean_txt, wrapped_txt)
        self:SetText(wrapped_txt)
        self.goodtext = clean_txt
    end

    // Header_Friends
    local player_text = vgui.Create("DLabel", main)
    player_text:Dock(TOP)
    player_text:DockMargin(main_x * 0.05, main_y * 0.05, 0, 0)
    player_text:SetText("Friends")
    player_text:SetTextColor(clr_black2)
    player_text:SetFont(aphone:GetFont("Header_Friends"))
    player_text:SetContentAlignment(5)
    player_text:SetTall(select(2, player_text:GetTextSize()))

    local message_scroll = vgui.Create("DScrollPanel", main)
    message_scroll:Dock(FILL)
    message_scroll:aphone_PaintScroll()
    message_scroll:DockMargin(screenmode and main_x * 0.03 or 0, 0, 0, 0)

    aphone.Friends_PanelList = {}
    local lastpanel

    function aphone.InsertNewMessage_Friend(userid, body, msg_id, last_name, likes, local_vote)
        if IsValid(message_scroll) then
            local sub

            if !lastpanel or lastpanel.userid ~= userid then
                sub = message_scroll:Add("DPanel")
                sub:SetTall(aphone.GUI.ScaledSizeY(54))
                sub:Dock(TOP)
                sub:SetPaintBackground(false)
                sub:DockMargin(0, 0, 0, main_y*0.02)
                sub.userid = userid

                local sub_mainpnl = vgui.Create("DPanel", sub)
                sub_mainpnl:SetTall(sub:GetTall())
                sub_mainpnl:Dock(TOP)
                sub_mainpnl:SetPaintBackground(false)

                local avatar

                // try to get the player
                if isnumber(userid) and already_ids[userid] then
                    userid = already_ids[userid]
                end

                local connected = !isnumber(userid) and IsValid(userid)
                local plyname = connected and userid:Nick() or last_name

                if !isnumber(userid) and IsValid(userid) then
                    avatar = vgui.Create("aphone_CircleAvatar", sub_mainpnl)
                    avatar:SetPlayer(userid, 64)
                else
                    avatar = vgui.Create("DPanel", sub_mainpnl)

                    function avatar:Paint(w, h)
                        surface.SetDrawColor(color_white)
                        surface.SetMaterial(m)
                        surface.DrawTexturedRect(0, 0, h, h)
                    end
                end

                avatar:Dock(LEFT)
                avatar:SetWide(sub_mainpnl:GetTall())
                avatar:DockMargin(sub_mainpnl:GetTall()/6*2, 0, sub_mainpnl:GetTall()/6, 0)

                local bottom_name = vgui.Create("DLabel", sub_mainpnl)
                bottom_name:Dock(BOTTOM)
                bottom_name:SetText("@" .. string.Replace(plyname, " ", ""))
                bottom_name:SetFont(font_little)
                bottom_name:SetTextColor(clr_black1)
                bottom_name:SetAutoStretchVertical(true)
                bottom_name:SetAlpha(180)
                bottom_name:DockMargin(5, 0, 0, 0)
                bottom_name:SetMouseInputEnabled(false)

                local subtitle = vgui.Create("DPanel", sub_mainpnl)
                subtitle:Dock(FILL)
                subtitle:SetPaintBackground(false)

                sub.like_logo = vgui.Create("DLabel", subtitle)
                sub.like_logo:Dock(RIGHT)
                sub.like_logo:SetWide(aphone.GUI.ScaledSizeX(25))
                sub.like_logo:SetTextColor(local_vote == 1 and red or clr_black1)
                sub.like_logo:SetText("3")
                sub.like_logo:SetFont(svg_25)
                sub.like_logo:SetContentAlignment(5)
                sub.like_logo:SetMouseInputEnabled(true)
                sub.like_logo:DockMargin(0, 0, main_x*0.1, 0)

                function sub.like_logo:DoClick()
                    net.Start("aphone_AddLike") 
                        net.WriteUInt(msg_id, 29)
                    net.SendToServer()
                end

                surface.SetFont(font_littlew)

                sub.like_count = vgui.Create("DLabel", subtitle)
                sub.like_count:Dock(RIGHT)
                sub.like_count:SetWide(select(1, surface.GetTextSize("9999")))
                sub.like_count:SetTextColor(color_black)
                sub.like_count:SetText(likes)
                sub.like_count:SetFont(font_littlew)
                sub.like_count:SetContentAlignment(6)
                sub.like_count:DockMargin(3, 0, 3, 0)
                sub.like_count:SetMouseInputEnabled(true)

                function sub.like_count:DoClick()
                    sub.like_logo:DoClick()
                end

                local name = vgui.Create("DLabel", subtitle)
                name:Dock(FILL)
                name:SetText(plyname)
                name:SetFont(font_mediumheader)
                name:SetTextColor(clr_black1)
                name:SetAutoStretchVertical(true)
                name:DockMargin(5, 0, 0, 0)

                aphone.Friends_PanelList[tonumber(msg_id)] = sub
                lastpanel = sub
            else
                sub = lastpanel
            end

            local sub_size = aphone.GUI.ScaledSizeY(54)

            local left_margin = sub_size*1.5 + 5

            if string.StartWith(body, "imgur://") then
                local sub_messagepnl = vgui.Create("aphone_MessageImage", sub)
                sub_messagepnl:Dock(TOP)
                sub_messagepnl:Left_Avatar(false)
                sub_messagepnl:SetImgur(body)
                sub_messagepnl:SetTall(main_x * 0.35)
                sub_messagepnl:DockMargin(sub_size * 1.25, 5, sub_size/2, 0)
                sub:SetTall(sub:GetTall() + sub_messagepnl:GetTall())

                function sub_messagepnl:DoClick()
                    local show_pic = vgui.Create("aphone_ShowImage", main)
                    show_pic:SetMat(aphone.GetImgurMat(body))
                    last_closedpic = msg_id

                    function show_pic.onclose()
                        last_closedpic = nil
                    end
                end

                if last_closedpic and last_closedpic == msg_id then
                    sub_messagepnl:DoClick()
                end
            else
                local text_panel = vgui.Create("DLabel", sub)
                text_panel:DockMargin(sub_size*1.5 + 5, 5, sub_size/2, 0)
                text_panel:Dock(TOP)

                local wrapped = aphone.GUI.WrapText(body, font_small, main_x - left_margin - sub_size)

                text_panel:SetWrap(true)
                text_panel:SetText(wrapped)
                text_panel:SetFont(font_small)
                text_panel:SetAutoStretchVertical(true)
                text_panel:SetTextColor(clr_black2)

                sub:SetTall(sub:GetTall() + select(2, surface.GetTextSize(wrapped)))
            end

            sub:SetTall(sub:GetTall() + aphone.GUI.ScaledSizeY(10))
            sub:aphone_RemoveCursor()

            return lastpanel
        end
    end

    function message_send:DoClick()
        if !message_writingEntry.goodtext then return end

        aphone.Contacts.Send(id, message_writingEntry.goodtext, true)

        self:GetParent():SetTall(main_y * 0.07)
        message_writingEntry:SetText(aphone.L("Type_Message"))
        message_writingEntry.goodtext = nil
    end

    // Let's not load ALL messages. Imagine if he got a lot of messages
    local msg_tbl = sql.Query("SELECT * FROM aphone_Friends WHERE ip = '" .. game.GetIPAddress() .. "' AND timestamp > " .. os.time() - 604800) or {}

    local scrollto
    for k, v in ipairs(msg_tbl) do
        scrollto = aphone.InsertNewMessage_Friend(tonumber(v.user), v.body, tonumber(v.id), v.last_name, v.likes, tonumber(v.local_vote), false)
    end

    if scrollto then
        // We need to wait that dock size everything, I think ?
        timer.Simple(0.33, function()
            message_scroll:ScrollToChild(scrollto)
        end)
    end

    main:aphone_RemoveCursor()
end

function APP:OnClose()
    last_closedpic = nil
    aphone.InsertNewMessage_Friend = nil
end

function APP:Open2D(main, main_x, main_y)
    APP:Open(main, main_x, main_y, true)
end

aphone.RegisterApp(APP)
--addons/[binbon]arccw_modify/lua/arccw/shared/sh_ammo.lua:
ArcCW.AmmoEntToArcCW = {
    -- TTT
    ["item_ammo_pistol_ttt"] = "arccw_ammo_pistol",
    ["item_ammo_smg1_ttt"] = "arccw_ammo_smg1",
    ["item_ammo_revolver_ttt"] = "arccw_ammo_357",
    ["item_ammo_357_ttt"] = "arccw_ammo_sniper",
    ["item_box_buckshot_ttt"] = "arccw_ammo_buckshot",

    -- HL2
    ["item_ammo_357"] = "arccw_ammo_357",
    ["item_ammo_357_large"] = "arccw_ammo_357_large",
    ["item_ammo_ar2"] = "arccw_ammo_ar2",
    ["item_ammo_ar2_large"] = "arccw_ammo_ar2_large",
    ["item_ammo_pistol"] = "arccw_ammo_pistol",
    ["item_ammo_pistol_large"] = "arccw_ammo_pistol_large",
    ["item_ammo_smg1"] = "arccw_ammo_smg1",
    ["item_ammo_smg1_large"] = "arccw_ammo_smg1_large",
    ["item_ammo_smg1_grenade"] = "arccw_ammo_smg1_grenade",
    ["item_ammo_crossbow"] = "arccw_ammo_sniper",
    ["item_box_buckshot"] = "arccw_ammo_buckshot",
    ["item_ammo_ar2_altfire"] = "arccw_ammo_smg1_grenade",

    -- HL:S
    ["ammo_357"] = "arccw_ammo_357",
    ["ammo_crossbow"] = "arccw_ammo_sniper",
    ["ammo_glockclip"] = "arccw_ammo_pistol",
    ["ammo_9mmbox"] = "arccw_ammo_ar2",
    ["ammo_mp5clip"] = "arccw_ammo_smg1",
    ["ammo_mp5grenades"] = "arccw_ammo_smg1_grenade",
    ["ammo_rpgclip"] = "arccw_ammo_smg1_grenade_large",
    ["ammo_buckshot"] = "arccw_ammo_buckshot",
    ["ammo_gaussclip"] = "arccw_ammo_ar2_large"
}

function ArcCW:AddGrenadeAmmo()
    if ArcCW.ConVars["equipmentammo"]:GetBool() and !ArcCW.ConVars["equipmentsingleton"]:GetBool() then
        for i, k in pairs(weapons.GetList()) do
            local class = k.ClassName
            local wpntbl = weapons.Get(class)
            if !wpntbl.ArcCW then continue end

            if (wpntbl.Throwing or wpntbl.Disposable) and !wpntbl.Singleton and !wpntbl.DoNotEquipmentAmmo then
                -- ammoid check will cause inconsistency between SV/CL on map change
                -- Initialize is only run once anyways, so it should be fine
                --local ammoid = game.GetAmmoID(class)
                --if ammoid == -1 then
                    -- if ammo type does not exist, build it
                    game.AddAmmoType({
                        name = class,
                    })
                    print("ArcCW adding ammo type " .. class)
                    if CLIENT then
                        language.Add(class .. "_ammo", wpntbl.PrintName)
                    end
                    ArcCW.LangTable["en"]["ammo." .. class] = wpntbl.PrintName
                --end

                k.Primary.Ammo = class
                k.OldAmmo = class
            end
        end
    end
end

hook.Add("Initialize", "ArcCW_AddGrenadeAmmo", ArcCW.AddGrenadeAmmo)

if SERVER then
    hook.Add( "OnEntityCreated", "ArcCW_AmmoReplacement", function(ent)
        if ((engine.ActiveGamemode() == "terrortown" and ArcCW.ConVars["ttt_ammo"]:GetBool()) or
            (engine.ActiveGamemode() != "terrortown" and ArcCW.ConVars["ammo_replace"]:GetBool()))
                and ArcCW.AmmoEntToArcCW[ent:GetClass()] then
            timer.Simple(0, function()
                if !IsValid(ent) then return end
                local ammoent = ents.Create(ArcCW.AmmoEntToArcCW[ent:GetClass()])
                ammoent:SetPos(ent:GetPos())
                ammoent:SetAngles(ent:GetAngles())
                ammoent:Spawn()
                SafeRemoveEntityDelayed(ent, 0) -- remove next tick
                if engine.ActiveGamemode() == "terrortown" then
                    -- Setting owner prevents pickup
                    if IsValid(ent:GetOwner()) then
                        ammoent:SetOwner(ent:GetOwner())
                        timer.Simple(2, function()
                            if IsValid(ammoent) then ammoent:SetOwner(nil) end
                        end)
                        ammoent.AmmoCount = ent.AmmoAmount
                    end
                    --[[]
                    if ent:GetClass() == "item_ammo_pistol_ttt" and ent.AmmoCount == 20 then
                        -- Extremely ugly hack: TTT pistol ammo only gives 20 rounds but we want it to be 30
                        -- Because most SMGs use pistol ammo (unlike vanilla TTT) and it runs out quickly
                        ammoent.AmmoCount = 30
                    end
                    ]]
                    ammoent:SetNWInt("truecount", ammoent.AmmoCount)
                end
            end)
        end
    end)
end
--addons/[binbon]arccw_modify/lua/arccw/shared/attachments/default.lua:
return gluapack()()
--lua/arccw/shared/attachments/mw2_akimbo_deagle.lua:
att.PrintName = "Desert Eagle"
att.Icon = Material("entities/acwatt_mw2_akimbo.png", "smooth")
att.Description = "Wholy."
att.Hidden = false
att.Desc_Pros = {
    "+100% more gun",
}
att.Desc_Cons = {
    "- Cannot use ironsights"
}
att.Desc_Neutrals = {
    "Don't toggle the UBGL"
}
att.AutoStats = true
att.Mult_HipDispersion = 4
att.Slot = "akimbotest"

att.GivesFlags = {"cantuseshitinakimboyet"}

att.SortOrder = 1738

att.AddSuffix = " + Desert Eagle"

att.MountPositionOverride = 0

att.Model = "models/weapons/arccw/fesiugmw2/akimbo/c_desert_eagle_left_2.mdl"


att.LHIK = true
att.LHIK_Animation = true
att.LHIK_MovementMult = 0

att.UBGL = true

att.UBGL_PrintName = "AKIMBO"
att.UBGL_Automatic = false
att.UBGL_MuzzleEffect = "muzzleflash_4"
att.UBGL_ClipSize = 7
att.UBGL_Ammo = "357"
att.UBGL_RPM = 60 / 0.079
att.UBGL_Recoil = 1
att.UBGL_RecoilSide = 1
att.UBGL_RecoilRise = 0
att.UBGL_Capacity = 7

att.Hook_ShouldNotSight = function(wep)
    return true
end

local function Ammo(wep)
    return wep.Owner:GetAmmoCount("357") -- att.UBGL_Ammo
end

att.Hook_Think = function(wep)
    if wep:GetMW2Masterkey_ShellInsertTime() < CurTime() and wep:GetMW2Masterkey_ShellInsertTime() != 0 then
        wep:SetMW2Masterkey_ShellInsertTime(0)
        local clip = 7
        if wep:Clip2() >= clip then return end
        if Ammo(wep) <= 0 then return end

        local reserve = Ammo(wep)
        reserve = reserve + wep:Clip2()
        local load = math.Clamp(clip, 0, reserve)
        wep.Owner:SetAmmo(reserve - load, "357")
        wep:SetClip2(load)
    end

    if !IsFirstTimePredicted() then return end
    if wep:GetOwner():KeyPressed(IN_RELOAD) then
        wep:SetInUBGL(false)
        wep:ReloadUBGL()
    elseif wep:GetOwner():KeyPressed(IN_ATTACK) then
        wep:SetInUBGL(false)
    elseif wep:GetOwner():KeyPressed(IN_ATTACK2) then
        wep:SetInUBGL(true)
        wep:ShootUBGL()
    end
end

local awesomelist = {
    ["sprint_in_akimbo_right"] = {
        time = 10/30,
        anim = "sprint_in",
    },
    ["sprint_out_akimbo_right"] = {
        time = 10/30,
        anim = "sprint_out",
    },
    ["sprint_loop_akimbo_right"] = {
        time = 30/40,
        anim = "sprint_loop",
    },
    ["pullout_akimbo_right"] = {
        time = 26/30 /4,
        anim = "pullout",
    },
    ["putaway_akimbo_right"] = {
        time = 26/30 /4,
        anim = "putaway",
    },
}

att.Hook_TranslateSequence = function(wep, anim)
    if awesomelist[anim] then
        local bab = awesomelist[anim]
        wep:DoLHIKAnimation(bab.anim, bab.time)
    end
end

att.Hook_LHIK_TranslateAnimation = function(wep, anim)
    if anim == "idle" then
        --wep:DoLHIKAnimation("idle", 200/30) This will fucking crash your game because it plays idle when the animation playing is idle WHY DIDNT I CALL IT IDLE_AKIMBO_LEFT WOEISME
        return "DoNotPlayIdle"
    end
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    -- this bitch
    local fixedcone = wep:GetDispersion() / 360 / 60

    wep.Owner:FireBullets({
		Src = wep.Owner:EyePos(),
		Num = 1,
		Damage = 40,
		Force = 1,
		Attacker = wep.Owner,
		Dir = wep.Owner:EyeAngles():Forward(),
		Spread = Vector(fixedcone, fixedcone, 0),
		Callback = function(_, tr, dmg)
			local dist = (tr.HitPos - tr.StartPos):Length() * ArcCW.HUToM

			local dmgmax = 40
			local dmgmin = 20

			local delta = dist / 800 * 0.025

			delta = math.Clamp(delta, 0, 1)

			local amt = Lerp(delta, dmgmax, dmgmin)

			dmg:SetDamage(amt)
		end
	})
    wep:EmitSound("weapons/fesiugmw2/fire/deagle.wav", 130, 115 * math.Rand(1 - 0.05, 1 + 0.05))
                            -- This is kinda important
                                            -- Wep volume
                                                    -- Weapon pitch (along with the pitch randomizer)




    wep:SetClip2(wep:Clip2() - 1)
    
    if wep:Clip2() > 0 then
        wep:DoLHIKAnimation("fire", 16/30)
    else
        wep:DoLHIKAnimation("fire_last", 16/30)
    end

    wep:DoEffects()

    return false
end

att.UBGL_Reload = function(wep, ubgl)
        if wep:Clip2() >= 7 then return end
        if Ammo(wep) <= 0 then return end

    wep:SetInUBGL(false)
    wep:Reload()

    if wep:Clip2() <= 0 then
        wep:DoLHIKAnimation("reload_empty", 63/30)
        wep:SetNextSecondaryFire(CurTime() + 63/30)
        wep:SetMW2Masterkey_ShellInsertTime(CurTime() + 1.429)
        wep:PlaySoundTable({
            {s = "weapons/fesiugmw2/foley/wpfoly_de50_reload_clipout_v1.wav", 	t = 10/30},
            {s = "weapons/fesiugmw2/foley/wpfoly_de50_reload_clipin_v1.wav",  	t = 39/30},
            {s = "weapons/fesiugmw2/foley/wpfoly_de50_reload_chamber_v1.wav", 	t = 48/30},
        })
    else
        wep:DoLHIKAnimation("reload", 59/30)
        wep:SetNextSecondaryFire(CurTime() + 59/30)
        wep:SetMW2Masterkey_ShellInsertTime(CurTime() + 1.429)
        wep:PlaySoundTable({
            {s = "weapons/fesiugmw2/foley/wpfoly_de50_reload_clipout_v1.wav", 	t = 10/30},
            {s = "weapons/fesiugmw2/foley/wpfoly_de50_reload_clipin_v1.wav", 	    t = 39/30},
        })
    end
end

att.Hook_GetHUDData = function( wep, data )
    if ArcCW:ShouldDrawHUDElement("CHudAmmo") then
        data.clip = wep:Clip2() .. " / " .. wep:Clip1()
    else
        data.clip = wep:Clip1() + wep:Clip2()
    end
    data.ubgl = nil
    return data
end
--lua/arccw/shared/attachments/mw2_akimbo_m1887.lua:
return gluapack()()
--lua/arccw/shared/attachments/mw2_akimbo_m93r.lua:
att.PrintName = "M93 Raffica"
att.Icon = Material("entities/acwatt_mw2_akimbo.png", "smooth")
att.Description = "Wholy."
att.Hidden = true
att.Desc_Pros = {
    "+100% more gun",
}
att.Desc_Cons = {
    "- Cannot use ironsights"
}
att.Desc_Neutrals = {
    "Don't toggle the UBGL"
}
att.AutoStats = true
att.Mult_HipDispersion = 4
att.Slot = "akimbotest"

att.GivesFlags = {"cantuseshitinakimboyet"}

att.SortOrder = 1738

att.AddSuffix = " + M93R"

att.MountPositionOverride = 0

att.Model = "models/weapons/arccw/fesiugmw2/akimbo/c_beretta393_left_2.mdl"

att.LHIK = true
att.LHIK_Animation = true
att.LHIK_MovementMult = 0

att.UBGL = true

att.UBGL_PrintName = "AKIMBO"
att.UBGL_Automatic = true
att.UBGL_MuzzleEffect = "muzzleflash_4"
att.UBGL_ClipSize = 20
att.UBGL_Ammo = "pistol"
att.UBGL_RPM = 60 / 0.064
att.UBGL_Recoil = .45
att.UBGL_RecoilSide = .55
att.UBGL_RecoilRise = .25
att.UBGL_Capacity = 20

local burstcount = 0
local burstlength = 3

att.Hook_ShouldNotSight = function(wep)
    return true
end

att.Hook_Think = function(wep)
    if !IsFirstTimePredicted() then return end
    if wep:GetOwner():KeyPressed(IN_RELOAD) then
        wep:SetInUBGL(false)
        wep:ReloadUBGL()
    elseif wep:GetOwner():KeyPressed(IN_ATTACK) then
        wep:SetInUBGL(true)
        wep:ShootUBGL()
    elseif wep:GetOwner():KeyReleased(IN_ATTACK) then
        local postburst = 0.1

        if (CurTime() + postburst) > wep:GetNextSecondaryFire() then
        wep:SetNextSecondaryFire(CurTime() + postburst) end
    elseif wep:GetOwner():KeyPressed(IN_ATTACK2) then
        wep:SetInUBGL(false)
    end

    if wep:Clip2() > 0 then
        if burstcount > 0 then
            wep:ShootUBGL()
        end
    
    end

        if burstcount == burstlength then
            att.UBGL_Automatic = false
            burstcount = 0
        end

end

att.Hook_TranslateSequence = function(wep, anim)
    local awesome-- = wep:GetAnimKeyTime(anim)

    -- i fucking hate it! i really do why the fuck it so nastyy
    -- need to find a way to fix this disaster

    
    if anim == "sprint_in_akimbo_right" or anim == "sprint_out_akimbo_right" or anim == "sprint_loop_akimbo_right" or anim == "pullout_akimbo_right" or anim == "putaway_akimbo_right" then
        if anim == "sprint_in_akimbo_right" then
            awesome = 11/30
            playanim = "sprint_in"
        elseif anim == "sprint_out_akimbo_right" then
            awesome = 11/30
            playanim = "sprint_out"
        elseif anim == "sprint_loop_akimbo_right" then
            awesome = 31/40
            playanim = "sprint_loop"
        elseif anim == "pullout_akimbo_right" then
            awesome = 26/30 /4
            playanim = "pullout"
        elseif anim == "putaway_akimbo_right" then
            awesome = 26/30 /4
            playanim = "putaway"
        end
            wep:DoLHIKAnimation(playanim, awesome)
    end
end

att.Hook_LHIK_TranslateAnimation = function(wep, anim)
    if anim == "idle" and wep:Clip2() <= 0 then
        return "idle_empty"
    end
end

local function Ammo(wep)
    return wep.Owner:GetAmmoCount("pistol") -- att.UBGL_Ammo
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    -- this bitch
    local fixedcone = wep:GetDispersion() / 360 / 60

    wep.Owner:FireBullets({
		Src = wep.Owner:EyePos(),
		Num = 1,
		Damage = 40,
		Force = 1,
		Attacker = wep.Owner,
		Dir = wep.Owner:EyeAngles():Forward(),
		Spread = Vector(fixedcone, fixedcone, 0),
		Callback = function(_, tr, dmg)
			local dist = (tr.HitPos - tr.StartPos):Length() * ArcCW.HUToM

			local dmgmax = 40
			local dmgmin = 20

			local delta = dist / 800 * 0.025

			delta = math.Clamp(delta, 0, 1)

			local amt = Lerp(delta, dmgmax, dmgmin)

			dmg:SetDamage(amt)
		end
	})
    wep:EmitSound("weapons/fesiugmw2/fire/m9.wav", 110, 100 * math.Rand(1 - 0.05, 1 + 0.05))
                            -- This is kinda important
                                            -- Wep volume
                                                    -- Weapon pitch (along with the pitch randomizer)




    wep:SetClip2(wep:Clip2() - 1)

    if IsFirstTimePredicted() then
        burstcount = burstcount + 1
    end
    
    if wep:Clip2() > 0 then
        wep:DoLHIKAnimation("fire", 6/30)
    else
        wep:DoLHIKAnimation("fire_last", 6/30)
    end

    wep:DoEffects()
end

att.UBGL_Reload = function(wep, ubgl)
        if wep:Clip2() >= 15 then return end
        if Ammo(wep) <= 0 then return end

    wep:SetInUBGL(false)
    wep:Reload()

    local clip = 20

    if wep:Clip2() >= clip then return end -- att.UBGL_Capacity

    if Ammo(wep) <= 0 then return end

    burstcount = 0

    if wep:Clip2() <= 0 then
        wep:DoLHIKAnimation("reload_empty", 89/40)
        wep:SetNextSecondaryFire(CurTime() + 89/40)
        wep:PlaySoundTable({
            {s = "weapons/fesiugmw2/foley/wpfoly_beretta9mm_reload_clipout_v2.wav", 	t = 4/40},
            {s = "weapons/fesiugmw2/foley/wpfoly_beretta9mm_reload_clipin_v2.wav",  	t = 42/40},
            {s = "weapons/fesiugmw2/foley/wpfoly_beretta9mm_reload_chamber_v2.wav", 	t = 67/40},
        })
    else
        wep:DoLHIKAnimation("reload", 70/40)
        wep:SetNextSecondaryFire(CurTime() + 70/40)
        wep:PlaySoundTable({
            {s = "weapons/fesiugmw2/foley/wpfoly_beretta9mm_reload_clipout_v2.wav", 	t = 4/40},
            {s = "weapons/fesiugmw2/foley/wpfoly_beretta9mm_reload_clipin_v2.wav", 	    t = 36/40},
        })
    end

    local reserve = Ammo(wep)

    reserve = reserve + wep:Clip2()

    local load = math.Clamp(clip, 0, reserve)

    wep.Owner:SetAmmo(reserve - load, "pistol") -- att.UBGL_Ammo

    wep:SetClip2(load)
end

att.Hook_GetHUDData = function( wep, data )
    if ArcCW:ShouldDrawHUDElement("CHudAmmo") then
        data.clip = wep:Clip2() .. " / " .. wep:Clip1()
    else
        data.clip = wep:Clip1() + wep:Clip2()
    end
    data.ubgl = nil
    return data
end
--lua/arccw/shared/attachments/mw2_wepcamo_urban.lua:
att.PrintName = "Urban"
att.Icon = Material("entities/mw2_wepcamo_urban.png", "smooth"
)
att.Description = "Red urban camouflage finish."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Slot = "mw2_wepcamo"
att.Free = true

att.ActivateElements = {"wepcamo-urban"}

att.SortOrder = 5 *-1
--lua/arccw/shared/attachments/mw2_wepcamo_whiteout.lua:
att.PrintName = "Whiteout"
att.Icon = Material("entities/mw2_wepcamo_whiteout.png", "smooth"
)
att.Description = "Pure white paint finish.\nUnofficial."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Slot = "mw2_wepcamo"
att.Free = true

att.ActivateElements = {"wepcamo-whiteout"}

att.SortOrder = 9 *-1
--lua/arccw/shared/attachments/optic_mw2_acog.lua:
return gluapack()()
--lua/arccw/shared/attachments/optic_mw2_mp5krearsight.lua:
att.PrintName = "Rearsight"
att.Icon = Material("entities/acwatt_optic_mw2_mp5krearsight.png", "smooth")
att.Description = "Alternative set of ironsights. Well, the addition of some."

att.SortOrder = 100

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "mw2_steyrrearsight"
att.MountPositionOverride = 0

att.Model = "models/weapons/arccw/fesiugmw2/atts/scopes/mp5k_rearsight_1.mdl"

att.AdditionalSights = {
    {
        Pos = Vector(0, 6.026, -0.5),
        Ang = Angle(0.8, 0, 0),
        ViewModelFOV = 65 / 1.3,
        Magnification = 1.3,
        IgnoreExtra = true
    },
}

att.ModelOffset = Vector(-0.5, 0, -0.4)
att.ModelScale  = Vector(0.9, 0.9, 0.9)

att.Holosight = false
--lua/arccw/shared/attachments/perk_fmj.lua:
att.PrintName = "FMJ"
att.Icon = Material("entities/acwatt_perk_fmj.png", "smooth")
att.Hidden = true
att.Desc_Cons = {
	"Increased muzzle flash",
}
att.Description = "Increased bullet penetration."
att.AutoStats = true
att.Ignore = false
att.Slot = "perk"

att.Mult_Penetration = 2
att.Override_MuzzleEffect = "muzzleflash_pistol_deagle"
--lua/arccw/shared/attachments/uc_40mm_caseless.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_40mm_caseless.lua:
att.PrintName = "40mm Caseless Grenades"
att.AbbrevName = "Caseless"
att.Icon = Material("entities/att/arccw_uc_40mm_caseless.png", "mips smooth")
att.Description = "Russian caseless VOG-25 grenades converted for use in regular tubes.\nWithout the need to remove an empty case, these can be reloaded faster; but the caseless design also means less propellant and less explosive power."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_40mm"

att.AutoStats = true

att.Mult_ReloadTime = 0.78
att.Mult_MuzzleVelocity = 0.85
att.Mult_Damage = 0.75
att.Mult_DamageMin = 0.75

att.Mult_ShootPitch = 1.1

att.ActivateElements = {"40mm_caseless"}

att.Hook_SelectReloadAnimation = function(wep, anim)
    return anim .. "_caseless"
end
--lua/arccw/shared/attachments/uc_40mm_incendiary.lua:
att.PrintName = "40mm Incendiary Grenades" -- trol
att.AbbrevName = "Incendiary"
att.Icon = Material("entities/att/arccw_uc_40mm_generic.png", "mips smooth")
att.Description = "Hand-made grenades loaded with a fuel mixture that disperses on impact, burning an area over time."
att.Desc_Pros = {
    "uc.40mm.incendiary"
}
att.Desc_Cons = {
    "uc.40mm.mindmg"
}
att.Desc_Neutrals = {
}
att.Slot = "uc_40mm"

att.AutoStats = true

att.Override_ShootEntity = "arccw_uc_40mm_incendiary"

--att.Mult_Recoil = 1

att.ActivateElements = {"40mm_incendiary"}
--lua/arccw/shared/attachments/uc_ammo_ap.lua:
att.PrintName = "\"AP\" Armor-piercing Rounds"
att.AbbrevName = "\"AP\" Armor-piercing"
att.SortOrder = 5
att.Icon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth")
att.Description = "Bullets designed to penetrate body armor, usually built around a penetrator of hardened steel, tungsten, or tungsten carbide.\nUpon impact on a hard target, the case is destroyed, but the penetrator continues its motion and penetrates the target."
att.Desc_Pros = {
    "uc.api.1",
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_ammo"

att.AutoStats = true

att.Mult_Range = 2
att.Mult_Penetration = 2

att.Mult_Damage = 0.9
att.Mult_DamageMin = 0.9

att.Hook_Compatible = function(wep)
    if wep:GetIsShotgun() then
        return false
    end
end

local cov = GetConVar("arccw_uc_apobjmult")
local metalMats = { -- it's actually the good type
    [77] = true,
}
att.Hook_BulletHit = function(wep,data)
    local ent = data.tr.Entity
    if IsValid(ent) and (metalMats[data.tr.MatType] or !(ent:IsNPC() or ent:IsPlayer() or ent:IsNextBot())) then
        data.damage = data.damage * cov:GetFloat()
        local eff = EffectData()
        eff:SetOrigin(data.tr.HitPos)
        util.Effect("cball_bounce", eff)
    end
end

--lua/arccw/shared/attachments/uc_ammo_jhp.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_ammo_sg_bird.lua:
att.PrintName = "\"BIRD\" #9 Birdshot"

att.SortOrder = 4
att.Icon = Material("entities/att/arccw_uc_ammo_shotgun_generic.png", "mips smooth")
att.Description = [[Hunting rounds with a wide spread and a very large number of pellets, designed to shoot birds out of the sky.
While not as lethal as buckshot, the loose clump spread makes it easier to hit small or multiple targets.]]
att.Desc_Pros = {
    "uc.pellet.2x"
}
att.Desc_Cons = {
    "uc.accuracy.20"
}
att.Desc_Neutrals = {
}
att.Slot = {"ud_ammo_shotgun", "uc_ammo"}

att.AutoStats = true

att.Mult_Num = 2
att.Mult_Damage = 0.85
att.Mult_DamageMin = 0.85
att.Mult_Recoil = 0.8

att.Add_AccuracyMOA = 20

att.Mult_HullSize = 0.1

att.Override_UC_ShellColor = Color(0.4 * 255, 0.6 * 255, 0.8 * 255)

att.Hook_Compatible = function(wep)
    if !wep:GetIsShotgun() or wep:GetBuff_Override("UC_Shotshell") then
        return false
    end
end
--lua/arccw/shared/attachments/uc_ammo_sg_frag.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_charm_urbancharm.lua:
att.PrintName = "Urban Charm"
att.Description = "The icon of a Garry's Mod addon."

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "charm"

att.Free = true

att.Model = "models/weapons/arccw/atts/charmbase.mdl"

att.DroppedModel = "models/Items/BoxSRounds.mdl"

att.Charm = true
att.CharmModel = "models/weapons/arccw/atts/uc_urbancharm.mdl"
att.CharmAtt = "Charm"
att.CharmScale = Vector(0.5, 0.5, 0.5)
att.CharmOffset = Vector(0, -1.1, -0.2)
att.CharmAngle = Angle(20, 0, 80)
att.CharmSkin = 0

att.Ignore = true --Toggles need to be done

att.ToggleLockDefault = true
att.ToggleStats = {
    {
        PrintName = "Common",
        CharmSkin = 0,
    },
    {
        PrintName = "Decay",
        CharmSkin = 1,
    },
    {
        PrintName = "Renewal",
        CharmSkin = 2,
    },
    {
        PrintName = "Anarchy",
        CharmSkin = 3,
    },
    {
        PrintName = "Ordinance",
        CharmSkin = 4,
    }
}

--lua/arccw/shared/attachments/uc_choke_cyl.lua:
att.PrintName = "Cylinder Choke"

att.Icon = nil -- Material("entities/att/acwatt_lowpolysaiga12extmag.png", "smooth mips")
att.Description = "A mildly tight shotgun choke. Tightens pellet spread at the cost of straight recoil."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"choke","muzzle"}
att.AutoStats = true

att.Hook_Compatible = function(wep)
    if !wep:GetIsShotgun() then
        return false
    end
end

att.Mult_Recoil = 1.1
att.Mult_AccuracyMOA = .9
--lua/arccw/shared/attachments/uc_choke_wide.lua:
att.PrintName = "Wide Choke"

att.Icon = nil -- Material("entities/att/acwatt_lowpolysaiga12extmag.png", "smooth mips")
att.Description = "A loose choke that widens pellet spread, potentailly making targets easier to hit."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"choke","muzzle"}
att.AutoStats = true

att.Hook_Compatible = function(wep)
    if !wep:GetIsShotgun() then
        return false
    end
end

att.Mult_Recoil = 0.75
att.Mult_AccuracyMOA = 1.25
--lua/arccw/shared/attachments/uc_fg_deeprifling.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_fg_dualstage.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_fg_light.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_fg_lubedparts.lua:
att.PrintName = "UD-40 Coating"

att.Icon = Material("entities/att/arccw_uc_lubedparts.png", "mips smooth")
att.Description = "Liberal use of a special lubricant greatly reduces the likelihood of jams and other malfuntions."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_fg"
att.AutoStats = true
att.SortOrder = 3

att.HideIfBlocked = true

att.Mult_MalfunctionMean = 2

--[[]
att.Hook_Compatible = function(wep)
    if wep:GetIsManualAction() then
        return false
    end
end
]]

att.AttachSound = "arccw_uc/common/gunsmith/internal_modification.ogg"

att.GivesFlags = {"technician"}
att.ExcludeFlags = {"lubedparts"}

--lua/arccw/shared/attachments/uc_grip_bcmvfg.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_muzzle_fhider1.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_muzzle_supp_tac.lua:
att.PrintName = "Mountain Armory Tactical Suppressor" -- fictional
att.AbbrevName = "Tactical Suppressor"
att.Icon = Material("entities/att/acwatt_uc_muzzle_supp_tactical.png", "mips smooth")
att.Description = "Traps propellant gas from the muzzle, reducing visual and audible report.\nLow-profile and enhances ballistics, but slightly cumbersome."
att.Desc_Neutrals = {"uc.exclusive.rifle", "uc.supptail"}

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/weapons/arccw/atts/ud_silencer_tactical.mdl"
att.ModelOffset = Vector(2.25, 0, 0)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = true
att.Override_MuzzleEffect = "muzzleflash_suppressed"
att.IsMuzzleDevice = true

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 0.75
att.Mult_Range = 1.1

att.Add_BarrelLength = 4
att.Mult_SightTime = 1.07
att.Mult_Sway = 1.15

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"

att.Hook_Compatible = function(wep,data)
    if !ArcCW.UC.RifleAmmoTypes[wep:GetBuff_Override("Override_Ammo", wep.Primary.Ammo)] then
        return false
    end
end

att.Hook_GetDistantShootSound = function(wep, distancesound)
    if wep:GetBuff("PhysBulletMuzzleVelocity") < ArcCW.UC.SubsonicThreshold then
        return false
    end
end
--lua/arccw/shared/attachments/uc_optic_annihilator.lua:
att.PrintName = "Annihilator Handcannon Laser"
att.AbbrevName = "Annihilator Laser"
att.Icon = Material("entities/att/acwatt_uc_optic_annihilator.png", "mips smooth")
att.Description = "Oversized laser module with iron sights, attached on the upper rail."
att.Desc_Cons = {
    "con.beam"
}
att.AutoStats = true

att.Slot = {"ur_deagle_tritium"} -- Deagle exclusive until we figure out the problem with the model
att.SortOrder = 998 -- Remove when att becomes universal

att.Model = "models/weapons/arccw/atts/ur_annihilator_laser.mdl"
att.ModelOffset = Vector(-6,0,-3.5) -- Will need to change when the model recompiles
att.ModelScale = Vector( 0.933, 0.933, 0.933 )

att.Mult_Sway = 1.5
att.Mult_SightTime = 1.25
att.Mult_SpeedMult = 0.975

att.AdditionalSights = {
    {
        Pos = Vector(0, 20, -1.62),
        Ang = Angle(-.2, 0, 0),
        Magnification = 1,
    }
}

att.LaserStrength = 2
att.ToggleStats = {
    {
        PrintName = "On",
        Laser = true,
        LaserBone = "laser",
        LaserColor = Color(50, 255, 50),
        Mult_HipDispersion = 0.75,
        Mult_MoveDispersion = 0.6,
        Mult_SightTime = 0.85
    },
    {
        PrintName = "Off",
        Laser = false,
    },
}
--lua/arccw/shared/attachments/uc_optic_eotech552.lua:
att.PrintName = "EOTech 552 (HOLO)"
att.Icon = Material("entities/att/acwatt_uc_optic_eotech552.png", "mips smooth")
att.Description = "Improves target acquisition with a highly precise circle-dot holographic reticle, while adding minimal extra weight."

att.SortOrder = 1

att.Desc_Pros = {
    "autostat.holosight",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/weapons/arccw/atts/uc_eotech552.mdl"
att.ModelOffset = Vector(-0.5, 0, 0)
att.ModelScale = Vector(0.67, 0.67, 0.67)

att.AdditionalSights = {
    {
        Pos = Vector(0, 9, -1.38),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ScrollFunc = ArcCW.SCROLL_NONE
    }
}

att.Holosight = true
att.HolosightReticle = Material("hud/reticles/ud_holo.png", "smooth")
att.HolosightSize = 1.1
att.HolosightBone = "holosight"
att.HolosightNoFlare = true

att.Colorable = true

att.Mult_SightedSpeedMult = 0.9
--lua/arccw/shared/attachments/uc_optic_micro_t1.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_optic_vortex_3x.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_powder_overpressure.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_tp_gang.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_870_barrel_long.lua:
att.PrintName = "Express-12 30\" Long Barrel"
att.AbbrevName = "30\" Long Barrel"

if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Remington 870 30\" Wingmaster Barrel"
    att.AbbrevName = "30\" Wingmaster Barrel"
end

att.Icon = Material("entities/att/acwatt_ud_870_barrel_long.png", "smooth mips")
att.Description = "Extended, unwieldy barrel. Reduces pellet spread and improves range."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ud_870_barrel"

att.AutoStats = true

att.Mult_AccuracyMOA = 0.8
att.Mult_Recoil = 0.8
att.Mult_Range = 1.2

att.Mult_Sway = 1.5
att.Mult_SightTime = 1.25
att.Mult_SpeedMult = 0.95

att.Mult_HipDispersion = 1.25

att.Add_BarrelLength = 4

att.ActivateElements = {"ud_870_barrel_long"}
--lua/arccw/shared/attachments/ud_870_stock_sawnoff.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_870_tube_ext.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_glock_caliber_45acp.lua:
att.PrintName = "Glock .45 ACP Conversion"
att.AbbrevName = ".45 ACP"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "GEN3 .45 ACP Conversion"
end

att.SortOrder = 70
att.Icon = Material("entities/att/uc_bullets/45acp.png", "smooth mips")
att.Description = "A venerable caliber with excellent close-range stopping power.\nBecause of the large bullet diameter, magazine capacity is significantly reduced."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ud_glock_caliber"

att.AutoStats = true

att.Override_Trivia_Calibre = ".45 ACP"

att.Mult_Damage = ArcCW.UC.CalConv("9mm", "45acp", "max")
att.Mult_DamageMin = ArcCW.UC.CalConv("9mm", "45acp", "min")
att.Mult_Penetration = ArcCW.UC.CalConv("9mm", "45acp", "pen")

att.Mult_RangeMin = 0.5
att.Mult_Recoil = 1.5
att.Mult_RecoilSide = 1.5
att.Mult_MalfunctionMean = 0.6

att.Override_PhysBulletMuzzleVelocity = 320

att.Mult_ClipSize = 0.76

att.Mult_RPM = 0.7619

local path = ")weapons/arccw_ud/glock/"
local common = ")/arccw_uc/common/"
local tail = common .. "45acp/"
local fire45 = {path .. "fire-45-01.ogg",path .. "fire-45-02.ogg",path .. "fire-45-03.ogg",path .. "fire-45-04.ogg",path .. "fire-45-05.ogg",path .. "fire-45-06.ogg"}
local fire45sup =  {path .. "fire-45-sup-01.ogg",path .. "fire-45-sup-02.ogg",path .. "fire-45-sup-03.ogg",path .. "fire-45-sup-04.ogg",path .. "fire-45-sup-05.ogg",path .. "fire-45-sup-06.ogg"}
local fire45dist = {tail .. "fire-dist-45acp-pistol-ext-01.ogg",tail .. "fire-dist-45acp-pistol-ext-02.ogg",tail .. "fire-dist-45acp-pistol-ext-03.ogg",tail .. "fire-dist-45acp-pistol-ext-04.ogg",tail .. "fire-dist-45acp-pistol-ext-05.ogg",tail .. "fire-dist-45acp-pistol-ext-06.ogg"}
local fire45distint = {common .. "fire-dist-int-pistol-heavy-01.ogg", common .. "fire-dist-int-pistol-heavy-02.ogg", common .. "fire-dist-int-pistol-heavy-03.ogg", common .. "fire-dist-int-pistol-heavy-04.ogg", common .. "fire-dist-int-pistol-heavy-05.ogg", common .. "fire-dist-int-pistol-heavy-06.ogg"}

att.Hook_GetShootSound = function(wep, sound)
    if wep:GetBuff_Override("Silencer") then
        return fire45sup
    else
        return fire45
    end
end


att.Hook_GetDistantShootSoundOutdoors = function(wep, distancesound)
    if wep:GetBuff_Override("Silencer") then
        -- fallback to script
    else
        return fire45dist
    end
end


att.Hook_GetDistantShootSoundIndoors = function(wep, distancesound)
    if wep:GetBuff_Override("Silencer") then
        -- fallback to script
    else
        return fire45distint
    end
end

att.GivesFlags = {"cal_subsonic"}
att.ExcludeFlags = {"powder_subsonic"}

--lua/arccw/shared/attachments/ud_glock_frame_flared.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_glock_muzzle_kkm.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_glock_slide_auto.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m16_fs_kac.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m16_fs_sclr.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m16_mag_40.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m16_mag_50beo_15.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m16_receiver_50beo.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m16_receiver_9mm.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m16_receiver_altburst.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m16_rs_3d.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m16_stock_carbine.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m16_stock_ru556.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_mini14_barrel_stub.lua:
att.PrintName = "Mini-14 15\" Stub Barrel"
att.AbbrevName = "15\" Stub Barrel"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Patriot 809 15\" Stub Barrel"
end

att.Icon = Material("entities/att/acwatt_ud_mini14_barrel_stub.png", "smooth mips")
att.SortOrder = 15
att.Description = "No, using your hacksaw on the barrel is not gunsmithing."
att.Desc_Pros = {
}
att.Desc_Cons = {
    "uc.nofs",
    "uc.nomuzzle",
}
att.Desc_Neutrals = {
}
att.Slot = "ud_mini14_barrel"

att.Mult_SightTime = 0.65
att.Mult_Recoil = 1.25
att.Mult_AccuracyMOA = 3
att.Mult_Range = 0.25
att.Mult_Sway = 0.5
att.Mult_SightedSpeedMult = 1.25

att.Add_BarrelLength = -8

att.AutoStats = true

att.GivesFlags = {"nomuzzle"}

att.A_Hook_Add_SightsDispersion = function(wep, data)
    if data and !wep.Attachments[1].Installed then
        data.add = data.add + 50
    end
end
--lua/arccw/shared/attachments/ud_mini14_mag_30_762.lua:
att.PrintName = "Mini-30 7.62x39mm 30-Round Extended Mag"
att.AbbrevName = "30-Round Extended Mag"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Patriot 816 7.62x39mm 30-Round Extended Mag"
end

att.SortOrder = 30
att.Icon = Material("entities/att/acwatt_ud_mini14_mag_30_762.png", "smooth mips")
att.Description = "Effectively an AK magazine with a modified feeding lip, this magazine is proof of gun hobbyists' dedication (and lunacy) in search of more dakka."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ud_mini14_mag"

att.AutoStats = true

att.Mult_SightTime = 1.15
att.Mult_ReloadTime = 1.2
att.Override_ClipSize = 30
att.Mult_Sway = 1.5
att.Mult_ShootSpeedMult = 0.95

att.Mult_MalfunctionMean = 0.75

att.ActivateElements = {"ud_mini14_mag_30_762"}
att.RequireFlags = {"mini14_762"}
att.HideIfBlocked = true

att.Hook_SelectReloadAnimation = function(wep, anim)
    return anim .. "_762"
end
--lua/arccw/shared/attachments/ud_mini14_stock_tactical.lua:
att.PrintName = "Mini-14 GB Folding Stock"
att.AbbrevName = "Folding Stock"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Patriot 812 Folding Stock"
end

att.Icon = Material("entities/att/acwatt_ud_mini14_stock_tactical_wood.png", "smooth mips")
att.Description = "Chassis replacement installed with both a pistol grip and exotic folding stock to improve deployment and movement speed; the stock, however, is rather unwieldy due to its shape."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ud_mini14_stock"

att.AutoStats = true

att.Mult_SightTime = 0.9
att.Mult_SpeedMult = 1.15
att.Mult_SightedSpeedMult = 1.1
att.Mult_DrawTime = 0.7
att.Mult_HolsterTime = 0.7

att.Mult_Recoil = 1.2
att.Mult_Sway = 1.5

-- att.Add_BarrelLength = 32

att.ActivateElements = {"ud_mini14_stock_tactical"}

att.Ignore = false
--lua/arccw/shared/attachments/ud_uzi_cal_22.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_1911_grip_snake.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_1911_skin_nickel.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_1911_slide_compact.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_1911_slide_m45_custom.lua:
att.PrintName = "M45 MEUSOC 5\" Slide w/ Custom Finish"
att.AbbrevName = "5\" M45 Slide (Custom)"
att.Icon = Material("entities/att/ur_1911/slide_45.png","mips smooth")
att.Description = "Modernized slide, hammer and trigger assembly designed and hand-built for the U.S. Marine Corps, bringing an old gun to a new age.\nImproves handling and ballistics, but is worse when hip fired.\n\nThis variant will use your configured custom color for that extra flair."

att.Desc_Neutrals = {
    "uc.custcolor",
}

att.AutoStats = true
att.Slot = "ur_m1911_slide"
att.SortOrder = 5
att.InvAtt = "ur_1911_slide_m45"

att.Mult_RPM = 1.05
att.Mult_SightTime = 0.9
att.Mult_AccuracyMOA = 0.8
att.Mult_RangeMin = 1.5

att.Mult_HipDispersion = 1.25
--lua/arccw/shared/attachments/ur_329_caliber_snakeshot.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_barrel_krinkov.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_hg_alpha.lua:
att.PrintName = "AK Zenitco Aluminum Handguard"
att.AbbrevName = "Aluminum Handguard"
if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "KF Aluminum Handguard"
end
att.Icon = Material("entities/att/ur_ak/handguards/alpha.png", "mips smooth")
att.Description = "Fancy Russian-made handguard featuring a rail interface for additional modularity. Especially lightweight, though less comfortable to grip."
att.Slot = {"ur_ak_hg"}
att.AutoStats = true

--att.Desc_Neutrals = {"uc.cosmetic"} nvm
att.SortOrder = 15.9

att.Mult_Sway = 1.15
att.Mult_SightedSpeedMult = 1.15
-- att.Mult_SpeedMult = 1.05
att.Mult_Recoil = 1.08

att.GivesFlags = {"ak_railedguard","nodong"}
att.ActivateElements = {"barrel_alpha"}

att.LHIK = true

att.ModelOffset = Vector(-22, -3.4, 3.3)
att.OffsetAng = Angle(5, 0, 0)
att.Model = "models/weapons/arccw/ak_lhik_u.mdl"
--lua/arccw/shared/attachments/ur_ak_hg_dong.lua:
att.PrintName = "\"Romanian Dong\" Integral Foregrip"
att.AbbrevName = "Dong Foregrip"
att.Icon = Material("entities/att/ur_ak/dong.png", "mips smooth")
att.Description = "Romanian lower handguard design, shaped into an integrated foregrip."
att.Slot = {"ur_ak_hg"}
att.Desc_Cons = {"uc.noubs"}
att.AutoStats = true

att.SortOrder = 16

att.Mult_Recoil = .82
att.Mult_SightTime = 1.12
att.Mult_MoveDispersion = 1.25

att.ActivateElements = {"barrel_dong"}
att.GivesFlags = {"ak_noubs"}

att.LHIK = true

att.ModelOffset = Vector(-23, -2.6, 3.8)
att.Model = "models/weapons/arccw/ak_lhik_dong.mdl"

att.Override_HoldtypeActive = "smg"
--lua/arccw/shared/attachments/ur_ak_mag_545_black.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_mag_762_10.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_stock_ak74m.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_stock_none.lua:
att.PrintName = "No Stock"
att.Icon = Material("arccw/hud/atts/default.png", "mips smooth")
att.Description = "You see Ivan, when take buttstock off rifle, you stronger than recoil for fear of hitting face."
-- att.Description = "Buttstock? What are you, Western capitalist WEAKLING? Real comrades channel strength of Siberian bear and shoot Kalashnikov without stock; withstand kick harder than 20 bottles of vodka."
att.Slot = {"ur_ak_stock"}
att.AutoStats = true
att.Free = true

att.SortOrder = -1

att.Mult_SightTime = 0.5
att.Mult_DrawTime = 0.6
att.Mult_HolsterTime = 0.6
att.Mult_Recoil = 1.65
att.Mult_RecoilSide = 1.95
att.Mult_SightedSpeedMult = 1.25
att.Mult_SpeedMult = 1.1
att.Mult_ShootSpeedMult = 1.15
att.Add_BarrelLength = -9
att.Mult_Sway = 3

att.ActivateElements = {"stock_none"}
--lua/arccw/shared/attachments/ur_ak_stock_skeletal.lua:
att.PrintName = "Skeletal Stock"
att.Icon = Material("entities/att/ur_ak/stock/saiga.png", "mips smooth")
att.Description = [[Lightens the weapon by reducing mass in the stock. Unlike other skeletal stocks for this platform, this stock cannot be folded.]]
att.AutoStats = true
att.Slot = {"ur_ak_stock"}

att.SortOrder = 2

att.Mult_SightTime = .8
att.Mult_SightedSpeedMult = 1.1
att.Mult_SpeedMult = 1.05

att.Mult_Sway = 1.1
att.Mult_Recoil = 1.35
att.Mult_RecoilSide = 1.15

att.ActivateElements = {"stock_skeletal"}

att.Ignore = true
att.Icon = Material("entities/att/obsolete.png", "mips smooth")
att.Description = "stop looking at deprecated shit you suka"
--lua/arccw/shared/attachments/ur_aw_barrel_sd.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_aw_barrel_short.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_aw_mag_10.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_aw_stock_ru_rubber.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_dbs_barrel_sawedoff.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_dbs_fg_extractor.lua:
att.PrintName = "Custom Extractor"
att.Icon = nil--Material("entities/att/acwatt_ur_dbs_tp_doom.png", "smooth mips")
att.Description = "Install a heavy aftermarket extractor to speeden reloads."
att.Desc_Pros = {
    "Speeds up reloads"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_db_fg"

att.AutoStats = true
att.SortOrder = 999

att.Mult_SightTime = 1.14
att.Mult_MoveSpeed = 0.92

att.Hook_SelectReloadAnimation = function(wep, anim)
    return anim .. "_extractor"
end

att.AttachSound = "arccw_uc/common/gunsmith/internal_modification.ogg"
--lua/arccw/shared/attachments/ur_g3_barrel_26.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_g3_mag_10.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_mp5_barrel_long.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_mp5_barrel_sword.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_mp5_barrel_sword.lua:
att.PrintName = "9\" Swordfish Upper"

att.Icon = Material("entities/att/ur_mp5/upper_fish.png", "smooth mips")
att.Description = "Aftermarket upper receiver that aggressively counters recoil using an integrated compensator. The added weight makes the weapon harder to aim with."
att.Desc_Cons = {
    "uc.nomuzzle"
}
att.AutoStats = true

att.Slot = "ur_mp5_barrel"

att.SortOrder = 9

att.Mult_Recoil = 0.7

att.Mult_SightedSpeedMult = 0.8
att.Mult_SightTime = 1.1
att.Mult_Sway = 1.5
att.Add_BarrelLength = 3

att.Mult_PhysBulletMuzzleVelocity = 1.15

att.Override_IronSightStruct = { 
     Pos = Vector(-3.17, -4, -0.22),
     Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 74,
} 

att.ActivateElements = {"ur_mp5_barrel_swordfish"}
att.GivesFlags = {"barrel_sword"}

--lua/arccw/shared/attachments/ur_mp5_caliber_40sw.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_mp5_mag_40.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_mp5_stock_a2.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_mp5_stock_none.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_mp5_ub_surefire_mlok.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_spas12_barrel_sport.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_spas12_charm_fear.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_spas12_charm_rail.lua:
att.PrintName = "Modern Rail Mount"
--att.Icon = Material("entities/att/aksidemount.png", "smooth mips")
att.Description = "As if this thing wasn't imposing enough."
att.Desc_Neutrals = {
    "uc.cosmetic",
}
att.Icon = Material("entities/att/ur_spas/modernmount.png", "smooth mips")
att.Slot = "ur_spas12_charm"

att.ActivateElements = {"rail_modern"}

att.SortOrder = 998
--addons/[binbon]arccw_modify/lua/arccw/shared/languages/base_en.lua:
L = {}
STL = {}

-- not a translate string, but in case a language needs its own font
L["default_font"] = "Comfortaa"

-- Attachment Slots
L["attslot.optic"] = "Optik"
L["attslot.bkoptic"] = "Yedek Optik"
L["attslot.muzzle"] = "Namlu Ucu"
L["attslot.barrel"] = "Namlu"
L["attslot.choke"] = "Şok Tüpü"
L["attslot.underbarrel"] = "Namlu Altı"
L["attslot.tactical"] = "Taktik"
L["attslot.grip"] = "Kavrama"
L["attslot.stock"] = "Dipçik"
L["attslot.fcg"] = "Ateşleme Grubu"
L["attslot.ammo"] = "Mermi Tipi"
L["attslot.perk"] = "Yetenek"
L["attslot.charm"] = "Tılsım"
L["attslot.skin"] = "Doku"
L["attslot.noatt"] = "Eklenti Yok"
L["attslot.optic.default"] = "Mekanik Nişangah"
L["attslot.muzzle.default"] = "Standart Namlu Ucu"
L["attslot.barrel.default"] = "Standart Namlu"
L["attslot.choke.default"] = "Standart Şok Tüpü"
L["attslot.grip.default"] = "Standart Kavrama"
L["attslot.stock.default"] = "Standart Dipçik"
L["attslot.stock.none"] = "Dipçiksiz"
L["attslot.fcg.default"] = "Standart Ateşleme Grubu"

-- Trivia
L["trivia.class"] = "Sınıf"
L["trivia.year"] = "Yıl"
L["trivia.mechanism"] = "Mekanizma"
L["trivia.calibre"] = "Çap"
L["trivia.ammo"] = "Mermi Tipi"
L["trivia.country"] = "Ülke"
L["trivia.manufacturer"] = "Üretici"
L["trivia.clipsize"] = "Şarjör Kapasitesi"
L["trivia.precision"] = "Hassasiyet"
L["trivia.noise"] = "Gürültü"
L["trivia.recoil"] = "Dikey Geri Tepme"
L["trivia.penetration"] = "Delme Gücü"
L["trivia.firerate"] = "Ateş Hızı"
L["trivia.firerate_burst"] = "Seri Ateş Hızı"
L["trivia.fusetime"] = "Fitil Süresi"

-- Class
L["class.pistol"] = "Tabanca"
L["class.revolver"] = "Revolver"
L["class.machinepistol"] = "Makineli Tabanca"
L["class.smg"] = "Hafif Makineli Tüfek"
L["class.pdw"] = "Kişisel Savunma Silahı"
L["class.shotgun"] = "Pompalı Tüfek"
L["class.assaultcarbine"] = "Saldırı Karabinasi"
L["class.carbine"] = "Karabina"
L["class.assaultrifle"] = "Saldırı Tüfeği"
L["class.rifle"] = "Tüfek"
L["class.battlerifle"] = "Muharebe Tüfeği"
L["class.dmr"] = "Nişancı Tüfeği"
L["class.sniperrifle"] = "Keskin Nişancı Tüfeği"
L["class.antimaterielrifle"] = "Anti-Materyal Tüfeği"
L["class.rocketlauncher"] = "Roketatar"
L["class.grenade"] = "El Bombası"
L["class.melee"] = "Yakın Dövüş Silahı"

-- UI
L["ui.savepreset"] = "Ön Ayarı Kaydet"
L["ui.loadpreset"] = "Ön Ayarı Yükle"
L["ui.stats"] = "İstatistikler"
L["ui.trivia"] = "Bilgiler"
L["ui.tttequip"] = "Ekipman"
L["ui.tttchat"] = "Hızlı Sohbet"
L["ui.position"] = "POZİSYON"
L["ui.positives"] = "OLUMLU YÖNLER:"
L["ui.negatives"] = "OLUMSUZ YÖNLER:"
L["ui.information"] = "BİLGİLER:"

-- İstatistikler
L["stat.stat"] = "İstatistik" -- İstatistik sayfasının ilk satırında kullanılır
L["stat.original"] = "Orijinal"
L["stat.current"] = "Şuanki"
L["stat.damage"] = "Yakın Mesafe Hasarı"
L["stat.damage.tooltip"] = "Bu silahın sıfır mesafede ne kadar hasar verdiği."
L["stat.damagemin"] = "Uzak Mesafe Hasarı"
L["stat.damagemin.tooltip"] = "Bu silahın menzilinin ötesinde ne kadar hasar verdiği."
L["stat.range"] = "Menzil"
L["stat.range.tooltip"] = "Yakın mesafe hasarının uzak mesafe hasarına dönüştüğü mesafe, metre cinsinden."
L["stat.firerate"] = "Ateş Hızı"
L["stat.firerate.tooltip"] = "Bu silahın dakikada kaç mermi attığı."
L["stat.firerate.manual"] = "MANUEL" -- Manuel bir silah olduğunda RPM yerine gösterilir
L["stat.capacity"] = "Kapasite"
L["stat.capacity.tooltip"] = "Bu silahın kaç mermi alabildiği."
L["stat.precision"] = "Hassasiyet"
L["stat.precision.tooltip"] = "Silahın sabit ve nişan alınmışken ne kadar hassas olduğu, yay dakikası cinsinden."
L["stat.hipdisp"] = "Kalçadan Dağılım"
L["stat.hipdisp.tooltip"] = "Silah kalçadan ateşlendiğinde ne kadar hassasiyetsizlik eklendiği."
L["stat.movedisp"] = "Hareket Halinde İsabetlilik"
L["stat.movedisp.tooltip"] = "Silah hareket halindeyken kullanıldığında ne kadar hassasiyetsizlik eklendiği."
L["stat.recoil"] = "Geri Tepme"
L["stat.recoil.tooltip"] = "Her atışta üretilen geri tepme miktarı."
L["stat.recoilside"] = "Yan Geri Tepme"
L["stat.recoilside.tooltip"] = "Her atışta üretilen yatay geri tepme miktarı."
L["stat.sighttime"] = "Kullanım Süresi"
L["stat.sighttime.tooltip"] = "Bu silahla koşudan veya nişangahlardan geçiş yapmak ne kadar sürer."
L["stat.speedmult"] = "Hareket Hızı"
L["stat.speedmult.tooltip"] = "Silahla hareket ettiğiniz hız, orijinal hızın yüzdesi olarak."
L["stat.sightspeed"] = "Nişan Alırken Hız"
L["stat.sightspeed.tooltip"] = "Nişan alırken hareket ettiğinizde uygulanan ek yavaşlama."
L["stat.meleedamage"] = "Vuruş Hasarı"
L["stat.meleedamage.tooltip"] = "Yakın dövüş vuruşunun ne kadar hasar verdiği."
L["stat.meleetime"] = "Vuruş Süresi"
L["stat.meleetime.tooltip"] = "Yakın dövüş vuruşu yapmak için geçen süre."
L["stat.shootvol"] = "Ateş Hacmi"
L["stat.shootvol.tooltip"] = "Silahın ne kadar gürültülü olduğu, desibel cinsinden. Daha gürültülü silahlar daha uzaktan duyulabilir."
L["stat.barrellen"] = "Silah Uzunluğu"
L["stat.barrellen.tooltip"] = "Silahın uzunluğu, Hammer birimleri / inç cinsinden. Uzun namlular duvarlar tarafından daha kolay engellenecektir."
L["stat.pen"] = "Delme"
L["stat.pen.tooltip"] = "Bu silahın ne kadar malzemeyi delebildiği."

-- Otomatik İstatistikler
L["autostat.bipodrecoil"] = "Çatal Ayaklı Geri Tepme"
L["autostat.bipoddisp"] = "Çatal Ayaklı Dağılım"
L["autostat.damage"] = "Yakın Mesafe Hasarı"
L["autostat.damagemin"] = "Uzak Mesafe Hasarı"
L["autostat.damageboth"] = "Hasar" -- Hasar ve uzak mesafe hasarı aynı değerde olduğunda
L["autostat.range"] = "Menzil"
L["autostat.penetration"] = "Delme"
L["autostat.muzzlevel"] = "Namlu Çıkış Hızı"
L["autostat.meleetime"] = "Yakın Dövüş Saldırı Süresi"
L["autostat.meleedamage"] = "Yakın Dövüş Hasarı"
L["autostat.meleerange"] = "Yakın Dövüş Menzili"
L["autostat.recoil"] = "Geri Tepme"
L["autostat.recoilside"] = "Yatay Geri Tepme"
L["autostat.firerate"] = "Ateş Hızı"
L["autostat.precision"] = "Hassasiyetsizlik"
L["autostat.hipdisp"] = "Kalçadan Ateşlemede Dağılım"
L["autostat.sightdisp"] = "Nişan Alırken Dağılım"
L["autostat.movedisp"] = "Hareket Halindeyken Dağılım"
L["autostat.jumpdisp"] = "Havada Dağılım"
L["autostat.barrellength"] = "Silah Uzunluğu"
L["autostat.shootvol"] = "Silah Hacmi"
L["autostat.speedmult"] = "Hareket Hızı"
L["autostat.sightspeed"] = "Nişan Alırken Hız"
L["autostat.shootspeed"] = "Ateş Ederken Hız"
L["autostat.reloadtime"] = "Yeniden Yükleme Süresi"
L["autostat.drawtime"] = "Çekme Süresi"
L["autostat.sighttime"] = "Kullanım"
L["autostat.cycletime"] = "Döngü Süresi"
L["autostat.magextender"] = "Genişletilmiş Şarjör Boyutu"
L["autostat.magreducer"] = "Azaltılmış Şarjör Boyutu"
L["autostat.bipod"] = "Çatal Ayak Kullanabilir"
L["autostat.holosight"] = "Hassas Nişangah Görüntüsü"
L["autostat.zoom"] = "Artırılmış Yakınlaştırma"
L["autostat.glint"] = "Görünür Dürbün Parlaması"
L["autostat.thermal"] = "Termal Görüş"
L["autostat.silencer"] = "Ateş Sesini Bastırır"
L["autostat.norandspr"] = "Rastgele Dağılım Yok"
L["autostat.sway"] = "Nişan Sallanması"
L["autostat.heatcap"] = "Isı Kapasitesi"
L["autostat.heatfix"] = "Aşırı Isınma Düzeltme Süresi"
L["autostat.heatdelay"] = "Isı Kurtarma Gecikmesi"
L["autostat.heatdrain"] = "Isı Kurtarma Oranı"

-- TTT
L["ttt.roundinfo"] = "ArcCW Yapılandırması"
L["ttt.roundinfo.replace"] = "TTT Silahlarını Otomatik Değiştir"
L["ttt.roundinfo.cmode"] = "Özelleştirme Modu:"
L["ttt.roundinfo.cmode0"] = "Kısıtlama Yok"
L["ttt.roundinfo.cmode1"] = "Kısıtlı"
L["ttt.roundinfo.cmode2"] = "Sadece Oyun Öncesi"
L["ttt.roundinfo.cmode3"] = "Sadece T/D"

L["ttt.roundinfo.attmode"] = "Eklenti Modu:"
L["ttt.roundinfo.free"] = "Serbest"
L["ttt.roundinfo.locking"] = "Kilitleme"
L["ttt.roundinfo.inv"] = "Envanter"
L["ttt.roundinfo.persist"] = "Kalıcı"
L["ttt.roundinfo.drop"] = "Ölümde Düşür"
L["ttt.roundinfo.inv"] = "Envanter"
L["ttt.roundinfo.pickx"] = "Seç"

L["ttt.roundinfo.bmode"] = "Ceset Üzerindeki Eklenti Bilgisi:"
L["ttt.roundinfo.bmode0"] = "Kullanılamaz"
L["ttt.roundinfo.bmode1"] = "Sadece Dedektifler"
L["ttt.roundinfo.bmode2"] = "Kullanılabilir"

L["ttt.roundinfo.amode"] = "Mermi Patlaması:"
L["ttt.roundinfo.amode-1"] = "Devre Dışı"
L["ttt.roundinfo.amode0"] = "Basit"
L["ttt.roundinfo.amode1"] = "Parçalı"
L["ttt.roundinfo.amode2"] = "Tam"
L["ttt.roundinfo.achain"] = "Zincirleme Patlamalar"

L["ttt.bodyatt.found"] = "Cinayet silahı olduğunu düşünüyorsun"
L["ttt.bodyatt.founddet"] = "Dedektiflik yeteneklerinle cinayet silahını çıkarıyorsun"
L["ttt.bodyatt.att1"] = " {att} takılıydı."
L["ttt.bodyatt.att2"] = " {att1} ve {att2} takılıydı."
L["ttt.bodyatt.att3"] = " şu eklentiler takılıydı: "

L["ttt.attachments"] = " Eklenti(ler): " -- TTT2 Hedef Kimliği'nde kullanılır
L["ttt.ammo"] = "Mermi: " -- TTT2 Hedef Kimliği'nde kullanılır

-- CS+'da bulunan ve nedenini bilmediğimiz şeyler
L["info.togglesight"] = "Nişangahları değiştirmek için +USE'ye iki kez basın"
L["info.toggleubgl"] = "Namlu altını değiştirmek için +ZOOM'a iki kez basın" -- kullanımdan kaldırıldı
L["pro.ubgl"] = "Seçilebilir namlu altı atıcısı" -- kullanımdan kaldırıldı
L["pro.ubsg"] = "Seçilebilir namlu altı pompalı tüfek" -- kullanımdan kaldırıldı
L["con.obstruction"] = "Nişangahları engelleyebilir"
L["autostat.underwater"] = "Sualtında ateş et"
L["autostat.sprintshoot"] = "Koşarken ateş et"
L["con.beam"] = "Görünür lazer ışını"
L["con.light"] = "Görünür el feneri ışını"
L["con.noscope"] = "Nişan noktası yok"
L["pro.invistracers"] = "Görünmez iz mermileri"

-- Incompatibility Menu
L["incompatible.title"] = "ArcCW: UYUMLU OLMAYAN EKLENTİLER"
L["incompatible.line1"] = "ArcCW ile çalışmadığı bilinen bazı eklentileriniz var."
L["incompatible.line2"] = "Bunları devre dışı bırakın veya bozuk davranışlar bekleyin!"
L["incompatible.confirm"] = "Onayla"
L["incompatible.wait"] = "{time} saniye bekle"
L["incompatible.never"] = "Beni bir daha uyarma"
L["incompatible.never.hover"] = "Sonuçları anladığınızdan kesinlikle emin misiniz?"
L["incompatible.never.confirm"] = "Uyumsuzluk uyarılarını bir daha göstermemeyi seçtiniz. Hatalarla veya bozuk davranışlarla karşılaşırsanız, sorumluluk size aittir."

-- 2020-12-11
L["hud.hp"] = "HP: " -- Varsayılan HUD'da kullanılır
L["fcg.safe"] = "Emniyet"
L["fcg.semi"] = "Yarı otomatik"
L["fcg.auto"] = "Otomatik"
L["fcg.burst"] = "%d mermilik seri atış"
L["fcg.ubgl"] = "UBGL"

-- 2021-01-14
L["ui.toggle"] = "DEĞİŞTİR"
L["ui.whenmode"] = "%s Olduğunda"
L["ui.modex"] = "Mod %s"

-- 2021-01-25
L["attslot.magazine"] = "Şarjör"

-- 2021-03-13
L["trivia.damage"] = "Hasar"
L["trivia.range"] = "Menzil"
L["trivia.attackspersecond"] = "Saniyedeki Saldırı Sayısı"
L["trivia.description"] = "Açıklama"
L["trivia.meleedamagetype"] = "Hasar Türü"

-- Birimler
L["unit.rpm"] = "DAK"
L["unit.moa"] = "MOA"
L["unit.mm"] = "mm"
L["unit.db"] = "dB"
L["unit.bce"] = "BC"
L["unit.aps"] = "SSA"

-- Yakın dövüş hasar türleri
L["dmg.generic"] = "Silahsız"
L["dmg.bullet"] = "Delici"
L["dmg.slash"] = "Kesici"
L["dmg.club"] = "Küt"
L["dmg.shock"] = "Şok"

L["ui.presets"] = "Ön Ayarlar"
L["ui.customize"] = "Özelleştir"
L["ui.inventory"] = "Envanter"

-- 2021-05-05
L["ui.gamemode_buttons"] = "Oyun modu özel komutları"
L["ui.gamemode_usehint"] = "Orijinal tuş atamalarına erişmek için KULLAN'ı basılı tutabilirsiniz."
L["ui.darkrpdrop"] = "Silahı Bırak"
L["ui.noatts"] = "Hiç eklentiniz yok"
L["ui.noatts_slot"] = "Bu yuva için hiç eklentiniz yok"
L["ui.lockinv"] = "Bu eklentiler tüm silahlar için kilidi açılmıştır."
L["autostat.ammotype"] = "Silah mermi türünü %s'ye dönüştürür"

-- 2021-05-08
L["autostat.rangemin"] = "Minimum menzil"

-- 2021-05-13
L["autostat.malfunctionmean"] = "Güvenilirlik"
L["ui.heat"] = "ISI"
L["ui.jammed"] = "SIKIŞTI"

-- 2021-05-15
L["trivia.muzzlevel"] = "Namlu Çıkış Hızı"
L["unit.mps"] = "m/s"
L["unit.lbfps"] = "lb-fps"
L["trivia.recoilside"] = "Yatay Geri Tepme"

--2021-05-27
L["ui.pickx"] = "Eklentiler: %d/%d"
L["ui.ballistics"] = "Balistik"

L["ammo.pistol"] = "Tabanca Mermisi"
L["ammo.357"] = "Magnum Mermisi"
L["ammo.smg1"] = "Karabina Mermisi"
L["ammo.ar2"] = "Tüfek Mermisi"
L["ammo.buckshot"] = "Pompalı Tüfek Mermisi"
L["ammo.sniperpenetratedround"] = "Keskin Nişancı Mermisi"
L["ammo.smg1_grenade"] = "Tüfek Bombaları"

--2021-05-31
L["ui.nodata"] = "Veri Yok"
L["ui.createpreset"] = "Oluştur"
L["ui.deletepreset"] = "Sil"

--2021-06-09 güzel
L["autostat.clipsize"] = "%d mermilik şarjör kapasitesi"

--2021-06-30
L["autostat.bipod2"] = "Çatal ayağa izin verir (-%d%% Dağılım, -%d%% Geri Tepme)"
L["autostat.nobipod"] = "Çatal ayağı devre dışı bırakır"

--2021-07-01
L["fcg.safe2"] = "İndirilmiş"
L["fcg.dact"] = "Çift etkili"
L["fcg.sact"] = "Tek etkili"
L["fcg.bolt"] = "Sürgülü"
L["fcg.pump"] = "Pompalı"
L["fcg.lever"] = "Mekanizmalı"
L["fcg.manual"] = "Manuel mekanizmalı"
L["fcg.break"] = "Kırmalı"
L["fcg.sngl"] = "Tekli"
L["fcg.both"] = "İkisi de"

--2021-08-11
L["autostat.clipsize.mod"] = "Şarjör kapasitesi" -- Add_ClipSize ve Mult_ClipSize için kullanılır

--2021-08-22
L["trivia.recoilscore"] = "Geri Tepme Puanı (Düşük daha iyidir)"
L["fcg.safe.abbrev"] = "EMN"
L["fcg.semi.abbrev"] = "YAR"
L["fcg.auto.abbrev"] = "OTO"
L["fcg.burst.abbrev"] = "%d-SER"
L["fcg.ubgl.abbrev"] = "UBGL"
L["fcg.safe2.abbrev"] = "İND"
L["fcg.dact.abbrev"] = "ÇİFT"
L["fcg.sact.abbrev"] = "TEK"
L["fcg.bolt.abbrev"] = "SÜRG"
L["fcg.pump.abbrev"] = "POMP"
L["fcg.lever.abbrev"] = "MEK"
L["fcg.manual.abbrev"] = "MAN"
L["fcg.break.abbrev"] = "KIR"
L["fcg.sngl.abbrev"] = "TEK"
L["fcg.both.abbrev"] = "İKİ"

-- 2021-10-10
STL["lowered"] = "fcg.safe2"
STL["double-action"] = "fcg.dact"
STL["single-action"] = "fcg.sact"
STL["bolt-action"] = "fcg.bolt"
STL["pump-action"] = "fcg.pump"
STL["lever-action"] = "fcg.lever"
STL["manual-action"] = "fcg.manual"
STL["break-action"] = "fcg.break"
--STL["single"] = "fcg.sngl"
--STL["both"] = "fcg.both"

-- 2021-11-27
L["ui.hitgroup"] = "Vuruş Bölgesi"
L["ui.shotstokill"] = "Öldürmek için gereken atış sayısı"
L["ui.hitgroup.head"] = "Kafa"
L["ui.hitgroup.torso"] = "Gövde" -- aynı olduklarında göğüs+karın
L["ui.hitgroup.chest"] = "Göğüs"
L["ui.hitgroup.stomach"] = "Karın"
L["ui.hitgroup.arms"] = "Kollar"
L["ui.hitgroup.legs"] = "Bacaklar"
L["ui.nonum"] = "İnsanları öldürmek için mermilere ihtiyacın var, aptal." -- sayı 0

-- 2022-05-23
L["fcg.nade"] = "El Bombası"
L["fcg.nade.abbrev"] = "BOMBA"

-- 2022-08-03
L["attslot.magazine"] = "Şarjör"
L["attslot.magazine.default"] = "Standart Şarjör"

-- 2022-08-17
L["autostat.ubgl"] = "Seçilebilir namlu altı silahı"
L["autostat.ubgl2"] = "Namlu altı silahını etkinleştirmek için KULLAN ve YENİDEN YÜKLE tuşlarına birlikte basın"
L["autostat.ammotypeubgl"] = "Namlu altı silahı %s kullanır"

-- 2023-09-09
L["autostat.triggerdelay"] = "Tetik gecikmesi"


--[[]
You can translate the trivia of any arbitrary weapon or attachment by adding the phrase ["desc.class_name"]
Similarly, you can translate attachment and weapon names with ["name.class_name"]
When translating weapon names, append .true for truename, like ["name.arccw_p228.true"]
Example:
 L["desc.fcg_auto"] = "blah blah blah automatic firemode"
 L["name.fcg_auto"] = "Auto But Cooler"
You can also translate custom firemodes with "fcg.FIREMODE_NAME"
]]
--lua/arccw/shared/languages/ud_en.lua:
L = {}

L["ud.title"] = "Urban Decay"

-- Glock
L["ud.glock.cs"] = "+3 Default magazine capacity"
L["ud.glock.subcompact"] = "Enables Subcompact attachments"
L["ud.glock.nytesyte.1"] = "Recoil becomes sideways while aiming"
L["ud.glock.nytesyte.2"] = "Optics will be mounted sideways"

L["ud.hushpuppy"] = "Switch to slide-lock firemode for manual action, reducing volume and imprecision"

L["fcg.slidelock"] = "Slide-lock"
L["fcg.slidelock.abbrev"] = "S-LOCK"

L["ud.glock.altanim"] = "Replaces the empty reload animation with a longer, flashier alternative."

-- M16
L["ud.flattop"] = "Lower optic position"
L["ud.m16_ch.1"] = "Mount optics on top of the carry handle instead of having a flat top."
L["ud.m16_ch.2"] = "It might improve visibility when aiming, or block your vision when hip-firing."
L["ud.m16_tl.1"] = "Mount tactical lasers on top of the weapon instead of the barrel or lower rail."
L["ud.m16_tl.2"] = "The front sight is removed, and the sight is changed to a point shooting stance."
L["ud.m16_nors"] = "This disables alternative iron sights."
L["ud.m16_a1"] = "This receiver has no flat top variant, and will apply a rail mount for optics."
L["ud.m16_altburst.1"] = "-10% Recoil in Burst fire mode"
L["ud.m16_altburst.2"] = "This receiver fires the entire burst with one trigger pull."
L["ud.usas"] = "Fire shotgun shells instead of bullets" -- deprecated
L["ud.m16_fs.1"] = "Keep the front iron sight on the gas block when mounting optics."
L["ud.m16_fs.2"] = "Certain optics will become obstructed by the front sight."
L["ud.m16.fpw1"] = "No semi-automatic mode"
L["ud.m16.fpw2"] = "+0.1s Trigger delay"
L["ud.m16.50beo"] = "Disables Lower Receiver attachments"
L["ud.m16.allowfs"] = "Allows Front Sight attachments"

-- 870
L["ud.870.ringsight"] = "Reduced field of vision"

-- Deprecated
L["ud.darkrp.cantremove"] = "You can't remove this without a gun license!"
L["ud.darkrp.cantattach"] = "You need a gun license to use this attachment!"
L["ud.darkrp.cantpickup"] = "You need a gun license to pickup this attachment!"
--addons/[binbon]arccw_modify/lua/arccw/shared/sh_truenames.lua:
return gluapack()()
--lua/arccw/client/cl_0_uc_wepsel.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/arccw/client/cl_garbage.lua:
ArcCW.CSModels       = {} -- [entid] = { Weapon = NULL, WModels = {}, VModels = {} }
ArcCW.CSModelPile    = {} -- { {Model = NULL, Weapon = NULL} }
ArcCW.FlashlightPile = {} -- { {Weapon = NULL, ProjectedTexture = NULL}}
ArcCW.ReferenceModel = NULL

local function ArcCW_CollectGarbage()
    local removed, removedents = 0, {}

    for i, k in pairs(ArcCW.CSModels) do
        if !IsValid(k.Weapon) then
            removed = removed + 1

            table.insert(removedents, i)

            if k.WModels then for _, m in pairs(k.WModels) do SafeRemoveEntity(m.Model) end end
            if k.VModels then for _, m in pairs(k.VModels) do SafeRemoveEntity(m.Model) end end
        end
    end

    for _, i in pairs(removedents) do ArcCW.CSModels[i] = nil end

    local newpile = {}

    for _, k in pairs(ArcCW.CSModelPile) do
        if IsValid(k.Weapon) then
            table.insert(newpile, k)

            continue
        end

        SafeRemoveEntity(k.Model)

        removed = removed + 1
    end

    ArcCW.CSModelPile = newpile

    if GetConVar("developer"):GetBool() and removed > 0 then
        print("Removed " .. tostring(removed) .. " CSModels")
    end
end

hook.Add("PostCleanupMap", "ArcCW_CleanGarbage", function()
    ArcCW_CollectGarbage()
end)

timer.Create("ArcCW CSModel Garbage Collector", 5, 0, ArcCW_CollectGarbage)

hook.Add("PostDrawEffects", "ArcCW_CleanFlashlights", function()
    local newflashlightpile = {}

    for _, k in pairs(ArcCW.FlashlightPile) do
        if IsValid(k.Weapon) and k.Weapon == LocalPlayer():GetActiveWeapon() then
            table.insert(newflashlightpile, k)

            continue
        end

        if k.ProjectedTexture and k.ProjectedTexture:IsValid() then
            k.ProjectedTexture:Remove()
        end
    end

    ArcCW.FlashlightPile = newflashlightpile

    local wpn = LocalPlayer():GetActiveWeapon()

    if !wpn then return end
    if !IsValid(wpn) then return end
    if !wpn.ArcCW then return end

    if GetViewEntity() == LocalPlayer() then return end

    wpn:KillFlashlightsVM()
end)

concommand.Add("arccw_dev_loadallattmodels", function()
    local e = ClientsideModel("models/weapons/v_pistol.mdl")
    print("created subject", e)
    
    for i, v in pairs(ArcCW.AttachmentTable) do
        if v.Model then
            print("\t- " .. v.Model)
            e:SetModel(v.Model)
        end
    end

    print("removed subject", e)
    e:Remove()
end)
--addons/[binbon]arccw_modify/lua/arccw/client/cl_hud.lua:
local hide = {
    ["CHudHealth"] = true,
    ["CHudBattery"] = true,
    ["CHudAmmo"] = true,
    ["CHudSecondaryAmmo"] = true,
}

CreateClientConVar("arccw_hud_togglestats", "0")

ArcCW.HUDElementConVars = {
    ["CHudHealth"] = CreateClientConVar("arccw_hud_showhealth", "1"),
    ["CHudBattery"] = ArcCW.ConVars["hud_showhealth"],
    ["CHudAmmo"] = CreateClientConVar("arccw_hud_showammo", "1"),
    ["CHudSecondaryAmmo"] = ArcCW.ConVars["hud_showammo"],
}

local grad = Material("arccw/hud/grad.png", "mips smooth")


hook.Add("RenderScreenspaceEffects", "ArcCW_ToyTown", function()
    if !LocalPlayer():IsValid() then return end
    local wpn = LocalPlayer():GetActiveWeapon()
    if !IsValid(wpn) then return end

    if !wpn.ArcCW then return end

    local delta = wpn:GetSightDelta()

    if delta < 1 then
        wpn:DoToyTown()
    end
end)

ArcCW.PollingDefaultHUDElements = false

function ArcCW:ShouldDrawHUDElement(ele)


    return false
end

local function GetFont()
    local font = "Bahnschrift"

    if ArcCW.GetTranslation("default_font") then
        font = ArcCW.GetTranslation("default_font")
    end

    if ArcCW.ConVars["font"]:GetString() != "" then
        font = ArcCW.ConVars["font"]:GetString()
    end

    return font
end

-- Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes.
-- What is the size of your ass. What is it. Tell me.
local ScreenScale_CacheC2 = {}
ArcCW.AugmentedScreenScale = function(size)
    if ScreenScale_CacheC2[size] then return ScreenScale_CacheC2[size] end

    local scrw, scrh = ScrW(), ScrH()
    if vrmod and vrmod.IsPlayerInVR(LocalPlayer()) then
        -- Other resolutions seem to cause stretching issues
        scrw = 1366
        scrh = 768
    end

    local scrwmult = ArcCW.ConVars["hud_deadzone_x"]:GetFloat() * scrw
    local scrhmult = ArcCW.ConVars["hud_deadzone_y"]:GetFloat() * scrh

    scrw, scrh = scrw - scrwmult, scrh - scrhmult

    local r = size
    r = r * (math.max(scrw, scrh) / 800)
    r = r * ArcCW.ConVars["hud_size"]:GetFloat()
    ScreenScale_CacheC2[size] = r
    return r
end

local sizes_to_make = {
    6,
    8,
    10,
    12,
    14,
    16,
    20,
    24,
    26,
    32
}

local sizes_to_make_cust2 = {
    8,
    10,
    12,
    14,
    16,
    24,
    32
}

local unscaled_sizes_to_make = {
    32,
    24
}

local function generatefonts()

    for _, i in pairs(sizes_to_make) do

        surface.CreateFont( "ArcCW_" .. tostring(i), {
            font = GetFont(),
            size = ScreenScale(i) * ArcCW.ConVars["hud_size"]:GetFloat(),
            weight = 0,
            antialias = true,
            extended = true, -- Required for non-latin fonts
        } )

        surface.CreateFont( "ArcCW_" .. tostring(i) .. "_Glow", {
            font = GetFont(),
            size = ScreenScale(i) * ArcCW.ConVars["hud_size"]:GetFloat(),
            weight = 0,
            antialias = true,
            blursize = 6,
            extended = true,
        } )

    end

    for _, i in pairs(sizes_to_make_cust2) do

        surface.CreateFont( "ArcCWC2_" .. tostring(i), {
            font = GetFont(),
            size = ArcCW.AugmentedScreenScale(i) * ArcCW.ConVars["hud_size"]:GetFloat(),
            weight = 0,
            antialias = true,
            extended = true, -- Required for non-latin fonts
        } )

        surface.CreateFont( "ArcCWC2_" .. tostring(i) .. "_Glow", {
            font = GetFont(),
            size = ArcCW.AugmentedScreenScale(i) * ArcCW.ConVars["hud_size"]:GetFloat(),
            weight = 0,
            antialias = true,
            blursize = 6,
            extended = true,
        } )

    end

    for _, i in pairs(unscaled_sizes_to_make) do

        surface.CreateFont( "ArcCW_" .. tostring(i) .. "_Unscaled", {
            font = GetFont(),
            size = i,
            weight = 0,
            antialias = true,
            extended = true,
        } )

    end

end

local og_ScreenScale = ScreenScale

local ScreenScale_Cache = {}

function ScreenScale(a)
    if ScreenScale_Cache[a] then return ScreenScale_Cache[a] end

    ScreenScale_Cache[a] = og_ScreenScale(a)
    return ScreenScale_Cache[a]
end

language.Add("SniperPenetratedRound_ammo", "Sniper Ammo")

generatefonts()
function ArcCW_Regen(full)
    if full then
        generatefonts()
        ScreenScale_Cache = {}
        ScreenScale_CacheC2 = {}
    end
    if IsValid(ArcCW.InvHUD) then
        ArcCW.InvHUD:Clear()
        ArcCW.InvHUD:Remove()
    end
end

--cvars.AddChangeCallback("arccw_dev_cust2beta",  function() ArcCW_Regen(true) end)
cvars.AddChangeCallback("arccw_hud_deadzone_x", function() ArcCW_Regen(true) end)
cvars.AddChangeCallback("arccw_hud_deadzone_y", function() ArcCW_Regen(true) end)
cvars.AddChangeCallback("arccw_hud_size",       function() ArcCW_Regen(true) end)
cvars.AddChangeCallback("arccw_font",           function() ArcCW_Regen(true) end)
hook.Add( "OnScreenSizeChanged", "ArcCW_Regen", function() ArcCW_Regen(true) end)

-- surface.CreateFont( "ArcCW_12", {
--     font = font,
--     size = ScreenScale(12),
--     weight = 0,
--     antialias = true,
-- } )

-- surface.CreateFont( "ArcCW_12_Glow", {
--     font = font,
--     size = ScreenScale(12),
--     weight = 0,
--     antialias = true,
--     blursize = 8,
-- } )

-- surface.CreateFont( "ArcCW_16", {
--     font = font,
--     size = ScreenScale(16),
--     weight = 0,
--     antialias = true,
-- } )

-- surface.CreateFont( "ArcCW_16_Glow", {
--     font = font,
--     size = ScreenScale(16),
--     weight = 0,
--     antialias = true,
--     blursize = 8,
-- } )

-- surface.CreateFont( "ArcCW_26", {
--     font = font,
--     size = ScreenScale(26),
--     weight = 0,
--     antialias = true,
-- } )

-- surface.CreateFont( "ArcCW_26_Glow", {
--     font = font,
--     size = ScreenScale(26),
--     weight = 0,
--     antialias = true,
--     blursize = 8,
-- } )
--lua/autorun/arccw_fml_karma9.lua:
sound.Add({
	name = 			"ARCCW_FML_Karma9.Out1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/arccw_fml_karma9/wpn_hemlok_reload_popmag_fr50_2ch_v1_01.wav"
})

sound.Add({
	name = 			"ARCCW_FML_Karma9.Out2",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/arccw_fml_karma9/wpn_hemlok_reload_empty_removemag_fr10_2ch_v1_01.wav"
})

sound.Add({
	name = 			"ARCCW_FML_Karma9.In1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/arccw_fml_karma9/wpn_hemlok_reload_handgrab_fr57_2ch_v1_01.wav"
})

sound.Add({
	name = 			"ARCCW_FML_Karma9.In2",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/arccw_fml_karma9/wpn_hemlok_reload_insertmag_fr36_2ch_v1_01.wav"
})

sound.Add({
	name = 			"ARCCW_FML_Karma9.Bolt1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/arccw_fml_karma9/wpn_hemlok_reload_empty_chargeback_fr68_2ch_v1_01.wav"
})

sound.Add({
	name = 			"ARCCW_FML_Karma9.Bolt2",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/arccw_fml_karma9/wpn_hemlok_reload_empty_chargeforward_fr76_2ch_v1_01.wav"
})
--addons/ashop/lua/ashop/code/_kernel/sh_object_types.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/gamemodes/currencies/sh_init.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/gamemodes/logs_integration_name/sh_helix.lua:
hook.Add("PostGamemodeLoaded", "AShop_Name_Helix", function()
    if ix then
        hook.Add("CharacterVarChanged", "AShop_Name_Helix", function(char, key, _, val)
            if ix and key == "Name" then
                ashop.Logs.RefreshName(char:GetPlayer(), val)
            end
        end)

        hook.Remove("PostGamemodeLoaded", "AShop_Name_Helix")
        hook.Remove("player_changename", "ashop_Name")
    end
end)
--addons/ashop/lua/ashop/code/giveaway/cl_init.lua:
//if true then return end
local circlePattern = Material('akulla/pattern_circle.png', "noclamp smooth")
local grad = Material('akulla/gradient-d.png')
local function spawnGiveawayPanel(itemName, restrictGroup, winnerPly, playerCountLoop, secExec)
    local pW = ashop.GetSize(12)
    local clrGrad1_0 = ashop.GetColor('Grad2_1')
    local fontSize = ashop.GetFontHeight('ashop_16')
    local clrStateOn = ashop.GetColor('StateOn', 125)
    local p = vgui.Create('EditablePanel')
    local wBarGrad = ashop.GetSize(10)
    p:SetSize(ScrW() * 0.4, ashop.GetSize(64) + fontSize * 2)
    p:SetPos(ScrW() / 2 - p:GetWide() / 2)

    local top = vgui.Create('EditablePanel', p)
    top:SetTall(p:GetTall() - fontSize * 2)
    top:Dock(TOP)

    function top:Paint(w, h)
        surface.SetDrawColor(clrGrad1_0)
        surface.DrawRect(0, 0, w, h)
    end

    function top:PaintOver(w, h)
        surface.SetDrawColor(color_white)
        surface.DrawRect(w/2-2, 0, 4, h)

        surface.SetMaterial(grad)
        surface.SetDrawColor(clrStateOn)
        surface.DrawTexturedRectRotated(w/2-2 - wBarGrad*0.5, h/2, h, wBarGrad, 90 )
        surface.DrawTexturedRectRotated(w/2+2 + wBarGrad*0.5, h/2, h, wBarGrad, 270 )
    end

    local bonusCountLoop = math.ceil(p:GetWide() / top:GetTall()) + 1

    local avatarPanel = vgui.Create('EditablePanel', top)
    avatarPanel:SetSize(top:GetTall() * (playerCountLoop+bonusCountLoop), top:GetTall())

    local bottom = vgui.Create('EditablePanel', p)
    bottom:Dock(FILL)
    bottom:DockPadding(fontSize, fontSize/2, fontSize, fontSize/2)

    function bottom:Paint(w, h)
        local rat = (w + h) / pW
        local bonus = (UnPredictedCurTime()*0.5 % 1)
        draw.RoundedBoxEx(8, 0, 0, w, h, clrGrad1_0, false, false, true, true)

        surface.SetMaterial(circlePattern)
        surface.SetDrawColor(ashop.GetColor('StateOn', 60))
        surface.DrawTexturedRectUV(0, 0, w + h, w + h, -bonus, bonus, rat-bonus, rat+bonus)

        surface.SetDrawColor(ashop.GetColor('StateOn'))
        surface.DrawRect(0, 0, w, 2)
    end

    if restrictGroup then
        local restrictedTo = vgui.Create('DLabel', bottom)
        restrictedTo:Dock(RIGHT)
        restrictedTo:SetFont('ashop_16_600')
        restrictedTo:SetTextColor(color_white)
        restrictedTo:SetText(ashop.L('RestrictedTo', restrictGroup))
        restrictedTo:SetWide(restrictedTo:GetContentSize())
    end

    local iconGift = vgui.Create('DLabel', bottom)
    iconGift:Dock(LEFT)
    iconGift:SetTextColor(color_white)
    iconGift:SetFont('ashop_icon_20')
    iconGift:SetText("3")
    iconGift:SetWide(iconGift:GetContentSize())
    iconGift:DockMargin(0, 0, fontSize, 0)

    local itemNameLabel = vgui.Create('DLabel', bottom)
    itemNameLabel:Dock(LEFT)
    itemNameLabel:SetTextColor(color_white)
    itemNameLabel:SetFont('ashop_16_600')
    itemNameLabel:SetText('"' .. itemName .. '"')
    itemNameLabel:SetWide(itemNameLabel:GetContentSize())

    local plys = {}
    for k, v in ipairs(player.GetHumans()) do
        if restrictGroup and ashop.groupranks[restrictGroup] and !ashop.groupranks[restrictGroup].ranks[v:GetUserGroup()] then continue end

        table.insert(plys, v)
    end

    for i = 0, playerCountLoop + bonusCountLoop do
        local ply = plys[math.random(#plys)]
        local avatar = vgui.Create('AvatarImage', avatarPanel)
        avatar:Dock(LEFT)

        if playerCountLoop == i then
            avatar:SetPlayer(winnerPly, 184)
        else
            avatar:SetPlayer(ply, 184)
        end
        avatar:SetWide(top:GetTall())
    end

    local goodPos = playerCountLoop * top:GetTall()
    local randOffset = math.Rand(-top:GetTall()*0.45, top:GetTall()*0.45)

    timer.Simple(2, function()
        avatarPanel:MoveTo(-goodPos - top:GetTall()/2 + p:GetWide()/2 + randOffset, 0, secExec, 0, 0.5, function()
            p:MoveTo(p:GetX(), -p:GetTall(), 1, 3, 0.5, function()
                p:Remove()
            end)
            if !IsValid(winnerPly) then return end

            local winnerLabel = vgui.Create('DLabel', bottom)
            winnerLabel:SetTextColor(color_white)
            winnerLabel:SetFont('ashop_16_600')
            winnerLabel:SetText(ashop.L('WinnerIs', (IsValid(winnerPly) and winnerPly:Nick() or "Unknown")))
            winnerLabel:SetWide(winnerLabel:GetContentSize())
            winnerLabel:SetPos(-winnerLabel:GetWide()/2 + p:GetWide()/2, fontSize/2)
            winnerLabel:SetTall(fontSize)
            winnerLabel:SetAlpha(0)
            winnerLabel:AlphaTo(255, 0.5)
        end)
    end)

    p:SetY(-p:GetTall())
    p:MoveTo(p:GetX(), 0, 1, 0, 0.5)
end

net.Receive('ashop_giveaway', function()
    local ply = net.ReadEntity()
    local name = net.ReadString()
    local restrictGroup = net.ReadBool() and net.ReadUInt(8) or nil
    local playerCountLoop = net.ReadUInt(9)
    local secExec = net.ReadUInt(6)

    spawnGiveawayPanel(name, restrictGroup, ply, playerCountLoop, secExec)
end)

// spawnGiveawayPanel("The Nicest Accessory !", "Test Rank", LocalPlayer(), 100, 5)
--addons/ashop/lua/ashop/code/object_types/case_opening/sh_hiddenmethods.lua:
// I don't want these functions to be global
// This would be bullshit, so I hide them in a file that I can include after

return {
    GetCaseLuck = function(itemList, count)
        local m = 0
        for k, v in ipairs(itemList) do
            m = m + v[2]
        end
    
        local resultTable = {}
        for i = 1, (count or 1) do
            local rand = math.Rand(0, m)
            local count = 0
    
            for k, v in ipairs(itemList) do
                if count <= rand and rand <= (count + v[2]) then
                    table.insert(resultTable, v[1])
                    break
                else
                    count = count + v[2]
                end
            end
        end
    
        return resultTable
    end
}
--addons/ashop/lua/ashop/code/object_types/entities/sh_entity.lua:
local OBJECT_TYPE = {}

OBJECT_TYPE.Name = ashop.L('EntitiesClass')
OBJECT_TYPE.DefaultRender = "Consumables"

OBJECT_TYPE.ItemParameters = {
    [1] = {
        name = ashop.L('Entities_1'),
        type = TYPE_STRING,
        options = {
            required = true
        }
    },

    [2] = {
        name = ashop.L('Entities_2'),
        type = TYPE_STRING,
    },
}

OBJECT_TYPE.UniqueIdentifier = "Entities"

ashop.RegisterObjectType(OBJECT_TYPE)
--addons/ashop/lua/ashop/code/object_types/kill_card/cl_killcard.lua:
local OBJECT_TYPE = {}

OBJECT_TYPE.Name = "Kill Cards"
OBJECT_TYPE.UniqueIdentifier = "KillCards"

local lastKillCard

local function simpleFormat(num)
    if num > 1000000 then
        return math.floor(num / 1000000) .. "m"
    elseif num > 1000 then
        return math.floor(num / 1000) .. "k"
    else
        return num
    end
end

local function spawnCard(mat, ourDmg, ourBullet, theirDmg, theirBullet, wep, n, item)
    local w = ashop.GetSize(466)
    local h = w * (128 / 512)
    local fontSize = ashop.GetFontHeight('ashop_16_600')
    local white25 = ashop.GetColor('White25')
    local poly
    local cR, cG, cB = item.metadata[2]:Unpack()
    local shotCount = math.min(theirBullet, 1000)
    local logoMargin = fontSize/3*2
    local logoSize = ashop.GetFontHeight('ashop_icon_18')
    local fontSize = ashop.GetFontHeight('ashop_16_600')
    local kcR, kcG, kcB = 40, 40, 40

    theirDmg = simpleFormat(theirDmg)
    ourDmg = simpleFormat(ourDmg)

    local p = vgui.Create('DPanel')
    p:SetSize(w, h + fontSize + fontSize*1.5)
    p:SetPos(ScrW()/2 - w/2, ScrH()*0.8 - p:GetTall()/2)
    p:SetAlpha(0)
    p:AlphaTo(255, 0.25)

    function p:Paint(w, h)
        surface.SetDrawColor(kcR, kcG, kcB)
        surface.DrawRect(0, 0, w, h)
    end

    local topPart = vgui.Create('EditablePanel', p)
    topPart:Dock(TOP)
    topPart:SetTall(fontSize + fontSize*1.5)
    topPart:DockPadding(fontSize/2, fontSize/2, fontSize/2, fontSize/2)

    local rightPart = vgui.Create('EditablePanel', topPart)
    rightPart:Dock(RIGHT)
    rightPart:SetWide(logoMargin)

    for k, v in ipairs({{"/", ourDmg}, {".", ourBullet}}) do
        local amt = vgui.Create('DLabel', rightPart)
        amt:SetFont('ashop_16_600')
        amt:Dock(RIGHT)
        amt:SetText(v[2])
        amt:SetWide(amt:GetContentSize()+1)
        amt:SetTextColor(color_white)
        amt:DockMargin(fontSize/4, 0, 0, 0)

        local icon = vgui.Create('DLabel', rightPart)
        icon:SetFont('ashop_icon_18')
        icon:Dock(RIGHT)
        icon:SetText(v[1])
        icon:SetWide(icon:GetContentSize()+1)
        icon:SetTextColor(white25)
        icon:DockMargin(logoMargin, 0, 0, 0)

        rightPart:SetWide(rightPart:GetWide() + logoMargin + fontSize/4 + icon:GetWide() + amt:GetWide())
    end

    local leftPart = vgui.Create('EditablePanel', topPart)
    leftPart:Dock(FILL)

    function leftPart:Paint(w, h)
        if !poly then
            poly = {
                {
                    x = math.ceil(-fontSize/2),
                    y = -fontSize/2
                },

                {
                    x = w - (h + fontSize)/2,
                    y = -fontSize/2,
                },

                {
                    x = w + (h + fontSize)/2,
                    y = h + fontSize/2,
                },

                {
                    x =  math.ceil(-fontSize/2),
                    y = (h + fontSize)
                }
            }
        end

        DisableClipping(true)
        surface.SetDrawColor(cR, cG, cB)
        draw.NoTexture()
        surface.DrawPoly(poly)
        DisableClipping(false)
    end

    surface.SetFont("ashop_16_600")

    local leftWide = p:GetWide() - fontSize*2 - rightPart:GetWide()
    leftWide = leftWide - surface.GetTextSize(theirDmg)
        - surface.GetTextSize(shotCount) - (logoMargin + logoSize + fontSize/4) * (wep and 4 or 3)

    local nameSize, nameScroll
    local wepSize, wepScroll
    nameSize = surface.GetTextSize(n)
    wepSize = surface.GetTextSize(wep or "")

    if wepSize == 0 then
        nameScroll = nameSize > leftWide and leftWide or nil
    elseif nameSize + wepSize > leftWide then
        // We should make wepScroll, in this case
        // Name size isn't that big
        if nameSize < leftWide/2 then
            wepScroll = leftWide - nameSize
        elseif wepSize < leftWide/2 then
            nameScroll = leftWide - wepSize
        else
            nameScroll = leftWide / 2
            wepScroll = leftWide / 2
        end
    end

    for k, v in ipairs({{"1", n, nameScroll}, {"0", wep, wepScroll}, {"/", theirDmg}, {".", shotCount}}) do
        if !v[2] then continue end

        local icon = vgui.Create('DLabel', leftPart)
        icon:SetFont('ashop_icon_18')
        icon:Dock(LEFT)
        icon:SetText(v[1])
        icon:SetTextColor(white25)
        icon:DockMargin(logoMargin, 0, 0, 0)
        icon:SetWide(icon:GetContentSize()+1)

        leftPart:SetWide(leftPart:GetWide() + logoMargin + icon:GetWide())
        local refCurTime = CurTime() - 1

        local amt = vgui.Create(v[3] and 'EditablePanel' or 'DLabel', leftPart)
        amt:Dock(LEFT)
        amt:DockMargin(fontSize/4, 0, 0, 0)

        if v[3] then
            surface.SetFont("ashop_16_600")
            amt:SetWide(v[3])
            local tX = surface.GetTextSize(v[2])

            function amt:Paint(w, h)
                local sub = (CurTime() - refCurTime)/4
                local rat

                if sub > 1 then
                    rat = math.abs(sub % 2) - 1
                else
                    rat = 0
                end

                draw.SimpleText(v[2], "ashop_16_600", (tX - w) * -rat, h/2, color_white, 0, 1)
            end
        else
            amt:SetFont('ashop_16_600')
            amt:SetText(v[2])
            amt:SetTextColor(color_white)
            amt:SetWide(amt:GetContentSize()+1)
        end

        leftPart:SetWide(leftPart:GetWide() + fontSize / 3 * 2 + amt:GetWide())
    end

    local paint = vgui.Create('EditablePanel', p)
    paint:Dock(FILL)
    
    function paint:Paint(w, h)
        if !mat then return end

        surface.SetDrawColor(255, 255, 255)
        surface.SetMaterial(isfunction(mat) and mat() or mat)
        surface.DrawTexturedRect(0, 0, w, h)
    end
    
    function p:OnRemove()
        if removeFunc then
            removeFunc()
        end
    end

    return p
end

net.Receive('ashop_killcards', function()
    local id = net.ReadUInt(ashop.Config.BitsItemID)
    local b = net.ReadBool()
    local ent = net.ReadEntity()
    local ourDmg, ourBullet = net.ReadUInt(16), net.ReadUInt(16)
    local theirDmg, theirBullet = net.ReadUInt(16), net.ReadUInt(16)

    local item

    if !net.ReadBool() then
        item = ashop.Network.R_ItemData()
        ashop.items[item.id] = item
    else
        item = ashop.items[id]
    end

    local w = ashop.GetSize(512)
    ashop.ui.setMaterialByLink(item.metadata[1], {
        ["$translucent"] = 1,
    }, function(m)
        if !IsValid(ent) then return end
        if IsValid(lastKillCard) then
            lastKillCard:Remove()
        end

        local p = spawnCard(m, ourDmg, ourBullet, theirDmg, theirBullet, (IsValid(ent:GetActiveWeapon()) and ent:GetActiveWeapon().PrintName or nil), ent:Nick(), item)
        lastKillCard = p

        if !b then
            local lply = LocalPlayer()
            function p:Think()
                if lply:Alive() then
                    self:Remove()
                end
            end
        else
            timer.Simple(5, function()
                if IsValid(lastKillCard) then
                    lastKillCard:Remove()
                end
            end)
        end
    end, 'UnlitGeneric')
end)

function OBJECT_TYPE.UI_FILL(plyItem, item, pnl, parent, w, h, noCircle)
    parent:SetMouseInputEnabled(true)

    local circleParent = vgui.Create("EditablePanel", pnl)
    circleParent:SetSize(w, h)

    local c = math.max(w, h) * 0.6
    local sub = vgui.Create("EditablePanel", circleParent)
    sub:SetSize(c, c)
    sub:Center()

    ashop.ui.setMaterialByLink(item.metadata[1], nil, function(m)
        if !IsValid(pnl) then
            return
        end
        
        local p = spawnCard(m, 100, 5, 50, 5, "Example Weapon", LocalPlayer():Nick(), item)
        p:SetVisible(false)
        p:SetMouseInputEnabled(false)
        
        parent:SetTooltipPanel(p)
        //sub:SetTooltipPanel(tooltip)
        parent:SetTooltipPanelOverride("ashop_TooltipAvatar")
        
        function circleParent:OnRemove()
            p:Remove()
        end

        if !IsValid(sub) then return end

        local r1
        function sub:Paint(w, h)
            if !r1 then
                r1 = ashop.ui.RoundedBox(ashop.Config.round, 0, 0, w, h)
            end

            local mat = isfunction(m) and m() or m
            ashop.StartStencil()
            surface.SetDrawColor(1,1,1,1)
            draw.NoTexture()
            surface.DrawPoly(r1)
            ashop.ReplaceStencil(1)
            surface.SetDrawColor(255, 255, 255)
            surface.SetMaterial(mat)
            
            local wOffset = mat:Height() / mat:Width()
            surface.DrawTexturedRectUV(0, 0, w, h, 0.5 - wOffset/2, 0, 0.5 + wOffset/2, 1)
            ashop.EndStencil()
        end
    end, 'UnlitGeneric')
end

ashop.RegisterObjectType(OBJECT_TYPE)

local killCardID

hook.Add('ashop_equip', 'loadKillCard', function(_, slot, item, plyItem)
    if !killCardID then
        killCardID = ashop.GetObjectTypeIDByUID("KillCards")
    end

    if item.object_types == killCardID then
        ashop.ui.setMaterialByLink(item.metadata[1], nil, nil, 'UnlitGeneric')
    end
end)
--addons/ashop/lua/ashop/code/object_types/kill_card/sh_killcard.lua:
local OBJECT_TYPE = {}

OBJECT_TYPE.Name = ashop.L('KillCardClass')
OBJECT_TYPE.DefaultRender = "Accessories"

OBJECT_TYPE.ItemParameters = {
    [1] = {
        name = ashop.L('KillCard_1'),
        type = TYPE_STRING,
        options = {
            required = true
        }
    },

    [2] = {
        name = ashop.L('KillCard_2'),
        type = TYPE_COLOR,
        options = {
            required = true
        }
    },
}

OBJECT_TYPE.UniqueIdentifier = "KillCards"
OBJECT_TYPE.SlotDefault = 1
OBJECT_TYPE.NoChild = true
OBJECT_TYPE.BlockSlotEdit = true

ashop.RegisterObjectType(OBJECT_TYPE)
--addons/ashop/lua/ashop/code/object_types/title_code/effect/cl_styles.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/object_types/title_code/effect/cl_text.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/object_types/wearable/cl_wearable.lua:
local OBJECT_TYPE = {}

OBJECT_TYPE.Name = ashop.L('ClothesClass')
OBJECT_TYPE.UniqueIdentifier = "Wearables"

function OBJECT_TYPE.UI_FILL(plyItem, item, pnl, parent, w, h, noCircle, fullSize)
    local circleParent = vgui.Create("EditablePanel", pnl)
    circleParent:SetSize(w, h)
    circleParent:SetMouseInputEnabled(false)
    circleParent:SetPaintedManually(true)

    local c = fullSize and math.max(w, h) or math.max(w, h) * 0.6

    local SpawnI = vgui.Create( "DModelPanel" , circleParent )
    SpawnI:SetSize(c, c)
    SpawnI:Center()
    SpawnI:SetModel(item.metadata[1])
    SpawnI:SetMouseInputEnabled(false)
    SpawnI:SetPaintedManually(true)

    local oldPaint = SpawnI.Paint
    function SpawnI:Paint(w, h)
        oldPaint(SpawnI, w, h)
    end
    
    if item.metadata[11] and isnumber(item.metadata[11]) then
        SpawnI.Entity:SetSkin(item.metadata[11])
    end

    if item.metadata[9] then
        SpawnI:SetColor(item.metadata[9])
    end
    local mdlMin, mdlMax = SpawnI.Entity:GetModelBounds()
    local center = (mdlMax - mdlMin)/2 + mdlMin
    local tab = PositionSpawnIcon(SpawnI.Entity, center)

    function SpawnI:PreDrawModel(ent)
        render.SetLightingMode(1)
    end

    function SpawnI:PostDrawModel(ent)
        render.SetLightingMode(0)
    end

    if item.metadata[13] then
        tab.origin = item.metadata[13]
    end

    SpawnI:SetFOV(tab.fov)
    SpawnI:SetCamPos(tab.origin)
    SpawnI:SetLookAt(center)

    function SpawnI:LayoutEntity() end
    SpawnI.ZFar = tab.zfar

    if item.metadata[12] then
        // Have fun looking the DModelPanel code for an explanation
        SpawnI:SetCamPos(( tab.origin - center ):Angle():Forward() * item.metadata[12])
    end

    return true, {SpawnI}
end

function OBJECT_TYPE.OnLocalEquip(ply, plyItem, item)
    OBJECT_TYPE.OnEquip(ply, plyItem, item)
end

local emptyAng = Angle()
local emptyVec = Vector()
local vec1 = Vector(1, 1, 1)
local seqAnim, actAnim = "idle_camera", ACT_HL2MP_IDLE_CAMERA

local function playEquipAnim(ply)
    local seqNum = ply:LookupSequence(seqAnim)
    local seqDur = ply:SequenceDuration(seqNum)/4

    if ply:IsPlayer() then
        hook.Add("CalcMainActivity", "ashop_animwearable", function(plyAnim, vel)
            if ply == plyAnim then
                return actAnim, seqNum
            end
        end)

        timer.Simple(seqDur, function()
            hook.Remove("CalcMainActivity", "ashop_animwearable")
        end)
    end
end

// Ghetto trick
// I can't verify if the player was visible this frame
// So I use the last frame
// PrepLayerDraw does not work, since some PM are rendered after some accessories ( Ex. Opaque acc, translucent ply )
// I can't use DrawModel because of bonemerged accessories
// It could be do-able, but this would be painful
local wasRenderedThisFrame = {}
local wasRenderedPostFrame = {}

hook.Add('PrePlayerDraw', 'ashop_AddFrameWearable', function(ply)
    wasRenderedThisFrame[ply] = true
end)

hook.Add('PostRender', 'ashop_ClearFrameWearable', function()
    wasRenderedPostFrame = wasRenderedThisFrame
    wasRenderedThisFrame = {}
end)

function OBJECT_TYPE.OnEquip(ply, plyItem, item)
    // item object: {itemTable, metadata, sub_category}
    local boneName = ashop.GetSubTypeAttributeByPlayerItem(plyItem, 1)
    local model = ashop.GetItemAttribute(plyItem, item, 1)
    local pac3 = ashop.GetItemAttribute(plyItem, item, 2)

    local boneID = ply:LookupBone(boneName)

    if !boneID then
        print('[AShop] Wearable object_type. This model "' .. ply:GetModel() .. '" does not have the bone "' .. boneName .. '"')
        return
    end

    playEquipAnim(ply)
    local cm = ClientsideModel(model)
    cm.owner = ply:GetClass()

    if !ply:IsPlayer() then
        cm:SetNoDraw(true)
    elseif ply == LocalPlayer() then
        function cm:RenderOverride(f)
            // The issue is that PrePlayerDraw may not use the correct flags to render
            // the prop, I think. This way is less intrusive since it let source
            // handle rendering flags without having me to interfere with a custom
            // entity or any bullshit.
            if (!ply.ShouldDrawLocalPlayer or ply:ShouldDrawLocalPlayer()) then
                self:DrawModel(f)
            end
        end
    else
        function cm:RenderOverride(f)
            if wasRenderedPostFrame[ply] then
                self:DrawModel(f)
            end
        end
    end

    local offsetPos = (ashop.GetItemAttribute(plyItem, item, 3) or emptyVec) +
        (ashop.GetItemAttribute(plyItem, item, 6) or emptyVec)

    local offsetAng = (ashop.GetItemAttribute(plyItem, item, 4) or emptyAng) +
        (ashop.GetItemAttribute(plyItem, item, 5) or emptyAng)

    local offsetScale = vec1 *
        (ashop.GetItemAttribute(plyItem, item, 7) or vec1) +
        (ashop.GetItemAttribute(plyItem, item, 8) or emptyVec)

    offsetScale.x = math.Clamp(offsetScale.x, 0.02, 5)
    offsetScale.y = math.Clamp(offsetScale.y, 0.02, 5)
    offsetScale.z = math.Clamp(offsetScale.z, 0.02, 5)

    if offsetScale != emptyVec then
        local mat = Matrix()
        mat:Scale(offsetScale)
        cm:EnableMatrix("RenderMultiply", mat)
    end

    local s = ashop.GetItemAttribute(plyItem, item, 11)
    cm:SetSkin(isnumber(s) and s or 1)

    local clr = ashop.GetItemAttribute(plyItem, item, 9)
    if clr then
        cm:SetRenderMode(RENDERMODE_TRANSCOLOR)
        cm:SetColor(clr)
    end
    
    if pac and pac3 and ashop.pac3[pac3] and ashop.pac3[pac3].outfit then
        local e = ashop.pac3[pac3].model_attach and cm or ply

        pac.SetupENT(e)
        e:AttachPACPart(ashop.pac3[pac3].outfit)
    end

    if item.metadata[10] then
        cm:SetParent(ply)
        cm:AddEffects(EF_BONEMERGE)
    end

    cm:Spawn()

    if ply.Team and ashop.Config.jobsBlockEquipAccessories[ply:Team()] and IsValid(cm) then
        plyItem.ent[1]:Remove()
    end

    plyItem.ent = {cm, boneName, model, offsetPos, offsetAng, offsetScale}
end

function OBJECT_TYPE.OnLocalRemove(ply, plyItem, item)
    OBJECT_TYPE.OnRemove(ply, plyItem, item)
end

function OBJECT_TYPE.OnLocalFPDraw(ply)
end

// All players
function OBJECT_TYPE.OnMetadataUpdate(ply, plyItem, item, metadataKey, oldValue, newValue)
    if !plyItem.ent then return end

    local cm = plyItem.ent[1]

    if metadataKey == 1 then
        if IsValid(cm) then
            cm:Remove()
        end

        OBJECT_TYPE.OnEquip(ply, plyItem, item)
    elseif metadataKey == 5 or metadataKey == 4 then
        plyItem.ent[5] = (ashop.GetItemAttribute(plyItem, item, 4) or emptyAng) +
            (ashop.GetItemAttribute(plyItem, item, 5) or emptyAng)
    elseif metadataKey == 3 or metadataKey == 6 then
        plyItem.ent[4] = (ashop.GetItemAttribute(plyItem, item, 3) or emptyVec) +
            (ashop.GetItemAttribute(plyItem, item, 6) or emptyVec)
    elseif metadataKey == 7 or metadataKey == 8 then
        plyItem.ent[6] = vec1 *
            (ashop.GetItemAttribute(plyItem, item, 7) or vec1) +
            (ashop.GetItemAttribute(plyItem, item, 8) or emptyVec)

        plyItem.ent[6].x = math.Clamp(plyItem.ent[6].x, 0.02, 5)
        plyItem.ent[6].y = math.Clamp(plyItem.ent[6].y, 0.02, 5)
        plyItem.ent[6].z = math.Clamp(plyItem.ent[6].z, 0.02, 5)

        local mat = Matrix()
        mat:Scale(plyItem.ent[6])
        cm:EnableMatrix("RenderMultiply", mat)
    elseif metadataKey == 9 then
        if newValue then
            cm:SetColor(newValue)
            cm:SetRenderMode(RENDERMODE_TRANSCOLOR)
        else
            cm:SetRenderMode(0)
            cm:SetColor(color_white)
        end
    elseif metadataKey == 11 then
        cm:SetSkin(newValue or 1)
    elseif metadataKey == 2 then
        if oldValue and ashop.pac3[oldValue] and ashop.pac3[oldValue].outfit then
            ply:RemovePACPart(ashop.pac3[oldValue].outfit)
        end

        if newValue and ashop.pac3[newValue] and ashop.pac3[newValue].outfit then
            if !ply.AttachPACPart then
                pac.SetupENT(ply)
            end

            ply:AttachPACPart(ashop.pac3[newValue].outfit)
        end
    elseif metadataKey == 10 then
        if newValue then
            cm:AddEffects(EF_BONEMERGE)
        else
            cm:RemoveEffects(EF_BONEMERGE)
        end
    elseif metadataKey == 11 then
        cm:SetSkin(newValue or 0)
    end
end

function OBJECT_TYPE.OnRemove(ply, plyItem, item)
    if plyItem.ent then
        local pac3 = ashop.GetItemAttribute(plyItem, item, 2)

        if pac3 and ashop.pac3[pac3] then
            if ashop.pac3[pac3].model_attach then
                plyItem.ent[1]:RemovePACPart(ashop.pac3[pac3].outfit)
            else
                ply:RemovePACPart(ashop.pac3[pac3].outfit)
            end
        end

        plyItem.ent[1]:Remove()
        playEquipAnim(ply)
    end

    plyItem.ent = nil
end

function OBJECT_TYPE.OnPostPlayerDraw(ply, plyItem, item, inModelPanel)
    if !plyItem.ent or item.metadata[10] then return end

    local cm = plyItem.ent[1]
    if ply.Team and ashop.Config.jobsBlockEquipAccessories[ply:Team()] then
        if IsValid(cm) then
            plyItem.ent[1]:Remove()
        end

        return
    end

    if !IsValid(cm) then
        plyItem.ent[1]:Remove()
        OBJECT_TYPE.OnEquip(ply, plyItem, item)
        cm = plyItem.ent[1]
    end

    local boneName = plyItem.ent[2]

    local boneID = ply:LookupBone(boneName)

    if !inModelPanel then
        if !boneID then
            cm:SetNoDraw(true)
            return
        else
            cm:SetNoDraw(false)
        end
    end

    // Uh oh, lag deleted it
    local matrix = ply:GetBoneMatrix(boneID)
    if !matrix then return end
    local bonePos, boneAng = LocalToWorld( plyItem.ent[4], plyItem.ent[5], matrix:GetTranslation(), matrix:GetAngles() )

    cm:SetPos(bonePos)
    cm:SetAngles(boneAng)
    cm:SetPredictable(false)
    cm:SetupBones()

    if !inModelPanel then
        //cm:DrawModel(8)
    else
        // Don't throw tomatoes at me, this is how DModelPanel manage this
        if cm.RemovePACPart then
            pac.ShowEntityParts(cm)
            pac.ForceRendering(true)
            cm:SetupBones()
            pac.FlashlightDisable(true)

            force_draw_localplayer = true
        end
        local c = cm:GetColor()
        local old_r, old_g, old_b = render.GetColorModulation()

        render.SetColorModulation( c.r / 255, c.g / 255, c.b / 255 )
        cm:DrawModel()
        render.SetColorModulation( old_r, old_g, old_b )

        if cm.RemovePACPart then
            pac.RenderOverride(cm, "opaque")
            pac.RenderOverride(cm, "translucent")

            force_draw_localplayer = false

            pac.FlashlightDisable(false)
            pac.ForceRendering(false)
        end
    end
end

ashop.RegisterObjectType(OBJECT_TYPE)



// Cmd
local backtrack = {}
concommand.Add("ashop_OpenClothesMenu", function()
    local ply = LocalPlayer()
    local b = ashop.GetObjectTypeIDByUID('Wearables')

    local l = {}
    backtrack = backtrack or {}

    for k, v in pairs(ashop.object_types[b].sub_cat) do
        local equipped, count = ply:AShop_SlotStateGet(b, k)
        backtrack[k] = backtrack[k] or {}

        if count < 1 then continue end

        for i = 1, count do
            if !equipped[i] and (!backtrack[k][i] or !ply.ashop_data.items[backtrack[k][i]]) then continue end

            local t = {
                name = v.name .. ": " .. i,
                data = {
                    subCat = k,
                    slotID = i,
                    item = equipped[i] or backtrack[k][i],
                    isEquipped = equipped[i] != nil,
                    count = count
                },
            }

            table.insert(l, t)

            local c = t.data.isEquipped and color_white or ColorAlpha(color_white, 100)

            if string.StartsWith(v.metadata[2], 'ht') then
                ashop.ui.setMaterialByLink(v.metadata[2], {
                    ["$translucent"] = 1,
                }, function(m)
                    t.data.drawMe = function(x, y, w, h)
                        surface.SetMaterial(isfunction(m) and m() or m)
                        surface.SetDrawColor(c)
                        surface.DrawTexturedRect(x, y, w, h)
                    end
                end, 'UnlitGeneric')
            else
                t.data.drawMe = function(x, y, w, h)
                    draw.SimpleText(v.metadata[2], 'ashop_icon_50', x+w/2, y+h/2, c, 1, 1)
                end
            end

            ashop.ui.setMaterialByLink(v.metadata[2], nil, function(m)
                t.data.mat = m
            end, 'UnlitGeneric')
        end
    end

    if table.IsEmpty(l) then return end

    local u = vgui.Create('AShop_RadialMenu')
    function u:CallbackItem(data)
        net.Start('ashop_PlayerEquippedItem')
            net.WriteUInt(data.item, ashop.Config.BitsPlyItemID)
            net.WriteBool(true)
            net.WriteUInt(data.slotID, math.ceil(math.log(data.count, 2)))
        net.SendToServer()

        backtrack[data.subCat][data.slotID] = data.item
        u:Remove()
    end

    function u:DrawItem(data, x, y, w, h, key)
        if data.drawMe then
            data.drawMe(x, y, w, h)
            draw.NoTexture()
        end
    end

    u.desc = "Remove/Add an accessory"

    u:SetContents(table.Count(l), l)
end)
--addons/ashop/lua/ashop/code/players/network_data/sh_playernets.lua:
/*
    Mode:
    - 0, sequential
    - 1, int key
    - 2, string key
*/

ashop.Network = ashop.Network or {}

function ashop.Network.W_Bulk(t, f, mode, keySize, tblSize)
    net.WriteUInt(mode == 0 and #t or table.Count(t), tblSize)

    for k, v in (mode == 0 and ipairs or pairs)(t) do
        f(v)
        if mode > 0 then
            if mode == 1 then
                net.WriteUInt(k, keySize)
            else
                net.WriteString(k)
            end
        end
    end
end

function ashop.Network.R_Compress()
    local s = net.ReadUInt(16)
    local d = net.ReadData(s)

    return util.Decompress(d)
end

function ashop.Network.W_Compress(txt)
    txt = util.Compress(txt)
    net.WriteUInt(#txt, 16)
    net.WriteData(txt)
end

function ashop.Network.R_Bulk(f, mode, keySize, tblSize)
    local t = {}
    for i = 1, net.ReadUInt(tblSize) do
        local d = f()

        if mode == 1 then
            t[net.ReadUInt(keySize)] = d
        elseif mode == 2 then
            t[net.ReadString()] = d
        else
            table.insert(t, d)
        end
    end

    return t
end

// Type
function ashop.Network.GetReadFunction(item_type, options)
    if (!options or !options.required) and !net.ReadBool() then
        return
    end

    if item_type == TYPE_STRING then
        return net.ReadString()
    elseif item_type == TYPE_VECTOR then
        return net.ReadVector()
    elseif item_type == TYPE_ANGLE then
        return net.ReadAngle()
    elseif item_type == TYPE_COLOR then
        return net.ReadColor()
    elseif item_type == TYPE_BOOL then
        return net.ReadBool()
    elseif item_type == "FLOAT" then
        return net.ReadFloat()
    elseif string.StartWith(item_type, "UInt") then
        local n = tonumber(string.sub(item_type, 5))
        return net.ReadUInt(n)
    elseif item_type == 'ITEMID' then
        return net.ReadUInt(ashop.Config.BitsItemID)
    elseif item_type == 'DATE' then
        return net.ReadUInt(32)
    elseif item_type == 'SELECT' then
        return ashop.Network.GetReadFunction(options.outputType, options)
    elseif item_type == 'LIST' then
        // we are going recursive WOWOW
        local t = {}

        while(net.ReadBool()) do
            local t2 = {}
            for k, v in SortedPairs(options.listObjects) do
                t2[k] = ashop.Network.GetReadFunction(v[1], v[4])
            end
            table.insert(t, t2)
        end

        return t
    else
        error("Value empty, but it was specified from server")
    end
end

function ashop.Network.GetWriteFunction(item_type, value, options)
    if !options or !options.required then
        net.WriteBool(value != nil)
        if value == nil then return end
    end

    if item_type == TYPE_STRING then
        net.WriteString(value)
    elseif item_type == TYPE_VECTOR then
        net.WriteVector(value)
    elseif item_type == TYPE_ANGLE then
        net.WriteAngle(value)
    elseif item_type == TYPE_COLOR then
        net.WriteColor(value)
    elseif item_type == TYPE_BOOL then
        net.WriteBool(value)
    elseif item_type == 'ITEMID' then
        net.WriteUInt(value, ashop.Config.BitsItemID)
    elseif string.StartWith(item_type, "UInt") then
        local n = tonumber(string.sub(item_type, 5))
        net.WriteUInt(value, n)
    elseif item_type == "FLOAT" then
        net.WriteFloat(value)
    elseif item_type == 'SELECT' then
        ashop.Network.GetWriteFunction(options.outputType, value, options)
    elseif item_type == 'DATE' then
        net.WriteUInt(value, 32)
    elseif item_type == 'LIST' then
        // Array of OBJECT, explained by options.listObjects
        for k, v in SortedPairs(value) do
            net.WriteBool(true)

            for key, j in SortedPairs(v) do
                ashop.Network.GetWriteFunction(options.listObjects[key][1], j, options.listObjects[key][4])
            end
        end
        net.WriteBool(false)
    else
        assert("Unknown write function for type: ", item_type)
    end
end

function ashop.Network.GetNetSizeData(item_type, value, options)
    local sum = 0

    if !options or !options.required then
        sum = sum + 1/8
        if value == nil then return 1 end
    end

    if item_type == TYPE_STRING then
        sum = sum + 1 + string.len(value)
    elseif item_type == TYPE_VECTOR then
        sum = sum + 32/8 * 3
    elseif item_type == TYPE_ANGLE then
        sum = sum + 32/4 * 3
    elseif item_type == TYPE_COLOR then
        sum = sum + 4
    elseif item_type == TYPE_BOOL then
        sum = sum + 1/8
    elseif item_type == 'ITEMID' then
        sum = sum + ashop.Config.BitsItemID/8
    elseif string.StartWith(item_type, "UInt") then
        local n = tonumber(string.sub(item_type, 5))
        sum = sum + n/8
    elseif item_type == "FLOAT" then
        sum = sum + 32/8
    elseif item_type == 'SELECT' then
        sum = sum + ashop.Network.GetNetSizeData(options.outputType, value, options)
    elseif item_type == 'DATE' then
        sum = sum + 32/8
    elseif item_type == 'LIST' then
        // Array of OBJECT, explained by options.listObjects
        for k, v in SortedPairs(value) do
            sum = sum + 1/8

            for key, j in SortedPairs(v) do
                sum = sum + ashop.Network.GetNetSizeData(options.listObjects[key][1], j, options.listObjects[key][4])
            end
        end
        sum = sum + 1/8
    else
        assert("Unknown write function for type: ", item_type)
    end

    return math.ceil(sum)
end
--addons/ashop/lua/ashop/code/players/sync_datas/client/cl_openui.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels/cl_dcombobox.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels/cl_dmenu.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels/cl_radialmenu.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels/cl_shopitem.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels_actions/cl_tradescreate.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_corona.lua:
ashop.RegisterPremade("Chirurgical/Corona mask", {
        requireWorkshop = "2174343063",

        objectTypes = {
            {
                "Wearables",
                {"ValveBiped.Bip01_Head1"},
                "Facemask"
            }
        },

        items = {
            {
                name = "Corona Mask",
                rendering = 2,
                metadata = {
                    [1] = 'models/rebs/maske/maske.mdl',
                    [3] = Vector(0.40625, -5.03125, -0.0625),
                    [4] = Angle(0.25, -75, -90),
                    [11] = 1,
                },
            },

            {
                name = "Corona Mask 2",
                rendering = 2,
                metadata = {
                    [1] = 'models/rebs/maske/maske.mdl',
                    [3] = Vector(0.40625, -5.03125, -0.0625),
                    [4] = Angle(0.25, -75, -90),
                },
            },
        }
    }
)
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_gmtower.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_gtav_neck.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_tera_pets.lua:
ashop.RegisterPremade("Tera Pets", {
    requireWorkshop = "2590529696",

    objectTypes = {
        {
            "Pets",
        }
    },

    items = {
        {
            name = "Tortoise",
            rendering = 1,
            metadata = {
                [1] = 'models/defcongaming/pets/tortoise.mdl',
                [3] = 3,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 0.5,
                    },
                    [2] = {
                        [1] = 'roll',
                        [2] = 0.5,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 0.25,
                    },
                    [2] = {
                        [1] = 'spin',
                        [2] = 0.25,
                    },
                },
                [6] = {
                },
                [7] = {
                    {
                        [1] = 'jump',
                        [2] = 0.20000000298023,
                    }
                },
            },
        },

        {
            name = "Rabbit",
            rendering = 1,
            metadata = {
                [1] = 'models/defcongaming/pets/rabbit.mdl',
                [3] = 3,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 0.5,
                    },
                    [2] = {
                        [1] = 'roll',
                        [2] = 0.5,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 0.25,
                    },
                    [2] = {
                        [1] = 'spin',
                        [2] = 0.25,
                    },
                },
                [6] = {
                },
                [7] = {
                    {
                        [1] = 'jump',
                        [2] = 0.20000000298023,
                    }
                },
            },
        },

        {
            name = "Parrot",
            rendering = 1,
            metadata = {
                [1] = 'models/defcongaming/pets/parrot.mdl',
                [3] = 3,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 0.5,
                    },
                    [2] = {
                        [1] = 'roll',
                        [2] = 0.5,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 0.25,
                    },
                    [2] = {
                        [1] = 'spin',
                        [2] = 0.25,
                    },
                },
                [6] = {
                },
                [7] = {
                    {
                        [1] = 'jump',
                        [2] = 0.20000000298023,
                    }
                },
            },
        },

        {
            name = "Pigeon",
            rendering = 1,
            metadata = {
                [1] = 'models/defcongaming/pets/pigeon.mdl',
                [3] = 3,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 0.5,
                    },
                    [2] = {
                        [1] = 'roll',
                        [2] = 0.5,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 0.20000000298023,
                    },
                    [2] = {
                        [1] = 'fear',
                        [2] = 0.5,
                    },
                    [3] = {
                        [1] = 'spin',
                        [2] = 0.5,
                    },
                },
                [6] = {
                },
                [7] = {
                    {
                        [1] = 'jump',
                        [2] = 0.20000000298023,
                    }
                },
            },
        },

        {
            name = "Mice",
            rendering = 1,
            metadata = {
                [1] = 'models/defcongaming/pets/mice.mdl',
                [3] = 3,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 0.5,
                    },
                    [2] = {
                        [1] = 'roll',
                        [2] = 0.5,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 0.25,
                    },
                    [2] = {
                        [1] = 'spin',
                        [2] = 0.25,
                    },
                },
                [6] = {
                },
                [7] = {
                    {
                        [1] = 'jump',
                        [2] = 0.20000000298023,
                    }
                },
            },
        },

        {
            name = "Dove",
            rendering = 1,
            metadata = {
                [1] = 'models/defcongaming/pets/dove.mdl',
                [3] = 3,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 0.5,
                    },
                    [2] = {
                        [1] = 'roll',
                        [2] = 0.5,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 0.20000000298023,
                    },
                    [2] = {
                        [1] = 'spin',
                        [2] = 0.20000000298023,
                    },
                    [3] = {
                        [1] = 'fear',
                        [2] = 0.20000000298023,
                    },
                },
                [6] = {
                },
                [7] = {
                    {
                        [1] = 'jump',
                        [2] = 0.20000000298023,
                    }
                },
            },
        },

        {
            name = "Goldfish",
            rendering = 1,
            metadata = {
                [1] = 'models/defcongaming/pets/goldfish.mdl',
                [3] = 3,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 0.5,
                    },
                    [2] = {
                        [1] = 'roll',
                        [2] = 0.5,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 0.20000000298023,
                    },
                },
                [6] = {
                },
                [7] = {
                    {
                        [1] = 'jump',
                        [2] = 0.20000000298023,
                    }
                },
            },
        },

        {
            name = "Goldfish",
            rendering = 1,
            metadata = {
                [1] = 'models/defcongaming/pets/goldfish.mdl',
                [3] = 3,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 0.5,
                    },
                    [2] = {
                        [1] = 'roll',
                        [2] = 0.5,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 0.20000000298023,
                    },
                },
                [6] = {
                },
                [7] = {
                    {
                        [1] = 'jump',
                        [2] = 0.20000000298023,
                    }
                },
            },
        },

        {
            name = "Dog",
            rendering = 1,
            metadata = {
                [1] = 'models/defcongaming/pets/dog.mdl',
                [3] = 3,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 0.5,
                    },
                    [2] = {
                        [1] = 'roll',
                        [2] = 0.5,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 0.20000000298023,
                    },
                    [2] = {
                        [1] = 'splash',
                        [2] = 0.5,
                    },
                    [3] = {
                        [1] = 'fear',
                        [2] = 0.5,
                    },
                },
                [6] = {
                },
                [7] = {
                    {
                        [1] = 'jump',
                        [2] = 0.20000000298023,
                    }
                },
            },
        },
        {
            name = "Cat",
            rendering = 1,
            metadata = {
                [1] = 'models/defcongaming/pets/cat.mdl',
                [3] = 3,
                [4] = {
                    [1] = {
                        [1] = 'run',
                        [2] = 0.5,
                    },
                    [2] = {
                        [1] = 'roll',
                        [2] = 0.5,
                    },
                },
                [5] = {
                    [1] = {
                        [1] = 'idle',
                        [2] = 0.25,
                    },
                    [2] = {
                        [1] = 'spin',
                        [2] = 0.25,
                    },
                },
                [6] = {
                },
                [7] = {
                    {
                        [1] = 'jump',
                        [2] = 0.20000000298023,
                    }
                },
            },
        },
    }
})
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_tf2anims.lua:
ashop.RegisterPremade("wOs TF2 Taunts", {
    requireWorkshop = "3060662332",

    objectTypes = {
        {
            "Taunts",
        }
    },

    items = {
        {
            metadata={ true, 'wos_tf2_demo_taunt_conga', true, 'https://akulla.dev/ashop/conga.mp3', 0.65},
            name='Conga',
            rendering=1,
        },
        {
            metadata={ true, 'wos_tf2_demo_taunt_mannrobics_start2',true, 'https://akulla.dev/ashop/mannrobics.mp3', 0.65},
            name='Mannrobics',
            rendering=1,
        },
        {
            metadata={ true, 'wos_tf2_demo_taunt_russian',true, 'https://akulla.dev/ashop/rasputin.mp3', 0.65},
            name='Russian',
            rendering=1,
        },
    }
})
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_ura_titleeffects.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_ura_titleeffects.lua:

ashop.RegisterPremade("Title Effects", {
        requireWorkshop = "",

        objectTypes = {
            {"TitleEffect"},
        },

        items = {
            // Effects
            {
                rendering = 1,
                name = "Shiny",
                metadata = {2},
            },

            {
                rendering = 1,
                name = "Waves",
                metadata = {3},
            },

            {
                rendering = 1,
                name = "Reverse",
                metadata = {4},
            },

            {
                rendering = 1,
                name = "Pixel Wave",
                metadata = {5},
            },

            {
                rendering = 1,
                name = "Hypnotic",
                metadata = {6},
            },

            {
                rendering = 1,
                name = "Hypnotic 2",
                metadata = {7},
            },
        }
    })
--lua/autorun/badodscript.lua:
return gluapack()()
--addons/bodygroupr/lua/bodyman/bodyman_config.lua:


BODYMAN.HelpText = [[]] -- edit this to your liking.

BODYMAN.HelpText_Fr =[[]] 

BODYMAN.ClosetViewDistance = 256 -- how far the text can be seen on the closet
BODYMAN.ClosetName = "Gardırop" -- what should the closet be called?
BODYMAN.ClosetHelpText = [[Açmak için [E] tuşuna basın.]]

BODYMAN.ClosetName_Fr = "Gardırop"
BODYMAN.ClosetHelpText_Fr = [[Açmak için [E] tuşuna basın.]]

BODYMAN.ClosetsOnly = false -- set this to true if you think players MUST use a closet. They will not be able to access the interface normally.

BODYMAN.strings = {
	Appearance = "Görünüm",
	Playermodels = "Oyuncu Modeli",
	Skins = "Skin",
	Bodygroups = "Vücut Grupları",
	Save = "Kaydet",
	Load = "Yükle",
	Remove_All = "Hepsini Sil",
	Without_Saving = "Kaydetme",
	Spawn_a = "Spawn",
}
BODYMAN.strings_fr = {
	Appearance = "Görünüm",
	Playermodels = "Oyuncu Modeli",
	Skins = "Skin",
	Bodygroups = "Vücut Grupları",
	Save = "Kaydet",
	Load = "Yükle",
	Remove_All = "Hepsini Sil",
	Without_Saving = "Kaydetme",
	Spawn_a = "Spawn",
}

BODYMAN.French = false -- Set this to true if your server speaks french.

BODYMAN.ClosetsCanBreak = false -- set this to true if you want closets to be destroyable with guns
BODYMAN.ClosetHealth = 100 -- default HP of closets. increase this if you want to take more shots to destroy them.


--addons/bodygroupr/lua/bodyman/arizard_derma.lua:
return gluapack()()
--addons/bodygroupr/lua/bodyman/arizard_derma.lua:


local fontstandard = "Trebuchet24"

-- collection of generic derma panels etc
-- a drop in solution for most of my addons, so that i can get nice UI up and running faster
-- yes, you have to ask me before using this stuff

surface.CreateFont("arizard_derma_Large", {
	font = fontstandard,
	size = 32,
	antialias = true,
	weight = 800
})
surface.CreateFont("arizard_derma_Medium", {
	font = fontstandard,
	size = 24,
	antialias = true,
	weight = 800
})

surface.CreateFont("arizard_derma_Small", {
	font = fontstandard,
	size = 20,
	antialias = true,
	weight = 800
})
surface.CreateFont("arizard_derma_Tiny", {
	font = fontstandard,
	size = 12,
	antialias = true,
	weight = 600
})

local hexvals = {
    ["0"] = 0,
    ["1"] = 1,
    ["2"] = 2,
    ["3"] = 3,
    ["4"] = 4,
    ["5"] = 5,
    ["6"] = 6,
    ["7"] = 7,
    ["8"] = 8,
    ["9"] = 9,
    ["A"] = 10,
    ["B"] = 11,
    ["C"] = 12,
    ["D"] = 13,
    ["E"] = 14,
    ["F"] = 15,
}

function Hex( hex ) -- utility functions

	hex = string.upper( hex )
    hex = string.Split( hex, "" )

    local num = 0

    for i = 1, #hex do
        local h = hex[i]
        local v = hexvals[h]

        v = v * (16^(#hex-i))
        num = num + v
    end

    return num

end

function HexColor(hex, alpha)

    if string.sub(hex, 1, 1) ~= "#" then return Color(255,255,255,255) end

    hex = string.Replace(hex, "#", "") -- remove #

    local ct = {}
    local len = string.len( hex )
    if len ~= 3 and len ~= 6 then return Color(255,255,255,255) end

    for i=1,3 do
        local l2 = len/3
        local m = 1
        ct[i] = Hex( string.sub(hex, l2*i -m, l2*i) )
    end
    --PrintTable(ct)
    return Color( ct[1], ct[2], ct[3], alpha or 255)

end

local COLORS = {}
COLORS.Bad = HexColor("#e74c3c")
COLORS.BadDark = HexColor("#c0392b")
COLORS.Good = HexColor("#2ecc71")
COLORS.GoodDark = HexColor("#27ae60")
COLORS.NeutralHigh = HexColor("#ecf0f1")
COLORS.NeutralMed = HexColor("#bdc3c7")
COLORS.NeutralLow = HexColor("#95a5a6")
COLORS.NeutralDark = HexColor("#7f8c8d")
COLORS.Turq = HexColor("#e67e22")
COLORS.TurqDark = HexColor("#d35400")

function ArizardShadowText( text, font, x, y, col, ax, ay , d)
	draw.DrawText( text, font, x+d, y+d, Color(0,0,0,col.a), ax, ay )
	draw.DrawText( text, font, x, y, col, ax, ay)
end

local blur = Material("pp/blurscreen")
local function ArizardDrawBlur(panel, amount)

	local x, y = panel:LocalToScreen(0,0)
	local w, h = ScrW(), ScrH()

	surface.SetDrawColor(255,255,255)
	surface.SetMaterial(blur)

	for i = 1, 3 do -- 3 pass blur i guess?
		blur:SetFloat("$blur", (i/3) * (amount or 7))
		blur:Recompute()

		render.UpdateScreenEffectTexture()

		surface.DrawTexturedRect(x*-1,y*-1,w,h)
	end
end


local MAIN = {}

function MAIN:OnClose() end-- stub

function MAIN:Init()  
	
	self.bgalpha = 255
	self.bgcolor = COLORS.NeutralHigh
	self.fgcolor = COLORS.NeutralDark
	self.title = "Arizard Window"
   
	self.cb = vgui.Create("DButton", self)      
	function self.cb:DoClick()
		self:GetParent():OnClose()
		self:GetParent():Close()
	end
	function self.cb:PaintOver(w,h)
		draw.RoundedBox(4,0,0,w,h, COLORS.Bad)
		draw.DrawText("✖","arizard_derma_Medium",w/2,-3,COLORS.NeutralHigh, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end	

	self.inner = vgui.Create("DPanel", self)
	function self.inner:Paint() end

	self:SetSize(384,512+28+8)
	self:Center()
	self:MakePopup()
	self:ShowCloseButton( false )
	self.lblTitle:SetVisible(false)

	

end

function MAIN:PerformLayout()

	
	self.cb:SetSize(20,20)
	self.cb:SetPos(self:GetWide()-20-4, 4)

	self.inner:SetSize( self:GetWide(), self:GetTall() - 28 - 8 )
	self.inner:SetPos(0,28)


end

function MAIN:Paint(w,h)
	local inner = {x = 0,y = 28, w = self:GetWide(), h = self:GetTall() - 28 - 8}

	surface.SetDrawColor(255,255,255, 0)
	ArizardDrawBlur(self, 4)

	local bgcol = self:GetSecondaryColor()
	local fgcol = self:GetPrimaryColor()

	surface.SetDrawColor( bgcol )
	surface.DrawRect(inner.x, inner.y, inner.w, inner.h)

	surface.SetDrawColor( fgcol)
	draw.RoundedBox(4,0,0,w,16, fgcol)
	surface.DrawRect(0,8,w,20)

	draw.RoundedBox(4,0,h-8,w,8, fgcol)
	surface.DrawRect(0,h-8,w,4)

	--title
	ArizardShadowText( self.title ,"arizard_derma_Small",w/2,4,Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1)
end

function MAIN:SetPrimaryColor( col )
	self.fgcolor = table.Copy(col)
end

function MAIN:SetSecondaryColor( col )
	self.bgcolor = table.Copy(col)
end

function MAIN:GetPrimaryColor( )
	return self.fgcolor
end

function MAIN:GetSecondaryColor( )
	return self.bgcolor
end

function MAIN:SetTitle( str )
	self.title = str
end

vgui.Register("arizard_window", MAIN, "DFrame")

local BUTTN = {} -- custom buttons

function BUTTN:Init()
	self.w, self.h = 64,24
	
	self.color = {}
	self.color.up = Color(192, 57, 43)
	self.color.hover = Color(231, 76, 60)
	self.hover = false
	self.active = false

	self.font = "arizard_derma_Small"
	self.offsets = {0,-11}

	self.text = "Label"

	self.b = vgui.Create("DButton", self)

	self.b.OnCursorEntered = function()
		self.hover = true
	end

	self.b.OnCursorExited = function()
		self.hover = false
	end

	self.b.OnMousePressed = function( self2, mkey )

		self:OnMousePressed(mkey)
	end

	function self.b:Paint() end
	self.b:SetText("")
	self.disabled = false
end

function BUTTN:PerformLayout()
	self.b:SetSize(self:GetWide(),self:GetTall())
end
function BUTTN:Paint() end
function BUTTN:PaintOver(w,h)
	if self.hover == true or self.active == true then
		surface.SetDrawColor(self.color.hover)
		draw.RoundedBox(4,0,0,w,h, self.color.hover)
	elseif self.hover == false then
		surface.SetDrawColor(self.color.up)
		draw.RoundedBox(4,0,0,w,h, self.color.up)
	end
	

	ArizardShadowText(self.text,self.font,self:GetWide()/2 + self.offsets[1], self:GetTall()/2 +self.offsets[2], Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1)
end

function BUTTN:SetFont(fo)
	self.font = fo
end

function BUTTN:SetOffsets(x,y)
	self.offsets = {x,y}
end

function BUTTN:SetSelected( bool )

	self.active = bool

end

function BUTTN:SetText( text )

	self.text = text

end

function BUTTN:SetColors(upcol, hovercol)
	self.color.up = upcol
	self.color.hover = hovercol
end

function BUTTN:DoClick()

end

function BUTTN:DoRightClick()
end

function BUTTN:OnMousePressed( mkey )

	if not self.disabled then
		if mkey == MOUSE_LEFT then
			self:DoClick()
		end

		if mkey == MOUSE_RIGHT then
			self:DoRightClick()
		end
	end

end

function BUTTN:IsDown()

	if self.hover == true then
		if input.IsMouseDown( MOUSE_LEFT ) then
			return true
		end
	end

	return false
end

function BUTTN:SetDisabled( bool )
	self.disabled = bool
end


vgui.Register("arizard_button",BUTTN)


--hub multi panels

local MPANEL = {}

function MPANEL:Init()

	self.buttonoffset = 0

	self:SetSize(640,320)
	self.panels = {}
	self.buttons = {}
	self.tabs = {}

	self.color = {
		HexColor("#c0392b"),
		HexColor("#e74c3c")
	}

	self:PerformLayout()

	self.activetab = 0

	self.spacer = vgui.Create("DPanel",self)

	function self.spacer:Paint()
		surface.SetDrawColor(COLORS.NeutralLow)
		surface.DrawRect(0,0,self:GetWide(),self:GetTall())
	end
	self.spacer:SetPos(0,24)
	 -- Color(46, 204, 113)
	  -- Color(39, 174, 96)
	self.navleft = vgui.Create("arizard_button", self)
	self.navleft:SetColors( Color(39, 174, 96), Color(46, 204, 113))
	self.navleft:SetText( "<" )
	self.navleft:SetSize(24,24)

	function self.navleft:Think()
		if self:IsDown() then
			self:GetParent().buttonoffset = self:GetParent().buttonoffset + 2 * (FrameTime()/(1/100))
			self:GetParent():PerformLayout()
		end
	end

	self.navright = vgui.Create("arizard_button", self)
	self.navright:SetColors( Color(39, 174, 96), Color(46, 204, 113))
	self.navright:SetText( ">" )
	self.navright:SetSize(24,24)

	function self.navright:Think()
		if self:IsDown() then
			print("moving right")
			self:GetParent().buttonoffset = self:GetParent().buttonoffset - 2 * (FrameTime()/(1/100))
			self:GetParent():PerformLayout()
		end
	end

	self.navleft:SetZPos(99)
	self.navright:SetZPos(98)


	self.arrowsvisible = true
end

function MPANEL:ArrowsVisible( bool )

	self.navleft:SetVisible( bool )
	self.navright:SetVisible( bool )

end

function MPANEL:SetTab( idx )

	for i = 1, #self.tabs do
		
		self.buttons[self.tabs[i]]:SetSelected( false )
		self.panels[self.tabs[i]]:SetVisible( false )

	end

	self.buttons[self.tabs[idx]]:SetSelected( true )
	self.panels[self.tabs[idx]]:SetVisible( true )

end

function MPANEL:SetTabDisabled( idx, bool )

	self.buttons[self.tabs[idx]]:SetDisabled( bool )

end

function MPANEL:SetColors(c1, c2)
	self.color[1] = c1
	self.color[2] = c2

end

function MPANEL:AddTab(str_name)

	self.buttons[str_name] = vgui.Create("arizard_button", self)
	self.buttons[str_name]:SetSize(92,24)
	self.buttons[str_name]:SetText(str_name)
	self.buttons[str_name]:SetColors(COLORS.GoodDark, COLORS.Good)

	self.tabs[#self.tabs+1] = str_name

	self.activetab = #self.tabs
	self.buttons[str_name].idx = #self.tabs

	

	local temp = self.buttons[str_name]

	function temp:DoClick()
		local parent = self:GetParent()
		parent:SetTab( self.idx )
	end


	temp.PaintOver = function(self, w, h)
		if self.hover == true or self.active == true then
			surface.SetDrawColor(self.color.hover)
			draw.RoundedBox(4,0,0,self:GetWide(),12, self.color.hover)
		elseif self.hover == false then
			surface.SetDrawColor(self.color.up)
			draw.RoundedBox(4,0,0,self:GetWide(),12,self.color.up)
		end

		surface.DrawRect(0,8,self:GetWide(),self:GetTall()-8)

		ArizardShadowText(self.text,self.font,self:GetWide()/2 + self.offsets[1], self:GetTall()/2 +self.offsets[2], Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1)
	end

	self.panels[str_name] = vgui.Create("DPanel", self)
	self.panels[str_name]:SetSize(self:GetWide(),self:GetTall()-28)
	self.panels[str_name]:SetPos(0,28)
	self.panels[str_name]:SetVisible(false)

	self.panels[str_name].Paint = function(self, w, h)
		surface.SetDrawColor(Color(225,225,225))
		surface.DrawRect(0,0,w, h) -- meh
	end

	self:PerformLayout()

	self:SetTab( self.activetab )

	return self.panels[str_name]

end

function MPANEL:PerformLayout()

	
	local maxoff = -((#self.tabs * 92) - self:GetWide()) -24*2 -8
	if self.buttonoffset > 8 then self.buttonoffset = 8 end
	if self.buttonoffset < maxoff then self.buttonoffset = maxoff end

	if maxoff > 0 then self.buttonoffset = 8 end
	
	if self.navright then
		self.navright:SetPos(self:GetWide() - 24)
	end

	if self.spacer then
		self.spacer:SetSize(self:GetWide(), 4)
	end
	for i = 1,#self.tabs do
		self.buttons[self.tabs[i]]:SetPos(24+(i-1)*92+self.buttonoffset,0)
		self.buttons[self.tabs[i]].OriginalX = 8+(i-1)*92
		self.panels[self.tabs[i]]:SetSize(self:GetWide(),self:GetTall()-28)

	end

end
vgui.Register("arizard_multipanel", MPANEL)

concommand.Add("arizard_test_derma", function()
	vgui.Create("arizard_window")
end)


--addons/ch_atm/lua/autorun/ch_atm_initialize.lua:
-- INITIALIZE SCRIPT

if SERVER then
	MsgC( Color( 52, 152, 219 ), "-------------------------------------------------------------------------------\n" )
	MsgC( Color( 52, 152, 219 ), "          ATM by Crap-Head | ", color_white, "Initializing server files.\n")
	MsgC( Color( 52, 152, 219 ), "-------------------------------------------------------------------------------\n" )
	
	for k, v in ipairs( file.Find( "ch_atm/shared/*.lua", "LUA" ) ) do
		include( "ch_atm/shared/" .. v )
		AddCSLuaFile( "ch_atm/shared/" .. v )
		MsgC( Color( 52, 152, 219 ), "ATM by Crap-Head | Loaded file ", color_white, v .."\n" )
	end
	
	for k, v in ipairs( file.Find( "ch_atm/shared/currencies/*.lua", "LUA" ) ) do
		include( "ch_atm/shared/currencies/" .. v )
		AddCSLuaFile( "ch_atm/shared/currencies/" .. v )
		MsgC( Color( 52, 152, 219 ), "ATM by Crap-Head | Loaded file ", color_white, v .."\n" )
	end

	for k, v in ipairs( file.Find( "ch_atm/server/*.lua", "LUA" ) ) do
		include( "ch_atm/server/" .. v )
		MsgC( Color( 52, 152, 219 ), "ATM by Crap-Head | Loaded file ", color_white, v .."\n" )
	end
	
	for k, v in ipairs( file.Find( "ch_atm/server/sql/*.lua", "LUA" ) ) do
		include( "ch_atm/server/sql/" .. v )
		MsgC( Color( 52, 152, 219 ), "ATM by Crap-Head | Loaded file ", color_white, v .."\n" )
	end
	
	for k, v in ipairs( file.Find( "ch_atm/server/integrations/*.lua", "LUA" ) ) do
		include( "ch_atm/server/integrations/" .. v )
		MsgC( Color( 52, 152, 219 ), "ATM by Crap-Head | Loaded file ", color_white, v .."\n" )
	end
	
	for k, v in ipairs( file.Find( "ch_atm/client/*.lua", "LUA" ) ) do
		AddCSLuaFile( "ch_atm/client/" .. v )
		MsgC( Color( 52, 152, 219 ), "ATM by Crap-Head | Loaded file ", color_white, v .."\n" )
	end
	
	MsgC( Color( 52, 152, 219 ), "-----------------------------------------------------------------------------\n" )
	MsgC( Color( 52, 152, 219 ), "          ATM by Crap-Head | ", color_white, "Server files initialized\n" )
	MsgC( Color( 52, 152, 219 ), "-----------------------------------------------------------------------------\n" )
end

if CLIENT then
	MsgC( Color( 52, 152, 219 ), "-------------------------------------------------------------------------------\n" )
	MsgC( Color( 52, 152, 219 ), "       ATM by Crap-Head | ", color_white, "Initializing client/shared files\n")
	MsgC( Color( 52, 152, 219 ), "-------------------------------------------------------------------------------\n" )
	
	for k, v in ipairs( file.Find( "ch_atm/shared/*.lua", "LUA" ) ) do
		include( "ch_atm/shared/" .. v )
		MsgC( Color( 52, 152, 219 ), "ATM by Crap-Head | Loaded file ", color_white, v .."\n" )
	end
	
	for k, v in ipairs( file.Find( "ch_atm/shared/currencies/*.lua", "LUA" ) ) do
		include( "ch_atm/shared/currencies/" .. v )
		MsgC( Color( 52, 152, 219 ), "ATM by Crap-Head | Loaded file ", color_white, v .."\n" )
	end
	
	for k, v in ipairs( file.Find( "ch_atm/client/*.lua", "LUA" ) ) do
		include( "ch_atm/client/" .. v )
		MsgC( Color( 52, 152, 219 ), "ATM by Crap-Head | Loaded file ", color_white, v .."\n" )
	end
	
	MsgC( Color( 52, 152, 219 ), "-----------------------------------------------------------------------------\n" )
	MsgC( Color( 52, 152, 219 ), "          ATM by Crap-Head | ", color_white, "Client/shared files initialized\n" )
	MsgC( Color( 52, 152, 219 ), "-----------------------------------------------------------------------------\n" )
end
--addons/ch_atm/lua/ch_atm/shared/ch_atm_meta.lua:
local PMETA = FindMetaTable( "Player" )

--[[
	Simple meta function to check if players team is in the PoliceTeams table.
--]]
function PMETA:CH_ATM_IsPoliceJob()
	return CH_ATM.Config.PoliceTeams[ team.GetName( self:Team() ) ]
end

--[[
	Check if players team is allowed to rob an ATM
--]]
function PMETA:CH_ATM_CanRobATM()
	return CH_ATM.Config.CriminalTeams[ team.GetName( self:Team() ) ]
end

--[[
	Check if player is an admin
--]]
function PMETA:CH_ATM_IsAdmin()
	if CH_ATM.Config.EnableCustomAdminGroups then
		if serverguard then 
			return CH_ATM.Config.CustomAdminGroups[ serverguard.player:GetRank( self ) ] or false
		else
			return CH_ATM.Config.CustomAdminGroups[ self:GetUserGroup() ] or false
		end
	else
		return self:IsAdmin()
	end
end
--addons/ch_atm/lua/ch_atm/shared/currencies/pointshop2.lua:
return gluapack()()
--addons/ch_atm/lua/ch_atm/client/ch_atm_imgui.lua:
return gluapack()()
--addons/ch_atm/lua/ch_atm/client/ch_atm_keypad_input.lua:
--[[
	Allow the player to use keyboard for input when keypad is active
--]]

function CH_ATM.EnableKeyboardInputForKeypad()
	if not CH_ATM.Config.AllowKeyboardInputForKeypad then
		return
	end
	
	local ply = LocalPlayer()
	local cur_time = CurTime()
	local delay = 0.2
	local atm = ply.CH_ATM_IsActivelyUsingATM
	
	-- Check if the localplayer is on an ATM
	if not IsValid( atm ) then
		return
	end
	
	-- Check that the keypad is active on ATM
	if not atm.KEYPAD_CurrentScreen or atm.KEYPAD_CurrentScreen == "none" then
		return
	end
	
	-- Check if the cooldown is active
	if ( ply.CH_ATM_LastKeypadInput or cur_time ) > cur_time then
		return
	end
	
	-- All checks out lets see which buttons they press!
	if input.IsKeyDown( KEY_0 ) or input.IsKeyDown( KEY_PAD_0 ) then
		ply.CH_ATM_LastKeypadInput = cur_time + delay

		atm:KEYPAD_AcceptInput( "0" )
	elseif input.IsKeyDown( KEY_1 ) or input.IsKeyDown( KEY_PAD_1 ) then
		ply.CH_ATM_LastKeypadInput = cur_time + delay
		
		atm:KEYPAD_AcceptInput( "1" )
	elseif input.IsKeyDown( KEY_2 ) or input.IsKeyDown( KEY_PAD_2 ) then
		ply.CH_ATM_LastKeypadInput = cur_time + delay
		
		atm:KEYPAD_AcceptInput( "2" )
	elseif input.IsKeyDown( KEY_3 ) or input.IsKeyDown( KEY_PAD_3 ) then
		ply.CH_ATM_LastKeypadInput = cur_time + delay
		
		atm:KEYPAD_AcceptInput( "3" )
	elseif input.IsKeyDown( KEY_4 ) or input.IsKeyDown( KEY_PAD_4 ) then
		ply.CH_ATM_LastKeypadInput = cur_time + delay
		
		atm:KEYPAD_AcceptInput( "4" )
	elseif input.IsKeyDown( KEY_5 ) or input.IsKeyDown( KEY_PAD_5 ) then
		ply.CH_ATM_LastKeypadInput = cur_time + delay
		
		atm:KEYPAD_AcceptInput( "5" )
	elseif input.IsKeyDown( KEY_6 ) or input.IsKeyDown( KEY_PAD_6 ) then
		ply.CH_ATM_LastKeypadInput = cur_time + delay
		
		atm:KEYPAD_AcceptInput( "6" )
	elseif input.IsKeyDown( KEY_7 ) or input.IsKeyDown( KEY_PAD_7 ) then
		ply.CH_ATM_LastKeypadInput = cur_time + delay
		
		atm:KEYPAD_AcceptInput( "7" )
	elseif input.IsKeyDown( KEY_8 ) or input.IsKeyDown( KEY_PAD_8 ) then
		ply.CH_ATM_LastKeypadInput = cur_time + delay
		
		atm:KEYPAD_AcceptInput( "8" )
	elseif input.IsKeyDown( KEY_9 ) or input.IsKeyDown( KEY_PAD_9 ) then
		ply.CH_ATM_LastKeypadInput = cur_time + delay
		
		atm:KEYPAD_AcceptInput( "9" )
	elseif input.IsKeyDown( KEY_PERIOD ) or input.IsKeyDown( KEY_PAD_DECIMAL ) then
		ply.CH_ATM_LastKeypadInput = cur_time + delay
		
		atm:KEYPAD_AcceptInput( "." )
	elseif input.IsKeyDown( KEY_BACKSPACE ) or input.IsKeyDown( KEY_DELETE ) then
		ply.CH_ATM_LastKeypadInput = cur_time + delay
		
		atm:KEYPAD_AcceptInput( "CANCEL" )
	elseif input.IsKeyDown( KEY_ENTER ) or input.IsKeyDown( KEY_PAD_ENTER ) then
		ply.CH_ATM_LastKeypadInput = cur_time + delay
		
		atm:KEYPAD_AcceptInput( "ENTER" )
	end
end
hook.Add( "Think", "CH_ATM.EnableKeyboardInputForKeypad", CH_ATM.EnableKeyboardInputForKeypad )
--addons/darkrpbankrobbery2/lua/ch_bank_robbery/client/bank_fonts.lua:
surface.CreateFont( "CH_BankRobbery2_NormalText", {
	font = "Tahoma", 
	size = 25, 
	weight = 600
} )

surface.CreateFont( "CH_BankRobbery2_SubHeader", {
	font = "Tahoma", 
	size = 30, 
	weight = 600
} )

surface.CreateFont( "CH_BankRobbery2_Money", {
	font = "Trebuchet MS", 
	size = 35, 
	weight = 900
} )

surface.CreateFont( "CH_BankRobbery2_VaultName", {
	font = "Trebuchet MS", 
	size = 50, 
	weight = 950
} )

surface.CreateFont( "CH_BankRobbery2_Header", {
	font = "Trebuchet MS", 
	size = 75, 
	weight = 1000
} )
--addons/ch_bitminers/lua/autorun/ch_bitminers_initialize.lua:
-- INITIALIZE SCRIPT
if SERVER then
	for k, v in ipairs( file.Find( "ch_bitminers/shared/*.lua", "LUA" ) ) do
		include( "ch_bitminers/shared/" .. v )
		AddCSLuaFile( "ch_bitminers/shared/" .. v )
	end
	
	for k, v in ipairs( file.Find( "ch_bitminers/server/*.lua", "LUA" ) ) do
		include( "ch_bitminers/server/" .. v )
	end
	
	for k, v in ipairs( file.Find( "ch_bitminers/client/*.lua", "LUA" ) ) do
		AddCSLuaFile( "ch_bitminers/client/" .. v )
	end
end

if CLIENT then
	for k, v in ipairs( file.Find( "ch_bitminers/shared/*.lua", "LUA" ) ) do
		include( "ch_bitminers/shared/" .. v )
	end
	
	for k, v in ipairs( file.Find( "ch_bitminers/client/*.lua", "LUA" ) ) do
		include( "ch_bitminers/client/" .. v )
	end
end
--addons/ch_bitminers/lua/ch_bitminers/client/bitminers_fonts.lua:
return gluapack()()
--addons/ch_mayor/lua/ch_adv_mayor/shared/config/upgrades/upgrade_health.lua:
return gluapack()()
--addons/ch_mayor/lua/ch_adv_mayor/client/ch_mayor_load.lua:
--[[
	This is a method of ensuring that the player is loaded in, so we can network stuff to them (PlayerInitialSpawn is unreliable)
	-- 76561198347218024
--]]
function CH_Mayor.IsPlayerLoadedIn()
	if IsValid( LocalPlayer() ) then
		net.Start( "CH_Mayor_Net_HUDPaintLoad" )
		net.SendToServer()
		
		hook.Remove( "HUDPaint", "CH_Mayor.IsPlayerLoadedIn" )
	end
end
hook.Add( "HUDPaint", "CH_Mayor.IsPlayerLoadedIn", CH_Mayor.IsPlayerLoadedIn )
--addons/ch_mayor/lua/ch_adv_mayor/client/ch_mayor_robbery.lua:
return gluapack()()
--addons/ch_mayor/lua/ch_adv_mayor/client/ch_mayor_stats.lua:
return gluapack()()
--addons/ch_mayor/lua/ch_adv_mayor/client/ch_mayor_stats.lua:
net.Receive( "CH_Mayor_Net_MayorStats", function( length, ply )
	-- Setup their stats clientside
	local ply = LocalPlayer()
	
	ply.CH_Mayor_Stats = {
		["WarrantsPlaced"] = net.ReadUInt( 32 ),
		["PlayersWanted"] = net.ReadUInt( 32 ),
		["TimesElected"] = net.ReadUInt( 32 ),
		["VaultRobbed"] = net.ReadUInt( 32 ),
		["TotalPlaytime"] = net.ReadUInt( 32 ),
		["PlayersDemoted"] = net.ReadUInt( 32 ),
		["PlayersPromoted"] = net.ReadUInt( 32 ),
		["CapitalAdded"] = net.ReadUInt( 32 ),
		["LockdownsInitiated"] = net.ReadUInt( 32 ),
		["LotteriesStarted"] = net.ReadUInt( 32 ),
	}
end )
--addons/ch_mayor/lua/ch_adv_mayor/client/vgui/ch_mayor_menu.lua:
return gluapack()()
--addons/ch_mayor/lua/ch_adv_mayor/client/vgui/ch_mayor_menu.lua:
CH_Mayor.Colors = CH_Mayor.Colors or {}
CH_Mayor.Materials = CH_Mayor.Materials or {}

CH_Mayor.ScrW = ScrW()
CH_Mayor.ScrH = ScrH()

--[[
	Cache materials
--]]
CH_Mayor.Materials.CheckmarkIcon = Material( "materials/craphead_scripts/advanced_mayor/gui/checkmark.png", "noclamp smooth" )
CH_Mayor.Materials.CloseIcon = Material( "materials/craphead_scripts/advanced_mayor/gui/close.png", "noclamp smooth" )
CH_Mayor.Materials.BackIcon = Material( "materials/craphead_scripts/advanced_mayor/gui/entities/arrowbtn.png", "noclamp smooth" )
CH_Mayor.Materials.BackIconBig = Material( "materials/craphead_scripts/advanced_mayor/gui/entities/arrowbtn.png", "noclamp smooth" )

CH_Mayor.Materials.WavingHand = Material( "materials/craphead_scripts/advanced_mayor/gui/waving_hand.png", "noclamp smooth" )
CH_Mayor.Materials.Cursor = Material( "materials/craphead_scripts/advanced_mayor/gui/entities/cursor.png", "noclamp smooth" )
CH_Mayor.Materials.StripesBG = Material( "materials/craphead_scripts/advanced_mayor/gui/bg_stripes.png", "noclamp smooth" )

CH_Mayor.Materials.Icon_Dashboard = Material( "materials/craphead_scripts/advanced_mayor/gui/dashboard.png", "noclamp smooth" )
CH_Mayor.Materials.Icon_Upgrades = Material( "materials/craphead_scripts/advanced_mayor/gui/upgrades.png", "noclamp smooth" )
CH_Mayor.Materials.Icon_Taxes = Material( "materials/craphead_scripts/advanced_mayor/gui/taxes.png", "noclamp smooth" )
CH_Mayor.Materials.Icon_Catalog = Material( "materials/craphead_scripts/advanced_mayor/gui/catalog.png", "noclamp smooth" )
CH_Mayor.Materials.Icon_Laws = Material( "materials/craphead_scripts/advanced_mayor/gui/laws.png", "noclamp smooth" )
CH_Mayor.Materials.Icon_Licenses = Material( "materials/craphead_scripts/advanced_mayor/gui/licenses.png", "noclamp smooth" )
CH_Mayor.Materials.Icon_OfficialsManagement = Material( "materials/craphead_scripts/advanced_mayor/gui/officials_management.png", "noclamp smooth" )
CH_Mayor.Materials.Icon_CivilianManagement = Material( "materials/craphead_scripts/advanced_mayor/gui/civilian_management.png", "noclamp smooth" )
CH_Mayor.Materials.Icon_Wanted = Material( "materials/craphead_scripts/advanced_mayor/gui/wanted.png", "noclamp smooth" )
CH_Mayor.Materials.Icon_Warrant = Material( "materials/craphead_scripts/advanced_mayor/gui/warrant.png", "noclamp smooth" )
CH_Mayor.Materials.Icon_Announcement = Material( "materials/craphead_scripts/advanced_mayor/gui/announcement.png", "noclamp smooth" )
CH_Mayor.Materials.Icon_Lockdown = Material( "materials/craphead_scripts/advanced_mayor/gui/lockdown.png", "noclamp smooth" )
CH_Mayor.Materials.Icon_Economy = Material( "materials/craphead_scripts/advanced_mayor/gui/economy.png", "noclamp smooth" )

CH_Mayor.Materials.Icon_ItemInspect = Material( "materials/craphead_scripts/advanced_mayor/gui/inspect.png", "noclamp smooth" )

CH_Mayor.Materials.Icon_Ent_AnnouncementLeft = Material( "materials/craphead_scripts/advanced_mayor/gui/entities/announcement_left.png", "noclamp smooth" )
CH_Mayor.Materials.Icon_Ent_AnnouncementRight = Material( "materials/craphead_scripts/advanced_mayor/gui/entities/announcement_right.png", "noclamp smooth" )
CH_Mayor.Materials.Icon_Ent_Wanted = Material( "materials/craphead_scripts/advanced_mayor/gui/entities/wanted.png", "noclamp smooth" )
CH_Mayor.Materials.Icon_Ent_Exclamation = Material( "materials/craphead_scripts/advanced_mayor/gui/entities/danger.png", "noclamp smooth" )
CH_Mayor.Materials.Icon_Ent_Leaderboard = Material( "materials/craphead_scripts/advanced_mayor/gui/entities/trophy.png", "noclamp smooth" )
CH_Mayor.Materials.Icon_Ent_Cityboard = Material( "materials/craphead_scripts/advanced_mayor/gui/entities/city_board.png", "noclamp smooth" )

CH_Mayor.Materials.Icon_Ent_Leaderboard_First = Material( "materials/craphead_scripts/advanced_mayor/gui/entities/first.png", "noclamp smooth" )
CH_Mayor.Materials.Icon_Ent_Leaderboard_Second = Material( "materials/craphead_scripts/advanced_mayor/gui/entities/second.png", "noclamp smooth" )
CH_Mayor.Materials.Icon_Ent_Leaderboard_Third = Material( "materials/craphead_scripts/advanced_mayor/gui/entities/third.png", "noclamp smooth" )

--[[
	Cache colors
--]]
CH_Mayor.Colors.GrayBG = Color( 30, 30, 30, 255 )
CH_Mayor.Colors.GrayFront = Color( 22, 22, 22, 255 )
CH_Mayor.Colors.GrayAlpha = Color( 22, 22, 22, 225 )

CH_Mayor.Colors.Green = Color( 52, 178, 52, 255 )
CH_Mayor.Colors.Red = Color( 201, 29, 29, 255 )
CH_Mayor.Colors.WhiteAlpha = Color( 255, 255, 255, 5 )
CH_Mayor.Colors.WhiteAlpha2 = Color( 255, 255, 255, 100 )
CH_Mayor.Colors.GMSBlue = Color( 52, 152, 219, 255 )

--[[
	Net message to show mayor menu
	-- 76561198347218024
--]]
net.Receive( "CH_Mayor_Net_ShowMayorMenu", function( len, ply )
	CH_Mayor.DashboardMenu()
end )

--[[
	If enabled then open mayor menu via a configurable key
--]]
function CH_Mayor.KeyShowMayorMenu()
	if not CH_Mayor.Config.UseMayorMenuKey then
		return
	end
	
	local ply = LocalPlayer()
	local cur_time = CurTime()
	
	if ( ply.CH_Mayor_NetDelay or 0 ) > cur_time then
		return
	end
	
	if not ply:CH_Mayor_IsMayor() then
		return
	end
	
	-- If player is mayor
	if input.IsKeyDown( CH_Mayor.Config.MayorMenuKey ) then
		CH_Mayor.DashboardMenu()
		
		ply.CH_Mayor_NetDelay = cur_time + 2
	end
end
hook.Add( "Think", "CH_Mayor.KeyShowMayorMenu", CH_Mayor.KeyShowMayorMenu )
--addons/ch_mining/lua/ch_mining/shared/ch_mining_inventory.lua:
local PMETA = FindMetaTable( "Player" )

function PMETA:CH_Mining_InventoryHasSpace( amount )
	-- Get total amount in inventory atm
	local total_amount = 0
	
	for k, v in pairs( self.CH_Mining_Inventory ) do
		total_amount = total_amount + v
	end
	
	-- Get our capacity skill level
	local capacity_level = self:CH_Mining_GetSkillPoints( "Capacity" )
	local max_amount = CH_Mining.Skills["Capacity"].Levels[ capacity_level ]
	
	-- Check if total cur amount + amount is above max allowed amount
	return ( total_amount + amount ) <= max_amount
end

function PMETA:CH_Mining_HasMineral( mineral, amount )
	return self.CH_Mining_Inventory[ mineral ] >= amount
end
--addons/ch_mining/lua/ch_mining/shared/ch_mining_skills.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/shared/currencies/sh_pointshop_premium.lua:
CH_Mining.Currencies[ "sh_pointshop_premium" ] = {
	Name = "SH Pointshop Premium Points",
	
	AddMoney = function( ply, amount )
		ply:PS2_AddPremiumPoints( amount )
	end,
	
	TakeMoney = function( ply, amount )
		ply:PS2_AddPremiumPoints( -amount )
	end,
	
	GetMoney = function( ply )
		return ply.PS2_Wallet.premiumPoints
	end,
	
	CanAfford = function( ply, amount )
		return ply.PS2_Wallet.premiumPoints >= amount
	end,
	
	FormatMoney = function( amount )
		return string.Comma( amount ) .. " point" .. ( amount > 1 and "s" or "" )
	end,
}
--addons/ch_mining/lua/ch_mining/shared/currencies/underdone.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/client/ch_mining_leaderboards.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/client/ch_mining_xp.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/client/vgui/ch_mining_menu_leaderboards.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/client/vgui/ch_mining_menu_transactions.lua:
--[[
	MINING MENU
--]]
function CH_Mining.TransactionsMenu()
	local ply = LocalPlayer()

	local GUI_TransactionsFrame = vgui.Create( "DFrame" )
	GUI_TransactionsFrame:SetTitle( "" )
	GUI_TransactionsFrame:SetSize( CH_Mining.ScrW * 0.6, CH_Mining.ScrH * 0.6875 )
	GUI_TransactionsFrame:Center()
	GUI_TransactionsFrame.Paint = function( self, w, h )
		-- Draw frame
		surface.SetDrawColor( CH_Mining.Colors.GrayFront )
		surface.DrawRect( 0, 0, w, h )
		
		-- Draw top
		surface.SetDrawColor( CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h * 0.059 )
		
		-- Draw the top title.
		draw.SimpleText( CH_Mining.LangString( "Transactions" ), "CH_Mining_Font_Size10", w / 2, h * 0.03, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		
		-- Draw title of list
		surface.SetDrawColor( CH_Mining.Colors.GrayBG )
		surface.DrawRect( w * 0.182, h * 0.07, w * 0.812, h * 0.059 )
		
		draw.SimpleText( CH_Mining.LangString( "Mineral Sold" ), "CH_Mining_Font_Size10", w * 0.245, h * 0.095, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		
		draw.SimpleText( CH_Mining.LangString( "Amount" ), "CH_Mining_Font_Size10", w * 0.421, h * 0.095, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		
		draw.SimpleText( CH_Mining.LangString( "Earnings" ), "CH_Mining_Font_Size10", w * 0.58, h * 0.095, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		
		draw.SimpleText( CH_Mining.LangString( "Timestamp" ), "CH_Mining_Font_Size10", w * 0.72, h * 0.095, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_TransactionsFrame:MakePopup()
	GUI_TransactionsFrame:SetDraggable( false )
	GUI_TransactionsFrame:ShowCloseButton( false )
	
	local GUI_CloseMenu = vgui.Create( "DButton", GUI_TransactionsFrame )
	GUI_CloseMenu:SetPos( CH_Mining.ScrW * 0.582, CH_Mining.ScrH * 0.01 )
	GUI_CloseMenu:SetSize( 24, 24 )
	GUI_CloseMenu:SetText( "" )
	GUI_CloseMenu.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.Red or color_white )
		surface.SetMaterial( CH_Mining.Materials.CloseIcon )
		surface.DrawTexturedRect( 0, 0, CH_Mining.ScrW * 0.0125, CH_Mining.ScrH * 0.02223 )
	end
	GUI_CloseMenu.DoClick = function()
		GUI_TransactionsFrame:Remove()
	end
	
	local GUI_DashboardFrameBtn = vgui.Create( "DButton", GUI_TransactionsFrame )
	GUI_DashboardFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_DashboardFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.0475 )
	GUI_DashboardFrameBtn:SetText( "" )
	GUI_DashboardFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuDashboard )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Dashboard" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_DashboardFrameBtn.DoClick = function()
		GUI_TransactionsFrame:Remove()
		
		CH_Mining.DashboardMenu()
	end

	local GUI_InventoryFrameBtn = vgui.Create( "DButton", GUI_TransactionsFrame )
	GUI_InventoryFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_InventoryFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.095 )
	GUI_InventoryFrameBtn:SetText( "" )
	GUI_InventoryFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuInventory )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Inventory" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_InventoryFrameBtn.DoClick = function()
		GUI_TransactionsFrame:Remove()
		
		CH_Mining.InventoryMenu()
	end
	
	local GUI_SkillsFrameBtn = vgui.Create( "DButton", GUI_TransactionsFrame )
	GUI_SkillsFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_SkillsFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.1425 )
	GUI_SkillsFrameBtn:SetText( "" )
	GUI_SkillsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuSkills )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Skills" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_SkillsFrameBtn.DoClick = function()
		GUI_TransactionsFrame:Remove()
		
		CH_Mining.SkillsMenu()
	end

	local GUI_CraftingFrameBtn = vgui.Create( "DButton", GUI_TransactionsFrame )
	GUI_CraftingFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_CraftingFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.19 )
	GUI_CraftingFrameBtn:SetText( "" )
	GUI_CraftingFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuCrafting )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Crafting" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_CraftingFrameBtn.DoClick = function()
		GUI_TransactionsFrame:Remove()
		
		CH_Mining.CraftingMenu()
	end
	
	local GUI_TransactionsFrameBtn = vgui.Create( "DButton", GUI_TransactionsFrame )
	GUI_TransactionsFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_TransactionsFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.2375 )
	GUI_TransactionsFrameBtn:SetText( "" )
	GUI_TransactionsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )
		
		surface.SetDrawColor( CH_Mining.Colors.GMSBlue )
		surface.DrawRect( 0, 0, 2, h )
		
		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuTransactions )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Transactions" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_TransactionsFrameBtn.DoClick = function()
		GUI_TransactionsFrame:Remove()
		
		CH_Mining.TransactionsMenu()
	end
	
	local GUI_LeaderboardsFrameBtn = vgui.Create( "DButton", GUI_TransactionsFrame )
	GUI_LeaderboardsFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_LeaderboardsFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.285 )
	GUI_LeaderboardsFrameBtn:SetText( "" )
	GUI_LeaderboardsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuLeaderboard )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Leaderboards" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_LeaderboardsFrameBtn.DoClick = function()
		GUI_TransactionsFrame:Remove()
		
		CH_Mining.LeaderboardsMenu( "MineralsMined" )
	end
	
	local GUI_StatsFrameBtn = vgui.Create( "DButton", GUI_TransactionsFrame )
	GUI_StatsFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_StatsFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.3325 )
	GUI_StatsFrameBtn:SetText( "" )
	GUI_StatsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuStats )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Statistics" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_StatsFrameBtn.DoClick = function()
		GUI_TransactionsFrame:Remove()
		
		CH_Mining.StatsMenu()
	end
	
	local GUI_OptionsFrameBtn = vgui.Create( "DButton", GUI_TransactionsFrame )
	GUI_OptionsFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_OptionsFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.38 )
	GUI_OptionsFrameBtn:SetText( "" )
	GUI_OptionsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuOptions )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Options" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_OptionsFrameBtn.DoClick = function()
		GUI_TransactionsFrame:Remove()
		
		CH_Mining.OptionsMenu()
	end
	
	-- The transactions
	local GUI_TransactionsList = vgui.Create( "DPanelList", GUI_TransactionsFrame )
	GUI_TransactionsList:SetSize( CH_Mining.ScrW * 0.491, CH_Mining.ScrH * 0.585 )
	GUI_TransactionsList:SetPos( CH_Mining.ScrW * 0.109, CH_Mining.ScrH * 0.095 )
	GUI_TransactionsList:EnableVerticalScrollbar( true )
	GUI_TransactionsList:EnableHorizontal( true )
	GUI_TransactionsList:SetSpacing( 8.5 )
	GUI_TransactionsList.Paint = function( self, w, h )
		draw.RoundedBox( 0, 0, 0, w, h, color_transparent )
	end
	if ( GUI_TransactionsList.VBar ) then
		GUI_TransactionsList.VBar.Paint = function( self, w, h ) -- BG
			surface.SetDrawColor( CH_Mining.Colors.GrayBG )
			surface.DrawRect( 0, 0, 7, h )
		end
		
		GUI_TransactionsList.VBar.btnUp.Paint = function( self, w, h )
			surface.SetDrawColor( CH_Mining.Colors.GrayBG )
			surface.DrawRect( 0, 0, 7, h )
		end
		
		GUI_TransactionsList.VBar.btnGrip.Paint = function( self, w, h )
			surface.SetDrawColor( CH_Mining.Colors.GMSBlue )
			surface.DrawRect( 0, 0, 7, h )
		end
		
		GUI_TransactionsList.VBar.btnDown.Paint = function( self, w, h )
			surface.SetDrawColor( CH_Mining.Colors.GrayBG )
			surface.DrawRect( 0, 0, 7, h )
		end
	end
	
	-- We have never made any transactions :(
	if not ply.CH_Mining_Transactions then
		return
	end
	
	for index, trans in ipairs( ply.CH_Mining_Transactions ) do
		if trans then
			local GUI_TransactionPanel = vgui.Create( "DPanelList" )
			GUI_TransactionPanel:SetSize( CH_Mining.ScrW * 0.48, CH_Mining.ScrH * 0.04 )
			GUI_TransactionPanel.Paint = function( self, w, h )
				-- Background
				surface.SetDrawColor( CH_Mining.Colors.GrayBG )
				surface.DrawRect( 0, 0, w, h )
				
				-- Icon
				surface.SetDrawColor( CH_Mining.Rocks[ trans.Mineral ].Color )
				surface.SetMaterial( CH_Mining.Materials.Diamond )
				surface.DrawTexturedRect( w * 0.02, h * 0.14, CH_Mining.ScrW * 0.01667, CH_Mining.ScrH * 0.02963 )
				
				-- Mineral name
				draw.SimpleText( CH_Mining.LangString( trans.Mineral ), "CH_Mining_Font_Size9", w * 0.08, h / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

				-- Amount
				draw.SimpleText( string.Comma( trans.Amount ) .." ".. CH_Mining.LangString( "minerals" ), "CH_Mining_Font_Size9", w * 0.3, h / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
				
				-- Earning of the transaction
				draw.SimpleText( CH_Mining.FormatMoney( trans.Price ), "CH_Mining_Font_Size9", w * 0.5, h / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
				
				-- Timestamp
				draw.SimpleText( trans.TimeStamp, "CH_Mining_Font_Size9", w * 0.675, h / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			end

			GUI_TransactionsList:AddItem( GUI_TransactionPanel )
		end
	end
end
--addons/xenin-coinflip/lua/autorun/coinflip_load.lua:
return gluapack()()
--lua/autorun/crsk_stuff.lua:
--спасибо Vall

if CLIENT then --шрифты сюда

surface.CreateFont( "FPaceSpeedoFont", {
	font = "Trebuchet24",
	size = 80,
	weight = 600,
	scanlines = 1,
	antialias = true,

} )

surface.CreateFont( "FPaceSpeedoFont2", {
	font = "Arial",
	size = 40,
	weight = 600,
	scanlines = 1,
	antialias = true,

} )

surface.CreateFont( "StingerSpeedoFont", {
	font = "Arial",
	size = 60,
	weight = 600,
	scanlines = 1,
	antialias = true,

} )

surface.CreateFont( "ModelXSpeedoFont", {
	font = "Arial",
	size = 90,
	weight = 600,
	scanlines = 1,
	antialias = true,

} )

surface.CreateFont( "XC90SpeedoFont", {
	font = "Arial",
	size = 100,
	weight = 600,
	scanlines = 1,
	antialias = true,

} )

surface.CreateFont( "XC90SpeedoFont2", {
	font = "Arial",
	size = 30,
	weight = 600,
	scanlines = 1,
	antialias = true,

} )

surface.CreateFont( "KaroqSpeedoFont", {
	font = "Arial",
	size = 80,
	weight = 600,
	scanlines = 1,
	antialias = true,

} )

surface.CreateFont( "KaroqSpeedoFont2", {
	font = "Arial",
	size = 20,
	weight = 600,
	scanlines = 1,
	antialias = true,

} )

surface.CreateFont( "SennaSpeedoFont", {
	font = "Arial",
	size = 90,
	weight = 600,
	scanlines = 1,
	antialias = true,

} )

surface.CreateFont( "RapidSpeedoFont", {
	font = "Arial",
	size = 115,
	weight = 600,
	scanlines = 1,
	antialias = true,

} )

surface.CreateFont( "RapidSpeedoFont2", {
	font = "Arial",
	size = 60,
	weight = 600,
	scanlines = 1,
	antialias = true,

} )

surface.CreateFont( "Civic17SpeedoFont", {
	font = "Arial",
	size = 100,
	weight = 600,
	scanlines = 1,
	antialias = true,

} )

surface.CreateFont( "Civic17SpeedoFont2", {
	font = "Arial",
	size = 30,
	weight = 600,
	scanlines = 1,
	antialias = true,

} )

surface.CreateFont( "RS6AvantSpeedoFont", {
	font = "Arial",
	size = 135,
	weight = 600,
	scanlines = 1,
	antialias = true,

} )

surface.CreateFont( "RS6AvantSpeedoFont2", {
	font = "Arial",
	size = 50,
	weight = 600,
	scanlines = 1,
	antialias = true,

} )

surface.CreateFont( "VitoSpeedoFont", {
	font = "Arial",
	size = 105,
	weight = 600,
	scanlines = 1,
	antialias = true,

} )

surface.CreateFont( "MustangGT18Font", {
	font = "Arial",
	size = 250,
	weight = 600,
	scanlines = 1,
	antialias = true,

} )

surface.CreateFont( "GLECoupeSpeedoFont", {
	font = "Arial",
	size = 95,
	weight = 600,
	scanlines = 1,
	antialias = true,

} )

surface.CreateFont( "Z4G29SpeedoFont", {
	font = "Arial",
	size = 70,
	weight = 600,
	scanlines = 1,
	antialias = true,

} )

end

if SERVER then 
return 
end 

local skorost = 0
hook.Add( "PostDrawOpaqueRenderables", "CrSkCifrovoiSpeedo", function()
    local Vehicle = LocalPlayer():GetVehicle()
    if IsValid( Vehicle ) and Vehicle:GetClass() == "prop_vehicle_jeep" then
		if Vehicle:GetModel() == "models/crsk_autos/jaguar/fpace_2016.mdl" then --путь до модельки
			local skorost = math.Round(Vehicle:GetVelocity():Length() / (63360/3600),0)
			cam.Start3D2D(Vehicle:LocalToWorld(Vector(-18.33,22.13,51.92)),Vehicle:LocalToWorldAngles(Angle(0,0,75)),0.0095) --положение 3д2д
				surface.SetDrawColor(0,255,0)
				draw.SimpleText( skorost , "FPaceSpeedoFont", -50, -10, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
				draw.SimpleText( "mph" , "FPaceSpeedoFont2", -50, 50, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
			cam.End3D2D()
		end
    end
	if IsValid( Vehicle ) and Vehicle:GetClass() == "prop_vehicle_jeep" then
		if Vehicle:GetModel() == "models/crsk_autos/kia/stinger_gt_2018.mdl" then --путь до модельки
			local skorost = math.Round(Vehicle:GetVelocity():Length() / (63360/3600),0)
			cam.Start3D2D(Vehicle:LocalToWorld(Vector(-19.58,28.35,44.54)),Vehicle:LocalToWorldAngles(Angle(0,0,75)),0.0095) --положение 3д2д
				surface.SetDrawColor(0,255,0)
				draw.SimpleText( skorost , "StingerSpeedoFont", 20, -37, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
			cam.End3D2D()
		end
    end
	if IsValid( Vehicle ) and Vehicle:GetClass() == "prop_vehicle_jeep" then
		if Vehicle:GetModel() == "models/crsk_autos/tesla/model_x_2015.mdl" then --путь до модельки
			local skorost = math.Round(Vehicle:GetVelocity():Length() / (63360/3600),0)
			cam.Start3D2D(Vehicle:LocalToWorld(Vector(-18.58,12.2,53.21)),Vehicle:LocalToWorldAngles(Angle(0,0,75)),0.0095) --положение 3д2д
				surface.SetDrawColor(0,255,0)
				draw.SimpleText( skorost , "ModelXSpeedoFont", 5, -50, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
			cam.End3D2D()
		end
    end
	if IsValid( Vehicle ) and Vehicle:GetClass() == "prop_vehicle_jeep" then
		if Vehicle:GetModel() == "models/crsk_autos/volvo/xc90_t8_2015.mdl" then --путь до модельки
			local skorost = math.Round(Vehicle:GetVelocity():Length() / (63360/3600),0)
			cam.Start3D2D(Vehicle:LocalToWorld(Vector(-22.45,9.87,52.47)),Vehicle:LocalToWorldAngles(Angle(0,0,80)),0.0095) --положение 3д2д
				surface.SetDrawColor(0,255,0)
				draw.SimpleText( skorost , "XC90SpeedoFont", 15, -65, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
				draw.SimpleText( "Km/h" , "XC90SpeedoFont2", 15, 25, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
			cam.End3D2D()
		end
    end
	if IsValid( Vehicle ) and Vehicle:GetClass() == "prop_vehicle_jeep" then
		if Vehicle:GetModel() == "models/crsk_autos/skoda/karoq_2018.mdl" then --путь до модельки
			local skorost = math.Round(Vehicle:GetVelocity():Length() / (63360/3600),0)
			cam.Start3D2D(Vehicle:LocalToWorld(Vector(-14.11,18.3,47.1)),Vehicle:LocalToWorldAngles(Angle(0,0,85)),0.0095) --положение 3д2д
				surface.SetDrawColor(0,255,0)
				draw.SimpleText( skorost , "KaroqSpeedoFont", 15, -65, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
				draw.SimpleText( "km/h" , "KaroqSpeedoFont2", 15, 7, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
			cam.End3D2D()
		end
    end
	if IsValid( Vehicle ) and Vehicle:GetClass() == "prop_vehicle_jeep" then
		if Vehicle:GetModel() == "models/crsk_autos/mclaren/senna_2019.mdl" then --путь до модельки
			local skorost = math.Round(Vehicle:GetVelocity():Length() / (63360/3600),0)
			cam.Start3D2D(Vehicle:LocalToWorld(Vector(-15.63,35.0,38.3)),Vehicle:LocalToWorldAngles(Angle(0,0,100)),0.0095) --положение 3д2д
				surface.SetDrawColor(0,255,0)
				draw.SimpleText( skorost , "SennaSpeedoFont", 15, -65, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
			cam.End3D2D()
		end
    end
		if IsValid( Vehicle ) and Vehicle:GetClass() == "prop_vehicle_jeep" then
		if Vehicle:GetModel() == "models/crsk_autos/skoda/rapid_2014.mdl" then --путь до модельки
			local skorost = math.Round(Vehicle:GetVelocity():Length() / (63360/3600),0)
			cam.Start3D2D(Vehicle:LocalToWorld(Vector(-18.5,38.42,45.73)),Vehicle:LocalToWorldAngles(Angle(0,0,75)),0.0095) --положение 3д2д
				surface.SetDrawColor(0,255,0)
				draw.SimpleText( skorost , "RapidSpeedoFont", 15, -85, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
				draw.SimpleText( "km/h" , "RapidSpeedoFont2", 15, 27, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
			cam.End3D2D()
		end
    end
		if IsValid( Vehicle ) and Vehicle:GetClass() == "prop_vehicle_jeep" then
		if Vehicle:GetModel() == "models/crsk_autos/honda/civic_typer_fk8_2017.mdl" then --путь до модельки
			local skorost = math.Round(Vehicle:GetVelocity():Length() / (63360/3600),0)
			cam.Start3D2D(Vehicle:LocalToWorld(Vector(-15.9,32.2,40.15)),Vehicle:LocalToWorldAngles(Angle(0,0,50)),0.0095) --положение 3д2д
				surface.SetDrawColor(0,255,0)
				draw.SimpleText( skorost , "Civic17SpeedoFont", -35, -85, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
				draw.SimpleText( "km/h" , "Civic17SpeedoFont2", 70, -30, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
			cam.End3D2D()
		end
    end
		if IsValid( Vehicle ) and Vehicle:GetClass() == "prop_vehicle_jeep" then
		if Vehicle:GetModel() == "models/crsk_autos/audi/rs6_avant_2016.mdl" then --путь до модельки
			local skorost = math.Round(Vehicle:GetVelocity():Length() / (4/3 * 10.936133),0)
			cam.Start3D2D(Vehicle:LocalToWorld(Vector(-18.8,33.33,45.66)),Vehicle:LocalToWorldAngles(Angle(0,0,50)),0.0095) --положение 3д2д
				surface.SetDrawColor(0,255,0)
				draw.SimpleText( skorost , "RS6AvantSpeedoFont", 0, 0, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
				draw.SimpleText( "km/h" , "RS6AvantSpeedoFont2", 130, 60, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
			cam.End3D2D()
		end
    end
		if IsValid( Vehicle ) and Vehicle:GetClass() == "prop_vehicle_jeep" then
		if Vehicle:GetModel() == "models/crsk_autos/audi/rs6_avant_2016_black.mdl" then --путь до модельки
			local skorost = math.Round(Vehicle:GetVelocity():Length() / (4/3 * 10.936133),0)
			cam.Start3D2D(Vehicle:LocalToWorld(Vector(-18.8,33.33,45.66)),Vehicle:LocalToWorldAngles(Angle(0,0,50)),0.0095) --положение 3д2д
				surface.SetDrawColor(0,255,0)
				draw.SimpleText( skorost , "RS6AvantSpeedoFont", 0, 0, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
				draw.SimpleText( "km/h" , "RS6AvantSpeedoFont2", 130, 60, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
			cam.End3D2D()
		end
    end
		if IsValid( Vehicle ) and Vehicle:GetClass() == "prop_vehicle_jeep" then
		if Vehicle:GetModel() == "models/crsk_autos/mercedes-benz/vito_panel_2014.mdl" then --путь до модельки
			local skorost = math.Round(Vehicle:GetVelocity():Length() / (4/3 * 10.936133),0)
			cam.Start3D2D(Vehicle:LocalToWorld(Vector(-17.54,49.93,52.42)),Vehicle:LocalToWorldAngles(Angle(0,0,50)),0.0095) --положение 3д2д
				surface.SetDrawColor(0,255,0)
				draw.SimpleText( skorost , "VitoSpeedoFont", 0, 0, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
			cam.End3D2D()
		end
    end
		if IsValid( Vehicle ) and Vehicle:GetClass() == "prop_vehicle_jeep" then
		if Vehicle:GetModel() == "models/crsk_autos/ford/mustang_gt_2018.mdl" then --путь до модельки
			local skorost = math.Round(Vehicle:GetVelocity():Length() / (4/3 * 10.936133),0)
			cam.Start3D2D(Vehicle:LocalToWorld(Vector(-13.5,17.4,42.81)),Vehicle:LocalToWorldAngles(Angle(0,0,65)),0.0095) --положение 3д2д
				surface.SetDrawColor(0,255,0)
				draw.SimpleText( skorost , "MustangGT18Font", 0, 0, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
			cam.End3D2D()
		end
    end
		if IsValid( Vehicle ) and Vehicle:GetClass() == "prop_vehicle_jeep" then
		if Vehicle:GetModel() == "models/crsk_autos/ford/mustang_rtr_2018.mdl" then --путь до модельки
			local skorost = math.Round(Vehicle:GetVelocity():Length() / (4/3 * 10.936133),0)
			cam.Start3D2D(Vehicle:LocalToWorld(Vector(-13.5,17.4,42.81)),Vehicle:LocalToWorldAngles(Angle(0,0,65)),0.0095) --положение 3д2д
				surface.SetDrawColor(0,255,0)
				draw.SimpleText( skorost , "MustangGT18Font", 0, 0, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
			cam.End3D2D()
		end
    end
	if IsValid( Vehicle ) and Vehicle:GetClass() == "prop_vehicle_jeep" then
		if Vehicle:GetModel() == "models/crsk_autos/mercedes-benz/gle63s_coupe_amg_2015.mdl" then --путь до модельки
			local skorost = math.Round(Vehicle:GetVelocity():Length() / (4/3 * 10.936133),0)
			cam.Start3D2D(Vehicle:LocalToWorld(Vector(-21.63,36.11,53.62)),Vehicle:LocalToWorldAngles(Angle(0,0,85)),0.0095) --положение 3д2д
				surface.SetDrawColor(0,255,0)
				draw.SimpleText( skorost , "GLECoupeSpeedoFont", 0, 0, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
			cam.End3D2D()
		end
	end
	if IsValid( Vehicle ) and Vehicle:GetClass() == "prop_vehicle_jeep" then
		if Vehicle:GetModel() == "models/crsk_autos/mercedes-benz/gle63s_coupe_amg_2015_black.mdl" then --путь до модельки
			local skorost = math.Round(Vehicle:GetVelocity():Length() / (4/3 * 10.936133),0)
			cam.Start3D2D(Vehicle:LocalToWorld(Vector(-21.63,36.11,53.62)),Vehicle:LocalToWorldAngles(Angle(0,0,85)),0.0095) --положение 3д2д
				surface.SetDrawColor(0,255,0)
				draw.SimpleText( skorost , "GLECoupeSpeedoFont", 0, 0, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
			cam.End3D2D()
		end
	end
		if IsValid( Vehicle ) and Vehicle:GetClass() == "prop_vehicle_jeep" then
		if Vehicle:GetModel() == "models/crsk_autos/bmw/z4_m40i_g29_2019.mdl" then --путь до модельки
			local skorost = math.Round(Vehicle:GetVelocity():Length() / (4/3 * 10.936133),0)
			cam.Start3D2D(Vehicle:LocalToWorld(Vector(-20.10,11.27,40.75)),Vehicle:LocalToWorldAngles(Angle(0,0,85)),0.0095) --положение 3д2д
				surface.SetDrawColor(0,255,0)
				draw.SimpleText( skorost , "Z4G29SpeedoFont", 0, 0, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
			cam.End3D2D()
		end
	end
	if IsValid( Vehicle ) and Vehicle:GetClass() == "prop_vehicle_jeep" then
		if Vehicle:GetModel() == "models/crsk_autos/bmw/z4_m40i_g29_2019_black.mdl" then --путь до модельки
			local skorost = math.Round(Vehicle:GetVelocity():Length() / (4/3 * 10.936133),0)
			cam.Start3D2D(Vehicle:LocalToWorld(Vector(-20.10,11.27,40.75)),Vehicle:LocalToWorldAngles(Angle(0,0,85)),0.0095) --положение 3д2д
				surface.SetDrawColor(0,255,0)
				draw.SimpleText( skorost , "Z4G29SpeedoFont", 0, 0, Color(200,200,200), TEXT_ALIGN_CENTER, 0)
			cam.End3D2D()
		end
	end
end )
--lua/autorun/divrioters.lua:
return gluapack()()
--addons/executioner/lua/autorun/executioner_defaults.lua:
return gluapack()()
--addons/executioner_v2/lua/executioner_v2/ui/executioner_v2_avatar.lua:
return gluapack()()
--addons/executioner_v2/lua/executioner_v2/ui/executioner_v2_shop.lua:
return gluapack()()
--lua/autorun/franklin_playermodel.lua:
return gluapack()()
--addons/gmodadminsuite-config/lua/gmodadminsuite_config.lua:
return gluapack()()
--addons/gmodadminsuite-logging-2.4.8/lua/gmodadminsuite/modules/logging/lang/french.lua:
return {
	Name = "French",
	Flag = "flags16/fr.png",
	Phrases = function() return {

		module_name = "Billy's Logs",

		--####################### UI PHRASES #######################--

		no_data                     = "Aucune donnée",
		add_to_evidence_box         = "Ajouter à la boite à preuves",
		livelogs_show_logs_for      = "Afficher les Logs pour",
		background_color            = "Couleur d'Arrière Plan",
		health_abbrieviated         = "%d PV",
		livelogs                    = "Logs en Direct",
		exit_deep_storage           = "Quitter le Stockage Interne",
		log_formatting              = "Formattage des Logs",
		strings                     = "Variables",
		when                        = "Quand",
		copy_log                    = "Copier Log",
		evidence_box                = "Boite à Preuves",
		livelogs_position_x         = "Position X (pixels)",
		width                       = "Largeur",
		color                       = "Couleur",
		help                        = "Aide",
		live_log_antispam           = "< journal en direct supprimé pour antispam >",
		settings                    = "Paramètres",
		loading_ellipsis            = "Chargement...",
		livelogs_enabled            = "Activer les logs en temps réel",
		armor_abbrieviated          = "%d ARM",
		deep_storage                = "Stockage Interne",
		all_logs                    = "Tous les logs",
		logs                        = "Logs",
		padding                     = "Bordure (pixels)",
		livelogs_position_y         = "Position Y (pixels)",
		livelogs_rows_help          = "Quel est le nombre maximal de logs devant être affichés ?",
		livelogs_rows               = "Rangées (Nombre de Logs)",
		livelogs_color_help         = "Les logs doivent-ils être affichés en couleur ?",
		export_to_clipboard         = "Exporter vers le Presse-Papier",
		players                     = "Joueurs",
		script_page                 = "Page de Script",
		wiki                        = "Wiki",
		module                      = "Module",
		modules                     = "Modules",
		localization                = "Localisation",
		view_deep_storage           = "Afficher Stockage Interne",
		copied                      = "Copié !",
		operator                    = "Opérateur",
		log                         = "Log",
		reset_to_defaults           = "Réinitialiser",
		livelogs_show_logs_for_help = "Combien de secondes les logs doivent-ils être affichés ?\nMettez 0 pour toujours.",
		advanced_search             = "Recherche Avancée",
		quick_search                = "Recherche Rapide",
		quick_search_ellipsis       = "Recherche Rapide...",
		entities                    = "Entitées",
		tutorial                    = "Tutoriel",
		clear_filters               = "Nettoyer Filtre",
		no_results_found            = "Aucun résultat trouvé",
		add_player                  = "+ Ajouter Joueur",
		add_module                  = "+ Ajouter Module",
		add_entity                  = "+ Ajouter Entitée",
		add_string                  = "+ Ajouter Variable",
		modules_search_tooltip      = "Quel(s) module(s) souhaitez-vous inclure ? (laissez blanc pour aucun module)",
		players_search_tooltip      = "Quel(s) joueur(s) cherchez-vous ? (laissez blanc pour n'importe quel joueur)",
		entities_search_tooltip     = "Quelle entitée(s) cherchez-vous ? (SWEPs, SENTs, véhicule, props, classes, etc.)",
		strings_search_tooltip      = "Recherchez-vous un texte spécifique ?",
		class_name_ellipsis         = "Nom de la classe...",
		add_string_popup_title      = "Ajouter Variable",
		add_string_popup_text       = "Entrez le texte que vous essayez de trouver.",
		text_ellipsis               = "Texte...",
		click_to_focus              = "Cliquez pour obtenir le focus",
		right_click_to_focus        = "Clic droit pour obtenir le focus",
		highlight_color             = "Couleur de surlignage",
		weapon_color                = "Couleur d'Armes",
		money_color                 = "Couleur d'Argent",
		vehicle_color               = "Couleur de Véhicules",
		entity_color                = "Couleur d'Entitées",
		health_color                = "Couleur de Santé",
		armor_color                 = "Couleur d'Armure",
		usergroup_color             = "Couleur de Grade",
		unavailable_color           = "Couleur Indisponible/Inconnue",
		learn_more                  = "En savoir plus",
		player_combats              = "Combats de joueurs",
		took_damage                 = "[a pris %d dgts]",
		jump_to_pvp_event           = "Sauter à l'évènement PvP",
		remove                      = "Retirer",
		greedy                      = "Gourmande",
		greedy_tip                  = "Si votre recherche est conséquente, le système tentera de faire correspondre le plus de logs possible. Si elle n'est pas conséquente, il tentera de faire correspondre le moins de logs possible.",
		log_colouring               = "Coloration des Logs",
		done_exclamation            = "Terminé !",
		module_settings             = "Paramètres des Modules",
		storage_settings            = "Paramètres du Stockage",
		third_party_addons          = "Addons Tiers",
		pvp_settings                = "Système de Log PvP",
		live_logs_settings          = "Paramètres de Logs en Direct",
		logging_settings            = "Paramètres de Logs",
		settings                    = "Paramètres",
		enabled_modules             = "Modules Activés",
		permissions                 = "Permissions",
		gamemode_modules            = "Modules de Mode de Jeu",
		saved_exclamation           = "Sauvegardé !",
		save_settings               = "Sauvegarder Paramètres",
		weapon_class                = "Classe d'Arme",
		enter_weapon_class          = "Entrez la classe de l'arme.\nVous ne la connaissez-pas ? Ouvrez votre menu de spawn, cliquez-droit sur une arme et séléctionnez \"Copy to clipboard\"",
		save                        = "Sauvegarder",
		add_new                     = "+ Ajouter Nouveau",
		enabled                     = "Activé",
		website                     = "Site Web",
		name                        = "Nom",
		usergroups                  = "Groupes d'Utilisateurs",
		everyone                    = "Tout le Monde",
		all_modules                 = "Tout les modules",
		all_teams                   = "Toutes les équipes",
		add_usergroup               = "Ajouter Groupe d'Utilisateurs",
		cl_sv_tooltip               = [[cl réprésente le temps nécéssaire à votre ordinateur pour demander les logs, les recevoir, les lire et les afficher
		
		sv réprésente le temps nécéssaire au serveur pour récupérer les logs depuis la mémoire/la base de données, les lires et vous les envoyer

		Les serveurs utilisant MySQL auront une valeur sv supérieur en fonction de la latence entre le serveur MySQL et Garry's Mod]],
		deep_storage_help           = [[Le Stockage Interne est une fonctionnalité de bLogs qui améliore les performances en stockant les logs des sessions serveurs précédentes séparément de la session actuelle.

		Après avoir cliqué sur "Afficher Stockage Interne", vous verrez seulement les logs des sessions serveurs précédentes.
		Vous pouvez voir les logs de la session actuelle en cliquant sur le bouton ci-dessus de nouveau, ou en réouvrant le menu.

		NOTE: Les logs de dégats ne sont pas inclus dans le stockage interne et sont supprimés à chaque redémarrage du serveur pour économiser de l'espace disque]],

		class_type_other = "Autres",
		class_type_player = "Joueur",
		class_type_team = "Equipe",
		class_type_weapon = "Arme",
		class_type_vehicle = "Véhicule",
		class_type_usergroup = "Groupe d'Utilisateur",
		class_type_prop = "Prop",
		class_type_ragdoll = "Ragdoll",
		class_type_country = "Pays",
		class_type_ammo = "Munition",
		class_type_role = "Rôle",
		class_selector = "Sélecteur de classe",
		custom_class = "Classe Personnalisée",
		class_type = "Type de Classe",
		value = "Valeur",
		search = "Rechercher",
		check_all = "Tout Cocher",
		uncheck_all = "Tout Décocher",
		general = "Général",
		class_search_title = "Recherche de classe",
		class_search_text = "Entrez le nom ou une partie du nom de la classe que vous cherchez (insensibles aux majuscules/minuscules)",
		view_logs = "Voir Logs",
		open_menu = "Ouvrir Menu",
		licensed_to = "License accordée à %s",

		--####################### SETTINGS #######################--

		Player_RecordTeam = "Afficher l'équipe du joueur dans les logs",
		Player_RecordUsergroup = "Afficher le grade du joueur dans les logs",
		Player_RecordHealth = "Afficher la santé du joueur dans les logs",
		Player_RecordArmor = "Afficher l'armure du joueur dans les logs",
		Player_RecordWeapon = "Afficher l'arme du joueur dans les logs",
		Player_RecordWeapon_DoNotRecord = "Filtre d'arme du joueur",
		Player_RecordWeapon_DoNotRecord_help = "Si vous souhaitez afficher les armes des joueurs dans les logs, utilisez cette option pour filtrer les armes non-désirées (comme le physgun, toolgun, etc.)",

		OverrideMoneyFormat = "Outrepasser le formatage de l'argent par défaut",
		OverrideMoneyFormat_help = "Lorsque désactivé, le formattage de l'argent du mode de jeu sera utilisé.\nLorsque activé, vous pouvez utiliser l'option ci-dessous pour créer votre propre formattage de l'argent.",
		MoneyFormat = "Formattage de l'Argent",
		MoneyFormat_help = "Entrez la façon dont vous souhaitez que l'argent apparaisse et insérez \"%s\" (sans guillemts) à l'endroit ou vous souhaitez voir l'argent affiché.",

		MaxSessionLogs = "Logs de session max",
		MaxSessionLogs_help = "Combien de logs de la session actuelle peuvent être affichées avant de déplacer toutes les logs dans le stockage interne ? (économies de performances)\nDéfinissez sur 0 pour infini ((Déconseillée)).",

		DeepStorageTooOld = "Age max des logs du stockage interne",
		DeepStorageTooOld_help = "Combien de jours souhaitez-vous conserver les logs dans le stockage interne avant de les supprimer? (économise l'espace disque)\nDéfinissez sur 0 pour ne jamais supprimer les logs dans le stockage interne (Déconseillée).",

		LiveLogsEnabled = "Logs en Direct Activées",
		LiveLogsEnabled_help = "Les logs en direct peuvent nuire aux performances sur les gros serveurs; vous pouvez complètement désactiver cette fonctionnalité ici.",
		LiveLogsIn10Seconds = "Logs en Direct max en 10 secondes",
		LiveLogsIn10Seconds_help = "Combien de logs en direct peuvent être envoyées avant que les logs supplémentaires ne soient supprimées par l'antispam ?",
		NotifyLiveLogsAntispam = "Notifier Antispam",
		NotifyLiveLogsAntispam_help = "Les utilisateurs doivent-ils être notifiés qu'un log en direct à été supprimée par l'antispam ?",

		TimeBetweenPvPEvents = "Temps entre les évènements PvP",
		TimeBetweenPvPEvents_help = "Quant un joueur commence à se battre, il crée un \"Evènement PvP\", quand aucun combat supplémentaire n'a eu lieu dans un certain nombre de secondes, l'évènement PvP est défini comme terminé et est envoyé aux logs. Combien de secondes bLogs doit attendre avant de faire cela ?",
		NonPvPWeapons = "Filtre des Armes PvP",
		NonPvPWeapons_help = "Quelles armes ne doivent pas être considérées comme des armes PvP ?",

		server_restart_required = "NOTE: Les modification effectuées ici ne prendront effets qu'après un redémarrage du serveur.",

		gamemode_modules_tip = [[bLogs supporte un grand nombre de modes de jeu.
		Cependant, il peut arriver que bLogs ait des problèmes à détecter le mode de jeu utilisé sur votre serveur.
		Sur cet écran, vous pouvez forcer bLogs à détecter un certain mode de jeu.

		Décoché = Comportement par défaut
		Coché = Activation Forcée
		Coché avec une croix = Désactivé

		Veuillez noter que certains modes de jeu sont des dérivation du Sandbox, cela signifie qu'ils utilisent certaines fonctionnalitées du Sandbox.
		Pour les modes de jeu comme DarkRP qui dérivent du Sandbox, il est recommandé de laisser Sandbox comme mode jeu par défaut.]],

		third_party_addons_tip = [[[bLogs supporte un grand nombre d'addons tiers'.
		Cependant, il peut arriver que bLogs ait des problèmes à détecter certains addons tiers installés.
		Sur cet écran, vous pouvez forcer bLogs à détecter certains addons tiers.

		Décoché = Comportement par défaut
		Coché = Activation Forcée
		Coché avec une croix = Désactivé]],

		edit_discord_webhooks = "Modifier les Webhooks Discord",
		webhook_name = "Nom du Webhook",
		webhook_name_tip = "Entrez le nom de votre webhook.\nIl ne sagit que d'un identifiant pour le webhook, vous entrerez l'URL dans la prochaine page.",
		webhook = "Webhook",
		webhook_url = "URL Webhook",
		webhook_url_tip = "Copier l'URL webhook de votre serveur discord et collez-la ici.",
		copy_webhook = "Copier Webhook",

		can_access_module = "Peu accéder au Module",
		can_access_all_modules = "Peu accéder à tous les modules",
		all_usergroups = "Tous les Grades",
		all_jobs_in_category = "Tous les métiers dans la catégorie",
		all_teams_in_category = "Toutes les équipes dans la catégorie",
		teams = "Equipes",
		permissions_tip = "Décoché = Hérité de \"%s\"\nCoché = Autorisé à utiliser le module\nCoché avec une croix = Interdit d'utiliser le module",
		all_modules_tip = "Les permissions sont héritées de cette section sauf en cas de substitution.",

		wipes_and_resets = "Nettoyage & Réinitialisations", -- wipes as in data wipes
		disable_buttons = "Désactiver les Boutons",
		enable_buttons = "Activer les Boutons",
		wipe_deepstorage = "Nettoyer le Stockage Interne",
		wipe_session = "Nettoyer les logs de Session",
		wipe_all_logs = "Nettoyer toutes les logs",
		reset_config = "Réinitialiser configuration",

		--####################### LOG PHRASES #######################--
		Logs = {
			round_start     = "DEBUT DE MANCHE",
			round_preparing = "PREPARATION DE MANCHE",
			round_end       = "FIN DE MANCHE",

			connected                                     = "{1} se connecte",
			connected_from_country                        = "{1} se connecte depuis {2}",
			finished_connecting                           = "{1} a fini de se connecter",
			respawned                                     = "{1} réapparu",
			disconnected                                  = "{1} déconnecté ({2})",
			picked_up_weapon                              = "{1} a ramassé une arme {2}",
			picked_up_item                                = "{1} a ramassé un item {2}",
			prop_killed_self                              = "{1} s'est suicidé avec son prop {2}",
			prop_killed_other                             = "{1} a été tué par un prop posé par {2} ({3})",
			prop_killed_world                             = "{1} a été tué par un prop de map {2}",
			prop_damaged_self                             = "{1} s'est infligé {2} de dégats avec son prop {3}",
			prop_damaged_other                            = "{1} a reçu des dégats d'un prop créer par {2} pour {3} dégats ({4})",
			prop_damaged_world                            = "{1} a reçu des dégats par un prop de map {2} pour {3} dégats",
			toolgun_used_their_ent                        = "{1} a utilisé l'outils {2} sur {3}",
			toolgun_used_other_ent                        = "{1} a utilisé l'outils {2} sur {3} créer par {4}",
			toolgun_used_world_ent                        = "{1} a utilisé l'outils {2} sur {3}",
			spawned_effect                                = "{1} a fait apparaitre un effet {2}",
			spawned_npc                                   = "{1} a fait apparaitre un NPC {2}",
			spawned_prop                                  = "{1} a fait apparaitre un prop {2}",
			spawned_ragdoll                               = "{1} a fait apparaitre un ragdoll {2}",
			spawned_sent                                  = "{1} a fait apparaitre un SENT {2}",
			spawned_swep                                  = "{1} a fait apparaitre un SWEP {2}",
			spawned_vehicle                               = "{1} a fait apparaitre un véhicule {2}",

			murder_loot                                   = "{1} a ramassé du butin",

			cinema_video_queued                           = "[{1}] {2} fait la queue [{3}] \"{4}\" {5}",

			ttt_win_traitor                               = "Les Traites ont gagné !",
			ttt_win_innocent                              = "Les Innocents ont gagné !",
			ttt_win_timelimit                             = "Innocents ont gagné - Limite de temps atteinte !",
			ttt_bought                                    = "{1} a acheté {2}",
			ttt_karma                                     = "{1} a été ÉJECTÉ pour faible karma",
			ttt_foundbody                                 = "{1} a trouvé le corps de {2}",
			ttt_founddna                                  = "{1} a trouvé l'ADN de {2} sur son {3}",
			ttt_founddna_corpse                           = "{1} a trouvé l'ADN de {2} sur son cadavre",

			darkrp_agenda_updated                         = "{1} a mis à jour l'agenda {2} pour: {3}",
			darkrp_agenda_removed                         = "{1} a supprimé le {2}",
			darkrp_arrest                                 = "{1} a arrêté {2}",
			darkrp_unarrest                               = "{1} a relaché {2}",
			darkrp_batteringram_owned_success             = "{1} a enfoncé le {2} de {3}",
			darkrp_batteringram_owned_door_success        = "{1} a enfoncé la porte de {2}",
			darkrp_batteringram_success                   = "{1} a enfoncé une {2} sans propriétaire",
			darkrp_batteringram_door_success              = "{1} a enfoncé une porte sans propriétaire",
			darkrp_batteringram_owned_failed              = "{1} n'a pas réussi à enfoncer le {2} de {3}",
			darkrp_batteringram_owned_door_failed         = "{1} n'a pas réussi à enfoncer la porte de {2}",
			darkrp_batteringram_failed                    = "{1} n'a pas réussi à enfoncer la {2} sans propriétaire",
			darkrp_batteringram_door_failed               = "{1} n'a pas réussi à enfoncer une porte sans propriétaire",
			darkrp_cheque_dropped                         = "{1} a posé un chèque de {2} pour {3}",
			darkrp_cheque_picked_up                       = "{1} a empoché un chèque de {2} fait par {3}",
			darkrp_cheque_tore_up                         = "{1} a dériché un chèque de {2} destiné à {3}",
			darkrp_demoted                                = "{1} a rétrogradé {2} pour {3}",
			darkrp_demoted_afk                            = "{1} a été rétrogradé pour avoir été AFK",
			darkrp_door_sold                              = "{1} a vendu une porte",
			darkrp_door_bought                            = "{1} a acheté une porte",
			darkrp_money_dropped                          = "{1} a posé {2}",
			darkrp_money_picked_up                        = "{1} a ramassé {2}",
			darkrp_money_picked_up_owned                  = "{1} a ramassé {2} posé par {3}",
			darkrp_job_changed                            = "{1} a changé de {2} pour {3}",
			darkrp_law_added                              = "{1} a ajouté la loi: {2}",
			darkrp_law_removed                            = "{1} a supprimé la loi: {2}",
			darkrp_purchase                               = "{1} a acheté {2} pour {3}",
			darkrp_purchase_ammo                          = "{1} a acheté {2} munitionjs pour {3}",
			darkrp_purchase_shipment                      = "{1} a acheté une caisse de x{2} {3} pour {4}",
			darkrp_purchase_food                          = "{1} a acheté {2} pour {3}",
			darkrp_weapons_checked                        = "{1} a vérifié l'arme de {2}",
			darkrp_weapons_confiscated                    = "{1} a confisqué les armes de {2}",
			darkrp_weapons_returned                       = "{1} a rendu les armes confisquées de {2}",
			darkrp_filed_warant                           = "{1} a déposé un mandat sur {2} pour: {3}",
			darkrp_warrant_cancelled                      = "{1} a annulé un mandat sur {2}",
			darkrp_set_wanted                             = "{1} recherche {2} pour {3}",
			darkrp_cancelled_wanted                       = "{1} a annulé l'avis de recherche de {2}",
			darkrp_starved                                = "{1} est mort affamé",
			darkrp_pocket_added                           = "{1} a mit {2} dans son sac",
			darkrp_pocket_dropped                         = "{1} a posé {2} depuis son sac",
			darkrp_rpname_change                          = "{1} a changé de nom rp de {2} pour {3}",
			darkrp_started_lockpick_owned_entity          = "{1} a commencé à crocheter {2} possédé par {3}",
			darkrp_started_lockpick_unowned_entity        = "{1} a commencé à crocheter une {2} sans propriétaire",
			darkrp_started_lockpick_owned_door            = "{1} a commencé à crocheter une porte appartenant à {2}",
			darkrp_started_lockpick_unowned_door          = "{1} a commencé à crocheter une porte sans propriétaire",
			darkrp_started_lockpick_own_entity            = "{1} a commencé à crocheter son {2}",
			darkrp_started_lockpick_own_door              = "{1} a commencé à crocheter l'une de ses portes",
			darkrp_successfully_lockpicked_owned_entity   = "{1} a crocheté {2} possédé par {3}",
			darkrp_successfully_lockpicked_unowned_entity = "{1} a crocheté une {2} sans propriétaire",
			darkrp_successfully_lockpicked_owned_door     = "{1} a crocheté une porte appartenant à {2}",
			darkrp_successfully_lockpicked_unowned_door   = "{1} a crocheté une porte sans propriétaire",
			darkrp_successfully_lockpicked_own_entity     = "{1} a crocheté sa {2}",
			darkrp_successfully_lockpicked_own_door       = "{1} a crocheté l'une de ses portes",
			darkrp_failed_lockpick_owned_entity           = "{1} n'a pas réussi à crocheter une {2} possédé par {3}",
			darkrp_failed_lockpick_unowned_entity         = "{1} n'a pas réussi à crocheter une {2} sans propriétaire",
			darkrp_failed_lockpick_owned_door             = "{1} n'a pas réussi à crocheter une porte possédé par {2}",
			darkrp_failed_lockpick_unowned_door           = "{1} n'a pas réussi à crocheter une porte sans propriétaire",
			darkrp_failed_lockpick_own_entity             = "{1} n'a pas réussi à crocheter sa {2}",
			darkrp_failed_lockpick_own_door               = "{1} n'a pas réussi à crocheter l'une de ses portes",
			darkrp_changed_job                            = "{1} a changé de métier de {2} pour {3}",
			darkrp_added_law                              = "{1} a ajouté la loi: {2}",
			darkrp_removed_law                            = "{1} a supprimé la loi: {2}",
			darkrp_hit_accepted                           = "{1} a accepté un contrat sur {2} donné par {3}",
			darkrp_hit_completed                          = "{1} a completé un contrat sur {2} ayant été donné par {3}",
			darkrp_hit_failed                             = "{1} a échoué sur un contrat contre {2} parce que {3}",
			darkrp_hit_requested                          = "{1} a donné un contrat sur {2} pendant {3} pour {4}",
			darkrp_sold_door                              = "{1} a vendu une porte",
			darkrp_bought_door                            = "{1} a acheté une porte",
			darkrp_dropped_money                          = "{1} a posé {2}",
			darkrp_picked_up_money                        = "{1} a ramassé {2}",
			darkrp_picked_up_money_dropped_by             = "{1} a ramssé {2} ayant été posé(e) par {3}",
			darkrp_afk_demoted                            = "{1} a été rétrogradé pour avoir été AFK",

			pvp_instigator_killed_noweapon                = "{1} {2} a fini un combat et à TUÉ {3} {4} après {5}", -- after X seconds/minutes/hours
			pvp_instigator_killed_weapon                  = "{1} {2} a fini un combat en utilisant {3} et à TUÉ {4} {5} après {6}",
			pvp_instigator_killed_weapons                 = "{1} {2} a fini un combat en utilisant plusieurs armes et à TUÉ {3} {4} après {5}",
			pvp_victim_killed_noweapon                    = "{1} {2} a fini un combat et à ÉTÉ TUÉ PAR {3} {4} après {5}",
			pvp_victim_killed_weapon                      = "{1} {2} a fini un combat en utilisant {3} et A ÉTÉ TUÉ PAR {4} {5} après {6}",
			pvp_victim_killed_weapons                     = "{1} {2} a fini un combat en utilisant plusieurs armes et A ÉTÉ TUÉ PAR {3} {4} après {5}",
			pvp_combat_noweapon                           = "{1} {2} finished combat with {3} {4} après {5}",
			pvp_combat_weapon                             = "{1} {2} a fini un combat en utilisant {3} avec {4} {5} après {6}",
			pvp_combat_weapons                            = "{1} {2} a fini un combat en utilisant plusieurs armes avec {3} {4} après {5}",
			pvp_log_noweapon                              = "{1} a touché {2} infligeant {3} dégats",
			pvp_log_weapon                                = "{1} a touché {2} infligeant {3} dégats avec un(e) {4}",
			pvp_killed                                    = "{1} a tué {2}",
			pvp_vehicle_owned_killed                      = "{1} a été touché et tué par un(e) {2} sans conducteur et appartenant à {3}",
			pvp_vehicle_owned_damaged                     = "{1} a été touché, recevant {2} dégats par {3} sans conducteur, et appartenant à {4}",
			pvp_vehicle_killed                            = "{1} a été touché et tué par un(e) {2} sans conducteur et sans propriétaire",
			pvp_vehicle_damaged                           = "{1} a été touché, recevant {2} dégats par {3} sans conducteur et sans propriétaire",
			pvp_killed_self                               = "{1} s'est suicidé",
			pvp_damaged_self                              = "{1} s'est infligé {2} dégats",

			changed_team                                  = "{1} a changé d'équipe de {2} pour {3}",
			command_used                                  = "{1}: {2}",
			warned_reason                                 = "{1} a été averti par {2} pour {3}",
			warned_noreason                               = "{1} a été averti par {2}",
			warned_kicked                                 = "{1} a été ÉJECTÉ pour avoir dépassé le seuil maximal d'avertissements",
			warned_banned                                 = "{1} a été BANNI pour avoir dépassé le seuil maximal d'avertissements",
			handcuffed                                    = "{1} a menotté {2}",
			handcuffs_broken_by                           = "{1} a libéré {2} de ses menottes",
			handcuffs_broken                              = "{1} s'est libéré de ses menottes",
			npc_health_bought                             = "{1} a acheté de la santé à un PNJ pour {2}",
			npc_armor_bought                              = "{1} a acheté de l'armure à un PNJ pour {2}",
			pac_outfit                                    = "{1} a changé pour une tenue PAC {2}",
			party_chat                                    = "{1} ({2}): {3}",
			party_created                                 = "{1} a créer une partie {2}",
			party_join                                    = "{1} a rejoint une partie {2}",
			party_join_request                            = "{1} a demandé à rejoindre une partie {2}",
			party_invite                                  = "{1} a invité {2} sur la partie {3}",
			party_leave                                   = "{1} a quitté la partie {2}",
			party_kick                                    = "{1} a ejecté {2} de la partie {3}",
			party_disbanded                               = "{1} a supprimé la partie {2}",
			party_abandoned                               = "{1} a quitté le serveur et a abandonné sa partie {2}",
			spraymesh                                     = "{1} a utilisé son spray {2}",
			starwarsvehicle_damage_owned_weapon           = "{1} a infligé des dégats sur Star Wars vehicle {2} possédé par {3} pour {4} dégats avec {5}",
			starwarsvehicle_damage_owned                  = "{1} a infligé des dégats sur Star Wars vehicle {2} possédé par {3} pour {4} dégats",
			starwarsvehicle_damage_weapon                 = "{1} a infligé des dégats sur Star Wars vehicle {2} pour {3} dégats avec {4}",
			starwarsvehicle_damage                        = "{1} a infligé des dégats sur Star Wars vehicle {2} pour {3} dégats",
			wac_damage_owned_weapon                       = "{1} a infligé des dégats sur WAC aircraft {2} possédé par {3} pour {4} dégats avec {5}",
			wac_damage_owned                              = "{1} a infligé des dégats sur WAC aircraft {2} possédé par {3} pour {4} dégats",
			wac_damage_weapon                             = "{1} a infligé des dégats sur WAC aircraft {2} pour {3} dégats avec {4}",
			wac_damage                                    = "{1} a infligé des dégats sur WAC aircraft {2} pour {3} dégats",
			wyozi_cinema_queued                           = "{1} a demandé la vidéo {2} ➞ {3} au cinéma {4}",
			wyozi_dj_queued                               = "{1} a ajouté en file d'attente {2} ➞ {3} sur le canal {4}",
			wyozi_dj_channel_rename                       = "{1} a renommé le canal en {2}",
		}

} end }
--lua/gmodadminsuite/sh_offline_player_data.lua:
return gluapack()()
--lua/gmodadminsuite/sh_teams.lua:
return gluapack()()
--lua/gmodadminsuite/modules/playerdatabase/_gas_info.lua:
return gluapack()()
--addons/gprofiler/lua/gprofiler/sh_access.lua:
GProfiler.Access.AdminSystem = GProfiler.Access.AdminSystem or false

local function GlobalExists(name)
	local exists = false
	pcall(function() exists = _G[name] and true or false end)
	return exists
end

local AdminSystems = {
	["FAdmin"] = {
		Priority = 1,
		IsAvailable = function() return GlobalExists("FAdmin") end,
		RegisterPrivilege = function(name)
			FAdmin.Access.AddPrivilege(name, 2)
		end,
		CheckAccess = function(ply, name)
			return FAdmin.Access.PlayerHasPrivilege(ply, name)
		end
	},
	["ULX"] = {
		Priority = 2,
		IsAvailable = function() return GlobalExists("ULib") and GlobalExists("ulx") end,
		RegisterPrivilege = function(name)
			if SERVER then ULib.ucl.registerAccess(name, ULib.ACCESS_SUPERADMIN, "Allows access to GProfiler", "GProfiler") end
		end,
		CheckAccess = function(ply, name)
			return ULib.ucl.query(ply, name)
		end
	},
	["sAdmin"] = {
		Priority = 3,
		IsAvailable = function() return GlobalExists("sAdmin") end,
		RegisterPrivilege = function(name)
			sAdmin.registerPermission(name, "GProfiler", false)
		end,
		CheckAccess = function(ply, name)
			return sAdmin.hasPermission(ply, name)
		end
	},
	["xAdmin"] = {
		Priority = 4,
		IsAvailable = function() return GlobalExists("xAdmin") end,
		RegisterPrivilege = function(name)
			xAdmin.RegisterPermission(name, "Allows access to GProfiler", "GProfiler")
		end,
		CheckAccess = function(ply, name)
			return ply:xAdminHasPermission(name)
		end
	},
	["SAM"] = {
		Priority = 5,
		IsAvailable = function() return GlobalExists("SAM_LOADED") end,
		RegisterPrivilege = function(name)
			sam.permissions.add(name, "GProfiler", "superadmin")
		end,
		CheckAccess = function(ply, name)
			return ply:HasPermission(name)
		end
	},
	["CAMI"] = {
		Priority = 6,
		IsAvailable = function() return GlobalExists("CAMI") end,
		CheckAccess = function(ply, name)
			return ply:IsSuperAdmin()
		end
	}
}

function GProfiler.Access.FindAdminSystem()
	for name, system in SortedPairsByMemberValue(AdminSystems, "Priority") do
		if system.IsAvailable() then
			GProfiler.Access.AdminSystem = system
			GProfiler.Log("Found admin system: " .. name, 2)
			return
		end
	end

	GProfiler.Access.AdminSystem = false
end

function GProfiler.Access.RegisterPrivilege(name)
	if not GProfiler.Access.AdminSystem then
		GProfiler.Log("No admin system found, cannot register privilege: " .. name, 3)
		return
	end

	if GProfiler.Access.AdminSystem.RegisterPrivilege then
		GProfiler.Access.AdminSystem.RegisterPrivilege(name)
	end
end

hook.Add("Initialize", "GProfiler.Access.Register", function()
	GProfiler.Access.FindAdminSystem()
	GProfiler.Access.RegisterPrivilege("gprofiler")
end)

function GProfiler.Access.HasAccess(ply)
	if ply:EntIndex() == 0 then return true end -- Console
	if GProfiler.Config.AllowedSteamIDs[ply:SteamID64()] or GProfiler.Config.AllowedSteamIDs[ply:SteamID()] then return true end
	if not GProfiler.Access.AdminSystem then return false end
	return GProfiler.Access.AdminSystem.CheckAccess(ply, "gprofiler")
end

--addons/gprofiler/lua/gprofiler/profilers/auto_profile/cl_autoprofile.lua:
return gluapack()()
--addons/gprofiler/lua/gprofiler/profilers/functions/sh_functions.lua:
return gluapack()()
--lua/autorun/harleyquinn.lua:
if SERVER then
	AddCSLuaFile()
end

player_manager.AddValidModel("Harley Quinn", "models/konnie/asapgaming/fortnite/harleyquinn.mdl")
player_manager.AddValidHands( "Harley Quinn", 	"models/weapons/arms/v_arms_harleyquinn.mdl", 0, "00000000" )

player_manager.AddValidModel("Harley Quinn Trickster", "models/konnie/asapgaming/fortnite/harleyquinn_trickster.mdl")
player_manager.AddValidHands( "Harley Quinn Trickster", 	"models/weapons/arms/v_arms_harleyquinn_trickster.mdl", 0, "00000000" )
--lua/autorun/inf_blackwidow.lua:
player_manager.AddValidModel( "[K] Black Widow", "models/kryptonite/inf_blackwidow/inf_blackwidow.mdl" ) 
list.Set( "PlayerOptionsModel",  "[K] Black Widow", "models/kryptonite/inf_blackwidow/inf_blackwidow.mdl" ) 
--lua/vgui/stackercontrolpresets.lua:
--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

local PANEL = {}

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
--	PANEL:OpenPresetEditor()
--
--]]--
function PANEL:OpenPresetEditor()
	if ( not self.m_strPreset ) then return end
	self.Window = vgui.Create( "StackerPresetEditor" )
	self.Window:MakePopup()
	self.Window:Center()
	self.Window:SetType( self.m_strPreset )
	self.Window:SetConVars( self.ConVars )
	self.Window:SetPresetControl( self )
end

vgui.Register( "StackerControlPresets", PANEL, "ControlPresets" )
--lua/vgui/stackerpreseteditor.lua:
--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

local PANEL = {}

--[[--------------------------------------------------------------------------
-- 	Localized Functions & Variables
--------------------------------------------------------------------------]]--

local vgui = vgui
local pairs = pairs
local AccessorFunc = AccessorFunc
local GetConVarString = GetConVarString

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

AccessorFunc( PANEL, "m_ConCommands", "ConCommands" )

--[[--------------------------------------------------------------------------
--
--	PANEL:Add()
--
--]]--
function PANEL:Add()
	if ( not self.m_ConVars ) then return end
	
	local ToName = self.txtName:GetValue()
	if ( not ToName or ToName == "" ) then return end
	
	-- Todo, Handle name collision
	local tabValues = {}
	
	for k, v in pairs( self.m_ConVars ) do
		tabValues[ v.CCmd ] = GetConVarString( v.CVar )
	end
		
	presets.Add( self.m_strType, ToName, tabValues )
	self:Update()
	self.PresetList:SelectByName( ToName )
	self.txtName:SetText( "" )
	
	if ( self.m_PresetControl ) then
		self.m_PresetControl:Update()
	end
end

vgui.Register( "StackerPresetEditor", PANEL, "PresetEditor" )
--lua/autorun/kuma_terrorists.lua:
player_manager.AddValidModel("Al Qaeda Commando","models/player/kuma/alqaeda_commando.mdl")
list.Set("PlayerOptionsModel","Al Qaeda Commando","models/player/kuma/alqaeda_commando.mdl")
player_manager.AddValidModel("Taliban Bomber","models/player/kuma/taliban_bomber.mdl")
list.Set("PlayerOptionsModel","Taliban Bomber","models/player/kuma/taliban_bomber.mdl")
player_manager.AddValidModel("Taliban RPG","models/player/kuma/taliban_rpg.mdl")
list.Set("PlayerOptionsModel","Taliban RPG","models/player/kuma/taliban_rpg.mdl")
player_manager.AddValidModel("Taliban Grunt","models/player/kuma/taliban_grunt.mdl")
list.Set("PlayerOptionsModel","Taliban Grunt","models/player/kuma/taliban_grunt.mdl")
--addons/minigame-tool-assistant/lua/minigames/vgui/setupgame.lua:
return gluapack()()
--addons/minigame-tool-assistant/lua/minigames/games/simonsays.lua:
return gluapack()()
--addons/minigame-tool-assistant/lua/minigames/games/templetumble.lua:
--[[--------------------------------------------
                Example Minigame
--------------------------------------------]]--

local SmallSquares = 94.89968
local BigSquares = 142.352

-- local RampAngle = Angle(0, 0, 45)
local RampOffset = Vector(0, 90, 30)
local RockModel = "models/hunter/misc/sphere2x2.mdl"

--[[----------------------------
       Initial Game Config
----------------------------]]--

local GameScript = Minigames.CreateNewGame()

GameScript:SetGameName("Temple Tumble")

GameScript:AddHeader("!gameconfig")

GameScript:AddConfig("RocksAmount", {
    min = 1,
    max = 5,
    def = 2
})

GameScript:AddHeader("!playzoneconfig")

GameScript:AddConfig("BigSquares", {
    def = false
})

GameScript:AddConfig("RampSize", {
    min = 2,
    max = 8,
    def = 2
})

GameScript:AddConfig("RampAngle", {
    min = 20,
    max = 80,
    def = 45
})

GameScript:AddConfig("Wide", {
    min = 1,
    max = 20,
    def = 5
})

GameScript:AddConfig("Offset", {
    min = 0,
    max = 100,
    def = 0
})

GameScript:AddConfig("Height", {
    min = 150,
    max = 2048,
    def = 200
})


--[[----------------------------
             Custom
----------------------------]]--

GameScript.RocksSpawnPos = {}


--[[----------------------------
        Trigger Events
----------------------------]]--

GameScript:AddHook( "PostPlayerDeath", "GetFallDamage" )

--[[----------------------------
          Main Functions
----------------------------]]--

function GameScript:StartGame()
    return Minigames.GameStart( self )
end

function GameScript:StopGame()
    self:RemoveAllPlayers(true)

    return Minigames.GameStop( self )
end

function GameScript:ToggleGame()
    local Result = false

    if self:IsActive() then

        Result = self:StopGame()
        self:SetActive(false)

    else

        Result = self:StartGame()
        self:SetActive(true)

    end

    return Result
end

function GameScript:SpawnGame( trace, owner )

    --[[--------------------------------
              Initial Prefabs
    --------------------------------]]--
    local UseBigSquares = self:GetOwnerConfig("BigSquares")
    local HeightOffset = self:GetOwnerConfig("Height")
    local RampSize = self:GetOwnerConfig("RampSize")
    local Offset = self:GetOwnerConfig("Offset")
    local Wide = self:GetOwnerConfig("Wide")

    local SquareSize = UseBigSquares and BigSquares or SmallSquares
    local SquareClass = UseBigSquares and "minigame_bigsquare" or "minigame_square"
    local RampAngle = Angle(0, 0, self:GetOwnerConfig("RampAngle"))

    local Pos = trace.HitPos + trace.HitNormal * HeightOffset
    local PosOffset = Vector(
        ( ( Offset + SquareSize ) * ( Wide - 1 ) ) / 2,
        0,
        0
    )

    Pos:Sub(PosOffset)

    for i = 0, Wide - 1 do
        square = self:CreateEntity(SquareClass)
        square:SetPos(Pos + Vector( (Offset + SquareSize) * i, 0, 0))
        square:Spawn()

        ramp = self:CreateEntity(SquareClass)
        ramp:SetPos( (Pos + RampOffset) + Vector( (Offset + SquareSize) * i, 0, 0) + RampOffset)
        ramp:SetAngles(RampAngle)
        ramp:Spawn()
        ramp:SetCollisionGroup(COLLISION_GROUP_INTERACTIVE)

        for j = 1, RampSize - 1 do
            subramp = self:CreateEntity(SquareClass)
            subramp:SetPos( ramp:GetPos() + ( ramp:GetRight() * -j * SquareSize ) )
            subramp:SetAngles(RampAngle)
            subramp:Spawn()
            subramp:SetCollisionGroup(COLLISION_GROUP_INTERACTIVE)

            if ( j == RampSize - 1 ) then
                table.insert(self.RocksSpawnPos, subramp:GetPos() + Vector(0, 0, 80))
            end
        end
    end

    self:SpawnPlayZone()

    self.DefaultTeleportEntities = self:GetEntities(true)

    return true
end

function GameScript:RenderGame(trace)

end

--[[----------------------------
        Action Functions
----------------------------]]--

function GameScript:LeftClick( trace, owner, FirstTime )
    local Result = true

    if FirstTime then
        Result = self:SpawnGame( trace )
    else
        if IsValid( trace.Entity ) and trace.Entity:IsPlayer() then
            Result = self:TogglePlayer( trace.Entity )
        end
    end

    return Result
end

function GameScript:RightClick( trace, owner )

end

function GameScript:Reload( trace, owner )

end

function GameScript:Think( trace, owner )
    if CLIENT then
        self:RenderGame(trace)
    end
end

function GameScript:Deploy( trace, owner )

end

function GameScript:RollUp( trace, owner )

end

-- Minigames.RegisterNewGame(GameScript)
--addons/minigame-tool-assistant/lua/minigames/rewards/nothing.lua:
local Reward = Minigames.CreateNewReward()

Reward:SetName("Nothing")
Reward:SetNameAmount("Nothing")

Reward:SetFunctionReward(function() end)

Reward:AddArgument({
    ["Name"] = "Nothing",
    ["Type"] = "none"
})

Minigames.RegisterReward(Reward)
--addons/media_player_fixed_edition/lua/mediaplayer/controls/dmediaplayerhtml.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/mediaplayer/controls/dhtmlcontrols.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/mediaplayer/sh_events.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/mediaplayer/players/base/cl_init.lua:
include "shared.lua"
include "cl_draw.lua"
include "cl_fullscreen.lua"
include "net.lua"

local CeilPower2 = MediaPlayerUtils.CeilPower2

function MEDIAPLAYER:NetReadUpdate()
	-- Allows for another media player type to extend update net messages
end

function MEDIAPLAYER:OnNetReadMedia( media )
	-- Allows for another media player type to extend media net messages
end

function MEDIAPLAYER:OnQueueKeyPressed( down, held )
	self._LastMediaUpdate = RealTime()
end


--[[---------------------------------------------------------
	Networking
-----------------------------------------------------------]]

local function OnMediaUpdate( len )

	local mpId = net.ReadString()
	local mpType = net.ReadString()

	if MediaPlayer.DEBUG then
		print( "Received MEDIAPLAYER.Update", mpId, mpType )
	end

	local mp = MediaPlayer.GetById(mpId)
	if not mp then
		mp = MediaPlayer.Create( mpId, mpType )
	end

	-- Read owner; may be NULL
	local owner = net.ReadEntity()
	if IsValid( owner ) then
		mp:SetOwner( owner )
	end

	local state = mp.net.ReadPlayerState()

	local queueRepeat = net.ReadBool()
	mp:SetQueueRepeat( queueRepeat )

	local queueShuffle = net.ReadBool()
	mp:SetQueueShuffle( queueShuffle )

	local queueLocked = net.ReadBool()
	mp:SetQueueLocked( queueLocked )

	-- Read extended update information
	mp:NetReadUpdate()

	-- Clear old queue
	mp:ClearMediaQueue()

	-- Read queue information
	local count = net.ReadUInt( mp:GetQueueLimit(true) )
	for i = 1, count do
		local media = mp.net.ReadMedia()
		mp:OnNetReadMedia(media)
		mp:AddMedia(media)
	end

	mp:QueueUpdated()

	mp:SetPlayerState( state )

	hook.Run( "OnMediaPlayerUpdate", mp )

end
net.Receive( "MEDIAPLAYER.Update", OnMediaUpdate )

local function OnMediaSet( len )

	if MediaPlayer.DEBUG then
		print( "Received MEDIAPLAYER.Media" )
	end

	local mpId = net.ReadString()
	local mp = MediaPlayer.GetById(mpId)

	if not mp then
		if MediaPlayer.DEBUG then
			ErrorNoHalt("Received media for invalid mediaplayer\n")
			print("ID: " .. tostring(mpId))
			debug.Trace()
		end
		return
	end

	if mp:GetPlayerState() >= MP_STATE_PLAYING then
		mp:OnMediaFinished()
		mp:QueueUpdated()
	end

	local media = mp.net.ReadMedia()

	if media then
		local startTime = mp.net.ReadTime()
		media:StartTime( startTime )

		mp:OnNetReadMedia(media)

		local state = mp:GetPlayerState()

		if state == MP_STATE_PLAYING then
			media:Play()
		else
			media:Pause()
		end
	end

	mp:SetMedia( media )

end
net.Receive( "MEDIAPLAYER.Media", OnMediaSet )

local function OnMediaRemoved( len )

	if MediaPlayer.DEBUG then
		print( "Received MEDIAPLAYER.Remove" )
	end

	local mpId = net.ReadString()
	local mp = MediaPlayer.GetById(mpId)
	if not mp then return end

	mp:Remove()

end
net.Receive( "MEDIAPLAYER.Remove", OnMediaRemoved )

local function OnMediaSeek( len )

	local mpId = net.ReadString()
	local mp = MediaPlayer.GetById(mpId)
	if not ( mp and (mp:GetPlayerState() >= MP_STATE_PLAYING) ) then return end

	local startTime = mp.net.ReadTime()

	if MediaPlayer.DEBUG then
		print( "Received MEDIAPLAYER.Seek", mpId, startTime )
	end

	local media = mp:CurrentMedia()

	if media then
		media:StartTime( startTime )
	else
		ErrorNoHalt("ERROR: MediaPlayer received seek message while no media is playing" ..
			"[" .. mpId .. "]\n")
		MediaPlayer.RequestUpdate( mp )
	end

end
net.Receive( "MEDIAPLAYER.Seek", OnMediaSeek )

local function OnMediaPause( len )

	local mpId = net.ReadString()
	local mp = MediaPlayer.GetById(mpId)
	if not mp then return end

	local state = mp.net.ReadPlayerState()

	if MediaPlayer.DEBUG then
		print( "Received MEDIAPLAYER.Pause", mpId, state )
	end

	mp:SetPlayerState( state )

end
net.Receive( "MEDIAPLAYER.Pause", OnMediaPause )

--addons/media_player_fixed_edition/lua/mediaplayer/players/base/cl_draw.lua:
local Color = Color
local RealTime = RealTime
local draw = draw
local math = math
local string = string
local surface = surface

local DrawHTMLPanel = MediaPlayerUtils.DrawHTMLPanel
local FormatSeconds = MediaPlayerUtils.FormatSeconds

local TEXT_ALIGN_CENTER	= draw.TEXT_ALIGN_CENTER
local TEXT_ALIGN_TOP	= draw.TEXT_ALIGN_TOP
local TEXT_ALIGN_BOTTOM	= draw.TEXT_ALIGN_BOTTOM
local TEXT_ALIGN_LEFT	= draw.TEXT_ALIGN_LEFT
local TEXT_ALIGN_RIGHT	= draw.TEXT_ALIGN_RIGHT

local TextPaddingX = 12
local TextPaddingY = 12

local TextBoxPaddingX = 8
local TextBoxPaddingY = 2

local TextBgColor = Color(0, 0, 0, 200)
local BarBgColor = Color(0, 0, 0, 200)
local BarFgColor = Color(255, 255, 255, 255)

local function DrawText( text, font, x, y, xalign, yalign )
	return draw.SimpleText( text, font, x, y, color_white, xalign, yalign )
end

local function DrawTextBox( text, font, x, y, xalign, yalign )

	xalign = xalign or TEXT_ALIGN_LEFT
	yalign = yalign or TEXT_ALIGN_TOP

	surface.SetFont( font )
	tw, th = surface.GetTextSize( text )

	if xalign == TEXT_ALIGN_CENTER then
		x = x - tw / 2
	elseif xalign == TEXT_ALIGN_RIGHT then
		x = x - tw
	end

	if yalign == TEXT_ALIGN_CENTER then
		y = y - th / 2
	elseif yalign == TEXT_ALIGN_BOTTOM then
		y = y - th
	end

	surface.SetDrawColor( TextBgColor )
	surface.DrawRect( x, y,
		tw + TextBoxPaddingX * 2,
		th + TextBoxPaddingY * 2 )

end

local UTF8SubLastCharPattern = "[^\128-\191][\128-\191]*$"
local OverflowString = "..." -- ellipsis

---
-- Limits a rendered string's width based on a maximum width.
--
-- @param text		Text string.
-- @param font		Font.
-- @param w			Maximum width.
-- @return String	String fitting the maximum required width.
--
local function RestrictStringWidth( text, font, w )

	-- TODO: Cache this

	surface.SetFont( font )
	local curwidth = surface.GetTextSize( text )
	local overflow = false

	-- Reduce text by one character until it fits
	while curwidth > w do

		-- Text has overflowed, append overflow string on return
		if not overflow then
			overflow = true
		end

		-- Cut off last character
		text = string.gsub(text, UTF8SubLastCharPattern, "")

		-- Check size again
		curwidth = surface.GetTextSize( text .. OverflowString )

	end

	return overflow and (text .. OverflowString) or text

end

function MEDIAPLAYER:DrawHTML( browser, w, h )
	surface.SetDrawColor( 0, 0, 0, 255 )
	surface.DrawRect( 0, 0, w, h )
	DrawHTMLPanel( browser, w, h )
end

function MEDIAPLAYER:DrawMediaInfo( media, w, h )

	-- TODO: Fadeout media info instead of just hiding
	if not vgui.CursorVisible() and RealTime() - self._LastMediaUpdate > 3 then
		return
	end

	-- Text dimensions
	local tw, th

	-- Title background
	local titleStr = RestrictStringWidth( media:Title(), "MediaTitle",
		w - (TextPaddingX * 2 + TextBoxPaddingX * 2) )

	DrawTextBox( titleStr, "MediaTitle", TextPaddingX, TextPaddingY )

	-- Title
	DrawText( titleStr, "MediaTitle",
		TextPaddingX + TextBoxPaddingX,
		TextPaddingY + TextBoxPaddingY )

	-- Track bar
	if media:IsTimed() then

		local duration = media:Duration()
		local curTime = media:CurrentTime()
		local percent = math.Clamp( curTime / duration, 0, 1 )

		-- Bar height
		local bh = math.Round(h * 1 / 32)

		-- Bar background
		draw.RoundedBox( 0, 0, h - bh, w, bh, BarBgColor )

		-- Bar foreground (progress)
		draw.RoundedBox( 0, 0, h - bh, w * percent, bh, BarFgColor )

		local timeY = h - bh - TextPaddingY * 2

		-- Current time
		local curTimeStr = FormatSeconds(math.Clamp(math.Round(curTime), 0, duration))

		DrawTextBox( curTimeStr, "MediaTitle", TextPaddingX, timeY,
			TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM )
		DrawText( curTimeStr, "MediaTitle", TextPaddingX * 2, timeY,
			TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM )

		-- Duration
		local durationStr = FormatSeconds( duration )

		DrawTextBox( durationStr, "MediaTitle", w - TextPaddingX * 2, timeY,
			TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM )
		DrawText( durationStr, "MediaTitle", w - TextBoxPaddingX * 2, timeY,
			TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM )

	end

	-- Volume
	local volume = MediaPlayer.Volume()
	local volumeStr = tostring( math.Round( volume * 100 ) )

	-- DrawText( volumeStr, "MediaTitle", w - TextPaddingX, h/2,
		-- TEXT_ALIGN_CENTER )


	-- Loading indicator

end

--addons/media_player_fixed_edition/lua/mediaplayer/services/base/cl_init.lua:
include "shared.lua"

function SERVICE:Volume( volume )
	if volume then
		self._volume = tonumber(volume) or self._volume
	end
	return self._volume
end

function SERVICE:IsPaused()
	return self._PauseTime ~= nil
end

function SERVICE:Stop()
	self._playing = false
	self:emit("stop")
end

function SERVICE:PlayPause()
	if self:IsPlaying() then
		self:Pause()
	else
		self:Play()
	end
end

function SERVICE:Sync()
	-- Implement this in timed services
end

function SERVICE:NetWriteRequest()
	-- Send any additional net data here
end

function SERVICE:OnMousePressed( x, y )
end

function SERVICE:OnMouseWheeled( scrollDelta )
end

function SERVICE:IsMouseInputEnabled()
	return false
end

--addons/media_player_fixed_edition/lua/mediaplayer/services/base/shared.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/mediaplayer/services/twitch/shared.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/mediaplayer/services/archive/shared.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/autorun/mediaplayer_spawnables.lua:
return gluapack()()
--lua/autorun/obese_male_deluxe_edition.lua:
return gluapack()()
--addons/onyx_framework_2/lua/onyx/util.lua:
return gluapack()()
--addons/onyx_framework_2/lua/onyx/framework/libs/thirdparty/sh_pon.lua:
--[[

DEVELOPMENTAL VERSION;

VERSION 1.2.2
Copyright thelastpenguin™

	You may use this for any purpose as long as:
	-	You don't remove this copyright notice.
	-	You don't claim this to be your own.
	-	You properly credit the author, thelastpenguin™, if you publish your work based on (and/or using) this.

	If you modify the code for any purpose, the above still applies to the modified code.

	The author is not held responsible for any damages incured from the use of pon, you use it at your own risk.

DATA TYPES SUPPORTED:
 - tables  - 		k,v - pointers
 - strings - 		k,v - pointers
 - numbers -		k,v
 - booleans- 		k,v
 - Vectors - 		k,v
 - Angles  -		k,v
 - Entities- 		k,v
 - Players - 		k,v

CHANGE LOG
V 1.1.0
 - Added Vehicle, NPC, NextBot, Player, Weapon
V 1.2.0
 - Added custom handling for k,v tables without any array component.
V 1.2.1
 - fixed deserialization bug.

THANKS TO...
 - VERCAS for the inspiration.
]]


local pon = {};
_G.pon = pon;

local type, count = type, table.Count ;
local tonumber = tonumber ;
local format = string.format;
do
	local type, count = type, table.Count ;
	local tonumber = tonumber ;
	local format = string.format;

	local encode = {};

	local tryCache ;

	local cacheSize = 0;

	encode['table'] = function( self, tbl, output, cache )

		if( cache[ tbl ] )then
			output[ #output + 1 ] = format('(%x)',  cache[tbl] );
			return ;
		else
			cacheSize = cacheSize + 1;
			cache[ tbl ] = cacheSize;
		end


    local first = next(tbl, nil)
    local predictedNumeric = 1
    local lastKey = nil
    -- starts with a numeric dealio
    if first == 1 then
      output[#output + 1] = '{'

      for k,v in next, tbl do
        if k == predictedNumeric then
          predictedNumeric = predictedNumeric + 1

          local tv = type(v)
          if tv == 'string' then
            local pid = cache[v]
            if pid then
              output[#output + 1] = format('(%x)', pid)
            else
              cacheSize = cacheSize + 1
              cache[v] = cacheSize
              self.string(self, v, output, cache)
            end
          else
            self[tv](self, v, output, cache)
          end

        else
          break
        end
      end

			predictedNumeric = predictedNumeric - 1
    else
      predictedNumeric = nil
    end

    if predictedNumeric == nil then
      output[#output + 1] = '[' -- no array component
    else
      output[#output + 1] = '~' -- array component came first so shit needs to happen
    end

    for k, v in next, tbl, predictedNumeric do
      local tk, tv = type(k), type(v)

      -- WRITE KEY
      if tk == 'string' then
        local pid = cache[ k ];
        if( pid )then
          output[ #output + 1 ] = format('(%x)',  pid );
        else
          cacheSize = cacheSize + 1;
          cache[ k ] = cacheSize;

          self.string( self, k, output, cache );
        end
      else
        self[tk](self, k, output, cache)
      end

      -- WRITE VALUE
      if( tv == 'string' )then
        local pid = cache[ v ];
        if( pid )then
          output[ #output + 1 ] = format('(%x)',  pid );
        else
          cacheSize = cacheSize + 1;
          cache[ v ] = cacheSize;

          self.string( self, v, output, cache );
        end
      else
        self[ tv ]( self, v, output, cache );
      end
    end

    output[#output + 1] = '}'
	end
	--    ENCODE STRING
	local gsub = string.gsub ;
	encode['string'] = function( self, str, output )
		--if tryCache( str, output ) then return end
		local estr, count = gsub( str, ";", "\\;");
		if( count == 0 )then
			output[ #output + 1 ] = '\''..str..';';
		else
			output[ #output + 1 ] = '"'..estr..'";';
		end
	end
	--    ENCODE NUMBER
	encode['number'] = function( self, num, output )
		if num%1 == 0 then
			if num < 0 then
				output[ #output + 1 ] = format( 'x%x;', -num );
			else
				output[ #output + 1 ] = format('X%x;', num );
			end
		else
			output[ #output + 1 ] = tonumber( num )..';';
		end
	end
	--    ENCODE BOOLEAN
	encode['boolean'] = function( self, val, output )
		output[ #output + 1 ] = val and 't' or 'f'
	end
	--    ENCODE VECTOR
	encode['Vector'] = function( self, val, output )
		output[ #output + 1 ] = ('v'..val.x..','..val.y)..(','..val.z..';');
	end
	--    ENCODE ANGLE
	encode['Angle'] = function( self, val, output )
		output[ #output + 1 ] = ('a'..val.p..','..val.y)..(','..val.r..';');
	end
	encode['Entity'] = function( self, val, output )
		output[ #output + 1] = 'E'..(IsValid( val ) and (val:EntIndex( )..';') or '#');
	end
	encode['Player']  = encode['Entity'];
	encode['Vehicle'] = encode['Entity'];
	encode['Weapon']  = encode['Entity'];
	encode['NPC']     = encode['Entity'];
	encode['NextBot'] = encode['Entity'];
	encode['PhysObj'] = encode['Entity'];

	encode['nil'] = function()
		output[ #output + 1 ] = '?';
	end
	encode.__index = function( key )
		ErrorNoHalt('Type: '..key..' can not be encoded. Encoded as as pass-over value.');
		return encode['nil'];
	end

	do
		local empty, concat = table.Empty, table.concat ;
		function pon.encode( tbl )
			local output = {};
			cacheSize = 0;
			encode[ 'table' ]( encode, tbl, output, {} );
			local res = concat( output );

			return res;
		end
	end
end

do
	local tonumber = tonumber ;
	local find, sub, gsub, Explode = string.find, string.sub, string.gsub, string.Explode ;
	local Vector, Angle, Entity = Vector, Angle, Entity ;

	local decode = {};
	decode['{'] = function( self, index, str, cache )

		local cur = {};
		cache[ #cache + 1 ] = cur;

		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tv = sub( str, index, index );
			if( not tv or tv == '~' )then
				index = index + 1;
				break ;
			end
			if( tv == '}' )then
				return index + 1, cur;
			end

			-- READ THE VALUE
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );
			cur[ k ] = v;

			k = k + 1;
		end

		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end

			-- READ THE KEY

			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );

			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );

			cur[ k ] = v;
		end

		return index, cur;
	end
	decode['['] = function( self, index, str, cache )

		local cur = {};
		cache[ #cache + 1 ] = cur;

		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end

			-- READ THE KEY
			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );
			if not k then continue end

			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			if not self[tv] then
				print('did not find type: '..tv)
			end
			index, v = self[ tv ]( self, index, str, cache );

			cur[ k ] = v;
		end

		return index, cur;
	end

	-- STRING
	decode['"'] = function( self, index, str, cache )
		local finish = find( str, '";', index, true );
		local res = gsub( sub( str, index, finish - 1 ), '\\;', ';' );
		index = finish + 2;

		cache[ #cache + 1 ] = res;
		return index, res;
	end
	-- STRING NO ESCAPING NEEDED
	decode['\''] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local res = sub( str, index, finish - 1 )
		index = finish + 1;

		cache[ #cache + 1 ] = res;
		return index, res;
	end

	-- NUMBER
	decode['n'] = function( self, index, str, cache )
		index = index - 1;
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, num;
	end
	decode['0'] = decode['n'];
	decode['1'] = decode['n'];
	decode['2'] = decode['n'];
	decode['3'] = decode['n'];
	decode['4'] = decode['n'];
	decode['5'] = decode['n'];
	decode['6'] = decode['n'];
	decode['7'] = decode['n'];
	decode['8'] = decode['n'];
	decode['9'] = decode['n'];
	decode['-'] = decode['n'];
	-- positive hex
	decode['X'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end
	-- negative hex
	decode['x'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = -tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end

	-- POINTER
	decode['('] = function( self, index, str, cache )
		local finish = find( str, ')', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, cache[ num ];
	end

	-- BOOLEAN. ONE DATA TYPE FOR YES, ANOTHER FOR NO.
	decode[ 't' ] = function( self, index )
		return index, true;
	end
	decode[ 'f' ] = function( self, index )
		return index, false;
	end

	-- VECTOR
	decode[ 'v' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local vecStr = sub( str, index, finish - 1 );
		index = finish + 1; -- update the index.
		local segs = Explode( ',', vecStr, false );
		return index, Vector( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ANGLE
	decode[ 'a' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local angStr = sub( str, index, finish - 1 );
		index = finish + 1; -- update the index.
		local segs = Explode( ',', angStr, false );
		return index, Angle( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ENTITY
	decode[ 'E' ] = function( self, index, str, cache )
		if( str[index] == '#' )then
			index = index + 1;
			return index, NULL ;
		else
			local finish = find( str, ';', index, true );
			local num = tonumber( sub( str, index, finish - 1 ) );
			index = finish + 1;
			return index, Entity( num );
		end
	end
	-- PLAYER
	decode[ 'P' ] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, Entity( num ) or NULL;
	end
	-- NIL
	decode['?'] = function( self, index, str, cache )
		return index + 1, nil;
	end


	function pon.decode( data )
		local _, res = decode[sub(data,1,1)]( decode, 2, data, {});
		return res;
	end
end

--addons/onyx_framework_2/lua/onyx/framework/libs/sh_netchunk.lua:
--[[
MIT License

Copyright (c) 2023 Aleksandrs Filipovskis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

if (netchunk) then return end

netchunk = netchunk or {}
netchunk.chunks = netchunk.chunks or {}
netchunk.registered = netchunk.registered or {}
-- netchunk.maxBytes = 32768
netchunk.maxBytes = 16384

local split do
    local len = string.len
    local sub = string.sub
    local maxBytes = netchunk.maxBytes

    function split(data)
        local length = len(data)
        local index = 1
        local last = 1
        local chunks = {}

        for i = 1, length do
            if (i - last + 1) > maxBytes then
                chunks[index] = sub(data, last, i)
                index = index + 1
                last = i + 1
            end
        end

        chunks[index] = sub(data, last, length)

        return chunks
    end
end

local function merge(chunks)
    local result = ''

    for i = 1, #chunks do
        result = result .. chunks[i]
    end

    return result
end

function netchunk.Register(name)
    if (SERVER) then
        util.AddNetworkString('netchunk[' .. name .. ']:Send')
    end

    netchunk.registered[name] = true
    netchunk.chunks[name] = {}
end

if (SERVER) then
    local function send(ply)
        if ply then
            net.Send(ply)
        else
            net.Broadcast()
        end
    end

    function netchunk.Send(ply, name, data)
        assert(netchunk.registered[name], 'Trying to send data during unregistered channel (`' .. name .. '`)')

        local encoded = pon.encode(data)
        local chunks = split(encoded)
        local count = #chunks

        for i = 1, count do
            local chunk = chunks[i]
            local length = #chunk

            net.Start('netchunk[' .. name .. ']:Send')
                net.WriteString(name)
                net.WriteUInt(length, 16)
                net.WriteData(chunks[i], length)
                net.WriteBool(i == count)
            send(ply)
        end
    end
else
    netchunk.callbacks = netchunk.callbacks or {}

    local ReadString = net.ReadString
    local ReadUInt = net.ReadUInt
    local ReadData = net.ReadData
    local ReadBool = net.ReadBool

    function netchunk.Callback(name, callback)
        assert(name)
        assert(callback)

        net.Receive('netchunk[' .. name .. ']:Send', function()
            local name = ReadString()
            local length = ReadUInt(16)
            local chunk = ReadData(length)
            local finished = ReadBool()

            local chunks = netchunk.chunks[name]

            chunks[#chunks + 1] = chunk

            if finished then
                local raw = merge(chunks)
                local amt = #chunks

                netchunk.chunks[name] = {}

                local data = pon.decode(raw)

                callback(data, #raw, amt)
            end
        end)
    end
end
--addons/onyx_framework_2/lua/onyx/ui/libs/cl_trait.lua:
return gluapack()()
--addons/onyx_framework_2/lua/onyx/ui/cfg/cl_config.lua:
return gluapack()()
--addons/onyx_framework_2/lua/onyx/ui/elements/cl_combo.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

22/04/2023

--]]

local PANEL = {}

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorGray = Color(125, 125, 125)
local wimgArrow = onyx.wimg.Simple('https://i.imgur.com/KGC51Ws.png', 'smooth mips')

AccessorFunc(PANEL, 'm_CurrentOptionText', 'CurrentOptionText')
AccessorFunc(PANEL, 'm_Font', 'Font')
AccessorFunc(PANEL, 'm_colOutlineActiveColor', 'OutlineActiveColor')
AccessorFunc(PANEL, 'm_colOutlineIdleColor', 'OutlineIdleColor')
AccessorFunc(PANEL, 'm_bHideOptionIcon', 'HideOptionIcon')

function PANEL:Init()
    self:Import('click')
    self:Import('hovercolor')
    self:SetTall(onyx.ScaleTall(30))

    self:SetColorKey('backgroundColor')
    self:SetColorIdle(colorPrimary)
    self:SetColorHover(onyx.OffsetColor(self:GetColorIdle(), -5))

    self:SetFont(onyx.Font('Comfortaa@16'))

    self:SetOutlineIdleColor(colorSecondary)
    self:SetOutlineActiveColor(colorAccent)
    self:Reset()

    self.options = {}
end

function PANEL:SetOutlineIdleColor(color)
    self.m_colOutlineIdleColor = color
    self.currentOutlineColor = onyx.CopyColor(color)
end

function PANEL:Paint(w, h)
    local thickness = 1
    local currentOutlineColor = self.currentOutlineColor

    if (self.highlight) then
        currentOutlineColor = ColorAlpha(self.highlightColor, math.abs(math.sin(CurTime() * 6)) * 200 + 55)
        if (self.highlightEndTime and self.highlightEndTime <= CurTime()) then
            self:ResetHighlight()
        end
    end

    draw.RoundedBox(8, 0, 0, w, h, currentOutlineColor)
    draw.RoundedBox(8, thickness, thickness, w - thickness * 2, h - thickness * 2, self.backgroundColor)

    local x = onyx.ScaleWide(10)
    local material = self.wimage and self.wimage:GetMaterial() or self.material

    if (material and self.current > 0 and not self.m_bHideOptionIcon) then
        local size = onyx.ScaleTall(12)

        surface.SetDrawColor(color_white)
        surface.SetMaterial(material)
        surface.DrawTexturedRect(x, h * .5 - size * .5, size, size)

        x = x + size + onyx.ScaleWide(5)
    end

    draw.SimpleText(self.m_CurrentOptionText, self.m_Font, x, h * .5, self.current > 0 and color_white or colorGray, 0, 1)

    local sz = math.floor(h * .33)
    wimgArrow:DrawRotated(w - h * .5, h * .5, sz, sz, 0, color_white)
end

function PANEL:AddOption(text, data, bSelectedDefault, icon, url)
    return self:AddOptionAdvanced({
        text = text,
        data = data,
        bSelectedDefault = bSelectedDefault,
        icon = icon
    })
end

function PANEL:AddOptionAdvanced(tblOption)
    return table.insert(self.options, tblOption)
end

function PANEL:ChooseOptionID(index, bIgnoreProcessing)
    local option = self.options[index]
    assert(option, 'trying to set invalid option (index:' .. index .. ')')

    self:SetCurrentOptionText(option.text)
    self.current = index

    if (option.iconURL) then
        self.wimage = onyx.wimg.Simple(option.iconURL, option.iconParams)
    else
        self.wimage = nil
    end

    if (not bIgnoreProcessing) then
        self:Call('OnSelect', nil, index, option.text, option.data)
    end
end

function PANEL:GetSelectedID()
    return self.current
end

function PANEL:GetOptionData(index)
    index = index or self.current

    local option = self.options[index]
    if (option) then
        return option.data
    end
end

function PANEL:GetOptionText(index)
    index = index or self.current

    local option = self.options[index]
    if (option) then
        return option.text
    end
end

function PANEL:Reset()
    self.current = -1
    self.wimage = nil
    if (onyx.lang) then
        self:SetCurrentOptionText(onyx.lang:Get('Select an option'))
    else
        self:SetCurrentOptionText('Select an option')
    end
    if (IsValid(self.dmenu)) then
        self.dmenu:Close()
    end
end

function PANEL:Clear()
    self.options = {}
    self:Reset()
end

function PANEL:GetOptions()
    return self.options
end

function PANEL:FindOptionByData(data)
    for index, option in ipairs(self.options) do
        if (option.data and option.data == data) then
            return option, index
        end
    end
end

function PANEL:DoClick()
    if (self.active) then
        return
    end

    self:ResetHighlight()

    local x, y = self:LocalToScreen(0, 0)

    local dmenu = vgui.Create('onyx.Menu')
    dmenu:SetPos(x, y + self:GetTall())
    dmenu:SetMinimumWidth(self:GetWide())
    dmenu.parent = self
    dmenu.Think = function(panel)
        local parent = panel.parent
        if (IsValid(parent)) then
            local x, y = parent:LocalToScreen(0, 0)
            local targetY = y + parent:GetTall()
            if (dmenu:GetY() ~= targetY) then
                dmenu:Close()
            end
            -- dmenu:SetPos(x, targetY)
        end
    end

    for index, option in ipairs(self.options) do
        local opt = dmenu:AddOption(option.text, function()
            self:ChooseOptionID(index)
        end)

        if (option.iconURL) then
            opt:SetIconURL(option.iconURL, option.iconParams)
        end
    end

    dmenu:Open()

    self.dmenu = dmenu
end

function PANEL:SetActive(bBool)
    self.active = bBool
    onyx.anim.Simple(self, .2, {
        currentOutlineColor = (bBool and self.m_colOutlineActiveColor or self.m_colOutlineIdleColor)
    }, 1)
end

function PANEL:Think()
    local bRealActive = IsValid(self.dmenu)
    if (bRealActive ~= self.active) then
        self:SetActive(bRealActive)
    end
end

function PANEL:OnRemove()
    if (IsValid(self.dmenu)) then
        self.dmenu:Remove()
    end
end

function PANEL:OnDisabled()
    local offset = -5
    self.onyxAnims = nil
    self:SetColorIdle(onyx.OffsetColor(colorPrimary, offset))
    self:SetColorHover(onyx.OffsetColor(self:GetColorIdle(), -5 + offset))
end

function PANEL:OnEnabled()
    local offset = 0
    self.onyxAnims = nil
    self:SetColorIdle(onyx.OffsetColor(colorPrimary, offset))
    self:SetColorHover(onyx.OffsetColor(self:GetColorIdle(), -5 + offset))
end

function PANEL:Highlight(color, time)
    self.highlightColor = color
    self.highlightStartTime = CurTime()
    if (time) then
        self.highlightEndTime = CurTime() + time
    end
    self.highlight = true
end

function PANEL:ResetHighlight()
    self.highlightColor = nil
    self.highlightStartTime = nil
    self.highlightEndTime = nil
    self.highlight = nil
end

onyx.gui.Register('onyx.ComboBox', PANEL)

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .4, .65, function(self)
--     self:MakePopup()

--     local content = self:Add('Panel')
--     content:Dock(FILL)
--     content:DockMargin(5, 5, 5, 5)

--     for i = 1, 10 do
--         local btn = content:Add('onyx.ComboBox')
--         btn:Dock(TOP)
--         btn:DockMargin(0, 0 ,0 ,5)
--         -- btn:AddOption('Apple')
--         -- btn:AddOption('Banana')
--         -- btn:AddOption('Pear')
--         btn:AddOptionAdvanced({
--             text = 'Apple',
--             iconURL = 'https://i.imgur.com/pkL906D.png',
--             iconParams = 'smooth mips'
--         })
--         btn:AddOptionAdvanced({
--             text = 'Pear',
--             iconURL = 'https://i.imgur.com/Y4UKPLO.png',
--             iconParams = 'smooth mips'
--         })
--         btn:AddOptionAdvanced({
--             text = 'Banana',
--             iconURL = 'https://i.imgur.com/qQl0sr8.png',
--             iconParams = 'smooth mips'
--         })
--         btn:Highlight(Color(212, 72, 72))
--         -- btn:SetHideOptionIcon(true   )
--         -- btn.OnSelect = function(panel, index, text, data)
--         --     panel:Clear()
--         --     panel.current = 1
--         --     panel:SetDisabled(true)
--         --     panel:SetCurrentOptionText('Thank you for your feedback.')
--         -- end
--     end

-- end)
--addons/onyx_framework_2/lua/onyx/ui/elements/cl_frame.lua:
return gluapack()()
--addons/onyx_framework_2/lua/onyx/ui/elements/cl_frame.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

local PANEL = {}

function PANEL:Init()
    self.divHeader = self:Add('onyx.Frame.Header')
    self.colorBG = onyx.OffsetColor(onyx:Config('colors.primary'), -5)

    self:Combine(self.divHeader, 'SetTitle')
    self:SetTitle('Frame')

    self.disabledPanels = {}
    self.focusMultiplier = 0

    self._Remove = self.Remove
    self.Remove = function(panel)
        panel:Close()
    end
end

function PANEL:ShowCloseButton(bVis)
    self.divHeader.btnClose:SetVisible(bVis)
end

function PANEL:PerformLayout(w, h)
    self.divHeader:Dock(TOP)
    self.divHeader:SetTall(ScreenScale(12))
end

function PANEL:Paint(w, h)
    local x, y = self:LocalToScreen(0, 0)

    if (self.focused and self.focusMultiplier > 0) then
        DisableClipping(true)
            onyx.DrawBlurExpensive(self, self.focusMultiplier)
        DisableClipping(false)
    end

    assert( self.colorBG )
    onyx.bshadows.BeginShadow()
        draw.RoundedBox(8, x, y, w, h, self.colorBG)
    onyx.bshadows.EndShadow(1, 5, 5)
end

function PANEL:Focus()
    local panels = vgui.GetWorldPanel():GetChildren()
    for _, child in ipairs(panels) do
        if child:IsVisible() and child ~= self and child:IsMouseInputEnabled() then
            child:SetMouseInputEnabled(false)
            table.insert(self.disabledPanels, child)
        end
    end

    self.focused = true

    onyx.anim.Simple(self, .33, {
        focusMultiplier = 5
    }, 1)
end

function PANEL:UnFocus()
    for _, child in ipairs(self.disabledPanels) do
        if IsValid(child) then
            child:SetMouseInputEnabled(true)
        end
    end

    self.disabledPanels = {}
    self.focused = false
end

function PANEL:OnRemove()
    self:UnFocus()
end

function PANEL:Close()
    self:AlphaTo(0, .2, 0, function(_, panel)
        if (IsValid(panel)) then
            panel:_Remove()
        end
    end)
end

onyx.gui.Register('onyx.Frame', PANEL, 'EditablePanel')

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .65, .65, function(self)
--     self:Focus()
-- end)
--addons/onyx_f4/lua/onyx/modules/f4/core/sh_core.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/12/2023

--]]

CAMI.RegisterPrivilege({
    Name = 'onyx_f4_edit',
    MinAccess = 'superadmin',
    Description = 'Allows to configure Onyx F4'
})

onyx.f4:RegisterOption('title', {
    title = 'f4.title.name',
    desc = 'f4.title.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = 'ONYX F4'
})

onyx.f4:RegisterOption('colored_items', {
    title = 'f4.colored_items.name',
    desc = 'f4.colored_items.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = true
})

onyx.f4:RegisterOption('edit_job_colors', {
    title = 'f4.edit_job_colors.name',
    desc = 'f4.edit_job_colors.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = true
})

onyx.f4:RegisterOption('hide_admins', {
    title = 'f4.hide_admins.name',
    desc = 'f4.hide_admins.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = false
})

onyx.f4:RegisterOption('hide_donate_tab', {
    title = 'f4.hide_donate_tab.name',
    desc = 'f4.hide_donate_tab.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = false
})

onyx.f4:RegisterOption('admin_on_duty', {
    title = 'f4.admin_on_duty.name',
    desc = 'f4.admin_on_duty.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = false
})

onyx.f4:RegisterOption('admin_on_duty_job', {
    title = 'f4.admin_on_duty_job.name',
    desc = 'f4.admin_on_duty_job.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = 'Admin on Duty'
})

onyx.f4:RegisterOption('item_columns', {
    title = 'f4.item_columns.name',
    desc = 'f4.item_columns.desc',
    category = 'Items',
    cami = 'onyx_f4_edit',
    type = 'int',
    min = 1,
    max = 3,
    default = 3
})

onyx.f4:RegisterOption('item_show_unavailable', {
    title = 'f4.item_show_unavailable.name',
    desc = 'f4.item_show_unavailable.desc',
    category = 'Items',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = true
})

onyx.f4:RegisterOption('job_columns', {
    title = 'f4.job_columns.name',
    desc = 'f4.job_columns.desc',
    category = 'Jobs',
    cami = 'onyx_f4_edit',
    type = 'int',
    min = 1,
    max = 3,
    default = 2
})

onyx.f4:RegisterOption('job_show_unavailable', {
    title = 'f4.job_show_unavailable.name',
    desc = 'f4.job_show_unavailable.desc',
    category = 'Jobs',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = true
})

onyx.f4:RegisterOption('job_show_requirejob', {
    title = 'f4.job_show_requirejob.name',
    desc = 'f4.job_show_requirejob.desc',
    category = 'Jobs',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = false
})

onyx.f4:RegisterOption('model_3d', {
    title = 'f4.model_3d.name',
    desc = 'f4.model_3d.desc',
    category = 'Performance',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = false
})

--[[------------------------------
URL
--------------------------------]]

onyx.f4:RegisterOption('website_ingame', {
    title = 'f4.website_ingame.name',
    desc = 'f4.website_ingame.desc',
    category = 'Links',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = true
})

onyx.f4:RegisterOption('discord_url', {
    title = 'f4.discord_url.name',
    desc = 'f4.option_url_desc',
    category = 'Links',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = ''
})

onyx.f4:RegisterOption('forum_url', {
    title = 'f4.forum_url.name',
    desc = 'f4.option_url_desc',
    category = 'Links',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = ''
})

onyx.f4:RegisterOption('steam_url', {
    title = 'f4.steam_url.name',
    desc = 'f4.option_url_desc',
    category = 'Links',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = ''
})

onyx.f4:RegisterOption('rules_url', {
    title = 'f4.rules_url.name',
    desc = 'f4.option_url_desc',
    category = 'Links',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = ''
})

onyx.f4:RegisterOption('donate_url', {
    title = 'f4.donate_url.name',
    desc = 'f4.option_url_desc',
    category = 'Links',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = ''
})
--addons/onyx_f4/lua/onyx/modules/f4/ui/cl_tab_dashboard.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

25/12/2023

--]]

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorGradient = onyx.OffsetColor(colorAccent, -50)
local colorTertiary = onyx:Config('colors.tertiary')
local colorCircleGray = Color(69, 69, 69)
local colorLabel = color_white
local fontTitle = onyx.Font('Comfortaa Bold@16')

local L = function(...) return onyx.lang:Get(...) end

local PANEL = {}

local formatMoney do
    local format = {
        {'t', 10 ^ 12, 2},
        {'b', 10 ^ 9, 2},
        {'m', 10 ^ 6, 2},
        {'k', 10 ^ 3}
    }
    local amount = #format

    function formatMoney(money)
        for index = 1, amount do
            local data = format[index]
            local name = data[1]
            local value = data[2]
            local decimals = data[3] or 1
            if (money > value) then
                return DarkRP.formatMoney( math.Round(money / value, decimals) ) .. name
            end
        end

        return DarkRP.formatMoney(money)
    end
end

local function drawShadowBG(panel, w, h, color)
    -- local x, y = panel:LocalToScreen(0, 0)

    -- onyx.bshadows.BeginShadow()
        draw.RoundedBox(8, 0, 0, w, h, color)
    -- onyx.bshadows.EndShadow(1, 1, 2, nil, nil, 2)
end

function PANEL:Init()
    self.space = onyx.ScaleTall(10)
    self.padding = onyx.ScaleTall(10)
    self.smallHeaderHeight = onyx.ScaleTall(25)

    self.divStats = self:Add('Panel')
    self.divStats.PerformLayout = function(panel, w, h)
        local children = panel:GetChildren()
        local amount = #children
        local space = self.space
        local wide = (w - (space * (amount - 1))) / amount

        for index, child in ipairs(children) do
            child:SetWide(wide)
            child:Dock(LEFT)
            child:DockMargin(0, 0, space, 0)
        end
    end

    self.divBody = self:Add('Panel')

    self.divActions = self.divBody:Add('Panel')
    self.divActions.Paint = function(panel, w, h)
        drawShadowBG(panel, w, h, colorPrimary)
    end

    self.lblActions = self.divActions:Add('onyx.Label')
    self.lblActions:SetText(L('f4_actions_u'))
    self.lblActions:SetFont(fontTitle)
    self.lblActions:SetTextColor(colorLabel)
    self.lblActions:Dock(TOP)
    self.lblActions:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    self.lblActions:CenterText()
    self.lblActions:SetTall(self.smallHeaderHeight)
    self.lblActions.Paint = function(panel, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorSecondary, true, true)
    end

    self.listActions = self.divActions:Add('onyx.ScrollPanel')
    self.listActions:DockMargin(self.padding, 0, self.padding, self.padding)
    self.listActions:Dock(FILL)

    self.divAdmins = self.divBody:Add('Panel')
    self.divAdmins:SetVisible(not onyx.f4:GetOptionValue('hide_admins'))
    self.divAdmins.Paint = function(panel, w, h)
        drawShadowBG(panel, w, h, colorPrimary)
    end

    self.lblAdmins = self.divAdmins:Add('onyx.Label')
    self.lblAdmins:SetText(L('f4_staffonline_u'))
    self.lblAdmins:SetFont(fontTitle)
    self.lblAdmins:SetTextColor(colorLabel)
    self.lblAdmins:Dock(TOP)
    self.lblAdmins:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    self.lblAdmins:CenterText()
    self.lblAdmins:SetTall(self.smallHeaderHeight)
    self.lblAdmins.Paint = function(panel, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorSecondary, true, true)
    end

    self.listAdmins = self.divAdmins:Add('onyx.ScrollPanel')
    self.listAdmins:DockMargin(self.padding, 0, self.padding, self.padding)
    self.listAdmins:Dock(FILL)

    self:InitActions()
    self:InitStats()
    self:InitAdmins()
end

function PANEL:PerformLayout(w, h)
    local space = self.space

    self.divStats:SetTall(h * .25)
    self.divStats:Dock(TOP)
    self.divStats:DockMargin(0, 0, 0, space)

    self.divBody:Dock(FILL)

    self.divActions:Dock(FILL)

    self.divAdmins:Dock(RIGHT)
    self.divAdmins:SetWide((w - space * 1) * .33)
    self.divAdmins:DockMargin(space, 0, 0, 0)
end

function PANEL:InitActions()
    local client = LocalPlayer()
    local listActions = self.listActions
    local categories = {}

    for _, action in ipairs(onyx.f4.actions) do
        local category = action.category
        local canSee = action.canSee

        if (canSee and not canSee(client)) then
            continue
        end

        if (not categories[category]) then
            local lblTitle = listActions:Add('onyx.Label')
            lblTitle:SetText(onyx.lang:Get(category))
            lblTitle:SetTextColor(color_white)
            lblTitle:Font('Overpass SemiBold@16')
            lblTitle:Dock(TOP)
            lblTitle:DockMargin(0, 0, 0, onyx.ScaleTall(10))

            local gridPanel = listActions:Add('onyx.Grid')
            gridPanel:Dock(TOP)
            gridPanel:SetColumnCount(3)
            gridPanel:SetSpaceX(onyx.ScaleTall(5))
            gridPanel:SetSpaceY(gridPanel:GetSpaceX())
            gridPanel:DockMargin(0, 0, 0, onyx.ScaleTall(10))

            categories[category] = gridPanel
        end

        self:AddAction(categories[category], action.name, action.func)
    end
end

function PANEL:AddAction(grid, name, func)
    local client = LocalPlayer()
    local button = grid:Add('onyx.Button')
    button:SetText(onyx.lang:Get(name))
    button:SetGradientColor(colorGradient)
    button:SetMasking(true)
    button:Font('Comfortaa Bold@16')
    button:SetTall(onyx.ScaleTall(25))
    button.DoClick = function()
        if (func) then
            func(client)
        end
    end
end

function PANEL:InitAdmins()
    local padding = onyx.ScaleTall(5)
    local client = LocalPlayer()
    for _, ply in ipairs(player.GetAll()) do
        if (onyx.f4.IsAdmin(ply)) then
            local panel = self.listAdmins:Add('Panel')
            panel:Dock(TOP)
            panel:SetTall(onyx.ScaleTall(45))
            panel:DockPadding(padding, padding, padding, padding)
            panel.Paint = function(panel, w, h)
                draw.RoundedBox(8, 0, 0, w, h, colorTertiary)
            end

            local height = panel:GetTall() - padding * 2

            local avatar = panel:Add('onyx.RoundedAvatar')
            avatar:SetPlayer(ply, 64)
            avatar:SetWide(height)
            avatar:Dock(LEFT)
            avatar:DockMargin(0, 0, onyx.ScaleWide(10), 0)
            avatar.PaintOver = function(panel, w, h)
                onyx.DrawOutlinedCircle(w * .5, h * .5, h * .5, 3, color_white)
            end

            local lblName = panel:Add('onyx.Label')
            lblName:Font('Comfortaa Bold@16')
            lblName:Dock(TOP)
            lblName:SetTall(height * .5)
            lblName:SetContentAlignment(1)
            lblName:SetText(ply:Name())

            if (client == ply) then
                lblName:SetTextColor(colorAccent)
            end

            local lblRank = panel:Add('onyx.Label')
            lblRank:SetText(ply:GetUserGroup())
            lblRank:Font('Comfortaa@14')
            lblRank:Dock(TOP)
            lblRank:SetTall(height * .5)
            lblRank:SetTextColor(Color(200, 200, 200))
            lblRank:SetContentAlignment(7)
        end
    end
end

function PANEL:InitStats()
    local client = LocalPlayer()
    local players = player.GetAll()
    local playerOnline = #players
    local playerMax = game.MaxPlayers()
    local clientMoney = client:getDarkRPVar('money') or 0
    local totalMoney = 0
    local staffOnline = 0

    for _, ply in ipairs(players) do
        local money = ply:getDarkRPVar('money') or 0
        totalMoney = totalMoney + money

        if (onyx.f4.IsAdmin(ply)) then
            staffOnline = staffOnline + 1
        end
    end

    self:AddStat(L('f4_playersonline_u'), playerOnline .. ' / ' .. playerMax, (playerOnline / playerMax), Color(255, 238, 108))
    self:AddStat(L('f4_totalmoney_u'), formatMoney(totalMoney), (clientMoney / totalMoney), Color(36, 129, 50), Color(179, 255, 170))
    self:AddStat(L('f4_staffonline_u'), staffOnline, (staffOnline > 0 and 1 or 0), Color(160, 61, 231))
end

function PANEL:AddStat(name, info, fraction, color, color2)
    local padding = onyx.ScaleTall(10)
    local angle = math.Round(fraction * 360, 0, 360)
    local font0 = onyx.Font('Comfortaa@18')

    local panel = self.divStats:Add('Panel')
    panel.Paint = function(this, w, h)
        drawShadowBG(this, w, h, colorPrimary)
    end

    local lblTitle = panel:Add('onyx.Label')
    lblTitle:SetText(name)
    lblTitle:SetFont(fontTitle)
    lblTitle:CenterText()
    lblTitle:SetTextColor(colorLabel)
    lblTitle:Dock(TOP)
    lblTitle:DockMargin(0, 0, 0, padding)
    lblTitle:SizeToContentsY(10)
    lblTitle.Paint = function(panel, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorSecondary, true, true)
    end

    local content = panel:Add('Panel')
    content:Dock(FILL)
    content:DockMargin(padding, 0, padding, padding)
    content.Paint = function(panel, w, h)
        local size = math.min(w, h)
        local radius = math.floor(size * .5)
        local x0 = w * .5
        local y0 = h * .5
        local outlineWidth   = 5

        DisableClipping(true)
            onyx.DrawOutlinedCircle(x0 + 1, y0 + 1, radius, outlineWidth, Color(0, 0, 0, 100))
        DisableClipping(false)

        onyx.DrawOutlinedCircle(x0, y0, radius, outlineWidth, color2 or colorCircleGray)
        onyx.DrawWithPolyMask(panel.mask, function()
            onyx.DrawOutlinedCircle(x0, y0, radius, outlineWidth, color)
        end)

        draw.SimpleText(info, font0, w * .5, h * .5, color_white, 1, 1)
    end
    content.PerformLayout = function(panel, w, h)
        panel.mask = onyx.CalculateArc(w * .5, h * .5, 0, angle, h * .5 + 2, 24, true)
    end
end

onyx.gui.Register('onyx.f4.Dashboard', PANEL)

--[[------------------------------
DEBUG
--------------------------------]]
-- onyx.gui.Test('onyx.f4.Frame', .6, .65, function(panel)
--     panel:MakePopup()
--     panel:ChooseTab(1)
-- end)
--addons/onyx_f4/lua/onyx/modules/f4/ui/cl_tab_jobs.lua:
return gluapack()()
--addons/bb_onyx_hud/lua/onyx/modules/hud/languages/cl_polish.lua:
--[[
KayZed @ 2024
--]]

local LANG = {}

--[[
    .............
    General Words
]]--

LANG[ 'hud_status_wanted' ] = 'Poszukiwany'
LANG[ 'hud_status_speaking' ] = 'Mówi'
LANG[ 'hud_status_typing' ] = 'Pisze'
LANG[ 'props' ] = 'Propy'
LANG[ 'close' ] = 'Zamknij'
LANG[ 'alert' ] = 'Alert'
LANG[ 'message' ] = 'Wiadomość'
LANG[ 'unknown' ] = 'Nieznany'
LANG[ 'accept' ] = 'Akceptuj'
LANG[ 'deny' ] = 'Odrzuć'
LANG[ 'none' ] = 'Brak'
LANG[ 'add' ] = 'Dodaj'
LANG[ 'remove' ] = 'Usuń'
LANG[ 'jobs' ] = 'Prace'
LANG[ 'door' ] = 'Drzwi'
LANG[ 'vehicle' ] = 'Pojazd'
LANG[ 'door_groups' ] = 'Grupy drzwi'
LANG[ 'display' ] = 'Wyświetl'
LANG[ 'general' ] = 'Ogólne'
LANG[ 'speedometer' ] = 'Prędkościomierz'
LANG[ 'fuel' ] = 'Paliwo'
LANG[ 'vote' ] = 'Głosowanie'
LANG[ 'question' ] = 'Pytanie'

--[[
    .......
    Timeout
]]--

LANG[ 'timeout_title' ] = 'UTRATA POŁĄCZENIA'
LANG[ 'timeout_info' ] = 'Serwer jest obecnie niedostępny, przepraszamy'
LANG[ 'timeout_status' ] = 'Zostaniesz ponownie połączony za %d sekund'

--[[
    ......
    Themes
]]--

LANG[ 'hud.theme.default.name' ] = 'Domyślny'
LANG[ 'hud.theme.forest.name' ] = 'Las'
LANG[ 'hud.theme.violet_night.name' ] = 'Fioletowa Noc'
LANG[ 'hud.theme.rustic_ember.name' ] = 'Zardzewiały Żar'
LANG[ 'hud.theme.green_apple.name' ] = 'Zielone Jabłko'
LANG[ 'hud.theme.lavender.name' ] = 'Lawenda'
LANG[ 'hud.theme.elegance.name' ] = 'Elegancja'
LANG[ 'hud.theme.mint_light.name' ] = 'Mięta'
LANG[ 'hud.theme.gray.name' ] = 'Szary'
LANG[ 'hud.theme.rose_garden.name' ] = 'Różany Ogród'
LANG[ 'hud.theme.ocean_wave.name' ] = 'Oceaniczna Fala'
LANG[ 'hud.theme.sky_blue.name' ] = 'Niebieskie Niebo'
LANG[ 'hud.theme.golden_dawn.name' ] = 'Złota Jutrzenka'

--[[
    ....
    Help
    - Full phrase: "Type <command> to open settings"
]]

LANG[ 'hud_help_type' ] = 'Wpisz'
LANG[ 'hud_help_to' ] = 'aby otworzyć ustawienia'

--[[
    .............
    3D2D Doors
]]--

LANG[ 'door_purchase' ] = 'Kup {object}'
LANG[ 'door_sell' ] = 'Sprzedaj {object}'
LANG[ 'door_addowner' ] = 'Dodaj właściciela'
LANG[ 'door_rmowner' ] = 'Usuń właściciela'
LANG[ 'door_rmowner_help' ] = 'Wybierz gracza, któremu chcesz odebrać własność'
LANG[ 'door_addowner_help' ] = 'Wybierz gracza, któremu chcesz przyznać własność'
LANG[ 'door_title' ] = 'Ustaw tytuł'
LANG[ 'door_title_help' ] = 'Jaki tytuł chcesz ustawić?'
LANG[ 'door_admin_disallow' ] = 'Odmów własności'
LANG[ 'door_admin_allow' ] = 'Zezwól na własność'
LANG[ 'door_admin_edit' ] = 'Edytuj dostęp'
LANG[ 'door_owned' ] = 'Własność Prywatna'
LANG[ 'door_unowned' ] = 'Na Sprzedaż'

LANG[ 'hud_door_help' ] = 'Naciśnij {bind}, aby kupić za {price}'
LANG[ 'hud_door_owner' ] = 'Właściciel: {name}'
LANG[ 'hud_door_allowed' ] = 'Uprawnieni do posiadania'
LANG[ 'hud_door_coowners' ] = 'Współwłaściciele'
LANG[ 'hud_and_more' ] = 'i więcej...'

--[[
    .........
    Uppercase
]]--

LANG[ 'reconnect_u' ] = 'PONOWNIE POŁĄCZ'
LANG[ 'disconnect_u' ] = 'ROZŁĄCZ'
LANG[ 'settings_u' ] = 'USTAWIENIA'
LANG[ 'configuration_u' ] = 'KONFIGURACJA'
LANG[ 'introduction_u' ] = 'WPROWADZENIE'

--[[
    .........
    Lowercase
]]--

LANG[ 'seconds_l' ] = 'sekundy'
LANG[ 'minutes_l' ] = 'minuty'

--[[
    .............
    Configuration
]]--

LANG[ 'hud.timeout.name' ] = 'Czas Trwania Przerwy'
LANG[ 'hud.timeout.desc' ] = 'Ile sekund przed automatycznym ponownym połączeniem'

LANG[ 'hud.alert_queue.name' ] = 'Kolejka Alertów'
LANG[ 'hud.alert_queue.desc' ] = 'Czy alerty powinny być umieszczone w kolejce'

LANG[ 'hud.props_counter.name' ] = 'Licznik propów'
LANG[ 'hud.props_counter.desc' ] = 'Pokaż licznik propów'

LANG[ 'hud.main_avatar_mode.name' ] = 'Główny Typ Awatara'
LANG[ 'hud.main_avatar_mode.desc' ] = 'Wybierz typ'

LANG[ 'hud.voice_avatar_mode.name' ] = 'Typ Awatara Głosowego'
LANG[ 'hud.voice_avatar_mode.desc' ] = 'Wybierz typ'

LANG[ 'hud.restrict_themes.name' ] = 'Ogranicz Motywy'
LANG[ 'hud.restrict_themes.desc' ] = 'Ogranicz graczy do wyboru motywów'

LANG[ 'hud.speedometer_mph.name' ] = 'Używaj Mil'
LANG[ 'hud.speedometer_mph.desc' ] = 'Przełącz jednostki na mile na godzinę'

LANG[ 'hud.speedometer_max_speed.name' ] = 'Maksymalna Domyślna Prędkość'
LANG[ 'hud.speedometer_max_speed.desc' ] = 'Maksymalna prędkość dla prędkościomierza'

LANG[ 'hud_should_draw' ] = 'Czy powinno rysować element'
LANG[ 'hud.main.name' ] = 'Główne HUD'
LANG[ 'hud.ammo.name' ] = 'Amunicja'
LANG[ 'hud.agenda.name' ] = 'Agenda'
LANG[ 'hud.alerts.name' ] = 'Alerty'
LANG[ 'hud.pickup_history.name' ] = 'Historia Podnoszenia'
LANG[ 'hud.level.name' ] = 'Poziom'
LANG[ 'hud.voice.name' ] = 'Panele Głosowe'
LANG[ 'hud.overhead_health.name' ] = '3D2D Pasek Zdrowia'
LANG[ 'hud.overhead_armor.name' ] = '3D2D Pasek Pancerza'
LANG[ 'hud.vehicle.name' ] = 'HUD Pojazdu'

--[[
    ........
    Settings
]]--

LANG[ 'hud.theme.name' ] = 'Motyw'
LANG[ 'hud.theme.desc' ] = 'Wybierz motyw HUDu'

LANG[ 'hud.scale.name' ] = 'Skala'
LANG[ 'hud.scale.desc' ] = 'Dostosuj skalę HUDu'

LANG[ 'hud.roundness.name' ] = 'Zaokrąglenie'
LANG[ 'hud.roundness.desc' ] = 'Dostosuj zaokrąglenie HUDu'

LANG[ 'hud.margin.name' ] = 'Margines'
LANG[ 'hud.margin.desc' ] = 'Odległość między HUDem a krawędziami'

LANG[ 'hud.icons_3d.name' ] = '3D Modele'
LANG[ 'hud.icons_3d.desc' ] = 'Renderuj ikony modeli w 3D'

LANG[ 'hud.compact.name' ] = 'Tryb Kompaktowy'
LANG[ 'hud.compact.desc' ] = 'Włącz tryb kompaktowy'

LANG[ 'hud.speedometer_blur.name' ] = 'Rozmycie Prędkościomierza'
LANG[ 'hud.speedometer_blur.desc' ] = 'Włącz rozmycie prędkościomierza'

LANG[ 'hud.3d2d_max_details.name' ] = 'Maks. Detale 3D2D'
LANG[ 'hud.3d2d_max_details.desc' ] = 'Maksymalna ilość szczegółowych informacji renderowanych'

--[[
    ......
    Status
]]--

LANG[ 'hud_lockdown' ] = 'GODZINA POLICYJNA'
LANG[ 'hud_lockdown_help' ] = 'Proszę wrócić do swoich domów!'

LANG[ 'hud_wanted' ] = 'POSZUKIWANY'
LANG[ 'hud_wanted_help' ] = 'Powód: {reason}'

LANG[ 'hud_arrested' ] = 'ARESZTOWANY'
LANG[ 'hud_arrested_help' ] = 'Zostaniesz wypuszczony za {time}'

onyx.lang:AddPhrases( 'polish', LANG )
--addons/bb_onyx_hud/lua/onyx/modules/hud/core/cl_theme.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

onyx.hud.themes = onyx.hud.themes or {}

local CONVAR_THEME = CreateClientConVar( 'cl_onyx_hud_theme_id', 'default', true, false )

cvars.AddChangeCallback( 'cl_onyx_hud_theme_id', function( _, _, new )
    hook.Run( 'onyx.hud.OnChangedTheme', onyx.hud:GetCurrentTheme() )
end, 'onyx.hud.internal' )

-- predefined colors
local COLORS = {
    [ 'light' ] = {
        textPrimary = color_black,
        textSecondary = Color( 45, 45, 45 ),
        textTertiary = Color( 70, 70, 70),
        negative = Color( 210, 35, 35),
        lockdown = Color( 166, 44, 44)
    },
    [ 'dark' ] = {
        textPrimary = color_white,
        textSecondary = Color( 171, 171, 171),
        textTertiary = Color( 97, 97, 97),
        negative = Color( 255, 76, 76),
        lockdown = Color( 255, 76, 76)
    }
}

function onyx.hud:GetColor( id )
    local themeTable = self:GetCurrentTheme()
    local colorsTable = themeTable.colors
    
    return ( colorsTable[ id ] )
end

function onyx.hud:GetCurrentTheme()
    if ( self:GetOptionValue( 'restrict_themes' ) ) then
        return self.themes[ 'default' ]
    else
        local themeID = CONVAR_THEME:GetString()
        return ( self.themes[ themeID ] or self.themes[ 'default' ] )
    end
end

function onyx.hud:IsDark()
    return self:GetCurrentTheme().dark
end

function onyx.hud:CreateTheme( id, data )
    local colors = data.colors
    local _, _, lightness = ColorToHSL( colors.primary )
    local isDark = lightness < .5
    local predefinedColors = COLORS[ isDark and 'dark' or 'light' ]

    data.id = id
    data.dark = isDark
    data.isDark = isDark
    
    table.Inherit( colors, predefinedColors )
    
    self.themes[ id ] = data
end

--addons/bb_onyx_hud/lua/onyx/modules/hud/elements/cl_alerts.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

17/08/2024

--]]

local DURATION = 5

local hud = onyx.hud
local alerts = {}

local function addAlert( text )
    local useQueue = hud:GetOptionValue( 'alert_queue' )
    local data = {
        title = onyx.utf8.upper( onyx.lang:Get( 'message' ) ),
        text = text,
        duration = DURATION
    }

    if ( useQueue ) then
        table.insert( alerts, data )
    else
        alerts[ 1 ] = data
    end
end

local function drawAlerts( element, client, scrW, scrH )
    local alert = alerts[ 1 ]

    if ( not alert ) then return end
    if ( not alert.endtime ) then alert.endtime = CurTime() + alert.duration end

    local maxW = hud.ScaleWide( 500 )
    local font = hud.fonts.Small
    local roundness = hud.GetRoundness()
    local colorPrimary = hud:GetColor( 'primary' )
    local colorText = hud:GetColor( 'textPrimary' )
    local colorTitle = hud:GetColor( 'textSecondary' )
    local colorAccent = hud:GetColor( 'accent' )
    local alertSpace = hud.ScaleTall( 5 )
    local baseY = ScrH() * .25 - 100
    local posY = baseY

    if ( not alert.wrapText ) then
        alert.wrapText = DarkRP.textWrap( alert.text, font, maxW )
    end
    
    local text = alert.wrapText
    local title = alert.title

    surface.SetFont( font )
    local textW, textH = surface.GetTextSize( text )
    local titleH = hud.ScaleTall( 20 )

    local padding = hud.ScaleTall( 10 )
    local x0, y0 = scrW * .5, scrH * .5
    local w = textW + padding * 2
    local h = textH + titleH + padding * 2
    local x = x0 - w * .5
    local y = posY
    local lineH = hud.ScaleTall( 3 )
    local timeLeft = math.max( 0, ( alert.endtime - CurTime() ) )
    local lifeFraction = timeLeft / alert.duration
    local isExpired = lifeFraction <= 0
    
    alert.alpha = Lerp( FrameTime() * 8, alert.alpha or 0, isExpired and 0 or 1 )

    surface.SetAlphaMultiplier( alert.alpha )

        hud.DrawRoundedBox( x, y, w, h, colorPrimary )

        render.SetScissorRect( x, y + h - lineH, x + w, y + h, true )
            hud.DrawRoundedBox( x, y, w, h, onyx.LerpColor( .75, colorAccent, colorPrimary ) )
        render.SetScissorRect( x, y + h - lineH, x + w * lifeFraction, y + h, true )
            hud.DrawRoundedBox( x, y, w, h, colorAccent )
        render.SetScissorRect( 0, 0, 0, 0, false )

        draw.SimpleText( title, hud.fonts.TinyBold, x0, y + padding, colorTitle, 1 )

        draw.DrawText( text, font, x0, y + padding + titleH, colorText, 1 )

    surface.SetAlphaMultiplier( 1 )
    
    if ( isExpired and math.Round( alert.alpha, 1 ) == 0 ) then
        table.remove( alerts, 1 )
    end
end

net.Receive( 'onyx.hud::SendAlert', function()
    if ( onyx.hud.IsElementEnabled( 'alerts' ) ) then
        addAlert( net.ReadString() )
    end
end )

hook.Add( 'onyx.inconfig.Updated', 'onyx.hud.ClearAlerts', function( id, old, new )
    if ( id and id == 'hud_display_alerts' ) then
        alerts = {}
    end
end )

onyx.hud:RegisterElement( 'alerts', { drawFn = drawAlerts } )
--addons/bb_onyx_hud/lua/onyx/modules/hud/elements/cl_pickup_history.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

local TYPE_AMMO = 0
local TYPE_WEAPON = 1
local TYPE_ITEM = 2
local HOLD_DURATION = 3

local hud = onyx.hud
local history = {}

-- Colors inspired by the original UI, so it would be easy to adapt for players
local TYPES = {
    [ TYPE_AMMO ] = Color( 107, 136, 255 ),
    [ TYPE_ITEM ] = Color( 107, 255, 166 ),
    [ TYPE_WEAPON ] = Color( 255, 198, 107),
}

local MAX_RECORDS = 10

local function addRecord( name, type, amount )
    table.insert( history, 1, {
        name = name,
        amount = amount,
        endtime = CurTime() + HOLD_DURATION,
        duration = HOLD_DURATION,
        type = type,
        color = TYPES[ type ],
        fraction = 0
    } )

    if ( #history > MAX_RECORDS ) then 
        table.remove( history, ( MAX_RECORDS + 1 ) )
    end
end

hook.Add( 'onyx.inconfig.Updated', 'onyx.hud.ClearPickupHistory', function( id, old, new )
    if ( id and id == 'hud_display_pickup_history' ) then
        history = {}
    end
end )

hook.Add( 'HUDAmmoPickedUp', 'onyx.hud.InsertPickupHistory', function( ammoID, amount )
    if ( onyx.hud:GetOptionValue( 'display_pickup_history' ) ) then
        local niceName = language.GetPhrase( string.format( '#%s_ammo', ammoID ) )
    
        for _, record in ipairs( history ) do
            if ( record.name == niceName ) then
                record.endtime = CurTime() + HOLD_DURATION
                record.fraction = 0
                record.amount = record.amount + amount
                return true
            end
        end
    
        addRecord( niceName, TYPE_AMMO, amount )
    end

    return true
end )

hook.Add( 'HUDWeaponPickedUp', 'onyx.hud.InsertPickupHistory', function( weapon )
    -- lol I have encountered a really weird bug when physgun_beam is passed here
    if ( IsValid( weapon ) and weapon:IsWeapon() and onyx.hud:GetOptionValue( 'display_pickup_history' ) ) then
        addRecord( language.GetPhrase( weapon:GetPrintName() ), TYPE_WEAPON, 1 )
    end
    return true
end )

hook.Add( 'HUDItemPickedUp', 'onyx.hud.InsertPickupHistory', function( itemName )
    if ( onyx.hud:GetOptionValue( 'display_pickup_history' ) ) then
        addRecord( language.GetPhrase( itemName ), TYPE_ITEM, 1 )
    end

    return true
end )

hook.Add( 'HUDDrawPickupHistory', 'onyx.hud.DrawPickupHistory', function()
    if ( #history == 0 ) then return true end
    if ( not onyx.hud:GetOptionValue( 'display_pickup_history' ) ) then return true end

    local scrW = ScrW()
    local scrH = ScrH()

    local screenPadding = onyx.hud.GetScreenPadding() * 0.5
    local baseY = scrH * .5
    local baseX = scrW - screenPadding

    local colorPrimary = onyx.hud:GetColor( 'primary' )
    local colorPrimaryText = onyx.hud:GetColor( 'textPrimary' )

    local recordW = hud.ScaleWide( 140 )
    local recordH = hud.ScaleTall( 22 )
    local recordSpace = hud.ScaleTall( 5 )
    local lineW = hud.ScaleWide( 5 )
    local padding = hud.ScaleTall( 5 )
    local posY = baseY

    for index, record in ipairs( history ) do
        local isExpired = record.endtime <= CurTime()
        local targetFraction = isExpired and 0 or 1
        local amount = record.amount

        record.fraction = math.Approach( record.fraction, targetFraction, FrameTime() * 8 )

        local posX = baseX - recordW

        record.x = Lerp( record.fraction, ScrW(), posX )
        record.y = Lerp( FrameTime() * 16, record.y or posY, posY )
        local x, y = record.x, record.y

        local prevAlpha = surface.GetAlphaMultiplier()

        surface.SetAlphaMultiplier( record.fraction )
    
            hud.DrawRoundedBox( x, y, recordW, recordH, colorPrimary )

            render.SetScissorRect( x, y, x + lineW, y + recordH, true )
                hud.DrawRoundedBox( x, y, recordW, recordH, record.color )
            render.SetScissorRect( 0, 0, 0, 0, false )

            draw.SimpleText( record.name, onyx.hud.fonts.TinyBold, x + padding + lineW, y + recordH * .5, colorPrimaryText, 0, 1 )

            if ( amount > 1 ) then
                draw.SimpleText( amount, onyx.hud.fonts.TinyBold, x + recordW - padding, y + recordH * .5, colorPrimaryText, 2, 1 )
            end
            
        surface.SetAlphaMultiplier( prevAlpha )

        posY = posY - recordH - recordSpace

        if ( isExpired and record.fraction == 0 ) then
            table.remove( history, index )
        end
    end

    return true
end )
--addons/bb_onyx_hud/lua/onyx/modules/hud/ui/cl_choice_wheel.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

local SPOLY_ID = 'onyx_hud_wheel_background_3'

do
    onyx.spoly.Generate( SPOLY_ID, function(w, h)
        local scaledThickness = h * .25

        local x = w * .5
        local y = h * .5
        local r = h * .5
        local vertices = 64

        local circleInner = onyx.CalculateCircle(x, y, r - scaledThickness, vertices)
        local circleOuter = onyx.CalculateCircle(x, y, r, vertices)

        onyx.InverseMaskFn(function()
            surface.DrawPoly(circleInner)
        end, function()
            surface.DrawPoly(circleOuter)
        end)
    end )
end

local PANEL = {}

AccessorFunc( PANEL, 'm_bShowLabel', 'ShowLabel' )

function PANEL:Init()
    local colors = onyx.hud:GetCurrentTheme().colors

    self.m_bShowLabel = false
    self.choices = {}
    self.fraction = 0
    self.colors = {
        primary = colors.primary,
        secondary = colors.secondary,
        tertiary = colors.tertiary,
        accent = colors.accent,
        textPrimary = colors.textPrimary,
        textSecondary = colors.textSecondary
    }

    self:Open()

    -- A new hook added in July patch
    -- It is going to replace gui.HideGameUI, so let's prepare to that moment
    -- https://wiki.facepunch.com/gmod/GM:OnPauseMenuShow
    hook.Add( 'OnPauseMenuShow', self, function( this )
        self:Close()
        return false
    end )
end

function PANEL:PerformLayout( w, h )
    self:UpdateSegments()
end

local choiceFont = onyx.Font( 'Comfortaa Bold@16' )
function PANEL:Paint( w, h )
    local colors = self.colors
    local x0, y0 = math.Round( w * .5 ), math.Round( h * .5 )
    local r = h * .5

    local animSpeed = FrameTime() * 8

    -- Draw segments
    for _, choice in ipairs( self.choices ) do
        if ( choice.valid ) then
            local isHovered = choice.isHovered
            local bgColor = isHovered and colors.secondary or colors.primary
            local textColor = isHovered and colors.accent or colors.textSecondary
            local outlineColor = not isHovered and colors.tertiary or colors.accent

            choice.outlineColor = onyx.LerpColor( animSpeed, choice.outlineColor or outlineColor, outlineColor )                                                                                                                                -- 9ad7c9aa-1560-4920-b64e-ac40347a307b
            choice.bgColor = onyx.LerpColor( animSpeed, choice.bgColor or bgColor, bgColor )

            local cos, sin = choice.cos, choice.sin
            local choiceX0 = x0 + cos * r * .75
            local choiceY0 = y0 + sin * r * .75
            local name = choice.name
            local iconSize = math.Round( r * .125 )

            -- Calculate text height
            surface.SetFont( choiceFont )
            local _, textH = surface.GetTextSize( name )

            -- Draw background
            onyx.DrawWithPolyMask( choice.mask, function()
                onyx.spoly.Draw( SPOLY_ID, 0, 0, w, h, choice.bgColor )
                onyx.DrawOutlinedCircle( x0, y0, r, 1, choice.outlineColor )
            end )

            -- Draw content
            if ( choice.wimg ) then
                choice.wimg:DrawRotated( choiceX0, choiceY0, iconSize, iconSize, 0, textColor )
            else 
                draw.DrawText( name, choiceFont, choiceX0, choiceY0 - textH * .5, textColor, 1 )
            end
        end
    end

    -- Draw lines
    for _, choice in ipairs( self.choices ) do
        if ( choice.valid ) then
            local lineRad = math.rad( choice.startAng - 90 )
            local lineCos, lineSin = math.cos( lineRad ), math.sin( lineRad )

            surface.SetDrawColor( colors.tertiary )
            surface.DrawLine( 
                x0 + lineCos * r * .5,
                y0 + lineSin * r * .5,
                x0 + lineCos * r * 1,
                y0 + lineSin * r * 1
             )
        end
    end

    -- Draw label
    local hoveredChoice = self.hoveredChoice
    if ( hoveredChoice and self:GetShowLabel() ) then
        local name = hoveredChoice.name
        
        surface.SetFont( choiceFont )
        local textW, textH = surface.GetTextSize( name )
        local labelPadding = r * .05
        local labelW = textW + labelPadding * 2
        local labelH = textH + labelPadding * 2
        local labelX = x0 - labelW * .5
        local labelY = y0 - labelH * .5

        draw.RoundedBox( 8, labelX, labelY, labelW, labelH, colors.primary )
        draw.DrawText( name, choiceFont, x0, labelY + labelPadding, colors.textPrimary, 1 )
    end
end

function PANEL:Think()
    if ( not self._CLOSED ) then
        self:HandleEscape()
        self:HandleControls()
        if ( self.PostThink ) then
            self:PostThink()
        end
    end
end

function PANEL:HandleEscape()
    if ( input.IsKeyDown( KEY_ESCAPE ) ) then
        if ( gui.HideGameUI ) then gui.HideGameUI() end
        self:Close()
    end
end

function PANEL:HandleControls()
    local w, h = self:GetSize()
    local x, y = input.GetCursorPos()
    local curPos = Vector( x, y )
    local centerPos = Vector( ScrW() * .5, ScrH() * .5 )
    local relX, relY = self:ScreenToLocal( x, y )
    
    relX = relX - ( w * .5 )
    relY = relY - ( h * .5 )

    local ang = ( math.deg( math.atan2( relY, relX ) ) + 90 ) % 360
    local distance = curPos:Distance( centerPos )
    local hoveredChoice

    for _, choice in ipairs( self.choices ) do
        if ( choice.valid ) then
            local startAngle = choice.startAng
            local endAngle = choice.endAng
            local isHovered = ( 
                self:IsHovered()
                and ang > startAngle 
                and ang < endAngle
                and distance > h * .25
                and distance < h * .5
            )
    
            choice.isHovered = isHovered

            if ( isHovered ) then
                hoveredChoice = choice
            end
        end
    end

    self.hoveredChoice = hoveredChoice
end

function PANEL:OnMouseReleased( mouseCode )
    local hoveredChoice = self.hoveredChoice
    if ( mouseCode == MOUSE_LEFT and hoveredChoice ) then
        self:HandleClick( hoveredChoice )
    end
end

function PANEL:HandleClick( choice )
    local clickFn = choice.clickFn or choice.callback
    
    if ( not choice.ignoreClose ) then
        self:Close()
    end

    if ( clickFn ) then
        clickFn( self )
    end
end

function PANEL:UpdateSegments()
    local w, h = self:GetSize()
    if ( w < 1 or h < 1 ) then return end

    local x0, y0 = w * .5, h * .5
    local choices = self.choices
    local amount = #choices

    local segmentAng = ( 360 / amount )

    for index = 1, amount do
        local choice = choices[ index ]
        if ( choice ) then
            local startAng = ( index - 1 ) * segmentAng
            local endAng = startAng + segmentAng
            local betweenAng = startAng + segmentAng * .5
            local rad = math.rad( betweenAng - 90 )
    
            choice.startAng = startAng
            choice.endAng = endAng
            choice.segmentAng = segmentAng
        
            choice.cos = math.cos( rad )
            choice.sin = math.sin( rad )
            choice.mask = onyx.CalculateArc( x0, y0, startAng, segmentAng - 0, math.ceil( h * .5 ) + 1, 24, true )

            choice.valid = true
        end
    end
end

function PANEL:AddChoice( data )
    if ( data.iconURL ) then
        data.wimg = onyx.wimg.Simple( data.iconURL, 'smooth mips' )
    elseif ( data.wimg ) then
        data.wimg = wimg
    elseif ( data.wimgID ) then
        data.wimg = onyx.wimg.Create( data.wimgID, 'smooth mips' )
    end

    table.insert( self.choices, data )
    self:UpdateSegments()
end

function PANEL:Close()
    self._CLOSED = true
    self:SetMouseInputEnabled( false )
    self:SetKeyBoardInputEnabled( false )

    onyx.anim.Create( self, .2, {
        index = 1,
        easing = 'inOutQuad',
        target = { fraction = 0 },
        think = function( _, this )
            this:SetAlpha( this.fraction * 255 )
        end,
        onFinished = function( _, this )
            this:Remove()
        end
    } )
end

function PANEL:Open()
    self:SetAlpha( 0 )

    onyx.anim.Create( self, .2, {
        index = 1,
        easing = 'inOutQuad',
        target = { fraction = 1 },
        think = function( _, this )
            this:SetAlpha( this.fraction * 255 )
        end
    } )
end

onyx.gui.Register( 'onyx.hud.ChoiceWheel', PANEL )

-- DEBUG

-- onyx.gui.oldDebugPanel:Remove()
-- onyx.gui.Test( 'onyx.hud.ChoiceWheel', 1, 1, function( this )
--     this:SetSize( 512, 512 )
--     this:Center()
--     this:MakePopup()
--     for i = 1, 8 do
        
--         this:AddChoice({ name = string.format( 'Button %d', i ), wimgID = 'hud_heart' })
--     end
-- end )
--addons/onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_german.lua:
return gluapack()()
--addons/onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_spanish.lua:
--[[

Author: Goran
Steam Profile:

03/07/2024

--]]

local LANG = {}

-- Phrases
LANG['copied_clipboard'] = 'Copiado al portapapeles'
LANG['scoreboard_search'] = 'Buscar... (Nombre/SteamID)'
LANG['you'] = 'Tú'
LANG['friend'] = 'Amigo'

-- Columns
LANG['scoreboard_col_team'] = 'Equipo'
LANG['scoreboard_col_job'] = 'Trabajo'
LANG['scoreboard_col_money'] = 'Dinero'
LANG['scoreboard_col_rank'] = 'Rango'
LANG['scoreboard_col_karma'] = 'Karma'
LANG['scoreboard_col_playtime'] = 'Tiempo de juego'
LANG['scoreboard_col_health'] = 'Salud'
LANG['scoreboard_col_level'] = 'Nivel'
LANG['scoreboard_col_none'] = 'Nada'
LANG['scoreboard_col_gang'] = 'Gang'

-- Name Effects
LANG['scoreboard_eff_default'] = 'Por Defecto'
LANG['scoreboard_eff_glow'] = 'Brillo'
LANG['scoreboard_eff_rainbow'] = 'Arcoíris'

-- Buttons
LANG['scoreboard_btn_profile'] = 'Abrir Perfil'
LANG['scoreboard_btn_freeze'] = 'Congelar'
LANG['scoreboard_btn_goto'] = 'Ir'
LANG['scoreboard_btn_bring'] = 'Traer'
LANG['scoreboard_btn_return'] = 'Regresar'
LANG['scoreboard_btn_respawn'] = 'Regenerar'
LANG['scoreboard_btn_slay'] = 'Asesinar'

-- Words
LANG['rank_id'] = 'ID de rango'
LANG['name'] = 'Nombre'
LANG['effect'] = 'Efecto'
LANG['color'] = 'Color'
LANG['preview'] = 'Previsualización'
LANG['creation'] = 'Creación'
LANG['save'] = 'Guardar'
LANG['dead'] = 'Muerto'
LANG['create_new'] = 'Crear nuevo'
LANG['column'] = 'Columna'

-- Settings
LANG['addon_settings_u'] = 'AJUSTES'
LANG['scoreboard_ranks_u'] = 'RANGOS'
LANG['scoreboard_columns_u'] = 'COLUMNAS'

LANG['scoreboard.title.name'] = 'Título'
LANG['scoreboard.title.desc'] = 'Ingresa el título del cuadro'

LANG['scoreboard.group_teams.name'] = 'Agrupar por equipo'
LANG['scoreboard.group_teams.desc'] = '(DarkRP) Agrupa los equipos por categoría de trabajo'

LANG['scoreboard.colored_players.name'] = 'Gradiente coloreado'
LANG['scoreboard.colored_players.desc'] = 'Mostrar gradiente coloreado en la línea del jugador'

LANG['scoreboard.blur.name'] = 'Tema Difuminado'
LANG['scoreboard.blur.desc'] = 'Habilitar Tema Difuminado'

onyx.lang:AddPhrases('spanish', LANG)
--addons/onyx_scoreboard/lua/onyx/modules/scoreboard/core/sh_init.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

28/02/2024

--]]

CAMI.RegisterPrivilege({
    Name = 'onyx_scoreboard_edit',
    MinAccess = 'superadmin',
    Description = 'Allows to configure Onyx Scoreboard'
})

onyx.scoreboard:RegisterOption('title', {
    title = 'scoreboard.title.name',
    desc = 'scoreboard.title.desc',
    category = 'General',
    cami = 'onyx_scoreboard_edit',
    type = 'string',
    default = 'ONYX SCOREBOARD'
})

onyx.scoreboard:RegisterOption('scale', {
    title = 'scoreboard.scale.name',
    desc = 'scoreboard.scale.desc',
    category = 'General',
    cami = 'onyx_scoreboard_edit',
    type = 'int',
    default = 100,
    min = 80,
    max = 130
})

onyx.scoreboard:RegisterOption('group_teams', {
    title = 'scoreboard.group_teams.name',
    desc = 'scoreboard.group_teams.desc',
    category = 'General',
    cami = 'onyx_scoreboard_edit',
    type = 'bool',
    default = true
})

onyx.scoreboard:RegisterOption('colored_players', {
    title = 'scoreboard.colored_players.name',
    desc = 'scoreboard.colored_players.desc',
    category = 'General',
    cami = 'onyx_scoreboard_edit',
    type = 'bool',
    default = true
})

onyx.scoreboard:RegisterOption('blur', {
    title = 'scoreboard.blur.name',
    desc = 'scoreboard.blur.desc',
    category = 'General',
    cami = 'onyx_scoreboard_edit',
    type = 'bool',
    default = false
})
--addons/onyx_scoreboard/lua/onyx/modules/scoreboard/core/columns/cl_columns.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

04/03/2024

--]]

net.Receive('onyx.scoreboard:SyncColumns', function()
    local amount = net.ReadUInt(8)

    onyx.scoreboard.columnsCustomizable = {}

    for _ = 1, amount do
        local index = net.ReadUInt(8)
        local id = net.ReadString()
        onyx.scoreboard.columnsCustomizable[index] = id
    end

    onyx.scoreboard:Print('Synchronized # columns.', amount)

    hook.Run('onyx.scoreboard.SyncedColumns')
end)
--addons/onyx_scoreboard/lua/onyx/modules/scoreboard/ui/cl_player_list.lua:
return gluapack()()
--lua/openpermissions/lang/english.lua:
return {
	Name = "English",
	Icon = "flags16/gb.png",
	Phrases = {
		operator_only_menu = "Only OpenPermissions Operators can access this menu.",
		permissions = "Permissions",
		help = "Help",
		tester = "Tester",
		access_groups = "Access Groups",
		access_group = "Access Group",
		type = "Type",
		add_access_group = "Add Access Group",
		custom_ellipsis = "Custom...",
		enter_usergroup = "Enter the name of a usergroup",
		enter_steamid = "Enter a SteamID or SteamID64. Examples:\nSteamID: %s\nSteamID64: %s",
		invalid_steamid = "That was not a valid SteamID.",
		error = "Error",
		ok = "OK",
		none_info = "(none)",
		key = "Key",
		access_group_exists = "This access group already exists.",
		operations = "Operations",
		select_an_access_group = "Please select access group(s) on the left",
		back_btn = "Back",
		delete_access_group = "Delete Selected Access Group(s)",
		copy = "Copy",
		paste = "Paste",
		all_permissions = "All Permissions",
		all_addons = "All Addons",
		save = "Save",
		not_an_addon = "That's not a valid addon.",
		hold_ctrl_to_select_multiple = "Hold CTRL to multiselect groups",
		permission_clash_msg = "WARNING: You have selected multiple access groups to copy, only permissions where\nall access groups have the same permission will be copied",
		Players = "Players",

		ACCESS_GROUP_OTHER = "Other",
		ACCESS_GROUP_USERGROUP = "Usergroup",
		ACCESS_GROUP_STEAMID = "SteamID",
		ACCESS_GROUP_TEAM = "Team",
		ACCESS_GROUP_LUA_FUNCTION = "Lua Function",
		ACCESS_GROUP_DARKRP_CATEGORY = "DarkRP Job Category",
	}
}
--lua/openpermissions/cl.lua:
return gluapack()()
--addons/partysystem/lua/autorun/partychat.lua:
if SERVER then
	util.AddNetworkString( "PartyChat")
	local function SendPartyMessage(ply, text)
		local Chatmembers = {}
		if !ply:GetParty() then return end
		for v, k in pairs (parties[ply:GetParty()].members) do
			table.insert(Chatmembers , player.GetBySteamID64(k))
		end
		local chattext = string.Right(text, string.len(text) - string.len( party.partychatcommand) - 1)
		local chattable = {ply:Nick(), chattext }
		net.Start("PartyChat")
			net.WriteTable(chattable)
		net.Send(Chatmembers)
		hook.Run("SPSChat", ply, parties[ply:GetParty()], chattext)
	end
	
	hook.Add( "PlayerSay", "PartyChatMessage", function(ply,text)
		if string.Left( text, string.len(party.partychatcommand) + 1 ) == party.partychatcommand.." " then  
		ServerLog("[Party] "..ply:Nick() ..": ".. text.."\n")
			if ply:GetParty() != nil then			
				SendPartyMessage(ply, text)
			end
		return ""
		end
	end)
end




if CLIENT then
	net.Receive("PartyChat", function(len, CLIENT)
		local chattable = net.ReadTable()
		chat.AddText( party.partychatcolr, party.language["[Party]"],  party.partychatnamecolr, chattable[1]..": ", party.partychatmsgcolr, chattable[2])
	end)
end
--addons/partysystem/lua/autorun/partysharedfunctions.lua:
return gluapack()()
--addons/pcasino/lua/perfectcasino/core/sh_config.lua:
return gluapack()()
--lua/autorun/pd2_swat_shield_zeal_player_npc.lua:
list.Set( "PlayerOptionsAnimations", "PD2_SWATShield_Zeal", { "idle_all_angry", "idle_all_01", "menu_walk" } )
player_manager.AddValidModel( "PD2_SWATShield_Zeal", "models/mark2580/payday2/pd2_swat_shield_zeal_player.mdl" )
player_manager.AddValidHands( "PD2_SWATShield_Zeal", "models/mark2580/payday2/pd2_swat_shield_zeal_c_arms.mdl", 0, "00000000" )

local function fixHealthAndModelBull( ply, ent )
  if IsValid(ent) then
    if ent:GetModel() == "models/mark2580/payday2/pd2_swat_shield_zeal_combine.mdl" then 
      ent:SetHealth( 300 )
      ent:SetMaxHealth( 300 )
    elseif ent:GetModel() == "models/mark2580/payday2/pd2_swat_shield_zeal_rebel.mdl" then 
      ent:SetHealth( 300 )
      ent:SetMaxHealth( 300 )
    end
  end
end

local Category = "PAYDAY 2 NPCs"

local NPC = {
  Name = "PD2 SWAT Heavy Zeal (Enemy)", 
  Class = "npc_combine_s",
  Model = "models/mark2580/payday2/pd2_swat_shield_zeal_combine.mdl",
  Weapons = { "weapon_smg1", "weapon_ar2", "weapon_shotgun" },
  Health = 100,
  KeyValues = {
    SquadName = "ZealTeam",
    Numgrenades = 5
  },
  Category = Category
}

list.Set( "NPC", "pd2_swat_shield_zeal_combine", NPC )

local NPC = {
  Name = "PD2 SWAT Heavy Zeal (Friendly)", 
  Class = "npc_citizen",
  Model = "models/mark2580/payday2/pd2_swat_shield_zeal_rebel.mdl",
  Health = 300,
  KeyValues = {
    citizentype = CT_UNIQUE
  },
  Weapons = { "weapon_pistol", "weapon_ar2", "weapon_smg1", "weapon_ar2", "weapon_shotgun" },
  Category = Category
}

list.Set( "NPC", "pd2_swat_shield_zeal_rebel", NPC )

hook.Add( "PlayerSpawnedNPC", "SWATShieldZealSpawned", fixHealthAndModelBull )
--lua/autorun/polisozelharekat_rebs.lua:
return gluapack()()
--lua/autorun/ppg.lua:
return gluapack()()
--addons/undertale/lua/autorun/psa_undertale.lua:
-- This script is copyright of !cake, STEAM_0:1:19269760, http://steamcommunity.com/profiles/76561197998805249
-- Undertale is copyright of Toby Fox
-- Undertale audio samples are copyright of Toby Fox

include ("psa_undertale/psa_undertale.lua")


--addons/undertale/lua/psa_undertale/ulx.lua:
return gluapack()()
--addons/tablo_ent/lua/scoresheet/sheets/level/shared.lua:
local SHEET = {}

SHEET.UniqueID = "top_10_levels"

SHEET.Name = scoresheet.level_header_text
SHEET.EntName = "score_level"
SHEET.HeaderColor = scoresheet.level_header_text_color

SHEET.Fetch = function()
	local data = sql.Query( "SELECT * from score_level ORDER by Level DESC LIMIT "..scoresheet.level_max_count )
	
	if ( !data ) then data = {} end

	return data
end

SHEET.Draw = function( ent, data )
	local y_pos = 20
	
	local x_pos = 0
	local cnt = 0
	
	for place, row in pairs( data ) do
		local row_header = "#"..place.." - "..row.Name
		local row_text = tonumber( row.Level ).." Level"
		
		if ( place == 1 ) then
			surface.SetFont( scoresheet.level_font_header )
			local textW = surface.GetTextSize( row_header )
			
			surface.SetDrawColor( 255, 255, 255 )
			surface.SetMaterial( scoresheet.level_first_place_icon )
			surface.DrawTexturedRect( x_pos + textW + 5, y_pos, 16, 16 )
		end
		
		draw.SimpleText( row_header, scoresheet.level_font_header, x_pos, y_pos, color_white )
		y_pos = y_pos + 20
		
		draw.SimpleText( row_text, scoresheet.level_font_text, x_pos, y_pos, color_white )
		y_pos = y_pos + 25
		
		cnt = cnt + 1
		
		if ( cnt >= scoresheet.level_cut_at_row_count ) then
			x_pos = 250
			y_pos = 20
			cnt = 0
		end
	end
end 

scoresheet:register( SHEET )
--addons/realisticcardealer/lua/realistic_cardealer/languages/sh_language_de.lua:
// Translated by Miya
// Steam Profile: https://steamcommunity.com/profiles/miyastudios
// Gmodstore Profile: https://www.gmodstore.com/users/76561198378317227

RCD = RCD or {}
RCD.Language = RCD.Language or {}

RCD.Language["de"] = {
	["undefined"] = "undefiniert",
	["adminMenuConfig"] = "ADMIN MENÜ - KONFIGURATION",
	["configureGroupsVehicles"] = "Konfiguriere Gruppen und Autos",
	["groups"] = "GRUPPEN",
	["vehicles"] = "AUTOS",
	["createGroup"] = "ERSTELLE EINE NEUE GRUPPE",
	["createVehicle"] = "ERSTELLE EIN NEUES AUTO",
	["dealerConfiguration"] = "AUTOHÄNDLER KONFIGURATION",
	["enterDealerName"] = "Wie soll der Autohändler heissen?",
	["groupsConfig"] = "Gruppen Config",
	["newPlateforms"] = "NEUE SPAWN PLATFORMEN",
	["deletePlateforms"] = "LÖSCHE ALLE PLATFORMEN",
	["deleteNPC"] = "LÖSCHE DEN NPC",
	["saveInformations"] = "INFORMATIONEN SPEICHERN",
	["configureGroups"] = "GRUPPEN INFORMATION KONFIGURIEREN",
	["rankAccess"] = "RANK ZUGRIFF",
	["jobAccess"] = "JOB ZUFRIFF",
	["enterGroupName"] = "Gruppennamen eingeben",
	["cancel"] = "ABBRECHEN",
	["validateCreateGroup"] = "GRUPPE BESTÄTIGEN UND ERSTELLEN",
	["configureVehicleInformations"] = "Autoinformationen konfigurieren",
	["preview"] = "Vorschau",
	["chooseVehicleClass"] = "Wähle eine Fahrzeugklasse...",
	["chooseVehicleGroup"] = "Wähle eine Fahrzeuggruppe...",
	["enterVehicleName"] = "Gebe einen Autonamen ein",
	["enterVehiclePrice"] = "Gebe einen AUtopreis ein",
	["vehicleView"] = "AUTOSICHT",
	["generalSettings"] = "ALLGEMEINE EINSTELLUNGEN",
	["priceSettings"] = "PREIS EINSTELLUNGEN",
	["validateCreateVehicle"] = "BESTÄTIGE UND ERSTELLE AUTO",
	["configureAddon"] = "Konfiguriere alle Addon Einstellungen",
	["beltConfig"] = "GURT EINSTELLUNGEN",
	["engineConfig"] = "MOTOR EINSTELLUNGEN",
	["speedometerConfig"] = "TACHO EINSTELLUNGEN",
	["driveConfig"] = "FAHR EINSTELLUNGEN",
	["configureCarDealers"] = "KONFIGURIERE ALLE AUTOHÄNDLER",
	["validateSaveSettings"] = "BESTÄTIGE UND SPEICHERE EINSTELLUNGEN",
	["underglow"] = "Unterbodenlicht",
	["skins"] = "Skins",
	["bodygroups"] = "Bodygroups",
	["carDealer"] = "Autohändler",
	["spawnVehicle"] = "AUTO SPAWNEN",
	["bringBack"] = "EINPARKEN",
	["testVehicle"] = "Testfahrt",
	["customize"] = "ANPASSEN",
	["sell"] = "VERKAUFEN",
	["buyVehicle"] = "KAUFEN",
	["customizationTitle"] = "ANPASSEN",
	["mainMenuTitle"] = "Hauptmenü",
	["modifyVehicle"] = "PASSE DEIN AUTO AN",
	["buySaleVehicles"] = "KAUFE ODER VERKAUFE DEIN AUTO",
	["vehicleOwned"] = "AUTO IM BESITZ",
	["vehicleForSale"] = "AUTO ZU VERKAUFEN",
	["allowed"] = "ERLAUBT",
	["cantCustomizeVehicle"] = "Du kannst das Auto nicht anpassen \n Wir entschuldigen uns für die Unannehmlichkeiten",
	["testDrive"] = "Testfahrt",
	["testDriveEnd"] = "Deine Testfahrt endet in: %ss",
	["addonNotInstalled"] = "%s addon ist nicht installiert",
	["vehicleTooFar"] = "Dein Auto ist zu weit weg um es anzupassen.",
	["customizeVehicleText"] = "Passe dein Auto für %s an",
	["invalidUsergroup"] = "Du hast nicht den erforderlichen Rank dafür",
	["invalidJob"] = "Du hast nicht den erforderlichen Job dafür",
	["cantAfford"] = "Du hast nicht genug Geld dafür",
	["buyVehicleText"] = "Du kaufst einen %s für %s",
	["cantReturnVehicle1"] = "Du kannst dein Auto nicht verkaufen wenn es ausgeparkt ist",
	["sellVehicleText"] = "Du hast dein Auto %s für %s verkauft",
	["testVehicleText"] = "Du hast eine Testfahrt gestartet, du hast jetzt %ss",
	["vehicleAlreadyExited"] = "Das Auto ist schon ausgeparkt",
	["maxVehicleLimitReached"] = "Du hast das Limit an ausgeparkten Autos erreicht",
	["cantSpawnVehicle2"] = "Du kannst während einer Testfahrt kein Auto ausparken",
	["noPlaceAvailable"] = "Es ist kein Platz vorhanden, komm später wieder",
	["vehicleExitedText2"] = "Du hast dein Fahrzeug %s ausgeparkt",
	["returnAroundVehicles"] = "Du hast dein Auto eingeparkt",
	["noVehiclesAround"] = "Es ist kein Auto in der Nähe",
	["vehicleTooFarText"] = "Dein Auto ist zu weit weg um es einzuparken",
	["vehicleReturned2"] = "Du hast dein Auto eingeparkt",
	["carDealerNotConfigured"] = "Der Autohändler ist noch nicht eingestellt, kontaktiere einen Admin.",
	["npcTooFar"] = "Du bist zu weit vom NPC weg um das zu tun.",
	["npcNotOwnedVehicle"] = "Der NPC hat dieses Fahrzeug nicht",
	["cantExitVehicle2"] = "Du kannst nicht aussteigen wenn dein Auto noch nicht steht",
	["cantExitVehicle3"] = "Du kannst nicht aussteigen wenn du noch angeschnallt bist",
	["invalidGroupName"] = "Der Gruppenname ist ungültig",
	["vehicleGroupEdited"] = "Du hast die Gruppe %s bearbeitet",
	["vehicleGroupCreated"] = "Du hast die Fahrzeuggruppe %s erstellt",
	["invalidGroupVehicle"] = "Die Fahrzeuggruppe ist ungültig",
	["vehicleGroupDeleted"] = "Du hast die Fahrzeuggruppe #%s gelöscht",
	["invalidVehicleClass"] = "Die Fahrzeugklasse ist ungültig",
	["invalidVehicleName"] = "Der Fahrzeugname ist ungültig",
	["invalidVehiclePrice"] = "Der Fahrzeugpreis ist ungültig",
	["vehicleEdited"] = "Du hast das Fahrzeug %s bearbeitet",
	["vehicleCreated"] = "Du hast Fahrzeug %s erstellt",
	["vehicleDeleted"] = "Du hast das Fahrzeug #%s gelöscht",
	["pnjUpdated"] = "Du hast den NPC %s geupdated",
	["pnjDeleted"] = "Du hast den NPC #%s gelöscht",
	["plateformEditMode"] = "Du bist im Editiermodus um Platformen zu platzieren",
	["beenSaved"] = "Du hast %s Platformen gespeichert",
	["allPlateformsDeleted"] = "Du hast alle Platformen gelöscht",
	["serverConfigurationUpdated"] = "Du hast die Konfiguration geupdated",
	["close"] = "Schliessen",
	["car"] = "Auto",
	["returnButton"] = "Einparken",
	["maxSpeed"] = "Max Geschwindigkeit",
	["horsePower"] = "PS",
	["wheelsPerAxles"] = "Reifen pro Achse",
	["posX"] = "Pos - X",
	["angleX"] = "Angle - X",
	["posY"] = "Pos - Y",
	["AngleY"] = "Angle - Y",
	["posZ"] = "Pos - Z",
	["angleZ"] = "Angle - Z",
	["fov"] = "FOV",
	["useCustomNotification"] = "Custom Benachrichtigung verwenden",
	["enterIntoVehicle"] = "Ins Fahrzeug einsteigen",
	["currency"] = "Währung",
	["adminCommand"] = "Admin Command",
	["maxVehicle"] = "Maximale Fahrzeuge",
	["testTime"] = "Testzeit",
	["distanceToReturn"] = "Reichweite zum einparken",
	["underglowKey"] = "Unterbodenlicht Taste",
	["activateBelt"] = "Sicherheitsgurt aktivieren",
	["warningSound"] = "Warnsound",
	["beltKey"] = "Sicherheitsgurt Taste",
	["activateEngine"] = "Motor aktivieren",
	["engineKey"] = "Motor Taste",
	["timeToLunchVehicle"] = "Zeit um Auto zu starten",
	["cantLeaveVehicleInMotion"] = "Kann das Auto verlassen wenn es in Bewegung ist?",
	["activateSmallAccident"] = "Kleine Unfälle aktivieren?",
	["activateEjectionAccident"] = "Auswurf Unfälle aktivieren?",
	["lowerSpeedToExit"] = "Langsame Geschwindigkeit zum austeigen",
	["minDamageSmallAccident"] = "Mindestschaden bei kleinen Unfällen",
	["minDamageEjectionAccident"] = "Mindestschaden bei Auswurf Unfällen",
	["activateSpeedometer"] = "Tacho aktivieren",
	["activateSimfphysSpeedometer"] = "Simfphys Tacho bei Simfphys Autos aktivieren",
	["speedometerSize"] = "Größe vom Tacho",
	["count"] = "Zählen",
	["space"] = "Platz",
	["defaultSkin"] = "Standartskin",
	["choose"] = "Auswählen",
	["skin"] = "Skin",
	["defaultColor"] = "Standartfarbe",
	["chooseColor"] = "Farbe wählen",
	["configureDefaultColor"] = "Standartfarbe Konfigurieren",
	["setDefaultColor"] = "Standartfarbe setzen",
	["canModifyBodygroup"] = "Darf die Bodygroup verändern?",
	["canModifySkin"] = "Darf den Skin verändern?",
	["canModifyColor"] = "Darf die Farbe verändern?",
	["canModifyUngerglow"] = "Darf das Unterbodenlicht verändern?",
	["canTestVehicle"] = "Darf das Auto testfahren?",
	["canBuyNitro"] = "Darf Nitro kaufen?",
	["priceToChangeBodygroups"] = "Preis um die Bodygroups zu ändern",
	["priceToChangeSkins"] = "Preis um den Skin zu ändern",
	["priceToChangeColors"] = "Preis um die Farbe zu ändern",
	["colors"] = "Farben",
	["nitro"] = "Nitro",
	["priceToChangeUnderglow"] = "Preis um das Unterbodenlicht zu ändern",
	["priceToBuyNitro"] = "Preis um Nitro zu kaufen",
	["pourcentSell"] = "Prozentzahl vom Sale",
	["noText"] = "Kein Text",
	["invalidText"] = "Text Problem",
	["language"] = "Sprache",
	["speedUnit"] = "Einheit der Geschwindigkeit",
	["free"] = "KOSTENLOS",
	["buyForFree"] = "KOSTENLOS KAUFEN",
	["customizePrice"] = "Du hast nicht genug Geld um das Auto zu modifizieren",
	["notEnoughtMoney"] = "Du hast nicht genug Geld um dies zu tun",
	["rentVehc"] = "Du hast das Fahrzeug: %s für %s gemietet",
	["cantSwitch"] = "Du kannst deinen Sitzplatz nicht wechseln wenn du angeschnallt bist",
	["canSellWithJob"] = "Du kannst Autos mieten wenn du Autohändler bist",
	["brakePower"] = "Bremskraft",
	["modifyRentVehicle"] = "Du hast die Fahrzeug Informationen bearbeitet",
	["refundRentVehicle"] = "Dir wurden %s rückerstattet",
	["turnSpeed"] = "Wendegeschwindigkeit",
	["mass"] = "Gewicht",
	["owned"] = "IM BESITZ",
	["cardealerJobSettings"] = "AUTOHÄNDLER JOB CONFIG",
	["cardealerJobDiscount"] = "Prozentualer Preis wenn das Auto von einem Spieler verkauft wird",
	["minCommissionPrice"] = "Mindestprovision",
	["maxCommissionPrice"] = "Maximaleprovision",
	["alreadyBought"] = "Du kannst das Auto nicht kaufen da du es schon besitzt",
	["notGoodTeam"] = "Du hast nicht den richtigen Job!",
	["rentPrice"] = "Mietpreis für den Autohändler Job",
	["vcmodTransfert"] = "Importiere alle VCMod Autos",
	["wcdTransfert"] = "Importiere alle WCD Autos",
	["advancedTransfert"] = "Importiere alle ACD Autos",
	["modernTransfert"] = "Importiere alle MCD Autos",
	["compatibilities"] = "Kompatibilität Einstellungen",
	["transfertStart"] = "Du hast die Datenübertragung gestartet... es könnte ein wenig dauern",
	["alreadyTransfert"] = "Du hast die Daten schon übertragen",
	["problem"] = "Ein Problem ist aufgetreten, bitte versuch es nochmal",
	["invoiceOptions"] = "Einstellungen",
	["invoiceCarName"] = "Fahrzeugname",
	["invoiceOptionPrice"] = "Preis",
	["invoiceTotalPrice"] = "Gesamtpreis",
	["sellerSignature"] = "Verkäufer Unterschrift",
	["buyerSignature"] = "Käufer Unterschrift",
	["invoice"] = "Rechnung",
	["seller"] = "Verkäufer : %s",
	["chooseSkin"] = "Wähle Skin",
	["chooseVehicle"] = "Wähle Fahrzeug",
	["sign"] = "Unterschreiben",
	["print"] = "Drucken",
	["openAdminConfiguration"] = "ADMIN EINSTELLUNGEN ÖFFNEN",
	["selectVehicle"] = "Du musst ein Fahrzeug auswählen",
	["noVehicles"] = "Du hast keine Autos die du konfigurieren kannst",
	["toolName"] = "NPC Setup",
	["toolDesc"] = "Platziere deinen NPC und Konfiguriere ihn",
	["toolLeft1"] = "Klicke Linksklick um die Platformen zu spawnen",
	["toolLeft2"] = "Klicke Linksklick um einen NPC zu spawnen oder zu konfigurieren",
	["toolRight1"] = "Klicke Rechtsklick um die letzte Platform zu löschen",
	["toolRight2"] = "Rechtsklick auf einen NPC um ihn zu löschen",
	["toolReload1"] = "Drücke RELOAD um die Platformen zu speichern",
	["toolReload2"] = "Drücke RELOAD um alle NPCs neuzuladen",
	["invoiceLimit"] = "Du hast dein Rechnungslimit erreicht",
	["stand"] = "STAND",
	["pressE"] = "DRÜCKE E",
	["yourCommission"] = "Deine Provisionen",
	["rentVehicle"] = "Miete das Auto für %s",
	["saveRentInformation"] = "INFORMATIONEN SPEICHERN",
	["startEngineProblem"] = "Ein Motorfehler ist aufgetreten als du deinen Motor starten wolltest",
	["giveVehicle"] = "Du hast das Fahrzeug %s zur SteamID %s gegeben",
	["carDealerJobConfig"] = "Autohändler Job Name",
    ["areYouSure"] = "BIST DU SICHER ?",
    ["reset"] = "ZURÜCKSETZEN",
    ["acceptedInvoice"] = "%s hat das Auto %s für %s gekauft",
    ["cantAcceptYourInvoice"] = "Du kannst deine eigene Rechnung nicht bezahlen!",
    ["import"] = "Importieren",
    ["standTitle"] = "AUTOHÄNDLER",
    ["sellVehicle"] = "Auto verkaufen",
    ["rentVehicleSpace"] = "Du hast keinen Platz um das Auto zu mieten!",
	["nitroKey"] = "Nitro Taste",
    ["nitroSpeed"] = "Nitro Geschwindigkeitsmultiplikator",
    ["minSpeedNitro"] = "Mindestgeschwindigkeit um Nitro zu aktivieren",
    ["cantSell"] = "Sie können dieses Fahrzeug nicht verkaufen",
    ["cantSellSetting"] = "Kann dieses Fahrzeug nicht verkaufen",
	["playersManagement"] = "Spielerverwaltung",
    ["open"] = "Öffnen",
    ["searchDisconnected"] = "ABGESCHALTETER SPIELER",
    ["connectedPlayers"] = "VERBUNDENDE SPIELER",
    ["selectedPlayer"] = "AUSGEWÄHLTER SPIELER",
    ["allVehicles"] = "ALLE FAHRZEUGE",
    ["adminMenuPlayer"] = "ADMIN MENÜ - SPIELER",  
    ["adminMenuPlayerDesc"] = "Fahrzeuge, die von deinen Spielern gekauft wurden, verwalten",
    ["modifiedInformation"] = "Du hast die Informationen von %s geändert",
    ["searchSteamId2"] = "Suche nach SteamID / SteamID64",
    ["refreshList"] = "LISTE AKTUALISIEREN",
    ["searchPlayer"] = "SPIELER SUCHEN",
    ["savePlayerInfo"] = "SPIELER INFORMATIONEN SPEICHERN",
	["nitroConfig"] = "NITRO-KONFIG",
	["nitroDuration"] = "Dauer von Nitro",
	["nitroCooldowns"] = "Nitro-Nachladezeit",
	["cooldownsNitroNotify"] = "Ihr Nitro ist nicht bereit für die nächste Ladung %ss",
	["alreadyRented"] = "Sie haben dieses Fahrzeug bereits gemietet",
	["sellVehicleRented"] = "Sie haben %s für den Verkauf des Fahrzeugs erhalten %s",
	["boatSettingText"] = "Handelt es sich bei dem Fahrzeug um ein Boot?",
	["disableBeltVehicle"] = "Sicherheitsgurtmodul für dieses Fahrzeug deaktivieren",
	["disableEngineVehicle"] = "Motormodul für dieses Fahrzeug deaktivieren",
}
--addons/realisticcardealer/lua/realistic_cardealer/sh_config.lua:
RCD = RCD or {}

--[[ If you use mysql you have to activate this and configure the mysql information and restart your server !! ]]
RCD.Mysql = false

--[[ Which rank can have access to the admin configuration ]]
RCD.AdminRank = {
    ["superadmin"] = true,
    ["admin"] = false,
}

--[[ Sound for each models ]]
RCD.AccidentModule = {
    ["modelSound"] = { 
        ["models/player/breen.mdl"] = "male",
        ["models/player/breen.mdl"] = "male",
    },
}

--[[ All colors used on the addon ]]
RCD.Colors = {
    ["black"] = Color(0, 0, 0),
    ["blackpurple"] = Color(23, 20, 35, 245),
    ["black18200"] = Color(18, 30, 42, 200),
    ["black18220"] = Color(18, 30, 42, 220),
    ["grey"] = Color(150, 150, 150),
    ["grey30"] = Color(150, 150, 150, 30),
    ["grey69"] = Color(69, 67, 79, 255),
    ["grey84"] = Color(84, 84, 88, 140),
    ["green97"] = Color(97, 181, 111),
    ["grey10010"] = Color(100, 100, 100, 10),
    ["grey10020"] = Color(100, 100, 100, 20),
    ["grey10050"] = Color(100, 100, 100, 50),
    ["grey134"] = Color(134, 119, 221, 20),
    ["grey187"] = Color(187, 178, -8, 108),
    ["notifycolor"] = Color(54, 140, 220),
    ["purple"] = Color(81, 56, 237),
    ["purple51"] = Color(84, 85, 165, 51),
    ["purple55"] = Color(55, 39, 134),
    ["purple84"] = Color(84, 86, 165),
    ["purple99"] = Color(99, 79, 210),
    ["purple120"] = Color(81, 56, 237, 100),
    ["red"] = Color(255, 0, 0, 255),
    ["red202"] = Color(202, 77, 68),
    ["speedoRed"] = Color(237, 56, 56),
    ["white"] = Color(248, 247, 252),
    ["white0"] = Color(255, 255, 255, 0),
    ["white2"] = Color(248, 247, 252, 2),
    ["white5"] = Color(248, 247, 252, 5),
    ["white20"] = Color(248, 247, 252, 10),
    ["white30"] = Color(248, 247, 252, 5),
    ["white80"] = Color(248, 247, 252, 80),
    ["white80248"] = Color(248, 247, 252, 80),
    ["white100"] = Color(248, 247, 252, 100),
    ["white120"] = Color(248, 247, 252, 120),
    ["white200"] = Color(248, 247, 252, 200),
    ["white200255"] = Color(200, 200, 200),
    ["white220"] = Color(255, 255, 255, 220),
    ["white250250"] = Color(250, 250, 250),
    ["white255200"] = Color(255, 255, 255, 200),
    ["white255"] = Color(255, 255, 255, 255),
    ["yellow"] = Color(183, 158, 55, 255),
}

RCD.UnitConvertion = {
    ["mph"] = 0.0568182, -- [[ Unit convertion to the mph ]]
    ["kmh"] = 0.09144, -- [[ Unit convertion to the kmh ]]
}

--[[ You can add more currency here ]]
RCD.Currencies = {
    ["$"] = function(money)
        return "$"..money
    end,
    ["€"] = function(money)
        return money.."€"
    end
}

--addons/realisticcardealer/lua/realistic_cardealer/client/cl_functions.lua:
return gluapack()()
--addons/realisticcardealer/lua/realistic_cardealer/client/cl_dealer.lua:
return gluapack()()
--addons/realisticcardealer/lua/realistic_cardealer/client/cl_speedometers.lua:
local lerpEngine, lerpBelt, redEngine, lerpEngineRed = 0, 0, false, 0
local lerpColorNitro = table.Copy(RCD.Colors["purple"])

hook.Add("HUDPaint", "RCD:HUDPaint:Speedometers", function()
    if not IsValid(RCD.LocalPlayer) then return end
    if not RCD.GetSetting("speedometerActivate", "boolean") then return end
    
    local plyVehc = RCD.LocalPlayer:GetVehicle()
    if not IsValid(plyVehc) then return end
    
    local vehc = RCD.GetVehicle(plyVehc)
    if not IsValid(vehc) then return end
    
    if istable(simfphys) && isfunction(RCD.LocalPlayer.IsDrivingSimfphys) && RCD.LocalPlayer:IsDrivingSimfphys() && RCD.DefaultSettings["activateSimfphysSpeedometer"] then return end
    /* 76561198447872548 */

    local unitChoose = RCD.GetSetting("unitChoose", "string")
    local speed = RCD.GetSpeedVehicle(vehc, unitChoose)
    local partSpeed = speed*0.01

    local speedoCount = RCD.GetSetting("speedometerCount", "number")
    local speedoSpace = RCD.GetSetting("speedometerSpace", "number")
    local speedoSize = RCD.GetSetting("speedometerSize", "number")

    local posx, posy = RCD.ScrW*RCD.GetSetting("speedometerPosX", "number"), RCD.ScrH*RCD.GetSetting("speedometerPosY", "number")
    local size = RCD.ScrW*0.0005*speedoSize

    RCD.MaskStencil(function()
        RCD.DrawComplexCircle(posx, posy, size*0.73, 0, 180, RCD.Colors["white"])
        for i=1, speedoCount do
            
            local radius = 180/speedoCount
            local space = i*radius

            RCD.DrawComplexCircle(posx, posy, size, space, space + speedoSpace, RCD.Colors["white"])
        end
    end, function()
        RCD.DrawComplexCircle(posx, posy, size, 1, 180, RCD.Colors["white120"])
    end, true)
    
    local nitro = RCD.GetNWVariables("RCDNitro", vehc)

    RCD.MaskStencil(function()
        RCD.DrawComplexCircle(posx, posy, size*0.73, 0, 180, RCD.Colors["white"])
        for i=1, speedoCount do
            
            local radius = 180/speedoCount
            local space = i*radius
            
            RCD.DrawComplexCircle(posx, posy, size, space, space + speedoSpace, RCD.Colors["white"])
        end
    end, function()
        lerpColorNitro = RCD.LerpColor(FrameTime()*2, lerpColorNitro, (nitro and RCD.Colors["speedoRed"] or RCD.Colors["purple"]))

        RCD.DrawComplexCircle(posx, posy, size, 0, math.Clamp(180*partSpeed, 0, 180), lerpColorNitro)
    end, true)
    
    surface.SetDrawColor(RCD.Colors["white"])
    surface.SetMaterial(RCD.Materials["needle"])

    RCD.DrawTexturedRectRotatedPoint(posx, posy, RCD.ScrW*0.08, size*1.1, 90-math.Clamp(180*partSpeed, 0, 180), 0, -(size*1.1)/2)
    
    surface.SetDrawColor(RCD.Colors["white220"])
	surface.SetMaterial(RCD.Materials["gradient"])
	surface.DrawTexturedRect(posx-RCD.ScrH*0.3, posy-RCD.ScrH*0.45, RCD.ScrH*0.6, RCD.ScrH*0.6)

    local speedRound = math.Round(speed)

    surface.SetFont(RCD.CreateFonts(RCD.ScrH*0.005*(size*0.09), "Georama Light", 0, true))
    local fontSizeX, fontSizeY = surface.GetTextSize(unitChoose)

    
    draw.SimpleText(speedRound, RCD.CreateFonts(RCD.ScrH*0.005*(size*0.16), "Georama Black", 1000), posx, posy*0.975 - fontSizeY, RCD.Colors["white"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
    draw.SimpleText(unitChoose, RCD.CreateFonts(RCD.ScrH*0.005*(size*0.075), "Georama Light", 0, true), posx, posy*0.99, RCD.Colors["white120"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
    
    local vehicleId = RCD.GetNWVariables("RCDVehicleId", vehc)
    local beltActivate = RCD.GetSetting("beltActivate", "boolean") && not RCD.GetVehicleParams(vehicleId, "disableBeltVehicle")

    --[[ Engine Module ]]
    if RCD.GetSetting("engineActivate", "boolean") && isfunction(vehc.GetDriver) && (vehc:GetDriver() == RCD.LocalPlayer) && not RCD.GetVehicleParams(vehicleId, "disableEngineVehicle") then
        local engineOn = hook.Run("RCD:CanChangeEngine", vehc)

        local posEngineX = (posx - size) - (beltActivate and RCD.ScrW*0.0001 or RCD.ScrW*0.0002)*size
        local sizeEngine = RCD.ScrW*0.00011*size
        local posEngineY = posy - (sizeEngine*(beltActivate and 3.5 or 1))
        
        local engineStatut = RCD.GetNWVariables("RCDEngine", vehc) && (engineOn != false)

        lerpEngine = Lerp(FrameTime()*5, lerpEngine, (engineStatut and sizeEngine or 0))
        
        RCD.DrawComplexCircle(posEngineX, posEngineY, sizeEngine, 0, 360, RCD.Colors["white80248"])
        RCD.DrawComplexCircle(posEngineX, posEngineY, lerpEngine, 0, 361, RCD.Colors["purple"])

        lerpEngineRed = Lerp(FrameTime()*5, lerpEngineRed, (redEngine and sizeEngine or 0))

        RCD.DrawComplexCircle(posEngineX, posEngineY, lerpEngineRed, 0, 361, RCD.Colors["speedoRed"])
        
        local iconSize = sizeEngine*0.9

        draw.SimpleText(string.upper(input.GetKeyName(RCD.GetSetting("engineKey", "number"))), RCD.CreateFonts(RCD.ScrH*0.005*(size*0.05), "Georama Bold", 1000), posEngineX-(iconSize*1.5), posEngineY-(sizeEngine*0.4), RCD.Colors["white120"], TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)

        surface.SetDrawColor(RCD.Colors["white"])
        surface.SetMaterial(RCD.Materials["engine"])
        surface.DrawTexturedRect(posEngineX-iconSize/2, posEngineY-iconSize/2, iconSize, iconSize)
    end
    
    --[[ Belt Module ]]
    if beltActivate then
        local posBeltX = (posx - size) - RCD.ScrW*0.0002*size
        local sizeBelt = RCD.ScrW*0.00011*size
        local posBeltY = posy - sizeBelt

        local securityBelt = RCD.GetNWVariables("RCDSecurityBelt", RCD.LocalPlayer)

        lerpBelt = Lerp(FrameTime()*5, lerpBelt, (securityBelt and sizeBelt or 0))
        
        RCD.DrawComplexCircle(posBeltX, posBeltY, sizeBelt, 0, 360, RCD.Colors["white80248"])
        RCD.DrawComplexCircle(posBeltX, posBeltY, lerpBelt, 0, 361, RCD.Colors["purple"])
        
        local iconSize = sizeBelt*0.9
        draw.SimpleText(string.upper(input.GetKeyName(RCD.GetSetting("beltKey", "number"))), RCD.CreateFonts(RCD.ScrH*0.005*(size*0.05), "Georama Bold", 1000), posBeltX-(iconSize*1.5), posBeltY-(sizeBelt*0.4), RCD.Colors["white120"], TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
        
        surface.SetDrawColor(RCD.Colors["white"])
        surface.SetMaterial(RCD.Materials["belt"])
        surface.DrawTexturedRect((posBeltX-iconSize/2), posBeltY-iconSize/2, iconSize, iconSize)
    end
end)

hook.Add("RCD:CanChangeEngine", "RCD:CanChangeEngine:Compatibilities", function(vehc)
    if not IsValid(vehc) then return end

    if vehc:WaterLevel() >= 2 then 
        local vehicleId = RCD.GetNWVariables("RCDVehicleId", vehc)
        local vehicleTable = RCD.GetVehicleInfo(vehicleId) or {}

        local options = vehicleTable["options"] or {}
        if options["isBoat"] then return end

        return false
    end

    local health, fuel = 100, 100
    if not vehc.IsSimfphyscar then
        if VC && isfunction(vehc.VC_getHealth) && isfunction(vehc.VC_fuelGet) then
            health = vehc:VC_getHealth(true)        
            fuel = vehc:VC_fuelGet(true)
        elseif SVMOD && SVMOD:GetAddonState() && isfunction(vehc.SV_GetHealth) && isfunction(vehc.SV_GetFuel) then
            health = vehc:SV_GetHealth()
            fuel = vehc:SV_GetFuel()
        end
    elseif vehc.IsSimfphyscar && isfunction(vehc.GetCurHealth) && isfunction(vehc.GetFuel) then
        health = vehc:GetCurHealth()
        fuel = vehc:GetFuel()
    end
    
    if fuel <= 0 then return false end
    if health <= 0 then return false end
end)

hook.Add("KeyPress", "RCD:KeyPress:CheckEngine", function(ply, key)
    if not IsValid(RCD.LocalPlayer) then return end

    local plyVehc = RCD.LocalPlayer:GetVehicle()
    if not IsValid(plyVehc) then return end

    local vehc = RCD.GetVehicle(plyVehc)
    if not IsValid(vehc) then return end

    local engineOn = hook.Run("RCD:CanChangeEngine", vehc)
    local engineStatut = RCD.GetNWVariables("RCDEngine", vehc) && (engineOn != false)

    if key == IN_FORWARD && not redEngine && not engineStatut && not RCD.GetVehicleParams(vehicleId, "disableEngineVehicle") then
        redEngine = true

        timer.Simple(0.7, function()
            redEngine = false
        end)
    end
end)
--addons/realisticcardealer/lua/realistic_cardealer/vgui/cl_slider.lua:
local PANEL = {}


function PANEL:Init()
    self:SetSize(RCD.ScrW*0.1949, RCD.ScrH*0.5)
    self:SetMinMax(0, 1)

    function self.Slider.Knob:Paint(w, h)
	    draw.NoTexture()
        RCD.DrawCircle(w/2, h/2, h/3.5, 0, 360, RCD.Colors["white"])
    end

    function self.Slider:Paint() end
    
    function self:Paint(w,h)
        local coef = math.Remap(self:GetValue(), self:GetMin(), self:GetMax(), 0, 1)

        draw.RoundedBox(0, 0, h*0.5-RCD.ScrH*0.005/2, w*0.99, RCD.ScrH*0.005, RCD.Colors["grey"])
        draw.RoundedBox(0, 0, h*0.5-RCD.ScrH*0.005/2, w*coef*0.99, RCD.ScrH*0.005, RCD.Colors["purple"])
    end

    self.TextArea:SetVisible(false)
    self.Label:SetVisible(false)
end

derma.DefineControl("RCD:Slider", "RCD Slider", PANEL, "DNumSlider")
--lua/autorun/rppropsextanded_init.lua:
return gluapack()()
--addons/rsc/lua/rsc/shared/sh_net.lua:
return gluapack()()
--addons/rsc/lua/rsc/client/cl_init.lua:
return gluapack()()
--addons/sam-159/lua/sam/libs/sh_async_netstream.lua:
if SAM_LOADED then return end

local netstream = sam.netstream
netstream.async = {}

if SERVER then
	local IsValid = IsValid
	function netstream.async.Hook(name, fn, check)
		netstream.Hook(name, function(ply, i, ...)
			if not sam.isnumber(i) then return end
			local res = function(...)
				if IsValid(ply) then
					netstream.Start(ply, name, i, ...)
				end
			end
			fn(res, ply, ...)
		end, check)
	end
else
	local count = 0
	local receivers = {}

	local hook_fn = function(i, ...)
		local receiver = receivers[i]
		if receiver[2] then
			receiver[2]()
		end
		receiver[1]:resolve(...)
		receivers[i] = nil
	end

	function netstream.async.Start(name, func_to_call, ...)
		local promise = sam.Promise.new()
		count = count + 1
		receivers[count] = {promise, func_to_call}
		netstream.Hook(name, hook_fn)
		if func_to_call then
			func_to_call()
		end
		netstream.Start(name, count, ...)
		return promise
	end
end
--addons/sam-159/lua/sam/libs/sh_promises.lua:
return gluapack()()
--addons/sam-159/lua/sam/command/arguments/player.lua:
return gluapack()()
--addons/sui/lua/includes/modules/sui.lua:
if sui then return end

AddCSLuaFile()

sui = {}

do
	local wspace_chs = {} -- whitespace  characters except a normal space " "
	for k, v in ipairs({0x0c, 0x0a, 0x0d, 0x09, 0x0b}) do
		wspace_chs[string.char(v)] = true
	end
	sui.wspace_chs = wspace_chs

	local cntrl_chs = {string.char(0x7f)} -- control characters
	for i = 0x00, 0x1f do
		cntrl_chs[string.char(i)] = true
	end
	sui.cntrl_chs = cntrl_chs
end

if SERVER then
	AddCSLuaFile("sui/libs/tdlib/cl_tdlib.lua")
	AddCSLuaFile("sui/libs/bshadows.lua")
	AddCSLuaFile("sui/libs/gif_loader.lua")
	AddCSLuaFile("sui/libs/png_encoder.lua")
	AddCSLuaFile("sui/libs/types.lua")
	AddCSLuaFile("sui/cl_base.lua")
else
	include("sui/libs/tdlib/cl_tdlib.lua")
	include("sui/libs/bshadows.lua")
	include("sui/libs/types.lua")
	include("sui/cl_base.lua")
end

if SERVER then
	for _, f in ipairs(file.Find("sui/vgui/*.lua", "LUA")) do
		AddCSLuaFile("sui/vgui/" .. f)
	end
end
--addons/sam-159/lua/sam/menu/cl_init.lua:
return gluapack()()
--addons/sui/lua/sui/vgui/sui_combobox.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local TEXT_FONT = SUI.CreateFont("ComboBox", "Roboto Regular", 16)

local GetColor = SUI.GetColor
local draw_material = sui.draw_material

local PANEL = {}

PANEL.NoOverrideClear = true

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()
	self.DropButton:Remove()
	self:SetFont(TEXT_FONT)
	self:SetSize(34, 22)
	self:SetIsMenu(true)

	local image = self:Add(NAME .. ".Image")
	image:Dock(FILL)
	image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/arrow.png")
	image.Draw = self.Paint
end

function PANEL:OpenMenu(pControlOpener)
	if pControlOpener and pControlOpener == self.TextEntry then return end
	if #self.Choices == 0 then return end

	if IsValid(self.Menu) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self.Menu = vgui.Create(NAME .. ".Menu", self)
	self.Menu:SetInternal(self)

	for k, v in ipairs(self.Choices) do
		self.Menu:AddOption(v, function()
			self:ChooseOption(v, k)
		end)
	end

	local x, y = self:LocalToScreen(0, self:GetTall())
	self.Menu:SetMinimumWidth(self:GetWide())
	self.Menu:Open(x, y, false, self)
end

function PANEL:Paint(w, h, from_image)
	local text_color = GetColor("menu_option_hover_text")

	if from_image then
		local size = SUI.ScaleEven(10)
		draw_material(nil, w - (size / 2) - 6, h / 2, size, text_color)
	else
		local col = GetColor("menu")
		self:RoundedBox("Background", 4, 0, 0, w, h, col)
		self:SetTextColor(text_color)
	end
end

function PANEL:PerformLayout()
end

sui.register("ComboBox", PANEL, "DComboBox")
--addons/sui/lua/sui/vgui/sui_frame.lua:
local math = math
local gui = gui
local draw = draw
local surface = surface

local ScrW = ScrW
local ScrH = ScrH
local IsValid = IsValid
local ipairs = ipairs

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local FRAME_FONT = SUI.CreateFont("Frame", "Roboto", 18)

local Panel = FindMetaTable("Panel")

local PANEL = {}

AccessorFunc(PANEL, "m_bHeaderHeight", "HeaderHeight", FORCE_NUMBER)
AccessorFunc(PANEL, "m_bTitleFont", "TitleFont", FORCE_STRING)
AccessorFunc(PANEL, "m_bSizable", "Sizable", FORCE_BOOL)
AccessorFunc(PANEL, "m_iMinWidth", "MinWidth", FORCE_NUMBER)
AccessorFunc(PANEL, "m_iMinHeight", "MinHeight", FORCE_NUMBER)

local header_Think = function(s)
	local parent = s.parent
	local sw, sh = ScrW(), ScrH()

	if s.dragging then
		local x, y = input.GetCursorPos()
		x, y = math.Clamp(x, 1, sw - 1), math.Clamp(y, 1, sh - 1)
		x, y = x - s.dragging[1], y - s.dragging[2]

		parent:SetPos(x, y)
		parent:InvalidateLayout(true)
		parent:OnPosChanged()
	else
		local x, y, w, h = parent:GetBounds()
		parent:SetPos(math.Clamp(x, 5, sw - w - 5), math.Clamp(y, 5, sh - h - 5))
	end
end

local header_OnMousePressed = function(s)
	local parent = s.parent
	s.dragging = {gui.MouseX() - parent.x, gui.MouseY() - parent.y}
	s:MouseCapture(true)
end

local header_OnMouseReleased = function(s)
	s.dragging = nil
	s:MouseCapture(false)
end

local title_SetBGColor = function(s, c)
	s:SetVisible(c and true or false)
end

local title_update_color = function(s)
	s:SetTextColor(SUI.GetColor("title"))
end

local close_DoClick = function(s)
	s.frame:Remove()
end

function PANEL:Init()
	local header_buttons = {}
	self.header_buttons = header_buttons

	self:Center()
	self:SetHeaderHeight(28)

	local header = self:Add("PANEL")
	header:Dock(TOP)
	header.Paint = self.HeaderPaint
	header:SetCursor("sizeall")

	header.parent = self
	header.Think = header_Think
	header.OnMousePressed = header_OnMousePressed
	header.OnMouseReleased = header_OnMouseReleased
	self.header = header

	local title = header:Add(NAME .. ".Label")
	title:Dock(LEFT)
	title:DockMargin(6, 2, 0, 2)
	title:SetText("")
	title:SetTextColor(SUI.GetColor("title"))
	title:SizeToContents()
	title.SetBGColor = title_SetBGColor
	hook.Add(NAME .. ".ThemeChanged", title, title_update_color)
	self.title = title

	self.close = self:AddHeaderButton("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/close.png", "close", close_DoClick)
	self.close.frame = self

	self:SetSize(SUI.Scale(520), SUI.Scale(364))
	self:SetTitleFont(FRAME_FONT)
	SUI.OnScaleChanged(self, self.ScaleChanged)

	function self:PerformLayout(w, h)
		if IsValid(title) then
			title:SizeToContents()
		end

		if IsValid(header) then
			header:SetTall(SUI.Scale(self:GetHeaderHeight()))
		end

		for k, v in ipairs(header_buttons) do
			if IsValid(v) then
				v:SetWide(v:GetTall())
				local margin = SUI.Scale(4)
				v.image:DockMargin(margin, margin, margin, margin)
			end
		end
	end
end

function PANEL:SetSize(w, h)
	self.real_w, self.real_h = w, h
	self:ScaleChanged()
end

function PANEL:HeaderPaint(w, h)
	draw.RoundedBoxEx(3, 0, 0, w, h, SUI.GetColor("header"), true, true)
end

local SetSize = Panel.SetSize
PANEL.RealSetSize = SetSize
function PANEL:ScaleChanged()
	if self.sizing then return end

	local new_w, new_h = SUI.Scale(self.real_w), SUI.Scale(self.real_h)
	self.x, self.y = self.x + (self:GetWide() / 2 - new_w / 2), self.y + (self:GetTall() / 2 - new_h / 2)
	SetSize(self, new_w, new_h)
	self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
	if SUI.GetColor("frame_blur") then
		TDLib.BlurPanel(self)
	end

	self:RoundedBox("Background", 3, 0, 0, w, h, SUI.GetColor("frame"))
end

function PANEL:SetTitleFont(font)
	self.m_bTitleFont = font
	self.title:SetFont(font)
end

function PANEL:SetTitle(text)
	self.title:SetText(text)
	self.title:SizeToContents()
end

function PANEL:AddHeaderButton(image_name, name, callback)
	local button = self.header:Add("DButton")
	button:SetText("")
	button:Dock(RIGHT)
	button:DockMargin(0, 2, #self.header:GetChildren() == 1 and 4 or 2, 2)

	local hover = name .. "_hover"
	local press = name .. "_press"
	local circle = {}
	button.Paint = function(s, w, h)
		if s:IsHovered() then
			TDLib.DrawCircle(circle, w / 2, h / 2, w / 2, SUI.GetColor(hover))
		end

		if s.Depressed then
			TDLib.DrawCircle(circle, w / 2, h / 2, w / 2, SUI.GetColor(press))
		end
	end
	button.DoClick = callback

	local image = button:Add(NAME .. ".Image")
	image:Dock(FILL)
	image:SetMouseInputEnabled(false)
	image:SetImage(image_name)

	button.image = image

	table.insert(self.header_buttons, button)

	return button
end

function PANEL:OnMousePressed(_, checking)
	if not self.m_bSizable then return end

	local x, y = self:LocalToScreen(0, 0)
	local w, h = self:GetSize()
	if gui.MouseX() > (x + w - 20) and gui.MouseY() > (y + h - 20) then
		if not checking then
			self.sizing = {gui.MouseX() - w, gui.MouseY() - h}
			self:MouseCapture(true)
		end

		self:SetCursor("sizenwse")

		return
	end

	if checking then
		self:SetCursor("arrow")
	end
end

function PANEL:OnMouseReleased()
	if not self.m_bSizable then return end

	self:MouseCapture(false)
	SUI.CallScaleChanged()
	self.sizing = nil
end

function PANEL:Think()
	if not self.m_bSizable then return end

	self:OnMousePressed(nil, true)

	if not self.sizing then return end

	local sw, sh = ScrW(), ScrH()

	local cx, cy = input.GetCursorPos()
	local mousex = math.Clamp(cx, 1, sw - 1)
	local mousey = math.Clamp(cy, 1, sh - 1)

	local x = mousex - self.sizing[1]
	x = math.Clamp(x, self.m_iMinWidth, sw - 10)

	local y = mousey - self.sizing[2]
	y = math.Clamp(y, self.m_iMinHeight, sh - 10)

	self.real_w, self.real_h = x, y
	SetSize(self, x, y)
	self:InvalidateLayout(true)
	self:SetCursor("sizenwse")
end

function PANEL:OnPosChanged()
end

local SetVisible = Panel.SetVisible
local Remove = Panel.Remove

local anim_speed = 0.2

local show = function(s)
	local w, h = s.real_w, s.real_h

	if s.anim_scale then
		w, h = SUI.Scale(w), SUI.Scale(h)
	end

	SetVisible(s, true)

	SetSize(s, w * 1.1, h * 1.1)
	s:Center()

	s:Stop()
	s:SizeTo(w, h, anim_speed, 0, -1)
	s:MoveTo((ScrW() / 2) - (w / 2), (ScrH() / 2) - (h / 2), anim_speed, 0, -1)
	s:AlphaTo(255, anim_speed + 0.02, 0)
	s:MakePopup()
end

local remove = function(s, hide)
	if not hide and not s:IsVisible() then
		Remove(s)
		return
	end

	local w, h = s.real_w, s.real_h

	if s.anim_scale then
		w, h = SUI.Scale(w), SUI.Scale(h)
	end

	w, h = w * 1.1, h * 1.1

	s:Stop()
	s:SizeTo(w, h, anim_speed, 0, -1)
	s:MoveTo((ScrW() / 2) - (w / 2), (ScrH() / 2) - (h / 2), anim_speed, 0, -1)
	s:SetMouseInputEnabled(false)
	s:SetKeyboardInputEnabled(false)
	s:AlphaTo(0, anim_speed + 0.02, 0, function()
		if hide then
			SetVisible(s, false)
		else
			Remove(s)
		end
	end)
end

local hide = function(s)
	remove(s, true)
end

function PANEL:AddAnimations(w, h, no_scale)
	self.anim_scale = not no_scale
	self.real_w, self.real_h = w, h

	self:SetAlpha(0)
	show(self)

	self.Remove = remove
	self.Hide = hide
	self.Show = show
end

sui.register("Frame", PANEL, "EditablePanel")
--addons/sui/lua/sui/vgui/sui_image.lua:
return gluapack()()
--addons/sui/lua/sui/vgui/sui_scroll_panel.lua:
local math = math
local table = table

local pairs = pairs

local TDLib = sui.TDLib
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local RoundedBox = sui.TDLib.LibClasses.RoundedBox

local Panel = {}

AccessorFunc(Panel, "m_bFromBottom", "FromBottom", FORCE_BOOL)
AccessorFunc(Panel, "m_bVBarPadding", "VBarPadding", FORCE_NUMBER)

Panel:SetVBarPadding(0)

Panel.NoOverrideClear = true

-- VBar
local starting_scroll_speed = 3

local vbar_OnMouseWheeled = function(s, delta)
	s.scroll_speed = s.scroll_speed + 20 * 0.012 --[[ slowly increase scroll speed ]]
	s:AddScroll(delta * -s.scroll_speed)
end

-- default set scroll clamps amount
local vbar_SetScroll = function(s, amount)
	if not s.Enabled then s.Scroll = 0 return end

	s.scroll_target = amount
	s:InvalidateLayout()
end

-- ¯\_(ツ)_/¯ https://github.com/Facepunch/garrysmod/blob/cd3d894288b847e3d081570129963d4089e36261/garrysmod/lua/vgui/dvscrollbar.lua#L234
local vbar_OnCursorMoved = function(s, _, y)
	if s.Dragging then
		y = y - s.HoldPos
		y = y / (s:GetTall() - s:GetWide() * 2 - s.btnGrip:GetTall())
		s.scroll_target = y * s.CanvasSize
	end
end

local vbar_Think = function(s)
	local frame_time = RealFrameTime() * 17
	local scroll_target = s.scroll_target

	s.Scroll = Lerp(frame_time, s.Scroll, scroll_target)

	if not s.Dragging then
		s.scroll_target = Lerp(frame_time, scroll_target, math.Clamp(scroll_target, 0, s.CanvasSize))
	end

	-- now start slowing it down!!!
	s.scroll_speed = Lerp(frame_time / 10, s.scroll_speed, starting_scroll_speed)
end

local vbar_Paint = function(s, w, h)
	TDLib.RoundedBox(s.vertices, 3, 0, 0, w, h, SUI.GetColor("scroll"))
end

local vbarGrip_Paint = function(s, w, h)
	TDLib.RoundedBox(s.vertices, 3, 0, 0, w, h, SUI.GetColor("scroll_grip"))
end

local vbar_PerformLayout = function(s, w, h)
	local scroll = s:GetScroll() / s.CanvasSize
	local bar_size = math.max(s:BarScale() * h, 10)

	local track = (h - bar_size) + 1
	scroll = scroll * track

	s.btnGrip.y = scroll
	s.btnGrip:SetSize(w, bar_size)
end
--

function Panel:Init()
	local canvas = self:GetCanvas()
	canvas:SUI_TDLib()

	local children = {}
	function canvas:OnChildAdded(child)
		table.insert(children, child)
	end
	function canvas:OnChildRemoved(child)
		for i = 1, #children do
			local v = children[i]
			if v == child then
				table.remove(children, i)
				return
			end
		end
	end
	canvas.GetChildren = function()
		return children
	end
	canvas.children = children

	local vbar = self.VBar
	vbar:SetHideButtons(true)
	vbar.btnUp:SetVisible(false)
	vbar.btnDown:SetVisible(false)

	vbar.vertices = {}
	vbar.scroll_target = 0
	vbar.scroll_speed = starting_scroll_speed

	vbar.OnMouseWheeled = vbar_OnMouseWheeled
	vbar.SetScroll = vbar_SetScroll
	vbar.OnCursorMoved = vbar_OnCursorMoved
	vbar.Think = vbar_Think
	vbar.Paint = vbar_Paint
	vbar.PerformLayout = vbar_PerformLayout

	vbar.btnGrip.vertices = {}
	vbar.btnGrip.Paint = vbarGrip_Paint

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function Panel:OnChildAdded(child)
	self:AddItem(child)
	self:ChildAdded(child)
end

function Panel:ChildAdded()
end

function Panel:ScaleChanged()
	local w = SUI.Scale(4)

	self.VBar:SetWide(w)
	self.VBar.btnDown:SetSize(w, 0)
	self.VBar.btnUp:SetSize(w, 0)
end

function Panel:Paint(w, h)
	local outline = SUI.GetColor("scroll_panel_outline")
	if outline then
		TDLib.DrawOutlinedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"), outline, 1)
	else
		RoundedBox(self, "Background", 3, 0, 0, w, h, SUI.GetColor("scroll_panel"))
	end
end

function Panel:ScrollToBottom()
	local vbar = self.VBar
	for k, anim in pairs(vbar.m_AnimList or {}) do
		anim:Think(vbar, 1)
		vbar.m_AnimList[k] = nil
	end

	self:InvalidateParent(true)
	self:InvalidateChildren(true)

	vbar:SetScroll(vbar.CanvasSize)
end

function Panel:PerformLayoutInternal(w, h)
	w = w or self:GetWide()
	h = h or self:GetTall()

	local canvas = self.pnlCanvas

	self:Rebuild()

	local vbar = self.VBar
	vbar:SetUp(h, canvas:GetTall())

	if vbar.Enabled then
		w = w - vbar:GetWide() - self.m_bVBarPadding
	end

	canvas:SetWide(w)

	self:Rebuild()
end

function Panel:Think()
	local canvas = self.pnlCanvas

	local vbar = self.VBar
	if vbar.Enabled then
		canvas.y = -vbar.Scroll
	else
		if self:GetFromBottom() then
			canvas._y = Lerp(10 * RealFrameTime(), canvas._y or canvas.y, self:GetTall() - canvas:GetTall())
		else
			canvas._y = Lerp(10 * RealFrameTime(), canvas._y or canvas.y, -vbar.Scroll)
		end
		canvas.y = canvas._y
	end
end

sui.register("ScrollPanel", Panel, "DScrollPanel")

--addons/sui/lua/sui/vgui/sui_zbutton.lua:
local draw = draw
local render = render

local TDLib = sui.TDLib
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local lerp_color = sui.lerp_color
local contrast_color = sui.contrast_color

local BUTTON_FONT = SUI.CreateFont("Button", "Roboto Medium", 16)

local color_white = color_white
local color_transparent = Color(0, 0, 0, 0)

local PANEL = {}

AccessorFunc(PANEL, "m_Background", "Background")
AccessorFunc(PANEL, "m_bContained", "Contained", FORCE_BOOL)

sui.TDLib.Install(PANEL)
sui.scaling_functions(PANEL)

PANEL:ClearPaint()
PANEL:SetContained(true)

local Panel = FindMetaTable("Panel")
local SetMouseInputEnabled = Panel.SetMouseInputEnabled
local IsMouseInputEnabled = Panel.IsMouseInputEnabled
local SetCursor = Panel.SetCursor
local SetContentAlignment = Panel.SetContentAlignment
function PANEL:Init()
	self:ScaleInit()

	self.vertices, self.vertices_2 = {}, {}

	SetMouseInputEnabled(self, true)
	SetCursor(self, "hand")
	SetContentAlignment(self, 5)

	self:SetSize(90, 30)
	self:SetFont(BUTTON_FONT)

	self:CircleClick(nil, 7)

	self.OldPaint, self.Paint = self.Paint, self.Paint2

	self.cur_col = Color(0, 0, 0, 0)
end

function PANEL:SetEnabled(b)
	SetMouseInputEnabled(self, b)
end

function PANEL:IsEnabled()
	return IsMouseInputEnabled(self)
end

function PANEL:ContainedPaint(w, h)
	local enabled = self:IsEnabled()
	local col
	if enabled then
		col = self:GetBackground() or SUI.GetColor("button")
		self:SetTextColor(SUI.GetColor("button_text"))
	else
		col = SUI.GetColor("button_disabled")
		self:SetTextColor(SUI.GetColor("button_disabled_text"))
	end
	self:RoundedBox("Background", 4, 0, 0, w, h, col)

	if not enabled then return end

	self.circle_click_color = SUI.GetColor("button_click")

	if self.Hovered or self.Selected then
		self:RoundedBox("Hover", 4, 0, 0, w, h, SUI.GetColor("button_hover"))
	end
end

function PANEL:SetColors(hover_color, text_color)
	self.hover = hover_color
	self.text_color = text_color
end

function PANEL:Paint2(w, h)
	if self:GetContained() then
		self:ContainedPaint(w, h)
		self:OldPaint(w, h)
		return
	end

	render.ClearStencil()
	render.SetStencilEnable(true)

	render.SetStencilWriteMask(1)
	render.SetStencilTestMask(1)

	render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	render.SetStencilPassOperation(STENCILOPERATION_ZERO)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
	render.SetStencilReferenceValue(1)

	TDLib.RoundedBox(self.vertices, 4, 0, 0, w, h, color_white)

	render.SetStencilFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	render.SetStencilReferenceValue(1)

	local cur_col = self.cur_col
	if self.Selected then
		lerp_color(cur_col, SUI.GetColor("button2_selected"))
	elseif self.Hovered then
		lerp_color(cur_col, self.hover or SUI.GetColor("button2_hover"))
	else
		lerp_color(cur_col, color_transparent)
	end

	TDLib.RoundedBox(self.vertices_2, 4, 0, 0, w, h, cur_col)

	if self.text_color then
		self.circle_click_color = self.text_color
		self:SetTextColor(self.text_color)
	else
		local col = contrast_color(cur_col)
		self.circle_click_color = col
		self:SetTextColor(col)
	end

	self:OldPaint(w, h)

	render.SetStencilEnable(false)
	render.ClearStencil()
end

sui.register("Button", PANEL, NAME .. ".Label")
--addons/sui/lua/sui/vgui/sui_zcollapse_category.lua:
local sui = sui

local draw_material = sui.draw_material

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local RoundedBox = sui.TDLib.LibClasses.RoundedBox
local TextColor = sui.TDLib.LibClasses.TextColor

local TABS_FONT = SUI.CreateFont("CategoryListTabs", "Roboto Bold", 13)
local ITEMS_FONT = SUI.CreateFont("CategoryListItems", "Roboto Medium", 14)

local Panel = {}

local item_OnRemove = function(s)
	local parent = s.parent

	local items = parent.items
	for k, v in ipairs(items) do
		if v == s then
			table.remove(items, k)
			break
		end
	end

	if #items == 0 then
		local category = s.category
		category:Remove()
		parent.categories[category.name] = nil
	end
end

local item_DoClick = function(s)
	local parent = s.parent
	parent:select_item(s)
end

function Panel:Init()
	local categories = {}
	local items = {}

	self.categories = categories
	self.items = items

	self:SetVBarPadding(1)

	local get_category = function(name)
		local category = categories[name]
		if category then return category end

		local expanded = false

		category = self:Add("Panel")
		category:Dock(TOP)
		category:DockMargin(0, 0, 0, 3)
		category.name = name

		local header = category:Add("DButton")
		header:Dock(TOP)
		header:DockMargin(0, 0, 0, 3)
		header:SetFont(TABS_FONT)
		header:SetContentAlignment(4)
		header:SetTextInset(6, 0)
		header:SetText(name)
		header:SizeToContentsY(SUI.Scale(14))

		local cur_col
		local cur_col_text = Color(GetColor("collapse_category_header_text"):Unpack())
		function header:Paint(w, h)
			if expanded then
				cur_col = GetColor("collapse_category_header_active")
				cur_col_text = GetColor("collapse_category_header_text_active")
			elseif self.Hovered then
				cur_col = GetColor("collapse_category_header_hover")
				cur_col_text = GetColor("collapse_category_header_text_hover")
			else
				cur_col = GetColor("collapse_category_header")
				cur_col_text = GetColor("collapse_category_header_text")
			end

			RoundedBox(self, "Background", 3, 0, 0, w, h, cur_col)
			TextColor(self, cur_col_text)
		end

		local image = header:Add(NAME .. ".Image")
		image:Dock(FILL)
		image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/arrow.png")

		function image:Draw(w, h)
			local size = SUI.ScaleEven(10)
			draw_material(nil, w - (size / 2) - 6, h / 2, size, cur_col_text, expanded and 180)
		end

		local current_h
		function category.RefreshHeight()
			local h
			if expanded then
				local _
				_, h = category:ChildrenSize()
				if self.searching and h == header:GetTall() then
					h = 0
				end
			else
				h = header:GetTall()
			end

			if current_h == h then return end

			if h > 0 then
				category:SetVisible(true)
			end

			current_h = h

			category:Stop()
			category:SizeTo(-1, h, 0.2, 0, -1, function()
				if h == 0 then
					category:SetVisible(false)
				end
			end)
		end

		function category.SetExpanded(_, set_expanded)
			if expanded == set_expanded then return end

			if sam.isbool(set_expanded) then
				expanded = set_expanded
			else
				expanded = not expanded
			end

			category.RefreshHeight()

			if expanded then
				self:OnCategoryExpanded(category)
			end

			self:InvalidateLayout(true)
		end
		header.DoClick = category.SetExpanded

		category:SetTall(header:GetTall())
		categories[name] = category

		return category
	end

	function self:add_item(name, category_name)
		local category = get_category(category_name)

		local item = category:Add("DButton")
		item:Dock(TOP)
		item:DockMargin(0, 0, 0, 3)
		item:SetFont(ITEMS_FONT)
		item:SetText(name)
		item:SizeToContentsY(SUI.Scale(3 * 2))
		item.name = name
		item.parent = self
		item.category = category

		local cur_col
		local cur_col_text = Color(GetColor("collapse_category_item_text"):Unpack())
		function item:Paint(w, h)
			if self.selected then
				cur_col = GetColor("collapse_category_item_active")
				cur_col_text = GetColor("collapse_category_item_text_active")
			elseif self.Hovered then
				cur_col = GetColor("collapse_category_item_hover")
				cur_col_text = GetColor("collapse_category_item_text_hover")
			else
				cur_col = GetColor("collapse_category_item")
				cur_col_text = GetColor("collapse_category_item_text")
			end

			RoundedBox(self, "Background", 4, 0, 0, w, h, cur_col)
			TextColor(self, cur_col_text)
		end

		item.DoClick = item_DoClick
		item.OnRemove = item_OnRemove

		table.insert(items, item)

		return item
	end
end

function Panel:OnCategoryExpanded(category)
end

function Panel:select_item(item)
	if self.selected_item ~= item then
		if IsValid(self.selected_item) then
			self.selected_item.selected = false
		end
		item.selected = true
		self.selected_item = item
		self:item_selected(item)
	end
end

function Panel:item_selected()
end

function Panel:Search(text, names)
	local items = self.items
	self.searching = true
	for i = 1, #items do
		local item = items[i]
		local category = item.category
		category:SetExpanded(true)

		if not names then
			if item.name:find(text, nil, true) then
				item:SetVisible(true)
			else
				item:SetVisible(false)
			end
		else
			local found = false
			for _, name in ipairs(item.names) do
				if name:find(text, nil, true) then
					found = true
					item:SetVisible(true)
				end
			end
			if not found then
				item:SetVisible(false)
			end
		end

		if text == "" then
			category:SetExpanded(false)
		end

		category:RefreshHeight()
		category:InvalidateLayout(true)
	end
	self.searching = false
end

sui.register("CollapseCategory", Panel, NAME .. ".ScrollPanel")
--addons/sui/lua/sui/vgui/sui_zmenu.lua:
return gluapack()()
--addons/sam-159/lua/sam/modules/murder.lua:
if SAM_LOADED then return end

local add = not GAMEMODE and hook.Add or function(_, _, fn)
	fn()
end

-- Thanks to https://github.com/boxama/addons/blob/master/addons/ULX_Murder/lua/ulx/modules/sh/murder.lua
add("PostGamemodeLoaded", "SAM.Murder", function()
	if GAMEMODE.Author ~= "MechanicalMind" then return end
	if not isstring(GAMEMODE.Version) or GAMEMODE.Version < "28" then return end

	local sam, command = sam, sam.command

	command.set_category("Murder")

	local autoslain_players = {}

	command.new("slaynr")
		:SetPermission("slaynr", "admin")

		:AddArg("player")
		:AddArg("number", {hint = "rounds", optional = true, default = 1, min = 1, max = 100, round = true})

		:Help("Slays the target(s) at the beggining of the next round.")

		:OnExecute(function(ply, targets, rounds)
			for i = 1, #targets do
				local v = targets[i]
				v.MurdererChance = 0

				if not v:IsBot() then
					autoslain_players[v:AccountID()] = rounds
				end
			end

			sam.player.send_message(nil, "{A} set {T} to be autoslain for {V} round(s)", {
				A = ply, T = targets, V = rounds
			})
		end)
	:End()

	command.new("unslaynr")
		:SetPermission("unslaynr", "admin")

		:AddArg("player")

		:Help("Remove target(s) autoslays.")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				local v = targets[i]
				v.MurdererChance = 1

				if not v:IsBot() then
					autoslain_players[v:AccountID()] = nil
				end
			end

			sam.player.send_message(nil, "Removed all autoslays for {T} ", {
				A = ply, T = targets
			})
		end)
	:End()

	hook.Add("OnStartRound", "SAM.Murder", function()
		timer.Simple(3, function()
			local players = team.GetPlayers(2)
			local targets = {admin = sam.console}
			for i = 1, #players do
				local v = players[i]
				if not v:IsBot() then continue end

				local slays = autoslain_players[v:AccountID()]
				if not slays then continue end

				v:Kill()

				slays = slays - 1

				targets[1] = v
				sam.player.send_message(nil, "{A} autoslayed {T}, autoslays left: {V}.", {
					A = sam.console, T = targets, V = slays
				})

				autoslain_players[v:AccountID()] = slays > 0 and slays or nil
			end
		end)
	end)

	hook.Add("PlayerInitialSpawn", "SAM.Murder", function(ply)
		if autoslain_players[ply:AccountID()] then
			ply.MurdererChance = 0
		end
	end)

	command.new("respawn")
		:SetPermission("respawn", "admin")

		:AddArg("player", {single_target = true})

		:Help("Respawn a target.")

		:OnExecute(function(ply, targets)
			local target = targets[1]

			if target:Team() ~= 2 then
				return ply:sam_add_text("You cannot respawn a spectator!")
			end

			target:Spectate(OBS_MODE_NONE)
			target:Spawn()

			sam.player.send_message(nil, "respawn", {
				A = ply, T = targets
			})
		end)
	:End()

	local get_admins = function()
		local admins = {}

		local players = player.GetHumans()
		for i = 1, #players do
			local v = players[i]
			if v:IsAdmin() then
				table.insert(admins, v)
			end
		end

		return admins
	end

	command.new("givemagnum")
		:SetPermission("givemagnum", "superadmin")

		:AddArg("player", {single_target = true, optional = true})

		:Help("Give the target a magnum.")

		:OnExecute(function(ply, targets)
			local target = targets[1]

			if target:Team() ~= 2 then
				return ply:sam_add_text("You cannot give spectator a magnum!")
			end

			target:Give("weapon_mu_magnum")

			sam.player.send_message(get_admins(), "{A} gave {T} a {V}", {
				A = ply, T = targets, V = "magnum"
			})
		end)
	:End()

	command.new("giveknife")
		:SetPermission("giveknife", "superadmin")

		:AddArg("player", {single_target = true, optional = true})

		:Help("Give the target a knife.")

		:OnExecute(function(ply, targets)
			local target = targets[1]

			if target:Team() ~= 2 then
				return ply:sam_add_text("You cannot give spectator a knife!")
			end

			target:Give("weapon_mu_knife")

			sam.player.send_message(get_admins(), "{A} gave {T} a {V}", {
				A = ply, T = targets, V = "knife"
			})
		end)
	:End()

	command.new("forcemurderer")
		:SetPermission("forcemurderer", "admin")

		:AddArg("player", {single_target = true, optional = true})

		:Help("Force the target to me a murderer next round.")

		:OnExecute(function(ply, targets)
			GAMEMODE.ForceNextMurderer = targets[1]

			sam.player.send_message(get_admins(), "{A} set {T} to be the Murderer next round!", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("getmurderers")
		:SetPermission("getmurderers", "admin")

		:Help("Print all murderers in chat.")

		:OnExecute(function(ply)
			local murderers = {admin = ply}

			local players = team.GetPlayers(2)
			for i = 1, #players do
				local v = players[i]
				if v:GetMurderer() then
					table.insert(murderers, v)
				end
			end

			sam.player.send_message(ply, "Murderers are: {T}", {
				T = murderers
			})
		end)
	:End()
end)
--addons/spzones/lua/sam/modules/spzones.lua:
return gluapack()()
--addons/sui/lua/sui/libs/gif_loader.lua:
local byte = string.byte
local sub = string.sub
local lshift = bit.lshift
local rshift = bit.rshift
local bor = bit.bor
local band = bit.band

local GIFDecoder = {}
local GIFDecoderMethods = {}
local GIFDecoder_meta = {__index = GIFDecoderMethods}

function GIFDecoder.new(buf)
	local buf_n = #buf
	local this = setmetatable({
		p = 1,
		buf = buf
	}, GIFDecoder_meta)

	local version = this:read(6)
	assert(version == "GIF89a" or version == "GIF87a", "wrong file format")

	this.width = this:word()
	this.height = this:word()

	local pf0 = this:byte()
	local global_palette_flag = rshift(pf0, 7)
	local num_global_colors_pow2 = band(pf0, 0x7)
	local num_global_colors = lshift(1, num_global_colors_pow2 + 1)
	this:skip(2)

	local global_palette_offset = nil
	local global_palette_size = nil

	if global_palette_flag > 0 then
		global_palette_offset = this.p
		this.global_palette_offset = global_palette_offset
		global_palette_size = num_global_colors
		this:skip(num_global_colors * 3)
	end

	local no_eof = true

	local frames = {}

	local delay = 0
	local transparent_index = nil
	local disposal = 1

	while no_eof and this.p <= buf_n do
		local b = this:byte()
		if b == 0x3b then
			no_eof = false
		elseif b == 0x2c then
			local x, y, w, h = this:word(), this:word(), this:word(), this:word()
			local pf2 = this:byte()
			local local_palette_flag = rshift(pf2, 7)
			local interlace_flag = band(rshift(pf2, 6), 1)
			local num_local_colors_pow2 = band(pf2, 0x7)
			local num_local_colors = lshift(1, num_local_colors_pow2 + 1)
			local palette_offset = global_palette_offset
			local palette_size = global_palette_size
			local has_local_palette = false
			if local_palette_flag ~= 0 then
				has_local_palette = true
				palette_offset = this.p
				palette_size = num_local_colors
				this:skip(num_local_colors * 3)
			end

			local data_offset = this.p

			this:skip(1)
			this:skip_eob()

			table.insert(frames, {
				x = x,
				y = y,
				width = w,
				height = h,
				has_local_palette = has_local_palette,
				palette_offset = palette_offset,
				palette_size = palette_size,
				data_offset = data_offset,
				data_length = this.p - data_offset,
				transparent_index = transparent_index,
				interlaced = interlace_flag > 0,
				delay = delay,
				disposal = disposal
			})
		elseif b == 0x21 then
			local b2 = this:byte()
			if b2 == 0xf9 then
				local len, flags = this:bytes(2)
				delay = this:word()
				local transparent, terminator = this:bytes(2)

				assert(len == 4 and terminator == 0, "Invalid graphics extension block.")

				if flags % 2 == 1 then
					transparent_index = transparent
				else
					transparent_index = nil
				end

				disposal = math.floor(flags / 4) % 8
			elseif b2 == 0xff then
				this:read(this:byte())
				this:skip_eob()
			else
				this:skip_eob()
			end
		end
	end

	this.frames = frames

	return this
end

function GIFDecoderMethods:skip(offset)
	self.p = self.p + offset
end

-- skip to end of block
function GIFDecoderMethods:skip_eob()
	repeat
		local size = self:byte()
		self:skip(size)
	until size == 0
end

function GIFDecoderMethods:byte()
	local b = byte(self.buf, self.p)
	self:skip(1)
	return b
end

function GIFDecoderMethods:bytes(len)
	local _p = self.p
	self:skip(len)
	return byte(self.buf, _p, len + _p - 1)
end

function GIFDecoderMethods:read(len)
	local _p = self.p
	self:skip(len)
	return sub(self.buf, _p, len + _p - 1)
end

function GIFDecoderMethods:word()
	return bor(self:byte(), lshift(self:byte(), 8))
end

local GifReaderLZWOutputIndexStream = function(this, output, output_length)
	local min_code_size = this:byte()
	local clear_code = lshift(1, min_code_size)
	local eoi_code = clear_code + 1
	local next_code = eoi_code + 1
	local cur_code_size = min_code_size + 1

	local code_mask = lshift(1, cur_code_size) - 1
	local cur_shift = 0
	local cur = 0
	local op = 0

	local subblock_size = this:byte()

	local code_table = {}

	local prev_code = nil

	while true do
		while cur_shift < 16 do
			if subblock_size == 0 then break end

			cur = bor(cur, lshift(this:byte(), cur_shift))
			cur_shift = cur_shift + 8

			if subblock_size == 1 then
				subblock_size = this:byte()
			else
				subblock_size = subblock_size - 1
			end
		end

		if cur_shift < cur_code_size then break end

		local code = band(cur, code_mask)
		cur = rshift(cur, cur_code_size)
		cur_shift = cur_shift - cur_code_size

		if code == clear_code then
			next_code = eoi_code + 1
			cur_code_size = min_code_size + 1
			code_mask = lshift(1, cur_code_size) - 1

			prev_code = null
			continue
		elseif code == eoi_code then
			break
		end

		local chase_code = code < next_code and code or prev_code
		local chase_length = 0
		local chase = chase_code
		while chase > clear_code do
			chase = rshift(code_table[chase], 8)
			chase_length = chase_length + 1
		end

		local k = chase
		local op_end = op + chase_length + (chase_code ~= code and 1 or 0)
		if op_end > output_length then
			Error("Warning, gif stream longer than expected.")
			return
		end

		output[op] = k; op = op + 1
		op = op + chase_length

		local b = op

		if chase_code ~= code then
			output[op] = k; op = op + 1
		end
		chase = chase_code

		while chase_length > 0 do
			chase_length = chase_length - 1
			chase = code_table[chase]
			b = b - 1
			output[b] = band(chase, 0xff)

			chase = rshift(chase, 8)
		end

		if prev_code ~= nil and next_code < 4096 then
			code_table[next_code] = bor(lshift(prev_code, 8), k)
			next_code = next_code + 1

			if next_code >= code_mask + 1 and cur_code_size < 12 then
				cur_code_size = cur_code_size + 1
				code_mask = bor(lshift(code_mask, 1), 1)
			end
		end

		prev_code = code
	end

	if op ~= output_length then
		Error("Warning, gif stream shorter than expected.")
	end

	return output
end

function GIFDecoderMethods:decode_and_blit_frame_RGBA(frame_num, pixels)
	local frame = self.frames[frame_num]
	local num_pixels = frame.width * frame.height
	local index_stream = {}

	self.p = frame.data_offset
	GifReaderLZWOutputIndexStream(self, index_stream, num_pixels)
	local palette_offset = frame.palette_offset

	local trans = frame.transparent_index
	if trans == nil then
		trans = 256
	end

	local width = self.width
	local framewidth = frame.width
	local framestride = width - framewidth
	local xleft = framewidth

	local opbeg = (frame.y * width + frame.x) * 4

	local opend = ((frame.y + frame.height) * width + frame.x) * 4
	local op = opbeg
	local scanstride = framestride * 4

	if frame.interlaced == true then
		scanstride = scanstride + (width * 4 * 7)
	end

	local interlaceskip = 8

	local i = 0
	local buf = self.buf
	while i < num_pixels do
		local index = index_stream[i]

		if xleft == 0 then
			op = op + scanstride
			xleft = framewidth

			if op >= opend then
				scanstride =
					framestride * 4 + width * 4 * (interlaceskip - 1)

				op =
					opbeg +
					(framewidth + framestride) * lshift(interlaceskip, 1)
				interlaceskip = rshift(interlaceskip, 1)
			end
		end

		if index ~= trans then
			index = palette_offset + index * 3
			pixels[op + 0] = byte(buf, index)
			pixels[op + 1] = byte(buf, index + 1)
			pixels[op + 2] = byte(buf, index + 2)
			pixels[op + 3] = 255
		end

		op = op + 4

		xleft = xleft - 1
		i = i + 1
	end
end

function GIFDecoderMethods:clear_frame(frame_num, pixels)
	local frame = self.frames[frame_num]

	self.p = frame.data_offset

	local width = self.width
	local framewidth = frame.width
	local framestride = width - framewidth
	local xleft = framewidth

	local opbeg = (frame.y * width + frame.x) * 4

	local opend = ((frame.y + frame.height) * width + frame.x) * 4
	local op = opbeg
	local scanstride = framestride * 4

	if frame.interlaced == true then
		scanstride = scanstride + (width * 4 * 7)
	end

	local interlaceskip = 8

	local i = 0
	local num_pixels = frame.width * frame.height
	while i < num_pixels do
		if xleft == 0 then
			op = op + scanstride
			xleft = framewidth

			if op >= opend then
				scanstride =
					framestride * 4 + width * 4 * (interlaceskip - 1)

				op =
					opbeg +
					(framewidth + framestride) * lshift(interlaceskip, 1)
				interlaceskip = rshift(interlaceskip, 1)
			end
		end

		pixels[op + 0] = 0
		pixels[op + 1] = 0
		pixels[op + 2] = 0
		pixels[op + 3] = 0
		op = op + 4

		xleft = xleft - 1
		i = i + 1
	end
end

function GIFDecoderMethods:get_frames()
	local num_pixels = self.width * self.height * 4 + 4
	local frames = {}
	local numFrames = #self.frames
	local last_frame
	local restore_from
	for i = 1, numFrames do
		local frame = self.frames[i]

		local data = {}

		if last_frame then
			local _data = last_frame.data
			for k = 0, num_pixels do
				data[k] = _data[k]
			end
		end

		if i > 1 then
			local last_disposal = last_frame.disposal
			if last_disposal == 3 then
				if restore_from then
					for k = 0, num_pixels do
						data[k] = restore_from[k]
					end
				else
					self:clear_frame(i - 1, data)
				end
			end

			if last_disposal == 2 then
				self:clear_frame(i - 1, data)
			end
		end

		self:decode_and_blit_frame_RGBA(i, data)

		local delay = frame.delay
		if delay < 2 then
			delay = 10
		end

		local disposal = frame.disposal
		last_frame = {
			data = data,
			delay = delay,
			disposal = disposal
		}
		frames[i] = last_frame

		if disposal ~= 3 then
			restore_from = data
		end
	end

	return frames
end

return GIFDecoder.new
--addons/sui/lua/sui/vgui/sui_number_slider.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local NUMBER_SLIDER_FONT = SUI.CreateFont("NumberSlider", "Roboto Regular", 14)

local PANEL = {}

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()

	local slider = vgui.Create(NAME .. ".Slider", self, "NumberSlider")
	slider:Dock(FILL)

	self.slider = slider

	local label = self:Add(NAME .. ".Label")
	label:Dock(RIGHT)
	label:DockMargin(3, 0, 0, 0)
	label:SetFont(NUMBER_SLIDER_FONT)
	self.label = label

	function label:Think()
		self:SetText(slider:GetValue())

		self:SizeToContents()
	end

	self:SetSize(100, 12)
	self:InvalidateLayout(true)
end

sui.register("NumberSlider", PANEL, "Panel")

--addons/sui/lua/sui/vgui/sui_slider.lua:
return gluapack()()
--addons/sui/lua/sui/vgui/sui_toggle_button.lua:
local Lerp = Lerp
local FrameTime = FrameTime

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local Panel = {}

sui.scaling_functions(Panel)

function Panel:Init()
	self:ScaleInit()

	local rounded_box = {}
	local switch_circle = {}
	function self:Paint(w, h)
		local is_checked = self:GetChecked()

		local _h = SUI.Scale(14)
		TDLib.RoundedBox(rounded_box, _h, 0, h / 2 - _h / 2, w, _h, is_checked and SUI.GetColor("toggle_button_active") or SUI.GetColor("toggle_button"))

		local size = h - 2
		do
			local pos = is_checked and (w - (size / 2)) or (h / 2 - 1)
			if self.pos then
				self.pos = Lerp(FrameTime() * 12, self.pos, pos)
			else
				self.pos = pos
			end
		end

		TDLib.DrawCircle(switch_circle, self.pos, h / 2, size / 2, is_checked and SUI.GetColor("toggle_button_switch_active") or SUI.GetColor("toggle_button_switch"))
	end

	self:SetSize(34, 20)
end

sui.register("ToggleButton", Panel, "DCheckBox")
--addons/scb-29/lua/scb/sh_chatbox.lua:
if SCB_LOADED then return end

local scb = scb

local PLAYER = FindMetaTable("Player")
function PLAYER:IsTyping()
	return self:GetNWBool("SCB.IsTyping", false)
end

function PLAYER:SCB_GetTag()
	local tags = scb.tags
	return tags[self:SteamID()] or tags[self:SteamID64()] or tags[self:GetUserGroup()] or false
end

local permissions = scb.config.permissions
function scb.has_permission(ply, permission)
	if not IsValid(ply) then return true end

	permission = permissions[permission]
	return permission[1] or permission[ply:GetUserGroup()] or permission[ply:SteamID()] or permission[ply:SteamID64()]
end
--addons/scb-29/lua/scb/cl_chatbox.lua:
return gluapack()()
--addons/thirdperson/lua/autorun/sh_thirdperson_init.lua:
--[[
!ThirdPerson
By Imperial Knight.
Copyright © Imperial Knight 2019: Do not redistribute.
(76561198347218024)

SHARED FILE
]]--

AddCSLuaFile();

THIRDPERSON               = THIRDPERSON or {};
THIRDPERSON.default       = THIRDPERSON.default or {};
THIRDPERSON.permissions   = THIRDPERSON.permissions or {};
THIRDPERSON.configuration = THIRDPERSON.configuration or {};
THIRDPERSON.client        = THIRDPERSON.client or {};
THIRDPERSON.clients       = THIRDPERSON.clients or {}; -- Serverside only
THIRDPERSON.access        = THIRDPERSON.access or {};
THIRDPERSON.dataTable     = THIRDPERSON.dataTable or {};

THIRDPERSON.dataTable["evolve"]      = false;
THIRDPERSON.dataTable["serverguard"] = false;

THIRDPERSON.evolve        = THIRDPERSON.evolve or {};
THIRDPERSON.serverguard   = THIRDPERSON.serverguard or {};

local include_sv = ( SERVER ) and include or function() end
local include_cl = ( SERVER ) and AddCSLuaFile or include
local include_sh = function( path )
    include_sv( path );
    include_cl( path );
end

-- Shared Includes --
include_sh( "thirdperson/sh_thirdperson_config.lua" );
include_sh( "thirdperson/sh_thirdperson.lua" );
-- Serverside Includes --
include_sv( "thirdperson/server/sv_thirdperson.lua" );
include_sv( "thirdperson/server/sv_resource.lua" );

-- Configuration Defines --
    function THIRDPERSON.registerConfigValue( permission, configuration, type )
        THIRDPERSON.permissions[ permission ] = configuration;
        THIRDPERSON.configuration[ permission ] = type;
    end

    THIRDPERSON.registerConfigValue( "thirdperson_view", "ThirdPerson", "bool" );
    THIRDPERSON.registerConfigValue( "thirdperson_bind", "Bind", "string" );
    THIRDPERSON.registerConfigValue( "thirdperson_preventwallcollisions", "PreventWallCollisions", "bool" );
    THIRDPERSON.registerConfigValue( "thirdperson_scoping", "Scoping", "bool" );
    THIRDPERSON.registerConfigValue( "thirdperson_entityview", "EntityView", "bool" );
    THIRDPERSON.registerConfigValue( "thirdperson_bulletcorrection", "BulletCorrections", "bool" );
    THIRDPERSON.registerConfigValue( "thirdperson_verticalview", "VerticalView", "number" );
    THIRDPERSON.registerConfigValue( "thirdperson_horizontalview", "HorizontalView", "number" );
    THIRDPERSON.registerConfigValue( "thirdperson_distance", "Distance", "number" );
    THIRDPERSON.registerConfigValue( "thirdperson_crosshair", "Crosshair", "string" );

    -- Setup Client Convars --
        -- General Convars--
        CreateClientConVar( "thirdperson_view", THIRDPERSON.boolToNumber( THIRDPERSON.default.ThirdPerson ), true, false, "Whether to enable third-person view or not." );
        CreateClientConVar( "thirdperson_bind", THIRDPERSON.default.Bind, true, false, "A key toggle for !ThirdPerson mode." );
        CreateClientConVar( "thirdperson_scoping", THIRDPERSON.boolToNumber( THIRDPERSON.default.Scoping ), true, false, "Whether or not scoping should temporarily switch to first-person." );
        CreateClientConVar( "thirdperson_entityview", THIRDPERSON.boolToNumber( THIRDPERSON.default.EntityView ), true, false, "Whether or not viewing certain entities should temporarily switch to first-person." );
        CreateClientConVar( "thirdperson_preventwallcollisions", THIRDPERSON.boolToNumber( THIRDPERSON.default.PreventWallCollisions ), true, false, "Whether or not to prevent wall collisions in third-person." );
        CreateClientConVar( "thirdperson_bulletcorrection", THIRDPERSON.boolToNumber( THIRDPERSON.default.BulletCorrections ), true, false, "Whether or not to correct where bullets land in third-person. Disable this if it interferes with a custom crosshair or HUD." );
        CreateClientConVar( "thirdperson_bulletcorrection_save", THIRDPERSON.boolToNumber( THIRDPERSON.default.BulletCorrections ), true, false, "Save of client config value (thirdperson_bulletcorrection)." );
        -- View Angle Convars --
        CreateClientConVar( "thirdperson_distance", THIRDPERSON.default.Distance, true, false, "The view distance in third-person." );
        CreateClientConVar( "thirdperson_verticalview", THIRDPERSON.default.VerticalView, true, false, "The vertical view angle in third-person." );
        CreateClientConVar( "thirdperson_horizontalview", THIRDPERSON.default.HorizontalView, true, false, "The horizontal view angle in third-person." );
        -- Crosshair Convars --
        CreateClientConVar( "thirdperson_crosshair", THIRDPERSON.default.Crosshair, true, false, "Whether or not to use the third-person crosshair and if so, which to use." );

        local crosshairColors = string.Explode( ",", string.gsub( THIRDPERSON.default.CrosshairColor, "%s+", "" ) );
        
        CreateClientConVar( "thirdperson_crosshair_color_r", crosshairColors[1], true, false, "Color (R) of the third-person crosshair." );
        CreateClientConVar( "thirdperson_crosshair_color_g", crosshairColors[2], true, false, "Color (G) of the third-person crosshair." );
        CreateClientConVar( "thirdperson_crosshair_color_b", crosshairColors[3], true, false, "Color (B) of the third-person crosshair." );
        CreateClientConVar( "thirdperson_crosshair_color_a", crosshairColors[4], true, false, "Color (A) of the third-person crosshair." );
    -- --
-- --

-- Clientside Includes --
include_cl( "thirdperson/client/ferma/cl_ferma.lua" );
include_cl( "thirdperson/client/ferma/cl_ferma_fpanel.lua" );
include_cl( "thirdperson/client/ferma/cl_ferma_fcheckboxlabel.lua" );
include_cl( "thirdperson/client/ferma/cl_ferma_flabel.lua" );
include_cl( "thirdperson/client/ferma/cl_ferma_fbutton.lua" );
include_cl( "thirdperson/client/ferma/cl_ferma_fpointmapper.lua" );
include_cl( "thirdperson/client/ferma/cl_ferma_fslider.lua" );
include_cl( "thirdperson/client/ferma/cl_ferma_fcolormixer.lua" );
include_cl( "thirdperson/client/ferma/cl_ferma_ftitlebar.lua" );
include_cl( "thirdperson/client/ferma/cl_ferma_fbinder.lua" );

include_cl( "thirdperson/client/cl_thirdperson.lua" );
include_cl( "thirdperson/client/cl_thirdperson_hud.lua" );
include_cl( "thirdperson/client/cl_thirdperson_menu.lua" );
include_cl( "thirdperson/client/cl_thirdperson_contextmenu.lua" );
--addons/thirdperson/lua/thirdperson/client/ferma/cl_ferma_fslider.lua:
return gluapack()()
--lua/slib/sh_util.lua:
return gluapack()()
--lua/slib/vgui/cl_sframe.lua:
return gluapack()()
--lua/slib/vgui/cl_sdropdown.lua:
return gluapack()()
--addons/eprotect_1.5.24/lua/e_protect/sh_baseconfig.lua:
return gluapack()()
--addons/eprotect_1.5.24/lua/e_protect/client/cl_eprotect.lua:
eProtect = eProtect or {}
eProtect.data = eProtect.data or {}

local margin = slib.getTheme("margin")
local maincolor_7, maincolor_10, hovercolor, linecol, textcolor_min50 = slib.getTheme("maincolor", 7), slib.getTheme("maincolor", 10), slib.getTheme("hovercolor"), Color(0,0,0,160), slib.getTheme("textcolor", -50)
local arrow_ico = Material("slib/down-arrow.png", "smooth noclamp")

local function networkData(data, ...)
    local args = {...}

    net.Start("eP:Handeler")
    net.WriteBit(1)
    net.WriteUInt(1, 2)
    net.WriteUInt(#args, 3)
    
    for k,v in pairs(args) do
        net.WriteString(v)
    end

    local statement = slib.getStatement(data)

    if statement == "bool" then
        net.WriteUInt(1, 2)
        net.WriteBool(data)
    elseif statement == "int" then
        net.WriteUInt(2, 2)
        net.WriteInt(data, 32)
    elseif statement == "table" or statement == "color" then
        net.WriteUInt(3, 2)

        data = eProtect.encodeSteamID64(table.Copy(data))
        data = util.Compress(util.TableToJSON(data))

        net.WriteUInt(#data, 32)
        net.WriteData(data, #data)
    end

    net.SendToServer()
end

local function openScreenshot(ply, id)
    if !IsValid(ply) then return end
    local nick = ply:Nick()

    http.Fetch(eProtect.config["scURL"].."?id="..id, function(result)
        local sc_frame = vgui.Create("SFrame")
        sc_frame:SetSize(slib.getScaledSize(960, "x"), slib.getScaledSize(540 + 25, "y"))
        :setTitle(slib.getLang("eprotect", eProtect.config["language"], "sc-preview")..nick)
        :MakePopup()
        :addCloseButton()
        :Center()
        :SetBG(true, true, nil, true)
        :setBlur(true)
    
        local display = vgui.Create("HTML", sc_frame.frame)
        display:Dock(FILL)
        display:SetHTML([[<img src="data:image/jpeg;base64,]] ..result.. [[" style="height:]]..(sc_frame.frame:GetTall())..[[px;width:]]..(sc_frame.frame:GetWide())..[[px;position:fixed;top:0px;left:0px">]])
    end)
end

local function sid64format(sid64)
    return slib.findName(sid64).." ("..sid64..")"
end

local function showAlts(ply, json)
    local font, sid_font = slib.createFont("Roboto", 16), slib.createFont("Roboto", 12)
    local alts = util.JSONToTable(json)

    local show_alts = vgui.Create("SFrame")
    show_alts:SetSize(slib.getScaledSize(470, "x"), slib.getScaledSize(360, "y"))
    :setTitle(slib.getLang("eprotect", eProtect.config["language"], "show-alts", ply))
    :MakePopup()
    :addCloseButton()
    :Center()
    :SetBG(true, true, nil, true)
    :setBlur(true)

    local alts_scroll = vgui.Create("SScrollPanel", show_alts.frame)
    alts_scroll:Dock(FILL)
    alts_scroll:DockMargin(0,margin,0,0)

    for k,v in ipairs(alts) do
        local alt = vgui.Create("EditablePanel", alts_scroll)
        alt:Dock(TOP)
        alt:DockMargin(margin,0,margin,margin)
        alt:SetTall(slib.getScaledSize(26, "y"))
        alt.Paint = function(s,w,h)
            surface.SetDrawColor(maincolor_7)
            surface.DrawRect(0,0,w,h)

            surface.SetFont(font)

            local name = slib.findName(v)
            local txt_w = surface.GetTextSize(name or "")
            
            draw.SimpleText(name, font, h + margin * 2, h * .5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
            draw.SimpleText("[ "..v.." ]", sid_font, (h + margin * 3) + txt_w, h * .5, textcolor_min50, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end

        local avatar = vgui.Create("EditablePanel", alt)
        avatar:SetSize(alt:GetTall(), alt:GetTall())
        avatar.Paint = function(s,w,h)
            surface.SetDrawColor(color_white)
            surface.SetMaterial(slib.findAvatar(v, true))
            surface.DrawTexturedRect(0,0,w,h)
        end

        local open_profile_h = slib.getScaledSize(22, "y")
        local gap_top_bottom = (alt:GetTall() - open_profile_h) / 2

        local open_profile = vgui.Create("SButton", alt)
        open_profile:setTitle(slib.getLang("eprotect", eProtect.config["language"], "open-profile"))
        open_profile:SetTall(open_profile_h)
        open_profile:Dock(RIGHT)
        open_profile:DockMargin(0,gap_top_bottom,margin,gap_top_bottom)

        open_profile.DoClick = function()
            gui.OpenURL("http://steamcommunity.com/profiles/"..v)
        end
    end
end

local function fillCleanData(index, tbl)
    local files, directories = file.Find(index, "DATA")

    if files then
        for k,v in pairs(files) do
            tbl[v] = true
        end
    end
	
	if index == "*" then index = "" end
	local attribute = !index and "/" or ""

    if directories then
        for k,v in pairs(directories) do
            tbl[v] = tbl[v] or {}

           fillCleanData(index..attribute..v.."/*", tbl[v])
        end
    end
end

local createPaginator = function(parent)
    local font = slib.createFont("Roboto", 16)
    local paginator_tall = slib.getScaledSize(25, "y")
    local paginator = vgui.Create("EditablePanel", parent)
    paginator:Dock(BOTTOM)
    paginator:DockPadding(margin,margin,margin,margin)
    paginator:SetTall(paginator_tall)
    paginator.page = 1
    paginator.maxpage = 5

    paginator.Paint = function(s,w,h)
        surface.SetDrawColor(linecol)
        surface.DrawRect(0,0,w,1)

        draw.SimpleText(slib.getLang("eprotect", eProtect.config["language"], "page_of_page", s.page, s.maxpage), font, w * .5, h * .5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    surface.SetFont(font)
    local prev_w = select(1, surface.GetTextSize(slib.getLang("eprotect", eProtect.config["language"], "previous")))
    local next_w = select(1, surface.GetTextSize(slib.getLang("eprotect", eProtect.config["language"], "next")))

    local left = vgui.Create("SButton", paginator)
    :Dock(LEFT)
    :SetWide(paginator_tall + prev_w)

    local ico_size = paginator:GetTall() * .5

    left.Paint = function(s,w,h)
        surface.SetDrawColor(maincolor_7)
        surface.DrawRect(0,0,w,h)

        local hover = s:IsHovered()
        local curCol = slib.lerpColor(s, hover and hovercolor or color_white)

        s.move = s.move or 1
        s.move = math.Clamp(hover and s.move + .05 or s.move - .05, 0, 2)

        surface.SetDrawColor(curCol)
        surface.SetMaterial(arrow_ico)
        surface.DrawTexturedRectRotated(h * .5 - s.move, h * .5,ico_size ,ico_size, -90)

        draw.SimpleText(slib.getLang("eprotect", eProtect.config["language"], "previous"), font, w - margin, h * .5, curCol, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
    end

    left.DoClick = function()
        if paginator.page <= 1 then return end
        local nextpage = paginator.page - 1

        paginator.onPageChanged(nextpage)
    end

    local right = vgui.Create("SButton", paginator)
    :Dock(RIGHT)
    :SetWide(paginator_tall + next_w)

    right.Paint = function(s,w,h)
        surface.SetDrawColor(maincolor_7)
        surface.DrawRect(0,0,w,h)

        local hover = s:IsHovered()
        local curCol = slib.lerpColor(s, hover and hovercolor or color_white)

        s.move = s.move or 1
        s.move = math.Clamp(hover and s.move + .05 or s.move - .05, 0, 2)

        surface.SetDrawColor(curCol)
        surface.SetMaterial(arrow_ico)
        surface.DrawTexturedRectRotated(w - (h * .5 - s.move), h * .5,ico_size ,ico_size, 90)

        draw.SimpleText(slib.getLang("eprotect", eProtect.config["language"], "next"), font, margin, h * .5, curCol, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    right.DoClick = function()
        if paginator.page >= paginator.maxpage then return end
        local nextpage = paginator.page + 1

        paginator.onPageChanged(nextpage)
    end

    return paginator
end

local function showID(ply, id)
    id = util.JSONToTable(util.Base64Decode(id))
    if !id or !istable(id) then slib.notify(eProtect.config["prefix"]..slib.getLang("eprotect", eProtect.config["language"], "ply-sent-invalid-data")) return end

    local id_list = vgui.Create("SFrame")
    id_list:SetSize(slib.getScaledSize(500, "x"),slib.getScaledSize(330, "y"))
    :Center()
    :MakePopup()
    :addCloseButton()
    :setTitle(slib.getLang("eprotect", eProtect.config["language"], "id-info")..ply:Nick(), slib.createFont("Roboto", 17))
    :setBlur(true)

    local id_details = vgui.Create("SListView", id_list.frame)
    id_details:Dock(FILL)
    :addColumns(slib.getLang("eprotect", eProtect.config["language"], "player"), slib.getLang("eprotect", eProtect.config["language"], "date"))
    
    for i, z in pairs(id) do
        local sid64 = util.SteamIDTo64(i)

        local _, line = id_details:addLine(function() return sid64format(sid64) end, {os.date("%H:%M:%S - %d/%m/%Y", z), z})
        line.DoClick = function()
            gui.OpenURL("http://steamcommunity.com/profiles/"..sid64)
        end

        line:SetZPos(z)
    end
end

local function showCorrelation(ply, data)
    data = util.JSONToTable(util.Base64Decode(data))
    if !data or !istable(data) then return end

    local correlation_list = vgui.Create("SFrame")
    correlation_list:SetSize(slib.getScaledSize(450, "x"),slib.getScaledSize(330, "y"))
    :Center()
    :MakePopup()
    :addCloseButton()
    :setTitle(slib.getLang("eprotect", eProtect.config["language"], "ip-correlation")..ply:Nick(), slib.createFont("Roboto", 17))
    :setBlur(true)

    local correlation_details = vgui.Create("SListView", correlation_list.frame)
    correlation_details:Dock(FILL)
    :addColumns(slib.getLang("eprotect", eProtect.config["language"], "player"), slib.getLang("eprotect", eProtect.config["language"], "ip"))

    for k, v in ipairs(data) do  
        if !v.sid64 then continue end
        
        local _, line = correlation_details:addLine(function() return sid64format(v.sid64) end, v.ip)
        line.DoClick = function()
            gui.OpenURL("http://steamcommunity.com/profiles/"..v.sid64)
        end

        line:SetZPos(z)
    end
end

local function showIPs(ply, data)
    data = util.JSONToTable(util.Base64Decode(data))
    if !data or !istable(data) then return end

    local ip_list = vgui.Create("SFrame")
    ip_list:SetSize(slib.getScaledSize(400, "x"),slib.getScaledSize(280, "y"))
    :Center()
    :MakePopup()
    :addCloseButton()
    :setTitle(slib.getLang("eprotect", eProtect.config["language"], "ip-info")..ply:Nick(), slib.createFont("Roboto", 17))
    :setBlur(true)

    local ip_details = vgui.Create("SListView", ip_list.frame)
    ip_details:Dock(FILL)
    :addColumns(slib.getLang("eprotect", eProtect.config["language"], "country-code"), slib.getLang("eprotect", eProtect.config["language"], "ip"), slib.getLang("eprotect", eProtect.config["language"], "date"))

    for k, v in pairs(data) do
        local _, line = ip_details:addLine(v.country, v.ip, {os.date("%H:%M:%S - %d/%m/%Y", v.logged_time), v.logged_time})
        line.DoClick = function()
            gui.OpenURL("https://whatismyipaddress.com/ip/"..v.ip)
        end

        line:SetZPos(v.logged_time)
    end
end

local requestLogData = function(id, page, search)
    net.Start("eP:Handeler")
    net.WriteBit(1)
    net.WriteUInt(0, 2)
    net.WriteUInt(id, 1)
    net.WriteUInt(page, 15)
    net.WriteString(search)
    net.SendToServer()
end

local eprotect_menu

local function openMenu()
    eprotect_menu = vgui.Create("SFrame")
    eprotect_menu:SetSize(slib.getScaledSize(720, "x"),slib.getScaledSize(530, "y"))
    :setTitle("eProtect")
    :Center()
    :addCloseButton()
    :MakePopup()
    :addTab(slib.getLang("eprotect", eProtect.config["language"], "tab-general"), "eprotect/tabs/general.png")

    if !eProtect.config["disabledModules"]["identifier"] then
        eprotect_menu:addTab(slib.getLang("eprotect", eProtect.config["language"], "tab-identifier"), "eprotect/tabs/identifier.png")
    end

    if !eProtect.config["disabledModules"]["detection_log"] then
        eprotect_menu:addTab(slib.getLang("eprotect", eProtect.config["language"], "tab-detectionlog"), "eprotect/tabs/detectionlog.png")
    end

    if !eProtect.config["disabledModules"]["net_limiter"] then
        eprotect_menu:addTab(slib.getLang("eprotect", eProtect.config["language"], "tab-netlimiter"),"eprotect/tabs/netlimit.png")
    end

    if !eProtect.config["disabledModules"]["net_logger"] then
        eprotect_menu:addTab(slib.getLang("eprotect", eProtect.config["language"], "tab-netlogger"), "eprotect/tabs/netlog.png")
    end

    if !eProtect.config["disablehttplogging"] and ((!VC and !XEON and !mLib) or eProtect.config["ignoreDRM"]) then
        eprotect_menu:addTab(slib.getLang("eprotect", eProtect.config["language"], "tab-httplogger"), "eprotect/tabs/httplog.png")
    end

    if !eProtect.config["disabledModules"]["exploit_patcher"] then
        eprotect_menu:addTab(slib.getLang("eprotect", eProtect.config["language"], "tab-exploitpatcher"), "eprotect/tabs/exploitpatcher.png")
    end

    if !eProtect.config["disabledModules"]["exploit_finder"] then
        eprotect_menu:addTab(slib.getLang("eprotect", eProtect.config["language"], "tab-exploitfinder"), "eprotect/tabs/exploitfinder.png")
    end

    if !eProtect.config["disabledModules"]["fake_exploits"] then
        eprotect_menu:addTab(slib.getLang("eprotect", eProtect.config["language"], "tab-fakeexploits"), "eprotect/tabs/fakeexploit.png")
    end

    
    if !eProtect.config["disabledModules"]["data_snooper"] then
        eprotect_menu:addTab(slib.getLang("eprotect", eProtect.config["language"], "tab-datasnooper"), "eprotect/tabs/datasnooper.png")
    end

    eprotect_menu:setActiveTab(slib.getLang("eprotect", eProtect.config["language"], "tab-general"))

    local generalscroller = vgui.Create("SScrollPanel", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-general")])
    generalscroller:Dock(FILL)
    generalscroller:GetCanvas():DockPadding(0,slib.getTheme("margin"),0,slib.getTheme("margin"))

    local player_list = vgui.Create("SListPanel", generalscroller)
    player_list:setTitle(slib.getLang("eprotect", eProtect.config["language"], "player-list"))
    :addSearchbar()
    :SetZPos(-200)
    :addButton(slib.getLang("eprotect", eProtect.config["language"], "disable-networking"), 
    function(s)
        if !s.selected or !IsValid(s.selected) then return end
        local sid = s.selected:SteamID()
        eProtect.data.disabled[sid] = !eProtect.data.disabled[sid]

        net.Start("eP:Handeler")
        net.WriteBit(1)
        net.WriteUInt(2, 2)
        net.WriteUInt(1, 3)
        net.WriteUInt(s.selected:EntIndex(), 14)
        net.WriteBool(eProtect.data.disabled[sid])
        net.SendToServer()
    end,
    function(s, bttn)
        if !s.selected or !IsValid(s.selected) then 
            bttn:setTitle(slib.getLang("eprotect", eProtect.config["language"], "disable-networking"))    
        return end

        if eProtect.data.disabled[s.selected:SteamID()] then 
            bttn:setTitle(slib.getLang("eprotect", eProtect.config["language"], "enable-networking")) 
        else 
            bttn:setTitle(slib.getLang("eprotect", eProtect.config["language"], "disable-networking")) 
        end
    end)
    :addButton(slib.getLang("eprotect", eProtect.config["language"], "capture"), function(s)
        if !s.selected or !IsValid(s.selected) then return end

        net.Start("eP:Handeler")
        net.WriteBit(1)
        net.WriteUInt(2, 2)
        net.WriteUInt(2, 3)
        net.WriteUInt(s.selected:EntIndex(), 14)
        net.WriteUInt(1, 2)
        net.SendToServer()
    end)
    :addButton(slib.getLang("eprotect", eProtect.config["language"], "check-ips"), function(s)
        if !s.selected or !IsValid(s.selected) then return end

        net.Start("eP:Handeler")
        net.WriteBit(1)
        net.WriteUInt(2, 2)
        net.WriteUInt(3, 3)
        net.WriteUInt(s.selected:EntIndex(), 14)
        net.WriteBit(0)
        net.SendToServer()
    end)

    for k,v in ipairs(player.GetAll()) do
        if v:IsBot() then continue end
        player_list:addEntry(v)
    end

    if eProtect.data.general then
        for k,v in pairs(eProtect.data.general) do
            if !eProtect.BaseConfig[k] then continue end
            
            local type = slib.getStatement(eProtect.BaseConfig[k][1])
            local cur_type =  slib.getStatement(v)
            if type ~= cur_type then v = eProtect.BaseConfig[k][1] end
            local option = vgui.Create("SStatement", generalscroller)
            local _, element = option:SetZPos(eProtect.BaseConfig[k][2])
            :addStatement(slib.getLang("eprotect", eProtect.config["language"], k), v)

            if type == "int" then
                element:SetMin(eProtect.BaseConfig[k][3].min)
                element:SetMax(eProtect.BaseConfig[k][3].max)
            elseif type == "table" then
                element.onElementOpen = function(s)
                    s.title = slib.getLang("eprotect", eProtect.config["language"], k)
                    s:SetSize(slib.getScaledSize(850, "x"), slib.getScaledSize(350, "y"))
                    s:Center()
                    s:addEntry()
                    s:addSuggestions(isfunction(eProtect.BaseConfig[k][3]) and eProtect.BaseConfig[k][3]() or {})
                    s:addSearch(s.viewbox, s.viewer)
                    s:addSearch(s.suggestionbox, s.suggestions)
                    
                    s.OnRemove = function()
                        if s.modified then
                            element.onValueChange(s.viewer.tbl)
                        end
                    end
                end
            end

            element.onValueChange = function(value)
                networkData(value, "general", k)
            end

            slib.createTooltip(slib.getLang("eprotect", eProtect.config["language"], k.."-tooltip"), option)
        end
    end

    -- Identifier tab
    if !eProtect.config["disabledModules"]["identifier"] then
        local search_id = vgui.Create("SSearchBar", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-identifier")])
        search_id:DockMargin(0,0,0,0)
        :addIcon()

        search_id.bg = maincolor_10

        local identifier = vgui.Create("SScrollPanel", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-identifier")])
        identifier:Dock(FILL)
        identifier:GetCanvas():DockPadding(0,slib.getTheme("margin"),0,slib.getTheme("margin"))

        search_id.entry.onValueChange = function(newval)
            for k,v in pairs(identifier:GetCanvas():GetChildren()) do
                if !string.find(string.lower(v.name), string.lower(newval)) then
                    v:SetVisible(false)
                else
                    v:SetVisible(true)
                end

                identifier:GetCanvas():InvalidateLayout(true)
            end
        end

        for k,v in ipairs(player.GetAll()) do
            if v:IsBot() then continue end
            local ply = vgui.Create("SPlayerPanel", identifier)
            ply:setPlayer(v)
            :addButton(slib.getLang("eprotect", eProtect.config["language"], "check-ids"), function()
                if !v or !IsValid(v) then return end
                
                net.Start("eP:Handeler")
                net.WriteBit(1)
                net.WriteUInt(2, 2)
                net.WriteUInt(2, 3)
                net.WriteUInt(v:EntIndex(), 14)
                net.WriteUInt(2, 2)
                net.SendToServer()
            end)
            :addButton(slib.getLang("eprotect", eProtect.config["language"], "correlate-ip"), function()
                if !v or !IsValid(v) then return end
                
                net.Start("eP:Handeler")
                net.WriteBit(1)
                net.WriteUInt(2, 2)
                net.WriteUInt(3, 3)
                net.WriteUInt(v:EntIndex(), 14)
                net.WriteBit(1)
                net.SendToServer()
            end)
            :addButton(slib.getLang("eprotect", eProtect.config["language"], "family-share-check"), function()
                if !v or !IsValid(v) then return end
                
                net.Start("eP:Handeler")
                net.WriteBit(1)
                net.WriteUInt(2, 2)
                net.WriteUInt(4, 3)
                net.WriteUInt(v:EntIndex(), 14)
                net.SendToServer()
            end)
        end
    end


    -- Punishment log
    if !eProtect.config["disabledModules"]["detection_log"] then
        local search_punishments = vgui.Create("SSearchBar", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-detectionlog")])
        search_punishments:DockMargin(0,0,0,2)
        :addIcon()

        search_punishments.bg = maincolor_10

        search_punishments.entry.onValueChange = function(newval)
            requestLogData(1, 1, newval)
        end

        local punishment_log = vgui.Create("SListView", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-detectionlog")])
        punishment_log:Dock(FILL)
        :addColumns(slib.getLang("eprotect", eProtect.config["language"], "player"), slib.getLang("eprotect", eProtect.config["language"], "reason"), slib.getLang("eprotect", eProtect.config["language"], "info"), slib.getLang("eprotect", eProtect.config["language"], "type"))

        local typeToLang = {
            [1] = "kicked",
            [2] = "banned",
            [3] = "notified"
        }

        local detections_paginator = createPaginator(eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-detectionlog")])
        detections_paginator.onPageChanged = function(page)
            local val = search_punishments.entry:GetValue()

            requestLogData(1, page, val == search_punishments.entry.placeholder and "" or val)
        end

        detections_paginator.onPageChanged(1)

        punishment_log.paginator = detections_paginator

        punishment_log.rebuild = function()
            for k,v in ipairs(punishment_log:GetCanvas():GetChildren()) do
                if !v.isLine then continue end
                v:Remove()
            end

            local tbl_detections = eProtect.data["requestedDetections"] and eProtect.data["requestedDetections"].result or {}
            
            detections_paginator.page, detections_paginator.maxpage = eProtect.data["requestedDetections"].page, eProtect.data["requestedDetections"].pageCount

            for k,v in ipairs(tbl_detections) do
                local _, line = punishment_log:addLine(v.name, function() return slib.getLang("eprotect", eProtect.config["language"], v.reason) end, v.info, function() return slib.getLang("eprotect", eProtect.config["language"], typeToLang[tonumber(v.type)]) end)
                line.isLine = true

                line.DoClick = function()
                    local dropdown = vgui.Create("SDropDown")
                    dropdown.buttonh = slib.getScaledSize(20, "y")
                    dropdown.buttonfont = slib.createFont("Roboto", 15)
                    dropdown.buttonbg = maincolor_10
                    dropdown.buttoncol = maincolor_min35
                    dropdown:addOption( slib.getLang("eprotect", eProtect.config["language"], "open-profile"))
                    :addOption( slib.getLang("eprotect", eProtect.config["language"], "copy_name"))
                    :addOption( slib.getLang("eprotect", eProtect.config["language"], "copy_steamid"))
                    :addOption( slib.getLang("eprotect", eProtect.config["language"], "copy_steamid64"))
    
                    if v.reason == "alt-detection" and v.additional_info and v.additional_info != "NULL" and v.additional_info != "" then
                        dropdown:addOption( slib.getLang("eprotect", eProtect.config["language"], "show_alts"))
                    end

                    dropdown.onValueChange = function(val)
                        if val ==  slib.getLang("eprotect", eProtect.config["language"], "open-profile") then
                            gui.OpenURL("https://steamcommunity.com/profiles/"..v.sid64)
                        elseif val ==  slib.getLang("eprotect", eProtect.config["language"], "copy_name") then
                            SetClipboardText(v.name)
                            slib.notify(eProtect.config["prefix"]..slib.getLang("eprotect", eProtect.config["language"], "copied_clipboard"))
                        elseif val ==  slib.getLang("eprotect", eProtect.config["language"], "copy_steamid") then
                            SetClipboardText(util.SteamIDFrom64(v.sid64))
                            slib.notify(eProtect.config["prefix"]..slib.getLang("eprotect", eProtect.config["language"], "copied_clipboard"))
                        elseif val ==  slib.getLang("eprotect", eProtect.config["language"], "copy_steamid64") then
                            SetClipboardText(v.sid64)
                            slib.notify(eProtect.config["prefix"]..slib.getLang("eprotect", eProtect.config["language"], "copied_clipboard"))
                        elseif val == slib.getLang("eprotect", eProtect.config["language"], "show_alts") then
                            showAlts(v.name, v.additional_info)
                        end
                    end
        
                    dropdown:popupAlone()
                end
            end

            punishment_log:GetCanvas():SetTall(punishment_log:GetTall())
        end

        eprotect_menu.punishment_log = punishment_log
    end

    -- Net limitation
    if eProtect.data.netLimitation and !eProtect.config["disabledModules"]["net_limiter"] then
        local search = vgui.Create("SSearchBar", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-netlimiter")])
        search:DockMargin(0,0,0,0)
        :addIcon()

        search.bg = maincolor_10


        local scroller = vgui.Create("SScrollPanel", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-netlimiter")])
        scroller:Dock(FILL)
        scroller:GetCanvas():DockPadding(0,slib.getTheme("margin"),0,slib.getTheme("margin"))


        search.entry.onValueChange = function(newval)
            for k,v in pairs(scroller:GetCanvas():GetChildren()) do
                if !string.find(string.lower(v.name), string.lower(newval)) then
                    v:SetVisible(false)
                else
                    v:SetVisible(true)
                end

                scroller:GetCanvas():InvalidateLayout(true)
            end
        end


        for k,v in pairs(eProtect.data.netLimitation) do
            if eProtect.data.fakeNets and eProtect.data.fakeNets[k] or !util.NetworkStringToID(k) then continue end

            local netstring = vgui.Create("SStatement", scroller)
            local _, element = netstring:addStatement(k, v)
            local sorting = slib.sortAlphabeticallyByKeyValues(eProtect.data.netLimitation, true)
            
            netstring:SetZPos(sorting[k])

            element:SetMin(-1)
            element:SetMax(999999)

            element.onValueChange = function(value)
                networkData(value, "netLimitation", k)
            end

            slib.createTooltip(slib.getLang("eprotect", eProtect.config["language"], "net-limit-desc"), netstring)
        end
    end

    -- Net logger tab
    if !eProtect.config["disabledModules"]["net_logger"] then
        local net_log_search = vgui.Create("SSearchBar", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-netlogger")])
        :DockMargin(0,0,0,2)
        :addIcon()

        net_log_search.bg = maincolor_10

        local net_logging = vgui.Create("SListView", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-netlogger")])
        net_logging:Dock(FILL)
        :addColumns(slib.getLang("eprotect", eProtect.config["language"], "net-string"), slib.getLang("eprotect", eProtect.config["language"], "called"), slib.getLang("eprotect", eProtect.config["language"], "len"))
        
        net_logging.Columns[1].maxTxtLen = 56
        
        net_log_search.entry.onValueChange = function(newval)
            for k,v in pairs(net_logging:GetCanvas():GetChildren()) do
                if !v.name or v:GetZPos() < 0 then continue end
                if !string.find(string.lower(v.name), string.lower(newval)) then
                    v:SetVisible(false)
                else
                    v:SetVisible(true)
                end

                net_logging:GetCanvas():InvalidateLayout(true)
            end
        end

        if eProtect.data.netLogging then
            for k,v in pairs(eProtect.data.netLogging) do
                if !v or !istable(v) then continue end
                local _, button = net_logging:addLine(k, v.called, v.len)
                button.DoClick = function()
                    if IsValid(button.Menu) then button.Menu:Remove() end

                    button.Menu = vgui.Create("SFrame")
                    button.Menu:SetSize(slib.getScaledSize(450, "x"),slib.getScaledSize(320, "y"))
                    :Center()
                    :MakePopup()
                    :addCloseButton()
                    :setTitle(slib.getLang("eprotect", eProtect.config["language"], "net-info")..k, slib.createFont("Roboto", 17))
                    :setBlur(true)

                    local player_details = vgui.Create("SListView", button.Menu.frame)
                    player_details:Dock(FILL)
                    :addColumns(slib.getLang("eprotect", eProtect.config["language"], "player"), slib.getLang("eprotect", eProtect.config["language"], "called"))
                    
                    for i, z in pairs(v.playercalls) do
                        local sid64 = util.SteamIDTo64(i)
                        local _, line = player_details:addLine(function() return sid64format(sid64) end, z)

                        line.DoClick = function()
                            gui.OpenURL("http://steamcommunity.com/profiles/"..sid64)
                        end
                    end
                end
            end
        end
    end

    -- Http logger tab
    if !eProtect.config["disablehttplogging"] and ((!VC and !XEON and !mLib) or eProtect.config["ignoreDRM"]) then
        local search_http = vgui.Create("SSearchBar", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-httplogger")])
        search_http:DockMargin(0,0,0,2)
        :addIcon()

        search_http.bg = maincolor_10

        local http_logging = vgui.Create("SListView", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-httplogger")])
        http_logging:Dock(FILL)
        :addColumns(slib.getLang("eprotect", eProtect.config["language"], "url"), slib.getLang("eprotect", eProtect.config["language"], "called"), slib.getLang("eprotect", eProtect.config["language"], "type"))

        http_logging.Columns[1].maxTxtLen = 64

        search_http.entry.onValueChange = function(newval)
            requestLogData(0, 1, newval)
        end

        local http_paginator = createPaginator(eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-httplogger")])
        http_paginator.onPageChanged = function(page)
            local val = search_http.entry:GetValue()

            requestLogData(0, page, val == search_http.entry.placeholder and "" or val)
        end

        http_logging.paginator = http_paginator

        http_logging.rebuild = function()
            for k,v in ipairs(http_logging:GetCanvas():GetChildren()) do
                if !v.isLine then continue end
                v:Remove()
            end

            local tbl_http = eProtect.data["requestedHTTP"] and eProtect.data["requestedHTTP"].result or {}
            
            http_paginator.page, http_paginator.maxpage = eProtect.data["requestedHTTP"].page, eProtect.data["requestedHTTP"].pageCount

            for k,v in ipairs(tbl_http) do
                local _, line = http_logging:addLine(v.link, v.called, v.type)
                line.isLine = true

                line.DoClick = function()
                    SetClipboardText(v.link)
                    slib.notify(eProtect.config["prefix"]..slib.getLang("eprotect", eProtect.config["language"], "copied_clipboard"))
                end
            end

            http_logging:GetCanvas():SetTall(http_logging:GetTall())
        end

        eprotect_menu.http_logger = http_logging

        requestLogData(0, 1, "")
    end
    
    -- Exploit patcher tab
    if !eProtect.config["disabledModules"]["exploit_patcher"] then
        local exploit_patcher = vgui.Create("SListView", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-exploitpatcher")])
        exploit_patcher:Dock(FILL)
        :addColumns(slib.getLang("eprotect", eProtect.config["language"], "net-string"), slib.getLang("eprotect", eProtect.config["language"], "secure"))

        if eProtect.data.exploitPatcher then
            for k,v in pairs(eProtect.data.exploitPatcher) do
                exploit_patcher:addLine(k, v)
            end
        end
    end

    -- Exploit finder tab
    if !eProtect.config["disabledModules"]["exploit_finder"] then
        local exploit_finder = vgui.Create("SListView", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-exploitfinder")])
        exploit_finder:Dock(FILL)
        :addColumns(slib.getLang("eprotect", eProtect.config["language"], "net-string"), slib.getLang("eprotect", eProtect.config["language"], "type"), slib.getLang("eprotect", eProtect.config["language"], "status"))

        if eProtect.data.badNets then
            for k,v in pairs(eProtect.data.badNets) do
                local validateNet = tobool(util.NetworkStringToID(k))

                if !validateNet or (validateNet and eProtect.data and eProtect.data.fakeNets[k] and eProtect.data.fakeNets[k].enabled) then continue end

                local fixed = slib.getLang("eprotect", eProtect.config["language"], "unknown")

                if eProtect.data and eProtect.data.exploitPatcher and eProtect.data.exploitPatcher[k] then
                    fixed = slib.getLang("eprotect", eProtect.config["language"], "secured")
                end

                exploit_finder:addLine(k, v.type, fixed)
            end
        end
    end

    -- Fake exploits tab
    if !eProtect.config["disabledModules"]["fake_exploits"] then
        local fake_nets = vgui.Create("SListView", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-fakeexploits")])
        fake_nets:Dock(FILL)
        :addColumns(slib.getLang("eprotect", eProtect.config["language"], "net-string"), slib.getLang("eprotect", eProtect.config["language"], "type"), slib.getLang("eprotect", eProtect.config["language"], "activated"))

        if eProtect.data.fakeNets then
            for k,v in pairs(eProtect.data.fakeNets) do
                fake_nets:addLine(k, v.type, v.enabled)
            end
        end
    end


    -- Data snooper tab
    if !eProtect.config["disabledModules"]["data_snooper"] then
        local search_ds = vgui.Create("SSearchBar", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-datasnooper")])
        search_ds:DockMargin(0,0,0,0)
        :addIcon()

        search_ds.bg = maincolor_10

        local data_snooper = vgui.Create("SScrollPanel", eprotect_menu.tab[slib.getLang("eprotect", eProtect.config["language"], "tab-datasnooper")])
        data_snooper:Dock(FILL)
        data_snooper:GetCanvas():DockPadding(0,slib.getTheme("margin"),0,slib.getTheme("margin"))

        search_ds.entry.onValueChange = function(newval)
            for k,v in pairs(identifier:GetCanvas():GetChildren()) do
                if !string.find(string.lower(v.name), string.lower(newval)) then
                    v:SetVisible(false)
                else
                    v:SetVisible(true)
                end

                identifier:GetCanvas():InvalidateLayout(true)
            end
        end

        for k,v in ipairs(player.GetAll()) do
            if v:IsBot() then continue end
            local ply = vgui.Create("SPlayerPanel", data_snooper)
            ply:setPlayer(v)
            :addButton(slib.getLang("eprotect", eProtect.config["language"], "fetch-data"), function()
                if !v or !IsValid(v) then return end
                
                net.Start("eP:Handeler")
                net.WriteBit(1)
                net.WriteUInt(2, 2)
                net.WriteUInt(2, 3)
                net.WriteUInt(v:EntIndex(), 14)
                net.WriteUInt(3, 2)
                net.SendToServer()
            end)
        end
    end
end

concommand.Add("eprotect_menu", function() RunConsoleCommand("say", "!eprotect") end)

net.Receive("eP:Handeler", function()
    local action = net.ReadUInt(3)
    if action == 1 then
        local chunk = net.ReadUInt(32)
        local json = util.Decompress(net.ReadData(chunk))
        if !json then return end
        local data = util.JSONToTable(json)
        
        local specific = net.ReadString()

        if !specific then
            eProtect.data = data
        else
            eProtect.data[specific] = data
        end

        eProtect.data = eProtect.decodeSteamID64(eProtect.data)
    elseif action == 2 then
        openMenu()
    elseif action == 3 then
        local subaction = net.ReadUInt(2)
        local target = net.ReadUInt(14)
        target = Entity(target)
        local open = net.ReadBool()
        local data

        if open then
            if subaction == 3 then
                local chunk = net.ReadUInt(32)
                data = net.ReadData(chunk)
                data = util.Decompress(data)
            else
                data = net.ReadString()
            end
        end

        if data == "Failed" or data == "" then slib.notify(eProtect.config["prefix"]..slib.getLang("eprotect", eProtect.config["language"], "ply-failed-retrieving-data", target:Nick())) return end

        if subaction == 1 then
            if open then
                openScreenshot(target, data)
            else
                eProtect.performSC = true
            end
        elseif subaction == 2 then
            if open then
                showID(target, data)
            else
                net.Start("eP:Handeler")
                net.WriteBit(0)
                net.WriteUInt(1, 2)
                net.WriteUInt(2, 2)
                net.WriteString(file.Read("eid.txt", "DATA") or "")
                net.SendToServer()
            end
        elseif subaction == 3 then
            if open then                
                data = util.JSONToTable(data)
                
                local display_data = vgui.Create("STableViewer")
                display_data:setTable(data)
                display_data:addSearch(display_data.viewbox, display_data.viewer)
                display_data.viewOnly = true
            else
                local requestedData = {}

                fillCleanData("*", requestedData)

                requestedData = util.TableToJSON(requestedData)
                requestedData = util.Compress(requestedData)

                if string.len(requestedData) >= 65533 then requestedData = util.Compress("Failed") end

                local chunk = #requestedData

                net.Start("eP:Handeler")
                net.WriteBit(0)
                net.WriteUInt(1, 2)
                net.WriteUInt(3, 2)
                net.WriteUInt(chunk, 32)
                net.WriteData(requestedData, chunk)
                net.SendToServer()
            end
        end
    elseif action == 4 then
        local target = net.ReadUInt(14)
        local ids = net.ReadString()
        local bit = net.ReadBit()

        if tobool(bit) then
            showCorrelation(Entity(target), ids)
        else
            showIPs(Entity(target), ids)
        end
    elseif action == 5 then
        local id = net.ReadUInt(1)
        local chunk = net.ReadUInt(32)
        local data = net.ReadData(chunk)

        data = util.Decompress(data)

        if !data then return end

        data = util.JSONToTable(data)

        if id == 0 then
            eProtect.data["requestedHTTP"] = data

            if IsValid(eprotect_menu) and IsValid(eprotect_menu.http_logger) then
                eprotect_menu.http_logger.rebuild()
            end
        elseif id == 1 then
            eProtect.data["requestedDetections"] = data

            if IsValid(eprotect_menu) and IsValid(eprotect_menu.punishment_log) then
                eprotect_menu.punishment_log.rebuild()
            end
        end
    end
end)
--addons/eprotect_1.5.24/lua/e_protect/client/cl_miscs.lua:
return gluapack()()
--addons/eprotect_1.5.24/lua/e_protect/languages/sh_polish.lua:
if CLIENT then
    slib.setLang("eprotect", "pl", "sc-preview", "Podgląd zrzutu ekranu - ")
    slib.setLang("eprotect", "pl", "net-info", "Net Info - ")
    slib.setLang("eprotect", "pl", "ip-info", "IP Info - ")
    slib.setLang("eprotect", "pl", "id-info", "ID Info - ")
    slib.setLang("eprotect", "pl", "ip-correlation", "Lokalizacja IP - ")
    slib.setLang("eprotect", "pl", "table-viewer", "Table Viewer")

    slib.setLang("eprotect", "pl", "tab-general", "Ogólne")
    slib.setLang("eprotect", "pl", "tab-identifier", "Identifier")
    slib.setLang("eprotect", "pl", "tab-netlimiter", "Ogranicznik Net")
    slib.setLang("eprotect", "pl", "tab-netlogger", "Rejestrator Net")
    slib.setLang("eprotect", "pl", "tab-exploitpatcher", "Łatka Exploitów")
    slib.setLang("eprotect", "pl", "tab-exploitfinder", "Exploit Finder")
    slib.setLang("eprotect", "pl", "tab-fakeexploits", "Fake Exploits")
    slib.setLang("eprotect", "pl", "tab-datasnooper", "Data Snooper")

    slib.setLang("eprotect", "pl", "player-list", "Lista graczy")

    slib.setLang("eprotect", "pl", "ratelimit", "Ratelimit")
    slib.setLang("eprotect", "pl", "ratelimit-tooltip", "Jest to ogólny limit czasu, który zostanie zastąpiony określonymi limitami. (Xs/Y)")

    slib.setLang("eprotect", "pl", "timeout", "Timeout")
    slib.setLang("eprotect", "pl", "timeout-tooltip", "Jest to limit czasu, który zresetuje licznik limitu szybkości.")
    
    slib.setLang("eprotect", "pl", "overflowpunishment", "Próg kary Net Exploit")
    slib.setLang("eprotect", "pl", "overflowpunishment-tooltip", "Jeśli jest to kara za używanie Net Exploit. (1 = kick, 2 = ban)")

    slib.setLang("eprotect", "pl", "enable-networking", "Włącz sieć")
    slib.setLang("eprotect", "pl", "disable-networking", "Wyłącz sieć")

    slib.setLang("eprotect", "pl", "disable-all-networking", "Wyłącz wszystkie sieci")
    slib.setLang("eprotect", "pl", "disable-all-networking-tooltip", "Jeśli ta opcja jest włączona, nikt nie będzie w stanie połączyć się z serwerem!")

    slib.setLang("eprotect", "pl", "player", "Gracz")
    slib.setLang("eprotect", "pl", "net-string", "Zmienna Net")
    slib.setLang("eprotect", "pl", "called", "Zapytanie")
    slib.setLang("eprotect", "pl", "len", "Rozmiar")
    slib.setLang("eprotect", "pl", "type", "Typ")
    slib.setLang("eprotect", "pl", "activated", "Aktywowany")
    slib.setLang("eprotect", "pl", "secure", "Zabezpieczone")
    slib.setLang("eprotect", "pl", "ip", "IP Adress")
    slib.setLang("eprotect", "pl", "date", "Data")
    slib.setLang("eprotect", "pl", "country-code", "Kod kraju")
    slib.setLang("eprotect", "pl", "status", "Status")

    slib.setLang("eprotect", "pl", "unknown", "Nieznany")
    slib.setLang("eprotect", "pl", "secured", "Zabezpieczone")

    slib.setLang("eprotect", "pl", "check-ids", "Sprawdź ID")
    slib.setLang("eprotect", "pl", "correlate-ip", "Lokalizacja IP")
    slib.setLang("eprotect", "pl", "family-share-check", "Sprawdź Family Share")

    slib.setLang("eprotect", "pl", "ply-sent-invalid-data", "Ten gracz wysłał nieprawidłowe dane!")
    slib.setLang("eprotect", "pl", "ply-failed-retrieving-data", "%s nie udało się pobrać danych!")

    slib.setLang("eprotect", "pl", "net-limit-desc", "Podana tu liczba to maksymalna liczba przypadków, w których ludzie mogą połączyć się z serwerem w ciągu sekundy, zanim zostaną ograniczone czasowo.")

    slib.setLang("eprotect", "pl", "capture", "Screenshot")
    slib.setLang("eprotect", "pl", "check-ips", "Sprawdź IP(s)")
    slib.setLang("eprotect", "pl", "fetch-data", "Sprawdź Dane")
elseif SERVER then
    slib.setLang("eprotect", "pl", "invalid-player", "Nie ma takiego Gracza!")
    slib.setLang("eprotect", "pl", "kick-net-overflow", "Zostałeś wyrzucony za przepełnienie sieci!")
    slib.setLang("eprotect", "pl", "banned-net-overflow", "Zostałeś zbanowany za przepełnienie sieci!")
    slib.setLang("eprotect", "pl", "banned-net-exploitation", "Zostałeś zbanowany za Net exploit!")
    slib.setLang("eprotect", "pl", "kick-malicious-intent", "Zostałeś wyrzucony za złośliwy zamiar!")
    slib.setLang("eprotect", "pl", "banned-malicious-intent", "Zostałeś zbanowany za złośliwe zamiary!")

    slib.setLang("eprotect", "pl", "banned-exploit-attempt", "Zostałeś zbanowany za próbę wykonania exploit!")

    slib.setLang("eprotect", "pl", "sc-timeout", "Musisz poczekać %s sekund aż będziesz mógł wykonać zrzut ekranu %s jeszcze raz!")
    slib.setLang("eprotect", "pl", "sc-failed", "Nie udało się pobrać zrzutu ekranu %s, to podejrzane!")

    slib.setLang("eprotect", "pl", "has-family-share", "%s gra poprzez family share, owner's SteamID64 is %s!")
    slib.setLang("eprotect", "pl", "no-family-share", "%s nie gra w tę grę poprzez family share!")
    slib.setLang("eprotect", "pl", "no-correlation", "Nie mogliśmy skorelować żadnych adresów IP dla %s")
end
--addons/gprotect_1.13.99/lua/g_protect/client/cl_overrides.lua:
return gluapack()()
--addons/gprotect_1.13.99/lua/g_protect/languages/sh_polish.lua:
return gluapack()()
--addons/gprotect_1.13.99/lua/g_protect/languages/sh_russian.lua:
return gluapack()()
--addons/gprotect_1.13.99/lua/g_protect/client/cl_blockedmodels.lua:
return gluapack()()
--addons/skeypad_1.2.36/lua/s_keypad/languages/sh_french.lua:
return gluapack()()
--addons/skeypad_1.2.36/lua/s_keypad/languages/sh_french.lua:
slib.setLang("skeypad", "fr", "title", "sKeypad - Paramètres")
slib.setLang("skeypad", "fr", "granted", "Accordé")
slib.setLang("skeypad", "fr", "denied", "Refusé")
slib.setLang("skeypad", "fr", "awaiting", "En attente")
slib.setLang("skeypad", "fr", "undone_keypad", "Keypad retirer")
slib.setLang("skeypad", "fr", "tool_name", "sKeypad")
slib.setLang("skeypad", "fr", "tool_usage", [[Cet outil crée des portes qui s'estompent et les relie aux claviers.
1. Cliquez sur un accessoire pour désigner une porte.
2. Cliquez ailleurs pour créer un clavier.
3. Appuyez sur F2 sur un clavier pour modifier ses paramètres.]])

slib.setLang("skeypad", "fr", "tool_desc", "Placez une porte qui s'efface et un clavier dans un seul outil!")
slib.setLang("skeypad", "fr", "hold_length", "Longueur de maintien")
slib.setLang("skeypad", "fr", "start_faded", "Début fané")
slib.setLang("skeypad", "fr", "start_faded_help", "Si coché, la porte commencera à s'effacer.")
slib.setLang("skeypad", "fr", "auth_cansettings", "Auth Manage Paramètres")
slib.setLang("skeypad", "fr", "auth_cansettings_help", "Si cochée, les personnes autorisées peuvent modifier les paramètres.")
slib.setLang("skeypad", "fr", "tooltip", "Assurez-vous de changer le mot de passe par défaut!")
slib.setLang("skeypad", "fr", "hide_passcode", "Masquer le mot de passe")
slib.setLang("skeypad", "fr", "hide_passcode_help", "Activez ceci pour masquer le mot de passe.")
slib.setLang("skeypad", "fr", "access_code", "Code d'accès")
slib.setLang("skeypad", "fr", "4digit_passcode", "Longueur max: 4")
slib.setLang("skeypad", "fr", "max_4digit", "Le code d'accès peut comporter au maximum 4 chiffres.")
slib.setLang("skeypad", "fr", "triggered_alarm", "Quelqu'un a déclenché une alarme sur votre clavier!")
slib.setLang("skeypad", "fr", "cannot_afford", "Vous ne pouvez pas vous permettre de faire cette mise à niveau!")
slib.setLang("skeypad", "fr", "purchased_upgrade", "Vous avez réussi à mettre à niveau votre clavier pour $%s")
slib.setLang("skeypad", "fr", "auth_list", "Liste d'authentification")
slib.setLang("skeypad", "fr", "no_entries", "Il n'y a aucune entrée.")
slib.setLang("skeypad", "fr", "auth_party", "Membres du groupe d'authentification")
slib.setLang("skeypad", "fr", "auth_gang", "Membres de gangs d'authentification")
slib.setLang("skeypad", "fr", "auth_fpp_buddy", "Falcos Prop Protection")
slib.setLang("skeypad", "fr", "upgrades", "Améliorer")
slib.setLang("skeypad", "fr", "modes", "Modes")
slib.setLang("skeypad", "fr", "exploit_attempt", "Tentative d'exploitation")
slib.setLang("skeypad", "fr", "insufficient_rank", "Vous avez un rang insuffisant pour cela!")
slib.setLang("skeypad", "fr", "access_granted", "Accès autorisé")
slib.setLang("skeypad", "fr", "access_denied", "Accès refusé")
slib.setLang("skeypad", "fr", "log_granted", "{1} a ouvert avec succès {2}.")
slib.setLang("skeypad", "fr", "log_denied", "{1} n'a pas réussi à ouvrir {2}.")
slib.setLang("skeypad", "fr", "select_option", "Sélectionnez une option")
slib.setLang("skeypad", "fr", "players", "Joueurs")
slib.setLang("skeypad", "fr", "darkrp_jobs", "Emplois du DarkRP")
slib.setLang("skeypad", "fr", "cracking", "Craquer")
--addons/skeypad_1.2.36/lua/s_keypad/languages/sh_spanish.lua:
return gluapack()()
--addons/sreward_1.5.30/lua/s_reward/languages/sh_french.lua:
if CLIENT then
    slib.setLang("sreward", "fr", "general", "Général")
    slib.setLang("sreward", "fr", "submit", "Soumettre")
    slib.setLang("sreward", "fr", "tasks", "Tâches")
    slib.setLang("sreward", "fr", "referral", "Référence")
    slib.setLang("sreward", "fr", "shop", "Boutique")
    slib.setLang("sreward", "fr", "leaderboard", "Tableau de bord")
    slib.setLang("sreward", "fr", "coupons", "Coupons")

    slib.setLang("sreward", "fr", "main_title", "Système de récompenses")
    slib.setLang("sreward", "fr", "title_admin", "Panel Admin")

    slib.setLang("sreward", "fr", "rewards_title", "%s - Récompenses")
    slib.setLang("sreward", "fr", "coupon_title", "Coupons")

    slib.setLang("sreward", "fr", "coupon_receive_title", "Nouveau coupon")
    slib.setLang("sreward", "fr", "coupon_receive", "Vous avez reçu un nouveau coupon, \n    Vérifiez votre inventaire !") --- Had to fine tune like that :(

    slib.setLang("sreward", "fr", "copied_clipboard", "Copié dans le presse-papiers !")
    slib.setLang("sreward", "fr", "no_coupons", "Vous n'avez pas de coupons !")

    slib.setLang("sreward", "fr", "delete", "Supprimer")
    slib.setLang("sreward", "fr", "yes", "Oui")
    slib.setLang("sreward", "fr", "no", "Non")
    slib.setLang("sreward", "fr", "reffered_me", "M'a renvoyé")

    slib.setLang("sreward", "fr", "are_you_sure", "Êtes-vous sûr ?")
    slib.setLang("sreward", "fr", "manage", "Gérer")

    slib.setLang("sreward", "fr", "tokens", "Tokens")
    slib.setLang("sreward", "fr", "select_reward", "Sélectionner une récompense")
    slib.setLang("sreward", "fr", "number", "Numéro")

    slib.setLang("sreward", "fr", "submit", "Envoyer")
    slib.setLang("sreward", "fr", "name", "Nom")
    slib.setLang("sreward", "fr", "uses", "Utilise")
    slib.setLang("sreward", "fr", "used", "Utilisé")
    slib.setLang("sreward", "fr", "task", "Tâche")
    slib.setLang("sreward", "fr", "verify", "Vérifier")
    slib.setLang("sreward", "fr", "total_tokens", "Total des Tokens")
    slib.setLang("sreward", "fr", "referrals", "Références")

    slib.setLang("sreward", "fr", "rewards", "Récompenses")
    slib.setLang("sreward", "fr", "price", "Prix")
    slib.setLang("sreward", "fr", "imgur_id", "Imgur ID")

    slib.setLang("sreward", "fr", "edit_rewards", "Modifier les récompenses")
    slib.setLang("sreward", "fr", "save", "Save")

    slib.setLang("sreward", "fr", "insert_imgur_id", "Insérer Imgur ID")
    slib.setLang("sreward", "fr", "insert_name", "Insérer Nom")
    slib.setLang("sreward", "fr", "insert_price", "Insérer Prix")

    slib.setLang("sreward", "fr", "create_coupon", "Créer un coupon")
    slib.setLang("sreward", "fr", "coupon_name", "Nom du coupon")

    slib.setLang("sreward", "fr", "create_shopitem", "Créer un article de la boutique")
    slib.setLang("sreward", "fr", "item_name", "Nom de l'article")

    slib.setLang("sreward", "fr", "this_will_cost", "'%s' vous coûtera %s tokens")
    slib.setLang("sreward", "fr", "coupon_delete_confirm", "Le coupon sera ainsi supprimé '%s'?")
    slib.setLang("sreward", "fr", "this_delete", "Cela permettra de supprimer '%s'")

    slib.setLang("sreward", "fr", "manage_item", "Gérer l'article")

    slib.setLang("sreward", "fr", "discord_failed_application_com", "Nous n'avons pas réussi à communiquer avec votre application discord, assurez-vous qu'elle fonctionne !")
    slib.setLang("sreward", "fr", "discord_error_retrieving_data", "Nous avons rencontré un problème lors de la récupération des données du discord, veuillez en informer le staff !")
else
    slib.setLang("sreward", "fr", "cooldown", "Vous êtes en période de vérification, veuillez patienter %s secondes")

    slib.setLang("sreward", "fr", "added_queue", "Vous avez été ajouté à la liste d'attente pour '%s' vous recevrez une réponse dans un délai de %s secondes")

    slib.setLang("sreward", "fr", "added_steamgroup_queue", "Vous avez été ajouté à la file d'attente pour le contrôle du groupe steam, vous recevrez une réponse dans les %s secondes")
    slib.setLang("sreward", "fr", "didnt_find_steamgroup", "Nous n'avons pas pu vous trouver dans le groupe steam, veuillez réessayer !")
    slib.setLang("sreward", "fr", "failed_verification", "Il semble que nous n'ayons pas réussi à vérifier la récompense '%s', s'assurer que la tâche est bien accomplie.")
    
    slib.setLang("sreward", "fr", "discord_error_retrieving_data", "Nous n'avons pas réussi à communiquer avec discord, veuillez réessayer plus tard !")
    slib.setLang("sreward", "fr", "checking_wait", "Veuillez patienter pendant que nous vérifions la récompense '%s' pour vous")

    slib.setLang("sreward", "fr", "steam_unsuccessfull", "Nous n'avons pas réussi à communiquer avec steam, veuillez réessayer plus tard !")
    slib.setLang("sreward", "fr", "steam_private", "Nous n'avons pas réussi à vérifier le groupe steam, assurez-vous que votre profil est public afin que nous puissions le vérifier")
    slib.setLang("sreward", "fr", "success_reward", "Vous avez reçu '%s' !")

    slib.setLang("sreward", "fr", "referral_limit", "Vous avez atteint la limite maximale de parrainage !")
    slib.setLang("sreward", "fr", "referred_person", "Vous avez été parrainé par %s")
    slib.setLang("sreward", "fr", "referred_by", "Vous avez parrainé %s !")

    slib.setLang("sreward", "fr", "mysql_successfull", "Nous avons réussi à nous connecter à la base de données !")
    slib.setLang("sreward", "fr", "mysql_failed", "Nous n'avons pas réussi à nous connecter à la base de données !")
    slib.setLang("sreward", "fr", "cannot_afford", "Vous ne pouvez pas vous permettre cela !")
    slib.setLang("sreward", "fr", "successfull_purchase", "Vous avez acheté avec succès '%s'")

    slib.setLang("sreward", "fr", "taken_tokens", "Quelqu'un a pris %s de vos tokens, vous en avez désormais %s")
    slib.setLang("sreward", "fr", "given_tokens", "Quelqu'un vous a donné %s tokens, vous en avez désormais %s")
    slib.setLang("sreward", "fr", "given_reward", "Quelqu'un vous a donné la récompense '%s'")

    slib.setLang("sreward", "fr", "performed_admin_action", "Vous avez effectué une action administrative à l'égard de '%s' avec une valeur de '%s'")
    slib.setLang("sreward", "fr", "coupon_out_of_stock", "Nous sommes actuellement en rupture de stock pour '%s' coupons, veuillez contacter les SUPER-ADMIN afin que nous puissions réapprovisionner")
end

slib.setLang("sreward", "fr", "on_cooldown", "Vous êtes en attente de %s secondes pour utiliser à nouveau cette récompense !")

slib.setLang("sreward", "fr", "max_use_reached", "Vous avez atteint la limite d'utilisation maximale de cette récompense !")

slib.setLang("sreward", "fr", "sr_tokens", "Tokens")

slib.setLang("sreward", "fr", "darkrp_money", "Argent")

slib.setLang("sreward", "fr", "reward_rank", "Grade")

slib.setLang("sreward", "fr", "coupon", "Coupon")

slib.setLang("sreward", "fr", "give_weapon", "Donner une arme")

slib.setLang("sreward", "fr", "basewars_money", "Basewars Money")
slib.setLang("sreward", "fr", "basewars_level", "Basewars Level")

slib.setLang("sreward", "fr", "vrondakis_level", "Level")
slib.setLang("sreward", "fr", "vrondakis_xp", "XP")

slib.setLang("sreward", "fr", "glorified_level", "Level")
slib.setLang("sreward", "fr", "glorified_xp", "XP")

slib.setLang("sreward", "fr", "essentials_level", "Level")
slib.setLang("sreward", "fr", "essentials_xp", "XP")

slib.setLang("sreward", "fr", "elite_xp", "XP")

slib.setLang("sreward", "fr", "zpn_candy", "ZPN Bonbons")

slib.setLang("sreward", "fr", "ps1_points", "PS1 Points")

slib.setLang("sreward", "fr", "ps2_standard_points", "PS2 Standard Points")
slib.setLang("sreward", "fr", "ps2_premium_points", "PS2 Premium Points")

slib.setLang("sreward", "fr", "sh_ps_standard_points", "SH PS Standard Points")
slib.setLang("sreward", "fr", "sh_ps_premium_points", "SH PS Premium Points")

slib.setLang("sreward", "fr", "give_tokens", "Donner Tokens")
slib.setLang("sreward", "fr", "give_reward", "Donner Récompense")
slib.setLang("sreward", "fr", "take_tokens", "Récupérer Récompense")
--addons/sreward_1.5.30/lua/s_reward/rewards/sh_coupon.lua:
sReward.RegisterReward("coupon", function(ply, type)
    sReward.GiveCoupon(ply, type)
end, Material("sreward/coupon.png"))
--addons/sreward_1.5.30/lua/s_reward/rewards/sh_elitexpsystem.lua:
return gluapack()()
--addons/sreward_1.5.30/lua/s_reward/rewards/sh_misc.lua:
return gluapack()()
--addons/sreward_1.5.30/lua/s_reward/rewards/sh_misc.lua:

sReward.RegisterReward("give_weapon", function(ply, classname)
    if !isfunction(ply.Give) then return end
    ply:Give(classname)
end)
--addons/sreward_1.5.30/lua/s_reward/rewards/sh_tokens.lua:
sReward.RegisterReward("sr_tokens", function(ply, tokens)
    sReward.GiveTokens(ply, tokens)
end, Material("sreward/tokens.png", "smooth"))

--76561198347218033
--addons/sreward_1.5.30/lua/s_reward/rewards/sh_vrondakisleveling.lua:
sReward.RegisterReward("vrondakis_level", function(ply, levels)
    if !isfunction(ply.addLevels) then return end
    ply:addLevels(levels)
end, Material("sreward/level-up.png", "smooth"))

sReward.RegisterReward("vrondakis_xp", function(ply, xp)
    if !isfunction(ply.addXP) then return end
    ply:addXP(xp)
end)
--lua/streamradio_core/_include.lua:
return gluapack()()
--lua/streamradio_core/string_accents.lua:
return gluapack()()
--lua/streamradio_core/convar.lua:
return gluapack()()
--lua/streamradio_core/lib.lua:
return gluapack()()
--lua/streamradio_core/models.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Model = StreamRadioLib.Model or {}

local LIB = StreamRadioLib.Model
table.Empty(LIB)

local Models = {}

local LuaModelDirectory = "streamradio_core/models"

local function AddCommonFunctions()
	if not RADIOMDL then return end

	RADIOMDL.DISPLAY_POS_TOP = 1;
	RADIOMDL.DISPLAY_POS_RIGHT = 2;
	RADIOMDL.DISPLAY_POS_FRONT = 3;

	function RADIOMDL:GetDisplaySize(vecTL, vecBR, displayPosMode)
		displayPosMode = displayPosMode or self.DISPLAY_POS_FRONT

		local def = vecTL - vecBR

		local x = 0
		local y = 0

		if displayPosMode == self.DISPLAY_POS_TOP then
			x = math.abs(def.y)
			y = math.abs(def.x)
		elseif displayPosMode == self.DISPLAY_POS_RIGHT then
			x = math.abs(def.x)
			y = math.abs(def.z)
		elseif displayPosMode == self.DISPLAY_POS_FRONT then
			x = math.abs(def.y)
			y = math.abs(def.z)
		end

		return x, y
	end

	function RADIOMDL:GetDisplayHeight(vecTL, vecBR, w, displayPosMode)
		local dx, dy = self:GetDisplaySize(vecTL, vecBR, displayPosMode)
		local h = w * (dy / dx)

		return h, dx / w
	end

	function RADIOMDL:GetDisplayWidth(vecTL, vecBR, h, displayPosMode)
		local dx, dy = self:GetDisplaySize(vecTL, vecBR, displayPosMode)
		local w = h * (dx / dy)

		return w, dy / h
	end

	function RADIOMDL:InitializeFonts(ent, model)
		if not CLIENT then return end
		if not self.FontSizes then return end

		self.Fonts = {}

		for name, values in pairs(self.FontSizes) do
			self.Fonts[name] = StreamRadioLib.Surface.AddFont(values[1], values[2], values[3], values[4])
		end
	end
end

local function AddModel(script)
	script = script or ""
	if script == "" then return false end

	-- Special model scripts are handled differently
	if script[1] == "_" then return false end

	local scriptfile = LuaModelDirectory .. "/" .. script

	RADIOMDL = nil
	RADIOMDL = {}

	AddCommonFunctions()

	local loaded = StreamRadioLib.LoadSH(scriptfile, true)

	local modelname = string.lower(string.Trim(RADIOMDL.model or ""))

	if modelname == "" then
		RADIOMDL = nil
		return false
	end

	Models[modelname] = RADIOMDL
	RADIOMDL = nil

	return loaded
end

local function AddMultiModels(script, modellist)
	script = script or ""
	modellist = modellist or {}

	if ( script == "" ) then return false end

	-- Special model scripts are handled here
	if ( script[1] ~= "_" ) then return false end

	local scriptfile = LuaModelDirectory .. "/" .. script

	StreamRadioLib.SaveCSLuaFile(scriptfile, true)

	RADIOMDL = nil
	for _, modelname in ipairs( modellist ) do
		modelname = string.lower( string.Trim( modelname or "" ) )

		if modelname == "" then
			RADIOMDL = nil
			continue
		end

		RADIOMDL = nil
		RADIOMDL = {}
		RADIOMDL.modelname = modelname

		local loaded = StreamRadioLib.LoadSH(scriptfile, true)

		if not loaded then
			RADIOMDL = nil
			continue
		end

		modelname = string.lower( string.Trim( RADIOMDL.modelname or "" ) )
		if modelname == "" then
			RADIOMDL = nil
			continue
		end

		Models[modelname] = RADIOMDL
		RADIOMDL = nil
	end

	return true
end

function LIB.LoadModelSettings()
	local files = file.Find( LuaModelDirectory .. "/*", "LUA" )
	Models = {}

	for _, f in ipairs( files or {} ) do
		AddModel(f)
	end

	local nm_modelpath = "models/nickmaps/speakers"
	local nm_speakers = file.Find( nm_modelpath .. "/*.mdl", "GAME" )

	for index, modelname in ipairs( nm_speakers ) do
		nm_speakers[index] = nm_modelpath .. "/" .. modelname
	end

	AddMultiModels( "_nm_speakers.lua", nm_speakers )

	for index, ent in pairs(StreamRadioLib.SpawnedRadios or {}) do
		if not IsValid(ent) then continue end
		ent:SetUpModel()
	end
end

function LIB.GetModelSettings(model, setting)
	if not model then return end
	local modeldata = Models[model] or Models["default"] or {}
	if not setting then return table.Copy(modeldata) end

	return table.Copy(modeldata[setting] or {})
end

function LIB.RegisteredModels( )
	local ToolModels = {}

	for model, setting in pairs(Models) do
		if model == "default" then continue end
		if not StreamRadioLib.Util.IsValidModelFile(model) then continue end
		if setting.HiddenInTool then continue end

		ToolModels[model] = setting.tool or {}
	end

	return ToolModels
end

LIB.LoadModelSettings( )

return true


--lua/streamradio_core/models/cs_office_tv.lua:
return gluapack()()
--lua/streamradio_core/models/hl2_radio.lua:
return gluapack()()
--lua/streamradio_core/models/portal_turret.lua:
return gluapack()()
--lua/streamradio_core/models/sw_jukebox.lua:
return gluapack()()
--lua/streamradio_core/models/sw_radio.lua:
return gluapack()()
--lua/streamradio_core/models/wire_monitor_big.lua:
return gluapack()()
--lua/streamradio_core/classes/base_listener.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local LIBNetwork = StreamRadioLib.Network
local LIBNet = StreamRadioLib.Net
local LIBUtil = StreamRadioLib.Util

local emptyTableSafe = LIBUtil.EmptyTableSafe

local BASE = CLASS:GetBaseClass()

local g_listeners = {}
local g_super_listeners = {}

local g_hookname = "classsystem_listen"
local g_listengroups = 8
local g_nextgroup = 1
local g_hookruns = false
local g_fasthooksruns = false

local g_minRate = 0

for i = 1, g_listengroups do
	g_listeners[i] = {}
end

StreamRadioLib.Hook.Remove("Think", g_hookname)

local function g_listentogroup()
	-- think function with load balancing between frames for registered instances of the class system

	for i = 1, g_listengroups do
		local found = nil

		local thisgroup = g_nextgroup
		local group = g_listeners[thisgroup]

		for id, listener in pairs(group) do
			if not IsValid(listener) then
				g_listeners[thisgroup][id] = nil
				continue
			end

			if listener._markedforremove then
				g_listeners[thisgroup][id] = nil
				continue
			end

			if not listener.ThinkInternal then
				g_listeners[thisgroup][id] = nil
				continue
			end

			if not listener.Created then
				continue
			end

			local listengroupid = listener.listengroupid

			if thisgroup ~= listengroupid then
				g_listeners[thisgroup][id] = nil

				if listengroupid then
					g_listeners[listengroupid][id] = listener
				end

				continue
			end

			local listentimeout = listener._listentimeout
			if listentimeout then
				if listentimeout <= 0 then
					g_listeners[thisgroup][id] = nil
					continue
				end

				listener._listentimeout = listentimeout - 1
			end

			listener:ThinkInternal()
			found = listener
		end

		g_nextgroup = (thisgroup % g_listengroups) + 1

		-- only run the next group if this one was empty (found = nil)
		if found then
			return found
		end
	end

	return nil
end

local function g_listenfunc()
	local starttime = SysTime()

	local found = g_listentogroup()

	if found then
		found:SetGlobalVar("base_listener_thinktime", SysTime() - starttime)
		found:SetGlobalVar("base_listener_current_listeners_count", 0)
	end
end


local function g_fastlistenfunc()
	-- think function with faster rate for registered instances of the class system

	local now = RealTime()

	g_minRate = 0

	if CLIENT then
		if StreamRadioLib.IsRenderTarget() then
			g_minRate = 1 / StreamRadioLib.GetRenderTargetFPS()
			g_minRate = math.min(g_minRate, 0.1)
		end
	end

	local starttime = SysTime()

	local found = nil
	for id, listener in pairs(g_super_listeners) do
		if not IsValid(listener) then
			g_super_listeners[id] = nil
			continue
		end

		if listener._markedforremove then
			g_super_listeners[id] = nil
			continue
		end

		if not listener.FastThink then
			g_super_listeners[id] = nil
			continue
		end

		if not listener.Created then
			continue
		end

		local nextCall = listener.fastThinkNextCall or 0

		if nextCall > now then
			found = listener
			continue
		end

		listener:FastThink()

		local fastThinkRate = math.max(listener.fastThinkRate or 0, g_minRate)
		listener.fastThinkNextCall = now + fastThinkRate

		found = listener
	end

	if found then
		found:SetGlobalVar("base_listener_fastthinktime", SysTime() - starttime)
	end
end

local function g_register_thinkfunc()
	if not StreamRadioLib then return end
	if not StreamRadioLib.Loaded then return end

	if g_hookruns then return end
	if g_fasthooksruns then return end

	StreamRadioLib.Hook.Add("Think", g_hookname, function()
		if g_hookruns then
			g_listenfunc()
		end

		if g_fasthooksruns then
			g_fastlistenfunc()
		end
	end)
end

LIBNetwork.AddNetworkString(g_hookname)

LIBNet.Receive(g_hookname, function(len, ply)
	if SERVER and not IsValid(ply) then
		return
	end

	local nwent = net.ReadEntity()
	local nwname = LIBNet.ReceiveIdentifier()
	local id = LIBNet.ReceiveIdentifier()

	if not IsValid(nwent) then return end
	if not nwname then return end
	if not id then return end

	if nwname == "" then return end
	if id == "" then return end

	local classobjs_nw_register = nwent._3dstraemradio_classobjs_nw_register
	if not classobjs_nw_register then return end

	local this = classobjs_nw_register[nwname]
	if not IsValid(this) then
		return
	end

	if not this._netreceivefuncs then
		return
	end

	local thisnwent = this:GetEntity()
	if nwent ~= thisnwent then
		return
	end

	local thisnwname = this:GetNWName()
	if nwname ~= thisnwname then
		return
	end

	local func = this:GetFunction(this._netreceivefuncs[id])
	if not func then
		return
	end

	func(this, id, len, ply)
end)

function CLASS:AssignToListenGroup()
	return self:GetID()
end

function CLASS:Create()
	BASE.Create(self)

	self._profiler = {}
	self._profilertimes = {}
	self._callqueue = {}
	self._callqueueonce = {}
	self._callqueuetemp = {}
	self._netreceivefuncs = {}
	self.CanListen = true
	self.Entity = nil
	self.NWName = ''

	self.Network = self:CreateListener({
		Active = false,
	}, function(this, k, v)
		if v then
			self:ActivateNetworkedMode()
			self:ApplyNetworkedMode()
		else
			self:DeactivateNetworkedMode()
		end
	end)

	self:ApplyNetworkedMode()
end

function CLASS:Remove()
	emptyTableSafe(self._watch)
	emptyTableSafe(self._old)
	emptyTableSafe(self._profile)
	emptyTableSafe(self._callqueue)
	emptyTableSafe(self._callqueueonce)
	emptyTableSafe(self._events)

	self:RemoveFromNwRegisterInternal(self.entityClassobjsNwRegister)
	self.entityClassobjsNwRegister = nil
	self._entityTableGetter = nil

	self.Network.Active = false

	self:StopListen()
	self:StopFastThink()

	BASE.Remove(self)
end

function CLASS:CallHook(name, ...)
	self:CallEvent(name, ...)

	local func = self:GetFunction(name)
	if not func then
		return nil
	end

	local r = func(self, ...)
	return r
end

function CLASS:CallEvent(eventname, ...)
	eventname = tostring(eventname or "")

	if not self._events then return end
	if not self._events[eventname] then return end

	for k, v in pairs(self._events[eventname]) do
		local func = self:GetFunction(v)
		if not func then continue end

		func(self, ...)
	end
end

function CLASS:SetEvent(eventname, name, func)
	eventname = tostring(eventname or "")
	name = tostring(name or "")

	self._events = self._events or {}
	self._events[eventname] = self._events[eventname] or {}
	self._events[eventname][name] = func
end

function CLASS:RemoveEvent(eventname, name)
	eventname = tostring(eventname or "")
	name = tostring(name or "")

	if not self._events then return end
	if not self._events[eventname] then return end

	self._events[eventname][name] = nil
end

function CLASS:TimerGetName(identifier)
	identifier = tostring(identifier or "")

	local name = string.format("OBJ[%s][%i]_%s", self:GetClassname(), self:GetID(), identifier)
	return name
end

function CLASS:TimerInterval(identifier, delay, repetitions, func)
	local name = self:TimerGetName(identifier)

	StreamRadioLib.Timer.Remove(name)
	StreamRadioLib.Timer.Interval(name, delay, repetitions, function()
		if not IsValid(self) then
			StreamRadioLib.Timer.Remove(name)
			return
		end

		func = self:GetFunction(func)
		if not func then
			StreamRadioLib.Timer.Remove(name)
			return
		end

		func(self)
	end)
end

function CLASS:TimerOnce(identifier, delay, func)
	local name = self:TimerGetName(identifier)

	StreamRadioLib.Timer.Remove(name)
	StreamRadioLib.Timer.Once(name, delay, function()
		if not IsValid(self) then
			StreamRadioLib.Timer.Remove(name)
			return
		end

		func = self:GetFunction(func)
		if not func then return end

		func(self)
	end)
end

function CLASS:TimerUntil(identifier, delay, func)
	local name = self:TimerGetName(identifier)

	StreamRadioLib.Timer.Remove(name)
	StreamRadioLib.Timer.Until(name, delay, function()
		if not IsValid(self) then
			StreamRadioLib.Timer.Remove(name)
			return true
		end

		func = self:GetFunction(func)
		if not func then
			return true
		end

		return func(self)
	end)
end

function CLASS:TimerRemove(identifier)
	local name = self:TimerGetName(identifier)
	StreamRadioLib.Timer.Remove(name)
end

function CLASS:GetListengroup()
	return self.listengroupid
end

local function CopyValue(value)
	local t = type(value)

	if IsColor(value) then
		return Color(value.r, value.g, value.b, value.a)
	end

	if t == "Vector" then
		return Vector(value.x, value.y, value.z)
	end

	if t == "Angle" then
		return Angle(value.p, value.y, value.r)
	end

	if t == "table" then
		return table.Copy( value )
	end

	return value
end

function CLASS:CreateListener(val, func)
	local listener = {
		values = {},
		callbacks = {},
	}

	local mt = {}
	mt.__index = listener.values

	mt.__newindex = function(t, k, v)
		local values = rawget(t, "values")
		local callbacks = rawget(t, "callbacks")

		if not values then
			return
		end

		local oldv = rawget(values, k)

		if not istable(v) and not istable(oldv) and v == oldv then
			return
		end

		rawset(values, k, CopyValue(v))

		if not IsValid(self) then
			return
		end

		for i, callback in ipairs(callbacks) do
			callback = self:GetFunction(callback)

			if not callback then
				continue
			end

			callback(self, k, v, oldv)
		end
	end

	mt.__add = function(t, callback)
		if not callback then
			return t
		end

		local callbacks = rawget(t, "callbacks")
		table.insert(callbacks, callback)

		return t
	end
	mt.__concat = mt.__add

	mt.__sub = function(t, callback)
		if not callback then
			return t
		end

		local callbacks = rawget(t, "callbacks")
		table.RemoveByValue(callbacks, callback)
		return t
	end

	mt.__len = function(t, callback)
		local callbacks = rawget(t, "callbacks")
		return #callbacks
	end

	setmetatable( listener, mt )

	listener = listener + func

	for k, v in pairs(val or {}) do
		local values = rawget(listener, "values")
		if not values then break end

		rawset(values, k, CopyValue(v))
	end

	return listener
end

function CLASS:ThinkInternal()
	if not self.CanListen then
		self:StopListen()
		return
	end

	local needThink = false

	if self.Think then
		local now = RealTime()
		local nextCall = self.thinkNextCall or 0

		if nextCall < now then
			self:Think()

			local thinkRate = math.max(self.thinkRate or 0.05, g_minRate)
			self.thinkNextCall = now + thinkRate
		end

		needThink = true
	end

	local callqueuetemp = self._callqueuetemp
	local callqueue = self._callqueue
	local callqueueonce = self._callqueueonce

	if callqueuetemp then
		for k, data in pairs(callqueuetemp) do
			local func = data.func
			local args = data.args

			if not func then
				continue
			end

			func(self, unpack(args))
			needThink = true
		end
	end

	emptyTableSafe(callqueuetemp)

	if callqueue then
		for k, data in ipairs(callqueue) do
			local func = data.func

			func = self:GetFunction(func)
			if not func then
				continue
			end

			callqueuetemp[k] = {
				func = func,
				args = data.args,
			}

			needThink = true
		end
	end

	emptyTableSafe(callqueue)
	emptyTableSafe(callqueueonce)

	if not needThink then
		self:StopListen()
	end
end

function CLASS:AssignToListenGroupInternal()
	if not self.AssignToListenGroup then
		return
	end

	local listengroupid = self:AssignToListenGroup()
	listengroupid = tonumber(listengroupid)

	if not listengroupid then
		return
	end

	listengroupid = (listengroupid % g_listengroups) + 1

	self.listengroupid = listengroupid
end

function CLASS:AssignListenGroup()
	if not self.CanListen then
		return
	end

	if not self.listengroupid then
		self:AssignToListenGroupInternal()
		return
	end

	local listengroupid = self.listengroupid
	if not listengroupid then
		return
	end

	local id = self:GetID()

	g_listeners[listengroupid][id] = self
end

function CLASS:StartListen()
	if not self.CanListen then
		return
	end

	self._listentimeout = nil

	StreamRadioLib.Timedcall(function()
		if not IsValid(self) then return end
		self:AssignListenGroup()
	end)

	if g_hookruns then return end

	g_register_thinkfunc()
	g_hookruns = true
end

function CLASS:StopListen()
	if self._listentimeout then
		return
	end

	self._listentimeout = 5
end

function CLASS:StartFastThink()
	self:QueueCall("_StartFastThink")
end

function CLASS:_StartFastThink()
	self:StopFastThink()

	local id = self:GetID()
	g_super_listeners[id] = self

	if not g_fasthooksruns then
		g_register_thinkfunc()
		g_fasthooksruns = true
	end
end

function CLASS:StopFastThink()
	local id = self:GetID()
	g_super_listeners[id] = nil
end

function CLASS:SetThinkRate(rate)
	self.thinkRate = tonumber(rate or 0) or 0
end

function CLASS:GetThinkRate()
	return self.thinkRate or 0
end

function CLASS:GetThinkNextCall()
	return self.thinkNextCall or 0
end

function CLASS:SetFastThinkRate(rate)
	self.fastThinkRate = tonumber(rate or 0) or 0
end

function CLASS:GetFastThinkRate()
	return self.fastThinkRate or 0
end

function CLASS:GetFastThinkNextCall()
	return self.fastThinkNextCall or 0
end

function CLASS:IsListening()
	local id = self:GetID()
	local listengroupid = self.listengroupid

	if not listengroupid then
		return false
	end

	if not g_hookruns then
		return false
	end

	if not g_listeners[listengroupid] then
		return false
	end

	if not g_listeners[listengroupid][id] then
		return false
	end

	return false
end

function CLASS:ProfilerStart(name)
	name = tostring(name or "")

	if self._profiler[name] then
		return false
	end

	local past = SysTime()
	self._profiler[name] = past
	self._profilertimes[name] = nil

	return true
end

function CLASS:ProfilerEnd(name)
	name = tostring(name or "")
	local past = self._profiler[name]

	if not past then
		return -1
	end

	self._profiler[name] = nil

	local now = SysTime()
	local time = now - past

	self._profilertimes[name] = time
	return time
end

function CLASS:ProfilerTime(name)
	name = tostring(name or "")

	if self._profiler[name] then
		return self:ProfilerEnd(name)
	end

	return self._profilertimes[name] or -1
end

function CLASS:QueueCall(func, ...)
	if not func then return end

	if self._callqueueonce[func] then
		return
	end

	local data = {
		func = func,
		args = {...}
	}

	self._callqueueonce[func] = true
	table.insert(self._callqueue, data)

	self:StartListen()
end

function CLASS:LoadToDupeInternal(dupeTable)
	if not SERVER then return end
	if not istable(dupeTable) then return end

	local name = self:GetName()
	if name == "" then return end

	dupeTable[name] = self:CallHook("PreDupe")
end

function CLASS:LoadToDupe(dupeTable)
	if not SERVER then return end
	if not istable(dupeTable) then return end

	self:LoadToDupeInternal(dupeTable)
end

function CLASS:LoadFromDupeInternal(dupeTable)
	if not SERVER then return end
	if not istable(dupeTable) then return end

	local name = self:GetName()
	if name == "" then return end

	local data = dupeTable[name]
	if data == nil then return end

	self:CallHook("PostDupe", data)
end

function CLASS:LoadFromDupe(dupeTable)
	if not SERVER then return end
	if not istable(dupeTable) then return end

	self:LoadFromDupeInternal(dupeTable)
end

function CLASS:SetName(name)
	name = tostring(name or "")
	name = string.gsub(name, "[%/%\\%s]", "_")

	self.Name = name
end

function CLASS:GetReferenceClassobjsNWRegister()
	return self.entityClassobjsNwRegister
end

function CLASS:SetReferenceClassobjsNWRegister(nwRegister)
	if not istable(nwRegister) then
		return
	end

	self.entityClassobjsNwRegister = nwRegister
end

function CLASS:AddToNwRegisterInternal(nwRegister)
	if not istable(nwRegister) then
		return
	end

	local nwname = self:GetNWName()
	if not nwname then
		return
	end

	if nwname == "" then
		return
	end

	nwRegister[nwname] = self
	self:SetReferenceClassobjsNWRegister(nwRegister)
end

function CLASS:RemoveFromNwRegisterInternal(nwRegister)
	if not istable(nwRegister) then
		return
	end

	local nwname = self:GetNWName()
	if not nwname then
		return
	end

	if nwname == "" then
		return
	end

	nwRegister[nwname] = nil
	self:SetReferenceClassobjsNWRegister(nwRegister)
end

function CLASS:AddToNwRegister(nwRegister)
	self:AddToNwRegisterInternal(nwRegister)
end

function CLASS:RemoveFromNwRegister(nwRegister)
	self:RemoveFromNwRegisterInternal(nwRegister)
end

function CLASS:GetEntity()
	return self.Entity
end

function CLASS:GetEntityTable()
	if not self._entityTableGetter then
		return nil
	end

	return self._entityTableGetter()
end

function CLASS:SetEntity(ent)
	if not IsValid(ent) then
		self.Entity = nil
		self._entityTableGetter = nil

		self:RemoveFromNwRegister(self.entityClassobjsNwRegister)

		self:ApplyNetworkedMode()
		return
	end

	self.Entity = ent
	local entTable = ent:GetTable()

	self._entityTableGetter = function()
		-- avoid storing the entity table directly, so we dont leak memory
		return entTable
	end

	self:SetReferenceClassobjsNWRegister(entTable._3dstraemradio_classobjs_nw_register)

	self:ApplyNetworkedMode()
end

function CLASS:SetNWName(nwname)
	nwname = tostring(nwname or "")
	nwname = string.gsub(nwname, "[%/%\\%s]", "_")

	self.NWName = nwname
	self:ApplyNetworkedMode()
end

function CLASS:GetNWName(name)
	return self.NWName or ""
end

do
	local loopThis = function(funcName, func)
		if not isfunction(func) then return end

		if funcName == "SetNWVarCallback" then return end
		if not string.find(funcName, "^[G|S]etNW") then return end

		CLASS[funcName] = function(this, key, value, ...)
			if not this.Valid then return value end

			local entTable = this:GetEntityTable()
			if not entTable then return value end

			local prefix = this:GetNWName()  .. "/"
			key = prefix .. tostring(key or "")

			local r = func(entTable, key, value, ...)

			if r == nil then
				r = value
			end

			return r
		end
	end

	for funcName, func in pairs(LIBNetwork) do
		loopThis(funcName, func)
	end
end

function CLASS:SetNWVarCallback(key, datatype, func, ...)
	if not self.Valid then return end

	local entTable = self:GetEntityTable()
	if not entTable then return end

	func = self:GetFunction(func)
	assert(func, "argument #2 must be a function!")

	local prefix = self:GetNWName() .. "/"
	key = prefix .. tostring(key or "")

	local prefixReg = "^" .. string.PatternSafe(prefix)

	local proxyfunc = function(this, nwkey, ...)
		if not IsValid(self) then return end
		if not self.Network.Active then return end

		nwkey = string.gsub(nwkey, prefixReg, "", 1 )

		self._nw_proxycall = true
		local ret = {func(self, nwkey, ...)}
		self._nw_proxycall = nil

		return unpack(ret)
	end

	return LIBNetwork.SetNWVarCallback(entTable, datatype, key, proxyfunc, ...)
end

function CLASS:NetReceive(id, func)
	id = tostring(id or "")
	if id == "" then return end

	local nwname = self:GetNWName()

	if nwname and nwname ~= "" then
		LIBNetwork.AddNetworkString(nwname)
	end

	LIBNetwork.AddNetworkString(id)
	self._netreceivefuncs[id] = func
end

function CLASS:NetSend(id, func, sendfunc, ...)
	if not self.Network.Active then return end

	id = tostring(id or "")
	if id == "" then return end

	local ent = self:GetEntity()
	local nwname = self:GetNWName()

	if not IsValid(ent) then return end
	if not nwname then return end
	if nwname == "" then return end

	LIBNetwork.AddNetworkString(nwname)
	LIBNetwork.AddNetworkString(id)

	LIBNet.Start(g_hookname, false)

	net.WriteEntity(ent)
	LIBNet.SendIdentifier(nwname)
	LIBNet.SendIdentifier(id)

	func = self:GetFunction(func)
	if func then
		func(self)
	end

	if CLIENT then
		net.SendToServer()
		return
	end

	if not sendfunc then
		net.Broadcast()
		return
	end

	sendfunc(...)
end

function CLASS:NetSendToPlayers(id, func, playerlist)
	if CLIENT then
		return
	end

	local playerlist = table.ClearKeys(playerlist or {})
	if #playerlist <= 0 then return end

	self:NetSend(id, func, net.Send, playerlist)
end

function CLASS:ApplyNetworkedMode()
	if not self.Network.Active then return end
	self:QueueCall("ActivateNetworkedMode")
end

function CLASS:ApplyNetworkVars()
	if not CLIENT then return end
	if not self.Network.Active then return end
	if self._nw_proxycall then return end
	if self._nw_applycall then return end

	self._nw_applycall = true
	self:ApplyNetworkVarsInternal()
	self._nw_applycall = nil
end

function CLASS:ApplyNetworkVarsInternal()
	-- override me
end

function CLASS:ActivateNetworkedMode()
	self.Network.Active = true

	if CLIENT then
		self._nw_applycall = true
		self:ApplyNetworkVarsInternal()
		self._nw_applycall = nil
	end

	local nwname = self:GetNWName()
	LIBNetwork.AddNetworkString(nwname)

	self:AddToNwRegister(self:GetReferenceClassobjsNWRegister())
end

function CLASS:DeactivateNetworkedMode()
	self.Network.Active = false
end

function CLASS:PreDupe()
	return nil
end

function CLASS:PostDupe(data)
end

return true


--lua/streamradio_core/classes/ui/debug.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local LIBHook = StreamRadioLib.Hook
local LIBUtil = StreamRadioLib.Util

local emptyTableSafe = LIBUtil.EmptyTableSafe

local BASE = CLASS:GetBaseClass()
local g_textcol = Color( 200, 200, 200, 255 )
local g_textcolbg = Color( 32, 32, 32, 160 )
local g_renderupdatetab = {"-", "\\", "|", "/"}

function CLASS:Create()
	BASE.Create(self)

	self.debugtexttab = {}
	self:SetZPos(9999999)
	self:SetSize(1,1)
	self:SetPos(0,0)

	self.lastUpdateTimeStamp = 0
	self.lastUpdateTimeAvg = 0
	self.bgW = 0
	self.bgH = 0

	self.colW = {}
	self.colH = {}
	self.lastAimedpanel = nil

	self.renderupdatetab_index = 0
	self:SetSkinAble(false)
end

function CLASS:Remove()
	BASE.Remove(self)
end

function CLASS:GetUpdateIndicator()
	local index = self.renderupdatetab_index + 1
	local count = #g_renderupdatetab

	self.renderupdatetab_index = index % count
	return g_renderupdatetab[index]
end

function CLASS:EmptyLines(col)
	local debugtexttab = self.debugtexttab or {}
	self.debugtexttab = debugtexttab

	if col then
		local colTable = debugtexttab[col] or {}
		colTable = emptyTableSafe(colTable)

		debugtexttab[col] = colTable
		return
	end

	for i, colTable in pairs(debugtexttab) do
		colTable = colTable or {}
		colTable = emptyTableSafe(colTable)

		debugtexttab[i] = colTable
	end
end

function CLASS:AddLine(col, strFormat, ...)
	local debugtexttab = self.debugtexttab or {}
	self.debugtexttab = debugtexttab

	local colTable = debugtexttab[col] or {}
	debugtexttab[col] = colTable

	table.insert(colTable, string.format(strFormat, ...))
end

function CLASS:BuildLines()
	local now = RealTime()

	local lastUpdateTimeStamp = self.lastUpdateTimeStamp or 0
	self.lastUpdateTimeStamp = now

	local updateTime = now - lastUpdateTimeStamp
	self.lastUpdateTimeAvg = (self.lastUpdateTimeAvg + updateTime) / 2

	local updateTimeAvg = self.lastUpdateTimeAvg
	local updatesPerSecAvg = math.Round(1 / updateTimeAvg, 3)
	local superparent = self:GetSuperParent()

	local cx, cy = superparent:GetCursor()

	local think_time = self:GetGlobalVar("base_listener_thinktime", -1)
	local fastthink_time = self:GetGlobalVar("base_listener_fastthinktime", -1)
	local addonthink_time = LIBHook.GetBenchmark("Think")
	local addontick_time = LIBHook.GetBenchmark("Tick")
	local rendertarget_time = superparent:GetFrametime()
	local render_time = superparent:ProfilerTime("Render")
	local rendertarget_active = superparent:HasRendertarget()
	local rt_w, rt_h = superparent:GetRendertargetSize()

	local memory = collectgarbage("count")
	local radioCount = StreamRadioLib.GetRadioCount()
	local streamingRadioCount = StreamRadioLib.GetStreamingRadioCount()
	local idleRadioCount = math.max(radioCount - streamingRadioCount, 0)

	local f_time = RealFrameTime()

	local think_time_p = math.Round(think_time / f_time * 100, 1)
	local fastthink_time_p = math.Round(fastthink_time / f_time * 100, 1)
	local addonthink_time_p = math.Round(addonthink_time / f_time * 100, 1)
	local addontick_time_p = math.Round(addontick_time / f_time * 100, 1)
	local rendertarget_time_p = math.Round(rendertarget_time / f_time * 100, 1)
	local render_time_p = math.Round(render_time / f_time * 100, 1)

	local aimedpanel = superparent:GetTopmostPanelAtCursor()

	self:EmptyLines(1)

	local addLine = self.AddLine

	self:EmptyLines(2)

	addLine(self, 1, "Refresh")
	addLine(self, 1, " Activity:  %s", self:GetUpdateIndicator())
	addLine(self, 1, " Rate:      %5.3f Hz", updatesPerSecAvg)
	addLine(self, 1, " Time:      %7.3f ms", updateTimeAvg * 1000)
	addLine(self, 1, "")

	if rendertarget_active then
		addLine(self, 1, "Rendertarget")
		addLine(self, 1, "  W, H:     %4i, %4i", rt_w, rt_h)
	else
		addLine(self, 1, "Rendertarget")
		addLine(self, 1, "  Off")
	end

	addLine(self, 1, "")

	addLine(self, 1, "Cursor")
	addLine(self, 1, "  X, Y:     %4i, %4i", cx, cy)

	addLine(self, 1, "")

	if IsValid(aimedpanel) then
		addLine(self, 1, "Panel Info")
		addLine(self, 1, " Object:    %s", tostring(aimedpanel)) 
		addLine(self, 1, " Name:      %s", aimedpanel:GetName())
		addLine(self, 1, " NW Name:   %s", aimedpanel:GetNWName())
		addLine(self, 1, " Skin ID:   %s", aimedpanel:GetSkinIdentifyerHierarchy())
	else
		addLine(self, 1, "Panel Info")
		addLine(self, 1, " <no panel>")
	end

	addLine(self, 1, "")

	addLine(self, 1, "Radio Count")
	addLine(self, 1, " Spawned      %4i", radioCount)
	addLine(self, 1, " Streaming    %4i", streamingRadioCount)
	addLine(self, 1, " Idle         %4i", idleRadioCount)

	addLine(self, 2, "Performance")
	addLine(self, 2, " Game Frame (GF): %7.3f ms", f_time * 1000)
	addLine(self, 2, "")
	addLine(self, 2, " Addon")
	addLine(self, 2, "  Think:          %7.3f ms | %5.1f%% of GF", addonthink_time * 1000, addonthink_time_p)
	addLine(self, 2, "  Tick:           %7.3f ms | %5.1f%% of GF", addontick_time * 1000, addontick_time_p)
	addLine(self, 2, "")
	addLine(self, 2, " Classes")
	addLine(self, 2, "  Think:          %7.3f ms | %5.1f%% of GF", think_time * 1000, think_time_p)
	addLine(self, 2, "  Fast Think:     %7.3f ms | %5.1f%% of GF", fastthink_time * 1000, fastthink_time_p)
	addLine(self, 2, "")
	addLine(self, 2, " GUI Render")
	addLine(self, 2, "  2D3D:           %7.3f ms | %5.1f%% of GF", render_time * 1000, render_time_p)
	addLine(self, 2, "  Content:        %7.3f ms | %5.1f%% of GF", rendertarget_time * 1000, rendertarget_time_p)
	addLine(self, 2, "")
	addLine(self, 2, " Lua Memory:      %7.1f MB", memory / 1024)
end


function CLASS:Render()
	local x, y = self:GetRenderPos()

	self:BuildLines()

	surface.SetFont( "DebugFixed" )
	surface.SetTextColor( g_textcol:Unpack() )

	local colW = self.colW
	local colH = self.colH

	local margin = 12
	local margin2 = margin / 2
	local margin4 = margin / 4

	do
		for i, cols in ipairs(self.debugtexttab) do
			local bg_col_w = 0
			local bg_col_h = 0

			if cols then
				for j, row in ipairs(cols) do
					row = row or ""

					local w, h = surface.GetTextSize(row)

					bg_col_w = math.max(bg_col_w, w + margin)
					bg_col_h = bg_col_h + h + 1
				end
			end

			bg_col_h = bg_col_h + margin2

			colW[i] = math.max(colW[i] or 0, bg_col_w)
			colH[i] = math.max(colH[i] or 0, bg_col_h)
		end
	end

	do
		local bg_w = 0
		local bg_h = 0

		for i, w in ipairs(colW) do
			bg_w = bg_w + w + margin4
		end

		for i, h in ipairs(colH) do
			bg_h = math.max(bg_h, h) + margin2
		end

		self.bgW = math.max(self.bgW, bg_w)
		self.bgH = math.max(self.bgH, bg_h)

		surface.SetDrawColor(g_textcolbg:Unpack())
		surface.DrawRect(x, y, self.bgW, self.bgH)
	end

	do
		local text_x = 0

		for i, cols in ipairs(self.debugtexttab) do
			local text_y = 0

			if i > 1 then
				text_x = text_x + (colW[i - 1] or 0)
			end

			local hasText = false

			if cols then
				for j, row in ipairs(cols) do
					row = row or ""

					local _, h = surface.GetTextSize(row)
					surface.SetTextPos(x + text_x + margin, y + text_y + margin2)
					surface.DrawText(row)

					text_y = text_y + h + 1
					hasText = true
				end
			end

			if not hasText then
				continue
			end

			if i > 1 then
				surface.SetDrawColor(g_textcol:Unpack())
				surface.DrawRect(x + text_x + margin2, y + margin2, 1, self.bgH - margin)
			end
		end
	end
end

function CLASS:IsInBounds(x, y)
	return false
end

function CLASS:SetModelSetup()
end

function CLASS:OnModelSetup()
end

function CLASS:ActivateNetworkedMode()
end

return true


--lua/streamradio_core/classes/ui/tooltip.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

function CLASS:Create()
	BASE.Create(self)

	self.TextPanel = self:AddPanelByClassname("text", true)
	self.TextPanel:SetPos(0, 0)
	self.TextPanel:SetSize(350, 1)
	self.TextPanel:SetAlign(TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	self.TextPanel:SetName("text")
	self.TextPanel:SetNWName("txt")
	self.TextPanel:SetSkinIdentifyer("text")
	self.TextPanel:SetStartLine(0)

	self:SetAlign(TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

	self.SkinMap["color_foreground"] = {
		set = "SetTextColor",
		get = "GetTextColor",
	}

	self.TextPanel.OnTextChange = function(pnl)
		if not IsValid(self) then return end
		self.TextPanel:FitToText(75, self:GetMaxWidth())
		self:InvalidateLayout()
		self:CallHook("OnTextChange")
	end

	self.TextPanel.OnFontChange = function(pnl)
		if not IsValid(self) then return end
		self.TextPanel:FitToText(75, self:GetMaxWidth())
		self:InvalidateLayout()
		self:CallHook("OnFontChange")
	end

	self.TextPanel.OnAlignChange = function(pnl)
		if not IsValid(self) then return end
		self:InvalidateLayout()
		self:CallHook("OnAlignChange")
	end

	if CLIENT then
		self.Colors.Main = Color(0, 0, 0, 192)
		self:SetTextColor(Color(255, 255, 255, 255))
	end

	local CalcSize = function(this, k, v)
		if k ~= "MaxWidth" then return end

		if not IsValid(self.TextPanel) then
			return
		end

		self.TextPanel:FitToText(75, v)
		self:InvalidateLayout()
	end

	self.Size = self.Size + CalcSize

	self.Clickable = false
	self.SkinAble = false

	self:SetPadding(10)
	self:SetMaxWidth(350)
	self:InvalidateLayout()
end

function CLASS:SetMaxWidth(maxw)
	self.Size.MaxWidth = math.max(maxw or 0, 75)
end

function CLASS:GetMaxWidth()
	return self.Size.MaxWidth or 0
end

function CLASS:Render()
	local text_panel = self.TextPanel
	if not IsValid(text_panel) then
		return
	end

	local x, y = self:GetRenderPos()
	local w, h = self:GetSize()

	local colText = self:GetTextColor()
	colText = colText or color_white

	local colMain = self.Colors.Main or color_black

	local thickness = 2
	local padding = 2

	surface.SetDrawColor(colText:Unpack())

	for i = 0, thickness - 1 do
		local t = i + padding
		local tt = t * 2

		surface.DrawOutlinedRect(x + t, y + t, w - tt, h - tt)
	end

	surface.SetDrawColor(colMain:Unpack())
	surface.DrawRect(x, y, w, h)

	BASE.Render(self)
end

function CLASS:PerformLayout(...)
	BASE.PerformLayout(self, ...)

	local text_panel = self.TextPanel
	if not IsValid(text_panel) then
		return
	end

	local padding = self:GetPadding()
	local w, h = text_panel:GetSize()
	local nw, nh = w + padding * 2, h + padding * 2

	self:SetSize(nw, nh)
end

function CLASS:GetTextAlign(...)
	return self:GetAlign(...)
end

function CLASS:SetTextAlign(...)
	return self:SetAlign(...)
end

function CLASS:GetAlign(...)
	return self.TextPanel:GetAlign(...)
end

function CLASS:SetAlign(...)
	return self.TextPanel:SetAlign(...)
end

function CLASS:SetText(...)
	return self.TextPanel:SetText(...)
end

function CLASS:GetText(...)
	return self.TextPanel:GetText(...)
end

function CLASS:SetFont(...)
	return self.TextPanel:SetFont(...)
end

function CLASS:GetFont(...)
	return self.TextPanel:GetFont(...)
end

function CLASS:SetTextColor(...)
	return self.TextPanel:SetColor(...)
end

function CLASS:GetTextColor(...)
	return self.TextPanel:GetColor(...)
end

function CLASS:IsInBounds(x, y)
	return false
end

function CLASS:OnModelSetup(setup)
	BASE.OnModelSetup(self, setup)

	if setup.font then
		self:SetFont(setup.font)
	end
end

return true


--lua/streamradio_core/classes/ui/list.lua:
return gluapack()()
--lua/streamradio_core/classes/ui/radio/gui_main.lua:
return gluapack()()
--lua/streamradio_core/classes/ui/radio/gui_player_controls.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

local g_mat_play = StreamRadioLib.GetPNGIcon("control_play")
local g_mat_pause = StreamRadioLib.GetPNGIcon("control_pause")
local g_mat_stop = StreamRadioLib.GetPNGIcon("control_stop")
local g_mat_back = StreamRadioLib.GetPNGIcon("control_start")
local g_mat_forward = StreamRadioLib.GetPNGIcon("control_end")
local g_mat_volumedown = StreamRadioLib.GetPNGIcon("sound_delete")
local g_mat_volumeup = StreamRadioLib.GetPNGIcon("sound_add")

-- the time bar is updated less often when the song is longer than an hour
local g_slowDisplayLength = 60 * 60

local g_mat_playback_modes = {
	[StreamRadioLib.PLAYBACK_LOOP_MODE_NONE] = StreamRadioLib.GetPNGIcon("arrow_not_refresh", true),
	[StreamRadioLib.PLAYBACK_LOOP_MODE_SONG] = StreamRadioLib.GetPNGIcon("arrow_refresh"),
	[StreamRadioLib.PLAYBACK_LOOP_MODE_PLAYLIST] = StreamRadioLib.GetPNGIcon("table_refresh"),
}

local g_tooltip_playback_modes = {
	[StreamRadioLib.PLAYBACK_LOOP_MODE_NONE] = "Change loop mode\n(currently: No loop)",
	[StreamRadioLib.PLAYBACK_LOOP_MODE_SONG] = "Change loop mode\n(currently: Song loop)",
	[StreamRadioLib.PLAYBACK_LOOP_MODE_PLAYLIST] = "Change loop mode\n(currently: Playlist loop)",
}

local g_next_playback_modes = {
	[StreamRadioLib.PLAYBACK_LOOP_MODE_NONE] = StreamRadioLib.PLAYBACK_LOOP_MODE_SONG,
	[StreamRadioLib.PLAYBACK_LOOP_MODE_SONG] = StreamRadioLib.PLAYBACK_LOOP_MODE_PLAYLIST,
	[StreamRadioLib.PLAYBACK_LOOP_MODE_PLAYLIST] = StreamRadioLib.PLAYBACK_LOOP_MODE_NONE,
}

local function FormatTime(seconds)
	seconds = tonumber(seconds or 0) or 0

	local rs, ms = math.modf(seconds)
	ms = math.floor(ms * 100)

	local s = rs % 60
	local m = math.floor((rs / 60) % 60)

	local rh = math.floor(rs / 3600)
	local h = rh % 24
	local d = math.floor(rh / 24)

	return d, h, m, s, ms
end

local function GetTimeFormated(seconds, timeScale)
	seconds = tonumber(seconds or 0) or 0
	timeScale = tonumber(timeScale or 0) or 0

	if timeScale <= 0 then
		timeScale = seconds
	end

	local d, h, m, s, ms = FormatTime(seconds)

	local scale_1m = 60
	local scale_1h = scale_1m * 60
	local scale_1d = scale_1h * 24

	if timeScale < scale_1h then
		return string.format("%01i:%02i.%02i", m, s, ms)
	end

	if timeScale < scale_1d then
		return string.format("%01i:%02i:%02i", h, m, s)
	end

	return string.format("%01i:%02i:%02i:%02i", d, h, m, s)
end

local function FormatTimeleft(time, len)
	time = time or 0
	len = len or 0

	local timef = GetTimeFormated(time, len)
	local lenf = nil

	if len > 0 then
		lenf = GetTimeFormated(len)
	end

	if lenf then
		return string.format("%s / %s" , timef, lenf)
	end

	return timef
end

function CLASS:Create()
	BASE.Create(self)

	self.StreamOBJ = nil

	self.PlayPauseButton = self:AddPanelByClassname("button", true)
	self.PlayPauseButton:SetIcon(g_mat_play)
	self.PlayPauseButton:SetName("play")
	self.PlayPauseButton:SetNWName("pl")
	self.PlayPauseButton:SetSkinIdentifyer("button")
	self.PlayPauseButton.DoClick = function()
		local stream = self.StreamOBJ
		if not IsValid(stream) then return end

		if stream:IsKilled() then
			stream:ReviveStream()
		end

		local isPlayMode = stream:IsPlayMode()

		if isPlayMode then
			self:CallHook("OnPause")
			stream:Pause()
			return
		end

		self:TriggerPlay()
	end

	self.BackButton = self:AddPanelByClassname("button", true)
	self.BackButton:SetIcon(g_mat_back)
	self.BackButton:SetName("back")
	self.BackButton:SetNWName("bk")
	self.BackButton:SetSkinIdentifyer("button")
	self.BackButton:SetTooltip("Previous track")
	self.BackButton.DoClick = function()
		self:CallHook("OnPlaylistBack")
	end

	self.ForwardButton = self:AddPanelByClassname("button", true)
	self.ForwardButton:SetIcon(g_mat_forward)
	self.ForwardButton:SetName("forward")
	self.ForwardButton:SetNWName("fw")
	self.ForwardButton:SetSkinIdentifyer("button")
	self.ForwardButton:SetTooltip("Next track")
	self.ForwardButton.DoClick = function()
		self:CallHook("OnPlaylistForward")
	end

	self.StopButton = self:AddPanelByClassname("button", true)
	self.StopButton:SetIcon(g_mat_stop)
	self.StopButton:SetName("stop")
	self.StopButton:SetNWName("sp")
	self.StopButton:SetSkinIdentifyer("button")
	self.StopButton:SetTooltip("Stop playback")
	self.StopButton.DoClick = function()
		if not IsValid(self.StreamOBJ) then return end
		self:CallHook("OnStop")
		self.StreamOBJ:Stop()
	end

	self.VolumeDownButton = self:AddPanelByClassname("button", true)
	self.VolumeDownButton:SetIcon(g_mat_volumedown)
	self.VolumeDownButton:SetName("volumedown")
	self.VolumeDownButton:SetNWName("vdn")
	self.VolumeDownButton:SetSkinIdentifyer("button")
	self.VolumeDownButton:SetTooltip("Decrease volume")
	self.VolumeDownButton.OnMousePressed = function()
		if CLIENT then return end
		if not IsValid(self.StreamOBJ) then return end

		local newvol = self.StreamOBJ:GetVolume()
		newvol = newvol - 0.1
		newvol = math.Clamp(newvol, 0, 1)

		self.StreamOBJ:SetVolume(newvol)
		self:CallHook("OnVolumeDown", newvol)
	end

	self.VolumeUpButton = self:AddPanelByClassname("button", true)
	self.VolumeUpButton:SetIcon(g_mat_volumeup)
	self.VolumeUpButton:SetName("volumeup")
	self.VolumeUpButton:SetNWName("vup")
	self.VolumeUpButton:SetSkinIdentifyer("button")
	self.VolumeUpButton:SetTooltip("Increase volume")
	self.VolumeUpButton.OnMousePressed = function()
		if CLIENT then return end
		if not IsValid(self.StreamOBJ) then return end

		local newvol = self.StreamOBJ:GetVolume()
		newvol = newvol + 0.1
		newvol = math.Clamp(newvol, 0, 1)

		self.StreamOBJ:SetVolume(newvol)
		self:CallHook("OnVolumeUp", newvol)
	end

	self.VolumeUpButton.DoClick = function(this)
		this.IsPressed = true
		this.LastClickTime = RealTime()
		this:OnMousePressed()
	end

	self.VolumeUpButton.OnMouseReleased = function(this)
		this.IsPressed = nil
		this.LastClickTime = nil
	end

	self.VolumeUpButton.Think = function(this)
		if not this.IsPressed then
			return
		end

		local lastclicktime = this.LastClickTime or 0
		local clickdistance = RealTime() - lastclicktime

		if clickdistance <= 0.5 then
			return
		end

		this.LastClickTime = RealTime() - 0.45
		this:CallHook("OnMousePressed")
	end

	self.VolumeDownButton.DoClick = self.VolumeUpButton.DoClick
	self.VolumeDownButton.OnMouseReleased = self.VolumeUpButton.OnMouseReleased
	self.VolumeDownButton.Think = self.VolumeUpButton.Think

	self.PlaybackLoopModeButton = self:AddPanelByClassname("button", true)
	self.PlaybackLoopModeButton:SetName("playback-mode")
	self.PlaybackLoopModeButton:SetNWName("pm")
	self.PlaybackLoopModeButton:SetSkinIdentifyer("button")

	self.PlaybackLoopModeButton.DoClick = function()
		local loopMode = self._currentLoopMode or StreamRadioLib.PLAYBACK_LOOP_MODE_NONE
		local newLoopMode = g_next_playback_modes[loopMode] or StreamRadioLib.PLAYBACK_LOOP_MODE_NONE

		self:CallHook("OnPlaybackLoopModeChange", newLoopMode)
	end

	self.Buttons = {}
	table.insert(self.Buttons, self.PlayPauseButton)
	table.insert(self.Buttons, self.StopButton)
	table.insert(self.Buttons, self.BackButton)
	table.insert(self.Buttons, self.ForwardButton)
	table.insert(self.Buttons, self.VolumeDownButton)
	table.insert(self.Buttons, self.VolumeUpButton)
	table.insert(self.Buttons, self.PlaybackLoopModeButton)

	self.PlayBar = self:AddPanelByClassname("progressbar", true)
	self.PlayBar:SetName("progressbar")
	self.PlayBar:SetNWName("pbar")
	self.PlayBar:SetSkinIdentifyer("progressbar")
	self.PlayBar.FractionChangeText = function(this, v)
		local stream = self.StreamOBJ
		if not IsValid(stream) then return end

		if stream:GetMuted() then
			return "Muted"
		end

		if stream:IsKilled() then
			return "Sound stopped!"
		end

		if stream:IsCheckingUrl() then
			return "Checking URL..."
		end

		if stream:IsDownloading() then
			return "Downloading..."
		end

		if stream:IsLoading() then
			return "Loading..."
		end

		if stream:IsBuffering() then
			return "Buffering..."
		end

		if stream:HasError() then
			return "Error!"
		end

		if stream:IsStopMode() then
			return "Stopped"
		end

		local len = stream:GetLength()
		local time = stream:GetTime()

		return FormatTimeleft(time, len)
	end

	-- @TODO: Fix that seaking is CLIENT -> SERVER instead if SERVER -> CLIENT
	self.PlayBar.OnFractionChangeEdit = function(this, v)
		local stream = self.StreamOBJ
		if not IsValid(stream) then return end

		local noise = math.random() * 0.00001
		local len = stream:GetMasterLength()

		-- add a minimal noise to the value, so we force the change in any case
		stream:SetTime(len * v - noise, true)
	end

	self.State = self:CreateListener({
		PlaylistEnabled = true,
	}, function(this, k, v)
		if IsValid(self.BackButton) then
			self.BackButton:SetVisible(v)
		end

		if IsValid(self.ForwardButton) then
			self.ForwardButton:SetVisible(v)
		end

		self:UpdatePlaybackLoopMode(self._currentLoopMode)
		self:InvalidateLayout()
	end)

	self:UpdatePlaybackLoopMode()
	self:UpdatePlayBar()

	self.PlayBar:SetSize(1, 1)

	if CLIENT then
		self:StartFastThink()
	end

	self:InvalidateLayout()
end

function CLASS:PerformLayout(...)
	BASE.PerformLayout(self, ...)

	local w, h = self:GetClientSize()

	local margin = self:GetMargin()
	local minbarw = (h + margin) * 1.618 * 2
	local buttoncount = 0
	local buttonw = h
	local buttonh = h
	local wpos = 0
	local hpos = 0
	local hasplaybar = IsValid(self.PlayBar) and self.PlayBar.Layout.Visible
	local buttons = self.Buttons or {}

	for k, v in ipairs(buttons) do
		if not IsValid(v) then continue end
		if not v.Layout.Visible then continue end

		wpos = wpos + buttonw + margin
		buttoncount = buttoncount + 1
	end

	local barw = w - wpos
	local oneline = hasplaybar and (barw > minbarw or w > ((h + margin) * buttoncount))
	local hasbuttons = buttoncount > 0

	wpos = 0
	if oneline then
		if barw < minbarw and hasbuttons then
			barw = 0
			hasplaybar = false
			buttonw = (w - margin * (buttoncount - 1)) / buttoncount
		end

		for k, v in ipairs(buttons) do
			if not IsValid(v) then continue end
			if not v.Layout.Visible then continue end

			v:SetSize(buttonw, buttonh)
			v:SetPos(wpos, hpos)

			wpos = wpos + buttonw + margin
		end
	else
		buttonw = 0
		barw = w

		if hasbuttons then
			buttonw = (w - margin * (buttoncount - 1)) / buttoncount
			if hasplaybar then
				buttonh = (h - margin) / 2
			end
		end

		hpos = hasplaybar and buttonh + margin or 0

		for k, v in ipairs(buttons) do
			if not IsValid(v) then continue end
			if not v.Layout.Visible then continue end

			v:SetSize(buttonw, buttonh)
			v:SetPos(wpos, hpos)

			wpos = wpos + buttonw + margin
		end

		wpos = 0
	end

	local barh = h
	if hasbuttons and not oneline then
		barh = buttonh
	end

	if IsValid(self.PlayBar) then
		self.PlayBar:SetSize(barw, barh)
		self.PlayBar:SetPos(wpos, 0)
	end
end

function CLASS:Remove()
	if IsValid(self.StreamOBJ) then
		self.StreamOBJ:RemoveEvent("OnTrackEnd", self:GetID())
		self.StreamOBJ:RemoveEvent("OnVolumeChange", self:GetID())
		self.StreamOBJ:RemoveEvent("OnPlayModeChange", self:GetID())

		if CLIENT then
			self.StreamOBJ:RemoveEvent("OnSeekingStart", self:GetID())
			self.StreamOBJ:RemoveEvent("OnSeekingEnd", self:GetID())
			self.StreamOBJ:RemoveEvent("OnMute", self:GetID())
			self.StreamOBJ:RemoveEvent("OnClose", self:GetID())

			self.StreamOBJ:RemoveEvent("OnSearch", self:GetID())
			self.StreamOBJ:RemoveEvent("OnConnect", self:GetID())
			self.StreamOBJ:RemoveEvent("OnError", self:GetID())
		end
	end

	BASE.Remove(self)
end

function CLASS:UpdateButtons()
	local stream = self.StreamOBJ
	if not IsValid(stream) then return end

	local isPlayMode = stream:IsPlayMode()
	local isStopMode = stream:IsStopMode()

	local syncMode = self:GetSyncMode()

	if IsValid(self.PlayPauseButton) then
		self.PlayPauseButton:SetIcon(isPlayMode and g_mat_pause or g_mat_play)
		self.PlayPauseButton:SetTooltip(isPlayMode and "Pause playback" or "Start playback")
		self.PlayPauseButton:SetDisabled(syncMode)
	end

	if IsValid(self.StopButton) then
		self.StopButton:SetDisabled(isStopMode or syncMode)
	end
end

function CLASS:UpdatePlayBar()
	if SERVER then return end

	if not IsValid(self.PlayBar) then
		return
	end

	if not self.PlayBar:IsVisibleSimple() then
		return
	end

	self.PlayBar:UpdateText()
end

function CLASS:SetStream(stream)
	if self.StreamOBJ == stream then
		return
	end

	self.StreamOBJ = stream

	self:SetFastThinkRate(0)

	self:UpdateFromStream()
	self:UpdateButtons()
	self:UpdatePlayBar()

	if not IsValid(stream) then return end

	stream:SetEvent("OnTrackEnd", self:GetID(), function()
		if not IsValid(self) then return end
		if not IsValid(stream) then return end

		self:QueueCall("UpdatePlayBar")
		self:QueueCall("UpdateButtons")
	end)

	local function OnVolumeChange(this, vol)
		if not IsValid(self) then return end

		if IsValid(self.VolumeUpButton) then
			self.VolumeUpButton:SetDisabled(vol >= 1)
		end

		if IsValid(self.VolumeDownButton) then
			self.VolumeDownButton:SetDisabled(vol <= 0)
		end
	end

	local function OnPlayModeChange(this, mode)
		if not IsValid(self) then return end
		if not IsValid(stream) then return end

		local isPlayMode = stream:IsPlayMode()
		local isStopMode = stream:IsStopMode()

		if IsValid(self.PlayPauseButton) then
			self.PlayPauseButton:SetIcon(isPlayMode and g_mat_pause or g_mat_play)
			self.PlayPauseButton:SetTooltip(isPlayMode and "Pause playback" or "Start playback")
		end

		if IsValid(self.StopButton) then
			self.StopButton:SetDisabled(isStopMode or self:GetSyncMode())
		end

		self:QueueCall("UpdatePlayBar")
		self:QueueCall("UpdateButtons")
	end

	stream:SetEvent("OnVolumeChange", self:GetID(), OnVolumeChange)
	stream:SetEvent("OnPlayModeChange", self:GetID(), OnPlayModeChange)

	if CLIENT then
		local function UpdatePlayBar()
			if not IsValid(self) then
				return false
			end

			-- Force the think hook to call once when the stream state changes.
			self:SetFastThinkRate(0)

			self:QueueCall("UpdateButtons")
			self:QueueCall("UpdatePlayBar")

			return true
		end

		stream:SetEvent("OnSeekingStart", self:GetID(), UpdatePlayBar)
		stream:SetEvent("OnSeekingEnd", self:GetID(), UpdatePlayBar)
		stream:SetEvent("OnMute", self:GetID(), UpdatePlayBar)
		stream:SetEvent("OnClose", self:GetID(), UpdatePlayBar)

		stream:SetEvent("OnDownload", self:GetID(), UpdatePlayBar)
		stream:SetEvent("OnRetry", self:GetID(), UpdatePlayBar)
		stream:SetEvent("OnSearch", self:GetID(), UpdatePlayBar)
		stream:SetEvent("OnConnect", self:GetID(), UpdatePlayBar)
		stream:SetEvent("OnError", self:GetID(), UpdatePlayBar)
	end

	OnVolumeChange(stream, stream:GetVolume())
	OnPlayModeChange(stream)
end

function CLASS:GetStream()
	return self.StreamOBJ
end

function CLASS:UpdateFromStream()
	local StreamOBJ = self.StreamOBJ
	if not IsValid(StreamOBJ) then return end

	local len = StreamOBJ:GetLength()
	local time = StreamOBJ:GetTime()

	local isEndlessOrNoStream = StreamOBJ:IsEndless() or StreamOBJ:IsLoading() or StreamOBJ:HasError() or StreamOBJ:GetMuted() or StreamOBJ:IsKilled()

	-- @TODO: Fix that seaking is CLIENT -> SERVER instead if SERVER -> CLIENT.
	--        That's because self.PlayBar is disabled on the server as BASS streams don't exist on servers.
	--        Thus these checks below are buggy and will be fixed some day. It is difficult to fix right now.

	if IsValid(self.PlayBar) and self.PlayBar:IsVisibleSimple() then
		if isEndlessOrNoStream then
			self.PlayBar:SetFraction(0)
			self.PlayBar:SetAllowFractionEdit(false)
			self.PlayBar:SetDisabled(self:GetSyncMode())
		else
			self.PlayBar:SetFraction(time / len)
			self.PlayBar:SetAllowFractionEdit(StreamOBJ:CanSeek())
			self.PlayBar:SetDisabled(self:GetSyncMode() or not StreamOBJ:CanSeek())
		end
	end
end

function CLASS:ShouldPerformRerender()
	if SERVER then return false end

	local stream = self.StreamOBJ
	if not IsValid(stream) then return false end

	if not IsValid(self.PlayBar) then
		return false
	end

	if not self.PlayBar:IsVisibleSimple() then
		return false
	end

	if stream:GetMuted() then
		return false
	end

	if stream:IsKilled() then
		return false
	end

	if stream:HasError() then
		return false
	end

	if not stream:IsPlaying() then
		return false
	end

	return true
end

if CLIENT then
	function CLASS:FastThink()
		self.fastThinkRate = 10

		local stream = self.StreamOBJ
		if not IsValid(stream) then return end

		self.fastThinkRate = 0.25

		if not self:IsSeen() then return end
		if not self:IsVisible() then return end

		if stream:IsPlayMode() and not stream:IsKilled() then
			local len = stream:GetLength()

			if len < g_slowDisplayLength or stream:IsSeeking() then
				self.fastThinkRate = 0.05
			end
		end

		self:UpdateFromStream()

		if not self:ShouldPerformRerender() then return end

		self:UpdatePlayBar()
		self:PerformRerender(true)
	end
end

function CLASS:EnablePlaylist(bool)
	self.State.PlaylistEnabled = bool
end

function CLASS:IsPlaylistEnabled()
	return self.State.PlaylistEnabled or false
end

function CLASS:TriggerPlay()
	local stream = self.StreamOBJ

	if not IsValid(stream) then return end

	if stream:IsKilled() then
		stream:ReviveStream()
	end

	local isPlayMode = stream:IsPlayMode()

	if isPlayMode then
		return
	end

	local hasEnded = stream:HasEnded()

	self:CallHook("OnPlay")
	stream:Play(hasEnded)

	if hasEnded then
		stream:SetTime(0, true)
	end
end

function CLASS:UpdatePlaybackLoopMode(loopMode)
	loopMode = loopMode or StreamRadioLib.PLAYBACK_LOOP_MODE_NONE
	self._currentLoopMode = loopMode

	if IsValid(self.PlaybackLoopModeButton) then
		self.PlaybackLoopModeButton:SetIcon(g_mat_playback_modes[loopMode])
		self.PlaybackLoopModeButton:SetTooltip(g_tooltip_playback_modes[loopMode])

		local antiSpamTime = 1

		self.PlaybackLoopModeButton:SetDisabled(true)

		self:TimerOnce("PlaybackLoopModeButtonAntiSpam", antiSpamTime, function()
			if not IsValid(self.PlaybackLoopModeButton) then
				return
			end

			self.PlaybackLoopModeButton:SetDisabled(false)
		end)
	end

	local StreamOBJ = self.StreamOBJ

	if not IsValid(StreamOBJ) then
		return
	end

	if not StreamOBJ:HasEnded() then
		local time = StreamOBJ:GetMasterTime()

		-- make sure we reapply the time between mode changes, so it prevents jumping
		StreamOBJ:SetTime(time, true)
	else
		if loopMode ~= StreamRadioLib.PLAYBACK_LOOP_MODE_NONE then
			self:TriggerPlay()
		end
	end
end

function CLASS:SetSyncMode(bool)
	self._syncmode = bool or false

	if not IsValid(self.StreamOBJ) then return end

	if IsValid(self.BackButton) then
		self.BackButton:SetDisabled(bool)
	end

	if IsValid(self.ForwardButton) then
		self.ForwardButton:SetDisabled(bool)
	end

	if IsValid(self.PlaybackLoopModeButton) then
		self.PlaybackLoopModeButton:SetDisabled(bool)
	end

	if IsValid(self.PlayBar) then
		self.PlayBar:SetDisabled(bool)
	end

	self:UpdateButtons()
	self:UpdatePlayBar()
end

function CLASS:GetSyncMode()
	return self._syncmode or false
end

return true


--lua/streamradio_core/classes/rendertarget.lua:
if SERVER then
	CLASS = nil
	return true
end

local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()
local g_classname = CLASS:GetClassname()

local catchAndErrorNoHaltWithStack = StreamRadioLib.Util.CatchAndErrorNoHaltWithStack

local g_RenderTargetsCache = {}

local function next2power(value)
	value = value or 0
	if value <= 0 then return 0 end

	return math.ceil(2 ^ math.ceil(math.log(value) / math.log(2)))
end

local function GetRenderTargetMaterial(tex)
	if not tex then
		return nil
	end

	if tex:IsError() then
		return nil
	end

	local name = tex:GetName()

	local materialParameters = {
		["$basetexture"] = name,
		["$vertexcolor"] = 1,
		["$vertexalpha"] = 1,
		["$nocull"] = 1,
		["$nolod"] = 1,
		["$selfillum"] = 1,
		["$translucent"] = 1,
	}

	local mat = CreateMaterial( name, "UnlitGeneric", materialParameters )

	if not mat then
		return nil
	end

	mat:Recompute()
	return mat
end

local function GetCacheForSize(w, h)
	w = w or 0
	h = h or 0

	if w <= 0 then
		return nil
	end

	if h <= 0 then
		return nil
	end

	g_RenderTargetsCache[w] = g_RenderTargetsCache[w] or {}
	g_RenderTargetsCache[w][h] = g_RenderTargetsCache[w][h] or {}

	return g_RenderTargetsCache[w][h]
end

local function GetCacheCountForSize(w, h)
	local cache = GetCacheForSize(w, h)

	if not cache then
		return 0
	end

	return #cache
end

local function FreeCache(w, h, index)
	local cache = GetCacheForSize(w, h)
	if not cache then return end
	if not cache[index] then return end

	cache[index].free = true
end

local function UnfreeCache(w, h, index)
	local cache = GetCacheForSize(w, h)
	if not cache then return end
	if not cache[index] then return end

	cache[index].free = false
end

local function GetRendertargetName(w, h, index)
	w = w or 0
	h = h or 0

	if w <= 0 then
		return nil
	end

	if h <= 0 then
		return nil
	end

	index = index or GetCacheCountForSize(w, h)

	local name = string.format("3dstreamradio-rt_cls-%s_%ix%i_id-%i", g_classname, w, h, index)
	name = string.lower(name or "")
	name = string.Trim(name)
	name = string.gsub(name, "[%s\\.]", "_" )

	return name
end

function CLASS:Create()
	BASE.Create(self)

	local CreateRendertarget = function(this, key, value)
		if key == "Framerate" then return end

		if key == "Disabled" and value then
			self:Free()
			self._RT = nil

			self:CallHook("OnRendertargetRemove")
			return
		end

		self._RT = self:CreateRendertarget()

		if self._RT then
			self:CallHook("OnRendertargetCreate")
		else
			self:CallHook("OnRendertargetRemove")
		end
	end

	self.Size = self:CreateListener({
		w = 0,
		h = 0,
	}, CreateRendertarget)

	self.Pos = self:CreateListener({
		x = 0,
		y = 0,
	}, function()
		self:CallHook("OnPosChange")
	end)

	self.Settings = self:CreateListener({
		Framerate = 0,
		Disabled = false,
	}, CreateRendertarget)
end

function CLASS:Initialize()
	BASE.Initialize(self)

	self._RT = self:CreateRendertarget()

	if self._RT then
		self:CallHook("OnRendertargetCreate")
	else
		self:CallHook("OnRendertargetRemove")
	end

	self:Update()
end

function CLASS:GetCache()
	local w, h = self:GetSize()
	local cache = GetCacheForSize(w, h)

	if not cache then
		return nil
	end

	for i, v in ipairs(cache) do
		if not v.free then continue end
		if not v.tex then continue end
		if not v.mat then continue end

		local out = {
			mat = v.mat,
			tex = v.tex,
			index = i
		}

		return out
	end

	return nil
end

function CLASS:SetCache(mat, tex)
	if not mat then return nil end
	if not tex then return nil end

	local w, h = self:GetSize()
	local cache = GetCacheForSize(w, h)

	if not cache then
		return nil
	end

	local rt = {}

	rt.mat = mat
	rt.tex = tex
	rt.free = true

	table.insert(cache, rt)

	local out = {
		mat = mat,
		tex = tex,
		index = #cache
	}

	return out
end

function CLASS:GetCacheCount()
	local w, h = self:GetSize()
	return GetCacheCountForSize(w, h)
end

function CLASS:Free()
	local w, h = self:GetSize()
	self:Clear()

	local rt = self._RT
	if not rt then return end

	FreeCache(w, h, rt.index)
end

function CLASS:GetMaxCacheCount()
	return self:GetGlobalVar("rendertarget_MaxCacheCount", 0)
end

function CLASS:SetMaxCacheCount(value)
	value = value or 0

	if value <= 0 then
		value = 0
	end

	return self:SetGlobalVar("rendertarget_MaxCacheCount", value)
end


function CLASS:CreateRendertarget()
	if not self.Valid then
		return nil
	end

	if not self.Created then
		return nil
	end

	if self:IsDisabled() then
		return nil
	end

	local w, h = self:GetSize()

	if w <= 0 then
		return nil
	end

	if h <= 0 then
		return nil
	end

	local rt = self:GetCache()
	if rt then
		UnfreeCache(w, h, rt.index)
		return rt
	end

	local name = GetRendertargetName(w, h)
	if not name then return nil end

	local maxcount = self:GetMaxCacheCount()
	if maxcount > 0 and self:GetCacheCount() > maxcount then
		return nil
	end

	-- No ENUMS for thise values are available in the game.
	-- https://wiki.facepunch.com/gmod/Enums/TEXTUREFLAGS
	local textureFlags = bit.bor(
		4,    -- TEXTUREFLAGS_CLAMPS
		8,    -- TEXTUREFLAGS_CLAMPT
		16,   -- TEXTUREFLAGS_ANISOTROPIC
		32,   -- TEXTUREFLAGS_HINT_DXT5
		512,  -- TEXTUREFLAGS_NOLOD
		8192, -- TEXTUREFLAGS_EIGHTBITALPHA
		32768 -- TEXTUREFLAGS_RENDERTARGET
	)

	local tex = GetRenderTargetEx(
		name, w, h,
		RT_SIZE_NO_CHANGE,
		MATERIAL_RT_DEPTH_SEPARATE,
		textureFlags,
		0,
		IMAGE_FORMAT_RGBA8888
	)

	local mat = GetRenderTargetMaterial(tex)

	rt = self:SetCache(mat, tex)
	if not rt then
		return nil
	end

	render.PushRenderTarget( tex )
		render.Clear( 0, 0, 0, 0, true )
	render.PopRenderTarget( )

	UnfreeCache(w, h, rt.index)
	return rt
end

function CLASS:Update()
	if not self._RT then return false end
	if self:IsDisabled() then return false end

	local now = SysTime()
	local framerate = self.Settings.Framerate or 0
	local min_rtframetime = 1 / math.max(framerate, 2)
	local renderNextTime = self._renderNextTime or 0

	if renderNextTime > now then
		return false
	end

	local w, h = self:GetSize()

	self:ProfilerStart("Render")
	render.PushRenderTarget(self._RT.tex, 0, 0, w, h)
		render.Clear(0, 0, 0, 0, true)
		cam.Start2D()
			catchAndErrorNoHaltWithStack(self.CallHook, self, "OnRender")
		cam.End2D()
	render.PopRenderTarget()
	self:ProfilerEnd("Render")

	self._renderNextTime = now + min_rtframetime
	return true
end

function CLASS:Remove()
	self:Free()
	self._RT = nil
	self:CallHook("OnRendertargetRemove")

	BASE.Remove(self)
end

function CLASS:Clear()
	if not self._RT then return end
	if self:IsDisabled() then return end

	local rt = self._RT
	local tex = rt.tex

	render.PushRenderTarget( tex )
		render.Clear( 0, 0, 0, 0, true )
	render.PopRenderTarget( )
end

function CLASS:Render()
	if not self._RT then return end
	if self:IsDisabled() then return end

	local rt = self._RT
	local mat = rt.mat

	local x, y = self:GetPos()
	local w, h = self:GetSize()

	surface.SetMaterial(mat)
	surface.DrawTexturedRectUV(x, y, w, h, 0, 0, 1, 1)
end

function CLASS:SetSize(w, h)
	self.Size.w = next2power(w)
	self.Size.h = next2power(h)
end

function CLASS:GetSize()
	if not self.Size then return 0, 0 end
	return self.Size.w or 0, self.Size.h or 0
end

function CLASS:GetWidth()
	return self.Size.w or 0
end

function CLASS:GetHeight()
	return self.Size.h or 0
end

function CLASS:SetPos(x, y)
	self.Pos.x = x or 0
	self.Pos.y = y or 0
end

function CLASS:GetPos()
	return self.Pos.x or 0, self.Pos.y or 0
end

function CLASS:SetPosX(x)
	self.Pos.x = x or 0
end

function CLASS:GetPosX()
	return self.Pos.x or 0
end

function CLASS:SetPosY(y)
	self.Pos.y = y or 0
end

function CLASS:GetPosY()
	return self.Pos.y or 0
end

function CLASS:GetRendertargetName()
	local rt = self._RT

	if not rt then
		return nil
	end

	local w, h = self:GetSize()

	return GetRendertargetName(w, h, rt.index)
end

function CLASS:HasRendertarget()
	if not self.Valid then return false end
	if self:IsDisabled() then return false end
	if self._RT then return true end
	return false
end

function CLASS:GetRendertarget()
	if not self.Valid then return nil end
	if self:IsDisabled() then return nil end
	return self._RT
end

function CLASS:GetTexture()
	if not self.Valid then return nil end
	if self:IsDisabled() then return nil end
	if not self._RT then return nil end
	return self._RT.tex
end

function CLASS:GetMaterial()
	if not self.Valid then return nil end
	if self:IsDisabled() then return nil end
	if not self._RT then return nil end
	return self._RT.mat
end

function CLASS:IsDisabled()
	if not self.Settings then return true end
	return self.Settings.Disabled or false
end

function CLASS:IsEnabled()
	if not self.Settings then return false end
	return not self.Settings.Disabled
end

function CLASS:SetEnabled(bool)
	if not self.Settings then return end
	self.Settings.Disabled = not bool
end

function CLASS:SetDisabled(bool)
	if not self.Settings then return end
	self.Settings.Disabled = bool or false
end

function CLASS:GetFramerate()
	if not self.Settings then return 0 end
	return self.Settings.Framerate or 0
end

function CLASS:SetFramerate(rate)
	if not self.Settings then return end
	self.Settings.Framerate = rate or 0
end

function CLASS:__tostring()
	local name = self:GetRendertargetName() or "no rendertarget"
	if not self:HasRendertarget() then
		name = "no rendertarget"
	end

	return string.format("[%s][%s]", self.classname, name)
end

function CLASS:__eg(other)
	if self:GetRendertargetName() ~= other:GetRendertargetName() then
		return false
	end

	return true
end

return true


--lua/streamradio_core/print.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Print = StreamRadioLib.Print or {}

local LIB = StreamRadioLib.Print
table.Empty(LIB)

local LIBString = StreamRadioLib.String

function LIB.Format(format, ...)
	format = tostring(format or "")
	if format == "" then return "" end

	local empty = table.IsEmpty({...})
	if empty then
		return format
	end

	local result = string.format(format, ...)
	return result
end

function LIB.Debug(format, ...)
	if not StreamRadioLib.Util.IsDebug() then return end

	local msgstring = LIB.Format(format, ...)
	msgstring = string.Trim(msgstring)

	if msgstring == "" then return end

	msgstring = LIBString.NormalizeNewlines(msgstring, "\n")
	msgstring = LIBString.IndentTextBlock(msgstring, 1, "  ")

	msgstring = string.Trim(StreamRadioLib.AddonPrefix .. msgstring) .. "\n"

	local hasVr = StreamRadioLib.VR.IsActive()

	local lines = string.Explode("\n", msgstring, false)
	for i, line in ipairs(lines) do
		if hasVr then
			StreamRadioLib.VR.Debug(line)
		else
			MsgN(line)
		end
	end
end

function LIB.Msg(ply, format, ...)
	local msgstring = LIB.Format(format, ...)
	msgstring = string.Trim(msgstring)

	if msgstring == "" then return end

	msgstring = LIBString.NormalizeNewlines(msgstring, "\n")
	msgstring = LIBString.IndentTextBlock(msgstring, 1, "  ")

	msgstring = string.Trim(StreamRadioLib.AddonPrefix .. msgstring) .. "\n"

	local hasPly = IsValid(ply)

	local lines = string.Explode("\n", msgstring, false)
	for i, line in ipairs(lines) do
		if hasPly then
			ply:PrintMessage(HUD_PRINTTALK, line)
		else
			MsgN(line)
		end
	end
end

function LIB.GetPlayerString(ply)
	local playerStr = ""

	if IsValid(ply) then
		playerStr = string.format("%s (%s)", ply:Name(), ply:SteamID())
	end

	return playerStr
end

local g_colorSeparator = Color(255, 255, 255)
local g_colorDateTime = Color(180, 180, 180)
local g_colorAddonName = Color(0, 200, 0)
local g_colorPlayer = Color(200, 200, 0)

function LIB.Log(ply, format, ...)
	local msgstring = LIB.Format(format, ...)
	msgstring = string.Trim(msgstring)

	if msgstring == "" then return end

	local playerStr = LIB.GetPlayerString(ply)

	local Timestamp = os.time()
	local TimeString = os.date("%Y-%m-%d %H:%M:%S" , Timestamp)

	MsgC(g_colorSeparator, "[")
	MsgC(g_colorDateTime, TimeString)
	MsgC(g_colorSeparator, "]")

	MsgC(g_colorSeparator, "[")
	MsgC(g_colorAddonName, StreamRadioLib.AddonTitle)
	MsgC(g_colorSeparator, "]")

	if playerStr ~= "" then
		MsgC(g_colorSeparator, "[")
		MsgC(g_colorPlayer, playerStr)
		MsgC(g_colorSeparator, "]")
	end

	Msg(" ")

	MsgN(msgstring)
end

local g_oldfloat = 0

function LIB.PrintFloatBar( float, len, ... )
	local float = math.Clamp( float, 0, 1 )
	local str = ""

	if float >= g_oldfloat then
		g_oldfloat = float
	end

	local bar = math.Round(float * len)
	local space = len - math.Round(float * len)
	local space1 = math.Round((g_oldfloat - float) * len)

	local space2 = space - space1 - 1
	str = string.rep("#", bar) .. string.rep(" ", space1) .. (math.Round(g_oldfloat * len) < len and "|" or "") .. string.rep(" ", space2)
	MsgC(Color(510 * float, 510 * (1 - float), 0, 255), str, " ", string.format("% 7.2f%%\t", float * 100), ..., "\n")

	if float < g_oldfloat then
		g_oldfloat = g_oldfloat - 0.5 * RealFrameTime()
	end

	return str
end

return true


--lua/streamradio_core/client/settings/admin.lua:
return gluapack()()
--lua/streamradio_core/client/cl_surface.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Surface = StreamRadioLib.Surface or {}

local LIB = StreamRadioLib.Surface
table.Empty(LIB)

local g_font_template = {
	font = "Arial",
	size = 0,
	weight = 0,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false
}

local LoadingMat = StreamRadioLib.GetCustomPNG("loading")

local pi = math.pi
local color_white = color_white

function LIB.Loading( x, y, w, h, color, cycles )
	surface.SetMaterial( LoadingMat )
	color = color or color_white
	cycles = math.floor( cycles or 0 )

	if cycles < 5 then
		cycles = 5
	end

	local time = RealTime( )
	local midw = w / 2
	local midh = h / 2
	local cw = w / cycles * 2
	local ch = h / cycles * 2

	for i = 1, cycles do
		--local posang = pi * 2 / cycles * i + time
		local cx = math.cos( pi * 2 / cycles * i + time ) * ( midw - cw / 2 ) + x - cw / 2 + midw
		local cy = math.sin( pi * 2 / cycles * i + time ) * ( midh - cw / 2 ) + y - ch / 2 + midh
		surface.SetDrawColor( color:Unpack() )
		surface.DrawTexturedRect( cx, cy, cw, ch )
	end
end

LIB._CreatedFonts = LIB._CreatedFonts or {}

function LIB.AddFont(size, weight, baseFontName, additionalData)
	local ft = g_font_template

	size = tonumber(size) or ft.size
	weight = tonumber(weight) or ft.weight
	baseFontName = tostring(baseFontName or ft.font)
	additionalData = additionalData or {}

	local additionalDataName = {}
	local additionalDataNameEmpty = true

	for k, v in SortedPairs(additionalData or {}) do
		if v == g_font_template[k] then
			continue
		end

		local name = string.format("[%s=%s]", tostring(k), tostring(v))
		table.insert(additionalDataName, name)

		additionalDataNameEmpty = false
	end

	if additionalDataNameEmpty then
		additionalDataName = ""
	else
		additionalDataName = table.concat(additionalDataName)
		additionalDataName = util.MD5(additionalDataName)
	end

	local ID = string.format("3DStreamRadio_Font_[%s][%d][%d][%s]", baseFontName, size, weight, additionalDataName)

	if LIB._CreatedFonts[ID] then
		return ID
	end

	local font = table.Copy(ft)

	for k, v in pairs(additionalData or {}) do
		font[k] = v
	end

	font.size = size
	font.weight = weight
	font.font = base

	surface.CreateFont(ID, font)

	LIB._CreatedFonts[ID] = true
	return ID
end

return true


--lua/streamradio_core/client/cl_playlist_edit.lua:
return gluapack()()
--lua/streamradio_core/client/cl_playlist_edit.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Editor = StreamRadioLib.Editor or {}

local LIB = StreamRadioLib.Editor
table.Empty(LIB)

local LIBNet = StreamRadioLib.Net

local g_listenPath = ""

local g_callbackFunc = nil
local g_callbackArgs = {}
local g_callbackObj = nil

function LIB.ListenToPath( path )
	g_listenPath = tostring( path or "" )

	return g_listenPath
end

function LIB.GetListenPath( )
	return g_listenPath
end

function LIB.CreateDir( path )
	if not path then return false end
	if path == "" then return false end

	LIBNet.Start("Editor_Request_Playlist")
	net.WriteUInt( 0, 4 )
	net.WriteString( path )
	net.SendToServer( )

	return true
end

function LIB.Save( path, DataTab )
	if not path then return false end
	if path == "" then return false end

	if not DataTab then return false end
	if not DataTab["format"] then return false end
	if StreamRadioLib.Filesystem.IsFolder(DataTab["format"]) then return false end

	local ply = LocalPlayer()
	if not IsValid(ply) then return false end
	if not ply:IsAdmin() then return false end

	--Start
	LIBNet.Start("Editor_Request_Playlist")
	net.WriteUInt(1, 4)
	net.WriteString(path)
	net.SendToServer()

	StreamRadioLib.TimedpairsStop( "Editor_SaveFile_" .. path )
	StreamRadioLib.Timedpairs( "Editor_SaveFile_" .. path, DataTab, 1, function( k, v )
		if not IsValid(ply) then return false end
		if not ply:IsAdmin() then return false end
		if isstring(k) then return end

		--Body
		LIBNet.Start("Editor_Request_Playlist")
		net.WriteUInt( 2, 4 )
		StreamRadioLib.NetSendPlaylistEditor(v["url"], v["name"], path)
		net.SendToServer( )
	end, function( k, v )
		if not IsValid(ply) then return false end
		if not ply:IsAdmin() then return false end

		--Finish
		LIBNet.Start("Editor_Request_Playlist")
		net.WriteUInt(3, 4)
		net.WriteUInt(DataTab["format"], 8)
		net.WriteUInt(#DataTab, 16)
		net.WriteString(path)
		net.SendToServer()
	end )

	return true
end

function LIB.Remove(path, format)
	if not path then return false end
	if path == "" then return false end

	local ply = LocalPlayer()

	if not IsValid(ply) then return false end
	if not ply:IsAdmin() then return false end

	LIBNet.Start("Editor_Request_Playlist")
	net.WriteUInt(4, 4)
	net.WriteUInt(format, 8)
	net.WriteString(path)
	net.SendToServer()

	return true
end

function LIB.Copy(path_old, path_new)
	if not path_old then return false end
	if not path_new then return false end

	if path_old == "" then return false end
	if path_new == "" then return false end
	if path_old == path_new then return false end

	local ply = LocalPlayer()
	if not IsValid(ply) then return false end
	if not ply:IsAdmin() then return false end

	LIBNet.Start("Editor_Request_Playlist")
	net.WriteUInt(5, 4)
	net.WriteString(path_old)
	net.WriteString(path_new)
	net.SendToServer()

	return true
end

function LIB.Rename(path_old, path_new)
	if not path_old then return false end
	if not path_new then return false end

	if path_old == "" then return false end
	if path_new == "" then return false end
	if path_old == path_new then return false end

	local ply = LocalPlayer()
	if not IsValid(ply) then return false end
	if not ply:IsAdmin() then return false end

	LIBNet.Start("Editor_Request_Playlist")
	net.WriteUInt(6, 4)
	net.WriteString(path_old)
	net.WriteString(path_new)
	net.SendToServer()

	return true
end

function LIB.SetCallback(func, this, ...)
	if not isfunction(func) then
		g_callbackFunc = nil
		g_callbackArgs = {}
		g_callbackObj = nil

		return
	end

	g_callbackFunc = func
	g_callbackArgs = {...}
	g_callbackObj = this
end

LIBNet.Receive("Editor_Return_Files", function( length )
	local path, name, type, filepath = StreamRadioLib.NetReceiveFileEditor( )
	if not isfunction(g_callbackFunc) then return end

	if g_callbackObj then
		g_callbackFunc( g_callbackObj, "files", path, name, filepath, type, unpack( g_callbackArgs or {} ) )
	else
		g_callbackFunc( "files", path, name, filepath, type, unpack( g_callbackArgs or {} ) )
	end
end)

LIBNet.Receive("Editor_Return_Playlist", function( length )
	local url, name, filepath = StreamRadioLib.NetReceivePlaylistEditor( )
	if not isfunction(g_callbackFunc) then return end

	if g_callbackObj then
		g_callbackFunc( g_callbackObj, "playlist", url, name, filepath, unpack( g_callbackArgs or {} ) )
	else
		g_callbackFunc( "playlist", url, name, filepath, unpack( g_callbackArgs or {} ) )
	end
end)

LIBNet.Receive("Editor_Error", function( length )
	local path, code = StreamRadioLib.NetReceiveEditorError( )
	if not isfunction(g_callbackFunc) then return end

	if g_callbackObj then
		g_callbackFunc( g_callbackObj, "error", path, code, unpack( g_callbackArgs or {} ) )
	else
		g_callbackFunc( "error", path, code, unpack( g_callbackArgs or {} ) )
	end
end)

local MainPanel
local EditorPanel

local function CreateMainPanel( )
	if IsValid(MainPanel) then
		MainPanel:Remove()
	end

	if IsValid(EditorPanel) then
		EditorPanel:Remove()
	end

	MainPanel = vgui.Create("DFrame") -- The main frame.
	MainPanel:SetPos(25, 25)

	local W = math.Clamp(ScrW() - 50, 750, 1200)
	local H = math.Clamp(ScrH() - 50, 400, 800)
	MainPanel:SetSize(W, H)

	MainPanel:SetMinWidth(750)
	MainPanel:SetMinHeight(400)
	MainPanel:SetSizable(true)
	MainPanel:SetDeleteOnClose(false)
	MainPanel:SetTitle("Stream Radio Playlist Editor")
	MainPanel:SetVisible(false)
	MainPanel:GetParent():SetWorldClicker(true)

	EditorPanel = vgui.Create("Streamradio_VGUI_PlaylistEditor", MainPanel)
	EditorPanel:DockMargin(5, 5, 5, 5)
	EditorPanel:Dock(FILL)
end

do
	local function ClosePanel( ply, cmd, args )
		if not IsValid(MainPanel) then
			return
		end

		StreamRadioLib.VR.CloseMenu(MainPanel)
	end

	local function OpenPanel( ply, cmd, args )
		if not IsValid(ply) then return end

		if not ply:IsAdmin() then
			StreamRadioLib.Print.Msg(ply, "You must be admin to use the playlist editor.")
			return
		end

		if not IsValid(MainPanel) then
			CreateMainPanel()
		end

		if not IsValid(MainPanel) then
			return
		end

		-- Open via VR lib regardless so we have smoother transitions without possible leftovers
		StreamRadioLib.VR.MenuOpen("StreamradioPlaylistEditor", MainPanel, true)
	end

	concommand.Add("cl_streamradio_playlisteditor", OpenPanel)
	concommand.Add("+cl_streamradio_playlisteditor", OpenPanel)
	concommand.Add("-cl_streamradio_playlisteditor", ClosePanel)
end

return true


--lua/streamradio_core/interfaces/youtube.lua:
return gluapack()()
--lua/streamradio_core/filesystem/_folder.lua:
local RADIOFS = RADIOFS
if not istable( RADIOFS ) then
	StreamRadioLib.Filesystem.Load()
	return
end

RADIOFS.name = "Folder"
RADIOFS.type = "folder"
RADIOFS.icon = StreamRadioLib.GetPNGIcon("Folder")
RADIOFS.nocreate = true

RADIOFS.loadToWhitelist = true
RADIOFS.priority = 999999

function RADIOFS:IsType(globalpath, vpath)
	if file.Exists(globalpath, "GAME") then
		return true
	end

	if file.IsDir(globalpath, "GAME") then
		return true
	end

	return false
end

function RADIOFS:Find(globalpath, vfolder, callback)
	if not file.Exists(globalpath, "DATA") then
		callback(false, nil, nil)
		return false
	end

	if not file.IsDir(globalpath, "DATA") then
		callback(false, nil, nil)
		return false
	end

	local _, folders = file.Find(globalpath .. "/*", "DATA", "nameasc")
	folders = StreamRadioLib.Filesystem.FilterInvalidFilepaths(folders)

	callback(true, nil, folders)
	return true
end

function RADIOFS:Exists(globalpath, vpath)
	if not file.Exists(globalpath, "DATA") then
		return false
	end

	if not file.IsDir(globalpath, "DATA") then
		return false
	end

	return true
end

function RADIOFS:Delete(globalpath, vpath, callback)
	local deleted = StreamRadioLib.Util.DeleteFolder(globalpath)
	callback(deleted)

	return deleted
end

RADIOFS.Read = nil

return true


--lua/streamradio_core/filesystem/json.lua:
return gluapack()()
--lua/streamradio_core/filesystem/m3u.lua:
return gluapack()()
--lua/autorun/svmod_loader.lua:
-- Includes SVMod methods.
-- Some of these methods require the player to be in a vehicle to be used,
-- but do not require the player to retrieve the instance of the vehicle for
-- convenience.
-- @class SVMOD

-- Refers to a vehicle modified by the SVMod.
-- It has additional attributes and methods.
-- @class SV_Vehicle

SVMOD = {}
SVMOD.Metatable = {}

local function RecursiveLoad(path)
	local Files, Directories = file.Find(path .. "*", "LUA")

	for _, f in ipairs(Files) do
		if string.match(f, "^sv") then
			if SERVER then
				include(path .. f)
			end
		elseif string.match(f, "^sh") then
			AddCSLuaFile(path .. f)
			include(path .. f)
		elseif string.match(f, "^cl") then
			AddCSLuaFile(path .. f)
			if CLIENT then
				include(path .. f)
			end
		end
	end

	for _, d in ipairs(Directories) do
		RecursiveLoad(path .. d .. "/")
	end
end

RecursiveLoad("svmod/")
--lua/svmod/cl_main.lua:
return gluapack()()
--lua/svmod/config/cl_config.lua:
SVMOD.CFG = {}

SVMOD.CFG.Lights = {
	DrawProjectedLights = true,
	DrawShadows = false,
	DisableBlinkersOnTurn = true
}

SVMOD.CFG.Damage = {
	DrawSmoke = true
}

SVMOD.CFG.Sounds = {
	Horn = 1,
	Siren = 1
}

SVMOD.CFG.Contributor = {
	EnterpriseID = 0,
	IsEnabled = false,
	Key = ""
}
--lua/svmod/data/sh_data.lua:
-- @class SVMOD
-- @shared

local function getDataPath(model)
	return "svmod/" .. string.Replace(model, "/", "_") .. ".txt"
end

-- Gets the data of a vehicle.
-- @tparam string model Vehicle model
-- @treturn table Data of a vehicle
-- @internal
function SVMOD:GetData(model)
	if self.Data then
		return self.Data[string.lower(model)]
	end
	return nil
end

-- Updates vehicle data. SVMod will contact the web server
-- to get the latest releases.
-- @tparam function callback Function callback
-- @internal
function SVMOD:Data_Update(fun)
	self.Data = {}

	if not file.IsDir("svmod", "DATA") then
		file.CreateDir("svmod")
	end

	local vehicles = {}
	for _, veh in ipairs(SVMOD:GetVehicleList()) do
		local filePath = getDataPath(veh.Model)

		local CRC = ""
		if file.Exists(filePath, "DATA") then
			CRC = util.CRC(file.Read(filePath, "DATA"))
		end
		table.insert(vehicles, {
			model = veh.Model,
			crc = CRC
		})
	end

	HTTP({
		url = "https://api.svmod.com/get_vehicles_new.php",
		method = "POST",
		body = util.TableToJSON({
			version = SVMOD.FCFG.DataVersion,
			enterpriseID = SVMOD.CFG.Contributor.EnterpriseID,
			vehicles = vehicles
		}),
		success = function(code, body)
			if code == 200 then
				local createdCount = 0
				local updatedCount = 0

				local JSON = util.JSONToTable(body)

				for _, veh in pairs(JSON) do
					local filePath = getDataPath(string.lower(veh["model"]))

					if file.Exists(filePath, "DATA") then
						updatedCount = updatedCount + 1
					else
						createdCount = createdCount + 1
					end

					file.Write(filePath, veh["json"])
				end

				SVMOD.VehicleDataUpdateTime = os.time()
				SVMOD:PrintConsole(SVMOD.LOG.Info, "Updater: " .. createdCount .. " added vehicle" .. self:AddPlurial(createdCount) .. ", " .. updatedCount .. " updated vehicle" .. self:AddPlurial(updatedCount) .. ".")
			else
				SVMOD:PrintConsole(SVMOD.LOG.Alert, "Updater: server responding with code " .. code .. ".")
			end

			self:Data_Load(fun)
		end,
		failed = function()
			SVMOD:PrintConsole(SVMOD.LOG.Alert, "Updater: server not responding.")

			self:Data_Load(fun)
		end
	})
end

local function temp_angleToAngles(x)
	for k, v in pairs(x) do
		if istable(v) then
			temp_angleToAngles(v)
		elseif k == "Angle" then
			x["Angles"] = v
			x[k] = nil
		end
	end
end
--
--local function temp_fuelpump(data)
--	if data.Fuel.GasTank.Angles then
--		local pos = data.Fuel.GasTank.Position
--		local ang = data.Fuel.GasTank.Angles
--
--		if data.Fuel.GasolinePistol then
--			data.Fuel.GasTank = {
--				{
--					GasHole = {
--						Position = pos,
--						Angles = ang
--					},
--					GasolinePistol = {
--						Position = data.Fuel.GasolinePistol.Position,
--						Angles = data.Fuel.GasolinePistol.Angles
--					}
--				}
--			}
--		else
--			data.Fuel.GasTank = {
--				{
--					GasHole = {
--						Position = pos,
--						Angles = ang
--					}
--				}
--			}
--		end
--	end
--end

local function temp_partType(data)
	for _, part in ipairs(data.Parts) do
		if not part.Type then
			part.Type = "engine"
		end
	end
end

-- Loads vehicle data.
-- @tparam function callback Function callback
-- @internal
function SVMOD:Data_Load(fun)
	for _, veh in ipairs(SVMOD:GetVehicleList()) do
		local model = string.lower(veh.Model)
		if file.Exists(getDataPath(model), "DATA") then
			local JSON = util.JSONToTable(file.Read(getDataPath(model), "DATA"))

			temp_angleToAngles(JSON)
			--temp_fuelpump(JSON)
			temp_partType(JSON)

			local checkResult = SVMOD:Data_Check(JSON)
			if checkResult == nil then
				self.Data[model] = JSON
			else
				SVMOD:PrintConsole(SVMOD.LOG.Alert, veh.Model .. " cannot be loaded, syntax error on " .. checkResult)
			end
		end
	end

	local importedCount = table.Count(self.Data)
	local incompatibleCount = table.Count(SVMOD:GetVehicleList()) - importedCount

	SVMOD:PrintConsole(SVMOD.LOG.Info, "Loader: " .. importedCount .. " loaded vehicle" .. self:AddPlurial(importedCount) .. ", " .. incompatibleCount .. " incompatible vehicle" .. self:AddPlurial(incompatibleCount) .. ".")

	if fun then
		fun()
	end
end
--lua/svmod/gui/cl_welcome.lua:
net.Receive("SV_WelcomeGUI", function()
	local frame = SVMOD:CreateFrame("WELCOME")
	frame:MakePopup()

	local leftPanel = frame:GetLeftPanel()
	leftPanel:SetSize(250, 0)

	local centerPanel = frame:GetCenterPanel()

	local function createLabel(text)
		local label = vgui.Create("DLabel", centerPanel)
		label:Dock(TOP)
		label:SetFont("SV_Calibri18")
		label:SetText(text)
		label:SetAutoStretchVertical(true)
		label:SetWrap(true)

		return label
	end

	SVMOD:CreateTitle(centerPanel, language.GetPhrase("svmod.welcome.thank_you_title"))

	createLabel(language.GetPhrase("svmod.welcome.thank_you_description"))

	local title = SVMOD:CreateTitle(centerPanel, language.GetPhrase("svmod.welcome.where_start_title"))
	title:DockMargin(0, 30, 0, 0)

	createLabel(language.GetPhrase("svmod.welcome.where_start_description"))

	local title = SVMOD:CreateTitle(centerPanel, language.GetPhrase("svmod.welcome.where_contributors_title"))
	title:DockMargin(0, 30, 0, 0)

	createLabel(language.GetPhrase("svmod.welcome.where_contributors_description"))

	local title = SVMOD:CreateTitle(centerPanel, language.GetPhrase("svmod.welcome.message_title"))
	title:DockMargin(0, 30, 0, 0)

	createLabel(language.GetPhrase("svmod.welcome.message_description"))


	local icon = vgui.Create("DImage", leftPanel)
	icon:SetImage("materials/vgui/svmod/icon.png")
	icon:SetSize(613 / 2.5, 567 / 2.5)
	icon:SetPos(0, 100)

	frame:CreateMenuButton(language.GetPhrase("svmod.close"), BOTTOM, function()
		frame:Remove()
	end)

	frame:CreateMenuButton(language.GetPhrase("svmod.welcome.discord"), BOTTOM, function()
		gui.OpenURL("https://discord.svmod.com/")
	end)

	frame:CreateMenuButton(language.GetPhrase("svmod.welcome.contributor"), BOTTOM, function()
		gui.OpenURL("https://svmod.com/pricing.php")
	end)
end)
--lua/svmod/gui/editor/cl_seats.lua:
function SVMOD:EDITOR_Seats(panel, veh)
	panel:Clear()

	local listView = SVMOD:CreateListView(panel)
	listView:SetWidth(100, 0)
	listView:SetHideHeaders(true)
	listView:Dock(LEFT)
	listView:DockMargin(0, 0, 20, 0)
	listView:AddColumn("ID")
	listView:SetMultiSelect(false)

	local bottomPanel = vgui.Create("DPanel", panel)
	bottomPanel:Dock(BOTTOM)
	bottomPanel:SetSize(0, 30)
	bottomPanel:SetPaintBackground(false)

	local centerPanel = vgui.Create("DPanel", panel)
	centerPanel:Dock(FILL)
	centerPanel:SetPaintBackground(false)

	local addSeat

	local addButton = SVMOD:CreateButton(bottomPanel, "Add", function()
		addSeat(Vector(0, 0, 0), Angle(0, 0, 0))
	end)
	addButton:Dock(RIGHT)

	-- -------------------
	--  FUNCTIONS
	-- -------------------

	addSeat = function(position, angles)
		local max = 0
		for _, line in pairs(listView:GetLines()) do
			local index = tonumber(line:GetColumnText(1))
			if index > max then
				max = index
			end
		end

		local line = listView:AddLine(max + 1)
		line.Seat = SVMOD:CreateCSSeat(veh)
		line.Seat:SetParent(veh)
		line.Seat:SetLocalPos(position)
		line.Seat:SetLocalAngles(angles)
		line.Seat:SetColor(Color(255, 255, 255, 150))
		line.Seat:SetRenderMode(RENDERMODE_TRANSCOLOR)
	end

	local function removeSeat(index)
		local line = listView:GetLine(index)
		columnText = tonumber(line:GetColumnText(1))
		if IsValid(line.Seat) then
			line.Seat:Remove()
		end

		for _, v in pairs(listView:GetLines()) do
			local index = tonumber(v:GetColumnText(1))
			if index > columnText then
				v:SetColumnText(1, index - 1)
			end
		end

		listView:RemoveLine(index)
	end

	local function upSeat(index)
		local line = listView:GetLine(index)
		lineIndex = tonumber(line:GetColumnText(1))

		for _, v in pairs(listView:GetLines()) do
			local tempIndex = tonumber(v:GetColumnText(1))
			if IsValid(v.Seat) and tempIndex == lineIndex - 1 then
				line.Seat, v.Seat = v.Seat, line.Seat
				break
			end
		end
	end

	local function downSeat(index)
		local line = listView:GetLine(index)
		lineIndex = tonumber(line:GetColumnText(1))

		for _, v in pairs(listView:GetLines()) do
			local tempIndex = tonumber(v:GetColumnText(1))
			if IsValid(v.Seat) and tempIndex == lineIndex + 1 then
				line.Seat, v.Seat = v.Seat, line.Seat
				break
			end
		end
	end

	local function createNumSlidePanel(panel, name, defaultValue, minValue, maxValue)
		local numSlider = SVMOD:CreateNumSlidePanel(panel, name, function() end)
		numSlider:SetSize(400, 30)
		numSlider:SetValue(defaultValue)
		numSlider:SetMinValue(minValue)
		numSlider:SetMaxValue(maxValue)
		numSlider:SetUnit(" ")
		numSlider:SetRealTime(true)

		return numSlider
	end

	-- -------------------
	--  HOOKS
	-- -------------------

	hook.Add("PreDrawHalos", "SV_Editor_Halo", function()
		local seats = {}

		local _, line = listView:GetSelectedLine()
		if line and IsValid(line.Seat) then
			table.insert(seats, line.Seat)
		end

		halo.Add(seats, Color(255, 0, 0), 2, 2, 1, true, true)
	end)

	listView.OnRemove = function()
		for _, line in pairs(listView:GetLines()) do
			local index = tonumber(line:GetColumnText(1))
			if IsValid(line.Seat) then
				veh.SV_Data.Seats[index] = {
					Position = line.Seat:GetLocalPos(),
					Angles = line.Seat:GetLocalAngles()
				}
				line.Seat:Remove()
			end
		end

		hook.Remove("PreDrawHalos", "SV_Editor_Halo")
	end

	listView.OnRowRightClick = function(_, index, e)
		local menu = DermaMenu()

		menu:AddOption("Up", function()
			upSeat(index)
		end):SetIcon("icon16/arrow_up.png")

		menu:AddOption("Down", function()
			downSeat(index)
		end):SetIcon("icon16/arrow_down.png")

		menu:AddOption("Symmetric", function()
			for _, line in pairs(listView:GetSelected()) do
				local pos = line.Seat:GetLocalPos()
				pos.x = -pos.x
				addSeat(pos, line.Seat:GetLocalAngles())
			end
		end):SetIcon("icon16/arrow_refresh.png")

		menu:AddOption("Delete", function()
			removeSeat(index)
		end):SetIcon("icon16/cross.png")

		menu:Open()
	end

	-- -------------------
	--  PANELS
	-- -------------------

	for _, seat in ipairs(veh.SV_Data.Seats) do
		addSeat(seat.Position, seat.Angles)
	end

	listView.OnRowSelected = function(_, _, e)
		centerPanel:Clear()

		local xPositionNumSlider, yPositionNumSlider, zPositionNumSlider

		local title = SVMOD:CreateTitle(centerPanel, "LOCAL POSITIONS")
		local button = SVMOD:CreateButton(title, "EyePos", function()
			local trace = LocalPlayer():GetEyeTrace()

			if IsValid(trace.Entity) and trace.Entity:IsVehicle() then
				local position = trace.Entity:WorldToLocal(trace.HitPos)
				e.Seat:SetLocalPos(position)

				xPositionNumSlider:SetValue(position.x)
				yPositionNumSlider:SetValue(position.y)
				zPositionNumSlider:SetValue(position.z)
			end
		end)
		button:Dock(RIGHT)

		local currentPos = e.Seat:GetLocalPos()

		xPositionNumSlider = createNumSlidePanel(centerPanel, "X Position", math.Round(currentPos.x), -200, 200)
		xPositionNumSlider:SetFunction(function(val)
			local pos = e.Seat:GetLocalPos()
			e.Seat:SetLocalPos(Vector(val, pos.y, pos.z))
		end)

		yPositionNumSlider = createNumSlidePanel(centerPanel, "Y Position", math.Round(currentPos.y), -200, 200)
		yPositionNumSlider:SetFunction(function(val)
			local pos = e.Seat:GetLocalPos()
			e.Seat:SetLocalPos(Vector(pos.x, val, pos.z))
		end)

		zPositionNumSlider = createNumSlidePanel(centerPanel, "Z Position", math.Round(currentPos.z), -200, 200)
		zPositionNumSlider:SetFunction(function(val)
			local pos = e.Seat:GetLocalPos()
			e.Seat:SetLocalPos(Vector(pos.x, pos.y, val))
		end)

		local title = SVMOD:CreateTitle(centerPanel, "ANGLES")
		title:DockMargin(0, 30, 0, 0)

		local currentAng = e.Seat:GetLocalAngles()

		local xAngleNumSlider = createNumSlidePanel(centerPanel, "Y Angle", math.Round(currentAng.x), -180, 180)
		xAngleNumSlider:SetFunction(function(val)
			local ang = e.Seat:GetLocalAngles()
			e.Seat:SetLocalAngles(Angle(math.floor(val), ang.y, ang.z))
		end)

		local yAngleNumSlider = createNumSlidePanel(centerPanel, "P Angle", math.Round(currentAng.y), -180, 180)
		yAngleNumSlider:SetFunction(function(val)
			local ang = e.Seat:GetLocalAngles()
			e.Seat:SetLocalAngles(Angle(ang.x, math.floor(val), ang.z))
		end)

		local zAngleNumSlider = createNumSlidePanel(centerPanel, "R Angle", math.Round(currentAng.z), -180, 180)
		zAngleNumSlider:SetFunction(function(val)
			local ang = e.Seat:GetLocalAngles()
			e.Seat:SetLocalAngles(Angle(ang.x, ang.y, math.floor(val)))
		end)
	end

	listView:SelectFirstItem()
end
--lua/svmod/gui/notification/cl_notification.lua:
return gluapack()()
--lua/svmod/gui/settings/cl_fuel.lua:
function SVMOD:GUI_Fuel(panel, data)
	panel:Clear()

	SVMOD:CreateTitle(panel, language.GetPhrase("svmod.fuel.fuel"))

	SVMOD:CreateSettingPanel(panel, language.GetPhrase("svmod.fuel.enable_fuel"), {
		{
			Name = language.GetPhrase("svmod.enable"),
			Color = Color(59, 217, 85),
			HoverColor = Color(156, 255, 161),
			IsSelected = (data.FuelIsEnabled == true),
			DoClick = function()
				net.Start("SV_Settings")
				net.WriteString("Fuel")
				net.WriteString("IsEnabled")
				net.WriteUInt(0, 2) -- bool
				net.WriteBool(true)
				net.SendToServer()
			end
		},
		{
			Name = language.GetPhrase("svmod.disable"),
			Color = Color(173, 48, 43),
			HoverColor = Color(224, 62, 56),
			IsSelected = (data.FuelIsEnabled == false),
			DoClick = function()
				net.Start("SV_Settings")
				net.WriteString("Fuel")
				net.WriteString("IsEnabled")
				net.WriteUInt(0, 2) -- bool
				net.WriteBool(false)
				net.SendToServer()
			end
		}
	})

	local slide = SVMOD:CreateNumSlidePanel(panel, language.GetPhrase("svmod.fuel.consumption_multiplier"), function(val)
		net.Start("SV_Settings")
		net.WriteString("Fuel")
		net.WriteString("Multiplier")
		net.WriteUInt(1, 2) -- float
		net.WriteFloat(val / 100)
		net.SendToServer()
	end)
	slide:SetValue(data.FuelMultiplier * 100)
	slide:SetMaxValue(200)
	slide:SetUnit("%")

	local title = SVMOD:CreateTitle(panel, language.GetPhrase("svmod.fuel.gas_pump"))
	title:DockMargin(0, 30, 0, 0)

	local pumpList = SVMOD:CreateListView(panel)
	pumpList:AddColumn("ID"):SetWidth(10)
	pumpList:AddColumn(language.GetPhrase("svmod.fuel.model"))
	pumpList:AddColumn("MapCreationID")
	pumpList:AddColumn(language.GetPhrase("svmod.fuel.position"))
	pumpList:AddColumn(language.GetPhrase("svmod.fuel.angles")):SetWidth(20)
	pumpList:AddColumn(language.GetPhrase("svmod.fuel.price")):SetWidth(10)

	pumpList.OnRowRightClick = function(self, _, line)
		local menu = DermaMenu()

		menu:AddOption(language.GetPhrase("svmod.fuel.goto"), function()
			net.Start("SV_Settings_GoToFuelPump")
			net.WriteUInt(tonumber(line:GetColumnText(1)), 5) -- max: 31
			net.SendToServer()
		end):SetIcon("icon16/arrow_in.png")

		menu:Open()
	end

	net.Start("SV_Settings_GetFuelPump")
	net.SendToServer()

	net.Receive("SV_Settings_GetFuelPump", function()
		local count = net.ReadUInt(5) -- max: 31
		for i = 1, count do
			local model = net.ReadString()
			local isCompiled = net.ReadBool()
			local mapCreationID = net.ReadUInt(16) -- max: 65535
			local position = net.ReadVector()
			local angle = net.ReadAngle()
			local price = net.ReadUInt(16) -- max: 65535

			if not isCompiled then
				mapCreationID = -1
			end

			pumpList:AddLine(
				table.Count(pumpList:GetLines()) + 1,
				model,
				mapCreationID,
				position.x .. ", " .. position.y .. ", " .. position.z,
				angle.x .. ", " .. angle.y .. ", " .. angle.z,
				price
			)
		end
	end)

	local bottomPanel = vgui.Create("DPanel", panel)
	bottomPanel:Dock(BOTTOM)
	bottomPanel:DockMargin(0, 4, 0, 4)
	bottomPanel:SetSize(0, 30)
	bottomPanel:SetPaintBackground(false)

	SVMOD:CreateHorizontalLine(panel, BOTTOM)

	local button = SVMOD:CreateButton(bottomPanel, language.GetPhrase("svmod.fuel.get_pistol"), function()
		net.Start("SV_Settings_GetFuelPumpCreatorPistol")
		net.SendToServer()
		panel:GetParent():Remove()
	end)
	button:Dock(RIGHT)
	button:SetSize(280, 0)
end
--lua/svmod/gui/settings/cl_sounds.lua:
return gluapack()()
--lua/svmod/gui/settings/cl_vehicles.lua:
return gluapack()()
--lua/autorun/tdmcars_mer300sel.lua:
return gluapack()()
--lua/autorun/tdmcars_mer300slgull.lua:
local V = {
			Name = "Mercedes-Benz 300SL Gullwing Coupe", 
			Class = "prop_vehicle_jeep",
			Category = "TDM Cars",
			Author = "TheDanishMaster, Turn 10",
			Information = "A drivable Mercedes-Benz 300SL Gullwing Coupe by TheDanishMaster",
			Model = "models/tdmcars/mer_300slgull.mdl",
			KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/mer300slgull.txt"
							}
			}
list.Set("Vehicles", "mer300slgulltdm", V)
--lua/autorun/tdmcars_porcycle.lua:
local V = {
			Name = "Porsche Tricycle", 
			Class = "prop_vehicle_jeep",
			Category = "TDM Cars",
			Author = "TheDanishMaster",
			Information = "A drivable Porsche Tricycle by TheDanishMaster",
			Model = "models/tdmcars/por_tricycle.mdl",					
			KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/porcycle.txt"
							}
			}
list.Set("Vehicles", "porcycletdm", V)

--lua/autorun/tdmcars_sl65.lua:
return gluapack()()
--addons/voidlib/lua/voidlib/sh_lists.lua:
VoidLib.Lists = VoidLib.Lists or {}
--addons/voidlib/lua/voidlib/sh_logging.lua:
VoidLib.Logging = VoidLib.Logging or {}
VoidLib.Logging.InjectedAddons = VoidLib.Logging.InjectedAddons or {}

VoidLib.Logging.AddonColors = {
    ["VoidCases"] = Color(210, 153, 38),
    ["VoidFactions"] = Color(66, 170, 70)
}

local LOG_KEEP_PERIOD = 60 * 60 * 48

CreateConVar("voidlib_logging_enable", SERVER and 1 or 0, FCVAR_NONE, "Enables logging for VoidLib.", 0, 1)
CreateConVar("voidlib_logging_savetofile", 0, FCVAR_NONE, "Commits logs to files.", 0, 1)
CreateConVar("voidlib_logging_commitinterval", 60, FCVAR_NONE, "The interval between file writes if savetofile is enabled. Server restart is required.", 1, 3600)

function VoidLib.Logging:Init(strAddon, tblAddon)
    local strDate = os.date("%Y-%m-%d")
    if (file.Exists("voidlib/persistent_logs/" .. strAddon .. "/" .. strDate .. ".dat", "DATA")) then
        local strData = file.Read("voidlib/persistent_logs/" .. strAddon .. "/" .. strDate .. ".dat")
        local tblDat = util.JSONToTable(strData)

        for k, v in ipairs(tblDat) do
            if (os.time() < v.time + LOG_KEEP_PERIOD) then
                table.insert(tblAddon.Logging.Logs, v)
            end
        end

        tblAddon:Log("Loaded previous persistent logs (:logCount:) from today (:date:)", {
            date = strDate,
            logCount = #tblDat
        }, "Logging")
    end
end

function VoidLib.Logging:CommitToDisk(bShutdown)
    -- Create a table that stores all data
    for strAddon, tblGlobal in pairs(VoidLib.Logging.InjectedAddons) do
        VoidLib:LogDebug("Commiting logs of :addon: to disk...", { addon = strAddon }, "Logging")

        if (bShutdown) then
            file.CreateDir("voidlib/persistent_logs")
            file.CreateDir("voidlib/persistent_logs/" .. strAddon)

            local strDate = os.date("%Y-%m-%d")
            file.Write("voidlib/persistent_logs/" .. strAddon .. "/" .. strDate .. ".dat", util.TableToJSON(tblGlobal.Logging.Logs))
            
            local tblFiles = file.Find("*.dat", "voidlib/persistent_logs/" .. strAddon)
            for k, v in pairs(tblFiles) do
                if (strDate .. ".dat" != v) then
                    file.Delete("voidlib/persistent_logs/" .. strAddon .. "/" .. v)
                end
            end
        else
            if (!GetConVar("voidlib_logging_savetofile"):GetBool() and !tblGlobal.Debug) then return end
            file.CreateDir("voidlib/logs/" .. strAddon)

            local strTime = os.date("%Y-%m-%d")
            local strFormat = VoidLib.Logging:FormatReadLogs(tblGlobal, true)

            file.Append("voidlib/logs/" .. strAddon .. "/" .. strTime .. ".txt", strFormat)
        end

        VoidLib:LogDebug("Commited logs of :addon: to disk!", { addon = strAddon }, "Logging")
    end
end

function VoidLib.Logging:FormatReadLogs(tblGlobal, bAllData)
    local strFormat = ""
    for k, v in pairs(tblGlobal.Logging.Logs) do
        local strFormatted = tblGlobal.Logging:FormatLog(v)
        if (bAllData) then
            strFormat = strFormat .. string.format("%s | [%s]: <%s> %s (%s:%s)", os.date("%d-%m-%Y %H:%M:%S", v.time), v.type:upper(), v.scope, VoidLib.StringFormat(v.log, v.args), v.src, v.line) .. "\n"
        else
            strFormat = strFormat .. string.format("%s | [%s]: <%s> %s", os.date("%d-%m-%Y %H:%M:%S", v.time), v.type:upper(), v.scope, VoidLib.StringFormat(v.log, v.args)) .. "\n"
        end
    end

    return strFormat
end

function VoidLib.Logging:Inject(strAddonGlobal, colLogColor)
    colLogColor = colLogColor or VoidUI.Colors.Blue

    local tblAddonGlobal = _G[strAddonGlobal]
    if (!tblAddonGlobal) then
        VoidLib.PrintError("Tried to inject logs to " .. strAddonGlobal .. ", which does not exist!")
        return
    end

    if (tblAddonGlobal.Logging and strAddonGlobal != "VoidLib") then return end

    VoidLib.Print("[Logging] Injecting log system to " .. strAddonGlobal)

    VoidLib.Logging.InjectedAddons[strAddonGlobal] = tblAddonGlobal

    tblAddonGlobal.Logging = tblAddonGlobal.Logging or {}
    tblAddonGlobal.Logging.Logs = {}
    tblAddonGlobal.Logging.Color = colLogColor

    function tblAddonGlobal.Logging:PrintLog(tblLog)
        MsgC(self.Color, string.format("[%s] ", strAddonGlobal), Color(0, 255, 255), string.format("[%s] ", tblLog.scope), self:GetTypeColor(tblLog.type), string.format("[%s] ", tblLog.type:upper()), VoidUI.Colors.White, unpack(tblLog.formattedLog))
    end

    function tblAddonGlobal.Logging:FormatLog(tblLog)
        local tblVarArgs = {}
        local intPrevStartPos = 1

        for k in string.gmatch(tblLog.log, ":[%w_]+:") do
            local intPos, intEndPos = string.find(tblLog.log, k, 1, true)

            local strSub = tblLog.log:sub(intPrevStartPos, intPos - 1)
            table.insert(tblVarArgs, strSub)

            local strKey = k:gsub(":", "")
            local strValue = tblLog.args[strKey] or "N/A"

            -- This is the log variable itself
            table.insert(tblVarArgs, VoidUI.Colors.Gold)
            table.insert(tblVarArgs, strValue)
            table.insert(tblVarArgs, VoidUI.Colors.White)

            intPrevStartPos = intEndPos + 1
        end

        table.insert(tblVarArgs, tblLog.log:sub(intPrevStartPos))
        table.insert(tblVarArgs, "\n")
        return tblVarArgs
    end

    function tblAddonGlobal.Logging:ConvertArgs(tblArgs)
        for k, strValue in pairs(tblArgs) do
            if (istable(strValue)) then
                strValue = table.ToString(strValue)
            end

            if (IsEntity(strValue)) then
                if (strValue:IsPlayer()) then
                    strValue = string.format("%s", strValue:Nick())
                end
            end

            tblArgs[k] = strValue
        end

        return tblArgs
    end

    function tblAddonGlobal.Logging:GetTypeColor(strType)
        local tblColors = {
            ["info"] = Color(0, 255, 255),
            ["error"] = Color(255, 0, 0),
            ["debug"] = Color(255, 0, 255),
            ["warning"] = Color(255, 255, 0)
        }

        return tblColors[strType]
    end

    function tblAddonGlobal.Logging:Log(strText, xFirst, xSecond, strType, bIsPrint)
        if (!GetConVar("voidlib_logging_enable"):GetBool()) then return end

        local tblArgs = {}
        local strName = "Generic"

        if (xFirst and istable(xFirst)) then
            tblArgs = xFirst
        end

        if (xFirst and isstring(xFirst)) then
            strName = xFirst
        end

        if (xSecond and xFirst and istable(xFirst)) then
            strName = xSecond
        end

        tblArgs = self:ConvertArgs(tblArgs)

        local tblDebugInfo = debug.getinfo(bIsPrint and 3 or 2)
        local tblLog = {
            src = tblDebugInfo.short_src,
            line = tblDebugInfo.currentline,

            log = strText,
            args = tblArgs,
            scope = strName,

            time = os.time(),
            type = strType,
        }

        local tblFormatted = self:FormatLog(tblLog)
        tblLog.formattedLog = tblFormatted
        
        if (strType != "debug" or tblAddonGlobal.Debug) then
            self:PrintLog(tblLog)
        end

        table.insert(tblAddonGlobal.Logging.Logs, tblLog)
    end

    function tblAddonGlobal.Logging:LogInfo(strText, xFirst, xSecond, bPrint)
        return self.Logging:Log(strText, xFirst, xSecond, "info", bPrint)
    end

    function tblAddonGlobal.Logging:LogDebug(strText, xFirst, xSecond, bPrint)
        return self.Logging:Log(strText, xFirst, xSecond, "debug", bPrint)
    end

    function tblAddonGlobal.Logging:LogError(strText, xFirst, xSecond, bPrint)
        return self.Logging:Log(strText, xFirst, xSecond, "error", bPrint)
    end

    function tblAddonGlobal.Logging:LogWarning(strText, xFirst, xSecond, bPrint)
        return self.Logging:Log(strText, xFirst, xSecond, "warning", bPrint)
    end

    tblAddonGlobal.Log = tblAddonGlobal.Logging.LogInfo
    tblAddonGlobal.LogInfo = tblAddonGlobal.Logging.LogInfo
    tblAddonGlobal.LogWarning = tblAddonGlobal.Logging.LogWarning
    tblAddonGlobal.LogDebug = tblAddonGlobal.Logging.LogDebug
    tblAddonGlobal.LogError = tblAddonGlobal.Logging.LogError

    local function varArgsToString(...)
        local str = ""
        for k, v in pairs({...}) do
            if (isstring(v)) then
                str = str .. v
            end
        end
        return str
    end

    function tblAddonGlobal.Print(...)
        tblAddonGlobal:LogInfo(varArgsToString(...), nil, nil, true)
    end

    function tblAddonGlobal.PrintError(...)
        tblAddonGlobal:LogError(varArgsToString(...), nil, nil, true)
    end

    function tblAddonGlobal.PrintDebug(...)
        tblAddonGlobal:LogDebug(varArgsToString(...), nil, nil, true)
    end

    VoidLib.Print("[Logging] Successfully injected log system to " .. strAddonGlobal)

    VoidLib.Logging:Init(strAddonGlobal, tblAddonGlobal)

    if (tblAddonGlobal.Debug) then
        tblAddonGlobal:LogWarning("Debug mode is enabled - logs will be saved. If you encounter any performance issues, disable Debug mode.", "Logging")
    end

    local tblDebugInfo = debug.getinfo(2)
    tblAddonGlobal:LogDebug("Logging injected from file :file:::line:", { file = tblDebugInfo.short_src, line = tblDebugInfo.currentline }, "Logging")
end

file.CreateDir("voidlib")
file.CreateDir("voidlib/logs")
timer.Create("VoidLib.Logging.LogFileCommiter", GetConVar("voidlib_logging_commitinterval"):GetInt(), 0, function ()
    VoidLib.Logging:CommitToDisk()
end)

hook.Add("ShutDown", "VoidLib.Logging.WriteLogDataToFile", function ()
    VoidLib:Log("Commiting persistent logs to disk...", "Logging")
    VoidLib.Logging:CommitToDisk(true)
    VoidLib:Log("Commited logs to disk! Bye!", "Logging")
end)

-- Inject logs for ourselves :D
VoidLib.Logging:Inject("VoidLib", Color(255, 0, 255))

hook.Add("InitPostEntity", "VoidLib.Logging.BackwardsCompatibility", function ()
    -- Inject older addons automatically! (if they are installed)
    if (VoidCases) then
        VoidLib.Logging:Inject("VoidCases", VoidLib.Logging.AddonColors["VoidCases"])
    end

    if (VoidFactions) then
        VoidLib.Logging:Inject("VoidFactions", VoidLib.Logging.AddonColors["VoidFactions"])
    end
end)
--addons/voidlib/lua/voidlib/vgui/dropdown.lua:
return gluapack()()
--addons/voidlib/lua/voidlib/vgui/elementgrid.lua:
return gluapack()()
--addons/voidlib/lua/voidlib/vgui/table.lua:
local sc = VoidUI.Scale

local PANEL = {}

function PANEL:Init()
    self:SetHeaderHeight(25)
    self:SetDataHeight(30)
    self:SetMultiSelect(false)

    self.fAddColumn = self.AddColumn

    self.AddColumn = function(self, strColumn)
        local pColumn = self:fAddColumn(strColumn)
        local tblChildren = pColumn:GetChildren()
        
        tblChildren[1]:SetTextColor(VoidUI.Colors.Gray)
        tblChildren[1]:SetFont("VoidUI.R20")
        tblChildren[1].Paint = function(self, w, h)
            draw.RoundedBox(0, 0, 0, w, h, VoidUI.Colors.BackgroundTransparent)
        end

        return pColumn
    end

    self.fAddLine = self.AddLine

    self.AddLine = function(self, ...)
        local pLine = self:fAddLine(...)
        local tblChildren = pLine:GetChildren()
        
        for k, pLabel in ipairs(tblChildren) do
            pLabel:SetTextColor(VoidUI.Colors.Gray)
            pLabel:SetFont("VoidUI.R18")
            pLabel:SetContentAlignment(5)
        end

        return pLine
    end
    

    local sbar = self.VBar

    sbar.Paint = function(self, w, h)
	draw.RoundedBox(24, sc(8), 0, w - sc(8), h, VoidUI.Colors.Background)
    end

    sbar.btnGrip.Paint = function(self, w, h)
	local color = self:IsHovered() and VoidUI.Colors.GrayTransparent or VoidUI.Colors.TextGray
	draw.RoundedBox(24, sc(8), 0, w-sc(8), h, color)
    end

    sbar:SetHideButtons(true)
end

function PANEL:Paint(w, h)
end


vgui.Register("VoidUI.Table", PANEL, "DListView")

--addons/voidfactions-1.10.6/lua/voidfactions/core/sh_utils.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/features/rewards/sh_rewards.lua:
-- Helper functions

VoidFactions.RewardModules = VoidFactions.RewardModules or {}
VoidFactions.RewardModules.List = {}

VoidFactions.FactionRewards = VoidFactions.FactionRewards or {}

local L = VoidFactions.Lang.GetPhrase

-- Class for creating new reward modules

local REWARD_CLASS = {}
REWARD_CLASS.__index = REWARD_CLASS

function REWARD_CLASS:New()
	local object = setmetatable({}, REWARD_CLASS)
		object.name = nil
        object.defaultIcon = nil

        object.setupFunc = nil
	return object
end

function REWARD_CLASS:Name(name)
    self.name = name
end

function REWARD_CLASS:Description(desc)
    self.desc = desc
end

function REWARD_CLASS:DefaultIcon(icon)
    self.defaultIcon = icon
end

-- Function setters

function REWARD_CLASS:Setup(func)
    self.setupFunc = func
end

-- Functions

function REWARD_CLASS:SetValue(faction, val)
    VoidFactions.SQL:UpdateRewardValues(self, faction, val)
end

function REWARD_CLASS:Increment(faction, val)
    local incrVal = (val or 1)

    VoidFactions.SQL:IncrementReward(self, faction, incrVal)
end

function REWARD_CLASS:Decrement(faction, val)
    local decrVal = (val or 1)

    VoidFactions.SQL:IncrementReward(self, faction, -decrVal)
end

-- Function getters

function REWARD_CLASS:PrintName()
    if (string.StartWith(self.name, "reward_")) then
        return L(self.name)
    end

    return self.name
end

function REWARD_CLASS:PrintValueDescription()
    if (string.StartWith(self.desc, "reward_desc_")) then
        return L(self.desc)
    end

    return self.desc
end

-- Public functions

function VoidFactions.RewardModules:NewReward()
	return REWARD_CLASS:New()
end

function VoidFactions.RewardModules:AddReward(reward)
    if (!istable(reward)) then return end

    if (!reward.name) then
        VoidFactions.PrintError("A reward module does not have a name! Stack trace:")
        print(debug.traceback())
        return
    end

    if (VoidFactions.RewardModules.List[reward.name]) then
        VoidFactions.PrintError("A reward module with the name " .. reward.name .. " was already registered!")
        return
    end

    VoidFactions.RewardModules.List[reward.name] = reward
    VoidFactions.PrintDebug("Registered reward module " .. reward.name .. "!")

    if (SERVER) then
        hook.Add("VoidFactions.Settings.Loaded", "VoidFactions.RewardModules.WaitForSettings" .. reward.name, function ()
            if (VoidFactions.Settings:IsStaticFactions()) then return end
            reward.setupFunc()
        end)
    end
end

-- Class for faction rewards

local FACTIONREWARD_CLASS = {}
FACTIONREWARD_CLASS.__index = FACTIONREWARD_CLASS

function FACTIONREWARD_CLASS:New(module, value)
	local object = setmetatable({}, FACTIONREWARD_CLASS)
		object.module = module
        object.value = value
	return object
end

function FACTIONREWARD_CLASS:SetValue(val)
    self.value = val
end

function VoidFactions.FactionRewards:New(...)
	return FACTIONREWARD_CLASS:New(...)
end
--addons/voidfactions-1.10.6/lua/voidfactions/features/upgrades/sh_upgrades.lua:
local L = VoidFactions.Lang.GetPhrase

VoidFactions.Upgrades = VoidFactions.Upgrades or {}
VoidFactions.Upgrades.Modules = VoidFactions.Upgrades.Modules or {}
VoidFactions.Upgrades.Custom = SERVER and {} or nil

-- Class for creating new upgrades

local UPGRADE_CLASS = {}
UPGRADE_CLASS.__index = UPGRADE_CLASS

function UPGRADE_CLASS:New()
	local object = setmetatable({}, UPGRADE_CLASS)
		object.name = nil
        object.icon = nil
        object.description = nil
        object.valueDescription = nil

        object.onEquip = nil
        object.onRespawn = nil
        object.onReset = nil
        object.onLoadFunc = nil

        object.formatVal = nil
        object.onlyOneInstance = false
        
        object.isNumeric = false

        object.isInstalledFunc = nil
	return object
end


-- Setters

-- If name starts with upgr_, then it's a translation phrase.
function UPGRADE_CLASS:Name(name)
    self.name = name
end

-- Sets the upgrade imgur icon.
function UPGRADE_CLASS:Icon(icon)
    self.icon = icon
end

function UPGRADE_CLASS:Numeric()
    self.isNumeric = true
end

function UPGRADE_CLASS:OneInstance()
    self.onlyOneInstance = true
end

-- If any translation starts with upgr_desc_, it's a translation phrase
-- Sets the upgrade description.
function UPGRADE_CLASS:Description(description)
    self.description = description
end

-- Sets the upgrade value description. (when creating a new upgrade)
function UPGRADE_CLASS:ValueDescription(description)
    self.valueDescription = description
end


-- Function setters

-- This gets called on purchase and join.
function UPGRADE_CLASS:OnEquip(func)
    self.onEquip = func
end

function UPGRADE_CLASS:OnReset(func)
    self.onReset = func
end

function UPGRADE_CLASS:IsInstalledFunc(func)
    self.isInstalledFunc = func
end

-- This gets called on respawn.
function UPGRADE_CLASS:OnRespawn(func)
    self.onRespawn = func
end

function UPGRADE_CLASS:FormatValue(func)
    self.formatVal = func
end

function UPGRADE_CLASS:OnLoad(func)
    self.onLoadFunc = func
end

-- Utility functions

function UPGRADE_CLASS:PrintValue(val)
    return self.formatVal(val)
end

function UPGRADE_CLASS:PrintName()
    if (string.StartWith(self.name, "upgr_")) then
        return L(self.name)
    end

    return self.name
end

function UPGRADE_CLASS:PrintDescription()
    if (string.StartWith(self.description, "upgr_desc_")) then
        return L(self.description)
    end

    return self.description
end

function UPGRADE_CLASS:PrintValueDescription()
    if (string.StartWith(self.valueDescription, "upgr_descval_")) then
        return L(self.valueDescription)
    end

    return self.valueDescription
end

function UPGRADE_CLASS:Reset(ply, prev)
    self.onReset(ply, prev)
end

function UPGRADE_CLASS:IsInstalled()
    local isInstalled = self.isInstalledFunc and self.isInstalledFunc()
    if (!self.isInstalledFunc) then
        isInstalled = true
    end
    return isInstalled
end

local function equipUpgrade(upgrade, ply, value)
    if (!IsValid(ply)) then return end
    if (upgrade.onlyOneInstance) then
        local faction = ply:GetVFFaction()
        local pts = faction:GetUpgradePointsByName("upgr_weapon")
        local point = nil
        for k, v in ipairs(pts) do
            if (!point) then
                point = v
            end

            if (v.posY > point.posY) then
                point = v
            end

            if (v.posY == point.posY and v.posX > point.posX) then
                point = v
            end
        end

        if (!point) then return end
        if (point.upgrade.value != value) then return end
    end

    upgrade.onEquip(ply, value)
end

local function equipSpawnUpgrade(upgrade, ply, value)
    if (!IsValid(ply)) then return end
    if (upgrade.onlyOneInstance) then
        local faction = ply:GetVFFaction()
        local pts = faction:GetUpgradePointsByName("upgr_weapon")
        local point = nil
        for k, v in ipairs(pts) do
            if (!point) then
                point = v
            end

            if (v.posY > point.posY) then
                point = v
            end

            if (v.posY == point.posY and v.posX > point.posX) then
                point = v
            end
        end

        if (!point) then return end
        if (point.upgrade.value != value) then return end
    end

    upgrade.onRespawn(ply, value)
end

function UPGRADE_CLASS:Load(val, id)
    if (!self.onLoadFunc) then return end
    self.onLoadFunc(val, id)
end

function UPGRADE_CLASS:Equip(receiver, value)
    if (!self.onEquip) then return end

    if (receiver.id) then
        -- Faction
        for k, member in ipairs(receiver.members) do
            if (IsValid(member.ply)) then
                equipUpgrade(self, member.ply, value)
            end
        end
    else
        -- Member
        equipUpgrade(self, receiver.ply, value)
    end
end

function UPGRADE_CLASS:Respawn(receiver, value)
    if (!self.onRespawn) then return end

    if (receiver.id) then
        -- Faction
        for k, member in ipairs(receiver.members) do
            if (IsValid(member.ply)) then
                equipSpawnUpgrade(self, member.ply, value)
            end
        end
    else
        -- Member
        equipSpawnUpgrade(self, receiver.ply, value)
    end
end


-- Static functions

function VoidFactions.Upgrades:NewUpgrade()
	return UPGRADE_CLASS:New()
end

function VoidFactions.Upgrades:AddUpgrade(upgrade)
    if (!istable(upgrade)) then return end

    if (!upgrade.name) then
        VoidFactions.PrintError("An upgrade module does not have a name! Stack trace:")
        print(debug.traceback())
        return
    end

    if (!upgrade.onReset and upgrade.onlyOneInstance) then
        VoidFactions.PrintError("Upgrade module " .. upgrade.name .. " doesn't have a OnReset handler, and only one instance is allowed!")
        return
    end

    VoidFactions.Upgrades.Modules[upgrade.name] = upgrade
    VoidFactions.PrintDebug("Registered upgrade module " .. upgrade.name .. "!")
end

-- Other

hook.Add("VoidFactions.Upgrade.UpgradesReceived", "VoidFactions.Upgrades.OnReceived", function ()
    if (SERVER) then return end

    for k, point in pairs(VoidFactions.UpgradePoints.List) do
        point.upgrade.module:Load(point.upgrade.value, point.id)
    end

    hook.Remove("VoidFactions.Upgrade.UpgradesReceived", "VoidFactions.Upgrades.OnReceived")
end)

--addons/voidfactions-1.10.6/lua/voidfactions/classes/sh_faction.lua:
VoidFactions.Factions = VoidFactions.Factions or {}
VoidFactions.Faction = VoidFactions.Faction or {}

-- Validators

function VoidFactions.Faction:ValidateFaction(name, maxMembers, tag)
	local nameLength = utf8.len(name or "")
	local tagLength = utf8.len(tag or "")

	if (VoidFactions.Settings:IsDynamicFactions()) then
		local nameMatch = name:match(VoidFactions.Settings.Hardcoded.FactionNamePattern)
		if (nameMatch) then return false, "invalid_characters" end
		
		local tagMatch = tag:match(VoidFactions.Settings.Hardcoded.FactionTagPattern)
		if (tagMatch) then return false, "invalid_characters" end
	end

    if (nameLength < 3) then return false, "nameShort" end
	if (VoidFactions.Settings:IsStaticFactions()) then
    	if (maxMembers > 65534) then return false, "maxMembersLimit" end
	else
		if (nameLength > 25) then return false, "nameLong" end
		if (!VoidFactions.Config.NametagsDisabled and tagLength < 2) then return false, "tagShort" end
		if (!VoidFactions.Config.NametagsDisabled and tagLength > tonumber(VoidFactions.Config.MaxTagLength)) then return false, "tagLong" end
	end
    
    return true
end

-- Class

local FACTION_CLASS = {}
FACTION_CLASS.__index = FACTION_CLASS

function FACTION_CLASS:New(id, name, logo, color, xp, level, parentFaction, maxMembers, tag, inviteRequired, canCaptureTerritory, showBoard, isDefaultFaction, description, money)
	local newObject = setmetatable({}, FACTION_CLASS)
		newObject.id = id
		newObject.name = name
		newObject.description = description
		newObject.logo = logo
		newObject.color = color

		newObject.money = money or 0

		newObject.tag = tag

		newObject.ranks = nil
		newObject.members = nil
		newObject.upgrades = SERVER and {} or nil
		newObject.deposits = nil
		newObject.transactions = nil
		newObject.rewardValues = nil

		newObject.factionRewards = {} -- only serverside

		newObject.inviteRequired = inviteRequired or false
		newObject.canCaptureTerritory = canCaptureTerritory or false
		newObject.showBoard = showBoard or false
		newObject.isDefaultFaction = isDefaultFaction or false

		newObject.requiredUsergroups = {}

		newObject.maxMembers = maxMembers

		newObject.factionRank = nil -- nothing to do with member ranks - its the position in leaderboard
		
		newObject.xp = xp or 0
		newObject.level = level or 0
		newObject.spawnPos = spawnPos or nil
		newObject.parentFaction = parentFaction or nil

		newObject.spentUpgradePoints = 0
	return newObject
end

-- Static changers

function FACTION_CLASS:SetRequiredUsergroups(tbl)
	self.requiredUsergroups = tbl
end

function FACTION_CLASS:SetSpentUpgradePoints(n)
	self.spentUpgradePoints = n
end

function FACTION_CLASS:SetTag(tag)
	self.tag = tag
end

function FACTION_CLASS:SetFactionRanking(rank)
	self.factionRank = rank
end

function FACTION_CLASS:SetUpgrades(upgrades)
	self.upgrades = upgrades
end

function FACTION_CLASS:SetFactionRewards(rewards)
	self.factionRewards = rewards
end

function FACTION_CLASS:SetTransactions(transactions)
	self.transactions = transactions
end

function FACTION_CLASS:SetDeposits(deposits)
	self.deposits = deposits
end

function FACTION_CLASS:SetRewardValues(rewardValues)
	self.rewardValues = rewardValues
end

-- This is for preloading members!
function FACTION_CLASS:SetPreloaded(b)
	self.isPreloaded = b
end

function FACTION_CLASS:SetMaxMembers(max)
	self.maxMembers = max
end

function FACTION_CLASS:SetMemberCount(count)
	self.memberCount = count
end

function FACTION_CLASS:SetDescription(desc)
	self.description = desc
end

function FACTION_CLASS:SetMoney(money)
	self.money = money
end

function FACTION_CLASS:SetLowestRankMemberCount(count)
	self.lowestRankMemberCount = count
end

function FACTION_CLASS:SetMembers(members)
	self.members = members
end

function FACTION_CLASS:SetRanks(ranks)
	self.ranks = ranks
end

function FACTION_CLASS:SetLogo(logo)
	self.logo = logo
end

function FACTION_CLASS:ChangeName(newName)
	self.name = newName
end

function FACTION_CLASS:ChangeLogo(newLogo)
	self.logo = newLogo
end

function FACTION_CLASS:ChangeColor(newColor)
	self.color = newColor
end

function FACTION_CLASS:ChangeSpawnPos(newSpawnPos)
	self.spawnPos = newSpawnPos
end

function FACTION_CLASS:ChangeParentFaction(newParentFaction)
	self.parentFaction = newParentFaction
end

function FACTION_CLASS:SetInviteRequired(b)
	self.inviteRequired = b
end

function FACTION_CLASS:SetCanCaptureTerritory(b)
	self.canCaptureTerritory = b
end

function FACTION_CLASS:SetShowBoard(b)
	self.showBoard = b
end

function FACTION_CLASS:SetIsDefaultFaction(b)
	self.isDefaultFaction = b
end


-- Util functions

-- For dynamic factions
function FACTION_CLASS:GetMaxMembers()
	if (VoidFactions.Settings:IsStaticFactions()) then
		return self.maxMembers 
	end

	-- Calculate max members by upgrades
	return VoidFactions.Config.DefaultMaxMembers + self:SumOfUpgradeValues("upgr_maxmembers")
end

-- Don't confuse upgrade points (number) with upgrade points (skill tree) :D
function FACTION_CLASS:GetUpgradePoints()
	-- Calculate by current level and purchased upgrades
	return self.level - self.spentUpgradePoints - 1
end

function FACTION_CLASS:GetMaxItems()
	-- Calculate max items by upgrades
	return VoidFactions.Config.DefaultMaxItems + self:SumOfUpgradeValues("upgr_maxitems")
end

function FACTION_CLASS:GetSubfactions()
	if (VoidFactions.Settings:IsDynamicFactions()) then return {} end
	local tbl = SERVER and VoidFactions.Factions or VoidFactions.LoadedFactions
	local result = {}
	for k, v in pairs(tbl or {}) do
		if (v.parentFaction and v.parentFaction.id == self.id) then
			result[v.id] = v
		end
		if (v.parentFaction and v.parentFaction.parentFaction and v.parentFaction.parentFaction.id == self.id) then
			result[v.id] = v
		end
	end
	return result
end

function FACTION_CLASS:GetRootFaction()
	return self.parentFaction and self.parentFaction.parentFaction or self.parentFaction or self
end

-- Not to be confused with the faction XP level!!!! It depends on subfactions
function FACTION_CLASS:GetFactionLevel()
	local level = 0
	-- Root
	if (!self.parentFaction) then
		level = 1
	end
	-- Faction
	if (self.parentFaction) then
		level = 2
	end
	-- Subfaction
	if (self.parentFaction and self.parentFaction.parentFaction) then
		level = 3
	end
	return level
end

function FACTION_CLASS:GetLowestRank()
	local res = nil
	for id, rank in SortedPairsByMemberValue(self.ranks or {}, "weight") do
		res = rank
	end
	return res
end

function FACTION_CLASS:GetNextRank(_rank)
	local isNext = false
	for id, rank in SortedPairsByMemberValue(self.ranks or {}, "weight", true) do
		if (isNext) then
			if (rank.weight >= _rank.weight) then return nil end
			return rank
		end
		if (rank.id == _rank.id) then
			isNext = true
		end
	end
end

function FACTION_CLASS:GetPrevRank(_rank)
	local isNext = false
	for id, rank in SortedPairsByMemberValue(self.ranks or {}, "weight", false) do
		if (isNext) then
			if (rank.weight <= _rank.weight) then return nil end
			return rank
		end
		if (rank.id == _rank.id) then
			isNext = true
		end
	end
end

function FACTION_CLASS:NotifyMembers(upper, text, color, time)
	for k, member in pairs(self.members or {}) do
		local ply = member.ply
		if (IsValid(ply)) then
			VoidLib.Notify(ply, upper, text, color, time)
		end
	end
end

function FACTION_CLASS:GetUpgradeValue(id)
	for k, v in pairs(self.upgrades) do
		local upgradePoint = VoidFactions.UpgradePoints.List[k]
		if (!upgradePoint) then continue end

		if (k == id) then
			return upgradePoint.upgrade.value
		end
	end
end

function FACTION_CLASS:GetParentFactions()
	local factions = {}
	if (self.parentFaction) then
		factions[#factions + 1] = self.parentFaction

		local secondLevelFaction = self.parentFaction.parentFaction
		if (secondLevelFaction) then
			factions[#factions + 1] = secondLevelFaction

			local thirdLevelFaction = self.parentFaction.parentFaction.parentFaction
			if (thirdLevelFaction) then
				factions[#factions + 1] = thirdLevelFaction
			end
		end
	end

	return factions
end

function FACTION_CLASS:GetUpgradePointsByName(name)
	if (VoidFactions.Settings:IsStaticFactions() and !VoidFactions.Config.UpgradesEnabled) then return {} end
	local points = {}
	for k, v in pairs(self.upgrades or {}) do
		local upgradePoint = VoidFactions.UpgradePoints.List[k]
		if (!upgradePoint) then continue end
		if (!upgradePoint.upgrade) then continue end

		if (upgradePoint.upgrade.module.name == name) then
			points[#points + 1] = upgradePoint
		end
	end
	return points
end

function FACTION_CLASS:SumOfUpgradeValues(name)
	local sum = 0
	local points = self:GetUpgradePointsByName(name)
	for k, v in ipairs(points) do
		sum = sum + v.upgrade.value
	end
	return sum
end

function FACTION_CLASS:HasUpgrade(name)
	for k, v in pairs(self.upgrades) do
		local upgradePoint = VoidFactions.UpgradePoints.List[k]
		if (!upgradePoint) then continue end

		if (upgradePoint.upgrade and upgradePoint.upgrade.module.name == name) then
			return true
		end
	end

	return false
end

function FACTION_CLASS:HasMember(member)
	for k, _member in pairs(self.members) do
		if (member == _member) then return true end
	end
	return false
end

-- Dynamic changers

function FACTION_CLASS:AddXP(xp)
	if (!self.xp) then return end
	if (!xp) then return end
	if (VoidFactions.Config.DisableXP) then return end

	local intOverrideXP = hook.Run("VoidFactions.XP.OnGainXP", self, xp)
	if (intOverrideXP and isnumber(intOverrideXP)) then
		xp = intOverrideXP
	end
	
	local xpSum = self.xp + xp
	local requiredXP = 0

	-- Find how many times would the xp itself level up the member
	local allLevelsFound = false
	local totalXP = 0
	local prevLevel = self.level
	local remainingXP = 0
	while (!allLevelsFound) do
		local lvlRequiredXP = VoidFactions.XP:GetRequiredXP(prevLevel)

		requiredXP = requiredXP + lvlRequiredXP
		if (totalXP + lvlRequiredXP > xp) then
			remainingXP = (totalXP + lvlRequiredXP) - xp
			allLevelsFound = true
			break
		else
			totalXP = totalXP + lvlRequiredXP
			prevLevel = prevLevel + 1
		end
	end

	local lvlDiff = prevLevel - self.level
	if (lvlDiff > 0) then
		didLevelUp = true
		self:AddLevels(lvlDiff)
		self:LevelUp(true)

		self.xp = remainingXP
	else
		-- If the xp itself didn't level up the member, then the member can level up only once.
		if (xpSum >= requiredXP) then
			didLevelUp = true
			self:LevelUp()
			self.xp = xpSum - requiredXP
		else
			self.xp = xpSum
		end
	end

	VoidFactions.Faction:UpdateFactionXP(self, didLevelUp)
    self:SaveDynamic()
end

function FACTION_CLASS:SetXP(newXP)
	self.xp = newXP
end

function FACTION_CLASS:LevelUp()
	self:AddLevels(1)
end

function FACTION_CLASS:AddLevels(level)
	self.level = self.level + level
end

function FACTION_CLASS:SetLevel(newLevel)
	self.level = newLevel
end

-- Networking
function FACTION_CLASS:NetworkToPlayer(ply)
	if (CLIENT) then return end
	VoidFactions.PrintDebug("Networking faction info to player!")

	VoidFactions.Faction:NetworkToPlayer(ply, self)
end

-- NOT TO BE CONFUSED WITH STATIC AND DYNAMIC FACTIONS!
-- Save static info to database (name, logo, color, spawnPos, parentFaction)
function FACTION_CLASS:SaveStatic()
	if (!SERVER) then return end
	VoidFactions.SQL:SaveFactionInfo(self)
end

-- Save dynamic info to database (xp, level)
function FACTION_CLASS:SaveDynamic()
	if (!SERVER) then return end
	VoidFactions.SQL:SaveFactionXP(self)
end

-- Global functions

function VoidFactions.Faction:InitFaction(...)
	local faction = FACTION_CLASS:New(...)
	return faction
end

--addons/voidfactions-1.10.6/lua/voidfactions/modules/experience/territories.lua:
local MODULE = VoidFactions.XP:Module()
MODULE:SetID("TerritoryCapped") -- Translation -> string.lower -> prepend xp_

MODULE:Setup(function ()
    hook.Add("VoidFactions.CapturePoints.PointCaptured", "VoidFactions.XP.PointCapped", function (faction)
        MODULE:AddXP(faction)
    end)
end)

VoidFactions.XP:AddModule(MODULE)
--addons/voidfactions-1.10.6/lua/voidfactions/modules/upgrades/armorincrease.lua:
local UPGRADE = VoidFactions.Upgrades:NewUpgrade()

UPGRADE:Name("upgr_morearmor")
UPGRADE:Icon("ihR4cHk")

UPGRADE:Description("upgr_desc_morearmor")
UPGRADE:ValueDescription("upgr_descval_morearmor")

UPGRADE:FormatValue(function (val)
    return "+" .. val
end)

UPGRADE:OnReset(function (ply)
    if (!SERVER) then return end
end)

UPGRADE:OnRespawn(function (ply, val)
    if (!SERVER) then return end

    timer.Simple(1, function ()
        ply:SetArmor(ply:Armor() + val)
    end)
end)

VoidFactions.Upgrades:AddUpgrade(UPGRADE)
--addons/voidfactions-1.10.6/lua/voidfactions/modules/upgrades/healthincrease.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/modules/upgrades/jumpboost.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/net/capturepoints/cl_capturepoints.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/net/deposit/cl_deposit.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/net/deposit/cl_deposit.lua:

function VoidFactions.Deposit:DepositItem(itemClass, printName)
    net.Start("VoidFactions.Deposit.DepositItem")
        net.WriteString(itemClass)
        net.WriteString(printName) -- We have to send the printName because the SERVER does not know the printname
    net.SendToServer()
end

function VoidFactions.Deposit:WithdrawItem(id, name)
    net.Start("VoidFactions.Deposit.WithdrawItem")
        net.WriteUInt(id, 20)
        net.WriteString(name)
    net.SendToServer()
end

function VoidFactions.Deposit:DepositMoney(money)
    net.Start("VoidFactions.Deposit.DepositMoney")
        net.WriteUInt(money, 32)
    net.SendToServer()
end

function VoidFactions.Deposit:WithdrawMoney(money)
    net.Start("VoidFactions.Deposit.WithdrawMoney")
        net.WriteUInt(money, 32)
    net.SendToServer()
end
--addons/voidfactions-1.10.6/lua/voidfactions/net/helpers/sh_helpers.lua:
-- Enums

VoidFactions.Transactions = VoidFactions.Transactions or {}
VoidFactions.Rewards = VoidFactions.Rewards or {}

VoidFactions.Faction.Enums = {
	RANKS_UPDATE = 1,
	MEMBERS_UPDATE = 2,
	DEPOSITS_UPDATE = 3,
	XP_UPDATE = 4,
	UPGRADES_UPDATE = 5,
	REWARDS_UPDATE = 6
}

VoidFactions.Member.PromoteEnums = {
	PROMOTE = 1,
	DEMOTE = 2,
	RANK_UPDATE = 3
}

VoidFactions.CapturePoints.UpdateEnums = {
	CAPTURE_CHANGE = 1,
	CAPTURE_RESULT = 2,
	POINT_CONTESTED = 3,
	POINT_PAUSED = 4,
	CAPTURE_FACTIONCHANGE = 5
}

-- Helper functions

local function shallowCopy(t)
  local t2 = {}
  for k,v in pairs(t) do
    t2[k] = v
  end
  return t2
end

-- Point relationships

function VoidFactions.Upgrades:WriteRelationships(relations)
	net.WriteUInt(#relations, 10)
	for k, v in ipairs(relations) do
		net.WriteUInt(v.id, 10)
	end
end

function VoidFactions.Upgrades:ReadRelationships()
	local length = net.ReadUInt(10)
	local relations = {}
	for i = 1, length do
		relations[i] = net.ReadUInt(10)
	end

	return relations
end


-- Upgrade points

function VoidFactions.Upgrades:WritePoint(point)
	net.WriteUInt(point.id, 10)
	net.WriteUInt(point.upgrade.id, 10)
	net.WriteUInt(point.posX, 16)
	net.WriteUInt(point.posY, 16)

	VoidFactions.Upgrades:WriteRelationships(point.to)
end

function VoidFactions.Upgrades:ReadPoint()
	local id = net.ReadUInt(10)
	local upgradeId = net.ReadUInt(10)

	local posX = net.ReadUInt(16)
	local posY = net.ReadUInt(16)

	local upgrade = VoidFactions.Upgrades.Custom[upgradeId]

	local point = nil
	if (VoidFactions.UpgradePoints.List and VoidFactions.UpgradePoints.List[id]) then
		point = VoidFactions.UpgradePoints.List[id]
		point:SetPos(posX, posY)
	else
		point = VoidFactions.UpgradePoints:New(id, upgrade, posX, posY)
	end

	local relations = VoidFactions.Upgrades:ReadRelationships()
	point.toIds = relations

	return point
end

-- Global rewards

function VoidFactions.Rewards:WriteReward(reward)
	net.WriteUInt(reward.id, 10)
	net.WriteString(reward.name)
	net.WriteString(reward.module.name)

	net.WriteInt(reward.requiredValue, 32)

	net.WriteUInt(reward.money, 32)
	net.WriteUInt(reward.xp, 32)

	net.WriteString(reward.icon)
end

function VoidFactions.Rewards:ReadReward()
	local id = net.ReadUInt(10)
	local name = net.ReadString()
	local moduleName = net.ReadString()
	local requiredValue = net.ReadInt(32)
	local money = net.ReadUInt(32)
	local xp = net.ReadUInt(32)

	local icon = net.ReadString()

	local module = VoidFactions.RewardModules.List[moduleName]

	local reward = nil
	if (VoidFactions.Rewards.List and VoidFactions.Rewards.List[id]) then
		reward = VoidFactions.Rewards.List[id]

		reward:SetName(name)
		reward:SetModule(module)
		reward:SetRequiredValue(requiredValue)
		reward:SetMoneyReward(money)
		reward:SetXPReward(xp)
		reward:SetIcon(icon)
	else
		reward = VoidFactions.Rewards:New(id, name, module, requiredValue, money, xp, icon)
	end

	return reward
end

-- Faction reward values

function VoidFactions.FactionRewards:WriteReward(reward)
	net.WriteString(reward.module.name)
	net.WriteInt(reward.value, 32)
end

function VoidFactions.FactionRewards:ReadReward(faction)
	local name = net.ReadString()
	local value = net.ReadInt(32)

	local module = VoidFactions.RewardModules.List[name]

	local reward = nil
	if (faction.rewardValues and faction.rewardValues[name]) then
		reward = faction.rewardValues[name]
		reward:SetValue(value)
	else
		reward = VoidFactions.FactionRewards:New(module, value)
	end

	return reward
end

-- Upgrades (custom)

function VoidFactions.Upgrades:WriteUpgrade(upgrade)
	net.WriteUInt(upgrade.id, 10)
	net.WriteString(upgrade.name)
	net.WriteString(upgrade.module.name)
	net.WriteString(upgrade.value)
	net.WriteString(upgrade.currency.name)
	net.WriteUInt(upgrade.cost, 32)
	net.WriteString(upgrade.icon)
end

function VoidFactions.Upgrades:ReadUpgrade()
	local id = net.ReadUInt(10)
	local name = net.ReadString()
	local moduleName = net.ReadString()
	local value = net.ReadString()
	local currencyName = net.ReadString()
	local cost = net.ReadUInt(32)
	local icon = net.ReadString()

	local module = VoidFactions.Upgrades.Modules[moduleName]
	local currency = VoidFactions.Currencies.List[currencyName]

	local upgrade = nil
	if (VoidFactions.Upgrades.Custom and VoidFactions.Upgrades.Custom[id]) then
		upgrade = VoidFactions.Upgrades.Custom[id]

		upgrade:SetName(name)
		upgrade:SetModule(module)
		upgrade:SetValue(value)
		upgrade:SetCurrency(currency)
		upgrade:SetCost(cost)
		upgrade:SetIcon(icon)
	else
		upgrade = VoidFactions.CustomUpgrades:New(id, name, module, value, currency, cost, icon)
	end

	return upgrade
end

-- Transactions

function VoidFactions.Transactions:WriteTransaction(transaction)
	net.WriteUInt(transaction.time or 0, 32)
	net.WriteString(transaction.sid)
	net.WriteInt(transaction.difference, 32)
	net.WriteString(transaction.itemClass or "")
end

function VoidFactions.Transactions:ReadTransaction(faction)
	local time = net.ReadUInt(32)
	local sid = net.ReadString()
	local diff = net.ReadInt(32)
	local itemClass = net.ReadString()

	local transaction = VoidFactions.TransactionHistory:New(time, faction, sid, diff, itemClass)
	if (itemClass == "money") then
		transaction:SetIsMoney()
	end

	faction.transactions[#faction.transactions + 1] = transaction
	return transaction
end

-- Deposit items

function VoidFactions.DepositItem:WriteItem(item)
	net.WriteUInt(item.id, 20)
	net.WriteString(item.class)
	net.WriteString(item.dropEnt)
	net.WriteString(item.model or "")
	net.WriteTable(item.data or {})
	net.WriteBool(item.isExternal or false)
end

function VoidFactions.DepositItem:ReadItem(faction)
	local id = net.ReadUInt(20)
	local class = net.ReadString()
	local dropEnt = net.ReadString()
	local model = net.ReadString()
	local data = net.ReadTable()
	local isExternal = net.ReadBool()

	return VoidFactions.DepositItem:New(id, faction, class, dropEnt, model, data, isExternal)
end

-- Capture points

function VoidFactions.CapturePoints:WriteCapturePoint(point)
	net.WriteUInt(point.id, 6) -- 63 capture points is more than enough
	net.WriteUInt(point.radius, 16)
	net.WriteVector(point.pos)

	net.WriteUInt(point.captureStart or 0, 32)

	net.WriteBool(point.captureFaction and true or false)
	if (point.captureFaction) then
		net.WriteUInt(point.captureFaction.id, 20)
	end

	net.WriteUInt(#point.capturingPlayers, 7)
	for k, v in ipairs(point.capturingPlayers) do
		net.WriteEntity(v)
	end
end

function VoidFactions.CapturePoints:ReadCapturePoint()
	local id = net.ReadUInt(6)
	local radius = net.ReadUInt(16)
	local pos = net.ReadVector()

	local captureStart = net.ReadUInt(32)

	local captureFaction = nil
	if (net.ReadBool()) then
		local factionId = net.ReadUInt(20)
		captureFaction = VoidFactions.LoadedFactions[factionId]
	end

	local capturingPlayers = {}
	local capturingPlayersCount = net.ReadUInt(7)
	for i = 1, capturingPlayersCount do
		local ply = net.ReadEntity()
		capturingPlayers[#capturingPlayers + 1] = ply
	end

	local pointsTable = VoidFactions.PointsTable[id]
	if (pointsTable) then
		pointsTable:SetRadius(radius)
		pointsTable:SetPos(pos)
	else
		local capturePoint = VoidFactions.CapturePoints:InitCapturePoint(id, pos, radius)
		VoidFactions.PointsTable[id] = capturePoint

		pointsTable = capturePoint
	end

	pointsTable:SetCapturingPlayers(capturingPlayers)
	pointsTable:SetFaction(captureFaction)
	pointsTable:SetCaptureStart(captureStart)

	VoidFactions.PrintDebug("Read capture point ID " .. id .. "!")

	return pointsTable
end

-- Factions

function VoidFactions.Faction:WriteFaction(faction, noRanksMembers, onlyRanks, dontWriteParentFactions, ply, bPromoteIteration)
	net.WriteUInt(faction.id, 20)
	net.WriteString(faction.name)

	net.WriteBool(faction.isPreloaded and true or false)

	net.WriteBool(faction.description and true or false)
	if (faction.description) then
		net.WriteString(faction.description)
	end

	net.WriteBool(faction.logo and true or false)
	if (faction.logo) then
		net.WriteString(faction.logo)
	end

	net.WriteColor(faction.color)
	net.WriteString(faction.tag or "")

	net.WriteUInt(faction.memberCount or 0, 16)
	net.WriteUInt(faction.lowestRankMemberCount or 0, 16)

	if (VoidFactions.Settings:IsDynamicFactions()) then
		net.WriteUInt(faction.xp or 0, 32)
		net.WriteUInt(faction.level or 0, 10)

		net.WriteUInt(faction.money or 0, 32)
		net.WriteUInt(faction.spentUpgradePoints or 0, 24)
	end

	if (VoidFactions.Settings:IsStaticFactions()) then
		net.WriteUInt(faction.maxMembers or 0, 16)

		net.WriteUInt(#faction.requiredUsergroups, 16)
		for k, v in ipairs(faction.requiredUsergroups) do
			net.WriteString(v)
		end
	end

	local shouldWriteParentFaction = faction.parentFaction and !dontWriteParentFactions
	net.WriteBool(shouldWriteParentFaction and true or false)
	if (shouldWriteParentFaction) then
		-- net.WriteUInt(faction.parentFaction.id, 20)
		VoidFactions.Faction:WriteFaction(faction.parentFaction, false, true)
	end

	net.WriteBool(faction.inviteRequired)
	if (VoidFactions.Settings:IsStaticFactions()) then
		net.WriteBool(faction.canCaptureTerritory)
		net.WriteBool(faction.showBoard)
		net.WriteBool(faction.isDefaultFaction)
	end

	net.WriteBool(false)
	net.WriteBool(!noRanksMembers)

	if (!noRanksMembers) then

		-- Write ranks
		net.WriteUInt(table.Count(faction.ranks or {}), 7)
		for id, rank in pairs(faction.ranks or {}) do
			VoidFactions.Rank:WriteRank(rank, bPromoteIteration)
		end

		-- Custom upgrades
		net.WriteUInt(table.Count(VoidFactions.Upgrades.Custom or {}), 10)
		for k, upgrade in pairs(VoidFactions.Upgrades.Custom or {}) do
			VoidFactions.Upgrades:WriteUpgrade(upgrade)
		end

		-- Rewards
		net.WriteUInt(table.Count(faction.rewardValues or {}), 10)
		for k, reward in pairs(faction.rewardValues or {}) do
			VoidFactions.FactionRewards:WriteReward(reward)
		end

		-- Points
		net.WriteUInt(table.Count(VoidFactions.UpgradePoints.List or {}), 10)
		for k, point in pairs(VoidFactions.UpgradePoints.List or {}) do
			VoidFactions.Upgrades:WritePoint(point)
		end

		-- Unlocked upgrades
		net.WriteUInt(table.Count(faction.upgrades or {}), 10)
		for upgrade, _ in pairs(faction.upgrades or {}) do
			net.WriteUInt(upgrade, 10)
		end

		net.WriteBool(!onlyRanks)
		if (!onlyRanks) then
			-- Write members
			local membersToWrite = {}

			if (!faction.isPreloaded) then
				for k, v in ipairs(faction.members or {}) do
					if (!IsValid(v.ply)) then continue end
					table.insert(membersToWrite, v)
				end
			else
				membersToWrite = faction.members
			end

			net.WriteUInt(membersToWrite and #membersToWrite or 0, 16)
			for k, member in ipairs(membersToWrite or {}) do
				VoidFactions.Member:WriteMember(member, true)
			end
		end

	end
	
end

function VoidFactions.Faction:ReadFaction(noUpdate)
	local id = net.ReadUInt(20)
	local name = net.ReadString()

	local isPreloaded = net.ReadBool()

	local description = nil
	if (net.ReadBool()) then
		description = net.ReadString()
	end

	local logo = nil
	if (net.ReadBool()) then
		logo = net.ReadString()
	end

	local color = net.ReadColor()
	local tag = net.ReadString()

	local memberCount = net.ReadUInt(16)
	local lowestRankMemberCount = net.ReadUInt(16)

	local xp = nil
	local level = nil
	local money = nil
	local upgrPoints = 0
	if (VoidFactions.Settings:IsDynamicFactions()) then
		xp = net.ReadUInt(32)
		level = net.ReadUInt(10)
		money = net.ReadUInt(32)
		upgrPoints = net.ReadUInt(24)
	end

	local maxMembers = nil
	local tblRequiredGroups = {}
	if (VoidFactions.Settings:IsStaticFactions()) then
		maxMembers = net.ReadUInt(16)

		local intLen = net.ReadUInt(16)
		for i = 1, intLen do
			tblRequiredGroups[i] = net.ReadString()
		end
	end

	local parentFaction = nil
	if (net.ReadBool()) then
		-- parentFaction = net.ReadUInt(20)
		parentFaction = VoidFactions.Faction:ReadFaction()
	end

	local inviteRequired = net.ReadBool()

	local canCaptureTerritory = nil
	local showBoard = nil
	local isDefaultFaction = nil
	if (VoidFactions.Settings:IsStaticFactions()) then
		canCaptureTerritory = net.ReadBool()
		showBoard = net.ReadBool()
		isDefaultFaction = net.ReadBool()
	end

	-- If we already have a reference, use it
	local faction = VoidFactions.PlayerMember and VoidFactions.PlayerMember.faction
	if (faction and faction.id != id) then
		faction = nil
	end

	if (!faction) then
		faction = VoidFactions.LoadedFactions[id]
	end

	if (!faction or noUpdate) then
		faction = VoidFactions.Faction:InitFaction(id, name, logo, color, xp, level, nil, maxMembers, tag, inviteRequired, canCaptureTerritory, showBoard, isDefaultFaction, description, money)
		faction:SetMemberCount(memberCount)
		faction:SetSpentUpgradePoints(upgrPoints)
		faction:SetRequiredUsergroups(tblRequiredGroups)
		faction:SetLowestRankMemberCount(lowestRankMemberCount)
	else
		VoidFactions.PrintDebug("Faction object already exists, using it")
		faction:ChangeName(name)
		faction:ChangeLogo(logo)
		faction:ChangeColor(color)
		faction:SetXP(xp)
		faction:SetLevel(level)
		faction:SetMaxMembers(maxMembers)
		faction:SetTag(tag)
		faction:SetMemberCount(memberCount)
		faction:SetInviteRequired(inviteRequired)
		faction:SetCanCaptureTerritory(canCaptureTerritory)
		faction:SetShowBoard(showBoard)
		faction:SetIsDefaultFaction(isDefaultFaction)
		faction:SetDescription(description)
		faction:SetMoney(money)
		faction:SetSpentUpgradePoints(upgrPoints)
		faction:SetRequiredUsergroups(tblRequiredGroups)
		faction:SetLowestRankMemberCount(lowestRankMemberCount)
	end
	faction.parentFaction = parentFaction or faction.parentFaction
	faction.isPreloaded = isPreloaded

	if (net.ReadBool()) then
		-- only ranks
		local rankCount = net.ReadUInt(7)
		VoidFactions.PrintDebug("Received rank count: " .. rankCount)
		local ranks = {}
		for i = 1, rankCount do
			local rank = VoidFactions.Rank:ReadRank(faction)
			ranks[tonumber(rank.id)] = rank

			VoidFactions.PrintDebug("Read rank id " .. rank.id .. "!")
		end

		faction:SetRanks(ranks)
	end

	-- Is sending ranks and factions?
	if (net.ReadBool()) then

		-- Read ranks
		local rankCount = net.ReadUInt(7)
		VoidFactions.PrintDebug("Received rank count: " .. rankCount)
		local ranks = {}
		for i = 1, rankCount do
			local rank = VoidFactions.Rank:ReadRank(faction)
			ranks[tonumber(rank.id)] = rank

			VoidFactions.PrintDebug("Read rank id " .. rank.id .. "!")
		end

		faction:SetRanks(ranks)

		-- Upgrades
		local upgradeLength = net.ReadUInt(10)

		local upgrades = {}
		for i = 1, upgradeLength do
			local upgrade = VoidFactions.Upgrades:ReadUpgrade()
			upgrades[upgrade.id] = upgrade
		end

		VoidFactions.Upgrades.Custom = upgrades

		-- Reward values
		local rewardsLength = net.ReadUInt(10)

		local rewards = {}
		for i = 1, rewardsLength do
			local reward = VoidFactions.FactionRewards:ReadReward(faction)
			rewards[reward.module.name] = reward
		end

		faction:SetRewardValues(rewards)


		-- Points
		local pointLength = net.ReadUInt(10)

		local points = {}
		local pointsKeys = {}
		for i = 1, pointLength do
			local point = VoidFactions.Upgrades:ReadPoint()
			points[i] = point
			pointsKeys[point.id] = point
		end

		-- Assign the to's Tables
		for k, v in ipairs(points) do
			v.to = {}
			for _, to in ipairs(v.toIds) do
				local toPoint = pointsKeys[to]
				v:AddTo(toPoint)
			end
		end

		VoidFactions.UpgradePoints.List = pointsKeys

		local upgradeCount = net.ReadUInt(10)
		local upgrades = {}
		for i = 1, upgradeCount do
			local upgrade = net.ReadUInt(10)
			upgrades[upgrade] = true
		end

		faction:SetUpgrades(upgrades)

		

		if (net.ReadBool()) then
			-- Read members
			local memberCount = net.ReadUInt(16)
			local members = {}
			for i = 1, memberCount do
				local member = VoidFactions.Member:ReadMember(false, faction)
				members[i] = member
			end

			faction:SetMembers(members)
		end

	end

	return faction
end

-- Members

function VoidFactions.Member:WriteMember(member, onlyMember)

	if (member.lastPromotion == "NULL") then
		member.lastPromotion = 0
	end

	net.WriteString(member.sid)

	if (!VoidFactions.Settings:IsDynamicFactions()) then
		net.WriteUInt(member.xp or 0, 32)
		net.WriteUInt(member.level or 0, 10)
	end

	net.WriteUInt(member.playtime or 0, 20)
	net.WriteUInt(member.lastPromotion or 0, 32)
	net.WriteUInt(member.factionJoined or 0, 32)
	net.WriteEntity(member.ply)

	net.WriteUInt(member.lastSeen or 0, 32)
	
	if (!VoidFactions.Settings:IsDynamicFactions()) then
		net.WriteBool(member.defaultFactionId and true or false)
		if (member.defaultFactionId) then
			net.WriteUInt(member.defaultFactionId, 20)
		end
	end

	if (!VoidFactions.Settings:IsDynamicFactions()) then
		net.WriteBool(member.name and true or false)
		if (member.name) then
			net.WriteString(member.name)
		end
	end

	net.WriteBool(member.faction and member.faction.id and member.rank and true or false)
	if (member.faction and member.faction.id and member.rank) then
		net.WriteUInt(member.rank.id, 20)
		if (!VoidFactions.Settings:IsDynamicFactions()) then
			net.WriteUInt(member.job or 0, 20)
		end
	end

	net.WriteBool(member.faction and member.faction.id and !onlyMember and true or false) -- Is sending faction?
	if (member.faction and member.faction.id and !onlyMember) then
		VoidFactions.PrintDebug("Writing member's faction!")
		VoidFactions.Faction:WriteFaction(member.faction)
	end

	net.WriteBool(!onlyMember and true or false)
end

function VoidFactions.Member:ReadMember(member, faction)
	local sid = net.ReadString()

	local xp = 0
	local level = 0
	if (!VoidFactions.Settings:IsDynamicFactions()) then
		xp = net.ReadUInt(32)
		level = net.ReadUInt(10)
	end

	local playtime = net.ReadUInt(20)

	local lastPromotion = net.ReadUInt(32)
	local factionJoined = net.ReadUInt(32)
	local ply = net.ReadEntity()

	local lastSeen = net.ReadUInt(32)

	local defaultFactionId = nil
	if (!VoidFactions.Settings:IsDynamicFactions() and net.ReadBool()) then
		defaultFactionId = net.ReadUInt(20)
	end

	local name = nil
	if (!VoidFactions.Settings:IsDynamicFactions() and net.ReadBool()) then
		name = net.ReadString()
	end


	local readingFromFaction = faction and true or false

	-- Is sending rank?
	local rank = nil
	local readingRank = net.ReadBool()
	local rankId = nil
	local job = nil

	local wasReadingFaction = false

	if (readingRank) then
		VoidFactions.PrintDebug("Reading rank from member....")
		rankId = net.ReadUInt(20)
		if (!VoidFactions.Settings:IsDynamicFactions()) then
			job = net.ReadUInt(20)
		end
	end
	
	if (net.ReadBool()) then -- If is sending faction, load it
		VoidFactions.PrintDebug("Reading faction from member!")
		faction = VoidFactions.Faction:ReadFaction()
	end

	if (net.ReadBool()) then
		wasReadingFaction = true
	end

	if (faction and faction.ranks and readingRank) then
		rank = faction.ranks[rankId]
	end

	-- Try to find a reference to update
	if (!member) then
		if (VoidFactions.PlayerMember and VoidFactions.PlayerMember.sid == sid) then
			member = VoidFactions.PlayerMember
		else
			for k, _member in ipairs(faction and (faction.members or {}) or {}) do
				if (_member.sid == sid) then
					member = _member
				end
			end
		end
	end


	-- If reference found, then update it
	if (member) then
		member:SetXP(xp)
		member:SetLevel(level)
		member:SetPlaytime(playtime)
		member:SetLastPromotion(lastPromotion)
		member:SetLastSeen(lastSeen)
		member:SetDefaultFactionId(defaultFactionId)
		member:SetFactionJoined(factionJoined)

		if (wasReadingFaction) then
			member:SetFaction(faction)
			member:SetRank(rank)
			member:SetJob(job)
		end

		if (name) then
			member:SetName(name)
		end

		return member
	else
		-- Otherwise just make a new reference
		local member = VoidFactions.Member:InitMember(sid, ply, faction, xp, level, playtime, lastPromotion, rank, job, name, lastSeen, defaultFactionId, nil, factionJoined)
		return member
	end

end

-- Jobs

function VoidFactions.Rank:WriteJobs(tbl)
	net.WriteUInt(#tbl, 5)
	for k, v in ipairs(tbl) do
		net.WriteUInt(v, 20)
	end
end

function VoidFactions.Rank:ReadJobs()
	local length = net.ReadUInt(5)
	local jobs = {}
	for i = 1, length do
		jobs[i] = net.ReadUInt(20)
	end
	return jobs
end

-- Ranks

function VoidFactions.Rank:WriteRank(rank, bDontWritePromotes)
	net.WriteUInt(rank.id, 20)
	net.WriteUInt(rank.weight, 32)
	net.WriteString(rank.name)
	net.WriteString(rank.tag or "")

	net.WriteBool(rank.canInvite)
	net.WriteUInt(rank.canPromote, 2)
	net.WriteBool(rank.canPurchasePerks)
	net.WriteUInt(rank.kickMembers, 2)
	net.WriteBool(rank.manageFaction)
	net.WriteUInt(rank.canDemote or 0, 2)


	net.WriteUInt(rank.maxMembers or 0, 16)
	net.WriteUInt(rank.minLevel or 0, 12)

	net.WriteBool(rank.jobs and true or false)
	if (rank.jobs) then
		VoidFactions.Rank:WriteJobs(rank.jobs)
	end

	if (VoidFactions.Settings:IsStaticFactions()) then
		net.WriteUInt(rank.autoPromoteLevel, 12)

		net.WriteBool(!bDontWritePromotes and true or false)
		if (!bDontWritePromotes) then
			local promoteDefaults = shallowCopy(rank.promoteDefault or {})
			local shouldPromoteDefault = rank.faction != nil and (rank.faction != "template" and promoteDefaults[rank.faction.id] or false) or false
			net.WriteBool(shouldPromoteDefault and true or false) -- is the same faction??
			if (shouldPromoteDefault) then
				table.remove(promoteDefaults, rank.faction.id)
			end
			net.WriteUInt(table.Count(promoteDefaults), 20)
			for k, faction in pairs(promoteDefaults) do
				VoidFactions.Faction:WriteFaction(faction, false, true, true, nil, true)
			end
		end
	end

	if (VoidFactions.Settings:IsDynamicFactions() or VoidFactions.Config.DepositEnabled) then
		net.WriteBool(rank.canWithdrawMoney)
		net.WriteBool(rank.canDepositMoney)
		net.WriteBool(rank.canWithdrawItems)
		net.WriteBool(rank.canDepositItems)
	end
end


-- If called without faction, the existing members faction will be used!!!
function VoidFactions.Rank:ReadRank(faction, noPass)
	local id = net.ReadUInt(20)
	local weight = net.ReadUInt(32)
	local name = net.ReadString()
	local tag = net.ReadString()

	local canInvite = net.ReadBool()
	local canPromote = net.ReadUInt(2)
	local canPurchasePerks = net.ReadBool()
	local kickMembers = net.ReadUInt(2)
	local manageFaction = net.ReadBool()
	local canDemote = net.ReadUInt(2)


	local maxMembers = net.ReadUInt(16)
	local minLevel = net.ReadUInt(12)

	local jobs = nil
	if (net.ReadBool()) then
		jobs = VoidFactions.Rank:ReadJobs()
	end
	
	if (!faction and !noPass) then
		VoidFactions.PrintDebug("Faction not passed to ReadRank, using members current faction")
		faction = VoidFactions.PlayerMember.faction
	end

	local autoPromoteLevel = 0
	local bWritePromotes = false

	local promoteDefault = {}
	if (VoidFactions.Settings:IsStaticFactions()) then
		autoPromoteLevel = net.ReadUInt(12)
		bWritePromotes = net.ReadBool()

		if (bWritePromotes) then
			local isSameFaction = net.ReadBool()
			if (isSameFaction) then
				promoteDefault[faction.id] = faction
			end

			local facLen = net.ReadUInt(20)
			for i = 1, facLen do
				local fac = VoidFactions.Faction:ReadFaction()
				promoteDefault[fac.id] = fac
			end
		end
	end


	local canWithdrawMoney = nil 
	local canDepositMoney = nil
	local canWithdrawItems = nil 
	local canDepositItems = nil
	if (VoidFactions.Settings:IsDynamicFactions() or VoidFactions.Config.DepositEnabled) then
		canWithdrawMoney = net.ReadBool()
		canDepositMoney = net.ReadBool()
		canWithdrawItems = net.ReadBool()
		canDepositItems = net.ReadBool()
	end

	local rankRef = nil
	if (!noPass) then
		rankRef = faction.ranks and faction.ranks[id]
		if (!rankRef) then
			rankRef = VoidFactions.PlayerMember and VoidFactions.PlayerMember.rank
		end
	else
		rankRef = VoidFactions.RankTemplates and VoidFactions.RankTemplates[id]
	end

	-- Use the reference if it exists
	local rank = nil
	if (rankRef and rankRef.id == id) then
		VoidFactions.PrintDebug("Reusing rank reference")
		rank = rankRef
		rank:SetWeight(weight)
		rank:SetName(name)
		rank:SetTag(tag)

		if (bWritePromotes) then
			rank:SetPromoteDefault(promoteDefault)
		end

		rank.canInvite = canInvite
		rank.canPromote = canPromote
		rank.canPurchasePerks = canPurchasePerks
		rank.kickMembers = kickMembers
		rank.manageFaction = manageFaction
		rank.canDemote = canDemote

		rank.canWithdrawItems = canWithdrawItems
		rank.canDepositItems = canDepositItems
		rank.canWithdrawMoney = canWithdrawMoney
		rank.canDepositMoney = canDepositMoney

		rank.autoPromoteLevel = autoPromoteLevel

		rank.maxMembers = maxMembers
		rank:SetJobs(jobs)
		rank:SetMinLevel(minLevel)
	else
		VoidFactions.PrintDebug("Creating new rank object!")
		rank = VoidFactions.Rank:InitRank(id, faction, name, weight, tag, canInvite, canPromote, canDemote, canPurchasePerks, kickMembers, manageFaction, jobs, maxMembers, minLevel, canWithdrawMoney, canDepositMoney, canWithdrawItems, canDepositItems, autoPromoteLevel, promoteDefault)
	end

	return rank
	
end

--addons/voidfactions-1.10.6/lua/voidfactions/vgui/admin/dynamic_faction_settings.lua:
local L = VoidFactions.Lang.GetPhrase
local sc = VoidUI.Scale

local PANEL = {}

function PANEL:Init()
	self:SetOrigSize(1000, 556)
	self:SetTitle(string.upper(L"faction"))

	self.requestedPages = {}
	self.totalFactions = 0

	local container = self:Add("Panel")
	container:Dock(FILL)
	container.Paint = function (s, w, h)
		draw.RoundedBox(8, 0, 0, w, h, VoidUI.Colors.Primary)

		draw.SimpleText(string.upper(L("factionCount", self.totalFactions)), "VoidUI.B22", sc(20), sc(15), VoidUI.Colors.Gray)
		draw.RoundedBox(8, sc(30), sc(55), w-sc(60), sc(30), VoidUI.Colors.BackgroundTransparent)
		local textY = sc(55) + sc(15)

		local baseX = sc(30)
		local textX = sc(45)
		draw.SimpleText(string.upper(L"name"), "VoidUI.B22", textX, textY, VoidUI.Colors.Gray, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		
		textX = baseX + sc(320)
		draw.SimpleText(string.upper(L"level"), "VoidUI.B22", textX, textY, VoidUI.Colors.Gray, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

		textX = baseX + sc(500)
		draw.SimpleText(string.upper(L"members"), "VoidUI.B22", textX, textY, VoidUI.Colors.Gray, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

		textX = w - baseX - sc(100)
		draw.SimpleText(string.upper(L"actions"), "VoidUI.B22", textX, textY, VoidUI.Colors.Gray, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end

	local rowPanel = container:Add("Panel")
	rowPanel:Dock(FILL)
	rowPanel.Paint = function (s, w, h)
		draw.RoundedBox(8, 0, 0, w, h, VoidUI.Colors.BackgroundTransparent)
	end

	local rowContent = rowPanel:Add("VoidUI.RowPanel")
	rowContent:Dock(FILL)

	local pagination = container:Add("VoidUI.PaginationPanel")
    pagination:Dock(BOTTOM)
    pagination:SetTranslations(L"showingPagination", L"page", L"from")

    pagination:PageChange(function (page)
        self:RequestPage(page)
    end)

	self.container = container
	self.pagination = pagination
	self.rowContent = rowContent
	self.rowPanel = rowPanel

	self:AddHooks()
	self:RequestPage(1)
end

function PANEL:AddHooks()
	hook.Add("VoidFactions.Factions.ReceivedFactionPage", "VoidFactions.UI.FactionSettings.PageReceived", function (page, factions, totalFactions)
		if (!IsValid(self)) then return end
		self.requestedPages[page] = factions
		self:DisplayPage(page)

		if (totalFactions) then
			self.totalFactions = totalFactions
			self.pagination:TotalPages(math.ceil(totalFactions / 8))
		end
	end)
end

function PANEL:OnRemove()
	hook.Remove("VoidFactions.Factions.ReceivedRankingPage", "VoidFactions.UI.FactionSettings.PageReceived")
end

function PANEL:RequestPage(page)
	VoidFactions.Faction:RequestRankingPage(page, 8)
end

function PANEL:DisplayPage(page)
	self.rowContent:Clear()
	self.pagination:CurrentPage(page)
    self.pagination:SetFromTo(page*8-8+1, page*8)

	local member = VoidFactions.PlayerMember
    local memberFaction = member.faction

    local factions = self.requestedPages[page]
    for rank, faction in pairs(factions) do
        local row = self.rowContent:Add("Panel")
        row:Dock(TOP)
        row.Paint = function (self, w, h)
            draw.SimpleText(faction.name, "VoidUI.R22", sc(20), h/2, VoidUI.Colors.Gray, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
            draw.SimpleText(faction.level, "VoidUI.R22", sc(320), h/2, VoidUI.Colors.Gray, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            draw.SimpleText(faction.count .. "/" .. faction:GetMaxMembers(), "VoidUI.R22", sc(500), h/2, VoidUI.Colors.Gray, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end

        local manageButton = row:Add("VoidUI.Button")
        manageButton:SetText(L"manage")

        manageButton:Dock(RIGHT)
        manageButton:SSetWide(100)
        manageButton:SetMedium()
        manageButton:MarginRight(50)
        manageButton.rounding = 14
        
        manageButton.font = "VoidUI.R20"

        manageButton.DoClick = function ()
			local frame = vgui.Create("VoidFactions.UI.FactionCreate")
			frame:EditMode(faction)

			frame:OnSave(function (name)
				faction.name = name
			end)

			frame:OnDelete(function ()
				faction = nil
				row:Remove()
			end)
        end


        self.rowContent:AddRow(row, 23)
    end
end

function PANEL:PerformLayout(w, h)
	self.container:SDockPadding(10, 10, 10, 15, self)

	self.container:MarginSides(45, self)
	self.container:MarginTop(15, self)
	self.container:MarginBottom(35, self)

	self.rowPanel:MarginSides(20, self)
	self.rowPanel:MarginTop(80, self)
	self.rowPanel:MarginBottom(15, self)
	
	self.rowContent:MarginTop(10, self)

	self.pagination:SSetTall(30, self)
	self.pagination:MarginSides(20, self)
end


vgui.Register("VoidFactions.UI.DynamicFactionSettings", PANEL, "VoidUI.PanelContent")
--addons/voidfactions-1.10.6/lua/voidfactions/vgui/admin/setup_panel.lua:
local L = VoidFactions.Lang.GetPhrase

local PANEL = {}

function PANEL:Init()
    self:SetOrigSize(1000, 600)

    local setupPanel = self
    setupPanel:SetTitle(string.upper(L"chooseMode"))

    local cardContainer = setupPanel:Add("Panel")
    cardContainer:Dock(TOP)

    local staticCard = cardContainer:Add("VoidUI.Card")
    staticCard:Dock(LEFT)

    staticCard:SetAccent(VoidUI.Colors.Blue)

    staticCard:SetContent(L"staticFactionsContent")
    staticCard:SetFooter(L"suitedForSerious")
    staticCard:SetTitle(L"factions", L"static")

    if not DarkRP then
        staticCard:SetFooter("Only supported in DarkRP based gamemodes!")
    end

    staticCard.button:SetText(L"select")
    if (VoidFactions.Config.FactionType == VOIDFACTIONS_STATICFACTIONS) then
        staticCard.button:SetSelected(true)
    end
    staticCard.button.DoClick = function ()
        if (VoidFactions.Settings:IsDynamicFactions()) then
            -- Are you sure you want to switch? Wipe all data later
            local popup = vgui.Create("VoidUI.Popup")
            popup:SetText(L"switchType", L"switchTypePrompt")
            popup:SetDanger()
            popup:Continue(L"switch", function ()
                VoidFactions.Settings:UpdateConfig("FactionType", VOIDFACTIONS_STATICFACTIONS)
                self.dynamicCard.button:SetSelected(false)
                staticCard.button:SetSelected(true)

                self:Remove()
                VoidFactions.Menu.ReopenRequested = true
            end)
            popup:Cancel(L"cancel")
            popup:SSetTall(200)
        else
            self.dynamicCard.button:SetSelected(false)
            staticCard.button:SetSelected(true)

            VoidFactions.Settings:UpdateConfig("FactionType", VOIDFACTIONS_STATICFACTIONS)
        end
    end

    local dynamicCard = cardContainer:Add("VoidUI.Card")
    dynamicCard:Dock(RIGHT)

    dynamicCard:SetAccent(VoidUI.Colors.Green)
    dynamicCard:SetGradient(VoidUI.Colors.GreenGradientEnd, VoidUI.Colors.Green)

    dynamicCard:SetTitle(L"factions", L"dynamic")
    dynamicCard:SetContent(L"dynamicFactionsContent")
    dynamicCard:SetFooter(L"suitedForNonSerious")

    dynamicCard.button:SetText(L"select")
    dynamicCard.button.DoClick = function ()
        if (VoidFactions.Settings:IsStaticFactions()) then
            -- Are you sure you want to switch? Wipe all data later
            local popup = vgui.Create("VoidUI.Popup")
            popup:SetText(L"switchType", L"switchTypePrompt")
            popup:SetDanger()
            popup:Continue(L"switch", function ()
                VoidFactions.Settings:UpdateConfig("FactionType", VOIDFACTIONS_DYNAMICFACTIONS)
                dynamicCard.button:SetSelected(true)
                staticCard.button:SetSelected(false)
                self:Remove()

                VoidFactions.Menu.ReopenRequested = true
            end)
            popup:Cancel(L"cancel")
            popup:SSetTall(200)
        else
            dynamicCard.button:SetSelected(true)
            staticCard.button:SetSelected(false)

            VoidFactions.Settings:UpdateConfig("FactionType", VOIDFACTIONS_DYNAMICFACTIONS)
        end
    end
    
    if (VoidFactions.Config.FactionType == VOIDFACTIONS_DYNAMICFACTIONS) then
        dynamicCard.button:SetSelected(true)
    end

    self.setupPanel = setupPanel
    self.cardContainer = cardContainer
    self.staticCard = staticCard
    self.dynamicCard = dynamicCard

end

function PANEL:PerformLayout(w, h)
    self.setupPanel:SDockPadding(140,20,140,80,self)
    self.setupPanel.panelTitle:SSetTall(45, self)

    self.cardContainer:MarginTop(10, self)
    self.cardContainer:SSetTall(410, self)
    self.cardContainer:MarginSides(45, self)

    self.staticCard:SSetWide(300, self)
    self.dynamicCard:SSetWide(300, self)
end

vgui.Register("VoidFactions.UI.SetupPanel", PANEL, "VoidUI.PanelContent")
--addons/voidfactions-1.10.6/lua/voidfactions/vgui/dynamic/ranking_panel.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/vgui/static/job_selection.lua:
local sc = VoidUI.Scale
local L = VoidFactions.Lang.GetPhrase

local PANEL = {}

function PANEL:Init()
	self:SSetSize(600, 500)
	self:Center()

	self:SetTitle(L"editingProfile")
end

vgui.Register("VoidFactions.UI.JobSelection", PANEL, "VoidUI.ModalFrame")
--lua/wos/anim_extension/loader/loader.lua:
return gluapack()()
--lua/wos/anim_extension/extensions/wos_base.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Base" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted wiltOS Animation Base\n" )
--lua/wos/anim_extension/core/sh_prone_support.lua:
return gluapack()()
--lua/wos/anim_extension/holdtypes/melee_combo.lua:
local DATA = {}

DATA.Name = "Melee Combination"
DATA.HoldType = "melee-combo"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

--DATA.Translations[ ACT_MP_STAND_IDLE ]					= 2680
--DATA.Translations[ ACT_MP_WALK ]						= 2683
--DATA.Translations[ ACT_MP_RUN ]							= 2685
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= ACT_HL2MP_IDLE_CROUCH_KNIFE 
DATA.Translations[ ACT_MP_CROUCHWALK ]					= ACT_HL2MP_WALK_CROUCH_KNIFE
--DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= 2688
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= ACT_HL2MP_GESTURE_RANGE_ATTACK_KNIFE 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_JUMP ]						= 3160
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
--DATA.Translations[ ACT_LAND ]							= ACT_LAND

wOS.AnimExtension:RegisterHoldtype( DATA )
--lua/wos/dynabase/core/sh_core.lua:
// That's right, x64 won't work with .dat in this trick. Special thanks to 8Z
WOS_DYNABASE_FILE_EXTENSION = ".dat"
-- if jit.arch == "x64" then
-- 	WOS_DYNABASE_FILE_EXTENSION = ".txt"
-- end

wOS = wOS or {}
wOS.DynaBase = wOS.DynaBase or {}
wOS.DynaBase.DataCachePass = 0
wOS.DynaBase.InitCompleted = false

wOS.DynaBase.Registers = {}
wOS.DynaBase.RegisterCount = 0

wOS.DynaBase.EnforcedOrder = {}
wOS.DynaBase.EnforceCount = 1

wOS.DynaBase.PlayerOrder = {}
wOS.DynaBase.PlayerCount = 1

WOS_DYNABASE = WOS_DYNABASE or {}
WOS_DYNABASE.SHARED = 1
WOS_DYNABASE.MALE = 2
WOS_DYNABASE.FEMALE = 3
WOS_DYNABASE.ZOMBIE = 4
WOS_DYNABASE.MAXCACHE = 1

WOS_DYNABASE.EXTENSION = 1
WOS_DYNABASE.REANIMATION = 2

wOS.DynaBase.DefaultTable = {}
wOS.DynaBase.DefaultTable.Male = { "data/wos/dynabase/local_male" .. WOS_DYNABASE_FILE_EXTENSION, "models/m_wos.mdl" }
wOS.DynaBase.DefaultTable.Female = { "data/wos/dynabase/local_female" .. WOS_DYNABASE_FILE_EXTENSION, "models/f_wos.mdl" }
wOS.DynaBase.DefaultTable.Zombie = { "data/wos/dynabase/local_zombie" .. WOS_DYNABASE_FILE_EXTENSION, "models/z_wos.mdl" }
wOS.DynaBase.DefaultTable.Shared = { "data/wos/dynabase/local_shared" .. WOS_DYNABASE_FILE_EXTENSION }

wOS.DynaBase.FilteredLoadOrder = {}
wOS.DynaBase.FilteredPlayerOrder = {}

wOS.DynaBase.FilteredBlacklist = {}
wOS.DynaBase.FilteredPlayerBlacklist = {}

local flags = {FCVAR_REPLICATED, FCVAR_PROTECTED, FCVAR_ARCHIVE}
WOS_DYNABASE_ENFORCECONTENT_CVAR = CreateConVar( "wos_dynabase_restrict_client_content", "0", flags, "Prevents usage of custom content (animations) that are not registered on the server.\n \t0 = No Restrictions\n \t1 = Registered Addons\n \t2 = Registered and Mounted Addons" )
WOS_DYNABASE_ENFORCEREANIMATE_CVAR = CreateConVar( "wos_dynabase_restrict_client_reanimation", "1", flags, "Prevents clients from being able to customize what re-animations are locally enabled" )
WOS_DYNABASE_ENFORCEEXTENDERS_CVAR = CreateConVar( "wos_dynabase_restrict_client_extension", "1", flags, "Prevents clients from being able to customize what animation extensions are locally enabled" )
WOS_DYNABASE_LOADORDERENFORCE_CVAR = CreateConVar( "wos_dynabase_restrict_server_loadorder", "1", flags, "Enforces the order of animations as registered by the order of wos_dynabase_mountaddon command executions. Addons not specified will be mounted after the initial list" )
WOS_DYNABASE_MOUNTORDERLIST_CVAR = CreateConVar( "wos_dynabase_mountorder", "", flags, "Enforces the order of animations as comma seperated names of registered addons. Addons not specified will be mounted after the initial list unless content enforcement is set to 2. Any addons not installed are simply skipped" )
WOS_DYNABASE_MOUNTBLACKLIST_CVAR = CreateConVar( "wos_dynabase_blacklist", "", flags, "A comma seperated list of the names of blacklisted registered sources" )
WOS_DYNABASE_SHOULDHOTLOAD_CVAR = CreateConVar( "wos_dynabase_live_reload", "1", {FCVAR_ARCHIVE}, "Should animations reload in-game when changes are made automatically? If you are experiencing crashing issues, disable this" )

local function InitializeBase()
	if not wOS.DynaBase.InitCompleted then
		hook.Call( "InitLoadAnimations" )
	end
    wOS.DynaBase:ProcessLoadOrder()
	wOS.DynaBase:ReloadAnimations()

	if SERVER then
		if wOS.DynaBase.InitCompleted and not WOS_DYNABASE_SHOULDHOTLOAD_CVAR:GetBool() then return end
		RunConsoleCommand( "r_flushlod" )
	end

	wOS.DynaBase.InitCompleted = true
end

local function HandleMountOrderList( args )
    if not args or #args < 1 then 
		wOS.DynaBase.EnforceCount = 0
		wOS.DynaBase.EnforcedOrder = nil 
		return 
	end

	wOS.DynaBase.EnforcedOrder = {}
    wOS.DynaBase.EnforceCount = 0

	local tbl = string.Explode( ",", args )
	for _, arg in ipairs( tbl ) do
		if table.HasValue( wOS.DynaBase.EnforcedOrder, arg ) then continue end
		wOS.DynaBase.EnforceCount = wOS.DynaBase.EnforceCount + 1
		wOS.DynaBase.EnforcedOrder[ wOS.DynaBase.EnforceCount ] = arg
	end
end

cvars.AddChangeCallback("wos_dynabase_mountorder", function(_, oldargs, args)

	if SERVER then
		net.Start( "wOS.DynaBase.ForceMountCallback" )
			net.WriteString( oldargs )
			net.WriteString( args )
		net.Broadcast()
	end

	HandleMountOrderList( args )

    if not WOS_DYNABASE_LOADORDERENFORCE_CVAR:GetBool() then return end
	InitializeBase()
    wOS.DynaBase.InitCompleted = true
end)

hook.Add( "CreateTeams", "wOS.DynaBase.InitLoadAnimations", function()
	if wOS.DynaBase.InitCompleted then return end
	if WOS_DYNABASE_LOADORDERENFORCE_CVAR:GetBool() then
		HandleMountOrderList( WOS_DYNABASE_MOUNTORDERLIST_CVAR:GetString() )
	end
	InitializeBase()
end )

function wOS.DynaBase:RegisterSource( data )
	if not data then return end
	if not data.Name then return end
	self.Registers[ data.Name ] = data
	self.RegisterCount = self.RegisterCount + 1

	print( "[wOS-DynaBase] Registered new animation source: " .. data.Name )

	if data.PreventActivities then
		self:FixActivities( data )
	end

	if CLIENT then
		if data.IconOverwrite then
			self.Registers[ data.Name ].IconOverwrite = Material( data.IconOverwrite, "unlitgeneric" )
		end
		return
	end

	if not self.InitCompleted then return end
	net.Start( "wOS.DynaBase.SendRegister" )
		net.WriteString( data.Name )
	net.Broadcast()
end

function wOS.DynaBase:ProcessLoadOrder()
	if self.EnforceCount < 1 then self.FilteredLoadOrder = {} return end

	// Initialize it here so it can fail later
	self.FilteredLoadOrder[ WOS_DYNABASE.MALE ] = {}
	self.FilteredLoadOrder[ WOS_DYNABASE.FEMALE ] = {}
	self.FilteredLoadOrder[ WOS_DYNABASE.ZOMBIE ] = {}
	self.FilteredLoadOrder[ WOS_DYNABASE.SHARED ] = {}

	for _, name in ipairs( self.EnforcedOrder ) do
		local data = self:GetSource( name )
		if not data then continue end

		if data.Shared then
			table.insert( self.FilteredLoadOrder[ WOS_DYNABASE.SHARED ], data.Shared )
		end

		if data.Male then
			table.insert( self.FilteredLoadOrder[ WOS_DYNABASE.MALE ], data.Male )
		end

		if data.Female then
			table.insert( self.FilteredLoadOrder[ WOS_DYNABASE.FEMALE ], data.Female )
		end

		if data.Zombie then
			table.insert( self.FilteredLoadOrder[ WOS_DYNABASE.ZOMBIE ], data.Zombie )
		end
	end
end

function wOS.DynaBase:ProcessPlayerOrder()
	if self.PlayerCount < 1 then 
		self.FilteredPlayerBlacklist = {} 
		self.FilteredPlayerOrder = {} 
		return 
	end

	// Initialize it here so it can fail later
	self.FilteredPlayerOrder[ WOS_DYNABASE.MALE ] = {}
	self.FilteredPlayerOrder[ WOS_DYNABASE.FEMALE ] = {}
	self.FilteredPlayerOrder[ WOS_DYNABASE.ZOMBIE ] = {}
	self.FilteredPlayerOrder[ WOS_DYNABASE.SHARED ] = {}

	self.FilteredPlayerBlacklist[ WOS_DYNABASE.MALE ] = {}
	self.FilteredPlayerBlacklist[ WOS_DYNABASE.FEMALE ] = {}
	self.FilteredPlayerBlacklist[ WOS_DYNABASE.ZOMBIE ] = {}
	self.FilteredPlayerBlacklist[ WOS_DYNABASE.SHARED ] = {}

	for _, dt in ipairs( self.PlayerOrder ) do
		local name = dt.Name
		local data = self:GetSource( name )
		if not data then continue end

		if data.Shared then
			table.insert( ( !dt.Toggled and self.FilteredPlayerBlacklist[ WOS_DYNABASE.SHARED ] ) or self.FilteredPlayerOrder[ WOS_DYNABASE.SHARED ], data.Shared )
		end

		if data.Male then
			table.insert( ( !dt.Toggled and self.FilteredPlayerBlacklist[ WOS_DYNABASE.MALE ] ) or self.FilteredPlayerOrder[ WOS_DYNABASE.MALE ], data.Male )
		end

		if data.Female then
			table.insert( ( !dt.Toggled and self.FilteredPlayerBlacklist[ WOS_DYNABASE.FEMALE ] ) or self.FilteredPlayerOrder[ WOS_DYNABASE.FEMALE ], data.Female )
		end

		if data.Zombie then
			table.insert( ( !dt.Toggled and self.FilteredPlayerBlacklist[ WOS_DYNABASE.ZOMBIE ] ) or self.FilteredPlayerOrder[ WOS_DYNABASE.ZOMBIE ], data.Zombie )
		end
	end
end

function wOS.DynaBase:GetSourceCount()
	return self.RegisterCount
end

function wOS.DynaBase:GetAllSources()
	return self.Registers
end

function wOS.DynaBase:GetSource( name )
	return self.Registers[ name ]
end


// Need to register the base stuff LMAO
wOS.DynaBase:RegisterSource({
	Name = "Base Animations",
	Type = WOS_DYNABASE.REANIMATION,
	IconOverwrite = "wos/dynabase/gmod.png",
	Core = true,
	Male = "models/m_wos.mdl",
	Female = "models/f_wos.mdl",
	Zombie = "models/z_wos.mdl",
})

wOS.DynaBase:RegisterSource({
	Name = "Local Player Animations",
	Type = WOS_DYNABASE.REANIMATION,
	IconOverwrite = "wos/dynabase/local.png",
	Core = true,
	Male = "data/wos/dynabase/local_male" .. WOS_DYNABASE_FILE_EXTENSION,
	Female = "data/wos/dynabase/local_female" .. WOS_DYNABASE_FILE_EXTENSION,
	Zombie = "data/wos/dynabase/local_zombie" .. WOS_DYNABASE_FILE_EXTENSION,
	Shared = "data/wos/dynabase/local_shared" .. WOS_DYNABASE_FILE_EXTENSION,
})

--lua/wos/dynabase/core/cl_local_copy.lua:
wOS = wOS or {}
wOS.DynaBase = wOS.DynaBase or {}

function wOS.DynaBase:CreateUserMount( data )
	if not data then return end
	if not data.Name then return end
	self.UserMounts[ data.Name ] = data
	
	local mounts = file.Read( "wos/dynabase/usermounts/mounts.txt", "DATA" ) or "{}"
	local local_mounts = util.JSONToTable( mounts )

	local_mounts[ data.Name ] = data
	local_mounts = util.TableToJSON( local_mounts )
	file.Write( "wos/dynabase/usermounts/mounts.txt", local_mounts )
end

function wOS.DynaBase:DeleteUserMount( name )
	if not name then return end
	if not self.UserMounts[ name ] then return end
    self.UserMounts[ name ] = nil

	local mounts = file.Read( "wos/dynabase/usermounts/mounts.txt", "DATA" ) or "{}"
	local local_mounts = util.JSONToTable( mounts )
	local_mounts[ name ] = nil

	local_mounts = util.TableToJSON( local_mounts )
	file.Write( "wos/dynabase/usermounts/mounts.txt", local_mounts )
end

function wOS.DynaBase:GetAllUserMounts()
	return self.UserMounts
end

function wOS.DynaBase:GetUserMount( name )
	return self.UserMounts[ name ] 
end

function wOS.DynaBase:CreateLocalMenu( parent, old_data )
    old_data = old_data or {}
    local w, h = parent:GetSize()

    local frame = vgui.Create( "DFrame", parent )
    frame:SetSize( w*0.5, h*0.4 )
    frame:Center()
    frame:MakePopup()
    frame:SetTitle( "Create User Mount" )
    frame.OnClose = function()
        parent:Remove()
    end
    frame.OldThink = frame.Think
    frame.Think = function( pan )
        pan:OldThink()
        if parent:HasFocus() then pan:MoveToFront() end
        if not self.AnimMenu then parent:Remove() end 
    end

    local fw, fh = frame:GetSize()

    local addon_list = vgui.Create( "DListView", frame )
    addon_list:SetWide( fw*0.3 )
    addon_list:Dock( LEFT )
    addon_list:SetMultiSelect( false )
    addon_list:AddColumn( "Addon Name" )

    local row = addon_list:AddLine( "Base Game" )
    row.title = "GAME"

    for _, addon in ipairs( engine.GetAddons() ) do
        if not addon.downloaded then continue end
        if not addon.mounted then continue end
        local row = addon_list:AddLine( addon.title )
    end

    local browser = vgui.Create( "DFileBrowser", frame )
    browser:SetTall( fh )
    browser:SetWide( fw*0.4 )
    browser:Dock( LEFT )
    browser:SetPath( "GAME" )
    browser:SetBaseFolder( "models" )
    browser:SetFileTypes( "*.mdl" )
    browser:SetOpen( true )

    addon_list.OnRowSelected = function( pan, i, row )
        browser:SetPath( row.title or row:GetColumnText(1) )
        browser:SetBaseFolder( "models" )
        browser:SetOpen( true )
    end

    local div = vgui.Create( "DPanel", frame )
    div:SetBackgroundColor( Color( 0, 0, 0 ) )
    div:SetWide( fw*0.01 )
    div:Dock( LEFT )

    local creation_frame = vgui.Create( "DPanel", frame )
    creation_frame:SetWide( fw*0.29 )
    creation_frame:SetBackgroundColor( Color( 130, 130, 130 ) )
    creation_frame:Dock( LEFT )
    creation_frame:DockPadding( fw*0.005, 0, fw*0.01, 0 )

    local cw, ch = creation_frame:GetSize()

    local name_lab =  vgui.Create( "DLabel", creation_frame )
    name_lab:SetTextColor( color_white )
    name_lab:SetFont( "wOS.DynaBase.DescFont" )
    name_lab:SetText( "Name of User Mount" )
    name_lab:Dock( TOP )
    name_lab.DefaultCol = name_lab:GetColor()

    local name_ent = vgui.Create( "DTextEntry", creation_frame )
    name_ent:Dock( TOP )
    name_ent:SetFont( "DermaDefaultBold" )
    name_ent:SetText( old_data.Name or "" )
    name_ent:SetPlaceholderText( "Enter name of mount" )
    name_ent:DockMargin( fw*0.01, 0, 0, 0 )
    name_ent.OnGetFocus = function(pan)
        name_lab:SetTextColor( name_lab.DefaultCol )
    end

    local name =  vgui.Create( "DLabel", creation_frame )
    name:SetTextColor( color_white )
    name:SetFont( "wOS.DynaBase.DescFont" )
    name:SetText( "Shared Mounting Model" )
    name:Dock( TOP )
    name:DockMargin( 0, fh*0.02, 0, 0 )

    local share_ent = vgui.Create( "DTextEntry", creation_frame )
    share_ent:Dock( TOP )
    share_ent:SetFont( "DermaDefaultBold" )
    share_ent:SetText( old_data.Shared or "" )
    share_ent:SetPlaceholderText( "Enter path or right click on model in browser" )
    share_ent:DockMargin( fw*0.01, 0, 0, 0 )

    local name =  vgui.Create( "DLabel", creation_frame )
    name:SetTextColor( color_white )
    name:SetFont( "wOS.DynaBase.DescFont" )
    name:SetText( "Male Mounting Model" )
    name:Dock( TOP )
    name:DockMargin( 0, fh*0.02, 0, 0 )

    local male_ent = vgui.Create( "DTextEntry", creation_frame )
    male_ent:Dock( TOP )
    male_ent:SetText( old_data.Male or "" )
    male_ent:SetFont( "DermaDefaultBold" )
    male_ent:SetPlaceholderText( "Enter path or right click on model in browser" )
    male_ent:DockMargin( fw*0.01, 0, 0, 0 )

    local name =  vgui.Create( "DLabel", creation_frame )
    name:SetTextColor( color_white )
    name:SetFont( "wOS.DynaBase.DescFont" )
    name:SetText( "Female Mounting Model" )
    name:Dock( TOP )
    name:DockMargin( 0, fh*0.02, 0, 0 )

    local female_ent = vgui.Create( "DTextEntry", creation_frame )
    female_ent:Dock( TOP )
    female_ent:SetText( old_data.Female or "" )
    female_ent:SetFont( "DermaDefaultBold" )
    female_ent:SetPlaceholderText( "Enter path or right click on model in browser" )
    female_ent:DockMargin( fw*0.01, 0, 0, 0 )

    local name =  vgui.Create( "DLabel", creation_frame )
    name:SetTextColor( color_white )
    name:SetFont( "wOS.DynaBase.DescFont" )
    name:SetText( "Zombie Mounting Model" )
    name:Dock( TOP )
    name:DockMargin( 0, fh*0.02, 0, 0 )

    local zombie_ent = vgui.Create( "DTextEntry", creation_frame )
    zombie_ent:Dock( TOP )
    zombie_ent:SetText( old_data.Zombie or "" )
    zombie_ent:SetFont( "DermaDefaultBold" )
    zombie_ent:SetPlaceholderText( "Enter path or right click on model in browser" )
    zombie_ent:DockMargin( fw*0.01, 0, 0, 0 )

    local cancel = vgui.Create("DButton", creation_frame )
    cancel:SetTall( fh*0.05 )
    cancel:Dock( BOTTOM )
    cancel:SetText( "Cancel" )
    cancel.DoClick = function() frame:Close() end

    local save = vgui.Create("DButton", creation_frame )
    save:SetTall( fh*0.05 )
    save:Dock( BOTTOM )
    save:SetText( "Save User Mount" )
    save.DoClick = function()
        local name = name_ent:GetText()
        if #name < 1 then
            name_lab:SetTextColor( Color( 255, 0, 0 ) )
            surface.PlaySound( "buttons/button10.wav" )
            return
        end

        local tbl = {
            Name = name,
            Shared = ( #share_ent:GetText() > 1 and share_ent:GetText() ) or nil,
            Male = ( #male_ent:GetText() > 1 and male_ent:GetText() ) or nil,
            Female = ( #female_ent:GetText() > 1 and female_ent:GetText() ) or nil,
            Zombie = ( #zombie_ent:GetText() > 1 and zombie_ent:GetText() ) or nil,
        }
        if old_data.Name then
            self:DeleteUserMount( old_data.Name )
        end
        self:CreateUserMount( tbl )
        parent:RefreshList()
        frame:Close()
    end

    function browser:OnRightClick( path, pnl ) -- Called when a file is clicked
        local menu = DermaMenu()
        menu:AddOption( "Set as Shared Mount", function()
            share_ent:SetText( path )
        end ):SetIcon( "icon16/group.png" )

        menu:AddOption( "Set as Male Mount", function()
            male_ent:SetText( path )
        end ):SetIcon( "icon16/male.png" )

        menu:AddOption( "Set as Female Mount", function()
            female_ent:SetText( path )
        end ):SetIcon( "icon16/female.png" )

        menu:AddOption( "Set as Zombie Mount", function()
            zombie_ent:SetText( path )
        end ):SetIcon( "icon16/bug.png" )

        menu:Open()
    end

end

hook.Add( "Initialize", "wOS.DynaBase.LoadUserMounts", function()
	local mounts = file.Read( "wos/dynabase/usermounts/mounts.txt", "DATA" ) or "{}"
	local local_mounts = util.JSONToTable( mounts )		

	for mount, data in pairs( local_mounts ) do
		wOS.DynaBase.UserMounts[ mount ] = data
	end

end )
--lua/wos/dynabase/core/cl_config_menu.lua:
wOS = wOS or {}
wOS.DynaBase = wOS.DynaBase or {}
wOS.DynaBase.WorkshopCache = wOS.DynaBase.WorkshopCache or {}

local w, h = ScrW(),  ScrH()

local male_mat = "icon16/male.png"
local female_mat = "icon16/female.png"
local zombie_mat = "icon16/bug.png"
local shared_mat = "icon16/group.png"

local reanim_mat = "icon16/application_edit.png"
local extend_mat = "icon16/application_add.png"

surface.CreateFont( "wOS.DynaBase.TitleFont", {
	font = "Roboto Cn", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name
	extended = false,
	size = 24*(h/1200),
	weight = 1000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.DynaBase.QuestionFont", {
	font = "Roboto Cn", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name
	extended = false,
	size = 108*(h/1200),
	weight = 1000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.DynaBase.DescFont",{
	font = "Roboto Cn", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name
	extended = false,
	size = 18*(h/1200),
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.DynaBase.URLFont",{
	font = "Roboto Cn", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name
	extended = false,
	size = 12*(h/1200),
	weight = 300,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = true,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

local function GetContainingAddon( mdl )
	mdl = mdl or "models/m_anm.mdl"
	for _, addon in pairs( engine.GetAddons() ) do
		local modelFound = file.Find(mdl, addon.title)
		if #modelFound != 0 then return addon end 
	end
end

local function GetWorkshopInfo( addon, callback )
	if not addon or not callback then return end
	if wOS.DynaBase.WorkshopCache[ addon.wsid ] then 
		callback( wOS.DynaBase.WorkshopCache[ addon.wsid ].Data, wOS.DynaBase.WorkshopCache[ addon.wsid ].Icon )
		return
	end

	steamworks.FileInfo( addon.wsid, function( result )
		if not result then return end
		wOS.DynaBase.WorkshopCache[ addon.wsid ] = {}
		wOS.DynaBase.WorkshopCache[ addon.wsid ].Data = result
		if not result.previewid then return end
		steamworks.Download( result.previewid, true, function( cache )
			if not cache then callback( result, nil ) return end
			local mat = AddonMaterial(cache)

			// Jazztronauts taught me not to trust this little material
			local baseTex = ( mat and mat:GetTexture("$basetexture") ) or nil
			if baseTex == nil then
				mat = AddonMaterial(cache)
			end			
			wOS.DynaBase.WorkshopCache[ addon.wsid ].Icon =  mat
			callback( result, mat )
		end ) 
	end )
end

function wOS.DynaBase:OpenConfigMenu()

	if self.OverFrame then 
		self.OverFrame:Remove()
		self.OverFrame = nil
		gui.EnableScreenClicker( false )
		return 
	end

	self.OverFrame = vgui.Create( "DFrame" )
	self.OverFrame:SetSize( w, h )
	self.OverFrame:Center()
	self.OverFrame.Paint = function() end
	self.OverFrame:SetTitle( "" )
	self.OverFrame:ShowCloseButton( false )
	self.OverFrame:SetDraggable( false )
	
	gui.EnableScreenClicker( true )
	self.AnimMenu = vgui.Create( "DFrame", self.OverFrame )
	self.AnimMenu:SetSize( w*0.4, h*0.5 )
	self.AnimMenu:Center()
	self.AnimMenu:MakePopup()
	self.AnimMenu:SetTitle( "wiltOS Dynamic Animation Manager" )
	self.AnimMenu:ShowCloseButton( true )
	self.AnimMenu:SetDraggable( true )
	self.AnimMenu.OnClose = function( pan )
		self:OpenConfigMenu()
	end

	local aw, ah  = self.AnimMenu:GetSize()

	local sheet = vgui.Create( "DPropertySheet", self.AnimMenu )
	sheet:SetSize(aw*0.9, ah*0.8)
	sheet:SetPos(aw*0.05, ah*0.05)

	////////////////////////////////////////////////////////////////// Server Menu
	local scroll = vgui.Create("DScrollPanel", sheet )
	scroll:SetSize(aw*0.9, ah*0.8)
	local sw, sh = scroll:GetSize()
	sheet:AddSheet( "Server Animations", scroll, "icon16/server.png" )

	//placehold
	local layout2 
	local layout = vgui.Create("DListLayout", scroll)
	layout:SetSize(sw, sh)
	layout:SetPaintBackground(true)
	layout:SetBackgroundColor(Color(100, 100, 100))

	local temp_loaded = {}
	local temp_count = 0
	local drop_check = WOS_DYNABASE_ENFORCECONTENT_CVAR:GetInt() >= 2 and WOS_DYNABASE_LOADORDERENFORCE_CVAR:GetBool() 
	if !drop_check then
		layout:MakeDroppable( "WOS_DYNABASE_DROPPABLE" )
		layout.OnModified = function( pan, opnl )
			local opos = pan.DroppedPan.OrderPos
			local npos = opos
			local children = pan:GetChildren()
			for id, child in ipairs( children ) do
				if child != pan.DroppedPan then continue end
				npos = id
				break
			end

			if WOS_DYNABASE_LOADORDERENFORCE_CVAR:GetBool() and ( npos <= temp_count or opos <= temp_count ) then
				if IsValid( pan.DroppedPan.PreviousPanel ) and pan.DroppedPan.PreviousPanel != pan.DroppedPan then
					pan.DroppedPan:MoveToAfter( pan.DroppedPan.PreviousPanel )
				else
					pan.DroppedPan:MoveToBefore( pan.DroppedPan.ForwardPanel )
				end
				return
			end

			for id, child in ipairs( children ) do
				child.OrderPos = id
				child.PreviousPanel = children[id - 1]
				child.ForwardPanel = children[id + 1]
			end
		end
	end

	local lw, lh = layout:GetSize()
	local fw, fh = lw, lh*0.2
	local iw, ih = fh*0.9, fh*0.9

	local add_pad = lw*0.05

	local order_checker = {}
	local disabled_list = {}
	if WOS_DYNABASE_LOADORDERENFORCE_CVAR:GetBool() and self.EnforceCount >= 1 and self.EnforcedOrder then
		for cnt, name in ipairs( self.EnforcedOrder ) do
			local data = self:GetSource( name )
			if not data then continue end
			temp_loaded[ name ] = true
			temp_count = temp_count + 1
			table.insert( order_checker, data )
		end
	end

	if WOS_DYNABASE_ENFORCECONTENT_CVAR:GetInt() < 2 then

		if self.PlayerOrder and self.PlayerCount > 1 then
			for _, dt in ipairs( self.PlayerOrder ) do
				local name = dt.Name
				local data = self:GetSource( name )
				if not data then continue end
				disabled_list[ name ] = dt.Toggled
				if temp_loaded[ name ] then continue end
				temp_loaded[ name ] = true
				table.insert( order_checker, data )
			end
		end

		for name, data in pairs( self:GetAllSources() ) do
			if temp_loaded[ name ] then continue end
			table.insert( order_checker, data )
		end

	end

	for order, data in ipairs( order_checker ) do
		if WOS_DYNABASE_ENFORCECONTENT_CVAR:GetInt() >= 1 and not data.ServerValid then continue end
		local name  = data.Name
		local frame = vgui.Create( "DPanel", layout )
		local prev_child = layout:GetChild( order - 2 )
		if prev_child then
			frame.PreviousPanel = prev_child
			prev_child.ForwardPanel = frame
		end
		frame:SetSize( fw, fh )
		frame.Icon = data.IconOverwrite
		frame.RegisterName = name
		frame.PreventSort = order <= temp_count
		frame.OrderPos = order
		frame.Toggled = true
		if disabled_list[ name ] != nil then
			frame.Toggled = disabled_list[ name ]
		end

		frame.OnDrop = function( pan )
			layout.DroppedPan = pan
			return pan
		end
		frame.Paint = function( pan, ww, hh )
			draw.RoundedBox( 0, 0, 0, ww, hh, Color( 0, 0, 0, 155 ) )
			draw.RoundedBox( 0, ww*0.005, 0, add_pad, hh, Color( 0, 0, 0, 200 ) )

			surface.SetDrawColor( Color( 255, 255, 255, 100 ) )
			surface.DrawOutlinedRect( 0, 0, ww, hh )
			

			if !drop_check and not pan.PreventSort then
				surface.SetDrawColor( color_white )
				for i=0, 1 do
					surface.DrawRect( ww*0.005 + add_pad*0.2 + i*(add_pad*0.4), hh*0.32, add_pad*0.2, add_pad*0.2 )
				end

				for i=0, 1 do
					surface.DrawRect( ww*0.005 + add_pad*0.2 + i*(add_pad*0.4), hh*0.5, add_pad*0.2, add_pad*0.2 )
				end

				for i=0, 1 do
					surface.DrawRect( ww*0.005 + add_pad*0.2 + i*(add_pad*0.4), hh*0.68, add_pad*0.2, add_pad*0.2 )
				end
			end


			local tx, th = draw.SimpleText( pan.RegisterName, "wOS.DynaBase.TitleFont", hh*0.1 + add_pad + iw + ww*0.01, hh*0.06, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP  )
			tx, th = draw.SimpleText( pan.AddonTitle or "Local File", "wOS.DynaBase.DescFont", hh*0.1 + add_pad + iw + ww*0.01, hh*0.06 + th + hh*0.03, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP  )
				

			surface.SetDrawColor( color_white )
			if not pan.Icon then 
				surface.DrawOutlinedRect( hh*0.05 + add_pad , hh*0.05, iw, ih  )
				draw.SimpleText( "?", "wOS.DynaBase.QuestionFont", hh*0.05 + iw*0.5 + add_pad, hh*0.05 + ih*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER  )
			else
				surface.SetMaterial( pan.Icon )
				surface.DrawTexturedRect( hh*0.05 + add_pad, hh*0.05, iw, ih )
			end
			if pan.Toggled then return end
			draw.RoundedBox( 0, hh*0.05 + add_pad, hh*0.05, iw, ih, Color( 0, 0, 0, 215 ) )			

		end

		local url = vgui.Create( "DButton", frame )
		url:SetPos(fh*0.1 + fw*0.01 + iw + add_pad, fh - fh*0.15)
		url:SetSize(fw*0.43, fh*0.125)
		url:SetColor( color_white ) 
		url:SetFont( "wOS.DynaBase.URLFont" )
		url:SetText( "" )
		url.Paint = function( pan, ww, hh )
			local txt = pan.URL or "No Workshop URL"
			draw.SimpleText( txt, "wOS.DynaBase.URLFont", 0, hh*0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		end
		url:SetDisabled( true )
		url.DoClick = function( pan )
			if not pan.URL then return end
			gui.OpenURL( pan.URL )
		end

		local icon = vgui.Create("DImageButton", frame)
		icon:SetPos(lw*0.01 + add_pad, lw*0.01)
		icon:SetSize(iw, ih)

		local ix, iy = icon:GetPos()

		local validated = vgui.Create("DImage", icon)
		validated:SetPos( -8, -8 )
		validated:SetSize( 16, 16 )
		validated:NoClipping( true )
		validated.UpdateCast = function( pan )
			if !frame.Toggled then
				pan:SetImage( "icon16/delete.png" )
				icon:SetTooltip( "This item is currently disabled"  )
			else
				if data.ServerValid then
					pan:SetImage( "icon16/accept.png" )
					icon:SetTooltip( "This item is registered by the server and client"  )
				else
					pan:SetImage( "icon16/error.png" )		
					icon:SetTooltip( "This item is only registered by the client and may cause unpredictable issues"  )	
				end
			end
		end
		validated:UpdateCast()

		local dock_bar = vgui.Create( "DPanel", frame )
		dock_bar:SetPos(fh*0.1 + fw*0.01 + iw + add_pad , fh - fh*0.42)
		dock_bar:SetSize(fw*0.7, fh*0.2)
		dock_bar:SetPaintBackground( false )

		local thetype = vgui.Create("DImageButton", dock_bar)
		thetype:SetTall( fh*0.2 )
		thetype:SetWide( fh*0.2 )
		thetype:Dock( LEFT )

		if data.Type == WOS_DYNABASE.REANIMATION then
			thetype:SetImage( reanim_mat )
			thetype:SetTooltip( "This addon replaces existing animations" )	
		else
			thetype:SetImage( extend_mat )
			thetype:SetTooltip( "This addon includes new animations" )	
		end

		local div = vgui.Create("DPanel", dock_bar)
		div:SetWide( fh*0.22 )
		div:Dock( LEFT )
		div.Paint = function( pan, ww, hh )
			surface.SetDrawColor( color_white )
			surface.DrawRect( ww*0.45, 0, ww*0.1, hh )
		end
		
		local shared = vgui.Create("DImageButton", dock_bar)
		shared:SetTall( fh*0.2 )
		shared:SetWide( fh*0.2 )
		shared:SetImage( shared_mat )
		shared:Dock( LEFT )
		if data.Shared then
			shared:SetTooltip( "Common / All Gender Animations" )
		else
			shared:SetColor(Color(135, 135, 135, 255))
		end

		local maled = vgui.Create("DImageButton", dock_bar)
		maled:SetTall( fh*0.2 )
		maled:SetWide( fh*0.2 )
		maled:Dock( LEFT )
		maled:SetImage( male_mat )
		if data.Male then
			maled:SetTooltip( "Male Animations" )
		else
			maled:SetColor(Color(125, 125, 125, 125))
		end

		local femaled = vgui.Create("DImageButton", dock_bar)
		femaled:SetTall( fh*0.2 )
		femaled:SetWide( fh*0.2 )
		femaled:Dock( LEFT )
		femaled:SetImage( female_mat )
		if data.Female then
			femaled:SetTooltip( "Female Animations" )
		else
			femaled:SetColor(Color(125, 125, 125, 125))
		end

		local zombied = vgui.Create("DImageButton", dock_bar)
		zombied:SetTall( fh*0.2 )
		zombied:SetWide( fh*0.2 )
		zombied:Dock( LEFT )
		zombied:SetImage( zombie_mat )
		if data.Zombie then
			zombied:SetTooltip( "Zombie Animations" )
		else
			zombied:SetColor(Color(125, 125, 125, 125))
		end

		local mdl = data.Shared
		if not mdl then mdl = data.Male end
		if not mdl then mdl = data.Female end
		if not mdl then mdl = data.Zombie end

		if mdl then
			local function UpdateContent( ndat, mat )
				if ndat and ndat.id then
					frame.AddonTitle = ndat.title
					frame.Description = ndat.description
					frame.ID = ndat.id

					url.URL = "https://steamcommunity.com/sharedfiles/filedetails/?id=" .. ndat.id 
					url:SetDisabled( false )
				end
				frame.Icon = mat
			end
			local addon = GetContainingAddon( mdl )
			GetWorkshopInfo( addon, UpdateContent )
		end


		local check1 = data.Type == WOS_DYNABASE.REANIMATION and WOS_DYNABASE_ENFORCEREANIMATE_CVAR:GetBool()
		local check2 = data.Type == WOS_DYNABASE.EXTENSION and WOS_DYNABASE_ENFORCEEXTENDERS_CVAR:GetBool()
		if !check1 and !check2 then
			local div2 = vgui.Create("DPanel", dock_bar)
			div2:SetWide( fh*0.22 )
			div2:Dock( LEFT )
			div2.Paint = function( pan, ww, hh )
				surface.SetDrawColor( color_white )
				surface.DrawRect( ww*0.45, 0, ww*0.1, hh )
			end

			local toggle = vgui.Create("DButton", dock_bar)
			toggle:SetTall( fh*0.2 )
			if frame.Toggled then
				toggle:SetText( "Unmount Addon" )
			else
				toggle:SetText( "Mount Addon" )
			end
			toggle:SetWide( fw*0.15 )
			toggle:Dock( LEFT )
			toggle.DoClick = function( pan )
				frame.Toggled = !frame.Toggled
				if frame.Toggled then
					pan:SetText( "Unmount Addon" )
				else
					pan:SetText( "Mount Addon" )
				end
				validated:UpdateCast()
			end
		end

		layout:Add( frame )
	end


	////////////////////////////////////////////////////////////////// Local Menu

	-- if WOS_DYNABASE_ENFORCECONTENT_CVAR:GetInt() > 0 then
	-- 	local err = vgui.Create( "DPanel", sheet )
	-- 	err:Dock( FILL )
	-- 	err.Paint = function( pan, ww, hh )
	-- 		draw.SimpleText( "SERVER HAS DISABLED LOCAL ANIMATION CONTENT", "wOS.DynaBase.TitleFont", ww/2, hh*0.4, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	-- 		draw.SimpleText( "USE THE SERVER TAB FOR AVAILABILITY", "wOS.DynaBase.TitleFont", ww/2, hh*0.6, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
	-- 	end
	-- 	sheet:AddSheet( "User Animations", err, "icon16/user.png" )
	-- else

	local core = vgui.Create( "DPanel", sheet )
	core:SetSize(aw*0.9, ah*0.8)
	sheet:AddSheet( "User Animations", core, "icon16/user.png" )

	local create_butt = vgui.Create( "DButton", core )
	create_butt:SetSize( aw*0.9, ah*0.05 )
	create_butt:Dock( TOP )
	create_butt:SetText( "Create User Mount" )

	local scroll2 = vgui.Create("DScrollPanel", core )
	scroll2:SetSize(aw*0.9, ah*0.69)
	scroll2:Dock( TOP )

	local function PopulateEntries()
		if layout2 then layout2:Remove() end

		local sw, sh = aw*0.9, ah*0.73
		layout2 = vgui.Create("DListLayout", scroll2)
		layout2:SetSize(sw, sh)
		layout2:SetPaintBackground(true)
		layout2:SetBackgroundColor(Color(100, 100, 100))
		layout2:MakeDroppable( "WOS_DYNABASE_DROPPABLE_LOCAL" )

		local local_temp_loaded = {}
		local lw, lh = layout2:GetSize()
		local fw, fh = lw, lh*0.13
		local iw, ih = 0, 0

		local add_pad = lw*0.05

		local local_order_checker = {}

		local read = file.Read( "wos/dynabase/usermounts/preference.txt", "DATA" ) or "{}"
		local local_order = util.JSONToTable( read )
		local enabled_check = {}

		if table.Count( local_order ) > 0 then
			for id, dd in ipairs( local_order ) do
				local name = dd.Name
				local data = self:GetUserMount( name )
				if not data then continue end
				local_temp_loaded[ name ] = true
				table.insert( local_order_checker, data )
				if dd.Toggled then enabled_check[ name ] = true end
			end
		end

		for name, data in pairs( self:GetAllUserMounts() ) do
			if local_temp_loaded[ name ] then continue end
			table.insert( local_order_checker, data )
		end

		for order, data in ipairs( local_order_checker ) do
			local name  = data.Name
			local frame = vgui.Create( "DPanel", layout2 )
			frame:SetSize( fw, fh )
			frame.RegisterName = name
			frame.Toggled = enabled_check[ name ]
			frame.Paint = function( pan, ww, hh )
				draw.RoundedBox( 0, 0, 0, ww, hh, Color( 0, 0, 0, 155 ) )
				draw.RoundedBox( 0, ww*0.005, 0, add_pad, hh, Color( 0, 0, 0, 200 ) )

				surface.SetDrawColor( Color( 255, 255, 255, 100 ) )
				surface.DrawOutlinedRect( 0, 0, ww, hh )
				
				surface.SetDrawColor( color_white )
				for i=0, 1 do
					surface.DrawRect( ww*0.005 + add_pad*0.2 + i*(add_pad*0.4), hh*0.32, add_pad*0.2, add_pad*0.2 )
				end

				for i=0, 1 do
					surface.DrawRect( ww*0.005 + add_pad*0.2 + i*(add_pad*0.4), hh*0.5, add_pad*0.2, add_pad*0.2 )
				end

				for i=0, 1 do
					surface.DrawRect( ww*0.005 + add_pad*0.2 + i*(add_pad*0.4), hh*0.68, add_pad*0.2, add_pad*0.2 )
				end

				local tx, th = draw.SimpleText( pan.RegisterName, "wOS.DynaBase.TitleFont", hh*0.1 + add_pad + iw + ww*0.01, hh*0.06, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP  )					
			end

			local dock_bar = vgui.Create( "DPanel", frame )
			dock_bar:SetPos(fh*0.1 + fw*0.01 + iw + add_pad , fh - fh*0.42)
			dock_bar:SetSize(fw*0.7, fh*0.35)
			dock_bar:SetPaintBackground( false )

			local validated = vgui.Create("DImageButton", dock_bar )
			validated:SetTall( fh*0.35 )
			validated:SetWide( fh*0.35 )
			validated:Dock( LEFT )
			validated.UpdateCast = function( pan )
				if !frame.Toggled then
					pan:SetImage( "icon16/delete.png" )
					pan:SetTooltip( "This item is currently disabled"  )
				else
					pan:SetImage( "icon16/accept.png" )
					pan:SetTooltip( "This item is currently enabled"  )
					pan:CheckModelValidity()
				end
			end
			validated.CheckModelValidity = function( pan )
				for _, mdl in ipairs( pan.Models ) do
					if file.Exists( mdl, "GAME" ) then continue end
					pan:SetImage( "icon16/error.png" )
					pan:SetTooltip( "This item is missing models"  )
					return
				end
			end

			local div = vgui.Create("DPanel", dock_bar)
			div:SetWide( fh*0.22 )
			div:Dock( LEFT )
			div.Paint = function( pan, ww, hh )
				surface.SetDrawColor( color_white )
				surface.DrawRect( ww*0.45, 0, ww*0.1, hh )
			end
			
			local mdls = {}

			local shared = vgui.Create("DImageButton", dock_bar)
			shared:SetTall( fh*0.35 )
			shared:SetWide( fh*0.35 )
			shared:SetImage( shared_mat )
			shared:Dock( LEFT )
			if data.Shared then
				table.insert( mdls, data.Shared )
				shared:SetTooltip( "Common / All Gender Animations" )
			else
				shared:SetColor(Color(135, 135, 135, 255))
			end

			local maled = vgui.Create("DImageButton", dock_bar)
			maled:SetTall( fh*0.35 )
			maled:SetWide( fh*0.35 )
			maled:Dock( LEFT )
			maled:SetImage( male_mat )
			if data.Male then
				table.insert( mdls, data.Male )
				maled:SetTooltip( "Male Animations" )
			else
				maled:SetColor(Color(125, 125, 125, 125))
			end

			local femaled = vgui.Create("DImageButton", dock_bar)
			femaled:SetTall( fh*0.35 )
			femaled:SetWide( fh*0.35 )
			femaled:Dock( LEFT )
			femaled:SetImage( female_mat )
			if data.Female then
				table.insert( mdls, data.Female )
				femaled:SetTooltip( "Female Animations" )
			else
				femaled:SetColor(Color(125, 125, 125, 125))
			end

			local zombied = vgui.Create("DImageButton", dock_bar)
			zombied:SetTall( fh*0.35 )
			zombied:SetWide( fh*0.35 )
			zombied:Dock( LEFT )
			zombied:SetImage( zombie_mat )
			if data.Zombie then
				table.insert( mdls, data.Zombie )
				zombied:SetTooltip( "Zombie Animations" )
			else
				zombied:SetColor(Color(125, 125, 125, 125))
			end

			validated.Models = mdls
			validated:UpdateCast()

			local div2 = vgui.Create("DPanel", dock_bar)
			div2:SetWide( fh*0.22 )
			div2:Dock( LEFT )
			div2.Paint = function( pan, ww, hh )
				surface.SetDrawColor( color_white )
				surface.DrawRect( ww*0.45, 0, ww*0.1, hh )
			end

			local toggle = vgui.Create("DButton", dock_bar)
			toggle:SetTall( fh*0.2 )
			if frame.Toggled then
				toggle:SetText( "Unmount" )
			else
				toggle:SetText( "Mount" )
			end
			toggle:SetWide( fw*0.1 )
			toggle:Dock( LEFT )
			toggle.DoClick = function( pan )
				frame.Toggled = !frame.Toggled
				if frame.Toggled then
					pan:SetText( "Unmount" )
				else
					pan:SetText( "Mount" )
				end
				validated:UpdateCast()
			end

			local div3 = vgui.Create("DPanel", dock_bar)
			div3:SetWide( fh*0.22 )
			div3:Dock( LEFT )
			div3.Paint = function( pan, ww, hh )
				surface.SetDrawColor( color_white )
				surface.DrawRect( ww*0.45, 0, ww*0.1, hh )
			end

			local edit = vgui.Create("DButton", dock_bar)
			edit:SetTall( fh*0.2 )
			edit:SetWide( fw*0.1 )
			edit:Dock( LEFT )
			edit:SetText(  "Edit" )
			edit.DoClick = function( pan )
				if IsValid( pan.OverFrame ) then pan.OverFrame:Remove() pan.OverFrame = nil end
				pan.OverFrame = vgui.Create( "DPanel" )
				pan.OverFrame:SetPaintBackground( true )
				pan.OverFrame:SetBackgroundColor( Color( 0, 0, 0, 185  ) )
				pan.OverFrame:SetSize( w, h )
				pan.OverFrame:MakePopup()
				pan.OverFrame.RefreshList = function()
					PopulateEntries()
				end

				self:CreateLocalMenu( pan.OverFrame, data )
			end

			local div4 = vgui.Create("DPanel", dock_bar)
			div4:SetWide( fh*0.22 )
			div4:Dock( LEFT )
			div4.Paint = function( pan, ww, hh )
				surface.SetDrawColor( color_white )
				surface.DrawRect( ww*0.45, 0, ww*0.1, hh )
			end

			local delete = vgui.Create("DButton", dock_bar)
			delete:SetTall( fh*0.2 )
			delete:SetWide( fw*0.1 )
			delete:Dock( LEFT )
			delete:SetText(  "Delete" )
			delete.DoClick = function( pan )
				self:DeleteUserMount( name )
				PopulateEntries()
			end

			layout2:Add( frame )
		end
	end
	
	create_butt.DoClick = function(pan) 
		if IsValid( pan.OverFrame ) then pan.OverFrame:Remove() pan.OverFrame = nil end
		pan.OverFrame = vgui.Create( "DPanel" )
		pan.OverFrame:SetPaintBackground( true )
		pan.OverFrame:SetBackgroundColor( Color( 0, 0, 0, 185  ) )
		pan.OverFrame:SetSize( w, h )
		pan.OverFrame:MakePopup()
		pan.OverFrame.RefreshList = function()
			PopulateEntries()
		end

		self:CreateLocalMenu( pan.OverFrame )
	end

	PopulateEntries()


	////////////////////////////////////////////////////////////////// Helper Menu
	local scroll = vgui.Create("DScrollPanel", sheet )
	scroll:SetSize(aw*0.9, ah*0.8)
	scroll.ReloadAddons = function() PopulateEntries() end
	local sw, sh = scroll:GetSize()
	sheet:AddSheet( "Helper Functions", scroll, "icon16/heart.png" )

	local download_butt = vgui.Create( "DButton", scroll )
	download_butt:SetSize( aw*0.9, ah*0.05 )
	download_butt:Dock( TOP )
	download_butt:SetText( "Convert Server to User Mounts (Will overwrite mounts with the same name!)" )
	download_butt.DoClick = function(pan) 
		for name, data in pairs( self:GetAllSources() ) do
			if data.Core then continue end
			if data.PreventActivities then continue end
			self:CreateUserMount( data )
		end
		PopulateEntries()
		chat.AddText( color_white, "[", Color( 0, 175, 255 ), "wOS-DynaBase", color_white, "] All registered server mounts have been added to your user mount list!" )
	end
	hook.Call( "wOS.DynaBase.PopulateHelperFunctions", nil, scroll )


	local savebutt = vgui.Create("DButton", self.AnimMenu )
	savebutt:SetSize(aw*0.9, ah*0.04)
	savebutt:SetPos( aw*0.05, ah*0.86 )
	savebutt:SetText( "Save Animation Settings" )
	sheet.OnActiveTabChanged = function( pan, old, new )
		local txt = new:GetText()
		if txt:find( "User" ) then
			savebutt:SetText( "Save User Settings" )
			savebutt:Show()
		elseif txt:find( "Server" ) then
			savebutt:SetText( "Save Server Settings" )
			savebutt:Show()
		else
			savebutt:Hide()
		end
	end
	savebutt.DoClick = function( pan )
		if sheet:GetActiveTab():GetText():find( "User" ) then
			if not layout2 then return end
			local order = {}
			for _, child in ipairs( layout2:GetChildren() ) do
				table.insert( order, { Name = child.RegisterName, Toggled = child.Toggled } )
			end
			local pref = util.TableToJSON( order )
			file.Write( "wos/dynabase/usermounts/preference.txt", pref )
			self:ReloadLocalAnimations( order )
		else
			self.PlayerOrder = {}
			self.PlayerCount = 0
			for _, child in ipairs( layout:GetChildren() ) do
				table.insert( self.PlayerOrder, { Name = child.RegisterName, Toggled = child.Toggled } )
				self.PlayerCount = self.PlayerCount + 1
			end
			self:ProcessPlayerOrder()
		end
		self:ReloadAnimations()
	end

	local nobutt = vgui.Create("DButton", self.AnimMenu )
	nobutt:SetSize(aw*0.9, ah*0.04)
	nobutt:SetPos( aw*0.05, ah*0.91 )
	nobutt:SetText( "Cancel" )
	nobutt.DoClick = function() self:OpenConfigMenu() end
	//toggle:SetText( "Cancel" )
end
--lua/wos/dynabase/registers/wos_legacy_registers.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/libs/loader.lua:
XENINUI_SERVER = 1
XENINUI_CLIENT = 2
XENINUI_SHARED = 3

do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Loader",
    setName = function(self, name)
      self.name = name
      return self
    end,
    setAcronym = function(self, acronym)
      self.acronym = acronym
      return self
    end,
    setDirectory = function(self, directory)
      self.directory = directory
      return self
    end,
    setColor = function(self, color)
      self.color = color
      return self
    end,
    getName = function(self)
      return self.name
    end,
    getAcronym = function(self)
      return self.acronym
    end,
    getDirectory = function(self)
      return self.directory
    end,
    getColor = function(self)
      return self.color
    end,
    loadMessage = function(self, path, realm, col)
      if col == nil then col = self:getColor()
      end
      local __laux_type = (istable(path) and path.__type and path:__type()) or type(path)
      assert(__laux_type == "string", "Expected parameter `path` to be type `string` instead of `" .. __laux_type .. "`")
      if (XeninUI.DisableLoadMessages) then return end

      local name = self:getName()

      MsgC(self:getColor(), "[" .. tostring(name), col, " - " .. tostring(realm) .. "] ", color_white, "Loaded ", Color(0, 255, 0), tostring(path) .. "\n")
    end,
    loadFile = function(self, path, realm, func)
      local __laux_type = (istable(path) and path.__type and path:__type()) or type(path)
      assert(__laux_type == "string", "Expected parameter `path` to be type `string` instead of `" .. __laux_type .. "`")
      local __laux_type = (istable(realm) and realm.__type and realm:__type()) or type(realm)
      assert(__laux_type == "number", "Expected parameter `realm` to be type `number` instead of `" .. __laux_type .. "`")
      if (!string.EndsWith(path, ".lua")) then path = path .. ".lua"
      end

      local fullPath = self:getDirectory() .. "/" .. path
      if self.loadedFiles[path] then
        if (!self.suppressDuplicates and !XeninUI.DisableLoadMessages) then
          local name = self:getName()
          MsgC(XeninUI.Theme.Red, "[" .. tostring(name) .. "]", color_white, " " .. tostring(fullPath) .. " has already been loaded. Skipping\n")
        end

        return
      end

      local tbl = self.realms[realm]
      self:loadMessage(string.StripExtension(fullPath), tbl.name, tbl.color)
      func = func or tbl.func
      func(self, fullPath)

      self.loadedFiles[path] = true

      return self
    end,
    loadFileOrIgnore = function(self, ...)
      pcall(self:loadFile(...))

      return self
    end,
    load = function(self, dir, realm, recursive, options)
      if recursive == nil then recursive = false
      end
      if options == nil then options = {}
      end
      local __laux_type = (istable(dir) and dir.__type and dir:__type()) or type(dir)
      assert(__laux_type == "string", "Expected parameter `dir` to be type `string` instead of `" .. __laux_type .. "`")
      local __laux_type = (istable(realm) and realm.__type and realm:__type()) or type(realm)
      assert(__laux_type == "number" or __laux_type == "table", "Expected parameter `realm` to be type `number|table` instead of `" .. __laux_type .. "`")
      local __laux_type = (istable(recursive) and recursive.__type and recursive:__type()) or type(recursive)
      assert(__laux_type == "boolean", "Expected parameter `recursive` to be type `boolean` instead of `" .. __laux_type .. "`")
      local ignoreFiles = options.ignoreFiles or {}
      local overwriteRealm = options.overwriteRealm or {}
      local path = self:getDirectory()
      if (!string.EndsWith(path, "/")) then path = path .. "/"
      end
      if (!string.EndsWith(dir, "/")) then dir = dir .. "/"
      end

      local realmTbl = isnumber(realm) and self.realms[realm]
      local files, folders = file.Find(path .. dir .. "*", "LUA")
      for i, file in ipairs(files) do
        local name = string.StripExtension(file)
        if (ignoreFiles[name]) then continue end

        local fileRealm = realm
        local func = (realmTbl and realmTbl.func)
        local color = (realmTbl and realmTbl.color)
        local realmName = (realmTbl and realmTbl.name)
        if (istable(realm) or overwriteRealm[name]) then
          local realm = overwriteRealm[name] or realm[name]
          if realm then
            local tbl = self.realms[realm]
            func = tbl.func
            color = tbl.color
            realmName = tbl.name
            fileRealm = realm
          end
        end

        local filePath = dir .. file
        self:loadFile(filePath, fileRealm, func)
      end

      if recursive then
        for i, folder in ipairs(folders) do
          self:load(dir .. folder, realm, recursive, options)
        end
      end

      return self
    end,
    done = function(self)
      local time = math.Round(SysTime() - self.start, 4)
      local files = table.Count(self.loadedFiles)

      MsgC(self:getColor(), "[" .. self:getName() .. "]", color_white, " Finished loading " .. tostring(files) .. " files in " .. tostring(time) .. "s\n")
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self, suppressDuplicates)
      self.realms = {
        [1] = {
          color = XeninUI.Theme.Blue,
          name = "SV",
          func = function(self, path)
            if (CLIENT) then return end

            return include(path)
          end
        },
        [2] = {
          color = XeninUI.Theme.Orange,
          name = "CL",
          func = function(self, path)
            if CLIENT then
              return include(path)
            end

            AddCSLuaFile(path)
          end
        },
        [3] = {
          color = XeninUI.Theme.Purple,
          name = "SH",
          func = function(self, path)
            self.realms[XENINUI_CLIENT].func(self, path)
            return self.realms[XENINUI_SERVER].func(self, path)
          end
        }
      }
      self.suppressDuplicates = suppressDuplicates or !XeninUI.Debug
      self.start = SysTime()
      self.loadedFiles = {}
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Loader = _class_0
end

--addons/xenin_framework/lua/xeninui/libs/wyvern.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/libs/languages/network/client.lua:
local LanguagesNetwork
do
  local _class_0
  local _parent_0 = XeninUI.Network
  local _base_0 = {
    __name = "LanguagesNetwork",
    __base = XeninUI.Network.__base,
    receiveLanguage = function(self, ply)
      local addonId = net.ReadString()
      local lang = net.ReadString()
      local data = self:decompress()

      XeninUI.LanguageAddons[addonId]:SetLocalLanguage(lang, data)
    end,
    sendRequestLanguage = function(self, addonId, lang)
      self:send("XeninUI.Language", function(self)
        net.WriteString(addonId)
        net.WriteString(lang)
      end)
    end,
    __type = function(self)
      return "XeninUI.LanguagesNetwork"end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__index)
  _class_0 = setmetatable({
    __init = function(self)
      LanguagesNetwork.__parent.__init(self)

      self:receiver("XeninUI.Language", self.receiveLanguage)
    end,
    __base = _base_0,
    __parent = _parent_0
  }, {
    __index = function(cls, parent)
      local val = rawget(_base_0, parent)
      if val == nil then local _parent = rawget(cls, "__parent")
        if _parent then return _parent[parent]
        end
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0)
  end
  LanguagesNetwork = _class_0
end

XeninUI.LanguagesNetwork = LanguagesNetwork()

--addons/xenin_framework/lua/xeninui/libs/configurator/classes/entities.lua:
local Entities
do
  local _class_0
  local _base_0 = {
    __name = "Entities",
    getEntities = function(self)
      return self.entities
    end,
    register = function(self, name, entity)
      self.entities[name] = entity
    end,
    get = function(self, name)
      return self.entities[name]
    end,
    create = function(self, name)
      return self:get(name)()
    end,
    createSQLTable = function(self, entity)
      local inst = entity()
      local name = inst:getDatabaseEntity()
      XeninUI.Configurator:PrintMessage("Creating SQL table for entity " .. tostring(name))
      inst:createSQLTable()
    end,
    __type = function(self)
      return "XeninUI.Configurator.Entities"end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.entities = {}
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  Entities = _class_0
end
XeninUI.Configurator.Entities = XeninUI.Configurator.Entities || Entities()

hook.Add("Xenin.Configurator.InitialisedDatabase", "XeninUI.Configurator.Entities", function()
  local ents = XeninUI.Configurator.Entities
  for i, v in pairs(ents:getEntities()) do
    ents:createSQLTable(v)
  end
end)

--addons/xenin_framework/lua/xeninui/libs/configurator/ui/frame.lua:
local PANEL = {}

function PANEL:Init()
  if IsValid(XeninUI.Configurator.AdminMenu) then XeninUI.Configurator.AdminMenu:Remove()end

  XeninUI.Configurator.AdminMenu = self

  self:SetSize(1020, 800)
  self:Center()
  self:MakePopup()

  self.Top = self:Add("Xenin.Configurator.Admin.Top")
  self.Top:Dock(TOP)
  self.Top:DockMargin(16, 16, 16, 16)
  self.Top:SetText({
    "Title",
    "Subtitle"
  })

  self.Sidebar = self:Add("Xenin.Configurator.Admin.Sidebar")
  self.Sidebar:Dock(LEFT)
end

function PANEL:AddTab(...)
  self.Sidebar:AddTab(...)
end

function PANEL:SetActive(id)
  self.Sidebar:SetActive(id)
end

function PANEL:PerformLayout(w, h)
  self.Top:SetTall(40)
  self.Sidebar:SetWide(200)
end

function PANEL:Paint(w, h)
  local x, y = self:LocalToScreen()

  BSHADOWS.BeginShadow()
  draw.RoundedBox(6, x, y, w, h, XeninUI.Theme.Background)
  BSHADOWS.EndShadow(1, 2, 2, 255, 0, 0)

  draw.RoundedBoxEx(6, 0, 0, w, 40 + 32, XeninUI.Theme.Primary, true, true, false, false)
end

function PANEL:SetScript(script)
  local __laux_type = (istable(script) and script.__type and script:__type()) or type(script)
  assert(__laux_type == "string", "Expected parameter `script` to be type `string` instead of `" .. __laux_type .. "`")
  self.script = script
  local ctr = XeninUI.Configurator:FindControllerByScriptName(script)
  local tabs = ctr:getTabs()
  for i, v in ipairs(tabs) do
    self.Sidebar:AddTab(v.name, v.icon, v.color, v.panel, script, v)
  end
  self.Top:SetScript(script, ctr)
  self.Top:SetText(ctr:getTitle())
  self.Sidebar:SetActive(1)
end

vgui.Register("Xenin.Configurator.Admin", PANEL, "EditablePanel")

concommand.Add("xenin_config", function(ply, cmd, args)
  assert(XeninUI.Permissions:canAccessFramework(ply), "You don't have access to this config")
  local script = args[1]
  assert(isstring(script), "You need the script ID you're looking for")
  local controller = XeninUI.Configurator:FindControllerByScriptName(script)
  assert(controller != nil, "That script does not exist")

  local frame = vgui.Create("Xenin.Configurator.Admin")
  frame:SetScript(script)
end, function(cmd, args)
  local script = string.lower(string.Trim(args))
  local tbl = {}
  for i, v in ipairs(XeninUI.Configurator:GetControllers()) do
    if (#script > 0 and !v:getScript():find(script)) then continue end

    table.insert(tbl, "xenin_config " .. v:getScript())
  end


  table.sort(tbl, function(a, b)
    return a > b end)

  return tbl
end)

--addons/xenin_framework/lua/xeninui/libs/configurator/ui/search_bar.lua:
local function __laux_concat_0(...)
  local arr = {
  ...
  }
  local result = {}
  for _, obj in ipairs(arr) do
    for i = 1, #obj do
      result[#result + 1] = obj[i]
    end
    for k, v in pairs(obj) do
      if type(k) == "number" and k > #obj then result[k] = v
      elseif type(k) ~= "number" then
        result[k] = v
      end
    end
  end
  return result
end
local PANEL = {}

function PANEL:Init()
  self.textentry:SetUpdateOnType(true)
  self.textentry.OnValueChange = function(pnl, text)
    self:Search(text:lower())
  end
end

function PANEL:RemovePopup()
  if IsValid(self.Popup) then self.Popup:Remove()end
end

PANEL.OnRemove = PANEL.RemovePopup

XeninUI:CreateFont("Xenin.Configurator.Admin.SearchBar.Title", 18)
XeninUI:CreateFont("Xenin.Configurator.Admin.SearchBar.Subtitle", 13)

function PANEL:Paint(w, h)
  if IsValid(self.Popup) then
    return draw.RoundedBoxEx(self:GetRounded(), 0, 0, w, h, self:GetBackgroundColor(), true, true, false, false)
  end

  draw.RoundedBox(self:GetRounded(), 0, 0, w, h, self:GetBackgroundColor())
end

function PANEL:CreatePopup(results)
  local size = #results
  local x, y = self:GetPos()
  x = x + 16
  y = y + 16
  y = y + self:GetTall()
  local w = self:GetWide()
  local h = 16 + (size * 48 + ((size - 1) * 4))
  if (size == 0) then h = h + 30
  end

  self.Popup = XeninUI.Configurator.AdminMenu:Add("DPanel")
  self.Popup:SetPos(x, y)
  self.Popup:SetSize(w, h)
  self.Popup:SetZPos(100)
  self.Popup:SetDrawOnTop(true)
  self.Popup.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBoxEx(6, 0, 0, w, h, XeninUI.Theme.Navbar, false, false, true, true)
  end

  self.Popup.Layout = self.Popup:Add("DListLayout")
  self.Popup.Layout:DockPadding(8, 8, 8, 8)
  self.Popup.Layout:Dock(TOP)

  if (size == 0) then
    local panel = self.Popup.Layout:Add("DLabel")
    panel:SetText("No Results")
    panel:SetFont("Xenin.Configurator.Admin.SearchBar.Title")
    panel:SetTextColor(color_white)
    panel:SetContentAlignment(5)

    return
  end

  for i = 1, size do
    local result = results[i]
    local panel = self.Popup.Layout:Add("DButton")
    panel:DockMargin(0, 0, 0, 4)
    panel:SetText("")
    panel:SetTall(48)
    panel.Result = result
    panel.Color = XeninUI.Theme.Navbar
    local cat = {
      icon = result.icon,
      color = result.color
    }
    XeninUI:DownloadIcon(panel, cat.icon)
    local desc = result.desc
    if (#desc >= 58) then
      desc = result.desc:sub(1, 58 - 3) .. "..."
    end
    panel.Markup = markup.Parse("<font=Xenin.Configurator.Admin.SearchBar.Title><color=255,255,255>" .. tostring(result.name) .. "</color></font>")
    panel.Paint = function(pnl, w, h)
      XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.Color)
      XeninUI:DrawIcon(8, 8, h - 16, h - 16, pnl, cat.color)

      pnl.Markup:Draw(h, h / 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
      XeninUI:DrawShadowText(desc, "Xenin.Configurator.Admin.SearchBar.Subtitle", h, h / 2, Color(179, 179, 179), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, 150)

      surface.SetFont("Xenin.Configurator.Admin.SearchBar.Title")
      local tw, th = pnl.Markup:GetWidth(), pnl.Markup:GetHeight()
      surface.SetFont("Xenin.Configurator.Admin.SearchBar.Subtitle")
      local sw, sh = surface.GetTextSize(result.category)
      XeninUI:DrawRoundedBox(6, h + tw + 4, h / 2 - th / 2 - 6, sw + 8, sh, result.color or cat.color)
      local col = XeninUI:GetContrastColor(result.color or cat.color, color_white, Color(65, 65, 65))
      draw.SimpleText(result.category, "Xenin.Configurator.Admin.SearchBar.Subtitle", h + tw + 4 + 4, h / 2 - th / 2 - 6, col, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
    end
    panel.OnCursorEntered = function(pnl, w, h)
      pnl:LerpColor("Color", XeninUI.Theme.Background)
    end
    panel.OnCursorExited = function(pnl, w, h)
      pnl:LerpColor("Color", XeninUI.Theme.Navbar)
    end
    panel.DoClick = function(pnl)
      if result.onClick then
        result.onClick(pnl, XeninUI.Configurator.AdminMenu)
      end

      self:RemovePopup()
    end
  end
end

function PANEL:Find(text, search)
  return text:find(search, nil, nil, true)
end

function PANEL:SetScript(script, ctr)
  self.script = script
  self.ctr = ctr
end

function PANEL:AddToSearch(name, desc, category, id, extra)
  if extra == nil then extra = {}
  end
  table.insert(self.Results, __laux_concat_0({
    name = name,
    desc = desc,
    category = category,
    catId = id
  }, extra))
end

function PANEL:GetSettings()
  if (self:HasReachedSearchLimit()) then return end
end

function PANEL:HasReachedSearchLimit()
  return #self.Results >= 4
end

function PANEL:Search(text)
  self:RemovePopup()
  if (#text == 0) then return end
  self.Results = self.ctr:getSearch(text)

  self:CreatePopup(self.Results)
end

vgui.Register("Xenin.Configurator.Admin.SearchBar", PANEL, "XeninUI.TextEntry")

--addons/xenin_framework/lua/xeninui/libs/configurator/ui/entities/entity_list_row.lua:
local PANEL = {}

function PANEL:OnDelete() end
function PANEL:DoClick() end

function PANEL:SetEntity(entity, template, isList)
  local __lauxi0 = template.getListView(entity, isList)
  assert(__lauxi0 ~= nil, "cannot destructure nil value")
  local display, title, subtitle = __lauxi0.display, __lauxi0.title, __lauxi0.subtitle

  self.Entity = entity
  self.Title = markup.Parse("<font=Xenin.Configurator.Row.Title><color=255,255,255>" .. tostring(title) .. "</color></font>")
  self.Subtitle = markup.Parse("<font=Xenin.Configurator.Row.Subtitle><color=174,174,174>" .. tostring(subtitle) .. "</color></font>")
  self:SetDisplay(display)
end

function PANEL:Init()
  self.Edit = self:Add("XeninUI.ButtonV2")
  self.Edit:SetText("Edit")
  self.Edit:SetFont("Xenin.Configurator.Row.Title")
  self.Edit:SetSolidColor(XeninUI.Theme.GreenDark)
  self.Edit:SetRoundness(6)
  self.Edit.DoClick = function(pnl)
    self:DoClick()
  end

  self.Delete = self:Add("XeninUI.ButtonV2")
  self.Delete:SetVisible(false)
  self.Delete:SetText("")
  self.Delete:SetSolidColor(XeninUI.Theme.Red)
  self.Delete:SetRoundness(6)
  self.Delete.DoClick = function(pnl)
    self:OnDelete()
  end
  self.Delete.PaintOver = function(pnl, w, h)
    local size = h / 2
    surface.SetMaterial(XeninUI.Materials.CloseButton)
    surface.SetDrawColor(color_white)
    surface.DrawTexturedRect(w / 2 - size / 2 + 1, h / 2 - size / 2, size, size)
  end
end

function PANEL:Think()
  if (self.DeleteDisabled) then return end

  self.Delete:SetVisible(self:IsHovered() or self:IsChildHovered())
end

function PANEL:SetDisplay(display)
  if (!display) then return end
  if (IsValid(self.Display)) then return end

  self.Display = self:Add("SpawnIcon")
  self.Display:Dock(LEFT)
  self.Display:SetWide(56)
  self.Display.Model = display
  self.Display:SetMouseInputEnabled(false)


  timer.Simple(0, function()
    self.Display:SetModel(self.Display.Model)
  end)
end

function PANEL:Paint(w, h)
  XeninUI:DrawRoundedBox(6, 0, 0, w, h, XeninUI.Theme.Navbar)

  local x = h + 4

  self.Title:Draw(x, h / 2 + 1, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
  self.Subtitle:Draw(x, h / 2 + 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
end

function PANEL:PerformLayout(w, h)
  self.Edit:SizeToContentsX(24)
  self.Edit:SizeToContentsY(8)
  self.Edit:AlignRight(12)
  self.Edit:CenterVertical()

  self.Delete:SetSize(self.Edit:GetTall(), self.Edit:GetTall())
  self.Delete:AlignRight(w - self.Edit.x + 12)
  self.Delete:CenterVertical()
end

vgui.Register("Xenin.Configurator.Admin.EntityList.Row", PANEL)

--addons/xenin_framework/lua/xeninui/libs/configurator/ui/inputs/key.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/libs/configurator/ui/inputs/key.lua:
local x

--addons/xenin_framework/lua/xeninui/libs/configurator/ui/inputs/textentry.lua:
local x

--addons/xenin_framework/lua/xeninui/libs/configurator/ui/inputs/textentrylist.lua:
local x

--addons/xenin_framework/lua/xeninui/libs/configurator/ui/inputs/toggle.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/libs/players/ui/notifications/main.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/libs/players/ui/notifications/row.lua:
local PANEL = {}

function PANEL:Init()
  self.OnPaint = {}
  self.BackgroundColor = XeninUI.Theme.Primary
end

function PANEL:SetNotification(notification)
  self.Notification = notification
  if self.Notification.readAt then
    self.BackgroundColor = XeninUI.Theme.Navbar
  end
  self.TypeData = XeninUI.Notification:getType(notification.scriptId, notification.type)

  self.Hooks = self.TypeData.hooks and self.TypeData.hooks(notification)
  local hooks = self.Hooks
  if (hooks and hooks.preInit) then
    hooks.preInit(notification, self)
  end

  local img = self.TypeData.img(notification)
  if img.custom then
    img.custom(notification, self)
  elseif img.src then
    XeninUI:DownloadIcon(self, img.src, "Image")
    self:AddPaint(function(self, w, h)
      XeninUI:DrawIcon(8, 8, 48 - 16, 48 - 16, self, self.color, self.color, "Image")
    end)
  elseif img.ply then
    self.PlayerAvatar = self:Add("XeninUI.Avatar")
    self.PlayerAvatar:SetSteamID(img.ply.sid64, 64)
    self.PlayerAvatar:SetVertices(30)
  end

  self.Title = {
    text = self.Notification.content,
    font = "XeninUI.Players.Notifications.Row.Title",
    color = Color(232, 232, 232)
  }
  self.Subtitle = {
    text = XeninUI:DateToString(self.Notification.createdAt),
    font = "XeninUI.Players.Notifications.Row.Subtitle",
    color = Color(175, 175, 175)
  }

  self.Button = self:Add("DButton")
  self.Button:SetText("")
  self.Button.Color = Color(87, 87, 87)
  XeninUI:DownloadIcon(self.Button, "oRwjOoj")
  self.Button.Paint = function(pnl, w, h)
    local s = 48 - 19
    XeninUI:DrawIcon(h / 2 - s / 4, h / 2 - s / 2, s, s, pnl, pnl.Color)
  end
  self.Button.OnCursorEntered = function(pnl)
    pnl:LerpColor("Color", XeninUI.Theme.Accent)
  end
  self.Button.OnCursorExited = function(pnl)
    pnl:LerpColor("Color", Color(87, 87, 87))
  end
  self.Button.DoClick = function(pnl)
    if self.TypeData.options then
      local options = XeninUI.Options(pnl)
      for i, v in ipairs(self.TypeData.options) do
        v(notification, options, self)
      end
      options:create()
    end
  end
  self.Button:SetVisible(self.TypeData.options)

  if (hooks and hooks.postInit) then
    hooks.postInit(notification, self)
  end
end

function PANEL:AddPaint(func)
  table.insert(self.OnPaint, func)
end

function PANEL:CalculateHeight()
  local h = 7 + draw.GetFontHeight(self.Subtitle.font) + 4
  local w = self:GetWide()

  if (w == 64) then
    w = 719
  end
  local lines = XeninUI:TextToLines(self.Title.text, self.Title.font, w - 48 - 24 - 8)
  h = h + (#lines * (draw.GetFontHeight(self.Title.font) - 2))

  return h
end

XeninUI:CreateFont("XeninUI.Players.Notifications.Row.Title", 18)
XeninUI:CreateFont("XeninUI.Players.Notifications.Row.Subtitle", 12)

function XeninUI:TextToLines(text, font, maxWidth)
  surface.SetFont(font)

  local strings = text:Split("\n")
  local lines = {}

  for i, str in ipairs(strings) do
    local buffer = {}
    for word in str:gmatch("%S+") do
      local w, h = surface.GetTextSize(table.concat(buffer, " ") .. " " .. word)
      if (w > maxWidth) then
        table.insert(lines, table.concat(buffer, " "))
        buffer = {}
      end

      table.insert(buffer, word)
    end

    if (#buffer > 0) then
      table.insert(lines, table.concat(buffer, " "))
    end
  end

  return lines
end

function XeninUI:DrawTextMultiline(text, font, x, y, col, xAlign, yAlign, maxWidth, spacing)
  if spacing == nil then spacing = draw.GetFontHeight(font)
  end
  local lines = self:TextToLines(text, font, maxWidth)

  local offset = y
  for i, v in ipairs(lines) do
    draw.SimpleText(v, font, x, offset, col, xAlign, yAlign)

    offset = offset + (spacing - 3)
  end
end

function PANEL:Paint(w, h)
  draw.RoundedBox(6, 0, 0, w, h, self.BackgroundColor)

  for i, v in ipairs(self.OnPaint) do
    v(self, w, h)
  end

  local x = 48
  draw.SimpleText("Job Disabled - " .. self.Subtitle.text, self.Subtitle.font, x, 7, self.Subtitle.color, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
  XeninUI:DrawTextMultiline(self.Title.text, self.Title.font, x, 7 + draw.GetFontHeight(self.Subtitle.font) * 2 + 4, self.Title.color, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM, w - 48 - 24 - 8)
end

function PANEL:PerformLayout(w, h)
  if IsValid(self.PlayerAvatar) then
    self.PlayerAvatar:SetPos(8, 8)
    self.PlayerAvatar:SetSize(h - 16, h - 16)
  end

  if IsValid(self.Button) then
    self.Button:SetSize(h - 8, h - 8)
    self.Button:AlignRight(0)
    self.Button:CenterVertical()
  end
end

vgui.Register("XeninUI.Players.Notifications.Row", PANEL)

--addons/xenin_framework/lua/xeninui/elements/breadcrumbs.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/elements/breadcrumbs.lua:
local PANEL = {}

XeninUI:CreateFont("XeninUI.Breadcrumbs", 22)

local matArrow = Material("xenin/next.png", "smooth")

function PANEL:Init()
  self.Buttons = {}
end

function PANEL:SetBreadcrumbs(tbl)
  self.Location = tbl
  for i, v in ipairs(self.Buttons) do
    v:Remove()
    self.Buttons[i] = nil
  end

  for i, v in ipairs(tbl) do
    self:CreateBreadcrumb(v, i)
  end

  self:InvalidateLayout(true)
end

function PANEL:CreateBreadcrumb(data, index)
  local size = #self.Location
  local isLast = size == index
  local name = istable(data) and data.name or data
  local onClick = istable(data) and data.onClick or function()
    return true end

  local btn = self:Add("DButton")
  btn:Dock(LEFT)
  btn:DockMargin(0, 0, 16, 0)
  btn:SetText(name)
  btn:SetExpensiveShadow(1)
  btn:SetFont("XeninUI.Breadcrumbs")
  btn:SizeToContentsX(10)
  btn.TextColor = isLast and XeninUI.Theme.Accent or Color(185, 185, 185)
  btn.IsActive = isLast
  btn.Alpha = 0
  btn.Paint = function(pnl, w, h)
    pnl:SetTextColor(pnl.TextColor)

    if (pnl.Alpha > 0) then
      XeninUI:DrawRoundedBox(6, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Accent, pnl.Alpha))
    end
  end
  btn.OnCursorEntered = function(pnl)
    pnl:LerpColor("TextColor", color_white)
    pnl:Lerp("Alpha", 255)
  end
  btn.OnCursorExited = function(pnl)
    pnl:LerpColor("TextColor", pnl.IsActive and XeninUI.Theme.Accent or Color(185, 185, 185))
    pnl:Lerp("Alpha", 0)
  end
  btn.DoClick = function(pnl)
    local close = onClick(pnl.IsActive, pnl)

    if close then
      self:RemoveTo(pnl:GetText())
    end
  end

  table.insert(self.Buttons, btn)

  self:CorrectColors()
end

function PANEL:CorrectColors()
  local size = #self.Buttons
  for i, v in ipairs(self.Buttons) do
    local isHovered = v:IsHovered()
    local isActive = i == size
    if (isHovered and isActive) then continue end

    v.IsActive = i == size
    v.TextColor = i == size and XeninUI.Theme.Accent or Color(185, 185, 185)
  end
end

function PANEL:AddBreadcrumb(name, onClick)
  local breadcrumb = onClick and {
    name = name,
    onClick = onClick
  } or name
  local id = table.insert(self.Location, breadcrumb)

  self:CreateBreadcrumb(breadcrumb, id)
  self:InvalidateLayout()
end

function PANEL:RemoveTo(removeToName)
  for i = #self.Location, 1, -1 do
    local breadcrumb = self.Location[i]
    local name = istable(breadcrumb) and breadcrumb.name or breadcrumb

    if (name == removeToName) then
      self.Buttons[i].IsActive = true

      break
    end

    table.remove(self.Location, i)
    if IsValid(self.Buttons[i]) then
      self.Buttons[i]:Remove()
      self.Buttons[i] = nil
    end
  end

  self:CorrectColors()
  self:InvalidateLayout()
end

function PANEL:PerformLayout(w, h)
  self:SizeToContentsX()
end

function PANEL:Paint(w, h)
  local x = 0
  local size = #self.Buttons
  for i, v in ipairs(self.Buttons) do
    if (i == size) then continue end

    surface.SetFont(v:GetFont())
    local tw = surface.GetTextSize(v:GetText())
    x = x + tw + 10 + 16

    surface.SetDrawColor(i == (size - 1) and XeninUI.Theme.Accent or Color(185, 185, 185))
    surface.SetMaterial(matArrow)
    surface.DrawTexturedRect(x - 12, h / 2 - h / 5 + 2, h / 2.5, h / 2.5)
  end
end

function PANEL:SizeToContentsX()
  local w = 0

  surface.SetFont("XeninUI.Breadcrumbs")
  local size = #self.Buttons
  for i, v in ipairs(self.Buttons) do
    local tw = surface.GetTextSize(v:GetText())
    tw = tw + 10

    if (i != size) then
      tw = tw + 16
    end

    w = w + tw
  end

  self:SetWide(w)
end

vgui.Register("XeninUI.Breadcrumbs", PANEL)

--addons/xenin_framework/lua/xeninui/elements/category.lua:
XeninUI:CreateFont("XeninUI.Category.Title", 20)

XENINUI_LAYOUT_GRID = 1
XENINUI_LAYOUT_ROW = 2

local PANEL = {}

AccessorFunc(PANEL, "m_topHeight", "TopHeight")
AccessorFunc(PANEL, "m_expanded", "Expanded")
AccessorFunc(PANEL, "m_topColor", "TopColor")
AccessorFunc(PANEL, "m_topColorHover", "TopColorHover")
AccessorFunc(PANEL, "m_topColorActive", "TopColorActive")
AccessorFunc(PANEL, "m_topTextColor", "TopTextColor")
AccessorFunc(PANEL, "m_topTextColorHover", "TopTextColorHover")
AccessorFunc(PANEL, "m_topTextColorActive", "TopTextColorActive")
AccessorFunc(PANEL, "m_rounded", "Rounded")
AccessorFunc(PANEL, "m_icon", "Icon")
AccessorFunc(PANEL, "m_iconSize", "IconSize")
AccessorFunc(PANEL, "m_iconOffset", "IconOffset")
AccessorFunc(PANEL, "m_xOffset", "XOffset")
AccessorFunc(PANEL, "m_name", "Name")
AccessorFunc(PANEL, "m_font", "Font")
AccessorFunc(PANEL, "m_background", "BackgroundColor")
AccessorFunc(PANEL, "m_layoutType", "LayoutType")
AccessorFunc(PANEL, "m_columns", "Columns")
AccessorFunc(PANEL, "m_layoutX", "LayoutX")
AccessorFunc(PANEL, "m_layoutY", "LayoutY")
AccessorFunc(PANEL, "m_layoutPanel", "LayoutPanel")
AccessorFunc(PANEL, "m_columnHeight", "ColumnHeight")
AccessorFunc(PANEL, "m_columnGridHeight", "GridColumnHeight")
AccessorFunc(PANEL, "m_bAnimateChanges", "AnimateChanges", FORCE_BOOL)
AccessorFunc(PANEL, "m_fAnimTime", "AnimTime")
AccessorFunc(PANEL, "m_InstantExpandWidth", "InstantExpandWidth", FORCE_NUMBER)
AccessorFunc(PANEL, "m_categoryColor", "CategoryColor")
AccessorFunc(PANEL, "m_border", "Border", FORCE_NUMBER)

function PANEL:Init()
  self:SetExpanded(false)
  self:SetTopHeight(48)
  self:SetTopColor(XeninUI.Theme.Primary)
  self:SetTopColorHover(Color(54, 54, 54))
  self:SetTopColorActive(Color(60, 60, 60))
  self:SetTopTextColor(Color(180, 180, 180))
  self:SetTopTextColorHover(Color(210, 210, 210))
  self:SetTopTextColorActive(color_white)
  self:SetRounded(6)
  self:SetXOffset(16)
  self:SetName("UNNAMED CATEGORY")
  self:SetFont("XeninUI.Category.Title")
  self:SetIcon(nil)
  self:SetIconSize(32)
  self:SetIconOffset(8)
  self:SetBackgroundColor(XeninUI.Theme.Navbar)
  self:SetBorder(8)
  self:SetLayoutType(XENINUI_LAYOUT_ROW)
  self:SetColumns(1)
  self:SetColumnHeight(48)
  self:SetLayoutX(8)
  self:SetLayoutY(8)
  self:SetLayoutPanel("DButton")
  self:SetInstantExpandWidth(0)

  self.Top = self:Add("DButton")
  self.Top:Dock(TOP)
  self.Top:SetText("")
  self.Top.textColor = self:GetTopTextColor()
  self.Top.background = self:GetTopColor()
  XeninUI:DownloadIcon(self.Top, "2QGKAd6")
  self.Top.rotation = 0
  self.Top.OnCursorEntered = function(pnl)
    if self:GetExpanded() then return end

    pnl:Lerp("rotation", 180)
    pnl:LerpColor("textColor", self:GetTopTextColorHover())
    pnl:LerpColor("background", self:GetTopColorHover())
  end
  self.Top.OnCursorExited = function(pnl)
    if self:GetExpanded() then return end

    pnl:Lerp("rotation", 0)
    pnl:LerpColor("textColor", self:GetTopTextColor())
    pnl:LerpColor("background", self:GetTopColor())
  end
  self.Top.Paint = function(pnl, w, h)
    local roundedBottom = self:GetTall() <= self:GetTopHeight()

    local col = self:GetCategoryColor()
    local xOffset = col and 4 or 0
    if (xOffset > 0) then
      XeninUI:DrawRoundedBoxEx(self:GetRounded(), 0, 0, w * 0.4, h, col, true, true, roundedBottom, roundedBottom)
    end
    if col then
      XeninUI:DrawRoundedBoxEx(self:GetRounded(), xOffset, 0, w - xOffset, h, pnl.background, !col, true, !col, roundedBottom)
    else
      XeninUI:DrawRoundedBoxEx(self:GetRounded(), xOffset, 0, w - xOffset, h, pnl.background, !col, true, roundedBottom, roundedBottom)
    end
    local x = self:GetXOffset()
    if self:GetIcon() then
      local iconSize = self:GetIconSize()
      surface.SetMaterial(self:GetIcon())
      surface.SetDrawColor(pnl.textColor)
      surface.DrawTexturedRect(self:GetIconOffset(), self:GetIconOffset(), iconSize, iconSize)

      x = h
    end

    draw.SimpleText(self:GetName(), self:GetFont(), x, h / 2, pnl.textColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

    local size = h / 3
    XeninUI:DrawIconRotated(w - size / 2 - 16, h / 2, size, size, pnl.rotation, pnl, pnl.textColor)
  end
  self.Top.DoClick = function(pnl)
    self:Expand(!self:GetExpanded())
  end

  self:SetAnimTime(0.3)
  self:SetAnimateChanges(false)
  self:SetTall(self.Top:GetTall())
  self.animSlide = Derma_Anim("Anim", self, self.AnimSlide)
end

function PANEL:AnimSlide(anim, delta, data)
  self:InvalidateLayout()
  self:InvalidateParent()

  if anim.Started then
    if (IsValid(self.Layout) and self:GetExpanded()) then
      self.Layout:SetVisible(false)
    end

    if self:GetExpanded() then
      self:SizeToChildren(false, true)
    else
      self:SetTall(self.Top:GetTall())
    end

    data.to = self:GetTall()
  end

  self:SetTall(XeninUI:Ease(delta, data.from, data.to - data.from, 1))

  if anim.Finished then
    if (IsValid(self.Layout) and !self:GetExpanded()) then
      self.Layout:SetVisible(false)
    end

    return
  end
end

function PANEL:SetLayoutType(type)
  if IsValid(self.Layout) then
    self.Layout:Remove()
  end

  local panel = type == XENINUI_LAYOUT_GRID and "DIconLayout" or "DListLayout"
  self.Layout = self:Add(panel)
  self.Layout:Dock(FILL)
  self.Layout:DockPadding(self:GetBorder(), self:GetBorder(), self:GetBorder(), self:GetBorder())

  if (panel == "DIconLayout") then
    self.Layout:SetBorder(8)
    self.Layout:SetSpaceY(self:GetLayoutX())
    self.Layout:SetSpaceX(self:GetLayoutY())
    self.Layout.PerformLayout = function(pnl, w, h)
      local children = pnl:GetChildren()
      local count = self:GetColumns()
      local amount = math.max(1, math.floor(#children / count)) * 276
      local width = w / math.min(count, #children)

      local x = 0
      local y = 0

      local spacingX = pnl:GetSpaceX()
      local spacingY = pnl:GetSpaceY()
      local border = pnl:GetBorder()
      local innerWidth = w - border * 2 - spacingX * (count - 1)

      for i, child in ipairs(children) do
        if (!IsValid(child)) then continue end

        child:SetPos(border + x * innerWidth / count + spacingX * x, border + y * child:GetTall() + spacingY * y)
        child:SetSize(innerWidth / count, self:GetGridColumnHeight() or innerWidth / count)

        x = x + 1
        if (x >= count) then
          x = 0
          y = y + 1
        end
      end

      pnl:SizeToChildren(false, true)
    end
  else
    self.Layout:SetTall(self:GetColumnHeight())
  end

  self.m_layoutType = type
end

function PANEL:Expand(state)
  self.Top:LerpColor("textColor", state and self:GetTopTextColorActive() or self:GetTopTextColorHover())
  self.Top:LerpColor("background", state and self:GetTopColorActive() or self:GetTopColorHover())

  local height = state and 48 + self.Layout:GetTall() or 48
  self:SetExpanded(state)

  self.Top.NextHeight = state and self.Top:GetTall() or self:GetTall()
  self.Top:Lerp("NextHeight", height)
  self.invalidateLayout = true

  self:OnToggle(self:GetExpanded())
end

function PANEL:OnToggle(state) end

function PANEL:CalculateHeight(childrenModifier)
  childrenModifier = childrenModifier or 0
  local children = #self.Layout:GetChildren() + childrenModifier
  local columns = self:GetColumns()
  local spacingX = self.Layout:GetSpaceX()
  local spacingY = self.Layout:GetSpaceY()
  local border = self.Layout:GetBorder()
  local innerWidth = (self:GetInstantExpandWidth() > 0 and self:GetInstantExpandWidth() or self:GetWide()) - border * 2 - spacingX * (columns - 1)
  local columnHeight = innerWidth / columns
  local height = math.ceil(children / columns) * (self:GetLayoutY() + columnHeight) + spacingY

  return 48 + height, children
end

function PANEL:FeedData(tbl, index, expand)
  self.DataTbl = tbl

  for i, v in pairs(tbl) do
    local panel = self.Layout:Add(self:GetLayoutPanel())

    if (self:GetLayoutType() == XENINUI_LAYOUT_ROW) then
      panel:Dock(TOP)
      panel:DockMargin(0, 0, 0, self:GetLayoutY())
      panel:SetTall(self:GetColumnHeight())
    end

    if panel.HandleData then
      panel:HandleData(v, i)
    end
  end

  if expand then
    self.Top.textColor = self:GetTopTextColorActive()
    self.Top.background = self:GetTopColorActive()
    self.Top.rotation = 180

    local height = 48
    if (self:GetLayoutType() == XENINUI_LAYOUT_GRID) then
      local columns = self:GetColumns()
      local spacingX = self.Layout:GetSpaceX()
      local spacingY = self.Layout:GetSpaceY()
      local border = self.Layout:GetBorder()
      local innerWidth = (self:GetInstantExpandWidth() > 0 and self:GetInstantExpandWidth() or self:GetWide()) - border * 2 - spacingX * (columns - 1)
      local columnHeight = innerWidth / columns

      height = height + math.ceil(#tbl / columns) * (self:GetLayoutY() + columnHeight) + spacingY
    elseif (self:GetLayoutType() == XENINUI_LAYOUT_ROW) then
      local columns = #tbl
      local y = self:GetLayoutY()
      local columnHeight = self:GetColumnHeight()

      height = height + self:GetBorder() + (columns * columnHeight) + (y * (columns - 1)) + self:GetBorder()
    end

    self:SetExpanded(true)
    self.Top.NextHeight = height
    self:InvalidateLayout(true)

    self:OnToggle(true)
  end

  self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
  draw.RoundedBoxEx(self:GetRounded(), 0, self.Top:GetTall(), w, h - self.Top:GetTall(), self:GetBackgroundColor(), false, false, true, true)
end

function PANEL:Think()
  if self.invalidateLayout then
    self:InvalidateLayout()
  end
end

function PANEL:PerformLayout(w, h)
  self.Top:SetTall(self:GetTopHeight())
  self:SetTall(self.Top.NextHeight or self.Top:GetTall())
end

vgui.Register("XeninUI.Category", PANEL)

--addons/xenin_framework/lua/xeninui/elements/colorpicker.lua:
local PANEL = {}


function PANEL:OnChange(color) end

function PANEL:UpdateColor()
  self.Color = XeninUI:HSLToColor(self.Hue, self.Saturation, self.Lightness)
  self:OnChange(self.Color)
end

function PANEL:SetColor(color)
  local h, s, l = ColorToHSL(color)
  h = h / (360 / 5)
  self.Hue = h
  self.Saturation = s
  self.Lightness = l

  self.Color = color
  self:OnChange(color)

  self:UpdatePositions()
end

function PANEL:UpdatePositions()
  local radius = self:GetTriangleRadius()
  local hue = self.Hue
  local third = (2 / 3) * math.pi
  local sat = self.Saturation
  local light = 1 - self.Lightness

  local hX = math.cos(hue)
  local hY = math.sin(hue)
  local sX = math.cos(hue - third)
  local sY = math.sin(hue - third)
  local vX = math.cos(hue + third)
  local vY = math.sin(hue + third)

  local mX = (sX + vX) / 2
  local mY = (sY + vY) / 2
  local a = (1 - 2 * math.abs(light - 0.5)) * sat

  self.TriX = sX + (vX - sX) * light + (hX - mX) * a
  self.TriY = sY + (vY - sY) * light + (hY - mY) * a
end

function PANEL:Think()
  local cursorX, cursorY = self:CursorPos()
  local cX, cY = self:GetCenter()
  local center = Vector(cX, cY, 0)
  local radius = self:GetRadius()
  local triangleRadius = self:GetTriangleRadius()

  if (!self.Pressed) then return end

  local diffX = cursorX - cX
  local diffY = cursorY - cY
  local rad = math.atan2(diffY, diffX)
  if (rad < 0) then
    rad = rad + (2 * math.pi)
  end

  if self.PressedWheel then
    self.Hue = rad
    self:UpdatePositions()
    self:UpdateColor()

    return
  end

  local rad0 = (rad + 2 * math.pi - self.Hue) % (2 * math.pi)
  local rad1 = rad0 % ((2 / 3) * math.pi) - (math.pi / 3)
  local a = 0.5 * triangleRadius
  local b = math.tan(rad1) * a
  local r = math.sqrt(diffX * diffX + diffY * diffY)
  local maxR = math.sqrt(a * a + b * b)

  if (r > maxR) then
    local dx = math.tan(rad1) * r
    local rad2 = math.Clamp(math.atan(dx / maxR), -math.pi / 3, math.pi / 3)
    rad = rad + (rad2 - rad1)
    rad0 = (rad + 2 * math.pi - self.hue) % (2 * math.pi)
    rad1 = rad0 % ((2 / 3) * math.pi) - (math.pi / 3)
    b = math.tan(rad1) * a
    maxR = math.sqrt(a * a + b * b)
    r = maxR
  end

  self.TriX = math.cos(rad) * r / triangleRadius
  self.TriY = math.sin(rad) * r / triangleRadius

  local triangleSideLen = math.sqrt(3) * triangleRadius
  local light = ((math.sin(rad0) * r) / triangleSideLen) + 0.5
  local widthShare = 1.0 - math.abs(light - 0.5) * 2.0
  local saturation = (((math.cos(rad0) * r) + (triangleRadius / 2)) / (1.5 * triangleRadius)) / widthShare
  saturation = math.Clamp(saturation, 0, 1)

  self.Lightness = 1 - light
  self.Saturation = saturation

  self:UpdateColor()
end

function PANEL:Init()
  self.Hue = 0
  self.SmoothHue = 0

  self.Lightness = 0
  self.Saturation = 0

  self.TriX = 0
  self.TriY = 0

  self:UpdateColor()
  self:UpdatePositions()

  XeninUI:DownloadIcon(self, "i0xcO1R")
  XeninUI:DownloadIcon(self, "k5mtok6", "Ring")
  XeninUI:DownloadIcon(self, "t0k86qy", "Picker")
end

function PANEL:OnMousePressed()
  self.Pressed = true

  local cX, cY = self:GetCenter()
  local cursorX, cursorY = self:CursorPos()
  local cursor = Vector(cursorX, cursorY)
  local center = Vector(cX, cY, 0)

  if (cursor:Distance(center) > self:GetTriangleRadius()) then
    self.PressedWheel = true

    return
  end

  self.PressedTriangle = true
end

function PANEL:OnMouseReleased()
  self.Pressed = false
  self.PressedWheel = false
  self.PressedTriangle = false
end

function PANEL:GetCenter()
  return self:GetWide() / 2, self:GetTall() / 2
end

function PANEL:GetRadius()
  return self:GetTall() / 2
end

function PANEL:GetTriangleRadius()
  return self:GetRadius() * 0.7
end

function PANEL:GetRingThickness()
  return self:GetRadius() * 0.2
end

function PANEL:GetHueColor()
  return XeninUI:HSLToColor(self.Hue, 1, 0.5)
end

function PANEL:Paint(w, h)
  local cX, cY = self:GetCenter()
  local radius = self:GetRadius()
  local triangleRadius = self:GetTriangleRadius()

  draw.NoTexture()

  local triangleAng = self.Hue
  local triangleOff = math.pi * 2 / 3
  local vertices = {
    {
      x = cX + math.cos(triangleAng - triangleOff) * triangleRadius,
      y = cY + math.sin(triangleAng - triangleOff) * triangleRadius,
      u = 0.5,
      v = 0.99
    },
    {
      x = cX + math.cos(triangleAng) * triangleRadius,
      y = cY + math.sin(triangleAng) * triangleRadius,
      u = 0.99,
      v = 0.01
    },
    {
      x = cX + math.cos(triangleAng + triangleOff * 1) * triangleRadius,
      y = cY + math.sin(triangleAng + triangleOff * 1) * triangleRadius,
      u = 0.01,
      v = 0.01
    }
  }

  local col = self:GetHueColor()
  surface.SetDrawColor(col)
  surface.DrawPoly(vertices)

  surface.SetDrawColor(255, 255, 255)
  surface.SetMaterial(self.Icon)
  surface.DrawPoly(vertices)
  surface.DrawPoly(vertices)

  vertices[1].u = 0.99
  vertices[1].v = 0.01

  vertices[2].u = 0.01
  vertices[2].v = 0.01

  vertices[3].u = 0.5
  vertices[3].v = 0.99

  surface.SetDrawColor(0, 0, 0)
  surface.SetMaterial(self.Icon)
  surface.DrawPoly(vertices)

  surface.SetDrawColor(255, 255, 255)
  surface.SetMaterial(self.Ring)
  surface.DrawTexturedRect(cX - radius, cY - radius, radius * 2, radius * 2)

  local pickerVerts = {
    {
      x = cX + self.TriX * triangleRadius + 2,
      y = cY + self.TriY * triangleRadius + 2,
      u = 1,
      v = 1
    },
    {
      x = cX + self.TriX * triangleRadius - 2,
      y = cY + self.TriY * triangleRadius + 2,
      u = 0,
      v = 1
    },
    {
      x = cX + self.TriX * triangleRadius - 2,
      y = cY + self.TriY * triangleRadius - 2,
      u = 0,
      v = 0
    },
    {
      x = cX + self.TriX * triangleRadius + 2,
      y = cY + self.TriY * triangleRadius - 2,
      u = 1,
      v = 0
    }
  }

  surface.SetDrawColor(255, 255, 255)
  surface.SetMaterial(self.Picker)
  surface.DrawPoly(pickerVerts)

  local hpX = cX + math.cos(self.Hue) * (radius - self:GetRingThickness() / 2)
  local hpY = cY + math.sin(self.Hue) * (radius - self:GetRingThickness() / 2)
  local size = 16
  local huePickerVerts = {
    {
      x = hpX + size / 2,
      y = hpY + size / 2,
      u = 1,
      v = 1
    },
    {
      x = hpX - size / 2,
      y = hpY + size / 2,
      u = 0,
      v = 1
    },
    {
      x = hpX - size / 2,
      y = hpY - size / 2,
      u = 0,
      v = 0
    },
    {
      x = hpX + size / 2,
      y = hpY - size / 2,
      u = 1,
      v = 0
    }
  }
  surface.SetDrawColor(255, 255, 255)
  surface.SetMaterial(self.Picker)
  surface.DrawPoly(huePickerVerts)
end

vgui.Register("XeninUI.ColorPicker", PANEL)

--addons/xenin_framework/lua/xeninui/elements/combobox.lua:
local x

--addons/xenin_framework/lua/xeninui/elements/dropdown_popup.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/elements/dropdown_popup.lua:
XeninUI:CreateFont("XeninUI.DropdownPopup", 19)

local PANEL = {}

AccessorFunc(PANEL, "m_backgroundColor", "BackgroundColor")
AccessorFunc(PANEL, "m_textColor", "TextColor")
AccessorFunc(PANEL, "m_accentColor", "AccentColor")
AccessorFunc(PANEL, "m_iconColor", "IconColor")

function PANEL:Init()
  self.choices = {}

  self.Alpha = 0
  self:LerpAlpha(255, 0.15)
  self:SetBackgroundColor(XeninUI.Theme.Primary)
  self:SetTextColor(color_white)
  self:SetAccentColor(XeninUI.Theme.Accent)
  self:SetIconColor(color_white)
  self:DockPadding(0, 8, 0, 8)
end

function PANEL:Paint(w, h)
  local aX, aY = self:LocalToScreen()

  BSHADOWS.BeginShadow()
  draw.RoundedBox(6, aX, aY, w, h, self:GetBackgroundColor())
  BSHADOWS.EndShadow(1, 2, 2)
end

function PANEL:AddChoice(name, onClick, textColor, accentColor, icon, iconColor)
  onClick = onClick or function()
    return true end

  local panel = vgui.Create("DButton", self)
  panel:Dock(TOP)
  panel:SetTall(48)
  panel:SetText(name)
  panel:SetFont("XeninUI.DropdownPopup")
  panel:SetTextInset(icon and 64 or 16, 0)
  panel:SetContentAlignment(4)
  panel:SetTextColor(textColor or self:GetTextColor())
  panel.alpha = 0
  panel.Paint = function(pnl, w, h)
    surface.SetDrawColor(ColorAlpha(accentColor or self:GetAccentColor(), pnl.alpha))
    surface.DrawRect(0, 0, w, h)
  end
  panel.OnCursorEntered = function(pnl)
    pnl:Lerp("alpha", 200)
  end
  panel.OnCursorExited = function(pnl)
    pnl:Lerp("alpha", 0)
  end
  panel.DoClick = function(pnl)
    onClick(pnl)

    self:Remove()
  end

  if icon then
    panel.icon = panel:Add("Panel")
    panel.icon:SetMouseInputEnabled(false)
    panel.icon.icon = icon
    panel.icon.CalculatePoly = function(self, w, h, vertices)
      local poly = {}

      local x = w / 2
      local y = h / 2
      local radius = h / 2

      table.insert(poly, {
        x = x,
        y = y
      })

      for i = 0, vertices do
        local a = math.rad((i / vertices) * -360)
        table.insert(poly, {
          x = x + math.sin(a) * radius,
          y = y + math.cos(a) * radius
        })
      end

      local a = math.rad(0)
      table.insert(poly, {
        x = x + math.sin(a) * radius,
        y = y + math.cos(a) * radius
      })
      self.data = poly
    end
    panel.icon.DrawPoly = function(self, w, h, vertices)
      if (!self.data) then
        self:CalculatePoly(w, h, vertices)
      end

      surface.DrawPoly(self.data)
    end
    panel.icon.Paint = function(pnl, w, h)
      render.ClearStencil()
      render.SetStencilEnable(true)

      render.SetStencilWriteMask(1)
      render.SetStencilTestMask(1)

      render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
      render.SetStencilPassOperation(STENCILOPERATION_ZERO)
      render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
      render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
      render.SetStencilReferenceValue(1)

      draw.NoTexture()
      surface.SetDrawColor(color_white)
      pnl:DrawPoly(w, h, 90)

      render.SetStencilFailOperation(STENCILOPERATION_ZERO)
      render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
      render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
      render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
      render.SetStencilReferenceValue(1)

      if pnl.icon then
        surface.SetDrawColor(iconColor or self:GetIconColor())
        surface.SetMaterial(pnl.icon)
        surface.DrawTexturedRect(0, 0, w, h)
      end

      render.SetStencilEnable(false)
      render.ClearStencil()
    end
    panel.PerformLayout = function(pnl, w, h)
      pnl.icon:SetPos(16, 6)
      pnl.icon:SetSize(h - 12, h - 12)
    end
  end

  local i = table.insert(self.choices, {
    panel = panel,
    str = name
  })

  self:InvalidateLayout()

  return panel
end

function PANEL:PerformLayout(w, h)
  local longest = 0

  surface.SetFont("XeninUI.DropdownPopup")
  for i, v in pairs(self.choices) do
    local tw = surface.GetTextSize(v.str)
    tw = tw + 16
    tw = tw + 16
    if v.panel.icon then
      tw = tw + 48
    end

    if (tw > longest) then
      longest = math.max(112, tw)
    end
  end

  self:SetWide(longest)
  self:SetTall(8 + #self.choices * 48 + 8)
end

function PANEL:OnFocusChanged(gained)
  if (!IsValid(self)) then return end
  if gained then return end
  if self.ignore then return end

  self:Remove()
end

function PANEL:Think()
  local w, h = self:GetSize()
  local x, y = self.x, self.y
  x = math.Clamp(x, 0, ScrW() - w)
  y = math.Clamp(y, 0, ScrH() - h)

  self:SetPos(x, y)
end

vgui.Register("XeninUI.DropdownPopup", PANEL, "EditablePanel")

function XeninUI:DropdownPopup(x, y)
  local panel = vgui.Create("XeninUI.DropdownPopup", vgui.GetWorldPanel())
  panel:SetDrawOnTop(true)
  panel:SetPos(x + 12, y + 12)
  panel:MakePopup()

  return panel
end

XeninUI:CreateFont("XeninUI.QueryPopup.Title", 19, 800)
XeninUI:CreateFont("XeninUI.QueryPopup.Subtitle", 16, 800)
XeninUI:CreateFont("XeninUI.QueryPopup.Button", 18, 800)

local PANEL = {}

AccessorFunc(PANEL, "m_title", "Title")
AccessorFunc(PANEL, "m_subtitle", "Subtitle")
AccessorFunc(PANEL, "m_subtitleColor", "SubtitleColor")

function PANEL:Init()
  self:DockPadding(8, 8, 8, 8)
  self:SetTall(96)

  self.onCancel = function() end
  self.onAccept = function() end

  self.title = vgui.Create("DLabel", self)
  self.title:Dock(TOP)
  self.title:SetText("Equip this booster?")
  self.title:SetFont("XeninUI.QueryPopup.Title")
  self.title:SetTextColor(color_black)

  self.subtitle = vgui.Create("DLabel", self)
  self.subtitle:Dock(TOP)
  self.subtitle:DockMargin(0, -2, 0, 0)
  self.subtitle:SetTextColor(Color(75, 75, 75))
  self.subtitle:SetFont("XeninUI.QueryPopup.Subtitle")

  self.bottom = vgui.Create("Panel", self)
  self.bottom:Dock(BOTTOM)
  self.bottom:SetTall(32)

  self.cancel = vgui.Create("DButton", self.bottom)
  self.cancel:Dock(RIGHT)
  self.cancel:DockMargin(8, 0, 0, 0)
  self.cancel:SetText("Cancel")
  self.cancel:SetTextColor(XeninUI.Theme.Red)
  self.cancel:SetFont("XeninUI.QueryPopup.Button")
  self.cancel.Paint = function(pnl, w, h)
    draw.RoundedBox(6, 0, 0, w, h, Color(220, 220, 220))
  end
  self.cancel.DoClick = function(pnl)
    self:onCancel()

    self:Remove()
  end
  local tw, th = surface.GetTextSize(self.cancel:GetText())
  self.cancel:SetWide(tw + 24)

  self.unlock = vgui.Create("DButton", self.bottom)
  self.unlock:Dock(RIGHT)
  self.unlock:SetText("Accept")
  self.unlock:SetTextColor(XeninUI.Theme.Green)
  self.unlock:SetFont("XeninUI.QueryPopup.Button")
  self.unlock.Paint = function(pnl, w, h)
    draw.RoundedBox(6, 0, 0, w, h, Color(220, 220, 220))
  end
  self.unlock.DoClick = function(pnl)
    self:onAccept()

    self:Remove()
  end
  surface.SetFont(self.unlock:GetFont())
  local tw, th = surface.GetTextSize(self.unlock:GetText())
  self.unlock:SetWide(tw + 16)

  surface.SetFont(self.title:GetFont())
  local tw, th = surface.GetTextSize(self.title:GetText())
  self:SetWide(tw + 16)
end

function PANEL:Paint(w, h)
  draw.RoundedBox(6, 0, 0, w, h, color_white)
end

function PANEL:OnFocusChanged(gained)
  if (!IsValid(self)) then return end
  if gained then return end
  if self.ignore then return end

  self:Remove()
end

vgui.Register("XeninUI.QueryPopup", PANEL, "EditablePanel")

function XeninUI:Popup(x, y, title, subtitle, onUnlock, onCancel, hideUnlock, titleColor, subtitleColor, acceptText)
  local panel = vgui.Create("XeninUI.QueryPopup")
  panel:SetDrawOnTop(true)
  panel:SetMouseInputEnabled(true)
  panel:SetPos(x + 12, y + 12 - 12)
  panel.title:SetText(title or "Title")
  panel.subtitle:SetText(subtitle or "Subtitle")

  if subtitleColor then
    panel.subtitle:SetTextColor(subtitleColor)
  end

  if titleColor then
    panel.title:SetTextColor(titleColor)
  end

  if acceptText then
    panel.unlock:SetText(acceptText)
  end

  if onUnlock then
    panel.onAccept = onUnlock

    local tw, th = surface.GetTextSize(panel.unlock:GetText())
    panel.unlock:SetWide(tw + 16)
  end
  if onCancel then
    panel.onCancel = onCancel

    local tw, th = surface.GetTextSize(panel.cancel:GetText())
    panel.cancel:SetWide(tw + 24)
  end
  if hideUnlock then
    panel.unlock:Remove()
    panel:InvalidateLayout()
  end

  surface.SetFont(panel.unlock:GetFont())
  local tw, th = surface.GetTextSize(panel.unlock:GetText())
  panel.unlock:SetWide(tw + 16)

  surface.SetFont(panel.title:GetFont())
  local tw, th = surface.GetTextSize(panel.title:GetText())
  panel:SetWide(math.max(192, tw + 16))

  return panel
end

--addons/xenin_framework/lua/xeninui/elements/notifications.lua:
XeninUI.Notifications = XeninUI.Notifications or {}
XeninUI:CreateFont("XeninUI.Notification", 18)
--addons/xenin_framework/lua/xeninui/elements/purchase_confirmation.lua:
local PANEL = {}

XeninUI:CreateFont("XeninUI.PurchaseConfirmation.Name", 24)
XeninUI:CreateFont("XeninUI.PurchaseConfirmation.Sid64", 18)
XeninUI:CreateFont("XeninUI.PurchaseConfirmation.String", 24)

AccessorFunc(PANEL, "m_player", "Player")
AccessorFunc(PANEL, "m_icon", "Icon")
AccessorFunc(PANEL, "m_purchaseStr", "PurchaseString")
AccessorFunc(PANEL, "m_accept", "Accept")
AccessorFunc(PANEL, "m_decline", "Decline")
AccessorFunc(PANEL, "m_tbl", "Table")

function PANEL:Start()
  self:SetAccept(function() end)
  self:SetDecline(function() end)

  self.background.avatar = self.background:Add("XeninUI.Avatar")
  self.background.avatar:SetPlayer(self:GetPlayer(), 64)
  self.background.avatar:SetVertices(90)
  self.background.avatar:SetMouseInputEnabled(false)

  self.background.name = self.background:Add("DLabel")
  self.background.name:SetText(self:GetPlayer():Nick())
  self.background.name:SetTextColor(color_white)
  self.background.name:SetFont("XeninUI.PurchaseConfirmation.Name")

  self.background.sid64 = self.background:Add("DTextEntry")
  self.background.sid64:SetText(self:GetPlayer():SteamID())
  self.background.sid64:SetTextColor(Color(190, 190, 190))
  self.background.sid64:SetFont("XeninUI.PurchaseConfirmation.Sid64")
  self.background.sid64:SetEnabled(false)
  self.background.sid64:SetDrawLanguageID(false)
  self.background.sid64.Paint = function(pnl, w, h)
    pnl:DrawTextEntryText(pnl:GetTextColor(), pnl:GetTextColor(), pnl:GetTextColor())
  end

  self.background.string = self.background:Add("DLabel")
  self.background.string:SetText(self:GetPurchaseString())
  self.background.string:SetTextColor(Color(220, 220, 220))
  self.background.string:SetWrap(true)
  self.background.string:SetFont("XeninUI.PurchaseConfirmation.String")
  self.background.string:SetContentAlignment(5)

  if (type(self:GetIcon()) == "string") then
    self.background.display = self.background:Add("XeninUI.AnimatedTexture")
    self.background.display:SetDirectory(self:GetIcon())
    local tbl = self:GetTable()
    self.background.display:SetTimes(tbl.normal, tbl.idle)
    self.background.display:PostInit()
  else
    self.background.display = self.background:Add("DPanel")
    self.background.display.Paint = function(pnl, w, h)
      if (!self:GetIcon()) then return end

      surface.SetMaterial(self:GetIcon())
      surface.SetDrawColor(color_white)
      surface.DrawTexturedRect(0, 0, w, h)
    end
  end

  self.background.accept = self.background:Add("DButton")
  self.background.accept:SetText("Confirm purchase")
  self.background.accept:SetFont("XeninUI.Query.Button")
  self.background.accept:SetTextColor(Color(21, 21, 21))
  self.background.accept.alpha = 0
  self.background.accept.background = XeninUI.Theme.Green
  self.background.accept.Paint = function(pnl, w, h)
    local x, y = pnl:LocalToScreen()

    BSHADOWS.BeginShadow()
    draw.RoundedBox(h / 2, x, y, w, h, pnl.background)
    BSHADOWS.EndShadow(1, 1, 2, pnl.alpha, 0, 0)
  end
  self.background.accept.OnCursorEntered = function(pnl)
    local col = XeninUI.Theme.Green
    col = Color(col.r + 5, col.g + 50, col.b + 7)

    pnl:LerpColor("background", col)
    pnl:Lerp("alpha", 255)
  end
  self.background.accept.OnCursorExited = function(pnl)
    pnl:LerpColor("background", XeninUI.Theme.Green)
    pnl:Lerp("alpha", 0)
  end
  self.background.accept.DoClick = function(pnl)
    self:GetAccept()(pnl)
    self:Remove()
  end

  self.background.decline = self.background:Add("DButton")
  self.background.decline:SetText("Cancel")
  self.background.decline:SetFont("XeninUI.Query.Button")
  self.background.decline:SetTextColor(Color(145, 145, 145))
  self.background.decline.alpha = 0
  self.background.decline.background = XeninUI.Theme.Background
  self.background.decline.Paint = function(pnl, w, h)
    local x, y = pnl:LocalToScreen()

    BSHADOWS.BeginShadow()
    draw.RoundedBox(h / 2, x, y, w, h, XeninUI.Theme.Navbar)
    BSHADOWS.EndShadow(1, 1, 2, pnl.alpha, 0, 0)

    draw.RoundedBox(h / 2, 2, 2, w - 4, h - 4, pnl.background)
  end
  self.background.decline.OnCursorEntered = function(pnl)
    pnl:LerpColor("background", XeninUI.Theme.Navbar)
    pnl:Lerp("alpha", 200)
  end
  self.background.decline.OnCursorExited = function(pnl)
    pnl:LerpColor("background", XeninUI.Theme.Background)
    pnl:Lerp("alpha", 0)
  end
  self.background.decline.DoClick = function(pnl)
    self:GetDecline()(pnl)
    self:Remove()
  end
end

function PANEL:PerformLayout(w, h)
  self.BaseClass.PerformLayout(self, w, h)

  local y = 40
  self.background.avatar:SetPos(16, y + 16)
  self.background.avatar:SetSize(48, 48)

  self.background.name:SetPos(16 + self.background.avatar:GetWide() + 8, y + 16 + 2)
  self.background.name:SizeToContents()

  self.background.sid64:SetPos(14 + self.background.avatar:GetWide() + 8, y + 16 + 24 + 2)
  self.background.sid64:SizeToContentsY()
  self.background.sid64:SetWide(155)

  y = y + self.background.avatar:GetTall() + 40

  self.background.display:SetSize(64, 64)
  self.background.display:SetPos(16, y)

  self.background.string:SetPos(8 + 64 + 16, y)
  self.background.string:SetWide(self.background:GetWide() - 16 - 64)
  self.background.string:SizeToContentsY()

  self.background.accept:SizeToContentsY(16)
  self.background.decline:SizeToContentsY(16)
  self.background.accept:SetWide(self.background:GetWide() / 2 - 16 - 8)
  self.background.decline:SetWide(self.background:GetWide() / 2 - 16 - 8)

  local y = self.background:GetTall() - self.background.accept:GetTall() - 16

  self.background.accept:SetPos(16, y)
  self.background.decline:SetPos(self.background:GetWide() / 2 + 8, y)
end

vgui.Register("XeninUI.PurchaseConfirmation", PANEL, "XeninUI.Popup")

--addons/xenin_framework/lua/xeninui/elements/scrollpanel.lua:
local PANEL = {}

function PANEL:Init()
  self.VBar:SetWide(12)
  self.VBar:SetHideButtons(true)

  self.VBar.Paint = function(pnl, w, h)
    draw.RoundedBox(6, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Navbar, 150))
  end
  self.VBar.btnGrip.Paint = function(pnl, w, h)
    draw.RoundedBox(6, 0, 0, w, h, XeninUI.Theme.Primary)
  end
end

function PANEL:HideScrollBar(hide)
  self.VBar:SetWide((hide and 0) or 12)
end

vgui.Register("XeninUI.ScrollPanel", PANEL, "DScrollPanel")

--addons/xenin_framework/lua/xeninui/elements/sidebar_player.lua:
local PANEL = {}

XeninUI:CreateFont("XeninUI.Sidebar.Player.Name", 20)
XeninUI:CreateFont("XeninUI.Sidebar.Player.Job", 16)

function PANEL:Init()
  self:SetColors({
    startColor = Color(208, 62, 106),
    endColor = Color(200, 60, 123)
  }, {
    startColor = Color(251, 211, 50),
    endColor = Color(69, 198, 103)
  })

  self.Avatar = self:Add("XeninUI.Avatar")
  self.Avatar:SetPlayer(LocalPlayer(), 64)
  self.Avatar:SetVertices(30)

  self.Text = self:Add("DPanel")
  self.Text:SetMouseInputEnabled(false)
  self.Text.TextHeight = 0
  self.Text.Paint = function(pnl, w, h)
    local ply = LocalPlayer()

    pnl.TextHeight = 0
    for i, v in pairs(pnl.Rows) do
      XeninUI:DrawShadowText(v.text, v.font, 0, pnl.TextHeight, v.color, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, 255)

      pnl.TextHeight = pnl.TextHeight + draw.GetFontHeight(v.font) - 2
    end
  end

  local ply = LocalPlayer()
  self:SetRows({
    {
      font = "XeninUI.Sidebar.Player.Name",
      text = ply:Nick(),
      color = color_white
    },
    {
      font = "XeninUI.Sidebar.Player.Job",
      text = ply:GetUserGroup():gsub("^%l", string.upper),
      color = XeninUI.Theme.Green
    }
  })
end

function PANEL:SetColors(startGradient, endGradient)
  self.startGradient = startGradient
  self.endGradient = endGradient
end

function PANEL:SetRows(rows)
  self.Text.Rows = rows
end

function PANEL:Paint(w, h)
  local aX, aY = self:LocalToScreen()
  draw.SimpleLinearGradient(aX, aY, w, h, self.startGradient.startColor, self.startGradient.endColor)

  XeninUI:Mask(function()
    XeninUI:DrawRoundedBox((h - 24) / 2, 12, 12, h - 24, h - 24, color_white)
  end, function()
    draw.SimpleLinearGradient(aX + 12, aY + 12, h - 24, h - 24, self.endGradient.startColor, self.endGradient.endColor, true)
  end)
end

function PANEL:PerformLayout(w, h)
  self.Avatar:SetPos(14, 14)
  self.Avatar:SetSize(h - 28, h - 28)

  self.Text:MoveRightOf(self.Avatar, 10)
  local textH = 1
  for i, v in pairs(self.Text.Rows) do
    textH = textH + draw.GetFontHeight(v.font)
  end
  self.Text:SetTall(textH)
  self.Text:CenterVertical()
  self.Text:SetWide(w - self.Text.x)
end

vgui.Register("XeninUI.Sidebar.Player", PANEL)

--addons/xenin_framework/lua/xeninui/elements/slider_pad.lua:
local PANEL = {}

function PANEL:Init()
  self.Rounding = 0

  self.Slider = self:Add("XeninUI.Slider")
  self.Slider:Dock(FILL)
  self.Slider:DockMargin(0, 0, 8, 0)
  self.Slider.OnValueChanged = function(pnl, frac)
    local value = math.Round(pnl:GetMin() + ((pnl:GetMax() - pnl:GetMin()) * frac), self.Rounding)
    self.Textentry:SetText(value)
    self:OnValueChanged(value)
  end

  self.Textentry = self:Add("XeninUI.TextEntry")
  self.Textentry:Dock(RIGHT)
  self.Textentry:SetNumeric(true)
  self.Textentry:SetUpdateOnType(true)
  self.Textentry.OnValueChange = function(pnl, text)
    local num = tonumber(text)
    if (!isnumber(num)) then return end
    num = math.Clamp(num, self:GetMin(), self:GetMax())
    num = math.Round(num, self.Rounding)

    self:SetValue(num, true)
    self:OnValueChanged(num)
  end

  self:SetValue(5)
end

function PANEL:SetValue(value, dontSetText)
  local frac = (value - self:GetMin()) / (self:GetMax() - self:GetMin())
  self:SetFraction(math.Clamp(frac, 0, 1))

  if (!dontSetText) then
    self.Textentry:SetText(value)
  end
  self.Slider:InvalidateLayout(true)
end

function PANEL:GetValue()
  return math.Clamp(self.Textentry:GetText(), self:GetMin(), self:GetMax())
end


function PANEL:OnValueChanged(value) end

function PANEL:SetMin(min)
  self.Slider:SetMin(min)end
function PANEL:GetMin()
  return self.Slider:GetMin()end
function PANEL:SetMax(max)
  self.Slider:SetMax(max)end
function PANEL:GetMax()
  return self.Slider:GetMax()end
function PANEL:SetColor(color)
  self.Slider:SetColor(color)end
function PANEL:GetColor()
  return self.Slider:GetColor()end
function PANEL:SetFraction(fraction)
  self.Slider.fraction = fraction end
function PANEL:GetFraction()
  return self.Slider.fraction end
function PANEL:SetRounding(rounding)
  self.Rounding = rounding end
function PANEL:GetRounding()
  return self.Rounding end

vgui.Register("XeninUI.SliderPad", PANEL, "Panel")

--addons/xenin_framework/lua/xeninui/elements/textentry.lua:
XeninUI:CreateFont("XeninUI.TextEntry", 18)

local PANEL = {}

AccessorFunc(PANEL, "m_backgroundColor", "BackgroundColor")
AccessorFunc(PANEL, "m_rounded", "Rounded")
AccessorFunc(PANEL, "m_placeholder", "Placeholder")
AccessorFunc(PANEL, "m_textColor", "TextColor")
AccessorFunc(PANEL, "m_placeholderColor", "PlaceholderColor")
AccessorFunc(PANEL, "m_iconColor", "IconColor")

function PANEL:Init()
	self:SetBackgroundColor(XeninUI.Theme.Navbar)
	self:SetRounded(6)
	self:SetPlaceholder("")
	self:SetTextColor(Color(205, 205, 205))
	self:SetPlaceholderColor(Color(120, 120, 120))
	self:SetIconColor(self:GetTextColor())

	self.textentry = vgui.Create("DTextEntry", self)
	self.textentry:Dock(FILL)
	self.textentry:DockMargin(8, 8, 8, 8)
	self.textentry:SetFont("XeninUI.TextEntry")
	self.textentry:SetDrawLanguageID(false)
	self.textentry.Paint = function(pnl, w, h)
		local col = self:GetTextColor()

		pnl:DrawTextEntryText(col, col, col)

		if (#pnl:GetText() == 0) then
			draw.SimpleText(self:GetPlaceholder() or "", pnl:GetFont(), 3, pnl:IsMultiline() and 8 or h / 2, self:GetPlaceholderColor(), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end
	end
	self.textentry.OnValueChange = function(pnl, text)
		self:OnValueChange(text)
	end
end

function PANEL:SetNumeric(bool)
	self.textentry:SetNumeric(true)end
function PANEL:GetNumeric()
	return self.textentry:GetNumeric()end
function PANEL:SetUpdateOnType(bool)
	self.textentry:SetUpdateOnType(true)end
function PANEL:GetUpdateOnType()
	return self.textentry:GetUpdateOnType()end
function PANEL:OnValueChanged() end

function PANEL:SetFont(str)
	self.textentry:SetFont(str)
end

function PANEL:GetFont()
	return self.textentry:GetFont()
end

function PANEL:GetText()
	return self.textentry:GetText()
end

function PANEL:SetText(str)
	self.textentry:SetText(str)
end

function PANEL:SetMultiLine(state)
	self:SetMultiline(state)
	self.textentry:SetMultiline(state)
end

function PANEL:SetLabel(label, left, textColor, offset)
	if offset == nil then offset = 0
	end
	if IsValid(self.label) then self.label:Remove()end

	self.label = self:Add("DLabel")
	self.label:Dock(left and LEFT or RIGHT)
	self.label:DockMargin(left and 10 or -5, 10, (left and -9 or 8) - offset, 10)
	self.label:SetText(label)
	self.label:SetTextColor(textColor or ColorAlpha(self:GetTextColor(), 175))
	self.label:SetFont(self.textentry:GetFont())
	self.label:SizeToContentsX()
end

function PANEL:SetIcon(icon, left)
	if (!IsValid(self.icon)) then
		self.icon = vgui.Create("DButton", self)
		self.icon:SetText("")
		self.icon:Dock(left and LEFT or RIGHT)
		self.icon:DockMargin(left and 10 or -5, 10, left and 0 or 10, 10)
		self.icon.Paint = function(pnl, w, h)
			surface.SetDrawColor(self:GetIconColor())
			surface.SetMaterial(pnl.mat)
			surface.DrawTexturedRect(0, 0, w, h)
		end
		self.icon.DoClick = function(pnl)
			self.textentry:RequestFocus()
		end
	end

	self.icon.mat = icon
end

function PANEL:PerformLayout(w, h)
	if IsValid(self.icon) then
		self.icon:SetWide(self.icon:GetTall())
	end
end

function PANEL:OnMousePressed()
	self.textentry:RequestFocus()
end

function PANEL:Paint(w, h)
	draw.RoundedBox(self:GetRounded(), 0, 0, w, h, self:GetBackgroundColor())
end

vgui.Register("XeninUI.TextEntry", PANEL)

--addons/xenin-coinflip/lua/coinflip/essentials/config_wrapper.lua:
return gluapack()()
--addons/xenin-coinflip/lua/coinflip/essentials/currency.lua:
return gluapack()()
--addons/xenin-coinflip/lua/coinflip/currencies/ps1.lua:
local CURRENCY = {}
CURRENCY.Name = "Points"

function CURRENCY:Add(ply, amt)
	ply:PS_GivePoints(amt)
end
function CURRENCY:CanAfford(ply, amt)
	return ply:PS_HasPoints(amt)
end
function CURRENCY:Format(amt)
	return string.Comma(amt) .. " points"
end

Coinflip:CreateCurrency("Pointshop", CURRENCY)
--addons/xenin-coinflip/lua/coinflip/ui/games_create.lua:
local PANEL = {}

XeninUI:CreateFont("Coinflip.Games.Create.Title", 28)
XeninUI:CreateFont("Coinflip.Games.Create.Option", 25)
XeninUI:CreateFont("Coinflip.Games.Create.Slider", 18)

local matCanAfford = Material("xenin/tick.png", "smooth")
local matCantAfford = Material("xenin/closebutton.png", "smooth")

function PANEL:Init()
	self:SetAlpha(0)
	self:AlphaTo(255, 0.15)

	self:SetSize(ScrW(), ScrH())
	self:SetBackgroundWidth(508)
	local height = 268
	if (!Coinflip.Config.DisableCreationAnnouncement) then height = height + 44 end
	if (!Coinflip.Config.DisableWinAnnouncement) then height = height + 44 end
	if (istable(Coinflip.Config.Currency)) then height = height + 44 end
	self:SetBackgroundHeight(height)
	self:SetTitle(Coinflip.i18n:get("ui.flips.create.title", nil, "Create a coinflip"))
	self:MakePopup()

	self.Panel = self.background:Add("XeninUI.Panel")
	self.Panel:Dock(FILL)
	self.Panel.PerformLayout = function(pnl, w, h)
		local x = 16
		local y = 16

		self.Avatar:SetPos(x, y)
		self.Avatar:SetSize(80, 80)

		self.Text:SetPos(x + self.Avatar:GetWide() + 10, y + 1)
		self.Text:SizeToContents()

		self.Textentry:SetPos(self.Text.x, self.Text.y + self.Text:GetTall() + 5)
		self.Textentry:SetTall(36)
		self.Textentry:SetWide(w - x - self.Avatar:GetWide() - 10 - x)

		y = y + self.Avatar:GetTall() + 16

		for i, v in pairs(self.options) do
			v:SetPos(x, y)
			v:SetSize(w - (x * 2), 36)

			y = y + v:GetTall() + 8
		end
	end

	self.Avatar = self.Panel:Add("XeninUI.Avatar")
	self.Avatar:SetVertices(90)
	self.Avatar:SetPlayer(LocalPlayer(), 128)

	self.Text = self.Panel:Add("DLabel")
	self.Text:SetText(Coinflip.i18n:get("ui.flips.create.howMuch", nil, "How much would you like to bet?"))
	self.Text:SetFont("Coinflip.Games.Create.Title")
	self.Text:SetTextColor(Color(220, 220, 220))

	self.Textentry = self.Panel:Add("XeninUI.TextEntry")
	self.Textentry:SetPlaceholder(Coinflip:GetCurrency():Format(10000))
	self.Textentry.textentry:SetUpdateOnType(true)
	self.Textentry.textentry:SetNumeric(true)
	self.Textentry.textentry.OnValueChange = function(pnl, text)
		local num = tonumber(text)
		if (!num) then self.Textentry.Summary.icon = nil return end
		local curr = Coinflip:GetCurrency(self.Currency)
		local canAfford = curr:CanAfford(LocalPlayer(), num)
		if (num < Coinflip.Config.MinBet) then canAfford = false end
		if (num > Coinflip.Config.MaxBet and Coinflip.Config.MaxBet != 0) then canAfford = false end

		self.Textentry.Summary.icon = canAfford and matCanAfford or matCantAfford
		self.Textentry.Summary.color = canAfford and XeninUI.Theme.Green or XeninUI.Theme.Red
	end

	self.Textentry.Summary = self.Textentry:Add("Panel")
	self.Textentry.Summary:Dock(RIGHT)
	self.Textentry.Summary:DockMargin(0, 0, 0, 0)
	self.Textentry.Summary:SetWide(36)
	self.Textentry.Summary.Paint = function(pnl, w, h)
		if (pnl.icon) then
			surface.SetMaterial(pnl.icon)
			surface.SetDrawColor(pnl.color)
			surface.DrawTexturedRect(6, 6, h - 12, h - 12)
		end
	end

	self.options = {}

	if (istable(Coinflip.Config.Currency)) then
		self:CreateDropdown("currency", Coinflip.i18n:get("ui.flips.create.currency", nil, "Currency"), Coinflip:GetCurrencies()[1])
	end
	if (!Coinflip.Config.DisableCreationAnnouncement) then
		self:CreateCheckbox("announceCreation", Coinflip.i18n:get("ui.flips.create.announceCreation", nil, "Announce creation"), true)
	end
	if (!Coinflip.Config.DisableWinAnnouncement) then
		self:CreateCheckbox("announceWinner", Coinflip.i18n:get("ui.flips.create.announceWinner", nil, "Announce winner"), true)
	end
	self:CreateSlider("timeLimit", Coinflip.i18n:get("ui.flips.create.timeLimit.msg", nil, "Time limit"), 5)

	self.Create = self.Panel:Add("XeninUI.ButtonV2")
	self.Create:Dock(BOTTOM)
	self.Create:DockMargin(16, 16, 16, 16)
	self.Create:SetText(Coinflip.i18n:get("ui.flips.create.create", nil, "Create"))
	self.Create:SetFont("Coinflip.Games.Button")
	self.Create:SizeToContentsY(24)
	self.Create:SetTextColor(Color(222, 222, 222))
	self.Create:SetRoundness(6)
	self.Create:SetSolidColor(XeninUI.Theme.Primary)
	self.Create:SetHoverColor(Color(65, 65, 65))
	local oldPaint = self.Create.Paint
	self.Create.Paint = function(pnl, w, h)
		oldPaint(pnl, w, h)

		if (pnl.Loading) then
			local size = h / 2
			local x = w / 2
			local y = h / 2

			XeninUI:DrawLoadingCircle(x, y, size)
		end
	end
	self.Create.DoClick = function(pnl)
		local money = tonumber(self.Textentry:GetText())
		if (!money) then return end
		money = math.abs(money)
		local curr = Coinflip:GetCurrency(self.Currency)
		if (!curr:CanAfford(LocalPlayer(), money)) then return end
		if (money < Coinflip.Config.MinBet) then return end
		if (money > Coinflip.Config.MaxBet and Coinflip.Config.MaxBet != 0) then return end

		pnl:SetText("")
		pnl.Loading = true

		local tbl = {}
		for i, v in pairs(self.options) do
			if (v.slider) then 
				tbl[i] = math.floor((v.slider:GetMax() * v.slider.fraction)) + v.slider:GetMin()

				continue
			elseif (v.button) then
				tbl[i] = v.button.Currency

				continue
			end

			tbl[i] = v.checkbox:GetState()
		end

		net.Start("Coinflip.Create")
			net.WriteUInt(money, 32)
			net.WriteBool(tobool(tbl.announceCreation))
			net.WriteBool(tobool(tbl.announceWinner))
			net.WriteUInt(tbl.timeLimit, 5)
			net.WriteString(tbl.currency or Coinflip.Config.Currency)
		net.SendToServer()

		hook.Add("Coinflip.Created", "CoinflipMenu", function(id)
			if (!IsValid(self)) then return end

			self:AlphaTo(0, 0.15, nil, function()
				self:Remove()
			end)
		end)
	end

	hook.Add("Coinflip.Create.Error", self, function(self, err)
		self.Panel:Notification(err, XeninUI.Theme.Red)
		self.Create.Loading = false
		self.Create:SetText(Coinflip.i18n:get("ui.flips.create.create", nil, "Create"))
	end)
end

function PANEL:CreateDropdown(id, text, defaultState)
	self.options[id] = self.Panel:Add("Panel")
	local panel = self.options[id]
	panel.text = panel:Add("DLabel")
	panel.text:Dock(LEFT)
	panel.text:SetText(text)
	panel.text:SetFont("Coinflip.Games.Create.Option")
	panel.text:SetTextColor(Color(200, 200, 200))
	panel.text:SizeToContents()

	local currency = Coinflip:GetCurrencies()[1]
	local realCurrency = currency
	for i, v in pairs(Coinflip.Currencies) do
		if (i != currency) then continue end
		
		realCurrency = i
		currency = v.Name or i
	end
	panel.button = panel:Add("XeninUI.ButtonV2")
	panel.button:Dock(RIGHT)
	panel.button:SetWide(110)
	panel.button:SetText(currency)
	panel.button.Currency = realCurrency
	panel.button:SetSolidColor(XeninUI.Theme.Primary)
	panel.button:SetRoundness(6)
	panel.button:SizeToContentsX(32)
	panel.button.SortChanged = function(pnl, text, currency)
    pnl:SetText(text)
		pnl:SizeToContentsX(32)
		pnl.Currency = currency
		self.Currency = currency

		self.Textentry:SetPlaceholder(Coinflip:GetCurrency(currency):Format(10000))

    self:InvalidateLayout()
	end
	panel.button.DoClick = function(pnl)
		local func = function(btn)
			local currency = btn:GetText()
			for i, v in pairs(Coinflip.Currencies) do
				if (v.Name != currency) then continue end
				
				currency = i
			end
		  pnl:SortChanged(btn:GetText(), currency)
		end
		local hoverColor = Color(75, 75, 75)

		local panel = XeninUI:DropdownPopup(pnl:LocalToScreen(-12, -12 + pnl:GetTall()))
		panel:SetBackgroundColor(XeninUI.Theme.Navbar)
		panel:SetTextColor(Color(185, 185, 185))
    for i, v in ipairs(Coinflip:GetCurrencies()) do
			local currency = Coinflip.Currencies[v]
			if (!currency) then continue end

      panel:AddChoice(currency.Name or v, func, nil, hoverColor)
    end
  end
end

function PANEL:CreateCheckbox(id, text, defaultState)
	self.options[id] = self.Panel:Add("Panel")
	local panel = self.options[id]
	panel.text = panel:Add("DLabel")
	panel.text:Dock(LEFT)
	panel.text:SetText(text)
	panel.text:SetFont("Coinflip.Games.Create.Option")
	panel.text:SetTextColor(Color(200, 200, 200))
	panel.text:SizeToContents()

	panel.checkbox = panel:Add("XeninUI.Checkbox")
	panel.checkbox:Dock(RIGHT)
	panel.checkbox:SetWide(110)
	panel.checkbox:SetStateText(
		Coinflip.i18n:get("ui.flips.create.no", nil, "NO"), 
		Coinflip.i18n:get("ui.flips.create.yes", nil, "YES")
	)
	panel.checkbox:SetState(defaultState, true)
end

function PANEL:CreateSlider(id, text, time)
	self.options[id] = self.Panel:Add("Panel")
	local panel = self.options[id]
	panel.text = panel:Add("DLabel")
	panel.text:Dock(LEFT)
	panel.text:SetText(text)
	panel.text:SetFont("Coinflip.Games.Create.Option")
	panel.text:SetTextColor(Color(200, 200, 200))
	panel.text:SizeToContentsY()
	panel.text:SizeToContentsX(16)

	panel.sliderText = panel:Add("DLabel")
	panel.sliderText:Dock(RIGHT)
	panel.sliderText:SetText(Coinflip.i18n:get("ui.flips.create.timeLimit.time", { number = time }, ":number: min"))
	panel.sliderText:SetFont("Coinflip.Games.Create.Slider")
	panel.sliderText:SetTextColor(Color(200, 200, 200))
	panel.sliderText:SizeToContentsY()
	panel.sliderText:SetContentAlignment(6)
	panel.sliderText:SetWide(58)

	panel.slider = panel:Add("XeninUI.Slider")
	panel.slider:Dock(RIGHT)
	panel.slider:DockMargin(0, 0, 16, 0)
	panel.slider:SetWide(110)
	panel.slider:SetMax(25)
	panel.slider:SetMin(5)
	panel.slider.OnValueChanged = function(pnl, frac)
		local time = pnl:GetMin() + math.floor(frac * pnl:GetMax())

		panel.sliderText:SetText(Coinflip.i18n:get("ui.flips.create.timeLimit.time", { number = time }, ":number: min"))
	end
end

vgui.Register("Coinflip.Games.Create", PANEL, "XeninUI.Popup")
--addons/xenin-coinflip/lua/coinflip/ui/history_row.lua:
return gluapack()()
--addons/xenin-inventory/lua/inventory/classes/config.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/inventory/configuration/items/zrms_bar.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

local ITEM = XeninInventory:CreateItemV2()
ITEM:SetMaxStack(10)
ITEM:SetModel("models/Zerochain/props_mining/zrms_bar.mdl")
ITEM:SetDescription("A Bar of Metal")

function ITEM:CanStack(newItem, invItem)
	local ent = isentity(newItem)
	local metaltype = ent and newItem:GetMetalType() or newItem.data.MetalType
	return metaltype == invItem.data.MetalType
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

ITEM:AddDrop(function(self, ply, ent, tbl, tr)
	local data = tbl.data
	ent:SetMetalType(data.MetalType)
	zrmine.f.SetOwner(ent, ply)
	ent:UpdateVisuals()
end)

function ITEM:GetData(ent)
	return {
		MetalType = ent:GetMetalType()
	}
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ITEM:GetDisplayName(item)
	return self:GetName(item)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ITEM:GetName(item)
	local ent = isentity(item)
	local metaltype = ent and item:GetMetalType() or item.data.MetalType
	local name = metaltype .. " Bar"

	return name
end

function ITEM:GetCameraModifiers(tbl)
	return {
		FOV = 40,
		X = 0,
		Y = -22,
		Z = 25,
		Angles = Angle(0, -190, 0),
		Pos = Vector(0, 0, -1)
	}
end

function ITEM:GetClientsideModel(tbl, mdlPanel)
	local MetalType = tbl.data.MetalType

	if (MetalType == "Iron") then
		mdlPanel.Entity:SetSkin(0)
	elseif (MetalType == "Bronze") then
		mdlPanel.Entity:SetSkin(1)
	elseif (MetalType == "Silver") then
		mdlPanel.Entity:SetSkin(2)
	elseif (MetalType == "Gold") then
		mdlPanel.Entity:SetSkin(3)
	end
end

ITEM:Register("zrms_bar")

--addons/zeros_retrominer_v2.3.6/lua/inventory/configuration/items/zrms_resource.lua:
return gluapack()()
--addons/zeros_trashman_v1.6.3/lua/inventory/configuration/items/ztm_recycled_block.lua:
return gluapack()()
--addons/xenin-inventory/lua/inventory/configuration/items/zwf_jar.lua:
--[[
This code was generated by LAUX, a Lua transpiler
LAUX is a fork of LAU with additional changes.

More info & source code can be found at: https://gitlab.com/sleeppyy/laux
]]

local ITEM = XeninInventory:CreateItemV2()
ITEM:SetMaxStack(1)
ITEM:SetModel("models/zerochain/props_weedfarm/zwf_jar.mdl")
ITEM:SetDescription("A jar of weed")

ITEM:AddDrop(function(self, ply, ent, tbl, tr)
  local data = tbl.data

  ent:SetPlantID(data.PlantID)
  ent:SetWeedName(data.WeedName)
  ent:SetWeedAmount(data.WeedAmount)
  ent:SetTHC(data.THC)

  ent:SetPerf_Time(data.Perf_Time)
  ent:SetPerf_Amount(data.Perf_Amount)
  ent:SetPerf_THC(data.Perf_THC)

  zwf.f.SetOwnerByID(ent, data.ZWFOwner)
end)

function ITEM:GetData(ent)
  return {
    PlantID = ent:GetPlantID(),
    WeedName = ent:GetWeedName(),
    WeedAmount = ent:GetWeedAmount(),
    THC = ent:GetTHC(),
    Perf_Time = ent:GetPerf_Time(),
    Perf_Amount = ent:GetPerf_Amount(),
    Perf_THC = ent:GetPerf_THC(),
    ZWFOwner = zwf.f.GetOwnerID(ent)
  }
end

function ITEM:GetVisualAmount(item)
  return item.data.WeedAmount
end

function ITEM:GetName(item)
  local ent = isentity(item)
  local weedName = ent and item:GetWeedName() or item.data.WeedName
  local plant = ent and item:GetPlantID() or item.data.PlantID
  plant = zwf.config.Plants[plant]
  plant = plant and plant.Name or "Unknown plant"

  return weedName .. " [" .. plant .. "]"
end


ITEM:Register("zwf_jar")

--addons/xenin-inventory/lua/inventory/importer/setting.lua:
return gluapack()()
--addons/xenin-inventory/lua/inventory/ui/inventory_field.lua:
return gluapack()()
--addons/xenin-inventory/lua/inventory/ui/admin/player.lua:
--[[
This code was generated by LAUX, a Lua transpiler
LAUX is a fork of LAU with additional changes.

More info & source code can be found at: https://gitlab.com/sleeppyy/laux
]]

local PANEL = {}
local INV = false
local BANK = true

function PANEL:Init()
  self:SetAlpha(0)
  self:AlphaTo(255, 0.15)

  self:SetSize(ScrW(), ScrH())
  self:SetBackgroundWidth(XeninUI.Frame.Width)
  self:SetBackgroundHeight(XeninUI.Frame.Height)
  self:SetTitle(XeninInventory:GetPhrase("Admin.Player.Title"))
  self:MakePopup()
end

XeninUI:CreateFont("XeninInventory.Admin.Player.State", 24)

function PANEL:SetData(tbl)
  local ply = LocalPlayer()
  self.data = tbl

  self.Top = self.background:Add("DPanel")
  self.Top:Dock(TOP)
  self.Top:DockMargin(0, 0, 0, 0)
  self.Top:SetTall(64)
  self.Top.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBox(0, 0, 0, w, h, XeninUI.Theme.Navbar)

    XeninUI:DrawShadowText(self.data.nick, "XeninInventory.Admin.Row.Title", h, h / 2 + 3 - 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM, 2, 125)
    XeninUI:DrawShadowText(XeninInventory:GetPhrase("Admin.Player.Items", {
    items = self.data.items }), "XeninInventory.Admin.Row.Subtitle", h, h / 2 + 2, Color(180, 180, 180), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, 125)
  end

  self.Top.Avatar = self.Top:Add("XeninUI.Avatar")
  self.Top.Avatar:SetVertices(30)
  self.Top.Avatar.avatar:SetSteamID(tbl.sid64, 128)

  self.Top.Clear = self.Top:Add("DButton")
  self.Top.Clear:SetText(XeninInventory:GetPhrase("Admin.Player.Clear.XeninInventory"))
  self.Top.Clear:SetFont("XeninInventory.Admin.Row.Interact")
  self.Top.Clear.TextColor = Color(220, 220, 220)
  self.Top.Clear.Color = XeninUI.Theme.Background
  self.Top.Clear.Paint = function(pnl, w, h)
    pnl:SetTextColor(pnl.TextColor)

    XeninUI:DrawRoundedBox(h / 2, 0, 0, w, h, pnl.Color)
  end
  self.Top.Clear.OnCursorEntered = function(pnl)
    pnl:LerpColor("TextColor", color_white)
    pnl:LerpColor("Color", XeninUI.Theme.Primary)
  end
  self.Top.Clear.OnCursorExited = function(pnl)
    pnl:LerpColor("TextColor", Color(220, 220, 220))
    pnl:LerpColor("Color", XeninUI.Theme.Background)
  end
  self.Top.Clear.DoClick = function(pnl)
    local bank = self.isBank
    local popup = vgui.Create("XeninUI.Query")
    popup:SetSize(ScrW(), ScrH())
    popup:SetBackgroundWidth(400)
    popup:SetBackgroundHeight(140)
    local str = bank and XeninInventory:GetPhrase("Admin.Player.Clear.Bank") or XeninInventory:GetPhrase("Admin.Player.Clear.XeninInventory")
    popup:SetTitle(str)
    str = XeninInventory:GetPhrase("Admin.Player.Clear.Popup.Text", {
    type = bank and "bank" or "inventory"
    })
    popup:SetText(str)
    popup:SetAccept(XeninInventory:GetPhrase("Admin.Player.Clear.Popup.Yes"), function()
      net.Start("XeninInventory.Admin.Clear")
      net.WriteString(self.data.sid64)
      net.WriteBool(bank)
      net.SendToServer()

      if bank then
        self.data.bank = {}
      else
        self.data.inv = {}
      end

      for i, v in pairs(self.Fields) do
        self.Fields[i]:Remove()
        self.Fields[i] = nil
      end
    end)
    popup:SetDecline(XeninInventory:GetPhrase("Admin.Player.Clear.Popup.No"), function() end)
    popup:MakePopup()
  end

  self.Top.PerformLayout = function(pnl, w, h)
    self.Top.Avatar:SetPos(8, 8)
    self.Top.Avatar:SetSize(h - 16, h - 16)

    self.Top.Clear:SizeToContentsX(32)
    self.Top.Clear:SizeToContentsY(16)
    self.Top.Clear:AlignRight(8)
    self.Top.Clear:CenterVertical()
  end

  self.Type = self.background:Add("XeninUI.Checkbox")
  self.Type:Dock(TOP)
  self.Type:SetTall(40)
  self.Type:SetStateText(XeninInventory:GetPhrase("Admin.Player.Tabs.XeninInventory"), XeninInventory:GetPhrase("Admin.Player.Tabs.Bank"))
  self.Type.font = "XeninInventory.Admin.Player.State"
  self.Type.OnStateChanged = function(pnl, state)
    self:Build(state)
  end

  self.Scroll = self.background:Add("XeninUI.Scrollpanel.Wyvern")
  self.Scroll:Dock(FILL)
  self.Scroll:DockMargin(8, 16, 8, 8)

  self.Layout = self.Scroll:Add("DIconLayout")
  self.Layout:Dock(FILL)
  self.Layout:DockMargin(0, 0, 8, 0)
  self.Layout:SetSpaceY(8)
  self.Layout:SetSpaceX(8)
  self.Layout.PerformLayout = function(pnl, w, h)
    local children = pnl:GetChildren()
    local count = 8
    local amount = math.max(1, math.floor(#children / count)) * 276
    local width = w / math.min(count, #children)

    local x = 0
    local y = 0

    local spacingX = pnl:GetSpaceX()
    local spacingY = pnl:GetSpaceY()
    local border = pnl:GetBorder()
    local innerWidth = w - border * 2 - spacingX * (count - 1)

    for i, child in ipairs(children) do
      if (!IsValid(child)) then continue end

      child:SetPos(border + x * innerWidth / count + spacingX * x, border + y * child:GetTall() + spacingY * y)
      child:SetSize(innerWidth / count, innerWidth / count)

      x = x + 1
      if (x >= count) then
        x = 0
        y = y + 1
      end
    end

    pnl:SizeToChildren(false, true)
  end

  self.Fields = {}

  self:Build(INV)
end

function PANEL:Build(bank)
  self.isBank = bank
  self.data.items = bank and table.Count(self.data.bank) or table.Count(self.data.inv)
  local str = bank and XeninInventory:GetPhrase("Admin.Player.Clear.Bank") or XeninInventory:GetPhrase("Admin.Player.Clear.XeninInventory")
  self.Top.Clear:SetText(str)
  self.Top:InvalidateLayout()

  for i, v in pairs(self.Fields) do
    v:Remove()
    self.Fields[i] = nil
  end

  local tbl = self.data[bank and "bank" or "inv"]
  local highestNum = 0
  for i, v in pairs(tbl) do
    if (v.id > highestNum) then
      highestNum = v.id
    end
  end

  for i = 1, highestNum do
    local id = tonumber(i)
    self.Fields[id] = self.Layout:Add("XeninInventory.Field")
    self.Fields[id]:SetItem(tbl and tbl[id])
    self.Fields[id]:SetDroppable(false, bank)
    self.Fields[id]:SetID(tbl[id] and tbl[id].id or id)
    self.Fields[id]:SetIsAdmin(self.data.sid64)
    self.Fields[id]:SetIsBank(self.isBank)
  end
end

function PANEL:PerformLayout(w, h)
  self.BaseClass.PerformLayout(self, w, h)
end

vgui.Register("XeninInventory.Admin.Player", PANEL, "XeninUI.Popup")

--lua/autorun/yardimcilider.lua:
if SERVER then
	AddCSLuaFile()
end


player_manager.AddValidModel("IMHD Yardimci Lider", "models/konnie/imhd/yardimcilider/wildcardyrm.mdl")
--addons/yet_another_warn_system/lua/yaws/core/sh_cami.lua:
return gluapack()()
--addons/yet_another_warn_system/lua/yaws/punishments/sh_jail.lua:
local PUNISHMENT = YAWS.Punishments.CreatePunishment()
PUNISHMENT:SetID("yaws.jail")
PUNISHMENT:SetName("Jail")
PUNISHMENT:SetDescription("Jails the player for a certain time.")

PUNISHMENT:AddParameter("duration", "Duration", "The duration they are jailed in minutes.", "number", 1)

PUNISHMENT:ShouldEnable(function()
    return (ulx || sam) and true or false
end)
PUNISHMENT:SetAction(function(admin, targetSteamID, params)
    local ply = player.GetBySteamID64(targetSteamID)
    if(!ply) then return false,"Player is not online." end

    if(ulx) then 
        -- ulx.jail(admin, {ply}, params['duration'] * 60, false)
        RunConsoleCommand("ulx", "jail", ply:SteamID(), params['duration'] * 60)
        YAWS.Language.SendRawMessage(ply, "Due to your actions you have been jailed.")
        return true
    end 

    if(sam) then 
        RunConsoleCommand("sam", "jail", targetSteamID, params.duration)
        YAWS.Language.SendRawMessage(ply, "Due to your actions you have been jailed.")
        return true
    end 
    -- and apparently xadmin doesn't support jailing :(
    
    return false, "Could not find a supported admin system to jail with."
end)
--addons/yet_another_warn_system/lua/yaws/ui/elements/cl_scroll.lua:
return gluapack()()
--addons/yet_another_warn_system/lua/yaws/ui/elements/cl_three_grid.lua:
-- MIT License

-- Copyright (c) 2018-2021 three bow technologies and industries ltd gmbh

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.







-- This is a modified version of Theebow's Better Derma Grid that actually
-- fucking works and lays out properly 
-- if your ever bored, download the original and try to get it to work with
-- elements that layout in PerformLayout like they're meant to, instead of just
-- on creation. Fun little experiment to see how quickly you turn to alcohol and
-- eventually the noose
-- https://github.com/Threebow/better-derma-grid

local PANEL = {}

AccessorFunc(PANEL, "horizontalMargin", "HorizontalMargin", FORCE_NUMBER)
AccessorFunc(PANEL, "verticalMargin", "VerticalMargin", FORCE_NUMBER)
AccessorFunc(PANEL, "columns", "Columns", FORCE_NUMBER)

function PANEL:Init()
	self:SetHorizontalMargin(0)
	self:SetVerticalMargin(0)

	self.Rows = {}
	self.Cells = {}
end

function PANEL:AddCell(pnl)
	local cols = self:GetColumns()
	local idx = math.floor(#self.Cells/cols)+1
	self.Rows[idx] = self.Rows[idx] || self:CreateRow()

	local margin = self:GetHorizontalMargin()
	
	pnl:SetParent(self.Rows[idx])
    -- _____
	pnl:Dock(LEFT)
	pnl:DockMargin(0, 0, #self.Rows[idx].Items+1 < cols && self:GetHorizontalMargin() || 0, 0)
	pnl:SetWide((self:GetWide() - margin * (cols - 1)) / cols)

	table.insert(self.Rows[idx].Items, pnl)
	table.insert(self.Cells, pnl)
	self:CalculateRowHeight(self.Rows[idx])

    self:InvalidateLayout()
end

function PANEL:CreateRow()
	local row = self:Add("DPanel")
    -- _____
	-- row:Dock(TOP)
	-- row:DockMargin(0, 0, 0, self:GetVerticalMargin())
	row.Paint = nil
	row.Items = {}
	return row
end

function PANEL:CalculateRowHeight(row)
	local height = 0

	for k, v in pairs(row.Items) do
		height = math.max(height, v:GetTall())
	end

	row:SetTall(height)
end

function PANEL:Skip()
	local cell = vgui.Create("DPanel")
	cell.Paint = nil
	self:AddCell(cell)
    self:InvalidateLayout()
end

function PANEL:Clear()
	for _, row in pairs(self.Rows) do
		for _, cell in pairs(row.Items) do
			cell:Remove()
		end
		row:Remove()
	end

	self.Cells, self.Rows = {}, {}
    self:InvalidateLayout()
end

function PANEL:PerformLayout(w, h)
	self:PrePerformLayout(w, h)

    for _,row in pairs(self.Rows) do 
        row:Dock(TOP)
	    row:DockMargin(0, 0, 0, self:GetVerticalMargin())
		
		for _,cell in pairs(row.Items) do
            local cols = self:GetColumns()
	        -- local idx = math.floor(#self.Cells/cols)+1
            local margin = self:GetHorizontalMargin()
			
			cell:Dock(LEFT)
			-- never gona be able to use this for anything else aside from 3 col grids now lmfao
			if(_ % 3 == 1) then 
				cell:DockMargin(
					0,
					0,
					margin,
					0
				)
			elseif(_ % 3 == 2) then 
				cell:DockMargin(
					0,
					0,
					0,
					0
				)
			else 
				cell:DockMargin(
					margin,
					0,
					0,
					0
				)
			end 
            cell:SetWide((self:GetWide() - (margin * (cols - 1))) / cols)
        end
    end 

	self:PostPerformLayout(w, h)
end 
function PANEL:PrePerformLayout(w, h) end 
function PANEL:PostPerformLayout(w, h) end 

PANEL.OnRemove = PANEL.Clear

vgui.Register("yaws.grid", PANEL, "yaws.scroll")
--addons/yet_another_warn_system/lua/yaws/ui/elements/inputs/cl_icon_btn.lua:
local PANEL = {}

function PANEL:Init()
    self:SetText("")
    self.material = nil 
    self.color = YAWS.UI.ColorScheme()["icon_button_base"]
    self.padding = 0
    self.flip = false
    self.frameTime = RealFrameTime()
end 

function PANEL:SetMaterial(mat)
    self.material = mat
end 
function PANEL:SetIconPadding(pad)
    self.padding = pad
end 
function PANEL:FlipIcon(flip)
    self.flip = flip
end 

function PANEL:Paint(w, h)
    if(!self.material) then return end

    local colors = YAWS.UI.ColorScheme()

    if(self:IsHovered()) then 
        self.color = YAWS.UI.LerpColor(self.frameTime * 5, self.color, colors["icon_button_hover"])
    else 
        self.color = YAWS.UI.LerpColor(self.frameTime * 5, self.color, colors["icon_button_base"])
    end 

    YAWS.UI.SetSurfaceDrawColor(self.color)
    surface.SetMaterial(self.material)
    if(self.flip) then 
        surface.DrawTexturedRectRotated(self.padding + (w / 4), self.padding + (h / 4), w - (self.padding * 2), h - (self.padding * 2), 180)
    else 
        surface.DrawTexturedRect(self.padding, self.padding, w - (self.padding * 2), h - (self.padding * 2))
    end
end 

vgui.Register("yaws.iconbtn", PANEL, "DButton")
--addons/yet_another_warn_system/lua/yaws/ui/elements/misc/cl_shadow.lua:
return gluapack()()
--addons/yet_another_warn_system/lua/yaws/ui/layouts/cl_misc.lua:
function YAWS.UI.DisplayLoading(master)
    master.PerformLayout = function(self, w, h) end
    master:Clear()
    
    local clr = YAWS.UI.ColorScheme()['text_header']
    master.loadRotation = 0

    -- yes this is a crude attempt at a easter egg
    master.text = ((math.random(0, 100) < 99) && YAWS.Language.GetTranslation("loading")) || YAWS.Language.GetTranslation("loading_hehe")

    master.Paint = function(self, w, h) 
        master.loadRotation = Lerp(RealFrameTime() * 100, master.loadRotation, master.loadRotation + 1)

        draw.NoTexture()
        surface.SetMaterial(YAWS.UI.MaterialCache['load'])
        YAWS.UI.SetSurfaceDrawColor(clr)
        surface.DrawTexturedRectRotated(w /2 , h / 2, w * 0.05, w * 0.05, master.loadRotation)

        draw.SimpleText(master.text, "yaws.8", w / 2, (h * 0.45) + (w * 0.05) + (h * 0.05), clr, 1, 1)
    end

    master:InvalidateLayout()
end

function YAWS.UI.ConfirmDeleteWarns(master, data)
    master.PerformLayout = function(self, w, h) end
    master:Clear()
        
    master.Paint = function(self, w, h) 
        local colors = YAWS.UI.ColorScheme()

        draw.SimpleText(YAWS.Language.GetFormattedTranslation("viewing_player_wipe_header", data.name), "yaws.9", w / 2, h * 0.46, colors['text_header'], 1, 1)
        draw.SimpleText(YAWS.Language.GetTranslation("viewing_player_wipe_subtext"), "yaws.7", w / 2, h * 0.505, colors['text_main'], 1, 1)
    end

    local buttons = vgui.Create("DPanel", master)
    buttons.Paint = function() end 

    local confirm = vgui.Create("yaws.button", buttons)
    confirm:SetLabel(YAWS.Language.GetTranslation("generic_save"))
    confirm.DoClick = function() 
        net.Start("yaws.warns.wipewarns")
        net.WriteString(data.steamid)
        net.SendToServer()
    
        if(YAWS.UI.CurrentData.FrameCache) then 
            YAWS.UI.CurrentData.FrameCache:Close()
        end 
    end 

    local back = vgui.Create("yaws.button", buttons)
    back:SetColors("button_warn_base", "button_warn_hover")
    back:SetLabel(YAWS.Language.GetTranslation("generic_cancel"))
    back.DoClick = function() 
        YAWS.UI.DisplayPlayerInfo(master, data)
    end 
    
    master.PerformLayout = function(self, w, h) 
        buttons:SetPos(master:GetWide() * 0.2, master:GetTall() * 0.55)
        buttons:SetSize(master:GetWide() * 0.6, master:GetTall() * 0.056)

        confirm:Dock(LEFT)
        confirm:SetWide((buttons:GetWide() / 2) - 5)

        back:Dock(RIGHT)
        back:SetWide((buttons:GetWide() / 2) - 5)
    end
    master:InvalidateLayout()
end 


net.Receive("yaws.warns.confirmupdate", function(len)
    YAWS.Core.PayloadDebug("yaws.warns.confirmupdate", len)
    if(!YAWS.UI.CurrentData.WaitingForServerResponse) then 
        YAWS.Core.LogWarning("[yaws.warns.confirmupdate] Just got a message from the server without wanting data from the server..?")
        return
    end 

    local success = net.ReadBool()
    if(success) then 
        if(YAWS.UI.LoadingCache['panel'] == "wipe_warns") then 
            YAWS.UI.LoadingCache['data'].warnData.warnings = {}
            YAWS.UI.LoadingCache['data'].warnData.expiredPointCount = 0
            YAWS.UI.LoadingCache['data'].warnData.pointCount = 0
        end 
    end 

    YAWS.UI.CurrentData.FrameCache:SetSidebarSelectedName(YAWS.Language.GetTranslation("sidebar_players"))
    YAWS.UI.DisplayPlayerInfo(YAWS.UI.CurrentData.MasterCache, YAWS.UI.LoadingCache['data'])
    YAWS.UI.CurrentData.WaitingForServerResponse = false
end)
--addons/yet_another_warn_system/lua/yaws/ui/layouts/tabs/cl_admin.lua:
return gluapack()()
--addons/advancedkillfeed/lua/z_advancedkillfeed/sh_z_advancedkillfeedsettings.lua:
return gluapack()()
--addons/advancedkillfeed/lua/z_advancedkillfeed/client/cl_z_advancedkillfeed_test.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER]]

-- local scrW,scrH = ScrW(),ScrH()
local scrW,scrH = 1920,1080

function CL_ADVANCEDFEED.DrawExampleStr(x,y,str,color,parent,drawBackGround)
	
	local FeedItem = vgui.Create("DPanel",parent)
	FeedItem:SetText("")
	FeedItem:SetAlpha(255)

	surface.SetFont( "z_CODKillFeedFont_Static" )
	local _, fontHeight = surface.GetTextSize( "[MWG]" )
	feedItemHeight = fontHeight + ScrH()*0.014
	
	FeedItem:SetSize(scrW*0.15,feedItemHeight)
	
	FeedItem:SetDrawBackground( false )
	FeedItem:SetPos(x,y)
	
	local strLbl = CL_ADVANCEDFEED.CreateTextLabel(FeedItem,str,color,drawBackGround,"z_CODKillFeedFont_Static")
	
	return strLbl
	
end


local function z_DrawExamples()
	
	local TestPanel = vgui.Create("DPanel")
	TestPanel:SetText("")
	TestPanel:SetPos(scrW*0.05,scrH*0.05)
	TestPanel:SetSize(scrW*0.4,scrH*0.5)
	TestPanel.Paint = function(_,w,h)
		draw.RoundedBox( 0,0,0,w,h,Color(0,0,0,180))
		draw.SimpleText("Examples","DermaLarge",w/2,h*0.01,SH_ADVANCEDFEED.Col.WHITE,TEXT_ALIGN_CENTER,TEXT_ALIGN_TOP )
		draw.SimpleText("Animations","DermaLarge",w/4,h*0.1,SH_ADVANCEDFEED.Col.WHITE,TEXT_ALIGN_CENTER,TEXT_ALIGN_TOP )
		draw.SimpleText("Effects","DermaLarge",w/4*3,h*0.1,SH_ADVANCEDFEED.Col.WHITE,TEXT_ALIGN_CENTER,TEXT_ALIGN_TOP )
		
		surface.SetDrawColor( SH_ADVANCEDFEED.Col.WHITE )
		surface.DrawOutlinedRect( 0, 0, w, h )
	end
	
	local w,h = TestPanel:GetSize()
	local xSpace = 65
	local animW,animH,effectW,effectH = w*0.17,h*0.25,w*0.7,h*0.25
	
	-- animations
	local waveCharTbl = CL_ADVANCEDFEED.DrawExampleStr(animW,animH,"Wave Animation",SH_ADVANCEDFEED.Col.WHITE,TestPanel,true)
	animH=animH+xSpace
	-- "double Wave Animation"
	local doubleWaveCharTbl = CL_ADVANCEDFEED.DrawExampleStr(animW,animH,"DAonuibmlaetwiaovne",SH_ADVANCEDFEED.Col.WHITE,TestPanel,true)
	animH=animH+xSpace
	local distortionWaveCharTbl = CL_ADVANCEDFEED.DrawExampleStr(animW,animH,"Distortion Wave Animation",SH_ADVANCEDFEED.Col.WHITE,TestPanel,true)
	animH=animH+xSpace
	local switchCharTbl = CL_ADVANCEDFEED.DrawExampleStr(animW,animH,"Switch Animation",SH_ADVANCEDFEED.Col.WHITE,TestPanel,true)
	animH=animH+xSpace
	local typewriterCharTbl = CL_ADVANCEDFEED.DrawExampleStr(animW,animH,"Type Writer Animation",SH_ADVANCEDFEED.Col.WHITE,TestPanel,true)
	
	-- effects
	local moveColEffectCharTbl = CL_ADVANCEDFEED.DrawExampleStr(effectW,effectH,"Moving Color Effect",SH_ADVANCEDFEED.Col.WHITE,TestPanel,true)
	effectH=effectH+xSpace
	local moveRainbowEffectCharTbl = CL_ADVANCEDFEED.DrawExampleStr(effectW,effectH,"Moving Rainbow Effect",SH_ADVANCEDFEED.Col.WHITE,TestPanel,true)
	effectH=effectH+xSpace
	local wordFlashCharTbl = CL_ADVANCEDFEED.DrawExampleStr(effectW,effectH,"Word Flash Effect",SH_ADVANCEDFEED.Col.WHITE,TestPanel,true)
	effectH=effectH+xSpace
	local letterFlashCharTbl = CL_ADVANCEDFEED.DrawExampleStr(effectW,effectH,"Letter Flash Effect",SH_ADVANCEDFEED.Col.WHITE,TestPanel,true)
	effectH=effectH+xSpace
	local letterRainbowCharTbl = CL_ADVANCEDFEED.DrawExampleStr(effectW,effectH,"Rainbow Effect",SH_ADVANCEDFEED.Col.WHITE,TestPanel,true)
	effectH=effectH+xSpace
	local pulseLineCharsTbl,waveStrWidth = CL_ADVANCEDFEED.DrawExampleStr(effectW,effectH,"Line Effect",SH_ADVANCEDFEED.Col.WHITE,TestPanel,true)
	CL_ADVANCEDFEED.EffectPulseLine(SH_ADVANCEDFEED.Col.RED,pulseLineCharsTbl,waveStrWidth,TestPanel,true)
	
	local nextTime = 0
	
	-- apply animations/effects
	TestPanel.Think = function()
		
		if nextTime < CurTime() then
		
			-- animations 
			CL_ADVANCEDFEED.AnimWave(waveCharTbl)
			CL_ADVANCEDFEED.AnimWaveDouble(doubleWaveCharTbl)
			CL_ADVANCEDFEED.AnimWaveDistortion(distortionWaveCharTbl)
			CL_ADVANCEDFEED.AnimSwitch(switchCharTbl)
			CL_ADVANCEDFEED.AnimTypeWriter(typewriterCharTbl,true)
			
			-- effects 
			CL_ADVANCEDFEED.EffectMovingColor(moveColEffectCharTbl,SH_ADVANCEDFEED.Col.RED)
			CL_ADVANCEDFEED.EffectMovingRainbow(moveRainbowEffectCharTbl,SH_ADVANCEDFEED.Col.RED)
			CL_ADVANCEDFEED.EffectWordFlash(wordFlashCharTbl)
			CL_ADVANCEDFEED.EffectLetterFlash(letterFlashCharTbl)
			CL_ADVANCEDFEED.EffectRainbow(letterRainbowCharTbl)
			
			
			-- limit everything to 30FPS
			nextTime = CurTime() + 0.033
			
		end
	end
	
	__Z_FEEDITEM = TestPanel
end


concommand.Add("advancedkillfeed_test",function( ply, cmd, args )
	
	if SH_ADVANCEDFEED.HasAccess(ply) then 
		
		if __Z_FEEDITEM == nil then
			print("Enter command again to remove examples from screen")
			z_DrawExamples()
		else 
			__Z_FEEDITEM:Remove()
			__Z_FEEDITEM = nil			
		end
		
	end

end)
--addons/advancedkillfeed/lua/z_advancedkillfeed/client/cl_z_advancedkillfeed_effects.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER]]

local sin = math.sin
local rand = math.Rand
local abs = math.abs
local min = math.min
local max = math.max

local function ModColor(col1, col2, mod)
	local r,g,b
    r = col1.r + ((col2.r - col1.r) * (mod))
    g = col1.g + ((col2.g - col1.g) * (mod))
    b = col1.b + ((col2.b - col1.b) * (mod))

    return Color(r, g, b)
end

function CL_ADVANCEDFEED.EffectMovingColor(strLbl,color)
	
	local letterCount = #strLbl.letters
	if letterCount == 0 then return end
	
	for i=1,letterCount do
		local letter = strLbl.letters[i]
		
		if letter._col == nil then 
			letter._col = letter.col
		end
		
		local modCol = ModColor(color, letter._col, abs(sin((CurTime() - (i * 0.08)) * SH_ADVANCEDFEED.Settings.effectMovingColorSpeed)))
		letter.col = modCol
	end
	
end

function CL_ADVANCEDFEED.EffectWordFlash(strLbl)

	local letterCount = #strLbl.letters
	if letterCount == 0 then return end
	
	local firstLetter = strLbl.letters[1]
	
	-- skip if the random color didn't change yet
	if firstLetter.col == CL_ADVANCEDFEED.Think.randColorTbl[1] then 
		return
	end
	
	for i=1,letterCount do
		strLbl.letters[i].col = CL_ADVANCEDFEED.Think.randColorTbl[1]
	end

end

function CL_ADVANCEDFEED.EffectLetterFlash(strLbl)
	
	local letterCount = #strLbl.letters
	if letterCount == 0 then return end
	
	local firstLetter = strLbl.letters[1]
	
	-- skip if the random color didn't change yet
	if firstLetter.col == CL_ADVANCEDFEED.Think.randColorTbl[1] then 
		return
	end
	
	for i=1,letterCount do
		strLbl.letters[i].col = CL_ADVANCEDFEED.Think.randColorTbl[i%SH_ADVANCEDFEED.Settings.capNamesAt]
	end

end


local function GetNewRainbowNum(num)

	num = num % #SH_ADVANCEDFEED.Col.RAINBOW
	
	if num == 0 then
		num = #SH_ADVANCEDFEED.Col.RAINBOW
	end

	return num
	
end
	
function CL_ADVANCEDFEED.EffectMovingRainbow(strLbl) 

	local letterCount = #strLbl.letters
	if letterCount == 0 then return end

	local movingRainbowNum = GetNewRainbowNum(CL_ADVANCEDFEED.Think.rndNumber)
	local movingRainbowCol = SH_ADVANCEDFEED.Col.RAINBOW[movingRainbowNum]

	CL_ADVANCEDFEED.EffectMovingColor(strLbl,movingRainbowCol)
	
end

function CL_ADVANCEDFEED.EffectRainbow(strLbl)
	
	local letterCount = #strLbl.letters
	if letterCount == 0 then return end
	
	local firstLetter = strLbl.letters[1]
	local curTime = CurTime()
	
	local rndNum = CL_ADVANCEDFEED.Think.rndNumber
	
	for i=1,letterCount do
	
		strLbl.letters[i].rainbowNum = GetNewRainbowNum(rndNum-i)
		local rainbowCol = SH_ADVANCEDFEED.Col.RAINBOW[strLbl.letters[i].rainbowNum]
		strLbl.letters[i].col =rainbowCol
		
	end

end

function CL_ADVANCEDFEED.EffectPulseLine(color,strLbl,forceUnderText) 

	local letterCount = #strLbl.letters
	if letterCount == 0 then return end
	
	local parent = strLbl:GetParent()
	local pw,ph = parent:GetSize()
	
	local posX,posY = strLbl:GetPos()
	local tall = strLbl:GetTall()
	local wide = strLbl:GetWide()
	local lineP = vgui.Create("DPanel",parent)
	lineP:SetSize(wide,tall*0.1)
	if forceUnderText then
		lineP:SetPos(posX,posY+tall*1.2)
	else 
		lineP:SetPos(posX,min(tall*1.2,ph-lineP:GetTall()))
	end
	
	lineP.Paint = function(_,w,h)
		draw.RoundedBox( 0,0,0,w,h,Color(color.r,color.g,color.b,min(CL_ADVANCEDFEED.Think.fadeVal,parent:GetAlpha())))
	end
	
	lineP:Show()
	
end

local effectMove = {}
effectMove.randomMoveSide = 0
effectMove.randomMoveUp = 0
effectMove.lastCalculated = 0

function CL_ADVANCEDFEED.KillStreak.EffectMove(label,speed) 

	if label.nextMove == nil then 
		label.nextMove = 0
	end
	
	if label.nextMove < CurTime() then 
		local parent = label:GetParent()
		
		-- setup a sort of temporary cache for performance
		if effectMove.lastCalculated < label.nextMove then
			effectMove.randomMoveSide = rand( 0, ScrW()*0.005 )
			effectMove.randomMoveUp = rand( 0, parent:GetTall()-label:GetTall() )
			effectMove.lastCalculated = CurTime()+0.033
		end
		
		label:SetPos(effectMove.randomMoveSide,effectMove.randomMoveUp)
		
		if speed > 0 then 
			label.nextMove = CurTime() + speed
		end
		
	end
	
end

function CL_ADVANCEDFEED.KillStreak.EffectWordFlash(label)

	-- skip if the random color didn't change yet
	if label:GetTextColor() == CL_ADVANCEDFEED.Think.randColorTbl[1]  then 
		return
	end
	
	label:SetTextColor(CL_ADVANCEDFEED.Think.randColorTbl[1])
	
end

function CL_ADVANCEDFEED.KillStreak.EffectColorFade(label,labelCol)

	local parent = label:GetParent()
	local alpha = min(CL_ADVANCEDFEED.Think.fadeVal,parent:GetAlpha())
	
	label:SetTextColor(ColorAlpha(labelCol,alpha))
end

function CL_ADVANCEDFEED.KillStreak.EffectColorTransition(label,labelCol,bgLabel,bgLabelCol)

	local parent = label:GetParent()
	local bgAlpha = min(CL_ADVANCEDFEED.Think.fadeVal,parent:GetAlpha())
	local fgAlpha = max(SH_ADVANCEDFEED.Settings.maxFadingAlpha - bgAlpha,0)
	
	label:SetTextColor(ColorAlpha(labelCol,fgAlpha))
	bgLabel:SetTextColor(ColorAlpha(bgLabelCol,bgAlpha))
	
end
--addons/advancedkillfeed/lua/z_advancedkillfeed/client/cl_z_advancedkillfeed.lua:
local color = Color(0,0,0)
local killfeed = killfeed || {}
local centerGradient = surface.GetTextureID("gui/center_gradient")

local function CleanFeed()
	for k,v in pairs(killfeed) do
		v:Remove()
	end
	killfeed = {}
end

function CL_ADVANCEDFEED.ReloadFont()

	local fontSize = ScrW()*SH_ADVANCEDFEED.Settings.font[2]
	
	surface.CreateFont( "z_CODKillFeedFont", {
		font = SH_ADVANCEDFEED.Settings.font[1],
		size = fontSize,
		weight = 0,
		blursize = 0,
		scanlines = 0,
		antialias = true, 
		underline = false, 
		italic = false, 
		strikeout = false,
		extended = true,
		symbol = false, 
		rotary = false,
		shadow = false, 
		additive = false, 
		outline = false
	} )
	surface.CreateFont( "z_CODKillFeedFontAssist", {
		font = SH_ADVANCEDFEED.Settings.font[1],
		size = fontSize*0.7,
		weight = 0,
		blursize = 0,
		scanlines = 0,
		antialias = true, 
		underline = false, 
		extended = true,
		italic = false, 
		strikeout = false,
		symbol = false, 
		rotary = false,
		shadow = false, 
		additive = false, 
		outline = false
	} )
	surface.CreateFont( "z_CODKillFeedFontAssist_Default", {
		font = "TargetID",
		size = fontSize*0.7,
		weight = 0,
		blursize = 0,
		scanlines = 0,
		antialias = true, 
		underline = false, 
		italic = false, 
		strikeout = false,
		symbol = false, 
		rotary = false,
		shadow = false, 
		additive = false, 
		outline = false,
		extended = true
	} )
	-- for the font choosing combo box -> only font as a var, not size
	surface.CreateFont( "z_CODKillFeedFont_FontChooser", {
		font = SH_ADVANCEDFEED.Settings.font[1],
		size = ScrW()*0.012,
		weight = 0,
		blursize = 0,
		scanlines = 0,
		antialias = true, 
		extended = true,
		underline = false, 
		italic = false, 
		strikeout = false,
		symbol = false, 
		rotary = false,
		shadow = false, 
		additive = false, 
		outline = false
	} )
	-- font for menu items
	surface.CreateFont( "z_CODKillFeedFont_Static", {
		font = "TargetID",
		size = ScrW()*0.012,
		weight = 0,
		blursize = 0,
		scanlines = 0,
		antialias = true, 
		underline = false, 
		extended = true,
		italic = false, 
		strikeout = false,
		symbol = false, 
		rotary = false,
		shadow = false, 
		additive = false, 
		outline = false
	} )
	CleanFeed()
	
	-- calculation for the feed item height
	surface.SetFont( "z_CODKillFeedFont" )
	local _, fontHeight = surface.GetTextSize( "[MWG]" )
	feedItemHeight = fontHeight + ScrH()*0.014
	CL_ADVANCEDFEED.__feedItemHeight = feedItemHeight
	
end
CL_ADVANCEDFEED.ReloadFont()

surface.CreateFont( "z_CODKillFeedFont_Default", {
	font = "TargetID",
	size = ScrW()*SH_ADVANCEDFEED.Settings.fontSize,
	weight = 0,
	blursize = 0,
	scanlines = 0,
	antialias = true, 
	underline = false, 
	italic = false, 
	strikeout = false,
	symbol = false, 
	rotary = false, 
	shadow = false, 
	additive = false, 
	outline = false,  
} )


local function AddItemInFeed(item)
	
	if SH_ADVANCEDFEED.Settings.logModus == SH_ADVANCEDFEED.LogModus.BOTTOMTOTOP then
	
		-- add the logs from bottom to top
		for i = 2, #killfeed do
			
			local item = killfeed[i]
			
			item.moveFrom = (SH_ADVANCEDFEED.Settings.moveUp * (i-2))
			
		end
		
		-- insert item at position 1
		table.insert(killfeed,1,item)
		
		-- move up when there is more then 1 log
		for i = 2, #killfeed do
			
			local item = killfeed[i]
			
			item.moveFrom = (SH_ADVANCEDFEED.Settings.moveUp * (i-2))
			
			-- if the item is not going to be on screen anyway, then remove it
			local feedYTarget = (SH_ADVANCEDFEED.Settings.startPosY*ScrH())-item.moveFrom
			if feedYTarget < 0 or feedYTarget > ScrH() then
				item:Remove()
				table.remove(killfeed,i)
			end
		end
		
		-- if there are more logs then allowed then start fading out the last log
		local fadingFrom = SH_ADVANCEDFEED.Settings.maxNotes+1
		local feedItem = killfeed[fadingFrom]
		if feedItem != nil then
			feedItem.fadeIn = false
			feedItem.alpha = feedItem.alpha - 1
		end
		
	else 
	
		-- like in gmod add the logs from top to bottom
		local startPos = SH_ADVANCEDFEED.Settings.startPosY*ScrH()
		item:SetPos(item.xPos,startPos-(SH_ADVANCEDFEED.Settings.moveUp*(SH_ADVANCEDFEED.Settings.maxNotes-1)))
		item.xPos,item.yPos = item:GetPos()
		
		table.insert(killfeed,item)

		if #killfeed > SH_ADVANCEDFEED.Settings.maxNotes then

			for i = #killfeed-SH_ADVANCEDFEED.Settings.maxNotes, 1, -1 do 
				local feed = killfeed[i]
				feed.fadeIn = false
				feed.alpha = feed.alpha - 1
			end
		end
		
	end
	
	-- start the fading process after x amount of seconds
	timer.Simple(SH_ADVANCEDFEED.Settings.timeToFade, function()
		if IsValid(item) then
			item.fadeIn = false
			item.alpha = item.alpha - 1
		end
	end)
	
end

local function CreateFeedItem(item)

	local FeedItem = vgui.Create("DPanel")
	FeedItem:SetText("")
	FeedItem:SetAlpha(0)
	
	-- old height
	-- FeedItem:SetTall(ScrH()*0.035)
	
	-- change space between logs accordingly
	SH_ADVANCEDFEED.Settings.moveUp = CL_ADVANCEDFEED.__feedItemHeight + ScrH()*0.002
	
	FeedItem:SetTall(CL_ADVANCEDFEED.__feedItemHeight)
	
	FeedItem.borderStart = 0
	local borderSize = math.Round(FeedItem:GetTall()*0.1)
	
	local killerIsPly = false
	if LocalPlayer().SteamID ~= nil then
		local steamID = tostring(LocalPlayer():SteamID())
		killerIsPly = tostring(item.killerID) == steamID
	end
	
	-- borders and background
	FeedItem.Paint = function(self,w,h)
	
		local borderStart = math.Round(self.borderStart)
		local alpha = self:GetAlpha()
		local borderCol = ColorAlpha( SH_ADVANCEDFEED.Settings.borderColor, math.Min(SH_ADVANCEDFEED.Settings.borderColor.a,alpha) )
		local backgroundCol = ColorAlpha( SH_ADVANCEDFEED.Settings.backgroundColor, math.Min(SH_ADVANCEDFEED.Settings.backgroundColor.a,alpha) )
		
		if !SH_ADVANCEDFEED.Settings.borderOnSelfKill or (SH_ADVANCEDFEED.Settings.borderOnSelfKill and killerIsPly) then
			CL_ADVANCEDFEED.RoundedOutlinedRect(4, borderStart, 0, w-borderStart, h, borderCol)
		end
		
		if (SH_ADVANCEDFEED.Settings.useBackgroundGradient and !SH_ADVANCEDFEED.Settings.csgoSkinActive) or ( SH_ADVANCEDFEED.Settings.csgoSkinActive and !killerIsPly ) then
			surface.SetDrawColor( backgroundCol )
			surface.SetTexture(centerGradient)
			surface.DrawTexturedRect(0,  0, w, h)
		else
			surface.SetDrawColor( backgroundCol )
			surface.DrawRect( borderStart + borderSize, borderSize, w-borderStart-borderSize*2, h-borderSize*2 )
		end

	end
	
	// utils
	FeedItem.fadeIn = true
	FeedItem.alpha = 1
	FeedItem.moveFrom = 0
	FeedItem.item = item
	FeedItem.feedWidth = 0
	FeedItem.hasPulseLine = {}
	
	local function addFeedWidth(width)
		FeedItem.feedWidth = FeedItem.feedWidth + width
	end
	
	local function addSmallFeedWidth() 
		FeedItem.feedWidth = FeedItem.feedWidth + ScrW()*0.005
	end
	
	local function addItem(item,centerVerticalNum,extraSpace,extraX)
	
		centerVerticalNum = centerVerticalNum || 0.5
		extraSpace = extraSpace || 0
		extraSpace =  item:GetWide() > 0 && extraSpace || 0
		extraX =  extraX || 0
		extraX =  item:GetWide() > 0 && extraX || 0

		item:SetParent(FeedItem)
		item:SetPos(FeedItem.feedWidth+extraX,0)
		item:CenterVertical(centerVerticalNum)
		
		addFeedWidth(item:GetWide()+extraX+extraSpace)
		
		local __oldSetAlpha = FeedItem.SetAlpha
		FeedItem.SetAlpha = function(self,amount)
			__oldSetAlpha(self,amount)
			item:SetAlpha(amount)
		end
		
	end
	
	addSmallFeedWidth()
	
	// kill
	if item.id == 1 then
		
		-- kill streak
		addItem(item.killStreak,0.5,ScrW()*0.005)
		
		-- distance
		if SH_ADVANCEDFEED.Settings.showDistance then
			CL_ADVANCEDFEED.CreateString(FeedItem,"["..item.killDist.."] ", SH_ADVANCEDFEED.Settings.distanceColor)
		end
		
		-- killstreak & distance cannot be inside the border
		FeedItem.borderStart = FeedItem.feedWidth
		
		addSmallFeedWidth()
		
		-- killer avatar
		local avatarExtraSpace = ScrW()*0.001
		addItem(item.killerAvatar,0.5,avatarExtraSpace)
		
		-- killer tag
		if item.killerTag != nil then 
			CL_ADVANCEDFEED.CreateString(FeedItem,item.killerTag, item.killerColor )
		end
		
		-- killer name
		FeedItem.killerLbl = CL_ADVANCEDFEED.CreateString(FeedItem,item.killer,item.killerColor,item.killerID, item.killerTeam)
		
		-- assist string
		if item.assistor != nil then 
			-- sign
			CL_ADVANCEDFEED.CreateString(FeedItem," + ",item.assistorColor,item.assistorID, item.assistorTeam, "z_CODKillFeedFontAssist")
			-- name
			FeedItem.assistorLbl = CL_ADVANCEDFEED.CreateString(FeedItem,item.assistor,item.assistorColor,item.assistorID, item.assistorTeam,"z_CODKillFeedFontAssist")
		end
		
		-- weapon icon
		addItem(item.weaponIcon,0.35)
		
		-- hitgroup icon
		if !item.weaponIcon.showWeaponNameIconInvalid then
			addItem(item.hitgroupIcon)
		end
		
		-- weapon name
		if !SH_ADVANCEDFEED.Settings.showWeaponIcon or item.weaponIcon.showWeaponNameIconInvalid then 
			CL_ADVANCEDFEED.CreateString(FeedItem," ["..item.weapon.."] ",SH_ADVANCEDFEED.Settings.weaponColor)
		end
		
		-- victim avatar
		addItem(item.victimAvatar,0.5,avatarExtraSpace,ScrW()*0.005)

		-- victim tag
		if item.victimTag != nil then
			CL_ADVANCEDFEED.CreateString(FeedItem,item.victimTag, item.victimColor )
		end
		
		-- victim name
		FeedItem.victimLbl = CL_ADVANCEDFEED.CreateString(FeedItem,item.victim,item.victimColor,item.victimID,item.victimTeam)
		
	end

	// msg
	if item.id == 2 then 
		
		-- ply name
		FeedItem.plyLb = CL_ADVANCEDFEED.CreateString(FeedItem,item.ply,item.color,item.plyID,item.plyTeam)
		
		-- msg
		CL_ADVANCEDFEED.CreateString(FeedItem," "..item.msg,item.color)
		
	end
	
	addSmallFeedWidth()
	FeedItem:SetWide(FeedItem.feedWidth)
	
	local feedXPos 
	if SH_ADVANCEDFEED.Settings.align == SH_ADVANCEDFEED.Align.RIGHT then 
		feedXPos = SH_ADVANCEDFEED.Settings.startPosX*ScrW()-FeedItem:GetWide() -- right
	elseif SH_ADVANCEDFEED.Settings.align == SH_ADVANCEDFEED.Align.LEFT then 
		feedXPos = SH_ADVANCEDFEED.Settings.startPosX*ScrW() -- left 
	else
		feedXPos = SH_ADVANCEDFEED.Settings.startPosX*ScrW()-FeedItem:GetWide()/2 -- center 
	end
	
	FeedItem:SetPos(feedXPos,SH_ADVANCEDFEED.Settings.startPosY*ScrH())
	
	FeedItem.xPos,FeedItem.yPos = FeedItem:GetPos()
	
	AddItemInFeed(FeedItem)
	
end

local function SetTag(ent)
	if ent.team != -1 and SH_ADVANCEDFEED.Settings.useDarkRPJobTags and SH_ADVANCEDFEED.Gm.isDarkRP then
		ent.tag = team.GetName(ent.team).."| "
	end
end

local function SetColor(ent)
	if ent.team != -1 then 
		
		-- ulx & dark rp
		if SH_ADVANCEDFEED.Settings.useULXTeamColors or ( SH_ADVANCEDFEED.Settings.useDarkRPJobColors and SH_ADVANCEDFEED.Gm.isDarkRP )  then 
			ent.color = team.GetColor(ent.team)
		else
			-- sandbox
			if ent.nick == LocalPlayer():Nick() then 
				ent.color = SH_ADVANCEDFEED.Settings.ownTeamColor
			end
		end
		
	else 
		-- npc
		ent.color = SH_ADVANCEDFEED.Settings.npcTeamColor
	end
end

local function SetNick(ent)
	
	if ent.nick != nil then
	
		if SH_ADVANCEDFEED.Settings.hidePlayerName and ent.team != -1 and ent.nick != LocalPlayer():Nick() then 
			ent.nick = SH_ADVANCEDFEED.Settings.hidePlayerNameText
		else
			
			-- make sure string is utf8 valid
			ent.nick = SH_ADVANCEDFEED.ConvertInvalidUTFToValid(ent.nick)
			
			-- cut nick to fit the max allowed length
			ent.nick = string.sub( ent.nick, 1, SH_ADVANCEDFEED.GetMaxStringLength(ent.nick))
		end
		
	end
	
end

local function AddKillToFeed() 
	
	if !LocalPlayer():IsValid() or LocalPlayer():Team() == nil then return end
	
	local myTeam = LocalPlayer():Team()
	local Killer = {
		nick = net.ReadString(),
		team = net.ReadInt(32),
		steamID64 = net.ReadString(),
		steamID = net.ReadString(),
		color = SH_ADVANCEDFEED.Settings.otherTeamColor,
		killStreak = net.ReadInt(16),
		killCombo = net.ReadInt(16)
	}
	
	-- geting assist information on client because its not crucial information
	local assistPly = net.ReadPlayer()
	local Assistor = {}
	if IsValid(assistPly) then 
		Assistor = {
			nick = assistPly:Nick(),
			team = assistPly:Team(),
			steamID = assistPly:SteamID(),
			color = SH_ADVANCEDFEED.Settings.otherTeamColor
		}
	end

	local Victim = {
		nick = net.ReadString(),
		team = net.ReadInt(32),
		steamID64 = net.ReadString(),
		steamID = net.ReadString(),
		color = SH_ADVANCEDFEED.Settings.otherTeamColor
	}
	
	local attackerWeapon = net.ReadInt(16)
	local inflictorClass = net.ReadString()
	local hitGroup = net.ReadInt(16)
	local hitGroupName = nil
	local killDist = net.ReadInt(32)
	
	-- Zombie: non ascii string testing
	-- Killer.nick = "Zombie Extinguisher"
	-- Killer.nick = "я лучшая машина в мире, я серия я серия я серия"
	-- Killer.nick = "查找查找查找查找查找查找查找查找查找查找查找查找查找查找查找查找查找查找查找查找查找查找查找查找查找查找查找查找查找查找查找"
	-- Killer.nick = "ямире,яс  ерия"
	-- Killer.nick = "Валера ЧикиБой"
	-- Victim.nick = "查找 Ik ben kanker geil я лучшая машина в мире"
	-- Killer.nick = "Лис"
	-- Killer.nick = "dzadzadazdazdaazdpikachu_key-drop.pl"
	
	-- extra fucky ones
	-- Killer.nick = "𝕭𝖆𝖗𝖟𝖚𝖒𝖀𝕬"
	-- Killer.nick = "[𝕭]𝖆[𝖗𝖟𝖚]𝖒𝖀[𝕬]"
	-- Killer.nick = "[𝕭]𝖆[𝖗𝖟𝖚]𝖒𝖀[𝕬]"
	-- Killer.nick = "𝕭𝖆𝖗𝖟𝖚𝖒𝖀𝕬𝕭𝖆𝖗𝖟𝖚𝖒𝖀𝕬𝕭𝖆𝖗𝖟𝖚𝖒𝖀𝕬𝕭𝖆𝖗𝖟𝖚𝖒𝖀𝕬𝕭𝖆𝖗𝖟𝖚𝖒𝖀𝕬"
	-- Killer.nick = "₣₳₦₮ǾḾ ™"
	-- Killer.nick = "[Uranium]๖̶̶̶ۣۣۜۜ͜ζ"
	-- Killer.nick = "[Etherious]๖̶̶̶ۣۣۜۜ͜"
	-- Killer.nick = "Rodriguez Manouche (ηοηαme"

	-- kill distance
	if SH_ADVANCEDFEED.Settings.showDistance and killDist != -1 then
		killDist = SH_ADVANCEDFEED.DistToStr(killDist)
	end
	
	-- attacker weapon string creation
	if attackerWeapon != -1 then
		
		local attackerEnt = Entity(attackerWeapon)
		
		if IsValid(attackerEnt) and attackerEnt.GetPrintName ~= nil then
			attackerWeapon = attackerEnt:GetPrintName()
			if inflictorClass == "player" then 
				inflictorClass = attackerEnt:GetClass()
			end
			
			-- hl1 & 2 weapons
			if string.StartWith(attackerWeapon,"#") then
				attackerWeapon = language.GetPhrase(attackerWeapon)
			end
			
		else 
			attackerWeapon = SH_ADVANCEDFEED.Settings.npcKillsPlayerText
		end
		
	else 
		attackerWeapon = SH_ADVANCEDFEED.Settings.npcKillsPlayerText
	end
	
	-- add hit bone to weapon
	if SH_ADVANCEDFEED.Settings.showHitGroup != SH_ADVANCEDFEED.Hitgroup.NONE and attackerWeapon != -1 and hitGroup != -1 then 
		
		if (SH_ADVANCEDFEED.Settings.showHitGroup == SH_ADVANCEDFEED.Hitgroup.HEAD and hitGroup == HITGROUP_HEAD) or (SH_ADVANCEDFEED.Settings.showHitGroup == SH_ADVANCEDFEED.Hitgroup.ALL) then 
			
			hitGroupName = SH_ADVANCEDFEED.GetHitboneName(hitGroup)
			attackerWeapon = attackerWeapon.." - "..hitGroupName
			
		end
		
	end
	

	
	SetColor(Victim)
	SetColor(Killer)
	SetColor(Assistor)
	

	
	SetNick(Victim)
	SetNick(Killer)
	SetNick(Assistor)
	

	
	SetTag(Victim)
	SetTag(Killer)
		
	CL_ADVANCEDFEED.CreateAvatar(Victim)
	CL_ADVANCEDFEED.CreateAvatar(Killer)
	
	local kill = {
		id = 1,
		killer = Killer.nick,
		killerTag = Killer.tag,
		killerColor = Killer.color,
		killerAvatar = Killer.avatar,
		killerTeam = Killer.team,
		killerID = Killer.steamID,
		victim = Victim.nick,
		victimTag = Victim.tag,
		victimColor = Victim.color,
		victimAvatar = Victim.avatar,
		victimTeam = Victim.team,
		victimID = Victim.steamID,
		assistor = Assistor.nick,
		assistorTeam = Assistor.team,
		assistorID = Assistor.steamID,
		assistorColor = Assistor.color,
		weapon = attackerWeapon,
		weaponIcon = weaponIcon,
		killDist = killDist
	}
	
	CL_ADVANCEDFEED.CreateWeaponIcon(kill,inflictorClass)
	CL_ADVANCEDFEED.CreateHitgroupIcon(kill,hitGroupName)
	CL_ADVANCEDFEED.CreateKillStreak(kill,Killer.killStreak,Killer.killCombo)
	
	CreateFeedItem(kill)
	
end
net.Receive( "z_AdvancedFeedAddKill", AddKillToFeed )

local function AddMsgToFeed()
	
	local msg = {
		id = 2,
		msg = net.ReadString(),
		color = net.ReadColor(),
		ply = net.ReadString(),
		plyID = net.ReadString(),
		plyTeam = net.ReadInt(32)
	}
	
	-- make sure string is utf8 valid
	msg.ply = SH_ADVANCEDFEED.ConvertInvalidUTFToValid(msg.ply)
	
	-- cut nick to fit the max allowed length
	msg.ply = string.sub( msg.ply, 1, SH_ADVANCEDFEED.GetMaxStringLength(msg.ply) ),
	
	CreateFeedItem(msg)
	
end
net.Receive( "z_AdvancedFeedAddMsg", AddMsgToFeed )

-- hook the used effects to the lbl
function CL_ADVANCEDFEED.HookPermissions(strLbl,plyID,plyTeam) 

	strLbl.hasAnimTypeWriter = SH_ADVANCEDFEED.CheckPlayerPermission(SH_ADVANCEDFEED.Settings.animTypeWriterPlayers,plyID,plyTeam)
	strLbl.hasAnimSwitch = SH_ADVANCEDFEED.CheckPlayerPermission(SH_ADVANCEDFEED.Settings.animSwitchPlayers,plyID,plyTeam) 
	strLbl.hasAnimWave = SH_ADVANCEDFEED.CheckPlayerPermission(SH_ADVANCEDFEED.Settings.animWavePlayers,plyID,plyTeam) 
	strLbl.hasAnimWaveDouble = SH_ADVANCEDFEED.CheckPlayerPermission(SH_ADVANCEDFEED.Settings.animWaveDoublePlayers,plyID,plyTeam) 
	strLbl.hasAnimWaveDistortion= SH_ADVANCEDFEED.CheckPlayerPermission(SH_ADVANCEDFEED.Settings.animWaveDistortionPlayers,plyID,plyTeam)
	strLbl.hasEffectWordFlash = SH_ADVANCEDFEED.CheckPlayerPermission(SH_ADVANCEDFEED.Settings.effectWordFlashPlayers,plyID,plyTeam)
	strLbl.hasEffectLetterFlash = SH_ADVANCEDFEED.CheckPlayerPermission(SH_ADVANCEDFEED.Settings.effectLetterFlashPlayers,plyID,plyTeam)
	strLbl.hasEffectMovingRainbow = SH_ADVANCEDFEED.CheckPlayerPermission(SH_ADVANCEDFEED.Settings.effectMovingRainbowPlayers,plyID,plyTeam)
	strLbl.hasEffectRainbow = SH_ADVANCEDFEED.CheckPlayerPermission(SH_ADVANCEDFEED.Settings.effectRainbowPlayers,plyID,plyTeam)
	strLbl.effectPulseLineCol = SH_ADVANCEDFEED.GetColor(SH_ADVANCEDFEED.Settings.effectPulseLinePlayers,plyID,plyTeam)
	strLbl.effectMovingColorCol = SH_ADVANCEDFEED.GetColor(SH_ADVANCEDFEED.Settings.effectMovingColorPlayers,plyID,plyTeam)

end

local function MoveLetters(key,feedItem)

	local targets = {
		feedItem.killerLbl,
		feedItem.victimLbl,
		feedItem.plyLbl,
		feedItem.assistorLbl
	}
	
	// applying animations and effects
	for k=1,#targets do
	
		strLbl = targets[k]
		
		if strLbl == nil then continue end
		
		if strLbl.hasAnimTypeWriter then		
			CL_ADVANCEDFEED.AnimTypeWriter(strLbl,SH_ADVANCEDFEED.Settings.animTypeWriterRepeat)
		end
		
		if strLbl.hasAnimSwitch then 
			CL_ADVANCEDFEED.AnimSwitch(strLbl)
		end
		
		if strLbl.hasAnimWave then 
			CL_ADVANCEDFEED.AnimWave(strLbl)
		end
		
		if strLbl.hasAnimWaveDouble then 
			CL_ADVANCEDFEED.AnimWaveDouble(strLbl)
		end
		
		if strLbl.hasAnimWaveDistortion then 
			CL_ADVANCEDFEED.AnimWaveDistortion(strLbl)
		end

		if feedItem.hasPulseLine[k] == nil then
			if strLbl.effectPulseLineCol != nil then
				CL_ADVANCEDFEED.EffectPulseLine(strLbl.effectPulseLineCol,strLbl,false)
				feedItem.hasPulseLine[k] = true
			end
		end
		
		if strLbl.effectMovingColorCol != nil then
			CL_ADVANCEDFEED.EffectMovingColor(strLbl,strLbl.effectMovingColorCol)
			continue
		end
		
		if strLbl.hasEffectWordFlash then
			CL_ADVANCEDFEED.EffectWordFlash(strLbl)
			continue
		end
		
		if strLbl.hasEffectLetterFlash then 
			CL_ADVANCEDFEED.EffectLetterFlash(strLbl)
			continue
		end
		
		if strLbl.hasEffectMovingRainbow then
			CL_ADVANCEDFEED.EffectMovingRainbow(strLbl)
			continue
		end
		
		if strLbl.hasEffectRainbow then
			CL_ADVANCEDFEED.EffectRainbow(strLbl)
		end
	
	end
	
end

local nextTime = 0
local nextRandColor=0
local fadeValRise = true
CL_ADVANCEDFEED.Think = {}
CL_ADVANCEDFEED.Think.randColorTbl = {}
CL_ADVANCEDFEED.Think.fadeVal = 255
CL_ADVANCEDFEED.Think.rndNumber = 1 -- range 1-#rainbow table

local function ExtraThink() 

	// global random colors and random number
	if nextRandColor < CurTime() then
		for i=0,(SH_ADVANCEDFEED.Settings.capNamesAt) do
			CL_ADVANCEDFEED.Think.randColorTbl[i] = ColorRand(false)
		end
		
		if CL_ADVANCEDFEED.Think.rndNumber == (#SH_ADVANCEDFEED.Col.RAINBOW+1) then
			CL_ADVANCEDFEED.Think.rndNumber = 1
		else
			CL_ADVANCEDFEED.Think.rndNumber = CL_ADVANCEDFEED.Think.rndNumber+1
		end
		
		nextRandColor = CurTime() + 0.1
	end
	
	// global fading value
	if CL_ADVANCEDFEED.Think.fadeVal >= 255 and fadeValRise then 
		fadeValRise = false
	elseif CL_ADVANCEDFEED.Think.fadeVal <= 30 and !fadeValRise then 
		fadeValRise = true
	end
	
	if fadeValRise then
		CL_ADVANCEDFEED.Think.fadeVal=CL_ADVANCEDFEED.Think.fadeVal+SH_ADVANCEDFEED.Settings.effectPulseLineSpeed
	else
		CL_ADVANCEDFEED.Think.fadeVal=CL_ADVANCEDFEED.Think.fadeVal-SH_ADVANCEDFEED.Settings.effectPulseLineSpeed
	end
	
end

local function RemoveItemFromFeed(index,item)

	if item != nil then 
		item:Remove() 
	end
	
	table.remove(killfeed,index)
	
end

local function Think()
	
	if nextTime < CurTime() then
	
		local move =  0 

		for k=1,#killfeed do
		
			local item = killfeed[k]
			
			-- update transparancy
			if item.fadeIn and item.alpha < SH_ADVANCEDFEED.Settings.maxFadingAlpha then 
				item.alpha = item.alpha + (SH_ADVANCEDFEED.Settings.fadingSpeed*3)*k
			elseif !item.fadeIn then 
				item.alpha = item.alpha - SH_ADVANCEDFEED.Settings.fadingSpeed*2
			end
			
			if item.alpha <= 0 then
				RemoveItemFromFeed(k,item)
				break
			end
			
			item:SetAlpha(item.alpha)
			

			-- update position
			local _,currYpos = item:GetPos()
			local targetYPos = SH_ADVANCEDFEED.Settings.moveUp*move
			
			moveSpeed = 5
			if SH_ADVANCEDFEED.Settings.logModus == SH_ADVANCEDFEED.LogModus.TOPTOBOTTOM then
				moveSpeed = 100
				-- if item is going up
				if currYpos < targetYPos then 
					moveSpeed = 9999
				end
			end

			item.moveFrom = math.Approach(item.moveFrom,targetYPos,moveSpeed*k)
			local newYPos = 0
			
			if SH_ADVANCEDFEED.Settings.logModus == SH_ADVANCEDFEED.LogModus.BOTTOMTOTOP then
				newYPos = item.yPos-item.moveFrom
			else 
				newYPos = item.yPos+item.moveFrom
			end
			
			item:SetPos(item.xPos,newYPos)
			move = move + 1
			
			-- apply effects and animations
			MoveLetters(k,item)
			
		end
		
		-- extra functions
		ExtraThink() 
		
		-- limit everything to 30FPS
		nextTime = CurTime() + 0.055
	end
	
end
hook.Add("Think","z_AdvancedFeedThink",Think)

-- hide default death notice
hook.Add("DrawDeathNotice","z_AdvancedFeedDrawDeathNoticeOverride",function(x, y)
	return 0,0
end)
--addons/advancedkillfeed/lua/autorun/z_advancedkillfeed_version.lua:
return gluapack()()
--addons/zeros_methlab_1.6.4/lua/autorun/zmlab_load.lua:
zmlab = zmlab or {}
zmlab.f = zmlab.f or {}

local function NicePrint(txt)
	if SERVER then
		MsgC(Color(98, 149, 193), txt .. "\n")
	else
		MsgC(Color(193, 193, 98), txt .. "\n")
	end
end

local IgnoreFileTable = {}
function zmlab.f.PreLoadFile(fdir,afile,info)
	IgnoreFileTable[afile] = true
	zmlab.f.LoadFile(fdir,afile,info)
end

function zmlab.f.LoadFile(fdir,afile,info)

	if info then
		local nfo = "// [ Initialize ]: " .. afile .. string.rep( " ", 30 - afile:len() ) .. "//"
		NicePrint(nfo)
	end

	if SERVER then
		AddCSLuaFile(fdir .. afile)
	end

	include(fdir .. afile)
end

function zmlab.f.LoadAllFiles(fdir)
	local files, dirs = file.Find(fdir .. "*", "LUA")

	for _, afile in ipairs(files) do
		if string.match(afile, ".lua") and not IgnoreFileTable[afile] then
			zmlab.f.LoadFile(fdir,afile,true)
		end
	end

	for _, dir in ipairs(dirs) do
		zmlab.f.LoadAllFiles(fdir .. dir .. "/")
	end
end

// Initializes the Script
function zmlab.f.Initialize()
	NicePrint(" ")
	NicePrint("///////////////////////////////////////////////////")
	NicePrint("///////////////// Zeros MethLab ///////////////////")
	NicePrint("///////////////////////////////////////////////////")

	zmlab.f.PreLoadFile("zmlab/sh/","zmlab_config.lua",true)
	zmlab.f.LoadAllFiles("zmlab_languages/")

	zmlab.f.LoadAllFiles("zmlab/sh/")
	if SERVER then
		zmlab.f.LoadAllFiles("zmlab/sv/")
	end
	zmlab.f.LoadAllFiles("zmlab/cl/")

	NicePrint("///////////////////////////////////////////////////")
	NicePrint("///////////////////////////////////////////////////")
end

if SERVER then

	timer.Simple(0,function()
		zmlab.f.Initialize()
	end)
else


	// This needs to be called instantly on client since client settings wont work otherwhise
	zmlab.f.PreLoadFile("zmlab/sh/","zmlab_materials.lua",false)
	zmlab.f.PreLoadFile("zmlab/cl/","zmlab_fonts.lua",false)
	zmlab.f.PreLoadFile("zmlab/cl/","zmlab_settings_menu.lua",false)

	timer.Simple(0,function()
		zmlab.f.Initialize()
	end)
end

--addons/partysystem/lua/autorun/client/cl_partyhalo.lua:
return gluapack()()
--addons/executioner/lua/autorun/client/executioner_graphics.lua:
    --[[
        Script: Executioner
        Developer: ted.lua
        Profile: http://steamcommunity.com/id/tedlua/
    ]]

    if not Graphics then Graphics = {} end

    function Graphics.DrawRect( x, y, w, h, col )
        surface.SetDrawColor( col )
        surface.DrawRect( x, y, w, h )
    end

    function Graphics.DrawText( msg, fnt, x, y, c, align )
        draw.SimpleText( msg, fnt, x, y, c, align and align or TEXT_ALIGN_CENTER )
    end

    function Graphics.DrawOutline( x, y, w, h, t, c )
       surface.SetDrawColor( c )
       for i = 0, t - 1 do
           surface.DrawOutlinedRect( x + i, y + i, w - i * 2, h - i * 2 )
       end
    end

    function Graphics.PlaySequence( parent, id )
        local model_entity = parent:GetEntity()
        local sequence = model_entity:LookupSequence( id )
        model_entity:SetSequence( sequence )
    end

    function Graphics.DrawRoundedBox( rad, x, y, w, h, col )
        draw.RoundedBox( rad, x, y, w, h, col )
    end

    function Graphics.GenerateScreenBlur( parent, startTime ) Derma_DrawBackgroundBlur( parent, startTime ) end

    function Graphics.CreateIconObject( self, icon, x, y, w, h, button )
        local image = vgui.Create( button and 'DImageButton' or 'DImage', self )
        image:SetSize( w, h )
        image:SetPos( x, y )
        image:SetMaterial( icon )
        --image:SetKeepAspect( true )
        if not button then return image end
        image.Paint = function( me ) me:SetColor( me:IsHovered() and Color( 230, 32, 25 ) or Color( 255, 255, 255 ) ) end
        image.DoClick = function() self:SetVisible( false ) end
    end

    function Graphics.PaintBar( parent, base_color, switch_color, bar_color )
        if not parent.VBar then print( 'No VBar found.' ) return end
        parent.VBar.Paint = function( me, w, h ) Graphics.DrawRect( 0, 0, w, h, base_color ) end
        parent.VBar.btnUp.Paint = function( me, w, h ) Graphics.DrawRect( 0, 0, w, h, switch_color ) end
        parent.VBar.btnDown.Paint = function( me, w, h ) Graphics.DrawRect( 0, 0, w, h, switch_color ) end
        parent.VBar.btnGrip.Paint = function( me, w, h ) Graphics.DrawRect( 0, 0, w, h, bar_color ) end
    end

    local blur = Material( "pp/blurscreen" )
    function Graphics.BlurMenu( panel, layers, density, alpha )
        -- Its a scientifically proven fact that blur improves a script
        local x, y = panel:LocalToScreen( 0, 0 )

        surface.SetDrawColor( 255, 255, 255, alpha )
        surface.SetMaterial( blur )

        for i = 1, 3 do
            blur:SetFloat( "$blur", ( i / layers ) * density )
            blur:Recompute()

            render.UpdateScreenEffectTexture()
            surface.DrawTexturedRect( -x, -y, ScrW(), ScrH() )
        end
    end

--addons/executioner/lua/autorun/client/executioner_hitman_hud.lua:
    if not CLIENT then return end

    surface.CreateFont( "rHit.Font.HUD", { font = "BFHUD", size = 32, weight = 800, bold = true } )
    surface.CreateFont( "rHit.Font.Info", { font = "BFHUD", size = 48, weight = 800, bold = true } )
    surface.CreateFont( "rHit.Font.Walls", { font = "BFHUD", size = 32, weight = 800, bold = true } )

    local _a, _t = {}, nil

    net.Receive( 'rHit.Send.a', function() _a = net.ReadTable() end )
    net.Receive( 'rHit.Send.t', function() _t = net.ReadEntity() end )

    local function SecondsToClock( seconds )
        local seconds = tonumber( seconds )
        if seconds <= 0 then
            return "00:00"
        else
            mins = string.format( "%02.f", math.floor( seconds / 60 ) )
            secs = string.format( "%02.f", math.floor( seconds - mins * 60 ) )
            return mins.. ":" .. secs
        end
    end

    function Executioner.OnComplete()
        local price = net.ReadInt( 32 ) or -1
        local frame = vgui.Create( 'base_panel' )
        frame:SetSize( 425, 170 )
        frame:SetDraggable( false )
        frame:SetPos( ScrW() / 2 - frame:GetWide() / 2, ScrH() - frame:GetTall() )
        frame:MoveTo( ScrW() / 2 - frame:GetWide() / 2, ScrH() / 2 - frame:GetTall() / 2, 0.3, 0, 1 )
        timer.Simple( 3, function()
            if IsValid( frame ) then
                frame:MoveTo( ScrW() + frame:GetWide(), ScrH() / 2 - frame:GetTall() / 2, 0.3, 0, 1 )
                timer.Simple( 1, function() if IsValid( frame ) then frame:Remove() _t = nil end end )
            end
        end  )
        frame:Deploy( false, true )
        frame.Paint = function( me, w, h )
            Graphics.DrawText( Executioner.Config.Hit_Completed, 'rHit.Font.Large', w / 2, 10, Executioner.Config.Hit_Completed_Color )
            Graphics.DrawText( string.format( '%s%s', '+', DarkRP.formatMoney( price ) ), 'rHit.Font.Large', w / 2, 75, Executioner.Config.Confirmation.Money_Text_Color )
        end
    end
    net.Receive( 'rHit.Send.ScreenMessage', Executioner.OnComplete )

    function Executioner.PaintDisplay()
        if not _a[ LocalPlayer():SteamID() ] or not IsValid( _t ) then return end
        Graphics.DrawRect( ScrW() - 407, 93, 384, Executioner.Config.EnableDistance and 167 or 109, Executioner.Config.Background )
        Graphics.DrawRect( ScrW() - 405, 125, 380, 75, Executioner.Config.Foreground )
        Graphics.DrawOutline( ScrW() - 405, 125, 380, 75, 2, Executioner.Config.HUD_Outline )
        Graphics.DrawRect( ScrW() - 405, 94, 380, 30, Executioner.Config.Foreground )
        Graphics.DrawText( Executioner.Config.EnableHitTime and Executioner.Config.Time_Left .. SecondsToClock( LocalPlayer():GetNWInt( 'rHit_HitTime', 0 ) ) or Executioner.Config.Active_Hit, 'rHit.Font.HUD', ScrW() - 220, 90, Color( 200, 0, 0 ) )
        Graphics.DrawText( Executioner.Config.Phone.Target .. _t:Nick(), 'rHit.Font.HUD', ScrW() - 395, 128, Color( 255, 255, 255 ), TEXT_ALIGN_LEFT )
        Graphics.DrawText( Executioner.Config.Occupation .. team.GetName( _t:Team() ), 'rHit.Font.HUD', ScrW() - 395, 159, Color( 255, 255, 255 ), TEXT_ALIGN_LEFT )
        if Executioner.Config.EnableDistance then
            Graphics.DrawRect( ScrW() - 405, 201, 380, 57, Executioner.Config.Foreground )
            Graphics.DrawText( Executioner.Config.Distance_Text, 'rHit.Font.HUD', ScrW() - 347, 200, Color( 255, 255, 255 ) )
            Graphics.DrawText( LocalPlayer():GetPos():Distance( _t:GetPos() ) > Executioner.Config.RangeDistance and math.Round( LocalPlayer():GetPos():Distance( _t:GetPos() ), 0 ) .. 'm' or '?????', 'rHit.Font.HUD', ScrW() - 75, 220, Color( 255, 255, 255 ) )
        end
    end
    hook.Add( 'HUDPaint', 'rHit.Render.Display', Executioner.PaintDisplay )

    function Executioner.PaintInfo()
        if not Executioner.Config.Draw_Info then hook.Remove( 'HUDPaint', 'rHit.Render.Info' ) return end
        local trace = LocalPlayer():GetEyeTrace().Entity
        if not trace then return end
        if IsValid( trace ) and trace:IsPlayer() and Executioner.Config.Hitman_Teams[ team.GetName( trace:Team() ) ] then
            if LocalPlayer():GetPos():Distance( trace:GetPos() ) > 120 then return end
            local w, h = ScrW(), ScrH()
            Graphics.DrawText( Executioner.Config.Hitman_Text, 'rHit.Font.Info', w / 2 - 5, h / 2 + 15, Color( 255, 255, 255 ) )
            Graphics.DrawText( _a[ trace:SteamID() ] and Executioner.Config.Busy_Text or Executioner.Config.Enable_Face_To_Face and Executioner.Config.Request_Hit_Text or '', 'rHit.Font.Info', w / 2, h / 2 + 50, _a[ trace:SteamID() ] and Color( math.abs( math.sin( CurTime() * 2 ) * 255 ), 0, 0 ) or Color( 200, 0, 0 ) )
        end
    end
    hook.Add( 'HUDPaint', 'rHit.Render.Info', Executioner.PaintInfo )

--addons/executioner/lua/autorun/client/executioner_placement.lua:
    --[[
        Script: Executioner
        Developer: ted.lua
        Profile: http://steamcommunity.com/id/tedlua/
    ]]

    if not CLIENT then return end

    surface.CreateFont( "rHit.Font.Generic", { font = "BFHUD", size = 30, weight = 700 } )
    surface.CreateFont( "rHit.Font.Medium", { font = "Calibri", size = 27, weight = 700 } )
    surface.CreateFont( "rHit.Font.Small", { font = "Calibri", size = 21, weight = 700 } )
    surface.CreateFont( "rHit.Font.Inbetween", { font = "Calibri", size = 24, weight = 700 } )
    surface.CreateFont( "rHit.Font.Other", { font = "BFHUD", size = 23, weight = 700 } )

    Executioner.emoteTable = { 'pose_standing_01', 'pose_standing_02', 'pose_standing_03', 'pose_standing_04' }
    Executioner.materials = { ['heart'] = 'like.png', ['armor'] = 'rawr.png', [ 'oink' ] = 'oink.png' } -- :D

    local function CreateTextEntry( dock, x, y, w, h, txt, font, numeric )
        local object = vgui.Create( 'DTextEntry', dock )
        object:SetSize( w, h )
        object:SetPos( x, y )
        object:SetText( txt )
        object:SetFont( font )
        object:SetNumeric( numeric )
        object:SetVisible( false )
        local base = baseclass.Get( 'DTextEntry' )
        object.Paint = function( me, w, h )
            if me:IsHovered() then
                Graphics.DrawRoundedBox( 6, 0, 0, w, h, Executioner.Config.Component_Colors[ 'hit_price_entry' ].hover )
            else
                Graphics.DrawRoundedBox( 6, 0, 0, w, h, Executioner.Config.Component_Colors[ 'hit_price_entry' ].normal )
            end
            me:DrawTextEntryText( Executioner.Config.Component_Colors[ 'hit_price_entry' ].text, Color( 28, 28, 28 ), Color( 255, 255, 255 ) )
        end
        return object
    end

    local function ShowComponents( component_tree )
        for x = 1, #component_tree do
            if IsValid( component_tree[ x ] ) then component_tree[ x ]:SetVisible( true ) end
        end
    end

    function Executioner.RenderDisplay( parent, w, h, selection, y )
        local bar_width = w - 64
        if not y then y = 0 end
        local health, armor = IsValid( selection ) and selection:Health() or 100, IsValid( selection ) and selection:Armor() or 0
        local heatlhSize = ( bar_width / 100 ) * health > bar_width and bar_width or ( bar_width / 100 ) * health
        local armorSize = ( bar_width / 100 ) * armor > bar_width and bar_width or ( bar_width / 100 ) * armor
        Graphics.DrawRect( 32, h / 2 + 77 + y, bar_width, 25, Executioner.Config.Component_Colors[ 'health_armor_display' ].barBackground )
        Graphics.DrawRect( 32, h / 2 + 77 + y, heatlhSize, 25, Executioner.Config.Component_Colors[ 'health_armor_display' ].healthBar )
        Graphics.DrawText( string.format( '%i%s', health < 0 and 0 or health, '%' ), 'rHit.Font.Inbetween', w / 2 - 5, h / 2 + 75 + y, Executioner.Config.Component_Colors[ 'health_armor_display' ].healthColor )
        Graphics.DrawRect( 32, h / 2 + 103 + y, bar_width, 25, Executioner.Config.Component_Colors[ 'health_armor_display' ].barBackground )
        Graphics.DrawRect( 32, h / 2 + 103 + y, armorSize, 25, Executioner.Config.Component_Colors[ 'health_armor_display' ].armorBar )
        Graphics.DrawText( string.format( '%i%s', armor, '%' ), 'rHit.Font.Inbetween', w / 2 - 5, h / 2 + 102 + y, Executioner.Config.Component_Colors[ 'health_armor_display' ].armorColor )
        Graphics.DrawOutline( 30, h / 2 + 75 + y, w - 60, 55, 2, Executioner.Config.Component_Colors[ 'health_armor_display' ].outline )
    end

    local function CreatePanelReplica( parent, default_paint, side, scroll, func )
        local static_gap, player_pane = 10
        local base_canvis = vgui.Create( 'DPanel', parent )
        base_canvis:SetSize( 355, parent:GetTall() - 47 )
        base_canvis:SetPos( side == 1 and static_gap or parent:GetWide() - base_canvis:GetWide() - static_gap, 40 )
        if default_paint then
            base_canvis.Paint = function( me, w, h )
                Graphics.DrawRect( 0, 0, w, h, Executioner.Config.Placement.Data_Canvis_Color )
                Graphics.DrawOutline( 0, 0, w, h, 2, Executioner.Config.Outline_Colors ) -- 42, 42, 42, 200
            end
        else base_canvis.Paint = func end

        if scroll then
            player_pane = vgui.Create( 'DPanelList', base_canvis )
            player_pane:SetSize( base_canvis:GetWide() - 4, base_canvis:GetTall() )
            player_pane:SetPos( 2, 2 )
            player_pane:SetSpacing( 1 )
            player_pane:EnableVerticalScrollbar( scroll )
            Graphics.PaintBar( player_pane, Color( 30, 30, 30, 220 ), Color( 28, 28, 28 ), Color( 26, 26, 26 ) )
        end

        return base_canvis, player_pane
    end

    function Executioner.DeployPlacer()
        local self = LocalPlayer()
        local frame = vgui.Create( 'base_panel' )
        frame:SetSize( 750, 520 )
        frame:SetDraggable( false )
        frame:SetPos( ( ScrW() / 2 - frame:GetWide() / 2 ) + frame:GetWide(), ( ScrH() / 2 - frame:GetTall() / 2 ) )
        frame:MoveTo( ScrW() / 2 - frame:GetWide() / 2, ScrH() / 2 - frame:GetTall() / 2, 0.2, 0, 1 )
        frame:Deploy( true )

        frame.Paint = function( me, w, h )
            --Graphics.GenerateScreenBlur( self, self.Start )
            Graphics.DrawRect( 0, 0, me:GetWide(), me:GetTall(), Executioner.Config.Placement.Background )
            if Executioner.Config.EnableBlur then Graphics.BlurMenu( me, 10, 15, 245 ) end
            Graphics.DrawText( 'Executioner', 'rHit.Font.Generic', 75, 3, Color( 230, 32, 25 ) )
            Graphics.DrawText( Executioner.Config.Placement.Main_Title, 'rHit.Font.Generic', me:GetWide() / 2, 3, Executioner.Config.Placement.Main_Title_Color )
            Graphics.DrawRect( w / 2 - 3, 40, 5, h - 47, Executioner.Config.Placement.Split_Bar )
        end

        local player_canivs, player_pane = CreatePanelReplica( frame, true, 1, true )
        local data_canvis = CreatePanelReplica( frame, true, 2, false )
        player_canivs:SetDisabled( true )

        local hasSelection, current_selection, color_selection = false, nil, Executioner.Config.Placement.Row_Hovers.mainColor

        data_canvis.Paint = function( me, w, h )
            Graphics.DrawRect( 0, 0, w, h, Executioner.Config.Placement.Data_Canvis_Color )
            Graphics.DrawOutline( 0, 0, w, h, 2, Executioner.Config.Outline_Colors  ) -- 42, 42, 42, 200
            if hasSelection and IsValid( current_selection ) then
                Graphics.DrawText( current_selection:Nick(), 'rHit.Font.Generic', w / 2 - 5, 6, Executioner.Config.Name_Colors )
                Graphics.DrawText( team.GetName( current_selection:Team() ), 'rHit.Font.Generic', w / 2 - 5, 273, team.GetColor( current_selection:Team() ) )
                Executioner.RenderDisplay( frame, w, h, current_selection )
            else
                Graphics.DrawText( Executioner.Config.Placement.No_Preview, 'rHit.Font.Generic', w / 2, 210, Executioner.Config.Placement.No_Preview_Color )
            end
        end

        local model_panel = vgui.Create( 'DModelPanel', data_canvis )
        model_panel:SetSize( 210, 225 )
        model_panel:SetPos( 70, 45 )
        model_panel:SetModel( current_selection and current_selection:GetModel() or '' )
        model_panel:SetAnimated( true )
        model_panel:SetVisible( false )
        model_panel.LayoutEntity = function() return end
        model_panel:SetCamPos( Vector( 50, 0, 60 ) )

        model_panel.Paint = function( me, w, h )
            Graphics.DrawRect( 0, 0, w, h, color_selection )
            Graphics.DrawOutline( 0, 0, w, h, 2, Executioner.Config.Outline_Colors )
            baseclass.Get( 'DModelPanel' ).Paint( me, w, h )
        end

        local price_range = CreateTextEntry( data_canvis, 30, data_canvis:GetTall() - 80, 293, 25, 'Hit Price', 'rHit.Font.Inbetween', true )
        price_range.OnMousePressed = function( me, w, h ) me:SetValue( '' ) end

        local request_hit = vgui.Create( 'DButton', data_canvis )
        request_hit:SetSize( 120, 35 )
        request_hit:SetPos( data_canvis:GetWide() / 2 - 60, data_canvis:GetTall() - 50 )
        request_hit:SetText( Executioner.Config.Placement.Request_Hit )
        request_hit:SetFont( 'rHit.Font.Small' )
        request_hit:SetTextColor( Executioner.Config.Component_Colors[ 'button_request' ].text )
        request_hit:SetVisible( false )

        request_hit.Paint = function( me, w, h )
            if me:IsHovered() then
                Graphics.DrawRect( 0, 0, w, h, Executioner.Config.Component_Colors[ 'button_request' ].hover )
            else
                Graphics.DrawRect( 0, 0, w, h, Executioner.Config.Component_Colors[ 'button_request' ].normal )
            end
        end

        request_hit.DoClick = function( me )
            local conversion = tonumber( price_range:GetValue() )
            if not isnumber( conversion ) or conversion <= 0 or conversion > Executioner.Config.Max_Hit_Price or conversion < Executioner.Config.Min_Hit_Price then Executioner.UnPackMessage( string.format( Executioner.Language.HitPriceFormatError, DarkRP.formatMoney( Executioner.Config.Max_Hit_Price ), DarkRP.formatMoney( Executioner.Config.Min_Hit_Price ) ) ) frame:Close() return end
            if not self:canAfford( conversion ) then
                Executioner.UnPackMessage( string.format( Executioner.Language.HitPriceCantAfford, DarkRP.formatMoney( conversion ), DarkRP.formatMoney( self:getDarkRPVar( 'money' ) ) ) )
                frame:Close()
                return
            end
            net.Start( 'rHit.Confirm.Placement' )
                net.WriteInt( conversion, 32 )
                net.WriteEntity( current_selection )
            net.SendToServer()
            --if Executioner.Config.PlaySound then surface.PlaySound( 'buttons/button14.wav' ) end
            frame:Close()
        end

        local objects, locked, choice, emote = {}, false, nil, nil

        local targets = {}
        -- This stops the rows being fucked up colors. If someone is hidden and we continue, k's value remains the same even though we can't see specific rows.
        -- This way we don't need to continue in the player.GetAll() loop when creating the panels
        -- So the color will always retain the correct color as only those who are valid we be in the loop.
        for k, v in pairs( player.GetAll() ) do
            if v ~= self and v:Alive() and not v:isArrested() and not v:GetNWBool( 'rHit_ActiveHit' ) and not Executioner.Config.Hitman_Teams[ team.GetName( v:Team() ) ] then
                if not Executioner.Config.Banned_Groups[ v:GetUserGroup() ] and not Executioner.Config.BlackList_Teams[ team.GetName( v:Team() ) ] then
                    table.insert( targets, v )
                end
            end
        end

        for k, v in pairs( targets ) do
            local player_index = vgui.Create( 'DPanel', player_pane )
            player_index:SetSize( 0, 50 )
            player_index.Paint = function( me, w, h )
                local name, group = IsValid( v ) and v:Nick() or 'Disconnected', Executioner.Config.Clean_Ranks[ v:GetUserGroup() ] or 'User' -- CHANGE
                Graphics.DrawRect( 0, 0, w, h, k % 2 == 0 and Executioner.Config.Placement.Row_Hovers.onSecond or Executioner.Config.Placement.Row_Hovers.mainColor )
                Graphics.DrawText( name, 'rHit.Font.Medium', 5, -1, Executioner.Config.Name_Colors, TEXT_ALIGN_LEFT )
                Graphics.DrawText( group, 'rHit.Font.Medium', 5, 21, Executioner.Config.GroupConfiguration[ v:GetUserGroup() ] or Executioner.Config.Name_Colors, TEXT_ALIGN_LEFT )
                if me.Selected then Graphics.DrawOutline( 0, 0, w, h, 2, Executioner.Config.Outline_Colors ) end
            end
            player_index.OnCursorEntered = function( me, w, h )
                if locked then return end
                if not IsValid( model_panel ) then return end
                hasSelection, current_selection, emote = true, v, table.Random( Executioner.emoteTable )
                model_panel:SetModel( v:GetModel() or 'models/player/group01/male_01.mdl' )
                Graphics.PlaySequence( model_panel, emote )
                color_selection = k % 2 == 0 and Executioner.Config.Placement.Row_Hovers.onSecond or Executioner.Config.Placement.Row_Hovers.mainColor
                ShowComponents( { model_panel, price_range, request_hit } )
                Graphics.CreateIconObject( data_canvis, Executioner.materials[ 'heart' ], 30, 309, 32, 32, false )
                Graphics.CreateIconObject( data_canvis, Executioner.materials[ 'armor' ], 30, 337, 32, 32, false )
            end
            player_index.OnMousePressed = function( me, w, h )
                if not me.Selected and choice ~= k then
                    for k, v in pairs( objects ) do
                        if IsValid( v ) then v.Selected, locked, choice = false, false, nil end
                    end
                    me.Selected, locked, choice = true, true, k
                elseif me.Selected and choice == k then
                     me.Selected, locked, choice = false, false, k
                elseif not me.Selected and choice == k then
                    me.Selected, locked, choice = true, true, k
                end
                current_selection = v
                model_panel:SetModel( v:GetModel() )
                Graphics.PlaySequence( model_panel, emote )
            end
            player_pane:AddItem( player_index )
            table.insert( objects, player_index )
        end
        --> Issue with the panel being entered on start? No idea why, cursor doesn't even hit the panel. This is a small fix. <--
        timer.Simple( 0.3, function() if IsValid( player_canivs ) then player_canivs:SetDisabled( false ) end end )
    end
    net.Receive( 'rHit.Open.Placement', Executioner.DeployPlacer )

--addons/partysystem/lua/autorun/client/partymessage.lua:
--GUI base created by billy
--https://scriptfodder.com/users/view/76561198040894045/scripts

function Party_Message(strText,strTitle,strButtonText)

	local Window = vgui.Create("PartyFrame")
	Window:SetTitle(strTitle or "Message")
	Window:SetDraggable(false)
	Window:SetBackgroundBlur(true)
	Window:SetDrawOnTop(true)

	local InnerPanel = vgui.Create("Panel",Window)

	local Text = vgui.Create("DLabel",InnerPanel)
	Text:SetFont("roboto16")
	Text:SetText(strText or "Message Text")
	Text:SizeToContents()
	Text:SetContentAlignment(5)
	Text:SetTextColor(Color(0,0,0))

	local ButtonPanel = vgui.Create("DPanel",Window)
	ButtonPanel:SetTall(30)
	ButtonPanel:SetDrawBackground(false)

	local Button = vgui.Create("PartyButton",ButtonPanel)
	Button:SetText(strButtonText or "OK")
	Button:SizeToContents()
	Button:SetTall(20)
	Button:SetWide(Button:GetWide() + 20)
	Button:SetPos(5,5)
	Button.DoClick = function() Window:Close() end

	ButtonPanel:SetWide(Button:GetWide() + 10)

	local w,h = Text:GetSize()

	Window:SetSize(w + 50,h + 25 + 45 + 10)

	InnerPanel:StretchToParent(5,25,5,45)

	Text:StretchToParent(5,5,5,5)	

	ButtonPanel:CenterHorizontal()
	ButtonPanel:AlignBottom(8)

	Window:MakePopup()
	Window:DoModal()

	Window:Center()
	Window:Configured()
	Window:ShowCloseButton(false)

	return Window

end
--addons/partysystem/lua/autorun/client/partystringrequest.lua:
--GUI base created by billy
--https://scriptfodder.com/users/view/76561198040894045/scripts

function Billy_StringRequest( strTitle, strText, strDefaultText, fnEnter, fnCancel, strButtonText, strButtonCancelText )

	local Window = vgui.Create( "PartyFrame" )
		Window:SetTitle( strTitle or "Message Title (First Parameter)" )
		Window:SetDraggable( false )
		Window:SetBackgroundBlur( true )
		Window:SetDrawOnTop( true )
		
	local InnerPanel = vgui.Create( "DPanel", Window )
		InnerPanel:SetDrawBackground( false )
	
	local Text = vgui.Create( "PartyLabel", InnerPanel )
		Text:SetTextColor(Color(0,0,0))
		Text:SetText( strText or "Message Text (Second Parameter)" )
		Text:SizeToContents()
		Text:SetContentAlignment( 5 )
		
	local TextEntry = vgui.Create( "PartyTextBox", InnerPanel )
		if (strDefaultText) then
			TextEntry:SetPlaceHolder( strDefaultText )
		else
			TextEntry:SetText( "" )
		end
		TextEntry.OnEnter = function() Window:Close() fnEnter( TextEntry:GetValue() ) end
		
	local ButtonPanel = vgui.Create( "DPanel", Window )
		ButtonPanel:SetTall( 30 )
		ButtonPanel:SetDrawBackground( false )
		
	local Button = vgui.Create( "PartyButton", ButtonPanel )
		Button:SetText( strButtonText or "OK" )
		Button:SizeToContents()
		Button:SetTall( 20 )
		Button:SetWide( Button:GetWide() + 20 )
		Button:SetPos( 5, 5 )
		Button.DoClick = function() Window:Close() fnEnter( TextEntry:GetValue() ) end
		
	local ButtonCancel = vgui.Create( "PartyButton", ButtonPanel )
		ButtonCancel:SetText( strButtonCancelText or "Cancel" )
		ButtonCancel:SizeToContents()
		ButtonCancel:SetTall( 20 )
		ButtonCancel:SetWide( Button:GetWide() + 20 )
		ButtonCancel:SetPos( 5, 5 )
		ButtonCancel.DoClick = function() Window:Close() if ( fnCancel ) then fnCancel( TextEntry:GetValue() ) end end
		ButtonCancel:MoveRightOf( Button, 5 )
		
	ButtonPanel:SetWide( Button:GetWide() + 5 + ButtonCancel:GetWide() + 10 )
	
	local w, h = Text:GetSize()
	w = math.max( w, 400 ) 
	
	Window:SetSize( w + 50, h + 25 + 75 + 10 )
	
	InnerPanel:StretchToParent( 5, 25, 5, 45 )
	
	Text:StretchToParent( 5, 5, 5, 35 )	
	
	TextEntry:StretchToParent( 5, nil, 5, nil )
	TextEntry:AlignBottom( 5 )
	
	TextEntry:RequestFocus()
	TextEntry:SelectAllText( true )
	
	ButtonPanel:CenterHorizontal()
	ButtonPanel:AlignBottom( 8 )
	
	Window:MakePopup()
	Window:DoModal()

	Window:Center()
	Window:Configured()
	Window:ShowCloseButton( false )

	return Window

end
--lua/vgui/bvgui/checkbox.lua:
return gluapack()()
--lua/vgui/bvgui/checkbox_crossable.lua:
return gluapack()()
--lua/vgui/bvgui/colormixer.lua:
return gluapack()()
--lua/vgui/bvgui/columnlayout.lua:
return gluapack()()
--lua/vgui/bvgui/form.lua:
local PANEL = {}

function PANEL:Init()
	self:SetColumns(bVGUI.COLUMN_LAYOUT_COLUMN_SHRINK, bVGUI.COLUMN_LAYOUT_COLUMN_GROW_COLUMN, bVGUI.COLUMN_LAYOUT_COLUMN_GROW)
end

function PANEL:SetTextSize(textsize)
	self.TextSize = textsize
end

function PANEL:CreateLabel(text, icon)
	if (ispanel(text)) then return text end
	local icon_container
	if (icon) then
		icon_container = vgui.Create("bVGUI.BlankPanel", self)
		icon_container:SetTall(16)
		icon_container.icon = vgui.Create("DImage", icon_container)
		icon_container.icon:SetSize(16,16)
		icon_container.icon:SetImage(icon)
	end

	local label
	if (icon) then
		label = vgui.Create("DLabel", icon_container)
	else
		label = vgui.Create("DLabel", self)
	end
	label:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", self.TextSize or 16))
	label:SetTextColor(bVGUI.COLOR_WHITE)
	label:SetText(text)
	label:SizeToContents()
	label:SetContentAlignment(7)
	label:SetWrap(true)
	label:SetAutoStretchVertical(true)
	if (icon) then
		function label:PerformLayout()
			icon_container:SetSize(16 + 5 + self:GetWide(), self:GetTall())
			self:AlignLeft(16 + 5)
		end
		return icon_container
	else
		return label
	end
end

function PANEL:AddSpacing(h)
	local pnl1 = vgui.Create("bVGUI.BlankPanel", self)
	pnl1:SetSize(0,h)
	local pnl2 = vgui.Create("bVGUI.BlankPanel", self)
	pnl2:SetSize(0,h)
	local pnl3 = vgui.Create("bVGUI.BlankPanel", self)
	pnl3:SetSize(0,h)
	self:AddRow(pnl1,pnl2,pnl3)
end

function PANEL:AddButton(text, btncolor, help, func)
	local btn = vgui.Create("bVGUI.Button", self)
	btn:SetColor(btncolor)
	btn:SetText(text)
	btn:SetTall(25)
	if (func) then
		function btn:DoClick()
			func()
		end
	end

	local l1 = self:CreateLabel(text)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, btn, l2)

	return l1, btn, l2
end

function PANEL:AddSwitch(text, state, help, func)
	local switch = vgui.Create("bVGUI.Switch", self)
	switch:SetChecked(state)
	switch:SetText("")
	if (func) then
		function switch:OnChange()
			func(switch:GetChecked())
		end
	end

	local l1 = self:CreateLabel(text)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, switch, l2)

	return l1, switch, l2
end

function PANEL:AddCheckbox(text, state, help, func)
	local switch = vgui.Create("bVGUI.Checkbox_Crossable", self)
	switch:SetChecked(state)
	switch:SetText("")
	if (func) then
		function switch:OnChange()
			func(switch:GetChecked())
		end
	end

	local l1 = self:CreateLabel(text)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, switch, l2)

	return l1, switch, l2
end

function PANEL:AddComboBox(text, selected, help, func, icon)
	local combobox = vgui.Create("bVGUI.ComboBox", self)
	if (selected) then combobox:SetValue(selected) end
	if (func) then
		function combobox:OnSelect(index, value, data)
			func(index, value, data)
		end
	end

	local l1 = self:CreateLabel(text, icon)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, combobox, l2)

	return l1, combobox, l2
end

function PANEL:AddTextEntry(text, value, help, func, validation, placeholder, icon)
	local textentry = vgui.Create("bVGUI.TextEntry", self)
	textentry:SetValue(value)
	if (placeholder) then
		textentry:SetPlaceholderText(placeholder)
	end
	local prev_val = value
	function textentry:OnValueChange(val)
		if (validation == nil or validation(val) == true) then
			prev_val = val
			if (func) then func(val) end
		else
			self:SetValue(prev_val)
			self:SetText(prev_val)
			GAS:PlaySound("error")
		end
	end

	local l1 = self:CreateLabel(text, icon)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, textentry, l2)

	return l1, textentry, l2
end

function PANEL:AddLongTextEntry(...)
	local l1, textentry, l2 = self:AddTextEntry(...)

	textentry:SetMultiline(true)
	textentry:SetContentAlignment(7)
	textentry:SetTall(75)

	return l1, textentry, l2
end

function PANEL:AddNumberEntry(text, value, help, func, allow_negative)
	local textentry = vgui.Create("bVGUI.TextEntry", self)
	textentry:SetNumeric(true)
	textentry:SetValue(value)
	local prev_val = value
	function textentry:OnValueChange(val)
		if (not tonumber(self:GetValue()) or (allow_negative ~= true and tonumber(self:GetValue()) < 0)) then
			self:SetValue(prev_val)
			self:SetText(prev_val)
			GAS:PlaySound("error")
		else
			prev_val = self:GetValue()
			if (func) then func(tonumber(val)) end
		end
	end

	local l1 = self:CreateLabel(text)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, textentry, l2)

	return l1, textentry, l2
end

function PANEL:AddColorMixer(text, value, help, func, alpha)
	local colormixer = vgui.Create("DColorMixer", self)
	colormixer:SetAlphaBar(alpha == true)
	colormixer:SetPalette(false)
	colormixer:SetTall(120)
	if (value) then
		colormixer:SetColor(value)
	end
	if (func) then
		function colormixer:ValueChanged(col)
			func(col)
		end
	end

	local l1 = self:CreateLabel(text)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, colormixer, l2)

	return l1, colormixer, l2
end

derma.DefineControl("bVGUI.Form", nil, PANEL, "bVGUI.ColumnLayout")
--lua/vgui/bvgui/grid.lua:
return gluapack()()
--lua/vgui/bvgui/tabs.lua:
--/// bVGUI.Tabs ///--

local PANEL = {}

function PANEL:Init()
	self.Tabs = {}
	self.TabPages = {}

	self.EnabledTabs = {}
	self.EnabledTabPages = {}

	self.SelectedTab = 0

	self.BarX = bVGUI.Lerp(0,0,.5)
	self.BarColor = bVGUI.LerpColor(bVGUI.COLOR_BLACK,bVGUI.COLOR_BLACK,.5)
end

function PANEL:OnRemove()
	for _,v in pairs(self.TabPages) do
		v:Remove()
	end
end

function PANEL:CalculateEnabledTabs()
	self.EnabledTabs = {}
	self.EnabledTabPages = {}
	for i,v in pairs(self.Tabs) do
		if (v:GetEnabled()) then
			v.EnabledTabIndex = table.insert(self.EnabledTabs, v)
			self.TabPages[i].EnabledTabIndex = table.insert(self.EnabledTabPages, self.TabPages[i])
		end
	end
end

function PANEL:AddTab(tab_name, tab_color, enabled)
	local tab_index = #self.Tabs + 1
	local tab = vgui.Create("bVGUI.Tab", self)
	self.Tabs[tab_index] = tab
	tab.TabIndex = tab_index
	tab:SetColor(tab_color)
	tab:SetText(tab_name)

	local tab_page = vgui.Create("bVGUI.TabPage", self:GetParent())
	self.TabPages[tab_index] = tab_page
	tab_page:SetTab(tab)
	tab_page:SetTabs(self)

	tab:SetTabPage(tab_page)
	tab:SetEnabled(enabled ~= false)
	if (self.SelectedTab == 0 and enabled ~= false) then
		self.SelectedTab = tab_index
		self.BarColor:SetColor(tab:GetColor())
	end

	return tab_page, tab
end

function PANEL:Paint(w,h)
	surface.SetDrawColor(bVGUI.COLOR_SLATE)
	surface.DrawRect(0,0,w,h)
end

function PANEL:PaintOver(w,h)
	if (self.SelectedTab > 0) then
		self.BarX:DoLerp()
		self.BarColor:DoLerp()

		surface.SetDrawColor(bVGUI.COLOR_DARK_GREY)
		surface.DrawRect(0, h - 3, w, 3)

		surface.SetDrawColor(self.BarColor:GetColor())
		surface.DrawRect(self.BarX:GetValue(), h - 3, self:GetWide() / #self.EnabledTabs, 3)
	end
end

function PANEL:PerformLayout()
	self:CalculateEnabledTabs()

	local tab_width = self:GetWide() / #self.EnabledTabs
	for i,v in ipairs(self.EnabledTabs) do
		v:SetSize(tab_width, self:GetTall())
		local _,y = v:GetPos()
		v:SetPos((i - 1) * tab_width, y)
	end

	if (self.SelectedTab > 0) then
		for i,v in ipairs(self.EnabledTabPages) do
			local _,y = self:GetPos()
			v:SetSize(self:GetWide(), v:GetParent():GetTall() - self:GetTall() - y)
			if (not v.m_AnimList or #v.m_AnimList == 0) then
				v:SetPos((i - self.Tabs[self.SelectedTab].EnabledTabIndex) * self:GetWide() + (self:GetPos()), y + self:GetTall())
			end
		end

		local bar_x = (self.Tabs[self.SelectedTab]:GetPos())
		if (not self.EnabledTabs_Check or self.EnabledTabs_Check ~= #self.EnabledTabs) then
			self.EnabledTabs_Check = #self.EnabledTabs
			self.BarX:SetValue(bar_x)
		end
		if (self.BarX.to ~= bar_x) then
			self.BarX:SetValue(bar_x)
		end
	end
end

function PANEL:SelectTab(tab_index, suppress_click_func)
	if self.MovingTo == tab_index then return end
	self.MovingTo = tab_index
	local tab = self.Tabs[tab_index]

	local prev_tab = self.SelectedTab
	self.SelectedTab = tab.TabIndex

	self.BarX:SetTo((tab:GetPos()))
	self.BarColor:SetTo(tab:GetColor())

	for i,v in pairs(self.EnabledTabPages) do
		local _,y = v:GetPos()
		v:Stop()
		v:MoveTo((i - self.Tabs[self.SelectedTab].EnabledTabIndex) * v:GetWide() + (self:GetPos()), y, 0.5, 0, -1, function()
			self:InvalidateLayout(true)
			v:InvalidateChildren(true)
		end)
	end

	if (not suppress_click_func and tab.ClickFunction) then
		tab:GetTabPage().ExecClickFunction = tab.ClickFunction
		timer.Simple(0, function()
			if (self.OnTabSelected and prev_tab ~= nil) then
				self:OnTabSelected(self.Tabs[prev_tab], tab)
			end
		end)
	else
		if (self.OnTabSelected and prev_tab ~= nil) then
			self:OnTabSelected(self.Tabs[prev_tab], tab)
		end
	end
end

derma.DefineControl("bVGUI.Tabs", nil, PANEL, "DPanel")

--/// bVGUI.Tab ///--

local PANEL = {}

function PANEL:Init()
	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")

	self.Label = vgui.Create("DLabel", self)
	self.Label:Dock(FILL)
	self.Label:SetContentAlignment(5)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetText("Tab")
end

function PANEL:OnMouseReleased()
	self:GetParent():SelectTab(self.TabIndex)
end

function PANEL:SetEnabled(enabled)
	self:SetVisible(enabled)
	self:GetTabPage():SetVisible(enabled)
	if (enabled ~= self.Enabled) then
		self.Enabled = enabled
		self:GetParent():InvalidateLayout(true)
	else
		self.Enabled = enabled
	end
end
function PANEL:GetEnabled()
	return self.Enabled
end

function PANEL:SetColor(color)
	self.Color = color
end
function PANEL:GetColor()
	return self.Color
end

function PANEL:SetText(name)
	self.Name = name
	self.Label:SetText(self.Name)
end
function PANEL:GetText()
	return self.Name
end

function PANEL:SetTabPage(tabpage)
	self.TabPage = tabpage
end
function PANEL:GetTabPage()
	return self.TabPage
end

function PANEL:SetFunction(func)
	self.ClickFunction = func
end
function PANEL:GetFunction()
	return self.ClickFunction
end

function PANEL:Paint(w,h)
	if (self:GetParent().SelectedTab == self.TabIndex) then
		surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT)
		surface.DrawTexturedRect(0,0,w,h)
	end
end

derma.DefineControl("bVGUI.Tab", nil, PANEL, "DPanel")

--/// bVGUI.TabPage ///--

local PANEL = {}

function PANEL:SetTab(tab)
	self.MyTab = tab
end
function PANEL:GetTab()
	return self.MyTab
end

function PANEL:SetTabs(tabs)
	self.MyTabs = tabs
end
function PANEL:GetTabs()
	return self.MyTabs
end

function PANEL:Think()
	if (self.ExecClickFunction) then
		self.ExecClickFunction(self:GetTab())
		self.ExecClickFunction = nil
	end
end

derma.DefineControl("bVGUI.TabPage", nil, PANEL, "bVGUI.BlankPanel")
--lua/vgui/bvgui/toolbarbutton.lua:
--/// bVGUI.ToolbarButton_IMG ///--

local PANEL = {}

function PANEL:Init()
	self:SetCursor("hand")
	self.bVGUI_IMG = vgui.Create("DImage", self)
	self.bVGUI_IMG:SetSize(16,16)
end

function PANEL:Paint()
	if (self:IsHovered()) then
		if (not self._IsHovered) then
			self._IsHovered = true
			self.bVGUI_IMG:SetMaterial(self.HoverMaterial)
		end
	else
		if (self._IsHovered) then
			self._IsHovered = nil
			self.bVGUI_IMG:SetMaterial(self.DefaultMaterial)
		end
	end
end

function PANEL:SetMaterial(mat)
	self.bVGUI_IMG:SetMaterial(mat)
	self.DefaultMaterial = mat
end
function PANEL:SetHoverMaterial(mat)
	self.HoverMaterial = mat
end

function PANEL:OnMouseReleased()
	self:DoClick()
end

function PANEL:PerformLayout()
	self.bVGUI_IMG:Center()
end

derma.DefineControl("bVGUI.ToolbarButton_IMG", nil, PANEL, "DPanel")

--/// bVGUI.ToolbarButton_IMGText ///--

local PANEL = {}

function PANEL:Init()
	self:SetCursor("hand")

	self.bVGUI_IMG = vgui.Create("DImage", self)
	self.bVGUI_IMG:SetSize(16,16)

	self.bVGUI_Text = vgui.Create("DLabel", self)
	self.bVGUI_Text:SetText("Menu")
	self.bVGUI_Text:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
	self.bVGUI_Text:SetTextColor(bVGUI.COLOR_DARK_GREY)
end

function PANEL:Paint()
	if (self:IsHovered()) then
		if (not self._IsHovered) then
			self._IsHovered = true
			self.bVGUI_IMG:SetMaterial(self.HoverMaterial)
			self.bVGUI_Text:SetTextColor(bVGUI.COLOR_WHITE)
		end
	else
		if (self._IsHovered) then
			self._IsHovered = nil
			self.bVGUI_IMG:SetMaterial(self.DefaultMaterial)
			self.bVGUI_Text:SetTextColor(bVGUI.COLOR_DARK_GREY)
		end
	end
end

function PANEL:SetMaterial(mat)
	self.bVGUI_IMG:SetMaterial(mat)
	self.DefaultMaterial = mat
end
function PANEL:SetHoverMaterial(mat)
	self.HoverMaterial = mat
end

function PANEL:SetText(txt)
	self.bVGUI_Text:SetText(txt)
	self:PerformLayout()
end

function PANEL:PerformLayout()
	self.bVGUI_IMG:AlignLeft(5)
	self.bVGUI_IMG:CenterVertical()

	self.bVGUI_Text:SizeToContents()
	self.bVGUI_Text:AlignLeft(5 + 16 + 5)
	self.bVGUI_Text:CenterVertical()

	self:SetWide(5 + 16 + 5 + self.bVGUI_Text:GetWide() + 5 + 2)
end

function PANEL:OnMouseReleased()
	self:DoClick()
end

derma.DefineControl("bVGUI.ToolbarButton_IMGText", nil, PANEL, "DPanel")
--lua/vgui/bvgui/vertical_option_selector.lua:
return gluapack()()
--lua/vgui/gas_circles.lua:
return gluapack()()
--addons/gmodadminsuite-logging-2.4.8/lua/vgui/gas_logging_entity_display.lua:
return gluapack()()
--lua/vgui/openpermissions_addon.lua:
return gluapack()()
--lua/vgui/openpermissions_listview.lua:
return gluapack()()
--lua/vgui/openpermissions_listview.lua:
local PANEL = {}

function PANEL:Init()
	self.CurrentOffset = 0
	self.TargetOffset = 0
	self.StartTime = 0
	self.EndTime = 0

	self.VBar:SetHideButtons(true)
	self.VBar:SetWide(5)
	self.VBar:DockMargin(3,3,3,3)

	function self.VBar:Paint() end
	function self.VBar.btnGrip:Paint(w,h)
		surface.SetDrawColor(0,0,0,150)
		surface.DrawRect(0,0,w,h)
	end

	self.VBar.CurrentY = 0
	self.VBar.TargetY = 0
	function self.VBar:PerformLayout()

		local Wide = self:GetWide()
		local BtnHeight = Wide
		if ( self:GetHideButtons() ) then BtnHeight = 0 end
		local Scroll = self:GetScroll() / self.CanvasSize
		local BarSize = math.max( self:BarScale() * ( self:GetTall() - ( BtnHeight * 2 ) ), 10 )
		local Track = self:GetTall() - ( BtnHeight * 2 ) - BarSize
		Track = Track + 1

		Scroll = Scroll * Track

		self.TargetY = BtnHeight + Scroll
		self.btnGrip:SetSize( Wide, BarSize )

		if ( BtnHeight > 0 ) then
			self.btnUp:SetPos( 0, 0, Wide, Wide )
			self.btnUp:SetSize( Wide, BtnHeight )

			self.btnDown:SetPos( 0, self:GetTall() - BtnHeight )
			self.btnDown:SetSize( Wide, BtnHeight )
			
			self.btnUp:SetVisible( true )
			self.btnDown:SetVisible( true )
		else
			self.btnUp:SetVisible( false )
			self.btnDown:SetVisible( false )
			self.btnDown:SetSize( Wide, BtnHeight )
			self.btnUp:SetSize( Wide, BtnHeight )
		end

	end

	function self.VBar:Think()
		self.CurrentY = Lerp(FrameTime() * 10, self.CurrentY, self.TargetY)
		self.btnGrip:SetPos(0, math.Round(self.CurrentY))
	end

	self.pnlCanvas.CurrentOffset = 0
	self.pnlCanvas.TargetOffset = 0
	function self.pnlCanvas:Think()
		self.CurrentOffset = Lerp(FrameTime() * 10, self.CurrentOffset, self.TargetOffset)
		self:SetPos(0, math.Round(self.CurrentOffset + self:GetParent():GetHeaderHeight()))
	end
end

function PANEL:OnVScroll(offset)
	self.pnlCanvas.TargetOffset = offset
end

function PANEL:PerformLayout()

	-- Do Scrollbar
	local Wide = self:GetWide()
	local YPos = 0

	if ( IsValid( self.VBar ) ) then

		self.VBar:SetPos( self:GetWide() - 5 - 3, 3 )
		self.VBar:SetSize( 5, self:GetTall() - 6 )
		self.VBar:SetUp( self.VBar:GetTall() - self:GetHeaderHeight(), self.pnlCanvas:GetTall() )
		YPos = self.VBar:GetOffset()

		if ( self.VBar.Enabled ) then Wide = Wide - 5 end

	end

	if ( self.m_bHideHeaders ) then
		self.pnlCanvas:SetPos( 0, YPos )
	else
		self.pnlCanvas:SetPos( 0, YPos + self:GetHeaderHeight() )
	end

	self.pnlCanvas:SetSize( Wide + self.VBar:GetWide(), self.pnlCanvas:GetTall() )

	self:FixColumnsLayout()

	--
	-- If the data is dirty, re-layout
	--
	if ( self:GetDirty() ) then

		self:SetDirty( false )
		local y = self:DataLayout()
		self.pnlCanvas:SetTall( y )

		-- Layout again, since stuff has changed..
		self:InvalidateLayout( true )

	end

end

derma.DefineControl("OpenPermissions.ListView", nil, PANEL, "DListView")
--gamemodes/darkrp/gamemode/modules/hitmenu/sh_interface.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/doorsystem/cl_interface.lua:
DarkRP.readNetDoorVar = DarkRP.stub{
    name = "readNetDoorVar",
    description = "Internal function. You probably shouldn't need this. DarkRP calls this function when reading DoorVar net messages. This function reads the net data for a specific DoorVar.",
    parameters = {
    },
    returns = {
        {
            name = "name",
            description = "The name of the DoorVar.",
            type = "string"
        },
        {
            name = "value",
            description = "The value of the DoorVar.",
            type = "any"
        }
    },
    metatable = DarkRP
}

DarkRP.ENTITY.drawOwnableInfo = DarkRP.stub{
    name = "drawOwnableInfo",
    description = "Draw the ownability information on a door or vehicle.",
    parameters = {
    },
    returns = {
    },
    metatable = DarkRP.ENTITY
}

DarkRP.hookStub{
    name = "HUDDrawDoorData",
    description = "Called when DarkRP is about to draw the door ownability information of a door or vehicle. Override this hook to ",
    parameters = {
        {
            name = "ent",
            description = "The door or vehicle of which the ownability information is about to be drawn.",
            type = "Entity"
        }
    },
    returns = {
        {
            name = "override",
            description = "Return true in your hook to disable the default drawing and use your own.",
            type = "boolean"
        }
    }
}

--gamemodes/darkrp/gamemode/modules/language/sh_english.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/hitmenu/cl_init.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/base/sh_playerclass.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/base/sh_createitems.lua:
local plyMeta = FindMetaTable("Player")

-----------------------------------------------------------
-- Job commands --
-----------------------------------------------------------
local function declareTeamCommands(CTeam)
    local k = 0
    for num, v in pairs(RPExtraTeams) do
        if v.command == CTeam.command then
            k = num
        end
    end

    local chatcommandCondition = function(ply)
        local plyTeam = ply:Team()

        if plyTeam == k then return false end
        if CTeam.admin == 1 and not ply:IsAdmin() or CTeam.admin == 2 and not ply:IsSuperAdmin() then return false end
        if isnumber(CTeam.NeedToChangeFrom) and plyTeam ~= CTeam.NeedToChangeFrom then return false end
        if istable(CTeam.NeedToChangeFrom) and not table.HasValue(CTeam.NeedToChangeFrom, plyTeam) then return false end
        if CTeam.customCheck and CTeam.customCheck(ply) == false then return false end
        if ply:isArrested() then return false end
        local numPlayers = team.NumPlayers(k)
        if CTeam.max ~= 0 and ((CTeam.max % 1 == 0 and numPlayers >= CTeam.max) or (CTeam.max % 1 ~= 0 and (numPlayers + 1) / player.GetCount() > CTeam.max)) then return false end
        if ply.LastJob and 10 - (CurTime() - ply.LastJob) >= 0 then return false end
        if ply.LastVoteCop and CurTime() - ply.LastVoteCop < 80 then return false end

        return true
    end

    if CTeam.vote or CTeam.RequiresVote then
        DarkRP.declareChatCommand{
            command = "vote" .. CTeam.command,
            description = "Vote to become " .. CTeam.name .. ".",
            delay = 1.5,
            condition =
                function(ply)
                    if CTeam.RequiresVote and not CTeam.RequiresVote(ply, k) then return false end
                    if CTeam.canStartVote and not CTeam.canStartVote(ply) then return false end

                    return chatcommandCondition(ply)
                end
        }

        DarkRP.declareChatCommand{
            command = CTeam.command,
            description = "Become " .. CTeam.name .. " and skip the vote.",
            delay = 1.5,
            condition =
                function(ply)
                    local requiresVote = CTeam.RequiresVote and CTeam.RequiresVote(ply, k)

                    if requiresVote then return false end
                    if requiresVote ~= false and CTeam.admin == 0 and not ply:IsAdmin() or CTeam.admin == 1 and not ply:IsSuperAdmin() then return false end
                    if CTeam.canStartVote and not CTeam.canStartVote(ply) then return false end

                    return chatcommandCondition(ply)
                end
        }
    else
        DarkRP.declareChatCommand{
            command = CTeam.command,
            description = "Become " .. CTeam.name .. ".",
            delay = 1.5,
            condition = chatcommandCondition
        }
    end
end

local function addTeamCommands(CTeam, max)
    if CLIENT then return end

    local k = 0
    for num, v in pairs(RPExtraTeams) do
        if v.command == CTeam.command then
            k = num
        end
    end

    if CTeam.vote or CTeam.RequiresVote then
        DarkRP.defineChatCommand("vote" .. CTeam.command, function(ply)
            if CTeam.RequiresVote and not CTeam.RequiresVote(ply, k) then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("job_doesnt_require_vote_currently"))

                return ""
            end

            if CTeam.canStartVote and not CTeam.canStartVote(ply) then
                local reason = isfunction(CTeam.canStartVoteReason) and CTeam.canStartVoteReason(ply, CTeam) or CTeam.canStartVoteReason or ""
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("unable", "/vote" .. CTeam.command, reason))

                return ""
            end

            if CTeam.admin == 1 and not ply:IsAdmin() then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_admin", "/" .. "vote" .. CTeam.command))

                return ""
            elseif CTeam.admin > 1 and not ply:IsSuperAdmin() then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_sadmin", "/" .. "vote" .. CTeam.command))

                return ""
            end

            if isnumber(CTeam.NeedToChangeFrom) and ply:Team() ~= CTeam.NeedToChangeFrom then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_to_be_before", team.GetName(CTeam.NeedToChangeFrom), CTeam.name))

                return ""
            elseif istable(CTeam.NeedToChangeFrom) and not table.HasValue(CTeam.NeedToChangeFrom, ply:Team()) then
                local teamnames = ""

                for _, b in pairs(CTeam.NeedToChangeFrom) do
                    teamnames = teamnames .. " or " .. team.GetName(b)
                end

                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_to_be_before", string.sub(teamnames, 5), CTeam.name))

                return ""
            end

            if CTeam.customCheck and not CTeam.customCheck(ply) then
                local message = isfunction(CTeam.CustomCheckFailMsg) and CTeam.CustomCheckFailMsg(ply, CTeam) or CTeam.CustomCheckFailMsg or DarkRP.getPhrase("unable", team.GetName(t), "")
                DarkRP.notify(ply, 1, 4, message)

                return ""
            end

            local allowed, time = ply:changeAllowed(k)
            if not allowed then
                local notif = time and DarkRP.getPhrase("have_to_wait", math.ceil(time), "/job, " .. DarkRP.getPhrase("banned_or_demoted")) or DarkRP.getPhrase("unable", team.GetName(k), DarkRP.getPhrase("banned_or_demoted"))
                DarkRP.notify(ply, 1, 4, notif)

                return ""
            end

            if ply:Team() == k then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("unable", CTeam.command, ""))

                return ""
            end

            local numPlayers = team.NumPlayers(k)
            if max ~= 0 and ((max % 1 == 0 and numPlayers >= max) or (max % 1 ~= 0 and (tnumPlayers + 1) / player.GetCount() > max)) then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("team_limit_reached", CTeam.name))

                return ""
            end

            if ply.LastJob and 10 - (CurTime() - ply.LastJob) >= 0 then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("have_to_wait", math.ceil(10 - (CurTime() - ply.LastJob)), GAMEMODE.Config.chatCommandPrefix .. CTeam.command))

                return ""
            end

            ply.LastVoteCop = ply.LastVoteCop or -80

            if CurTime() - ply.LastVoteCop < 80 then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("have_to_wait", math.ceil(80 - (CurTime() - ply:GetTable().LastVoteCop)), GAMEMODE.Config.chatCommandPrefix .. CTeam.command))

                return ""
            end

            DarkRP.createVote(DarkRP.getPhrase("wants_to_be", ply:Nick(), CTeam.name), "job", ply, 20, function(vote, choice)
                local target = vote.target
                if not IsValid(target) then return end

                if choice >= 0 then
                    target:changeTeam(k)
                else
                    DarkRP.notifyAll(1, 4, DarkRP.getPhrase("has_not_been_made_team", target:Nick(), CTeam.name))
                end
            end, nil, nil, {
                targetTeam = k
            })

            ply.LastVoteCop = CurTime()

            return ""
        end)

        local function onJobCommand(ply, hasPriv)
            if hasPriv then
                ply:changeTeam(k)
                return
            end

            local a = CTeam.admin
            if a > 0 and not ply:IsAdmin()
            or a > 1 and not ply:IsSuperAdmin()
            then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_admin", CTeam.name))
                return
            end

            if not CTeam.RequiresVote and
                (a == 0 and not ply:IsAdmin()
                or a == 1 and not ply:IsSuperAdmin()
                or a == 2)
            or CTeam.RequiresVote and CTeam.RequiresVote(ply, k)
            then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_to_make_vote", CTeam.name))
                return
            end

            ply:changeTeam(k)
        end
        DarkRP.defineChatCommand(CTeam.command, function(ply)
            CAMI.PlayerHasAccess(ply, "DarkRP_GetJob_" .. CTeam.command, fp{onJobCommand, ply})

            return ""
        end)
    else
        DarkRP.defineChatCommand(CTeam.command, function(ply)
            if CTeam.admin == 1 and not ply:IsAdmin() then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_admin", "/" .. CTeam.command))

                return ""
            end

            if CTeam.admin > 1 and not ply:IsSuperAdmin() then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_sadmin", "/" .. CTeam.command))

                return ""
            end

            ply:changeTeam(k)

            return ""
        end)
    end

    concommand.Add("rp_" .. CTeam.command, function(ply, cmd, args)
        if ply:EntIndex() ~= 0 and not ply:IsAdmin() then
            ply:PrintMessage(HUD_PRINTCONSOLE, DarkRP.getPhrase("need_admin", cmd))
            return
        end

        if CTeam.admin > 1 and not ply:IsSuperAdmin() and ply:EntIndex() ~= 0 then
            ply:PrintMessage(HUD_PRINTCONSOLE, DarkRP.getPhrase("need_sadmin", cmd))
            return
        end

        if CTeam.vote then
            if CTeam.admin >= 1 and ply:EntIndex() ~= 0 and not ply:IsSuperAdmin() then
                ply:PrintMessage(HUD_PRINTCONSOLE, DarkRP.getPhrase("need_sadmin", cmd))
                return
            elseif CTeam.admin > 1 and ply:IsSuperAdmin() and ply:EntIndex() ~= 0 then
                ply:PrintMessage(HUD_PRINTCONSOLE, DarkRP.getPhrase("need_to_make_vote", CTeam.name))
                return
            end
        end

        if not args or not args[1] then
            DarkRP.printConsoleMessage(ply, DarkRP.getPhrase("invalid_x", DarkRP.getPhrase("arguments"), ""))
            return
        end

        local target = DarkRP.findPlayer(args[1])

        if not target then
            DarkRP.printConsoleMessage(ply, DarkRP.getPhrase("could_not_find", tostring(args[1])))
            return
        end

        target:changeTeam(k, true)
        local nick
        if (ply:EntIndex() ~= 0) then
            nick = ply:Nick()
        else
            nick = "Console"
        end
        DarkRP.notify(target, 0, 4, DarkRP.getPhrase("x_made_you_a_y", nick, CTeam.name))
    end)
end

local function addEntityCommands(tblEnt)
    DarkRP.declareChatCommand{
        command = tblEnt.cmd,
        description = "Purchase a " .. tblEnt.name,
        delay = tblEnt.delay or GAMEMODE.Config.EntitySpamTime,
        condition =
            function(ply)
                if not tblEnt.allowPurchaseWhileDead and not ply:Alive() then return false end
                if ply:isArrested() then return false end
                if istable(tblEnt.allowed) and not table.HasValue(tblEnt.allowed, ply:Team()) then return false end
                if not ply:canAfford(tblEnt.price) then return false end
                if tblEnt.customCheck and tblEnt.customCheck(ply) == false then return false end

                return true
            end
    }

    if CLIENT then return end

    -- Default spawning function of an entity
    -- used if tblEnt.spawn is not defined
    local function defaultSpawn(ply, tr, tblE)
        local ent = ents.Create(tblE.ent)

        if not ent:IsValid() then error("Entity '" .. tblE.ent .. "' does not exist or is not valid.") end
        if ent.Setowning_ent then ent:Setowning_ent(ply) end

        ent:SetPos(tr.HitPos)
        -- These must be set before :Spawn()
        ent.SID = ply.SID
        ent.allowed = tblE.allowed
        ent.DarkRPItem = tblE
        ent:Spawn()
        ent:Activate()

        DarkRP.placeEntity(ent, tr, ply)

        local phys = ent:GetPhysicsObject()
        if phys:IsValid() then phys:Wake() end

        return ent
    end

    local function buythis(ply, args)
        if ply:isArrested() then return "" end
        if not tblEnt.allowPurchaseWhileDead and not ply:Alive() then
            DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("must_be_alive_to_do_x", DarkRP.getPhrase("buy_x", tblEnt.name)))
            return ""
        end
        if istable(tblEnt.allowed) and not table.HasValue(tblEnt.allowed, ply:Team()) then
            DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("incorrect_job", tblEnt.name))
            return ""
        end

        if tblEnt.customCheck and not tblEnt.customCheck(ply) then
            local message = isfunction(tblEnt.CustomCheckFailMsg) and tblEnt.CustomCheckFailMsg(ply, tblEnt) or
                tblEnt.CustomCheckFailMsg or
                DarkRP.getPhrase("not_allowed_to_purchase")
            DarkRP.notify(ply, 1, 4, message)
            return ""
        end

        if ply:customEntityLimitReached(tblEnt) then
            DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("limit", tblEnt.name))
            return ""
        end

        local canbuy, suppress, message, price = hook.Call("canBuyCustomEntity", nil, ply, tblEnt)

        local cost = price or tblEnt.getPrice and tblEnt.getPrice(ply, tblEnt.price) or tblEnt.price

        if not ply:canAfford(cost) then
            DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("cant_afford", tblEnt.name))
            return ""
        end

        if canbuy == false then
            if not suppress and message then DarkRP.notify(ply, 1, 4, message) end
            return ""
        end

        ply:addMoney(-cost)

        local trace = {}
        trace.start = ply:EyePos()
        trace.endpos = trace.start + ply:GetAimVector() * 85
        trace.filter = ply

        local tr = util.TraceLine(trace)

        local ent = (tblEnt.spawn or defaultSpawn)(ply, tr, tblEnt)
        ent.onlyremover = not tblEnt.allowTools
        -- Repeat these properties to alleviate work in tblEnt.spawn:
        ent.SID = ply.SID
        ent.allowed = tblEnt.allowed
        ent.DarkRPItem = tblEnt

        hook.Call("playerBoughtCustomEntity", nil, ply, tblEnt, ent, cost)

        if cost == 0 then
            DarkRP.notify(ply, 0, 4, DarkRP.getPhrase("you_got_yourself", tblEnt.name))
        else
            DarkRP.notify(ply, 0, 4, DarkRP.getPhrase("you_bought", tblEnt.name, DarkRP.formatMoney(cost), ""))
        end

        ply:addCustomEntity(tblEnt)
        return ""
    end
    DarkRP.defineChatCommand(tblEnt.cmd, buythis)
end

RPExtraTeams = {}
local jobByCmd = {}
DarkRP.getJobByCommand = function(cmd)
    if not jobByCmd[cmd] then return nil, nil end
    return RPExtraTeams[jobByCmd[cmd]], jobByCmd[cmd]
end
plyMeta.getJobTable = function(ply)
    local tbl = RPExtraTeams[ply:Team()]
    -- don't error when the player has not fully joined yet
    if not tbl and (ply.DarkRPInitialised or ply.DarkRPDataRetrievalFailed) then
        DarkRP.error(
            string.format("There is a player with an invalid team!\n\nThe player's name is %s, their team number is \"%s\", which has the name \"%s\"",
                ply:EntIndex() == 0 and "Console" or IsValid(ply) and ply:Nick() or "unknown",
                ply:Team(),
                team.GetName(ply:Team())),
            1,
            {
                "It is the server owner's responsibility to figure out why that player has no valid team.",
                "This error is very likely to be caused by an earlier error. If you don't see any errors in your own console, look at the server console."
            }
        )
    end
    return tbl
end

function DarkRP.createJob(Name, colorOrTable, model, Description, Weapons, command, maximum_amount_of_this_class, Salary, admin, Vote, Haslicense, NeedToChangeFrom, CustomCheck)
    local tableSyntaxUsed = not IsColor(colorOrTable)

    local CustomTeam = tableSyntaxUsed and colorOrTable or
        {color = colorOrTable, model = model, description = Description, weapons = Weapons, command = command,
            max = maximum_amount_of_this_class, salary = Salary, admin = admin or 0, vote = tobool(Vote), hasLicense = Haslicense,
            NeedToChangeFrom = NeedToChangeFrom, customCheck = CustomCheck
        }
    CustomTeam.name = Name
    CustomTeam.default = DarkRP.DARKRP_LOADING

    -- Disabled job
    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["jobs"][CustomTeam.command] then return end

    local valid, err, hints = DarkRP.validateJob(CustomTeam)
    if not valid then DarkRP.error(string.format("Corrupt team: %s!\n%s", CustomTeam.name or "", err), 2, hints) end

    if not (GM or GAMEMODE):CustomObjFitsMap(CustomTeam) then return end

    local jobCount = #RPExtraTeams + 1

    CustomTeam.team = jobCount

    CustomTeam.salary = math.floor(CustomTeam.salary)

    CustomTeam.customCheck           = CustomTeam.customCheck           and fp{DarkRP.simplerrRun, CustomTeam.customCheck}
    CustomTeam.CustomCheckFailMsg = isfunction(CustomTeam.CustomCheckFailMsg) and fp{DarkRP.simplerrRun, CustomTeam.CustomCheckFailMsg} or CustomTeam.CustomCheckFailMsg
    CustomTeam.CanPlayerSuicide      = CustomTeam.CanPlayerSuicide      and fp{DarkRP.simplerrRun, CustomTeam.CanPlayerSuicide}
    CustomTeam.PlayerCanPickupWeapon = CustomTeam.PlayerCanPickupWeapon and fp{DarkRP.simplerrRun, CustomTeam.PlayerCanPickupWeapon}
    CustomTeam.PlayerDeath           = CustomTeam.PlayerDeath           and fp{DarkRP.simplerrRun, CustomTeam.PlayerDeath}
    CustomTeam.PlayerLoadout         = CustomTeam.PlayerLoadout         and fp{DarkRP.simplerrRun, CustomTeam.PlayerLoadout}
    CustomTeam.PlayerSelectSpawn     = CustomTeam.PlayerSelectSpawn     and fp{DarkRP.simplerrRun, CustomTeam.PlayerSelectSpawn}
    CustomTeam.PlayerSetModel        = CustomTeam.PlayerSetModel        and fp{DarkRP.simplerrRun, CustomTeam.PlayerSetModel}
    CustomTeam.PlayerSpawn           = CustomTeam.PlayerSpawn           and fp{DarkRP.simplerrRun, CustomTeam.PlayerSpawn}
    CustomTeam.PlayerSpawnProp       = CustomTeam.PlayerSpawnProp       and fp{DarkRP.simplerrRun, CustomTeam.PlayerSpawnProp}
    CustomTeam.RequiresVote          = CustomTeam.RequiresVote          and fp{DarkRP.simplerrRun, CustomTeam.RequiresVote}
    CustomTeam.ShowSpare1            = CustomTeam.ShowSpare1            and fp{DarkRP.simplerrRun, CustomTeam.ShowSpare1}
    CustomTeam.ShowSpare2            = CustomTeam.ShowSpare2            and fp{DarkRP.simplerrRun, CustomTeam.ShowSpare2}
    CustomTeam.canStartVote          = CustomTeam.canStartVote          and fp{DarkRP.simplerrRun, CustomTeam.canStartVote}

    jobByCmd[CustomTeam.command] = table.insert(RPExtraTeams, CustomTeam)
    DarkRP.addToCategory(CustomTeam, "jobs", CustomTeam.category)

    team.SetUp(jobCount, Name, CustomTeam.color)

    timer.Simple(0, function()
        declareTeamCommands(CustomTeam)
        addTeamCommands(CustomTeam, CustomTeam.max)
    end)

    -- Precache model here. Not right before the job change is done
    if istable(CustomTeam.model) then
        for _, v in pairs(CustomTeam.model) do util.PrecacheModel(v) end
    else
        util.PrecacheModel(CustomTeam.model)
    end
    return jobCount
end
AddExtraTeam = DarkRP.createJob

local function removeCustomItem(tbl, category, hookName, reloadF4, i)
    local item = tbl[i]
    tbl[i] = nil
    if category then DarkRP.removeFromCategory(item, category) end
    if istable(item) and (item.command or item.cmd) then DarkRP.removeChatCommand(item.command or item.cmd) end
    hook.Run(hookName, i, item)
    if CLIENT and reloadF4 and IsValid(DarkRP.getF4MenuPanel()) then DarkRP.getF4MenuPanel():Remove() end -- Rebuild entire F4 menu frame
end

function DarkRP.removeJob(i)
    local job = RPExtraTeams[i]
    jobByCmd[job.command] = nil

    DarkRP.removeChatCommand("vote" .. job.command)
    removeCustomItem(RPExtraTeams, "jobs", "onJobRemoved", true, i)
end

RPExtraTeamDoors = {}
RPExtraTeamDoorIDs = {}
local maxTeamDoorID = 0
function DarkRP.createEntityGroup(name, ...)
    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["doorgroups"][name] then return end
    RPExtraTeamDoors[name] = {...}
    RPExtraTeamDoors[name].name = name

    maxTeamDoorID = maxTeamDoorID + 1
    RPExtraTeamDoorIDs[name] = maxTeamDoorID
end
AddDoorGroup = DarkRP.createEntityGroup

DarkRP.removeEntityGroup = fp{removeCustomItem, RPExtraTeamDoors, nil, "onEntityGroupRemoved", false}

CustomVehicles = {}
CustomShipments = {}
local shipByName = {}
DarkRP.getShipmentByName = function(name)
    name = string.lower(name or "")

    if not shipByName[name] then return nil, nil end
    return CustomShipments[shipByName[name]], shipByName[name]
end

function DarkRP.createShipment(name, model, entity, price, Amount_of_guns_in_one_shipment, Sold_separately, price_separately, noshipment, classes, shipmodel, CustomCheck)
    local tableSyntaxUsed = istable(model)

    price = tonumber(price)
    local shipmentmodel = shipmodel or "models/Items/item_item_crate.mdl"

    local customShipment = tableSyntaxUsed and model or
        {model = model, entity = entity, price = price, amount = Amount_of_guns_in_one_shipment,
        seperate = Sold_separately, pricesep = price_separately, noship = noshipment, allowed = classes,
        shipmodel = shipmentmodel, customCheck = CustomCheck, weight = 5}

    -- The pains of backwards compatibility when dealing with ancient spelling errors...
    if customShipment.separate ~= nil then
        customShipment.seperate = customShipment.separate
    end
    customShipment.separate = customShipment.seperate

    if customShipment.allowed == nil then
        customShipment.allowed = {}
        for k in pairs(team.GetAllTeams()) do
            table.insert(customShipment.allowed, k)
        end
    end

    customShipment.name = name
    customShipment.default = DarkRP.DARKRP_LOADING
    customShipment.shipmodel = customShipment.shipmodel or shipmentmodel

    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["shipments"][customShipment.name] then return end

    local valid, err, hints = DarkRP.validateShipment(customShipment)
    if not valid then DarkRP.error(string.format("Corrupt shipment: %s!\n%s", name or "", err), 2, hints) end

    customShipment.spawn = customShipment.spawn and fp{DarkRP.simplerrRun, customShipment.spawn}
    customShipment.allowed = isnumber(customShipment.allowed) and {customShipment.allowed} or customShipment.allowed
    customShipment.customCheck = customShipment.customCheck   and fp{DarkRP.simplerrRun, customShipment.customCheck}
    customShipment.CustomCheckFailMsg = isfunction(customShipment.CustomCheckFailMsg) and fp{DarkRP.simplerrRun, customShipment.CustomCheckFailMsg} or customShipment.CustomCheckFailMsg

    if not customShipment.noship then DarkRP.addToCategory(customShipment, "shipments", customShipment.category) end
    if customShipment.separate then DarkRP.addToCategory(customShipment, "weapons", customShipment.category) end

    shipByName[string.lower(name or "")] = table.insert(CustomShipments, customShipment)
    util.PrecacheModel(customShipment.model)
end
AddCustomShipment = DarkRP.createShipment

function DarkRP.removeShipment(i)
    local ship = CustomShipments[i]
    shipByName[ship.name] = nil
    removeCustomItem(CustomShipments, "shipments", "onShipmentRemoved", true, i)
end

function DarkRP.createVehicle(Name_of_vehicle, model, price, Jobs_that_can_buy_it, customcheck)
    local vehicle = istable(Name_of_vehicle) and Name_of_vehicle or
        {name = Name_of_vehicle, model = model, price = price, allowed = Jobs_that_can_buy_it, customCheck = customcheck}

    vehicle.default = DarkRP.DARKRP_LOADING

    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["vehicles"][vehicle.name] then return end

    local found = false
    for k in pairs(DarkRP.getAvailableVehicles()) do
        if string.lower(k) == string.lower(vehicle.name) then found = true break end
    end

    local valid, err, hints = DarkRP.validateVehicle(vehicle)
    if not valid then DarkRP.error(string.format("Corrupt vehicle: %s!\n%s", vehicle.name or "", err), 2, hints) end

    if not found then DarkRP.error("Vehicle invalid: " .. vehicle.name .. ". Unknown vehicle name.", 2) end

    vehicle.customCheck = vehicle.customCheck and fp{DarkRP.simplerrRun, vehicle.customCheck}
    vehicle.CustomCheckFailMsg = isfunction(vehicle.CustomCheckFailMsg) and fp{DarkRP.simplerrRun, vehicle.CustomCheckFailMsg} or vehicle.CustomCheckFailMsg

    table.insert(CustomVehicles, vehicle)
    DarkRP.addToCategory(vehicle, "vehicles", vehicle.category)
end
AddCustomVehicle = DarkRP.createVehicle

DarkRP.removeVehicle = fp{removeCustomItem, CustomVehicles, "vehicles", "onVehicleRemoved", true}

--[[---------------------------------------------------------------------------
Decides whether a custom job or shipmet or whatever can be used in a certain map
---------------------------------------------------------------------------]]
function GM:CustomObjFitsMap(obj)
    if not obj or not obj.maps then return true end

    local map = string.lower(game.GetMap())
    for _, v in pairs(obj.maps) do
        if string.lower(v) == map then return true end
    end
    return false
end

DarkRPEntities = {}
function DarkRP.createEntity(name, entity, model, price, max, command, classes, CustomCheck)
    local tableSyntaxUsed = istable(entity)

    local tblEnt = tableSyntaxUsed and entity or
        {ent = entity, model = model, price = price, max = max,
        cmd = command, allowed = classes, customCheck = CustomCheck}
    tblEnt.name = name
    tblEnt.default = DarkRP.DARKRP_LOADING

    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["entities"][tblEnt.name] then return end

    if isnumber(tblEnt.allowed) then
        tblEnt.allowed = {tblEnt.allowed}
    end

    local valid, err, hints = DarkRP.validateEntity(tblEnt)
    if not valid then DarkRP.error(string.format("Corrupt entity: %s!\n%s", name or "", err), 2, hints) end

    tblEnt.customCheck = tblEnt.customCheck and fp{DarkRP.simplerrRun, tblEnt.customCheck}
    tblEnt.CustomCheckFailMsg = isfunction(tblEnt.CustomCheckFailMsg) and fp{DarkRP.simplerrRun, tblEnt.CustomCheckFailMsg} or tblEnt.CustomCheckFailMsg
    tblEnt.getPrice    = tblEnt.getPrice    and fp{DarkRP.simplerrRun, tblEnt.getPrice}
    tblEnt.getMax      = tblEnt.getMax      and fp{DarkRP.simplerrRun, tblEnt.getMax}
    tblEnt.spawn       = tblEnt.spawn       and fp{DarkRP.simplerrRun, tblEnt.spawn}

    -- if SERVER and FPP then
    --  FPP.AddDefaultBlocked(blockTypes, tblEnt.ent)
    -- end

    table.insert(DarkRPEntities, tblEnt)
    DarkRP.addToCategory(tblEnt, "entities", tblEnt.category)
    timer.Simple(0, function() addEntityCommands(tblEnt) end)
end
AddEntity = DarkRP.createEntity

DarkRP.removeEntity = fp{removeCustomItem, DarkRPEntities, "entities", "onEntityRemoved", true}

-- here for backwards compatibility
DarkRPAgendas = {}

local agendas = {}
-- Returns the agenda managed by the player
plyMeta.getAgenda = fn.Compose{fn.Curry(fn.Flip(fn.GetValue), 2)(DarkRPAgendas), plyMeta.Team}

-- Returns the agenda this player is member of
function plyMeta:getAgendaTable()
    return agendas[self:Team()]
end

DarkRP.getAgendas = fp{fn.Id, agendas}

function DarkRP.createAgenda(Title, Manager, Listeners)
    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["agendas"][Title] then return end

    local agenda = {Manager = Manager, Title = Title, Listeners = Listeners, ManagersByKey = {}}
    agenda.default = DarkRP.DARKRP_LOADING

    local valid, err, hints = DarkRP.validateAgenda(agenda)
    if not valid then DarkRP.error(string.format("Corrupt agenda: %s!\n%s", agenda.Title or "", err), 2, hints) end

    for _, v in pairs(agenda.Listeners) do
        agendas[v] = agenda
    end

    for _, v in pairs(istable(agenda.Manager) and agenda.Manager or {agenda.Manager}) do
        agendas[v] = agenda
        DarkRPAgendas[v] = agenda -- backwards compat
        agenda.ManagersByKey[v] = true
    end

    if SERVER then
        timer.Simple(0, function()
            -- Run after scripts have loaded
            agenda.text = hook.Run("agendaUpdated", nil, agenda, "")
        end)
    end
end
AddAgenda = DarkRP.createAgenda

function DarkRP.removeAgenda(title)
    local agenda
    for k, v in pairs(agendas) do
        if v.Title == title then
            agenda = v
            agendas[k] = nil
        end
    end

    for k, v in pairs(DarkRPAgendas) do
        if v.Title == title then DarkRPAgendas[k] = nil end
    end
    hook.Run("onAgendaRemoved", title, agenda)
end

GM.DarkRPGroupChats = {}
local groupChatNumber = 0
function DarkRP.createGroupChat(funcOrTeam, ...)
    local gm = GM or GAMEMODE
    gm.DarkRPGroupChats = gm.DarkRPGroupChats or {}
    if DarkRP.DARKRP_LOADING then
        groupChatNumber = groupChatNumber + 1
        if DarkRP.disabledDefaults["groupchat"][groupChatNumber] then return end
    end
    -- People can enter either functions or a list of teams as parameter(s)
    if isfunction(funcOrTeam) then
        table.insert(gm.DarkRPGroupChats, fp{DarkRP.simplerrRun, funcOrTeam})
    else
        local teams = {funcOrTeam, ...}
        table.insert(gm.DarkRPGroupChats, function(ply) return table.HasValue(teams, ply:Team()) end)
    end
end
GM.AddGroupChat = function(_, ...) DarkRP.createGroupChat(...) end

DarkRP.removeGroupChat = fp{removeCustomItem, GM.DarkRPGroupChats, nil, "onGroupChatRemoved", false}

DarkRP.getGroupChats = fp{fn.Id, GM.DarkRPGroupChats}

GM.AmmoTypes = {}

function DarkRP.createAmmoType(ammoType, name, model, price, amountGiven, customCheck)
    local gm = GM or GAMEMODE
    gm.AmmoTypes = gm.AmmoTypes or {}
    local ammo = istable(name) and name or {
        name = name,
        model = model,
        price = price,
        amountGiven = amountGiven,
        customCheck = customCheck
    }
    ammo.ammoType = ammoType
    ammo.default = DarkRP.DARKRP_LOADING

    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["ammo"][ammo.name] then return end

    ammo.customCheck = ammo.customCheck and fp{DarkRP.simplerrRun, ammo.customCheck}
    ammo.CustomCheckFailMsg = isfunction(ammo.CustomCheckFailMsg) and fp{DarkRP.simplerrRun, ammo.CustomCheckFailMsg} or ammo.CustomCheckFailMsg
    ammo.id = table.insert(gm.AmmoTypes, ammo)

    DarkRP.addToCategory(ammo, "ammo", ammo.category)
end
GM.AddAmmoType = function(_, ...) DarkRP.createAmmoType(...) end

DarkRP.removeAmmoType = fp{removeCustomItem, GM.AmmoTypes, "ammo", "onAmmoTypeRemoved", true}

local demoteGroups = {}
function DarkRP.createDemoteGroup(name, tbl)
    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["demotegroups"][name] then return end
    if not tbl or not tbl[1] then error("No members in the demote group!") end

    local set = demoteGroups[tbl[1]] or disjoint.MakeSet(tbl[1])
    set.name = name
    for i = 2, #tbl do
        set = (demoteGroups[tbl[i]] or disjoint.MakeSet(tbl[i])) + set
        set.name = name
    end

    for _, teamNr in pairs(tbl) do
        if demoteGroups[teamNr] then
            -- Unify the sets if there was already one there
            demoteGroups[teamNr] = demoteGroups[teamNr] + set
        else
            demoteGroups[teamNr] = set
        end
    end
end

function DarkRP.removeDemoteGroup(name)
    local foundSet
    for k, v in pairs(demoteGroups) do
        local set = disjoint.FindSet(v)
        if set.name == name then
            foundSet = set
            demoteGroups[k] = nil
        end
    end
    hook.Run("onDemoteGroupRemoved", name, foundSet)
end

function DarkRP.getDemoteGroup(teamNr)
    demoteGroups[teamNr] = demoteGroups[teamNr] or disjoint.MakeSet(teamNr)
    return disjoint.FindSet(demoteGroups[teamNr])
end

DarkRP.getDemoteGroups = fp{fn.Id, demoteGroups}

local categories = {
    jobs = {},
    entities = {},
    shipments = {},
    weapons = {},
    vehicles = {},
    ammo = {},
}
local categoriesMerged = false -- whether categories and custom items are merged.

DarkRP.getCategories = fp{fn.Id, categories}

local categoryOrder = function(a, b)
    local aso = a.sortOrder or 100
    local bso = b.sortOrder or 100
    return aso < bso or aso == bso and a.name < b.name
end

local function insertCategory(destination, tbl)
    -- Override existing category of applicable
    for k, cat in pairs(destination) do
        if cat.name ~= tbl.name then continue end

        destination[k] = tbl
        tbl.members = cat.members
        return
    end

    table.insert(destination, tbl)
    local i = #destination

    while i > 1 do
        if categoryOrder(destination[i - 1], tbl) then break end
        destination[i - 1], destination[i] = destination[i], destination[i - 1]
        i = i - 1
    end
end

function DarkRP.createCategory(tbl)
    local valid, err, hints = DarkRP.validateCategory(tbl)
    if not valid then DarkRP.error(string.format("Corrupt category: %s!\n%s", tbl.name or "", err), 2, hints) end
    tbl.members = {}

    local destination = categories[tbl.categorises]
    insertCategory(destination, tbl)

    -- Too many people made the mistake of not creating a category for weapons as well as shipments
    -- when having shipments that can also be sold separately.
    if tbl.categorises == "shipments" then
        insertCategory(categories.weapons, table.Copy(tbl))
    end
end

function DarkRP.addToCategory(item, kind, cat)
    cat = cat or "Other"
    item.category = cat

    -- The merge process will take care of the category:
    if not categoriesMerged then return end

    -- Post-merge: manual insertion into category
    local cats = categories[kind]
    for _, c in ipairs(cats) do
        if c.name ~= cat then continue end

        insertCategory(c.members, item)
        return
    end

    DarkRP.errorNoHalt(string.format([[The category of "%s" ("%s") does not exist!]], item.name, cat), 2, {
        "Make sure the category is created with DarkRP.createCategory.",
        "The category name is case sensitive!",
        "Categories must be created before DarkRP finished loading.",
    })
end

function DarkRP.removeFromCategory(item, kind)
    local cats = categories[kind]
    if not cats then DarkRP.error(string.format("Invalid category kind '%s'.", kind), 2) end
    local cat = item.category
    if not cat then return end
    for _, v in pairs(cats) do
        if v.name ~= item.category then continue end
        for k, mem in pairs(v.members) do
            if mem ~= item then continue end
            table.remove(v.members, k)
            break
        end
        break
    end
end

-- Assign custom stuff to their categories
local function mergeCategories(customs, catKind, path)
    local cats = categories[catKind]
    local catByName = {}
    for _, v in pairs(cats) do catByName[v.name] = v end
    for _, v in pairs(customs) do
        -- Override default thing categories:
        local catName = v.default and (GAMEMODE.Config.CategoryOverride[catKind] or {})[v.name] or v.category or "Other"
        local cat = catByName[catName]
        if not cat then
            DarkRP.errorNoHalt(string.format([[The category of "%s" ("%s") does not exist!]], v.name, catName), 3, {
                "Make sure the category is created with DarkRP.createCategory.",
                "The category name is case sensitive!",
                "Categories must be created before DarkRP finished loading."
            }, path, -1, path)
            cat = catByName.Other
        end

        cat.members = cat.members or {}
        table.insert(cat.members, v)
    end

    -- Sort category members
    for _, v in pairs(cats) do table.sort(v.members, categoryOrder) end
end

hook.Add("loadCustomDarkRPItems", "mergeCategories", function()
    local shipments = fn.Filter(fc{fn.Not, fp{fn.GetValue, "noship"}}, CustomShipments)
    local guns = fn.Filter(fp{fn.GetValue, "separate"}, CustomShipments)

    mergeCategories(RPExtraTeams, "jobs", "your jobs")
    mergeCategories(DarkRPEntities, "entities", "your custom entities")
    mergeCategories(shipments, "shipments", "your custom shipments")
    mergeCategories(guns, "weapons", "your custom weapons")
    mergeCategories(CustomVehicles, "vehicles", "your custom vehicles")
    mergeCategories(GAMEMODE.AmmoTypes, "ammo", "your custom ammo")

    categoriesMerged = true
end)

--addons/glorifiedleveling/lua/glorifiedleveling/libraries/cl_glorifiedleveling_themes.lua:
return gluapack()()
--addons/glorifiedleveling/lua/glorifiedleveling/localization/sh_glorifiedleveling_danish.lua:

GlorifiedLeveling.i18n.RegisterPhrases( "da", {
    glDarkTheme = "Mørk",
    glLevelNotHighEnough = "Dit rang er ikke højt nok til at gøre dette.",
    glYouReceivedXP = "Du har modtaget %s XP.",
    glYouReceivedXPKill = "Du har modtaget %s XP for at dræbe %s.",
    glLevelX = "Rang %s",
    glLevelUp = "Nyt Rang!",
    glAdminMenuLockdown = "NEDLUKNING",
    glAdminMenuPlayers = "SPILLERE",
    glPlayersOnline = "Spillere Online: %s",
    glSetLevel = "Set Rang",
    glResetLevel = "Nulstil Rang",
    glAddXP = "Tilføj XP",
    glConfirmation = "Bekræftelse",
    glYes = "Ja",
    glNo = "Nej",
    glConfirmationResetLevel = "Vil du nulstille denne spillers rang?",
    glEnterLevel = "Indtast spillerens nye rang forneden.",
    glEnterXP = "Indtast hvor meget XP du vil tilføje.",
    glEnter = "Enter",
    glInvalidAmount = "Ugyldig mændge valgt.",
    glMaxLevel = "Max Rang",

    -- Leaderboard localization.
    glLeaderboard = "Rangliste",
    glName = "Navn",
    glXP = "XP",
    glLevel = "Rang",
    glNobodyHere = "Ranglisten er tom :(",

    -- Perk localization.
    glSkills = "Færdigheder",
    glPoints = "%s Point",
    glComplete = "Fuldendt",

    glHasteBoots = "Kondisko",
    glHasteBootsDescription = "Du kan løbe hurtigere",

    glFeralLeaping = "Boots of Feral Leaping",
    glFeralLeapingDescription = "Hop højere og tag mindre skade fra fald",

    glIronSkin = "Skudsikker Vest",
    glIronSkinDescription = "Ekstra rustning",

    glJuggernaut = "Juggernaut",
    glJuggernautDescription = "Du vil have mere liv",

    glBulletAbsorption = "Udrustning",
    glBulletAbsorptionDescription = "Du tager mindre skade fra kugler",

    glHighGradeBullets = "Høj kvalitets kugler",
    glHighGradeBulletsDescription = "Du gør mere skade med skydevåben",
} )
--addons/glorifiedleveling/lua/glorifiedleveling/modules/integrations/cl_glorifiedleveling_vrondakis.lua:
return gluapack()()
--addons/glorifiedleveling/lua/glorifiedleveling/modules/ui/leaderboard/cl_glorifiedleveling_leaderboard_titlebar.lua:
return gluapack()()
--addons/zeros_trashman_v1.6.3/lua/darkrp_modules/ztrashman/sh_ztm_darkrp.lua:
TEAM_ZTM_TRASHMAN = DarkRP.createJob("Çöpçü", {
    color = Color(20, 150, 20, 255),
    model = {"models/player/group03/male_04.mdl"},
    description = [[Şehrin arka planındaki gizli kahramanlardan birisin! 
    Sokakları temiz tutar, çöpleri toplar ve düzeni sağlarsın. 
    Kimse fark etmese de, sen olmasan şehir çöp yığınına döner. 
    Ama unutma, bazen çöplerin arasında değerli şeyler de bulunabilir... ya da başını belaya sokacak bir şeyler!
    
    -Raid Yapamaz.
	-Mug Atamaz.
	-Banka Soyamaz.
	-İllegal Aktivitelerde Bulunamaz.
    ]],
    weapons = {"ztm_trashcollector"},
    command = "ztm_trashman",
    max = 4,
    salary = 250,
    admin = 0,
    vote = false,
    category = "Sivil",
    hasLicense = false
})

--addons/zeros_methlab02_v1.4.1/lua/darkrp_modules/zmlab2/sh_zmlab2_darkrp.lua:
return gluapack()()
--addons/realisticcardealer/lua/darkrp_modules/rcd_job_module/sh_job_modules.lua:
/*
-- bozuk abi ya
TEAM_CARDEALER = DarkRP.createJob("Galerici", {
    color = Color(158, 38, 228),
    model = {"models/player/breen.mdl"},
    description = [[ Galerici  ]],
    weapons = {},
    command = "cardealer",
    max = 1,
    salary = 20,
    admin = 0,
    vote = false,
    category = "Esnaf",
    hasLicense = false
})

DarkRP.createCategory{
	name = "Cardealer Job", 
	categorises = "entities",
	startExpanded = true,
	color = Color(158, 38, 228),
	canSee = function(ply) return true end,
	sortOrder = 100,
}

DarkRP.createEntity("Showcase", {
	ent = "rcd_showcase",
	model = "models/dimitri/kobralost/stand.mdl",
	price = 500,
	max = 2,
	cmd = "rcd_showcase",
	allowed = {TEAM_CARDEALER},
    category = "Cardealer Job",
})

DarkRP.createEntity("Printer", {
	ent = "rcd_printer",
	model = "models/dimitri/kobralost/printer.mdl",
	price = 500,
	max = 2,
	cmd = "rcd_printer",
	allowed = {TEAM_CARDEALER},
    category = "Cardealer Job",
})
*/
--addons/darkrpmodification/lua/darkrp_customthings/shipments.lua:

DarkRP.createShipment("Tam Zırh", {
    model = "models/combine_vests/bogvest.mdl",
    entity = "heavy_armor",
    amount = 3,
    price = 100000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Zırh",
    allowed = {TEAM_GUN}
})

DarkRP.createShipment("Telsiz", {
    model = "models/danradio/w_radio.mdl",
    entity = "dradio",
    amount = 5,
    price = 50000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Zırh",
    allowed = {TEAM_GUN}
})

DarkRP.createShipment("RPK", {
    model = "models/weapons/w_rif_ak47.mdl",
    entity = "arccw_ur_rpk",
    amount = 1,
    price = 675000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Ağır Makineli",
    allowed = {TEAM_GUNDEALER}
})

DarkRP.createShipment("AKM", {
    model = "models/weapons/w_rif_ak47.mdl",
    entity = "arccw_ur_ak",
    amount = 1,
    price = 825000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Tam Otomatik Silah",
    allowed = {TEAM_GUN}
})

DarkRP.createShipment("Desert Eagle", {
    model = "models/weapons/w_pist_deagle.mdl",
    entity = "arccw_ur_deagle",
    amount = 1,
    price = 412500,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Tabanca",
    allowed = {TEAM_GUN, TEAM_SILAH}
})

DarkRP.createShipment("GLOCK-17", {
    model = "models/weapons/arccw/c_ud_glock.mdl",
    entity = "arccw_ud_glock",
    amount = 1,
    price = 225000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Tabanca",
    allowed = {TEAM_GUN, TEAM_SILAH}
})

DarkRP.createShipment("Benelli M4", {
    model = "models/weapons/arccw/c_ud_m1014.mdl",
    entity = "arccw_ud_m1014",
    amount = 1,
    price = 705000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Pompalı",
    allowed = {TEAM_GUN}
})

DarkRP.createShipment("M1191", {
    model = "models/weapons/arccw/c_ur_m1911.mdl",
    entity = "arccw_ur_m1911",
    amount = 1,
    price = 262500,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Tabanca",
    allowed = {TEAM_GUN, TEAM_SILAH}
})

DarkRP.createShipment("Model329PD", {
    model = "models/weapons/arccw/c_ur_329pd.mdl",
    entity = "arccw_ur_329",
    amount = 1,
    price = 300000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Tabanca",
    allowed = {TEAM_GUN, TEAM_SILAH}
})

DarkRP.createShipment("MP5A4", {
    model = "models/weapons/arccw/c_ur_mp5.mdl",
    entity = "arccw_ur_mp5",
    amount = 1,
    price = 900000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Tam Otomatik Silah",
    allowed = {TEAM_GUN}
})

DarkRP.createShipment("REMINGTON 870", {
    model = "models/weapons/arccw/c_ud_870.mdl",
    entity = "arccw_ud_870",
    amount = 1,
    price = 420000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Pompalı",
    allowed = {TEAM_GUN}
})

DarkRP.createShipment("AK 101", {
    model = "models/weapons/w_rif_ak47.mdl",
    entity = "arccw_ur_ak101",
    amount = 1,
    price = 1050000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Tam Otomatik Silah",
    allowed = {TEAM_GUN}
})

DarkRP.createShipment("Uzi", {
    model = "models/weapons/arccw/c_ud_uzi.mdl",
    entity = "arccw_ud_uzi",
    amount = 1,
    price = 360000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Tam Otomatik Silah",
    allowed = {TEAM_GUN}
})

DarkRP.createShipment("Butter Fly Vape", {
    model = "models/swamponions/vape.mdl",
    entity = "weapon_vape_butterfly",
    amount = 3,
    price = 25000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Vape",
    cmd = "Butter",
    allowed = {TEAM_TUTUNCU}
})
DarkRP.createShipment("Can Doldurdan Vape", {
    model = "models/swamponions/vape.mdl",
    entity = "weapon_vape_medicinal",
    amount = 3,
    separate = false,
    pricesep = 0,
    noship = false,
    price = 400000,
    category = "Vape",
    cmd = "candolduranvape",
    allowed = {TEAM_TUTUNCU}
})
DarkRP.createShipment("Meyveli Vape", {
    model = "models/swamponions/vape.mdl",
    entity = "weapon_vape_juicy",
    amount = 3,
    price = 20000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Vape",
    cmd = "candolduranvape",
    allowed = {TEAM_TUTUNCU}
})
DarkRP.createShipment("American Vape", {
    model = "models/swamponions/vape.mdl",
    entity = "weapon_vape_american",
    amount = 3,
    separate = false,
    pricesep = 0,
    noship = false,
    price = 33000,
    category = "Vape",
    cmd = "candolduranvape",
    allowed = {TEAM_TUTUNCU}
})





DarkRP.createShipment("Yavaş Lockpick", {
    model = "models/weapons/w_crowbar.mdl",
    entity = "lockpick",
    amount = 2,
    price = 250000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Çilingirci",
    allowed = {TEAM_GUN}
})
DarkRP.createShipment("Hızlı Lockpick", {
    model = "models/weapons/w_crowbar.mdl",
    entity = "pro_lockpick_update",
    amount = 2,
    price = 400000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Çilingirci",
    allowed = {TEAM_GUN}
})












DarkRP.createShipment("M45", {
    entity = "arccw_ur_m45",
    model = "models/weapons/arccw/c_ur_m1911.mdl",
    amount = 1,
    price = 262500,
    noship = false,
    separate = false,
    category = "Tabanca",
    allowed = {
        TEAM_SILAH
    },
})

DarkRP.createShipment("USP Match", {
    entity = "arccw_uc_uspmatch",
    model = "models/weapons/arccw/c_uc_usp.mdl",
    amount = 1,
    price = 262500,
    noship = false,
    separate = false,
    category = "Tabanca",
    allowed = {
        TEAM_SILAH
    },
})

DarkRP.createShipment("G24", {
    entity = "arccw_ud_g24",
    model = "models/weapons/arccw/c_ud_glock.mdl",
    amount = 1,
    price = 345000,
    noship = false,
    separate = false,
    category = "Tabanca",
    allowed = {
        TEAM_SILAH
    },
})

DarkRP.createShipment("MP5K", {
    entity = "arccw_ur_mp5k",
    model = "models/weapons/arccw/c_ur_mp5.mdl",
    amount = 1,
    price = 600000,
    noship = false,
    separate = false,
    category = "Tam Otomatik Silah",
    allowed = {
        TEAM_SILAH
    },
})

DarkRP.createShipment("Micro Uzi", {
    entity = "arccw_ud_microuzi",
    model = "models/weapons/arccw/c_ud_uzi.mdl",
    amount = 1,
    price = 600000,
    noship = false,
    separate = false,
    category = "Tam Otomatik Silah",
    allowed = {
        TEAM_SILAH
    },
})

DarkRP.createShipment("Uzi Carbine", {
    entity = "arccw_ud_uzicarbine",
    model = "models/weapons/arccw/c_ud_uzi.mdl",
    amount = 1,
    price = 675000,
    noship = false,
    separate = false,
    category = "Tam Otomatik Silah",
    allowed = {
        TEAM_SILAH
    },
})

DarkRP.createShipment("STG-44", {
    entity = "arccw_mkb44h",
    model = "models/weapons/w_stg44.mdl",
    amount = 1,
    price = 600000,
    noship = false,
    separate = false,
    category = "Tam Otomatik Silah",
    allowed = {
        TEAM_GUN
    },
})

DarkRP.createShipment("AT", {
    entity = "arccw_ur_at",
    model = "models/weapons/arccw/c_ur_aw.mdl",
    amount = 1,
    price = 4500000,
    noship = false,
    separate = false,
    category = "Keskin Nişancı",
    allowed = {
        TEAM_SILAH
    },
})

DarkRP.createShipment("Keypad Kırıcı", {
    model = "models/weapons/w_c4.mdl",
    entity = "weapon_sh_keypadcracker_deploy",
    amount = 1,
    price = 225000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Çilingirci",
    allowed = {TEAM_GUN}
})

DarkRP.createShipment("Kelepçe", {
    model = "models/sterling/glorified_handcuffs.mdl",
    entity = "glorifiedhandcuffs_handcuffs",
    amount = 1,
    price = 60000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Çilingirci",
    allowed = {TEAM_GUN}
})

DarkRP.createShipment("MINI-14", {
    model = "models/weapons/arccw/c_ud_mini14.mdl",
    entity = "arccw_ud_mini14",
    amount = 1,
    price = 975000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Keskin Nişancı",
    allowed = {TEAM_GUNDEALER}
})

DarkRP.createShipment("AWM", {
    model = "models/weapons/arccw/c_ur_aw.mdl",
    entity = "arccw_ur_awm",
    amount = 1,
    price = 1500000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Keskin Nişancı",
    allowed = {TEAM_GUNDEALER}
})

DarkRP.createShipment("AWS", {
    model = "models/weapons/arccw/c_ur_aw.mdl",
    entity = "arccw_ur_aws",
    amount = 1,
    price = 1800000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Keskin Nişancı",
    allowed = {TEAM_GUNDEALER}
})

DarkRP.createShipment("AT", {
    model = "models/weapons/arccw/c_ur_aw.mdl",
    entity = "arccw_ur_at",
    amount = 1,
    price = 1275000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Keskin Nişancı",
    allowed = {TEAM_GUNDEALER}
})

DarkRP.createShipment("M13 Virtus SBR", {
    model = "models/weapons/w_mcxvirtus.mdl",
    entity = "arccw_mcx",
    amount = 1,
    price = 1500000,
    separate = false,
    pricesep = 0,
    noship = false,
    category = "Tam Otomatik Silah",
    allowed = {TEAM_GUN}
})

--addons/darkrpmodification/lua/darkrp_customthings/entities.lua:
DarkRP.createEntity("SMG Mermisi", {
    ent = "arccw_ammo_smg1",
    model = "models/items/boxsrounds.mdl",
    price = 1500,
    category = "Mermiler",
    max = 10,
    cmd = "buysmgammo"
})

DarkRP.createEntity("SMG Mermisi (Büyük)", {
    ent = "arccw_ammo_smg1_large",
    model = "models/items/boxsrounds.mdl",
    price = 3000,
    category = "Mermiler",
    max = 5,
    cmd = "buysmglammo"
})

DarkRP.createEntity("357 Mermisi", {
    ent = "arccw_ammo_357",
    model = "models/items/boxsrounds.mdl",
    price = 2000,
    category = "Mermiler",
    max = 10,
    cmd = "buy357ammo"
})

DarkRP.createEntity("357 Mermisi (Büyük)", {
    ent = "arccw_ammo_357_large",
    model = "models/items/boxsrounds.mdl",
    price = 4000,
    category = "Mermiler",
    max = 5,
    cmd = "buy357lammo"
})

DarkRP.createEntity("Tabanca Mermisi", {
    ent = "arccw_ammo_pistol",
    model = "models/items/boxsrounds.mdl",
    price = 1000,
    category = "Mermiler",
    max = 10,
    cmd = "buypistolammo"
})

DarkRP.createEntity("Tabanca Mermisi (Büyük)", {
    ent = "arccw_ammo_pistol_large",
    model = "models/items/boxsrounds.mdl",
    price = 2500,
    category = "Mermiler",
    max = 5,
    cmd = "buypistollammo"
})

DarkRP.createEntity("AR2 Mermisi", {
    ent = "arccw_ammo_ar2",
    model = "models/items/boxsrounds.mdl",
    price = 2000,
    category = "Mermiler",
    max = 10,
    cmd = "buyar2ammo"
})

DarkRP.createEntity("AR2 Mermisi (Büyük)", {
    ent = "arccw_ammo_ar2_large",
    model = "models/items/boxsrounds.mdl",
    price = 4500,
    category = "Mermiler",
    max = 5,
    cmd = "buyar2lammo"
})

DarkRP.createEntity("Pompalı Tüfek Mermisi", {
    ent = "arccw_ammo_buckshot",
    model = "models/items/boxsrounds.mdl",
    price = 1200,
    category = "Mermiler",
    max = 10,
    cmd = "buyshotgunammo"
})

DarkRP.createEntity("Pompalı Tüfek Mermisi (Büyük)", {
    ent = "arccw_ammo_buckshot_large",
    model = "models/items/boxsrounds.mdl",
    price = 3000,
    category = "Mermiler",
    max = 5,
    cmd = "buyshotgunlammo"
})

DarkRP.createEntity("Piyano", {
    ent = "gmt_instrument_piano", 
    model = "models/fishy/furniture/piano.mdl",
    price = 50000,
    max = 1,
    cmd = "buypiano",
    allowed = {TEAM_PIYANO}
})

DarkRP.createEntity("Televizyon", {
    ent = "mediaplayer_tv",
    model = "models/gmod_tower/suitetv_large.mdl",
    price = 75000,
    max = 3,
    cmd = "buytelevizyon",
    allowed = {TEAM_TELEVIZYONCU}
})

DarkRP.createEntity("Keskin Nişancı Tüfeği Mermisi", {
    ent = "arccw_ammo_sniper",
    model = "models/items/boxsrounds.mdl",
    price = 3000,
    category = "Mermiler",
    max = 10,
    cmd = "buysniperammo"
})

DarkRP.createEntity("Keskin Nişancı Tüfeği Mermisi (Büyük)", {
    ent = "arccw_ammo_sniper_large",
    model = "models/items/boxsrounds.mdl",
    price = 6000,
    category = "Mermiler",
    max = 5,
    cmd = "buysniperlammo"
})


--addons/glorifiedhandcuffs/lua/glorifiedhandcuffs/libraries/cl_glorifiedhandcuffs_themes.lua:
return gluapack()()
--addons/glorifiedhandcuffs/lua/glorifiedhandcuffs/libraries/sh_glorifiedhandcuffs_i18n.lua:

--[[
    GlorifiedPig's Localization & Internationalization Library
    © 2020 GlorifiedPig

    Please read usage guide @ https://github.com/GlorifiedPig/gmod-i18n

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]--

local language = GetConVar( "gmod_language" )
local registeredPhrases = {}

GlorifiedHandcuffs.i18n = {}

function GlorifiedHandcuffs.i18n.RegisterPhrase( languageIdentifier, phraseId, text )
    if not registeredPhrases[languageIdentifier] then registeredPhrases[languageIdentifier] = {} end
    registeredPhrases[languageIdentifier][phraseId] = text
end

function GlorifiedHandcuffs.i18n.RegisterPhrases( languageIdentifier, phraseTbl )
    for k, v in pairs( phraseTbl ) do
        GlorifiedHandcuffs.i18n.RegisterPhrase( languageIdentifier, k, v )
    end
end

function GlorifiedHandcuffs.i18n.GetPhrase( phraseIdentifier, ... )
    local phraseLanguage = registeredPhrases[language:GetString()] or registeredPhrases["en"]
    local finalPhrase = registeredPhrases["en"][phraseIdentifier]
    if phraseLanguage[phraseIdentifier] then finalPhrase = phraseLanguage[phraseIdentifier] end

    return #{ ... } > 0 and string.format( finalPhrase, ... ) or finalPhrase
end
--addons/glorifiedhandcuffs/lua/glorifiedhandcuffs/localization/sh_glorifiedhandcuffs_english.lua:

GlorifiedHandcuffs.i18n.RegisterPhrases( "en", {
        cuffed = "Kelepçelisin",
    blindfolded = "Gözlerin bağlı",
    gagged = "Ağzın bağlı",
    hitToFree = "%s  tuşunu spamlayarak kelepçeden kurtulabilirsin",
    brokenFreeWanted = "Tutsaklıktan kaçtı",
    bailMenu = "Kefalet Menüsü",
    bailPlayer = "Oyuncunun Kefaletini Öde",
    bailNpc = "Kefalet NPC’si",
    jailerNpc = "Gardiyan NPC’si",
    noPlayers = "Tutuklu hiçbir oyuncu yok.",
    surrendering = "Teslim oluyorsun",
    putHandsDown = "Ellerini indirmek için %s  tuşuna bas",
    playersJailed = "%s’yı %s süreliğine hapise attın.",
    name = "İsim",
    job = "Meslek",
    wallet = "Cüzdan",
    confiscateAll = "Tüm Eşyalarına El Koy",
    confiscateIllegal = "İllegal Eşyalarına El Koy",
    takeAll = "Hepsini Al",
    takeIllegal = "İllegal Eşyasını Al",
    dragPlayer = "Oyuncuyu Sürükle",
    blindfoldPlayer = "Oyuncunun Gözlerini Bağla",
    removeBlindfold = "Göz Bağını Çıkar",
    gagPlayer = "Oyuncunun Ağzını Bağla",
    removeGag = "Oyuncunun Ağzını Çöz",
    confiscate = "El Koy",
    handcuffs = "Kelepçe",
    baton = "Cop",
    --[[
    cuffed = "You are cuffed",
    blindfolded = "You are blindfolded",
    gagged = "You are gagged",
    hitToFree = "Spam  %s  to break free",
    brokenFreeWanted = "Escaped from custody",
    bailMenu = "Bail Menu",
    bailPlayer = "Bail Player",
    bailNpc = "Bail NPC",
    jailerNpc = "Jailer NPC",
    noPlayers = "There are no arrested players.",
    surrendering = "You are surrendering",
    putHandsDown = "Press  %s  to put your hands down",
    playersJailed = "You jailed %s player(s) for %s.",
    name = "Name",
    job = "Job",
    wallet = "Wallet",
    confiscateAll = "Confiscate All",
    confiscateIllegal = "Confiscate Illegal",
    takeAll = "Take All",
    takeIllegal = "Take Illegal",
    dragPlayer = "Drag Player",
    blindfoldPlayer = "Blindfold Player",
    removeBlindfold = "Remove Blindfold",
    gagPlayer = "Gag Player",
    removeGag = "Remove Gag",
    confiscate = "Confiscate",
    handcuffs = "Handcuffs",
    baton = "Baton",
    --]]
} )
--addons/glorifiedhandcuffs/lua/glorifiedhandcuffs/modules/ui/interactionmenu/cl_glorifiedhandcuffs_interactionmenu_infobox.lua:
return gluapack()()
--addons/glorifiedhandcuffs/lua/glorifiedhandcuffs/modules/ui/interactionmenu/cl_glorifiedhandcuffs_interactionmenu_titlebar.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/weapons/arccw_base/shared.lua:
AddCSLuaFile()

-- For those who may find it useful...
-- use WEAPONENTITY:SetNWBool("ArcCW_DisableAutosave", true) to tell the client to not load their autosaves.

SWEP.Spawnable = false -- this obviously has to be set to true
SWEP.AutoSpawnable = nil -- TTT weapon autospawn. ArcCW weapons automatically spawn in TTT as long as SWEP.Spawnable is set to true
SWEP.Category = "ArcCW - Firearms" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "ArcCW Base"
SWEP.Trivia_Class = nil -- "Submachine Gun"
SWEP.Trivia_Desc = nil -- "Ubiquitous 9mm SMG. Created as a response to the need for a faster-firing and more reliable submachine gun than existing options at the time."
SWEP.Trivia_Manufacturer = nil -- "Auschen Waffenfabrik"
SWEP.Trivia_Calibre = nil -- "9x21mm Jager"
SWEP.Trivia_Mechanism = nil -- "Roller-Delayed Blowback"
SWEP.Trivia_Country = nil -- "Austria"
SWEP.Trivia_Year = nil -- 1968

SWEP.UseHands = true

SWEP.ViewModel = "" -- I mean, you probably have to edit these too
SWEP.WorldModel = ""

SWEP.MirrorVMWM = nil -- Copy the viewmodel, along with all its attachments, to the worldmodel. Super convenient!
SWEP.MirrorWorldModel = nil -- Use this to set the mirrored viewmodel to a different model, without any floating speedloaders or cartridges you may have. Needs MirrorVMWM
SWEP.HideViewmodel = nil
--[[SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}]]

SWEP.PresetBase = nil -- make this weapon share saves with this one.

SWEP.KillIconAlias = nil -- set to other weapon class to share select and kill icons

SWEP.DefaultBodygroups = "00000000"
SWEP.DefaultWMBodygroups = "00000000"
SWEP.DefaultSkin = 0
SWEP.DefaultWMSkin = 0

SWEP.WorldModelOffset = nil
-- {
--     pos = Vector(0, 0, 0),
--     ang = Angle(0, 0, 0)
-- }

SWEP.NoHideLeftHandInCustomization = false

SWEP.Damage = 26
SWEP.DamageMin = 10 -- damage done at maximum range
SWEP.DamageRand = 0 -- damage will vary randomly each shot by this fraction
SWEP.RangeMin = 0 -- how far bullets will retain their maximum damage for
SWEP.Range = 200 -- in METRES
SWEP.Penetration = 4
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false -- set to true to have the base not do anything with damage types
-- this includes: igniting if type has DMG_BURN; adding DMG_AIRBOAT when hitting helicopter; adding DMG_BULLET to DMG_BUCKSHOT

SWEP.Distance = nil -- Maximum distance of the bullet (does not affect physbullets)

SWEP.Force = nil -- bullet force. set nil to autocalculate

SWEP.ShootEntity = nil -- entity to fire, if any
SWEP.MuzzleVelocity = 400 -- projectile muzzle velocity in m/s
SWEP.PhysBulletMuzzleVelocity = nil -- override phys bullet muzzle velocity
SWEP.PhysBulletDrag = 1
SWEP.PhysBulletGravity = 1
SWEP.PhysBulletDontInheritPlayerVelocity = true

SWEP.BodyDamageMults = nil
-- if a limb is not set the damage multiplier will default to 1
-- that means gmod's stupid default limb mults will **NOT** apply
-- {
--     [HITGROUP_HEAD] = 1.25,
--     [HITGROUP_CHEST] = 1,
--     [HITGROUP_LEFTARM] = 0.9,
--     [HITGROUP_RIGHTARM] = 0.9,
-- }

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 0 -- color for phys tracer. can be a number or a string (see sh_physbullet2.lua)
-- there are 8 default options:
-- 0 = normal
-- 1 = red
-- 2 = green
-- 3 = blue
-- 4 = yellow
-- 5 = violet
-- 6 = cyan
-- 7 = black/invisible

SWEP.TracerNum = 1 -- tracer every X
SWEP.TracerFinalMag = 0 -- the last X bullets in a magazine are all tracers
SWEP.Tracer = "arccw_tracer" -- override tracer (hitscan) effect
SWEP.TracerCol = Color(255, 255, 255)
SWEP.HullSize = 0 -- HullSize used by FireBullets

SWEP.ChamberSize = 1 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 25 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 50
SWEP.ReducedClipSize = 10

-- But if you insist...
SWEP.ForceDefaultClip = nil
SWEP.ForceDefaultAmmo = nil

-- The amount of rounds to load in the chamber when the gun is non-empty or empty
-- Defaults to ChamberSize and 0. Don't change unless you have a good reason
SWEP.ChamberLoadNonEmpty = nil
SWEP.ChamberLoadEmpty = nil

SWEP.AmmoPerShot = 1
SWEP.InfiniteAmmo = false -- weapon can reload for free
SWEP.BottomlessClip = false -- weapon never has to reload

SWEP.DoNotEquipmentAmmo = false -- do not automatically give this weapon unique ammo when arccw_equipmentammo is used

SWEP.ShotgunReload = false -- reloads like shotgun instead of magazines
SWEP.HybridReload = false -- reload normally when empty, reload like shotgun when part full

SWEP.ManualAction = false -- pump/bolt action
SWEP.NoLastCycle = false -- do not cycle on last shot

SWEP.RevolverReload = false -- cases all eject on reload

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.LockSightsInPriorityAnim = false

SWEP.CanFireUnderwater = false

SWEP.Disposable = false -- when all ammo is expended, the gun will remove itself when holstered

SWEP.AutoReload = false -- when weapon is drawn, the gun will reload itself.

SWEP.IsShotgun = false -- weapon receives shotgun ammo types

SWEP.TriggerDelay = false -- Set to true to play the "trigger" animation before firing. Delay time is dependent on animation time.
SWEP.TriggerCharge = false -- If TriggerDelay is set, holding trigger will charge and releasing it fires. Also allows premature release of trigger.
SWEP.TriggerPullWhenEmpty = true -- If true, can pull the trigger even if no ammo is left.

SWEP.Recoil = 2
SWEP.RecoilSide = 1
SWEP.RecoilRise = 1
SWEP.MaxRecoilBlowback = -1
SWEP.VisualRecoilMult = 1.25
SWEP.RecoilPunch = 1.5
SWEP.RecoilPunchBackMax = 1
SWEP.RecoilPunchBackMaxSights = nil -- may clip with scopes
SWEP.RecoilVMShake = 1 -- random viewmodel offset when shooty

SWEP.Sway = 0

SWEP.ShotgunSpreadDispersion = false -- dispersion will cause pattern to increase instead of shifting
SWEP.ShotgunSpreadPattern = nil
SWEP.ShotgunSpreadPatternOverrun = nil
-- {Angle(1, 1, 0), Angle(1, 0, 0) ..}
-- list of how far each pellet should veer
-- if only one pellet then it'll use the first index
-- if two then the first two
-- in case of overrun pellets will start looping, preferably with the second one, so use that for the loopables
-- precision will still be applied
SWEP.NoRandSpread = false

SWEP.RecoilDirection = Angle(1, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1, 0)

SWEP.Delay = 60 / 750 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemode = 1 -- 0: safe, 1: semi, 2: auto, negative: burst
SWEP.Firemodes = {
    -- {
    --     Mode = 1,
    --     CustomBars = "---_#!",
--[[
                Custom bar setup
        Colored variants        Classic
        'a' Filled              '-' Filled
        'b' Outline             '_' Outline
        'd' CLR w Outline       '!' Red w Outline
                    '#' Empty
]]
    --     PrintName = "PUMP",
    --     RunAwayBurst = false,
    --     AutoBurst = false, -- hold fire to continue firing bursts
    --     PostBurstDelay = 0,
    --     ActivateElements = {}
    --     RestoreAmmo = false -- switching to this firemode will call RestoreAmmo(). intended to be used alongside firemode changing animations
    -- }
}

SWEP.ShotRecoilTable = nil -- {[1] = 0.25, [2] = 2} etc.

SWEP.NotForNPCS = false
SWEP.NPCWeaponType = nil -- string or table, the NPC weapons for this gun to replace
-- if nil, this will be based on holdtype
SWEP.NPCWeight = 0 -- relative likeliness for an NPC to have this weapon
SWEP.TTTWeaponType = nil -- string or table, like NPCWeaponType but specifically for TTT weapons (takes precdence over NPCWeaponType)
SWEP.TTTWeight = 0 -- like NPCWeight but for TTT gamemode

SWEP.AccuracyMOA = 15 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 150 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 0 -- dispersion that remains even in sights
SWEP.JumpDispersion = 300 -- dispersion penalty when in the air

SWEP.Bipod_Integral = false -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 1 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 1 -- Bipod recoil for Integral bipods

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "pistol" -- what ammo type the gun uses
SWEP.MagID = "mpk1" -- the magazine pool this gun draws from

SWEP.ShootVol = 125 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = nil
SWEP.ShootSound = ""
SWEP.ShootSoundLooping = nil
SWEP.FirstShootSoundSilenced = nil
SWEP.ShootDrySound = nil -- Add an attachment hook for Hook_GetShootDrySound please!
SWEP.DistantShootSound = nil
SWEP.ShootSoundSilenced = "weapons/arccw/m4a1/m4a1-1.wav"
SWEP.ShootSoundSilencedLooping = nil
SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"
SWEP.EnterBipodSound = "weapons/arccw/bipod_down.wav"
SWEP.ExitBipodSound = "weapons/arccw/bipod_up.wav"
SWEP.SelectUBGLSound =  "weapons/arccw/ubgl_select.wav"
SWEP.ExitUBGLSound = "weapons/arccw/ubgl_exit.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects
SWEP.ImpactEffect = nil
SWEP.ImpactDecal = nil

SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellMaterial = nil
SWEP.ShellEffect = nil
SWEP.ShellEjectPosCorrection = nil
SWEP.ShellScale = 1
SWEP.ShellPhysScale = 1
SWEP.ShellPitch = 100
SWEP.ShellSounds = "autocheck"--ArcCW.ShellSoundsTable
SWEP.ShellRotate = 0
SWEP.ShellTime = 0.5

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on
SWEP.ProceduralViewBobAttachment = nil -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.CamAttachment = nil -- if set, this attachment will control camera movement
SWEP.MuzzleFlashColor = Color(244, 209, 66)

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1

SWEP.BulletBones = { -- the bone that represents bullets in gun/mag
    -- [0] = "bulletchamber",
    -- [1] = "bullet1"
}
SWEP.CaseBones = {}
-- Unlike BulletBones, these bones are determined by the missing bullet amount when reloading
SWEP.StripperClipBones = {}

-- the same as the bone versions but works via bodygroups.
-- bodygroups work the same as in attachmentelements.
-- [0] = {ind = 0, bg = 1}
SWEP.BulletBGs = {}
SWEP.CaseBGs = {}
SWEP.StripperClipBGs = {}

SWEP.KeepBaseIrons = false -- do not override iron sights when scope installed
SWEP.BaseIronsFirst = false -- If a sight keeps base irons, irons comes first

SWEP.IronSightStruct = {
    Pos = Vector(-8.728, -13.702, 4.014),
    Ang = Angle(-1.397, -0.341, -2.602),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 15, -4),
        Ang = Angle(0, 0, -45),
    },
    Magnification = 1,
    BlackBox = false,
    ScopeTexture = nil,
    SwitchToSound = "", -- sound that plays when switching to this sight
    SwitchFromSound = "",
    ScrollFunc = ArcCW.SCROLL_NONE,
    CrosshairInSights = false,
}

SWEP.LaserOffsetAngle = nil -- adjusts the offset angle of lasers
SWEP.LaserIronsAngle = nil -- additional offset when using ironsights only

-- Works identically to AdditionalSights in attachments
-- KeepBaseIrons and BaseIronsFirst also affect this
SWEP.ExtraIrons = nil

-- add lasers to your weapon without attachments
SWEP.Lasers = nil
-- {
--     {
--         LaserStrength = 1,
--         LaserBone = "laser",
--         Color = Color(255, 0, 0)
--     }
-- }

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false
SWEP.SightTime = 0.33
SWEP.SprintTime = 0

-- Override free aim convar and variable
SWEP.FreeAimAngle = nil -- defaults to HipDispersion / 80. overwrite here
SWEP.NeverFreeAim = nil
SWEP.AlwaysFreeAim = nil

-- If Jamming is enabled, a heat meter will gradually build up until it reaches HeatCapacity.
-- Once that happens, the gun will overheat, playing an animation. If HeatLockout is true, it cannot be fired until heat is 0 again.
SWEP.Jamming = false
SWEP.HeatGain = 1 -- heat gained per shot
SWEP.HeatCapacity = 200 -- rounds that can be fired non-stop before the gun jams, playing the "fix" animation
SWEP.HeatDissipation = 2 -- rounds' worth of heat lost per second
SWEP.HeatLockout = false -- overheating means you cannot fire until heat has been fully depleted
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = false -- when the "fix" animation is played, all heat is restored.
SWEP.HeatOverflow = nil -- if true, heat is allowed to exceed capacity (this only applies when the default overheat handling is overridden)

-- If Malfunction is enabled, the gun has a random chance to be jammed
-- after the gun is jammed, it won't fire unless reload is pressed, which plays the "unjam" animation
-- if no "unjam", "fix", or "cycle" animations exist, the weapon will reload instead
SWEP.Malfunction = false
SWEP.MalfunctionJam = true -- After a malfunction happens, the gun will dryfire until reload is pressed. If unset, instead plays animation right after.
SWEP.MalfunctionTakeRound = true -- When malfunctioning, a bullet is consumed.
SWEP.MalfunctionPostFire = false -- If set, jam will occur after firing the round successfully.
SWEP.MalfunctionWait = 0.5 -- The amount of time to wait before playing malfunction animation (or can reload)
SWEP.MalfunctionMean = nil -- The mean number of shots between malfunctions, will be autocalculated if nil
SWEP.MalfunctionVariance = 0.25 -- The fraction of mean for variance. e.g. 0.2 means 20% variance
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "smg"
SWEP.HoldtypeCustomize = "slam"
SWEP.HoldtypeSprintShoot = nil
SWEP.HoldtypeNPC = nil

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.GuaranteeLaser = false -- GUARANTEE that the laser position will be accurate, so don't bother with sighted correction

SWEP.ShieldProps = nil
-- {
--     {
--         Model = "",
--         Pos = Vector(0, 0, 0),
--         Ang = Angle(0, 0, 0),
--         Bone = "", -- leave blank for valvebiped right hand
--         Resistance = 5, -- one unit of this object counts for how much penetration amount
--     }
-- }

SWEP.CanBash = true
SWEP.PrimaryBash = false -- primary attack triggers melee attack

SWEP.Lunge = nil -- Whether to allow the bash/melee to lunge a short distance
SWEP.LungeLength = 64 -- Maximum distance for lunging

SWEP.MeleeDamage = 25
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.Melee2 = false
SWEP.Melee2Damage = 25
SWEP.Melee2Range = 16
SWEP.Melee2Time = 0.5
SWEP.Melee2Gesture = nil
SWEP.Melee2AttackTime = 0.2

SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)

SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.ReloadPos = nil
SWEP.ReloadAng = nil

SWEP.CrouchPos = nil
SWEP.CrouchAng = nil

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)

-- When using custom sprint animations, set this to the same as ActivePos and ActiveAng
SWEP.SprintPos = nil
SWEP.SprintAng = nil

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)

SWEP.CustomizePos = Vector(9.824, 0, -4.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.BarrelLength = 24

SWEP.SightPlusOffset = nil

SWEP.DefaultPoseParams = {} -- {["pose"] = 0.5}
SWEP.DefaultWMPoseParams = {}

SWEP.DefaultElements = {} -- {"ele1", "ele2"}

SWEP.AttachmentElements = {
    -- ["name"] = {
    --     RequireFlags = {}, -- same as attachments
    --     ExcludeFlags = {},
    --     NamePriority = 0, -- higher = more likely to be chosen
    --     NameChange = "",
    --     TrueNameChange = "",
    --     AddPrefix = "",
    --     AddSuffix = "",
    --     VMPoseParams = {}, -- {["pose"] = 0.5}
    --     VMColor = Color(),
    --     VMMaterial = "",
    --     VMBodygroups = {{ind = 1, bg = 1}},
    --     VMElements = {
    --         {
    --             Model = "",
    --             Bone = "",
    --             Offset = {
    --                 pos = Vector(),
    --                 ang = Angle(),
    --             },
    --             ModelSkin = 0,
    --             ModelBodygroups = "",
    --             Scale = Vector(1, 1, 1),
    --             IsMuzzleDevice = false -- this element is a muzzle device, and the muzzle flash should come from here.
    --         }
    --     },
    --     VMOverride = "", -- change the view model to something else. Please make sure it's compatible with the last one.
    --     VMBoneMods = {
    --         ["bone"] = Vector(0, 0, 0)
    --     },
    --     WMPoseParams = {}, -- {["pose"] = 0.5}
    --     WMColor = Color(),
    --     WMMaterial = "",
    --     WMBodygroups = {},
    --     WMElements = {
    --         {
    --             Model = "",
    --             Offset = {
    --                 pos = Vector(),
    --                 ang = Angle(),
    --             },
    --             IsMuzzleDevice = false -- this element is a muzzle device, and the muzzle flash should come from here.
    --         }
    --     },
    --     WMOverride = "", -- change the world model to something else. Please make sure it's compatible with the last one.
    --     WMBoneMods = {
    --         ["bone"] = Vector(0, 0, 0)
    --     },
    --     AttPosMods = {
    --         [1] = {
    --             bone = "", -- optional
    --             vpos = Vector(0, 0, 0),
    --             vang = Angle(0, 0, 0),
    --             wpos = Vector(0, 0, 0),
    --             wang = Angle(0, 0, 0),
    --             SlideAmount = { -- only if base att has slideable
    --                 vmin = Vector(0, 0, 0),
    --                 vmax = Vector(0, 0, 0),
    --                 wmin = Vector(0, 0, 0),
    --                 wmax = Vector(0, 0, 0)
    --             }
    --         }
    --     }
    -- }
}

SWEP.RejectAttachments = {
    -- ["optic_docter"] = true -- stop this attachment from being usable on this gun
}

SWEP.TTT_DoNotAttachOnBuy = false -- don't give all attachments when bought

SWEP.Attachments = {}
-- [1] = {
--     PrintName = "Optic", -- print name
--     DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
--     DefaultAttIcon = Material(),
--     Slot = "pic_sight", -- what kind of attachments can fit here
--     MergeSlots = {}, -- these other slots will be merged into this one.
--     Bone = "sight", -- relevant bone any attachments will be mostly referring to
--     WMBone = "ValveBiped.Bip01_L_Hand", -- set it to change parent bone of attachment WM
--     KeepBaseIrons = false,
--     ExtraSightDist = 0,
--     Offset = {
--         vpos = Vector(0, 0, 0), -- offset that the attachment will be relative to the bone
--         vang = Angle(0, 0, 0),
--         wpos = Vector(0, 0, 0), -- same, for the worldmodels
--         wang = Angle(0, 0, 0)
--     },
--     RejectAttachments = {}, -- specific blacklist of attachments this slot cannot accept. Needs to be like {"optic_mrs" = true}
--     VMScale = Vector(1, 1, 1),
--     WMScale = Vector(1, 1, 1),
--     SlideAmount = { -- how far this attachment can slide in both directions.
--         -- overrides Offset.
--         vmin = Vector(0, 0, 0),
--         vmax = Vector(0, 0, 0),
--         wmin = Vector(0, 0, 0),
--         wmax = Vector(0, 0, 0),
--     },
--     CorrectiveAng = Vector(1, 1, 1), -- okay, I know I said sights were pain-free.
--     CorrectivePos = Vector(0, 0, 0), -- that won't always be the case. Use these to fix it. Issues mainly crop up in case of sights parented to bones that are not a root bone.
--     InstalledEles = {"toprail"}, -- activate these AttachmentElements if something is installed
--     DefaultEles = {""} -- activeate these AttachmentElements *unless* something is installed
--     Hidden = false, -- attachment cannot be seen in customize menu
--     Integral = false, -- attachment is assumed never to change
--     RandomChance = 1, -- multiplies chance this slot will get a random attachment
--     DoNotRandomize = false,
--     NoWM = false, -- do not make this show up on worldmodel
--     NoVM = false, -- what do *you* think this one does?
--     FreeSlot = false, -- slot does not count towards attachment capacity
--     -- ABOUT THE FLAG SYSTEM:
--     -- Attachments and slots can give flags
--     -- All attachments automatically give themselves as a flag, e.g. "optic_mrs"
--     -- If requirements are not satisfied, the slot or attachment will not be attachable
--     ExcludeFlags = {}, -- if the weapon has this flag, hide this slot
--     RequireFlags = {}, -- if the weapon does not have all these flags, hide this slot
--     GivesFlags = {} -- give these slots if something is installed here
--     DefaultFlags = {} -- give these slots UNLESS something is installed here
--     HideIfBlocked = false, -- If flag requirements are not met, do not show the attachment at all
-- }

-- ready: deploy first time
-- draw
-- holster
-- reload
-- fire
-- cycle (for bolt/pump actions)
-- bash
-- fix
-- enter_bipod
-- exit_bipod
-- enter_sight
-- exit_sight
-- a_to_b: switch from firemode a to firemode b. e.g.: 1_to_2
-- idle
-- idle_sights
-- idle_sprint
-- idle_bipod
-- enter_inspect
-- idle_inspect
-- exit_inspect
-- enter_ubgl
-- exit_ubgl
-- idle_ubgl

-- you can append suffixes for different states
-- append list:

-- _iron, _sights, or _sight     for sighted variation
-- _sprint                       for sprinting variation
-- _bipod                        for bipod variation
-- _empty                        for empty variation
-- _jammed                       for jammed variation

-- this does not apply to reload animations.

-- !! they MUST be in the order of this list.
-- example: fire_iron_bipod_empty

-- use SWEP/wep.Hook_TranslateAnimation, same as in attachment, to do even more behaviours
-- use SWEP/wep.Hook_SelectReloadAnimation to change the reload animation
-- use SWEP/wep.Hook_SelectInsertAnimation to change the shotgun reload insert animation
-- use SWEP/wep.Hook_SelectFireAnimation to change the fire animation
-- use SWEP/wep.Hook_SelectCycleAnimation to change the cycle/pump animation
-- use SWEP/wep.Hook_SelectBashAnim to change the bash animation
-- use SWEP/wep.Hook_SelectJamAnim to change the jam animation

-- which sequence to derive the sight autosolver from.
SWEP.AutosolveSourceSeq = "idle"

-- Disclaimer: LHIK is *actually* a type of forward kinematics.
-- If you prefer, LHIK can stand for "Left Hand Individual Kinematics" or some shit

SWEP.Animations = {
    -- ["idle"] = {
    --     Source = "idle",
    --     Time = 10
    -- },
    -- ["draw"] = {
    --     RestoreAmmo = 1, -- only used by shotgun empty insert reload
    --     Source = "deploy",
    --     RareSource = "", -- 1/RareSourceChance of playing this animation instead
    --     RareSourceChance = 100, -- Chance the rapper
    --     Time = 0.5, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    --     Mult = 1, -- Multiplies the rate of animation.
    --     TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, -- third person animation to play when this animation is played
    --     TPAnimStartTime = 0, -- when to start it from
    --     Checkpoints = {}, -- time checkpoints. If weapon is unequipped, the animation will continue to play from these checkpoints when reequipped.
    --     ShellEjectAt = 0, -- animation includes a shell eject at these times
    --     LHIKIn = 0.25, -- In/Out controls how long it takes to switch to regular animation.
    --     LHIKOut = 0.25, -- (not actually inverse kinematics)
    --     LHIKEaseIn = 0.1, -- how long LHIK eases in.
    --     LHIKEaseOut = 0.1, -- if no value is specified then ease = lhikin
    --     LHIKTimeline = { -- allows arbitrary LHIK values to be interpolated between
    --         {
    --             t = 0.1,
    --             lhik = 0,
    --         },
    --         {
    --             t = 0.25,
    --             lhik = 1
    --         }
    --     },
    --     LHIK = true, -- basically disable foregrips on this anim
    --     SoundTable = {
    --         {
    --             s = "", -- sound; can be string or table
    --             p = 100, -- pitch
    --             v = 75, -- volume
    --             t = 1, -- time at which to play relative to Animations.Time
    --             c = CHAN_ITEM, -- channel to play the sound

    --             -- Can also play an effect at the same time
    --             e = "", -- effect name
    --             att = nil, -- attachment, defaults to shell attachment
    --             mag = 100, -- magnitude
    --             -- also capable of modifying bodygroups
    --             ind = 0,
    --             bg = 0,
    --             -- and poseparams
    --             pp = "pose",
    --             ppv = 0.25,
    --         }
    --     },
    --     ViewPunchTable = {
    --         {
    --             p = Vector(0, 0, 0),
    --             t = 1
    --         }
    --     },
    --     ProcDraw = false, -- for draw/deploy animations, always procedurally draw in addition to playing animation
    --     ProcHolster = false, -- procedural holster weapon, THEN play animation
    --     LastClip1OutTime = 0, -- when should the belt visually replenish on a belt fed
    --     MinProgress = 0, -- how much time in seconds must pass before the animation can be cancelled
    --     ForceEmpty = false, -- Used by empty shotgun reloads that load rounds to force consider the weapon to still be empty.
    --     ForceCamReset = false, -- Use the first frame of the sequence as starting angles for the cambone.
    -- }
}

-- don't change any of this stuff

SWEP.Primary.Automatic = true
SWEP.Primary.DefaultClip = -1
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.DrawCrosshair = true
SWEP.m_WeaponDeploySpeed = 80.08135 -- 8008135 boobies is funny but it'll bitch in console :(
        -- We don't do that here

SWEP.ArcCW = true
SWEP.BurstCount = 0
SWEP.AnimQueue = {}
SWEP.FiremodeIndex = 1
SWEP.UnReady = true
SWEP.EventTable = {
    [1] = {} -- for every overlapping one, a new one is made -- checked to be removed afterwards, except 1
}

SWEP.ProneMod_DisableTransitions = true

SWEP.DrawWeaponInfoBox = false
SWEP.BounceWeaponIcon = false

if CLIENT or game.SinglePlayer() then

SWEP.RecoilAmount = 0
SWEP.RecoilAmountSide = 0
SWEP.RecoilPunchBack = 0
SWEP.RecoilPunchUp = 0
SWEP.RecoilPunchSide = 0
SWEP.HammerDown = false

SWEP.LHIKTimeline = nil
SWEP.LHIKStartTime = 0
-- {number starttime, number intime, number outtime, number finishouttime}
end

SWEP.Bodygroups = {} -- [0] = 1, [1] = 0...
-- SWEP.RegularClipSize = 0

local searchdir = "weapons/arccw_base"

local function autoinclude(dir)
    local files, dirs = file.Find(searchdir .. "/*.lua", "LUA")

    for _, filename in pairs(files) do
        if filename == "shared.lua" then continue end
        local luatype = string.sub(filename, 1, 2)

        if luatype == "sv" then
            if SERVER then
                include(dir .. "/" .. filename)
            end
        elseif luatype == "cl" then
            AddCSLuaFile(dir .. "/" .. filename)
            if CLIENT then
                include(dir .. "/" .. filename)
            end
        else
            AddCSLuaFile(dir .. "/" .. filename)
            include(dir .. "/" .. filename)
        end
    end

    for _, path in pairs(dirs) do
        autoinclude(dir .. "/" .. path)
    end
end

autoinclude(searchdir)

function SWEP:SetupDataTables()
    self:NetworkVar("Int", 0, "NWState")
    self:NetworkVar("Int", 1, "FireMode")
    self:NetworkVar("Int", 2, "BurstCountUM")
    self:NetworkVar("Int", 3, "LastLoad")
    self:NetworkVar("Int", 4, "NthReload")
    self:NetworkVar("Int", 5, "NthShot")

    -- 2 = insert
    -- 3 = cancelling
    -- 4 = insert empty
    -- 5 = cancelling empty
    self:NetworkVar("Int", 6, "ShotgunReloading")
    self:NetworkVar("Int", 7, "MagUpCount")

    self:NetworkVar("Bool", 0, "HeatLocked")
    self:NetworkVar("Bool", 1, "NeedCycle")
    self:NetworkVar("Bool", 2, "InBipod")
    self:NetworkVar("Bool", 3, "InUBGL")
    self:NetworkVar("Bool", 4, "InCustomize")
    self:NetworkVar("Bool", 5, "GrenadePrimed")
    self:NetworkVar("Bool", 6, "NWMalfunctionJam")
    self:NetworkVar("Bool", 7, "UBGLDebounce")

    self:NetworkVar("Float", 0, "Heat")
    self:NetworkVar("Float", 1, "WeaponOpDelay")
    self:NetworkVar("Float", 2, "ReloadingREAL")
    self:NetworkVar("Float", 3, "MagUpIn")
    self:NetworkVar("Float", 4, "NextPrimaryFireSlowdown")
    self:NetworkVar("Float", 5, "NextIdle")
    self:NetworkVar("Float", 6, "Holster_Time")
    self:NetworkVar("Float", 7, "NWSightDelta")
    self:NetworkVar("Float", 8, "NWSprintDelta")
    self:NetworkVar("Float", 9, "NWPriorityAnim")

    self:NetworkVar("Vector", 0, "BipodPos")

    self:NetworkVar("Angle", 0, "BipodAngle")
    self:NetworkVar("Angle", 1, "FreeAimAngle")
    self:NetworkVar("Angle", 2, "LastAimAngle")

    self:NetworkVar("Entity", 0, "Holster_Entity")

    self:SetNWSightDelta(1)
end

function SWEP:OnRestore()
    self:SetNthReload(0)
    self:SetNthShot(0)
    self:SetBurstCountUM(0)
    self:SetReloadingREAL(0)
    self:SetWeaponOpDelay(0)
    self:SetMagUpIn(0)
    self:SetNWPriorityAnim(0)

    self:KillTimers()
    self:Initialize()

    self.UnReady = false
end


function SWEP:SetReloading(v)
    if isbool(v) then
        if v then
            self:SetReloadingREAL(math.huge)
        else
            self:SetReloadingREAL(-math.huge)
        end
    elseif isnumber(v) and v > self:GetReloadingREAL() then
        self:SetReloadingREAL( v )
    end
end

function SWEP:GetReloading()
    local decide

    if self:GetReloadingREAL() > CurTime() then
        decide = true
    else
        decide = false
    end

    self:GetBuff_Hook("Hook_GetReloading", decide)

    return decide
end

function SWEP:SetBurstCount(b)
    self:SetBurstCountUM(b)
end

function SWEP:GetBurstCount()
    return self:GetBuff_Hook("Hook_GetBurstCount", self:GetBurstCountUM()) or self:GetBurstCountUM() or 0
end

function SWEP:SetState(v)
    self:SetNWState(v)
    if !game.SinglePlayer() and CLIENT then self.State = v end
end

function SWEP:GetState(v)
    if !game.SinglePlayer() and CLIENT and self.State then return self.State end
    return self:GetNWState(v)
end

function SWEP:IsProne()
    if PRONE_INPRONE then
        return self:GetOwner().IsProne and self:GetOwner():IsProne()
    else
        return false
    end
end

-- BarrelHitWall is known to cause viewmodel flickering on certain playermodels if called during VM position function (a270cc9)
local hitwallcache
function SWEP:BarrelHitWall()

    local len = self:GetBuff("BarrelLength")
    if len == 0 or !ArcCW.ConVars["override_nearwall"]:GetBool()
            or (vrmod and vrmod.IsPlayerInVR(self:GetOwner()))
            or (self:GetOwner():IsPlayer() and self:GetOwner():InVehicle()) then
        hitwallcache = {0, CurTime()}
    end

    if !hitwallcache or hitwallcache[2] ~= CurTime() then

        local offset = self:GetBuff("BarrelOffsetHip")

        if self:GetState() == ArcCW.STATE_SIGHTS then
            offset = LerpVector(self:GetSightDelta(), self:GetBuff("BarrelOffsetSighted"), offset)
        end

        local dir = self:GetOwner():EyeAngles()
        local src = self:GetOwner():EyePos()
        local r, f, u = dir:Right(), dir:Forward(), dir:Up()

        for i = 1, 3 do
            src[i] = src[i]
                    + r[i] * offset[1]
                    + f[i] * offset[2]
                    + u[i] * offset[3]
        end

        local filter = {self:GetOwner()}

        table.Add(filter, self.Shields)

        local tr = util.TraceLine({
            start = src,
            endpos = src + (f * len),
            filter = filter,
            mask = MASK_SOLID
        })

        if tr.Hit and !tr.Entity.ArcCWProjectile then
            --local l = (tr.HitPos - src):Length()
            --hitwallcache = {math.Clamp(1 - l / len, 0, 1), CurTime()}
            hitwallcache = {1 - tr.Fraction, CurTime()}
        else
            hitwallcache = {0, CurTime()}
        end
    end

    return hitwallcache[1] or 0
end

function SWEP:GetBarrelNearWall()
    return hitwallcache and hitwallcache[1] or 0
end

SWEP.CL_SightDelta = 1
function SWEP:SetSightDelta(d)
    if !game.SinglePlayer() and CLIENT then self.CL_SightDelta = d end
    self:SetNWSightDelta(d)
end

function SWEP:GetSightDelta()
    if !game.SinglePlayer() and CLIENT then return self.CL_SightDelta end
    return self:GetNWSightDelta()
end

SWEP.CL_SprintDelta = 0
function SWEP:SetSprintDelta(d)
    if !game.SinglePlayer() and CLIENT then self.CL_SprintDelta = d end
    self:SetNWSprintDelta(d)
end

function SWEP:GetSprintDelta()
    if !game.SinglePlayer() and CLIENT then return self.CL_SprintDelta end
    return self:GetNWSprintDelta()
end

SWEP.CL_MalfunctionJam = false
function SWEP:SetMalfunctionJam(d)
    if !game.SinglePlayer() and CLIENT then self.CL_MalfunctionJam = tobool(d) end
    self:SetNWMalfunctionJam(d)
end

function SWEP:GetMalfunctionJam()
    if !game.SinglePlayer() and CLIENT then return self.CL_MalfunctionJam end
    return self:GetNWMalfunctionJam()
end

-- DIRTY OPTIMIZATION TRICK: NeedCycle is reused for grenades!
function SWEP:SetGrenadeAlt(d)
    if !self.Throwing then return end
    self:SetNeedCycle(d)
end

function SWEP:GetGrenadeAlt()
    if !self.Throwing then return false end
    return self:GetNeedCycle()
end

function SWEP:SetPriorityAnim(v)
    if isbool(v) then
        if v then
            self:SetNWPriorityAnim(math.huge)
        else
            self:SetNWPriorityAnim(-math.huge)
        end
    elseif isnumber(v) and v > self:GetNWPriorityAnim() then
        self:SetNWPriorityAnim(v)
    end
end

function SWEP:GetPriorityAnim()
    local decide = self:GetNWPriorityAnim() > CurTime()

    -- Reloading is always a priority animation
    if !decide then decide = self:GetReloading() end

    self:GetBuff_Hook("Hook_GetPriorityAnim", decide)

    return decide
end
--addons/[binbon]arccw_modify/lua/weapons/arccw_base/cl_hud.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/weapons/arccw_base/sh_customize.lua:
local translate = ArcCW.GetTranslation

local function ScreenScaleMulti(input)
    return ScreenScale(input) * ArcCW.ConVars["hud_size"]:GetFloat()
end

local temp = 0
local SolidBlack = Color(temp, temp, temp)
-- don't fucking mess with the shadow, makes the menu hurt your goddamn eyes

local function DrawTextRot(span, txt, x, y, tx, ty, maxw, only)
    local tw, th = surface.GetTextSize(txt)

    if tw > maxw then
        local realx, realy = span:LocalToScreen(x, y)
        render.SetScissorRect(realx, realy, realx + maxw, realy + (th * 2), true)

        if !only then
            span.TextRot = span.TextRot or 0
            span.StartTextRot = span.StartTextRot or CurTime()
            span.TextRotState = span.TextRotState or 0 -- 0: start, 1: moving, 2: end
            if span.TextRotState == 0 then
                span.TextRot = 0
                if span.StartTextRot < CurTime() - 2 then
                    span.TextRotState = 1
                end
            elseif span.TextRotState == 1 then
                span.TextRot = span.TextRot + (FrameTime() * ScreenScaleMulti(16))
                if span.TextRot >= (tw - maxw) + ScreenScaleMulti(8) then
                    span.StartTextRot = CurTime()
                    span.TextRotState = 2
                end
            elseif span.TextRotState == 2 then
                if span.StartTextRot < CurTime() - 2 then
                    span.TextRotState = 0
                    span.StartTextRot = CurTime()
                end
            end
        end
        surface.SetTextPos(tx - span.TextRot, ty)
        surface.DrawText(txt)
        render.SetScissorRect(0, 0, 0, 0, false)
    else
        surface.DrawText(txt)
    end
end


function SWEP:ToggleCustomizeHUD(ic)
    if ic and self:GetState() == ArcCW.STATE_SPRINT then return end
    if self:GetReloading() then ic = false end
    if self:GetState() == ArcCW.STATE_DISABLE then return end

    local noinspect = (CLIENT and ArcCW.ConVars["noinspect"]:GetBool()) or (SERVER and self:GetOwner():GetInfoNum("arccw_noinspect", 0) > 0)

    if ic then
        if (self:GetNextPrimaryFire() + 0.1) >= CurTime() then return end

        self:SetState(ArcCW.STATE_CUSTOMIZE)
        self:ExitSights()
        self:SetShouldHoldType()
        self:ExitBipod()
        if !noinspect then
            self:PlayAnimation(self:SelectAnimation("enter_inspect"), nil, true, nil, nil, true, false)
        end

        if CLIENT then
            self:OpenCustomizeHUD()
        end
    else
        self:SetState(ArcCW.STATE_IDLE)
        self.Sighted = false
        self.Sprinted = false
        self:SetShouldHoldType()

        if !noinspect then
            self:PlayAnimation(self:SelectAnimation("exit_inspect"), nil, true, nil, nil, true, false)
        end

        if CLIENT then
            self:CloseCustomizeHUD()
            self:SendAllDetails()
        end
    end
end

if CLIENT then

local function multlinetext(text, maxw, font)
    local content = {}
    local tline = ""
    local x = 0
    surface.SetFont(font)

    local newlined = string.Split(text, "\n")

    for _, line in pairs(newlined) do
        local words = string.Split(line, " ")

        for _, word in pairs(words) do
            local tx = surface.GetTextSize(word)

            if x + tx >= maxw then
                table.insert(content, tline)
                tline = ""
                x = surface.GetTextSize(word)
            end

            tline = tline .. word .. " "

            x = x + surface.GetTextSize(word .. " ")
        end

        table.insert(content, tline)
        tline = ""
        x = 0
    end

    -- local space_len = surface.GetTextSize(" ")

    -- for _, word in pairs(string.Split(text, " ")) do
    --     if word == "\n" then
    --         table.insert(content, line)
    --         line = ""
    --         x = 0
    --     else
    --         x = x + surface.GetTextSize(word)

    --         if x >= limitx then
    --             table.insert(content, line)
    --             line = ""
    --             x = 0
    --             x = x + surface.GetTextSize(word)
    --         end

    --         line = line .. word .. " "

    --         x = x + space_len

    --         -- print(word .. " at " .. tostring(x))
    --     end
    -- end

    -- table.insert(content, line)

    return content
end

-- Same snippet of code in Paint() moved to its own function so the button won't be added if it's not valid to begin with
function SWEP:ValidateAttachment(attname, attslot, i)
    if !self:IsValid() or !self.Attachments then return false end
    local atttbl = ArcCW.AttachmentTable[attname]
    if !atttbl then return true, nil, nil, nil end

    attslot = attslot or self.Attachments[i]

    local show = true
    local showqty = true
    local installed = false
    local blocked = !self:CheckFlags(atttbl.ExcludeFlags, atttbl.RequireFlags)
    local owned = self:PlayerOwnsAtt(attname)

    if !ArcCW:SlotAcceptsAtt(attslot.Slot or "", self, attname) then
        blocked = true
    end

    if !atttbl or atttbl.Free then
        showqty = false
    end

    if ArcCW.ConVars["attinv_free"]:GetBool() then
        showqty = false
    end

    -- if !owned then
    --     showqty = false
    -- end

    if ArcCW.ConVars["attinv_lockmode"]:GetBool() then
        showqty = false
    end

    -- orighas checks if the original slot accepts this attachment.
    -- If the original slot is ok but the mergeslot that has the same attachment is not, we're still okay
    local orighas = ArcCW:SlotAcceptsAtt(self.Attachments[i], self, attname) and self:CheckFlags(self.Attachments[i].ExcludeFlags, self.Attachments[i].RequireFlags)

    if attslot.Installed == attname then
        installed = true
    end

    if attname == "" and !attslot.Installed then
        installed = true

        for _, slot in pairs(attslot.MergeSlots or {}) do
            if self.Attachments[slot].Installed then
                installed = false
                break
            end
        end
    end

    for _, slot in pairs(attslot.MergeSlots or {}) do
        if !slot then continue end
        if !self.Attachments[slot] then continue end
        if !blocked and ArcCW:SlotAcceptsAtt(self.Attachments[slot], self, attname) and
                !self:CheckFlags(self.Attachments[slot].ExcludeFlags, self.Attachments[slot].RequireFlags) and
                !orighas then
            blocked = true
            if self.Attachments[slot].HideIfBlocked then
                show = false
            end
            break
        end
        if self.Attachments[slot].Installed == attname then
            installed = true
            break
        end
    end

    if blocked and atttbl and atttbl.HideIfBlocked then
        show = false
    end

    if !owned and atttbl and atttbl.HideIfUnavailable then
        show = false
    end

    if !owned and ArcCW.ConVars["attinv_hideunowned"]:GetBool() then
        show = false
    end

    return show, installed, blocked, showqty
end

function SWEP:OpenCustomizeHUD()
    if self:GetPriorityAnim() then return end
    if IsValid(ArcCW.InvHUD) then
        ArcCW.InvHUD:Show()
        -- ArcCW.InvHUD:RequestFocus()
    else
        --if GetConVar("arccw_dev_cust2beta"):GetBool() then self:CreateCustomize2HUD() else self:CreateCustomizeHUD() end
        self:CreateCustomize2HUD()
        gui.SetMousePos(ScrW() / 2, ScrH() / 2)
    end

    ArcCW.Inv_Hidden = false
    gui.EnableScreenClicker(true)

    if ArcCW.ConVars["cust_sounds"]:GetBool() then surface.PlaySound("weapons/arccw/extra.wav") end

end

function SWEP:CloseCustomizeHUD( hide )
    if IsValid(ArcCW.InvHUD) then
        --if !GetConVar("arccw_dev_cust2beta"):GetBool() then
        if false then
            ArcCW.InvHUD:Hide()
            ArcCW.InvHUD:Clear()
            if vrmod and vrmod.MenuExists( "ArcCW_Customize" ) then
                vrmod.MenuClose( "ArcCW_Customize" )
            end
            if !hide then
                ArcCW.InvHUD:Remove()
            end
        else
            -- The new hud fades out instead of commiting sudoku, only do this if we're debugging
            if ArcCW.ConVars["dev_removeonclose"]:GetBool() then
                ArcCW.InvHUD:Remove()
            end
        end

        if !hide then
            gui.EnableScreenClicker(false)
        end
        ArcCW.Inv_Hidden = false

        if ArcCW.ConVars["cust_sounds"]:GetBool() then surface.PlaySound("weapons/arccw/extra2.wav") end
    end
end

local defaultatticon = Material("arccw/hud/atts/default.png", "smooth mips")
local blockedatticon = Material("arccw/hud/atts/blocked.png", "smooth mips")
local activeslot = nil
local bird = Material("arccw/hud/arccw_bird.png", "mips smooth")

SWEP.InAttMenu = false

function SWEP:CreateCustomizeHUD()
    local barsize = ScreenScaleMulti(160)
    local airgap = ScreenScaleMulti(16)
    local smallgap = ScreenScaleMulti(2)
    local linesize = ScreenScaleMulti(1)
    local buttonsize = ScreenScaleMulti(32)
    local fg_col = Color(255, 255, 255, 255)
    local bg_col = Color(0, 0, 0, 150)

    if !self:IsValid() then return end

    self.InAttMenu = false
    activeslot = nil

    local scrw, scrh = ScrW(), ScrH()
    if vrmod and vrmod.IsPlayerInVR(self:GetOwner()) then
        -- Other resolutions seem to cause stretching issues
        scrw = 1366
        scrh = 768
    end

    ArcCW.InvHUD = vgui.Create("DFrame")

            local scrwmult = ArcCW.ConVars["hud_deadzone_x"]:GetFloat() * ScrW()
            local scrhmult = ArcCW.ConVars["hud_deadzone_y"]:GetFloat() * ScrH()

    scrw, scrh = scrw - scrwmult, scrh - scrhmult

    ArcCW.InvHUD:SetPos(0, 0)
    ArcCW.InvHUD:SetSize(scrw, scrh)
    ArcCW.InvHUD:Center()
    ArcCW.InvHUD:SetText("")
    ArcCW.InvHUD:SetTitle("")
    ArcCW.InvHUD.Paint = function(span)
        if !IsValid(self) then
            gui.EnableScreenClicker(false)
            span:Remove()
        end

        if --[[self:GetState() != ArcCW.STATE_CUSTOMIZE or]] self:GetReloading() then
            span:Remove()
        end
    end
    ArcCW.InvHUD.ActiveWeapon = self
    ArcCW.InvHUD.OnRemove = function()
        local close = false
        if self:IsValid() and self:GetState() == ArcCW.STATE_CUSTOMIZE then
            close = true
        end

        if LocalPlayer():GetActiveWeapon() != ArcCW.InvHUD.ActiveWeapon then
            close = true
        end

        if close then
            net.Start("arccw_togglecustomize")
            net.WriteBool(false)
            net.SendToServer()

            if IsValid(self) and self.ToggleCustomizeHUD then
                self:ToggleCustomizeHUD(false)
            end
        end

        gui.EnableScreenClicker(false)
    end

    if ArcCW.ConVars["attinv_onlyinspect"]:GetBool() then
        return
    end

    local loadpresets = vgui.Create("DButton", ArcCW.InvHUD)
    loadpresets:SetSize((barsize - ScreenScaleMulti(2)) / 2, ScreenScaleMulti(14))
    loadpresets:SetText("")
    loadpresets:SetPos(scrw - barsize - airgap, airgap)

    loadpresets.OnMousePressed = function(spaa, kc)
        self:CreatePresetMenu()
    end

    loadpresets.Paint = function(spaa, w, h)
        if !self:IsValid() then return end
        if !self.Attachments then return end
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 100)

        if spaa:IsHovered() then
            Bbg_col = Color(255, 255, 255, 100)
            Bfg_col = Color(0, 0, 0, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = (translate("ui.loadpreset"))

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(smallgap, ScreenScaleMulti(1))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end

    local savepresets = vgui.Create("DButton", ArcCW.InvHUD)
    savepresets:SetSize((barsize - ScreenScaleMulti(2)) / 2, ScreenScaleMulti(14))
    savepresets:SetText("")
    savepresets:SetPos(scrw - (barsize / 2) + ScreenScaleMulti(1) - airgap, airgap)

    savepresets.OnMousePressed = function(spaa, kc)
        self:CreatePresetSave()
    end

    savepresets.Paint = function(spaa, w, h)
        if !self:IsValid() then return end
        if !self.Attachments then return end
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 100)

        if spaa:IsHovered() then
            Bbg_col = Color(255, 255, 255, 100)
            Bfg_col = Color(0, 0, 0, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = (translate("ui.savepreset"))

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(smallgap, ScreenScaleMulti(1))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end

    local attcatsy = scrh - ScreenScaleMulti(64) - airgap

    local attcats = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    attcats:SetText("")
    attcats:SetSize(barsize, attcatsy)
    attcats:SetPos(airgap, airgap)
    attcats.Paint = function(span, w, h)
        -- surface.SetDrawColor(bg_col)
        -- surface.DrawRect(0, 0, w, h)
    end

    local triviabox = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    triviabox:SetText("")
    triviabox:SetSize(barsize, scrh - ScreenScaleMulti(64) - (3 * airgap))
    triviabox:SetPos(scrw - barsize - airgap, 2 * airgap)
    triviabox.Paint = function(span, w, h)
        surface.SetDrawColor(bg_col)
        surface.DrawRect(0, 0, w, h)
    end

    local sbar = attcats:GetVBar()
    sbar.Paint = function() end

    sbar.btnUp.Paint = function(span, w, h)
    end

    sbar.btnDown.Paint = function(span, w, h)
    end

    sbar.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(fg_col)
        surface.DrawRect(0, 0, w, h)
    end

    local wpninfo = attcats:Add("DLabel")
    wpninfo:SetSize(barsize, buttonsize)
    wpninfo:SetText("")
    wpninfo:Dock( TOP )
    wpninfo:DockMargin( 0, 0, 0, smallgap )

    wpninfo.Paint = function(span, w, h)
        if !IsValid(self) then return end
        local Bfg_col = fg_col
        local Bbg_col = bg_col

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)
        surface.DrawRect(0, 0, w, h / 2)

        surface.SetDrawColor(Bfg_col)
        surface.DrawRect(0, (h - linesize) / 2, w, linesize)

        surface.SetTextColor(SolidBlack)
        surface.SetTextPos(smallgap, 0)
        surface.SetFont("ArcCW_12_Glow")
        surface.DrawText(translate("name." .. self:GetClass() .. (ArcCW.ConVars["truenames"]:GetBool() and ".true" or "")) or self.PrintName)

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(smallgap, 0)
        surface.SetFont("ArcCW_12")
        surface.DrawText(translate("name." .. self:GetClass() .. (ArcCW.ConVars["truenames"]:GetBool() and ".true" or "")) or self.PrintName)

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(smallgap * 2, (h - linesize) / 2 + smallgap)
        surface.SetFont("ArcCW_12")

        local pick = self:GetPickX()

        if pick <= 0 then
            surface.DrawText(ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Class") or self.Trivia_Class))
        else
            local txt = self:CountAttachments() .. "/" .. pick .. " Attachments"

            surface.DrawText(txt)
        end
    end

    local statbox = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    statbox:SetText("")
    statbox:SetSize(barsize, scrh - ScreenScaleMulti(64) - (3 * airgap))
    statbox:SetPos(scrw - barsize - airgap, 2 * airgap)
    statbox.Paint = function(span, w, h)
        surface.SetDrawColor(bg_col)
        surface.DrawRect(0, 0, w, h)
    end
    statbox:Hide()
    local regenStatList -- early definition so category unequiping can update

    local sbar3 = statbox:GetVBar()
    sbar3.Paint = function() end

    sbar3.btnUp.Paint = function(span, w, h)
    end

    sbar3.btnDown.Paint = function(span, w, h)
    end

    sbar3.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(fg_col)
        surface.DrawRect(0, 0, w, h)
    end

    local attmenuh = scrh - (2 * airgap)

    local attmenu = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    attmenu:SetText("")
    attmenu:SetSize(barsize + ScreenScaleMulti(12), attmenuh)
    attmenu:SetPos(airgap + barsize + smallgap, airgap)
    attmenu.Paint = function(span, w, h)
        -- surface.SetDrawColor(bg_col)
        -- surface.DrawRect(0, 0, w, h)
    end
    attmenu:Hide()

    local sbar4 = attmenu:GetVBar()
    sbar4.Paint = function() end

    sbar4.btnUp.Paint = function(span, w, h)
    end

    sbar4.btnDown.Paint = function(span, w, h)
    end

    sbar4.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(fg_col)
        surface.DrawRect(0, 0, w, h)
    end

    local attslidebox = vgui.Create("DPanel", ArcCW.InvHUD)
    attslidebox:SetSize(barsize, ScreenScaleMulti(20))
    attslidebox:SetPos(scrw - barsize - airgap, scrh - ScreenScaleMulti(64) - (1 * airgap))
    attslidebox.Paint = function(span, w, h)
        surface.SetDrawColor(bg_col)
        surface.DrawRect(0, 0, w, h)

        surface.SetTextColor(fg_col)
        surface.SetFont("ArcCW_6")
        surface.SetTextPos(smallgap, smallgap)
        surface.DrawText(translate("ui.position"))
    end

    local attslider = vgui.Create("DSlider", attslidebox)
    attslider:SetPos(ScreenScaleMulti(4), ScreenScaleMulti(12))
    attslider:SetSize(barsize - ScreenScaleMulti(4 * 2), ScreenScaleMulti(4))

    attslider.Paint = function(span, w, h)
        surface.SetDrawColor(fg_col)
        surface.DrawRect(0, h / 2, w, ScreenScaleMulti(1))
    end

    local lastslidepos = 0
    local lastsoundtime = 0

    attslider.Knob.Paint = function(span, w, h)
        if !self:IsValid() then return end
        if !self.Attachments then return end

        if span:IsHovered() or attslider:GetDragging() then
            surface.SetDrawColor(fg_col)
            surface.DrawRect((w - ScreenScaleMulti(2)) / 2, 0, ScreenScaleMulti(2), h)
        else
            surface.SetDrawColor(fg_col)
            surface.DrawRect((w - ScreenScaleMulti(1)) / 2, 0, ScreenScaleMulti(1), h)
        end

        if attslider:GetDragging() and activeslot then
            local delta = attslider:GetSlideX()
            if lastslidepos != delta and lastsoundtime <= CurTime() then

                EmitSound("weapons/arccw/dragatt.wav", EyePos(), -2, CHAN_ITEM, 1,75, 0, math.Clamp(delta * 200, 90, 110))

                lastsoundtime = CurTime() + 0.05
            end

            self.Attachments[activeslot].SlidePos = delta
            lastslidepos = delta
        end

        attslider:SetSlideX((self.Attachments[activeslot] or {}).SlidePos or 0.5)
    end

    local og_attsliderknobmr = attslider.Knob.OnMouseReleased

    attslider.Knob.OnMouseReleased = function(span, kc)
        og_attsliderknobmr(span, kc)
        self:SendDetail_SlidePos(activeslot)
        self:SavePreset("autosave")
    end

    attslidebox:Hide()

    local atttogglebtn = vgui.Create("DButton", ArcCW.InvHUD)
    atttogglebtn:SetSize(barsize * 0.25, ScreenScaleMulti(15))
    atttogglebtn:SetPos(scrw - barsize - airgap + barsize * 0.75, scrh - ScreenScaleMulti(64) - (1 * airgap))
    atttogglebtn:SetText("")
    atttogglebtn.OnMousePressed = function(spaa, kc)
        if !self.Attachments[activeslot] then return end
        local catttbl = ArcCW.AttachmentTable[self.Attachments[activeslot].Installed]
        if !catttbl or !catttbl.ToggleStats then return end

        self:ToggleSlot(activeslot)
        --[[]
        self.Attachments[activeslot].ToggleNum = (self.Attachments[activeslot].ToggleNum or 1) + 1
        if self.Attachments[activeslot].ToggleNum > #catttbl.ToggleStats then
            self.Attachments[activeslot].ToggleNum = 1
        end
        self:SendDetail_ToggleNum(activeslot)
        self:AdjustAtts()
        if self:GetHasFlashlights() then
            self:CreateFlashlightsVM()
        end

        EmitSound("weapons/arccw/firemode.wav", EyePos(), -2, CHAN_ITEM, 1,75, 0, 100)
        ]]
    end
    atttogglebtn.Paint = function(spaa, w, h)
        if !self:IsValid() then return end
        if !self.Attachments then return end
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 100)

        if spaa:IsHovered() then
            Bbg_col = Color(255, 255, 255, 100)
            Bfg_col = Color(0, 0, 0, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = (translate("ui.toggle"))
        local catttbl = activeslot and ArcCW.AttachmentTable[self.Attachments[activeslot].Installed]
        if catttbl and catttbl.ToggleStats[self.Attachments[activeslot].ToggleNum]
                and catttbl.ToggleStats[self.Attachments[activeslot].ToggleNum].PrintName then
            txt = ArcCW.TryTranslation(catttbl.ToggleStats[self.Attachments[activeslot].ToggleNum].PrintName)
        end

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(smallgap, ScreenScaleMulti(1))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end

    atttogglebtn:Hide()

    local atttrivia = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    atttrivia:SetSize(barsize, scrh - ScreenScaleMulti(116))
    atttrivia:SetPos(scrw - barsize - airgap, 2 * airgap)
    atttrivia.Paint = function(span, w, h)
        surface.SetDrawColor(bg_col)
        surface.DrawRect(0, 0, w, h)
    end
    atttrivia:Hide()

    local sbar5 = atttrivia:GetVBar()
    sbar5.Paint = function() end

    sbar5.btnUp.Paint = function(span, w, h)
    end

    sbar5.btnDown.Paint = function(span, w, h)
    end

    sbar5.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(fg_col)
        surface.DrawRect(0, 0, w, h)
    end

    local last_atttrivia = nil

    local function atttrivia_do(att, slot)

        if !att then
            last_atttrivia = att
            atttrivia:Hide()
            atttrivia:Clear()
            return
        end

        if att == "" then
            last_atttrivia = att
            atttrivia:Hide()
            atttrivia:Clear()
            return
        end

        if att == last_atttrivia then
            last_atttrivia = att
            return
        end

        atttrivia:Clear()

        last_atttrivia = att

        local atttbl = ArcCW.AttachmentTable[att]

        atttrivia:Show()

        -- att name

        local triv_attname = vgui.Create("DLabel", atttrivia)
            triv_attname:SetSize(barsize, ScreenScaleMulti(16))
            triv_attname:Dock(TOP)
            triv_attname:DockMargin( 0, 0, 0, 0 )
            triv_attname:SetText("")
            triv_attname.Paint = function(span, w, h)
                local txt = multlinetext(translate("name." .. att) or atttbl.PrintName, w, "ArcCW_16")

                c = 0

                for _, i in pairs(txt) do
                    surface.SetFont("ArcCW_16")
                    local tw = surface.GetTextSize(i)

                    surface.SetFont("ArcCW_16_Glow")
                    surface.SetTextPos((smallgap + (w - tw)) / 2, c)
                    surface.SetTextColor(SolidBlack)
                    surface.DrawText(i)

                    surface.SetFont("ArcCW_16")
                    surface.SetTextPos((smallgap + (w - tw)) / 2, c)
                    surface.SetTextColor(fg_col)
                    surface.DrawText(i)

                    c = c + ScreenScaleMulti(16)
                end

                span:SetSize(barsize, c)
            end

        -- att pic

        local triv_pic = vgui.Create("DLabel", atttrivia)
            triv_pic:SetSize(barsize, barsize / 2)
            triv_pic:Dock(TOP)
            triv_pic:DockMargin( 0, 0, 0, smallgap )
            triv_pic:SetText("")
            triv_pic.Paint = function(span, w, h)
                local img = atttbl.Icon or defaultatticon
                if !img or img:IsError() then img = bird end

                surface.SetDrawColor(fg_col)
                surface.SetMaterial(img)
                surface.DrawTexturedRect(h / 2, 0, h, h)
            end

        -- att desc

        desctext = multlinetext(translate("desc." .. att) or atttbl.Description, barsize - smallgap * 2, "ArcCW_8")

        local triv_desc = vgui.Create("DLabel", atttrivia)
        triv_desc:SetSize(barsize, ScreenScaleMulti(8) * (table.Count(desctext) + 1))
        triv_desc:SetText("")
        triv_desc:DockMargin( 0, 0, 0, smallgap )
        triv_desc:Dock(TOP)
        triv_desc.Paint = function(span, w, h)
            local y = ScreenScaleMulti(8)
            for i, line in pairs(desctext) do
                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap * 2, y)
                surface.SetTextColor(fg_col)
                surface.DrawText(line)
                y = y + ScreenScaleMulti(8)
            end
        end

        local neutrals = atttbl.Desc_Neutrals or {}

        local pros, cons = ArcCW:GetProsCons(self, atttbl, self.Attachments[slot].ToggleNum)

        if (pros and #pros or 0) > 0 then

            local triv_pros = vgui.Create("DLabel", atttrivia)
            triv_pros:SetSize(barsize, ScreenScaleMulti(10))
            triv_pros:SetText("")
            triv_pros:Dock(TOP)
            triv_pros.Paint = function(span, w, h)
                surface.SetDrawColor(Color(0, 50, 0, 100))
                surface.DrawRect(0, 0, w, h)

                surface.SetTextColor(Color(125, 200, 125))
                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap, 0)
                surface.DrawText(translate("ui.positives"))
            end

            for _, i in pairs(pros) do
                local triv_pro = vgui.Create("DLabel", atttrivia)
                triv_pro:SetSize(barsize, ScreenScaleMulti(10))
                triv_pro:SetText("")
                triv_pro:Dock(TOP)
                triv_pro.Paint = function(span, w, h)

                    surface.SetTextColor(Color(150, 225, 150))
                    surface.SetFont("ArcCW_8")
                    surface.SetTextPos(smallgap, 0)
                    surface.DrawText(i)
                end
            end
        end

        if (cons and #cons or 0) > 0 then
            local triv_cons = vgui.Create("DLabel", atttrivia)
            triv_cons:SetSize(barsize, ScreenScaleMulti(10))
            triv_cons:SetText("")
            triv_cons:Dock(TOP)
            triv_cons.Paint = function(span, w, h)
                surface.SetDrawColor(Color(50, 0, 0, 100))
                surface.DrawRect(0, 0, w, h)

                surface.SetTextColor(Color(200, 125, 125))
                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap, 0)
                surface.DrawText(translate("ui.negatives"))
            end

            for _, i in pairs(cons) do
                local triv_con = vgui.Create("DLabel", atttrivia)
                triv_con:SetSize(barsize, ScreenScaleMulti(10))
                triv_con:SetText("")
                triv_con:Dock(TOP)
                triv_con.Paint = function(span, w, h)

                    surface.SetTextColor(Color(225, 150, 150))
                    surface.SetFont("ArcCW_8")
                    surface.SetTextPos(smallgap, 0)
                    surface.DrawText(i)
                end
            end
        end

        if #neutrals > 0 then

            local triv_neutrals = vgui.Create("DLabel", atttrivia)
            triv_neutrals:SetSize(barsize, ScreenScaleMulti(10))
            triv_neutrals:SetText("")
            triv_neutrals:Dock(TOP)
            triv_neutrals.Paint = function(span, w, h)
                surface.SetDrawColor(Color(0, 0, 50, 100))
                surface.DrawRect(0, 0, w, h)

                surface.SetTextColor(Color(125, 125, 200))
                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap, 0)
                surface.DrawText(translate("ui.information"))
            end

            for _, i in pairs(neutrals) do
                local triv_neutral = vgui.Create("DLabel", atttrivia)
                triv_neutral:SetSize(barsize, ScreenScaleMulti(10))
                triv_neutral:SetText("")
                triv_neutral:Dock(TOP)
                triv_neutral.Paint = function(span, w, h)

                    surface.SetTextColor(Color(150, 150, 225))
                    surface.SetFont("ArcCW_8")
                    surface.SetTextPos(smallgap, 0)
                    surface.DrawText(ArcCW.TryTranslation(i))
                end
            end
        end
    end

    ArcCW.InvHUD.OnMousePressed = function(span, kc)
        if (kc == MOUSE_LEFT or kc == MOUSE_RIGHT) and
                !triviabox:IsVisible() and !statbox:IsVisible() then
            activeslot = nil
            triviabox:Show()
            statbox:Hide()
            attmenu:Hide()
            self.InAttMenu = false
            atttrivia:Hide()
            attslidebox:Hide()
            atttogglebtn:Hide()
            if ArcCW.ConVars["cust_sounds"]:GetBool() then surface.PlaySound("weapons/arccw/close.wav") end
        end
    end

    for i, k in pairs(self.Attachments) do
        if !k.PrintName then continue end
        if i == "BaseClass" then continue end
        if k.Hidden or k.Blacklisted then continue end
        if k.Integral then continue end

        local attcatb = attcats:Add("DButton")
        if ArcCW.ConVars["hud_embracetradition"]:GetBool() then
            attcatb:SetSize(barsize, buttonsize )
        else
            attcatb:SetSize(barsize, buttonsize / 2)
        end
        attcatb:SetText("")
        attcatb:Dock( TOP )
        attcatb:DockMargin( 0, 0, 0, smallgap )

        attcatb.AttIndex = i
        attcatb.AttSlot = k

        local function attcatb_regen(span)
            local catt = self.Attachments[span.AttIndex].Installed
            local catttbl
            if catt then
                catttbl = ArcCW.AttachmentTable[catt]
            end

            if self.Attachments[span.AttIndex].Installed and self.Attachments[span.AttIndex].SlideAmount and !catttbl.MountPositionOverride then
                attslidebox:Show()
            else
                attslidebox:Hide()
            end

            if self.Attachments[span.AttIndex].Installed and catttbl and catttbl.ToggleStats then
                if attslidebox:IsVisible() then
                    atttogglebtn:SetPos(scrw - barsize - airgap + barsize * 0.75, scrh - ScreenScaleMulti(40) - (1 * airgap))
                else
                    atttogglebtn:SetPos(scrw - barsize - airgap + barsize * 0.75, scrh - ScreenScaleMulti(64) - (1 * airgap))
                end
                atttogglebtn:Show()
            else
                atttogglebtn:Hide()
            end

            attmenu:Clear()

            local atts = {}
            local slots = {i}
            local attCheck = {}

            table.Add(slots, k.MergeSlots or {})

            for _, y in pairs(slots) do
                for _, bruh in pairs(ArcCW:GetAttsForSlot((self.Attachments[y] or {}).Slot, self)) do
                    if attCheck[bruh] then continue end
                    table.insert(atts, {
                        att = bruh,
                        slot = y
                    })
                    attCheck[bruh] = true
                end
            end

            atts[0] = ""

            table.sort(atts, function(a, b)
                a = a.att or ""
                b = b.att or ""
                local atttbl_a = ArcCW.AttachmentTable[a]
                local atttbl_b = ArcCW.AttachmentTable[b]

                local order_a = 0
                local order_b = 0

                order_a = atttbl_a.SortOrder or order_a
                order_b = atttbl_b.SortOrder or order_b

                if order_a == order_b then
                    return (translate("name." .. a) or atttbl_a.PrintName or "") > (translate("name." .. b) or atttbl_b.PrintName or "")
                end

                return order_a > order_b
            end)

            local ca = 0

            for _, att in pairs(atts) do
                local aslot = att
                if istable(att) then
                    aslot = aslot.slot
                    att = att.att
                end
                local owned = self:PlayerOwnsAtt(att)

                if !owned and ArcCW.ConVars["attinv_hideunowned"]:GetBool() then continue end

                local valid, installed, blocked, showqty = self:ValidateAttachment(att, k, i)

                if !valid then continue end

                local attbtn = attmenu:Add("DButton")
                attbtn:SetSize(barsize + ScreenScaleMulti(12), ScreenScaleMulti(14))
                attbtn:SetText("")
                attbtn:Dock( TOP )
                attbtn:DockMargin( 0, 0, 0, smallgap )

                ca = ca + 1

                attbtn.AttName = att

                attbtn.OnMousePressed = function(spaa, kc2)

                    owned = self:PlayerOwnsAtt(spaa.AttName)
                    local installed = false
                    local orighas = ArcCW:SlotAcceptsAtt(self.Attachments[i], self, spaa.AttName) and self:CheckFlags(self.Attachments[i].ExcludeFlags, self.Attachments[i].RequireFlags)

                    local atttbl = ArcCW.AttachmentTable[spaa.AttName]
                    if atttbl then
                        if !self:CheckFlags(atttbl.ExcludeFlags, atttbl.RequireFlags) then return end
                        for _, slot in pairs(k.MergeSlots or {}) do
                            if self.Attachments[slot].Installed then
                                installed = true
                            end

                            if slot and self.Attachments[slot] and
                                    ArcCW:SlotAcceptsAtt(self.Attachments[slot], self, spaa.AttName) and
                                    !self:CheckFlags(self.Attachments[slot].ExcludeFlags, self.Attachments[slot].RequireFlags) and
                                    !orighas then
                                return
                            end
                        end
                    end

                    if kc2 == MOUSE_LEFT and owned then

                        if spaa.AttName == "" then
                            self:DetachAllMergeSlots(span.AttIndex)
                        else
                            self:DetachAllMergeSlots(span.AttIndex, true)
                            self:Attach(aslot, spaa.AttName)
                        end
                    elseif kc2 == MOUSE_RIGHT and spaa.AttName != "" then
                        if span.AttSlot.Installed == spaa.AttName then
                            -- Unequip
                            self:DetachAllMergeSlots(span.AttIndex)
                        elseif installed then
                            self:DetachAllMergeSlots(span.AttIndex)
                        elseif owned then
                            -- Drop attachment
                            if ArcCW.ConVars["attinv_free"]:GetBool() then return end
                            if ArcCW.ConVars["attinv_lockmode"]:GetBool() then return end
                            if ArcCW.ConVars["enable_customization"]:GetInt() < 0 then return end
                            if !ArcCW.ConVars["enable_dropping"]:GetBool() then return end

                            net.Start("arccw_asktodrop")
                                net.WriteUInt(ArcCW.AttachmentTable[spaa.AttName].ID, 24)
                            net.SendToServer()

                            ArcCW:PlayerTakeAtt(self:GetOwner(), spaa.AttName)
                        end
                    end

                    attcatb_regen(span)
                end

                attbtn.Paint = function(spaa, w, h)
                    if !self:IsValid() then return end
                    if !self.Attachments then return end
                    local Bfg_col = Color(255, 255, 255, 255)
                    local Bbg_col = Color(0, 0, 0, 100)
                    local atttbl = ArcCW.AttachmentTable[spaa.AttName]
                    local qty = ArcCW:PlayerGetAtts(self:GetOwner(), spaa.AttName)

                    valid, installed, blocked, showqty = self:ValidateAttachment(att, k, i)
                    if !valid then
                        attbtn:Remove()
                        return
                    end

                    owned = self:PlayerOwnsAtt(spaa.AttName)

                    if !atttbl and ArcCW.AttachmentTable[k.EmptyFallback] then
                        atttbl = ArcCW.AttachmentTable[k.EmptyFallback]
                    elseif !atttbl then
                        atttbl = {
                            PrintName = k.DefaultAttName and ArcCW.TryTranslation(k.DefaultAttName) or translate("attslot.noatt"),
                            Icon = k.DefaultAttIcon or defaultatticon,
                            Free = true
                        }
                    end

                    if spaa:IsHovered() or installed then
                        Bbg_col = Color(255, 255, 255, 100)
                        Bfg_col = Color(0, 0, 0, 255)
                    end

                    if spaa:IsHovered() and installed then
                        Bbg_col = Color(255, 255, 255, 200)
                        Bfg_col = Color(0, 0, 0, 255)
                    end

                    if spaa:IsHovered() then
                        atttrivia_do(spaa.AttName, i)
                    end

                    if !owned and ArcCW.ConVars["attinv_darkunowned"]:GetBool() then
                        if spaa:IsHovered() then
                            Bbg_col = Color(50, 50, 50, 150)
                            Bfg_col = Color(150, 150, 150, 255)
                        else
                            Bbg_col = Color(20, 20, 20, 150)
                            Bfg_col = Color(150, 150, 150, 255)
                        end
                    elseif !owned or blocked then
                        if spaa:IsHovered() then
                            Bbg_col = Color(125, 25, 25, 150)
                            Bfg_col = Color(150, 50, 50, 255)
                        else
                            Bbg_col = Color(75, 0, 0, 150)
                            Bfg_col = Color(150, 50, 50, 255)
                        end
                    end

                    local max = atttbl.Max

                    if max then
                        local amt = 0

                        for i2, k2 in pairs(self.Attachments) do
                            if k2.Installed == spaa.AttName then
                                amt = amt + 1
                            end
                        end

                        if amt >= max and self.Attachments[i].Installed != spaa.AttName then
                            if spaa:IsHovered() then
                                Bbg_col = Color(125, 25, 25, 150)
                                Bfg_col = Color(150, 50, 50, 255)
                            else
                                Bbg_col = Color(75, 0, 0, 150)
                                Bfg_col = Color(150, 50, 50, 255)
                            end
                        end
                    end

                    surface.SetDrawColor(Bbg_col)
                    surface.DrawRect(0, 0, w, h)
                    surface.DrawRect(0, 0, h * 1.5, h)

                    surface.SetDrawColor(Bfg_col)
                    surface.DrawRect((h * 1.5) - (linesize / 2), 0, linesize, h)

                    local txt = translate("name." .. spaa.AttName) or atttbl.PrintName or "???"

                    if showqty then
                        txt = txt .. " (" .. tostring(qty) .. ")"
                    end

                    surface.SetTextColor(Bfg_col)
                    surface.SetTextPos((h * 1.5) + smallgap, ScreenScaleMulti(1))
                    surface.SetFont("ArcCW_12")

                    DrawTextRot(spaa, txt, h * 1.5, 0, (h * 1.5) + smallgap, ScreenScaleMulti(1), w - (h * 1.5))

                    -- surface.DrawText(txt)

                    local icon = k.DefaultAttIcon or defaultatticon
                    if atttbl then
                        icon = atttbl.Icon
                    end
                    if (!icon or icon:IsError()) then icon = bird end

                    surface.SetDrawColor(Bfg_col)
                    surface.SetMaterial(icon)
                    surface.DrawTexturedRect(h / 4, 0, h, h)

                    if blocked then
                        surface.SetDrawColor(color_white)
                        surface.SetMaterial(blockedatticon)
                        surface.DrawTexturedRect(h / 4 - h * 0.1, - h * 0.1, h * 1.2, h * 1.2)
                    end
                end
            end

            local specsize = ca * (ScreenScaleMulti(14) + smallgap)

            attmenu:SetSize(barsize + ScreenScaleMulti(12), math.min(specsize, attmenuh))
        end

        attcatb.OnMousePressed = function(span, kc)
            if !self:CheckFlags(span.AttSlot.ExcludeFlags, span.AttSlot.RequireFlags) then
                return
            end

            if kc == MOUSE_LEFT then
                if activeslot == span.AttIndex then
                    activeslot = nil
                    triviabox:Show()
                    statbox:Hide()
                    attmenu:Hide()
                    self.InAttMenu = false
                    atttrivia:Hide()
                    attslidebox:Hide()
                    atttogglebtn:Hide()
                    surface.PlaySound("weapons/arccw/close.wav")
                else
                    activeslot = span.AttIndex
                    triviabox:Hide()
                    statbox:Hide()
                    attmenu:Show()
                    attslider:SetSlideX(self.Attachments[span.AttIndex].SlidePos)
                    lastslidepos = self.Attachments[span.AttIndex].SlidePos
                    self.InAttMenu = true
                    surface.PlaySound("weapons/arccw/open.wav")

                    span.TextRot = 0
                    span.StartTextRot = CurTime()
                    span.TextRotState = 0

                    if self.Attachments[span.AttIndex].Installed then
                        atttrivia_do(self.Attachments[span.AttIndex].Installed, span.AttIndex)
                    end

                    attcatb_regen(span)
                end
            elseif kc == MOUSE_RIGHT then
                self:DetachAllMergeSlots(span.AttIndex)
                attcatb_regen(span)
                if statbox:IsVisible() then
                    regenStatList()
                end
            end
        end

        attcatb.Paint = function(span, w, h)

            -- Might error when player dies
            if !self or !self.Attachments then return end

            local Bfg_col = Color(255, 255, 255, 255)
            local Bbg_col = Color(0, 0, 0, 100)

            if span:IsHovered() or activeslot == span.AttIndex then
                Bbg_col = Color(255, 255, 255, 100)
                Bfg_col = Color(0, 0, 0, 255)
            end

            if span:IsHovered() and activeslot == span.AttIndex then
                Bbg_col = Color(255, 255, 255, 200)
                Bfg_col = Color(0, 0, 0, 255)
            end

            if self.CheckFlags and !self:CheckFlags(span.AttSlot.ExcludeFlags, span.AttSlot.RequireFlags) then
                Bbg_col = Color(75, 0, 0, 150)
                Bfg_col = Color(150, 50, 50, 255)
            end

            local txt =  ArcCW.TryTranslation(k.PrintName)

            local att_txt = k.DefaultAttName and ArcCW.TryTranslation(k.DefaultAttName) or translate("attslot.noatt")
            local att_icon = k.DefaultAttIcon or defaultatticon

            local installed = k.Installed

            if !installed then
                (k.MergeSlots or {})["BaseClass"] = nil
                for _, slot in pairs(k.MergeSlots or {}) do
                    if self.Attachments[slot] and self.Attachments[slot].Installed then
                        installed = self.Attachments[slot].Installed
                        break
                    elseif !self.Attachments[slot] then
                        print("ERROR! No attachment " .. tostring(slot))
                    end
                end
            end

            if installed then
                local atttbl = ArcCW.AttachmentTable[installed]

                if atttbl.Health then
                    local perc = (self:GetAttachmentHP(i) / self:GetAttachmentMaxHP(i)) * 100
                    perc = math.Round(perc)
                    txt = txt .. " (" .. tostring(perc) .. "%)"
                end
                if !ArcCW.ConVars["hud_embracetradition"]:GetBool() then
                    att_txt = translate("name." .. installed) or atttbl.PrintName

                    if atttbl.Icon then
                        att_icon = atttbl.Icon
                        if (!att_icon or att_icon:IsError()) then att_icon = bird end
                    end
                end
            end

            if ArcCW.ConVars["hud_embracetradition"]:GetBool() then
                surface.SetDrawColor(Bbg_col)
                surface.DrawRect(0, 0, w, h)
                surface.DrawRect(0, 0, w, h / 2)
                surface.DrawRect(w - (1.5 * h), h / 2, 1.5 * h, h / 2)

                surface.SetDrawColor(Bbg_col)
                surface.DrawRect(0, 0, w, h)
                surface.DrawRect(0, 0, w, h / 2)
                surface.DrawRect(w - (1.5 * h), h / 2, 1.5 * h, h / 2)

                surface.SetDrawColor(Bfg_col)
                surface.DrawRect(0, (h - linesize) / 2, w - (1.5 * h), linesize)

                surface.SetTextColor(SolidBlack)
                surface.SetTextPos(smallgap, 0)
                surface.SetFont("ArcCW_12_Glow")
                surface.DrawText(txt)

                surface.SetTextColor(Bfg_col)
                surface.SetTextPos(smallgap, 0)
                surface.SetFont("ArcCW_12")
                surface.DrawText(txt)

                if installed then
                    local atttbl = ArcCW.AttachmentTable[installed]

                    att_txt = translate("name." .. installed) or atttbl.PrintName

                    if atttbl.Icon then
                        att_icon = atttbl.Icon
                        if (!att_icon or att_icon:IsError()) then att_icon = bird end
                    end
                end

                surface.SetTextColor(Bfg_col)
                surface.SetTextPos(smallgap * 2, (h - linesize) / 2 + smallgap)
                surface.SetFont("ArcCW_12")
                DrawTextRot(span, att_txt, 0, h / 2, smallgap * 2, (h - linesize) / 2 + smallgap, w - 1.5 * h)

                surface.SetDrawColor(Bfg_col)
                surface.DrawRect(w - (1.5 * h), 0, linesize, h)

                surface.SetDrawColor(Bfg_col)
                surface.SetMaterial(att_icon)
                surface.DrawTexturedRect(w - (1.25 * h), 0, h, h)
            ----------------------------------------------------------------------
            elseif activeslot == span.AttIndex then
                span:SetSize(barsize, buttonsize)

                surface.SetDrawColor(Bbg_col)
                surface.DrawRect(0, 0, w, h)
                surface.DrawRect(0, 0, w, h / 2)
                surface.DrawRect(w - (1.5 * h), h / 2, 1.5 * h, h / 2)

                surface.SetDrawColor(Bfg_col)
                surface.DrawRect(0, (h - linesize) / 2, w - (1.5 * h), linesize)

                surface.SetTextColor(SolidBlack)
                surface.SetTextPos(smallgap, 0)
                surface.SetFont("ArcCW_12_Glow")
                surface.DrawText(txt)

                surface.SetTextColor(Bfg_col)
                surface.SetTextPos(smallgap, 0)
                surface.SetFont("ArcCW_12")
                surface.DrawText(txt)

                surface.SetTextColor(Bfg_col)
                surface.SetTextPos(smallgap * 2, (h - linesize) / 2 + smallgap)
                surface.SetFont("ArcCW_12")

                DrawTextRot(span, att_txt, 0, h / 2, smallgap * 2, (h - linesize) / 2 + smallgap, w - 1.5 * h)

                surface.SetDrawColor(Bfg_col)
                surface.DrawRect(w - (1.5 * h), 0, linesize, h)

                surface.SetDrawColor(Bfg_col)
                surface.SetMaterial(att_icon)
                surface.DrawTexturedRect(w - (1.25 * h), 0, h, h)
            else
                if installed then
                    local atttbl = ArcCW.AttachmentTable[installed]
                    txt = att_txt

                    if atttbl.Health then
                        local perc = (self:GetAttachmentHP(i) / self:GetAttachmentMaxHP(i)) * 100
                        perc = math.Round(perc)
                        txt = txt .. " (" .. tostring(perc) .. "%)"
                    end
                end

                span:SetSize(barsize, buttonsize / 2)

                surface.SetDrawColor(Bbg_col)
                surface.DrawRect(0, 0, w, h)
                surface.DrawRect(w - (1.5 * h), 0, 1.5 * h, h)

                surface.SetTextColor(SolidBlack)
                surface.SetTextPos(smallgap, 0)
                surface.SetFont("ArcCW_12_Glow")
                -- surface.DrawText(txt)
                DrawTextRot(span, txt, 0, 0, smallgap, 0, w - 1.5 * h)

                surface.SetTextColor(Bfg_col)
                surface.SetTextPos(smallgap, 0)
                surface.SetFont("ArcCW_12")
                DrawTextRot(span, txt, 0, 0, smallgap, 0, w - 1.5 * h, true)

                surface.SetDrawColor(Bfg_col)
                surface.DrawRect(w - (1.5 * h), 0, linesize, h)

                surface.SetDrawColor(Bfg_col)
                surface.SetMaterial(att_icon)
                surface.DrawTexturedRect(w - (1.25 * h), 0, h, h)
            end
        end
    end

    local sbar2 = triviabox:GetVBar()
    sbar2.Paint = function() end

    sbar2.btnUp.Paint = function(span, w, h)
    end

    sbar2.btnDown.Paint = function(span, w, h)
    end

    sbar2.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(fg_col)
        surface.DrawRect(0, 0, w, h)
    end

    local triv_wpnnamelabel = vgui.Create("DLabel", triviabox)
    triv_wpnnamelabel:SetSize(barsize, buttonsize)
    triv_wpnnamelabel:Dock(TOP)
    triv_wpnnamelabel:DockMargin( 0, 0, 0, smallgap )
    triv_wpnnamelabel:SetText("")
    triv_wpnnamelabel.Paint = function(span, w, h)
        if !IsValid(self) then return end
        local txt = translate("name." .. self:GetClass()) or self.PrintName

        surface.SetFont("ArcCW_20")
        local tw, th = surface.GetTextSize(txt)

        surface.SetFont("ArcCW_20_Glow")
        surface.SetTextPos((w - tw) / 2, th / 2)
        surface.SetTextColor(SolidBlack)
        surface.DrawText(txt)

        surface.SetFont("ArcCW_20")
        surface.SetTextPos((w - tw) / 2, th / 2)
        surface.SetTextColor(fg_col)
        surface.DrawText(txt)
    end

    local year = self:GetBuff_Override("Override_Trivia_Year") or self.Trivia_Year

    if isnumber(year) and year < 0 then
        year = tostring(math.abs(year)) .. "BC"
    end

    year = tostring(year)

    local trivia = {
        function() return translate("trivia.class") .. ": " .. ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Class") or self.Trivia_Class) or "Unknown" end,
        function() return translate("trivia.year") .. ": " .. year or "Unknown" end,
        function() return translate("trivia.mechanism") .. ": " .. ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Mechanism") or self.Trivia_Mechanism or "Unknown") end,
        function() return translate("trivia.calibre") .. ": " .. ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Calibre") or self.Trivia_Calibre or "Unknown") end,
        function() return translate("trivia.ammo") .. ": " .. language.GetPhrase(self.Primary.Ammo or self.PrintName) end,
        function() return translate("trivia.country") .. ": " .. ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Country") or self.Trivia_Country or "Unknown") end,
        function() return translate("trivia.manufacturer") .. ": " .. ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Manufacturer") or self.Trivia_Manufacturer or "Unknown") end,
        function() return translate("trivia.clipsize") .. ": " .. self:GetCapacity() end,
        function() return translate("trivia.precision") .. ": " .. self:GetBuff("AccuracyMOA") .. " MOA" end,
        function() return translate("trivia.noise") .. ": " .. (self:GetBuff("ShootVol")) .. "dB" end,
        function() return translate("trivia.recoil") .. ": " .. math.Truncate(self.Recoil * 41.4 * self:GetBuff_Mult("Mult_Recoil"), 1) .. " lb-fps" end,
        function() return translate("trivia.penetration") .. ": " .. math.Round(self:GetBuff("Penetration"), 1) .. "mm" end,
    }

    if !self.ManualAction and !self:GetBuff_Override("Override_ManualAction") then
        table.insert(trivia, function()
            local rpm = math.Round(60 / self:GetFiringDelay())
            return translate("trivia.firerate") .. ": " .. rpm .. "RPM"
        end)
    end

    if !(self:GetBuff_Override("Override_Trivia_Class") or self.Trivia_Class) then
        trivia[1] = nil
    end

    if !(self:GetBuff_Override("Override_Trivia_Year") or self.Trivia_Year) then
        trivia[2] = nil
    end

    if !(self:GetBuff_Override("Override_Trivia_Mechanism") or self.Trivia_Mechanism) then
        trivia[3] = nil
    end

    if !(self:GetBuff_Override("Override_Trivia_Calibre") or self.Trivia_Calibre) then
        trivia[4] = nil
    end

    if !(self:GetBuff_Override("Override_Trivia_Country") or self.Trivia_Country) then
        trivia[6] = nil
    end

    if !(self:GetBuff_Override("Override_Trivia_Manufacturer") or self.Trivia_Manufacturer) then
        trivia[7] = nil
    end

    if self.PrimaryBash then
        trivia[4] = nil
        trivia[5] = nil
        trivia[8] = nil
        trivia[9] = nil
        trivia[10] = nil
        trivia[11] = nil
        trivia[12] = nil
        trivia[13] = nil
    end

    if self.Throwing then
        trivia[4] = nil
        trivia[8] = nil
        trivia[9] = nil
        trivia[10] = nil
        trivia[11] = nil
        trivia[12] = nil
        trivia[13] = nil
    end

    local ft = self:GetBuff_Override("Override_FuseTime") or self.FuseTime

    if ft then
        table.insert(trivia, function() return translate("trivia.fusetime") .. ": " .. tostring(ft) end)
    end

    for _, i in pairs(trivia) do
        if !i then continue end
        local triv_misc = vgui.Create("DLabel", triviabox)
        triv_misc:SetSize(barsize, ScreenScaleMulti(8))
        triv_misc:Dock(TOP)
        triv_misc:SetText("")
        triv_misc:DockMargin( 0, 0, 0, 0 )
        triv_misc.Paint = function(span, w, h)
            if !IsValid(self) then return end
            local txt = i()

            surface.SetFont("ArcCW_8")
            surface.SetTextPos(smallgap, 0)
            surface.SetTextColor(fg_col)
            surface.DrawText(txt)
        end
    end

    -- multlinetext(text, maxw, font)

    local adesctext = multlinetext(ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Desc")) or translate("desc." .. self:GetClass()) or self.Trivia_Desc, barsize - smallgap, "ArcCW_8")

    table.insert(adesctext, "")

    local triv_desc = vgui.Create("DLabel", triviabox)
    triv_desc:SetSize(barsize, ScreenScaleMulti(8) * (table.Count(adesctext) + 1))
    triv_desc:SetText("")
    triv_desc:Dock(TOP)
    triv_desc.Paint = function(span, w, h)
        local y = ScreenScaleMulti(8)
        for _, line in pairs(adesctext) do
            surface.SetFont("ArcCW_8")
            surface.SetTextPos(smallgap, y)
            surface.SetTextColor(fg_col)
            surface.DrawText(line)
            y = y + ScreenScaleMulti(8)
        end
    end

    if !self.ShootEntity and !self.PrimaryBash and !self.Throwing and !self.NoRangeGraph then
        local rangegraph = vgui.Create("DLabel", triviabox)
        rangegraph:SetSize(barsize, ScreenScaleMulti(64))
        rangegraph:SetText("")
        rangegraph:Dock(TOP)
        rangegraph.Paint = function(span, w, h)
            if !IsValid(self) then return end
            local sidegap = 0
            local gx, gy = 0, smallgap
            local gw, gh = w - (2 * sidegap), h - smallgap - ScreenScaleMulti(6)

            local dmgmax = math.Round(self:GetDamage(0))
            local dmgmin = math.Round(self:GetDamage(math.huge))

            local grsh = math.max(dmgmax, dmgmin)

            grsh = math.ceil((grsh / 12) + 1) * 12

            local mingr = self.RangeMin * self:GetBuff_Mult("Mult_Range") * self:GetBuff_Mult("Mult_RangeMin")
            local maxgr = self.Range * self:GetBuff_Mult("Mult_Range")

            if dmgmax < dmgmin then
                maxgr = (self.Range / self:GetBuff_Mult("Mult_Range"))
            end

            maxgr = math.Round(maxgr)

            local grsw = math.ceil((maxgr / 12) + 1) * 12

            local convw = gw / grsw
            local convh = gh / grsh

            local starty = gh - (dmgmax * convh)
            local endy = gh - (dmgmin * convh)
            local startx = mingr * convw
            local endx = maxgr * convw

            surface.SetDrawColor(bg_col)
            surface.DrawRect(gx, gy, gw, gh)

            surface.SetDrawColor(fg_col)

            -- start
            surface.DrawLine(0, gy + starty, gx + startx, gy + starty)
            -- before mid
            surface.DrawLine(gx + startx, gy + starty, gx + endx, gy + endy)
            if mingr != 0 then
                surface.DrawLine(gx + startx, gy+ScreenScaleMulti(2) + starty, gx + startx, gy-ScreenScaleMulti(2) + starty)
            end
            -- long and into the void
            surface.DrawLine(gx + endx, gy + endy, gx + gw, gy + endy)
            surface.DrawLine(gx + endx, gy+ScreenScaleMulti(2) + endy, gx + endx, gy-ScreenScaleMulti(2) + endy)

            -- start dmg
            surface.SetTextColor(fg_col)
            surface.SetFont("ArcCW_6")
            surface.SetTextPos(0, gy + starty - ScreenScaleMulti(7) - 1)
            surface.DrawText(tostring(dmgmax) .. "DMG")

            -- end dmg
            surface.SetTextColor(fg_col)
            surface.SetFont("ArcCW_6")

            local dtw = surface.GetTextSize(tostring(dmgmin) .. "DMG")
            surface.SetTextPos(gx + gw - dtw, gy + endy - ScreenScaleMulti(7) - 1)
            surface.DrawText(tostring(dmgmin) .. "DMG")

            -- start range
            surface.SetTextColor(fg_col)
            surface.SetFont("ArcCW_6")
            surface.SetTextPos(sidegap, smallgap + gh)
            surface.DrawText("0m")

            -- before mid range
            if mingr != 0 then
                surface.SetTextColor(fg_col)
                surface.SetFont("ArcCW_6")
                local btw = surface.GetTextSize(tostring(mingr) .. "m")
                surface.SetTextPos(gx + startx - (btw / 2), smallgap + gh)
                surface.DrawText(tostring(mingr) .. "m")
            end

            -- mid range
            surface.SetTextColor(fg_col)
            surface.SetFont("ArcCW_6")
            local mtw = surface.GetTextSize(tostring(maxgr) .. "m")
            surface.SetTextPos(gx + endx - (mtw / 2), smallgap + gh)
            surface.DrawText(tostring(maxgr) .. "m")

            -- end range
            surface.SetTextColor(fg_col)
            surface.SetFont("ArcCW_6")
            local rtw = surface.GetTextSize(tostring(grsw) .. "m")
            surface.SetTextPos(w - sidegap - rtw, smallgap + gh)
            surface.DrawText(tostring(grsw) .. "m")

            local mousex, mousey = span:CursorPos()

            if mousex > gx and mousex < (gx + gw) and
                    (mousey > gy and mousey < (gy + gh)) then
                local mouser = (mousex - gx) / convw

                local shy
                local shdmg

                if mouser < mingr then
                    shy = starty
                    shdmg = dmgmax
                elseif mouser < maxgr then
                    local delta = mouser / maxgr
                    shy = Lerp(delta, starty, endy)
                    shdmg = Lerp(delta, dmgmax, dmgmin)
                else
                    shy = endy
                    shdmg = dmgmin
                end

                surface.SetDrawColor(Color(fg_col.r, fg_col.g, fg_col.b, 150))
                surface.DrawLine(gx, gy + shy, gw, gy + shy)
                surface.DrawLine(mousex, gy, mousex, gh + gy)

                shy = shy + ScreenScaleMulti(4)

                mouser = math.Round(mouser)
                shdmg = math.Round(shdmg)

                local alignleft = true

                surface.SetFont("ArcCW_6")
                local twmr = surface.GetTextSize(tostring(mouser) .. "m")
                local twmb = surface.GetTextSize(tostring(shdmg) .. "DMG")

                if mousex < math.max(twmr, twmb) + ScreenScaleMulti(2) then
                    alignleft = false
                end

                surface.SetTextColor(fg_col)
                surface.SetFont("ArcCW_6")
                if alignleft then
                    surface.SetTextPos(mousex - ScreenScaleMulti(2) - twmr, shy)
                else
                    surface.SetTextPos(mousex + ScreenScaleMulti(2), shy)
                end
                surface.DrawText(tostring(mouser) .. "m")

                surface.SetTextColor(fg_col)
                surface.SetFont("ArcCW_6")
                if alignleft then
                    surface.SetTextPos(mousex - ScreenScaleMulti(2) - twmb, ScreenScaleMulti(2) + gy)
                else
                    surface.SetTextPos(mousex + ScreenScaleMulti(2), ScreenScaleMulti(2) + gy)
                end
                surface.DrawText(tostring(shdmg) .. "DMG")
            end
        end
    end

    local function defaultStatFunc(name, unit, round)
        local orig = self[name]
        if ArcCW.ConVar_BuffMults["Mult_" .. name] then
            orig = orig * GetConVar(ArcCW.ConVar_BuffMults["Mult_" .. name]):GetFloat()
        end
        return math.Round((unit == "%" and 100 or unit == "ms" and 1000 or 1) * orig, round) .. (unit or ""),
               math.Round((unit == "%" and 100 or unit == "ms" and 1000 or 1) * self[name] * self:GetBuff_Mult("Mult_" .. name), round) .. (unit or "")
    end

    local function defaultBetterFunc(name, inverse)
        local mult = self:GetBuff_Mult("Mult_" .. name)
        if ArcCW.ConVar_BuffMults[name] then
            mult = mult / GetConVar(ArcCW.ConVar_BuffMults[name]):GetFloat()
        end
        if inverse then mult = 1 / mult end
        if mult > 1 then return true
        elseif mult < 1 then return false
        else return nil end
    end

    local statList
    regenStatList = function()
        statList = {
            {translate("stat.stat"), "",
                function() return translate("stat.original"), translate("stat.current") end,
                function() return nil end,
            },
            {translate("stat.damage"), translate("stat.damage.tooltip"),
                function()
                    local curNum = self:GetBuff("Num")
                    local orig = math.Round(self.Damage * ArcCW.ConVars["mult_damage"]:GetFloat()) .. (self.Num != 1 and ("×" .. self.Num) or "")
                    local cur = math.Round(self:GetDamage(0) / curNum * ArcCW.ConVars["mult_damage"]:GetFloat()) .. (curNum != 1 and ("×" .. curNum) or "")
                    return orig, cur
                end,
                function()
                    local orig = self.Damage * self.Num * ArcCW.ConVars["mult_damage"]:GetFloat()
                    local cur = self:GetDamage(0)
                    if orig == cur then return nil else return cur > orig end
                end,
            },
            {translate("stat.damagemin"), translate("stat.damagemin.tooltip"),
                function()
                    local curNum = self:GetBuff("Num")
                    local orig = math.Round(self.DamageMin * ArcCW.ConVars["mult_damage"]:GetFloat()) .. (self.Num != 1 and ("×" .. self.Num) or "")
                    local cur = math.Round(self:GetDamage(self.Range) / curNum * ArcCW.ConVars["mult_damage"]:GetFloat()) .. (curNum != 1 and ("×" .. curNum) or "")
                    return orig, cur
                end,
                function()
                    local orig = self.DamageMin * self.Num * ArcCW.ConVars["mult_damage"]:GetFloat()
                    local maxgr = (self:GetBuff("Range"))
                    if math.Round(self:GetDamage(self.Range)) < math.Round(self:GetDamage(0)) then
                        maxgr = (self.Range / self:GetBuff_Mult("Mult_Range"))
                    end
                    local cur = self:GetDamage(maxgr)
                    if orig == cur then return nil else return cur > orig end
                end,
            },
            {translate("stat.range"), translate("stat.range.tooltip"),
                function() return defaultStatFunc("Range", "m") end,
                function() return defaultBetterFunc("Range") end,
            },
            {translate("stat.firerate"), translate("stat.firerate.tooltip"),
                function()

                local orig = math.Round(60 / self.Delay) .. "RPM"
                local cur = math.Round(60 / self:GetFiringDelay()) .. "RPM"

                if self.ManualAction then
                    orig = translate("stat.firerate.manual")
                end
                if self:GetBuff_Override("Override_ManualAction") or self.ManualAction then
                    cur = translate("stat.firerate.manual")
                end

                return orig, cur
                end,
                function()
                    if !self:GetBuff_Override("Override_ManualAction") and !self.ManualAction then
                        return defaultBetterFunc("RPM")
                    end
                    -- Funky calculations for when some manual gun goes automatic
                    if !self.ManualAction and self:GetBuff_Override("Override_ManualAction") == true then
                        return false
                    elseif self.ManualAction and self:GetBuff_Override("Override_ManualAction") == false then
                        return true
                    end
                    return nil
                end,
            },
            {translate("stat.capacity"), translate("stat.capacity.tooltip"),
                function()
                    local m = self.RegularClipSize
                    local m2 = self.Primary.ClipSize
                    local cs = self.ChamberSize
                    local cs2 = self:GetChamberSize()
                    return m .. (cs > 0 and " +" .. cs or ""), m2 .. (cs2 > 0 and " +" .. cs2 or "")
                end,
                function()
                    local m = self.RegularClipSize
                    local m2 = self.Primary.ClipSize
                    local cs = self.ChamberSize
                    local cs2 = self:GetChamberSize()
                    if m + cs == m2 + cs2 then return nil end
                    return m + cs < m2 + cs2
                end,
            },
            {translate("stat.precision"), translate("stat.precision.tooltip"),
                function() return defaultStatFunc("AccuracyMOA", " MOA", 3) end,
                function() return defaultBetterFunc("AccuracyMOA", true) end,
            },
            {translate("stat.hipdisp"), translate("stat.hipdisp.tooltip"),
                function() return defaultStatFunc("HipDispersion", " MOA") end,
                function() return defaultBetterFunc("HipDispersion", true) end,
            },
            {translate("stat.movedisp"), translate("stat.movedisp.tooltip"),
                function() return defaultStatFunc("MoveDispersion", " MOA") end,
                function() return defaultBetterFunc("MoveDispersion", true) end,
            },
            {translate("stat.recoil"), translate("stat.recoil.tooltip"),
                function() return defaultStatFunc("Recoil", nil, 2) end,
                function() return defaultBetterFunc("Recoil", true) end,
            },
            {translate("stat.recoilside"), translate("stat.recoilside.tooltip"),
                function() return defaultStatFunc("RecoilSide", nil, 2) end,
                function() return defaultBetterFunc("RecoilSide", true) end,
            },
            {translate("stat.sighttime"), translate("stat.sighttime.tooltip"),
                function() return defaultStatFunc("SightTime", "ms") end,
                function() return defaultBetterFunc("SightTime", true) end,
            },
            {translate("stat.speedmult"), translate("stat.speedmult.tooltip"),
                function()
                    return math.Round(self.SpeedMult * 100) .. "%", math.Round(math.Clamp(self:GetBuff("SpeedMult") * self:GetBuff_Mult("Mult_MoveSpeed"), 0, 1) * 100) .. "%"
                end,
                function()
                    local mult = self:GetBuff_Mult("Mult_SpeedMult") * self:GetBuff_Mult("Mult_MoveSpeed")
                    if mult == 1 then return nil
                    elseif mult > 1 then return true
                    else return false end
                end,
            },
            {translate("stat.sightspeed"), translate("stat.sightspeed.tooltip"),
                function()
                    return math.Round(self.SightedSpeedMult * 100) .. "%", math.Round(math.Clamp(self:GetBuff("SightedSpeedMult") * self:GetBuff_Mult("Mult_SightedMoveSpeed"), 0, 1) * 100) .. "%"
                end,
                function()
                    local mult = self:GetBuff_Mult("Mult_SightedSpeedMult") * self:GetBuff_Mult("Mult_SightedMoveSpeed")
                    if mult == 1 then return nil
                    elseif mult > 1 then return true
                    else return false end
                end,
            },
            {translate("stat.meleedamage"), translate("stat.meleedamage.tooltip"),
                function() return defaultStatFunc("MeleeDamage") end,
                function() return defaultBetterFunc("MeleeDamage") end,
            },
            {translate("stat.meleetime"), translate("stat.meleetime.tooltip"),
                function() return defaultStatFunc("MeleeTime", "ms", 2) end,
                function() return defaultBetterFunc("MeleeTime", true) end,
            },
            {translate("stat.shootvol"), translate("stat.shootvol.tooltip"),
                function() return defaultStatFunc("ShootVol","dB") end,
                function() return defaultBetterFunc("ShootVol", true) end,
            },
            {translate("stat.barrellen"), translate("stat.barrellen.tooltip"),
                function()
                    local orig = self.BarrelLength
                    local cur = orig + self:GetBuff_Add("Add_BarrelLength")
                    return orig .. "in", cur .. "in"
                end,
                function()
                    local add = self:GetBuff_Add("Add_BarrelLength")
                    if add == 0 then return nil else return add < 0 end
                end,
            },
            {translate("stat.pen"), translate("stat.pen.tooltip"),
                function() return defaultStatFunc("Penetration","mm") end,
                function() return defaultBetterFunc("Penetration") end,
            },
        }

        statbox:Clear()

        for _, i in pairs(statList) do
            if !i then continue end
            local stat_panel = vgui.Create("DPanel", statbox)
            stat_panel:SetSize(barsize, ScreenScaleMulti(10))
            stat_panel:Dock(TOP)
            stat_panel:SetText("")
            stat_panel:DockMargin( 0, ScreenScaleMulti(1), 0, ScreenScaleMulti(1) )
            stat_panel.Paint = function(spaa, w, h)
                local Bbg_col = Color(0, 0, 0, 50)

                if spaa:IsHovered() then
                    Bbg_col = Color(100, 100, 100, 50)
                end

                surface.SetDrawColor(Bbg_col)
                surface.DrawRect(0, 0, w, h)
            end

            local stat_title = vgui.Create("DLabel", stat_panel)
            stat_title:SetSize(barsize * 0.5, ScreenScaleMulti(10))
            stat_title:SetText("")
            stat_title:Dock(LEFT)
            stat_title.Paint = function(span, w, h)
                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap, 0)
                surface.SetTextColor(fg_col)
                surface.DrawText(i[1])
            end

            local origStat, curStat = i[3]()
            local better = i[4]()
            local stat_orig = vgui.Create("DLabel", stat_panel)
            stat_orig:SetSize(barsize * 0.25, ScreenScaleMulti(10))
            stat_orig:SetText("")
            stat_orig:Dock(LEFT)
            stat_orig.Paint = function(span, w, h)
                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap, 0)
                surface.SetTextColor(fg_col)
                surface.DrawText(origStat)
            end
            local stat_cur = vgui.Create("DLabel", stat_panel)
            stat_cur:SetSize(barsize * 0.25, ScreenScaleMulti(10))
            stat_cur:SetText("")
            stat_cur:Dock(LEFT)
            stat_cur.Paint = function(span, w, h)
                local color = better == true and Color(150, 255, 150) or better == false and Color(255, 150, 150) or fg_col

                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap, 0)
                surface.SetTextColor(color)
                surface.DrawText(curStat)
            end
        end
    end

    if !self.Throwing and !self.PrimaryBash and !self.ShootEntity then
        local togglestat = vgui.Create("DButton", ArcCW.InvHUD)
        togglestat:SetSize((barsize - ScreenScaleMulti(2)) / 2, ScreenScaleMulti(14))
        togglestat:SetText("")
        togglestat:SetPos(scrw - barsize - airgap - ScreenScaleMulti(1) - (barsize / 2), airgap)

        togglestat.OnMousePressed = function(spaa, kc)
            if statbox:IsVisible() then
                statbox:Hide()
                triviabox:Show()
            else
                regenStatList()
                statbox:Show()
                triviabox:Hide()
                attmenu:Hide()
                self.InAttMenu = false
                atttrivia:Hide()
                attslidebox:Hide()
                atttogglebtn:Hide()
            end
        end

        togglestat.Paint = function(spaa, w, h)
            if !self:IsValid() then return end
            if !self.Attachments then return end
            local Bfg_col = Color(255, 255, 255, 255)
            local Bbg_col = Color(0, 0, 0, 100)

            if spaa:IsHovered() then
                Bbg_col = Color(255, 255, 255, 100)
                Bfg_col = Color(0, 0, 0, 255)
            end

            surface.SetDrawColor(Bbg_col)
            surface.DrawRect(0, 0, w, h)

            local txt = translate(statbox:IsVisible() and "ui.trivia" or "ui.stats")

            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(smallgap, ScreenScaleMulti(1))
            surface.SetFont("ArcCW_12")
            surface.DrawText(txt)
        end
    end

    if engine.ActiveGamemode() == "terrortown" then
        local gap = airgap

        if GetRoundState() == ROUND_ACTIVE and (LocalPlayer():GetTraitor() or LocalPlayer():GetDetective() or (TTT2 and LocalPlayer().IsShopper and LocalPlayer():IsShopper())) then
            local buymenu = vgui.Create("DButton", ArcCW.InvHUD)
            buymenu:SetSize((barsize - ScreenScaleMulti(2)) / 2, ScreenScaleMulti(14))
            buymenu:SetText("")
            buymenu:SetPos(scrw - barsize - airgap - ScreenScaleMulti(1) - (barsize / 2), airgap + gap)
            gap = gap + airgap

            buymenu.OnMousePressed = function(spaa, kc)
                RunConsoleCommand("ttt_cl_traitorpopup")
            end

            buymenu.Paint = function(spaa, w, h)
                if !self:IsValid() then return end
                if !self.Attachments then return end
                local Bfg_col = Color(255, 255, 255, 255)
                local Bbg_col = Color(0, 0, 0, 100)

                if spaa:IsHovered() then
                    Bbg_col = Color(255, 255, 255, 100)
                    Bfg_col = Color(0, 0, 0, 255)
                end

                surface.SetDrawColor(Bbg_col)
                surface.DrawRect(0, 0, w, h)

                local txt = translate("ui.tttequip")

                surface.SetTextColor(Bfg_col)
                surface.SetTextPos(smallgap, ScreenScaleMulti(1))
                surface.SetFont("ArcCW_12")
                surface.DrawText(txt)
            end
        end

        local radiomenu = vgui.Create("DButton", ArcCW.InvHUD)
        radiomenu:SetSize((barsize - ScreenScaleMulti(2)) / 2, ScreenScaleMulti(14))
        radiomenu:SetText("")
        radiomenu:SetPos(scrw - barsize - airgap - ScreenScaleMulti(1) - (barsize / 2), airgap + gap)

        radiomenu.OnMousePressed = function(spaa, kc)
            RADIO:ShowRadioCommands(!RADIO.Show)
        end

        radiomenu.Paint = function(spaa, w, h)
            if !self:IsValid() then return end
            if !self.Attachments then return end
            local Bfg_col = Color(255, 255, 255, 255)
            local Bbg_col = Color(0, 0, 0, 100)

            if spaa:IsHovered() then
                Bbg_col = Color(255, 255, 255, 100)
                Bfg_col = Color(0, 0, 0, 255)
            end

            surface.SetDrawColor(Bbg_col)
            surface.DrawRect(0, 0, w, h)

            local txt = translate("ui.tttchat")

            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(smallgap, ScreenScaleMulti(1))
            surface.SetFont("ArcCW_12")
            surface.DrawText(txt)
        end
    end

    if CLIENT and vrmod and vrmod.IsPlayerInVR(self:GetOwner()) then
        local w, h = ArcCW.InvHUD:GetSize()
        local ang = Angle(0,g_VR.tracking.hmd.ang.yaw-90,45)
        local pos = g_VR.tracking.hmd.pos + Vector(0,0,-20) + Angle(0,g_VR.tracking.hmd.ang.yaw,0):Forward() * 30 + ang:Forward() * w * -0.02 + ang:Right() * h * -0.02
        pos, ang = WorldToLocal(pos, ang, g_VR.origin, g_VR.originAngle)
        vrmod.MenuCreate( "ArcCW_Customize", w, h, ArcCW.InvHUD, 4,
                pos, ang, 0.04, true, function()
            self:CloseCustomizeHUD()
        end)
    end

end

end
--addons/[binbon]arccw_modify/lua/weapons/arccw_base/sh_firemodes.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/weapons/arccw_base/sh_ttt.lua:
return gluapack()()
--lua/weapons/arccw_mw2_fucket.lua:
SWEP.Base = "arccw_mw2_abase"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - MW2 - Unofficial"
SWEP.AdminOnly = false
SWEP.WeaponCamBone = tag_camera

SWEP.PrintName = "Fucket"
SWEP.Trivia_Class = "Sniper Rifle"
SWEP.Trivia_Desc = "Break-action double-barrel musket.\nUnofficial.\nAn 8Z moment."

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/fesiugmw2/c_musket.mdl"
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-4, 4, -4),
    ang = Angle(-10, 0, 180),
    scale = 1.125
}
SWEP.WorldModel = "models/weapons/w_shotgun.mdl"
SWEP.ViewModelFOV = 80

SWEP.Damage = 90
SWEP.DamageMin = 130
SWEP.Range = 90 -- in METRES
SWEP.Penetration = 22

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 2 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 4
SWEP.ReducedClipSize = 1

SWEP.VisualRecoilMult = 0
SWEP.Recoil = 4
SWEP.RecoilSide = 1.5

SWEP.AccuracyMOA = 8 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 100 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 150

SWEP.Delay = 60 / 400 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemodes = {
    {
        PrintName = "SNGL",
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.NPCWeaponType = {"weapon_annabelle", "weapon_shotgun"}
SWEP.NPCWeight = 100

SWEP.Primary.Ammo = "ar2" -- what ammo type the gun uses

SWEP.ShootVol = 120 -- volume of shoot sound
SWEP.ShootPitch = 70 -- pitch of shoot sound

SWEP.ShootSound =			"weapons/fesiugmw2/fire/fucket_u.wav"
--SWEP.DistantShootSound =	"weapons/arccw/nova/nova-1-distant.wav"
SWEP.ShootSoundSilenced =	"weapons/fesiugmw2/fleshymusket/musket_sil.wav"

SWEP.MuzzleEffect = "muzzleflash_shotgun"
SWEP.ShellModel = "models/shells/shell_12gauge.mdl"
SWEP.ShellPitch = 100
SWEP.ShellScale = 1

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.40
SWEP.SightTime = 0.30

SWEP.IronSightStruct = {
    Pos = Vector(-3.241, -3, 0.93),
    Ang = Angle(0.513, 0, 0),
    ViewModelFOV = 65 / 1.3,
    Magnification = 1.3,
}

SWEP.RevolverReload = true

SWEP.BulletBones = {
    [1] = "Weapon_Ammo1",
    [2] = "Weapon_Ammo"
}

SWEP.CaseBones = {
    [1] = "Weapon_Ammo1",
    [2] = "Weapon_Mag"
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "ar2"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(1, 0, 1)
SWEP.HolsterAng = Angle(-10, 12, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.AttachmentElements = {
    ["nors"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
        WMBodygroups = {},
    },
    ["mount"] = {
        VMElements = {
            {
                Model = "models/weapons/arccw/atts/mount_rail.mdl",
                Bone = "Weapon_Break",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(0, -2.2, -5),
                    ang = Angle(90, 0, -90)
                }
            }
        },
    }
}

SWEP.ShootVol = 130 -- volume of shoot sound

SWEP.BarrelLength = 20

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "ar2"

SWEP.ExtraSightDist = 5

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic_lp", "optic", "optic_sniper"},
        Bone = "Weapon_Break",
        Offset = {
            vpos = Vector(0, -2.2, -5),
            vang = Angle(90, 0, -90),
            wpos = Vector(13.762, 0.832, -6.102),
            wang = Angle(-10.393, 0, 180)
        },
        InstalledEles = {"nors","mount"},		
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = "muzzle",
        Bone = "Weapon_Break", 
        Offset = {
            vpos = Vector(0, -1.75, 12),
            vang = Angle(90, 0, -90),
            wpos = Vector(25, 0.825, -7.5),
            wang = Angle(-9.738, -1, 180)
        },
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip", "ubgl", "bipod", "style_pistol"},
        Bone = "Weapon_Break",
        Offset = {
            vpos = Vector(0, -0.25, 3),
            vang = Angle(90, 0, -90),
            wpos = Vector(14.329, 0.602, -4.453),
            wang = Angle(-10.216, 0, 180)
        },
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "Weapon_Break",
        Offset = {
            vpos = Vector(-0.8, -2, 5),
            vang = Angle(90, 0, 180),
            wpos = Vector(19.625, 0.053, -6.298),
            wang = Angle(-8.829, -0.556, 90)
        },
    },
    {
        PrintName = "Fire Group",
        Slot = "fcg",
        DefaultAttName = "Standard FCG"
    },
    {
        PrintName = "Perk",
        Slot = "perk"
    },	
    {
        PrintName = "Ammo Type",
        Slot = "ammo_bullet"
    },
    {
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        Bone = "Weapon_Main",
        Offset = {
            vpos = Vector(0.75, -1.5, 6.5),
            vang = Angle(-90, 180, 90),
            wpos = Vector(9.625, 1.5, -4),
            wang = Angle(0, 0, 180)
        },
    },
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
        Time = 1
    },
    ["draw"] = {
        Source = "draw",
        Time = 0.5,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.25,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
    },
    ["ready"] = {
        Source = "deploy",
        Time = 50/60,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.25,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
    },
    ["fire"] = {
        Source = "fire",
        Time = 0.4,
    },
    ["fire_iron"] = {
        Source = "iron",
        Time = 0.4,
    },
    ["reload"] = {
        Source = "wet",
        Time = 155/60,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        Checkpoints = {20, 85, 117},
        FrameRate = 30,
        LHIK = false,
        LHIKIn = 0.5,
        LHIKOut = 0.5,
        LastClip1OutTime = 0.4,
    },
    ["reload_empty"] = {
        Source = "dry",
        Time = 155/60,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        Checkpoints = {20, 85, 117},
        FrameRate = 30,
        LHIK = false,
        LHIKIn = 0.5,
        LHIKOut = 0.5,
        LastClip1OutTime = 0.4,
    },
}

sound.Add({
	name = 			"ArcCW_FML_MW2R_Musket_Open.1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fesiugmw2/unofficial/fleshymusket/open.wav"
})

sound.Add({
	name = 			"ArcCW_FML_MW2R_Musket_In.1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fesiugmw2/unofficial/fleshymusket/insert.wav"
})

sound.Add({
	name = 			"ArcCW_FML_MW2R_Musket_Close.1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fesiugmw2/unofficial/fleshymusket/close.wav"
})

--lua/weapons/arccw_mw2_intervention.lua:
SWEP.Base = "arccw_mw2_abase"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - MW2"
SWEP.AdminOnly = false
SWEP.WeaponCamBone = tag_camera

SWEP.PrintName = "Intervention"
SWEP.Trivia_Class = "Sniper Rifle"
SWEP.Trivia_Desc = "Bolt action."

SWEP.Slot = 2

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/fesiugmw2/c_intervention.mdl"
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-6.5, 4, -6),
    ang = Angle(-10, 0, 180),
    scale = 1.125
}
SWEP.WorldModel = "models/weapons/w_snip_awp.mdl"
SWEP.ViewModelFOV = 65

SWEP.Damage = 105
SWEP.DamageMin = 105
SWEP.Range = 4000 * 0.025 -- in METRES
SWEP.Penetration = 22

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 5 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 10
SWEP.ReducedClipSize = 3

SWEP.VisualRecoilMult = 0
SWEP.Recoil = 2
SWEP.RecoilSide = 2

SWEP.AccuracyMOA = 0.04 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 666 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 200

SWEP.Delay = 60 / 400 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemodes = {
    {
        PrintName = "BOLT",
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.NPCWeaponType = {"weapon_crossbow"}
SWEP.NPCWeight = 100

SWEP.ManualAction = true
SWEP.NoLastCycle = true -- do not cycle on last shot

SWEP.Primary.Ammo = "SniperPenetratedRound" -- what ammo type the gun uses

SWEP.ShootVol = 140 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound

SWEP.ShootSound =			"weapons/fesiugmw2/fire/cheytac_mp.wav"
--SWEP.DistantShootSound =	"weapons/fesiugmw2/fire_distant/cheytac_mp.wav"
SWEP.ShootSoundSilenced =	"weapons/fesiugmw2/fire/sniper_sil.wav"

SWEP.MuzzleEffect = "muzzleflash_6"
SWEP.ShellModel = "models/shells/shell_338mag.mdl"
SWEP.ShellPitch = 80
SWEP.ShellScale = 1
SWEP.ShellRotateAngle = Angle(0, 90, 0)

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.40
SWEP.SightTime = 0.4 / 1.15

SWEP.IronSightStruct = {
    Pos = Vector(-3.778, -3, 0.93),
    Ang = Angle(0.513, 0, 0),
    ViewModelFOV = 65 / 1.3,
    Magnification = 1.3,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(1, 0, 1)
SWEP.HolsterAng = Angle(-10, 12, 0)

SWEP.SprintPos = Vector(0, 0, 1)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.AttachmentElements = {
    --[[["nors"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
        WMBodygroups = {},
    },]]
    ["nolaser"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
        WMBodygroups = {},
    },
    ["wepcamo-desert"]		= { VMSkin = 1 },
    ["wepcamo-arctic"]		= { VMSkin = 2 },
    ["wepcamo-woodland"]	= { VMSkin = 3 },
    ["wepcamo-digital"]		= { VMSkin = 4 },
    ["wepcamo-urban"]		= { VMSkin = 5 },
    ["wepcamo-bluetiger"]	= { VMSkin = 6 },
    ["wepcamo-redtiger"]	= { VMSkin = 7 },
    ["wepcamo-fall"]		= { VMSkin = 8 },
    ["wepcamo-whiteout"]	= { VMSkin = 9 },
    ["wepcamo-blackout"]        = { VMSkin = 10 },
    ["wepcamo-bushdweller"]     = { VMSkin = 11 },
    ["wepcamo-thunderstorm"]    = { VMSkin = 12 },
}

SWEP.BarrelLength = 50

SWEP.ExtraSightDist = 5
SWEP.Bipod_Integral = true

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic_sniper","optic"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(4.2, 0, 3),
            vang = Angle(0, 0, 0),
        },
        Installed = "optic_cheytacscope"
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = "muzzle",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(33, 0, 1.6),
            vang = Angle(0, 0, 0),
            wpos = Vector(26.648, 0.782, -8.042),
            wang = Angle(-9.79, 0, 180)
        },
		VMScale = Vector(2, 1.25, 1.25)
    },
    {
        PrintName = "Tactical",
        Slot = {"tac","mw2_hidelaser"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(18, 0, 2.6),
            vang = Angle(0, 0, 180),
            wpos = Vector(15.625, -0.253, -6.298),
            wang = Angle(-8.829, -0.556, 90)
        },
        InstalledEles = {"nolaser"},
    },
    {
        PrintName = "Ammo Type",
        Slot = "ammo_bullet"
    },
    {
        PrintName = "Perk",
        Slot = "perk"
    },
    {
        PrintName = "Camouflage",
        DefaultAttName = "None",
        Slot = "mw2_wepcamo",
        FreeSlot = true,
    },
    {
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(4, -0.6, 1),
            vang = Angle(0, 0, 0),
            wpos = Vector(9.625, 1.5, -4),
            wang = Angle(0, 0, 180)
        },
    },
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
        Time = 101/30
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 20/30
    },
    ["idle_sprint"] = {
        Source = "sprint_loop",
        Time = 30/40
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 10/30
    },
    ["draw"] = {
        Source = "pullout",
        Time = 40/30,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.25,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
    },
    ["holster"] = {
        Source = "putaway",
        Time = 36/30,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.25,
    },
    ["fire"] = {
        Source = "fire",
        Time = 10/30,
		MinProgress = 10/30,
    },
    ["cycle"] = {
        Source = "rechamber",
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_cheytech_reload_boltunlock_v1.wav", 	t = 3/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_cheytech_reload_boltopen_v1.wav", 		t = 7/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_cheytech_reload_boltclose_v1.wav", 	t = 16/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_cheytech_reload_boltlock_v1.wav", 		t = 19/30},
					},
        ShellEjectAt = 7/30,
        Time = 29/30,
    },
    ["reload"] = {
        Source = "reload_tac",
        Time = 69/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_cheytech_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_cheytech_reload_clipout_v1.wav", 	t = 18/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_cheytech_reload_clipin_v1.wav", 	t = 47/30},
					},
        Checkpoints = {18, 47},
        FrameRate = 30,
        LHIK = false,
        LHIKIn = 0.5,
        LHIKOut = 0.5,
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        Time = 117/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_cheytech_reload_lift_v1.wav", 			t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_cheytech_reload_boltunlock_v1.wav", 	t = 13/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_cheytech_reload_boltopen_v1.wav", 		t = 18/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_cheytech_reload_clipout_v1.wav", 		t = 54/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_cheytech_reload_clipin_v1.wav", 		t = 81/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_cheytech_reload_boltclose_v1.wav", 	t = 99/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_cheytech_reload_boltlock_v1.wav", 		t = 103/30},
					},
        Checkpoints = {18, 54, 81, 99},
        FrameRate = 30,
        LHIK = false,
        LHIKIn = 0.5,
        LHIKOut = 0.5,
    },
}
--lua/weapons/arccw_mw2_l85_u.lua:
SWEP.Base = "arccw_mw2_abase"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - MW2 - Unofficial"
SWEP.AdminOnly = false
SWEP.WeaponCamBone = tag_camera

SWEP.PrintName = "L85A2"
SWEP.Trivia_Class = "Assault Rifle"
SWEP.Trivia_Desc = "Fully automatic, all purpose weapon.\nUnofficial."

SWEP.Slot = 2

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/fesiugmw2/c_sa80_5.mdl"
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-8, 3, -5),
    ang = Angle(-10, 0, 180),
    scale = 1.25
}
SWEP.WorldModel = "models/weapons/w_rif_aug.mdl"
SWEP.ViewModelFOV = 65

SWEP.DefaultBodygroups = "100000"

SWEP.Damage = 40
SWEP.DamageMin = 20
SWEP.Range = 1300 * 0.025  -- GAME UNITS * 0.025 = METRES
SWEP.Penetration = 7
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil -- entity to fire, if any


SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 45
SWEP.ReducedClipSize = 15

SWEP.VisualRecoilMult = 0
SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.5
SWEP.RecoilRise = 0

SWEP.Delay = 0.086 -- lazy, fix this l8r btich -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.NPCWeaponType = {"weapon_ar2", "weapon_smg1"}
SWEP.NPCWeight = 100

SWEP.AccuracyMOA = 5 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 250

SWEP.Primary.Ammo = "smg1" -- what ammo type the gun uses

SWEP.ShootVol = 110 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound

SWEP.ShootSound =			"weapons/fesiugmw2/fire/l85_u.wav"
SWEP.ShootMechSound =       ArcCW_MW2_Mech
--SWEP.DistantShootSound =	"weapons/fesiugmw2/fire_distant/aug.wav"
SWEP.ShootDrySound =        "weapons/fesiugmw2/fire/dryfire_rifle.wav"
SWEP.ShootSoundSilenced =	"weapons/fesiugmw2/fire/m4_sil.wav"

SWEP.MuzzleEffect = "muzzleflash_4"
SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellPitch = 95
SWEP.ShellScale = 1
SWEP.ShellRotateAngle = Angle(0, 90, 0)

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.38
SWEP.SightTime = 0.25

SWEP.BulletBones = { -- the bone that represents bullets in gun/mag
    -- [0] = "bulletchamber",
    -- [1] = "bullet1"
}

SWEP.IronSightStruct = {
    Pos = Vector(-2.42, -2.026, -0.35),
    Ang = Angle(0.203, 0, 0),
    ViewModelFOV = 65 / 1.3,
    Magnification = 1.3,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10.479, 0, -1.321)
SWEP.CustomizeAng = Angle(18.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(1, 0, 1)
SWEP.HolsterAng = Angle(-10, 12, 0)

SWEP.SprintPos = Vector(0, 0, 1)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.BarrelLength = 27

SWEP.AttachmentElements = {
    ["nors"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
    ["grip"] = { VMBodygroups = {{ind = 2, bg = 1}} },
    ["wepcamo-desert"]		= { VMSkin = 1 },
    ["wepcamo-arctic"]		= { VMSkin = 2 },
    ["wepcamo-woodland"]	= { VMSkin = 3 },
    ["wepcamo-digital"]		= { VMSkin = 4 },
    ["wepcamo-urban"]		= { VMSkin = 5 },
    ["wepcamo-bluetiger"]	= { VMSkin = 6 },
    ["wepcamo-redtiger"]	= { VMSkin = 7 },
    ["wepcamo-fall"]		= { VMSkin = 8 },
    ["wepcamo-whiteout"]	= { VMSkin = 9 },
    ["wepcamo-blackout"]        = { VMSkin = 10 },
    ["wepcamo-bushdweller"]     = { VMSkin = 11 },
    ["wepcamo-thunderstorm"]    = { VMSkin = 12 },
}

SWEP.ExtraSightDist = 5

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic"},
        Bone = "j_gun",
        Offset = {
            vpos = Vector(-3.3, 0, 2.4),
            vang = Angle(0, 0, 0),
            wang = Angle(-9.738, 0, 180)
        },
        InstalledEles = {"nors"},
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = "muzzle",
        Bone = "j_gun",
        Offset = {
            vpos = Vector(14, 0, 1),
            vang = Angle(0, 0, 0),
            wpos = Vector(33.719, -2.122, -5.573),
            wang = Angle(0, 6.034, 180)
        },
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip", "bipod", "foregrip_mw2exclusive"},
        Bone = "j_gun",
        Offset = {
            vpos = Vector(6, 0, -0.2),
            vang = Angle(0, 0, 0),
            wpos = Vector(14.329, 0.602, -4.453),
            wang = Angle(-2.461, -6.525, 176.662)
        },
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "j_gun",
        Offset = {
            vpos = Vector(-1.9, -1, 0.67),
            vang = Angle(0, 0, 90),
            wpos = Vector(15.625, -0.253, -6.298),
            wang = Angle(-8.829, -0.556, 90)
        },
    },
    {
        PrintName = "Fire Group",
        Slot = "fcg",
        DefaultAttName = "Standard FCG"
    },
    {
        PrintName = "Ammo Type",
        Slot = "ammo_bullet"
    },
    {
        PrintName = "Perk",
        Slot = "perk"
    },
    {
        PrintName = "Camouflage",
        DefaultAttName = "None",
        Slot = "mw2_wepcamo",
        FreeSlot = true,
    },
	{
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        Bone = "j_gun",
        Offset = {
            vpos = Vector(0, -0.5, 0.5),
            vang = Angle(0, 0, 0),
            wpos = Vector(9.625, 1.5, -4),
            wang = Angle(0, 0, 180)
        },
    },
}

SWEP.Hook_TranslateAnimation = function(wep, anim)
	local attached = wep.Attachments[3].Installed
	
	-- m203 is 1, masterkey is 2, fgrip is 3
	local attthing
		if 		attached 							then attthing = 3
		else 											 attthing = 0
	end
	
    if attthing == 3 then
        return anim .. "_fgrip"
    end
end

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
        Time = 1/30
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 10/30
    },
    ["idle_sprint"] = {
        Source = "sprint_loop",
        Time = 30/40
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 10/30
    },
    ["draw"] = {
        Source = "pullout",
        Time = 30/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["holster"] = {
        Source = "putaway",
        Time = 25/30,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["ready"] = {
        Source = "pullout_first",
        Time = 43/30,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_lift_v1.wav", 	t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_chamber_v1.wav", 	t = 18/30},
					},
    },
    ["fire"] = {
        Source = "fire",
        Time = 5/30,
        ShellEjectAt = 0,
    },
    ["fire_iron"] = {
        Source = "fire_ads",
        Time = 5/30,
        ShellEjectAt = 0,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_clipout_v1.wav", 	t = 19/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_clipin_v1.wav", 		t = 66/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_hit_v1.wav", 		t = 75/30},
					},
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        Time = 113/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_clipout_v1.wav", 	t = 19/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_clipin_v1.wav", 		t = 66/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_hit_v1.wav", 		t = 75/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_chamber_v1.wav",		t = 86/30},
					},
    },	
------------------------------------------------
------ Here lies foregrip animations. awesome --
------------------------------------------------
    ["idle_fgrip"] = {
        Source = "idle_fgrip",
        Time = 1/30
    },
    ["enter_sprint_fgrip"] = {
        Source = "sprint_in_fgrip",
        Time = 10/30
    },
    ["idle_sprint_fgrip"] = {
        Source = "sprint_loop_fgrip",
        Time = 30/40
    },
    ["exit_sprint_fgrip"] = {
        Source = "sprint_out_fgrip",
        Time = 10/30
    },
    ["draw_fgrip"] = {
        Source = "pullout_fgrip",
        Time = 30/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["holster_fgrip"] = {
        Source = "putaway_fgrip",
        Time = 25/30,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["ready_fgrip"] = {
        Source = "pullout_first_fgrip",
        Time = 43/30,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_lift_v1.wav", 	t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_chamber_v1.wav", 	t = 18/30},
					},
    },
    ["fire_fgrip"] = {
        Source = "fire_fgrip",
        Time = 5/30,
        ShellEjectAt = 0,
    },
    ["fire_iron_fgrip"] = {
        Source = "fire_ads_fgrip",
        Time = 5/30,
        ShellEjectAt = 0,
    },
    ["reload_fgrip"] = {
        Source = "reload_fgrip",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_clipout_v1.wav", 	t = 19/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_clipin_v1.wav", 		t = 66/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_hit_v1.wav", 		t = 75/30},
					},
    },
    ["reload_empty_fgrip"] = {
        Source = "reload_empty_fgrip",
        Time = 113/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_clipout_v1.wav", 	t = 19/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_clipin_v1.wav", 		t = 66/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_hit_v1.wav", 		t = 75/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_sa80_reload_chamber_v1.wav",		t = 86/30},
					},
    },	
}
--lua/weapons/arccw_mw2_pp2000.lua:
SWEP.Base = "arccw_mw2_abase"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - MW2"
SWEP.AdminOnly = false
SWEP.WeaponCamBone = tag_camera

SWEP.PrintName = "PP2000"
SWEP.Trivia_Class = "Machine Pistol"
SWEP.Trivia_Desc = "Fully automatic, close range."

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/fesiugmw2/c_pp2000_3a.mdl"
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-14, 4, -2.5),
    ang = Angle(-7, 0, 180),
    scale = 1.25
}
SWEP.WorldModel = "models/weapons/w_smg_tmp.mdl"
SWEP.ViewModelFOV = 65

SWEP.Damage = 40
SWEP.DamageMin = 20
SWEP.Range = 750 * 0.025  -- GAME UNITS * 0.025 = METRES
SWEP.Penetration = 4
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil -- entity to fire, if any


SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 30
SWEP.ReducedClipSize = 10

SWEP.VisualRecoilMult = 0
SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.5
SWEP.RecoilRise = 0.2

SWEP.Delay = 0.075 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.NPCWeaponType = {"weapon_ar2", "weapon_smg1"}
SWEP.NPCWeight = 100

SWEP.AccuracyMOA = 12 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 300 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 175

SWEP.Primary.Ammo = "pistol" -- what ammo type the gun uses

SWEP.ShootVol = 110 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound

SWEP.ShootSound =			"weapons/fesiugmw2/fire/pp2000.wav"
--SWEP.DistantShootSound =	"weapons/fesiugmw2/fire_distant/pp2000.wav"
SWEP.ShootSoundSilenced =	"weapons/fesiugmw2/fire/usp45_sil.wav"

SWEP.MuzzleEffect = "muzzleflash_4"
SWEP.ShellModel = "models/shells/shell_9mm.mdl"
SWEP.ShellScale = 1
SWEP.ShellRotateAngle = Angle(0, 90, 0)

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.8
SWEP.SightTime = 0.2

SWEP.BulletBones = { -- the bone that represents bullets in gun/mag
    -- [0] = "bulletchamber",
    -- [1] = "bullet1"
}

SWEP.IronSightStruct = {
    Pos = Vector(-3.85, -2.485, 0.9),
    Ang = Angle(-0.4, 0, 0),
    ViewModelFOV = 65 / 1.18,
    Magnification = 1.18,
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "revolver"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(8.479, -2, 1.321)
SWEP.CustomizeAng = Angle(0.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(1, 0, 1)
SWEP.HolsterAng = Angle(-10, 12, 0)

SWEP.SprintPos = Vector(0, 0, 1)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.BarrelLength = 18

SWEP.ExtraSightDist = 0

SWEP.AttachmentElements = {
    ["stock2"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
    ["wepcamo-desert"]		= { VMSkin = 1 },
    ["wepcamo-arctic"]		= { VMSkin = 2 },
    ["wepcamo-woodland"]	= { VMSkin = 3 },
    ["wepcamo-digital"]		= { VMSkin = 4 },
    ["wepcamo-urban"]		= { VMSkin = 5 },
    ["wepcamo-bluetiger"]	= { VMSkin = 6 },
    ["wepcamo-redtiger"]	= { VMSkin = 7 },
    ["wepcamo-fall"]		= { VMSkin = 8 },
    ["wepcamo-whiteout"]	= { VMSkin = 9 },
    ["wepcamo-blackout"]        = { VMSkin = 10 },
    ["wepcamo-bushdweller"]     = { VMSkin = 11 },
    ["wepcamo-thunderstorm"]    = { VMSkin = 12 },
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic_lp"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 0, 0),
            vang = Angle(0, 0, 0),
        },
        SlideAmount = {
            vmin = Vector(-3, -0.025, 2),
            vmax = Vector(-1, -0.025, 2),
        },
		ExtraSightDist = 5,
        InstalledEles = {"stock2"},
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = "muzzle",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(7, 0, 0.6),
            vang = Angle(0, 0, 0),
            wpos = Vector(26.648, 0.782, -8.042),
            wang = Angle(-9.79, 0, 180)
        },
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, -0.9, 1.2),
            vang = Angle(0, 0, 90),
        },
		VMScale = Vector(0.8, 0.8, 0.8),
    },
    {
        PrintName = "Fire Group",
        Slot = "fcg",
        DefaultAttName = "Standard FCG"
    },
    {
        PrintName = "Ammo Type",
        Slot = "ammo_bullet"
    },
    {
        PrintName = "Perk",
        Slot = "perk"
    },
    {
        PrintName = "Camouflage",
        DefaultAttName = "None",
        Slot = "mw2_wepcamo",
        FreeSlot = true,
    },
	{
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0.75, -0.75, 0.75),
            vang = Angle(0, 0, 0),
            wpos = Vector(9.625, 1.5, -4),
            wang = Angle(0, 0, 180)
        },
    },
}

SWEP.Animations = { 
    ["idle"] = {
        Source = "idle",
        Time = 0/30,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 11/30
    },
    ["idle_sprint"] = {
        Source = "sprint_loop",
        Time = 31/40
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 11/30
    },
    ["draw"] = {
        Source = "pullout",
        Time = 26/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["ready"] = {
        Source = "pullout_first",
        Time = 33/30,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_pp2000_reload_first_lift_v1.wav", 	t = 0/30},
						--{s = "weapons/fesiugmw2/foley/wpfoly_pp2000_reload_chamber_v1.wav", 	t = 17/30},
					},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["holster"] = {
        Source = "putaway",
        Time = 26/30,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["fire"] = {
        Source = "fire",
        Time = 6/30,
        ShellEjectAt = 0,
    },
    ["fire_iron"] = {
        Source = "fire_ads",
        Time = 6/30,
        ShellEjectAt = 0,
    },
    ["reload"] = {
        Source = "reload",
        Time = 62/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_pp2000_reload_lift_v1.wav", 		t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_pp2000_reload_clipout_v1.wav", 	t = 12/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_pp2000_reload_clipin_v1.wav", 	    t = 39/30},
					},
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        Time = 83/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_pp2000_reload_lift_v1.wav", 	    t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_pp2000_reload_clipout_v1.wav", 	t = 11/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_pp2000_reload_clipin_v1.wav", 	    t = 39/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_pp2000_reload_chamber_v1.wav", 	t = 59/30},
					},
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
    },
}
--lua/weapons/arccw_mw2_ranger_long.lua:
return gluapack()()
--lua/weapons/arccw_mw2_ump45.lua:
return gluapack()()
--lua/weapons/arccw_uc_galilarm.lua:
return gluapack()()
--lua/weapons/arccw_myt_uc_scar.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - Urban Coalition"
SWEP.UC_CategoryPack = "9Urban Expedition"
SWEP.AdminOnly = false
SWEP.UseHands = true

-- Muzzle and shell effects --

SWEP.MuzzleEffect = "muzzleflash_1"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/556x45.mdl"
SWEP.ShellScale = 1.145
SWEP.ShellPitch = 100
SWEP.UC_ShellColor = Color(0.7*255, 0.2*255, 0.2*255)

SWEP.MuzzleEffectAttachment = 1
SWEP.CaseEffectAttachment = 2
SWEP.CamAttachment = 3
SWEP.TracerNum = 1
SWEP.TracerCol = Color(25, 255, 25)
SWEP.TracerWidth = 2

-- Fake name --

SWEP.PrintName = "Osckée 21"
-- True name --
SWEP.TrueName = "SCAR-H"

-- Trivia --

SWEP.Trivia_Class = "Battle Rifle"
SWEP.Trivia_Desc = [[
A highly modular rifle platform designed to be used by expeditionary forces. Configurable for urban combat, marksmanship, and more.

This alteration is permanently half baked in sun light.
]]
SWEP.Trivia_Calibre = "7.62x51mm NATO"
SWEP.Trivia_Country = "Wallonia" -- massive funny
SWEP.Trivia_Manufacturer = "Héristal van Hoog-Zert"  -- /Haut-Sart/ why are they speaking fake Dutch with French grammar?
SWEP.Trivia_Year = 2004

-- Weapon slot --

SWEP.Slot = 2

-- Weapon's manufacturer real name --

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "FN Herstal"
    SWEP.Trivia_Country = "Belgium"
end

-- Viewmodel / Worldmodel / FOV --

SWEP.ViewModel = "models/weapons/arccw/c_uc_myt_scar.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_uc_myt_scar.mdl"
SWEP.ViewModelFOV = 70
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

-- Damage --

SWEP.Damage = ArcCW.UC.StdDmg["762_51"].max
SWEP.DamageMin = ArcCW.UC.StdDmg["762_51"].min
SWEP.RangeMin = 50
SWEP.Range = 400
SWEP.Penetration = ArcCW.UC.StdDmg["762_51"].pen
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = ArcCW.UC.StdDmg["762_51"].vel
SWEP.PhysBulletMuzzleVelocity = ArcCW.UC.StdDmg["762_51"].vel

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.chreleaseSize = 1
SWEP.Primary.ClipSize = 20
SWEP.ExtendedClipSize = 30
SWEP.ReducedClipSize = 10

-- Recoil --

SWEP.Recoil = 1.1
SWEP.RecoilSide = 0.7

SWEP.RecoilRise = 0.1
SWEP.RecoilPunch = 1
SWEP.VisualRecoilMult = 1
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 1
SWEP.RecoilPunchpull = 1

SWEP.Sway = 0.5

-- Firerate / Firemodes --

SWEP.Delay = 60 / 600
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120
SWEP.ShootPitchVariation = 0

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_ar2"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 3.5
SWEP.HipDispersion = 750
SWEP.MoveDispersion = 220
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "ar2"

-- Speed multipliers --

SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.5
SWEP.ShootSpeedMult = 0.9

-- Length --

SWEP.BarrelLength = 48
SWEP.ExtraSightDist = 7

-- Ironsights / Customization / Poses --

SWEP.HolsterPos = Vector(0.5, 8, -0.5)
SWEP.HolsterAng = Angle(-10, 8, -15)

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.IronSightStruct = {
     Pos = Vector(-3.71, 3, 0.51),
     Ang = Angle(0, 0, 0),
     Magnification = 1.1,
     SwitchToSound = "",
}

SWEP.ActivePos = Vector(0, 7, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(0, 5, -2)
SWEP.CustomizeAng = Angle(10, 0, 0)

SWEP.CrouchPos = Vector(-1, 5, -0.25)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.BarrelOffsetHip = Vector(2, 0, -5)

SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos        =    Vector(-3, 4, -8),
    ang        =    Angle(-6, 0, 180),
    bone    =    "ValveBiped.Bip01_R_Hand",
}

-- Firing sounds --

local path = ")weapons/uc_osk/"
local common = ")/arccw_uc/common/"
local rottle = {common .. "cloth_1.ogg", common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_5.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local mech = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}
local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}
local rutle = {common .. "movement-rifle-01.ogg", common .. "movement-rifle-02.ogg", common .. "movement-rifle-03.ogg", common .. "movement-rifle-04.ogg"}
local magdrop = {common .. "rifle_magdrop_1.ogg", common .. "rifle_magdrop_2.ogg", common .. "rifle_magdrop_3.ogg", common .. "rifle_magdrop_4.ogg"}
--SWEP.FirstShootSound = path .. "fire_first.ogg"

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}
SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = path .. "dryfire.ogg"

local tail = ")/arccw_uc/common/308/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-308-rif-ext-01.ogg",
    tail .. "fire-dist-308-rif-ext-02.ogg",
    tail .. "fire-dist-308-rif-ext-03.ogg",
    tail .. "fire-dist-308-rif-ext-04.ogg",
    tail .. "fire-dist-308-rif-ext-05.ogg",
    tail .. "fire-dist-308-rif-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    tail .. "fire-dist-308-rif-int-01.ogg",
    tail .. "fire-dist-308-rif-int-02.ogg",
    tail .. "fire-dist-308-rif-int-03.ogg",
    tail .. "fire-dist-308-rif-int-04.ogg",
    tail .. "fire-dist-308-rif-int-05.ogg",
    tail .. "fire-dist-308-rif-int-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.FiremodeSound = {
    path .. "selector-01.ogg",
    path .. "selector-02.ogg",
    path .. "selector-03.ogg",
    path .. "selector-04.ogg",
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

-- Bodygroups --


SWEP.AttachmentElements = {	
    ["conv_9mm"] = {
        NameChange = "Aanvulloir 16",
        TrueNameChange = "SCAR-9",
        VMBodygroups = {
            {ind = 2, bg = 3},
            {ind = 4, bg = 4},
        },
    },	 
	["conv_ak"] = {
        NameChange = "Chijmaar 32",
        TrueNameChange = "SCAR-47",
        VMBodygroups = {
            {ind = 2, bg = 2},
            {ind = 4, bg = 2},
        },
    },
	["conv_ak70"] = {
        NameChange = "Chijmaar 70",
        TrueNameChange = "SCAR-47/70",
        VMBodygroups = {
            {ind = 2, bg = 4},
            {ind = 4, bg = 3},
        },
    },
	["conv_556"] = {
        NameChange = "Scarlett 17",
        TrueNameChange = "SCAR-L",
        VMBodygroups = {
            {ind = 2, bg = 1},
            {ind = 4, bg = 1},
        },
    },	
	["conv_ssr"] = {
        NameChange = "Lancierie 24",
        TrueNameChange = "SCAR-SSR",
        VMBodygroups = {
            {ind = 2, bg = 5},
            {ind = 4, bg = 0},
        },
    },	

	["stock_ssr"] = {
        VMBodygroups = {
            {ind = 7, bg = 6},
        },
    },
	["stock_tube"] = { VMBodygroups = { {ind = 0, bg = 2},{ind = 7, bg = 10}, }, },
	["stock_folded"] = { VMBodygroups = { {ind = 7, bg = 1}, }, },
	["stock_pdw"] = { VMBodygroups = { {ind = 7, bg = 4}, }, },
	["stock_pdwf"] = { VMBodygroups = { {ind = 7, bg = 5}, }, },
	["stock_231_ex"] = { VMBodygroups = { {ind = 7, bg = 7}, {ind = 0, bg = 2}, }, },
	["stock_231_in"] = { VMBodygroups = { {ind = 7, bg = 8}, {ind = 0, bg = 2}, }, },
	["stock_fold"] = { VMBodygroups = { {ind = 7, bg = 2}, }, },
	["stock_foldf"] = { VMBodygroups = { {ind = 7, bg = 3}, }, },

	["grip_flat"] = { VMBodygroups = { {ind = 6, bg = 1}, }, },	
	["grip_hollow"] = { VMBodygroups = { {ind = 6, bg = 2}, }, },
	
	["hg_l"] = {
        VMBodygroups = {
            {ind = 8, bg = 3},
            {ind = 9, bg = 3},
        },
        AttPosMods = {
            [3] = { vpos = Vector(0, -1.65, 22.0) },
        }
    },	
	["hg_20"] = {
        VMBodygroups = {
            {ind = 8, bg = 5},
            {ind = 9, bg = 5},
			{ind = 1, bg = 5},
        },
        AttPosMods = {
            [3] = { vpos = Vector(0, -1.65, 22.6) },
        }
    },
    ["hg_sd"] = {
        VMBodygroups = {
            {ind = 8, bg = 4},
            {ind = 9, bg = 4},
            {ind = 1, bg = 3},
        },
        AttPosMods = {
            [3] = { vpos = Vector(0, -1.65, 15.5) },
            [4] = { vpos = Vector(0, 0, 9) },
            [5] = { vpos = Vector(-1.5, -1.7, 9.5) },
			[14] = { vpos = Vector(0, -1, 6) },
        },
    },
    ["hg_s"] = {
        VMBodygroups = {
            {ind = 8, bg = 1},
            {ind = 9, bg = 1},
            {ind = 1, bg = 1},
        }, 
        AttPosMods = {
            [3] = { vpos = Vector(0, -1.65, 12.9) },
            [4] = { vpos = Vector(0, -0.75, 7.5) },
            [5] = { vpos = Vector(-1, -1.7, 8.5) },
        },
    },
    ["hg_xs"] = {
        VMBodygroups = {
            {ind = 8, bg = 2},
            {ind = 9, bg = 2},
            {ind = 1, bg = 2},
        }, 
        AttPosMods = {
            [3] = { vpos = Vector(0, -1.65, 10.5) },
            [4] = { vpos = Vector(0, -0.75, 7) },
            [5] = { vpos = Vector(-1, -1.7, 7.5) },
        },
    },
}

SWEP.DefaultBodygroups = "000000000000000"

SWEP.Hook_ModifyBodygroups = function(wep, data)
	local vm = data.vm
	local handguard = wep.Attachments[2].Installed
	if wep.Attachments[1].Installed then 
        if (handguard == "uc_myt_scar_hg_s") || (handguard == "uc_myt_scar_hg_sd") then vm:SetBodygroup(5, 3) 
        elseif handguard == "uc_myt_scar_hg_xs" then vm:SetBodygroup(5, 5)
        elseif handguard == "uc_myt_scar_hg_20" then vm:SetBodygroup(5, 8)
        else   vm:SetBodygroup(5, 1) end
    
	else
		if (handguard == "uc_myt_scar_hg_s") || (handguard == "uc_myt_scar_hg_sd") then vm:SetBodygroup(5, 2) 
		elseif handguard == "uc_myt_scar_hg_xs" then vm:SetBodygroup(5, 4)
		elseif handguard == "uc_myt_scar_hg_20" then vm:SetBodygroup(5, 7)
		else   vm:SetBodygroup(5, 0) end

    end

	if wep.Attachments[3].Installed then vm:SetBodygroup(9, 4) end	
end

SWEP.Hook_Think = ArcCW.UC.ADSReload

SWEP.NoHideLeftHandInCustomization = true
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },

    ["ready"] = {
        Source = "deploy",
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "rattle.ogg", t = 0.2 + 5/40},
            {s = path .. "chpull.ogg",   t = 18/40},
            {s = common .. "cloth_4.ogg",  t = 0.5 + 5/40},
            {s = path .. "chrelease.ogg",  t = 32/40},
        },
        ProcDraw = false,
    },	
    ["ready_empty"] = {
        Source = "deploy_empty",
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "rattle.ogg", t = 0.2 + 5/40},
            {s = common .. "cloth_4.ogg",  t = 0.5 + 5/40},
        },
        ProcDraw = false,
        ForceEmpty = true,
    },	
    ["idle_empty"] = {
        Source = "idle_empty",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "shoulder.ogg", t = 0.15},
            {s = path .. "rattle_3.ogg", t = 0.2},
        },
    },
    ["draw_empty"] = {
        Source = "draw_empty",
        Time = 20 / 30,
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "shoulder.ogg", t = 0.15},
            {s = path .. "rattle_3.ogg", t = 0.2},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = false,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "cloth_6.ogg", t = 0.2},
        },
    },
    ["holster_empty"] = {
        Source = "holster_empty",
        LHIK = false,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "cloth_6.ogg", t = 0.2},
        },
    },
    ["fix"] = {
        Source = "fix",
        ShellEjectAt = 0.5,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.7,
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "rattle.ogg", t = 0.2},
            {s = path .. "chpull.ogg",   t = 0.15},
            {s = common .. "cloth_4.ogg",  t = 0.5},
            {s = path .. "chrelease.ogg",  t = 0.5},
        },
    },  
    ["fire"] = {
        Source = "fire",
        ShellEjectAt = 0.01,
        SoundTable = {{ s = mech, t = 0, v = 0.25 }},
    },  
	["fire_iron"] = {
        Source = "fire",
        ShellEjectAt = 0.01,
        SoundTable = {
            {s = common .. "common_mech_light.ogg", t = 0},
            { s = mech, t = 0 }
        },
    },
    ["fire_empty"] = {
        Source = "fire_empty",
        ShellEjectAt = 0.01,
        SoundTable = {
            {s = common .. "common_mech_light.ogg", t = 0},
            {s = path .. "mech_last.ogg", t = 0}, -- Temporary
        },
    }, 
	["fire_iron_empty"] = {
        Source = "fire_empty",
        ShellEjectAt = 0.01,
        SoundTable = {
            {s = common .. "common_mech_light.ogg", t = 0},
            {s = path .. "mech_last.ogg", t = 0}, -- Temporary
        },
    },

    -- Base --

    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 1.8,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 10/40},
            {s = rottle, 			                    t = 20/40},
            {s = common .. "magpouch.ogg",              t = 32/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 42/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 56/40},
            {s = rottle, 			                    t = 60/40},
            {s = "weapons/uc_osk/magtap.ogg", 			t = 66/40},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 2.25,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 7/40},
            {s = rottle, 			                    t = 17/40},
            {s = magdrop, 			                    t = 40/40, v = 0.25},
            {s = common .. "magpouch.ogg",              t = 32/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 46/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 62/40},
            {s = rottle, 			                    t = 69/40},
            {s = "weapons/uc_osk/boltcatch.ogg", 		t = 82/40},
            {s = rottle, 			                    t = 88/40},
        },
    },

    ["enter_inspect"] = {
        Source = "inspect_enter",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect"] = {
        Source = "inspect_loop",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_inspect"] = {
        Source = "inspect_exit",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.375,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 20/40},
            {s = rottle, 			                    t = 17/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 60/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 70/40},
            {s = rottle, 			                    t = 69/40},
            {s = common .. "shoulder.ogg", 	        	t = 88/40, v = .5},
        },
    },
    ["enter_inspect_empty"] = {
        Source = "inspect_enter_empty",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_empty"] = {
        Source = "inspect_loop_empty",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_inspect_empty"] = {
        Source = "inspect_exit_empty",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.375,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 20/40},
            {s = rottle, 			                    t = 17/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 60/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 70/40},
            {s = rottle, 			                    t = 69/40},
            {s = common .. "shoulder.ogg", 	        	t = 88/40, v = .5},
        },
    },	

    -- 9mm --

    ["reload_9mm"] = {
        Source = "reload_9mm",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout-9.ogg", 		t = 10/40},
            {s = rottle, 			                    t = 20/40},
            {s = common .. "magpouch.ogg",              t = 32/40},
            {s = "weapons/uc_osk/struggle-9.ogg", 		t = 40/40},
            {s = "weapons/uc_osk/magin-9.ogg", 			t = 53/40},
            {s = rottle, 			                    t = 60/40},
        },
    },
    ["reload_empty_9mm"] = {
        Source = "reload_empty_9mm",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 1.6,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout-9.ogg", 		t = 5/40},
            {s = rottle, 			                    t = 17/40},
            {s = magdrop, 			                    t = 30/40, v = 0.25},
            {s = common .. "magpouch.ogg",              t = 32/40},
            {s = "weapons/uc_osk/struggle-9.ogg", 		t = 35/40},
            {s = "weapons/uc_osk/magin-9.ogg", 			t = 41/40},
            {s = "weapons/uc_osk/boltcatchpress-9.ogg", t = 58/40},
            {s = rottle, 			                    t = 62/40},
        },
    },

    ["enter_inspect_9mm"] = {
        Source = "inspect_enter_9mm",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_9mm"] = {
        Source = "inspect_loop_9mm",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_inspect_9mm"] = {
        Source = "inspect_exit_9mm",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.375,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout-9.ogg", 			t = 20/40},
            {s = rottle, 			                    t = 17/40},
            {s = "weapons/uc_osk/struggle-9.ogg", 		t = 53/40},
            {s = "weapons/uc_osk/magin-9.ogg", 			t = 68/40},
            {s = rottle, 			                    t = 69/40},
        },
    },
    ["enter_inspect_empty_9mm"] = {
        Source = "inspect_enter_empty_9mm",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0, 
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_empty_9mm"] = {
        Source = "inspect_loop_empty_9mm",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0, 
    },
    ["exit_inspect_empty_9mm"] = {
        Source = "inspect_exit_empty_9mm",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.375,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout-9.ogg", 			t = 20/40},
            {s = rottle, 			                    t = 17/40},
            {s = "weapons/uc_osk/struggle-9.ogg", 		t = 53/40},
            {s = "weapons/uc_osk/magin-9.ogg", 			t = 68/40},
            {s = rottle, 			                    t = 69/40},
        },
    },	 
	
    -- ssr --

    ["reload_ssr"] = {
        Source = "reload_ssr",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 2,
        LastClip1OutTime = 0.9,
        LHIK = false,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 14/40},
            {s = rottle, 			                    t = 17/40},
            {s = common .. "magpouch.ogg",              t = 40/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 60/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 72/40},
            {s = rottle, 			                    t = 80/40},
        },
    },
    ["reload_empty_ssr"] = {
        Source = "reload_empty_ssr",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 2.7,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 2.8,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 14/40},
            {s = rottle, 			                    t = 17/40},
            {s = common .. "magpouch.ogg",              t = 32/40},
            {s = magdrop, 			                    t = 46/40, v = 0.25},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 60/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 72/40},
            {s = rottle, 			                    t = 78/40},
            {s = "weapons/uc_osk/boltcatch.ogg", 		t = 101/40},
            {s = rottle, 			                    t = 104/40},
        },
    },

    ["enter_inspect_ssr"] = {
        Source = "inspect_enter_ssr",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0, 
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_ssr"] = {
        Source = "inspect_loop_ssr",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0, 
    },
    ["exit_inspect_ssr"] = {
        Source = "inspect_exit_ssr",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.375,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 20/40},
            {s = rottle, 			                    t = 17/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 46/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 70/40},
            {s = rottle, 			                    t = 69/40},
            -- {s = "weapons/uc_osk/boltcatch.ogg", 		t = 82/40},
        },
    },
    ["enter_inspect_empty_ssr"] = {
        Source = "inspect_enter_empty_ssr",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0, 
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_empty_ssr"] = {
        Source = "inspect_loop_empty_ssr",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_inspect_empty_ssr"] = {
        Source = "inspect_exit_empty_ssr",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.375,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 20/40},
            {s = rottle, 			                    t = 17/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 60/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 70/40},
            {s = rottle, 			                    t = 69/40},
            {s = common .. "shoulder.ogg", 	        	t = 88/40, v = .5},
        },
    },	 

    -- 556 --

    ["reload_556"] = {
        Source = "reload_556",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 1.5,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 10/40},
            {s = rottle, 			                    t = 20/40},
            {s = common .. "magpouch.ogg",              t = 30/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 40/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 53/40},
            {s = rottle, 			                    t = 60/40},
        },
    },
    ["reload_empty_556"] = {
        Source = "reload_empty_556",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 1.85,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 3/40},
            {s = rottle, 			                    t = 17/40},
            {s = magdrop, 			                    t = 22/40, v = 0.35},
            {s = common .. "magpouch.ogg",              t = 26/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 40/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 50/40},
            {s = rottle, 			                    t = 69/40},
            {s = "weapons/uc_osk/boltcatchpress.ogg", 	t = 70/40},
            {s = rottle, 			                    t = 75/40},
        },
    },

    ["enter_inspect_556"] = {
        Source = "inspect_enter_556",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_556"] = {
        Source = "inspect_loop_556",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0, -- maybe im dumb
    },
    ["exit_inspect_556"] = {
        Source = "inspect_exit_556",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.375,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 20/40},
            {s = rottle, 			                    t = 17/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 60/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 70/40},
            {s = rottle, 			                    t = 69/40},
            {s = common .. "shoulder.ogg", 	        	t = 88/40, v = .5},
        },
    },
    ["enter_inspect_empty_556"] = {
        Source = "inspect_enter_empty_556",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_empty_556"] = {
        Source = "inspect_loop_empty_556",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_inspect_empty_556"] = {
        Source = "inspect_exit_empty_556",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.375,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 20/40},
            {s = rottle, 			                    t = 17/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 60/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 70/40},
            {s = rottle, 			                    t = 69/40},
            {s = common .. "shoulder.ogg", 	        	t = 88/40, v = .5},
        },
    },	 

	-- ak --

    ["reload_ak"] = {
        Source = "reload_ak",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 1.6,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout-762.ogg", 		t = 12/40},
            {s = rottle, 			                    t = 20/40},
            {s = common .. "magpouch.ogg",              t = 32/40},
            {s = "weapons/uc_osk/struggle-762.ogg", 	t = 49/40},
            {s = "weapons/uc_osk/magin-762.ogg", 		t = 61/40},
            {s = rottle, 			                    t = 60/40},
        },
    },
    ["reload_empty_ak"] = {
        Source = "reload_empty_ak",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 2.3,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout-762.ogg", 		t = 12/40},
            {s = rottle, 			                    t = 20/40},
            {s = common .. "magpouch.ogg",              t = 32/40},
            {s = "weapons/uc_osk/struggle-762.ogg", 	t = 51/40},
            {s = "weapons/uc_osk/magin-762.ogg", 		t = 61/40},
            {s = rottle, 			                    t = 69/40},
            {s = "weapons/uc_osk/boltcatchpress.ogg", 	t = 85/40},
            {s = rottle, 			                    t = 88/40},
        },
    },

    ["enter_inspect_ak"] = {
        Source = "inspect_enter_ak",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_ak"] = {
        Source = "inspect_loop_ak",
        -- time = 72 / 60,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0
    },
    ["exit_inspect_ak"] = {
        Source = "inspect_exit_ak",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.375,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 20/40},
            {s = rottle, 			                    t = 17/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 60/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 70/40},
            {s = rottle, 			                    t = 69/40},
            {s = common .. "shoulder.ogg", 	        	t = 88/40, v = .5},
        },
    },
    ["enter_inspect_empty_ak"] = {
        Source = "inspect_enter_empty_ak",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_empty_ak"] = {
        Source = "inspect_loop_empty_ak",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_inspect_empty_ak"] = {
        Source = "inspect_exit_empty_ak",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.375,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 20/40},
            {s = rottle, 			                    t = 17/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 60/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 70/40},
            {s = rottle, 			                    t = 69/40},
            {s = common .. "shoulder.ogg", 	        	t = 88/40, v = .5},
        },
    },	
	
	-- ak drum--

    ["reload_ak_drum"] = {
        Source = "reload_ak_drum",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 2.1,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.25,
        LHIKEaseIn = 0.225,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout-762.ogg", 		t = 12/40},
            {s = rottle, 			                    t = 20/40},
            {s = common .. "magpouch.ogg",              t = 32/40},
            {s = "weapons/uc_osk/struggle-762.ogg", 	t = 54/40},
            {s = "weapons/uc_osk/magin-762.ogg", 		t = 64/40},
			{s = "weapons/uc_osk/magtap.ogg", 			t = 75/40},
            {s = rottle, 			                    t = 60/40},
        },
    },
    ["reload_empty_ak_drum"] = {
        Source = "reload_empty_ak_drum",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 2.8,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.25,
        LHIKEaseIn = 0.225,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout-762.ogg", 		t = 12/40},
            {s = rottle, 			                    t = 20/40},
            {s = common .. "magpouch.ogg",              t = 32/40},
            {s = "weapons/uc_osk/struggle-762.ogg", 	t = 54/40},
            {s = "weapons/uc_osk/magin-762.ogg", 		t = 64/40},
            {s = rottle, 			                    t = 69/40},
            {s = path .. "chpull.ogg",   				t = 95/40},
            {s = common .. "cloth_4.ogg", 				t = 98/40},
            {s = path .. "chrelease.ogg",  				t = 106/40},
            {s = rottle, 			                    t = 114/40},
        },
    },

    ["enter_inspect_ak_drum"] = {
        Source = "inspect_enter_ak_drum",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_ak_drum"] = {
        Source = "inspect_loop_ak_drum",
        -- time = 72 / 60,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0
    },
    ["exit_inspect_ak_drum"] = {
        Source = "inspect_exit_ak_drum",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.475,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = common .. "shoulder.ogg", 	        	t = 20/40, v = .5},
        },
    },
    ["enter_inspect_empty_ak_drum"] = {
        Source = "inspect_enter_empty_ak_drum",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_empty_ak_drum"] = {
        Source = "inspect_loop_empty_ak_drum",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_inspect_empty_ak_drum"] = {
        Source = "inspect_exit_empty_ak_drum",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.475,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = common .. "shoulder.ogg", 	        	t = 20/40, v = .5},
        },
    },	
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        --InstalledEles = {"upper_flat"}, no such thing
        Slot = {"optic","optic_sniper"},
        Bone = "W_Main",
        VMScale = Vector(1.15, 1.15, 1.15),
        Offset = {
            vpos = Vector(-0, -3.78, 0.5),
            vang = Angle(90, 0, -90),
        },
        //MergeSlots = {16},
    },
    {
        PrintName = "Barrel",
        DefaultAttName = "14\" Standard Barrel",
        Slot = "uc_myt_scar_hg",
        Bone = "W_Main",
        Offset = {
            vpos = Vector(3.5, -4.25, -7),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle"},
        Bone = "W_Main",
        Offset = {
            vpos = Vector(0, -1.65, 15.5),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"sd"},
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip"},
        Bone = "W_Main",
        Offset = {
            vpos = Vector(0, -0.75, 9),
            vang = Angle(90, 0, -90),
        },
        MergeSlots = {14},
    },
    {
        PrintName = "Tactical",
        Slot = {"tac"},
        Bone = "W_Main",
        Offset = {
            vpos = Vector(-1, -1.7, 9.5),
            vang = Angle(90, 0, 180),
        },
        GivesFlags = {"tac"},
        --InstalledEles = {"ud_m16_clamp_fullsize"}
    },
    {
        PrintName = "Grip Type",
        Slot = {"uc_myt_scar_grip"},
		Hidden = true,
        DefaultAttName = "Standard Grip",
    },
    {
        PrintName = "Stock",
        Slot = {"uc_myt_scar_stock"},
        DefaultAttName = "Standard Stock",
        MergeSlots = {15},
    },
    {
        PrintName = "Magazine",
        Slot = {"uc_myt_scar_mag"},
        Bone = "W_Main",
        Offset = {
            vpos = Vector(0, -0.75, 9),
            vang = Angle(90, 0, -90),
        },
        DefaultAttName = "20-Round Mag",
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm"},
        FreeSlot = true,
        Bone = "W_Main",
        Offset = {
            vpos = Vector(0.8, -1.9, 2.5),
            vang = Angle(90, 0, -90),
        },
	},
    {
        PrintName = "M203 slot",
        Slot = "uc_ubgl",
        Bone = "W_Main",
        Offset = {
            vpos = Vector(0, -1.75, 6), -- this is also changed by ModifyBodygroups
            vang = Angle(90, 0, -90),
        },
        Hidden = true,
        InstalledEles = {"mount_underbarrel"},
	},
    {
        PrintName = "Tube Stock Adaptor",
        Slot = {"go_stock"},
        -- GSO support
        Hidden = true,
        InstalledEles = {"stock_tube"},
        Bone = "W_Main",
        Offset = {
            vpos = Vector(0, -2.15, -7.5),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Hidden = true,
        InstalledEles = {"cust_irons"},
        Slot = {"ud_m16_rs"},
        Bone = "W_Main",
        Offset = {
            vpos = Vector(-0, -3.78, 0.5),
            vang = Angle(90, 0, -90),
        },
    },
}
--lua/weapons/arccw_uc_scarssr.lua:
return gluapack()()
--lua/weapons/arccw_uc_usp.lua:
return gluapack()()
--lua/weapons/arccw_uc_uspmatch.lua:
if !file.Exists("weapons/arccw_uc_usp.lua","LUA") then return end

include("weapons/arccw_uc_usp.lua") // Deriving the class from the base USP doesn't work because SWEP.Attachments is left blank

SWEP.Category = "ArcCW - UC Presets"
SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets Pistols"
end

SWEP.PrintName = "P93 Match"
SWEP.TrueName = "USP Match"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

SWEP.Attachments[1].Installed = "uc_usp_sight"
SWEP.Attachments[2].Installed = "uc_usp_slide_match"
SWEP.Attachments[3].Installed = "uc_usp_cal_9mm"
SWEP.Attachments[13].Installed = "uc_usp_skin_nickel"

SWEP.Hook_NameChange = function(wep)
    if !wep.Attachments[2].Installed then
        return GetConVar("arccw_truenames"):GetBool() and "USP Tactical" or "P93"
    end
end
--lua/weapons/arccw_ud_coltlmg.lua:
if !file.Exists("arccw/shared/languages/ud_en.lua","LUA") then return end

include("weapons/arccw_ud_m16.lua")

SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets LMGs"
end

SWEP.PrintName = "AMSAW-NG"
SWEP.TrueName = "Colt LMG"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

SWEP.Attachments[1].Installed = "ud_m16_rs_ch"
SWEP.Attachments[3].Installed = "ud_m16_hg_lmg"
SWEP.Attachments[6].Installed = "ud_m16_receiver_auto"
SWEP.Attachments[11].Installed = "ud_m16_mag_100"
--lua/weapons/arccw_ud_g18.lua:
return gluapack()()
--lua/weapons/arccw_ud_m1014.lua:
return gluapack()()
--lua/weapons/arccw_ud_m16.lua:
return gluapack()()
--lua/weapons/arccw_ud_m16.lua:
return gluapack()()
--lua/weapons/arccw_ud_870.lua:
return gluapack()()
--lua/weapons/arccw_ur_329.lua:
return gluapack()()
--lua/weapons/arccw_ur_ak101.lua:
return gluapack()()
--lua/weapons/arccw_ur_ak105.lua:
if !file.Exists("arccw/shared/sh_1_ur.lua","LUA") then return end

include("weapons/arccw_ur_ak.lua")

SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets Rifles"
end

SWEP.PrintName = "KF-105" -- make this something russian and cool
SWEP.TrueName = "AK-105"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

SWEP.Attachments[2].Installed = "ur_ak_barrel_105"
SWEP.Attachments[3].Installed = "ur_ak_hg_alpha"
--SWEP.Attachments[3].Installed = "ur_ak_muzzle_ak74"
SWEP.Attachments[5].Installed = "ur_ak_cal_545"
SWEP.Attachments[6].Installed = "ur_ak_mag_545_black"
SWEP.Attachments[9].Installed = "ur_ak_grip_alpha"
SWEP.Attachments[10].Installed = "ur_ak_stock_alpha"
SWEP.Attachments[15].Installed = "ur_ak_cover_alpha"
--lua/weapons/arccw_ur_ak.lua:
return gluapack()()
--lua/weapons/arccw_ur_aks74.lua:
if !file.Exists("arccw/shared/sh_1_ur.lua","LUA") then return end

include("weapons/arccw_ur_ak.lua")

SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets Rifles"
end

SWEP.PrintName = "KFS-76" -- make this something russian and cool
SWEP.TrueName = "AKS-74"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

SWEP.Attachments[3].Installed = "ur_ak_hg_74m"
SWEP.Attachments[4].Installed = "ur_ak_muzzle_bayonet"
SWEP.Attachments[5].Installed = "ur_ak_cal_545"
SWEP.Attachments[10].Installed = "ur_ak_stock_aks"

SWEP.Attachments[3].ToggleNum = 2
SWEP.Attachments[3].ToggleLock = true
SWEP.Attachments[10].ToggleLock = true
--lua/weapons/arccw_ur_ak.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "ArcCW - Urban Coalition" -- edit this if you like
SWEP.UC_CategoryPack = "2Urban Renewal"
SWEP.AdminOnly = false

SWEP.PrintName = "KF-67"
SWEP.TrueName = "AKM"

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

local descStart = "One of the first assault rifles, wielded around the world to this day for its cheap price, quick production, ease of maintenance, and infallible reliability. Consequently, it has become the most popular rifle ever; a constant of freedom fighters and third-world dictators virtually everywhere. One fifth of all small arms in existence can be traced to this design.\n\n"
local desc_762 = "The default pattern is well-rounded and hard-hitting, but kicks harder than other weapons of its class."
local desc_545 = "With a heavier frame than other service rifles, the AK-74 platform is accurate and easy to control."
local desc_74u = "This PDW variant sacrifices range and control to fit the power of a rifle into a very compact form."
local desc_9mm = "Well-rounded submachine gun that shares common parts with AK rifles. For its widespread use by a variety of security divisions, it can be described as a Russian counterpart to the MP5.\n\nThe moniker \"Vityaz\" translates to \"knight.\""
local desc_12g = "Magazine-fed semi automatic shotgun based on the Kalashnikov pattern. It is a popular civilian weapon due to the comparative simplicity of Russia's smoothbore gun licenses, but it has also been used by security firms around the world.\n\nIts low accuracy is compensated for by a much faster reload time than tube-fed designs."
local desc_556 = "This international variant has a lower damage output than the Russian cartridges, but boasts substantially lower recoil."
local desc_366 = "AK-pattern shotgun chambered in .366 TKM, a sporting cartridge that uses reshaped M43 casings. It is considered a shotgun because of its smoothbore barrel, a change made to circumvent Russian rifle laws. Despite the lack of rifling, it achieves similar ballistics to a proper AK-47."

SWEP.Trivia_Class = "Assault Rifle"
SWEP.Trivia_Desc = descStart .. desc_762
SWEP.Trivia_Manufacturer = "Izhmash"
SWEP.Trivia_Calibre = "7.62x39mm Soviet"
SWEP.Trivia_Mechanism = "Gas-Operated Rotating Bolt"
SWEP.Trivia_Country = "Soviet Union"
SWEP.Trivia_Year = 1959

SWEP.Slot = 2
SWEP.CamAttachment = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/c_ur_ak.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ur_ak.mdl"
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "010000800120"

-- Damage --

SWEP.Damage = 50 -- 2 shot close range kill
SWEP.DamageMin = 25 -- 4 shot long range kill
SWEP.RangeMin = 30
SWEP.Range = 300 -- 3 shot until ~170m
SWEP.Penetration = 16
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 715
SWEP.PhysBulletMuzzleVelocity = 715

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 30
SWEP.ExtendedClipSize = 40
SWEP.ReducedClipSize = 15

-- Recoil --

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.3

SWEP.RecoilRise = 0.6
SWEP.RecoilPunch = 1
SWEP.VisualRecoilMult = 1
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 1
SWEP.RecoilPunchBack = 2

SWEP.Sway = 0.6

-- Firerate / Firemodes --

SWEP.Delay = 60 / 600
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_ar2"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 800
SWEP.MoveDispersion = 250
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "ar2"
SWEP.MagID = "ak"

SWEP.HeatCapacity = 75
SWEP.HeatDissipation = 15
SWEP.HeatDelayTime = 3

-- SWEP.Malfunction = true
SWEP.MalfunctionMean = 200
--SWEP.MeleeTime = 1.5

-- Speed multipliers --

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.75

local path = ")weapons/arccw_ur/ak/"
local path1 = ")weapons/arccw_ur/mp5/"
local common = ")/arccw_uc/common/"
local rottle = {common .. "cloth_1.ogg", common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}
local rutle = {common .. "movement-rifle-01.ogg",common .. "movement-rifle-02.ogg",common .. "movement-rifle-03.ogg",common .. "movement-rifle-04.ogg"}
--SWEP.FirstShootSound = path .. "fire_first.ogg"

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}
SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = path .. "dryfire.ogg"

local tail = ")/arccw_uc/common/762x39/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-762x39-rif-ext-01.ogg",
    tail .. "fire-dist-762x39-rif-ext-02.ogg",
    tail .. "fire-dist-762x39-rif-ext-03.ogg",
    tail .. "fire-dist-762x39-rif-ext-04.ogg",
    tail .. "fire-dist-762x39-rif-ext-05.ogg",
    tail .. "fire-dist-762x39-rif-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-rifle-01.ogg",
    common .. "fire-dist-int-rifle-02.ogg",
    common .. "fire-dist-int-rifle-03.ogg",
    common .. "fire-dist-int-rifle-04.ogg",
    common .. "fire-dist-int-rifle-05.ogg",
    common .. "fire-dist-int-rifle-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

SWEP.MuzzleEffect = "muzzleflash_6"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/762x39.mdl"
SWEP.ShellPitch = 90
SWEP.ShellScale = .666
SWEP.ShellRotateAngle = Angle(0, 0, 0)
SWEP.UC_ShellColor = Color(0.7 * 255, 0.2 * 255, 0.2 * 255)

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.BulletBones = {
    [1] = "tag_mag2",
}

SWEP.IronSightStruct = {
    Pos = Vector(-2.61, -2, 0.45),
    Ang = Angle(0.60, 0.274, 5.53),
    Magnification = 1.1,
    SwitchToSound = "", -- sound that plays when switching to this sight
    CrosshairInSights = false
}
SWEP.LaserOffsetAngle = Angle(0, 0, 0)
SWEP.LaserIronsAngle = Angle(0, 0, 0)

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0.5, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 0)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-2, -2, -0.6)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.HolsterPos = Vector(-1, -1, 1.2)
SWEP.HolsterAng = Angle(-15, 8, -10)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(0, 0, 0)

-- SWEP.CustomizePos = Vector(6.5, 0.8, -0.2)
-- SWEP.CustomizeAng = Angle(8, 22, 15)

SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.BarrelLength = 24

SWEP.AttachmentElements = {
    ["barrel_74m"] = {
        VMBodygroups = {{ind = 1, bg = 3}}
    },
    ["barrel_74m_red"] = {
        VMBodygroups = {{ind = 1, bg = 10}}
    },
    ["barrel_74m_green"] = {
        VMBodygroups = {{ind = 1, bg = 11}}
    },
    ["barrel_akm"] = {
        VMBodygroups = {{ind = 1, bg = 0}}
    },
    ["barrel_alpha"] = {
        VMBodygroups = {
            {ind = 1, bg = 7},
            -- {ind = 7, bg = 6},
            -- {ind = 8, bg = 2},
        },
    },
    ["barrel_rpk"] = {
        VMBodygroups = {
            {ind = 7, bg = 1},
            {ind = 8, bg = 2}
        },
        AttPosMods = {[4] = {
            vpos = Vector(0, 32.2, 2.6),
            vang = Angle(0, 270, 0),
        }},
    Override_IronSightStruct = {
            Pos = Vector(-2.625, -2, 0.68),
            Ang = Angle(-0.1, 0.274, 5.53),
            Magnification = 1,
    }
    },
    ["barrel_rpk74m"] = {
        VMBodygroups = {
            {ind = 1, bg = 5},
            -- {ind = 7, bg = 1},
            -- {ind = 8, bg = 2}
        },
        -- AttPosMods = {[4] = {
        --     vpos = Vector(0, 32.2, 2.6),
        --     vang = Angle(0, 270, 0),
        -- }},
        -- Override_IronSightStruct = {
        -- 	Pos = Vector(-2.625, -2, 0.68),
        -- 	Ang = Angle(-0.1, 0.274, 5.53),
        -- 	Magnification = 1,
        -- }
    },
    ["barrel_krinkov"] = {
        VMBodygroups = {
            {ind = 1, bg = 6},
            {ind = 7, bg = 5},
            {ind = 8, bg = 2},
            {ind = 4, bg = 1},
            {ind = 5, bg = 1}
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, 15, 2.85),
                vang = Angle(0, 270, 0),
            },
            [7] = {
                vpos = Vector(0,10,1.7),
                vang = Angle(90, -90, -90),
                SlideAmount = {
                    vmin = Vector(0,10,1.7),
                    vmax = Vector(0,10,1.7)
                },
            },
            [8] = {
                vpos = Vector(-0.8, 11.75, 2.9),
                vang = Angle(-90, 270, 0),
                wang = Angle(-90, 270, 0),
            }
        },
        Override_IronSightStruct = {
            Pos = Vector(-2.638, -2, 0.9),
            Ang = Angle(-1, 0.12, 5.53),
            Magnification = 1,
        }
    },
    ["barrel_vityaz"] = {
        VMBodygroups = {
            {ind = 1, bg = 8},
            {ind = 7, bg = 5},
            {ind = 8, bg = 2},
            {ind = 5, bg = 1}
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, 16.5, 2.85),
                vang = Angle(0, 270, 0),
            },
            [7] = {
                vpos = Vector(0,11,1.7),
                vang = Angle(90, -90, -90),
                SlideAmount = {
                    vmin = Vector(0,10,1.7),
                    vmax = Vector(0,11,1.7)
                },
            },
            [8] = {
                vpos = Vector(-0.8, 11.75, 2.9),
                vang = Angle(-90, 270, 0),
                wang = Angle(-90, 270, 0),
            }
        },
        Override_IronSightStruct = {
            Pos = Vector(-2.62, -2, 0.75),
            Ang = Angle(-0.42, 0.2, 5.53),
            Magnification = 1,
        }
    },
    ["barrel_t56"] = {
        VMBodygroups = {
            {ind = 7, bg = 3},
            {ind = 11, bg = 2},
            {ind = 8, bg = 2}
        },
    },
    ["barrel_t56_ext"] = {
        VMBodygroups = {
            {ind = 7, bg = 3},
            {ind = 11, bg = 3},
            {ind = 8, bg = 2}
        },
    },
    ["barrel_vepr"] = {
        VMBodygroups = {
            --{ind = 1, bg = 9},
            {ind = 7, bg = 4},
            {ind = 8, bg = 2}
        },
        AttPosMods = {[4] = {
            vpos = Vector(0, 28.5, 2.7),
            vang = Angle(0, 270, -0),
        }},
        Override_IronSightStruct = {
            Pos = Vector(-2.63, -2, 0.76),
            Ang = Angle(-0.3, 0.18, 5.53),
            Magnification = 1,
        }
    },

    ["ur_ak_hg_vepr"] = {
        VMBodygroups = {
            {ind = 1, bg = 9},
        },
    },

    ["barrel_105"] = {
        VMBodygroups = {
            --{ind = 1, bg = 3},
            {ind = 7, bg = 2},
            {ind = 8, bg = 2}
        },
        AttPosMods = {[4] = {
            vpos = Vector(0, 19.9, 2.7),
            vang = Angle(0, 270, 0),
        }},
        Override_IronSightStruct = {
            Pos = Vector(-2.6, -2, 0.48),
            Ang = Angle(0.6, 0.265, 5.53),
            Magnification = 1,
        }
    },
    ["barrel_dong"] = {
        VMBodygroups = {{ind = 1, bg = 2}}, -- This will show up regardless of barrel selection because underbarrel atts are always processed after barrel atts
        AttPosMods = {[6] = {
            SlideAmount = {
                vmin = Vector(0,12,1.9),
                vmax = Vector(0,12,1.9)
            },
        }}
    },

    ["muzzle_akm"] = {
        VMBodygroups = {{ind = 8, bg = 1}}
    },
    ["muzzle_ak74"] = {
        VMBodygroups = {{ind = 8, bg = 3}}
    },
    ["muzzle_aku"] = {
        VMBodygroups = {{ind = 8, bg = 6}}
    },
    ["muzzle_bayonet"] = {
        VMBodygroups = {{ind = 11, bg = 1}}
    },

    ["stock_alpha"] = {
        VMBodygroups = {
            {ind = 6, bg = 4},
            {ind = 3, bg = 1},
        }

    },
    ["stock_aks"] = {
        VMBodygroups = {
            {ind = 6, bg = 3},
            {ind = 3, bg = 1},
    }
    },
    ["stock_aks_folded"] = {
        VMBodygroups = {
            {ind = 6, bg = 10},
            {ind = 3, bg = 1},
        }

    },
    ["stock_underfolder"] = {
        VMBodygroups = {{ind = 6, bg = 2}}
    },
    ["stock_underfolder_folded"] = {
        VMBodygroups = {{ind = 6, bg = 1}}
    },
    ["stock_ak74m"] = {
        VMBodygroups = {
            {ind = 3, bg = 1},
            {ind = 6, bg = 12}
        }
    },
    ["stock_ak74m_folded"] = {
        VMBodygroups = {
            {ind = 3, bg = 1},
            {ind = 6, bg = 13}
        }
    },
    ["stock_rpk"] = {
        VMBodygroups = {{ind = 6, bg = 5}}
    },
    ["stock_akn"] = {
        VMBodygroups = {{ind = 6, bg = 0}}
    },
    ["stock_skeletal"] = {
        VMBodygroups = {
            {ind = 6, bg = 6},
            {ind = 3, bg = 1},
        }
    },
    ["stock_vepr"] = {
        VMBodygroups = {
            {ind = 6, bg = 7},
            {ind = 9, bg = 4}
        }
    },
    ["stock_none"] = {
        VMBodygroups = {
            {ind = 6, bg = 9},
            {ind = 3, bg = 1},
        }
    },

    ["mag_762_75"] = {
        VMBodygroups = {{ind = 2, bg = 1}}
    },
    ["mag_762_bakelite"] = {
        VMBodygroups = {{ind = 2, bg = 11}}
    },
    ["mag_762_pmag"] = {
        VMBodygroups = {{ind = 2, bg = 12}}
    },
    ["mag_545_30"] = {
        VMBodygroups = {{ind = 2, bg = 2}}
    },
    ["mag_556_30"] = {
        VMBodygroups = {{ind = 2, bg = 10}}
    },
    ["mag_545_45"] = {
        VMBodygroups = {{ind = 2, bg = 3}}
    },
    ["mag_9mm"] = {
        VMBodygroups = {{ind = 2, bg = 4}}
    },
    ["mag_12g"] = {
        VMBodygroups = {{ind = 2, bg = 5}}
    },
    ["mag_366"] = {
        VMBodygroups = {{ind = 2, bg = 6}}
    },

    ["grip_akm"] = {
        VMBodygroups = {{ind = 9, bg = 0}}
    },
    ["grip_alpha"] = {
        VMBodygroups = {{ind = 9, bg = 2}}
    },
    ["grip_saiga"] = {
        VMBodygroups = {{ind = 9, bg = 3}}
    },

    ["cover_ribbed"] = {
        VMBodygroups = {{ind = 10, bg = 0}}
    },
    ["cover_alpha"] = {
        VMBodygroups = {{ind = 10, bg = 1}},
        AttPosMods = {[1] = {
            vpos = Vector(0, 3.5, 4.68),
            vang = Angle(0, -90, 0),
        }}
    },
    ["optic_raillaser"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(0.95, 2.5, 4.05),
                vang = Angle(0, -90, 125),
            },
        },
    },
    ["cover_ak12"] = {
        VMBodygroups = {{ind = 10, bg = 4}},
        AttPosMods = {[1] = {
            vpos = Vector(0, 3.5, 4.67),
            vang = Angle(0, -90, 0),
        }}
    },

    ["grip_ak12"] = {
        VMBodygroups = {{ind = 9, bg = 5}}
    },
    ["stock_ak12"] = {
        VMBodygroups = {{ind = 6, bg = 11}},
    },
    ["handguard_ak12"] = {
        VMBodygroups = {{ind = 1, bg = 12}},
        --[[AttPosMods = {[6] = {
            vpos = Vector(0, 11.75, 2.2),
            vang = Angle(90, -90, -90),
        }}]]
        AttPosMods = {
            [8] = {
                vpos = Vector(-0.7, 13.5, 3.8),
                vang = Angle(-90, 270, 0),
                wang = Angle(-90, 270, 0),
            },
            [7] = {
                vpos = Vector(0, 11.75, 2.2),
                vang = Angle(90, -90, -90),
            }
        },
    },
    ["barrel_ak12"] = {
        VMBodygroups = {
            {ind = 7, bg = 6},
            {ind = 8, bg = 2}
        },
        AttPosMods = {[4] = {
            vpos = Vector(0, 23.5, 2.8),
            vang = Angle(0, 270, 0),
        }},
        Override_IronSightStruct = {
            Pos = Vector(-2.68, 0, 1.3),
            Ang = Angle(-2.02, 0.028, 5.53),
            Magnification = 1,
        }
        --RequireFlags = {"cover_rail"},
    },
    ["muzzle_ak12"] = {
        VMBodygroups = {{ind = 8, bg = 2}},
    },
    ["reciever_ak12"] = {
        VMBodygroups = {{ind = 0, bg = 1}}
    },
    ["sight_ak12"] = {
        VMBodygroups = {{ind = 4, bg = 3}},
        RequireFlags = {"cover_rail", "ak_railedguard"},
        Override_IronSightStruct = {
            Pos = Vector(-2.63, 0, 0.79),
            Ang = Angle(-1.12, 0.116, 5.53),
            Magnification = 1,
        },
        Override_IronSightStruct_Priority = 2,
    },
    ["mag_545_ak12"] = {
        VMBodygroups = {{ind = 2, bg = 7}}
    },
    ["mag_545_black"] = {
        VMBodygroups = {{ind = 2, bg = 9}}
    },
    ["mag_308"] = {
        VMBodygroups = {{ind = 2, bg = 8}}
    },

    ["cover_trail"] = {
        VMBodygroups = {{ind = 4, bg = 4}},
        AttPosMods = {[1] = {
            vpos = Vector(0, 8.2, 5.20),
            vang = Angle(0, -90, 0),
        }}
    },
}

SWEP.Hook_ModifyBodygroups = function(wep, data)
    local akOptics = {["uc_optic_pso1"] = true, ["uc_optic_kobra"] = true} -- Will need to update this list if more AK optics get added
    local railHgs = {["default"] = true, ["type3"] = true}
    local bipodBarrs = {["rpk"] = true}
    local shortBarrs = {["krinkov"] = true, ["vityaz"] = true}
    local intCals = {["545"] = true, ["556"] = true, ["545_ak12"] = true}

    local optic = wep.Attachments[1].Installed
    local barr = string.Replace(wep.Attachments[2].Installed or "default","ur_ak_barrel_","")
    local hg = string.Replace(wep.Attachments[3].Installed or "default","ur_ak_hg_","")
    local muzz = wep.Attachments[4].Installed
    local cal = string.Replace(wep.Attachments[5].Installed or "default","ur_ak_cal_","")
    local ub = wep.Attachments[7].Installed-- or wep.Attachments[17].Installed
    local upper = wep.Attachments[15].Installed
    local alpha = (upper == "ur_ak_cover_alpha" or upper == "ur_ak_cover_ak12" or upper == "ur_ak_cover_truniun_rail")
    local taclaser = (wep.Attachments[16].Installed == "ur_ak_charm_tl")

    local vm = data.vm
    if !IsValid(vm) then return end

    -- Default muzzle devices
    if !muzz or muzz == "ur_ak_muzzle_bayonet" then
        if barr == "ak12" and (cal == "default" or intCals[cal]) then
            vm:SetBodygroup(8,3)
        elseif barr == "krinkov" then
            vm:SetBodygroup(8,4)
        elseif barr == "default" or barr == "t56" then
            if cal == "default" then
                vm:SetBodygroup(8,1)
            elseif intCals[cal] then
                vm:SetBodygroup(8,3)
            else
                vm:SetBodygroup(8,0)
            end
        end
    elseif barr == "default" then
        vm:SetBodygroup(8,0)
    else
        vm:SetBodygroup(8,2)
    end

    --
    if taclaser and !akOptics[optic] then
        vm:SetBodygroup(12,2)
    else
        if optic and !alpha and !akOptics[optic] then
            vm:SetBodygroup(12,1)
        else
            vm:SetBodygroup(12,0)
        end
    end

    -- Railed underbarrel
    if ub and hg != "ur_ak_hg_dong" and barr != "vityaz" then
        if barr == "krinkov" then
            vm:SetBodygroup(13,2)
        elseif railHgs[hg] then
            vm:SetBodygroup(1,13)
        else
            vm:SetBodygroup(13,1)
        end
    else
        vm:SetBodygroup(13,0)
    end

    -- RPK bipod
    if bipodBarrs[barr] then
        vm:SetBodygroup(7, (wep:GetInBipod() and (wep.LastAnimKey ~= "enter_bipod" or wep.LastAnimFinishTime < CurTime())) and 7 or 1)
    end
end

SWEP.ExtraSightDist = 2
SWEP.GuaranteeLaser = false

SWEP.WorldModelOffset = {
    pos = Vector(-7, 4, -4),
    ang = Angle(-12, 0, 180)
}

SWEP.MirrorVMWM = true

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic","optic_sniper","ur_ak_optic"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 2, 4.92),
            vang = Angle(0, -90, 0),
        },
        CorrectivePos = Vector(0, 0, -0.0),
        CorrectiveAng = Angle(-1.9, 180.15, 0),
        VMScale = Vector(1, 1, 1),
        -- SlideAmount = {
        --     vmin = Vector(0, 2-1, 4.55),
        --     vmax = Vector(0, 2+0.5, 4.55),
        -- },
--        RequireFlags = {"cover_rail"},
--        HideIfBlocked = true,
        -- InstalledEles = {"optic_rail"},
    },
    {
        PrintName = "Barrel",
        DefaultAttName = "16\" Standard Barrel",
        DefaultAttIcon = Material("entities/att/ur_ak/barrel/std.png", "mips smooth"),
        Slot = "ur_ak_barrel",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0,12, 1.9),
            vang = Angle(90, -90, -90),
        },
    },
    {
        PrintName = "Handguard",
        DefaultAttName = "Factory Handguard",
        DefaultAttIcon = Material("entities/att/ur_ak/handguards/std.png", "mips smooth"),
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0,12, 1.9),
            vang = Angle(90, -90, -90),
        },
        Slot = "ur_ak_hg",
        ExcludeFlags = {"barrel_carbine"},
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle","ur_ak_muzzle"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 24.1, 2.7),
            vang = Angle(0, 270, 0),
        },
        ExcludeFlags = {"ur_ak_nomuzzle"},
        --Installed = "ur_ak_muzzle_akm"
    },
    {
        PrintName = "Receiver",
        DefaultAttName = "7.62x39mm Reciever",
        DefaultAttIcon = Material("entities/att/uc_bullets/762x39.png", "mips smooth"),
        Slot = {"ur_ak_cal"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(2.8, -4.2, -11.5),
            vang = Angle(90, 0, -90),
        },
        DefaultFlags = {"cal_default"}
    },
    {
        PrintName = "Magazine",
        Slot = {"ur_ak_mag"},
        DefaultAttName = "30-Round Mag",
        DefaultAttIcon = Material("entities/att/ur_ak/magazines/762_30.png", "mips smooth"),
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip","ur_ak_ub"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0,12, 1.9),
            vang = Angle(90, -90, -90),
        },
        VMScale = Vector(1, 1, 1),
        SlideAmount = {
            vmin = Vector(0,10.5,1.9),
            vmax = Vector(0,13.5,1.9)
        },
        InstalledEles = {"rail_fg"},
        ExcludeFlags = {"ak_noubs"},
        MergeSlots = {17},
    },
    {
        PrintName = "Tactical",
        Slot = {"tac"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 19.6, 2.1),
            vang = Angle(0, 270, 0),
        },
        GivesFlags = {"tac"},
        --InstalledEles = {"ud_m16_clamp_fullsize"}
    },
    {
        PrintName = "Grip Type",
        Slot = {"ur_ak_grip"},
        DefaultAttName = "Factory Grip",
        DefaultAttIcon = Material("entities/att/ur_ak/grip_modern.png", "mips smooth"),
        ExcludeFlags = {"stock_vepr"},
    },
    {
        PrintName = "Stock",
        Slot = {"ur_ak_stock"},
        DefaultAttName = "Factory Stock",
        DefaultAttIcon = Material("entities/att/ur_ak/stock/n.png", "mips smooth"),
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Dust Cover",
        DefaultAttName = "Ribbed Dust Cover",
        DefaultAttIcon = Material("entities/att/ur_ak/dustcover_stock.png", "mips smooth"),
        Slot = {"ur_ak_cover"},
        FreeSlot = true,
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm", "ur_ak_charm"},
        FreeSlot = true,
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0.6, 6.7, 2.2),
            vang = Angle(90, -90, -90),
        },
    },
    {
        PrintName = "M203 slot",
        Slot = "uc_ubgl",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 9.9, 2.9),
            vang = Angle(90, -90, -90),
        },
        InstalledEles = {"rail_fg"},
        ExcludeFlags = {"ak_noubs","barrel_rpk"},
        Hidden = true,
    }
}

function SWEP:Hook_TranslateAnimation(anim)
    if anim == "fire_iron" then
        if self:GetBuff_Override("NoStock") then return "fire" end
    elseif anim == "fire_iron_empty" then
        if self:GetBuff_Override("NoStock") then return "fire_empty" end
    end
end

SWEP.Hook_NameChange = function(wep,name)
    local foldStocks = {["underfolder"] = true,["aks"] = true}
    local akCals = {["762"] = true,["545"] = true}
    local shortBarrs = {["krinkov"] = true,["vityaz"] = true}
    local fakeNames = !GetConVar("arccw_truenames"):GetBool()

    local start = "AK"
    local mid = ""
    local post = "M"
    local noN = false

    if fakeNames then
        start = "KF"
        post = "-67"
    end

    local atts = wep.Attachments
    local barr = string.Replace(atts[2].Installed or "default", "ur_ak_barrel_", "")
    local hg = string.Replace(atts[3].Installed or "default", "ur_ak_hg_", "")
    local cal = string.Replace(atts[5].Installed or "762", "ur_ak_cal_", "")
    local stock = string.Replace(atts[10].Installed or "default", "ur_ak_stock_", "")
    local upper = atts[11].Installed
    local alpha = (upper == "ur_ak_cover_alpha" or upper == "ur_ak_cover_ak12" or upper == "ur_ak_cover_truniun_rail")
    -- local ak12 = alpha and barr == "ak12"

    wep.Trivia_Desc = descStart .. desc_762
    wep.Trivia_Mechanism = "Gas-Operated Rotating Bolt"

    if alpha then noN = true end

    if atts[14].Installed == "uc_fg_civvy" then
        start = (fakeNames and "Amur") or "Vepr"
        if cal == "12g" then
            post = "-12"
            wep.Trivia_Desc = desc_12g
        elseif cal == "545_ak12" or cal == "545" then
            post = " 5.45"
            wep.Trivia_Desc = descStart .. desc_545
        elseif cal == "762" then
            post = " 7.62"
        elseif cal == "9mm" then
            start = "Saiga"
            post = "-9"
            wep.Trivia_Desc = desc_9mm
            wep.Trivia_Mechanism = "Blowback"
        else
            post = " ." .. cal
        end
        return start .. post
    end

    if cal == "9mm" then
        if fakeNames then
            start = "Bogatyr"
            post = " SMG"
        else
            start = "PP"
            post = "-19 Vityaz"
        end
        wep.Trivia_Desc = desc_9mm
        wep.Trivia_Mechanism = "Blowback"
    -- elseif cal == "12g" then
    --     start = "Saiga"
    --     if shortBarrs[barr] then
    --         post = "-12K"
    --     else
    --         post = "-12"
    --     end
    --     wep.Trivia_Desc = desc_12g -- Obsolete
    elseif cal == "366" then
        if barr == "vepr" or string.find(atts[14].Installed or "","rifling") then
            start = (fakeNames and "Amur") or "Vepr"
            post = " .366"
        else
            start = (fakeNames and "KFN") or "VPO"
            post = "-209"
            wep.Trivia_Desc = desc_366
        end
    elseif cal == "308" then
        post = "-308"
    -- elseif cal == "545_ak12" or ak12 then
    --     noN = true
    --     if string.StartWith(cal,"545") then
    --         post = "-12"
    --         wep.Trivia_Desc = descStart .. desc_545
    --     elseif cal == "762" then
    --         post = "-15"
    --     elseif cal == "556" then
    --         post = "-18"
    --     end
    --     if string.EndsWith(barr,"105") or shortBarrs[barr] then
    --         post = post .. "K"
    --     end -- Obsolete
    elseif barr == "rpk" or barr == "rpk74m" then
        start = (fakeNames and "PKF") or "RPK"
        if !fakeNames and barr == "rpk" and cal == "762" then
            post = ""
        end
    elseif cal == "762" then
        if barr == "t56" then
            noN = true
            if fakeNames then
                start = "Yucha"
                post = " 7"
            else
                start = "Type "
                post = "56"
            end
        elseif (hg == "74m" or hg == "rpk74m" or hg == "ak12") and stock == "ak74m" then
            noN = true
            post = "-103"
        end
    elseif cal == "556" then
        if fakeNames then
            post = "-45"
        elseif string.EndsWith(barr,"105") then
            post = "-102"
        else
            post = "-101"
        end
        wep.Trivia_Desc = descStart .. desc_556
    end

    if foldStocks[stock] and akCals[cal] and !string.StartWith(barr,"105") then
        if cal == "762" then
            if barr == "t56" then
                post = post .. "-1"
            elseif !fakeNames then
                post = "MS"
            else
                mid = "S"
            end
        else
            mid = "S"
        end
    end

    if cal == "545" then
        wep.Trivia_Desc = descStart .. desc_545
        if (hg == "74m" or hg == "rpk74m" or hg == "ak12") and stock == "ak74m" then
            noN = true
            post = (fakeNames and "-76M") or "-74M"
        elseif shortBarrs[barr] then
            if fakeNames then
                post = "-76"
                mid = mid .. "U"
            else
                post = "-74U"
            end
            wep.Trivia_Desc = descStart .. desc_74u
        else
            post = (fakeNames and "-76") or "-74"
        end
    end

    if akCals[cal] then
        if string.EndsWith(barr,"105") then
            noN = true
            if cal == "545" then
                post = "-105"
            elseif cal == "762" then
                post = "-104"
            elseif cal == "556" then
                post = "-102"
            end
        else
            -- if shortBarrs[barr] then
            --     post = post .. "U" -- I know I said the AK-47U doesn't exist, but we have fucking Glock 44 Autos so I warmed up to it
            --     wep.Trivia_Desc = descStart .. desc_74u
            -- end
            if !noN and atts[1].Installed then
                post = post .. "N"
            end
        end

    end

    return start .. mid .. post
end

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["draw"] = {
        Source = "draw",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "raise.ogg", t = 0.2},
            {s = common .. "shoulder.ogg",    t = 0.2},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        SoundTable = {
            {s = ratel, t = 0},
           -- {s = common .. "raise.ogg", t = 0.2},
            -- {s = common .. "shoulder.ogg",    t = 0.2},
        },
    },
    ["ready"] = {
        Source = "ready",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.6,
        LHIKEaseOut = 0.25,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "chback.ogg",    t = 0.2},
            {s = path .. "chamber.ogg",    t = 0.3},
            {s = common .. "shoulder.ogg",    t = .6},
        },
    },
    ["fire"] = {
        Source = {"fire"},
        Time = 0.5,
        ShellEjectAt = 0,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    ["fire_iron"] = {
        Source = {"fire"},
        Time = 0.5,
        ShellEjectAt = 0,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.65,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = common .. "magpouch.ogg", t = 0.0, v = 0.45},
            {s = path .. "reload_start.ogg", 	 t = 0.025},
            {s = rottle,  t = 0.05},
            {s = ratel, t = 0.25},
            {s = path .. "magrelease.ogg", 	 t = 0.4},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.35},
            {s = common .. "magpouchin.ogg", t = 1.38},
            {s = path .. "grab.ogg", t = 1.9, v = 0.45},
            {s = common .. "shoulder.ogg", t = 2.0},
            {s = path .. "shoulder.ogg", t = 2.15},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magrelease.ogg", 	 t = 0.4},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = path .. "bonk.ogg", 	 t = 0.5},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin.ogg",    t = 0.97},
            {s = ratel, t = 1.1},
            {s = common .. "rifle_magdrop.ogg", t = 1.15, v = 0.5},
            {s = rottle,  t = 1.16},
            {s = path .. "chback.ogg",    t = 1.9},
            {s = path .. "chamber.ogg",    t = 2.0},
            {s = path .. "grab.ogg", t = 2.3, v = 0.45},
            {s = common .. "shoulder.ogg", t = 2.4},
            {s = path .. "shoulder.ogg", t = 2.5},
        },
    },
    ["reload_75"] = {
        Source = "reload_drum",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.9,
        LHIKEaseOut = 0.25,
        MinProgress = 1.6,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magrelease.ogg", 	 t = 0.1},
            {s = path .. "magout_drum.ogg", 	 t = 0.25},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = ratel, t = 1.0},
            {s = path .. "magin_drum.ogg",    t = 1.1},
            {s = rottle,  t = 1.75},
            {s = path .. "grab.ogg", t = 2.0, v = 0.45},
            {s = common .. "shoulder.ogg", t = 2.1},
            {s = path .. "shoulder.ogg", t = 2.25},
        },
    },
    ["reload_empty_75"] = {
        Source = "reload_drum_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 1.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.6,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magrelease.ogg", 	 t = 0.1},
            {s = path .. "magout_drum.ogg", 	 t = 0.25},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = ratel, t = 1.0},
            {s = path .. "magin_drum.ogg",    t = 1.1},
            {s = path .. "grab.ogg", t = 2.0, v = 0.45},
            {s = rottle,  t = 1.9},
            {s = path .. "chback.ogg",    t = 2.37},
            {s = path .. "chamber.ogg",    t = 2.48},
            {s = common .. "shoulder.ogg", t = 2.78},
            {s = path .. "shoulder.ogg", t = 2.93},
        },
    },
    ["reload_9mm"] = {
        Source = "reload_9mm",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.9,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path1 .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path1 .. "magin.ogg",    t = 0.73},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.4},
            {s = common .. "magpouchin.ogg", t = 1.35},
            {s = common .. "shoulder.ogg", t = 2.05},
            {s = common .. "grab.ogg", t = 2.1},
        },
    },
    ["reload_empty_9mm"] = {
        Source = "reload_9mm_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path1 .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path1 .. "magin.ogg",    t = 0.85},
            {s = ratel, t = 1.1},
            {s = common .. "pistol_magdrop.ogg", t = 1.15},
            {s = rottle,  t = 1.15},
            {s = path .. "chback_9.ogg",    t = 1.8},
            {s = path .. "chamber_9.ogg",    t = 2.05},
            {s = common .. "grab.ogg", t = 2.4},
            {s = common .. "shoulder.ogg", t = 2.5},
        },
    },
    ["reload_10rnd"] = {
        Source = "reload_10rnd",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.9,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.35},
            {s = common .. "magpouchin.ogg", t = 1.35},
            {s = common .. "shoulder.ogg", t = 2.05},
            {s = common .. "grab.ogg", t = 2.1},
        },
    },
    ["reload_empty_10rnd"] = {
        Source = "reload_10rnd_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = path .. "bonk.ogg", 	 t = 0.5},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin.ogg",    t = 0.97},
            {s = ratel, t = 1.1},
            {s = common .. "rifle_magdrop.ogg", t = 1.15},
            {s = rottle,  t = 1.15},
            {s = path .. "chback.ogg",    t = 1.9},
            {s = path .. "chamber.ogg",    t = 2.0},
            {s = common .. "grab.ogg", t = 2.4},
            {s = common .. "shoulder.ogg", t = 2.5},
        },
    },
    ["reload_308"] = {
        Source = "reload_308",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.9,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin_308.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.35},
            {s = common .. "magpouchin.ogg", t = 1.35},
            {s = common .. "shoulder.ogg", t = 2.05},
            {s = common .. "grab.ogg", t = 2.1},
        },
    },
    ["reload_empty_308"] = {
        Source = "reload_308_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = path .. "bonk.ogg", 	 t = 0.5},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin_308.ogg",    t = 1.0},
            {s = ratel, t = 1.1},
            {s = common .. "rifle_magdrop.ogg", t = 1.15},
            {s = rottle,  t = 1.15},
            {s = path .. "chback_308.ogg",    t = 1.85},
            {s = path .. "chamber_308.ogg",    t = 2.0},
            {s = common .. "grab.ogg", t = 2.4},
            {s = common .. "shoulder.ogg", t = 2.5},
        },
    },
    ["reload_12g"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.65,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "12ga/magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "12ga/magin.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.35},
            {s = common .. "magpouchin.ogg", t = 1.35},
            {s = common .. "shoulder.ogg", t = 2.05},
            {s = common .. "grab.ogg", t = 2.1},
        },
    },
    ["reload_empty_12g"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "12ga/magout.ogg", 	 t = 0.45},
            {s = path .. "bonk.ogg", 	 t = 0.5, v = 0.25},
            {s = ratel, t = 0.55},
            {s = rottle,  t = 0.75},
            {s = path .. "12ga/magin.ogg",    t = 0.97},
            {s = ratel, t = 1.1},
            {s = common .. "rifle_magdrop.ogg", t = 1.15},
            {s = rottle,  t = 1.75},
            {s = path .. "12ga/chback.ogg",    t = 1.85},
            {s = path .. "12ga/chamber.ogg",    t = 2.0},
            {s = common .. "grab.ogg", t = 2.4},
            {s = common .. "shoulder.ogg", t = 2.5},
        },
    },
    ["enter_inspect"] = {
        Source = "inspect_enter",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect"] = {
        Source = "inspect_loop",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
    },
    ["exit_inspect"] = {
        Source = "inspect_exit",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
        SoundTable = {
            {s = common .. "movement-rifle-04.ogg", t = 0.2},
            {s = rottle, t = 0.25},
            {s = rottle, t = 1.2},
            {s = common .. "movement-rifle-03.ogg", t = 1.25},
        },
    },
    ["enter_sprint"] = {
        Source = "sprint_start",
        Time = 0.9,
    },
    ["idle_sprint"] = {
        Source = "sprint_idle",
    },
    ["exit_sprint"] = {
        Source = "sprint_end",
        Time = 1.25,
    },
    ["unjam"] = {
        Source = "jamfix",
        -- Time = 45 / 30,
        ShellEjectAt = 0.65,
        -- LHIK = true,
        -- LHIKIn = 0.3,
        -- LHIKEaseIn = 0.4,
        -- LHIKEaseOut = 0.15,
        -- LHIKOut = 0.4,
        -- SoundTable = {                                             zenith do noises here
        --     {s = path .. "chback.ogg",   t = 0.15},
        --     {s = common .. "cloth_4.ogg",  t = 0.5},
        --     {s = path .. "chamber.ogg",  t = 0.5},
        -- },
        SoundTable = {
            {s = common .. "cloth_4.ogg",  t = 0.1},
            {s = path .. "presscheck_1.ogg",    t = 0.2},
            {s = path .. "chback.ogg",    t = 0.6},
            {s = path .. "chamber.ogg",    t = 0.7},
            {s = common .. "grab.ogg", t = 1.1},
            {s = common .. "shoulder.ogg", t = 1.15},
        }
    },
    ["bash_bayonet"] = {
        Source = "bayonet",
        --Time = 1.2,
        --MinProgress = .7,
        SoundTable = {
            {s = "weapons/arccw/melee_lift.wav", t = 0}
        }
    },

    ["exit_bipod"] = {
        Source = "bipod_undeploy",
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        --Time = 1.2,
        --MinProgress = .7,
        Mult = .8,
        SoundTable = {
            -- {s = "weapons/arccw/melee_lift.wav", t = 0}
        }
    },
    ["enter_bipod"] = {
        Source = "bipod_deploy",
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        --Time = 1.2,
        --MinProgress = .7,
        Mult = .8,
        SoundTable = {
            -- {s = "weapons/arccw/melee_lift.wav", t = 0}                   -- yeah here too
        }
    },
}

SWEP.Hook_Think = ArcCW.UC.ADSReload
--lua/weapons/arccw_ur_db.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - Urban Coalition"
SWEP.UC_CategoryPack = "2Urban Renewal"
SWEP.AdminOnly = false
SWEP.UseHands = true

-- Muzzle and shell effects --

SWEP.MuzzleEffect = "muzzleflash_shotgun"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/12g.mdl"
SWEP.ShellPitch = 100
SWEP.ShellSounds = ArcCW.ShotgunShellSoundsTable
SWEP.ShellScale = 1
SWEP.UC_ShellColor = Color(0.7*255, 0.2*255, 0.2*255)

SWEP.MuzzleEffectAttachment = 1
SWEP.CaseEffectAttachment = 6
SWEP.CamAttachment = 7

-- Fake name --

SWEP.PrintName = "Volga Super" -- it's marketed to Americans

-- True name --

SWEP.TrueName = "IZh-58"

-- Trivia --

SWEP.Trivia_Class = "Shotgun"
SWEP.Trivia_Desc = [[The design of the double-barrel shotgun is so ubiquitous that it is usually referred to by weapon class instead of model name. These traditional shotguns are very popular in both rural and urban communities around the world for their simplicity and reliability.

Both barrels can be fired back-to-back in quick, deadly succession, but they must be reloaded frequently. Switch to burst firemode to pull both triggers at once.]]
SWEP.Trivia_Manufacturer = "Sikov Machining Plant"
SWEP.Trivia_Calibre = "12 Gauge"
SWEP.Trivia_Mechanism = "Break Action"
SWEP.Trivia_Country = "Soviet Union"
SWEP.Trivia_Year = 1958

-- Weapon slot --

SWEP.Slot = 3

-- Weapon's manufacturer real name --

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Izhevsk Mechanical Plant"
end

-- Viewmodel / Worldmodel / FOV --

SWEP.ViewModel = "models/weapons/arccw/c_ur_dbs.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ur_dbs.mdl"
SWEP.ViewModelFOV = 60
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos        =    Vector(-3, 3, -5),
    ang        =    Angle(-12, 0, 180),
    bone    =    "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage parameters --

SWEP.Damage = 18 -- 6 pellets to kill
SWEP.DamageMin = 10 -- 10 pellets to kill
SWEP.Range = 40
SWEP.RangeMin = 6
SWEP.Num = 8
SWEP.Penetration = 2
SWEP.DamageType = DMG_BUCKSHOT
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 365
SWEP.PhysBulletMuzzleVelocity = 365

SWEP.HullSize = 0.25

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults_Shotgun

-- Mag size --

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 2
SWEP.RejectMagSizeChange = true -- Signals to attachments that mag size shouldn't be changeable; needs to be implemented attachment-side with att.Compatible

-- Recoil --

SWEP.Recoil = 2.8
SWEP.RecoilSide = 2

SWEP.RecoilRise = 0.24
SWEP.VisualRecoilMult = 0
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 1

SWEP.Sway = 0.5

-- Firerate / Firemodes --

SWEP.Delay = 60 / 350
SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "fcg.break",
    },
    {
        Mode = 1,
        PrintName = "ur.spas12.dbl",
        Mult_AccuracyMOA = 1.15,
        Mult_HipDispersion = 0.8,
        Mult_Num = 2,
        Override_AmmoPerShot = 2,
        Mult_Damage = 2,
        Mult_DamageMin = 2,
        Mult_VisualRecoilMult = 2,

        CustomBars = "--___",
    },
    {
        PrintName = "fcg.safe2",
        Mode = 0,
    }
}

SWEP.UC_CanManualAction = true

SWEP.MalfunctionTakeRound = false
SWEP.MalfunctionMean = math.huge -- Theoretically it will never malfunction

SWEP.ShootVol = 160
SWEP.ShootPitch = 100

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = false
SWEP.RevolverReload = true

-- NPC --

SWEP.NPCWeaponType = "weapon_shotgun"
SWEP.NPCWeight = 210

-- Accuracy --

SWEP.AccuracyMOA = 25
SWEP.HipDispersion = 400
SWEP.MoveDispersion = 125
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "buckshot"

-- Speed multipliers --

SWEP.SpeedMult = 0.91
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.25
SWEP.ShootSpeedMult = 0.75

-- Length --

SWEP.BarrelLength = 49
SWEP.ExtraSightDist = 2

-- Ironsights / Customization / Poses --

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.IronSightStruct = {
     Pos = Vector(-1.5, 0, 2.5),
     Ang = Angle(0, 0, 3),
     Magnification = 1.05,
     SwitchToSound = "",
}

SWEP.SprintPos = Vector(7, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -10)

SWEP.HolsterPos = Vector(7, 0, 0)
SWEP.HolsterAng = Angle(-10, 40, -10)

SWEP.ActivePos = Vector(1, 1.5, 1.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-1, 2, 1)
SWEP.CrouchAng = Angle(0, 0, -20)

SWEP.CustomizePos = Vector(10, 1, 2)
SWEP.CustomizeAng = Angle(10, 40, 20)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(3, 0, -4.5)

-- Firing sounds --

local path = ")weapons/arccw_ur/dbs/"
local common = ")/arccw_uc/common/"
SWEP.ShootSoundSilenced = path .. "fire_supp.ogg"
--[[SWEP.DistantShootSound = {path .. "fire-dist-01.ogg", path .. "fire-dist-02.ogg", path .. "fire-dist-03.ogg", path .. "fire-dist-04.ogg", path .. "fire-dist-05.ogg"}
SWEP.DistantShootSoundSilenced = common .. "sup_tail.ogg"]]
SWEP.ShootDrySound = common .. "manual_trigger.ogg"

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}

local tail = ")/arccw_uc/common/12ga/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-12ga-pasg-ext-01.ogg",
    tail .. "fire-dist-12ga-pasg-ext-02.ogg",
    tail .. "fire-dist-12ga-pasg-ext-03.ogg",
    tail .. "fire-dist-12ga-pasg-ext-04.ogg",
    tail .. "fire-dist-12ga-pasg-ext-05.ogg",
    tail .. "fire-dist-12ga-pasg-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-shotgun-01.ogg",
    common .. "fire-dist-int-shotgun-02.ogg",
    common .. "fire-dist-int-shotgun-03.ogg",
    common .. "fire-dist-int-shotgun-04.ogg",
    common .. "fire-dist-int-shotgun-05.ogg",
    common .. "fire-dist-int-shotgun-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = function(wep,data)
    ArcCW.UC.InnyOuty(wep)

    if wep:GetCurrentFiremode().Override_AmmoPerShot == 2 then
        timer.Simple(0.05, function()
            if IsValid(wep) then
                wep:EmitSound(wep.ShootSound[math.random(1,#wep.ShootSound)], data.volume * .4, data.pitch, 1, CHAN_WEAPON - 1)
            end
        end)
    end
end

-- Animations --

local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}
local rottle = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local shellin = {common .. "dbs-shell-insert-01.ogg", common .. "dbs-shell-insert-02.ogg", common .. "dbs-shell-insert-03.ogg", common .. "dbs-shell-insert-04.ogg", common .. "dbs-shell-insert-05.ogg", common .. "dbs-shell-insert-06.ogg", common .. "dbs-shell-insert-07.ogg", common .. "dbs-shell-insert-08.ogg", common .. "dbs-shell-insert-09.ogg", common .. "dbs-shell-insert-10.ogg", common .. "dbs-shell-insert-11.ogg", common .. "dbs-shell-insert-12.ogg"}
local shellfall = {path .. "shell-fall-01.ogg", path .. "shell-fall-02.ogg", path .. "shell-fall-03.ogg", path .. "shell-fall-04.ogg"}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["draw"] = {
        Source = "draw",
        --Time = 20 / 30,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "grab.ogg", t = 0.2},
            {s = path .. "shoulder.ogg", t = 0.5},
        },
    },
    ["ready"] = {
        Source = "deploy",
        Time = 26 / 30,
        SoundTable = {
            {s = path .. "close.ogg", t = 0.1},
            {s = common .. "shoulder.ogg", t = 0.2},
            {s = path .. "shoulder.ogg", t = 0.455},
        },
    },
    ["holster"] = {
        Source = "holster",
        Time = 20 / 30,
        SoundTable = ArcCW.UC.HolsterSounds,
    },

    ["fire"] = { -- first barrel
        Source = "fire",
        -- Time = 23 / 25,--30,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    ["fire_iron"] = {
        Source = "fire",
        -- Time = 23 / 25,--30,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },

    ["fire_empty"] = { -- second barrel
        Source = "fire_empty", -- fire_empty
        -- Time = 23 / 25,--30,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    ["fire_iron_empty"] = {
        Source = "fire_empty", -- fire_empty
        -- Time = 23 / 25,--30,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0}},
    },

    ["fire_2bst"] = { -- both
        Source = "fireboth",
        -- Time = 35 / 25,--30,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
        MinProgress = 0.3
    },

    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        ShellEjectAt = 0.91,
        SoundTable = {
            {s = common .. "cloth_4.ogg", t = 0},
            {s = path .. "open.ogg", t = 0.2},
            {s = path .. "eject.ogg", t = 0.8},
            {s = common .. "magpouch_pull_small.ogg", t = 1.0},
            {s = shellfall, t = 1.0},
            {s = common .. "cloth_2.ogg", t = 1.1},
            {s = path .. "struggle.ogg", t = 1.5, v = 0.5},
            {s = shellin, t = 1.8},
            {s = path .. "grab.ogg", t = 2.15, v = 0.5},
            {s = path .. "close.ogg", t = 2.3},
            {s = common .. "shoulder.ogg", t = 2.4},
            {s = path .. "shoulder.ogg", t = 2.675},
        },
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.5,
        MinProgress = 2.05,
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        ShellEjectAt = 1.0,
        SoundTable = {
            {s = common .. "cloth_4.ogg", t = 0},
            {s = path .. "open.ogg", t = 0.3},
            {s = path .. "eject.ogg", t = 0.8},
            {s = shellfall, t = 0.9},
            {s = shellfall, t = 0.95},
            {s = common .. "cloth_2.ogg", t = 1.1},
            {s = common .. "magpouch_pull_small.ogg", t = 1.2},
            {s = path .. "struggle.ogg", t = 1.7, v = 0.5},
            {s = shellin, t = 1.85},
            {s = shellin, t = 1.9},
            {s = path .. "grab.ogg", t = 2.17, v = 0.5},
            {s = path .. "close.ogg", t = 2.3},
            {s = common .. "shoulder.ogg", t = 2.44},
            {s = path .. "shoulder.ogg", t = 2.6},
        },
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.5,
        MinProgress = 2.05,
    },

    ["reload_extractor"] = {
        Source = "reload2",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        ShellEjectAt = 0.4,
        SoundTable = {
            {s = common .. "cloth_4.ogg", t = 0},
            {s = path .. "open.ogg", t = 0.2},
            {s = common .. "magpouch_pull_small.ogg", t = 0.5},
            {s = shellfall, t = 0.4},
            {s = common .. "cloth_2.ogg", t = 0.6},
            {s = path .. "struggle.ogg", t = 1.0, v = 0.5},
            {s = shellin, t = 1.2},
            {s = path .. "grab.ogg", t = 1.5, v = 0.5},
            {s = path .. "close.ogg", t = 1.7},
            {s = common .. "shoulder.ogg", t = 1.8},
            {s = path .. "shoulder.ogg", t = 2.2},
        },
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.5,
        MinProgress = 1.3,
    },
    ["reload_empty_extractor"] = {
        Source = "reload2_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        ShellEjectAt = 0.4,
        SoundTable = {
            {s = common .. "cloth_4.ogg", t = 0},
            {s = path .. "open.ogg", t = 0.2},
            {s = common .. "magpouch_pull_small.ogg", t = 0.5},
            {s = shellfall, t = 0.4},
            {s = shellfall, t = 0.45},
            {s = common .. "cloth_2.ogg", t = 0.6},
            {s = path .. "struggle.ogg", t = 1.0, v = 0.5},
            {s = shellin, t = 1.2},
            {s = shellin, t = 1.25},
            {s = path .. "grab.ogg", t = 1.5, v = 0.5},
            {s = path .. "close.ogg", t = 1.7},
            {s = common .. "shoulder.ogg", t = 1.8},
            {s = path .. "shoulder.ogg", t = 2.2},
        },
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.5,
        MinProgress = 1.3,
    },
}

SWEP.BulletBones = {
    --[1] = "1014_shell1",
}

-- Bodygroups --

SWEP.AttachmentElements = {
    ["barrel_mid"] = { VMBodygroups = { {ind = 1, bg = 1} } },
    ["barrel_compact"] = { VMBodygroups = { {ind = 1, bg = 4} } },
    ["barrel_sw"] = { VMBodygroups = { {ind = 1, bg = 2} } },
    ["barrel_swplus"] = { VMBodygroups = { {ind = 1, bg = 3}, {ind = 3, bg = 1} } },

    ["stock_sw"] = { VMBodygroups = { {ind = 2, bg = 1} } },
}

SWEP.DefaultBodygroups = "00000000"

SWEP.Attachments = {
    -- {
    --     PrintName = "Optic",
    --     DefaultAttName = "Iron Sights",
    --     Slot = {"optic_lp","optic"},
    --     Bone = "barrels",
    --     Offset = {
    --         vpos = Vector(0.5, -1.75, 1.5),
    --         vang = Angle(0, 90, 0),
    --     },
    --     VMScale = Vector(1,1,1),
    --     CorrectivePos = Vector(0, 0, -0.0),
    --     CorrectiveAng = Angle(0, 180, 0),
    -- },
    {
        PrintName = "Barrel",
        DefaultAttName = "26\" Factory Barrel",
        DefaultAttIcon = Material("entities/att/ur_dbs/blong.png", "smooth mips"),
        Slot = "ur_db_barrel",
        Bone = "body",
        Offset = {
            vpos = Vector(-0.4, -5, -6),
            vang = Angle(0, 90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        Slot = "choke",
    },
    {
        PrintName = "Stock",
        Slot = {"ur_db_stock"},
        DefaultAttName = "Wooden Stock",
        DefaultAttIcon = Material("entities/att/ur_dbs/s.png", "smooth mips"),
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"BUCK\" #00 Buckshot",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_shotgun_generic.png", "mips smooth"),
        Slot = {"ud_ammo_shotgun"},
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = {"uc_fg_singleshot", "uc_db_fg"}, -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm", "uc_db_tp"},
        FreeSlot = true,
        Bone = "body",
        Offset = {
            vpos = Vector(-0.55, 1, -0.5),
            vang = Angle(0, 90, 0),
        },
    },
}
--lua/weapons/arccw_ur_g3sg1.lua:
if !file.Exists("arccw/shared/sh_1_ur.lua","LUA") then return end

include("weapons/arccw_ur_g3.lua")

SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets DMRs"
end

SWEP.PrintName = "AG-SSR"
SWEP.TrueName = "G3SG/1"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

SWEP.Attachments[1].Installed = "ur_g3_optic_sg1"
SWEP.Attachments[8].Installed = "ur_g3_stock_sg"
SWEP.Attachments[16].Installed = "ur_g3_skin_olive"
--lua/weapons/arccw_ur_g3.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "ArcCW - Urban Coalition" -- edit this if you like
SWEP.UC_CategoryPack = "2Urban Renewal"
SWEP.AdminOnly = false

SWEP.PrintName = "AG58"
SWEP.TrueName = "G3A3"

SWEP.Trivia_Class = "Battle Rifle"
SWEP.Trivia_Desc = [[Heckler & Koch's earliest major weapon design, conceived in collaboration with Spanish research group CETME. As a pioneer of the roller-delay system, its success within the Bundeswehr inspired HK to derive subsequent designs from its layout, including the MP5 submachine gun.

Well known for its excellent accuracy and range, but its powerful cartridge makes sustained fire difficult.]]
SWEP.Trivia_Manufacturer = "Crowdley & Nelson"
SWEP.Trivia_Calibre = "7.62x51mm NATO"
SWEP.Trivia_Mechanism = "Roller-Delayed Blowback"
SWEP.Trivia_Country = "Germany"
SWEP.Trivia_Year = 1958

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Heckler & Koch"
end

SWEP.Slot = 2
SWEP.CamAttachment = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/c_ur_g3.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ur_g3.mdl"
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "000000000000"

-- Damage --

SWEP.Damage = 65
SWEP.DamageMin = 35
SWEP.RangeMin = 50
SWEP.Range = 400
SWEP.Penetration = 20
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 715
SWEP.PhysBulletMuzzleVelocity = 715

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 20

-- Recoil --

SWEP.Recoil = 1.4
SWEP.RecoilSide = 0.6

SWEP.RecoilRise = 0.6
SWEP.RecoilPunch = 1
SWEP.VisualRecoilMult = 1
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 1
SWEP.RecoilPunchBack = 2

SWEP.Sway = 0.4

-- Firerate / Firemodes --

SWEP.Delay = 60 / 520
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_ar2"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 2
SWEP.HipDispersion = 900
SWEP.MoveDispersion = 200
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "ar2"
SWEP.MagID = "ak"

SWEP.HeatCapacity = 75
SWEP.HeatDissipation = 15
SWEP.HeatDelayTime = 3

-- SWEP.Malfunction = true
SWEP.MalfunctionMean = 200
--SWEP.MeleeTime = 1.5

-- Speed multipliers --

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.75

local path = ")weapons/arccw_ur/g3/"
local path1 = ")weapons/arccw_ur/mp5/"
local common = ")/arccw_uc/common/"
local rottle = {common .. "cloth_1.ogg", common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}
--SWEP.FirstShootSound = path .. "fire_first.ogg"

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}
SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = path .. "dryfire.ogg"

local tail = ")/arccw_uc/common/308/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-308-rif-ext-01.ogg",
    tail .. "fire-dist-308-rif-ext-02.ogg",
    tail .. "fire-dist-308-rif-ext-03.ogg",
    tail .. "fire-dist-308-rif-ext-04.ogg",
    tail .. "fire-dist-308-rif-ext-05.ogg",
    tail .. "fire-dist-308-rif-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-rifle-01.ogg",
    common .. "fire-dist-int-rifle-02.ogg",
    common .. "fire-dist-int-rifle-03.ogg",
    common .. "fire-dist-int-rifle-04.ogg",
    common .. "fire-dist-int-rifle-05.ogg",
    common .. "fire-dist-int-rifle-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "sup_tail.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

SWEP.MuzzleEffect = "muzzleflash_6"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/556x45.mdl"
SWEP.ShellScale = 1.145
SWEP.ShellPitch = 90
SWEP.ShellScale = 1
SWEP.ShellRotateAngle = Angle(0, 0, 0)
SWEP.UC_ShellColor = Color(0.7*255, 0.2*255, 0.2*255)

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.BulletBones = {
    --[1] = "tag_mag2",
}

SWEP.IronSightStruct = {
    Pos = Vector(-2.3, -1, 0.9),
    Ang = Angle(0, 0.02, 0),
    Magnification = 1.1,
    ViewModelFOV = 65,
    SwitchToSound = "", -- sound that plays when switching to this sight
    CrosshairInSights = false
}
SWEP.LaserOffsetAngle = Angle(0, 0, 0)
SWEP.LaserIronsAngle = Angle(0, 0, 0)

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0.3, 1, 0.8)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0.5, 1, 0.5)
SWEP.SprintAng = Angle(-8.5, 15, -10)

SWEP.CrouchPos = Vector(-0.7, 0.6, 0)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.HolsterPos = Vector(-1, -1, 1.2)
SWEP.HolsterAng = Angle(-15, 8, -10)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(0, 0, 0)

-- SWEP.CustomizePos = Vector(10.5, 4, 1)
-- SWEP.CustomizeAng = Angle(8, 30, 15)
SWEP.CustomizePos = Vector(0.3, 1, 0.8)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.BarrelLength = 24

SWEP.AttachmentElements = {
    ["ur_g3_skin_wood"] = { VMSkin = 1 },
    ["ur_g3_skin_olive"] = { VMSkin = 2 },
    ["ur_g3_skin_tan"] = { VMSkin = 3 },
    ["ur_g3_skin_custom"] = { VMSkin = 4 },

    ["stock_g3_collapsible"] = {
        VMBodygroups = {
            {ind = 5, bg = 2},
        }
    },
    ["stock_g3_collapsed"] = {
        VMBodygroups = {
            {ind = 5, bg = 3},
        }
    },
    ["ur_g3_stock_psg"] = {
        VMBodygroups = {
            {ind = 5, bg = 4},
        }
    },
    ["ur_g3_stock_sg"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
        }
    },
    ["ur_g3_stock_rucar"] = {
        VMBodygroups = {
            {ind = 5, bg = 5},
        }
    },

    ["ur_g3_rec_hk33"] = {
        VMBodygroups = {
            {ind = 0, bg = 1},
            {ind = 3, bg = 1},
            {ind = 4, bg = 4},
        },
    },
    ["ur_g3_rec_psg"] = {
        VMBodygroups = {
            -- {ind = 1, bg = 1},
            {ind = 3, bg = 2},
        },
        NameChange = "PMR-2",
        TrueNameChange = "PSG1",
    },

    ["ur_g3_mag_10"] = {
        VMBodygroups = {
            {ind = 4, bg = 1},
        }
    },
    ["ur_g3_mag_50"] = {
        VMBodygroups = {
            {ind = 4, bg = 2},
        }
    },
    ["ur_g3_mag_20_556"] = {
        VMBodygroups = {
            {ind = 4, bg = 3},
        }
    },
    ["ur_g3_mag_40_556"] = {
        VMBodygroups = {
            {ind = 4, bg = 5},
        }
    },

    ["ur_g3_barrel_12"] = {
        VMBodygroups = {
            {ind = 2, bg = 1},
        },
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 0.06, 17.7),
                vang = Angle(90, 0, -90),
            },
            [7] = {
                vpos = Vector(-0.94, 0.2, 14),
                vang = Angle(90, 0, 180),
            },
        }
    },
    ["ur_g3_barrel_15"] = {
        VMBodygroups = {
            {ind = 2, bg = 4},
        },
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 0.06, 20),
                vang = Angle(90, 0, -90),
            },
            [7] = {
                vpos = Vector(-0.94, 0.2, 14),
                vang = Angle(90, 0, 180),
            },
        }
    },
    ["ur_g3_barrel_8"] = {
        VMBodygroups = {
            {ind = 2, bg = 2},
        },
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 0.06, 13.7),
                vang = Angle(90, 0, -90),
            },
            [7] = {
                vpos = Vector(-0.94, 0.2, 11),
                vang = Angle(90, 0, 180),
            },
        }
    },
    ["ur_g3_barrel_26"] = {
        VMBodygroups = {
            {ind = 2, bg = 3},
        },
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 0.06, 29.7),
                vang = Angle(90, 0, -90),
            },
            [7] = {
                vpos = Vector(-0.94, 0.2, 17),
                vang = Angle(90, 0, 180),
            },
        }
    },

    ["ur_g3_hg_slim"] = {
        AttPosMods = {
            [6] = {
                vpos = Vector(0, 0.66, 9),
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["ur_g3_hg_pica"] = {
        AttPosMods = {
            [6] = {
                vpos = Vector(0, 0.75, 9.2),
                vang = Angle(90, 0, -90),
            },
        }
    },
}

local hgbg = {
    ["ur_g3_hg_slim"] = 1,
    ["ur_g3_hg_pica"] = 2,
    ["ur_mp5_ub_mlok"] = 3,
    ["ur_mp5_ub_surefire"] = 4,
}
local muzzlebg = {
    ["ur_g3_barrel_8"] = 2,
    ["ur_g3_barrel_12"] = 1,
    ["ur_g3_barrel_15"] = 4,
    ["ur_g3_barrel_26"] = 3,
    ["default"] = 0,
}
local opticbg = {
    ["ur_g3_optic_psg1"] = 2,
    ["ur_g3_optic_sg1"] = 3,
}
local ubmountbg = {
    ["ur_g3_hg_slim"] = 2,
    ["ur_g3_hg_pica"] = 0,
}

SWEP.Hook_ModifyBodygroups = function(wep,data)
    local vm = data.vm
    if !IsValid(vm) then return end

    local atts = wep.Attachments
    local barrel = atts[2].Installed or "default"
    local hg = atts[4].Installed
    local muzzle = atts[5].Installed
    local ub = atts[6].Installed or atts[15].Installed
    local optic = atts[1].Installed
    local charm = atts[14].Installed
    local bayobipod = atts[17].Installed

    local hgind = hgbg[hg] or 0

    if barrel == "ur_g3_barrel_12" or barrel == "ur_g3_barrel_15" then
        vm:SetBodygroup(6, hgind + 3)

        if ub == "ur_g3_ub_bayonet" then
            vm:SetBodygroup(7, 2)
        elseif ub == "ur_g3_ub_bipod" then
            vm:SetBodygroup(7, 4)
        end
    elseif barrel == "ur_g3_barrel_8" then
        vm:SetBodygroup(6, hgind + 6)
    elseif barrel == "ur_g3_barrel_26" then
        vm:SetBodygroup(6, 11)
    else
        vm:SetBodygroup(6, hgind)
    end

    if (barrel == "default" or barrel == "ur_g3_barrel_12" or barrel == "ur_g3_barrel_15" or barrel == "ur_g3_barrel_8") and ub == "uc_ubgl_hk79" then
        vm:SetBodygroup(6, 11)
        atts[15].Offset.vpos = Vector(0, -0.7, 7.3)
    else
        atts[15].Offset.vpos = Vector(0, 0.1, 6.9)
    end

    if barrel == "ur_g3_barrel_26" then
        vm:SetBodygroup(1, 1)
    end

    vm:SetBodygroup(9, !muzzle and muzzlebg[barrel] or 3)

    vm:SetBodygroup(10, (optic or charm == "ur_mp5_optic_mount") and (opticbg[optic] and 0 or 1) or 0)

    vm:SetBodygroup(8, ub and (ubmountbg[hg] or 1) or 0)

    local todo = 0
    local short = barrel == "ur_g3_barrel_12" or barrel == "ur_g3_barrel_15"
    if bayobipod == "ur_g3_bayobipod_bayonet" then
        todo = short and 2 or 1
    elseif bayobipod == "ur_g3_bayobipod_bipod" then
        todo = short and 4 or 3
    end
    vm:SetBodygroup(7, todo)
end

SWEP.Hook_NameChange = function(wep)
    local atts = wep.Attachments
    local barr = string.Replace(atts[2].Installed or "default","ur_g3_barrel_","")
    local rec = string.Replace(atts[3].Installed or "default","ur_g3_rec_","")
    local stock = string.Replace(atts[8].Installed or "default","ur_g3_stock_","")
    local trueNames = GetConVar("arccw_truenames"):GetBool()


    if rec == "hk33" then
        if trueNames then
            local bLookup = {
                ["8"] = "HK53",
                ["12"] = "HK33KA3",
            }

            if bLookup[barr] then
                return bLookup[barr]
            elseif atts[1].Installed == "ur_g3_optic_sg1" then
                return "HK33SG/1"
            else
                return (stock == "collapsible" and "HK33A3") or "HK33A2"
            end
        else
            local bLookup = {
                ["8"] = "CN109",
                ["12"] = "CN66K",
            }

            if bLookup[barr] then
                return bLookup[barr]
            elseif atts[1].Installed == "ur_g3_optic_sg1" then
                return "CN66-SSR"
            else
                return "CN66"
            end
        end
    elseif rec == "default" then -- not "else" here to allow the base's PSG1 namechange to happen
        if trueNames then
            if atts[13].Installed == "uc_fg_civvy" then return "HK91" end

            local bLookup = {
                ["8"] = "HK51",
                ["12"] = "G3KA4",
            }

            if bLookup[barr] then
                return bLookup[barr]
            elseif atts[1].Installed == "ur_g3_optic_sg1" then
                return "G3SG/1"
            else
                return (stock == "collapsible" and "G3A4") or wep.TrueName
            end
        else
            local bLookup = {
                ["8"] = "CN102",
                ["12"] = "AG58K",
            }
            if bLookup[barr] then
                return bLookup[barr]
            elseif atts[1].Installed == "ur_g3_optic_sg1" then
                return "AG-SSR"
            else
                return "AG58"
            end
        end
    end
end

SWEP.O_Hook_UC_UseClassicHK79Mount = function(wep, data)
    local atts = wep.Attachments
    local barrel = atts[2].Installed or "default"
    local ub = atts[6].Installed or atts[15].Installed

    if ub == "uc_ubgl_hk79" and (barrel == "default" or barrel == "ur_g3_barrel_12" or barrel == "ur_g3_barrel_15" or barrel == "ur_g3_barrel_8") then
        data.current = true
    end
end

SWEP.ExtraSightDist = 2
SWEP.GuaranteeLaser = false

SWEP.WorldModelOffset = {
    pos = Vector(-5, 3, -5),
    ang = Angle(-12, 0, 180)
}

SWEP.MirrorVMWM = true


SWEP.Attachments = {
    {
        PrintName = "Optic",
        Slot = {"ur_g3_optic", "optic"},
        Bone = "body",
        Offset = {
            vpos = Vector(0, -1.6, -0.55),
            vang = Angle(90, 0, -90),
        },
        InstalledEles = {"mount_optic"},
        CorrectivePos = Vector(0.018, 0, -0.0),
        CorrectiveAng = Angle(0, 0.3, 0.45),
    },
    {
        PrintName = "Barrel",
        Slot = "ur_g3_barrel",
        DefaultAttName = "18\" Standard Barrel",
        DefaultAttIcon = Material("entities/att/ur_g3/barrel_std.png", "smooth mips"),
        DefaultFlags = {"g3_not8"}
    },
    {
        PrintName = "Reciever",
        Slot = "ur_g3_rec",
        DefaultAttName = "Standard Reciever",
        DefaultAttIcon = Material("entities/att/ur_g3/rec_std.png", "smooth mips"),
    },
    {
        PrintName = "Handguard",
        Slot = "ur_g3_handguard",
        Bone = "body",
        Offset = {
            vpos = Vector(0, 1.5, 10),
            vang = Angle(90, 0, -90),
        },
        DefaultAttName = "Standard Handguard",
        DefaultAttIcon = Material("entities/att/ur_g3/hg_std.png", "smooth mips"),
        ExcludeFlags = {"hk79_pro","g3_nohg"},
    },
    {
        PrintName = "Muzzle",
        Slot = "muzzle",
        Bone = "body",
        Offset = {
            vpos = Vector(0, 0.06, 22.5),
            vang = Angle(90, 0, -90),
        },
        MergeSlots = {17},
    },
    {
        PrintName = "Underbarrel",
        Slot = "foregrip",
        Bone = "body",
        Offset = {
            vpos = Vector(0, 1.17, 8.6),
            vang = Angle(90, 0, -90),
        },
        InstalledEles = {"mount_underbarrel"},
        ExcludeFlags = {"g3_noub"},
        MergeSlots = {15},
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "body",
        Offset = {
            vpos = Vector(-0.8, 0, 17),
            vang = Angle(90, 0, 180),
        },
        InstalledEles = {"mount_tactical"},
    },
    {
        PrintName = "Stock",
        Slot = "ur_g3_stock",
        DefaultAttName = "Factory Stock",
        DefaultAttIcon = Material("entities/att/ur_g3/stock_std.png", "smooth mips"),
    },
    {
        PrintName = "Magazine",
        Slot = "ur_g3_mag",
        DefaultAttName = "20-Round Mag",
        DefaultAttIcon = Material("entities/att/ur_g3/mag20.png", "smooth mips"),
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg",
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm", "mp5_charm"},
        FreeSlot = true,
        Bone = "body",
        Offset = {
            vpos = Vector(0.5, 1.3, 3),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "M203 slot",
        Slot = "uc_ubgl",
        Bone = "body",
        Offset = {
            vpos = Vector(0, 0.1, 6.9), -- this is also changed by ModifyBodygroups
            vang = Angle(90, 0, -90),
        },
        Hidden = true,
        InstalledEles = {"mount_underbarrel"},
    },
    {
        PrintName = "Furniture",
        Slot = "ur_g3_skin",
        DefaultAttName = "Gray",
        DefaultAttIcon = Material("entities/att/ur_g3/skin_gray.png", "smooth mips"),
    },
    {
        PrintName = "UR G3 bayobipod slot",
        Slot = "ur_g3_bayobipod",
        ExcludeFlags = {"g3_hk51hg"},
    },
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["draw"] = {
        Source = "draw",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "raise.ogg", t = 0.2},
            {s = common .. "shoulder.ogg",    t = 0.2},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        SoundTable = {
            {s = ratel, t = 0},
           -- {s = common .. "raise.ogg", t = 0.2},
            -- {s = common .. "shoulder.ogg",    t = 0.2},
        },
    },
    ["ready"] = {
        Source = "ready",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.6,
        LHIKEaseOut = 0.25,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "chback.ogg",    t = 0.2},
            {s = path .. "chamber.ogg",    t = 0.3},
            {s = common .. "shoulder.ogg",    t = .6},
        },
    },

    ["fire"] = {
        Source = {"fire_01","fire_02","fire_03"},
        ShellEjectAt = 0,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    ["fire_iron"] = {
        Source = {"fire_01","fire_02","fire_03"},
        ShellEjectAt = 0,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },

   ["reload"] = {
       Source = "reload",
       TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
       LHIK = true,
       LHIKIn = 0.3,
       LHIKOut = 0.65,
       LHIKEaseOut = 0.25,
       MinProgress = 1.3,
       SoundTable = {
            {s = rottle,  t = 0.0},
            {s = ratel, t = 3/30},
            {s = common .. "magpouch_gear.ogg", t = 9/30},
            {s = path .. "magout.ogg", 	 t = 11/30},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "struggle.ogg", t = 36/30},
            {s = path .. "magin.ogg", t = 42/30},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = common .. "grab.ogg", t = 52/30},
            {s = common .. "shoulder.ogg", t = 54/30},
       },
   },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 5/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 23/30},
            {s = rottle,  t = 24/30},
            {s = common .. "magpouch_gear.ogg", t = 25/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 57/30},
            {s = path .. "magin.ogg", t = 62/30},
            {s = rottle,  t = 75/30},
            {s = path .. "chslap.ogg", t = 80/30},
            {s = ratel,  t = 81/30},
            {s = common .. "grab.ogg", t = 87/30},
            {s = common .. "shoulder.ogg", t = 88/30},
        },
    },
    ["reload_empty_scope"] = {
        Source = "reload_empty_scope",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 23/30},
            {s = rottle,  t = 24/30},
            {s = common .. "magpouch.ogg", t = 26/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 57/30},
            {s = path .. "magin.ogg", t = 62/30},
            {s = rottle,  t = 75/30},
            {s = path .. "chlock.ogg", t = 75/30, v = 1.95},
            {s = path .. "chamber.ogg", t = 80/30},
            {s = ratel,  t = 81/30},
            {s = common .. "grab.ogg", t = 92/30},
            {s = common .. "shoulder.ogg", t = 93/30},
        },
    },
   ["reload_30rnd"] = {
       Source = "reload_30rnd",
       TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
       LHIK = true,
       LHIKIn = 0.3,
       LHIKOut = 0.65,
       LHIKEaseOut = 0.25,
       MinProgress = 1.3,
       SoundTable = {
            {s = rottle,  t = 0.0},
            {s = ratel, t = 3/30},
            {s = path .. "magout.ogg", 	 t = 11/30},
            {s = common .. "magpouch.ogg", t = 26/30},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "struggle.ogg", t = 39/30},
            {s = path .. "magin.ogg", t = 44/30},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = common .. "grab.ogg", t = 56/30},
            {s = common .. "shoulder.ogg", t = 61/30},
       },
   },
    ["reload_empty_30rnd"] = {
        Source = "reload_empty_30rnd",
        RareSource = "reload_empty_30rnd_rare",
        RareSourceChance = 100,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 22/30},
            {s = rottle,  t = 23/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = common .. "magpouch.ogg", t = 47/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 57/30},
            {s = path .. "magin.ogg", t = 62/30},
            {s = rottle,  t = 75/30},
            {s = path .. "chslap.ogg", t = 80/30},
            {s = ratel,  t = 81/30},
            {s = common .. "grab.ogg", t = 92/30},
            {s = common .. "shoulder.ogg", t = 93/30},
        },
    },
    ["reload_empty_30rnd_scope"] = {
        Source = "reload_empty_scope_30rnd",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 22/30},
            {s = rottle,  t = 23/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = common .. "magpouch.ogg", t = 47/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 57/30},
            {s = path .. "magin.ogg", t = 62/30},
            {s = rottle,  t = 75/30},
            {s = path .. "chlock.ogg", t = 75/30, v = 1.95},
            {s = path .. "chamber.ogg", t = 80/30},
            {s = ratel,  t = 81/30},
            {s = common .. "grab.ogg", t = 92/30},
            {s = common .. "shoulder.ogg", t = 93/30},
        },
    },
   ["reload_10rnd"] = {
       Source = "reload_10rnd",
       TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
       LHIK = true,
       LHIKIn = 0.3,
       LHIKOut = 0.65,
       LHIKEaseOut = 0.25,
       MinProgress = 1.3,
       SoundTable = {
            {s = rottle,  t = 0.0},
            {s = ratel, t = 3/30},
            {s = path .. "magout.ogg", 	 t = 10/30},
            {s = common .. "magpouch.ogg", t = 26/30},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "struggle.ogg", t = 36/30},
            {s = path .. "magin.ogg", t = 42/30},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = common .. "grab.ogg", t = 52/30},
            {s = common .. "shoulder.ogg", t = 56/30},
       },
   },
    ["reload_empty_10rnd"] = {
        Source = "reload_empty_10rnd",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 22/30},
            {s = rottle,  t = 23/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = common .. "magpouch.ogg", t = 47/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 57/30},
            {s = path .. "magin.ogg", t = 62/30},
            {s = rottle,  t = 75/30},
            {s = path .. "chslap.ogg", t = 80/30},
            {s = ratel,  t = 81/30},
            {s = common .. "grab.ogg", t = 92/30},
            {s = common .. "shoulder.ogg", t = 93/30},
        },
    },
    ["reload_empty_10rnd_scope"] = {
        Source = "reload_empty_scope_10rnd",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 22/30},
            {s = rottle,  t = 23/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = common .. "magpouch.ogg", t = 47/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 57/30},
            {s = path .. "magin.ogg", t = 62/30},
            {s = rottle,  t = 74/30},
            {s = path .. "chlock.ogg", t = 75/30, v = 1.95},
            {s = path .. "chamber.ogg", t = 80/30},
            {s = ratel,  t = 81/30},
            {s = common .. "grab.ogg", t = 92/30},
            {s = common .. "shoulder.ogg", t = 93/30},
        },
    },
   ["reload_50rnd"] = {
       Source = "reload_50rnd",
       TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
       LHIK = true,
       LHIKIn = 0.3,
       LHIKOut = 0.65,
       LHIKEaseOut = 0.25,
       MinProgress = 1.3,
       SoundTable = {
            {s = rottle,  t = 0.0},
            {s = ratel, t = 3/30},
            {s = path .. "magout.ogg", 	 t = 11/30},
            {s = common .. "magpouch.ogg", t = 26/30},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "struggle.ogg", t = 42/30},
            {s = path .. "magin.ogg", t = 48/30},
            {s = ratel, t = 1.1+5/30},
            {s = rottle,  t = 1.15+5/30},
            {s = common .. "grab.ogg", t = 58/30},
            {s = common .. "shoulder.ogg", t = 62/30},
       },
   },
    ["reload_empty_50rnd"] = {
        Source = "reload_empty_50rnd",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 22/30},
            {s = rottle,  t = 23/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = common .. "magpouch.ogg", t = 47/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 62/30},
            {s = path .. "magin.ogg", t = 67/30},
            {s = rottle,  t = 80/30},
            {s = path .. "chslap.ogg", t = 85/30},
            {s = ratel,  t = 86/30},
            {s = common .. "grab.ogg", t = 97/30},
            {s = common .. "shoulder.ogg", t = 98/30},
        },
    },
    ["reload_empty_50rnd_scope"] = {
        Source = "reload_empty_scope_50rnd",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 50/30,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "chback.ogg", t = 6/30, v = 1.95},
            {s = path .. "chlock.ogg", t = 13/30, v = 1.95},
            {s = ratel,  t = 22/30},
            {s = rottle,  t = 23/30},
            {s = path .. "magrel.ogg", t = 27/30},
            {s = path .. "magout.ogg", t = 30/30},
            {s = common .. "magpouch.ogg", t = 47/30},
            {s = rottle,  t = 49/30},
            {s = rottle,  t = 55/30},
            {s = {common .. "rifle_magdrop_1.ogg",common .. "rifle_magdrop_2.ogg",common .. "rifle_magdrop_3.ogg",common .. "rifle_magdrop_4.ogg",common .. "rifle_magdrop.ogg"}, t = 51/30, v = 0.25},
            {s = path .. "struggle.ogg", t = 62/30},
            {s = path .. "magin.ogg", t = 67/30},
            {s = rottle,  t = 80/30},
            {s = path .. "chlock.ogg", t = 75/30, v = 1.95},
            {s = path .. "chamber.ogg", t = 85/30},
            {s = ratel,  t = 86/30},
            {s = common .. "grab.ogg", t = 97/30},
            {s = common .. "shoulder.ogg", t = 98/30},
        },
    },
    ["unjam"] = {
        Source = "jamfix",
        ShellEjectAt = 0.5,
        SoundTable = {
            {s = common .. "cloth_4.ogg",  t = 0.1},
            {s = path .. "chback.ogg",    t = 0.3},
            {s = path .. "chamber.ogg",    t = 0.6},
            {s = common .. "grab.ogg", t = 0.9},
            {s = common .. "shoulder.ogg", t = 0.95},
        },
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.6,
    },

    ["enter_inspect"] = {
        Source = "inspect_enter",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect"] = {
        Source = "inspect_loop",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
    },
    ["exit_inspect"] = {
        Source = "inspect_exit",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
        SoundTable = {
            {s = common .. "movement-rifle-04.ogg", t = 0.2},
            {s = rottle, t = 0.25},
            {s = rottle, t = 1.2},
            {s = common .. "movement-rifle-03.ogg", t = 1.25},
        },
    },
}

-- SWEP.Hook_Think = ArcCW.UC.ADSReload

SWEP.Hook_Think = function(wep)
    local vm = wep:GetOwner():GetViewModel()

    vm:SetPoseParameter("short", wep.Attachments[2].Installed == "ur_g3_barrel_8" and 1 or 0)

    ArcCW.UC.ADSReload(wep)
end

SWEP.Hook_SelectReloadAnimation = function(wep, anim) -- not in atts cause _scope wont work
    local seq = anim

    if wep.Attachments[9].Installed == "ur_g3_mag_50" then
        seq = seq .. "_50rnd"
    elseif wep.Attachments[9].Installed == "ur_g3_mag_10" then
        seq = seq .. "_10rnd"
    elseif wep.Attachments[9].Installed == "ur_g3_mag_40_556" or wep.Attachments[3].Installed == "ur_g3_rec_hk33" and !wep.Attachments[9].Installed then
        seq = seq .. "_30rnd"
    end
    if anim == "reload_empty" and wep.Attachments[1].Installed then
        seq = seq .. "_scope"
    end

    return seq
end
--lua/weapons/arccw_ur_m45.lua:
if !file.Exists("arccw/shared/sh_1_ur.lua","LUA") then return end

include("weapons/arccw_ur_m1911.lua")

SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets Pistols"
end

SWEP.PrintName = "AMASIN"
SWEP.TrueName = "M45"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

SWEP.Attachments[2].Installed = "ur_1911_slide_m45"
SWEP.Attachments[14].Installed = "ur_1911_skin_tan"
--lua/weapons/arccw_ur_mp5.lua:
return gluapack()()
--lua/weapons/arccw_ur_mp5.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - Urban Coalition"
SWEP.UC_CategoryPack = "2Urban Renewal"
SWEP.AdminOnly = false
SWEP.UseHands = true

-- Effects --

SWEP.MuzzleEffect = "muzzleflash_mp5"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/9x19.mdl"
SWEP.ShellScale = 1
--SWEP.ShellMaterial = "models/weapons/arcticcw/shell_9mm"
SWEP.ShellPitch = 100
SWEP.ShellSounds = ArcCW.PistolShellSoundsTable

SWEP.MuzzleEffectAttachment = 1
SWEP.CaseEffectAttachment = 2
-- SWEP.CamAttachment = 3 ---------------------------------------------------------------------------
-- SWEP.TracerNum = 1
-- SWEP.TracerCol = Color(25, 255, 25)
-- SWEP.TracerWidth = 2

-- Fake name --

SWEP.PrintName = "PK5-4"

-- True name --

SWEP.TrueName = "MP5A4"

-- Trivia --

SWEP.Trivia_Class = "Submachine Gun"
SWEP.Trivia_Desc = [[Versatile submachine gun known for its use by high profile police units around the world, most famously by the British SAS during the Iranian embassy siege. Its reliable closed-bolt design and craftsmanship allowed it to remain relevant among new generations of submachine guns.

If accurate, sophisticated close-combat performance is what you're looking for, no weapon has a better track record.

Switch to burst fire mode to reduce dispersion from moving and hipfiring.]]
SWEP.Trivia_Manufacturer = "Crowdley & Nelson"
SWEP.Trivia_Calibre = "9x19mm Parabellum"
SWEP.Trivia_Mechanism = "Roller-Delayed Blowback"
SWEP.Trivia_Country = "Germany"
SWEP.Trivia_Year = 1966

-- Weapon slot --

SWEP.Slot = 2

-- Weapon's manufacturer real name --

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Heckler & Koch"
end

-- Viewmodel / Worldmodel / FOV --

SWEP.ViewModel = "models/weapons/arccw/c_ur_mp5.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ur_mp5.mdl"
SWEP.ViewModelFOV = 70
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2
SWEP.ProceduralIronFire = true

-- Damage --

SWEP.Damage = ArcCW.UC.StdDmg["9mm"].max
SWEP.DamageMin = ArcCW.UC.StdDmg["9mm"].min
SWEP.Penetration = ArcCW.UC.StdDmg["9mm"].pen
SWEP.RangeMin = 20
SWEP.Range = 100

SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 400
SWEP.PhysBulletMuzzleVelocity = 400

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 30
SWEP.ExtendedClipSize = 40
SWEP.ReducedClipSize = 15

-- Recoil --

SWEP.Recoil = 0.22
SWEP.RecoilSide = 0.17

SWEP.RecoilRise = 0.6
SWEP.RecoilPunch = 1
SWEP.VisualRecoilMult = 1.25
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 0.6
SWEP.RecoilPunchBack = 1.5

SWEP.Sway = 0.25

-- Firerate / Firemodes --

SWEP.Delay = 60 / 800
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = -3,
        Mult_MoveDispersion = 0.75,
        Mult_HipDispersion = 0.9,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_smg1"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 3
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 150
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "pistol"
SWEP.MagID = "mp5"

SWEP.HeatCapacity = 75
SWEP.HeatDissipation = 15
SWEP.HeatDelayTime = 3

SWEP.MalfunctionMean = 200

-- Speed multipliers --

SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.3
SWEP.ShootSpeedMult = 0.95

-- Length --

SWEP.BarrelLength = 24
SWEP.ExtraSightDist = 2

-- Ironsights / Customization / Poses --

SWEP.HolsterPos = Vector(0.5, -2, 1)
SWEP.HolsterAng = Angle(-8.5, 8, -10)

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.IronSightStruct = {
     Pos = Vector(-3.17, -1, 0.6),
     Ang = Angle(0.45, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 60,
}

SWEP.ActivePos = Vector(-0.3, 1.1, 0.6)
SWEP.ActiveAng = Angle(0, 0, -1)

-- SWEP.SprintPos = Vector(-0.5, 3, 1.5)
-- SWEP.SprintAng = Angle(-12, 15, -15)

SWEP.SprintPos = Vector(0, -3, 0)
SWEP.SprintAng = Angle(0, 0, 0)
-- SWEP.CustomizePos = Vector(6, -2, -1.5)
-- SWEP.CustomizeAng = Angle(16, 28, 0)
SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-2, 0.5, 0)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.BarrelOffsetHip = Vector(4, 0, -4)

SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos        =    Vector(-8, 4, -5),
    ang        =    Angle(-12, 0, 180),
    bone    =    "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Firing sounds --
local path = ")weapons/arccw_ur/mp5/"
local common = ")/arccw_uc/common/"

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}
SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = path .. "dryfire.ogg"

SWEP.DistantShootSoundOutdoors = {
    path .. "fire-dist-01.ogg",
    path .. "fire-dist-02.ogg",
    path .. "fire-dist-03.ogg",
    path .. "fire-dist-04.ogg",
    path .. "fire-dist-05.ogg",
    path .. "fire-dist-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-pistol-01.ogg",
    common .. "fire-dist-int-pistol-02.ogg",
    common .. "fire-dist-int-pistol-03.ogg",
    common .. "fire-dist-int-pistol-04.ogg",
    common .. "fire-dist-int-pistol-05.ogg",
    common .. "fire-dist-int-pistol-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 0.6
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

-- Bodygroups --

SWEP.BulletBones = {
    -- [1] = "uzi_b1", [2] = "uzi_b2", [3] = "uzi_b3", [4] = "uzi_b4"
}

--[[

1 --- 	id: 0
     [	name: iron
    num: 1
    submodels:
    0 --- ironSIGHT.smd
2 --- 	id: 1
     [	name: 1
    num: 4
    submodels:
    0 --- mp5UPPER.smd
    1 --- mp5sdUPPER.smd
    2 --- mp5kUPPER.smd
    3 --- swordUPPER.smd
3 --- 	id: 2
     [	name: 2
    num: 2
    submodels:
    0 --- fourLOWER.smd
    1 --- sefLOWER.smd
4 --- 	id: 3
     [	name: 3
    num: 11
    submodels:
    0 --- fixedSTOCK.smd
    1 --- collapseSTOCK.smd
    2 --- collapseSTOCKcoll.smd
    3 --- pdwSTOCK.smd
    4 --- pdwSTOCKfold.smd
    5 --- tacticSTOCK.smd
    6 --- tacticSTOCKfold.smd
    7 --- futureSTOCK.smd
    8 --- futureSTOCKcoll.smd
    9 --- futureSTOCKfold.smd
    10 --- buttSTOCK.smd
5 --- 	id: 4
     [	name: 4
    num: 10
    submodels:
    0 --- standardHG.smd
    1 --- flashHG.smd
    2 --- flashmlokHG.smd
    3 --- slimHG.smd
    4 --- picaHG.smd
    5 --- mlokHG.smd
    6 --- kurzgripHG.smd
    7 --- kurzslimHG.smd
    8 --- kurzmlokHG.smd
    9 ---
6 --- 	id: 5
     [	name: 5
    num: 4
    submodels:
    0 --- standardMAG.smd
    1 --- smallMAG.smd
    2 --- straightMAG.smd
    3 --- drumMAG.smd
7 --- 	id: 6
     [	name: 6
    num: 2
    submodels:
    0 ---
    1 --- mp5RAIL.smd

]]

SWEP.AttachmentElements = {
    ["ur_mp5_barrel_sd"] = {
        VMBodygroups = {
            {ind = 1, bg = 1},
            {ind = 4, bg = 9},
            //{ind = 8, bg = 1},
        },
        AttPosMods = {
            [6] = {
                vpos = Vector(0, 1.3, 10),
                vang = Angle(90, 0, -90),
            },
            [7] = {
				vpos = Vector(-1.15, 0.3, 8),
				vang = Angle(90, 0, 180),
			},
        },
    },
    ["ur_mp5_barrel_eod"] = {
        VMBodygroups = {
            {ind = 4, bg = 10},
            //{ind = 8, bg = 2},
        },
        AttPosMods = {
            [6] = {
                vpos = Vector(0, 1.5, 10),
                vang = Angle(90, 0, -90),
            },
            [7] = {
				vpos = Vector(-0.95, 0.3, 8),
				vang = Angle(90, 0, 180),
			},
		}
    },
    ["ur_mp5_barrel_kurz"] = {
        VMBodygroups = {
            {ind = 1, bg = 2},
            {ind = 4, bg = 7},
        },
        AttPosMods = {[4] = {
            vpos = Vector(-0.1, 0.3, 11.5),
            vang = Angle(90, 0, -90),
        }}
    },
    ["ur_mp5_barrel_swordfish"] = {
        VMBodygroups = {
            --{ind = 0, bg = 1},
            {ind = 1, bg = 3},
            {ind = 6, bg = 0},
        },
    },

    ["ur_mp5_rail_fg"] = {
        VMBodygroups = {{ind = 4, bg = 4}},
    },
    ["ur_mp5_ub_classic"] = {
        VMBodygroups = {{ind = 4, bg = 3}},
    },
    ["ur_mp5_ub_surefire"] = {
        VMBodygroups = {{ind = 4, bg = 1}},
    },
    ["ur_mp5_ub_surelock"] = {
        VMBodygroups = {{ind = 4, bg = 2}},
    },
    ["ur_mp5_ub_kurzgrip"] = {
        VMBodygroups = {{ind = 4, bg = 6}},
    },
    ["ur_mp5_ub_kurzmlok"] = {
        VMBodygroups = {{ind = 4, bg = 8}},
    },
    ["ur_mp5_ub_wood"] = {
        VMBodygroups = {{ind = 4, bg = 3}}, -- insert wood handguard here
    },

    ["ur_mp5_mag_15"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
    ["ur_mp5_mag_40"] = {
        VMBodygroups = {{ind = 5, bg = 3}},
    },
    ["ur_mp5_mag_50"] = {
        VMBodygroups = {{ind = 5, bg = 3}},
    },
    ["ur_mp5_mag_waffle"] = {
        VMBodygroups = {{ind = 5, bg = 2}},
    },

    ["ur_mp5_rail_optic"] = {
        VMBodygroups = {{ind = 6, bg = 1}},
    },

    ["ur_mp5_clamp"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },

    ["receiver_lower"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["receiver_lower_semi"] = {
        VMBodygroups = {{ind = 2, bg = 2}},
    },
    ["receiver_lower_0"] = {
        VMBodygroups = {{ind = 2, bg = 0}},
    },
    ["receiver_upper_0"] = {
        VMBodygroups = {{ind = 7, bg = 0}},
    },

    ["stock_a3"] = {
        VMBodygroups = {
            {ind = 3, bg = 1},
        },
    },
    ["stock_a3_folded"] = {
        VMBodygroups = {
            {ind = 3, bg = 2},
        },
    },
    ["ur_mp5_stock_remove"] = {
        VMBodygroups = {{ind = 3, bg = 10}},
    },
    ["ur_mp5_stock_wood"] = {
        -- VMBodygroups = {{ind = 0, bg = 4}},
        -- Make this part of the VMSkin
    },
    ["stock_pdw"] = {
        VMBodygroups = {{ind = 3, bg = 3}},
    },
    ["stock_pdw_folded"] = {
        VMBodygroups = {{ind = 3, bg = 4}},
    },
    ["stock_ump"] = {
        VMBodygroups = {{ind = 3, bg = 5}},
    },
    ["stock_ump_folded"] = {
        VMBodygroups = {{ind = 3, bg = 6}},
    },
    ["stock_future"] = {
        VMBodygroups = {{ind = 3, bg = 7}},
    },
    ["stock_future_folded"] = {
        VMBodygroups = {{ind = 3, bg = 8}},
    },
    ["ur_mp5_precision_irons"] = {
        VMBodygroups = {
            {ind = 0, bg = 2},
            {ind = 6, bg = 0},
            },
    },
}

SWEP.Hook_ModifyBodygroups = function(wep, data)
    local atts = wep.Attachments
    local vm = data.vm
    if IsValid(vm) then
        local barr = string.Replace(atts[2].Installed or "default","ur_mp5_barrel_","")
        local hg = string.Replace(atts[5].Installed or "default","ur_mp5_ub_","")
        
        if atts[6].Installed or atts[7].Installed then
            if barr == "sd" then
                vm:SetBodygroup(8, 1)
            elseif barr == "eod" then
                vm:SetBodygroup(8, 2)
            elseif hg == "default" or hg == "classic" then
                vm:SetBodygroup(4, 4)
                vm:SetBodygroup(8, 0)
            else
                vm:SetBodygroup(8, 0)
            end
        else
            vm:SetBodygroup(8, 0)
        end

        if hg == "mlok" then
            if barr == "kurz" then
                vm:SetBodygroup(4,8)
            else
                vm:SetBodygroup(4,5)
            end
        end

        if barr == "sword" then
            vm:SetBodygroup(0,(atts[1].Installed and 3) or 1)
        end
    end
end

SWEP.Hook_NameChange = function(wep,name)
    local atts = wep.Attachments
    local barr = string.Replace(atts[2].Installed or "default","ur_mp5_barrel_","")
    local cal = string.Replace(atts[3].Installed or "default","ur_mp5_caliber_","")
    local stock = string.Replace(atts[8].Installed or "default","ur_mp5_stock_","")
    local fakeNames = !GetConVar("arccw_truenames"):GetBool()
    local defaultCals = {
        ["default"] = true,
        ["noburst"] = true,
        ["semi"] = true
    }

    local start = "MP5"
    local mid = "A"
    local num = "4"
    if fakeNames then
        start = "PK5"
        mid = "-"
    end

    if cal == "semi" or atts[12].Installed == "uc_fg_civvy" then
        if fakeNames then
            return "PK5-CIV"
        else
            if barr == "long" or barr == "sd" then
                start = "HK94" -- I know how prolific civies can get with their gunbuilds, so the nonsensical names will continue
            else
                return "SP5" .. ((barr == "kurz" and "K-PDW") or "")
            end
        end
    end

    if !defaultCals[cal] then
        if barr == "sd" then
            num = "SD"
        else
            num = ""
        end
        if cal == "10auto" then
            mid = "/10"
        elseif cal == "40sw" then
            mid = "/40"
        elseif cal == "22lr" then
            if barr == "sd" then
                mid = "SD"
                num = " .22 LR"
            else
                mid = " .22 LR"
            end
        end
    else
        if barr == "kurz" then
            if fakeNames then
                mid = "C"
            else
                mid = "K"
            end
            if stock == "pdw" then
                num = "-PDW"
            elseif cal == "default" then
                if fakeNames then
                    num = "-4"
                else
                    num = "A4"
                end
            else
                num = ""
            end
        else
            if barr == "sd" then
                mid = "SD"
            end

            if cal == "noburst" or cal == "semi" then
                if stock == "a3" then
                    num = "3"
                elseif stock == "none" then
                    num = "1"
                else
                    num = "2"
                end
            else
                if stock == "a3" then
                    if barr == "sd" then
                        num = "6"
                    else
                        num = "5"
                    end
                elseif stock == "none" then
                    if barr == "sd" then
                        num = "4"
                    end
                else
                    if barr == "sd" then
                        num = "5"
                    end
                end
            end
        end
    end

    return start .. mid .. num
end

-- Animations --

SWEP.Hook_Think = ArcCW.UC.ADSReload

local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}
local rottle = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local rutle = {common .. "movement-smg-03.ogg",common .. "movement-smg-04.ogg"}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    -- ["idle_empty"] = {
    --     Source = "idle",
    -- },
    ["ready"] = {
        Source = "ready",
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0.15},
            {s = path .. "rack1.ogg",         t = 0.15, c = ci},
            {s = path .. "rack2.ogg",         t = 0.38, c = ci},
            {s = ratel,         t = 0.75},
        }
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = ArcCW.UC.DrawSounds,
    },
    -- ["draw_empty"] = {
    --     Source = "draw_empty",
    --     SoundTable = ArcCW.UC.DrawSounds,
    -- },
    ["holster"] = {
        Source = "holster",
        --Time = 0.25,
        SoundTable = ArcCW.UC.HolsterSounds,
    },
    -- ["holster_empty"] = {
    --     Source = "holster_empty",
    --     --Time = 0.25,
    --     SoundTable = ArcCW.UC.HolsterSounds,
    -- },
    ["fire"] = {
        Source = "fire",
        Time = 13 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    -- ["fire_empty"] = {
    --     Source = "fire",
    --     Time = 13 / 30,
    --     ShellEjectAt = 0.03,
    --     SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    -- },
    ["fire_iron"] = {
        Source = "idle",
        Time = 13 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },
    -- ["fire_empty_iron"] = {
    --     Source = "idle",
    --     Time = 13 / 30,
    --     ShellEjectAt = 0.03,
    --     SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    -- },

    ["fix"] = {
        Source = "fix",
        Time = 40 / 30,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        ShellEjectAt = 0.36,
        SoundTable = {
            {s = rottle, t = 0.15},
            {s = path .. "rack1.ogg",         t = 0.27, c = ci},
            {s = path .. "rack2.ogg",         t = 0.5, c = ci},
        },
    },

    -- 30 Round Reloads --

    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 2,
        MinProgress = 1.2,
        LastClip1OutTime = 2,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "magpouch.ogg", t = 0.05},
            {s = path .. "magout.ogg",        t = 0.4, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 0.61, c = ci},
            {s = common .. "magpouchin.ogg", t = 1.25},
            {s = ratel,  t = 1.55},
            {s = common .. "shoulder.ogg",  t = 1.5},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.045, c = ci},
            {s = path .. "chlock.ogg",         t = 0.18, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = 0.86, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.13, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.05, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },
    ["reload_kurz"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 2,
        MinProgress = 1.2,
        LastClip1OutTime = 2,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "magpouch.ogg", t = 0.05},
            {s = path .. "magout.ogg",        t = 0.4, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 0.63, c = ci},
            {s = common .. "magpouchin.ogg", t = 1.25},
            {s = ratel,  t = 1.55},
            {s = common .. "shoulder.ogg",  t = 1.5},
        },
    },
    ["reload_empty_kurz"] = {
        Source = "reload_empty_kurz",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.066, c = ci},
            {s = path .. "chlock.ogg",         t = 0.2, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = 0.86, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.13, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.1, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },

    -- 15 Round Reloads --

    ["reload_15"] = {
        Source = "reload",--"reload_15",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 67 / 30,
        MinProgress = 1.2,
        LastClip1OutTime = 67 / 30,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "magpouch.ogg", t = 0.05},
            {s = path .. "magout.ogg",        t = 0.25, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 0.5, c = ci},
            {s = common .. "magpouchin.ogg", t = 1.25},
            {s = ratel,  t = 1.55},
            {s = common .. "shoulder.ogg",  t = 1.5},
        },
    },
    ["reload_empty_15"] = {
        Source = "reload_empty",--"reload_empty_15",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.1, c = ci},
            {s = path .. "chlock.ogg",         t = 0.19, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = .9, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.2, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.13, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },
    ["reload_empty_kurz_15"] = {
        Source = "reload_empty_kurz",--"reload_empty_15",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.1, c = ci},
            {s = path .. "chlock.ogg",         t = 0.19, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = .9, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.2, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.13, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },

    -- 40 Round Reloads --

    ["reload_40"] = {
        Source = "reload",--"reload_40",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 67 / 30,
        MinProgress = 1.2,
        LastClip1OutTime = 67 / 30,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "magpouch.ogg", t = 0.05},
            {s = path .. "magout.ogg",        t = 0.25, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 0.5, c = ci},
            {s = common .. "magpouchin.ogg", t = 1.25},
            {s = ratel,  t = 1.55},
            {s = common .. "shoulder.ogg",  t = 1.5},
        },
    },
    ["reload_empty_40"] = {
        Source = "reload_empty",--"reload_empty_40",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.1, c = ci},
            {s = path .. "chlock.ogg",         t = 0.19, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = .9, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.2, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.13, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },
    ["reload_empty_kurz_40"] = {
        Source = "reload_empty_kurz",--"reload_empty_40",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.1, c = ci},
            {s = path .. "chlock.ogg",         t = 0.19, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = .9, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.2, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.13, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },

    -- 100 Round Reloads --

    ["reload_drum"] = {
        Source = "reload_drum",--"reload_50",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 67 / 30,
        MinProgress = 1.6,
        LastClip1OutTime = 1,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.9,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "magout.ogg",        t = 0.32, c = ci},
            {s = rottle, t = 0.25},
            {s = rottle, t = 0.75},
            {s = path .. "magin.ogg",         t = 1.05, c = ci},
            {s = common .. "cloth_4.ogg",  t = 1.65},
            {s = path .. "magtap.ogg",         t = 1.755, c = ci},
            {s = common .. "shoulder.ogg",  t = 2.25},
        },
    },
    ["reload_empty_drum"] = {
        Source = "reload_empty_drum",--"reload_empty_50",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.4,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 1,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "magout.ogg",        t = 0.3, c = ci},
            {s = rottle, t = 0.25},
            {s = rottle, t = 0.75},
            {s = common .. "magdrop.ogg",  t = 1.0},
            {s = path .. "magin.ogg",         t = 1.05, c = ci},
            {s = common .. "cloth_4.ogg",  t = 1.65},
            {s = path .. "magtap.ogg",         t = 1.755, c = ci},
            {s = path .. "rack1.ogg",         t = 2.3, c = ci},
            {s = path .. "rack2.ogg",         t = 2.5, c = ci},
            {s = common .. "shoulder.ogg",  t = 3.0},
        },
    },

    ["enter_inspect"] = {
        Source = "inspect_enter",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-smg-03.ogg", t = 0},
        },
    },
    ["idle_inspect"] = {
        Source = "inspect_loop",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
    },
    ["exit_inspect"] = {
        Source = "inspect_exit",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
        SoundTable = {
            {s = common .. "movement-smg-01.ogg", t = 0.2},
            {s = rottle, t = 0.25},
            {s = rottle, t = 1.2},
            {s = common .. "movement-smg-04.ogg", t = 1.25},
        },
    },

    ["enter_sprint"] = {
        Source = "sprint_enter",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKOut = 0,
        Time = .5,
    },
    ["idle_sprint"] = {
        Source = "sprint_loop",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_sprint"] = {
        Source = "sprint_exit",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.5,
        Time = .5,
    },
}

SWEP.AutosolveSourceSeq = "idle"

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic_lp","optic","ur_mp5_optic"}, -- ,"optic"
        Bone = "body",
        Offset = {
            vpos = Vector(-0.1, -1.6, 3),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(-0.09, 0, 0),
        CorrectiveAng = Angle(1, 0.6, -4.0),
        InstalledEles = {"ur_mp5_rail_optic"}
    },
    {
        PrintName = "Upper Receiver",
        DefaultAttName = "9\" Standard Upper",
        DefaultAttIcon = Material("entities/att/ur_mp5/upper_std.png", "smooth mips"),
        Slot = "ur_mp5_barrel",
        Bone = "body",
        Offset = {
            vpos = Vector(2.6, -3.7, -17.3),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Lower Receiver",
        DefaultAttName = "Navy Lower",
        DefaultAttIcon = Material("entities/att/ur_mp5/grip.png", "smooth mips"),
        Slot = "ur_mp5_caliber",
        DefaultEles = {"receiver_lower_0"}
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle"},
        Bone = "body",
        Offset = {
            vpos = Vector(0, 0.3, 14.8),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"barrel_sd","barrel_eod","barrel_sword"}
    },
    {
        PrintName = "Handguard",
        DefaultAttName = "Tropical Handguard",
        DefaultAttIcon = Material("entities/att/ur_mp5/hg_std.png", "smooth mips"),
        Slot = {"ur_mp5_hg"},
        ExcludeFlags = {"barrel_sd", "barrel_eod"},
        Bone = "body",
        Offset = {
            vpos = Vector(0, .9, 10),
            vang = Angle(90, 0, -90),
        },
        --VMScale = Vector(.8, .8, .8),
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip"},
        Bone = "body",
        Offset = {
            vpos = Vector(0, .9, 10),
            vang = Angle(90, 0, -90),
        },
        --VMScale = Vector(.8, .8, .8),
        --InstalledEles = {"ur_mp5_rail_fg"},
        GivesFlags = {"mp5_rail"},
        ExcludeFlags = {"mp5_badhg","mp5_kurz"},
        MergeSlots = {15},
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "body",
        Offset = {
            vpos = Vector(-0.9, 0.2, 8),
            vang = Angle(90, 0, 180),
        },
        VMScale = Vector(.8,.8,.8),
        --InstalledEles = {"ur_mp5_clamp"}
        GivesFlags = {"mp5_rail"},
    },
    {
        PrintName = "Stock",
        Slot = {"ur_mp5_stock"},
        DefaultAttName = "Full Stock",
        DefaultAttIcon = Material("entities/att/ur_mp5/stock_std.png", "smooth mips"),
    },
    {
        PrintName = "Magazine",
        Slot = {"ur_mp5_mag"},
        DefaultAttName = "30-Round Mag",
        DefaultAttIcon = Material("entities/att/ur_mp5/mag30.png", "smooth mips"),
        ExcludeFlags = {"ur_mp5_cal_40sw","ur_mp5_cal_10mm"}
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load",
        ExcludeFlags = {"barrel_sd"}
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm", "mp5_charm"},
        FreeSlot = true,
        Bone = "Body",
        Offset = {
            vpos = Vector(0.6, 1.1, 2.5),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "M203 slot",
        Slot = "uc_ubgl",
        Bone = "Body",
        Offset = {
            vpos = Vector(0, 0, 7.9),
            vang = Angle(90, 0, -90),
        },
        Hidden = true,
        --RequireFlags = {"barrel_eod"},
        ExcludeFlags = {"mp5_badhg","mp5_kurz"},
    }
}

-- SWEP.AttachmentOverrides = {
--     ["uc_grip_handstop"] = {
--         LHIK = false
--     }
-- } -- THIS SHIT DOESN'T WORK

--lua/weapons/arccw_ur_mp5.lua:
return gluapack()()
--lua/weapons/arccw_ur_mp5swordfish.lua:
return gluapack()()
--lua/weapons/arccw_ur_aw.lua:
return gluapack()()
--lua/weapons/arccw_ur_ak.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "ArcCW - Urban Coalition" -- edit this if you like
SWEP.UC_CategoryPack = "2Urban Renewal"
SWEP.AdminOnly = false

SWEP.PrintName = "KF-67"
SWEP.TrueName = "AKM"

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

local descStart = "One of the first assault rifles, wielded around the world to this day for its cheap price, quick production, ease of maintenance, and infallible reliability. Consequently, it has become the most popular rifle ever; a constant of freedom fighters and third-world dictators virtually everywhere. One fifth of all small arms in existence can be traced to this design.\n\n"
local desc_762 = "The default pattern is well-rounded and hard-hitting, but kicks harder than other weapons of its class."
local desc_545 = "With a heavier frame than other service rifles, the AK-74 platform is accurate and easy to control."
local desc_74u = "This PDW variant sacrifices range and control to fit the power of a rifle into a very compact form."
local desc_9mm = "Well-rounded submachine gun that shares common parts with AK rifles. For its widespread use by a variety of security divisions, it can be described as a Russian counterpart to the MP5.\n\nThe moniker \"Vityaz\" translates to \"knight.\""
local desc_12g = "Magazine-fed semi automatic shotgun based on the Kalashnikov pattern. It is a popular civilian weapon due to the comparative simplicity of Russia's smoothbore gun licenses, but it has also been used by security firms around the world.\n\nIts low accuracy is compensated for by a much faster reload time than tube-fed designs."
local desc_556 = "This international variant has a lower damage output than the Russian cartridges, but boasts substantially lower recoil."
local desc_366 = "AK-pattern shotgun chambered in .366 TKM, a sporting cartridge that uses reshaped M43 casings. It is considered a shotgun because of its smoothbore barrel, a change made to circumvent Russian rifle laws. Despite the lack of rifling, it achieves similar ballistics to a proper AK-47."

SWEP.Trivia_Class = "Assault Rifle"
SWEP.Trivia_Desc = descStart .. desc_762
SWEP.Trivia_Manufacturer = "Izhmash"
SWEP.Trivia_Calibre = "7.62x39mm Soviet"
SWEP.Trivia_Mechanism = "Gas-Operated Rotating Bolt"
SWEP.Trivia_Country = "Soviet Union"
SWEP.Trivia_Year = 1959

SWEP.Slot = 2
SWEP.CamAttachment = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/c_ur_ak.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ur_ak.mdl"
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "010000800120"

-- Damage --

SWEP.Damage = 50 -- 2 shot close range kill
SWEP.DamageMin = 25 -- 4 shot long range kill
SWEP.RangeMin = 30
SWEP.Range = 300 -- 3 shot until ~170m
SWEP.Penetration = 16
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 715
SWEP.PhysBulletMuzzleVelocity = 715

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 30
SWEP.ExtendedClipSize = 40
SWEP.ReducedClipSize = 15

-- Recoil --

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.3

SWEP.RecoilRise = 0.6
SWEP.RecoilPunch = 1
SWEP.VisualRecoilMult = 1
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 1
SWEP.RecoilPunchBack = 2

SWEP.Sway = 0.6

-- Firerate / Firemodes --

SWEP.Delay = 60 / 600
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_ar2"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 800
SWEP.MoveDispersion = 250
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "ar2"
SWEP.MagID = "ak"

SWEP.HeatCapacity = 75
SWEP.HeatDissipation = 15
SWEP.HeatDelayTime = 3

-- SWEP.Malfunction = true
SWEP.MalfunctionMean = 200
--SWEP.MeleeTime = 1.5

-- Speed multipliers --

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.75

local path = ")weapons/arccw_ur/ak/"
local path1 = ")weapons/arccw_ur/mp5/"
local common = ")/arccw_uc/common/"
local rottle = {common .. "cloth_1.ogg", common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}
local rutle = {common .. "movement-rifle-01.ogg",common .. "movement-rifle-02.ogg",common .. "movement-rifle-03.ogg",common .. "movement-rifle-04.ogg"}
--SWEP.FirstShootSound = path .. "fire_first.ogg"

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}
SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = path .. "dryfire.ogg"

local tail = ")/arccw_uc/common/762x39/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-762x39-rif-ext-01.ogg",
    tail .. "fire-dist-762x39-rif-ext-02.ogg",
    tail .. "fire-dist-762x39-rif-ext-03.ogg",
    tail .. "fire-dist-762x39-rif-ext-04.ogg",
    tail .. "fire-dist-762x39-rif-ext-05.ogg",
    tail .. "fire-dist-762x39-rif-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-rifle-01.ogg",
    common .. "fire-dist-int-rifle-02.ogg",
    common .. "fire-dist-int-rifle-03.ogg",
    common .. "fire-dist-int-rifle-04.ogg",
    common .. "fire-dist-int-rifle-05.ogg",
    common .. "fire-dist-int-rifle-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

SWEP.MuzzleEffect = "muzzleflash_6"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/762x39.mdl"
SWEP.ShellPitch = 90
SWEP.ShellScale = .666
SWEP.ShellRotateAngle = Angle(0, 0, 0)
SWEP.UC_ShellColor = Color(0.7 * 255, 0.2 * 255, 0.2 * 255)

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.BulletBones = {
    [1] = "tag_mag2",
}

SWEP.IronSightStruct = {
    Pos = Vector(-2.61, -2, 0.45),
    Ang = Angle(0.60, 0.274, 5.53),
    Magnification = 1.1,
    SwitchToSound = "", -- sound that plays when switching to this sight
    CrosshairInSights = false
}
SWEP.LaserOffsetAngle = Angle(0, 0, 0)
SWEP.LaserIronsAngle = Angle(0, 0, 0)

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0.5, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 0)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-2, -2, -0.6)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.HolsterPos = Vector(-1, -1, 1.2)
SWEP.HolsterAng = Angle(-15, 8, -10)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(0, 0, 0)

-- SWEP.CustomizePos = Vector(6.5, 0.8, -0.2)
-- SWEP.CustomizeAng = Angle(8, 22, 15)

SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.BarrelLength = 24

SWEP.AttachmentElements = {
    ["barrel_74m"] = {
        VMBodygroups = {{ind = 1, bg = 3}}
    },
    ["barrel_74m_red"] = {
        VMBodygroups = {{ind = 1, bg = 10}}
    },
    ["barrel_74m_green"] = {
        VMBodygroups = {{ind = 1, bg = 11}}
    },
    ["barrel_akm"] = {
        VMBodygroups = {{ind = 1, bg = 0}}
    },
    ["barrel_alpha"] = {
        VMBodygroups = {
            {ind = 1, bg = 7},
            -- {ind = 7, bg = 6},
            -- {ind = 8, bg = 2},
        },
    },
    ["barrel_rpk"] = {
        VMBodygroups = {
            {ind = 7, bg = 1},
            {ind = 8, bg = 2}
        },
        AttPosMods = {[4] = {
            vpos = Vector(0, 32.2, 2.6),
            vang = Angle(0, 270, 0),
        }},
    Override_IronSightStruct = {
            Pos = Vector(-2.625, -2, 0.68),
            Ang = Angle(-0.1, 0.274, 5.53),
            Magnification = 1,
    }
    },
    ["barrel_rpk74m"] = {
        VMBodygroups = {
            {ind = 1, bg = 5},
            -- {ind = 7, bg = 1},
            -- {ind = 8, bg = 2}
        },
        -- AttPosMods = {[4] = {
        --     vpos = Vector(0, 32.2, 2.6),
        --     vang = Angle(0, 270, 0),
        -- }},
        -- Override_IronSightStruct = {
        -- 	Pos = Vector(-2.625, -2, 0.68),
        -- 	Ang = Angle(-0.1, 0.274, 5.53),
        -- 	Magnification = 1,
        -- }
    },
    ["barrel_krinkov"] = {
        VMBodygroups = {
            {ind = 1, bg = 6},
            {ind = 7, bg = 5},
            {ind = 8, bg = 2},
            {ind = 4, bg = 1},
            {ind = 5, bg = 1}
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, 15, 2.85),
                vang = Angle(0, 270, 0),
            },
            [7] = {
                vpos = Vector(0,10,1.7),
                vang = Angle(90, -90, -90),
                SlideAmount = {
                    vmin = Vector(0,10,1.7),
                    vmax = Vector(0,10,1.7)
                },
            },
            [8] = {
                vpos = Vector(-0.8, 11.75, 2.9),
                vang = Angle(-90, 270, 0),
                wang = Angle(-90, 270, 0),
            }
        },
        Override_IronSightStruct = {
            Pos = Vector(-2.638, -2, 0.9),
            Ang = Angle(-1, 0.12, 5.53),
            Magnification = 1,
        }
    },
    ["barrel_vityaz"] = {
        VMBodygroups = {
            {ind = 1, bg = 8},
            {ind = 7, bg = 5},
            {ind = 8, bg = 2},
            {ind = 5, bg = 1}
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, 16.5, 2.85),
                vang = Angle(0, 270, 0),
            },
            [7] = {
                vpos = Vector(0,11,1.7),
                vang = Angle(90, -90, -90),
                SlideAmount = {
                    vmin = Vector(0,10,1.7),
                    vmax = Vector(0,11,1.7)
                },
            },
            [8] = {
                vpos = Vector(-0.8, 11.75, 2.9),
                vang = Angle(-90, 270, 0),
                wang = Angle(-90, 270, 0),
            }
        },
        Override_IronSightStruct = {
            Pos = Vector(-2.62, -2, 0.75),
            Ang = Angle(-0.42, 0.2, 5.53),
            Magnification = 1,
        }
    },
    ["barrel_t56"] = {
        VMBodygroups = {
            {ind = 7, bg = 3},
            {ind = 11, bg = 2},
            {ind = 8, bg = 2}
        },
    },
    ["barrel_t56_ext"] = {
        VMBodygroups = {
            {ind = 7, bg = 3},
            {ind = 11, bg = 3},
            {ind = 8, bg = 2}
        },
    },
    ["barrel_vepr"] = {
        VMBodygroups = {
            --{ind = 1, bg = 9},
            {ind = 7, bg = 4},
            {ind = 8, bg = 2}
        },
        AttPosMods = {[4] = {
            vpos = Vector(0, 28.5, 2.7),
            vang = Angle(0, 270, -0),
        }},
        Override_IronSightStruct = {
            Pos = Vector(-2.63, -2, 0.76),
            Ang = Angle(-0.3, 0.18, 5.53),
            Magnification = 1,
        }
    },

    ["ur_ak_hg_vepr"] = {
        VMBodygroups = {
            {ind = 1, bg = 9},
        },
    },

    ["barrel_105"] = {
        VMBodygroups = {
            --{ind = 1, bg = 3},
            {ind = 7, bg = 2},
            {ind = 8, bg = 2}
        },
        AttPosMods = {[4] = {
            vpos = Vector(0, 19.9, 2.7),
            vang = Angle(0, 270, 0),
        }},
        Override_IronSightStruct = {
            Pos = Vector(-2.6, -2, 0.48),
            Ang = Angle(0.6, 0.265, 5.53),
            Magnification = 1,
        }
    },
    ["barrel_dong"] = {
        VMBodygroups = {{ind = 1, bg = 2}}, -- This will show up regardless of barrel selection because underbarrel atts are always processed after barrel atts
        AttPosMods = {[6] = {
            SlideAmount = {
                vmin = Vector(0,12,1.9),
                vmax = Vector(0,12,1.9)
            },
        }}
    },

    ["muzzle_akm"] = {
        VMBodygroups = {{ind = 8, bg = 1}}
    },
    ["muzzle_ak74"] = {
        VMBodygroups = {{ind = 8, bg = 3}}
    },
    ["muzzle_aku"] = {
        VMBodygroups = {{ind = 8, bg = 6}}
    },
    ["muzzle_bayonet"] = {
        VMBodygroups = {{ind = 11, bg = 1}}
    },

    ["stock_alpha"] = {
        VMBodygroups = {
            {ind = 6, bg = 4},
            {ind = 3, bg = 1},
        }

    },
    ["stock_aks"] = {
        VMBodygroups = {
            {ind = 6, bg = 3},
            {ind = 3, bg = 1},
    }
    },
    ["stock_aks_folded"] = {
        VMBodygroups = {
            {ind = 6, bg = 10},
            {ind = 3, bg = 1},
        }

    },
    ["stock_underfolder"] = {
        VMBodygroups = {{ind = 6, bg = 2}}
    },
    ["stock_underfolder_folded"] = {
        VMBodygroups = {{ind = 6, bg = 1}}
    },
    ["stock_ak74m"] = {
        VMBodygroups = {
            {ind = 3, bg = 1},
            {ind = 6, bg = 12}
        }
    },
    ["stock_ak74m_folded"] = {
        VMBodygroups = {
            {ind = 3, bg = 1},
            {ind = 6, bg = 13}
        }
    },
    ["stock_rpk"] = {
        VMBodygroups = {{ind = 6, bg = 5}}
    },
    ["stock_akn"] = {
        VMBodygroups = {{ind = 6, bg = 0}}
    },
    ["stock_skeletal"] = {
        VMBodygroups = {
            {ind = 6, bg = 6},
            {ind = 3, bg = 1},
        }
    },
    ["stock_vepr"] = {
        VMBodygroups = {
            {ind = 6, bg = 7},
            {ind = 9, bg = 4}
        }
    },
    ["stock_none"] = {
        VMBodygroups = {
            {ind = 6, bg = 9},
            {ind = 3, bg = 1},
        }
    },

    ["mag_762_75"] = {
        VMBodygroups = {{ind = 2, bg = 1}}
    },
    ["mag_762_bakelite"] = {
        VMBodygroups = {{ind = 2, bg = 11}}
    },
    ["mag_762_pmag"] = {
        VMBodygroups = {{ind = 2, bg = 12}}
    },
    ["mag_545_30"] = {
        VMBodygroups = {{ind = 2, bg = 2}}
    },
    ["mag_556_30"] = {
        VMBodygroups = {{ind = 2, bg = 10}}
    },
    ["mag_545_45"] = {
        VMBodygroups = {{ind = 2, bg = 3}}
    },
    ["mag_9mm"] = {
        VMBodygroups = {{ind = 2, bg = 4}}
    },
    ["mag_12g"] = {
        VMBodygroups = {{ind = 2, bg = 5}}
    },
    ["mag_366"] = {
        VMBodygroups = {{ind = 2, bg = 6}}
    },

    ["grip_akm"] = {
        VMBodygroups = {{ind = 9, bg = 0}}
    },
    ["grip_alpha"] = {
        VMBodygroups = {{ind = 9, bg = 2}}
    },
    ["grip_saiga"] = {
        VMBodygroups = {{ind = 9, bg = 3}}
    },

    ["cover_ribbed"] = {
        VMBodygroups = {{ind = 10, bg = 0}}
    },
    ["cover_alpha"] = {
        VMBodygroups = {{ind = 10, bg = 1}},
        AttPosMods = {[1] = {
            vpos = Vector(0, 3.5, 4.68),
            vang = Angle(0, -90, 0),
        }}
    },
    ["optic_raillaser"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(0.95, 2.5, 4.05),
                vang = Angle(0, -90, 125),
            },
        },
    },
    ["cover_ak12"] = {
        VMBodygroups = {{ind = 10, bg = 4}},
        AttPosMods = {[1] = {
            vpos = Vector(0, 3.5, 4.67),
            vang = Angle(0, -90, 0),
        }}
    },

    ["grip_ak12"] = {
        VMBodygroups = {{ind = 9, bg = 5}}
    },
    ["stock_ak12"] = {
        VMBodygroups = {{ind = 6, bg = 11}},
    },
    ["handguard_ak12"] = {
        VMBodygroups = {{ind = 1, bg = 12}},
        --[[AttPosMods = {[6] = {
            vpos = Vector(0, 11.75, 2.2),
            vang = Angle(90, -90, -90),
        }}]]
        AttPosMods = {
            [8] = {
                vpos = Vector(-0.7, 13.5, 3.8),
                vang = Angle(-90, 270, 0),
                wang = Angle(-90, 270, 0),
            },
            [7] = {
                vpos = Vector(0, 11.75, 2.2),
                vang = Angle(90, -90, -90),
            }
        },
    },
    ["barrel_ak12"] = {
        VMBodygroups = {
            {ind = 7, bg = 6},
            {ind = 8, bg = 2}
        },
        AttPosMods = {[4] = {
            vpos = Vector(0, 23.5, 2.8),
            vang = Angle(0, 270, 0),
        }},
        Override_IronSightStruct = {
            Pos = Vector(-2.68, 0, 1.3),
            Ang = Angle(-2.02, 0.028, 5.53),
            Magnification = 1,
        }
        --RequireFlags = {"cover_rail"},
    },
    ["muzzle_ak12"] = {
        VMBodygroups = {{ind = 8, bg = 2}},
    },
    ["reciever_ak12"] = {
        VMBodygroups = {{ind = 0, bg = 1}}
    },
    ["sight_ak12"] = {
        VMBodygroups = {{ind = 4, bg = 3}},
        RequireFlags = {"cover_rail", "ak_railedguard"},
        Override_IronSightStruct = {
            Pos = Vector(-2.63, 0, 0.79),
            Ang = Angle(-1.12, 0.116, 5.53),
            Magnification = 1,
        },
        Override_IronSightStruct_Priority = 2,
    },
    ["mag_545_ak12"] = {
        VMBodygroups = {{ind = 2, bg = 7}}
    },
    ["mag_545_black"] = {
        VMBodygroups = {{ind = 2, bg = 9}}
    },
    ["mag_308"] = {
        VMBodygroups = {{ind = 2, bg = 8}}
    },

    ["cover_trail"] = {
        VMBodygroups = {{ind = 4, bg = 4}},
        AttPosMods = {[1] = {
            vpos = Vector(0, 8.2, 5.20),
            vang = Angle(0, -90, 0),
        }}
    },
}

SWEP.Hook_ModifyBodygroups = function(wep, data)
    local akOptics = {["uc_optic_pso1"] = true, ["uc_optic_kobra"] = true} -- Will need to update this list if more AK optics get added
    local railHgs = {["default"] = true, ["type3"] = true}
    local bipodBarrs = {["rpk"] = true}
    local shortBarrs = {["krinkov"] = true, ["vityaz"] = true}
    local intCals = {["545"] = true, ["556"] = true, ["545_ak12"] = true}

    local optic = wep.Attachments[1].Installed
    local barr = string.Replace(wep.Attachments[2].Installed or "default","ur_ak_barrel_","")
    local hg = string.Replace(wep.Attachments[3].Installed or "default","ur_ak_hg_","")
    local muzz = wep.Attachments[4].Installed
    local cal = string.Replace(wep.Attachments[5].Installed or "default","ur_ak_cal_","")
    local ub = wep.Attachments[7].Installed-- or wep.Attachments[17].Installed
    local upper = wep.Attachments[15].Installed
    local alpha = (upper == "ur_ak_cover_alpha" or upper == "ur_ak_cover_ak12" or upper == "ur_ak_cover_truniun_rail")
    local taclaser = (wep.Attachments[16].Installed == "ur_ak_charm_tl")

    local vm = data.vm
    if !IsValid(vm) then return end

    -- Default muzzle devices
    if !muzz or muzz == "ur_ak_muzzle_bayonet" then
        if barr == "ak12" and (cal == "default" or intCals[cal]) then
            vm:SetBodygroup(8,3)
        elseif barr == "krinkov" then
            vm:SetBodygroup(8,4)
        elseif barr == "default" or barr == "t56" then
            if cal == "default" then
                vm:SetBodygroup(8,1)
            elseif intCals[cal] then
                vm:SetBodygroup(8,3)
            else
                vm:SetBodygroup(8,0)
            end
        end
    elseif barr == "default" then
        vm:SetBodygroup(8,0)
    else
        vm:SetBodygroup(8,2)
    end

    --
    if taclaser and !akOptics[optic] then
        vm:SetBodygroup(12,2)
    else
        if optic and !alpha and !akOptics[optic] then
            vm:SetBodygroup(12,1)
        else
            vm:SetBodygroup(12,0)
        end
    end

    -- Railed underbarrel
    if ub and hg != "ur_ak_hg_dong" and barr != "vityaz" then
        if barr == "krinkov" then
            vm:SetBodygroup(13,2)
        elseif railHgs[hg] then
            vm:SetBodygroup(1,13)
        else
            vm:SetBodygroup(13,1)
        end
    else
        vm:SetBodygroup(13,0)
    end

    -- RPK bipod
    if bipodBarrs[barr] then
        vm:SetBodygroup(7, (wep:GetInBipod() and (wep.LastAnimKey ~= "enter_bipod" or wep.LastAnimFinishTime < CurTime())) and 7 or 1)
    end
end

SWEP.ExtraSightDist = 2
SWEP.GuaranteeLaser = false

SWEP.WorldModelOffset = {
    pos = Vector(-7, 4, -4),
    ang = Angle(-12, 0, 180)
}

SWEP.MirrorVMWM = true

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic","optic_sniper","ur_ak_optic"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 2, 4.92),
            vang = Angle(0, -90, 0),
        },
        CorrectivePos = Vector(0, 0, -0.0),
        CorrectiveAng = Angle(-1.9, 180.15, 0),
        VMScale = Vector(1, 1, 1),
        -- SlideAmount = {
        --     vmin = Vector(0, 2-1, 4.55),
        --     vmax = Vector(0, 2+0.5, 4.55),
        -- },
--        RequireFlags = {"cover_rail"},
--        HideIfBlocked = true,
        -- InstalledEles = {"optic_rail"},
    },
    {
        PrintName = "Barrel",
        DefaultAttName = "16\" Standard Barrel",
        DefaultAttIcon = Material("entities/att/ur_ak/barrel/std.png", "mips smooth"),
        Slot = "ur_ak_barrel",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0,12, 1.9),
            vang = Angle(90, -90, -90),
        },
    },
    {
        PrintName = "Handguard",
        DefaultAttName = "Factory Handguard",
        DefaultAttIcon = Material("entities/att/ur_ak/handguards/std.png", "mips smooth"),
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0,12, 1.9),
            vang = Angle(90, -90, -90),
        },
        Slot = "ur_ak_hg",
        ExcludeFlags = {"barrel_carbine"},
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle","ur_ak_muzzle"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 24.1, 2.7),
            vang = Angle(0, 270, 0),
        },
        ExcludeFlags = {"ur_ak_nomuzzle"},
        --Installed = "ur_ak_muzzle_akm"
    },
    {
        PrintName = "Receiver",
        DefaultAttName = "7.62x39mm Reciever",
        DefaultAttIcon = Material("entities/att/uc_bullets/762x39.png", "mips smooth"),
        Slot = {"ur_ak_cal"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(2.8, -4.2, -11.5),
            vang = Angle(90, 0, -90),
        },
        DefaultFlags = {"cal_default"}
    },
    {
        PrintName = "Magazine",
        Slot = {"ur_ak_mag"},
        DefaultAttName = "30-Round Mag",
        DefaultAttIcon = Material("entities/att/ur_ak/magazines/762_30.png", "mips smooth"),
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip","ur_ak_ub"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0,12, 1.9),
            vang = Angle(90, -90, -90),
        },
        VMScale = Vector(1, 1, 1),
        SlideAmount = {
            vmin = Vector(0,10.5,1.9),
            vmax = Vector(0,13.5,1.9)
        },
        InstalledEles = {"rail_fg"},
        ExcludeFlags = {"ak_noubs"},
        MergeSlots = {17},
    },
    {
        PrintName = "Tactical",
        Slot = {"tac"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 19.6, 2.1),
            vang = Angle(0, 270, 0),
        },
        GivesFlags = {"tac"},
        --InstalledEles = {"ud_m16_clamp_fullsize"}
    },
    {
        PrintName = "Grip Type",
        Slot = {"ur_ak_grip"},
        DefaultAttName = "Factory Grip",
        DefaultAttIcon = Material("entities/att/ur_ak/grip_modern.png", "mips smooth"),
        ExcludeFlags = {"stock_vepr"},
    },
    {
        PrintName = "Stock",
        Slot = {"ur_ak_stock"},
        DefaultAttName = "Factory Stock",
        DefaultAttIcon = Material("entities/att/ur_ak/stock/n.png", "mips smooth"),
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Dust Cover",
        DefaultAttName = "Ribbed Dust Cover",
        DefaultAttIcon = Material("entities/att/ur_ak/dustcover_stock.png", "mips smooth"),
        Slot = {"ur_ak_cover"},
        FreeSlot = true,
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm", "ur_ak_charm"},
        FreeSlot = true,
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0.6, 6.7, 2.2),
            vang = Angle(90, -90, -90),
        },
    },
    {
        PrintName = "M203 slot",
        Slot = "uc_ubgl",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 9.9, 2.9),
            vang = Angle(90, -90, -90),
        },
        InstalledEles = {"rail_fg"},
        ExcludeFlags = {"ak_noubs","barrel_rpk"},
        Hidden = true,
    }
}

function SWEP:Hook_TranslateAnimation(anim)
    if anim == "fire_iron" then
        if self:GetBuff_Override("NoStock") then return "fire" end
    elseif anim == "fire_iron_empty" then
        if self:GetBuff_Override("NoStock") then return "fire_empty" end
    end
end

SWEP.Hook_NameChange = function(wep,name)
    local foldStocks = {["underfolder"] = true,["aks"] = true}
    local akCals = {["762"] = true,["545"] = true}
    local shortBarrs = {["krinkov"] = true,["vityaz"] = true}
    local fakeNames = !GetConVar("arccw_truenames"):GetBool()

    local start = "AK"
    local mid = ""
    local post = "M"
    local noN = false

    if fakeNames then
        start = "KF"
        post = "-67"
    end

    local atts = wep.Attachments
    local barr = string.Replace(atts[2].Installed or "default", "ur_ak_barrel_", "")
    local hg = string.Replace(atts[3].Installed or "default", "ur_ak_hg_", "")
    local cal = string.Replace(atts[5].Installed or "762", "ur_ak_cal_", "")
    local stock = string.Replace(atts[10].Installed or "default", "ur_ak_stock_", "")
    local upper = atts[11].Installed
    local alpha = (upper == "ur_ak_cover_alpha" or upper == "ur_ak_cover_ak12" or upper == "ur_ak_cover_truniun_rail")
    -- local ak12 = alpha and barr == "ak12"

    wep.Trivia_Desc = descStart .. desc_762
    wep.Trivia_Mechanism = "Gas-Operated Rotating Bolt"

    if alpha then noN = true end

    if atts[14].Installed == "uc_fg_civvy" then
        start = (fakeNames and "Amur") or "Vepr"
        if cal == "12g" then
            post = "-12"
            wep.Trivia_Desc = desc_12g
        elseif cal == "545_ak12" or cal == "545" then
            post = " 5.45"
            wep.Trivia_Desc = descStart .. desc_545
        elseif cal == "762" then
            post = " 7.62"
        elseif cal == "9mm" then
            start = "Saiga"
            post = "-9"
            wep.Trivia_Desc = desc_9mm
            wep.Trivia_Mechanism = "Blowback"
        else
            post = " ." .. cal
        end
        return start .. post
    end

    if cal == "9mm" then
        if fakeNames then
            start = "Bogatyr"
            post = " SMG"
        else
            start = "PP"
            post = "-19 Vityaz"
        end
        wep.Trivia_Desc = desc_9mm
        wep.Trivia_Mechanism = "Blowback"
    -- elseif cal == "12g" then
    --     start = "Saiga"
    --     if shortBarrs[barr] then
    --         post = "-12K"
    --     else
    --         post = "-12"
    --     end
    --     wep.Trivia_Desc = desc_12g -- Obsolete
    elseif cal == "366" then
        if barr == "vepr" or string.find(atts[14].Installed or "","rifling") then
            start = (fakeNames and "Amur") or "Vepr"
            post = " .366"
        else
            start = (fakeNames and "KFN") or "VPO"
            post = "-209"
            wep.Trivia_Desc = desc_366
        end
    elseif cal == "308" then
        post = "-308"
    -- elseif cal == "545_ak12" or ak12 then
    --     noN = true
    --     if string.StartWith(cal,"545") then
    --         post = "-12"
    --         wep.Trivia_Desc = descStart .. desc_545
    --     elseif cal == "762" then
    --         post = "-15"
    --     elseif cal == "556" then
    --         post = "-18"
    --     end
    --     if string.EndsWith(barr,"105") or shortBarrs[barr] then
    --         post = post .. "K"
    --     end -- Obsolete
    elseif barr == "rpk" or barr == "rpk74m" then
        start = (fakeNames and "PKF") or "RPK"
        if !fakeNames and barr == "rpk" and cal == "762" then
            post = ""
        end
    elseif cal == "762" then
        if barr == "t56" then
            noN = true
            if fakeNames then
                start = "Yucha"
                post = " 7"
            else
                start = "Type "
                post = "56"
            end
        elseif (hg == "74m" or hg == "rpk74m" or hg == "ak12") and stock == "ak74m" then
            noN = true
            post = "-103"
        end
    elseif cal == "556" then
        if fakeNames then
            post = "-45"
        elseif string.EndsWith(barr,"105") then
            post = "-102"
        else
            post = "-101"
        end
        wep.Trivia_Desc = descStart .. desc_556
    end

    if foldStocks[stock] and akCals[cal] and !string.StartWith(barr,"105") then
        if cal == "762" then
            if barr == "t56" then
                post = post .. "-1"
            elseif !fakeNames then
                post = "MS"
            else
                mid = "S"
            end
        else
            mid = "S"
        end
    end

    if cal == "545" then
        wep.Trivia_Desc = descStart .. desc_545
        if (hg == "74m" or hg == "rpk74m" or hg == "ak12") and stock == "ak74m" then
            noN = true
            post = (fakeNames and "-76M") or "-74M"
        elseif shortBarrs[barr] then
            if fakeNames then
                post = "-76"
                mid = mid .. "U"
            else
                post = "-74U"
            end
            wep.Trivia_Desc = descStart .. desc_74u
        else
            post = (fakeNames and "-76") or "-74"
        end
    end

    if akCals[cal] then
        if string.EndsWith(barr,"105") then
            noN = true
            if cal == "545" then
                post = "-105"
            elseif cal == "762" then
                post = "-104"
            elseif cal == "556" then
                post = "-102"
            end
        else
            -- if shortBarrs[barr] then
            --     post = post .. "U" -- I know I said the AK-47U doesn't exist, but we have fucking Glock 44 Autos so I warmed up to it
            --     wep.Trivia_Desc = descStart .. desc_74u
            -- end
            if !noN and atts[1].Installed then
                post = post .. "N"
            end
        end

    end

    return start .. mid .. post
end

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["draw"] = {
        Source = "draw",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "raise.ogg", t = 0.2},
            {s = common .. "shoulder.ogg",    t = 0.2},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        SoundTable = {
            {s = ratel, t = 0},
           -- {s = common .. "raise.ogg", t = 0.2},
            -- {s = common .. "shoulder.ogg",    t = 0.2},
        },
    },
    ["ready"] = {
        Source = "ready",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.6,
        LHIKEaseOut = 0.25,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "chback.ogg",    t = 0.2},
            {s = path .. "chamber.ogg",    t = 0.3},
            {s = common .. "shoulder.ogg",    t = .6},
        },
    },
    ["fire"] = {
        Source = {"fire"},
        Time = 0.5,
        ShellEjectAt = 0,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    ["fire_iron"] = {
        Source = {"fire"},
        Time = 0.5,
        ShellEjectAt = 0,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.65,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = common .. "magpouch.ogg", t = 0.0, v = 0.45},
            {s = path .. "reload_start.ogg", 	 t = 0.025},
            {s = rottle,  t = 0.05},
            {s = ratel, t = 0.25},
            {s = path .. "magrelease.ogg", 	 t = 0.4},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.35},
            {s = common .. "magpouchin.ogg", t = 1.38},
            {s = path .. "grab.ogg", t = 1.9, v = 0.45},
            {s = common .. "shoulder.ogg", t = 2.0},
            {s = path .. "shoulder.ogg", t = 2.15},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magrelease.ogg", 	 t = 0.4},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = path .. "bonk.ogg", 	 t = 0.5},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin.ogg",    t = 0.97},
            {s = ratel, t = 1.1},
            {s = common .. "rifle_magdrop.ogg", t = 1.15, v = 0.5},
            {s = rottle,  t = 1.16},
            {s = path .. "chback.ogg",    t = 1.9},
            {s = path .. "chamber.ogg",    t = 2.0},
            {s = path .. "grab.ogg", t = 2.3, v = 0.45},
            {s = common .. "shoulder.ogg", t = 2.4},
            {s = path .. "shoulder.ogg", t = 2.5},
        },
    },
    ["reload_75"] = {
        Source = "reload_drum",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.9,
        LHIKEaseOut = 0.25,
        MinProgress = 1.6,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magrelease.ogg", 	 t = 0.1},
            {s = path .. "magout_drum.ogg", 	 t = 0.25},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = ratel, t = 1.0},
            {s = path .. "magin_drum.ogg",    t = 1.1},
            {s = rottle,  t = 1.75},
            {s = path .. "grab.ogg", t = 2.0, v = 0.45},
            {s = common .. "shoulder.ogg", t = 2.1},
            {s = path .. "shoulder.ogg", t = 2.25},
        },
    },
    ["reload_empty_75"] = {
        Source = "reload_drum_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 1.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.6,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magrelease.ogg", 	 t = 0.1},
            {s = path .. "magout_drum.ogg", 	 t = 0.25},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = ratel, t = 1.0},
            {s = path .. "magin_drum.ogg",    t = 1.1},
            {s = path .. "grab.ogg", t = 2.0, v = 0.45},
            {s = rottle,  t = 1.9},
            {s = path .. "chback.ogg",    t = 2.37},
            {s = path .. "chamber.ogg",    t = 2.48},
            {s = common .. "shoulder.ogg", t = 2.78},
            {s = path .. "shoulder.ogg", t = 2.93},
        },
    },
    ["reload_9mm"] = {
        Source = "reload_9mm",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.9,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path1 .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path1 .. "magin.ogg",    t = 0.73},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.4},
            {s = common .. "magpouchin.ogg", t = 1.35},
            {s = common .. "shoulder.ogg", t = 2.05},
            {s = common .. "grab.ogg", t = 2.1},
        },
    },
    ["reload_empty_9mm"] = {
        Source = "reload_9mm_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path1 .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path1 .. "magin.ogg",    t = 0.85},
            {s = ratel, t = 1.1},
            {s = common .. "pistol_magdrop.ogg", t = 1.15},
            {s = rottle,  t = 1.15},
            {s = path .. "chback_9.ogg",    t = 1.8},
            {s = path .. "chamber_9.ogg",    t = 2.05},
            {s = common .. "grab.ogg", t = 2.4},
            {s = common .. "shoulder.ogg", t = 2.5},
        },
    },
    ["reload_10rnd"] = {
        Source = "reload_10rnd",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.9,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.35},
            {s = common .. "magpouchin.ogg", t = 1.35},
            {s = common .. "shoulder.ogg", t = 2.05},
            {s = common .. "grab.ogg", t = 2.1},
        },
    },
    ["reload_empty_10rnd"] = {
        Source = "reload_10rnd_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = path .. "bonk.ogg", 	 t = 0.5},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin.ogg",    t = 0.97},
            {s = ratel, t = 1.1},
            {s = common .. "rifle_magdrop.ogg", t = 1.15},
            {s = rottle,  t = 1.15},
            {s = path .. "chback.ogg",    t = 1.9},
            {s = path .. "chamber.ogg",    t = 2.0},
            {s = common .. "grab.ogg", t = 2.4},
            {s = common .. "shoulder.ogg", t = 2.5},
        },
    },
    ["reload_308"] = {
        Source = "reload_308",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.9,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin_308.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.35},
            {s = common .. "magpouchin.ogg", t = 1.35},
            {s = common .. "shoulder.ogg", t = 2.05},
            {s = common .. "grab.ogg", t = 2.1},
        },
    },
    ["reload_empty_308"] = {
        Source = "reload_308_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = path .. "bonk.ogg", 	 t = 0.5},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin_308.ogg",    t = 1.0},
            {s = ratel, t = 1.1},
            {s = common .. "rifle_magdrop.ogg", t = 1.15},
            {s = rottle,  t = 1.15},
            {s = path .. "chback_308.ogg",    t = 1.85},
            {s = path .. "chamber_308.ogg",    t = 2.0},
            {s = common .. "grab.ogg", t = 2.4},
            {s = common .. "shoulder.ogg", t = 2.5},
        },
    },
    ["reload_12g"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.65,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "12ga/magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "12ga/magin.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.35},
            {s = common .. "magpouchin.ogg", t = 1.35},
            {s = common .. "shoulder.ogg", t = 2.05},
            {s = common .. "grab.ogg", t = 2.1},
        },
    },
    ["reload_empty_12g"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "12ga/magout.ogg", 	 t = 0.45},
            {s = path .. "bonk.ogg", 	 t = 0.5, v = 0.25},
            {s = ratel, t = 0.55},
            {s = rottle,  t = 0.75},
            {s = path .. "12ga/magin.ogg",    t = 0.97},
            {s = ratel, t = 1.1},
            {s = common .. "rifle_magdrop.ogg", t = 1.15},
            {s = rottle,  t = 1.75},
            {s = path .. "12ga/chback.ogg",    t = 1.85},
            {s = path .. "12ga/chamber.ogg",    t = 2.0},
            {s = common .. "grab.ogg", t = 2.4},
            {s = common .. "shoulder.ogg", t = 2.5},
        },
    },
    ["enter_inspect"] = {
        Source = "inspect_enter",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect"] = {
        Source = "inspect_loop",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
    },
    ["exit_inspect"] = {
        Source = "inspect_exit",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
        SoundTable = {
            {s = common .. "movement-rifle-04.ogg", t = 0.2},
            {s = rottle, t = 0.25},
            {s = rottle, t = 1.2},
            {s = common .. "movement-rifle-03.ogg", t = 1.25},
        },
    },
    ["enter_sprint"] = {
        Source = "sprint_start",
        Time = 0.9,
    },
    ["idle_sprint"] = {
        Source = "sprint_idle",
    },
    ["exit_sprint"] = {
        Source = "sprint_end",
        Time = 1.25,
    },
    ["unjam"] = {
        Source = "jamfix",
        -- Time = 45 / 30,
        ShellEjectAt = 0.65,
        -- LHIK = true,
        -- LHIKIn = 0.3,
        -- LHIKEaseIn = 0.4,
        -- LHIKEaseOut = 0.15,
        -- LHIKOut = 0.4,
        -- SoundTable = {                                             zenith do noises here
        --     {s = path .. "chback.ogg",   t = 0.15},
        --     {s = common .. "cloth_4.ogg",  t = 0.5},
        --     {s = path .. "chamber.ogg",  t = 0.5},
        -- },
        SoundTable = {
            {s = common .. "cloth_4.ogg",  t = 0.1},
            {s = path .. "presscheck_1.ogg",    t = 0.2},
            {s = path .. "chback.ogg",    t = 0.6},
            {s = path .. "chamber.ogg",    t = 0.7},
            {s = common .. "grab.ogg", t = 1.1},
            {s = common .. "shoulder.ogg", t = 1.15},
        }
    },
    ["bash_bayonet"] = {
        Source = "bayonet",
        --Time = 1.2,
        --MinProgress = .7,
        SoundTable = {
            {s = "weapons/arccw/melee_lift.wav", t = 0}
        }
    },

    ["exit_bipod"] = {
        Source = "bipod_undeploy",
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        --Time = 1.2,
        --MinProgress = .7,
        Mult = .8,
        SoundTable = {
            -- {s = "weapons/arccw/melee_lift.wav", t = 0}
        }
    },
    ["enter_bipod"] = {
        Source = "bipod_deploy",
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        --Time = 1.2,
        --MinProgress = .7,
        Mult = .8,
        SoundTable = {
            -- {s = "weapons/arccw/melee_lift.wav", t = 0}                   -- yeah here too
        }
    },
}

SWEP.Hook_Think = ArcCW.UC.ADSReload
--lua/weapons/arccw_ur_rpk.lua:
return gluapack()()
--lua/weapons/arccw_ur_spas12hl.lua:
if !file.Exists("arccw/shared/sh_1_ur.lua","LUA") then return end

include("weapons/arccw_ur_spas12.lua")

SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets Shotguns"
end

SWEP.PrintName = "Semi-Automatic Assault Shotgun"
SWEP.TrueName = "SPAS-12 Freeman"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

SWEP.Attachments[2].Installed = "ur_spas12_barrel_hl"
SWEP.Attachments[5].Installed = "ur_spas12_stock_none"
--SWEP.Attachments[7].Installed = "ur_spas12_tube_reduced"

SWEP.Hook_NameChange = function()
    return (GetConVar("arccw_truenames"):GetBool() and "SPAS-12") or "Martello 12/70"
end
--lua/weapons/arccw_ur_t56.lua:
return gluapack()()
--lua/weapons/arccw_ur_vpo209.lua:
return gluapack()()
--lua/weapons/arccw_ur_ak.lua:
return gluapack()()
--addons/cityworker/lua/weapons/cityworker_shovel.lua:
return gluapack()()
--addons/cityworker/lua/weapons/cityworker_wrench.lua:
return gluapack()()
--addons/cityworker/lua/weapons/cityworker_wrench.lua:
SWEP.PrintName              = "İngiliz anahtarı"
SWEP.Author                 = "Silhouhat"
SWEP.Purpose                = "City Worker"
SWEP.Instructions           = "LMB to tighten leak"

SWEP.Category               = "City Worker"
SWEP.Spawnable              = false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		    = "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo		    = "none"

SWEP.Weight			        = 5
SWEP.AutoSwitchTo		    = false
SWEP.AutoSwitchFrom		    = false

SWEP.Slot			        = 3
SWEP.SlotPos			    = 1
SWEP.DrawAmmo			    = false
SWEP.DrawCrosshair		    = true

SWEP.ViewModel			    = "models/props_c17/tools_wrench01a.mdl"
SWEP.WorldModel			    = "models/props_c17/tools_wrench01a.mdl"

function SWEP:Initialize()
    self:SetHoldType( "melee" )
end

function SWEP:PrimaryAttack()
    if CLIENT then return end
    if not IsFirstTimePredicted() then return end

    self:SetNextPrimaryFire( CurTime() + 1 )

    local ent = self.Owner:GetEyeTrace().Entity
    if not IsValid( ent ) then return end
    if ent:GetClass() == "cityworker_leak" or ( ent:GetClass() == "cityworker_hydrant" and ent:GetLeaking() ) then 
        if ent:GetPos():Distance( self.Owner:GetPos() ) > 200 then return end

        CITYWORKER.Begin( self.Owner, ent ) 
    end
end

function SWEP:SecondaryAttack()
    return
end

function SWEP:Reload()
    return
end

function SWEP:DrawWorldModel()
    /*

    if not IsValid( self.Owner ) then return end

    local pos, ang = self.Owner:GetBonePosition( self.Owner:LookupBone( "ValveBiped.Bip01_R_Hand" ) )
    local offsetPos = ang:Right() * 1 + ang:Forward() * 3 + ang:Up() * -2

    ang:RotateAroundAxis( ang:Right(), 0 )
    ang:RotateAroundAxis( ang:Forward(), 90 )
    ang:RotateAroundAxis( ang:Up(), 180 )

    self:SetRenderOrigin( pos + offsetPos )
    self:SetRenderAngles( ang )

    self:DrawModel()
    */
end

function SWEP:GetViewModelPosition( pos, ang )
    pos = pos + ang:Right() * 9 + ang:Forward() * 18 + ang:Up() * -9

    ang:RotateAroundAxis( ang:Right(), 90 )
    ang:RotateAroundAxis( ang:Up(), -90 )

    return pos, ang
end
--addons/bricksenchancedsweps/lua/weapons/dsr_taser.lua:
return gluapack()()
--addons/gmodadminsuite-logging-2.4.8/lua/weapons/gas_log_scanner/shared.lua:
local function L(phrase, discriminator)
	return GAS:Phrase(phrase, "logging", discriminator)
end

local COLOR_RED = Color(255, 0, 0)
local SCANNER_HUD

SWEP.PrintName    = "bLogs Scanner"
SWEP.Category     = "GmodAdminSuite"
SWEP.Author       = "GmodAdminSuite"
SWEP.Purpose      = "This scanner allows you to view logs related to entities in the world"
SWEP.Instructions = "Look at an entity"
SWEP.Contact      = "www.gmodadminsuite.com"

SWEP.Slot           = 5
SWEP.SlotPos        = 2
SWEP.DrawAmmo       = false
SWEP.DrawCrosshair  = true
SWEP.Weight         = 5
SWEP.AutoSwitchTo   = false
SWEP.AutoSwitchFrom = false

SWEP.ViewModel  = "models/weapons/v_emptool.mdl"
SWEP.WorldModel = "models/weapons/w_pistol.mdl"
SWEP.Spawnable  = true
SWEP.AdminOnly  = true

SWEP.ShowViewModel  = true
SWEP.ShowWorldModel = false

SWEP.Primary.ClipSize    = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = false
SWEP.Primary.Ammo        = "none"

SWEP.Secondary.ClipSize    = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic   = false
SWEP.Secondary.Ammo        = "none"

SWEP.HolsterSound       = Sound("npc/turret_floor/retract.wav")
SWEP.DeploySound        = Sound("npc/turret_floor/deploy.wav")
SWEP.ErrorSound         = Sound("npc/roller/code2.wav")
SWEP.ViewLogsSound      = Sound("AlyxEMP.Discharge")
SWEP.ShowInterfaceSound = Sound("gmodadminsuite/btn_light.ogg")
SWEP.HideInterfaceSound = Sound("gmodadminsuite/btn_heavy.ogg")

SWEP.WElements = {
	["scanner"] = {
		type = "Model",
		model = "models/weapons/w_emptool.mdl",
		bone = "ValveBiped.Anim_Attachment_LH",
		rel = "",
		pos = Vector(0.518, -3.636, 6.752),
		angle = Angle(38.57, -180, 12.857),
		size = Vector(1, 1, 1),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

if (CLIENT) then
	function SWEP:Initialize()
		self:CreateModels(self.WElements)
	end
end

function SWEP:PrimaryAttack()
	self:SendWeaponAnim(ACT_VM_FIDGET)

	if (CLIENT) then
		if (IsValid(self.HUD) and self.HUD:IsVisible()) then
			self.LastInspectedEnt = self.HUD.InspectingEnt
			self.LastInspectedEntHUD = self.HUD

			self.HUD:ShowCloseButton(true)
			self.HUD:ShowFullscreenButton(true)
			self.HUD:ShowPinButton(true)
			self.HUD:MakePopup()

			GAS:PlaySound("popup")
			self.HUD = nil
			self:CreateInterface()

			local tr = self.Owner:GetEyeTrace()
			local effectdata = EffectData()
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			effectdata:SetMagnitude(8)
			effectdata:SetScale(1)
			effectdata:SetRadius(16)
			util.Effect("cball_bounce", effectdata)

			self:EmitSound(self.ViewLogsSound)
		else
			self:EmitSound(self.ErrorSound)
		end
	end

	return true
end

function SWEP:SecondaryAttack()
	return false
end

if (SERVER) then
	util.AddNetworkString("gmodadminsuite:gas_log_scanner:Init")
	function SWEP:Deploy()
		if (not IsFirstTimePredicted()) then return end
		self:SetHoldType("duel")
		self:EmitSound(self.DeploySound)
		self:SendWeaponAnim(ACT_VM_DRAW)
		
		GAS:netStart("gas_log_scanner:Init")
		net.Send(self.Owner)
	end
else
	function SWEP:NetworkedDeploy()
		hook.Add("PreDrawHalos", "gas_log_scanner:Halo", function()
			if (not IsValid(self)) then
				timer.Remove("gas_log_scanner:UncacheData")
				timer.Remove("gas_log_scanner:LoadLogs")
				hook.Remove("PreDrawHalos", "gas_log_scanner:Halo")
				if (IsValid(SCANNER_HUD)) then
					SCANNER_HUD:Close()
				end
			else
				self:DrawHalo()
			end
		end)
		self:CreateInterface()
	end
	net.Receive("gmodadminsuite:gas_log_scanner:Init", function()
		timer.Create("gas_log_scanner:Init", 0, 0, function()
			if (IsValid(LocalPlayer():GetActiveWeapon()) and LocalPlayer():GetActiveWeapon():GetClass() == "gas_log_scanner" and LocalPlayer():GetActiveWeapon().NetworkedDeploy ~= nil) then
				LocalPlayer():GetActiveWeapon():NetworkedDeploy()
				timer.Remove("gas_log_scanner:Init")
			end
		end)
	end)
end

function SWEP:Holster()
	if (not IsFirstTimePredicted()) then
		return
	end
	self:EmitSound(self.HolsterSound)
	if (CLIENT) then
		timer.Remove("gas_log_scanner:UncacheData")
		timer.Remove("gas_log_scanner:LoadLogs")
		hook.Remove("PreDrawHalos", "gas_log_scanner:Halo")
		if (IsValid(self.HUD)) then
			self.HUD:Close()
		end
	end
	return true
end

if (SERVER) then
	function SWEP:Think()
		if (not IsValid(self.Owner)) then return end
		local tr = self.Owner:GetEyeTrace()
		if (IsValid(tr.Entity) and not tr.Entity:IsWorld()) then
			self:SetHoldType("magic")
		else
			self:SetHoldType("duel")
		end
	end
end

if (CLIENT) then
	hook.Add("PlayerSwitchWeapon", "gas_log_scanner:RemoveMenuOnSwitch", function(ply, oldWeapon, newWeapon)
		if (ply ~= LocalPlayer()) then return end
		if (IsValid(oldWeapon) and oldWeapon:GetClass() == "gas_log_scanner") then
			if (IsValid(newWeapon) and newWeapon:GetClass() == "gas_log_scanner") then
				return
			else
				timer.Remove("gas_log_scanner:UncacheData")
				timer.Remove("gas_log_scanner:LoadLogs")
				hook.Remove("PreDrawHalos", "gas_log_scanner:Halo")
				if (IsValid(oldWeapon.HUD)) then
					oldWeapon.HUD:Close()
				end
			end
		end
	end)

	function SWEP:CreateInterface()
		timer.Remove("gas_log_scanner:LoadLogs")
		if (IsValid(self.HUD)) then
			self.HUD:Close()
		end
		if (IsValid(SCANNER_HUD)) then
			SCANNER_HUD:Close()
		end

		self.HUD = vgui.Create("bVGUI.Frame")
		local HUD = self.HUD
		SCANNER_HUD = HUD

		HUD.FirstLoad = true
		HUD:SetTitle("bLogs Scanner")
		HUD:SetSize(425,400)
		HUD:SetPos(1050,300)
		HUD:ShowCloseButton(false)
		HUD:ShowFullscreenButton(false)
		HUD:ShowPinButton(false)
		HUD:SetVisible(false)

		HUD.Pagination = vgui.Create("bVGUI.Pagination", HUD)
		HUD.Pagination:SetTall(30)
		HUD.Pagination:Dock(TOP)
		HUD.Pagination:SetPages(1)
		function HUD.Pagination:OnPageSelected(page)
			HUD.Logs:Clear()
			HUD.Logs:SetLoading(true)
			local function LoadLogs()
				if (not IsValid(HUD) or not IsValid(self)) then return end
				HUD.FirstLoad = nil
				if (not IsValid(HUD.InspectingEnt)) then
					HUD.Logs:SetLoading(false)
				else
					local function LoadScannerLogs()
						GAS:StartNetworkTransaction("logging:LoadScannerLogs", function()
							net.WriteUInt(page, 16)
							net.WriteEntity(HUD.InspectingEnt)
						end, function(data_present, l)
							if (not IsValid(HUD)) then return end
							HUD.Logs:SetLoading(false)
							if (data_present) then
								local ent = net.ReadEntity()
								local pages = net.ReadUInt(16)
								local logs = GAS:DeserializeTable(util.Decompress(net.ReadData(l - 16 - 16)))

								HUD.Pagination:SetPages(pages)
								for _,log in ipairs(logs) do
									local module_data = GAS.Logging.IndexedModules[log[2]]
									local formatted_log = GAS.Logging:FormatMarkupLog(log, GAS.Logging.Config.ColoredLogs or true)
									local log_row = HUD.Logs:AddRow("<color=" .. GAS:Unvectorize(module_data.Colour or bVGUI.COLOR_WHITE) .. ">" .. GAS:EscapeMarkup(module_data.Name) .. "</color>", GAS:SimplifyTimestamp(log[3]), formatted_log)
									log_row.Data = log
									log_row.IsColored = GAS.Logging.Config.ColoredLogs or true
								end
							end
						end)
					end
					if (GAS.Logging.IndexedModules == nil) then
						GAS:StartNetworkTransaction("logging:GetModules", nil, function()
							net.ReadBool()
							local data_len = net.ReadUInt(16)

							GAS.Logging.Modules = {}
							GAS.Logging.IndexedModules = GAS:DeserializeTable(util.Decompress(net.ReadData(data_len)))
							for module_id, module_data in pairs(GAS.Logging.IndexedModules) do
								if (module_data.Offline) then continue end
								GAS.Logging.Modules[module_data.Category] = GAS.Logging.Modules[module_data.Category] or {}
								GAS.Logging.Modules[module_data.Category][module_data.Name] = module_data
							end

							LoadScannerLogs()
						end)
					else
						LoadScannerLogs()
					end
				end
			end
			if (HUD.FirstLoad) then
				timer.Create("gas_log_scanner:LoadLogs", .5, 1, LoadLogs)
			else
				LoadLogs()
			end
		end

		HUD.Logs = vgui.Create("bVGUI.Table", HUD)
		HUD.Logs:Dock(FILL)
		HUD.Logs:AddColumn(L"module", bVGUI.TABLE_COLUMN_SHRINK, TEXT_ALIGN_CENTER)
		HUD.Logs:AddColumn(L"when", bVGUI.TABLE_COLUMN_SHRINK, TEXT_ALIGN_CENTER)
		HUD.Logs:AddColumn(L"log", bVGUI.TABLE_COLUMN_GROW)
		HUD.Logs:SetRowCursor("hand")
		HUD.Logs:SetLoading(true)

		function HUD.Logs:OnRowRightClicked(row)
			self:OnRowClicked(row)
		end
		function HUD.Logs:OnRowClicked(row)
			GAS.Logging:OpenLogsContextMenu(row)
		end
	end

	SWEP.HaloTable = {}
	function SWEP:DrawHalo()
		if (not IsValid(self) or not IsValid(self.Owner) or self.Owner:GetActiveWeapon() ~= self) then
			return hook.Remove("PreDrawHalos", "gas_log_scanner:Halo")
		end
		local tr = self.Owner:GetEyeTrace()
		if (IsValid(tr.Entity) and not tr.Entity:IsWorld()) then
			if (tr.Entity == self.LastInspectedEnt and IsValid(self.LastInspectedEntHUD)) then
				self.HaloTable[1] = nil
				return
			end
			if (self.HaloTable[1] == nil) then
				self:EmitSound(self.ShowInterfaceSound)
			end
			self.HaloTable[1] = tr.Entity

			halo.Add(self.HaloTable, COLOR_RED, 2, 2, 5, true, true)

			if (IsValid(self.HUD)) then
				self.HUD:SetVisible(true)
				self.HUD:SetTitle(tr.Entity:GetClass() .. " (" .. tr.Entity:EntIndex() .. ")")
				self.HUD.InspectingEnt = tr.Entity
				if (self.HUD.LastInspectedEnt ~= tr.Entity) then
					self.HUD.LastInspectedEnt = tr.Entity
					self.HUD.FirstLoad = true
					self.HUD.Pagination:SetPages(1)
					self.HUD.Pagination:SetPage(1)
					self.HUD.Pagination:OnPageSelected(1)
				end
				if (self.HUD.UncacheData) then
					self.HUD.UncacheData = nil
					self.HUD.Pagination:SetPage(1)
					self.HUD.Pagination:OnPageSelected(1)
				end
			end

			timer.Remove("gas_log_scanner:UncacheData")
		else
			self.LastInspectedEntHUD = nil
			self.LastInspectedEnt = nil

			if (self.HaloTable[1] ~= nil) then
				self:EmitSound(self.HideInterfaceSound)
			end
			self.HaloTable[1] = nil

			if (IsValid(self.HUD)) then
				self.HUD:SetVisible(false)
				self.HUD.InspectingEnt = nil
				if (not timer.Exists("gas_log_scanner:UncacheData") and not self.HUD.UncacheData) then
					timer.Create("gas_log_scanner:UncacheData", 3, 1, function()
						self.HUD.UncacheData = true
					end)
				end
			end
		end
	end

	-- Credit for this goes to the SWEP Construction Kit
	-- https://github.com/Clavus/SWEP_Construction_Kit

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		if (self.GetBoneOrientation == nil) then return end
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end

		if (not self.wRenderOrder) then
			self.wRenderOrder = {}
			for k, v in pairs(self.WElements) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end
		end

		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			bone_ent = self
		end

		for k, name in pairs(self.wRenderOrder) do
			local v = self.WElements[name]
			if (not v) then
				self.wRenderOrder = nil
				break
			end
			if (v.hide) then continue end

			local pos, ang

			if (v.bone) then
				pos, ang = self:GetBoneOrientation(self.WElements, v, bone_ent)
			else
				pos, ang = self:GetBoneOrientation(self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand")
			end

			if (not pos) then continue end

			local model = v.modelEnt

			model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z)
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
			model:SetAngles(ang)
			local matrix = Matrix()
			matrix:Scale(v.size)
			model:EnableMatrix("RenderMultiply", matrix)

			if (v.material == "") then
				model:SetMaterial("")
			elseif (model:GetMaterial() ~= v.material) then
				model:SetMaterial(v.material)
			end

			if (v.skin and v.skin ~= model:GetSkin()) then
				model:SetSkin(v.skin)
			end

			if (v.bodygroup) then
				for k, v in pairs(v.bodygroup) do
					if (model:GetBodygroup(k) ~= v) then
						model:SetBodygroup(k, v)
					end
				end
			end

			if (v.surpresslightning) then
				render.SuppressEngineLighting(true)
			end

			render.SetColorModulation(v.color.r / 255, v.color.g / 255, v.color.b / 255)
			render.SetBlend(v.color.a / 255)
			model:DrawModel()
			render.SetBlend(1)
			render.SetColorModulation(1, 1, 1)

			if (v.surpresslightning) then
				render.SuppressEngineLighting(false)
			end
		end
	end

	function SWEP:CreateModels(tab)
		for k, v in pairs(tab) do
			if
				(v.type == "Model" and v.model and v.model ~= "" and (not IsValid(v.modelEnt) or v.createdModel ~= v.model) and
					string.find(v.model, ".mdl") and
					file.Exists(v.model, "GAME"))
			 then
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
			elseif
				(v.type == "Sprite" and v.sprite and v.sprite ~= "" and (not v.spriteMaterial or v.createdSprite ~= v.sprite) and
					file.Exists("materials/" .. v.sprite .. ".vmt", "GAME"))
			 then
				local name = v.sprite .. "-"
				local params = {["$basetexture"] = v.sprite}
				local tocheck = {"nocull", "additive", "vertexalpha", "vertexcolor", "ignorez"}
				for i, j in pairs(tocheck) do
					if (v[j]) then
						params["$" .. j] = 1
						name = name .. "1"
					else
						name = name .. "0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name, "UnlitGeneric", params)
			end
		end
	end
end

--addons/glorifiedhandcuffs/lua/weapons/glorifiedhandcuffs_nightstick.lua:

AddCSLuaFile()

SWEP.PrintName = "Nightstick"
SWEP.Category = "GlorifiedHandcuffs"
SWEP.Author = "GlorifiedPig"
SWEP.Instructions = "Left click to stun player."

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.Base = "weapon_base"

SWEP.Weight = 6
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.Slot = 1

SWEP.ViewModel = Model( "models/weapons/v_stunbaton.mdl" )
SWEP.WorldModel = Model( "models/weapons/w_stunbaton.mdl" )
SWEP.UseHands = true
SWEP.ViewModelFOV = 85

SWEP.DrawCrosshair = false

function SWEP:Initialize()
    self:SetHoldType( "Melee" )
end

function SWEP:PrimaryAttack()
    self:SetNextPrimaryFire( CurTime() + 0.45 )
    local traceResult = {
        start = self.Owner:GetShootPos(),
        endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * GlorifiedHandcuffs.Config.NIGHTSTICK_STUN_PUSH_DISTANCE,
        mins = Vector( -5, -5, -5 ),
        maxs = Vector( 5, 5, 5 ),
        filter = self.Owner
    }
    self:GetOwner():LagCompensation( true )
    traceResult = util.TraceHull( traceResult )
    self:GetOwner():LagCompensation( false )

    if traceResult.Hit then
        local trEntity = traceResult.Entity
        self:SendWeaponAnim( ACT_VM_HITCENTER )
        local soundToEmit = "physics/concrete/concrete_impact_hard" .. math.random( 1, 3 ) .. ".wav"

        if trEntity:IsPlayer() then
            soundToEmit = "physics/body/body_medium_impact_hard" .. math.random( 1, 4 ) .. ".wav"
            if not trEntity:IsFrozen() then
                trEntity:Freeze( true )
                timer.Simple( GlorifiedHandcuffs.Config.NIGHTSTICK_STUN_TIME, function()
                    if trEntity and trEntity:IsValid() and trEntity:IsPlayer() and not GlorifiedHandcuffs.IsPlayerHandcuffed( trEntity ) then
                        trEntity:Freeze( false )
                    end
                end )
            end
        end

        timer.Simple( 0.12, function()
            if not self or not trEntity or not trEntity:IsValid() then return end
            if trEntity:IsPlayer() then
                trEntity:SetVelocity( ( trEntity:GetPos() - self:GetOwner():GetPos() ) * 5 )
            end
            self:EmitSound( soundToEmit )
            hook.Run( "GlorifiedHandcuffs.BatonUsed", self:GetOwner(), trEntity )
        end )
    else
        self:EmitSound( "Weapon_Stunstick.Melee_Miss" )
        self:SendWeaponAnim( ACT_VM_MISSCENTER )
    end
    self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:SecondaryAttack() end
--addons/pcasino/lua/weapons/gmod_tool/stools/pcasino_creator.lua:
return gluapack()()
--lua/weapons/gmod_tool/stools/streamradio_gui_color_global.lua:
TOOL.Category = "Stream Radio"
TOOL.Name = "#Tool." .. TOOL.Mode .. ".name"

TOOL.Information = {
	{ name = "left" },
	{ name = "right" },
	{ name = "reload" },
}

TOOL.SkinColorsVars = {
	cursor = {
		hierarchies = {
			"",
		},

		colors = {
			color_cursor = {
				default = Color(255, 255, 255, 255),
				order = 1,
			},
		},

		order = 1,
	},

	main = {
		hierarchies = {
			"main",
		},

		colors = {
			color = {
				default = Color(0, 0, 64, 255),
				order = 1,
			},
		},

		order = 2,
	},

	border = {
		hierarchies = {
			"",
		},

		colors = {
			color_border = {
				default = Color(0, 64, 128, 255),
				order = 1,
			},
		},

		order = 3,
	},

	header = {
		hierarchies = {
			"main/browser/header",
			"main/player/header",
		},

		colors = {
			color = {
				default = Color(0, 100, 0, 255),
				order = 1,
			},

			color_foreground = {
				default = Color(255, 255, 255, 255),
				order = 2,
			},

			color_shadow = {
				default = Color(40, 40, 40, 255),
				order = 99,
			},
		},

		order = 4,
	},

	button = {
		hierarchies = {
			"main/browser/sidebutton",
			"main/browser/list/button",
			"main/browser/error/button",
			"main/browser/list/scrollbar/bar",
			"main/browser/list/scrollbar/button",
			"main/browser/error/textbox/scrollbar/bar",
			"main/browser/error/textbox/scrollbar/button",

			"main/player/button",
			"main/player/controls/button",
			"main/player/controls/progressbar",
			"main/player/spectrum/error/button",
			"main/player/spectrum/error/textbox/scrollbar/bar",
			"main/player/spectrum/error/textbox/scrollbar/button",
		},

		colors = {
			color = {
				default = Color(0, 128, 128, 255),
				order = 1,
			},

			color_foreground = {
				default = Color(255, 255, 255, 255),
				order = 2,
			},

			color_icon = {
				default = Color(255, 255, 255, 255),
				order = 3,
			},


			color_hover = {
				default = Color(150, 150, 150, 255),
				order = 4,
			},

			color_foreground_hover = {
				default = Color(0, 0, 0, 255),
				order = 5,
			},

			color_icon_hover = {
				default = Color(255, 255, 255, 255),
				order = 6,
			},


			color_disabled = {
				default = Color(100, 100, 100, 255),
				order = 7,
			},

			color_foreground_disabled = {
				default = Color(255, 255, 255, 255),
				order = 8,
			},

			color_icon_disabled = {
				default = Color(255, 255, 255, 255),
				order = 9,
			},


			color_shadow = {
				default = Color(40, 40, 40, 255),
				order = 99,
			},
		},

		order = 5,
	},

	error = {
		hierarchies = {
			"main/browser/error/textbox",
			"main/player/spectrum/error/textbox",
		},

		colors = {
			color = {
				default = Color(128, 32, 0, 255),
				order = 1,
			},

			color_foreground = {
				default = Color(255, 255, 255, 255),
				order = 2,
			},

			color_shadow = {
				default = Color(40, 40, 40, 255),
				order = 99,
			},
		},

		order = 6,
	},

	spectrum = {
		hierarchies = {
			"main/player/spectrum",
		},

		colors = {
			color = {
				default = Color(64, 32, 0, 255),
				order = 1,
			},

			color_foreground = {
				default = Color(192, 0, 0, 255),
				order = 2,
			},

			color_icon = {
				default = Color(255, 255, 255, 255),
				order = 3,
			},

			color_shadow = {
				default = Color(40, 40, 40, 255),
				order = 99,
			},
		},

		order = 7,
	},
}

TOOL.SkinVars = {}
local count = 0

for areaname, colvars in SortedPairsByMemberValue(TOOL.SkinColorsVars, "order") do
	local hierarchies = colvars.hierarchies or {}

	for colname, colvar in SortedPairsByMemberValue(colvars.colors or {}, "order") do
		local color = colvar.default or Color(255, 255, 255, 255)
		local varname = areaname .. "_" .. colname

		TOOL.ClientConVar[varname .. "_t"] = "1"
		TOOL.ClientConVar[varname .. "_r"] = color.r
		TOOL.ClientConVar[varname .. "_g"] = color.g
		TOOL.ClientConVar[varname .. "_b"] = color.b
		TOOL.ClientConVar[varname .. "_a"] = color.a

		local order = count + 1
		local skinvar = {}

		skinvar.default = color
		skinvar.hierarchies = hierarchies
		skinvar.areaname = areaname
		skinvar.name = colname
		skinvar.order = order

		TOOL.SkinVars[varname] = skinvar
		count = order
	end
end

if StreamRadioLib and StreamRadioLib.Loaded then
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "LeftClick")
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "RightClick")
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "Reload")
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "Holster")

	StreamRadioLib.Tool.AddLocale(TOOL, "name", "Radio Colorer (Global)")
	StreamRadioLib.Tool.AddLocale(TOOL, "desc", "Change colors of radio GUI skins")

	StreamRadioLib.Tool.AddLocale(TOOL, "left", "Apply colors of radio GUI skins")
	StreamRadioLib.Tool.AddLocale(TOOL, "right", "Copy the colors from radio GUI skins")
	StreamRadioLib.Tool.AddLocale(TOOL, "reload", "Reset the skin of the radio to default")

	StreamRadioLib.Tool.AddLocale(TOOL, "list", "List of changeable colors:")
	StreamRadioLib.Tool.AddLocale(TOOL, "color", "Selected color:")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.common.active.desc", "If checked the color will be applied on left click.\nUncheck this if you don't want to change this color on the GUI.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.main_color", "Background")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.main_color.desc", "Color of the main background.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.border_color_border", "Border")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.border_color_border.desc", "Color of the surrounding border.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.header_color", "Header Background")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.header_color_foreground", "Header Text")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.header_color_shadow", "Header Shadow")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.header_color.desc", "Color of the header background.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.header_color_foreground.desc", "Color of the header text.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.header_color_shadow.desc", "Color of the header shadow.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color", "Button Background")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_foreground", "Button Text")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_icon", "Button Icon")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color.desc", "Color of all button backgrounds.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_foreground.desc", "Color of all button texts.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_icon.desc", "Color of all button icons.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_hover", "Button Hover Background")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_foreground_hover", "Button Hover Text")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_icon_hover", "Button Hover Icon")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_hover.desc", "Color of all hovered button backgrounds.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_foreground_hover.desc", "Color of all hovered button texts.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_icon_hover.desc", "Color of all hovered button icons.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_disabled", "Button Disabled Background")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_foreground_disabled", "Button Disabled Text")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_icon_disabled", "Button Disabled Icon")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_disabled.desc", "Color of all disabled button backgrounds.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_foreground_disabled.desc", "Color of all disabled button texts.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_icon_disabled.desc", "Color of all disabled button icons.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_shadow", "Button Shadow")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_shadow.desc", "Color of all button Shadow.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.error_color", "Error Background")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.error_color_foreground", "Error Text")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.error_color_shadow", "Error Shadow")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.error_color.desc", "Color of the error box background.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.error_color_foreground.desc", "Color of the error box text.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.error_color_shadow.desc", "Color of the error box shadow.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.spectrum_color", "Spectrum Background")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.spectrum_color_foreground", "Spectrum Foreground")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.spectrum_color_icon", "Spectrum Icon")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.spectrum_color_shadow", "Spectrum Shadow")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.spectrum_color.desc", "Color of the spectrum box background.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.spectrum_color_foreground.desc", "Color of the spectrum box foreground.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.spectrum_color_icon.desc", "Color of the spectrum box icons.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.spectrum_color_shadow.desc", "Color of the spectrum box shadow.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.cursor_color_cursor", "Cursor")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.cursor_color_cursor.desc", "Color of the Cursor.")

	StreamRadioLib.Tool.Setup(TOOL)
else
	TOOL.Information = nil

	if CLIENT then
		local StreamRadioLib = StreamRadioLib or {}
		local _mode = TOOL.Mode

		language.Add("Tool." .. _mode .. ".name", "Radio Colorer (Global)")
		language.Add("Tool." .. _mode .. ".desc", "Change colors of radio GUI skins")
		language.Add("Tool." .. _mode .. ".0", "This tool could not be loaded.")

		function TOOL.BuildCPanel(CPanel)
			if StreamRadioLib.Loader_CreateErrorPanel then
				StreamRadioLib.Loader_CreateErrorPanel(CPanel, "This tool could not be loaded.")
			end
		end
	end
end

function TOOL:IsValid()
	return IsValid(self:GetSWEP())
end

function TOOL:GetColors(forceall)
	local data = {}

	for varname, v in pairs(self.SkinVars) do
		if not forceall then
			local ticked = self:GetClientBool(varname .. "_t")
			if not ticked then continue end
		end

		local r = self:GetClientNumber(varname .. "_r")
		local g = self:GetClientNumber(varname .. "_g")
		local b = self:GetClientNumber(varname .. "_b")
		local a = self:GetClientNumber(varname .. "_a")

		data[varname] = Color(r, g, b, a)
	end

	return data
end

function TOOL:SetColors(data)
	data = data or {}

	for varname, v in pairs(self.SkinVars) do
		local color = data[varname] or v.default or Color(255, 255, 255, 255)

		self:SetClientNumber(varname .. "_r", color.r)
		self:SetClientNumber(varname .. "_g", color.g)
		self:SetClientNumber(varname .. "_b", color.b)
		self:SetClientNumber(varname .. "_a", color.a)
	end
end

function TOOL:AddModeList( panel )
	local listpanel = vgui.Create( "DListView" )
	panel:AddPanel(listpanel)

	listpanel:SetMultiSelect(false)

	local col1 = listpanel:AddColumn("No.")
	listpanel:AddColumn("Item")
	local col3 = listpanel:AddColumn("Color")
	local col4 = listpanel:AddColumn("Active")

	col1:SetFixedWidth(30)
	col3:SetMinWidth(40)
	col3:SetMaxWidth(70)
	col4:SetFixedWidth(40)

	local lines = {}

	listpanel.NextConVarCheck = 0

	local update = function()
		if not IsValid(self) then return end
		if not IsValid(listpanel) then return end

		local data = self:GetColors(true)
		local changed = false

		if input.IsMouseDown(MOUSE_LEFT) then return end
		if listpanel.NextConVarCheck > RealTime() then return end

		listpanel.NextConVarCheck = RealTime() + 0.2

		for varname, line in pairs(lines) do
			if not self.SkinVars[varname] then continue end
			if not IsValid(line) then continue end

			local colortile = line.Columns[line._colorindex]
			if not IsValid(colortile) then continue end

			local activecheckbox = line.Columns[line._activeindex]
			if not IsValid(activecheckbox) then continue end

			local color = data[varname]
			if not color then continue end

			local oldcolor = colortile:GetColor()
			if color == oldcolor then continue end

			colortile:SetColor(color)
			line:SetSortValue(line._colorindex, tostring(color))
			changed = true
		end

		if changed and listpanel.OnColorUpdate then
			listpanel:OnColorUpdate(data)
		end
	end

	local data = self:GetColors(true)

	for varname, color in pairs(data) do
		local colortile = vgui.Create( "DColorButton" )
		local activecheckbox = vgui.Create( "DCheckBoxLabel" )
		if not self.SkinVars[varname] then continue end

		activecheckbox:SetText("")
		activecheckbox:SetConVar(self.Mode .. "_" .. varname  .. "_t")
		activecheckbox:SetIndent(12)
		activecheckbox:SetTooltip(StreamRadioLib.Tool.GetLocaleTranslation(self, "list.common.active.desc"))

		local order = self.SkinVars[varname].order or 0

		local line = listpanel:AddLine(order, StreamRadioLib.Tool.GetLocaleTranslation(self, "list." .. varname), colortile, activecheckbox)
		colortile.DoClick = function()
			listpanel:ClearSelection()
			listpanel:SelectItem(line)
		end

		line:SetTooltip(StreamRadioLib.Tool.GetLocaleTranslation(self, "list." .. varname .. ".desc"))
		line:SetSortValue(1, order)

		line._colorindex = 3
		line._activeindex = 4

		activecheckbox.OnChange = function(this, value)
			local sort = value and 1 or 0
			sort = sort * 1000 - order

			line:SetSortValue(line._activeindex, sort)
		end

		line._varname = varname
		lines[varname] = line
	end

	listpanel:SetTall(230)
	listpanel:SortByColumn(1)

	listpanel.Think = function()
		update()
	end

	update()

	return listpanel
end


function TOOL:BuildToolPanel( CPanel )
	self:AddLabel(CPanel, "list")

	local listpanel = self:AddModeList(CPanel)
	local colorpanel = nil
	local selectedline = nil

	listpanel.OnRowSelected = function(this, LineID, Line)
		selectedline = Line
		if not IsValid(selectedline) then return end
		if not IsValid(colorpanel) then return end
		if not selectedline._varname then return end

		local precmd = self.Mode .. "_" .. selectedline._varname

		colorpanel:SetConVarR(precmd .. "_r")
		colorpanel:SetConVarG(precmd .. "_g")
		colorpanel:SetConVarB(precmd .. "_b")
		colorpanel:SetConVarA(precmd .. "_a")
		colorpanel.txtA:SetConVar(precmd .. "_a")

		local colortile = selectedline.Columns[selectedline._colorindex]
		if not IsValid(colortile) then return end
		colorpanel:SetColor(colortile:GetColor())
	end

	listpanel.DoDoubleClick = function(this, LineID, Line)
		if not IsValid(Line) then return end
		if not IsValid(colorpanel) then return end

		local activecheckbox = selectedline.Columns[selectedline._activeindex]
		if not IsValid(activecheckbox) then return end
		activecheckbox:Toggle()
	end

	listpanel.OnColorUpdate = function(this, data)
		this:OnRowSelected(selectedline:GetID(), selectedline)
	end

	self:AddLabel(CPanel, "color")
	colorpanel = self:AddColorMixer(CPanel)

	listpanel:SelectFirstItem()
end

function TOOL:GetAimedGui(trace)
	if not self.ToolLibLoaded then return end

	trace = trace or self:GetFallbackTrace()

	if not trace then return end
	if not trace.Hit then return end

	local ent = trace.Entity

	if not self:IsValidGUIRadio(ent) then return end

	local entgui = ent:GetGUI()
	if not IsValid(entgui) then return end

	return entgui, ent
end

function TOOL:LeftClick(trace)
	if not self.ToolLibLoaded then return end

	local entgui = self:GetAimedGui(trace)
	if not IsValid(entgui) then return false end

	if CLIENT then return true end

	StreamRadioLib.Tool.CallClientToolHook(self, "LeftClick")
	return true
end

function TOOL:RightClick(trace)
	if not self.ToolLibLoaded then return end

	local entgui = self:GetAimedGui(trace)
	if not IsValid(entgui) then return false end

	if CLIENT then return true end

	StreamRadioLib.Tool.CallClientToolHook(self, "RightClick")
	return true
end

function TOOL:LeftClickClient()
	if not self.ToolLibLoaded then return end

	local entgui = self:GetAimedGui()
	if not IsValid(entgui) then return end

	local data = self:GetColors()

	for varname, color in pairs(data) do
		local skinvar = self.SkinVars[varname] or {}
		local hierarchies = skinvar.hierarchies or {}
		local hrvarname = skinvar.name

		for _, skinhierarchy in pairs(hierarchies) do
			entgui:SetSkinPropertyOnServer(skinhierarchy, hrvarname, color)
		end
	end
end

function TOOL:RightClickClient()
	if not self.ToolLibLoaded then return end

	local entgui = self:GetAimedGui()
	if not IsValid(entgui) then return end

	local skindata = {}

	for varname, skinvar in pairs(self.SkinVars) do
		local hierarchies = skinvar.hierarchies or {}
		local hrvarname = skinvar.name
		local value = nil

		for _, skinhierarchy in pairs(hierarchies) do
			local panels = entgui:GetPanelsBySkinIdentifyer(skinhierarchy)

			for _, panel in pairs(panels) do
				if not IsValid(panel) then continue end
				value = panel:GetSkinValue(hrvarname)

				if value then break end
			end

			if value then break end
		end

		skindata[varname] = value
	end

	self:SetColors(skindata)
end

function TOOL:Reload(trace)
	if not self.ToolLibLoaded then return end

	local entgui = self:GetAimedGui()
	if not IsValid(entgui) then return false end

	if CLIENT then return true end

	StreamRadioLib.Tool.CallClientToolHook(self, "Reload")
	return true
end

function TOOL:ReloadClient()
	if not self.ToolLibLoaded then return end

	local entgui = self:GetAimedGui()
	if not IsValid(entgui) then return end

	entgui:SetSkinOnServer(StreamRadioLib.Skin.GetDefaultSkin(), false)
end

function TOOL:Holster()
	if not self.ToolLibLoaded then return end

	self:Clear()
	StreamRadioLib.Tool.CallClientToolHook(self, "Holster")
end

function TOOL:HolsterClient()
	if not self.ToolLibLoaded then return end
	self:Clear()
end

function TOOL:Clear()

end

function TOOL:Think()
	if SERVER then return end
end

--lua/weapons/gmod_tool/stools/textscreen.lua:
return gluapack()()
--addons/zeros_trashman_v1.6.3/lua/sh_ztm_config.lua:
/*
    Addon id: 
    Version: v1.6.3 (stable)
*/

ztm = ztm or {}
ztm.config = ztm.config or {}

/////////////////////////////////////////////////////////////////////////////

// Bought by 
// Version v1.6.3


/////////////////////////// Zeros Trashman /////////////////////////////

// Developed by ZeroChain:
// http://steamcommunity.com/id/zerochain/
// https://www.gmodstore.com/users/view/76561198013322242
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

/////////////////////////////////////////////////////////////////////////////

///////////////////////// zclib Config //////////////////////////////////////
/*
	This config can be used to overwrite the main config of zeros libary
*/

// The Currency
zclib.config.Currency = "₺"

// Should the Currency symbol be in front or after the money value?
zclib.config.CurrencyInvert = true

// These Ranks are admins
// If xAdmin, sAdmin or SAM is installed then this table can be ignored
zclib.config.AdminRanks = {
	["superadmin"] = true
}

//zclib.config.CleanUp.SkipOnTeamChange[TEAM_STAFF] = true
/////////////////////////////////////////////////////////////////////////////

                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

// Switches between FastDl and Workshop
ztm.config.FastDl = false

// The language , en , de , cn , ru , fr , es , pl , dk , tr
ztm.config.SelectedLanguage = "tr"

// Unit of weight
ztm.config.UoW = "kg"

// This function will spawn the money
ztm.config.MoneySpawn = function(pos, money , ply)

	if DarkRP then
		// The default DarkRP way to spawn money
	    return DarkRP.createMoneyBag(pos, money)
	else
		// Give the player the money directly
		if IsValid(ply) then
			zclib.Money.Give(ply, money)
			zclib.Notify(ply, "+" .. zclib.Money.Display(money), 0)
			zclib.NetEvent.Create("zclib_sell", {ply:GetPos()})
		end
	end
end

/*
	Can be used to modify the players earned money according to his rank
	0.5 = Half the money
	1 = NoChange
	2 = Double the money
*/
ztm.config.MoneyxRank = {
	["default"] = 1,
	["vip"] = 2,
}

/*
	Because people asked, thats how you could allow players to pickup trashbags / recycledblocks via USE
*/
if SERVER then
	local AllowedClass = {
		[ "ztm_trashbag" ] = true,
		[ "ztm_recycled_block" ] = true,
		[ "ztm_trash" ] = true,
	}
	hook.Add("KeyPress", "ztm_custom_pickup", function(ply, key)
		if key == IN_USE then
			local tr = ply:GetEyeTrace()

			if tr and tr.Hit and IsValid(tr.Entity) and AllowedClass[ tr.Entity:GetClass() ] and not tr.Entity:IsPlayerHolding() then
				// Enable physics
				local phys = tr.Entity:GetPhysicsObject()
				if IsValid(phys) then
					phys:Wake()
					phys:EnableMotion(true)
				end

				// We need to delay the pickup action for one frame because reasons
				timer.Simple(0,function()
					if IsValid(ply) and IsValid(tr.Entity) then
						ply:PickupObject(tr.Entity)
					end
				end)
			end
		end
	end)
end

// Those jobs will be regonized as trashmans
ztm.config.Jobs = {}
// If the job gets not fully removed then atleast now it wont break the script anymore :I
if TEAM_ZTM_TRASHMAN then ztm.config.Jobs[TEAM_ZTM_TRASHMAN] = true end


// Here you can define what entities are considered trash
ztm.config.TrashClass = {
    ["money_printer"] = {
        // How much trash are we getting from this trashclass?
        Trash = function(ply,ent)
            return 10
        end,

        // Can we collect this trashclass?
        CanCollect = function(ply,ent)
            return true
        end,

        // What should happen when we collect this trashclass
        OnCollect = function(ply,ent)
            ztm.TrashCollector.XP(ply,5)
        end,
    },
    ["spawned_shipment"] = {
        Trash = function(ply,ent)
            return 25
        end,
        CanCollect = function(ply,ent)
            return true
        end,
        OnCollect = function(ply,ent)
            ztm.TrashCollector.XP(ply,5)
        end,
    },
    ["spawned_weapon"] = {
        Trash = function(ply,ent)
            return 5
        end,
        CanCollect = function(ply,ent)
            return true
        end,
        OnCollect = function(ply,ent)
        end,
    },
    ["spawned_money"] = {
        Trash = function(ply,ent)
            return 1
        end,
        CanCollect = function(ply,ent)
            return true
        end,
        OnCollect = function(ply,ent)
        end,
    },
    ["spawned_food"] = {
        Trash = function(ply,ent)
            return 5
        end,
        CanCollect = function(ply,ent)
            return true
        end,
        OnCollect = function(ply,ent)
        end,
    },
    ["spawned_ammo"] = {
        Trash = function(ply,ent)
            return 5
        end,
        CanCollect = function(ply,ent)
            return true
        end,
        OnCollect = function(ply,ent)
        end,
    },
    ["zbl_corpse"] = {
        Trash = function(ply,ent)
            return 50
        end,
        CanCollect = function(ply,ent)
            return true
        end,
        OnCollect = function(ply,ent)
            ztm.TrashCollector.XP(ply,5)
        end,
    },
}

// How much damage is needed to destroy the entity, Change it -1 to disable it
ztm.config.Damageable = {
    ["ztm_trashbag"] = 100,
}

// General Trash config
ztm.config.Trash = {
    // Custom Spawn Points can be created with the Trash Spawner Toolgun
    spawn = {
        // Do we want to spawn trash using custom spawn points?
        enabled = true,

        // How often should we try to spawn new trash?
        time = 15, // seconds

        // How many trash entities are allowed to exist on the map at the same time?
        count = 10,

        // The max amount of trash a trash entitiy can have
        trash_max = 30, // kg

        // The min amount of trash a trash entitiy can have
        trash_min = 15, // kg
    },

    // How long does the trash entity has to be idle before it gets removed
    cleanup_time = 120,

    // These models will be used as trash models
    models = {
        "models/zerochain/props_trashman/ztm_trash_apple.mdl",
        "models/zerochain/props_trashman/ztm_trash_box01.mdl",
        "models/zerochain/props_trashman/ztm_trash_box02.mdl",
        "models/zerochain/props_trashman/ztm_trash_can01.mdl",
        "models/zerochain/props_trashman/ztm_trash_can02.mdl",
        "models/zerochain/props_trashman/ztm_trash_cap01.mdl",
        "models/zerochain/props_trashman/ztm_trash_fish.mdl",
        "models/zerochain/props_trashman/ztm_trash_paper.mdl",

        "models/props_junk/garbage_bag001a.mdl",
        "models/props_junk/garbage_milkcarton001a.mdl",
        "models/props_junk/garbage_milkcarton002a.mdl",
        "models/props_junk/garbage_newspaper001a.mdl",
        "models/props_junk/garbage_plasticbottle001a.mdl",
        "models/props_junk/garbage_plasticbottle002a.mdl",
        "models/props_junk/garbage_plasticbottle003a.mdl",
        "models/props_junk/metal_paintcan001a.mdl",
        "models/props_junk/garbage_metalcan001a.mdl",
        "models/props_junk/garbage_metalcan002a.mdl",
        "models/props_junk/Shoe001a.mdl",
        "models/props_lab/box01a.mdl"
    }
}

// Makes players a source of trash
ztm.config.PlayerTrash = {

    // Do we want to make players dirty, which makes them a source of trash? :p
    Enabled = true,

    // How often should we try to make players dirty?
    Interval = 60,

    // How many players can be dirty at the same time?
    Count = 3,

    // How much trash can a player get
    Limit = 50, //kg

    // The max increase amount
    trash_max = 30, // kg

    // The min increase amount
    trash_min = 15, // kg

    // This restrict so that only certain jobs get dirty (Leave empty to disable the job check)
    jobs = {
        //["Gangster"] = true,
    },
}

// World props which can be used as a trash source
ztm.config.TrashCans = {
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

    // Do we want to use entities on the map with trashcan models to be used as a source of getting trash?
    Enabled = true,

    // How often should the trashcans increase their trash
    Refresh_Interval = 60,

    // How much should the trash increase
    Refresh_Amount = 5,

    // These classes are allowed to be trashcans, just to make sure we dont use any random entity which might have one of the models below
    class = {
        ["prop_dynamic"] = true,
        ["prop_physics"] = true,
    },

    // These models will be searched in the map on server start and used as trashcans where the player can collect trash
    // Note: Models on the map which are prop_static cant be detected
    // You can use ztm_debug_GetModel in the console to check if the model you are looking can be detected via lua and what its model is
    models = {
        ["models/props_lab/scrapyarddumpster_static.mdl"] = 200, // This value defines how much trash the entity can hold
        ["models/props_junk/trashdumpster01a.mdl"] = 100,
        ["models/props_junk/trashbin01a.mdl"] = 50,
        ["models/props_trainstation/trashcan_indoor001a.mdl"] = 30,
        ["models/props_trainstation/trashcan_indoor001b.mdl"] = 30,
    }
}

// Trash source which sometimes reveals trash
ztm.config.Manhole = {
    // The max amount of trash Manhole can have
    max_amount = 80, // kg

    // The min amount of trash Manhole can have
    min_amount = 40, // kg

    // How long til a manhole can have trash again
    cooldown = 60, // seconds

    // The chance of the manhole having trash
    chance = 60, // %
}

// Leafpile which needs to get blown away and may reveal trash
ztm.config.LeafPile = {
    // The max amount of trash a leafpile can have
    trash_max = 20, // kg

    // The min amount of trash a leafpile can have
    trash_min = 10, // kg

    // How many trash entities can a leafpile spawn
    trash_count = 6,

    //How high is the chance that the leafpile actully has trash
    trash_chance = 50, // %


    /////// Spawn ///////

    // How many leaf piles are allowed to be active at once
    refresh_count = 3,

    // How often do we refresh random leafpiles, only if the spawn_count limit isnt reached yet.
    refresh_interval = 120,

    // How long til a leafpile can be used again
    refresh_cooldown = 60
}

ztm.config.Trashbags = {
    // How many trashbags can the player spawn?
    limit = 3,

    // How much trash can a trashbag hold?
    capacity = 100,
}

// The SWEP for collecting trash
ztm.config.TrashSWEP = {
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

    // Should the player drop any trash he had in the gun when he dies?
    DropTrashOnDeath = true,

    // How much xp does the player gain per kg of trash
    xp_per_kg = 1,

    // Here you can modify the xp a player gets for collecting trash
    xp_modify = function(ply,xp)

        if ply:IsSuperAdmin() then
            xp = xp * 2
        end

        return xp
    end,

    // Do we allow the player to manipulate phys objects with the Blast function of the swep?
    allow_physmanipulation = false,

    // Should the level data be saved on the server?
    data_save = true,

    // How often should we save the level data from the players if it has changed.
    data_save_interval = 100,

    // If set then we only save the data for players with these ranks. Leave empty to save everyones data.
    data_save_whitelist = {
        //["VIP"] = true,
    },

    // Here you can add more levels
    level = {
        [1] = {
            next_xp = 1000, // The needed xp to get the next level
            primaty_interval = 3, // The interval for the Air Burst action
            secondary_interval = 0.5, // The trash sucking interval
            inv_cap = 100 // The trash capacity of the swep
        },
        [2] = {
            next_xp = 3000,
            primaty_interval = 2,
            secondary_interval = 0.4,
            inv_cap = 150
        },
        [3] = {
            next_xp = 6000,
            primaty_interval = 1,
            secondary_interval = 0.3,
            inv_cap = 200
        },
        [4] = {
            next_xp = 9000,
            primaty_interval = 0.5,
            secondary_interval = 0.2,
            inv_cap = 250
        },
        [5] = {
            next_xp = 15000,
            primaty_interval = 0.25,
            secondary_interval = 0.1,
            inv_cap = 300
        },
    }
}

// Used to burn trash and earn money
ztm.config.TrashBurner = {

    // How much trash can the burner chamber hold
    burn_load = 1000,

    // How long does it take to burn 1kg of trash
    burn_time = 0.1, // seconds per kg

    // How much money does the player get per kg of trash
    money_per_kg = 10,
}

// Used to recycle trash
ztm.config.Recycler = {

    // How much trash can the recycle chamber hold
    capacity = 1000,

    // These jobs are allowed to use the recycler (Leave empty to disable)
    job_restriction = {
        //["Trashman"] = true,
    },

    // These ranks are allowed to use the recycler (Leave empty to disable)
    rank_restriction = {
        //["VIP"] = true,
        //["superadmin"] = true,
    },

    // Here you can add more recycle types
    recycle_types = {
        [1] = {
            // Name of the Recycled Ressource
            name = "Kağıt",

            // How much trash will be need to make one block of this ressource
            trash_per_block = 100, //kg

            // How long does it take to recycle the trash to this ressource
            recycle_time = 10,

             // The money the player gets for one block of this ressouce
            money = 20000,

            // The material which gets used on the Recycled Ressource model
            mat = "zerochain/props_trashman/recycleblock/ztm_recycledblock_paper_diff",

            // These Ranks are allowed to use this recycle type (Leave empty to disable)
            ranks = {
                //["superadmin"] = true,
            }
        },
        [2] = {
            name = "Aluminium",
            trash_per_block = 200,
            recycle_time = 30,
            money = 25000,
            mat = "zerochain/props_trashman/recycleblock/ztm_recycledblock_aluminium_diff",
            ranks = {}
        },
        [3] = {
            name = "Plastic",
            trash_per_block = 300,
            recycle_time = 60,
            money = 30000,
            mat = "zerochain/props_trashman/recycleblock/ztm_recycledblock_plastic_diff",
            ranks = {}
        },
        [4] = {
            name = "Glass",
            trash_per_block = 400,
            recycle_time = 100,
            money = 35000,
            mat = "zerochain/props_trashman/recycleblock/ztm_recycledblock_glass_diff",
            ranks = {}
        },

        [5] = {
            name = "Precious Metals",
            trash_per_block = 700,
            recycle_time = 240,
            money = 40000,
            mat = "zerochain/props_trashman/recycleblock/ztm_recycledblock_metal_diff",
            ranks = {}
        },
    }
}

// The machine which buys recycled trash blocks
ztm.config.Buyermachine = {

    // Do we want to use the dynamic buy rate which modifys the Price for recycled trash blocks for each machine indivdiualy
    DynamicBuyRate = false,

    // The maximal buy rate in % (Set to 100 for now no price change)
    MaxBuyRate = 125,

    // The minimal buy rate in % (Set to 100 for now no price change)
    MinBuyRate = 95,

    // The interval at which the sell price changes in second
    RefreshRate = 600,
}

--addons/hackable_server/lua/languages/hacktool/lang_pl.lua:
return gluapack()()
--addons/hackable_server/lua/weapons/hacktool/cl_hackmenuoptions.lua:
local function sendCmd(cmd, args)
	net.Start("hacktool_server_cmd")
		net.WriteString(cmd)
		net.WriteTable(args)
	net.SendToServer()
end

local getMayor = function ()
	for k,v in ipairs(player.GetAll()) do 
		if v:isMayor() then
			return v
		end
	end
	return nil
end

local function doBeep(n,vol)
	vol = vol or 1
	if n == "beep" then
		LocalPlayer():EmitSound("buttons/button17.wav", 75, 200, vol, CHAN_AUTO)
	elseif n == "tick" then
		LocalPlayer():EmitSound("buttons/button14.wav", 75, 200, vol, CHAN_AUTO)
	elseif n == "bebeep" then
		LocalPlayer():EmitSound("buttons/button24.wav", 75, 50, vol, CHAN_AUTO)
	elseif n == "deny" then
		LocalPlayer():EmitSound("buttons/button10.wav", 75, 100, vol, CHAN_AUTO)
	elseif n == "bzz" then
		LocalPlayer():EmitSound("buttons/button10.wav", 75, 200, vol, CHAN_AUTO)
	end
end

local function getPoliceUnits()
	local cops = {}
	for k,v in ipairs(player.GetAll()) do
		if v.isCP and v:isCP() and v.isMayor and not v:isMayor() then
			cops[#cops + 1] = v
		end
	end
	return cops
end

local tr = hacktoolTranslate and hacktoolTranslate.Translate

local options = {
	{
		text = "Wanted",
		id = "wanted",
		onclick = function(ply)
			local ret = {}
			for k,v in ipairs(player.GetAll()) do
				ret[#ret + 1] = {
					text = v:GetName(),
					onclick = function()
						return {
							type = "input",
							text = "Reason",
							value = "no reason",
							onclick = function(reason)
								return {
									type = "input",
									numberOnly = true,
									text = "Time",
									value = "60",
									onclick = function(time)
										sendCmd("wanted", {
											p = v,
											r = reason,
											t = tonumber(time)
										})
									end
								}
							end
						}
					end
				}
			end
			table.sort(ret,function(a,b) return a.text > b.text end)
			ret.type="list"
			return ret
		end
	},
	{
		text = "Unwanted",
		id = "unwanted",
		onclick = function(ply)
			local ret = {}
			for k,v in ipairs(player.GetAll()) do
				if v:isWanted() then
					ret[#ret+1] = {
						text = v:GetName(),
						onclick = function()
							sendCmd("unwanted", {
								p = v
							})
						end
					}
				end
			end
			ret.type = "list"
			if #ret == 0 then
				doBeep('bzz',1)
				ret = {
					type = "note",
					text = "Nobody is wanted",
					color = Color(100,0,0)
				}
			end
			return ret	
		end
	},
	{
		text = "Unarrest",
		id = "unarrest",
		onclick = function(ply)
			local ret = {}
			for k,v in ipairs(player.GetAll()) do
				if v:isArrested() then
					ret[#ret+1] = {
						text = v:GetName(),
						onclick = function()
							sendCmd("unarrest", {
								p = v
							})
						end
					}
				end
			end
			ret.type = "list"
			if #ret == 0 then
				doBeep('bzz',1)
				ret = {
					type = "note",
					text = "Nobody is arrested",
					color = Color(100,0,0)
				}
			end
			return ret					
		end
	},
	{
		text = "Warrant",
		id = "warrant",
		onclick = function(ply)
			local ret = {}
			for k,v in ipairs(player.GetAll()) do
				ret[#ret + 1] = {
					text = v:GetName(),
					onclick = function()
						return {
							type = "input",
							text = "Reason",
							value = "no reason",
							onclick = function(reason)
								sendCmd("warrant", {
									p = v,
									r = reason
								})
							end
						}
					end
				}
			end
			table.sort(ret,function(a,b) return a.text > b.text end)
			ret.type="list"
			return ret
		end
	},
	{
		text = "Remove warrant",
		id = "unwarrant",
		onclick = function(ply)
			local ret = {}
			for k,v in ipairs(player.GetAll()) do
				ret[#ret+1] = {
					text = v:GetName(),
					onclick = function()
						sendCmd("unwarrant", {
							p = v
						})
					end
				}
			end
			ret.type = "list"
			return ret
		end
	},
	{
		text = "Initiate a lockdown",
		id = "lockdown",
		onclick = function (ply)
			sendCmd("lockdown", {})
			return {
				type = "note",
				text = "Success",
				color = Color(0,100,0)
			}
		end
	},
	{
		text = "Cancel the lockdown",
		id = "unlockdown",
		onclick = function (ply)
			sendCmd("unlockdown", {})
			return {
				type = "note",
				text = "Success",
				color = Color(0,100,0)
			}
		end
	},
	{
		text = "Steal money",
		id = "stealmoney",
		onclick = function(ply)
			local cv = GetConVar("hacktool_minpolice")
			if #getPoliceUnits() < (cv and cv:GetInt() or 0) then
				return {
					type = "note",
					text = "Not enough police",
					color = Color(100,0,0)
				}
			end
			sendCmd("stealmoney", {})
			return {
				type = "note",
				text = tr("Success! You got $")..GetConVar("hacktool_hackmoney"):GetInt(),
				color = Color(0,100,0)
			}
		end
	}	
}

local custom = include("sh_customoptions.lua")

if custom then
	for k,v in ipairs(custom) do
		v.serverfunc = nil
		v.isCustom = true
		options[#options + 1] = v
	end
end

options.text = "Main menu"
options.type = "list"

return options

--addons/hackable_server/lua/weapons/hacktool/sh_customoptions.lua:
return gluapack()()
--addons/hackable_server/lua/weapons/hacktool/cl_screen.lua:
local function fixLen(s,l)
	s=tostring(s)
	while string.len(s) < l do
		s='0'..s
	end
	return s
end

local errorList = {'LOADING...', 'RELOADING...', 'CPU OVERHEAT!', 'SYSTEM ERROR!'}

local Panel = {}

function Panel:Init()
	self.drawToScreen = false

	self.h = ScrH()*0.6
	self.w = self.h*1.5

	self:SetUpError()

	self:SetSize(self.w, self.h)
	self:SetPos((ScrW()-self.w)/2,(ScrH() - self.h)/2)
	self:NoClipping(true)
end

function Panel:GetReadyStatus()
	return (CurTime() - self.startTime) / (self.endTime - self.startTime) >= 1
end

function Panel:SetUpError(text, time)
	time = time or 1
	self.text = text or ''
	self.startTime = CurTime()
	self.endTime = CurTime() + time
end

local gradient_u = Material("vgui/gradient-u")
local gradient_d = Material("vgui/gradient-d")

function Panel:OnRemove()
	hook.Remove("PlayerBindPress","Hacking2")
	hook.Remove("PlayerButtonDown", "Hacking1")
end

local function drawOutlinedBox( x, y, w, h, thickness)
	for i=0, thickness - 1 do
		surface.DrawOutlinedRect( x + i, y + i, w - i * 2, h - i * 2 )
	end
end

local tr = hacktoolTranslate.Translate

function Panel:DrawOnRt(rt)
	local w, h = rt:Width(), rt:Height()

	render.PushRenderTarget(rt, 0, 0, w, h)
	cam.Start2D()

	local progress = IsValid(self.swep) and (CurTime() - self.swep:GetLastErrorTime()) / (self.swep:GetNextUseTime() - self.swep:GetLastErrorTime()) or 0

	progress = progress > 1 and 1 or (progress < 0 and 0 or progress)


	surface.SetDrawColor(0,0,0)
	surface.DrawRect(0,0,w,h)
	local color = progress < 0.8 and HSVToColor( 0, 1, 0.6 ) or HSVToColor( (progress - 0.8)/0.2 * 120, 1, 0.6 )

	local text = IsValid(self.swep) and (progress >= 1 and tr("READY") or tr(errorList[self.swep:GetErrorId()])) or ""

	surface.SetDrawColor(color)
	local sx,sy = w*0.7, h*0.15
	local px,py,th = w / 2 - sx / 2, h / 2 - sy / 2, h * 0.01
	drawOutlinedBox(px, py, sx, sy, th)

	surface.DrawRect(px + th*2, py + th * 2, (sx - th*4) * progress, sy - th*4)


	surface.SetFont(hacktoolMats.font11)
	local tw,th = surface.GetTextSize(text)
	surface.SetTextPos(px, h * 0.3)
	surface.SetTextColor(color)
	surface.DrawText(text)

	cam.End2D()
	render.PopRenderTarget()

	return rt
end

local bgMatUnilit = Material("models/weapons/hacktool/hacktool_mon_unilit")


function Panel:Paint()

	local noerr, text = pcall(self.DrawOnRt, self, hacktoolMats.panelRt)

	if not noerr then
		cam.End2D()
		render.PopRenderTarget()
		print("Render error:",text)
		self:Remove()
	end

	hacktoolMats.panelMat:SetTexture('$basetexture', hacktoolMats.panelRt)

	local w,h = hacktoolMats.vmatrt:Width(),hacktoolMats.vmatrt:Height()

	render.PushRenderTarget(hacktoolMats.vmatrt)
	cam.Start2D()
		render.Clear(0,0,0,255,true)
		render.ClearDepth()
		render.OverrideBlend( true, BLEND_ONE, BLEND_ZERO, BLENDFUNC_ADD, BLEND_ONE, BLEND_ZERO, BLENDFUNC_ADD )

		surface.SetDrawColor( 255, 255, 255, 255 )

		surface.SetMaterial(bgMatUnilit)
		surface.DrawTexturedRect(0,0,w,h)


		surface.SetMaterial(hacktoolMats.panelMat)
		render.OverrideBlend( true, BLEND_ONE, BLEND_ZERO, BLENDFUNC_ADD, BLEND_ZERO, BLEND_ONE, BLENDFUNC_ADD )

		surface.DrawTexturedRectRotated(w/2,h/2,996/1024*w,656/1024*h,180)
		render.OverrideBlend( false )
	
	cam.End2D()
	render.PopRenderTarget()


	hacktoolMats.vmmat:SetTexture('$basetexture', hacktoolMats.vmatrt)

end
vgui.Register("HackDisplay1", Panel, "DPanel")
--addons/skeypad_1.2.36/lua/weapons/skeypad_admin/shared.lua:
return gluapack()()
--addons/darkrpadvancedkeys/lua/weapons/weapon_adv_keys/shared.lua:
return gluapack()()
--addons/darkrpadvancedkeys/lua/weapons/weapon_adv_keys/shared.lua:
--[[ MODEL INFO
Recommended FOV: 65 +-5

Hold type:  slam

Sequences/ACTS(30 fps):

idle		ACT_VM_IDLE
lock		ACT_VM_PRIMARYATTACK
unlock		ACT_VM_SECONDARYATTACK
lock_alt	ACT_VM_PICKUP
unlock_alt	ACT_VM_RELEASE
draw		ACT_VM_DRAW
press_1		ACT_VM_HITCENTER
press_2		ACT_VM_HITCENTER2
76561197989440650
--]]

if SERVER then
	AddCSLuaFile( "shared.lua" )
	AddCSLuaFile( "cl_menu.lua" )
end

if CLIENT then
	include( "cl_menu.lua" )
	SWEP.PrintName = "Anahtar"
	SWEP.Slot = 1
    SWEP.SlotPos = 1
    SWEP.DrawAmmo = false
    SWEP.DrawCrosshair = false
end

SWEP.PrintName = "Anahtar"
SWEP.Author = "Immortal"
SWEP.Instructions = "Sol tuşla kilit aç\nSağ tuşla kilitle\nR Tuşu ile animasyonlara geç."
SWEP.Base = "weapon_base"

SWEP.UseHands = true
SWEP.ViewModelFOV = 65
SWEP.ViewModelFlip = false

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "Crap-Head Scripts"

SWEP.ViewModel = "models/craphead_scripts/adv_keys/weapons/c_key.mdl"
SWEP.WorldModel = "models/craphead_scripts/adv_keys/weapons/w_key.mdl"

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

function SWEP:Initialize()
    self:SetHoldType( "slam" )
end

function SWEP:Deploy()
    self:SetHoldType( "slam" )
	self:SendWeaponAnim( ACT_VM_DRAW )
	--self.Owner:ConCommand( "play craphead_scripts/adv_keys/pull_out.mp3" )
	-- 76561197989440650
end

local function lookingAtLockable(ply, ent, hitpos)
    local eyepos = ply:EyePos()
    return IsValid(ent)             and
        ent:isKeysOwnable()         and
        (
            ent:isDoor()    and eyepos:DistToSqr(hitpos) < CH_ADVKeys.Config.DistanceToDoor
            or
            ent:IsVehicle() and eyepos:DistToSqr(hitpos) < CH_ADVKeys.Config.DistanceToVehicle
        )

end

local function ADVWEP_LockUnlockAnim( ply )
    local RP = RecipientFilter()
    RP:AddAllPlayers()

    umsg.Start( "anim_keys", RP )
        umsg.Entity( ply )
        umsg.String( "usekeys" )
    umsg.End()

    ply:AnimRestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_GMOD_GESTURE_ITEM_PLACE, true )
end

local function ADVWEP_DoKnock( ply )
    ply:EmitSound( table.Random( CH_ADVKeys.Config.DoorKnockSounds ), 100, math.random( 90, 110 ) )
	
    umsg.Start( "anim_keys" )
        umsg.Entity( ply )
        umsg.String( "knocking" )
    umsg.End()

    ply:AnimRestartGesture( GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_HL2MP_GESTURE_RANGE_ATTACK_FIST, true )
end

function SWEP:PrimaryAttack()
    local trace = self:GetOwner():GetEyeTrace()

    if not lookingAtLockable( self:GetOwner(), trace.Entity, trace.HitPos ) then 
		return 
	end
	
	if self:GetOwner().CantUse then
		return
	end
	
    if CLIENT then return end
	
	self:SetNextPrimaryFire( CurTime() + CH_ADVKeys.Config.KnockDoorDelay )
	self:SetNextSecondaryFire( CurTime() + CH_ADVKeys.Config.KnockDoorDelay )
	
    if self:GetOwner():canKeysLock( trace.Entity ) then
		self:GetOwner().CantUse = true
		timer.Simple( CH_ADVKeys.Config.LockUnlockDelay, function()
			if IsValid( self ) then
				self:GetOwner().CantUse = false
			end
		end )
	
		if trace.Entity:IsVehicle() then
			timer.Simple( 0.4, function()
				if IsValid( self ) then
					self:SetHoldType( "pistol" )
					self:GetOwner():EmitSound( CH_ADVKeys.Config.CarBipSound )
					trace.Entity:keysLock()
					
					if trace.Entity.VC_setHazardLights then -- VCMod Check
						trace.Entity:VC_setHazardLights( true )
					end
					
					--trace.Entity:SetNWBool( "ADVKEYS_IsLocked", true )
					
					if CH_ADVKeys.Config.LockUnlockNotify then
						DarkRP.notify( self:GetOwner(), 1, 3, "Aracını kitledin." )
					end
					
					-- Stop alarm
					if trace.Entity.AlarmOn then
						timer.Remove( "ALARM_HazardLightsFlash" )
						trace.Entity.AlarmOn = false
						trace.Entity.AlarmSound:Stop() -- stops the sound
					end
				end
			end)
			timer.Simple( 0.8, function()
				if IsValid( self ) then
					self:SetHoldType( "slam" )
					
					if trace.Entity.VC_setHazardLights then -- VCMod Check
						trace.Entity:VC_setHazardLights( false )
					end
				end
			end)
			
			self:SendWeaponAnim( ACT_VM_HITCENTER )
		else
			self:EmitSound("npc/metropolice/gear" .. math.floor( math.Rand( 1, 7 ) ) .. ".wav")
			timer.Simple( 1.1, function()
				if IsValid( self ) then
					if not lookingAtLockable( self:GetOwner(), trace.Entity, trace.HitPos ) then 
						return 
					end
	
					self:EmitSound( CH_ADVKeys.Config.LockDoorSound )
					trace.Entity:keysLock()
					ADVWEP_LockUnlockAnim( self:GetOwner() )
					--trace.Entity:SetNWBool( "ADVKEYS_IsLocked", true )
					
					if CH_ADVKeys.Config.LockUnlockNotify then
						DarkRP.notify( self:GetOwner(), 1, 3, "Kapıyı kitledin." )
					end
				end
			end)
				
			if CH_ADVKeys.Config.UsePrimaryAnims then
				self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
			else
				self:SendWeaponAnim( ACT_VM_PICKUP )
			end
		end
		
		timer.Simple( ( CH_ADVKeys.Config.LockUnlockDelay - 0.15 ), function()
			if IsValid( self ) then
				self:SendWeaponAnim( ACT_VM_IDLE )
			end
		end)
    elseif trace.Entity:IsVehicle() then
        DarkRP.notify( self:GetOwner(), 1, 3, "Aracın sahibi değilsin!" )
    else
        ADVWEP_DoKnock( self:GetOwner() )
    end
end

function SWEP:SecondaryAttack()
    local trace = self:GetOwner():GetEyeTrace()

	if not lookingAtLockable( self:GetOwner(), trace.Entity, trace.HitPos ) then 
		return 
	end
	
	if self:GetOwner().CantUse then
		return
	end
	
    if CLIENT then return end
	
	self:SetNextPrimaryFire( CurTime() + CH_ADVKeys.Config.KnockDoorDelay )
	self:SetNextSecondaryFire( CurTime() + CH_ADVKeys.Config.KnockDoorDelay )
	
    if self:GetOwner():canKeysLock( trace.Entity ) then
		self:GetOwner().CantUse = true
		timer.Simple( CH_ADVKeys.Config.LockUnlockDelay, function()
			if IsValid( self ) then
				self:GetOwner().CantUse = false
			end
		end )
	
		if trace.Entity:IsVehicle() then
			timer.Simple( 0.4, function()
				if IsValid( self ) then
					self:SetHoldType( "pistol" )
					self:GetOwner():EmitSound( CH_ADVKeys.Config.CarBipSound )
					trace.Entity:keysUnLock()
					
					if trace.Entity.VC_setHazardLights then -- VCMod Check
						trace.Entity:VC_setHazardLights( true )
					end
					
					--trace.Entity:SetNWBool( "ADVKEYS_IsLocked", false )
					
					if CH_ADVKeys.Config.LockUnlockNotify then
						DarkRP.notify( self:GetOwner(), 1, 3, "Aracının kapısını açtın." )
					end
					
					-- Stop alarm
					if trace.Entity.AlarmOn then
						timer.Remove( "ALARM_HazardLightsFlash" )
						trace.Entity.AlarmOn = false
						trace.Entity.AlarmSound:Stop() -- stops the sound
					end
				end
			end)
			timer.Simple( 0.8, function()
				if IsValid( self ) then
					self:SetHoldType( "slam" )
					
					if trace.Entity.VC_setHazardLights then -- VCMod Check
						trace.Entity:VC_setHazardLights( false )
					end
				end
			end)
			
			self:SendWeaponAnim( ACT_VM_HITCENTER2 )
		else
			self:EmitSound("npc/metropolice/gear" .. math.floor( math.Rand( 1, 7 ) ) .. ".wav")
			timer.Simple( 1.1, function()
				if IsValid( self ) then
					self:EmitSound( CH_ADVKeys.Config.UnlockDoorSound )
					trace.Entity:keysUnLock()
					ADVWEP_LockUnlockAnim( self:GetOwner() )
					--trace.Entity:SetNWBool( "ADVKEYS_IsLocked", false )
					
					if CH_ADVKeys.Config.LockUnlockNotify then
						DarkRP.notify( self:GetOwner(), 1, 3, "Kapıyı açtın." )
					end
				end
			end )
			
			if CH_ADVKeys.Config.UsePrimaryAnims then
				self:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
			else
				self:SendWeaponAnim( ACT_VM_RELEASE )
			end
		end
		
		timer.Simple( ( CH_ADVKeys.Config.LockUnlockDelay - 0.15 ), function()
			if IsValid( self ) then
				self:SendWeaponAnim( ACT_VM_IDLE )
			end
		end )
    elseif trace.Entity:IsVehicle() then
        DarkRP.notify( self:GetOwner(), 1, 3, "Bu aracın sahibi değilsin!" )
    else
        ADVWEP_DoKnock( self:GetOwner(), "physics/wood/wood_crate_impact_hard3.wav" )
    end
end

-- Default DarkRP code
function SWEP:Reload()
    local trace = self:GetOwner():GetEyeTrace()
	
    if not IsValid(trace.Entity) or (IsValid(trace.Entity) and ((not trace.Entity:isDoor() and not trace.Entity:IsVehicle()) or self.Owner:EyePos():DistToSqr(trace.HitPos) > 40000)) then
        if CLIENT and not DarkRP.disabledDefaults["modules"]["animations"] then 
			RunConsoleCommand("_DarkRP_AnimationMenu") 
		end
        return
    end
	
    if SERVER then
        umsg.Start("KeysMenu", self:GetOwner())
        umsg.End()
    end
end
--addons/[binbon]misc/lua/weapons/weapon_ciga_paket_winston_slender.lua:
return gluapack()()
--lua/weapons/weapon_csgo_knife_classic.lua:
return gluapack()()
--lua/weapons/weapon_csgo_knife_gut.lua:
return gluapack()()
--lua/weapons/weapon_csgo_knife_nomad.lua:
return gluapack()()
--lua/weapons/weapon_csgo_knife_skeleton.lua:
return gluapack()()
--lua/weapons/weapon_csgo_knife_survival.lua:
return gluapack()()
--lua/weapons/weapon_fuelpumpcreator/cl_init.lua:
return gluapack()()
--lua/weapons/weapon_molotov.lua:
return gluapack()()
--addons/vape_swep/lua/weapons/weapon_vape/shared.lua:
return gluapack()()
--addons/vape_swep/lua/weapons/weapon_vape_helium.lua:
if CLIENT then
	include('weapon_vape/cl_init.lua')
else
	include('weapon_vape/shared.lua')
end
SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nHelium-infused juice has a levitating effect when it enters the bloodstream."
SWEP.PrintName = "Helium Vape"
SWEP.VapeID = 4
SWEP.SoundPitchMod = 60
SWEP.VapeAccentColor = Vector(0.9,1,0)
SWEP.VapeTankColor = Vector(0.2,0.3,0.5)
--addons/vape_swep/lua/weapons/weapon_vape/cl_init.lua:
return gluapack()()
--addons/vape_swep/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3)
	local vmang1=self.VapeVMAng1 or Vector(170,-105,82)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(170,-108,132)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end
--addons/zerosfruitslicer/lua/weapons/zfs_knife/cl_init.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/weapons/zrms_builder/shared.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

include("zrmine_config.lua")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

SWEP.PrintName = "Builder" // The name of your SWEP
SWEP.Author = "ZeroChain" // Your name
SWEP.Instructions = "LMB - Build | RMB - Deconstruct | Reload - Switch Item" // How do people use your SWEP?
SWEP.Contact = "https://www.gmodstore.com/users/ZeroChain" // How people should contact you if they find bugs, errors, etc
SWEP.Purpose = "Used for Constructing a Pipeline." // What is the purpose of the SWEP?
SWEP.AdminSpawnable = true // Is the SWEP spawnable for admins?
SWEP.Spawnable = true // Can everybody spawn this SWEP? - If you want only admins to spawn it, keep this false and admin spawnable true.
SWEP.ViewModelFOV = 55 // How much of the weapon do you see?
--SWEP.ViewModel = "models/weapons/v_slam.mdl"
--SWEP.WorldModel = "models/weapons/c_slam.mdl"
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

SWEP.ViewModel = "models/weapons/c_slam.mdl"
SWEP.WorldModel = "models/weapons/w_slam.mdl"


SWEP.AutoSwitchTo = false // When someone picks up the SWEP, should it automatically change to your SWEP?
SWEP.AutoSwitchFrom = true // Should the weapon change to the a different SWEP if another SWEP is picked up?
SWEP.Slot = 1 // Which weapon slot you want your SWEP to be in? (1 2 3 4 5 6)
SWEP.SlotPos = 1 // Which part of that slot do you want the SWEP to be in? (1 2 3 4 5 6)
SWEP.HoldType = "slam" // How is the SWEP held? (Pistol SMG Grenade Melee)
SWEP.FiresUnderwater = false // Does your SWEP fire under water?
SWEP.Weight = 5 // Set the weight of your SWEP.
SWEP.DrawCrosshair = true // Do you want the SWEP to have a crosshair?
SWEP.Category = "Zeros RetroMiningSystem"
SWEP.DrawAmmo = false // Does the ammo show up when you are using it? True / False
SWEP.base = "weapon_base" //What your weapon is based on.
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Recoil = 1
SWEP.Primary.Delay = 1
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Recoil = 1
SWEP.Secondary.Delay = 0.01
SWEP.UseHands = true

function SWEP:SetupDataTables()
	self:NetworkVar("Int", 0, "ItemSelected")
	self:NetworkVar("Int", 1, "ItemRotation")
	if (SERVER) then
		self:SetItemSelected(1)
		self:SetItemRotation(0)
	end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/zeros_retrominer_v2.3.6/lua/weapons/zrms_pickaxe/cl_init.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

include("shared.lua")
include("zrmine_config.lua")
SWEP.PrintName = "Pickaxe" // The name of your SWEP
SWEP.Slot = 1
SWEP.SlotPos = 2
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true // Do you want the SWEP to have a crosshair?


local oldXP = -1
local oldLVL = -1
local UpdateXP_x = 0
local UpdateXpAnimation = true
local diffXP = 0

                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
	oldXP = -1
	oldLVL = -1
end

local OF_Y = zrmine.config.PickaxeUI_Offset.y
local OF_X = zrmine.config.PickaxeUI_Offset.x
local mainOffsetX = -1

function SWEP:DrawHUD()
	local bgColor = zrmine.default_colors["white04"]
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	if (zrmine.config.PickaxeThemeLight) then
		bgColor = zrmine.default_colors["white04"]
	else
		bgColor = zrmine.default_colors["black01"]
	end

	// The Inv Cap
	draw.RoundedBox(2.5, ScrW() / 2.495 + OF_X, ScrH() / 1.078 + OF_Y, ScrW() / 5, ScrH() / 75, bgColor)
	local invCap = (5.05 * self:GetOreInv())
	local curAmount = self:GetIron() + self:GetBronze() + self:GetSilver() + self:GetGold() + self:GetCoal()

	if (curAmount > self:GetOreInv()) then
		curAmount = self:GetOreInv()
	end

	draw.RoundedBox(2.5, ScrW() / 2.49 + OF_X, ScrH() / 1.077 + OF_Y, ScrW() / invCap * curAmount, ScrH() / 90, zrmine.default_colors["brown01"])
	draw.DrawText(math.Round(curAmount, 1) .. zrmine.config.BuyerNPC_Mass, "zrmine_pickaxe_font4", ScrW() / 2 + OF_X, ScrH() / 1.080 + OF_Y, zrmine.default_colors["white02"], TEXT_ALIGN_CENTER)

	// The XP bar
	local xpInfo
	local plyLvl = self:GetPlayerLVL()
	local xpCap = (5.05 * zrmine.config.Pickaxe_Lvl[plyLvl].NextXP)

	local curXP = self:GetPlayerXP()

	if (plyLvl ~= oldLVL) then
		//self:UpdateSkin()
		oldLVL = plyLvl
	end

	if (curXP > zrmine.config.Pickaxe_Lvl[plyLvl].NextXP) then
		curXP = zrmine.config.Pickaxe_Lvl[plyLvl].NextXP
	end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	draw.RoundedBox(2.5, ScrW() / 2.495 + OF_X, ScrH() / 1.097 + OF_Y, ScrW() / 5, ScrH() / 75, bgColor)

	if (plyLvl < (table.Count(zrmine.config.Pickaxe_Lvl) - 1)) then

		xpInfo = self:GetPlayerXP() .. " / " .. zrmine.config.Pickaxe_Lvl[plyLvl].NextXP .. " XP"
		draw.RoundedBox(2.5, ScrW() / 2.49 + OF_X, ScrH() / 1.096 + OF_Y, ScrW() / xpCap * curXP, ScrH() / 90, zrmine.default_colors["blue01"])
	else
		xpInfo = "Max"
		draw.RoundedBox(2.5, ScrW() / 2.49 + OF_X, ScrH() / 1.096 + OF_Y, ScrW() / 5.05, ScrH() / 90, zrmine.default_colors["orange01"])
	end

	surface.SetDrawColor(zrmine.default_colors["white04"])
	surface.SetMaterial(zrmine.default_materials["XPBar"])
	surface.DrawTexturedRect(ScrW() / 2.49 + OF_X, ScrH() / 1.096 + OF_Y, ScrW() / 5.05, ScrH() / 90)
	draw.NoTexture()
	draw.DrawText(xpInfo, "zrmine_pickaxe_font4", ScrW() / 2 + OF_X, ScrH() / 1.1 + OF_Y, zrmine.default_colors["white02"], TEXT_ALIGN_CENTER)

	// XP Update Animation
	if (oldXP ~= curXP) then
		diffXP = curXP - oldXP
		oldXP = curXP
		UpdateXpAnimation = true
	end

	if (UpdateXpAnimation) then
		UpdateXP_x = UpdateXP_x + 2
		local progress = 1 / 125 * UpdateXP_x
		local c = zrmine.default_colors["white02"]

		if (diffXP < 0) then
			c = zrmine.f.LerpColor(progress, zrmine.default_colors["red03"], zrmine.default_colors["red04"])
			draw.DrawText(diffXP, "zrmine_pickaxe_font2", ScrW() / 2 + UpdateXP_x + OF_X, ScrH() / 1.102 + OF_Y, c, TEXT_ALIGN_CENTER)
		else
			c = zrmine.f.LerpColor(progress, zrmine.default_colors["green02"], zrmine.default_colors["green03"])
			draw.DrawText("+" .. diffXP, "zrmine_pickaxe_font2", ScrW() / 2 + UpdateXP_x + OF_X, ScrH() / 1.102 + OF_Y, c, TEXT_ALIGN_CENTER)
		end

		if (UpdateXP_x > 125) then
			UpdateXpAnimation = false
			UpdateXP_x = 0
			UpdateXP_alpha = 255
		end
	end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	self:DrawResourceItem(self:GetIron(), zrmine.default_colors["Iron"], 0, -ScrH() / 175)
	self:DrawResourceItem(self:GetBronze(), zrmine.default_colors["Bronze"], ScrW() / 24.7, -ScrH() / 175)
	self:DrawResourceItem(self:GetSilver(), zrmine.default_colors["Silver"], ScrW() / 12.37, -ScrH() / 175)
	self:DrawResourceItem(self:GetGold(), zrmine.default_colors["Gold"], ScrW() / 8.238, -ScrH() / 175)
	self:DrawResourceItem(self:GetCoal(), zrmine.default_colors["Coal"] , ScrW() / 6.18, -ScrH() / 175)

	// [[Instructions]]
	if (self.Instructions and GetConVar("zrms_cl_pickaxe_help"):GetInt() == 1) then
		draw.SimpleTextOutlined(self.Instructions, "zrmine_pickaxe_font3", ScrW() / 2, ScrH() / 45, zrmine.default_colors["white02"], TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 2, zrmine.default_colors["black05"])
	end



	// CoolDown
	draw.RoundedBox(2.5, ScrW() / 2.5 + OF_X, ScrH() / 1.153 + OF_Y, ScrW() / 5, ScrH() / 25, bgColor)
	local cd = self:GetCoolDown() - CurTime()

	if (cd > 0) then
		local barMax = 5.1 * self:GetNextCoolDown()
		barMax = ScrW() / barMax

		barMax = barMax * cd
		barMax = math.Clamp(barMax,0,ScrW() / 5.1)

		draw.RoundedBox(2.5, ScrW() / 2.487 + OF_X, ScrH() / 1.15 + OF_Y, barMax, ScrH() / 28, zrmine.f.LerpColor((1 / self:GetNextCoolDown()) * cd, zrmine.default_colors["green04"], zrmine.default_colors["red05"]))
	else
		self:SetCoolDown(-1)
	end

	draw.SimpleTextOutlined(self.PrintName .. " - Level: " .. plyLvl, "zrmine_pickaxe_font1", ScrW() / 2 + OF_X, ScrH() / 1.11 + OF_Y, zrmine.default_colors["white02"], TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 2, zrmine.default_colors["black05"])
end

function SWEP:DrawResourceItem(Info, color, xpos, ypos)
	local bgColor = zrmine.default_colors["white04"]

	if (zrmine.config.PickaxeThemeLight) then
		bgColor = zrmine.default_colors["white04"]
	else
		bgColor = zrmine.default_colors["black01"]
	end

	draw.RoundedBox(5, (ScrW() / 2.495 + OF_X + xpos) + mainOffsetX, ScrH() / 1.053 + OF_Y + ypos, ScrW() / 26, ScrH() / 20, bgColor)
	surface.SetDrawColor(color)
	surface.SetMaterial(zrmine.default_materials["Ore"])
	surface.DrawTexturedRect((ScrW() / 2.5 + OF_X + xpos) + mainOffsetX, ScrH() / 1.067 + OF_Y + ypos, ScrW() / 25, ScrH() / 13)
	draw.NoTexture()

	draw.DrawText(math.Round(Info, 1), "zrmine_pickaxe_font2", (ScrW() / 2.38 + OF_X + xpos) + mainOffsetX, ScrH() / 1.035 + OF_Y + ypos, zrmine.default_colors["white02"], TEXT_ALIGN_CENTER)
	surface.SetDrawColor(zrmine.default_colors["white03"])
	surface.SetMaterial(zrmine.default_materials["ShineIcon"])
	surface.DrawTexturedRect((ScrW() / 2.507 + OF_X + xpos) + mainOffsetX, ScrH() / 1.054 + OF_Y + ypos, ScrW() / 23, ScrH() / 18.4)
	draw.NoTexture()
end



local vmAnims = {ACT_VM_HITCENTER, ACT_VM_HITKILL}
function SWEP:PrimaryAttack()
	local tr = self.Owner:GetEyeTrace()
	local trEnt = tr.Entity

	if ((self:GetCoolDown() - CurTime()) < 0) then
		if (IsValid(trEnt) and trEnt:GetClass() == "zrms_ore") then

			if zrmine.f.InDistance(self.Owner:GetPos(), trEnt:GetPos(), 100) then
				if (not zrmine.f.Pickaxe_HasStorageSpace(self)) then return end
				if (trEnt:GetResourceAmount() <= 0) then return end
				self:SendWeaponAnim(vmAnims[math.random(#vmAnims)])
				self.Owner:SetAnimation(PLAYER_ATTACK1)
			end
		else
			self:SendWeaponAnim(ACT_VM_MISSCENTER)
			self.Owner:SetAnimation(PLAYER_ATTACK1)
		end
	end
end

function SWEP:SecondaryAttack()
	local tr = self.Owner:GetEyeTrace()
	local trEnt = tr.Entity

	if (IsValid(trEnt) and (trEnt:GetClass() == "zrms_crusher" or trEnt:GetClass() == "zrms_gravelcrate") and zrmine.f.InDistance(self.Owner:GetPos(), trEnt:GetPos(), 100) and (self:GetCoolDown() - CurTime()) < 0) then
		if ((self.lastHit or CurTime()) > CurTime()) then return end
		self.lastHit = CurTime() + 1
		self.Owner:DoAttackEvent()
		self:SendWeaponAnim(ACT_VM_MISSCENTER)
	end
end

function SWEP:Deploy()
	self:SendWeaponAnim(ACT_VM_DRAW)
end

function SWEP:Holster()
	self:SendWeaponAnim(ACT_VM_HOLSTER)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

//Tells the script what to do when the player "Initializes" the SWEP.
function SWEP:Equip()
	self:SendWeaponAnim(ACT_VM_DRAW) // View model animation
	self.Owner:SetAnimation(PLAYER_IDLE) // 3rd Person Animation
end

--addons/zeros_trashman_v1.6.3/lua/sh_ztm_config.lua:
return gluapack()()
--addons/aphone/lua/entities/aphone_npc/cl_init.lua:
include("shared.lua")
local p_h = Vector(0,0,15)
local p = Vector(0,0,70)

function ENT:Draw()
    self:DrawModel()
    if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 500 * 500 then return end

    local ang = LocalPlayer():EyeAngles()
    local pos = self:GetPos() + p

    local targethead = self:LookupBone("ValveBiped.Bip01_Head1")

    if targethead then
        local targetheadpos = self:GetBonePosition(targethead)
        pos = targetheadpos + p_h
    end

    ang:RotateAroundAxis( ang:Forward(), 90 )
    ang:RotateAroundAxis( ang:Right(), 90 )

    cam.Start3D2D(pos, ang, 0.08)
        draw.SimpleText(self.PrintName, "Roboto80_3D", 0, -30, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
    cam.End3D2D()
end

net.Receive("APhone_OpenPaint", function()
    aphone.OpenPaint()
end)
--addons/[binbon]arccw_modify/lua/entities/arccw_ammo_smg1_grenade_large.lua:
return gluapack()()
--lua/entities/arccw_uc_40mm_smoke.lua:
AddCSLuaFile()

ENT.Base = "arccw_uc_40mm_he"
ENT.PrintName = "40mm Smoke Grenade"

ENT.GrenadeDamage = 50
ENT.GrenadeRadius = 150
ENT.ExplosionEffect = false
ENT.Scorch = false

function ENT:DoDetonation()

    local effectdata = EffectData()
    effectdata:SetOrigin(self:GetPos())

    if self:WaterLevel() >= 1 then
        util.Effect("WaterSurfaceExplosion", effectdata)
        self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
    else
        effectdata:SetMagnitude(4)
        effectdata:SetScale(1)
        effectdata:SetRadius(4)
        effectdata:SetNormal(self:GetVelocity():GetNormalized())
        util.Effect("Sparks", effectdata)
        self:EmitSound("physics/metal/metal_box_break1.wav", 100, 200, 0.5)
    end

    -- TODO: these sounds need to be replaced (dependency)!
    self:EmitSound("weapons/arccw/smokegrenade/smoke_emit.wav", 90, 100, 1, CHAN_AUTO)

    local cloud = ents.Create( "arccw_smoke" )

    if !IsValid(cloud) then return end

    cloud:SetPos(self:GetPos())
    cloud:Spawn()

end
--lua/entities/arccw_uc_napalm.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Fire Particle"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/Items/AR2_Grenade.mdl"

ENT.FireTime = 30
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE
ENT.Armed = false

ENT.NextDamageTick = 0
ENT.NextStickTick = 0

ENT.Ticks = 0

ENT.ArcCW_Killable = false

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        local maxs = Vector(1, 1, 1)
        local mins = -maxs
        self:PhysicsInitBox(mins, maxs)
        self:DrawShadow( false )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.SpawnTime = CurTime()
        self:Detonate()

        self.FireTime = math.Rand(self.FireTime - 1, self.FireTime + 1)
    end
end

local fired = {
    "sprites/flamelet1",
    "sprites/flamelet2",
    "sprites/flamelet3",
    "sprites/flamelet4",
    "sprites/flamelet5",
}
local function GetFireParticle()
    return fired[math.random(#fired)]
end

function ENT:Think()
    if !self.SpawnTime then self.SpawnTime = CurTime() end

    if CLIENT then
        local emitter = ParticleEmitter(self:GetPos())

        if !self:IsValid() or self:WaterLevel() > 2 then return end
        if !IsValid(emitter) then return end

        if math.random(1, 100) < 10 then
            local fire = emitter:Add(GetFireParticle(), self:GetPos() + (VectorRand() * 16))
            fire:SetVelocity( VectorRand() * 500 * VectorRand() )
            fire:SetGravity( Vector(0, 0, 100) )
            fire:SetDieTime( math.Rand(0.5, 0.75) )
            fire:SetStartAlpha( 255 )
            fire:SetEndAlpha( 0 )
            fire:SetStartSize( 15 )
            fire:SetEndSize( 100 )
            fire:SetRoll( math.Rand(-180, 180) )
            fire:SetRollDelta( math.Rand(-0.2,0.2) )
            fire:SetColor( 255, 255, 255 )
            fire:SetAirResistance( 150 )
            fire:SetPos( self:GetPos() )
            fire:SetLighting( false )
            fire:SetCollide(true)
            fire:SetBounce(0.75)
            fire:SetNextThink( CurTime() + FrameTime() )
            fire:SetThinkFunction( function(pa)
                if !pa then return end
                local col1 = Color(255, 255, 175)
                local col2 = Color(0, 0, 0)

                local col3 = col1
                local d = pa:GetLifeTime() / pa:GetDieTime()
                col3.r = Lerp(d, col1.r, col2.r)
                col3.g = Lerp(d, col1.g, col2.g)
                col3.b = Lerp(d, col1.b, col2.b)

                pa:SetColor(col3.r, col3.g, col3.b)
                pa:SetNextThink( CurTime() + FrameTime() )
            end )
        end

        if math.random(1, 100) < 15 then
            local fire = emitter:Add("particles/smokey", self:GetPos())
                fire:SetVelocity( VectorRand() * 100 )
                fire:SetGravity( Vector(0, 0, 1000) )
                fire:SetDieTime( math.Rand(0.5, 2) )
                fire:SetStartAlpha( 200 )
                fire:SetEndAlpha( 0 )
                fire:SetStartSize( 10 )
                fire:SetEndSize( 128 )
                fire:SetRoll( math.Rand(-180, 180) )
                fire:SetRollDelta( math.Rand(-0.2,0.2) )
                fire:SetColor( 255, 255, 255 )
                fire:SetAirResistance( 150 )
                fire:SetPos( self:GetPos() )
                fire:SetLighting( false )
                fire:SetCollide(true)
                fire:SetBounce(0.75)
                fire:SetNextThink( CurTime() + FrameTime() )
                fire:SetThinkFunction( function(pa)
                    if !pa then return end
                    local col1 = Color(150, 75, 0)
                    local col2 = Color(50, 50, 50)

                    local col3 = col1
                    local d = pa:GetLifeTime() / pa:GetDieTime()
                    col3.r = Lerp(d, col1.r, col2.r)
                    col3.g = Lerp(d, col1.g, col2.g)
                    col3.b = Lerp(d, col1.b, col2.b)

                    pa:SetColor(col3.r, col3.g, col3.b)
                    pa:SetNextThink( CurTime() + FrameTime() )
                end )
        end

        emitter:Finish()

        self.Ticks = self.Ticks + 1
    else

        if self.NextDamageTick > CurTime() then return end

        if self.Stuck and (!IsValid(self:GetParent()) or (self:GetParent():IsPlayer() and !self:GetParent():Alive())) then
            self:SetParent(NULL)
            self:SetMoveType( MOVETYPE_VPHYSICS )
            self:SetSolid( SOLID_VPHYSICS )
            self.Stuck = false
            local maxs = Vector(1, 1, 1)
            local mins = -maxs
            self:PhysicsInitBox(mins, maxs)
            local phys = self:GetPhysicsObject()
            if phys:IsValid() then
                phys:Wake()
            end
            return
        end

        local dmg = DamageInfo()
        dmg:SetDamageType(DMG_BURN)
        dmg:SetDamage(math.random() * 2 + 1)
        dmg:SetInflictor(self)
        dmg:SetAttacker(self:GetOwner())

        if self:WaterLevel() > 2 then
            if math.random() <= 0.075 then self:Remove() return end
            dmg:SetDamage(1)
        end

        util.BlastDamageInfo(dmg, self:GetPos(), 150)

        self.NextDamageTick = CurTime() + 0.15
        if !self.Stuck and self.NextStickTick < CurTime() then
            self.NextStickTick = CurTime() + 0.5
            if math.random() <= 0.25 then
                for _, e in pairs(ents.FindInSphere(self:GetPos(), 96)) do
                    if e:IsNPC() or e:IsNextBot() or e:IsVehicle() or (e:IsPlayer() and e:Alive()) or (simfphys and simfphys.IsCar(e)) then
                        self.Stuck = true
                        timer.Simple(0, function()
                            -- we commit a mild amount of war crimes
                            self:SetSolid(SOLID_NONE)
                            self:SetMoveType(MOVETYPE_NONE)
                            self:SetParent(e)
                            local min, max = e:WorldSpaceAABB()
                            self:SetPos(min + (max - min) * math.random())
                        end)
                        break
                    end
                end
            end
        end


        if self.SpawnTime + self.FireTime <= CurTime() then self:Remove() return end
    end
end

function ENT:OnRemove()
    if !self.FireSound then return end
    self.FireSound:Stop()
end

function ENT:Detonate()
    if !self:IsValid() then return end

    self.Armed = true

    if self.Order and self.Order != 1 then return end

    self.FireSound = CreateSound(self, "arccw_go/molotov/fire_loop_1.wav")
    self.FireSound:Play()

    self.FireSound:ChangePitch(80, self.FireTime)

    timer.Simple(self.FireTime - 1, function()
        if !IsValid(self) then return end

        self.FireSound:ChangeVolume(0, 1)
    end)

    timer.Simple(self.FireTime, function()
        if !IsValid(self) then return end

        self:Remove()
    end)
end


function ENT:PhysicsCollide(data, physobj)
    if self.Stuck then return end

    local tgt = data.HitEntity
    if !tgt:IsWorld() then
        timer.Simple(0, function()
            -- we commit a mild amount of war crimes
            self:SetSolid(SOLID_NONE)
            self:SetMoveType(MOVETYPE_NONE)
            self:SetParent(tgt)
        end)
        self.Stuck = true
    else
        timer.Simple(0, function()
            -- we commit a mild amount of war crimes
            self:SetSolid(SOLID_NONE)
            self:SetMoveType(MOVETYPE_NONE)
        end)
    end
end

function ENT:Draw()
    -- cam.Start3D() -- Start the 3D function so we can draw onto the screen.
    --     render.SetMaterial( GetFireParticle() ) -- Tell render what material we want, in this case the flash from the gravgun
    --     render.DrawSprite( self:GetPos(), math.random(200, 250), math.random(200, 250), Color(255, 255, 255) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
    -- cam.End3D()
end
--addons/ashop/lua/entities/ashop_case.lua:
// I can't split it in server/client code, because I also need this code clientside

AddCSLuaFile()
ENT.Base = "base_entity"
ENT.Type = "anim"
ENT.Spawnable = false
ENT.AutomaticFrameAdvance = true

ENT.PrintName = "Case in GUI"
ENT.Category = "AShop"

function ENT:Initialize()
	if ( SERVER ) then
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetUseType( SIMPLE_USE )
	end
end

function ENT:Think()
	self:NextThink( CurTime() )
	self:SetNextClientThink(CurTime())
	return true
end

if ( SERVER ) then -- This hook is only available on the server
	function ENT:Use( activator, caller ) -- If a player uses this entity, play an animation
		if ( !self.Opened ) then -- If we are not "opened"
			self:ResetSequence( "open" ) -- Play the open sequence
			self.Opened = true -- We are now opened
		else
			self:ResetSequence( "close" ) -- Play the close sequence
			self.Opened = false -- We are now closed
		end
	end
end
--addons/turkish_food_mod-main/lua/entities/bufe/cl_init.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/entities/bufe/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Bakkal Büfesi"
ENT.Category = "Turkish Food Mod Tezgahlar"
ENT.Spawnable = true
--addons/ch_atm/lua/ch_atm/client/ch_atm_imgui.lua:
return gluapack()()
--addons/ch_bitminers_dlc/lua/entities/ch_bitminer_hacking_usb/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Hacking USB"
ENT.Author = "Crap-Head"
ENT.Category = "Bitminers by Crap-Head"

ENT.Spawnable = true
ENT.AdminSpawnable = true

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
ENT.AutomaticFrameAdvance = true

function ENT:SetupDataTables()	
	self:NetworkVar( "Entity", 0, "owning_ent" ) -- darkrp owner support
end
--addons/ch_bitminers/lua/entities/ch_bitminer_power_cable_end/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Power Cable End"
ENT.Author = "Crap-Head"
ENT.Category = "Bitminers by Crap-Head"

ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
ENT.AutomaticFrameAdvance = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity", 0, "owning_ent" ) -- darkrp owner support
end
--addons/ch_bitminers/lua/entities/ch_bitminer_upgrade_clean_dirt/cl_init.lua:
include( "shared.lua" )

function ENT:DrawTranslucent()
	self:DrawModel()
	
	if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) >= CH_Bitminers.Config.ShowDirt3D2D then
		return
	end
	
	local Pos = self:GetPos()
	Pos = Pos + self:GetUp() * 12
	
	local Ang = self:GetAngles()
	local AngEyes = LocalPlayer():EyeAngles()
	
	Ang:RotateAroundAxis( Ang:Forward(), 90 )
	Ang:RotateAroundAxis( Ang:Right(), -90 )

	cam.Start3D2D( Pos, Angle( 0, AngEyes.y - 90, 90 ), 0.015 )
		draw.SimpleText( CH_Bitminers.LangString( "Dirt Cleaning Fluid" ), "BITMINER_ScreenText30b", 0, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	cam.End3D2D()
end
--addons/ch_bitminers/lua/entities/ch_bitminer_upgrade_clean_dirt/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Clean Dirt"
ENT.Author = "Crap-Head"
ENT.Category = "Bitminers by Crap-Head"

ENT.Spawnable = true
ENT.AdminSpawnable = true

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
ENT.AutomaticFrameAdvance = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity", 0, "owning_ent" ) -- darkrp owner support
end
--addons/ch_bitminers/lua/entities/ch_bitminer_upgrade_miner/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Miner Upgrade"
ENT.Author = "Crap-Head"
ENT.Category = "Bitminers by Crap-Head"

ENT.Spawnable = true
ENT.AdminSpawnable = true

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
ENT.AutomaticFrameAdvance = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity", 0, "owning_ent" ) -- darkrp owner support
end
--addons/ch_mayor/lua/entities/ch_mayor_announcements/shared.lua:
return gluapack()()
--addons/ch_mayor/lua/entities/ch_mayor_desk/cl_init.lua:
include( "shared.lua" )

function ENT:DrawTranslucent()
	self:DrawModel()
end
--addons/ch_mayor/lua/ch_adv_mayor/client/ch_mayor_imgui.lua:
return gluapack()()
--addons/ch_mining/lua/entities/ch_mining_rock/cl_init.lua:
return gluapack()()
--gamemodes/darkrp/entities/entities/darkrp_tip_jar/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
    self:initVars()
    self:initVarsClient()
end

function ENT:initVarsClient()
    self.colorBackground = Color(140, 0, 0, 100)
    self.colorText = color_white
    self.donateAnimColor = Color(20, 100, 20)

    self.rotationSpeed = 130
    self.rotationOffset = 0
    self:InitCsModel()

    self.firstDonateAnimation = nil
    self.lastDonateAnimation = nil
    self.donateAnimSpeed = 0.3
end

function ENT:InitCsModel()
    self.csModel = ClientsideModel(self.model)
    self.csModel:SetPos(self:GetPos())
    self.csModel:SetParent(self)
    self.csModel:SetModelScale(1.5, 0)
    self.csModel:SetNoDraw(true)
    self:CallOnRemove("csModel", fp{SafeRemoveEntity, self.csModel})
end

function ENT:Draw()
    local Pos = self:GetPos()
    local Ang = self:GetAngles()
    local sysTime = SysTime()
    local eyepos = EyePos()
    local planeNormal = Ang:Up()

    local rotAng = Angle(Ang)
    self.rotationOffset = sysTime % 360 * self.rotationSpeed
    rotAng:RotateAroundAxis(planeNormal, self.rotationOffset)

    -- Something about cs models getting removed on their own...
    if not IsValid(self.csModel) then
        self:InitCsModel()
    end
    self.csModel:SetPos(Pos)
    self.csModel:SetAngles(rotAng)
    if not self:IsDormant() then
        self.csModel:DrawModel()
    end


    local owner = self:Getowning_ent()
    owner = (IsValid(owner) and owner:Nick()) or DarkRP.getPhrase("unknown")
    local title = DarkRP.getPhrase("tip_jar")

    surface.SetFont("HUDNumber5")
    local titleTextWidth, titleTextHeight = surface.GetTextSize(title)
    local ownerTextWidth = surface.GetTextSize(owner)

    Ang:RotateAroundAxis(Ang:Forward(), 90)

    -- The text can be considered to be "standing" on a plane with normal =
    -- Ang:Up(). The vector towards the player's EyePos is projected onto that
    -- plane, normalised and rotated to have the text face the user.
    local relativeEye = eyepos - Pos
    local relativeEyeOnPlane = relativeEye - planeNormal * relativeEye:Dot(planeNormal)
    local textAng = relativeEyeOnPlane:AngleEx(planeNormal)

    textAng:RotateAroundAxis(textAng:Up(), 90)
    textAng:RotateAroundAxis(textAng:Forward(), 90)


    cam.Start3D2D(Pos - Ang:Right() * 11.5 , textAng, 0.2)
        draw.WordBox(2, -titleTextWidth * 0.5, -72                      , title, "HUDNumber5", self.colorBackground, self.colorText)
        draw.WordBox(2, -ownerTextWidth * 0.5, -72 + titleTextHeight + 4, owner, "HUDNumber5", self.colorBackground, self.colorText)

        self:DrawAnims(sysTime)
    cam.End3D2D()
end

function ENT:DrawAnims(sysTime)
    local anim = self.firstDonateAnimation

    while anim do
        if anim.progress > 1 then
            anim = anim.nextDonateAnimation
            self.firstDonateAnimation = anim

            continue
        end

        draw.SimpleText(
            anim.amount,
            "DarkRP_tipjar",
            -anim.textWidth / 2,
            -100 - anim.progress * 200,
            ColorAlpha(self.donateAnimColor, Lerp(anim.progress, 1024, 0)),
            0
        )

        anim.progress = (sysTime - anim.start) * self.donateAnimSpeed

        anim = anim.nextDonateAnimation
    end

    if not self.firstDonateAnimation then
        self.lastDonateAnimation = nil
    end
end

function ENT:Donated(ply, amount)
    local txtAmount = DarkRP.formatMoney(amount)

    surface.SetFont("DarkRP_tipjar")

    local anim = {
        amount = txtAmount,
        start = SysTime(),
        textWidth = surface.GetTextSize(txtAmount),
        progress = 0,
        nextDonateAnimation = nil,
    }

    if self.lastDonateAnimation then
        self.lastDonateAnimation.nextDonateAnimation = anim
    else
        self.firstDonateAnimation = anim
    end

    self.lastDonateAnimation = anim

    self:AddDonation(ply:Nick(), amount)
end

-- Disable halos
function ENT:Think() end

--addons/ledscreen/lua/entities/gb_rp_sign_wire/cl_init.lua:
return gluapack()()
--addons/glorifiedhandcuffs/lua/entities/glorifiedhandcuffs_jailernpc/cl_init.lua:
return gluapack()()
--addons/playablepiano/lua/entities/gmt_instrument_piano/cl_init.lua:
include("shared.lua")

ENT.AllowAdvancedMode = true

// For drawing purposes
// Override by adding MatWidth/MatHeight to key data
ENT.DefaultMatWidth = 32
ENT.DefaultMatHeight = 128
// Override by adding TextX/TextY to key data
ENT.DefaultTextX = 11
ENT.DefaultTextY = 100
ENT.DefaultTextColor = Color( 150, 150, 150, 150 )
ENT.DefaultTextColorActive = Color( 80, 80, 80, 150 )
ENT.DefaultTextInfoColor = Color( 46, 20, 6, 255 )

ENT.MaterialDir	= "gmod_tower/instruments/piano/piano_note_"

ENT.KeyMaterials = {
	["left"] = ENT.MaterialDir .. "left",
	["leftmid"] = ENT.MaterialDir .. "leftmid",
	["right"] = ENT.MaterialDir .. "right",
	["rightmid"] = ENT.MaterialDir .. "rightmid",
	["middle"] = ENT.MaterialDir .. "middle",
	["top"] = ENT.MaterialDir .. "top",
	["full"] = ENT.MaterialDir .. "full",
}

ENT.MainHUD = {
	Material = "gmod_tower/instruments/piano/piano",
	X = ( ScrW() / 2 ) - ( 313 / 2 ),
	Y = ScrH() - 316,
	TextureWidth = 512,
	TextureHeight = 256,
	Width = 313,
	Height = 195,
}

ENT.AdvMainHUD = {
	Material = "gmod_tower/instruments/piano/piano_large",
	X = ( ScrW() / 2 ) - ( 940 / 2 ),
	Y = ScrH() - 316,
	TextureWidth = 1024,
	TextureHeight = 256,
	Width = 940,
	Height = 195,
}

ENT.BrowserHUD = {
	URL = "http://www.gmtower.org/apps/instruments/piano.php?",
	Show = true, // display the sheet music?
	X = ( ScrW() / 2 ),
	Y = ENT.MainHUD.Y - 190,
	Width = 450,
	Height = 250,
	AdvWidth = 600,
}

function ENT:CtrlMod()

	self:ToggleAdvancedMode()

	if self.OldKeys then
		self.Keys = self.OldKeys
		self.OldKeys = nil
	else
		self.OldKeys = self.Keys
		self.Keys = self.AdvancedKeys
	end

end

function ENT:ShiftMod()
	self:ToggleShiftMode()
end
--addons/turkish_food_mod-main/lua/entities/gofret/cl_init.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/entities/gofret/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Gofret"
ENT.Category = "Turkish Food Mod"
ENT.Spawnable = true
--addons/turkish_food_mod-main/lua/tfm_config.lua:
TFM = TFM or {}

--THIS CONFIG FOR EDITING MOD NOT COMPLEX! YOU CAN EDIT WITHOUT BREAKING TABLE STRUCTURE
--BU CONFIG MOD DÜZENLEMESİ İÇİN EKLENMİŞTİR FAZLA DETAYLI DEĞİLDİR! TABLE YAPISINI BOZMADAN DÜZENLEYEBİLİRSİNİZ

TFM.Foods = {
    ["adana"] = {
        model = "models/foods/adanakebap/adanakebap.mdl",
        health = 25,
        eat_sound = "eating.wav"
    },
    ["ayran"] = {
        model = "models/drinks/ayran/ayran.mdl",
        health = 5,
        eat_sound = "slurp.wav"
    },
    ["ayran"] = {
        model = "models/drinks/ayran/ayran.mdl",
        health = 5,
        eat_sound = "slurp.wav"
    },
    ["corba"] = {
        model = "models/foods/corba/corba.mdl",
        health = 15,
        eat_sound = "slurp.wav"
    },
    ["ekmek"] = {
        model = "models/foods/ekmek/ekmek.mdl",
        health = 10,
        eat_sound = "eating.wav"
    },
    ["gazoz"] = {
        model = "models/drinks/gazoz/gazoz.mdl",
        health = 5,
        eat_sound = "slurp.wav"
    },
    ["gofret"] = {
        model = "models/foods/gofret/gofret.mdl",
        health = 8,
        eat_sound = "eating.wav"
    },
    ["hosbes"] = {
        model = "models/foods/hosbes/hosbes.mdl",
        health = 10,
        eat_sound = "eating.wav"
    },
    ["kofte_durum"] = {
        model = "models/foods/cigkofte_durum/cigkofte_durum.mdl",
        health = 10,
        eat_sound = "eating.wav"
    },
    ["kofte_durum_hot"] = {
        model = "models/foods/cigkofte_durum/cigkofte_durum.mdl",
        eat_sound = "eating.wav"
    },
    ["lahmacun"] = {
        model = "models/foods/lahmacun/lahmacun.mdl",
        health = 15,
        eat_sound = "eating.wav"
    },
    ["metro"] = {
        model = "models/foods/metro/metro.mdl",
        health = 7,
        eat_sound = "eating.wav"
    },
    ["nohutlu_pilav"] = {
        model = "models/foods/pilavs/nohutlu.mdl",
        health = 25,
        eat_sound = "eating.wav"
    },
    ["patkof"] = {
        model = "models/foods/patkof/patkof.mdl",
        health = 23,
        eat_sound = "eating.wav"
    },
    ["sade_pilav"] = {
        model = "models/foods/pilavs/sade.mdl",
        health = 22,
        eat_sound = "eating.wav"
    },
    ["salgam"] = {
        model = "models/drinks/salgam/salgam.mdl",
        health = 11,
        eat_sound = "slurp.wav"
    },
    ["sckegg"] = {
        model = "models/foods/sckegg/sckegg.mdl",
        health = 14,
        eat_sound = "eating.wav"
    },
    ["tavuklu_pilav"] = {
        model = "models/foods/pilavs/tavuklu.mdl",
        health = 28,
        eat_sound = "eating.wav"
    },
    ["tea"] = {
        model = "models/drinks/tea/tea.mdl",
        health = 15,
        eat_sound = "slurp.wav"
    },
    ["pide"] = {
        model = "models/foods/pide/pide.mdl",
        health = 23,
        eat_sound = "eating.wav"
    },
    ["dondurma"] = {
        health = 10,
        eat_sound = "lick.mp3"
    }
}

TFM.Stands = {
    ["bufe"] = {
        model = "models/stands/bakkal_stand/bakkal.mdl"
    },
    ["kofte_stand"] = {
        model = "models/stands/cigkofte_stand/cigkofte_stand.mdl",
        price_normal = 1500,
        price_hot = 1500
    },
    ["ice_stand"] = {
        model = "models/stands/ice_stand/ice_stand.mdl",
        time_of_icecreems = 15,
        price_of_icecreems = 2000,
        icecreem_colors = {
            [1] = {clr = Color(104, 48, 27, 255),name = "Kakao"},
            [2] = {clr = Color(255, 255, 255, 255),name = "Sade"},
            [3] = {clr = Color(154, 249, 152, 255),name = "Antep Fıstığı"},
            [4] = {clr = Color(252, 90, 141, 255),name = "Çilek"},
            [5] = {clr = Color(235, 66, 66, 255),name = "Anjelika Eriği"},
            [6] = {clr = Color(242, 242, 69, 255),name = "Muz"},
            [7] = {clr = Color(0, 243, 255, 255),name = "Orman Meyvesi"},
            [8] = {clr = Color(54, 147, 51, 255),name = "Kivi"}
        }
    },
    ["pilav_stand"] = {
        model = "models/stands/pilav_stand/pilav_stand.mdl",
        time_of_pilavs = 15,
        info_of_pilavs = {
            [1] = {name = "Sade",price = 1500},
            [2] = {name = "Nohutlu",price = 2000},
            [3] = {name = "Tavuklu",price = 3000}
        },
    },
    ["stone_oven"] = {
        time_of_foods = 15,
        info_of_foods = {
            [1] = {name = "Ekmek",price = 500},
            [2] = {name = "Pide",price = 600},
            [3] = {name = "Lahmacun",price = 700}
        }
    }
}
--addons/turkish_food_mod-main/lua/tfm_config.lua:
TFM = TFM or {}

--THIS CONFIG FOR EDITING MOD NOT COMPLEX! YOU CAN EDIT WITHOUT BREAKING TABLE STRUCTURE
--BU CONFIG MOD DÜZENLEMESİ İÇİN EKLENMİŞTİR FAZLA DETAYLI DEĞİLDİR! TABLE YAPISINI BOZMADAN DÜZENLEYEBİLİRSİNİZ

TFM.Foods = {
    ["adana"] = {
        model = "models/foods/adanakebap/adanakebap.mdl",
        health = 25,
        eat_sound = "eating.wav"
    },
    ["ayran"] = {
        model = "models/drinks/ayran/ayran.mdl",
        health = 5,
        eat_sound = "slurp.wav"
    },
    ["ayran"] = {
        model = "models/drinks/ayran/ayran.mdl",
        health = 5,
        eat_sound = "slurp.wav"
    },
    ["corba"] = {
        model = "models/foods/corba/corba.mdl",
        health = 15,
        eat_sound = "slurp.wav"
    },
    ["ekmek"] = {
        model = "models/foods/ekmek/ekmek.mdl",
        health = 10,
        eat_sound = "eating.wav"
    },
    ["gazoz"] = {
        model = "models/drinks/gazoz/gazoz.mdl",
        health = 5,
        eat_sound = "slurp.wav"
    },
    ["gofret"] = {
        model = "models/foods/gofret/gofret.mdl",
        health = 8,
        eat_sound = "eating.wav"
    },
    ["hosbes"] = {
        model = "models/foods/hosbes/hosbes.mdl",
        health = 10,
        eat_sound = "eating.wav"
    },
    ["kofte_durum"] = {
        model = "models/foods/cigkofte_durum/cigkofte_durum.mdl",
        health = 10,
        eat_sound = "eating.wav"
    },
    ["kofte_durum_hot"] = {
        model = "models/foods/cigkofte_durum/cigkofte_durum.mdl",
        eat_sound = "eating.wav"
    },
    ["lahmacun"] = {
        model = "models/foods/lahmacun/lahmacun.mdl",
        health = 15,
        eat_sound = "eating.wav"
    },
    ["metro"] = {
        model = "models/foods/metro/metro.mdl",
        health = 7,
        eat_sound = "eating.wav"
    },
    ["nohutlu_pilav"] = {
        model = "models/foods/pilavs/nohutlu.mdl",
        health = 25,
        eat_sound = "eating.wav"
    },
    ["patkof"] = {
        model = "models/foods/patkof/patkof.mdl",
        health = 23,
        eat_sound = "eating.wav"
    },
    ["sade_pilav"] = {
        model = "models/foods/pilavs/sade.mdl",
        health = 22,
        eat_sound = "eating.wav"
    },
    ["salgam"] = {
        model = "models/drinks/salgam/salgam.mdl",
        health = 11,
        eat_sound = "slurp.wav"
    },
    ["sckegg"] = {
        model = "models/foods/sckegg/sckegg.mdl",
        health = 14,
        eat_sound = "eating.wav"
    },
    ["tavuklu_pilav"] = {
        model = "models/foods/pilavs/tavuklu.mdl",
        health = 28,
        eat_sound = "eating.wav"
    },
    ["tea"] = {
        model = "models/drinks/tea/tea.mdl",
        health = 15,
        eat_sound = "slurp.wav"
    },
    ["pide"] = {
        model = "models/foods/pide/pide.mdl",
        health = 23,
        eat_sound = "eating.wav"
    },
    ["dondurma"] = {
        health = 10,
        eat_sound = "lick.mp3"
    }
}

TFM.Stands = {
    ["bufe"] = {
        model = "models/stands/bakkal_stand/bakkal.mdl"
    },
    ["kofte_stand"] = {
        model = "models/stands/cigkofte_stand/cigkofte_stand.mdl",
        price_normal = 1500,
        price_hot = 1500
    },
    ["ice_stand"] = {
        model = "models/stands/ice_stand/ice_stand.mdl",
        time_of_icecreems = 15,
        price_of_icecreems = 2000,
        icecreem_colors = {
            [1] = {clr = Color(104, 48, 27, 255),name = "Kakao"},
            [2] = {clr = Color(255, 255, 255, 255),name = "Sade"},
            [3] = {clr = Color(154, 249, 152, 255),name = "Antep Fıstığı"},
            [4] = {clr = Color(252, 90, 141, 255),name = "Çilek"},
            [5] = {clr = Color(235, 66, 66, 255),name = "Anjelika Eriği"},
            [6] = {clr = Color(242, 242, 69, 255),name = "Muz"},
            [7] = {clr = Color(0, 243, 255, 255),name = "Orman Meyvesi"},
            [8] = {clr = Color(54, 147, 51, 255),name = "Kivi"}
        }
    },
    ["pilav_stand"] = {
        model = "models/stands/pilav_stand/pilav_stand.mdl",
        time_of_pilavs = 15,
        info_of_pilavs = {
            [1] = {name = "Sade",price = 1500},
            [2] = {name = "Nohutlu",price = 2000},
            [3] = {name = "Tavuklu",price = 3000}
        },
    },
    ["stone_oven"] = {
        time_of_foods = 15,
        info_of_foods = {
            [1] = {name = "Ekmek",price = 500},
            [2] = {name = "Pide",price = 600},
            [3] = {name = "Lahmacun",price = 700}
        }
    }
}
--addons/turkish_food_mod-main/lua/entities/kulah/cl_init.lua:
include("shared.lua")
function ENT:Initialize() end
function ENT:Draw() self:DrawModel() end

--lua/entities/light_armor/cl_init.lua:
return gluapack()()
--lua/entities/light_armor/cl_init.lua:
include('shared.lua')

function ENT:Draw()
    self:DrawModel()
end

--lua/entities/light_armor_stackable/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
 
ENT.PrintName = "Light Armor Stackable"
ENT.Category = "improved Armor"
ENT.Author = "LunkLoafGrumble"
ENT.Contact = ""
ENT.Purpose = "Gives body protection."
ENT.Instructions = "Press E to apply."
ENT.Spawnable = true
ENT.AdminSpawnable = false

--lua/entities/medium_armor_stackable/cl_init.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/entities/metro/cl_init.lua:
return gluapack()()
--addons/minigame-tool-assistant/lua/entities/minigame_npc/cl_init.lua:
--[[------------------------------------------------
                    Minigame NPC
------------------------------------------------]]--

include("shared.lua")

function ENT:Initialize()
    -- TO DO
end


net.Receive("NPCBot.Comment", function()
    local Pos = net.ReadVector()
    local Response = net.ReadString()

    EmitSound( Response, Pos, 0, CHAN_AUTO, 1, Minigames.Config["BotTalkVolume"], 0, 100 )
end)
--addons/pcasino/lua/entities/pcasino_blackjack_table/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Blackjack Table"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = false
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "StartRoundIn")
end

function ENT:GetPadByName(padName)
	if not self.padCache then
		self:GetCurrentPad(Vector(0, 0, 0)) -- Generate the cache
	end

	for i, _ in ipairs(self.padCache) do
		for k, v in pairs(_) do
			if k == padName then
				return k, v
			end
		end
	end
end

PerfectCasino.Core.RegisterEntity("pcasino_blackjack_table", {
	-- Bet data
	bet = {
		default = {d = 500, t = "num"}, -- The default bet
		max = {d = 1000, t = "num"}, -- The default bet
		min = {d = 100, t = "num"}, -- The default bet
		iteration = {d = 100, t = "num"} -- The default bet
	},
	turn = {
		timeout = {d = 30, t = "num"}
	},
	payout = {
		win = {d = 1.5, t = "num"},
		blackjack = {d = 3, t = "num"}
	},
	general = {
		betPeriod = {d = 30, t = "num"} -- The default bet
	}
},
"models/freeman/owain_blackjack_table.mdl")
--addons/pcasino/lua/entities/pcasino_roulette_table/shared.lua:
return gluapack()()
--addons/pcasino/lua/entities/pcasino_sign_interior_wall/shared.lua:
return gluapack()()
--addons/sh_keypadcracker/lua/entities/prop_sh_keypadcracker/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "Deployable Keypad Cracker"

ENT.Spawnable = false

ENT.Model = Model("models/weapons/w_c4_planted.mdl")
ENT.KeyCrackSound = Sound("buttons/blip2.wav")

function ENT:SetupDataTables()
	self:NetworkVar("Float", 0, "StartTime")
	self:NetworkVar("Float", 1, "CompletionTime")
end
--addons/realisticcardealer/lua/entities/rcd_showcase/cl_init.lua:
include("shared.lua")

--[[ Thanks to Mouloud for this part ]]
function ENT:Draw()
    self:DrawModel()
	self.vehicleInfo = self.vehicleInfo or {}

    local pos = self:GetPos()+self:GetUp()*48+self:GetForward()*12.3+self:GetRight()*-2.6
	local ang = self:GetAngles()
	
	ang:RotateAroundAxis(ang:Up(), 180)
	ang:RotateAroundAxis(ang:Forward(), 59.22)
	
	RCD.JobButtons:addView(pos, ang, self:EntIndex(), false, 0.007)
	RCD.JobButtons:drawView(RCD.CarDealerJob["calcPos"], RCD.CarDealerJob["calcAng"], 115, self:EntIndex())

	if isstring(self.vehicleInfo["model"]) then
		self.GhostEntity:SetModel((self.vehicleInfo["model"] or ""))

		if self.vehicle then
			self.GhostEntity:SetNoDraw(true)
		else
			self.GhostEntity:SetNoDraw(false)

			if self:RCDCanSpawn(self.GhostEntity) then
				self.GhostEntity:SetColor(RCD.Colors["purple"])
			else
				self.GhostEntity:SetColor(RCD.Colors["red"])
			end
		end

		if not RCD.VehiclesList or not RCD.VehiclesList[self.vehicleInfo["class"] or ""] then return end
		local addAng = RCD.VehiclesList[self.vehicleInfo["class"] or ""]["SpawnAngleOffset"] or 0
		local spawnOffset = RCD.VehiclesList[self.vehicleInfo["class"] or ""]["SpawnOffset"] or {}

		self.GhostEntity:SetPos(self:LocalToWorld(RCD.Constants["vectorShowcase"]) + Vector(0,0,(spawnOffset[3] or 0)))
		self.GhostEntity:SetAngles(self:LocalToWorldAngles(Angle(0, 90+addAng, 0)))
	end
end

function ENT:RCDCreateGhostEntity()
	if IsValid(self.GhostEntity) then return end

    self.GhostEntity = ents.CreateClientProp()
    if not IsValid(self.GhostEntity) then return end

    self.GhostEntity:Spawn()
    self.GhostEntity:SetParent(self)
    self.GhostEntity:SetMaterial("rcd_materials/model_stripes")
end

// check if the ent have space to spawn
function ENT:RCDCanSpawn(ent)
	if not IsValid(ent) then return end

    local maxL = ent:OBBMaxs()
    local minL = ent:OBBMins()

    local lenghtY = (maxL.y-minL.y)/10
    local lenghtZ = (maxL.z-minL.z)/2

    for j = 0, 1 do
        for i = 0, 10 do
            local botLeft = ent:OBBMins()
            botLeft.y = botLeft.y+lenghtY*i

            local topRight = ent:OBBMaxs()
            topRight.y = minL.y+lenghtY*i
            topRight.z = topRight.z-lenghtZ*j

            local topLeft = ent:OBBMins()
            topLeft.y = topLeft.y+lenghtY*i

            local botRight = ent:OBBMaxs()
            botRight.y = minL.y+lenghtY*i
            botRight.z = minL.z
            topLeft.z = maxL.z-lenghtZ*j

            botLeft = ent:LocalToWorld(botLeft)
            topRight = ent:LocalToWorld(topRight)
            topLeft = ent:LocalToWorld(topLeft)
            botRight = ent:LocalToWorld(botRight)

            local End = util.TraceLine({
                start = botLeft,
                endpos = topRight,
                filter = self,
            })

            local Start = util.TraceLine({
                start = topLeft,
                endpos = botRight,
                filter = self,
            })

            if End.Hit or Start.Hit then return false end
        end
    end
    return true
end

function ENT:OnRemove()
    if IsValid(self.GhostEntity) then
        self.GhostEntity:Remove()
    end
    RCD.JobButtons:removeView(self:EntIndex())
end


function RCD.loadMenuInformation(ent, vehicleId, class, price)
	RCD.JobButtons:removeView(ent:EntIndex())
	RCD.JobButtons:addView(RCD.Constants["vectorOrigin"], RCD.Constants["vectorOrigin"], ent:EntIndex(), false, 0.01)

    local layoutMenu = RCD.JobButtons:createButton()
	layoutMenu:SetSize(3550, 1700)
	layoutMenu:SetPos(0, 0)
	layoutMenu:SetIdView(ent:EntIndex())
	layoutMenu.Paint = function(self,w,h,x,y)
		surface.SetDrawColor(RCD.Colors["white255"])
		surface.SetMaterial(RCD.Materials["background"])
		surface.DrawTexturedRect(x, y, w, h)
		
        surface.SetDrawColor(RCD.Colors["white255"])
        surface.SetMaterial(RCD.Materials["logo"])
        surface.DrawTexturedRectRotated(x+w/2, y+h/2, 1000, 1000, math.sin(CurTime())*10)
		
		local base = string.upper(RCD.GetSentence("standTitle"))

		surface.SetFont("RCD3D:Font:01")
        local textSize = surface.GetTextSize(base)

		draw.DrawText(base, "RCD3D:Font:01", x+150, y+100, color_white, TEXT_ALIGN_LEFT)
		draw.DrawText(" - "..RCD.GetSentence("stand"), "RCD3D:Font:02", x+150+textSize, y+100, color_white, TEXT_ALIGN_LEFT)
        draw.DrawText(RCD.GetSentence("pressE"), "RCD3D:Font:02", x+w/2, y+h-300, color_white, TEXT_ALIGN_CENTER)
	end

	if isstring(class) then
		local vehicleList = RCD.VehiclesList or {}
		ent.vehicleInfo = {
			["model"] = vehicleList[class]["Model"],
			["name"] = vehicleList[class]["Name"],
			["class"] = class,
			["bodyGroups"] = {},
			["underglow"] = RCD.Colors["white"],
			["color"] = RCD.Colors["white"],
			["skin"] = 0,
			["price"] = price,
			["vehicleId"] = vehicleId,
			["commission"] = 30,
		}

		ent:RCDCreateGhostEntity()
	end
end

local lerpBuy, lerpSell = 0, 0
function RCD.OpenShowcaseMenu(ent, vehicleId, class)
    local vehicleList = RCD.VehiclesList or {}
	if class && not vehicleList[class] then return end

	RCD.JobButtons:removeView(ent:EntIndex())
	RCD.JobButtons:addView(RCD.Constants["vectorOrigin"], RCD.Constants["angleOrigin"], ent:EntIndex(), false, 0.01)

	local mainModel
	local layoutMenu = RCD.JobButtons:createButton()
	layoutMenu:SetSize(3550, 1700)
	layoutMenu:SetPos(0, 0)
	layoutMenu:SetIdView(ent:EntIndex())
	layoutMenu.Paint = function(self,w,h,x,y)
		surface.SetDrawColor(RCD.Colors["white255"])
		surface.SetMaterial(RCD.Materials["background"])
		surface.DrawTexturedRect(x, y, w, h)

		local base = string.upper(RCD.GetSentence("standTitle"))

		surface.SetFont("RCD3D:Font:01")
        local textSize = surface.GetTextSize(base)

		draw.DrawText(base, "RCD3D:Font:01", x+150, y+100, color_white, TEXT_ALIGN_LEFT)
		draw.DrawText(" - "..RCD.GetSentence("stand"), "RCD3D:Font:02", x+150+textSize, y+100, color_white, TEXT_ALIGN_LEFT)

		if mainModel then
			if not mainModel.customMaterial then return end
			mainModel.Updated = false
			surface.SetDrawColor(RCD.Colors["white255"])
			surface.SetMaterial(mainModel.customMaterial)
			surface.DrawTexturedRect(x+w/5-1000, y+h/2-1000, 2000, 2000, 0)
		end

		draw.DrawText(ent.vehicleInfo["name"].." ("..RCD.formatMoney((ent.vehicleInfo["price"] or 0))..")" or "", "RCD3D:Font:03", x+w/5, y+h-250, color_white, TEXT_ALIGN_CENTER)
	end

	mainModel = RCD.JobButtons:createButton()
	mainModel:SetSize(4000, 4000)
	mainModel:SetPos(0, 0)
	mainModel:SetFOV(40)
	mainModel:CreateDModelPanel(ent.vehicleInfo["model"])
	mainModel:AddRemoveParent(layoutMenu)
	mainModel:SetIdView(ent:EntIndex())
	mainModel.PaintManual = true
	mainModel.Paint = function(self,w,h,x,y) end

	local layoutPurchase = RCD.JobButtons:createButton()
	layoutPurchase:SetSize(1900, 1200)
	layoutPurchase:SetPos(1500, 150)
	layoutPurchase:SetIdView(ent:EntIndex())
	layoutPurchase:CreateLayout(frame, 0, 25, 25, 10, -10)
	layoutPurchase.Paint = function(self,w,h,x,y) end

	local modelCars = {}
	local layoutCar
	
    local idModel = 1
	for k, v in pairs(RCD.AdvancedConfiguration["vehiclesList"]) do
		local options = v.options or {}
		if not options["canSellWithJob"] then continue end

		modelCars[k] = modelCars[k] or {}

		local modelCars1 = RCD.JobButtons:createButton()
		modelCars1:SetSize(4000, 4000)
		modelCars1:SetPos(0, 0)
		modelCars1:SetFOV(40)
		modelCars1:CreateDModelPanel(vehicleList[v.class]["Model"])
		modelCars1:AddRemoveParent(layoutMenu)
		modelCars1:SetIdView(ent:EntIndex())
		modelCars1.PaintManual = true
		modelCars1.Paint = function(self,w,h,x,y) end

		modelCars[k][1]	= modelCars1
        modelCars[k].id = idModel
		
		local modelCars2 = RCD.JobButtons:createButton()
		modelCars2:SetSize(350, 350)
		modelCars2:SetPos(1525+((modelCars[k].id-1)%5)*(350+25), 10000)
		modelCars2:SetIdView(ent:EntIndex())
		modelCars2.PaintManual = true
		modelCars2.lerp = 0
		modelCars2.Paint = function(self,w,h,x,y)
			self.lerp = Lerp(FrameTime()*5, self.lerp, (self:IsHovered() and 30 or 50))

			self.y = (layoutCar.y or 0)+125+math.floor((modelCars[k].id-1)/5)*375
			draw.RoundedBox(10, x, y, w, h, ColorAlpha(RCD.Colors["grey134"], self.lerp))
		end
		modelCars2.DoClick = function()
			ent.vehicleInfo = {
				["model"] = vehicleList[v.class]["Model"],
				["name"] = vehicleList[v.class]["Name"],
				["class"] = v.class,
				["price"] = v.price,
				["bodyGroups"] = {},
				["underglow"] = RCD.Colors["white"],
				["color"] = RCD.Colors["white"],
				["skin"] = 0,
				["vehicleId"] = k,
				["commission"] = 30,
			}
			RCD.OpenShowcaseMenu(ent, k, v.class)
		end

		modelCars[k][2]	= modelCars2
        idModel = idModel + 1
	end

	layoutCar = RCD.JobButtons:createButton()
	layoutCar:SetSize(1900, 100)
	layoutCar:SetPos(1500, 150)
	layoutCar:SetOpenSize(125+math.ceil((idModel-1)/5)*375)
	layoutCar.Paint = function(self,w,h,x,y)
		surface.SetDrawColor(RCD.Colors["grey10020"])
		surface.DrawRect(x, y, w, 100)

		draw.DrawText(RCD.GetSentence("buyVehicle"), "RCD3D:Font:05", x+30, y+12, color_white, TEXT_ALIGN_LEFT)

		surface.SetDrawColor(RCD.Colors["grey10010"])
		surface.DrawRect(x, y+100, w, h-100)

		for k, v in pairs(RCD.AdvancedConfiguration["vehiclesList"]) do
			if !modelCars[k] then continue end

			if modelCars[k][1] && modelCars[k][2] then
				local btn = modelCars[k][2]
				btn:Paint(btn.w, btn.h, btn.x, btn.y)

				surface.SetDrawColor(RCD.Colors["white255"])
				surface.SetMaterial(modelCars[k][1].customMaterial)
				surface.DrawTexturedRect(btn.x+btn.w/2-300, btn.y+btn.h/2-300, 600, 600)
			end
		end
	end
	layoutCar.DoClick = function(self)
		if modelCars then
			for _,panel in pairs(modelCars) do
				if panel[2]:IsHovered() then
					if panel[2].DoClick then
						panel[2]:DoClick()
					end
					return
				end
			end
		end

		self:SetOpen(!self:GetOpen())
		ent.layoutCarOpen = self:GetOpen()
	end
	if ent.layoutCarOpen then
		layoutCar:SetOpen(true)
		layoutCar.h = layoutCar:GetOpenSize()
	end

	layoutPurchase:AddToLayout(layoutCar)

	local layoutColor1, layoutColor2
	
	local bodyChildren = {}
	local layoutBody = RCD.JobButtons:createButton()
	layoutBody:SetSize(925, 100)
	layoutBody:SetPos(1500, 150)
	layoutBody:SetOpenSize(600)
	layoutBody.line = true
	layoutBody.Paint = function(self,w,h,x,y)
		surface.SetDrawColor(RCD.Colors["grey10020"])
		surface.DrawRect(x, y, w, 100)

		draw.DrawText(RCD.GetSentence("bodygroups"), "RCD3D:Font:05", x+30, y+12, color_white, TEXT_ALIGN_LEFT)

		surface.SetDrawColor(RCD.Colors["grey10010"])
		surface.DrawRect(x, y+100, w, h-100)
		for k, v in pairs(bodyChildren) do
			v[0]:Paint(v[0].w, v[0].h, v[0].x, v[0].y)

			for kk, panel in pairs(v) do
				if kk == 0 then continue end
				panel:Paint(panel.w, panel.h, panel.x, panel.y)
			end
		end
	end
	layoutBody.DoClick = function(self)
		if bodyChildren then
			for _,v in pairs(bodyChildren) do
				for _, panel in pairs(v) do
					if panel:IsHovered() then
						if panel.DoClick then
							panel:DoClick()
						end
						return
					end
				end
			end
		end
		local Open = !self:GetOpen()
		layoutBody:SetOpen(Open)
		layoutColor1:SetOpen(Open)
		layoutColor2:SetOpen(Open)
		ent.layoutColorOpen = Open
	end
	layoutPurchase:AddToLayout(layoutBody)

	local id = 1
	local sizeY = 100

	for k, v in pairs(mainModel.Model:GetBodyGroups()) do
		if #v.submodels < 1 then continue end

		bodyChildren[id] = {}
		bodyChildren[id][0] = RCD.JobButtons:createButton()
		bodyChildren[id][0]:SetSize(925, 70)
		bodyChildren[id][0]:SetPos(1500, 0)
		bodyChildren[id][0]:SetIdView(ent:EntIndex())
		bodyChildren[id][0].id = id
		bodyChildren[id][0].moveY = sizeY-100
		bodyChildren[id][0].PaintManual = true
		bodyChildren[id][0].Paint = function(self,w,h,x,y)
			self.y = layoutBody.y+110+self.moveY
			draw.DrawText(v.name, "RCD3D:Font:06", x+30, y, color_white, TEXT_ALIGN_LEFT)
		end
		
		local countY, moveY = 0, 0
		local modelCount = #v.submodels

		for i = 0, modelCount do
			bodyChildren[id][i+1] = RCD.JobButtons:createButton()
			bodyChildren[id][i+1]:SetSize(70, 70)
			bodyChildren[id][i+1]:SetPos(1525+countY*80, 0)
			bodyChildren[id][i+1]:SetIdView(ent:EntIndex())
			bodyChildren[id][i+1].Parent = bodyChildren[id][0]
			bodyChildren[id][i+1].moveY = moveY
			bodyChildren[id][i+1].PaintManual = true
			bodyChildren[id][i+1].Paint = function(self,w,h,x,y)
				self.y = self.Parent.y+60+self.moveY
				if self:IsHovered() or ent.vehicleInfo["bodyGroups"][v.id] == i then
					draw.RoundedBox(4, x, y, w, h, RCD.Colors["purple99"])
				else
					draw.RoundedBox(4, x, y, w, h, RCD.Colors["purple55"])
				end
				draw.DrawText(i, "RCD3D:Font:06", x+w/2, y+10, color_white, TEXT_ALIGN_CENTER)
			end
			bodyChildren[id][i+1].DoClick = function()
				mainModel.Model:SetBodygroup(v.id, i)
				ent.vehicleInfo["bodyGroups"][v.id] = i
			end
			
			countY = countY+1
			if countY == 11 then
				countY = 0
				moveY = moveY+80
			end
		end

		sizeY = sizeY+70+math.ceil(modelCount/11)*90
		id = id+1
	end

    mainModel.Model:SetColor(ent.vehicleInfo["color"])
    mainModel.Model:SetSkin(ent.vehicleInfo["skin"])
    for k, v in pairs(ent.vehicleInfo["bodyGroups"]) do
        mainModel.Model:SetBodygroup(k, v)
    end

	local colorChildren1 = {}

	layoutColor1 = RCD.JobButtons:createButton()
	layoutColor1:SetSize(472.5, 100)
	layoutColor1:SetPos(2450, 150)
	layoutColor1:SetOpenSize(600)
	layoutColor1.line = true
	layoutColor1.Paint = function(self, w, h, x, y)
		surface.SetDrawColor(RCD.Colors["grey10020"])
		surface.DrawRect(x, y, w, 100)
		draw.DrawText(RCD.GetSentence("colors"), "RCD3D:Font:05", x+30, y+12, color_white, TEXT_ALIGN_LEFT)

		surface.SetDrawColor(RCD.Colors["grey10010"])
		surface.DrawRect(x, y+100, w, h-100)

		for _, panel in pairs(colorChildren1) do
			panel:Paint(panel.w, panel.h, panel.x, panel.y)
		end
	end

	layoutColor1.DoClick = function(self)
		if colorChildren1 then
			for _,panel in pairs(colorChildren1) do
				if panel:IsHovered() then
					if panel.DoClick then
						panel:DoClick()
					end
					return
				end
			end
		end
		local Open = !self:GetOpen()
		layoutBody:SetOpen(Open)
		layoutColor1:SetOpen(Open)
		layoutColor2:SetOpen(Open)
		ent.layoutColorOpen = Open
	end

	colorChildren1[0] = RCD.JobButtons:createButton()
	colorChildren1[0]:SetSize(393, 393)
	colorChildren1[0]:SetPos(2450+472.5/2-393/2, 10000)
	colorChildren1[0]:SetIdView(ent:EntIndex())
	colorChildren1[0].PaintManual = true
	colorChildren1[0].posMouse = {colorChildren1[0]:GetWide()/2, colorChildren1[0]:GetTall()/2}
	colorChildren1[0].Paint = function(self, w, h, x, y)
		self.y = layoutColor1.y+150
		surface.SetDrawColor(RCD.Colors["white255"])
		surface.SetMaterial(RCD.Materials["color_circle"])
		surface.DrawTexturedRect(x, y, w, h)

		local cx, cy = RCD.JobButtons:getXCursor(0.007)-x, RCD.JobButtons:getYCursor(0.007)-y

		surface.SetDrawColor(Color(0, 0, 0))
		draw.NoTexture()
		RCD.DrawSimpleCircle(x+self.posMouse[1], y+self.posMouse[2], 20, 30)

		surface.SetDrawColor(ent.vehicleInfo["color"] or self.m_color or color_white)
		draw.NoTexture()
		RCD.DrawSimpleCircle(x+self.posMouse[1], y+self.posMouse[2], 15, 30)

		if self.DragStart then
			if !input.IsMouseDown(MOUSE_LEFT) then
				self.DragStart = false
			end
			local ang = math.atan2( cy-h / 2, cx-w / 2 )
			local dist = math.Distance(w/2, h/2, cx, cy)
			if dist <= w/2 then
				dist = dist / w
				ang = ang+math.pi
				ang = -ang

				self.m_color = HSVToColor( math.deg( ang ) > 0 and math.deg( ang ) or math.abs( math.deg( ang )-180 ), dist*2, 1)
				self.posMouse = {cx, cy}
				mainModel.Model:SetColor(self.m_color)

				ent.vehicleInfo["color"] = self.m_color
			end
		else
			local n, s, r = ColorToHSV(ent.vehicleInfo["color"])
			local rad = math.rad(n)
			self.posMouse = {w/2+math.cos(rad)*(s*w/2), h/2+math.sin(rad)*(s*w/2)}
		end
	end
	colorChildren1[0].DoClick = function(self)
		self.DragStart = true
	end

	for k, v in pairs(RCD.ColorPaletteColors) do
		colorChildren1[k] = RCD.JobButtons:createButton()
		colorChildren1[k]:SetSize(50, 50)
		colorChildren1[k]:SetPos(2460+((k-1)%9)*50, 10000)
		colorChildren1[k]:SetIdView(ent:EntIndex())
		colorChildren1[k].id = k
		colorChildren1[k].PaintManual = true
		colorChildren1[k].Paint = function(self, w, h, x, y)
			self.y = layoutColor1.y+600+math.floor((self.id-1)/9)*50
			surface.SetDrawColor(v)
			draw.NoTexture()
			RCD.DrawSimpleCircle(x+w/2, y+h/2, 20, 30)
		end
		colorChildren1[k].DoClick = function()
			mainModel.Model:SetColor(v)

			ent.vehicleInfo["color"] = v
		end
	end
	layoutPurchase:AddToLayout(layoutColor1)

	local colorChildren2 = {}

	layoutColor2 = RCD.JobButtons:createButton()
	layoutColor2:SetSize(472.5, 100)
	layoutColor2:SetPos(2925+12.5, 150)
	layoutColor2:SetOpenSize(600)
	layoutColor2.Paint = function(self,w,h,x,y)

		surface.SetDrawColor(RCD.Colors["grey10020"])
		surface.DrawRect(x, y, w, 100)
		draw.DrawText(RCD.GetSentence("underglow"), "RCD3D:Font:05", x+30, y+12, self.m_color or color_white, TEXT_ALIGN_LEFT)

		surface.SetDrawColor(RCD.Colors["grey10010"])
		surface.DrawRect(x, y+100, w, h-100)

		for _, panel in pairs(colorChildren2) do
			panel:Paint(panel.w, panel.h, panel.x, panel.y)
		end
	end

	layoutColor2.DoClick = function(self)
		if colorChildren2 then
			for _,panel in pairs(colorChildren2) do
				if panel:IsHovered() then
					if panel.DoClick then
						panel:DoClick()
					end
					return
				end
			end
		end
		local Open = !self:GetOpen()
		
		layoutBody:SetOpen(Open)
		layoutColor1:SetOpen(Open)
		layoutColor2:SetOpen(Open)
		ent.layoutColorOpen = Open
	end

	colorChildren2[0] = RCD.JobButtons:createButton()
	colorChildren2[0]:SetSize(393, 393)
	colorChildren2[0]:SetPos(3173-393/2, 10000)
	colorChildren2[0]:SetIdView(ent:EntIndex())
	colorChildren2[0].PaintManual = true
	colorChildren2[0].posMouse = {colorChildren2[0]:GetWide()/2, colorChildren2[0]:GetTall()/2}
	colorChildren2[0].Paint = function(self,w,h,x,y)
		self.y = layoutColor2.y+150
		surface.SetDrawColor(RCD.Colors["white255"])
		surface.SetMaterial(RCD.Materials["color_circle"])
		surface.DrawTexturedRect(x, y, w, h)

		local cx, cy = RCD.JobButtons:getXCursor(0.007)-x, RCD.JobButtons:getYCursor(0.007)-y

		surface.SetDrawColor(RCD.Colors["black"])
		draw.NoTexture()
		RCD.DrawSimpleCircle(x+self.posMouse[1], y+self.posMouse[2], 20, 30)

		surface.SetDrawColor(ent.vehicleInfo["underglow"] or self.m_color or color_white)
		draw.NoTexture()
		RCD.DrawSimpleCircle(x+self.posMouse[1], y+self.posMouse[2], 15, 30)

		if self.DragStart then
			if not input.IsMouseDown(MOUSE_LEFT) then
				self.DragStart = false
			end
			local ang = math.atan2(cy-h/2, cx-w/2)
			local dist = math.Distance(w/2, h/2, cx, cy)
			if dist <= w/2 then
				dist = dist/w
				ang = ang+math.pi
				ang = -ang

				self.m_color = HSVToColor(math.deg(ang) > 0 and math.deg(ang) or math.abs(math.deg(ang)-180), dist*2, 1)
				self.posMouse = {cx, cy}

				ent.vehicleInfo["underglow"] = self.m_color
			end
		else
			local n, s, r = ColorToHSV(ent.vehicleInfo["underglow"])
			local rad = math.rad(n)
			self.posMouse = {w/2+math.cos(rad)*(s*w/2), h/2+math.sin(rad)*(s*w/2)}
		end
	end
	colorChildren2[0].DoClick = function(self)
		self.DragStart = true
	end

	for k, v in pairs(RCD.ColorPaletteColors) do
		colorChildren2[k] = RCD.JobButtons:createButton()
		colorChildren2[k]:SetSize(50, 50)
		colorChildren2[k]:SetPos(2945+((k-1)%9)*50, 10000)
		colorChildren2[k]:SetIdView(ent:EntIndex())
		colorChildren2[k].id = k
		colorChildren2[k].PaintManual = true
		colorChildren2[k].Paint = function(self,w,h,x,y)
			self.y = layoutColor2.y+600+math.floor((self.id-1)/9)*50
			surface.SetDrawColor(v)
			draw.NoTexture()
			RCD.DrawSimpleCircle(x+w/2, y+h/2, 20, 30)
		end
		colorChildren2[k].DoClick = function()
			mainModel.Model:SetColor(v)
			ent.vehicleInfo["underglow"] = v
		end
	end
	layoutPurchase:AddToLayout(layoutColor2)

	sizeY = math.max(sizeY, 915)
	layoutBody:SetOpenSize(sizeY)
	layoutColor1:SetOpenSize(sizeY)
	layoutColor2:SetOpenSize(sizeY)

	if ent.layoutColorOpen then
		layoutBody:SetOpen(true)
		layoutColor1:SetOpen(true)
		layoutColor2:SetOpen(true)

		layoutBody.h = layoutBody:GetOpenSize()
		layoutColor1.h = layoutColor1:GetOpenSize()
		layoutColor2.h = layoutColor2:GetOpenSize()
	end

	local skinChildren = {}
	local layoutSkin = RCD.JobButtons:createButton()
	layoutSkin:SetSize(1900, 100)
	layoutSkin:SetPos(1500, 150)
	layoutSkin:SetOpenSize(200)
	layoutSkin.Paint = function(self,w,h,x,y)
		surface.SetDrawColor(RCD.Colors["grey10020"])
		surface.DrawRect(x, y, w, 100)

		draw.DrawText(RCD.GetSentence("skins"), "RCD3D:Font:05", x+30, y+12, color_white, TEXT_ALIGN_LEFT)

		surface.SetDrawColor(RCD.Colors["grey10010"])
		surface.DrawRect(x, y+100, w, h-100)
		
		for _, panel in pairs(skinChildren) do
			panel:Paint(panel.w, panel.h, panel.x, panel.y)
		end
	end
	layoutSkin.DoClick = function(self)
		if skinChildren then
			for _,panel in pairs(skinChildren) do
				if panel:IsHovered() then
					if panel.DoClick then
						panel:DoClick()
					end
					return
				end
			end
		end
		self:SetOpen(!self:GetOpen())
		ent.layoutSkinOpen = self:GetOpen()
	end
	layoutPurchase:AddToLayout(layoutSkin)

	if ent.layoutSkinOpen then
		layoutSkin:SetOpen(true)
		layoutSkin.h = layoutSkin:GetOpenSize()
	end

	for i = 0, mainModel.Model:SkinCount()-1 do
		skinChildren[i] = RCD.JobButtons:createButton()
		skinChildren[i]:SetSize(70, 70)
		skinChildren[i]:SetPos(1525+i*80, 0)
		skinChildren[i]:SetIdView(ent:EntIndex())
		skinChildren[i].PaintManual = true
		skinChildren[i].Paint = function(self,w,h,x,y)
			self.y = layoutSkin.y+115
			if self:IsHovered() or ent.vehicleInfo["skin"] == i then
				draw.RoundedBox(4, x, y, w, h, RCD.Colors["purple99"])
			else
				draw.RoundedBox(4, x, y, w, h, RCD.Colors["purple55"])
			end
			draw.DrawText(i, "RCD3D:Font:06", x+w/2, y+10, color_white, TEXT_ALIGN_CENTER)
		end
		skinChildren[i].DoClick = function()
			mainModel.Model:SetSkin(i)
			ent.vehicleInfo["skin"] = i
		end
	end

	local sliderB
	local layoutPrice = RCD.JobButtons:createButton()
	layoutPrice:SetSize(1900, 100)
	layoutPrice:SetPos(1500, 150)
	layoutPrice:SetOpenSize(200)
	layoutPrice.Paint = function(self,w,h,x,y)
		surface.SetDrawColor(RCD.Colors["grey10020"])
		surface.DrawRect(x, y, w, 100)
		draw.DrawText(RCD.GetSentence("yourCommission"), "RCD3D:Font:05", x+30, y+12, color_white, TEXT_ALIGN_LEFT)

		surface.SetDrawColor(RCD.Colors["grey10010"])
		surface.DrawRect(x, y+100, w, h-100)

		draw.RoundedBox(10, x+50, y+150, (sliderB.x-1475)-50, 10, RCD.Colors["purple55"])
		draw.RoundedBox(10, x+(sliderB.x-1475), y+150, w-(sliderB.x-1475)-50, 10, RCD.Colors["grey"])
		sliderB:Paint(sliderB.w, sliderB.h, sliderB.x, sliderB.y)
	end
	layoutPrice.DoClick = function(self)
		if sliderB && sliderB:IsHovered() then
			sliderB:DoClick()
		else
			self:SetOpen(!self:GetOpen())
			ent.layoutPriceOpen = self:GetOpen()
		end
	end

	if ent.layoutPriceOpen then
		layoutPrice:SetOpen(true)
		layoutPrice.h = layoutPrice:GetOpenSize()
	end

	local vehicleTable = RCD.AdvancedConfiguration["vehiclesList"][ent.vehicleInfo["vehicleId"]] or {}
	vehicleTable["options"] = vehicleTable["options"] or {}

	local min, max = (vehicleTable["options"]["minCommissionPrice"] or 0), (vehicleTable["options"]["maxCommissionPrice"] or 1000)
	local commission = ent.vehicleInfo["commission"]

	sliderB = RCD.JobButtons:createButton()
	sliderB:SetSize(50, 50)
	sliderB:SetPos(1600, 0)
	sliderB:SetIdView(ent:EntIndex())
	sliderB.PaintManual = true
	sliderB.Paint = function(self,w,h,x,y)
		self.y = layoutPrice.y+130

		surface.SetDrawColor(RCD.Colors["white255"])
		draw.NoTexture()
		RCD.DrawSimpleCircle(x+w/2, y+h/2, 20, 30)

		local ratio = (self.x-1550)/(3325-1550)

		if self.StartGrag then
			if !input.IsMouseDown(MOUSE_LEFT) then
				self.StartGrag = false
				return
			end
			self.x = math.Clamp(RCD.JobButtons:getXCursor(0.007), 1550, 3325)
			commission = math.Round(ratio, 2)*max
		else
			self.x = ((commission-min)/(max-min))*(3325-1550)+1550
		end
		draw.DrawText(RCD.formatMoney(commission), "RCD3D:Font:05", 3350, y-115, RCD.Colors["white200255"], TEXT_ALIGN_RIGHT)
	end
	sliderB.DoClick = function(self)
		self.StartGrag = true
	end

	layoutPurchase:AddToLayout(layoutPrice)

	local vehicleBought = ent.vehicle

	local buyBtn = RCD.JobButtons:createButton()
	buyBtn:SetSize((vehicleBought and 945 or 1900), 150)
	buyBtn:SetPos(1500, 1450)
	buyBtn:SetIdView(ent:EntIndex())
	buyBtn.Paint = function(self,w,h,x,y)
		lerpBuy = Lerp(FrameTime()*5, lerpBuy, (self:IsHovered() and 150 or 255))

		draw.RoundedBox(10, x, y, w, h, ColorAlpha(RCD.Colors["purple55"], lerpBuy))
		draw.DrawText(vehicleBought and RCD.GetSentence("saveRentInformation") or RCD.GetSentence("rentVehicle"):format(RCD.formatMoney((vehicleTable["options"]["rentPrice"] or 0))), "RCD3D:Font:04", x+160, y+23, color_white, TEXT_ALIGN_LEFT)

		surface.SetDrawColor(RCD.Colors["grey10050"])
		draw.NoTexture()
		RCD.DrawSimpleCircle(x+h/2, y+h/2, h/3, 30)

		surface.SetDrawColor(RCD.Colors["white250250"])
		surface.SetMaterial(RCD.Materials["icon_money"])
		surface.DrawTexturedRect(x+h/2-h/8, y+h/2-h/8, h/4, h/4)
	end
	buyBtn.DoClick = function()
		if (not ent.GhostEntity:GetNoDraw() && not ent:RCDCanSpawn(ent.GhostEntity)) then RCD.Notification(5, RCD.GetSentence("rentVehicleSpace")) return end

		local vehicleColor = Color((ent.vehicleInfo["color"].r or 255), (ent.vehicleInfo["color"].g or 255), (ent.vehicleInfo["color"].b or 255))
		local neonColor = Color((ent.vehicleInfo["underglow"].r or 255), (ent.vehicleInfo["underglow"].g or 255), (ent.vehicleInfo["underglow"].b or 255))
		local bodyGroups = ent.vehicleInfo["bodyGroups"]

		ent.vehicleInfo["commission"] = commission

		net.Start("RCD:Main:Job")
			net.WriteUInt(2, 4)
			net.WriteEntity(ent)
			net.WriteUInt(ent.vehicleInfo["vehicleId"], 32)
			net.WriteUInt(ent.vehicleInfo["commission"], 32)
			net.WriteUInt((ent.vehicleInfo["skin"] or 0), 8)
			net.WriteColor(vehicleColor)
			net.WriteColor(neonColor)
			net.WriteUInt(table.Count(bodyGroups), 8)
			for k,v in pairs(bodyGroups) do
				net.WriteUInt(k, 8)
				net.WriteUInt(v, 8)
			end
		net.SendToServer()
	end

	if vehicleBought then
		local sellBtn = RCD.JobButtons:createButton()
		sellBtn:SetSize((vehicleBought and 945 or 1900), 150)
		sellBtn:SetPos(2470, 1450)
		sellBtn:SetIdView(ent:EntIndex())
		sellBtn.Paint = function(self,w,h,x,y)
			lerpSell = Lerp(FrameTime()*5, lerpSell, (self:IsHovered() and 150 or 255))

			draw.RoundedBox(10, x, y, w, h, ColorAlpha(RCD.Colors["purple55"], lerpSell))
			draw.DrawText(RCD.GetSentence("bringBack"), "RCD3D:Font:04", x+160, y+23, color_white, TEXT_ALIGN_LEFT)

			surface.SetDrawColor(RCD.Colors["grey10050"])
			draw.NoTexture()
			RCD.DrawSimpleCircle(x+h/2, y+h/2, h/3, 30)

			surface.SetDrawColor(RCD.Colors["white250250"])
			surface.SetMaterial(RCD.Materials["icon_leave"])
			surface.DrawTexturedRect(x+h/2-h/8, y+h/2-h/8, h/4, h/4)
		end
		sellBtn.DoClick = function()
			net.Start("RCD:Main:Job")
				net.WriteUInt(3, 4)
				net.WriteEntity(ent)
			net.SendToServer()
		end
	end
end

hook.Add("DrawPhysgunBeam", "RCD:Debug:3D2D", function(_, _, _, ent)
    if IsValid(ent) && ent:GetClass() == "rcd_showcase" then
        return false
    end
end)

function ENT:Initialize()
	RCD.loadMenuInformation(self)
end
--addons/skeypad_1.2.36/lua/entities/s_deployable_cracker/shared.lua:
return gluapack()()
--addons/skeypad_1.2.36/lua/entities/s_keypad/shared.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/entities/sade_pilav/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Sade Pilav"
ENT.Category = "Turkish Food Mod"
ENT.Spawnable = true
--lua/entities/sammyservers_textscreen/cl_init.lua:
return gluapack()()
--addons/serious_business/lua/entities/sb_crime_guide/cl_init.lua:
/*----------------------------------------------------------------------
Leak by Famouse

Play good games:↓
http://store.steampowered.com/curator/32364216

Subscribe to the channel:↓
www.youtube.com/c/Famouse

More leaks in the discord:↓ 
discord.gg/rFdQwzm
------------------------------------------------------------------------*/

include("shared.lua");

surface.CreateFont("SB_Guide_Icon", {
	font = "Webdings",
	size = 256,
	weight = 100,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = true,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false
});

surface.CreateFont("SB_Guide_Text", {
	font = "Tahoma",
	size = 32,
	weight = 800,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false
});

function ENT:Initialize()	

end;

function ENT:Think()

end;

function ENT:Draw()
	self:DrawModel();
	
	local camPos = self:WorldSpaceCenter();
	local camAng = self:GetAngles();
	
	camAng:RotateAroundAxis(camAng:Up(), 180);
	camAng:RotateAroundAxis(camAng:Forward(), 90);	
	camAng:RotateAroundAxis(camAng:Right(), 0);

	if (LocalPlayer():GetPos():Distance(self:GetPos()) < SeriousBusiness_Config.DrawDistance) then
		cam.Start3D2D(camPos+camAng:Up()*1.50, camAng, 0.075)
			draw.RoundedBox(0, -64, -64-8, 128, 128+8, Color(0, 0, 0, 200));
			draw.SimpleText("L", "SB_Guide_Icon", 0, 0, Color(255, 255, 255, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
		cam.End3D2D();

		cam.Start3D2D(camPos+camAng:Up()*1.50, camAng, 0.035)
			draw.SimpleText("Crime for Dummies", "SB_Guide_Text", 0, -128, Color(255, 255, 255, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
		cam.End3D2D();
	end;
end;

/*------------------------------------------------------------------------
Donation for leaks

Qiwi Wallet         4890494419811120 
YandexMoney         410013095053302
WebMoney(WMR)       R235985364414
WebMoney(WMZ)       Z309855690994
------------------------------------------------------------------------*/
--addons/serious_business/lua/entities/sb_wk_place/cl_init.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/entities/sckegg/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Sucuklu Yumurta"
ENT.Category = "Turkish Food Mod"
ENT.Spawnable = true
--addons/turkish_food_mod-main/lua/entities/stone_oven/shared.lua:
return gluapack()()
--lua/entities/sv_health_kit/shared.lua:
ENT.Base = "base_entity"
ENT.Type = "anim"

ENT.PrintName = "Health Kit"
ENT.Category = "SVMod"
ENT.Author = "TomLaVachette & Seefox"
ENT.Contact = "From workshop page only!"
ENT.Instructions = "Touch a vehicle with the kit to repair the vehicle."

ENT.Spawnable = true
ENT.AdminOnly = true
--lua/entities/sv_repair/shared.lua:
ENT.Base = "base_ai"
ENT.Type = "ai"

ENT.PrintName		= "Repair"
ENT.Category		= "SVMod" 
ENT.Author 			= "Seefox"
ENT.Contact	= "From workshop page only!"
ENT.Instructions = "Use to repair the vehicle."

ENT.Spawnable		= true
ENT.AdminSpawnable		= true
ENT.AutomaticFrameAdvance = true

function ENT:SetAutomaticFrameAdvance(bUsingAnim)
	self.AutomaticFrameAdvance = bUsingAnim
end
--lua/entities/sv_spikestrip/cl_init.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/entities/tavuklu_pilav/cl_init.lua:
return gluapack()()
--addons/zerosfruitslicer/lua/entities/zfs_smoothie/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = true
ENT.RenderGroup = RENDERGROUP_OPAQUE
ENT.PrintName = "Smoothie"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "info"
ENT.Category = "Zeros FruitSlicer"
ENT.Model = "models/zerochain/fruitslicerjob/fs_fruitcup.mdl"
function ENT:CanProperty(ply)
    return ply:IsSuperAdmin()
end

function ENT:CanTool(ply, tab, str)
    return ply:IsSuperAdmin()
end

function ENT:CanDrive(ply)
    return false
end

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "ProductID")
	self:NetworkVar("Int", 1, "ToppingID")

	if SERVER then
		self:SetProductID(1)
		self:SetToppingID(1)
	end
end

--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_crate/shared.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

ENT.Type                    = "anim"
ENT.Base                    = "base_anim"
ENT.AutomaticFrameAdvance   = false
ENT.PrintName               = "Crate"
ENT.Author                  = "ZeroChain"
ENT.Category                = "Zeros GrowOP 2"
ENT.Spawnable               = true
ENT.AdminSpawnable          = false
ENT.Model                   = "models/zerochain/props_growop2/zgo2_crate.mdl"
ENT.RenderGroup             = RENDERGROUP_OPAQUE
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- a0e6ade09fe02808a86c0dfaee2704d791bcc0344cd386f9ebfd43c1dd1de59e

function ENT:CanProperty(ply)
    return ply:IsSuperAdmin()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586

function ENT:CanTool(ply, tab, str)
    return ply:IsSuperAdmin()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224595

function ENT:CanDrive(ply)
    return false
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 5f074b2717244cb0b28afc4f82cbfebeed301ee81f5a05ae65232daad257b16a

--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_item_base/shared.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_joint_ent/shared.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_lamp/shared.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_npc_export/shared.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

ENT.Type                    = "ai"
ENT.Base                    = "base_ai"
ENT.AutomaticFrameAdvance   = true
ENT.PrintName               = "Export Manager"
ENT.Author                  = "ZeroChain"
ENT.Category                = "Zeros GrowOP 2"
ENT.Spawnable               = true
ENT.AdminSpawnable          = false
ENT.RenderGroup             = RENDERGROUP_BOTH
ENT.Model 					= "models/odessa.mdl"
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224595
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 8ffb188c701d3f1856df3a15bfe8e14b5be84a41e03a52af8e86de4fbee82eeb
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586

--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_packer/cl_init.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

include("shared.lua")

function ENT:Initialize()
	zgo2.Packer.Initialize(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 8ffb188c701d3f1856df3a15bfe8e14b5be84a41e03a52af8e86de4fbee82eeb

function ENT:Draw()
	self:DrawModel()
	zgo2.Packer.OnDraw(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586

function ENT:Think()
	zgo2.Packer.OnThink(self)
	self:SetNextClientThink(CurTime())
	return true
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- c360111a1078b749c222565727765c993fb6b426190023d6d23362bac0c7683a

function ENT:OnRemove()
	zgo2.Packer.OnRemove(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586

--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_plant/cl_init.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_plant/shared.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

ENT.Type                    = "anim"
ENT.Base                    = "base_anim"
ENT.AutomaticFrameAdvance   = false
ENT.PrintName               = "Plant"
ENT.Author                  = "ZeroChain"
ENT.Category                = "Zeros GrowOP 2"
ENT.Spawnable               = false
ENT.AdminSpawnable          = false
ENT.Model                   = "models/zerochain/props_growop2/zgo2_plant01.mdl"
ENT.RenderGroup             = RENDERGROUP_TRANSLUCENT

function ENT:SetupDataTables()

	// Id to the plant config
	self:NetworkVar("Int", 0, "PlantID")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224595

	// How much THC do we currently have
	self:NetworkVar("Int", 3, "GrowCompletedTime")

	// Time in seconds till its fully grown
	self:NetworkVar("Int", 1, "GrowProgress")

	// Amount of light the plant is getting
	self:NetworkVar("Int", 2, "LightLevel")
	/*
		0 = No Light
		1 = Enough Light
		2 = Too much light
		3 = Wrong Color
	*/

	if (SERVER) then
		self:SetPlantID(0)
		self:SetGrowProgress(0)
		self:SetLightLevel(0)
		self:SetGrowCompletedTime(0)
	end
end

function ENT:CanProperty(ply)
    return ply:IsSuperAdmin()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586

function ENT:CanTool(ply, tab, str)
    return ply:IsSuperAdmin()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224595
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586

function ENT:CanDrive(ply)
    return false
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586

--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_pot/shared.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_rack/cl_init.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

include("shared.lua")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586

function ENT:Initialize()

end

function ENT:Draw()
	self:DrawModel()
	/*
	// NOTE For debugging
	local dat = zgo2.Rack.GetData(self:GetRackID())
	for k,v in pairs(dat.PotPositions) do
		debugoverlay.Sphere(self:LocalToWorld(v),5,0.1,Color( 0, 255, 0 ),true)
	end
	*/
end

function ENT:OnRemove()

end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224595
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 70b873f322570e153a05d9cee15c50a5d97bffffec86f684a14bf17014b60342
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- a0e6ade09fe02808a86c0dfaee2704d791bcc0344cd386f9ebfd43c1dd1de59e

--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_seed/shared.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_soil.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

AddCSLuaFile()
DEFINE_BASECLASS("zgo2_item_base")
ENT.Type                    = "anim"
ENT.Base                    = "zgo2_item_base"
ENT.AutomaticFrameAdvance   = false
ENT.PrintName               = "Soil"
ENT.Author                  = "ZeroChain"
ENT.Category                = "Zeros GrowOP 2"
ENT.Spawnable               = true
ENT.AdminSpawnable          = false
ENT.Model                   = "models/zerochain/props_growop2/zgo2_soil.mdl"
ENT.RenderGroup             = RENDERGROUP_OPAQUE

if SERVER then
	function ENT:AcceptInput(inputName, activator, caller, data)
		if inputName == "Use" and IsValid(activator) and activator:IsPlayer() and activator:Alive() then
			zgo2.Soil.OnUse(self, activator)
		end
	end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 70b873f322570e153a05d9cee15c50a5d97bffffec86f684a14bf17014b60342

	function ENT:PostInitialize()
		zgo2.Destruction.SetupHealth(self)
	end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 5f074b2717244cb0b28afc4f82cbfebeed301ee81f5a05ae65232daad257b16a
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 70b873f322570e153a05d9cee15c50a5d97bffffec86f684a14bf17014b60342

function ENT:CanProperty(ply)
	return ply:IsSuperAdmin()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 8ffb188c701d3f1856df3a15bfe8e14b5be84a41e03a52af8e86de4fbee82eeb

function ENT:CanTool(ply, tab, str)
	return ply:IsSuperAdmin()
end

function ENT:CanDrive(ply)
	return false
end

--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_watertank/cl_init.lua:
return gluapack()()
--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_equipment/cl_init.lua:
return gluapack()()
--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_item_acid/shared.lua:
return gluapack()()
--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_item_lox/cl_init.lua:
/*
    Addon id: a36a6eee-6041-4541-9849-360baff995a2
    Version: v1.4.1 (stable)
*/

include("shared.lua")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218024

function ENT:Initialize()
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- b59bd1b1f8d16a52cb3d0a12454834a0ad28afe2633004db7a9dc71add4aef45
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- b59bd1b1f8d16a52cb3d0a12454834a0ad28afe2633004db7a9dc71add4aef45

end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218033

function ENT:DrawTranslucent()
	self:Draw()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- f846397ffcf09571d053f7b7aff0b4ab920f6d7152aebc0550c4aa612acbeab0

function ENT:Draw()
	self:DrawModel()
end

--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_machine_filler/shared.lua:
/*
    Addon id: a36a6eee-6041-4541-9849-360baff995a2
    Version: v1.4.1 (stable)
*/

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Model = "models/zerochain/props_methlab/zmlab2_filler.mdl"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "Filler"
ENT.Category = "Zeros Methlab 2"
ENT.RenderGroup = RENDERGROUP_OPAQUE

                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 15871293219a231313fbdc551fcfaeb89901409b08b17abf512df78d792aeeea

function ENT:SetupDataTables()

    // Corresponds to a ID from the MethTypes config (normal meth, blue meth)
    self:NetworkVar("Int", 1, "MethType")
    self:NetworkVar("Int", 2, "MethAmount")
    self:NetworkVar("Int", 3, "MethQuality")

    self:NetworkVar("Int", 4, "ProcessState")

    self:NetworkVar("Entity", 1, "Tray")


    if (SERVER) then
        self:SetMethType(1)
        self:SetProcessState(0)
        self:SetMethAmount(0)
        self:SetMethQuality(1)
        self:SetTray(NULL)
    end
end

function ENT:OnPumpButton(ply)
    local trace = ply:GetEyeTrace()
    local lp = self:WorldToLocal(trace.HitPos)

    if lp.x > -8 and lp.x < 0 and lp.y < 15 and lp.y > 10 and lp.z > 26 and lp.z < 31 then
        return true
    else
        return false
    end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 008d00393091244a629b726da410c82cc21d3876952f1a2fa78c80bc6afb7013

// Tell us if you allow to receive liquid
function ENT:AllowConnection(From_ent)
    if From_ent:GetClass() == "zmlab2_machine_filter" and From_ent:GetProcessState() == 4 and self:GetProcessState() == 0 then
        return true
    else
        return false
    end
end

// Returns the start position and direction for a hose
function ENT:GetHose_In()
    local attach = self:GetAttachment(1)
    if attach == nil then return self:GetPos(),self:GetAngles() end
    local ang = attach.Ang
    ang:RotateAroundAxis(ang:Right(),180)
    return attach.Pos,ang
end

                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218033

function ENT:CanProperty(ply)
    return zclib.Player.IsAdmin(ply)
end

function ENT:CanTool(ply, tab, str)
    return zclib.Player.IsAdmin(ply)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- f846397ffcf09571d053f7b7aff0b4ab920f6d7152aebc0550c4aa612acbeab0
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218033

function ENT:CanDrive(ply)
    return zclib.Player.IsAdmin(ply)
end

--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_machine_filter/shared.lua:
/*
    Addon id: a36a6eee-6041-4541-9849-360baff995a2
    Version: v1.4.1 (stable)
*/

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Model = "models/zerochain/props_methlab/zmlab2_filter.mdl"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "Filter"
ENT.Category = "Zeros Methlab 2"
ENT.RenderGroup = RENDERGROUP_OPAQUE
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 15871293219a231313fbdc551fcfaeb89901409b08b17abf512df78d792aeeea
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- ce15eec833bf47ebbcf6161ad127d2657901fd54a4bc9d5aa5fcda90913684bc

function ENT:SetupDataTables()

    // Corresponds to a ID from the MethTypes config (normal meth, blue meth)
    self:NetworkVar("Int", 1, "MethType")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- f846397ffcf09571d053f7b7aff0b4ab920f6d7152aebc0550c4aa612acbeab0

    self:NetworkVar("Int", 2, "ProcessState")

    self:NetworkVar("Int", 3, "Progress")

    self:NetworkVar("Int", 4, "MethQuality")

    self:NetworkVar("Int", 5, "ErrorStart")

    if (SERVER) then
        self:SetMethType(6)
        self:SetProcessState(0)
        self:SetProgress(0)
        self:SetMethQuality(1)
        self:SetErrorStart(-1)
    end
end

function ENT:OnStart(ply)
    local trace = ply:GetEyeTrace()
    local lp = self:WorldToLocal(trace.HitPos)
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218033

    if lp.x > 0 and lp.x < 8 and lp.y < 15 and lp.y > 10 and lp.z > 27 and lp.z < 32 then
        return true
    else
        return false
    end
end

function ENT:OnErrorButton(ply)
    local trace = ply:GetEyeTrace()
    local lp = self:WorldToLocal(trace.HitPos)

    if lp.x > 0 and lp.x < 8 and lp.y < 15 and lp.y > 10 and lp.z > 25 and lp.z < 31.4 then
        return true
    else
        return false
    end
end


// Tell us if you allow to receive liquid
function ENT:AllowConnection(From_ent)
    if From_ent:GetClass() == "zmlab2_machine_mixer" and From_ent:GetProcessState() == 9 and self:GetProcessState() == 0 then
        return true
    else
        return false
    end
end

// Returns the start position and direction for a hose
function ENT:GetHose_In()
    local attach = self:GetAttachment(1)
    if attach == nil then return self:GetPos(),self:GetAngles() end
    local ang = attach.Ang
    ang:RotateAroundAxis(ang:Right(),180)
    return attach.Pos,ang
end

// Returns the start position and direction for a hose
function ENT:GetHose_Out()
    local attach = self:GetAttachment(2)
    if attach == nil then return self:GetPos(),self:GetAngles() end
    return attach.Pos,attach.Ang
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- ce15eec833bf47ebbcf6161ad127d2657901fd54a4bc9d5aa5fcda90913684bc

function ENT:CanProperty(ply)
    return zclib.Player.IsAdmin(ply)
end

function ENT:CanTool(ply, tab, str)
    return zclib.Player.IsAdmin(ply)
end

function ENT:CanDrive(ply)
    return zclib.Player.IsAdmin(ply)
end

--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_table/cl_init.lua:
return gluapack()()
--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_table/shared.lua:
return gluapack()()
--addons/zeros_methlab_1.6.4/lua/entities/zmlab_baseanim/cl_init.lua:
include("shared.lua")

------------------------------//
function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:Think()
	self:SetNextClientThink(CurTime()) -- Make animations run smoothly
	-- Apply NextThink() call

	return true
end

--addons/zeros_methlab_1.6.4/lua/entities/zmlab_methbuyer/cl_init.lua:
return gluapack()()
--addons/zeros_methlab_1.6.4/lua/entities/zmlab_sludge/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	self:Draw()
end

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_basket_coal.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

AddCSLuaFile()
DEFINE_BASECLASS("zrms_basket")
ENT.Type = "anim"
ENT.Base = "zrms_basket"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "Crate - Coal"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "info"
ENT.Category = "Zeros RetroMiningSystem"
ENT.AutomaticFrameAdvance = true
ENT.DisableDuplicator = false

function ENT:SetupDataTables()
	self:NetworkVar("Float", 0, "ResourceAmount")
	self:NetworkVar("String", 0, "ResourceType")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	if (SERVER) then
		self:SetResourceAmount(zrmine.config.ResourceCrates_Capacity)
		self:SetResourceType("Coal")
	end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_melter/cl_init.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_minecart/cl_init.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:DrawTranslucent()
	self:Draw()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:Think()
	self:SetNextClientThink(CurTime())

	return true
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_mineentrance_base/cl_init.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

include("shared.lua")


function ENT:Initialize()

	self.mainColor = HSVToColor(math.random(0, 360), 0.5, 0.5)
	ZRMS_SHAFTS[self:EntIndex()] = self

	self.OwnerName = ""
	timer.Simple(1,function()
		if IsValid(self) then
			local owner = zrmine.f.GetOwner(self)
			if (IsValid(owner)) then
				self.OwnerName = owner:Nick()
			end
		end
	end)
end


// UI STUFF
function ENT:Draw()
	self:DrawModel()

	if zrmine.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 600) then
		self:DrawInfo()
	end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:DrawInfo()
	local title = ""

	if (zrmine.config.Mine_CustomName) then
		title = zrmine.config.Mine_CustomName
	else
		title = self.OwnerName or ""
	end

	local info
	local cState = self:GetCurrentState()

	if (cState == 4) then
		info = zrmine.language.Mine_Mining
	elseif (cState == 1) then
		info = zrmine.language.Mine_Ready
	else
		info = zrmine.language.Mine_Wait
	end

	local rtype = self:GetMineResourceType()
	local rColor = zrmine.f.GetOreColor(rtype)


	cam.Start3D2D(self:LocalToWorld(Vector(50,0,56)), self:LocalToWorldAngles(Angle(0,90,90)), 0.07)
		surface.SetDrawColor(zrmine.default_colors["white02"])
		surface.SetMaterial(zrmine.default_materials["MineBgIcon"])
		surface.DrawTexturedRect(-425, -51, 850, 160)

		draw.RoundedBox(5, -425, -51, 850, 160, zrmine.default_colors["black03"])
		draw.RoundedBox(0, -250, 65, 550, 12, zrmine.default_colors["black04"])

		if (cState == 0) then
			draw.DrawText(zrmine.language.Mine_SearchOre, "zrmine_mineentrance_font2", 0, 10, zrmine.default_colors["white02"], TEXT_ALIGN_CENTER)
		else
			draw.DrawText(info, "zrmine_mineentrance_font2", 0, -15, zrmine.default_colors["white02"], TEXT_ALIGN_CENTER)
			local startMineTime = self:GetStartMinningTime()
			local mineTime = self:GetMinningTime() + 5
			local moveStep
			startMineTime = (startMineTime + mineTime) - CurTime()
			local cartIcon = zrmine.default_materials["Minecart"]

			if (startMineTime > mineTime / 2) then
				moveStep = -750 + (1000 / mineTime) * startMineTime
				cartIcon = zrmine.default_materials["Minecart"]
			elseif (startMineTime > 0) then
				moveStep = 250 + (-1000 / mineTime) * startMineTime
				cartIcon = zrmine.default_materials["MinecartFull"]
			else
				moveStep = 250
			end

			draw.RoundedBox(0, -250, 75, 550, 5, zrmine.default_colors["grey03"])

			surface.SetDrawColor(zrmine.default_colors["white02"])
			surface.SetMaterial(zrmine.default_materials["MineIcon"])
			surface.DrawTexturedRect(250, -21, 110, 110)

			if (mineTime - 5 > 0) then
				surface.SetDrawColor(zrmine.default_colors["white02"])
				surface.SetMaterial(cartIcon)
				surface.DrawTexturedRect(moveStep, 32, 50, 50)
			end
		end

		if (rtype ~= "Nothing") then
			surface.SetDrawColor(rColor)
			surface.SetMaterial(zrmine.default_materials["Ore"])
			surface.DrawTexturedRect(-400, -70, 200, 200)
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

			if (rtype == "Random") then
				draw.DrawText("?", "zrmine_mineentrance_font3", -300, -15, zrmine.default_colors["white02"], TEXT_ALIGN_CENTER)
			end
		end
	cam.End3D2D()

	cam.Start3D2D(self:LocalToWorld(Vector(55,0,56)), self:LocalToWorldAngles(Angle(0,90,90)), 0.08)
		draw.RoundedBox(0, -340, -190, 680, 120, self.mainColor)

		surface.SetDrawColor(zrmine.default_colors["grey04"])
		surface.SetMaterial(zrmine.default_materials["MineSignIcon"])
		surface.DrawTexturedRect(-360, -205, 720, 160)

		draw.DrawText(title .. "´s Mine", "zrmine_mineentrance_font1", 0, -150, zrmine.default_colors["white02"], TEXT_ALIGN_CENTER)
	cam.End3D2D()
end

function ENT:CreateClientSideModel()
	self.csModel = ClientsideModel("models/zerochain/props_mining/mining_tunnel.mdl")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	if (IsValid(self.csModel) and IsValid(self)) then
		self.csModel:SetPos(self:GetPos())
		self.csModel:SetAngles(self:GetAngles())
		self.csModel:SetParent(self)
		self.csModel:SetNoDraw(true)
	end
end

function ENT:CreateCart()
	self.csCartModel = ClientsideModel("models/Zerochain/props_mining/me_cart.mdl")

	if (IsValid(self) and IsValid(self.csCartModel) ) then
		local attachID = self:LookupAttachment("cart")

		if (attachID == 1) then
			self.csCartModel:SetPos(self:GetAttachment(attachID).Pos)
			local ang = self:GetAttachment(attachID).Ang
			ang:RotateAroundAxis(self:GetAttachment(attachID).Ang:Up(), 90)
			self.csCartModel:SetAngles(ang)
			self.csCartModel:SetParent(self, attachID)
			self.csCartModel:SetNoDraw(true)
		end
	end
end

function ENT:Think()
	if zrmine.f.InDistance(self:GetPos(), LocalPlayer():GetPos(), 1000) then
		if (IsValid(self.csModel)) then
			self.csModel:SetPos(self:GetPos())
			self.csModel:SetAngles(self:GetAngles())
		else
			self:CreateClientSideModel()
		end


		if (IsValid(self.csCartModel)) then
			local attachID = self:LookupAttachment("cart")

			if (attachID == 1) then
				self.csCartModel:SetPos(self:GetAttachment(attachID).Pos)
				local ang = self:GetAttachment(attachID).Ang
				ang:RotateAroundAxis(self:GetAttachment(attachID).Ang:Up(), 90)
				self.csCartModel:SetAngles(ang)
			end
		else
			self:CreateCart()
		end
	end

	self:SetNextClientThink(CurTime())
	return true
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:OnRemove()
	if IsValid(self.csModel) then
		self.csModel:Remove()
	end

	if IsValid(self.csCartModel) then
		self.csCartModel:Remove()
	end
end

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_ore/shared.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_refiner_iron.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_resource/cl_init.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_resource/cl_init.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

include("shared.lua")

function ENT:Draw()
	self:DrawModel()

	if zrmine.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 300) then
		self:DrawInfo()
	end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:DrawTranslucent()
	self:Draw()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:DrawInfo()
	local Text = math.Round(self:GetResourceAmount()) .. zrmine.config.BuyerNPC_Mass
	cam.Start3D2D(self:GetPos() + Vector(0, 0, 10), Angle(0, LocalPlayer():EyeAngles().y - 90, 90), 0.1)
		draw.DrawText(Text, "zrmine_resource_font1", 0, 15, zrmine.default_colors["white02"], TEXT_ALIGN_CENTER)
	cam.End3D2D()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:OnRemove()
	zrmine.f.EmitSoundENT("zrmine_resourcedespawn", self)
	zrmine.f.ParticleEffect("zrms_resource_despawn", self:GetPos(), self:GetAngles(), self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_resource_coal.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

AddCSLuaFile()
DEFINE_BASECLASS("zrms_resource")
ENT.Type = "anim"
ENT.Base = "zrms_resource"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.PrintName = "Gravel - Coal"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "info"
ENT.Category = "Zeros RetroMiningSystem"
ENT.Model = "models/Zerochain/props_mining/zrms_resource.mdl"
ENT.DisableDuplicator = false
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:SetupDataTables()
	self:NetworkVar("Float", 0, "ResourceAmount")
	self:NetworkVar("String", 0, "ResourceType")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	if (SERVER) then
		self:SetResourceType("Coal")
		self:SetResourceAmount(25)
	end
end

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_sorter/shared.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_sorter_coal.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_sorter_iron.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_splitter/cl_init.lua:
return gluapack()()
--addons/zeros_trashman_v1.6.3/lua/entities/ztm_trashbag/shared.lua:
return gluapack()()
--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_distillery_condenser/cl_init.lua:
include("shared.lua")

function ENT:Initialize()

	self.c_WeakMoonshine = 0
	self.c_Moonshine = 0
	self.FillingJar = false
	self.HasFillEffect = false
end

function ENT:Draw()
	self:DrawModel()

	if zyb.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 300) then
		self:DrawInfo()
		self:DrawName()
		self:DrawUpgradeInfo()
		self:DrawWeakMoonShine()
	end
end

function ENT:DrawName()
	cam.Start3D2D(self:LocalToWorld(Vector(14, 0, 80)), self:LocalToWorldAngles(Angle(0,90,90)), 0.05)

		-- Title
		draw.RoundedBox(25, -200, -20, 400, 90, zyb.default_colors["black01"])
		draw.SimpleText(zyb.language.General["Condenser"], "zyb_barrel_font01", 0, -10, zyb.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

		draw.SimpleText(self:GetMoonShine() .. zyb.config.LiquidUnit, "zyb_condenser_font01", 0, 925, zyb.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	cam.End3D2D()
end

function ENT:DrawUpgradeInfo()
	cam.Start3D2D(self:LocalToWorld(Vector(15, 0, 70)), self:LocalToWorldAngles(Angle(0,90,90)), 0.05)
		local text = zyb.language.VGUI["UpgradeMenu"]
		local bSize = zyb.f.GetTextSize(text,"zyb_barrel_font02")

		if self:OnUpgradeMenu(LocalPlayer()) then
			draw.RoundedBox(20, -bSize / 2, -20, bSize, 80, zyb.default_colors["orange01"])
		else
			draw.RoundedBox(20, -bSize / 2, -20, bSize, 80, zyb.default_colors["grey02"])
		end

		draw.SimpleText(text, "zyb_barrel_font02", 0, -10, zyb.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	cam.End3D2D()
end

function ENT:DrawWeakMoonShine()

	local WeakMoonShine = self:GetWeakMoonShine()

	local s_bar = (540 / zyb.config.Condenser.WeakMoonshineStorage) * WeakMoonShine
	self.c_WeakMoonshine = self.c_WeakMoonshine + 100 * FrameTime()
	self.c_WeakMoonshine = math.Clamp(self.c_WeakMoonshine, 0, s_bar)

	cam.Start3D2D(self:LocalToWorld(Vector(16, 0, 70)), self:LocalToWorldAngles(Angle(0,90,90)), 0.05)

		if WeakMoonShine > 0 then
			surface.SetDrawColor(zyb.default_colors["brown02"])
			surface.SetMaterial(zyb.default_materials["circle"])
			surface.DrawTexturedRect(-120, -530, 240, 240)

			draw.SimpleText(self:GetWeakMoonShine() .. zyb.config.LiquidUnit, "zyb_condenser_font01", 0, -450, zyb.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		end

		if WeakMoonShine > zyb.config.Condenser.WeakMoonshineStorage / 3 then
			surface.SetDrawColor(zyb.default_colors["brown03"])
			surface.SetMaterial(zyb.default_materials["circle"])
			surface.DrawTexturedRect(-120, -930, 240, 240)

		end

		if WeakMoonShine > zyb.config.Condenser.WeakMoonshineStorage / 2 then
			surface.SetDrawColor(zyb.default_colors["brown04"])
			surface.SetMaterial(zyb.default_materials["circle"])
			surface.DrawTexturedRect(-120, -1330, 240, 240)

		end

		if WeakMoonShine > zyb.config.Condenser.WeakMoonshineStorage / 1.3 then
			surface.SetDrawColor(zyb.default_colors["brown05"])
			surface.SetMaterial(zyb.default_materials["circle"])
			surface.DrawTexturedRect(-120, -1730, 240, 240)

		end
	cam.End3D2D()
end

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:FillEffect_Start()
	if self.HasFillEffect == false then
		zyb.f.ParticleEffectAttach("yb_moonshine", self, 5)
		self.HasFillEffect = true
	end
end

function ENT:FillEffect_Stop()
	if self.HasFillEffect then
		self:StopParticlesNamed("yb_moonshine")
		self.HasFillEffect = false
	end
end

function ENT:Think()

	if zyb.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 500) then

		local fillingJar = self:GetFillingJar()

		if self.FillingJar ~= fillingJar then
			self.FillingJar = fillingJar

			if self.FillingJar then
				self:FillEffect_Start()
			else
				self:FillEffect_Stop()
			end

		end
	else
		self:FillEffect_Stop()
	end

	zyb.f.LoopedSound(self,"zyb_fill_moonshine", self.FillingJar)

	self:SetNextClientThink(CurTime())
	return true
end


function ENT:DrawInfo()
	local ang = self:GetAngles()
	ang:RotateAroundAxis(self:GetUp(),-90)
	ang:RotateAroundAxis(self:GetRight(),-90)

	local moonShine = self:GetMoonShine()

	cam.Start3D2D(self:LocalToWorld(Vector(14, 0, 50)), ang, 0.05)

		surface.SetDrawColor(zyb.default_colors["white01"])
		surface.SetMaterial(zyb.default_materials["barfront01bg"])
		surface.DrawTexturedRect(-390,-440, 780, 780)
		draw.NoTexture()

		local m_bar = (710 / zyb.config.Condenser.MoonshineStorage) * moonShine
		self.c_Moonshine = self.c_Moonshine + 100 * FrameTime()
		self.c_Moonshine = math.Clamp(self.c_Moonshine, 0, m_bar)

		if self.c_Moonshine > 5 then
			draw.RoundedBox(0, -60, -405, 120, self.c_Moonshine, zyb.default_colors["brown06"])
		end

		surface.SetDrawColor(zyb.default_colors["white02"])
		surface.SetMaterial(zyb.default_materials["barfront01fg"])
		surface.DrawTexturedRect(-390,-440, 780, 780)
		draw.NoTexture()

		surface.SetDrawColor(Color(160,160,160,255))
		surface.SetMaterial(zyb.default_materials["barfront01"])
		surface.DrawTexturedRect(-390,-440, 780, 780)
		draw.NoTexture()



	cam.End3D2D()
end

--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_distillery_cooler/cl_init.lua:
return gluapack()()
--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_fuel/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Model = "models/zerochain/props_yeastbeast/yb_wood.mdl"
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "Wood"
ENT.Category = "Zeros YeastBeast"
ENT.RenderGroup = RENDERGROUP_OPAQUE

--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_motor/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Model = "models/zerochain/props_yeastbeast/yb_motor.mdl"
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "Grinder Motor"
ENT.Category = "Zeros YeastBeast"
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
ENT.AutomaticFrameAdvance = true

function ENT:SetupDataTables()
    self:NetworkVar("Bool", 0, "Running")


    if (SERVER) then
        self:SetRunning(false)
    end
end

--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_palette/shared.lua:
return gluapack()()
--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_water/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:OnRemove()
	self:StopSound("zyb_fill_liquid")
	self:StopParticlesNamed("yb_water")
end

function ENT:Think()

	zyb.f.LoopedSound(self, "zyb_fill_liquid", self:GetFilling())

	self:SetNextClientThink(CurTime())
	return true
end

--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_yeastgrinder/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.IsGrinding = false
	self.YeastAmount = 0
	self.c_BlockHeight = 0
	self.c_BlockScale = 0
end

function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:Think()


	if zyb.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 500) then
		self.YeastAmount = self:GetYeastAmount()

		local grinding = self:GetGrinding()
		zyb.f.LoopedSound(self, "zyb_grinding", grinding)

		if self.IsGrinding ~= grinding then
			self.IsGrinding = grinding

			if self.IsGrinding then
				zyb.f.PlayClientAnimation(self,"spin", 1)

				zyb.f.ParticleEffectAttach("yb_yeast", self, 1)
				zyb.f.ParticleEffectAttach("yb_yeastgrinding", self, 2)
			else
				zyb.f.PlayClientAnimation(self,"idle", 1)
				self:StopParticlesNamed("yb_yeast")
				self:StopParticlesNamed("yb_yeastgrinding")
			end

		end

		if self.ClientProps then
			if not IsValid(self.ClientProps["YeastBlock"]) then
				self:SpawnClientModel_Yeastblock()
			else

				if self.YeastAmount <= 0 then
					self.ClientProps["YeastBlock"]:SetNoDraw(true)
				else
					self.ClientProps["YeastBlock"]:SetNoDraw(false)

					local height = 5 - ((5 / zyb.config.YeastBlock.Amount) * self.YeastAmount)
					self.c_BlockHeight = self.c_BlockHeight + 1 * FrameTime()
					self.c_BlockHeight = math.Clamp(self.c_BlockHeight, 0, height)
					self.ClientProps["YeastBlock"]:SetPos(self:GetPos() + self:GetUp() * 50 + self:GetUp() * -self.c_BlockHeight)


					local mScale = math.Clamp((1 / zyb.config.YeastBlock.Amount) * self.YeastAmount, 0.8, 1)
					self.c_BlockScale = self.c_BlockScale + 1 * FrameTime()
					self.c_BlockScale = math.Clamp(self.c_BlockScale, 0, mScale)
					self.ClientProps["YeastBlock"]:SetModelScale(self.c_BlockScale)

					if self.IsGrinding then
						self.ClientProps["YeastBlock"]:SetLocalAngles(Angle(90, RealTime() * 180, 0))
					end
				end

			end
		else
			self.ClientProps = {}
		end
	else

		self:RemoveClientModels()
	end

	self:SetNextClientThink(CurTime())
	return true
end

function ENT:SpawnClientModel_Yeastblock()
	local ent = ents.CreateClientProp()
	ent:SetPos( self:LocalToWorld( Vector( 0, 0, 15 ) ) )
	ent:SetModel("models/zerochain/props_yeastbeast/yb_yeastblock.mdl")
	ent:SetAngles( self:LocalToWorldAngles( Angle( 0, 0, 0 ) ) )
	ent:Spawn()
	ent:Activate()
	ent:SetParent(self)

	self.ClientProps["YeastBlock"] = ent
	self.ClientProps["YeastBlock"]:SetNoDraw(true)
	self.ClientProps["YeastBlock"]:SetLocalAngles(Angle(90, 0, 0))
	self.ClientProps["YeastBlock"]:SetPos(self:GetPos() + self:GetUp() * 50 )
end

function ENT:RemoveClientModels()
	if (self.ClientProps and table.Count(self.ClientProps) > 0) then
		for k, v in pairs(self.ClientProps) do
			if IsValid(v) then
				v:Remove()
			end
		end
	end
	self.ClientProps = {}
end

function ENT:OnRemove()
	self:RemoveClientModels()
end

--lua/effects/arccw_uc_tracer.lua:
return gluapack()()
--addons/ch_mining/lua/effects/rock_spark/init.lua:
return gluapack()()
--addons/serious_business/lua/effects/sb_product_progress.lua:
return gluapack()()
--addons/serious_business/lua/effects/sb_skill_progress.lua:
return gluapack()()
--addons/serious_business/lua/effects/sb_skill_progress.lua:
/*----------------------------------------------------------------------
Leak by Famouse

Play good games:↓
http://store.steampowered.com/curator/32364216

Subscribe to the channel:↓
https://www.youtube.com/c/Famouse

More leaks in the discord:↓ 
discord.gg/rFdQwzm
------------------------------------------------------------------------*/

--[[
	Just a first attempt in effect.
	Green text just makes me feel better.
]]--

function EFFECT:Init(data)
	
	local offset = data:GetOrigin();
	local scale = 1.5;
	
	--sound.Play("garrysmod/balloon_pop_cute.wav", offset, 90, math.random(90, 120));
	
	local particlesAmount = 1;
	local emitter = ParticleEmitter(offset, false);

	local particle = emitter:Add("sgm/playercircle", offset);
	
	if (particle) then
		
		particle:SetVelocity(Vector(math.random(-8, 8), math.random(-8, 8), 64));
		
		particle:SetLifeTime(0);
		particle:SetDieTime(2);
		
		particle:SetStartAlpha(255);
		particle:SetEndAlpha(255);
		
		particle:SetStartSize(8*scale);
		particle:SetEndSize(4*scale);
		
		particle:SetRoll(math.random(180, 480));
		particle:SetRollDelta(math.random(-2, 2));
		
		particle:SetAirResistance(256);
		particle:SetGravity(Vector(0, 0, 64));
		
		particle:SetColor(255, 205, 0);
		
		particle:SetCollide(true);
		particle:SetBounce(1);
		
		particle:SetAngleVelocity(Angle(math.random(-2, 2), math.random(-2, 2), math.random(-2, 2)));
		
		particle:SetLighting(true);
	end;
	emitter:Finish();
end;


function EFFECT:Think()
	return false;
end;


function EFFECT:Render()

end;

/*------------------------------------------------------------------------
Donation for leaks

Qiwi Wallet         4890494419811120 
YandexMoney         410013095053302
WebMoney(WMR)       R235985364414
WebMoney(WMZ)       Z309855690994
------------------------------------------------------------------------*/
--addons/oneprint/lua/oneprint/shared/i18n/tr.lua:
OnePrint.Lang = {
    [ "Scroll to unlock" ] = "Kaydırarak kilidi aç",
    [ "Withdraw" ] = "Para çek",
    [ "Return" ] = "Geri dön",
    [ "Show" ] = "Göster",
    [ "Home" ] = "Ana sayfa",
    [ "Money" ] = "Para",
    [ "Temperature" ] = "Sıcaklık",
    [ "Servers" ] = "Sunucular",
    [ "Defense" ] = "Savunma",
    [ "Watercooling" ] = "Su soğutma",
    [ "Power" ] = "Güç",
    [ "Overclocking" ] = "Hız aşırtma",
    [ "Security" ] = "Güvenlik",
    [ "Silencer" ] = "Susturucu",
    [ "CPU" ] = "İşlemci",
    [ "Income" ] = "Gelir",
    [ "Shop" ] = "Mağaza",
    [ "Lights" ] = "Işıklar",
    [ "Lock" ] = "Kilitle",
    [ "Locked" ] = "Kilitli",
    [ "Unlock" ] = "Kilidi aç",
    [ "Freeze" ] = "Dondur",
    [ "Unfreeze" ] = "Dondurma",
    [ "Start" ] = "Başlat",
    [ "Stop" ] = "Durdur",
    [ "Upgrade" ] = "Yükseltme",
    [ "Upgrade All" ] = "Hepsini yükselt",
    [ "Not enough money" ] = "Yeterli para yok",
    [ "Limit reached" ] = "Sınırına ulaşıldı",
    [ "Add user" ] = "Kullanıcı ekle",
    [ "Remove user" ] = "Kullanıcıyı sil",
    [ "Manage users" ] = "Kullanıcıları yönet",
    [ "Added" ] = "Eklendi",
    [ "Owner" ] = "Sahip",
    [ "Installation" ] = "Yükleme",
    [ "Installed" ] = "Yüklendi",
    [ "Not installed" ] = "Yüklenmedi",

    [ "Income history" ] = "Gelir geçmişi",
    [ "Activity history" ] = "Etkinlik geçmişi",
    [ "Condition" ] = "Durum",
    [ "Menu" ] = "Menü",
    [ "Users" ] = "Kullanıcılar",
    [ "Repair" ] = "Onar",
    [ "Reparation" ] = "Onarım",
    [ "Current" ] = "Geçerli",

    [ "Hack" ] = "Hackle",
    [ "Success" ] = "Başarılı",
    [ "Fail" ] = "Başarısız",
    [ "Step" ] = "Adım",
    [ "Update every %s sec." ] = "Her %s saniyede güncelle",
    [ "In %s" ]  = "İçinde %s",

    [ "Lock printer" ] = "Yazıcıyı kilitle",
    [ "Are you sure?" ] = "Emin misin?",
    [ "Yes" ] = "Evet",
    [ "No" ] = "Hayır",
    [ "N/A" ] = "N/A",
    [ "Change light" ] = "Işık değiştir", 
    [ "Choose a new light color" ] = "Yeni bir ışık rengi seç", 
    [ "Blue" ] = "Mavi", 
    [ "White" ] = "Beyaz", 
    [ "Red" ] = "Kırmızı", 
    [ "Green" ] = "Yeşil", 

    [ "You paid %s to repair this printer" ] = "Bu yazıcıyı tamir etmek için %s ödediniz", 
    [ "You were rewarded %s for destroying a printer" ] = "Bir yazıcıyı yok ettiğiniz için %s ödül kazandınız", 
    [ "Your printer is in critical condition" ] = "Yazıcınız kritik durumda", 
    [ "Your printer got hacked" ] = "Yazıcınız hacklendi", 

    [ "You must buy a server before" ] = "Önce bir sunucu satın almalısınız (Mağaza sekmesine gidin)", 
    [ "This printer is empty" ] = "Bu yazıcı boş", 
    [ "You withdrew %s" ] = "%s çektiniz", 
    [ "You froze this printer" ] = "Bu yazıcıyı dondurdunuz", 
    [ "You unfroze this printer" ] = "Bu yazıcının dondurmasını kaldırdınız", 
    [ "You started this printer" ] = "Bu yazıcıyı başlattınız", 
    [ "You stopped this printer" ] = "Bu yazıcıyı durdurdunuz", 
    [ "%s upgrade installed" ] = "%s yükseltmesi yüklendi", 
    [ "Light color applied : %s" ] = "Işık rengi uygulandı: %s", 

    [ "Max health" ] = "Maksimum sağlık", 
    [ "Max power" ] = "Maksimum güç", 
    [ "Max temperature" ] = "Maksimum sıcaklık", 
    [ "Max watercooling" ] = "Maksimum su soğutma", 
    [ "Max overclocking" ] = "Maksimum overclock", 
    [ "Max silencer" ] = "Maksimum susturucu", 
    [ "Max security" ] = "Maksimum güvenlik", 
    [ "Noise reduction" ] = "Gürültü azaltma", 
    [ "Hacking difficulty" ] = "Hackleme zorluğu", 
    [ "Hacking notification" ] = "Hackleme bildirimi", 
    [ "Low HP notification" ] = "Düşük HP bildirimi", 

    Logs = {
        [ 0 ] = "Yeni sahibi: %s", 
        [ 1 ] = "%s çekildi $%s", 
        [ 2 ] = "%s satın aldı %s", 
        [ 3 ] = "%s, %s'e erişim izni verildi",
        [ 4 ] = "%s, %s'nin erişim iznini kaldırdı"
    }
}