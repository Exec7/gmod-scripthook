--Stealed clientside server code by exechack.cc
--Hostname: Age of Clones | Clone Wars Roleplay | Eigener Spielmodus - Part 5/12 - 06/04/2025


--PATH lua/autorun/aoc_sonstiges.lua:
player_manager.AddValidModel( "Commander Fox", 		"models/starwars/grady/aoc/st/st_lore/commander_fox.mdl" );
player_manager.AddValidHands( "Commander Fox", 		"models/starwars/grady/aoc/st/st_lore/commander_fox_viewhands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Commander Fox", 	"models/starwars/grady/aoc/st/st_lore/commander_fox.mdl" );
--addons/arccw_weapons/lua/arccw/shared/attachments/15s_mag_drum.lua:
att.PrintName = "15s Extended Magazine (DRUM)"
att.SortOrder = 100
att.Icon = nil
att.Description = "Extended magazine for DC-15s"
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Slot = "15s_mag"
att.ActivateElements = {"15s_mag_drum"}

att.AutoStats = true
att.HideIfBlocked = true
att.Override_ClipSize = 100

att.Mult_SightTime = 1.05
att.Mult_Sway = 2.1
att.Mult_SpeedMult = 0.90
att.Mult_ShootSpeedMult = 0.90
att.Mult_DrawTime = 1.35
att.Mult_HolsterTime = 1.25
att.Mult_HipDispersion = 1.9

--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_explosive_mod.lua:
att.PrintName = "Explosive Mod"
att.Icon = Material("entities/acwatt_go_ammo_blanks.png", "mips smooth")
att.Description = "Explosive rounds"
att.Desc_Pros = {
}
att.Desc_Cons = {
}

att.AutoStats = true
att.Slot = "special_ammo"

att.Mult_ShootPitch = 0.9
att.Mult_ShootVol = 1.3
att.Mult_Penetration = 0
att.Mult_Damage = 4
att.Mult_Range = 0.7

att.Override_DamageType = DMG_BURN

att.Override_Tracer = "tfa_tracer_yellow" -- tracer effect name

att.Hook_GetCapacity = function(wep, cap)
    return math.Clamp(math.Round(wep.RegularClipSize * 1), 1, 12)
end

att.Hook_BulletHit = function(wep, data)
    local ent = data.tr.Entity
    util.BlastDamage(wep, wep:GetOwner(), data.tr.HitPos, 96, wep:GetDamage(data.range))
    if ent:IsValid() and ent:GetClass() == "npc_helicopter" then
        data.dmgtype = DMG_AIRBOAT
    end
end
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_rocket_ion.lua:
att.PrintName = "Ion Rocket"
att.Description = "Highly powered round."
att.Icon = Material("interfaz/iconos/kraken/jedi comm gunnery/292808524_4235241327.png")

att.Slot = "ammo_rocket"
att.AutoStats = true
att.Override_ShootEntity = "ion_throwed"
--addons/arccw_weapons/lua/arccw/shared/attachments/bipod.lua:
att.PrintName = "Bipod"
att.Icon = Material("entities/acwatt_bipod.png")
att.Description = "Bipod can be deployed by pressing +USE while in an eligible spot. While deployed, the user's aiming angle is limited and recoil is reduced to near-zero. Moving will release bipod. While not in use, the bipod negatively impacts weapon maneuverability."

att.SortOrder = 10

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "bipod"

att.LHIK = true
att.LHIK_Animation = true

att.MountPositionOverride = 1

att.Model = "models/weapons/arccw/atts/bipod.mdl"
att.ModelScale = Vector(1.25, 1.25, 1.25)

att.Bipod = true
att.Mult_BipodRecoil = 0.25
att.Mult_BipodDispersion = 0.1

att.Mult_SightTime = 1.2
att.Mult_HipDispersion = 1.2
att.Mult_SpeedMult = 0.95

att.Hook_LHIK_TranslateAnimation = function(wep, anim)
    if anim == "idle" or anim == "in" or anim == "out" then
        if wep:InBipod() then
            return "idle_bipod"
        else
            return "idle"
        end
    end
end

att.Hook_Compatible = function(wep)
    if wep.Bipod_Integral then return false end
end
--addons/arccw_weapons/lua/arccw/shared/attachments/dc17m_mag_sniper.lua:
att.PrintName = "DC-17m Sniper Magazine"
att.SortOrder = 100
att.Icon = Material("entities/snipermag.png")
att.Description = "Special magazine designed for the DC-17m Modular."
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Slot = "17m_mag"
att.ActivateElements = {"17m_mag_sniper"}

att.AutoStats = true
att.HideIfBlocked = true

att.Override_ClipSize = 10

att.Mult_Penetration = 5
att.Mult_DamageMin = 1
att.Mult_Damage = 2

att.Mult_SightTime = 1.05
att.Mult_Sway = 1
att.Mult_SpeedMult = 0.85
att.Mult_ShootSpeedMult = 0.90
att.Mult_DrawTime = 1.15
att.Mult_HolsterTime = 1.15
att.Mult_HipDispersion = 2
--addons/arccw_weapons/lua/arccw/shared/attachments/dc17m_module_sniper.lua:
att.PrintName = "Sniper Module"
att.Icon = Material("entities/sniper.png")
att.Description = "DC-17m Sniper Module. Changes the main shoot to a charged plasma armor-piercing round. Big damage, lower ammo and RPM."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.NotForNPCs = true
att.AutoStats = true

att.Slot = "17m_module"
att.ActivateElements = {"17m_module_sniper"}

att.Mult_ShootPitch = 0.8

att.Reload = 1.5
att.Mult_Penetration = 5
att.Mult_DamageMin = 2
att.Mult_Damage = 3

att.Mult_Recoil = 1.5
att.Mult_SightTime = 1.2
att.Mult_RPM = 0.5
att.Mult_MuzzleVelocity = 5
att.Mult_HipDispersion = 1.2
att.Mult_SpeedMult = 0.90
--addons/arccw_weapons/lua/arccw/shared/attachments/gl_impact.lua:
att.PrintName = "Grenade Launcher (Impact)"
att.Icon = Material("interfaz/armas/sw_highenergyclip.png")
att.Description = "Grenade Launcher module. Replaces a charged tibanna cartridge with a grenade launcher one."
att.Desc_Pros = {
    "pro.ubgl",
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "info.toggleubgl"
}
att.AutoStats = true
att.Slot = "ubgl_module"

att.SortOrder = 1738

att.MountPositionOverride = 0

att.UBGL = true
att.UBGL_BaseAnims = false
att.UBGL_PrintName = "Grenade Launcher (Impact)"
att.UBGL_Automatic = false
--att.UBGL_MuzzleEffect = "swrp_muzzleflash_blue"
att.UBGL_ClipSize = 1
att.UBGL_Ammo = "Grenade"
att.UBGL_RPM = 1200
att.UBGL_Recoil = 2
att.UBGL_Capacity = 1

att.AddSuffix = "Grenadier"

att.Hook_ShouldNotSight = function(wep)
    return wep:GetInUBGL()
end

local function Ammo(wep)
    return wep.Owner:GetAmmoCount("Grenade")
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    wep:PlayAnimation("Reload", 1, true, nil, nil, nil, true)

    wep:FireRocket("tfa_battlefront_ent_nade_impact", 1000)

    if wep.MW2_M203isGP25 then
        wep:EmitSound("armas3/gl_fire_1.wav", 100)
    else
        wep:EmitSound("armas3/gl_fire_4.wav", 100)
    end

    wep:SetClip2(wep:Clip2() - 1)

    wep:DoEffects()
end

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end

    if Ammo(wep) <= 0 then return end

    wep:PlayAnimation("reload", 1, true, nil, nil, nil, true)
    wep:SetReloading(CurTime() + wep:GetAnimKeyTime("reload"))

    local reserve = Ammo(wep)

    reserve = reserve + wep:Clip2()

    local clip = 1

    local load = math.Clamp(clip, 0, reserve)

    wep.Owner:SetAmmo(reserve - load, "Grenade")

    wep:SetClip2(load)
end

att.Mult_SightTime = 1.25
-- att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--addons/arccw_weapons/lua/arccw/shared/attachments/muzzle_a280cfe_mod.lua:
att.PrintName = "A280-CFE Barrel Mod"
att.Description = "Bulky and heavy, but provides better ballistic performance.\n\n\"By the time you figured it out, it would be too late.\""

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/atts/a280cfe_barrel_mod.mdl"
att.ModelOffset = Vector(0, 0, 0)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = true
att.IsMuzzleDevice = false

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 1

att.Add_BarrelLength = 6
att.Mult_SightTime = 1.1
att.Mult_HipDispersion = 1.1
att.Mult_Range = 0.9
--addons/arccw_weapons/lua/arccw/shared/attachments/optic_se.lua:
att.PrintName = "Experimental Scope (SE)"
att.Icon = Material("entities/acwatt_optic_micro.png")
att.Description = "test scope for swrp"

att.SortOrder = 2

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = false
att.Slot = "swoptic_module_dcse"

att.Model = "models/weapons/arccw/atts/dc17c_sight.mdl"
att.HideModel = false
att.ModelScale = Vector(1.4, 1.4, 1.4)
att.ModelOffset = Vector(0, 0, 0)
att.OffsetAng = Angle(0, 90, 0)
att.AdditionalSights = {
    {
        Pos = Vector(0, 11.5, -2.3),
        Ang = Angle(0, 0, 0),
        Magnification = 2,
    }
}

att.Holosight = true
att.HolosightReticle = Material("#sw/visor/sw_ret_redux_blue.png", "smooth")
att.HolosightNoFlare = false
att.HolosightSize = 6
att.HolosightBone = "holosight"
att.HolosightPiece = "models/weapons/arccw/atts/dc17c_hsp.mdl"

att.HolosightMagnification = 2
att.HolosightBlackbox = true
att.HolosightNoHSP = false

att.Mult_SightTime = 1.08
att.Mult_SightedSpeedMult = 0.94
--addons/arccw_weapons/lua/arccw/shared/attachments/perk_handyman.lua:
att.PrintName = "Handyman"
att.Icon = Material("interfaz/iconos/kraken/jedi guns dirty fighting/3726085931_3536543931.png")
att.Description = "Operate the firearm using only one hand. This improves weapon mobility, but accurate fire becomes difficult at best and near impossible at worst.\nBecause accuracy is already out the window, practictioners of this style also opt to shoot while sprinting at full speed."
att.Desc_Pros = {
    "+6% Coolness"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true

att.Override_ShootWhileSprint = true
att.Mult_HipDispersion = 0.75

att.Mult_Recoil = 1.5
att.Mult_RecoilSide = 2
att.Mult_SightTime = 1.5
att.Mult_Sway = 2
--att.Mult_MoveDispersion = 2
att.Mult_MoveSpeed = .95

att.LHIK = true
att.LHIKHide = true
att.Override_HoldtypeActive = "pistol"
att.Override_HoltypeActive_Priority = 999
att.Override_HoldtypeSights = "pistol"
att.Override_HoltypeSights_Priority = 999
att.Override_HoldtypeHolstered = "normal"

att.Hook_Compatible = function(wep, data)
    if wep:GetIsManualAction() and wep:GetBuff("HoldtypeActive") ~= "pistol" and wep:GetBuff("HoldtypeActive") ~= "revolver" then return false end
end

att.NotForNPCs = true
--addons/arccw_weapons/lua/arccw/shared/attachments/rep_ubgl.lua:
att.PrintName = "Underbarrel Grenade-Launcher"
att.AbbrevName = "Underbarrel Grenade-Launcher"
att.Icon = Material("interfaz/iconos/jedi/453218427_4064545516.png", "mips smooth")
att.Description = "Single-shot underbarrel grenade launcher designed to Special Infantry."

att.SortOrder = -100000

att.AutoStats = true
att.Desc_Pros = {
}
att.Slot = "rep_ubgl"
att.ExcludeFlags = {"uc_noubgl"}
att.LHIK = true
att.ModelOffset = Vector(0, 0, 0)
att.Model = "models/weapons/arccw/atts/uc_ubgl_m203.mdl"
att.SelectUBGLSound =  ""
att.ExitUBGLSound = ""
att.UBGL = true
att.UBGL_PrintName = "UBGL"
att.UBGL_Automatic = false
--att.UBGL_MuzzleEffect = "wpn_muzzleflash_dc17_orange"
att.UBGL_Ammo = "Grenade"
att.UBGL_RPM = 120
att.UBGL_Recoil = 2
att.UBGL_Capacity = 1
att.UBGL_ClipSize = 1
att.LHIK_GunDriver = 2
att.LHIK_CamDriver = 3

local function Ammo(wep)
    return (wep:GetOwner():GetAmmoCount("Grenade"))
end

att.Hook_LHIK_TranslateAnimation = function(wep, key)
    if key == "idle" then
        if wep:GetInUBGL() then
            return "idle_armed"
        else
            return "idle"
        end
    end
end

att.Hook_ShouldNotSight = function(wep)
    if wep:GetInUBGL() then
        return true
    end
end

att.Hook_OnSelectUBGL = function(wep)
    wep:SetNextSecondaryFire(CurTime() + 0.7)
    if (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoLHIKAnimation("to_armed", 0.7)
        wep:PlaySoundTable({
            {s = "arccw_uc/common/rattle_b2i_rifle.ogg", t = 0},
            {s = "arccw_uc/common/raise.ogg", t = 0.2},
            {s = "arccw_uc/common/grab.ogg", t = 0.5},
        })
    end
end

att.Hook_OnDeselectUBGL = function(wep)
    wep:SetNextSecondaryFire(CurTime() + 0.7)
    if (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoLHIKAnimation("to_idle", 0.7)
        wep:PlaySoundTable({
            {s = "arccw_uc/common/rattle_b2i_rifle.ogg", t = 0},
            {s = "arccw_uc/common/shoulder.ogg", t = 0.4},
        })
    end
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    local owner = wep:GetOwner()
    local class = wep:GetBuff_Override("UBGL_Entity") or "tfa_battlefront_ent_nade_impact"

    if class == "BUCKSHOT" then
        local dir = (owner:EyeAngles() + wep:GetFreeAimOffset()):Forward()

        local bullet = {
            DamageMax = 18,
            DamageMin = 6,
            Range = 50,
            RangeMin = 5,
            DamageType = DMG_BUCKSHOT + DMG_BULLET,
            Penleft = 0,
            Penetration = 0,
            Num = 1,
            Damaged = {},
            Weapon = wep,
        }

        local data = {
            Attacker = owner,
            Dir        = dir,
            Src        = wep:GetShootSrc(),
            Spread     = Vector(0, 0, 0),
            Damage     = 0,
            Num        = 1,
            Force      = 5,
            HullSize   = 4,
            Weapon     = wep,
            Callback = function(attacker, tr, dmg)
                -- HACK: Pass a fake bullet table instead of ourselves so we don't use the weapon's attributes unintentionally
                bullet.Travelled = (tr.HitPos - tr.StartPos):Length()
                ArcCW:BulletCallback(att, tr, dmg, bullet)
            end
        }

        if wep:GetOwner():IsPlayer() then
            for n = 1, 20 do
                local dirry = Vector(dir.x, dir.y, dir.z)
                math.randomseed(math.Round(util.SharedRandom(n, -1337, 1337, !game.SinglePlayer() and wep:GetOwner():GetCurrentCommand():CommandNumber() or CurTime()) * (wep:EntIndex() % 30241)))
                wep:ApplyRandomSpread(dirry, ArcCW.MOAToAcc * 50)
                data.Dir = dirry
                if GetConVar("arccw_bullet_enable"):GetBool() then
                    ArcCW:ShootPhysBullet(wep, data.Src, (250 / ArcCW.HUToM) * data.Dir:GetNormalized(), 0, bullet)
                else
                    owner:FireBullets(data, true)
                end
            end
        else
            data.Spread = Vector(ArcCW.MOAToAcc * 50, ArcCW.MOAToAcc * 50, 0)
            data.Num = 20
            owner:FireBullets(data, true)
        end
        wep:MyEmitSound(")^/arccw_uc/common/gl_fire_buck.ogg", 100, 100, 1, CHAN_WEAPON )
        wep:MyEmitSound(")^/arccw_uc/common/gl_fire_buck_dist.ogg", 149, 100, 0.5, CHAN_WEAPON + 1)
    else
        local proj = wep:FireRocket(class, 2500)
        if SERVER then
            proj.Damage = 130 -- lower than the m79 (200) for balance reasons
        end
        wep:MyEmitSound(")^/arccw_uc/common/40mm/fire-0" .. math.random(1, 6) .. ".ogg", 100, 100, 1, CHAN_WEAPON)
        wep:MyEmitSound(")^/arccw_uc/common/40mm/fire-dist-0" .. math.random(1, 6) .. ".ogg", 149, 100, 0.5, CHAN_BODY)
        wep:MyEmitSound(")^/arccw_uc/common/40mm/mech-0" .. math.random(1, 6) .. ".ogg", 149, 100, 0.5, CHAN_AUTO)
    end

    if game.SinglePlayer() and SERVER or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoEffects()
        wep:DoLHIKAnimation("fire")
    end
    wep:SetClip2(wep:Clip2() - 1)
    wep:DoEffects()
end

local casing = {"arccw_uc/common/40mm/casing-40mm-01.ogg", "arccw_uc/common/40mm/casing-40mm-02.ogg", "arccw_uc/common/40mm/casing-40mm-03.ogg", "arccw_uc/common/40mm/casing-40mm-04.ogg", "arccw_uc/common/40mm/casing-40mm-05.ogg", "arccw_uc/common/40mm/casing-40mm-06.ogg"}

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end
    if Ammo(wep) <= 0 then return end

    wep:SetNextSecondaryFire(CurTime() + 2.75)

    local holy = (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted())
    if holy then
        wep:DoLHIKAnimation("reload", 2.75)
        wep:PlaySoundTable({
            {s = { "arccw_uc/common/rattle1.ogg", "arccw_uc/common/rattle2.ogg", "arccw_uc/common/rattle3.ogg" }, t = 0},
            {s = "arccw_uc/common/40mm/203open.ogg", t = 0.2},
            {s = casing, t = 0.7},
            {s = "arccw_uc/common/magpouch_replace_small.ogg", t = 0.9},
            {s = "arccw_uc/common/40mm/203insert.ogg", t = 1.2},
            {s = "arccw_uc/common/shoulder.ogg", t = 1.5},
            {s = "arccw_uc/common/40mm/203close.ogg", t = 1.7},
            {s = "arccw_uc/common/shoulder.ogg", t = 2.3},
        })
    end

    local reserve = Ammo(wep)
    reserve = reserve + wep:Clip2()
    local clip = 1
    local load = math.Clamp(clip, 0, reserve)
    wep:SetClip2(load)
end

att.Mult_SightTime = 1.2
att.Mult_SpeedMult = 0.9
att.Mult_SightedSpeedMult = 0.85
att.ToggleLockDefault = false
att.ToggleStats = {
    {
        PrintName = "Impact Grenade",
        UBGL_Entity = "tfa_battlefront_ent_nade_impact"
    },
    {
        PrintName = "Poison Grenade",
        UBGL_Entity = "tfa_battlefront_ent_nade_poison"
    },
    {
        PrintName = "Smoke Grenade",
        UBGL_Entity = "tfa_battlefront_ent_nade_smoke"
    },
    {
        PrintName = "Bacta Grenade",
        UBGL_Entity = "tfa_battlefront_ent_nade_heal"
    }
}
--addons/arccw_weapons/lua/arccw/shared/attachments/st_cr2.lua:
att.PrintName = "CR-2 Stock"
att.PrintName = "CR-2 Stock"
att.Icon = Material("interfaz/iconos/kraken/jedi vang shield specialist/4102273676_3304716367.png")
att.Description = ""
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = "stock"

att.Model = "models/sw_battlefront/weapons/mods/cr2_stock_default.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(0, 0, 0)
att.ModelOffset = Vector(0, 0, 0)
att.ModelScale = Vector(1, 1, 1)

att.AutoStats = true
att.HideIfBlocked = true

att.Mult_Damage = 1.05
att.Mult_SightTime = 1.05
att.Mult_Sway = 1.0
att.Mult_RPM = 1.2
att.Mult_SpeedMult = 1.1

att.Mult_DrawTime = 1.1
att.Mult_HolsterTime = 1.05

att.Mult_HipDispersion = 1.05

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--addons/arccw_weapons/lua/arccw/shared/attachments/sw_mag_dc15a_60mag.lua:
att.PrintName = "SW-Extended Magazine"
att.AbbrevName = "60-Round Mag"
att.SortOrder = 100
att.Icon = nil
att.Description = "Extended magazine, ideal for additional fire support. Slight Bulky construction and additional ammo capacity increases weight, making the weapon difficult to handle"
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "dc15a_magazine"

att.Model = "models/weapons/arccw/atts/magazine/a280_cell_mod.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(0, -90, 90)
att.ModelOffset = Vector(-0.9, -0.3, -2.8)
att.ModelScale = Vector(1.5, 1.5, 1.5)

att.AutoStats = true

att.HideIfBlocked = true

att.Override_ClipSize = 60

att.Mult_SightTime = 1.05
att.Mult_Sway = 2.1

att.Mult_SpeedMult = 0.95
att.Mult_ShootSpeedMult = 0.95

att.Mult_DrawTime = 1.25
att.Mult_HolsterTime = 1.25

att.Mult_HipDispersion = 1.3

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--addons/arccw_weapons/lua/arccw/shared/attachments/sw_stun15.lua:
att.PrintName = "Betäubung - 15s"
att.AbbrevName = "Betäubung - 15s"
att.Icon = Material("interfaz/iconos/dpsicon.png")
att.Description = "Replace the main-fire for stun rounds."

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"aocrp_ammo"}

att.AutoStats = true
att.Override_AmmoPerShot = 5
att.Override_Tracer = "effect_sw_laser_blue_stun"
att.Hook_BulletHit = function(wep, data)
	GMSERV:AddStatus(data.tr.Entity, data.att, "stun", 15, 1, true) --Entity,Owner,Status Effect Type (Yes, you can add the others),Duration, Damage, ParticleEffect
end
att.Hook_GetShootSound = function(wep, sound)
    return false
end
att.Hook_AddShootSound = function(wep, data)
    wep:MyEmitSound("everfall/weapons/republic/stun.wav", data.volume, data.pitch, 1, CHAN_WEAPON - 1)
end
--addons/arccw_weapons/lua/arccw/shared/attachments/sw_stun5.lua:
att.PrintName = "Betäubung - 5s"
att.AbbrevName = "Betäubung - 5s"
att.Icon = Material("interfaz/iconos/dpsicon2.png")
att.Description = "Replace the main-fire for stun rounds."

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"aocrp_ammo"}

att.AutoStats = true
att.Override_AmmoPerShot = 5
att.Override_Tracer = "effect_sw_laser_blue_stun"
att.Hook_BulletHit = function(wep, data)
	GMSERV:AddStatus(data.tr.Entity, data.att, "stun", 5, 1, true) --Entity,Owner,Status Effect Type (Yes, you can add the others),Duration, Damage, ParticleEffect
end
att.Hook_GetShootSound = function(wep, sound)
    return false
end
att.Hook_AddShootSound = function(wep, data)
    wep:MyEmitSound("everfall/weapons/republic/stun.wav", data.volume, data.pitch, 1, CHAN_WEAPON - 1)
end
--lua/arccw/shared/attachments/uc_40mm_airburst.lua:
att.PrintName = "40mm Airburst Grenades"
att.AbbrevName = "Airburst"
att.Icon = Material("entities/att/arccw_uc_40mm_generic.png", "mips smooth")
att.Description = "Grenades filled with fragmentation. While usually detonated by a time fuse, this one has been modified to detonate by proximity. Intended for indirect fire, the projectile is slow and has high drag, with a safety fuse to prevent point-blank detonations."
att.Desc_Pros = {
    "uc.40mm.airburst",
    "uc.40mm.proximity",
}
att.Desc_Cons = {
    "uc.40mm.mindmg",
    "uc.40mm.arm",
    "uc.40mm.drag.high",
}
att.Desc_Neutrals = {
}
att.Slot = "uc_40mm"

att.AutoStats = true

att.Override_ShootEntity = "arccw_uc_40mm_airburst"

att.Mult_MuzzleVelocity = 0.75

att.Mult_ShootPitch = 0.9

att.ActivateElements = {"40mm_airburst"}
--lua/arccw/shared/attachments/uc_ammo_sg_frag.lua:
att.PrintName = "\"HE\" FRAG-12"
att.Icon = Material("entities/att/arccw_uc_ammo_shotgun_generic.png", "mips smooth")
att.Description = [[Shotgun slug with a small high-explosive warhead. On impact, the round saturates its surroundings with shrapnel like a frag grenade.
Meant for breaching, but it can also useful for applying damage over an area.
Beware: the explosion doesn't care who it hurts.

Only compatible with manual action shotguns due to a weak pressure curve.]]
att.Desc_Pros = {
    "uc.explode"
}
att.Desc_Cons = {
    "uc.alwaysphys",
}
att.Desc_Neutrals = {
    "uc.oneprojectile",
    "uc.manualonly",
}
att.SortOrder = 2

att.Slot = {"ud_ammo_shotgun", "uc_ammo"}

att.Mult_Penetration = 0.1
att.Mult_Damage = 0.75
att.Mult_DamageMin = 0.75
att.Mult_Range = .5
att.Mult_HipDispersion = 1.5
att.Override_Num = 1
att.Override_Num_Priority = 99
att.AutoStats = true

att.Override_HullSize = 0

att.ActivateElements = {"uc_manualonly"}
att.GivesFlags = {"uc_slug"}

att.Override_AlwaysPhysBullet = true
att.Mult_PhysBulletGravity = 1.5
att.Override_PhysBulletImpact = false

att.Hook_PhysBulletHit = function(wep, data)
    if SERVER then
    local delta = data.bullet.Travelled / (data.bullet.Range / ArcCW.HUToM)
    delta = math.Clamp(delta, 0, 1)
    local dmg = Lerp(delta, data.bullet.DamageMax, data.bullet.DamageMin)

    util.BlastDamage(wep, wep:GetOwner(), data.tr.HitPos, 128, dmg)

    local eff = EffectData()
    eff:SetOrigin(data.tr.HitPos)
    eff:SetMagnitude(4)
    eff:SetScale(0.5)
    eff:SetRadius(4)
    util.Effect("Sparks", eff)
    util.Effect("Explosion", eff)
    util.Decal("Scorch", data.tr.HitPos - data.tr.HitNormal, data.tr.HitPos + data.tr.HitNormal, ents.GetAll())
    end
end

att.Override_UC_ShellColor = Color(0.9 * 255, 0.7 * 255, 0.3 * 255)

att.Hook_Compatible = function(wep)
    if (!wep.ManualAction and !wep.UC_CanManualAction) or !wep:GetIsShotgun() or wep:GetBuff_Override("UC_Shotshell") then return false end
end
--lua/arccw/shared/attachments/uc_charm_sgmanual.lua:
att.PrintName = "Slugger"

att.SortOrder = 1
att.Icon = Material("entities/att/arccw_uc_ammo_shotgun_generic.png", "mips smooth")
att.Description = "Forces weapons to only use manual-action modes. Not the most competitively viable, but it surely shows you can still kick ass without all those fancy-shmancy automatic modes."
att.Desc_Pros = {
}
att.Desc_Cons = {
    "uc.manualonly",
}
att.Slot = "charm"
att.AutoStats = true

att.ActivateElements = {"uc_manualonly"}
att.GivesFlags = {"needsmanual"}
att.Hook_Compatible = function(wep)
    if (!wep.ManualAction and !wep.UC_CanManualAction) or !wep:GetIsShotgun() then return false end
end

att.Ignore = true
--lua/arccw/shared/attachments/uc_charm_urbancharm_ordinance.lua:
att.PrintName = "Urban Charm - Ordinance"
att.Description = "The icon of a Garry's Mod addon."
att.Ignore = true

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "charm"

att.Free = true

att.Model = "models/weapons/arccw/atts/charmbase.mdl"

att.DroppedModel = "models/Items/BoxSRounds.mdl"

att.Charm = true
att.CharmModel = "models/weapons/arccw/atts/uc_urbancharm.mdl"
att.CharmAtt = "Charm"
att.CharmScale = Vector(0.5, 0.5, 0.5)
att.CharmOffset = Vector(0, -1.1, -0.2)
att.CharmAngle = Angle(20, 0, 80)
att.CharmSkin = 4

--lua/arccw/shared/attachments/uc_muzzle_supp_lighthouse.lua:
att.PrintName = "L15 'Lighthouse' Suppressor" -- fictional
att.AbbrevName = "Lighthouse Suppressor"

att.Icon = Material("entities/att/acwatt_uc_muzzle_supp_lighthouse.png", "mips smooth")
att.Description = "Traps propellant gas from the muzzle, reducing visual and audible report.\nImproves close range stopping power slightly due to redirection of gas pressure."
att.Desc_Neutrals = {"uc.exclusive.rifle", "uc.supptail"}

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/weapons/arccw/atts/ud_silencer_light.mdl"
att.ModelOffset = Vector(-0.25, 0, 0)
att.OffsetAng = Angle(0, 180, 0)

att.Silencer = true
att.Override_MuzzleEffect = "muzzleflash_suppressed"
att.IsMuzzleDevice = true

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 0.75
att.Mult_Range = 0.85
att.Mult_RangeMin = 1.75

att.Add_BarrelLength = 5
att.Mult_SightTime = 1.1
att.Mult_Sway = 1.15

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"

att.Hook_Compatible = function(wep,data)
    if !ArcCW.UC.RifleAmmoTypes[wep:GetBuff_Override("Override_Ammo", wep.Primary.Ammo)] then
        return false
    end
end

att.Hook_GetDistantShootSound = function(wep, distancesound)
    if wep:GetBuff("PhysBulletMuzzleVelocity") < ArcCW.UC.SubsonicThreshold then
        return false
    end
end
--lua/arccw/shared/attachments/uc_optic_annihilator.lua:
att.PrintName = "Annihilator Handcannon Laser"
att.AbbrevName = "Annihilator Laser"
att.Icon = Material("entities/att/acwatt_uc_optic_annihilator.png", "mips smooth")
att.Description = "Oversized laser module with iron sights, attached on the upper rail."
att.Desc_Cons = {
    "con.beam"
}
att.AutoStats = true

att.Slot = {"ur_deagle_tritium"} -- Deagle exclusive until we figure out the problem with the model
att.SortOrder = 998 -- Remove when att becomes universal

att.Model = "models/weapons/arccw/atts/ur_annihilator_laser.mdl"
att.ModelOffset = Vector(-6,0,-3.5) -- Will need to change when the model recompiles
att.ModelScale = Vector( 0.933, 0.933, 0.933 )

att.Mult_Sway = 1.5
att.Mult_SightTime = 1.25
att.Mult_SpeedMult = 0.975

att.AdditionalSights = {
    {
        Pos = Vector(0, 20, -1.62),
        Ang = Angle(-.2, 0, 0),
        Magnification = 1,
    }
}

att.LaserStrength = 2
att.ToggleStats = {
    {
        PrintName = "On",
        Laser = true,
        LaserBone = "laser",
        LaserColor = Color(50, 255, 50),
        Mult_HipDispersion = 0.75,
        Mult_MoveDispersion = 0.6,
        Mult_SightTime = 0.85
    },
    {
        PrintName = "Off",
        Laser = false,
    },
}
--lua/arccw/shared/attachments/uc_optic_hamr.lua:
att.PrintName = "Leupold Mark 4 High Accuracy Multi-Range Riflescope (3x/HOLO)"
att.AbbrevName = "HAMR (3x/HOLO)"
att.Icon = Material("entities/att/acwatt_uc_optic_hamr.png", "mips smooth")
att.Description = "Top-of-the-line magnified combat optic with an integral DeltaPoint.\nThough it is moderately heavy, a skilled operator will be able to make use of it at every typical engagement distance."

att.SortOrder = 3

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Neutrals = {"uc.bus"}

att.AutoStats = true
att.Slot = {"optic", "ud_optic", "ud_acog"}

att.Model = "models/weapons/arccw/atts/uc_gso_hamr.mdl"
att.ModelOffset = Vector(0, 0, -0.1)
att.ModelScale = Vector(1, 1, 1)
att.OffsetAng = Angle(0, 0, 0)

att.AdditionalSights = {
    {
        Pos = Vector(0, 8, -1.43),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ViewModelFOV = 38,
        IgnoreExtra = true,
        CrosshairInSights = false,
        HolosightBone = "holosight",
        HolosightData = {
            Holosight = true,
            HolosightReticle = Material("hud/scopes/uc_hamr.png", "smooth"),
            HolosightNoFlare = true,
            HolosightSize = 11.5,
            HolosightPiece = "models/weapons/arccw/atts/uc_gso_hamr_hsp.mdl",
            HolosightBlackbox = true,
            HolosightMagnification = UC_HalfScope( 3 ),
            Colorable = true,
        },
    },
    {
        Pos = Vector(0, 8, -2.84738),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        IgnoreExtra = true,
        HolosightData = {
            Holosight = true,
            HolosightReticle = Material("hud/reticles/uc_reddot.png", "mips smooth"),
            HolosightSize = 2,
            Colorable = true,
        },
    },
}

att.Colorable = true
att.HolosightPiece = "models/weapons/arccw/atts/uc_gso_hamr_hsp.mdl"

att.Mult_SightedSpeedMult = 0.75
att.Mult_SightTime = 1.1

--lua/arccw/shared/attachments/uc_optic_holosun2.lua:
att.PrintName = "Holosun HS510C (RDS)"
att.AbbrevName = "Holosun (RDS)"
att.Icon = Material("entities/att/acwatt_uc_optic_holosun2.png", "mips smooth")
att.Description = "Improves sighted visibility with a red-dot targeting reticle, while adding minimal extra weight."

att.SortOrder = 1

att.Desc_Pros = {
    "autostat.holosight",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = {"optic","optic_lp"}

att.Model = "models/weapons/arccw/atts/uc_holosun2.mdl"
att.ModelScale = Vector( 1.5, 1.5, 1.5 )
att.ModelOffset = Vector( -0.5, 0, 0 )

att.AdditionalSights = {
    {
        Pos = Vector(0, 9.5, -1.5 + (0.3285 * 1.5)),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ScrollFunc = ArcCW.SCROLL_NONE
    }
}

att.Holosight = true
att.HolosightReticle = Material("hud/reticles/uc_reddot.png", "mips smooth")
att.HolosightNoFlare = false
att.HolosightSize = 1.5
att.HolosightBone = "holosight"
att.Colorable = true

att.Mult_SightedSpeedMult = .9
--lua/arccw/shared/attachments/uc_optic_kobra.lua:
att.PrintName = "Kobra EKP-8-16 Reflex Sight (RDS)"
att.AbbrevName = "Kobra (RDS)"
att.Icon = Material("entities/att/acwatt_uc_optic_kobra.png", "mips smooth")
att.Description = "Improves sighted visibility with a red-dot targeting reticle, while adding minimal extra weight.\nExclusive to the \"Warsaw Pact\" optic mount, and is slightly more agile than rail mounted optics."

att.SortOrder = 299

att.Desc_Pros = {
    "autostat.holosight",
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "uc.swapreticle"
}
att.AutoStats = true
att.Slot = {"ur_ak_optic"}

att.Model = "models/weapons/arccw/atts/ur_kobra.mdl"
att.ModelOffset = Vector(-2, 0, -4.55)

local R1, R2, R3, R4 = Material("hud/reticles/uc_kobra1.png", "mips smooth"), Material("hud/reticles/uc_kobra2.png", "mips smooth"), Material("hud/reticles/uc_kobra3.png", "mips smooth"), Material("hud/reticles/uc_kobra4.png", "mips smooth")

att.AdditionalSights = {
    {
        Pos = Vector(0, 13, -1.3),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ScrollFunc = ArcCW.SCROLL_NONE,

        HolosightData = {
            HolosightReticle = R1,
            HolosightPiece = "models/weapons/arccw/atts/ur_kobra_hsp.mdl",
            HolosightNoFlare = true,
            HolosightSize = 1.5,
            HolosightBone = "holosight",
            Colorable = true
        }
    },
    {
        Pos = Vector(0, 13, -1.3),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ScrollFunc = ArcCW.SCROLL_NONE,

        HolosightData = {
            HolosightReticle = R2,
            HolosightPiece = "models/weapons/arccw/atts/ur_kobra_hsp.mdl",
            HolosightNoFlare = true,
            HolosightSize = 2,
            HolosightBone = "holosight",
            Colorable = true
        }
    },
    {
        Pos = Vector(0, 13, -1.3),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ScrollFunc = ArcCW.SCROLL_NONE,

        HolosightData = {
            HolosightReticle = R3,
            HolosightPiece = "models/weapons/arccw/atts/ur_kobra_hsp.mdl",
            HolosightNoFlare = true,
            HolosightSize = 2,
            HolosightBone = "holosight",
            Colorable = true
        }
    },
    {
        Pos = Vector(0, 13, -1.3),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ScrollFunc = ArcCW.SCROLL_NONE,

        HolosightData = {
            HolosightReticle = R4,
            HolosightPiece = "models/weapons/arccw/atts/ur_kobra_hsp.mdl",
            HolosightNoFlare = true,
            HolosightSize = 2,
            HolosightBone = "holosight",
            Colorable = true
        }
    },
}

att.Holosight = true
att.HolosightPiece = "models/weapons/arccw/atts/ur_kobra_hsp.mdl"
att.Mult_SightedSpeedMult = 0.925

att.ExcludeFlags = {"ak_norail","cover_rail"}

--lua/arccw/shared/attachments/uc_powder_high.lua:
att.PrintName = "Increased Load"

att.SortOrder = 19
att.Icon = Material("entities/att/acwatt_uc_powder_high.png", "smooth mips")
att.Description = "Ammunition loaded with a higher amount of powder, slightly increasing ballistic performance."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_powder"

att.AutoStats = true

att.Mult_Recoil = 1.15
att.Mult_Range = 1.2

att.Mult_ShootVol = 1.15
att.Mult_RPM = 1.04
--att.Mult_ShootPitch = 0.95 please don't

att.Mult_MalfunctionMean = 0.85
att.Mult_PhysBulletMuzzleVelocity = 1.1
--lua/arccw/shared/attachments/uc_powder_low.lua:
att.PrintName = "Reduced Load"

att.SortOrder = 18
att.Icon = Material("entities/att/acwatt_uc_powder_low.png", "smooth mips")
att.Description = "Underpressured ammunition places less strain on the weapon, but lowers muzzle velocity and cyclic rate."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_powder"

att.AutoStats = true

att.Mult_Recoil = 0.85
att.Mult_Range = 0.8

att.Mult_RPM = 0.95
att.Mult_ShootVol = 0.9
--att.Mult_ShootPitch = 1.05 please don't

att.Mult_MalfunctionMean = 1.15
att.Mult_PhysBulletMuzzleVelocity = 0.9
--lua/arccw/shared/attachments/uc_tac_flashlight3.lua:
att.PrintName = "High-Power Rail-Mounted Flashlight"
att.AbbrevName = "High-Power Flashlight"
att.Icon = Material("entities/att/acwatt_uc_tac_flashlight3.png", "mips smooth")
att.Description = "Illuminates dark areas in front of the muzzle.\nEmits a strong, orange-tinted light."
att.Desc_Pros = {
    "uc.light"
}
att.Desc_Cons = {
    "con.light"
}
att.Desc_Neutrals = {}
att.AutoStats = true

att.Slot = {"tac"}
att.SortOrder = 30+3

att.Model = "models/weapons/arccw/atts/uc_flashlight.mdl"
att.ModelOffset = Vector(0.5,0,-0.07)
att.OffsetAng = Angle(0,0,0)
att.ModelScale = Vector(0.75,0.75,0.75)

att.Flashlight = false
att.FlashlightFOV = 40
att.FlashlightFarZ = 1536 -- how far it goes
att.FlashlightNearZ = 1 -- how far away it starts
att.FlashlightAttenuationType = ArcCW.FLASH_ATT_LINEAR -- LINEAR, CONSTANT, QUADRATIC are available
att.FlashlightColor = Color(255, 229, 200)
att.FlashlightTexture = "effects/flashlight001"
att.FlashlightBrightness = 4
att.FlashlightBone = "flashlight"

att.ToggleStats = {
    {
        PrintName = "On",
        Flashlight = true
    },
    {
        PrintName = "Off",
        Flashlight = false,
    }
}
--lua/arccw/shared/attachments/uc_tp_gong.lua:
att.PrintName = "Action Hero"
att.Icon = Material("entities/att/arccw_uc_tp_actionhero.png", "smooth mips")
att.Description = "Operate the firearm using only one hand. This improves weapon mobility, but accurate fire becomes difficult at best and near impossible at worst.\nBecause accuracy is already out the window, practictioners of this style also opt to shoot while sprinting at full speed."
att.Desc_Pros = {
    --"+6% Coolness"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_tp"

att.AutoStats = true
att.SortOrder = 20

att.Override_ShootWhileSprint = true
att.Mult_HipDispersion = 0.75

att.Mult_Recoil = 1.5
att.Mult_RecoilSide = 2
att.Mult_SightTime = 1.5
att.Mult_Sway = 2
--att.Mult_MoveDispersion = 2
att.Mult_MoveSpeed = .95

att.LHIK = true
att.LHIKHide = true
att.Override_HoldtypeActive = "pistol"
att.Override_HoltypeActive_Priority = 999
att.Override_HoldtypeSights = "pistol"
att.Override_HoltypeSights_Priority = 999
att.Override_HoldtypeHolstered = "normal"

att.Hook_Compatible = function(wep, data)
    if wep:GetIsManualAction() and wep:GetBuff("HoldtypeActive") ~= "pistol" and wep:GetBuff("HoldtypeActive") ~= "revolver" then return false end
end

att.NotForNPCs = true
--lua/arccw/shared/attachments/uc_tp_quickdraw.lua:
att.PrintName = "Quick Draw"

att.Icon = Material("entities/att/arccw_uc_tp_quickdraw.png", "smooth mips")
att.Description = "Like the fastest guns in the Old West, you can draw, aim, and shoot in the blink of an eye.\n\nTexas Red had not cleared leather 'fore a bullet fairly ripped, and the Ranger's aim was deadly with the big iron on his hip."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_tp"

att.AutoStats = true
att.SortOrder = 5

att.Mult_DrawTime = 0.5
att.Mult_SightTime = 0.85

att.NotForNPCs = true
--lua/arccw/shared/attachments/uc_ubgl_m203.lua:
att.PrintName = "M203 Underbarrel Grenade Launcher"
att.AbbrevName = "M203 Grenade Launcher"
att.Icon = Material("entities/att/acwatt_uc_ubgl_m203.png", "mips smooth")
att.Description = "Single-shot underbarrel grenade launcher designed to replace the Colt XM148. Able to fire several basic 40x46mm grenade types."

att.SortOrder = -100000

att.AutoStats = true
att.Desc_Pros = {
}
att.Slot = "uc_ubgl"
att.ExcludeFlags = {"uc_noubgl"}

att.LHIK = true

att.ModelOffset = Vector(0, 0, 0)
att.Model = "models/weapons/arccw/atts/uc_ubgl_m203.mdl"

att.SelectUBGLSound =  ""
att.ExitUBGLSound = ""

att.UBGL = true

att.UBGL_PrintName = "UBGL"
att.UBGL_Automatic = false
att.UBGL_MuzzleEffect = "muzzleflash_m79"
att.UBGL_Ammo = "smg1_grenade"
att.UBGL_RPM = 120
att.UBGL_Recoil = 2

-- ??
att.UBGL_Capacity = 1
att.UBGL_ClipSize = 1

att.LHIK_GunDriver = 2
att.LHIK_CamDriver = 3

local pretty = GetConVar("arccw_uc_infiniteubwammo")

att.Hook_ModifyAttBodygroups = function(wep, data)
    if wep:GetBuff_Override("UC_UseClassicM203Mount") then
        data.element.Model:SetBodygroup(1, 1)
    end
end

local function Ammo(wep)
    return (pretty:GetBool() and 9999 or wep:GetOwner():GetAmmoCount("smg1_grenade"))
end

att.Hook_LHIK_TranslateAnimation = function(wep, key)
    if key == "idle" then
        if wep:GetInUBGL() then
            return "idle_armed"
        else
            return "idle"
        end
    end
end

att.Hook_ShouldNotSight = function(wep)
    if wep:GetInUBGL() then
        return true
    end
end

att.Hook_OnSelectUBGL = function(wep)
    wep:SetNextSecondaryFire(CurTime() + 0.7)
    if (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoLHIKAnimation("to_armed", 0.7)
        wep:PlaySoundTable({
            {s = "arccw_uc/common/rattle_b2i_rifle.ogg", t = 0},
            {s = "arccw_uc/common/raise.ogg", t = 0.2},
            {s = "arccw_uc/common/grab.ogg", t = 0.5},
        })
    end
end

att.Hook_OnDeselectUBGL = function(wep)
    wep:SetNextSecondaryFire(CurTime() + 0.7)
    if (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoLHIKAnimation("to_idle", 0.7)
        wep:PlaySoundTable({
            {s = "arccw_uc/common/rattle_b2i_rifle.ogg", t = 0},
            {s = "arccw_uc/common/shoulder.ogg", t = 0.4},
        })
    end
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    local owner = wep:GetOwner()
    local class = wep:GetBuff_Override("UBGL_Entity") or "arccw_uc_40mm_he"

    if class == "BUCKSHOT" then
        local dir = (owner:EyeAngles() + wep:GetFreeAimOffset()):Forward()

        local bullet = {
            DamageMax = 18,
            DamageMin = 6,
            Range = 50,
            RangeMin = 5,
            DamageType = DMG_BUCKSHOT + DMG_BULLET,
            Penleft = 0,
            Penetration = 0,
            Num = 1,
            Damaged = {},
            Weapon = wep,
        }

        local data = {
            Attacker = owner,
            Dir        = dir,
            Src        = wep:GetShootSrc(),
            Spread     = Vector(0, 0, 0),
            Damage     = 0,
            Num        = 1,
            Force      = 5,
            HullSize   = 4,
            Weapon     = wep,
            Callback = function(attacker, tr, dmg)
                -- HACK: Pass a fake bullet table instead of ourselves so we don't use the weapon's attributes unintentionally
                bullet.Travelled = (tr.HitPos - tr.StartPos):Length()
                ArcCW:BulletCallback(att, tr, dmg, bullet)
            end
        }

        if wep:GetOwner():IsPlayer() then
            for n = 1, 20 do
                local dirry = Vector(dir.x, dir.y, dir.z)
                math.randomseed(math.Round(util.SharedRandom(n, -1337, 1337, !game.SinglePlayer() and wep:GetOwner():GetCurrentCommand():CommandNumber() or CurTime()) * (wep:EntIndex() % 30241)))
                wep:ApplyRandomSpread(dirry, ArcCW.MOAToAcc * 50)
                data.Dir = dirry
                if GetConVar("arccw_bullet_enable"):GetBool() then
                    ArcCW:ShootPhysBullet(wep, data.Src, (250 / ArcCW.HUToM) * data.Dir:GetNormalized(), 0, bullet)
                else
                    owner:FireBullets(data, true)
                end
            end
        else
            data.Spread = Vector(ArcCW.MOAToAcc * 50, ArcCW.MOAToAcc * 50, 0)
            data.Num = 20
            owner:FireBullets(data, true)
        end
        wep:MyEmitSound(")^/arccw_uc/common/gl_fire_buck.ogg", 100, 100, 1, CHAN_WEAPON )
        wep:MyEmitSound(")^/arccw_uc/common/gl_fire_buck_dist.ogg", 149, 100, 0.5, CHAN_WEAPON + 1)
    else
        local proj = wep:FireRocket(class, 2500)
        if SERVER then
            proj.Damage = 130 -- lower than the m79 (200) for balance reasons
        end
        wep:MyEmitSound(")^/arccw_uc/common/40mm/fire-0" .. math.random(1, 6) .. ".ogg", 100, 100, 1, CHAN_WEAPON)
        wep:MyEmitSound(")^/arccw_uc/common/40mm/fire-dist-0" .. math.random(1, 6) .. ".ogg", 149, 100, 0.5, CHAN_BODY)
        wep:MyEmitSound(")^/arccw_uc/common/40mm/mech-0" .. math.random(1, 6) .. ".ogg", 149, 100, 0.5, CHAN_AUTO)
    end

    if game.SinglePlayer() and SERVER or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoEffects()
        wep:DoLHIKAnimation("fire")
    end
    wep:SetClip2(wep:Clip2() - 1)
    wep:DoEffects()
end

local casing = {"arccw_uc/common/40mm/casing-40mm-01.ogg", "arccw_uc/common/40mm/casing-40mm-02.ogg", "arccw_uc/common/40mm/casing-40mm-03.ogg", "arccw_uc/common/40mm/casing-40mm-04.ogg", "arccw_uc/common/40mm/casing-40mm-05.ogg", "arccw_uc/common/40mm/casing-40mm-06.ogg"}

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end
    if Ammo(wep) <= 0 then return end

    wep:SetNextSecondaryFire(CurTime() + 2.75)

    local holy = (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted())
    if holy then
        wep:DoLHIKAnimation("reload", 2.75)
        wep:PlaySoundTable({
            {s = { "arccw_uc/common/rattle1.ogg", "arccw_uc/common/rattle2.ogg", "arccw_uc/common/rattle3.ogg" }, t = 0},
            {s = "arccw_uc/common/40mm/203open.ogg", t = 0.2},
            {s = casing, t = 0.7},
            {s = "arccw_uc/common/magpouch_replace_small.ogg", t = 0.9},
            {s = "arccw_uc/common/40mm/203insert.ogg", t = 1.2},
            {s = "arccw_uc/common/shoulder.ogg", t = 1.5},
            {s = "arccw_uc/common/40mm/203close.ogg", t = 1.7},
            {s = "arccw_uc/common/shoulder.ogg", t = 2.3},
        })
    end

    local reserve = Ammo(wep)
    reserve = reserve + wep:Clip2()
    local clip = 1
    local load = math.Clamp(clip, 0, reserve)
    if (!pretty:GetBool()) then
        wep:GetOwner():RemoveAmmo(1, "smg1_grenade")
    end
    wep:SetClip2(load)
end

att.Mult_SightTime = 1.2
att.Mult_SpeedMult = 0.9
att.Mult_SightedSpeedMult = 0.85

att.ToggleLockDefault = true
att.ToggleStats = {
    {
        PrintName = "High Explosive",
        UBGL_Entity = "arccw_uc_40mm_he"
    },
    {
        PrintName = "Smoke",
        UBGL_Entity = "arccw_uc_40mm_smoke"
    },
    {
        PrintName = "Buckshot",
        UBGL_Entity = "BUCKSHOT"
    }
}
--addons/arccw_weapons/lua/arccw/shared/attachments/wepcamo_us.lua:
att.PrintName = "United States"
att.Description = "WHAT THE FUCK IS A KILOMETERRRRR, RAAAAAAAAAAAAHHHHHH"
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Slot = "rep_vibrocamo"
att.Free = true

att.ActivateElements = {"wepcamo-us"}
att.SortOrder = 2 *-1
--addons/arccw_weapons/lua/arccw/shared/sh_meeks_effects.lua:
game.AddParticles( "particles/apex_fx.pcf" )
game.AddParticles( "particles/melee_fx.pcf" )
--game.AddParticles( "particles/muzzleflashes_new.pcf" )

--NEW MUZZLES
PrecacheParticleSystem("wpn_muzzleflash_mgl_FULL")

--TRACERS
PrecacheParticleSystem("tfa_apex_tracer_anvil")
PrecacheParticleSystem("tfa_apex_tracer_ar")
PrecacheParticleSystem("tfa_apex_tracer_hmg")
PrecacheParticleSystem("tfa_apex_tracer_hmg_rampage")
PrecacheParticleSystem("tfa_apex_tracer_pistol")
PrecacheParticleSystem("tfa_apex_tracer_shotgun")
PrecacheParticleSystem("tfa_apex_tracer_smg")
PrecacheParticleSystem("tfa_apex_tracer_sniper")

-- MISC
PrecacheParticleSystem("tfa_apex_lstar_explode_core")
PrecacheParticleSystem("tfa_apex_arcstar_explode")
PrecacheParticleSystem("tfa_apex_frag_explode")
PrecacheParticleSystem("grenade_final")
PrecacheParticleSystem("tfa_apex_arcstar_impact")
PrecacheParticleSystem("tfa_apex_bocek_impact")
PrecacheParticleSystem("tfa_apex_bocek_trail")
PrecacheParticleSystem("tfa_apex_bullet_trail")
PrecacheParticleSystem("tfa_apex_bullet_energy_trail")
PrecacheParticleSystem("tfa_apex_bullet_sent_trail")
--addons/arccw_base_modified/lua/arccw/shared/sh_move.lua:

function ArcCW.Move(ply, mv, cmd)
    local wpn = ply:GetActiveWeapon()

    if !wpn.ArcCW then return end

    local s = 1

    local sm = Lerp( ArcCW.ConVars["mult_movespeed"]:GetFloat(), 1, math.Clamp(wpn.SpeedMult * wpn:GetBuff_Mult("Mult_SpeedMult") * wpn:GetBuff_Mult("Mult_MoveSpeed"), 0, 1) )

    -- look, basically I made a bit of an oopsy and uh this is the best way to fix that
    s = s * sm

    local basespd = (Vector(cmd:GetForwardMove(), cmd:GetUpMove(), cmd:GetSideMove())):Length()
    basespd = math.min(basespd, mv:GetMaxClientSpeed())

    local shotdelta = 0 -- how close should we be to the shoot speed mult
    local shottime = wpn:GetNextPrimaryFireSlowdown() - CurTime()

    local blocksprint = false

    if wpn:GetNWState() == ArcCW.STATE_SIGHTS or wpn:GetTriggerDelta() > 0 or
        wpn:GetNWState() == ArcCW.STATE_CUSTOMIZE then
        blocksprint = true
        s = s * Lerp( ArcCW.ConVars["mult_movespeedads"]:GetFloat() * (1-wpn:GetSightDelta()), 1, math.Clamp(wpn:GetBuff("SightedSpeedMult") * wpn:GetBuff_Mult("Mult_SightedMoveSpeed"), 0, 1) )
    elseif shottime > 0 or wpn:GetGrenadePrimed() then
        blocksprint = true

        if wpn:CanShootWhileSprint() then
            blocksprint = false
        end
    end

    if blocksprint then
        basespd = math.min(basespd, ply:GetWalkSpeed())
    end

    if wpn:GetInBipod() then
        s = 0.0001
    end

    if shottime > 0 then
        -- full slowdown for duration of firing
        shotdelta = 1
    else
        -- recover from firing slowdown after shadow duration
        local delay = wpn:GetFiringDelay()
        local aftershottime = -shottime / delay
        shotdelta = math.Clamp(1 - aftershottime, 0, 1)
    end
    local shootmove = Lerp( ArcCW.ConVars["mult_movespeedfire"]:GetFloat(), 1, math.Clamp(wpn:GetBuff("ShootSpeedMult"), 0.0001, 1) )
    s = s * Lerp(shotdelta, 1, shootmove)

    mv:SetMaxSpeed(basespd * s)
    mv:SetMaxClientSpeed(basespd * s)
    ply.ArcCW_LastTickSpeedMult = s -- in case other addons need it
end

hook.Add("SetupMove", "ArcCW_SetupMove", ArcCW.Move)

local limy_p = 45
local limy_n = -45
local limp_p = 30
local limp_n = -30

function ArcCW.CreateMove(cmd)
    local ply = LocalPlayer()
    local wpn = ply:GetActiveWeapon()

    if !wpn.ArcCW then return end

    if wpn:GetInBipod() and wpn:GetBipodAngle() then
        --[[]
        if !wpn:GetBipodAngle() then
            wpn:SetBipodPos(wpn:GetOwner():EyePos())
            wpn:SetBipodAngle(wpn:GetOwner():EyeAngles())
        end
        ]]

        local bipang = wpn:GetBipodAngle()
        local ang = cmd:GetViewAngles()

        local dy = math.AngleDifference(ang.y, bipang.y)
        local dp = math.AngleDifference(ang.p, bipang.p)

        if dy > limy_p then
            ang.y = bipang.y + limy_p
        elseif dy < limy_n then
            ang.y = bipang.y + limy_n
        end

        if dp > limp_p then
            ang.p = bipang.p + limp_p
        elseif dp < limp_n then
            ang.p = bipang.p + limp_n
        end

        cmd:SetViewAngles(ang)
    end
end

hook.Add("CreateMove", "ArcCW_CreateMove", ArcCW.CreateMove)

local function tgt_pos(ent, head)
    local mins, maxs = ent:WorldSpaceAABB()
    local pos = ent:WorldSpaceCenter()
    pos.z = pos.z + (maxs.z - mins.z) * 0.2 -- Aim at chest level
    if head and ent:GetAttachment(ent:LookupAttachment("eyes")) ~= nil then
        pos = ent:GetAttachment(ent:LookupAttachment("eyes")).Pos
    end
    return pos
end

local lst = SysTime()

function ArcCW.StartCommand(ply, ucmd)
    -- Sprint will not interrupt a runaway burst
    local wep = ply:GetActiveWeapon()
    if ply:Alive() and IsValid(wep) and wep.ArcCW and wep:GetBurstCount() > 0
            and ucmd:KeyDown(IN_SPEED) and wep:GetCurrentFiremode().RunawayBurst
            and !wep:CanShootWhileSprint() then
        ucmd:SetButtons(ucmd:GetButtons() - IN_SPEED)
    end

    -- Holster code
    if IsValid(wep) and wep.ArcCW and wep:GetHolster_Time() != 0 and wep:GetHolster_Time() <= CurTime() and IsValid(wep:GetHolster_Entity()) then
        wep:SetHolster_Time(-math.huge)
        ucmd:SelectWeapon(wep:GetHolster_Entity())
    end


    -- Aim assist
    if CLIENT and IsValid(wep) and wep.ArcCW
            and (wep:GetBuff("AimAssist", true) or (ArcCW.ConVars["aimassist"]:GetBool() and ply:GetInfoNum("arccw_aimassist_cl", 0) == 1))  then
        local cone = wep:GetBuff("AimAssist", true) and wep:GetBuff("AimAssist_Cone") or ArcCW.ConVars["aimassist_cone"]:GetFloat()
        local dist = wep:GetBuff("AimAssist", true) and wep:GetBuff("AimAssist_Distance") or ArcCW.ConVars["aimassist_distance"]:GetFloat()
        local inte = wep:GetBuff("AimAssist", true) and wep:GetBuff("AimAssist_Intensity") or ArcCW.ConVars["aimassist_intensity"]:GetFloat()
        local head = wep:GetBuff("AimAssist", true) and wep:GetBuff("AimAssist_Head") or ArcCW.ConVars["aimassist_head"]:GetBool()

        -- Check if current target is beyond tracking cone
        local tgt = ply.ArcCW_AATarget
        if IsValid(tgt) and (tgt_pos(tgt, head) - ply:EyePos()):Cross(ply:EyeAngles():Forward()):Length() > cone * 2 then ply.ArcCW_AATarget = nil end -- lost track

        -- Try to seek target if not exists
        tgt = ply.ArcCW_AATarget
        if !IsValid(tgt) or (tgt.Health and tgt:Health() <= 0) or util.QuickTrace(ply:EyePos(), tgt_pos(tgt, head) - ply:EyePos(), ply).Entity ~= tgt then
            local min_diff
            ply.ArcCW_AATarget = nil
            for _, ent in ipairs(ents.FindInCone(ply:EyePos(), ply:EyeAngles():Forward(), dist, math.cos(math.rad(cone)))) do
                if ent == ply or (!ent:IsNPC() and !ent:IsNextBot() and !ent:IsPlayer()) or ent:Health() <= 0
                        or (ent:IsPlayer() and ent:Team() ~= TEAM_UNASSIGNED and ent:Team() == ply:Team()) then continue end
                local tr = util.TraceLine({
                    start = ply:EyePos(),
                    endpos = tgt_pos(ent, head),
                    mask = MASK_SHOT,
                    filter = ply
                })
                if tr.Entity ~= ent then continue end
                local diff = (tgt_pos(ent, head) - ply:EyePos()):Cross(ply:EyeAngles():Forward()):Length()
                if !ply.ArcCW_AATarget or diff < min_diff then
                    ply.ArcCW_AATarget = ent
                    min_diff = diff
                end
            end
        end

        -- Aim towards target
        tgt = ply.ArcCW_AATarget
        if wep:GetState() ~= ArcCW.STATE_CUSTOMIZE and wep:GetState() ~= ArcCW.STATE_SPRINT and IsValid(tgt) then
            local ang = ucmd:GetViewAngles()
            local pos = tgt_pos(tgt, head)
            local tgt_ang = (pos - ply:EyePos()):Angle()
            local ang_diff = (pos - ply:EyePos()):Cross(ply:EyeAngles():Forward()):Length()
            if ang_diff > 0.1 then
                ang = LerpAngle(math.Clamp(inte / ang_diff, 0, 1), ang, tgt_ang)
                ucmd:SetViewAngles(ang)
            end
        end
    end

    if CLIENT and IsValid(wep) and wep.ArcCW then
        local ang2 = ucmd:GetViewAngles()
        local ft = (SysTime() - (lst or SysTime())) * GetConVar("host_timescale"):GetFloat()

        local recoil = Angle()
        recoil = recoil + (wep:GetBuff_Override("Override_RecoilDirection") or wep.RecoilDirection) * wep.RecoilAmount
        recoil = recoil + (wep:GetBuff_Override("Override_RecoilDirectionSide") or wep.RecoilDirectionSide) * wep.RecoilAmountSide
        ang2 = ang2 - (recoil * ft * 30)
        ucmd:SetViewAngles(ang2)

        local r = wep.RecoilAmount
        local rs = wep.RecoilAmountSide
        wep.RecoilAmount = math.Approach(wep.RecoilAmount, 0, ft * 20 * r)
        wep.RecoilAmountSide = math.Approach(wep.RecoilAmountSide, 0, ft * 20 * rs)
    end
    lst = SysTime()
end

hook.Add("StartCommand", "ArcCW_StartCommand", ArcCW.StartCommand)
--addons/arccw_base_modified/lua/arccw/shared/sh_util.lua:
-- Works around the 10 bodygroup limit on ENTITY:SetBodyGroups()
function ArcCW.SetBodyGroups(mdl, bodygroups)
    mdl:SetBodyGroups(bodygroups)
    local len = string.len(bodygroups or "")
    for i = 10, len - 1 do
        mdl:SetBodygroup(i, tonumber(string.sub(bodygroups, i + 1, i + 2)))
    end
end

-- doesn't work
function ArcCW.RotateAroundPoint(pos, ang, point, offset, offset_ang)
    local v = Vector(0, 0, 0)
    v = v + (point.x * ang:Right())
    v = v + (point.y * ang:Forward())
    v = v + (point.z * ang:Up())

    local newang = Angle()
    newang:Set(ang)

    newang:RotateAroundAxis(ang:Right(), offset_ang.p)
    newang:RotateAroundAxis(ang:Forward(), offset_ang.r)
    newang:RotateAroundAxis(ang:Up(), offset_ang.y)

    v = v + newang:Right() * offset.x
    v = v + newang:Forward() * offset.y
    v = v + newang:Up() * offset.z

    -- v:Rotate(offset_ang)

    v = v - (point.x * newang:Right())
    v = v - (point.y * newang:Forward())
    v = v - (point.z * newang:Up())

    return v + pos, newang
end

function ArcCW.RotateAroundPoint2(pos, ang, point, offset, offset_ang)

    -- debugoverlay.Cross(point, 1, 1, Color(255, 0, 0), true)

    local mat = Matrix()
    mat:SetTranslation(pos)
    mat:SetAngles(ang)
    -- debugoverlay.Cross(pos, 1.5, 1, Color(0, 0, 255), true)
    -- debugoverlay.Line(mat:GetTranslation(), mat:GetTranslation() + ang:Forward() * 32, 1, color_white, true)
    -- debugoverlay.Line(mat:GetTranslation(), point, 1, Color(255, 150, 150), true)

    mat:Translate(point)
    -- debugoverlay.Cross(mat:GetTranslation(), 2, 1, Color(255, 0, 255), true)

    local rot_mat = Matrix()
    rot_mat:SetAngles(offset_ang)
    rot_mat:Invert()
    mat:Mul(rot_mat)

    --mat:Rotate(offset_ang)
    mat:Translate(-point)

    mat:Translate(offset)

    -- debugoverlay.Cross(mat:GetTranslation(), 1, 1, Color(0, 255, 0), true)
    -- debugoverlay.Line(mat:GetTranslation(), mat:GetTranslation() + mat:GetAngles():Forward() * 8, 1, Color(0, 255, 0), true)

    return mat:GetTranslation(), mat:GetAngles()
end

-- See https://wiki.facepunch.com/gmod/Entity:GetAttachment
function ArcCW.FormatViewModelAttachment(nFOV, vOrigin, bFrom)
    local vEyePos = EyePos()
    local aEyesRot = EyeAngles()
    local vOffset = vOrigin - vEyePos
    local vForward = aEyesRot:Forward()
    local nViewX = math.tan(nFOV * math.pi / 360)

    if nViewX == 0 then
        vForward:Mul(vForward:Dot(vOffset))
        vEyePos:Add(vForward)

        return vEyePos
    end

    -- FIXME: LocalPlayer():GetFOV() should be replaced with EyeFOV() when it's binded
    local nWorldX = math.tan(LocalPlayer():GetFOV() * math.pi / 360)

    if nWorldX == 0 then
        vForward:Mul(vForward:Dot(vOffset))
        vEyePos:Add(vForward)

        return vEyePos
    end

    local vRight = aEyesRot:Right()
    local vUp = aEyesRot:Up()

    if bFrom then
        local nFactor = nWorldX / nViewX
        vRight:Mul(vRight:Dot(vOffset) * nFactor)
        vUp:Mul(vUp:Dot(vOffset) * nFactor)
    else
        local nFactor = nViewX / nWorldX
        vRight:Mul(vRight:Dot(vOffset) * nFactor)
        vUp:Mul(vUp:Dot(vOffset) * nFactor)
    end

    vForward:Mul(vForward:Dot(vOffset))
    vEyePos:Add(vRight)
    vEyePos:Add(vUp)
    vEyePos:Add(vForward)

    return vEyePos
end
--addons/arccw_base_modified/lua/arccw/client/cl_blacklist.lua:
local srf      = surface



local function ScreenScaleMulti(input)
    return ScreenScale(input) * ArcCW.ConVars["hud_size"]:GetFloat()
end

local blacklistWindow = nil
local blacklistTbl    = {}
local filter          = ""
local onlyblacklisted = false
local internalName    = false
local dragMode = nil

local color_arccwbred = Color(150, 50, 50, 255)
local color_arccwlred = Color(125, 25, 25, 150)
local color_arccwdred = Color(75, 0, 0, 150)
local color_arccwdtbl = Color(0, 0, 0, 200)

local function SaveBlacklist()
    -- We send ID over instead of strings to save on network costs
    -- optimization_is_optimization.png

    local blacklistAmt = 0

    for attName, bStatus in pairs(blacklistTbl) do
        if bStatus then blacklistAmt = blacklistAmt + 1 end
    end

    net.Start("arccw_blacklist")
        net.WriteBool(false)
        net.WriteUInt(blacklistAmt, ArcCW.GetBitNecessity())
        for attName, bStatus in pairs(blacklistTbl) do
            if bStatus then
                net.WriteUInt(ArcCW.AttachmentTable[attName].ID, ArcCW.GetBitNecessity())
            end
        end
    net.SendToServer()

    blacklistTbl = {}
end

local function CreateAttButton(parent, attName, attTbl)
    local attBtn = vgui.Create("DButton", parent)
    attBtn:SetFont("ArcCW_8")
    attBtn:SetText("")
    attBtn:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(16))
    attBtn:Dock(TOP)
    attBtn:DockMargin(ScreenScaleMulti(36), ScreenScaleMulti(1), ScreenScaleMulti(36), ScreenScaleMulti(1))
    attBtn:SetContentAlignment(5)

    attBtn.Paint = function(spaa, w, h)
        local blisted = blacklistTbl[attName]
        if blisted == nil then blisted = attTbl.Blacklisted end

        local hovered = spaa:IsHovered()
        local blackhov = blisted and hovered

        local Bfg_col = blackhov and color_arccwbred or blisted and color_arccwbred or hovered and color_black or color_white
        local Bbg_col = blackhov and color_arccwlred or blisted and color_arccwdred or hovered and color_white or color_arccwdtbl

        srf.SetDrawColor(Bbg_col)
        srf.DrawRect(0, 0, w, h)

        local img = attTbl.Icon
        if img then
            srf.SetDrawColor(Bfg_col)
            srf.SetMaterial(img)
            srf.DrawTexturedRect(ScreenScaleMulti(2), 0, h, h)
        end

        local txt = attTbl.PrintName
        if internalName then txt = attName end
        srf.SetTextColor(Bfg_col)
        srf.SetTextPos(ScreenScaleMulti(20), ScreenScaleMulti(2))
        srf.SetFont("ArcCW_12")
        srf.DrawText(txt)

        local listed   = (blacklistTbl[attName] and !attTbl.Blacklisted)
        local unlisted = (attTbl.Blacklisted and !blacklistTbl[attName])
        local saved = (listed or unlisted) and " [not saved]" or ""
        srf.SetTextColor(Bfg_col)
        srf.SetTextPos(spaa:GetWide() - ScreenScaleMulti(36), ScreenScaleMulti(4))
        srf.SetFont("ArcCW_8")
        srf.DrawText(saved)
    end

    -- In addition to clicking on a button, you can drag over all of them!
    attBtn.OnMousePressed = function(spaa, kc)
        blacklistTbl[attName] = !blacklistTbl[attName] and !attTbl.Blacklisted or !blacklistTbl[attName]
        dragMode = blacklistTbl[attName]
        hook.Add("Think", "ArcCW_Blacklist", function()
            if !input.IsMouseDown(MOUSE_LEFT) then
                dragMode = nil
                hook.Remove("Think", "ArcCW_Blacklist")
            end
        end)
    end
    attBtn.OnCursorEntered = function(spaa, kc)
        if dragMode != nil and input.IsMouseDown(MOUSE_LEFT) then
            blacklistTbl[attName] = dragMode
        end
    end

    return attBtn
end

function ArcCW.MakeBlacklistWindow()
    if blacklistWindow then blacklistWindow:Remove() end

    blacklistTbl = {}

    blacklistWindow = vgui.Create("DFrame")
    blacklistWindow:SetSize(ScrW() * 0.5, ScrH() * 0.75)
    blacklistWindow:Center()
    blacklistWindow:SetTitle("")
    blacklistWindow:SetDraggable(false)
    blacklistWindow:SetVisible(true)
    blacklistWindow:ShowCloseButton(true)
    blacklistWindow:MakePopup()
    blacklistWindow.Paint = function(self, w, h)
        srf.SetDrawColor(color_arccwdtbl)
        srf.DrawRect(0, 0, w, h)
    end

    local title = vgui.Create("DLabel", blacklistWindow)
    title:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(26))
    title:Dock(TOP)
    title:SetFont("ArcCW_24")
    title:SetText("ArcCW Blacklist")
    title:DockMargin(ScreenScaleMulti(16), 0, ScreenScaleMulti(16), ScreenScaleMulti(8))

    local desc = vgui.Create("DLabel", blacklistWindow)
    desc:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(12))
    desc:Dock(TOP)
    desc:DockMargin(ScreenScaleMulti(4), 0, ScreenScaleMulti(4), ScreenScaleMulti(4))
    desc:SetFont("ArcCW_12")
    desc:SetText("Attachments checked here will stop showing up at all.")
    desc:SetContentAlignment(5)

    local attList = vgui.Create("DScrollPanel", blacklistWindow)
    attList:SetText("")
    attList:Dock(FILL)
    attList:SetContentAlignment(5)
    attList.Paint = function(span, w, h) end

    local sbar = attList:GetVBar()
    sbar.Paint = function() end
    sbar.btnUp.Paint = function(span, w, h) end
    sbar.btnDown.Paint = function(span, w, h) end
    sbar.btnGrip.Paint = function(span, w, h)
        srf.SetDrawColor(color_white)
        srf.DrawRect(0, 0, w, h)
    end

    local FilterPanel = vgui.Create("DPanel", blacklistWindow)
    FilterPanel:Dock(TOP)
    FilterPanel:DockMargin(ScreenScaleMulti(16), ScreenScaleMulti(2), ScreenScaleMulti(16), ScreenScaleMulti(2))
    FilterPanel:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(12))
    FilterPanel:SetPaintBackground(false)

    local FilterLabel = vgui.Create("DLabel", FilterPanel)
    FilterLabel:Dock(LEFT)
    FilterLabel:SetWidth(ScreenScaleMulti(36))
    FilterLabel:DockMargin(ScreenScaleMulti(2), ScreenScaleMulti(2), ScreenScaleMulti(2), ScreenScaleMulti(2))
    FilterLabel:SetFont("ArcCW_12")
    FilterLabel:SetText("FILTER")

    local FilterButton = vgui.Create("DButton", FilterPanel)
    FilterButton:SetFont("ArcCW_8")
    FilterButton:SetText("")
    FilterButton:SetSize(ScreenScaleMulti(48), ScreenScaleMulti(12))
    FilterButton:Dock(RIGHT)
    FilterButton:DockMargin(ScreenScaleMulti(1), 0, 0, 0)
    FilterButton:SetContentAlignment(5)

    FilterButton.OnMousePressed = function(spaa, kc)
        onlyblacklisted = !onlyblacklisted

        attList:GenerateButtonsToList()
    end

    FilterButton.Paint = function(spaa, w, h)
        local hovered = spaa:IsHovered()

        local Bfg_col = hovered and color_black or color_white
        local Bbg_col = hovered and color_white or color_arccwdtbl

        srf.SetDrawColor(Bbg_col)
        srf.DrawRect(0, 0, w, h)

        spaa:SetTextColor(Bfg_col)
        spaa:SetText(onlyblacklisted and "BLACKLISTED" or "ALL")
    end

    local NameButton = vgui.Create("DButton", FilterPanel)
    NameButton:SetFont("ArcCW_8")
    NameButton:SetText("")
    NameButton:SetSize(ScreenScaleMulti(24), ScreenScaleMulti(12))
    NameButton:Dock(RIGHT)
    NameButton:DockMargin(ScreenScaleMulti(1), 0, 0, 0)
    NameButton:SetContentAlignment(5)

    NameButton.OnMousePressed = function(spaa, kc)
        internalName = !internalName
        attList:GenerateButtonsToList()
    end

    NameButton.Paint = function(spaa, w, h)
        local hovered = spaa:IsHovered()

        local Bfg_col = hovered and color_black or color_white
        local Bbg_col = hovered and color_white or color_arccwdtbl

        srf.SetDrawColor(Bbg_col)
        srf.DrawRect(0, 0, w, h)

        spaa:SetTextColor(Bfg_col)
        spaa:SetText(internalName and "ID" or "NAME")
    end

    local FilterEntry = vgui.Create("DTextEntry", FilterPanel)
    FilterEntry:Dock(FILL)
    FilterEntry:SetValue(filter)
    FilterEntry:SetFont("ArcCW_12")
    FilterEntry.OnChange = function( self )
        filter = self:GetValue():lower()

        attList:GenerateButtonsToList()
    end

    local accept = vgui.Create("DButton", blacklistWindow)
    accept:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(20))
    accept:SetText("")
    accept:Dock(BOTTOM)
    accept:DockMargin(ScreenScaleMulti(48), ScreenScaleMulti(2), ScreenScaleMulti(48), ScreenScaleMulti(2))
    accept:SetContentAlignment(5)

    accept.OnMousePressed = function(spaa, kc)
        SaveBlacklist()

        blacklistWindow:Close()
        blacklistWindow:Remove()
    end

    accept.Paint = function(spaa, w, h)
        local hovered = spaa:IsHovered()

        local Bfg_col = hovered and color_black or color_white
        local Bbg_col = hovered and color_white or color_arccwdtbl

        srf.SetDrawColor(Bbg_col)
        srf.DrawRect(0, 0, w, h)

        srf.SetTextColor(Bfg_col)
        srf.SetTextPos(ScreenScaleMulti(4), ScreenScaleMulti(4))
        srf.SetFont("ArcCW_12")
        srf.DrawText("Save")
    end

    -- Perhaps unoptimized, but it's client
    -- client_side_calculations_is_not_expensive.png
    function attList:GenerateButtonsToList()
        self:GetCanvas():Clear()

        for attName, attTbl in SortedPairsByMemberValue(ArcCW.AttachmentTable, "PrintName") do
            if attTbl.Hidden then continue end

            if attTbl.Blacklisted then blacklistTbl[attName] = true end

            if onlyblacklisted and !(attTbl.Blacklisted or blacklistTbl[attName]) then continue end

            if filter != "" and !(string.find((attTbl.PrintName):lower(), filter) or string.find((attName):lower(), filter)) then continue end

            --if attTbl.Slot == "charm" then continue end why the fuck would you do this

            CreateAttButton(self, attName, attTbl)
        end
    end

    attList:GenerateButtonsToList()
end

concommand.Add("arccw_blacklist", function()
    if LocalPlayer():IsAdmin() then ArcCW.MakeBlacklistWindow() end
end)
--addons/sh_lounge_chatbox/lua/chatbox_emoticons.lua:
/**
* Derma Emoticons 
**/

-- Enable Derma emoticons?
-- You can see the full list here: http://www.famfamfam.com/lab/icons/silk/previews/index_abc.png
LOUNGE_CHAT.EnableDermaEmoticons = true

-- Restrict Derma emoticons?
-- You can configure the restrictions in the "DermaEmoticonsRestrictions" option.
-- "false" means derma emoticons can be used by anyone.
LOUNGE_CHAT.RestrictDermaEmoticons = false

-- Here you can decide on restrictions for players to be able to use Derma emoticons in their messages.
-- Only works if the "RestrictDermaEmoticons" option is set to true
LOUNGE_CHAT.DermaEmoticonsRestrictions = {
	-- This means only admins, superadmins and players with the specific SteamID/SteamID64 can use Derma emoticons.
	usergroups = {"admin", "superadmin"},
	steamids = {"STEAM_0:1:8039869", "76561197976345467"},
	vipOnly = true
}

/**
* Custom Emoticons 
**/

-- Add your custom emoticons here!
-- Two examples are provided for you to copy.
LOUNGE_CHAT.CustomEmoticons = {
	-- This creates a "grin" emoticon with the material "vgui/face/grin"
	["grin"] = {
		path = "vgui/face/grin",
		w = 64,
		h = 32,
	},

	-- This creates a "awesomeface" emoticon with the URL "http://i.imgur.com/YBUpyZg.png"
	["awesomeface"] = {
		url = "http://i.imgur.com/YBUpyZg.png",
		w = 32,
		h = 32,
	},

	// FA emoticons
	["kami"] = {
		url = "https://vgy.me/pzfz8k.png",
		w = 32,
		h = 32,
	},
	["kosmugi"] = {
		url = "http://i.imgur.com/fWxbVLv.png",
		w = 32,
		h = 32,
	},
	["chaika"] = {
		url = "http://i.imgur.com/h25fTDE.png",
		w = 32,
		h = 32,
	},
	["thatcat"] = {
		url = "http://i.imgur.com/00Xaj13.png",
		w = 32,
		h = 32,
	},
	["skull"] = {
		url = "https://i.imgur.com/bkR1Sln.png",
		w = 16,
		h = 16,
	},
	["flushed"] = {
		url = "https://i.imgur.com/2tJNSKn.png",
		w = 16,
		h = 16,
	},
	["nerd"] = {
		url = "https://i.imgur.com/95oBvWr.png",
		w = 16,
		h = 16,
	},
	["angry"] = {
		url = "https://i.imgur.com/EUHImac.png",
		w = 16,
		h = 16,
	},
}

-- Here you can decide whether an emoticon can only be used by a specific usergroup/SteamID
LOUNGE_CHAT.EmoticonRestriction = {
	-- This restricts the "awesomeface" emoticon so that it can only be used by:
	-- * "admin" and "superadmin" usergroups
	-- * players with the SteamID "STEAM_0:1:8039869" or SteamID64 "76561197976345467"
	["awesomeface"] = {
		usergroups = {"admin", "superadmin"},
		steamids = {"STEAM_0:1:8039869", "76561197976345467"}
	},
}

/**
* End of configuration
**/

LOUNGE_CHAT.Emoticons = {}

function LOUNGE_CHAT:RegisterEmoticon(id, path, url, w, h, restrict)
	self.Emoticons[id] = {
		path = path,
		url = url,
		w = w or 16,
		h = h or 16,
		restrict = restrict,
	}
end

if (LOUNGE_CHAT.EnableDermaEmoticons) then
	local fil = file.Find("materials/icon16/*.png", "GAME")
	for _, f in pairs (fil) do
		local restrict
		if (LOUNGE_CHAT.RestrictDermaEmoticons) then
			restrict = LOUNGE_CHAT.DermaEmoticonsRestrictions
		end

		LOUNGE_CHAT:RegisterEmoticon(string.StripExtension(f), "icon16/" .. f, nil, 16, 16, restrict)
	end
end

for id, em in pairs (LOUNGE_CHAT.CustomEmoticons) do
	LOUNGE_CHAT:RegisterEmoticon(id, em.path, em.url, em.w, em.h, LOUNGE_CHAT.EmoticonRestriction[id])
end
--addons/weapons_other/lua/autorun/droid_audio.lua:

hook.Add("AOCRP.PlayerCanHearPlayersVoice", "DroidCanHearVoice", function(lis, tal)
 	if lis == tal then return end
	
	if tal.droid == nil && IsValid(lis.droid) then 
		if tal:GetPos():DistToSqr(lis.droid:GetPos()) < 500 * 500 then
			return true, false
		end
	end 
end)

--addons/fspectate/lua/fspectate/cl_init.lua:
FSpectate = {}

local stopSpectating, startFreeRoam
local isSpectating = false
local specEnt
local thirdperson = true
local isRoaming = false
local roamPos -- the position when roaming free
local roamVelocity = Vector(0)
local thirdPersonDistance = 100

/*---------------------------------------------------------------------------
Retrieve the current spectated player
---------------------------------------------------------------------------*/
function FSpectate.getSpecEnt()
    if isSpectating and not isRoaming then
        return IsValid(specEnt) and specEnt or nil
    else
        return nil
    end
end

/*---------------------------------------------------------------------------
startHooks
FAdmin tab buttons
---------------------------------------------------------------------------*/
hook.Add("Initialize", "FSpectate", function()
    surface.CreateFont("UiBold", {
        size = 16,
        weight = 800,
        antialias = true,
        shadow = false,
        font = "Verdana"})

    if not FAdmin then return end
    FAdmin.StartHooks["zzSpectate"] = function()
        FAdmin.Commands.AddCommand("Spectate", nil, "<Player>")

        -- Right click option
        FAdmin.ScoreBoard.Main.AddPlayerRightClick("Spectate", function(ply)
            if not IsValid(ply) then return end
            RunConsoleCommand("FSpectate", ply:UserID())
        end)

        local canSpectate = false
        local function calcAccess()
            CAMI.PlayerHasAccess(LocalPlayer(), "FSpectate", function(b, _)
                canSpectate = b
            end)
        end
        calcAccess()

        -- Spectate option in player menu
        FAdmin.ScoreBoard.Player:AddActionButton("Spectate", "fadmin/icons/spectate", Color(0, 200, 0, 255), function(ply) calcAccess() return canSpectate and ply ~= LocalPlayer() end, function(ply)
            if not IsValid(ply) then return end
            RunConsoleCommand("FSpectate", ply:UserID())
        end)
    end
end)

/*---------------------------------------------------------------------------
Get the thirdperson position
---------------------------------------------------------------------------*/
local function getThirdPersonPos(ent)
    local aimvector = LocalPlayer():GetAimVector()
    local startPos = ent:IsPlayer() and ent:GetShootPos() or ent:LocalToWorld(ent:OBBCenter())
    local endpos = startPos - aimvector * thirdPersonDistance

    local tracer = {
        start = startPos,
        endpos = endpos,
        filter = specEnt
    }

    local trace = util.TraceLine(tracer)

    return trace.HitPos + trace.HitNormal * 10
end

/*---------------------------------------------------------------------------
Get the CalcView table
---------------------------------------------------------------------------*/
local view = {}
local function getCalcView()
    if not isRoaming then
        if thirdperson then
            view.origin = getThirdPersonPos(specEnt)
            view.angles = LocalPlayer():EyeAngles()
        else
            view.origin = specEnt:IsPlayer() and specEnt:GetShootPos() or specEnt:LocalToWorld(specEnt:OBBCenter())
            view.angles = specEnt:IsPlayer() and specEnt:EyeAngles() or specEnt:GetAngles()
        end

        roamPos = view.origin
        view.drawviewer = false

        return view
    end

    view.origin = roamPos
    view.angles = LocalPlayer():EyeAngles()
    view.drawviewer = true

    return view
end

/*---------------------------------------------------------------------------
specCalcView
Override the view for the player to look through the spectated player's eyes
---------------------------------------------------------------------------*/
local function specCalcView(ply, origin, angles, fov)
    if not IsValid(specEnt) and not isRoaming then
        startFreeRoam()
        return
    end

    view = getCalcView()

    if IsValid(specEnt) then
        specEnt:SetNoDraw(not thirdperson)
    end

    return view
end

/*---------------------------------------------------------------------------
Find the right player to spectate
---------------------------------------------------------------------------*/
local function findNearestObject()
    local aimvec = LocalPlayer():GetAimVector()

    local fromPos = not isRoaming and IsValid(specEnt) and specEnt:EyePos() or roamPos

    local lookingAt = util.QuickTrace(fromPos, aimvec * 5000, LocalPlayer())
    local ent = lookingAt.Entity

    if IsValid(ent) then return ent end

    local foundPly, foundDot = nil, 0

    for _, ply in ipairs(player.GetAll()) do
        if not IsValid(ply) or ply == LocalPlayer() then continue end

        local pos = ply:GetShootPos()
        local dot = (pos - fromPos):GetNormalized():Dot(aimvec)

        -- Discard players you're not looking at
        if dot < 0.97 then continue end
        -- not a better alternative
        if dot < foundDot then continue end

        local trace = util.QuickTrace(fromPos, pos - fromPos, ply)

        if trace.Hit then continue end

        foundPly, foundDot = ply, dot
    end

    return foundPly
end

/*---------------------------------------------------------------------------
Spectate the person you're looking at while you're roaming
---------------------------------------------------------------------------*/
local function spectateLookingAt()
    local obj = findNearestObject()

    if not IsValid(obj) then return end

    isRoaming = false
    specEnt = obj

    net.Start("FSpectateTarget")
        net.WriteEntity(obj)
    net.SendToServer()
end

/*---------------------------------------------------------------------------
specBinds
Change binds to perform spectate specific tasks
---------------------------------------------------------------------------*/
-- Manual keysDown table, so I can return true in plyBindPress and still detect key presses
local keysDown = {}
local function specBinds(ply, bind, pressed)
    local key = input.LookupBinding(bind)

    if bind == "+jump" then
        stopSpectating()
        return true
    elseif bind == "+reload" and pressed then
        local pos = getCalcView().origin - Vector(0, 0, 64)
        RunConsoleCommand("FTPToPos", string.format("%d, %d, %d", pos.x, pos.y, pos.z),
            string.format("%d, %d, %d", roamVelocity.x, roamVelocity.y, roamVelocity.z))
        stopSpectating()
    elseif bind == "+attack" and pressed then
        if not isRoaming then
            startFreeRoam()
        else
            spectateLookingAt()
        end
        return true
    elseif bind == "+attack2" and pressed then
        if isRoaming then
            roamPos = roamPos + LocalPlayer():GetAimVector() * 500
            return true
        end
        thirdperson = not thirdperson

        return true
    elseif isRoaming and not LocalPlayer():KeyDown(IN_USE) then
        local keybind = string.lower(string.match(bind, "+([a-z A-Z 0-9]+)") or "")
        if not keybind or keybind == "use" or keybind == "showscores" or string.find(bind, "messagemode") then return end

        keysDown[keybind:upper()] = pressed

        return true
    elseif not isRoaming and thirdperson and (key == "MWHEELDOWN" or key == "MWHEELUP") then
        thirdPersonDistance = thirdPersonDistance + 10 * (key == "MWHEELDOWN" and 1 or -1)
    end
    -- Do not return otherwise, spectating admins should be able to move to avoid getting detected
end

/*---------------------------------------------------------------------------
Scoreboardshow
Set to main view when roaming, open on a player when spectating
---------------------------------------------------------------------------*/
local function fadminmenushow()
    if isRoaming then
        FAdmin.ScoreBoard.ChangeView("Main")
    elseif IsValid(specEnt) and specEnt:IsPlayer() then
        FAdmin.ScoreBoard.ChangeView("Main")
        FAdmin.ScoreBoard.ChangeView("Player", specEnt)
    end
end


/*---------------------------------------------------------------------------
RenderScreenspaceEffects
Draws the lines from players' eyes to where they are looking
---------------------------------------------------------------------------*/
local LineMat = Material("cable/new_cable_lit")
local linesToDraw = {}
local function lookingLines()
    if not linesToDraw[0] then return end

    render.SetMaterial(LineMat)

    cam.Start3D(view.origin, view.angles)
        for i = 0, #linesToDraw, 3 do
            render.DrawBeam(linesToDraw[i], linesToDraw[i + 1], 4, 0.01, 10, linesToDraw[i + 2])
        end
    cam.End3D()
end

/*---------------------------------------------------------------------------
gunpos
Gets the position of a player's gun
---------------------------------------------------------------------------*/
local function gunpos(ply)
    local wep = ply:GetActiveWeapon()
    if not IsValid(wep) then return ply:EyePos() end
    local att = wep:GetAttachment(1)
    if not att then return ply:EyePos() end
    return att.Pos
end

/*---------------------------------------------------------------------------
Spectate think
Free roaming position updates
---------------------------------------------------------------------------*/
local function specThink()
    local ply = LocalPlayer()

    -- Update linesToDraw
    local pls = player.GetAll()
    local lastPly = 0
    local skip = 0
    for i = 0, #pls - 1 do
        local p = pls[i + 1]
        if not IsValid(p) then continue end
        if not isRoaming and p == specEnt and not thirdperson then skip = skip + 3 continue end

        local tr = p:GetEyeTrace()
        local sp = gunpos(p)

        local pos = i * 3 - skip

        linesToDraw[pos] = tr.HitPos
        linesToDraw[pos + 1] = sp
        linesToDraw[pos + 2] = team.GetColor(p:Team())
        lastPly = i
    end

    -- Remove entries from linesToDraw that don't match with a player anymore
    for i = #linesToDraw, lastPly * 3 + 3, -1 do linesToDraw[i] = nil end

    if not isRoaming or keysDown["USE"] then return end

    local roamSpeed = 1000
    local aimVec = ply:GetAimVector()
    local direction
    local frametime = RealFrameTime()

    if keysDown["FORWARD"] then
        direction = aimVec
    elseif keysDown["BACK"] then
        direction = -aimVec
    end

    if keysDown["MOVELEFT"] then
        local right = aimVec:Angle():Right()
        direction = direction and (direction - right):GetNormalized() or -right
    elseif keysDown["MOVERIGHT"] then
        local right = aimVec:Angle():Right()
        direction = direction and (direction + right):GetNormalized() or right
    end

    if keysDown["SPEED"] then
        roamSpeed = 2500
    elseif keysDown["WALK"] or keysDown["DUCK"] then
        roamSpeed = 300
    end

    roamVelocity = (direction or Vector(0, 0, 0)) * roamSpeed

    roamPos = roamPos + roamVelocity * frametime
end

/*---------------------------------------------------------------------------
Draw help on the screen
---------------------------------------------------------------------------*/
local uiForeground, uiBackground = Color(240, 240, 255, 255), Color(20, 20, 20, 120)
local red = Color(255, 0, 0, 255)
local function drawHelp()
    local scrHalfH = math.floor(ScrH() / 2)
    draw.WordBox(2, 10, scrHalfH, "Linksklick: Spieler (Un)selecten", "UiBold", uiBackground, uiForeground)
    draw.WordBox(2, 10, scrHalfH + 20, isRoaming and "Rechtsklick: Schnell nach Vorne bewegen" or "Right click: toggle thirdperson", "UiBold", uiBackground, uiForeground)
    draw.WordBox(2, 10, scrHalfH + 40, "Leertaste: Stoppe das beobachten", "UiBold", uiBackground, uiForeground)
    draw.WordBox(2, 10, scrHalfH + 60, "R: Teleportiere dich zur ausgewählten Stelle", "UiBold", uiBackground, uiForeground)

    if FAdmin then
        draw.WordBox(2, 10, scrHalfH + 80, "Opening FAdmin's menu while spectating a player", "UiBold", uiBackground, uiForeground)
        draw.WordBox(2, 10, scrHalfH + 100, "\twill open their page!", "UiBold", uiBackground, uiForeground)
    end


    local target = findNearestObject()
    local pls = player.GetAll()
    for i = 1, #pls do
        local ply = pls[i]
        if not IsValid(ply) then continue end
        if not isRoaming and ply == specEnt then continue end

        local pos = ply:GetShootPos():ToScreen()
        if not pos.visible then continue end

        local x, y = pos.x, pos.y

        draw.RoundedBox(2, x, y - 6, 12, 12, team.GetColor(ply:Team()))
        draw.WordBox(2, x, y - 66, ply:Nick(), "UiBold", uiBackground, uiForeground)
        draw.WordBox(2, x, y - 46, "Health: " .. ply:Health(), "UiBold", uiBackground, uiForeground)
        draw.WordBox(2, x, y - 26, ply:GetUserGroup(), "UiBold", uiBackground, uiForeground)
    end

    if not isRoaming then return end

    if not IsValid(target) then return end

    local center = target:LocalToWorld(target:OBBCenter())
    local eyeAng = EyeAngles()
    local rightUp = eyeAng:Right() * 16 + eyeAng:Up() * 36
    local topRight = (center + rightUp):ToScreen()
    local bottomLeft = (center - rightUp):ToScreen()

    draw.RoundedBox(12, bottomLeft.x, bottomLeft.y, math.max(20, topRight.x - bottomLeft.x), topRight.y - bottomLeft.y, red)
    draw.WordBox(2, bottomLeft.x, bottomLeft.y + 12, "Left click to spectate!", "UiBold", uiBackground, uiForeground)
end

/*---------------------------------------------------------------------------
Start roaming free, rather than spectating a given player
---------------------------------------------------------------------------*/
startFreeRoam = function()
    roamPos = isSpectating and roamPos or LocalPlayer():GetShootPos()

    if IsValid(specEnt) then
        if specEnt:IsPlayer() then
            roamPos = thirdperson and getThirdPersonPos(specEnt) or specEnt:GetShootPos()
        end
        specEnt:SetNoDraw(false)
    end

    specEnt = nil
    isRoaming = true
    keysDown = {}
end

/*---------------------------------------------------------------------------
specEnt
Spectate a player
---------------------------------------------------------------------------*/
local function startSpectate(um)
    isRoaming = net.ReadBool()
    specEnt = net.ReadEntity()
    specEnt = IsValid(specEnt) and specEnt or nil

    if isRoaming then
        startFreeRoam()
    end

    isSpectating = true
    keysDown = {}

    hook.Add("CalcView", "FSpectate", specCalcView)
    hook.Add("PlayerBindPress", "FSpectate", specBinds)
    hook.Add("ShouldDrawLocalPlayer", "FSpectate", function() return isRoaming or thirdperson end)
    hook.Add("Think", "FSpectate", specThink)
    hook.Add("HUDPaint", "FSpectate", drawHelp)
    hook.Add("FAdmin_ShowFAdminMenu", "FSpectate", fadminmenushow)
    hook.Add("RenderScreenspaceEffects", "FSpectate", lookingLines)

    timer.Create("FSpectatePosUpdate", 0.5, 0, function()
        if not isRoaming then return end

        RunConsoleCommand("_FSpectatePosUpdate", roamPos.x, roamPos.y, roamPos.z)
    end)
end
net.Receive("FSpectate", startSpectate)

/*---------------------------------------------------------------------------
stopSpectating
Stop spectating a player
---------------------------------------------------------------------------*/
stopSpectating = function()
    hook.Remove("CalcView", "FSpectate")
    hook.Remove("PlayerBindPress", "FSpectate")
    hook.Remove("ShouldDrawLocalPlayer", "FSpectate")
    hook.Remove("Think", "FSpectate")
    hook.Remove("HUDPaint", "FSpectate")
    hook.Remove("FAdmin_ShowFAdminMenu", "FSpectate")
    hook.Remove("RenderScreenspaceEffects", "FSpectate")

    timer.Remove("FSpectatePosUpdate")

    if IsValid(specEnt) then
        specEnt:SetNoDraw(false)
    end

    RunConsoleCommand("FSpectate_StopSpectating")
    isSpectating = false
end

--addons/gm_express/lua/gm_express/sh_helpers.lua:
AddCSLuaFile()
express.version = 1
express.revision = 1
express._putCache = {}
express._maxCacheTime = (24 - 1) * 60 * 60
express._waitingForAccess = {}

express.domain = CreateConVar(
    "express_domain", "stg.gmod.express", FCVAR_ARCHIVE + FCVAR_REPLICATED,
    "The domain of the Express server"
)
express.downloadChunkSize = CreateConVar(
    "express_download_chunk_size", tostring( 12 * 1024 * 1024 ), FCVAR_ARCHIVE,
    "The size (in bytes) of each chunk downloaded from the Express server", 1
)
express.maxAttempts = CreateConVar(
    "express_download_max_attempts", tostring( 12 ), FCVAR_ARCHIVE,
    "How many times to retry downloading a file before giving up", 0
)
express.retryDelay = CreateConVar(
    "express_download_retry_delay", tostring( 0.125 ), FCVAR_ARCHIVE,
    "The duration in seconds to wait between each download retry", 0
)
express.timeout = CreateConVar(
    "express_timeout", tostring( CLIENT and 280 or 60 ), FCVAR_ARCHIVE,
    "The timeout in seconds for Express HTTP requests. (Flaky/slow connections should set this higher)", 1
)
express.useRanges = CreateConVar(
    "express_use_ranges", tostring( 1 ), FCVAR_ARCHIVE + FCVAR_REPLICATED,
    "Whether or not to request data in Ranges. (Improves stability for bad internets, might avoid some bugs, could slow things down)", 0, 1
)
express.minSize = CreateConVar(
    "express_min_size", tostring( 64 * 3 * 1024 ), FCVAR_ARCHIVE + FCVAR_REPLICATED,
    "The minimum size (in bytes) that will send via express. Anything smaller than this will send with NetStream"
)

-- Useful for self-hosting if you need to set express_domain to localhost
-- and direct clients to a global IP/domain to hit the same service
express.domain_cl = CreateConVar(
    "express_domain_cl", "", FCVAR_ARCHIVE + FCVAR_REPLICATED,
    "The client-specific domain of the Express server. If empty, express_domain will be used."
)


-- Runs the correct net Send function based on the realm --
function express.shSend( target )
    if CLIENT then
        net.SendToServer()
    else
        net.Send( target )
    end
end


-- Returns the correct domain based on the realm and convars --
function express:getDomain()
    return "stg.gmod.express"
end


-- Creates the base of the API URL from the protocol, domain, and version --
function express:makeBaseURL()
    local protocol = self._protocol
    local domain = self:getDomain()
    return string.format( "%s://%s/v%d", protocol, domain, self.version )
end


-- Creates a full URL with the given access token --
function express:makeAccessURL( action, ... )
    local url = self:makeBaseURL()
    local args = { action, self.access,  ... }

    return url .. "/" .. table.concat( args, "/" )
end

function express.parseContentRange( header )
    local pattern = "bytes (%d+)-(%d+)/(%d+)"
    local rangeStart, rangeEnd, fullSize = header:match( pattern )
    return tonumber( rangeStart ), tonumber( rangeEnd ), tonumber( fullSize )
end


-- Sets the access token and runs requests that were waiting --
function express:SetAccess( access, clientAccess )
    self.access = access
    self._clientAccess = clientAccess

    local waiting = self._waitingForAccess
    for _, callback in ipairs( waiting ) do
        callback()
    end

    self._waitingForAccess = {}
end


-- Checks the version of the API and alerts of a mismatch --
function express.CheckRevision()
    local suffix = " on version check! (Is express up to date?)"
    local err = function( msg )
        msg = "'" .. msg .. "'"
        return "Express: " .. msg .. suffix
    end

    local url = express:makeBaseURL() .. "/revision"
    local success = function( code, body )
        assert( code >= 200 and code < 300, err( "Invalid response code (" .. code .. ")" ) )

        local dataHolder = util.JSONToTable( body )
        assert( dataHolder, err( "Invalid JSON response" ) )

        local revision = dataHolder.revision
        assert( revision, err( "Invalid JSON response" ) )

        local current = express.revision
        if revision ~= current then
            error( "Express: Revision mismatch! Expected " .. current .. ", got " .. revision .. " (Update the addon?)" )
        end
    end

    local madeRequest = express.HTTP( {
        url = url,
        method = "GET",
        success = success,
        failed = function( message )
            error( err( message ) )
        end,
        headers = express.jsonHeaders,
        timeout = express:_getTimeout()
    } )

    if not madeRequest then
        error( err( "HTTP request failed" ) )
    end
end

function express.HandleReceivedData( body, id, cb )
    if string.StartsWith( body, "<raw>" ) then
        print( "Express: Returning raw data for ID '" .. id .. "'." )
        body = string.sub( body, 6 )
        local hash = util.SHA1( body )
        return cb( body, hash )
    else
        local hash = util.SHA1( body )
        local decodedData = sfs.decode( body )
        return cb( decodedData, hash )
    end
end

function express:Get( id, cb )
    local url = self:makeAccessURL( "read", id )

    local attempts = 0
    local rangeStart = 0
    local rangeEnd = self.downloadChunkSize:GetInt()

    local fullBody = ""
    local headers = table.Copy( self._bytesHeaders )

    local makeRequest
    local function success( code, body, responseHeaders )
        -- print( "Express: GET " .. url .. " : " .. tostring( code ), headers.Range, "Attempts: " .. attempts )

        express._checkResponseCode( code )

        if attempts > 0 then
            print( "Express:Get() succeeded after " .. attempts .. " attempts" )
        end

        -- We had a successful download, so reset the attempts
        attempts = 0
        fullBody = fullBody .. body

        -- If Range headers are supported on the server
        if code == 206 then
            local _, _, fullSize = self.parseContentRange( responseHeaders["Content-Range"] )
            if #fullBody == fullSize then
                return express.HandleReceivedData( fullBody, id, cb )
            end

            rangeStart = rangeEnd + 1
            rangeEnd = rangeStart + self.downloadChunkSize:GetInt()
            return makeRequest()
        end

        -- If we didn't receive a 206, then we should have received a 200 with the full file
        -- This will happen if the express server doesn't support Range headers
        return express.HandleReceivedData( fullBody, id, cb )
    end

    local function failure( reason )
        local shouldHalt = hook.Run( "Express_GetFailed", url, reason, attempts, id, cb )
        if shouldHalt == true then return end

        -- Unsuccessful HTTP requests might succeed on a retry
        if reason == "unsuccessful" then
            print( "Express: Failed to download file '" .. url .. "': HTTP request failed. Retrying." )
            attempts = attempts + 1
            makeRequest()
        else
            error( "Express: Failed to download file '" .. url .. "': " .. reason .. "\n" )
        end
    end

    makeRequest = function()
        if express.useRanges:GetBool() then
            -- We have to add 0-1 or the http call will fail :(
            -- FIXME: This has the nice side effect of printing an engine warning in console!
            headers.Range = string.format( "bytes=%d-%d, 0-1", rangeStart, rangeEnd )
        end
        print( "Express: Downloading chunk " .. rangeStart .. " to " .. rangeEnd .. " of " .. id )

        express.HTTP( {
            method = "GET",
            url = url,
            headers = headers,
            success = success,
            failed = failure,
            timeout = self:_getTimeout()
        } )
    end

    makeRequest()
end

-- Runs the main :Get function, or queues the request if no access token is set --
function express:_get( id, cb )
    if self.access then
        return self:Get( id, cb )
    end

    table.insert( self._waitingForAccess, function()
        self:Get( id, cb )
    end )
end

-- Processes/Formats the data that will be sent
function express.processSendData( data )
    local processed = ""

    if istable( data ) then
        print( "Express: Sending table data." )
        if table.Count( data ) == 0 then
            error( "Express: Tried to send empty data!" )
        end

        local serialized, err = sfs.encode( data )
        if not serialized then
            err = err or "unknown error"

            local message = "Express: Failed to encode table data! (" .. err .. ")"
            error( message )
        end

        processed = serialized

    elseif isstring( data ) then
        print( "Express: Sending raw data." )
        if #data == 0 then
            error( "Express: Tried to send empty data!" )
        end

        processed = "<raw>" .. data

    else
        error( "Express: Invalid data type '" .. type( data ) .. "'! (expected string or table)" )
    end

    local hash = util.SHA1( processed )
    local size = string.len( processed )

    if size > express._maxDataSize then
        error( "Express: Data too large (" .. size .. " bytes)" )
    end

    return {
        data = processed,
        hash = hash,
        size = size
    }
end


--- Sends the given data with Express
--- Encodes and compresses the given data, then sends it to the API if not already cached
function express:_put( struct, cb )
    local size = struct.size
    local hash = struct.hash

    local now = os.time()
    local cached = self._putCache[hash]

    if cached then
        if cached.complete then
            local cachedAt = cached.cachedAt

            if now <= ( cachedAt + self._maxCacheTime ) then
                local cachedSize = cached.size
                local niceSize = string.NiceSize( cachedSize )
                print( "Express: Using cached ID '" .. cached.id .. "' for hash '" .. hash .. "' (Saved you " .. niceSize .. "!)" )

                -- Force the callback to run asynchronously for consistency
                timer.Simple( 0, function()
                    cb( cached.id, hash, cachedSize )
                end )

                return
            end
        else
            table.insert( cached.waiting, cb )
            return
        end
    end

    local waiting = {}
    local cacheItem = {
        size = size,
        waiting = waiting,
        complete = false,
        cachedAt = now
    }
    self._putCache[hash] = cacheItem

    local function onComplete( id )
        cacheItem.id = id
        cacheItem.complete = true

        local count = #waiting
        for _ = 1, count do
            table.remove( waiting )( id, hash, size )
        end

        cb( id, hash, size )
    end

    if self.access then
        return self:Put( struct.data, onComplete )
    end

    table.insert( self._waitingForAccess, function()
        self:Put( struct.data, onComplete )
    end )
end


-- Creates a contextual callback for the :_put endpoint, delaying the notification to the recipient(s) --
function express:_putCallback( message, plys, onProof )
    return function( id, hash, size )
        assert( id )
        assert( hash )
        assert( size )

        if onProof then
            self:SetExpected( hash, onProof, plys )
        end

        net.Start( "express" )
        print( "Express: Sending message '" .. message .. "' to: ", plys )
        net.WriteString( message )
        net.WriteString( id )
        net.WriteBool( onProof ~= nil )

        if SERVER then
            net.WriteUInt( size, 27 )
        end

        express.shSend( plys )
    end
end


function express:_putSmall( struct, message, plys, onProof )
    net.Start( "express_small" )
    print( "Express: Sending NetStream message '" .. message .. "' to: ", plys )
    net.WriteString( message )
    net.WriteUInt( struct.size, 27 )
    net.WriteBool( onProof ~= nil )
    net.WriteStream( struct.data, onProof, true )
    express.shSend( plys )
end


-- Calls the _put function with a contextual callback --
function express:_send( message, data, plys, onProof )
    if not isstring( message ) then
        error( "Express: Invalid message type '" .. type( message ) .. "'!", 2 )
    end

    if not (istable( data ) or isstring( data )) then
        error( "Express: Invalid data type '" .. type( data ) .. "'!", 2 )
    end

    if SERVER then
        if not (istable( plys ) or type( plys ) == "Player") then
            error( "Express: Invalid player(s) type '" .. type( plys ) .. "'! (expected Player or table of Players)", 2 )
        end
    end

    if onProof and not isfunction( onProof ) then
        error( "Express: Invalid proof callback type '" .. type( onProof ) .. "'!", 2 )
    end

    local processed = express.processSendData( data )
    local size = processed.size

    if size < express.minSize:GetFloat() then
        print( "Express: Message ('" .. message .. "') is too small to send with express. Falling back to NetStream:", string.NiceSize( size ) )
        self:_putSmall( processed, message, plys, onProof )
        return false
    end

    if size > express._maxDataSize then
        error( "Express: Data too large (" .. size .. " bytes)" )
    end

    self:_put( processed, self:_putCallback( message, plys, onProof ) )
end


-- Assigns a callback to the given message --
function express:_setReceiver( message, cb )
    message = string.lower( message )
    self._receivers[message] = cb
end


-- Returns the receiver set for the given message --
function express:_getReceiver( message )
    message = string.lower( message )
    return self._receivers[message]
end


-- Returns the pre-download receiver set for the given message --
function express:_getPreDlReceiver( message )
    message = string.lower( message )
    return self._preDlReceivers[message]
end


-- Returns a realm-specific timeout value for HTTP requests --
function express:_getTimeout()
    return self.timeout:GetFloat()
end


-- Ensures that the given HTTP response code indicates a succcessful request --
function express._checkResponseCode( code )
    local isOk = isnumber( code ) and code >= 200 and code < 300
    if isOk then return end

    error( "Express: Invalid response code (" .. tostring( code ) .. ")" )
end


-- Attempts to re-register with the new domain, and then verifies its version --
cvars.AddChangeCallback( "express_domain", function()
    express._putCache = {}

    if SERVER then express:Register() end

    express:CheckRevision()
end, "domain_check" )

-- Both client and server should check the version on startup so that errors are caught early --
cvars.AddChangeCallback( "express_domain_cl", function( _, _, new )
    if CLIENT then express._putCache = {} end
    if new == "" then return end

    express:CheckRevision()
end, "domain_check" )


hook.Add( "ExpressLoaded", "Express_HTTPInit", function()
    hook.Add( "Tick", "Express_RevisionCheck", function()
        hook.Remove( "Tick", "Express_RevisionCheck" )
        if SERVER then express:Register() end
        express:CheckRevision()
    end )
end )

--addons/billy_gas/lua/includes/modules/billyserrors.lua:
AddCSLuaFile()

local BillysErrors_Version = 1
if (BillysErrors) then
	if (BillysErrors.Version >= BillysErrors_Version) then
		return
	elseif (CLIENT and IsValid(BillysErrors.Menu)) then
		BillysErrors.Menu:Close()
	end
end

BillysErrors = {}
BillysErrors.Version = BillysErrors_Version

BillysErrors.IMPORTANCE_NOTICE  = 0
BillysErrors.IMPORTANCE_WARNING = 1
BillysErrors.IMPORTANCE_FATAL   = 2

BillysErrors.COLOR_RED        = Color(255,0,0)
BillysErrors.COLOR_YELLOW     = Color(255,255,0)
BillysErrors.COLOR_LIGHT_BLUE = Color(0,255,255)
BillysErrors.COLOR_WHITE      = Color(255,255,255)

local function UnvectorizeColor(col)
	return col.r, col.g, col.b, col.a
end

function BillysErrors:ProcessConsoleMsg(print_items, msg)
	if (msg.Importance == BillysErrors.IMPORTANCE_NOTICE) then
		table.insert(print_items, BillysErrors.COLOR_LIGHT_BLUE)
		table.insert(print_items, "[NOTICE] ")
	elseif (msg.Importance == BillysErrors.IMPORTANCE_WARNING) then
		table.insert(print_items, BillysErrors.COLOR_YELLOW)
		table.insert(print_items, "[WARNING] ")
	elseif (msg.Importance == BillysErrors.IMPORTANCE_FATAL) then
		table.insert(print_items, BillysErrors.COLOR_RED)
		table.insert(print_items, "[FATAL] ")
	end
	if (#msg.TextItems > 0) then
		local prev_color
		if (not IsColor(msg.TextItems[1])) then
			table.insert(print_items, BillysErrors.COLOR_WHITE)
			prev_color = BillysErrors.COLOR_WHITE
		else
			prev_color = msg.TextItems[1]
		end
		for _,item in ipairs(msg.TextItems) do
			if (type(item) == "string") then
				table.insert(print_items, item)
			elseif (IsColor(item)) then
				table.insert(print_items, item)
				prev_color = item
			elseif (type(item) == "table" and item.Link ~= nil) then
				table.insert(print_items, BillysErrors.COLOR_LIGHT_BLUE)
				table.insert(print_items, item.Link)
				table.insert(print_items, prev_color)
			end
		end
	end
end

if (CLIENT) then
	function BillysErrors:ProcessRichTextMsg(rich_text, msg)
		if (msg.Importance == BillysErrors.IMPORTANCE_NOTICE) then
			rich_text:InsertColorChange(UnvectorizeColor(BillysErrors.COLOR_LIGHT_BLUE))
			rich_text:AppendText("[NOTICE] ")
		elseif (msg.Importance == BillysErrors.IMPORTANCE_WARNING) then
			rich_text:InsertColorChange(UnvectorizeColor(BillysErrors.COLOR_YELLOW))
			rich_text:AppendText("[WARNING] ")
		elseif (msg.Importance == BillysErrors.IMPORTANCE_FATAL) then
			rich_text:InsertColorChange(UnvectorizeColor(BillysErrors.COLOR_RED))
			rich_text:AppendText("[FATAL] ")
		end
		if (#msg.TextItems > 0) then
			local prev_color
			if (not IsColor(msg.TextItems[1])) then
				rich_text:InsertColorChange(UnvectorizeColor(BillysErrors.COLOR_WHITE))
				prev_color = BillysErrors.COLOR_WHITE
			else
				prev_color = msg.TextItems[1]
			end
			for i,item in ipairs(msg.TextItems) do
				if (IsColor(item)) then
					rich_text:InsertColorChange(UnvectorizeColor(item))
					prev_color = item
				elseif (type(item) == "table") then
					rich_text:InsertColorChange(0,125,255,255)
					rich_text:InsertClickableTextStart("OpenURL " .. item.Link)
					rich_text:AppendText(item.Link)
					rich_text:InsertClickableTextEnd()
					rich_text:InsertColorChange(UnvectorizeColor(prev_color))
				else
					rich_text:AppendText(tostring(item))
				end
			end
		end
	end
end

if (SERVER) then
	util.AddNetworkString("billyserrors")

	BillysErrors.Addons = {}
	BillysErrors.HasMessage = false

	local ADDON = {}
	function ADDON:Init(options)
		self.Name = options.Name
		self.Color = options.Color
		self.Icon = options.Icon
		self.Messages = options.Messages or {}
	end
	function ADDON:AddMessage(importance, ...)
		local msg = {
			Importance = importance,
			TextItems = {...}
		}
		table.insert(self.Messages, msg)

		local print_items = {}
		BillysErrors:ProcessConsoleMsg(print_items, msg)
		table.insert(print_items, "\n")
		MsgC(unpack(print_items))

		BillysErrors.HasMessage = true
		BillysErrors:SendData()
	end

	function BillysErrors:AddAddon(options)
		local addon = table.Copy(ADDON)
		addon:Init(options)
		table.insert(BillysErrors.Addons, addon)
		return addon
	end

	function BillysErrors:SendData(ply)
		if (not BillysErrors.HasMessage) then return end
		local data = util.Compress(util.TableToJSON(BillysErrors.Addons))
		if (ply ~= nil) then
			if (not IsValid(ply) or not ply:IsSuperAdmin()) then return end
			net.Start("billyserrors")
				net.WriteData(data, #data)
			net.Send(ply)
		else
			for _,ply in ipairs(player.GetHumans()) do
				if (not ply:IsSuperAdmin()) then continue end
				net.Start("billyserrors")
					net.WriteData(data, #data)
				net.Send(ply)
			end
		end
	end
	net.Receive("billyserrors", function(_, ply)
		BillysErrors:SendData(ply)
	end)
else
	function BillysErrors:OpenMenu()
		if (IsValid(BillysErrors.Menu)) then
			BillysErrors.Menu.Categories:Remove()
			BillysErrors.Menu.Categories = vgui.Create("bVGUI.Categories", BillysErrors.Menu.Content)
			BillysErrors.Menu.Categories:Dock(LEFT)
			BillysErrors.Menu.Categories:SetWide(175)
			BillysErrors.Menu.Categories:MoveToBefore(BillysErrors.Menu.Header)

			BillysErrors.Menu:LoadMessages(true)
			return
		end

		BillysErrors.Menu = vgui.Create("bVGUI.Frame")
		BillysErrors.Menu:SetSize(600,500)
		BillysErrors.Menu:SetMinimumSize(600,500)
		BillysErrors.Menu:Center()
		BillysErrors.Menu:SetTitle("BillysErrors")
		BillysErrors.Menu:MakePopup()
		function BillysErrors.Menu:OnClose()
			hook.Remove("SetupMove", "BillysErrors:ScrollRichText")
		end

		BillysErrors.Menu.Content = vgui.Create("bVGUI.BlankPanel", BillysErrors.Menu)
		BillysErrors.Menu.Content:Dock(FILL)
		function BillysErrors.Menu.Content:PaintOver(w,h)
			surface.SetDrawColor(255,255,255,255)
			surface.SetMaterial(bVGUI.MATERIAL_SHADOW)
			surface.DrawTexturedRect(175,0,10,h)
		end

		BillysErrors.Menu.Categories = vgui.Create("bVGUI.Categories", BillysErrors.Menu.Content)
		BillysErrors.Menu.Categories:Dock(LEFT)
		BillysErrors.Menu.Categories:SetWide(175)

		BillysErrors.Menu.Header = vgui.Create("bVGUI.Header", BillysErrors.Menu.Content)
		BillysErrors.Menu.Header:Dock(TOP)
		BillysErrors.Menu.Header:SetText("Help")
		BillysErrors.Menu.Header:SetColor(Color(76,216,76))
		BillysErrors.Menu.Header:SetIcon("icon16/help.png")

		local function CreateRichText()
			if (IsValid(BillysErrors.Menu.Text)) then
				BillysErrors.Menu.Text:Remove()
			end
			BillysErrors.Menu.Text = vgui.Create("RichText", BillysErrors.Menu.Content)
			BillysErrors.Menu.Text:Dock(FILL)
			BillysErrors.Menu.Text:DockMargin(10,10,10,10)
			BillysErrors.Menu.Text:SetVerticalScrollbarEnabled(true)
			BillysErrors.Menu.Text:InsertColorChange(255,255,255,255)

			local font_name = bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14)
			function BillysErrors.Menu.Text:PerformLayout()
				self:SetFontInternal(font_name)
			end

			function BillysErrors.Menu.Text:ActionSignal(signalName, signalValue)
				if (signalName == "TextClicked" and signalValue:sub(1,8) == "OpenURL ") then
					if (GAS) then
						GAS:OpenURL(signalValue:sub(9))
					else
						gui.OpenURL(signalValue:sub(9))
					end
				end
			end
		end

		function BillysErrors.Menu:LoadMessages(is_refresh)
			BillysErrors.Menu.Categories:Clear()

			local function ShowHelpText()
				if (not is_refresh) then
					BillysErrors.LastSelectedAddon = nil
				end

				CreateRichText()
				BillysErrors.Menu.Text:InsertColorChange(255,0,0,255)
				BillysErrors.Menu.Text:AppendText("(This window is only visible to superadmins)\n\n")
				BillysErrors.Menu.Text:InsertColorChange(255,255,255,255)
				BillysErrors.Menu.Text:AppendText(([[

					Uh oh! Something's wrong with an addon you have installed to your server.

					Click the addon's name on the left to see what's wrong, and how to fix the problem.

				]]):gsub("\t", ""):gsub("^%s",""):gsub("%s$",""))

				BillysErrors.Menu.Header:SetText("Help")
				BillysErrors.Menu.Header:SetColor(Color(76,216,76))
				BillysErrors.Menu.Header:SetIcon("icon16/help.png")
			end
			BillysErrors.Menu.Categories:AddItem("Help", ShowHelpText, Color(76,216,76)):SetActive(not is_refresh or BillysErrors.LastSelectedAddon == nil)

			ShowHelpText()

			local category_col = Color(216,76,76)
			if (BillysErrors.Addons[1] ~= nil and BillysErrors.Addons[1].Color ~= nil) then
				category_col = BillysErrors.Addons[1].Color
			end
			local category = BillysErrors.Menu.Categories:AddCategory("Addons", category_col)
			for _,addon in ipairs(BillysErrors.Addons) do
				if (#addon.Messages == 0) then continue end
				local item = category:AddItem(addon.Name, function()

					BillysErrors.LastSelectedAddon = addon.Name

					BillysErrors.Menu.Header:SetText(addon.Name)
					BillysErrors.Menu.Header:SetColor(addon.Color or Color(0,125,255))
					BillysErrors.Menu.Header:SetIcon(addon.Icon or false)

					CreateRichText()
					for i,msg in ipairs(addon.Messages) do
						local print_items = {}
						BillysErrors:ProcessConsoleMsg(print_items, msg)
						table.insert(print_items, "\n\n")
						MsgC(unpack(print_items))

						BillysErrors:ProcessRichTextMsg(BillysErrors.Menu.Text, msg)
						if (i ~= #msg) then BillysErrors.Menu.Text:AppendText("\n\n") end
					end

				end, addon.Color, addon.Icon)
				if (BillysErrors.LastSelectedAddon == addon.Name) then
					item:OnMouseReleased(MOUSE_LEFT)
				end
			end
		end
		BillysErrors.Menu:LoadMessages()

		BillysErrors.Menu:EnableUserResize()
		surface.PlaySound("gmodadminsuite/oof.mp3")
	end

	net.Receive("billyserrors", function(l)
		BillysErrors.Addons = util.JSONToTable(util.Decompress(net.ReadData(l)))
		BillysErrors:OpenMenu()
	end)

	if (BillysErrors_InitPostEntity) then
		net.Start("billyserrors")
		net.SendToServer()
	else
		hook.Add("InitPostEntity", "BillysErrors:InitPostEntity", function()
			BillysErrors_InitPostEntity = true

			net.Start("billyserrors")
			net.SendToServer()

			hook.Remove("InitPostEntity", "BillysErrors:InitPostEntity")
		end)
	end
end
--addons/billy_gas/lua/gmodadminsuite/thirdparty/von.lua:
--[[	vON 1.3.4

	Copyright 2012-2014 Alexandru-Mihai Maftei
					aka Vercas

	GitHub Repository:
		https://github.com/vercas/vON

	You may use this for any purpose as long as:
	-	You don't remove this copyright notice.
	-	You don't claim this to be your own.
	-	You properly credit the author (Vercas) if you publish your work based on (and/or using) this.

	If you modify the code for any purpose, the above obligations still apply.
	If you make any interesting modifications, try forking the GitHub repository instead.

	Instead of copying this code over for sharing, rather use the link:
		https://github.com/vercas/vON/blob/master/von.lua

	The author may not be held responsible for any damage or losses directly or indirectly caused by
	the use of vON.

	If you disagree with the above, don't use the code.

-----------------------------------------------------------------------------------------------------------------------------
	
	Thanks to the following people for their contribution:
		-	Divran						Suggested improvements for making the code quicker.
										Suggested an excellent new way of deserializing strings.
										Lead me to finding an extreme flaw in string parsing.
		-	pennerlord					Provided some performance tests to help me improve the code.
		-	Chessnut					Reported bug with handling of nil values when deserializing array components.

		-	People who contributed on the GitHub repository by reporting bugs, posting fixes, etc.

-----------------------------------------------------------------------------------------------------------------------------
	
	The vanilla types supported in this release of vON are:
		-	table
		-	number
		-	boolean
		-	string
		-	nil

	The Garry's Mod-specific types supported in this release are:
		-	Vector
		-	Angle
		+	Entities:
			-	Entity
			-	Vehicle
			-	Weapon
			-	NPC
			-	Player
			-	NextBot

	These are the types one would normally serialize.

-----------------------------------------------------------------------------------------------------------------------------
	
	New in this version:
		-	Fixed addition of extra entity types. I messed up really badly.
--]]



local _deserialize, _serialize, _d_meta, _s_meta, d_findVariable, s_anyVariable
local sub, gsub, find, insert, concat, error, tonumber, tostring, type, next = string.sub, string.gsub, string.find, table.insert, table.concat, error, tonumber, tostring, type, next



--[[    This section contains localized functions which (de)serialize
        variables according to the types found.                          ]]



--	This is kept away from the table for speed.
function d_findVariable(s, i, len, lastType, jobstate)
	local i, c, typeRead, val = i or 1

	--	Keep looping through the string.
	while true do
		--	Stop at the end. Throw an error. This function MUST NOT meet the end!
		if i > len then
			error("vON: Reached end of string, cannot form proper variable.")
		end

		--	Cache the character. Nobody wants to look for the same character ten times.
		c = sub(s, i, i)

		--	If it just read a type definition, then a variable HAS to come after it.
		if typeRead then
			--	Attempt to deserialize a variable of the freshly read type.
			val, i = _deserialize[lastType](s, i, len, false, jobstate)
			--	Return the value read, the index of the last processed character, and the type of the last read variable.
			return val, i, lastType

		--	@ means nil. It should not even appear in the output string of the serializer. Nils are useless to store.
		elseif c == "@" then
			return nil, i, lastType

		--	$ means a table reference will follow - a number basically.
		elseif c == "$" then
			lastType = "table_reference"
			typeRead = true

		--	n means a number will follow. Base 10... :C
		elseif c == "n" then
			lastType = "number"
			typeRead = true

		--	b means boolean flags.
		elseif c == "b" then
			lastType = "boolean"
			typeRead = true

		--	' means the start of a string.
		elseif c == "'" then
			lastType = "string"
			typeRead = true

		--	" means the start of a string prior to version 1.2.0.
		elseif c == "\"" then
			lastType = "oldstring"
			typeRead = true

		--	{ means the start of a table!
		elseif c == "{" then
			lastType = "table"
			typeRead = true


--[[    Garry's Mod types go here    ]]

		--	e means an entity ID will follow.
		elseif c == "e" then
			lastType = "Entity"
			typeRead = true
--[[
		--	c means a vehicle ID will follow.
		elseif c == "c" then
			lastType = "Vehicle"
			typeRead = true

		--	w means a weapon entity ID will follow.
		elseif c == "w" then
			lastType = "Weapon"
			typeRead = true

		--	x means a NPC ID will follow.
		elseif c == "x" then
			lastType = "NPC"
			typeRead = true
--]]
		--	p means a player ID will follow.
		--	Kept for backwards compatibility.
		elseif c == "p" then
			lastType = "Entity"
			typeRead = true

		--	v means a vector will follow. 3 numbers.
		elseif c == "v" then
			lastType = "Vector"
			typeRead = true

		--	a means an Euler angle will follow. 3 numbers.
		elseif c == "a" then
			lastType = "Angle"
			typeRead = true

--[[    Garry's Mod types end here    ]]


		--	If no type has been found, attempt to deserialize the last type read.
		elseif lastType then
			val, i = _deserialize[lastType](s, i, len, false, jobstate)
			return val, i, lastType

		--	This will occur if the very first character in the vON code is wrong.
		else
			error("vON: Malformed data... Can't find a proper type definition. Char#" .. i .. ":" .. c)
		end

		--	Move the pointer one step forward.
		i = i + 1
	end
end

--	This is kept away from the table for speed.
--	Yeah, ton of parameters.
function s_anyVariable(data, lastType, isNumeric, isKey, isLast, jobstate)
	local tp = type(data)

	if jobstate[1] and jobstate[2][data] then
		tp = "table_reference"
	end

	--	Basically, if the type changes.
	if lastType ~= tp then
		--	Remember the new type. Caching the type is useless.
		lastType = tp

		if _serialize[lastType] then
			--	Return the serialized data and the (new) last type.
			--	The second argument, which is true now, means that the data type was just changed.
			return _serialize[lastType](data, true, isNumeric, isKey, isLast, false, jobstate), lastType
		else
			error("vON: No serializer defined for type \"" .. lastType .. "\"!")
		end
	end

	--	Otherwise, simply serialize the data.
	return _serialize[lastType](data, false, isNumeric, isKey, isLast, false, jobstate), lastType
end



--[[    This section contains the tables with the functions necessary
        for decoding basic Lua data types.                               ]]



_deserialize = {
--	Well, tables are very loose...
--	The first table doesn't have to begin and end with { and }.
	["table"] = function(s, i, len, unnecessaryEnd, jobstate)
		local ret, numeric, i, c, lastType, val, ind, expectValue, key = {}, true, i or 1, nil, nil, nil, 1
		--	Locals, locals, locals, locals, locals, locals, locals, locals and locals.

		if sub(s, i, i) == "#" then
			local e = find(s, "#", i + 2, true)

			if e then
				local id = tonumber(sub(s, i + 1, e - 1))

				if id then
					if jobstate[1][id] and not jobstate[2] then
						error("vON: There already is a table of reference #" .. id .. "! Missing an option maybe?")
					end

					jobstate[1][id] = ret

					i = e + 1
				else
					error("vON: Malformed table! Reference ID starting at char #" .. i .. " doesn't contain a number!")
				end
			else
				error("vON: Malformed table! Cannot find end of reference ID start at char #" .. i .. "!")
			end
		end

		--	Keep looping.
		while true do
			--	Until it meets the end.
			if i > len then
				--	Yeah, if the end is unnecessary, it won't spit an error. The main chunk doesn't require an end, for example.
				if unnecessaryEnd then
					return ret, i

				--	Otherwise, the data has to be damaged.
				else
					error("vON: Reached end of string, incomplete table definition.")
				end
			end

			--	Cache the character.
			c = sub(s, i, i)
			--print(i, "table char:", c, tostring(unnecessaryEnd))

			--	If it's the end of a table definition, return.
			if c == "}" then
				return ret, i

			--	If it's the component separator, switch to key:value pairs.
			elseif c == "~" then
				numeric = false

			elseif c == ";" then
				--	Lol, nothing!
				--	Remenant from numbers, for faster parsing.

			--	OK, now, if it's on the numeric component, simply add everything encountered.
			elseif numeric then
				--	Find a variable and it's value
				val, i, lastType = d_findVariable(s, i, len, lastType, jobstate)
				--	Add it to the table.
				ret[ind] = val

				ind = ind + 1

			--	Otherwise, if it's the key:value component...
			else
				--	If a value is expected...
				if expectValue then
					--	Read it.
					val, i, lastType = d_findVariable(s, i, len, lastType, jobstate)
					--	Add it?
					ret[key] = val
					--	Clean up.
					expectValue, key = false, nil

				--	If it's the separator...
				elseif c == ":" then
					--	Expect a value next.
					expectValue = true

				--	But, if there's a key read already...
				elseif key then
					--	Then this is malformed.
					error("vON: Malformed table... Two keys declared successively? Char#" .. i .. ":" .. c)

				--	Otherwise the key will be read.
				else
					--	I love multi-return and multi-assignement.
					key, i, lastType = d_findVariable(s, i, len, lastType, jobstate)
				end
			end

			i = i + 1
		end

		return nil, i
	end,

--	Just a number which points to a table.
	["table_reference"] = function(s, i, len, unnecessaryEnd, jobstate)
		local i, a = i or 1
		--	Locals, locals, locals, locals

		a = find(s, "[;:}~]", i)

		if a then
			local n = tonumber(sub(s, i, a - 1))

			if n then
				return jobstate[1][n] or error("vON: Table reference does not point to a (yet) known table!"), a - 1
			else
				error("vON: Table reference definition does not contain a valid number!")
			end
		end

		--	Using %D breaks identification of negative numbers. :(

		error("vON: Number definition started... Found no end.")
	end,


--	Numbers are weakly defined.
--	The declaration is not very explicit. It'll do it's best to parse the number.
--	Has various endings: \n, }, ~, : and ;, some of which will force the table deserializer to go one char backwards.
	["number"] = function(s, i, len, unnecessaryEnd, jobstate)
		local i, a = i or 1
		--	Locals, locals, locals, locals

		a = find(s, "[;:}~]", i)

		if a then
			return tonumber(sub(s, i, a - 1)) or error("vON: Number definition does not contain a valid number!"), a - 1
		end

		--	Using %D breaks identification of negative numbers. :(

		error("vON: Number definition started... Found no end.")
	end,


--	A boolean is A SINGLE CHARACTER, either 1 for true or 0 for false.
--	Any other attempt at boolean declaration will result in a failure.
	["boolean"] = function(s, i, len, unnecessaryEnd, jobstate)
		local c = sub(s,i,i)
		--	Only one character is needed.

		--	If it's 1, then it's true
		if c == "1" then
			return true, i

		--	If it's 0, then it's false.
		elseif c == "0" then
			return false, i
		end

		--	Any other supposely "boolean" is just a sign of malformed data.
		error("vON: Invalid value on boolean type... Char#" .. i .. ": " .. c)
	end,


--	Strings prior to 1.2.0
	["oldstring"] = function(s, i, len, unnecessaryEnd, jobstate)
		local res, i, a = "", i or 1
		--	Locals, locals, locals, locals

		while true do
			a = find(s, "\"", i, true)

			if a then
				if sub(s, a - 1, a - 1) == "\\" then
					res = res .. sub(s, i, a - 2) .. "\""
					i = a + 1
				else
					return res .. sub(s, i, a - 2), a
				end
			else
				error("vON: Old string definition started... Found no end.")
			end
		end
	end,

--	Strings after 1.2.0
	["string"] = function(s, i, len, unnecessaryEnd, jobstate)
		local res, i, a = "", i or 1
		--	Locals, locals, locals, locals

		while true do
			a = find(s, "\"", i, true)

			if a then
				if sub(s, a - 1, a - 1) == "\\" then
					res = res .. sub(s, i, a - 2) .. "\""
					i = a + 1
				else
					return res .. sub(s, i, a - 1), a
				end
			else
				error("vON: String definition started... Found no end.")
			end
		end
	end,
}



_serialize = {
--	Uh. Nothing to comment.
--	Ton of parameters.
--	Makes stuff faster than simply passing it around in locals.
--	table.concat works better than normal concatenations WITH LARGE-ISH STRINGS ONLY.
	["table"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		--print(string.format("data: %s; mustInitiate: %s; isKey: %s; isLast: %s; nice: %s; indent: %s; first: %s", tostring(data), tostring(mustInitiate), tostring(isKey), tostring(isLast), tostring(nice), tostring(indent), tostring(first)))

		local result, keyvals, len, keyvalsLen, keyvalsProgress, val, lastType, newIndent, indentString = {}, {}, #data, 0, 0
		--	Locals, locals, locals, locals, locals, locals, locals, locals, locals and locals.

		--	First thing to be done is separate the numeric and key:value components of the given table in two tables.
		--	pairs(data) is slower than next, data as far as my tests tell me.
		for k, v in next, data do
			--	Skip the numeric keyz.
			if type(k) ~= "number" or k < 1 or k > len or (k % 1 ~= 0) then	--	k % 1 == 0 is, as proven by personal benchmarks,
				keyvals[#keyvals + 1] = k									--	the quickest way to check if a number is an integer.
			end																--	k % 1 ~= 0 is the fastest way to check if a number
		end																	--	is NOT an integer. > is proven slower.

		keyvalsLen = #keyvals

		--	Main chunk - no initial character.
		if not first then
			result[#result + 1] = "{"
		end

		if jobstate[1] and jobstate[1][data] then
			if jobstate[2][data] then
				error("vON: Table #" .. jobstate[1][data] .. " written twice..?")
			end

			result[#result + 1] = "#"
			result[#result + 1] = jobstate[1][data]
			result[#result + 1] = "#"

			jobstate[2][data] = true
		end

		--	Add numeric values.
		if len > 0 then
			for i = 1, len do
				val, lastType = s_anyVariable(data[i], lastType, true, false, i == len and not first, jobstate)
				result[#result + 1] = val
			end
		end

		--	If there are key:value pairs.
		if keyvalsLen > 0 then
			--	Insert delimiter.
			result[#result + 1] = "~"

			--	Insert key:value pairs.
			for _i = 1, keyvalsLen do
				keyvalsProgress = keyvalsProgress + 1

				val, lastType = s_anyVariable(keyvals[_i], lastType, false, true, false, jobstate)

				result[#result + 1] = val..":"

				val, lastType = s_anyVariable(data[keyvals[_i]], lastType, false, false, keyvalsProgress == keyvalsLen and not first, jobstate)
				
				result[#result + 1] = val
			end
		end

		--	Main chunk needs no ending character.
		if not first then
			result[#result + 1] = "}"
		end

		return concat(result)
	end,

--	Number which points to table.
	["table_reference"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		data = jobstate[1][data]

		--	If a number hasn't been written before, add the type prefix.
		if mustInitiate then
			if isKey or isLast then
				return "$"..data
			else
				return "$"..data..";"
			end
		end

		if isKey or isLast then
			return data
		else
			return data..";"
		end
	end,


--	Normal concatenations is a lot faster with small strings than table.concat
--	Also, not so branched-ish.
	["number"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		--	If a number hasn't been written before, add the type prefix.
		if mustInitiate then
			if isKey or isLast then
				return "n"..data
			else
				return "n"..data..";"
			end
		end

		if isKey or isLast then
			return data
		else
			return data..";"
		end
	end,


--	I hope gsub is fast enough.
	["string"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		if sub(data, #data, #data) == "\\" then	--	Hah, old strings fix this best.
			return "\"" .. gsub(data, "\"", "\\\"") .. "v\""
		end

		return "'" .. gsub(data, "\"", "\\\"") .. "\""
	end,


--	Fastest.
	["boolean"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		--	Prefix if we must.
		if mustInitiate then
			if data then
				return "b1"
			else
				return "b0"
			end
		end

		if data then
			return "1"
		else
			return "0"
		end
	end,


--	Fastest.
	["nil"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		return "@"
	end,
}



--[[    This section handles additions necessary for Garry's Mod.    ]]



if gmod then	--	Luckily, a specific table named after the game is present in Garry's Mod.
	local Entity = Entity



	local extra_deserialize = {
--	Entities are stored simply by the ID. They're meant to be transfered, not stored anyway.
--	Exactly like a number definition, except it begins with "e".
		["Entity"] = function(s, i, len, unnecessaryEnd, jobstate)
			local i, a = i or 1
			--	Locals, locals, locals, locals

			a = find(s, "[;:}~]", i)

			if a then
				return Entity(tonumber(sub(s, i, a - 1))), a - 1
			end

			error("vON: Entity ID definition started... Found no end.")
		end,


--	A pair of 3 numbers separated by a comma (,).
		["Vector"] = function(s, i, len, unnecessaryEnd, jobstate)
			local i, a, x, y, z = i or 1
			--	Locals, locals, locals, locals

			a = find(s, ",", i)

			if a then
				x = tonumber(sub(s, i, a - 1))
				i = a + 1
			end

			a = find(s, ",", i)

			if a then
				y = tonumber(sub(s, i, a - 1))
				i = a + 1
			end

			a = find(s, "[;:}~]", i)

			if a then
				z = tonumber(sub(s, i, a - 1))
			end

			if x and y and z then
				return Vector(x, y, z), a - 1
			end

			error("vON: Vector definition started... Found no end.")
		end,


--	A pair of 3 numbers separated by a comma (,).
		["Angle"] = function(s, i, len, unnecessaryEnd, jobstate)
			local i, a, p, y, r = i or 1
			--	Locals, locals, locals, locals

			a = find(s, ",", i)

			if a then
				p = tonumber(sub(s, i, a - 1))
				i = a + 1
			end

			a = find(s, ",", i)

			if a then
				y = tonumber(sub(s, i, a - 1))
				i = a + 1
			end

			a = find(s, "[;:}~]", i)

			if a then
				r = tonumber(sub(s, i, a - 1))
			end

			if p and y and r then
				return Angle(p, y, r), a - 1
			end

			error("vON: Angle definition started... Found no end.")
		end,
	}

	local extra_serialize = {
--	Same as numbers, except they start with "e" instead of "n".
		["Entity"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
			data = data:EntIndex()

			if mustInitiate then
				if isKey or isLast then
					return "e"..data
				else
					return "e"..data..";"
				end
			end

			if isKey or isLast then
				return data
			else
				return data..";"
			end
		end,


--	3 numbers separated by a comma.
		["Vector"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
			if mustInitiate then
				if isKey or isLast then
					return "v"..data.x..","..data.y..","..data.z
				else
					return "v"..data.x..","..data.y..","..data.z..";"
				end
			end

			if isKey or isLast then
				return data.x..","..data.y..","..data.z
			else
				return data.x..","..data.y..","..data.z..";"
			end
		end,


--	3 numbers separated by a comma.
		["Angle"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
			if mustInitiate then
				if isKey or isLast then
					return "a"..data.p..","..data.y..","..data.r
				else
					return "a"..data.p..","..data.y..","..data.r..";"
				end
			end

			if isKey or isLast then
				return data.p..","..data.y..","..data.r
			else
				return data.p..","..data.y..","..data.r..";"
			end
		end,
	}

	for k, v in pairs(extra_serialize) do
		_serialize[k] = v
	end

	for k, v in pairs(extra_deserialize) do
		_deserialize[k] = v
	end

	local extraEntityTypes = { "Vehicle", "Weapon", "NPC", "Player", "NextBot" }

	for i = 1, #extraEntityTypes do
		_serialize[extraEntityTypes[i]] = _serialize.Entity
	end
end



--[[    This section exposes the functions of the library.    ]]



local function checkTableForRecursion(tab, checked, assoc)
	local id = checked.ID

	if not checked[tab] and not assoc[tab] then
		assoc[tab] = id
		checked.ID = id + 1
	else
		checked[tab] = true
	end

	for k, v in pairs(tab) do
		if type(k) == "table" and not checked[k] then
			checkTableForRecursion(k, checked, assoc)
		end
		
		if type(v) == "table" and not checked[v] then
			checkTableForRecursion(v, checked, assoc)
		end
	end
end



local _s_table = _serialize.table
local _d_table = _deserialize.table

_d_meta = {
	__call = function(self, str, allowIdRewriting)
		if type(str) == "string" then
			return _d_table(str, nil, #str, true, {{}, allowIdRewriting})
		end

		error("vON: You must deserialize a string, not a "..type(str))
	end
}
_s_meta = {
	__call = function(self, data, checkRecursion)
		if type(data) == "table" then
			if checkRecursion then
				local assoc, checked = {}, {ID = 1}

				checkTableForRecursion(data, checked, assoc)

				return _s_table(data, nil, nil, nil, nil, true, {assoc, {}})
			end

			return _s_table(data, nil, nil, nil, nil, true, {false})
		end

		error("vON: You must serialize a table, not a "..type(data))
	end
}



von = {
	version = "1.3.4",
	versionNumber = 1003004,	--	Reserving 3 digits per version component.

	deserialize = setmetatable(_deserialize,_d_meta),
	serialize = setmetatable(_serialize,_s_meta)
}



return von
--addons/billy_gas/lua/gmodadminsuite/lang/french.lua:
return {
	Name = "French",
	Flag = "flags16/fr.png",
	Phrases = function() return {

		open_menu                 = "Ouvrir Menu",
		menu_nopermission         = "Désolé, mais vous n'avez pas la permission d'accéder au menu GmodAdminSuite.",
		menu_unknown_module       = "Désolé, mais le module spécifié n'est pas installé ou n'existe pas.",
		menu_disabled_module      = "Désolé, mais ce module est désactivé.",
		menu_module_nopermission  = "Désolé, mais vous n'avez pas la permission d'accéder à ce module.",
		open_gas                  = "Ouvrir GmodAdminSuite",
		module_shortcut           = "Raccourci Module",
		module_shortcut_info      = [[You can quickly access this GmodAdminSuite module through console and chat commands.

		To access the module through your console, type: %s
		To access the module through chat, type: %s

		Additionally, you can bind a key on your keyboard to a specific module.
		To do this, in your console, type: %s

		Make sure to replace KEY with a key on your keyboard of your choice.
		%s]],
		close                     = "Fermer",
		wiki                      = "Wiki",
		licensee                  = "Licencié",
		support                   = "Support",
		module_shop               = "Boutique de Modules",
		welcome                   = "Bienvenue",
		operator                  = "Opérateur",
		script_page               = "Page du Script",
		wiki                      = "Wiki",
		no_modules_available      = "Aucuns modules disponnibles!",
		no_modules_available_info = [[Désolé, but there aren't any GmodAdminSuite modules available for you to use.
		You may have insufficient permissions to use any, or none are enabled.]],
		custom_ellipsis           = "Custom...",
		usergroup_ellipsis        = "Groupe d'Utilisateurs...",
		steamid_ellipsis          = "SteamID...",
		enter_steamid_ellipsis    = "Entrez SteamID...",
		by_distance               = "Par Distance",
		by_usergroup              = "Par Groupes d'Utilisateurs",
		by_team                   = "Par Equipe",
		by_name                   = "Par Nom",
		right_click_to_focus      = "Clic Droit pour faire le focus",
		unknown                   = "Inconnu",
		utilities                 = "Utilitaires",
		player_management         = "Gestion Joueurs",
		administration            = "Administration",
		s_second                  = "1 seconde",
		s_seconds                 = "%d secondes",
		s_minute                  = "1 minute",
		s_minutes                 = "%d minutes",
		s_hour                    = "1 heure",
		s_hours                   = "%d heures",
		second_ago                = "il y a 1 seconde",
		seconds_ago               = "il y a %d secondes",
		minute_ago                = "il y a 1 minute",
		minutes_ago               = "il y a %d minutes",
		hour_ago                  = "il y a 1 heure",
		hours_ago                 = "il y a %d heures",
		just_now                  = "A l'instant",
		click_to_focus            = "Clic pour faire le focus",
		add_steamid               = "SteamID Custom",
		copied                    = "Copié !",
		settings                  = "Paramètres",
		add_steamid_help          = [[Entrez un SteamID ou SteamID64. Exemples:
		SteamID: %s
		SteamID64: %s]],

		setting_default_module = "Module par Défaut",
		setting_default_module_tip = "Quel module doit être ouvert lorsque le menu principal GmodAdminSuite est ouvert ?",
		none = "Aucun",
		general = "Général",
		localization = "Localisation",
		setting_menu_voicechat = "Autoriser Chat Vocal\nlorsque les menu GAS sont ouverts",
		setting_menu_voicechat_tip = "Les menu GmodAdminSuite ne vous empêchent pas de communiquer en jeu lorsqu'ils sont ouverts. Si cette option est active, appuyez simplement sur votre touche désignée à cet effet pour parler.",
		use_gas_language = "Utiliser le langage GmodAdminSuite",
		default_format = "Format par Défaut",
		short_date_format = "Format Date Abrégée",
		long_date_format = "Format Date Entière",
		short_date_format_tip = "Date format used for shorter date formats\n\nThe default format automatically matches the date format of your region (North America, Europe, etc.)",
		long_date_format_tip = "Date format used for longer date formats",
		permissions = "Permissions",
		module_enable_switch_tip = "Changes to this will only apply after a server restart/map change",
		enabled = "Activé",
		modules = "Modules",
		permissions_help = [[GmodAdminSuite utilise une librairie de permission open-sources nommée OpenPermissions, développée par Billy pour GAS. Elle fournit une gestion optimisée des permissions pour les systèmes avancées fonctionnant sur des serveurs de tous types.
		
		OpenPermissions est l'addon depuis lequel vous contrôlerez quels groupes peuvent accéder à quels modules, et ce qu'ils peuvent faire avec ces modules.
		Il peut être ouvert ouvert n'importe quand en écrivant "!openpermissions" dans le chat, ou "openpermissions" dans la console en jeu.

		Pour obtenir de l'aide, ou des informations, cliquez sur l'onglet "Aide" dans le menu OpenPermissions.]],
		website = "Site Web",
		fun = "Fun",

		bvgui_copied               = "Copié !",
		bvgui_open_context_menu    = "Ouvrir Menu Contextuel",
		bvgui_open_steam_profile   = "Afficher Profil Steam",
		bvgui_right_click_to_focus = "Clic Droit pour faire le focus",
		bvgui_click_to_focus       = "Clic pour faire le focus",
		bvgui_unknown              = "Inconnu",
		bvgui_no_data              = "Aucune Données",
		bvgui_no_results_found     = "Aucun résultat trouvé",
		bvgui_done                 = "Terminé",
		bvgui_enter_text_ellipsis  = "Entrez texte...",
		bvgui_loading_ellipsis     = "Chargement...",
		bvgui_pin_tip              = "Appuyez sur ECHAP pour pouvoir de nouveau intéragir avec le menu",

} end }
--addons/billy_gas/lua/gmodadminsuite/modules/fpsbooster/lang/chinese.lua:
return {
    Name = "Chinese",
    Flag = "flags16/cn.png",
    Phrases = function()
        return {
            module_name = "FPS提升器",

            fps_booster = "FPS提升器",
            never_show_again = "不再显示",
            never_show_again_tip = "您将失去此菜单的好处！将来可以在控制台中输入“gmodadminsuite fpsbooster”来打开此菜单。",

            show_fps = "显示FPS",
            multicore_rendering = "启用多核渲染",
            multicore_rendering_help = "这是GMod的一个实验性功能，通过使用多个CPU核心渲染帧来提升FPS。",
            hardware_acceleration = "启用硬件加速",
            shadows = "禁用阴影",
            disable_skybox = "禁用天空盒",
            sprays = "禁用玩家喷漆",
            gibs = "禁用碎片",
            gibs_help = "“碎片”是可以从尸体和布娃娃上飞出的粒子和物体。",
        }
    end
}

--addons/billy_gas/lua/gmodadminsuite/modules/fpsbooster/lang/french.lua:
return {
	Name = "French",
	Flag = "flags16/fr.png",
	Phrases = function() return {

		module_name = "FPS Booster",

		--####################### UI PHRASES #######################--

		fps_booster          = "Booster de FPS",
		never_show_again     = "Ne plus afficher",
		never_show_again_tip = "Vous perdrez les avantages de ce menu ! Tapez \"gmodadminsuite fpsbooster\" dans votre console pour ouvrir ce menu dans le futur.",

		--####################### SETTING PHRASES #######################--

		show_fps                 = "Afficher FPS",
		multicore_rendering      = "Afficher le rendu Multi-Coeur",
		multicore_rendering_help = "C'est une fonctionnalité expérimentale de GMod qui permet d'augmenter les FPS en faisant un rendu des images sur plusieurs coeurs de votre processeur.",
		hardware_acceleration    = "Activer l'Accélération Matérielle",
		shadows                  = "Désactiver les Ombres",
		disable_skybox           = "Désactiver Skybox",
		sprays                   = "Désactiver les Sprays des Joueurs",
		gibs                     = "Désactiver Gibs",
		gibs_help                = "\"Gibs\" Sont des particules qui volent hors des cadavres et des ragdolls.",

} end }
--addons/billy_gas/lua/gmodadminsuite/modules/fpsbooster/sh_init.lua:
if (SERVER) then
	AddCSLuaFile("cl_menu.lua")
else
	GAS:hook("gmodadminsuite:LoadModule:fpsbooster", "LoadModule:fpsbooster", function()
		include("gmodadminsuite/modules/fpsbooster/cl_menu.lua")
	end)
end
--addons/weapon_jedi/lua/lscs/autorun/cl_lscs_convar.lua:
-- dynamic light
local cvarDynamicLight = CreateClientConVar( "lscs_dynamiclight", 1, true, false)

LSCS.DynamicLight = cvarDynamicLight and cvarDynamicLight:GetBool() or false

cvars.AddChangeCallback( "lscs_dynamiclight", function( convar, oldValue, newValue ) 
	LSCS.DynamicLight = tonumber( newValue ) ~=0
end)


-- impact effects
local cvarImpactEffects = CreateClientConVar( "lscs_impacteffects", 1, true, false)

LSCS.ImpactEffects = cvarImpactEffects and cvarImpactEffects:GetBool() or false

cvars.AddChangeCallback( "lscs_impacteffects", function( convar, oldValue, newValue ) 
	LSCS.ImpactEffects = tonumber( newValue ) ~=0
end)


-- trail detail
local cvarSaberTrailDetail = CreateClientConVar( "lscs_traildetail", 100, true, false)

LSCS.SaberTrailDetail  = cvarSaberTrailDetail and (cvarSaberTrailDetail:GetInt() / 100) or 1

cvars.AddChangeCallback( "lscs_traildetail", function( convar, oldValue, newValue ) 
	LSCS.SaberTrailDetail = math.Clamp( tonumber( newValue ), 0, 100 ) / 100
end)


-- host timescale
local cVarTimeScale = GetConVar( "host_timescale" )

LSCS.TimeScale = cVarTimeScale and cVarTimeScale:GetFloat() or 1

cvars.AddChangeCallback( "host_timescale", function( convar, oldValue, newValue ) 
	LSCS.TimeScale = tonumber( newValue )
end)


-- hud should draw
local cvarDrawHud = CreateClientConVar( "lscs_drawhud", 1, true, false)

LSCS.DrawHud = cvarDrawHud and cvarDrawHud:GetBool() or false

cvars.AddChangeCallback( "lscs_drawhud", function( convar, oldValue, newValue ) 
	LSCS.DrawHud = tonumber( newValue ) ~=0
end)
--addons/weapon_jedi/lua/lscs/autorun/cl_lscs_menu.lua:
local THE_FONT = {
	font = "Verdana",
	extended = false,
	size = 20,
	weight = 2000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = true,
	additive = false,
	outline = false,
}
surface.CreateFont( "LSCS_FONT", THE_FONT )

THE_FONT.size = 12
THE_FONT.weight = 500
surface.CreateFont( "LSCS_FONT_SMALL", THE_FONT )

THE_FONT.font = "Ink Free"
THE_FONT.size = 16
THE_FONT.weight = 1000
surface.CreateFont( "LSCS_VERSION", THE_FONT )

THE_FONT.size = 40
THE_FONT.weight = 1000
surface.CreateFont( "LSCS_FONT_MAXIMUM", THE_FONT )

local function bezier(p0, p1, p2, p3, t)
	local e = p0 + t * (p1 - p0)
	local f = p1 + t * (p2 - p1)
	local g = p2 + t * (p3 - p2)

	local h = e + t * (f - e)
	local i = f + t * (g - f)

	local p = h + t * (i - h)

	return p
end

local function DrawFrame( w, h, offset, thickness )
	surface.DrawRect( offset, offset, thickness, h - offset * 2 )
	surface.DrawRect( w - offset - thickness, offset, thickness, h - offset * 2 )

	surface.DrawRect( offset, offset, w - offset * 2 - thickness, thickness )
	surface.DrawRect( offset, h - offset - thickness, w - offset * 2 - thickness, thickness )
end

local function DrawBezier( startPos, endPos )
	local detail = 15
	local p2 = Vector(endPos.x,startPos.y,0)
	local p3 = Vector(startPos.x,endPos.y,0)

	for i = 1,detail do
		local sp = bezier(startPos, p2, p3, endPos, (i - 1) / detail)
		local ep = bezier(startPos, p2, p3, endPos, i / detail)
		surface.DrawLine( sp.x, sp.y, ep.x, ep.y )
	end
end

local Gradient = Material("vgui/gradient-l")
local ClickMat = Material("sun/overlay")

local menu_white_dim = Color(100,100,100,255)
local menu_white = Color(255,255,255,255)
local menu_dark = Color(24,30,54,255)
local menu_dim = Color(37,42,64,255)
local menu_light = Color(46,51,73,255)
local menu_black = Color(31,31,31,255)
local menu_text = Color(0,127,255,255)

local icon_lscs = Material("lscs/ui/icon256.png")

local icon_inventory = Material("lscs/ui/inventory.png")
local icon_hilt = Material("lscs/ui/hilt.png")
local icon_stance = Material("lscs/ui/stance.png")
local icon_force = Material("lscs/ui/force.png")
local icon_settings = Material("lscs/ui/settings.png")

local icon_check = Material("lscs/ui/check.png")
local icon_cross = Material("lscs/ui/cross.png")

local icon_hand = Material("lscs/ui/hand.png")
local icon_lhand = Material("lscs/ui/hand_l.png")
local icon_rhand = Material("lscs/ui/hand_r.png")

local icon_load_version = Material("gui/html/refresh")

local icon_invert = Material( "lscs/ui/logo_invert.png")
local icon_steam = Material("lscs/ui/steam.png")
local icon_youtube = Material("lscs/ui/youtube.png")
local icon_discord = Material("lscs/ui/discord.png")
local icon_github = Material("lscs/ui/github.png")

local zoom_mat = Material( "vgui/zoom" )
local gradient_mat = Material( "gui/gradient" )
local adminMat = Material( "icon16/shield.png" )

local function BaseButtonClick( self, sound )
	if not self:IsEnabled() then return end

	sound = sound or "ui/buttonclick.wav"

	surface.PlaySound( sound )
	self.smScale = 1
end

local function DrawButtonClick( self, w, h ) 
	local Col = menu_white_dim
	if self:IsHovered() then
		Col = menu_white
	end
	if not self:IsEnabled() then
		Col = menu_text
	end

	self.smScale = self.smScale or 0
	self.smScale = self.smScale - math.min(self.smScale,RealFrameTime() * 3)

	local Size = self.smScale

	if Size > 0.05 then
		surface.DrawCircle( w * 0.5, h * 0.5, (1 - Size) * (w - 25), 150, 200, 255, 255 * Size )
		surface.DrawCircle( w * 0.5, h * 0.5, (1 - Size) * (w - 15), 150, 200, 255, 255 * 0.5 * Size )
		surface.DrawCircle( w * 0.5, h * 0.5, (1 - Size) * (w - 10), 150, 200, 255, 255 * 0.2 * Size )

		surface.SetMaterial( ClickMat )
		surface.SetDrawColor( 150 * Size, 200 * Size, 255 * Size, 255 * Size )
		surface.DrawTexturedRect( w * 0.5 - w * 0.5 * Size * 2, h * 0.5 - h * 0.5 * Size * 2, w * Size * 2, h * Size * 2 )
	end

	return Col
end

local ForceNum = 1
local StanceNum = 1
local Frame

local FrameBarHeight = 24

local FrameSizeX = 750
local FrameSizeY = 480 + FrameBarHeight

local SelectorHeight = 80 * 6
local SelectorWidth = 80
local SelectorWidthActive = 196

local PanelPosX = SelectorWidth
local PanelPosY = FrameBarHeight
local PanelSizeX = FrameSizeX - SelectorWidth
local PanelSizeY = FrameSizeY - FrameBarHeight * 2

function LSCS:SetActivePanel( newpanel )
	if not IsValid( Frame ) then
		LSCS:OpenMenu()
	end

	if IsValid( Frame.PANEL ) then
		Frame.PANEL:Remove()
	end

	Frame.PANEL = newpanel
end

local function BaseButtonClickSB( self, sound )
	sound = sound or "ui/buttonclick.wav"

	surface.PlaySound( sound )

	Frame.buttons = Frame.buttons or {}
	Frame.buttons[ self.ID ] = 1
end

local function DrawButtonClickSB( self, w, h ) 
	local Col = menu_white_dim
	if self:IsHovered() then
		Col = menu_white
	end

	Frame.buttons = Frame.buttons or {}
	Frame.buttons[ self.ID ] = Frame.buttons[ self.ID ] or 0

	Frame.buttons[ self.ID ] = Frame.buttons[ self.ID ] - math.min(Frame.buttons[ self.ID ],RealFrameTime() * 3)

	local Size = Frame.buttons[ self.ID ]

	if Size > 0.05 then
		surface.DrawCircle( w * 0.5, h * 0.5, (1 - Size) * (w - 25), 150, 200, 255, 255 * Size )
		surface.DrawCircle( w * 0.5, h * 0.5, (1 - Size) * (w - 15), 150, 200, 255, 255 * 0.5 * Size )
		surface.DrawCircle( w * 0.5, h * 0.5, (1 - Size) * (w - 10), 150, 200, 255, 255 * 0.2 * Size )

		surface.SetMaterial( ClickMat )
		surface.SetDrawColor( 150 * Size, 200 * Size, 255 * Size, 255 * Size )
		surface.DrawTexturedRect( w * 0.5 - w * 0.5 * Size * 2, h * 0.5 - h * 0.5 * Size * 2, w * Size * 2, h * Size * 2 )
	end

	return Col
end

local function CreateSideBarButton( icon, ID, text )
	local button = vgui.Create( "Button", Frame.SideBar )
	button.text = text or ""
	button:SetText( "" )	
	button:SetSize( SelectorWidthActive,  80 )
	button:SetPos( 0,  (ID - 1) * 80 )
	button.DoClick = function( self )
	end
	button.Paint = function(self, w, h )
		Frame._smSB = Frame._smSB or SelectorWidth

		local xPos = Frame._smSB - 8 - 64

		local Col = DrawButtonClickSB( self, w, h ) 
		if Frame.ID == self.ID then
			Col = menu_text

			draw.DrawText( self.text, "LSCS_FONT", -110 + xPos, h * 0.5 - 10, Col, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

			surface.SetMaterial( Gradient )
			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			surface.DrawTexturedRect( 0, 0, 6, h )
		else
			draw.DrawText( self.text, "LSCS_FONT", -110 + xPos, h * 0.5 - 10, Col, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		end

		surface.SetMaterial( icon )
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawTexturedRect( xPos, 8, 64, 64 )
	end
	button.ID = ID

	return button
end

function LSCS:SideBar( Frame )
	if IsValid( Frame.SideBar ) then
		Frame.SideBar:Remove()
	end
	Frame.SideBar = vgui.Create( "DPanel", Frame )
	Frame.SideBar:SetPos( 0, FrameBarHeight )
	Frame.SideBar:SetSize( (Frame:SideBarIsActive() and SelectorWidthActive or SelectorWidth), SelectorHeight )
	Frame.SideBar.Paint = function(self, w, h )
		draw.RoundedBoxEx( 8, 0, 0, w, h, menu_dark, false, false, true, false )
	end

	local button = CreateSideBarButton( icon_lscs, 1, "Home" )
	button.DoClick = function( self )
		BaseButtonClickSB( self )
		LSCS:BuildMainMenu( Frame )
	end

	local button = CreateSideBarButton( icon_inventory, 2, "Inventory" )
	button.DoClick = function( self )
		BaseButtonClickSB( self )
		LSCS:BuildInventory( Frame )
	end

	local button = CreateSideBarButton( icon_hilt, 3, "Lightsaber" )
	button.DoClick = function( self )
		BaseButtonClickSB( self )
		LSCS:BuildSaberMenu( Frame )
	end

	local button = CreateSideBarButton( icon_stance, 4, "Stance" )
	button.DoClick = function( self )
		BaseButtonClickSB( self )
		LSCS:BuildStanceMenu( Frame )
	end

	local button = CreateSideBarButton( icon_force, 5, "Force" )
		button.DoClick = function( self )
		BaseButtonClickSB( self )
		LSCS:BuildForceMenu( Frame )
	end

	local button = CreateSideBarButton( icon_settings, 6, "Settings" )
		button.DoClick = function( self )
		BaseButtonClickSB( self )
		LSCS:BuildSettings( Frame )
	end
end

function LSCS:BuildMainMenu( Frame )
	local smMove = 0

	local Panel = vgui.Create( "DPanel", Frame )
	Panel:SetPos( PanelPosX, PanelPosY )
	Panel:SetSize( PanelSizeX, PanelSizeY + FrameBarHeight )
	Panel.Paint = function(self, w, h )
		local Col = Color( 255, 191, 0, 255 ) 

		surface.SetDrawColor( menu_dim )
		surface.DrawRect( 4, h - 64, w - 8, 60 )

		if LSCS.VERSION_GITHUB == 0 then
			surface.SetMaterial( icon_load_version )
			surface.SetDrawColor( Col )
			surface.DrawTexturedRectRotated( w - 14, h - 14, 16, 16, -CurTime() * 200 )

			draw.SimpleText( "v"..LSCS:GetVersion()..LSCS.VERSION_TYPE, "LSCS_VERSION", w - 23, h - 14, Col, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
		else
			local Current = LSCS:GetVersion()
			local Latest = LSCS.VERSION_GITHUB

			local Pref = "v"

			if Current >= Latest then
				Col = Color(0,255,0,255)
			else
				Col = Color(255,0,0,255)
				Pref = "OUTDATED v"
			end

			draw.SimpleText( Pref..LSCS:GetVersion()..LSCS.VERSION_TYPE, "LSCS_VERSION", w - 7, h - 14, Col, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
		end
	end

	local Header = vgui.Create( "DPanel", Panel )
	Header:SetSize( 0, 136 )
	Header:Dock( TOP )
	Header.Paint = function(self, w, h )
		-- showoff lmao
		local Col = menu_light

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h )

		local A = math.rad( CurTime() * 150 )
		local X = math.cos( A ) * w * 0.5
		local Y = math.sin( A ) * h * 0.5

		surface.SetDrawColor( menu_dim )
		surface.DrawRect( w - 132, 4, 128, 128 )

		surface.SetMaterial( ClickMat )
		surface.SetDrawColor( menu_text )

		surface.DrawTexturedRectRotated( w * 0.5 + X - 5, h * 0.5 + Y, 150, 150, 0 )

		surface.SetDrawColor( menu_dim )
		surface.SetMaterial( icon_invert )
		surface.DrawTexturedRect( w - 132, 4, 128, 128 )
		surface.DrawRect( 4, 4, w - 136, 128 )

		draw.SimpleText( "THANK YOU FOR USING", "LSCS_FONT_MAXIMUM", w * 0.5 - 18, h * 0.5, menu_text, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
		draw.SimpleText( "LSCS", "LSCS_FONT_MAXIMUM", w * 0.5 - 18, h * 0.5, menu_text, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
	end

	local Bar = vgui.Create( "DPanel", Panel )
	Bar:SetSize( 0, 136 )
	Bar:Dock( TOP )
	Bar:DockMargin( 4, 0, 4, 4 )
	Bar.Paint = function(self, w, h )
		local Col = menu_dim

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h )
	end

	local B = vgui.Create( "DButton", Bar )
	B:SetText("")
	B:SetSize( PanelSizeX * 0.45 , 128 )
	B:Dock( LEFT )
	B:DockMargin( 4, 4, 4, 4 )
	B.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		draw.SimpleText( "PROBLEMS?", "LSCS_FONT_MAXIMUM", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
		draw.SimpleText( "REPORT HERE", "LSCS_FONT_MAXIMUM", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
	end
	B.DoClick = function( self )
		BaseButtonClick( self )
		timer.Simple( 0.5, function()
			gui.OpenURL( "https://github.com/Blu-x92/lscs_public" )
		end )
	end

	local B = vgui.Create( "DButton", Bar )
	B:SetText("")
	B:SetSize( PanelSizeX * 0.5 , 128 )
	B:Dock( LEFT )
	B:DockMargin( 4, 4, 4, 4 )
	B.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		draw.SimpleText( "THIS PROJECT", "LSCS_FONT_MAXIMUM", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
		draw.SimpleText( "ON STEAM", "LSCS_FONT_MAXIMUM", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
	end
	B.DoClick = function( self )
		BaseButtonClick( self )
		timer.Simple( 0.5, function()
			gui.OpenURL( "https://steamcommunity.com/sharedfiles/filedetails/?id=2837856621" )
		end )
	end

	local ToolBar = vgui.Create( "DPanel", Panel )
	ToolBar:SetSize( 0, 136 )
	ToolBar:Dock( TOP )
	ToolBar:DockMargin( 4, 0, 4, 4 )
	ToolBar.Paint = function(self, w, h )
		local Col = menu_dim

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h )
	end

	local B = vgui.Create( "DButton", ToolBar )
	B:SetText("")
	B:SetSize( 128, 128 )
	B:Dock( LEFT )
	B:DockMargin( 60, 4, 4, 4 )
	B.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		surface.SetMaterial( icon_steam )
		surface.SetDrawColor( Col )
		surface.DrawTexturedRectRotated( w * 0.5, h * 0.5, w, h, 0 )

		draw.SimpleText( "STEAM", "LSCS_FONT", w * 0.5, h - 4, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
	end
	B.DoClick = function( self )
		BaseButtonClick( self )
		timer.Simple( 0.5, function()
			gui.OpenURL( "https://steamcommunity.com/id/Blu-x92/myworkshopfiles/" )
		end )
	end

	local B = vgui.Create( "DButton", ToolBar )
	B:SetText("")
	B:SetSize( 128, 128 )
	B:Dock( LEFT )
	B:DockMargin( 4, 4, 4, 4 )
	B.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		surface.SetMaterial( icon_discord )
		surface.SetDrawColor( Col )
		surface.DrawTexturedRectRotated( w * 0.5, h * 0.5, w, h, 0 )

		draw.SimpleText( "DISCORD", "LSCS_FONT", w * 0.5, h - 4, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
	end
	B.DoClick = function( self )
		BaseButtonClick( self )
		timer.Simple( 0.5, function()
			gui.OpenURL( "https://discord.gg/BeVtn7uwNH" )
		end )
	end

	local B = vgui.Create( "DButton", ToolBar )
	B:SetText("")
	B:SetSize( 128, 128 )
	B:Dock( LEFT )
	B:DockMargin( 4, 4, 4, 4 )
	B.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		surface.SetMaterial( icon_youtube )
		surface.SetDrawColor( Col )
		surface.DrawTexturedRectRotated( w * 0.5, h * 0.5, w, h, 0 )

		draw.SimpleText( "YOUTUBE", "LSCS_FONT", w * 0.5, h - 4, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
	end
	B.DoClick = function( self )
		BaseButtonClick( self )
		timer.Simple( 0.5, function()
			gui.OpenURL( "https://www.youtube.com/channel/UCoXuTyv69fGOUv7hZcAPHoQ" )
		end )
	end

	local B = vgui.Create( "DButton", ToolBar )
	B:SetText("")
	B:SetSize( 128, 128 )
	B:Dock( LEFT )
	B:DockMargin( 4, 4, 4, 4 )
	B.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		surface.SetMaterial( icon_github )
		surface.SetDrawColor( Col )
		surface.DrawTexturedRectRotated( w * 0.5, h * 0.5, w, h, 0 )

		draw.SimpleText( "GITHUB", "LSCS_FONT", w * 0.5, h - 4, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
	end
	B.DoClick = function( self )
		BaseButtonClick( self )
		timer.Simple( 0.5, function()
			gui.OpenURL( "https://github.com/Blu-x92" )
		end )
	end

	LSCS:SetActivePanel( Panel )
	LSCS:SideBar( Frame )

	Frame.ID = 1
end

function LSCS:BuildInventory( Frame )
	local ply = LocalPlayer()

	local Panel = vgui.Create( "DPanel", Frame )
	Panel:SetPos( PanelPosX, PanelPosY )
	Panel:SetSize( PanelSizeX, PanelSizeY + FrameBarHeight )
	Panel.Paint = function(self, w, h )
		surface.SetMaterial( ClickMat )
		surface.SetDrawColor( 255, 255, 255, 255 )
		local X, Y = self:CursorPos()
		surface.DrawTexturedRectRotated( X, Y, 512, 512, 0 )

		local Col = menu_light
		surface.SetDrawColor( Col.r, Col.g, Col.b, 240 )
		surface.DrawRect( 0, 0, w, h  )
	end

	local ToolBar = vgui.Create( "DPanel", Panel )
	ToolBar:SetSize( PanelSizeX, 50 )
	ToolBar:Dock( BOTTOM )
	ToolBar:DockMargin( 10, 4, 24, 10 )
	ToolBar.Paint = function(self, w, h )
		local Col = menu_dim

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h )
	end

	local Refresh = vgui.Create( "DButton", ToolBar )
	Refresh:SetText("")
	Refresh:SetSize( 130, 100 )
	Refresh:Dock( RIGHT )
	Refresh:DockMargin( 4, 4, 4, 4 )
	Refresh.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		draw.SimpleText( "REFRESH", "LSCS_FONT", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )

		DrawFrame( w, h, 0, 2 )
	end
	Refresh.DoClick = function( self )
		BaseButtonClick( self )

		self:SetEnabled( false )

		timer.Simple( 0.2, function()
			if not IsValid( self ) then return end
			self:SetEnabled( true )
			net.Start("lscs_inventory_refresh")
				net.WriteBool( false )
			net.SendToServer()
		end )
	end

	local DropAll = vgui.Create( "DButton", ToolBar )
	DropAll:SetText("")
	DropAll:SetSize( 180, 100 )
	DropAll:Dock( LEFT )
	DropAll:DockMargin( 4, 4, 4, 4 )
	DropAll.SafetyEnabled = 1
	DropAll.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		if self.SafetyEnabled == 1 then
			draw.SimpleText( "DROP ALL", "LSCS_FONT", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		elseif self.SafetyEnabled == 2 then
			draw.SimpleText( "ARE YOU SURE??", "LSCS_FONT", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		else
			Col = Color(255, 0, 0, 255)
			surface.SetMaterial( ClickMat )
			surface.SetDrawColor( 150, 0, 0, 255 )
			surface.DrawTexturedRect( 0, 0, w, h )

			draw.SimpleText( "!!DROP ALL!!", "LSCS_FONT", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )

		DrawFrame( w, h, 0, 2 )
	end
	DropAll.DoClick = function( self )
		BaseButtonClick( self )

		if self.SafetyEnabled < 3 then
			self:SetEnabled( false )

			timer.Simple( 1, function()
				if not IsValid( self ) then return end
				self:SetEnabled( true )
				self.SafetyEnabled = self.SafetyEnabled + 1
			end )
		else
			self:SetEnabled( false )

			net.Start("lscs_inventory_refresh")
				net.WriteBool( true )
				net.WriteBool( false )
			net.SendToServer()
		end
	end

	local DropUnEq = vgui.Create( "DButton", ToolBar )
	DropUnEq:SetText("")
	DropUnEq:SetSize( 180, 100 )
	DropUnEq:Dock( LEFT )
	DropUnEq:DockMargin( 4, 4, 4, 4 )
	DropUnEq.SafetyEnabled = 1
	DropUnEq.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		if self.SafetyEnabled == 1 then
			draw.SimpleText( "DROP", "LSCS_FONT", w * 0.5, h * 0.5 + 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			draw.SimpleText( "UNEQUIPPED", "LSCS_FONT", w * 0.5, h * 0.5 - 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		elseif self.SafetyEnabled == 2 then
			draw.SimpleText( "ARE YOU SURE??", "LSCS_FONT", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		else
			Col = Color(255, 0, 0, 255)
			surface.SetMaterial( ClickMat )
			surface.SetDrawColor( 150, 0, 0, 255 )
			surface.DrawTexturedRect( 0, 0, w, h )

			draw.SimpleText( "!!DROP!!", "LSCS_FONT", w * 0.5, h * 0.5 + 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			draw.SimpleText( "!!UNEQUIPPED!!", "LSCS_FONT", w * 0.5, h * 0.5 - 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		end

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )

		DrawFrame( w, h, 0, 2 )
	end
	DropUnEq.DoClick = function( self )
		BaseButtonClick( self )

		if self.SafetyEnabled < 3 then
			self:SetEnabled( false )

			timer.Simple( 1, function()
				if not IsValid( self ) then return end
				self:SetEnabled( true )
				self.SafetyEnabled = self.SafetyEnabled + 1
			end )
		else
			self:SetEnabled( false )

			net.Start("lscs_inventory_refresh")
				net.WriteBool( true )
				net.WriteBool( true )
			net.SendToServer()
		end
	end

	local DScrollPanel = vgui.Create( "DScrollPanel", Panel )
	DScrollPanel:SetSize( PanelSizeX, PanelSizeY - 40 )
	DScrollPanel:Dock( BOTTOM )

	local Inventory = LocalPlayer():lscsGetInventory()

	local X = 8
	local Y = 8
	for index, class in pairs( Inventory ) do
		local DButton = vgui.Create( "DButton", DScrollPanel )
		DButton:SetText( "" )
		DButton:SetPos( X, Y )
		DButton:SetSize( 128, 128 )

		DButton.SetMaterial = function( self, mat ) 
			if file.Exists( "materials/"..mat, "GAME" ) then
				self.Mat = Material( mat )
			else
				self.Mat = Material( "debug/debugwireframe" )
			end
		end
		DButton.GetMaterial = function( self ) return self.Mat end

		DButton.SetID = function( self, id ) self.ID = id end
		DButton.GetID = function( self ) return self.ID end

		DButton.SetItem = function( self, item ) self.Item = LSCS:ClassToItem( item ) self.ClassName = class end
		DButton.GetItem = function( self ) return self.Item end

		DButton:SetItem( class )
		DButton:SetID( index )
		DButton:SetMaterial( "entities/"..class..".png" )

		DButton.Paint = function(self, w, h )
			if not self:IsEnabled() then
				local Col = menu_dim
				surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
				surface.DrawRect( 2, 2, w - 4, h - 4 )
				return
			end

			surface.SetMaterial( self:GetMaterial() )
			surface.SetDrawColor( 255,255,255,255 )
			surface.DrawTexturedRect( 2, 2, w - 4, h - 4 )

			DrawButtonClick( self, w, h ) 

			if not self:IsHovered() and not IsValid( self.menu ) then
				local Col = menu_dark

				surface.SetDrawColor( 0,0,0,100 )
				surface.DrawRect( 2, 2, w - 4, h - 4 )

				surface.SetDrawColor( Color(255,255,255,255) )
				surface.SetMaterial(zoom_mat ) 

				local BoxSize = w - 4
				local xPos = 2
				local yPos = 2

				surface.DrawTexturedRectRotated( xPos + BoxSize * 0.25, yPos + BoxSize * 0.25, BoxSize * 0.5, BoxSize * 0.5, 90 )
				surface.DrawTexturedRectRotated( xPos + BoxSize * 0.75, yPos + BoxSize * 0.25, BoxSize * 0.5, BoxSize * 0.5, 0 )
				surface.DrawTexturedRectRotated( xPos + BoxSize * 0.25, yPos + BoxSize * 0.75, BoxSize * 0.5, BoxSize * 0.5, 180 )
				surface.DrawTexturedRectRotated( xPos + BoxSize * 0.75, yPos + BoxSize * 0.75, BoxSize * 0.5, BoxSize * 0.5, 270 )

				surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
				surface.DrawRect( 4, h - 24, w-8, 20  )
		
				local Item = self:GetItem()
				if Item then
					draw.SimpleText( Item.name.." ["..Item.Type.."]", "LSCS_FONT_SMALL", w * 0.5, h - 8, menu_white_dim, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
				else
					draw.SimpleText( self.ClassName, "LSCS_FONT_SMALL", w * 0.5, h - 8, menu_white_dim, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
				end

				local eq = ply:lscsGetEquipped()[ self:GetID() ] 
				if isbool( eq ) then
					surface.SetDrawColor( 255, 191, 0, 255 )
					DrawFrame( w, h, 2, 2 )

					if Item and (Item.type == "hilt" or Item.type == "crystal") then
						if eq == true then
							surface.SetMaterial( icon_rhand )
						else
							surface.SetMaterial( icon_lhand )
						end
					else
						surface.SetMaterial( icon_hand )
					end
					surface.DrawTexturedRect( 4, 4, 64, 64 )

				end
			else
				local Col = menu_light

				surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
				surface.DrawRect( 4, h - 24, w-8, 20  )

				local Item = self:GetItem()
				if Item then
					draw.SimpleText( Item.name.." ["..Item.Type.."]", "LSCS_FONT_SMALL", w * 0.5, h - 8, menu_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
				else
					draw.SimpleText( self.ClassName, "LSCS_FONT_SMALL", w * 0.5, h - 8, menu_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
				end

				Col = menu_text

				if IsValid( self.menu ) then
					surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
					DrawFrame( w, h, 2, 2 )
					if isbool( ply:lscsGetEquipped()[ self:GetID() ] ) then
						surface.SetDrawColor( 255, 191, 0, 255 )
						DrawFrame( w, h, 4, 2 )
					end
				else
					if isbool( ply:lscsGetEquipped()[ self:GetID() ] ) then
						surface.SetDrawColor( 255, 191, 0, 255 )
						DrawFrame( w, h, 2, 2 )
					else
						if self:IsHovered() then
							surface.SetDrawColor( Color(255,255,255,255) )
							DrawFrame( w, h, 2, 2 )
						end
					end
				end
			end
		end
		DButton.DoClick = function( self )
			BaseButtonClick( self )

			self.menu = DermaMenu()

			if isbool( ply:lscsGetEquipped()[ self:GetID() ] ) then
				self.menu:AddOption( "Unequip", function()
					if not self.GetItem then return end -- what happened ?

					local Item = self:GetItem()

					if not Item then return end

					if Item.type == "hilt" or Item.type == "crystal" then
						ply:lscsEquipItem( self:GetID(), nil )
						ply:lscsCraftSaber()
					else
						ply:lscsEquipItem( self:GetID(), nil )
					end
				end )
			else
				self.menu:AddOption( "Equip", function()
					if not self.GetItem then return end -- what happened ?

					local Item = self:GetItem()

					if not Item then return end

					if Item.type == "hilt" then
						ply:lscsClearEquipped( "hilt" )
					end

					if Item.type == "crystal" then
						ply:lscsClearEquipped( "crystal" )
					end

					ply:lscsEquipItem( self:GetID(), true )

					if Item.type =="hilt" or Item.type == "crystal" then
						local A, _ = ply:lscsGetHilt()
						local B, _ = ply:lscsGetBlade()
						if A and A ~= "" and B and B ~= "" then
							ply:lscsCraftSaber()
						end
					end
				end )
			end
			self.menu:AddOption( "Drop", function() ply:lscsDropItem( self:GetID() ) self:SetEnabled( false ) end )
			self.menu:Open()
		end
		DButton.DoRightClick = function( self )
		end

		X = X + 128
		if X > (PanelSizeX - 128) then
			X = 8
			Y = Y + 128
		end
	end

	while Y < (PanelSizeY - 128) or X < (PanelSizeX - 128) do
		local Panel = vgui.Create( "DPanel", DScrollPanel )
		Panel:SetPos( X, Y )
		Panel:SetSize( 128, 128 )
		Panel.Paint = function(self, w, h )
			local Col = menu_dim
			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			surface.DrawRect( 2, 2, w - 4, h - 4 )
		end

		X = X + 128
		if X > (PanelSizeX - 128) then
			if Y < (PanelSizeY - 128) then
				X = 8
			end
			Y = Y + 128
		end
	end

	LSCS:SetActivePanel( Panel )
	LSCS:SideBar( Frame )

	Frame.ID = 2
end

local CrafterButtonPaint = function(self, w, h )
	if self.Item then
		if not self.Mat then
			if file.Exists( "materials/entities/"..self.Item.class..".png", "GAME" ) then
				self.Mat = Material( "entities/"..self.Item.class..".png" )
			else
				self.Mat = Material( "debug/debugwireframe" )
			end
		end

		surface.SetMaterial( self.Mat )
		surface.SetDrawColor( 255, 255, 255 ,255 )
		surface.DrawTexturedRect( 2, h * 0.5 - w * 0.5 - 2, w - 4, w - 4 )

		local IsMainHovered = IsValid(self.Main) and self.Main:IsHovered()
		if self:IsHovered() or IsValid( self.menu ) or IsMainHovered then
			Col = menu_light

			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			surface.DrawRect( 4, h - 24, w-8, 20  )

			draw.SimpleText( self.Item.name, "LSCS_FONT_SMALL", w * 0.5, h - 8, menu_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
		else
			surface.SetDrawColor( Color(255,255,255,255) )
			surface.SetMaterial(zoom_mat ) 
			local BoxSizeX = w - 4
			local BoxSizeY = h - 4
			local xPos = 2
			local yPos = 2

			surface.DrawTexturedRectRotated( xPos + BoxSizeX * 0.25, yPos + BoxSizeY * 0.25, BoxSizeY * 0.5, BoxSizeX * 0.5, 90 )
			surface.DrawTexturedRectRotated( xPos + BoxSizeX * 0.75, yPos + BoxSizeY * 0.25, BoxSizeX * 0.5, BoxSizeY * 0.5, 0 )
			surface.DrawTexturedRectRotated( xPos + BoxSizeX * 0.25, yPos + BoxSizeY * 0.75, BoxSizeX * 0.5, BoxSizeY * 0.5, 180 )
			surface.DrawTexturedRectRotated( xPos + BoxSizeX * 0.75, yPos + BoxSizeY * 0.75, BoxSizeY * 0.5, BoxSizeX * 0.5, 270 )

			Col = menu_dark
			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			surface.DrawRect( 4, h - 24, w-8, 20  )
	
			draw.SimpleText( self.Item.name, "LSCS_FONT_SMALL", w * 0.5, h - 8, menu_white_dim, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
		end

		local Col = DrawButtonClick( self, w, h )
		
		if IsMainHovered then
			Col = menu_white
		end

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		DrawFrame( w, h, 0, 2 )


		local Col = menu_text
		if IsValid( self.menu ) then
			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			DrawFrame( w, h, 0, 2 )
		end
	else
		local Col = menu_dark
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h )

		Col = DrawButtonClick( self, w, h )

		surface.SetMaterial( icon_cross )

		if self:IsHovered() then
			Col = Color(255,0,0,255)
		end
		if IsValid( self.menu ) then
			Col = menu_white
		end

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )

		surface.DrawTexturedRect( 32, 32, 64, 64 )

		DrawFrame( w, h, 0, 2 )

		draw.SimpleText( self.InfoText, "LSCS_FONT", w * 0.5, h - 8, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )

		if IsValid( self.menu ) then
			Col = menu_text
			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			DrawFrame( w, h, 0, 2 )
		end
	end
end

function LSCS:BuildSaberMenu( Frame )
	local ply = LocalPlayer()
	local HiltR, HiltL = ply:lscsGetHilt()
	local BladeR, BladeL = ply:lscsGetBlade()

	local AAA = 80

	local Panel = vgui.Create( "DPanel", Frame )
	Panel:SetPos( PanelPosX, PanelPosY )
	Panel:SetSize( PanelSizeX, PanelSizeY + FrameBarHeight )
	Panel.Paint = function(self, w, h )
		surface.SetMaterial( ClickMat )
		surface.SetDrawColor( 150,150,150,150 )
		local X, Y = self:CursorPos()
		surface.DrawTexturedRectRotated( X, Y, 512, 512, 0 )

		draw.RoundedBoxEx( 8, 4, 4, w - 8, h - 8, menu_dim, false, false, false, true )

		draw.SimpleText( "Information", "LSCS_FONT", 8, 14, menu_text, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		draw.SimpleText( "NOTE: For this to work you need a Hilt and a Blade-Crystal in your Inventory and you must have permission to spawn SWEP's", "LSCS_FONT_SMALL", 8, 30, menu_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

		if IsValid( self.Main ) and self.Main:IsHovered() then
			local Col = menu_white_dim
			if HiltR and BladeR then
				Col = menu_white
			end
			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			DrawBezier( Vector(PanelSizeX - 125,PanelSizeY - 54,0), Vector(PanelSizeX * 0.5 + 64,35+64+AAA,0) )
			surface.DrawLine( 163, 99+AAA, PanelSizeX * 0.5 - 64,35+64+AAA )
			Col = menu_white_dim
			if HiltL and BladeL then
				Col = menu_white
			end
			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			DrawBezier( Vector(PanelSizeX - 125,PanelSizeY - 54,0), Vector(PanelSizeX * 0.5 + 64,PanelSizeY - 64 - 35,0) )
			surface.DrawLine( 163, PanelSizeY - 64 - 35, PanelSizeX * 0.5 - 64,PanelSizeY - 64 - 35 )
		else
			local Col = menu_white_dim
			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			DrawBezier( Vector(PanelSizeX - 125,PanelSizeY - 54,0), Vector(PanelSizeX * 0.5 + 64,35+64+AAA,0) )
			surface.DrawLine( 163, 99+AAA, PanelSizeX * 0.5 - 64,35+64+AAA )
			DrawBezier( Vector(PanelSizeX - 125,PanelSizeY - 54,0), Vector(PanelSizeX * 0.5 + 64,PanelSizeY - 64 - 35,0) )
			surface.DrawLine( 163, PanelSizeY - 64 - 35, PanelSizeX * 0.5 - 64,PanelSizeY - 64 - 35 )
		end
	end

	local Main = vgui.Create( "DButton", Panel )
	Main:SetText( "" )
	Main:SetPos( PanelSizeX - 125, PanelSizeY - 104 )
	Main:SetSize( 100, 100 )
	Main.Paint = function(self, w, h )
		local Col = menu_dark
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h )

		Col = DrawButtonClick( self, w, h )
		local Col2 = Col

		surface.SetMaterial( icon_check )
		if self:IsHovered() then
			Col2 = Color(0,255,0)
		end
		surface.SetDrawColor( Col2.r, Col2.g, Col2.b, Col2.a )
		surface.DrawTexturedRect( 18, 18, w - 36, h - 36 )

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		DrawFrame( w, h, 0, 2 )
	end
	Main.DoClick = function( self )
		BaseButtonClick( self )
		ply:lscsCraftSaber()
		Frame:Remove()
	end
	Panel.Main = Main

	-- RIGHT
	local ButtonHilt = vgui.Create( "DButton", Panel )
	ButtonHilt.InfoText = "Hilt [RH]"
	ButtonHilt:SetText( "" )
	ButtonHilt:SetPos( PanelSizeX * 0.5 - 64, 35 + AAA )
	ButtonHilt:SetSize( 128, 128 )
	ButtonHilt.Item = LSCS:GetHilt( HiltR )
	ButtonHilt.Paint = CrafterButtonPaint
	ButtonHilt.DoClick = function( self )
		BaseButtonClick( self )
		if self.Item then
			self.menu = DermaMenu()
			self.menu:AddOption( "Unequip", function()
				ply:lscsClearEquipped( "hilt", true )
				ply:lscsCraftSaber()
			end )
			self.menu:Open()
		else
			self.menu = DermaMenu()
			local Num = 0
			for k, v in pairs( ply:lscsGetInventory() ) do
				if isbool( ply:lscsGetEquipped()[ k ] ) then continue end

				local item = LSCS:ClassToItem( v )
				if item.type == "hilt" then
					Num = Num + 1
					self.menu:AddOption( item.name, function()
						ply:lscsEquipItem( k, true )
					end )
				end
			end
			if Num >= 1 then
				self.menu:Open()
			else
				surface.PlaySound("buttons/button10.wav")
				self.menu:Remove()
			end
		end
	end
	ButtonHilt.Main = Main

	local ButtonBlade = vgui.Create( "DButton", Panel )
	ButtonBlade.InfoText = "Crystal [RH]"
	ButtonBlade:SetText( "" )
	ButtonBlade:SetPos( 35, 35+AAA )
	ButtonBlade:SetSize( 128, 128 )
	ButtonBlade.Item = LSCS:GetBlade( BladeR )
	ButtonBlade.Paint = CrafterButtonPaint
	ButtonBlade.DoClick = function( self )
		BaseButtonClick( self )

		if self.Item then
			self.menu = DermaMenu()
			self.menu:AddOption( "Unequip", function()
				ply:lscsClearEquipped( "crystal", true )
				ply:lscsCraftSaber()
			end )
			self.menu:Open()
		else
			self.menu = DermaMenu()
			local Num = 0
			for k, v in pairs( ply:lscsGetInventory() ) do
				if isbool( ply:lscsGetEquipped()[ k ] ) then continue end

				local item = LSCS:ClassToItem( v )
				if item.type == "crystal" then
					Num = Num + 1
					self.menu:AddOption( item.name, function()
						ply:lscsEquipItem( k, true )
					end )
				end
			end
			if Num >= 1 then
				self.menu:Open()
			else
				surface.PlaySound("buttons/button10.wav")
				self.menu:Remove()
			end
		end
	end
	ButtonBlade.Main = Main

	-- LEFT
	local ButtonHilt = vgui.Create( "DButton", Panel )
	ButtonHilt.InfoText = "Hilt [LH]"
	ButtonHilt:SetText( "" )
	ButtonHilt:SetPos( PanelSizeX * 0.5 - 64, PanelSizeY - 128 - 35 )
	ButtonHilt:SetSize( 128, 128 )
	ButtonHilt.Item = LSCS:GetHilt( HiltL )
	ButtonHilt.Paint = CrafterButtonPaint
	ButtonHilt.DoClick = function( self )
		BaseButtonClick( self )
		if self.Item then
			self.menu = DermaMenu()
			self.menu:AddOption( "Unequip", function()
				ply:lscsClearEquipped( "hilt", false )
				ply:lscsCraftSaber()
			end )
			self.menu:Open()
		else
			self.menu = DermaMenu()
			local Num = 0
			for k, v in pairs( ply:lscsGetInventory() ) do
				if isbool( ply:lscsGetEquipped()[ k ] ) then continue end

				local item = LSCS:ClassToItem( v )

				if not item then continue end

				if item.type == "hilt" then
					Num = Num + 1
					self.menu:AddOption( item.name, function()
						ply:lscsEquipItem( k, false )
					end )
				end
			end
			if Num >= 1 then
				self.menu:Open()
			else
				surface.PlaySound("buttons/button10.wav")
				self.menu:Remove()
			end
		end
	end
	ButtonHilt.Main = Main

	local ButtonBlade = vgui.Create( "DButton", Panel )
	ButtonBlade.InfoText = "Crystal [LH]"
	ButtonBlade:SetText( "" )
	ButtonBlade:SetPos( 35, PanelSizeY - 128 - 35 )
	ButtonBlade:SetSize( 128, 128 )
	ButtonBlade.Item = LSCS:GetBlade( BladeL )
	ButtonBlade.Paint = CrafterButtonPaint
	ButtonBlade.DoClick = function( self )
		BaseButtonClick( self )
		if self.Item then
			self.menu = DermaMenu()
			self.menu:AddOption( "Unequip", function()
				ply:lscsClearEquipped( "crystal", false )
				ply:lscsCraftSaber()
			end )
			self.menu:Open()
		else
			self.menu = DermaMenu()
			local Num = 0
			for k, v in pairs( ply:lscsGetInventory() ) do
				if isbool( ply:lscsGetEquipped()[ k ] ) then continue end

				local item = LSCS:ClassToItem( v )

				if not item then continue end

				if item.type == "crystal" then
					Num = Num + 1
					self.menu:AddOption( item.name, function()
						ply:lscsEquipItem( k, false )
					end )
				end
			end
			if Num >= 1 then
				self.menu:Open()
			else
				surface.PlaySound("buttons/button10.wav")
				self.menu:Remove()
			end
		end
	end
	ButtonBlade.Main = Main

	LSCS:SetActivePanel( Panel )
	LSCS:SideBar( Frame )

	Frame.ID = 3
end

function LSCS:BuildStanceMenu( Frame )
	local ply = LocalPlayer()

	if StanceNum > #ply:lscsGetCombo() then
		StanceNum = 1
	end

	local combo = ply:lscsGetCombo( StanceNum )

	local ColHead = menu_text
	local ColText = menu_white

	local LastID

	local Panel = vgui.Create( "DPanel", Frame )
	Panel:SetPos( PanelPosX, PanelPosY )
	Panel:SetSize( PanelSizeX, PanelSizeY + FrameBarHeight )
	Panel.Paint = function(self, w, h )
		draw.RoundedBoxEx( 8, 0, 0, w, h, menu_light, false, false, false, true )

		surface.SetMaterial( ClickMat )
		surface.SetDrawColor( 150,150,150,150 )
		local X, Y = self:CursorPos()
		surface.DrawTexturedRectRotated( X, Y, 512, 512, 0 )
	end

	local mdl = vgui.Create( "DModelPanel", Panel )
	mdl:SetSize( 250, 0)
	mdl:Dock( RIGHT )
	mdl:DockMargin( 4, 4, 4, 4 )
	mdl:SetFOV( 30 )
	mdl:SetCamPos( vector_origin )
	mdl:SetDirectionalLight( BOX_RIGHT, Color( 255, 160, 80, 255 ) )
	mdl:SetDirectionalLight( BOX_LEFT, Color( 80, 160, 255, 255 ) )
	mdl:SetAmbientLight( Vector( -64, -64, -64 ) )
	mdl:SetAnimated( true )
	mdl.Angles = angle_zero
	mdl:SetLookAt( Vector( -100, 0, -22 ) )
	mdl:SetModel( LocalPlayer():GetModel() )
	function mdl.Entity:GetPlayerColor() return LocalPlayer():GetPlayerColor() end
	mdl.Entity:SetPos( Vector( -100, 0, -61 ) )

	function mdl:DragMousePress()
		self.PressX, self.PressY = gui.MousePos()
		self.Pressed = true
	end

	function mdl:DragMouseRelease() self.Pressed = false end

	function mdl:LayoutEntity( ent )
		if ( self.bAnimated ) then self:RunAnimation() end

		if ( self.Pressed ) then
			local mx = gui.MousePos()
			self.Angles = self.Angles - Angle( 0, ( ( self.PressX or mx ) - mx ) / 2, 0 )

			self.PressX, self.PressY = gui.MousePos()
		end

		ent:SetAngles( self.Angles )
	end

	mdl.Paint = function(self, w, h )
		local Col = menu_dim
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )
	
		if not IsValid( self.Entity ) then return end

		local x, y = self:LocalToScreen( 0, 0 )

		self:LayoutEntity( self.Entity )

		local ang = self.aLookAngle
		if not ang then
			ang = ( self.vLookatPos - self.vCamPos ):Angle()
		end

		cam.Start3D( self.vCamPos, ang, self.fFOV, x, y, w, h, 5, self.FarZ )

		render.SuppressEngineLighting( true )
		render.SetLightingOrigin( self.Entity:GetPos() )
		render.ResetModelLighting( self.colAmbientLight.r / 255, self.colAmbientLight.g / 255, self.colAmbientLight.b / 255 )
		render.SetColorModulation( self.colColor.r / 255, self.colColor.g / 255, self.colColor.b / 255 )
		render.SetBlend( ( self:GetAlpha() / 255 ) * ( self.colColor.a / 255 ) ) -- * surface.GetAlphaMultiplier()

		for i = 0, 6 do
			local col = self.DirectionalLight[ i ]
			if ( col ) then
				render.SetModelLighting( i, col.r / 255, col.g / 255, col.b / 255 )
			end
		end

		self:DrawModel()

		render.SuppressEngineLighting( false )
		cam.End3D()

		self.LastPaint = RealTime()
	end

	local descriptionHeader = vgui.Create( "DPanel", Panel )
	descriptionHeader:Dock( TOP )
	descriptionHeader:DockMargin( 4, 4, 0, 0 )
	descriptionHeader.Paint = function(self, w, h )
		local Col = menu_dim

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h )
		draw.SimpleText( "Information", "LSCS_FONT", w * 0.5, h * 0.5, menu_text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

	end

	local SPB = vgui.Create( "DPanel", Panel )
	SPB:SetSize( 0, 280 )
	SPB:Dock( BOTTOM )
	SPB:DockMargin( 4, 4, 0, 4 )
	SPB.Paint = function(self, w, h )
		local Col = menu_dim
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )
	end

	local DScrollPanel = vgui.Create( "DScrollPanel", SPB )
	DScrollPanel:Dock( FILL )

	local nice_combo = {}

	for index, obj in pairs( combo.Attacks ) do
		local info = LSCS.ComboInfo[ index ]

		local data = {
			text = info.description,
			name = info.name,
			AttackAnim = (obj.AttackAnimMenu or obj.AttackAnim),
			id = info.order,
		}
		table.insert( nice_combo, data )
	end
	table.sort( nice_combo, function( a, b ) return a.id < b.id end )

	for index, data in ipairs( nice_combo ) do
		local DButton = DScrollPanel:Add( "DButton" )
		DButton.InfoText = data.text
		DButton.InfoName = data.name
		DButton:SetSize(100,50)
		DButton:SetText("")
		DButton:Dock( TOP )
		DButton:DockMargin( 5, 5, 5, 2.5 )
		DButton.Paint = function(self, w, h )
			DrawButtonClick( self, w, h ) 
			local Col = menu_white_dim

			if LastID == index then
				Col = menu_text
				draw.SimpleText( "["..self.InfoName.."]", "LSCS_FONT", w * 0.5, 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )

				surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
				DrawFrame( w, h, 0, 2 )
				Col = menu_white
			else
				if self:IsHovered() then
					Col = menu_white
					surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
					DrawFrame( w, h, 0, 2 )
				end

				draw.SimpleText( self.InfoName, "LSCS_FONT", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

				return
			end

			local words = string.Explode( "\n", self.InfoText )
			if #words > 1 then
				draw.SimpleText( words[1], "LSCS_FONT_SMALL", w * 0.5, h - 2 - 12, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
				draw.SimpleText( words[2], "LSCS_FONT_SMALL", w * 0.5, h - 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			else
				draw.SimpleText( words[1], "LSCS_FONT_SMALL", w * 0.5, h - 8, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			end
		end
		DButton.DoClick = function( self )
			BaseButtonClick( self )

			LastID = index

			local model = mdl.Entity
			if IsValid( model ) then
				local seqID = model:LookupSequence( data.AttackAnim )
				model:SetSequence( seqID )
				model:ResetSequence( seqID )
				model:SetCycle( 0 )
			end
		end
	end

	local description = vgui.Create( "DPanel", Panel )
	description:SetSize( 275, 0 )
	description:Dock( LEFT )
	description:DockMargin( 4, 4, 0, 0 )
	description.Paint = function(self, w, h ) 
		local Col = menu_dim
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )
	end
	local richtext = vgui.Create( "RichText", description )
	richtext:Dock( FILL )
	richtext:InsertColorChange( ColHead.r, ColHead.g, ColHead.b, ColHead.a )
	richtext:AppendText("Name:\n")
	richtext:InsertColorChange( ColText.r, ColText.g, ColText.b, ColText.a )
	richtext:AppendText((combo.name or combo.id).."\n\n")
	richtext:InsertColorChange( ColHead.r, ColHead.g, ColHead.b, ColHead.a )
	richtext:AppendText("Description:\n")
	richtext:InsertColorChange( ColText.r, ColText.g, ColText.b, ColText.a )
	richtext:AppendText((combo.description or "").."\n\n")

	if combo.LeftSaberActive then
		richtext:InsertColorChange( 0,255,0,255 )
		richtext:AppendText("This Stance supports Left Hand Sabers\n\n")
	else
		richtext:InsertColorChange( 255,200,0,255 )
		richtext:AppendText("This Stance does not support Left Hand Sabers\n\n")
	end

	richtext:InsertColorChange( ColHead.r, ColHead.g, ColHead.b, ColHead.a )

	richtext:AppendText("Author:\n")
	richtext:InsertColorChange( ColText.r, ColText.g, ColText.b, ColText.a )
	richtext:AppendText((combo.author or "").."\n\n")
	richtext:InsertColorChange( ColHead.r, ColHead.g, ColHead.b, ColHead.a )

	local Button = vgui.Create( "DButton", Panel )
	Button.Item = combo
	Button:SetText( "" )
	Button:SetSize( 130, 0 )
	Button:Dock( LEFT )
	Button:DockMargin( 4, 4, 4, 0 )
	Button.Paint = function( self, w, h )
		local Col = menu_dim
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )

		CrafterButtonPaint( self, w, h )
	end
	Button.DoClick = function( self )
		BaseButtonClick( self )

		local NumCombo = #ply:lscsGetCombo()

		self.menu = DermaMenu()

		self.menu:AddOption( "view next", function()
			StanceNum = StanceNum + 1
			if StanceNum > NumCombo then
				StanceNum = 1
			end
			combo = ply:lscsGetCombo( StanceNum )
			self.menu:Remove()
			LSCS:RefreshMenu()
		end )
		self.menu:AddOption( "view previous", function()
			StanceNum = StanceNum - 1
			if StanceNum <= 0 then
				StanceNum = NumCombo
			end
			combo = ply:lscsGetCombo( StanceNum )
			self.menu:Remove()
			LSCS:RefreshMenu()
		end )

		local subMenu = self.menu:AddSubMenu("equip")

		local Num = 0
		for k, v in pairs( ply:lscsGetInventory() ) do
			if isbool( ply:lscsGetEquipped()[ k ] ) then continue end

			local item = LSCS:ClassToItem( v )

			if not item then continue end

			if item.type == "stance" then
				Num = Num + 1
				subMenu:AddOption( item.name, function()
					ply:lscsEquipItem( k, true )
				end )
			end
		end

		self.menu:Open()
	end
	Button.DoRightClick = function( self )
		BaseButtonClick( self )

		local NumCombo = #ply:lscsGetCombo()

		StanceNum = StanceNum + 1
		if StanceNum > NumCombo then
			StanceNum = 1
		end
		combo = ply:lscsGetCombo( StanceNum )
		LSCS:RefreshMenu()
	end

	LSCS:SetActivePanel( Panel )
	LSCS:SideBar( Frame )

	Frame.ID = 4
end

function LSCS:BuildForceMenu( Frame )
	local ply = LocalPlayer()
	local ForceAbilities = ply:lscsGetForceAbilities()

	if ForceNum > #ForceAbilities then
		ForceNum = 1
	end

	local Force = ForceAbilities[ ForceNum ] and ForceAbilities[ ForceNum ].item or false

	local Panel = vgui.Create( "DPanel", Frame )
	Panel:SetPos( PanelPosX, PanelPosY )
	Panel:SetSize( PanelSizeX, PanelSizeY + FrameBarHeight )
	Panel.Paint = function(self, w, h )
		surface.SetMaterial( ClickMat )
		surface.SetDrawColor( 150,150,150,150 )
		local X, Y = self:CursorPos()
		surface.DrawTexturedRectRotated( X, Y, 512, 512, 0 )
	end

	local L = vgui.Create( "DPanel", Panel )
	L:SetSize( PanelSizeX - 208, 800 )
	L:Dock( LEFT )
	L:DockMargin( 0, 0, 0, 0 )
	L.Paint = function(self, w, h )
	end

	local descriptionHeader = vgui.Create( "DPanel", L )
	descriptionHeader:Dock( TOP )
	descriptionHeader:DockMargin( 4, 4, 0, 0 )
	descriptionHeader.Paint = function(self, w, h )
		local Col = menu_dim

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h )
		draw.SimpleText( "Information", "LSCS_FONT", w * 0.5, h * 0.5, menu_text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local SelectBind = vgui.Create( "DPanel", L )
	SelectBind:SetSize( 0, 280 )
	SelectBind:Dock( BOTTOM )
	SelectBind:DockMargin( 4, 4, 0, 4 )
	SelectBind.Paint = function(self, w, h )
		local Col = menu_dim
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )
	end

	local description = vgui.Create( "DPanel", L )
	description:SetSize( 324, 0 )
	description:Dock( LEFT )
	description:DockMargin( 4, 4, 0, 0 )
	description.Paint = function(self, w, h ) 
		local Col = menu_dim
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )
	end

	local ColHead = menu_text
	local ColText = menu_white

	local richtext = vgui.Create( "RichText", description )
	richtext:Dock( FILL )
	if Force then
		richtext:InsertColorChange( ColHead.r, ColHead.g, ColHead.b, ColHead.a )
		richtext:AppendText("Name:\n")

		richtext:InsertColorChange( ColText.r, ColText.g, ColText.b, ColText.a )
		richtext:AppendText("Force "..(Force.name or Force.id).."\n\n")

		richtext:InsertColorChange( ColHead.r, ColHead.g, ColHead.b, ColHead.a )
		richtext:AppendText("Description:\n")
		richtext:InsertColorChange( ColText.r, ColText.g, ColText.b, ColText.a )
		richtext:AppendText((Force.description or "").."\n\n")
		richtext:InsertColorChange( ColHead.r, ColHead.g, ColHead.b, ColHead.a )
		richtext:AppendText("Author:\n")
		richtext:InsertColorChange( ColText.r, ColText.g, ColText.b, ColText.a )
		richtext:AppendText((Force.author or "").."\n\n")
		richtext:InsertColorChange( ColHead.r, ColHead.g, ColHead.b, ColHead.a )
	else
		richtext:InsertColorChange( ColHead.r, ColHead.g, ColHead.b, ColHead.a )
		richtext:AppendText("You don't have any Force Powers")
	end

	local Button = vgui.Create( "DButton", L )
	Button.Item = Force
	Button.InfoText = "N/A"
	Button:SetText( "" )
	Button:SetSize( 130, 0 )
	Button:Dock( LEFT )
	Button:DockMargin( 4, 4, 4, 0 )
	Button.Paint = function( self, w, h )
		local Col = menu_dim
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )

		CrafterButtonPaint( self, w, h )
	end
	Button.DoClick = function( self )
		BaseButtonClick( self )

		local NumForce = #ForceAbilities

		self.menu = DermaMenu()

		self.menu:AddOption( "view next", function()
			ForceNum = ForceNum + 1
			if ForceNum > NumForce then
				ForceNum = 1
			end
			self.menu:Remove()
			LSCS:RefreshMenu()
		end )
		self.menu:AddOption( "view previous", function()
			ForceNum = ForceNum - 1
			if ForceNum <= 0 then
				ForceNum = NumForce
			end
			self.menu:Remove()
			LSCS:RefreshMenu()
		end )

		local subMenu = self.menu:AddSubMenu("equip")

		local Num = 0
		for k, v in pairs( ply:lscsGetInventory() ) do
			if isbool( ply:lscsGetEquipped()[ k ] ) then continue end

			local item = LSCS:ClassToItem( v )

			if not item then continue end

			if item.type == "force" then
				Num = Num + 1
				subMenu:AddOption( item.name, function()
					ply:lscsEquipItem( k, true )
				end )
			end
		end

		self.menu:Open()
	end
	Button.DoRightClick = function( self )
		BaseButtonClick( self )

		local NumForce = #ForceAbilities

		ForceNum = ForceNum + 1
		if ForceNum > NumForce then
			ForceNum = 1
		end
		LSCS:RefreshMenu()
	end


	local descriptionHeader = vgui.Create( "DPanel", SelectBind )
	descriptionHeader:Dock( TOP )
	descriptionHeader:DockMargin( 4, 4, 0, 0 )
	descriptionHeader.Paint = function(self, w, h )
		local Col = menu_dim

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h )
		draw.SimpleText( "Force Selector Keybinding", "LSCS_FONT", w * 0.5, h * 0.5, menu_text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local ActivatorBG = vgui.Create( "DPanel", SelectBind )
	ActivatorBG:SetSize( 250, 30 )
	ActivatorBG:Dock( TOP )
	ActivatorBG:DockMargin( 4, 4, 4, 0 )
	ActivatorBG.Paint = function(self, w, h )
		local Col = menu_light

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )

		draw.SimpleText( "Mouse Override (LMB to use Force, Scroll Wheel to select)", "LSCS_FONT_SMALL", (w - 100) * 0.5, h * 0.5 - 1, menu_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local ActivatorBinder = vgui.Create( "DBinder", ActivatorBG )
	ActivatorBinder:SetSize( 100, 30 )
	ActivatorBinder:Dock( RIGHT )
	ActivatorBinder:DockMargin( 2, 2, 2, 2 )
	ActivatorBinder:SetValue( LSCS.ForceSelector.KeyActivate:GetInt() )
	ActivatorBinder.OnChange = function( self, num )
		LSCS.ForceSelector.KeyActivate:SetInt( num )
	end

	local Next = vgui.Create( "DPanel", SelectBind )
	Next:SetSize( 250, 30 )
	Next:Dock( TOP )
	Next:DockMargin( 4, 4, 4, 0 )
	Next.Paint = function(self, w, h )
		local Col = menu_light

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )

		draw.SimpleText( "Next", "LSCS_FONT_SMALL", (w - 100) * 0.5, h * 0.5 - 1, menu_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local Binder = vgui.Create( "DBinder", Next )
	Binder:SetSize( 100, 30 )
	Binder:Dock( RIGHT )
	Binder:DockMargin( 2, 2, 2, 2 )
	Binder:SetValue( LSCS.ForceSelector.KeyNext:GetInt() )
	Binder.OnChange = function( self, num )
		LSCS.ForceSelector.KeyNext:SetInt( num )
	end

	local Prev = vgui.Create( "DPanel", SelectBind )
	Prev:SetSize( 250, 30 )
	Prev:Dock( TOP )
	Prev:DockMargin( 4, 4, 4, 0 )
	Prev.Paint = function(self, w, h )
		local Col = menu_light

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )

		draw.SimpleText( "Previous", "LSCS_FONT_SMALL", (w - 100) * 0.5, h * 0.5 - 1, menu_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local Binder = vgui.Create( "DBinder", Prev )
	Binder:SetSize( 100, 30 )
	Binder:Dock( RIGHT )
	Binder:DockMargin( 2, 2, 2, 2 )
	Binder:SetValue( LSCS.ForceSelector.KeyPrev:GetInt() )
	Binder.OnChange = function( self, num )
		LSCS.ForceSelector.KeyPrev:SetInt( num )
	end


	local Use = vgui.Create( "DPanel", SelectBind )
	Use:SetSize( 250, 30 )
	Use:Dock( TOP )
	Use:DockMargin( 4, 4, 4, 0 )
	Use.Paint = function(self, w, h )
		local Col = menu_light

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )

		draw.SimpleText( "Use", "LSCS_FONT_SMALL", (w - 100) * 0.5, h * 0.5 - 1, menu_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local Binder = vgui.Create( "DBinder", Use )
	Binder:SetSize( 100, 30 )
	Binder:Dock( RIGHT )
	Binder:DockMargin( 2, 2, 2, 2 )
	Binder:SetValue( LSCS.ForceSelector.KeyUse:GetInt() )
	Binder.OnChange = function( self, num )
		LSCS.ForceSelector.KeyUse:SetInt( num )
	end


	local SPH = vgui.Create( "DPanel", Panel )
	SPH:SetSize( 0, 50 )
	SPH:Dock( TOP )
	SPH:DockMargin( 4, 4, 4, 0 )
	SPH.Paint = function(self, w, h )
		local Col = menu_dim
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )

		draw.SimpleText( "Force Power", "LSCS_FONT", w * 0.5, h * 0.5, menu_text, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
		draw.SimpleText( "Direct Key Binding", "LSCS_FONT", w * 0.5, h * 0.5, menu_text, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
	end

	local SPB = vgui.Create( "DPanel", Panel )
	SPB:SetSize( 200, 0 )
	SPB:Dock( RIGHT )
	SPB:DockMargin( 0, 4, 4, 4 )
	SPB.Paint = function(self, w, h )
		local Col = menu_dim
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )
	end

	local DScrollPanel = vgui.Create( "DScrollPanel", SPB )
	DScrollPanel:Dock( FILL )

	for ID, item in pairs( LSCS.Force ) do
		local P = DScrollPanel:Add( "DPanel" )
		P:SetSize( 250, 30 )
		P:Dock( TOP )
		P:DockMargin( 4, 4, 4, 0 )
		P.Paint = function(self, w, h )
			local Col = menu_light

			if Force and Force.id == ID then
				Col = menu_text
			end

			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			surface.DrawRect( 0, 0, w, h  )

			draw.SimpleText( item.name, "LSCS_FONT_SMALL", (w - 100) * 0.5, h * 0.5 - 1, menu_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		local B = vgui.Create( "DBinder", P )
		
		B:SetSize( 100, 30 )
		B:Dock( RIGHT )
		B:DockMargin( 2, 2, 2, 2 )
		B:SetValue( item.cmd:GetInt() )
		B.OnChange = function( self, num )
			item.cmd:SetInt( num )
			LSCS:RefreshKeys()
		end
	end

	LSCS:SetActivePanel( Panel )
	LSCS:SideBar( Frame )

	Frame.ID = 5
end

function LSCS:BuildSettings( Frame )
	local Panel = vgui.Create( "DPanel", Frame )
	Panel:SetPos( PanelPosX, PanelPosY )
	Panel:SetSize( PanelSizeX, PanelSizeY + FrameBarHeight )
	Panel.Paint = function(self, w, h )
		surface.SetMaterial( ClickMat )
		surface.SetDrawColor( 150,150,150,150 )
		local X, Y = self:CursorPos()
		surface.DrawTexturedRectRotated( X, Y, 512, 512, 0 )
	end

	local PerfSettings = vgui.Create( "DPanel", Panel )
	PerfSettings:SetSize( 0, 166 )
	PerfSettings:DockMargin( 4, 4, 4, 4 )
	PerfSettings:Dock( TOP )
	PerfSettings.Paint = function(self, w, h )
		surface.SetDrawColor( menu_dim )
		surface.DrawRect( 0, 0, w, h )
	end

	local Header = vgui.Create( "DPanel", PerfSettings )
	Header:SetSize( 0, 40 )
	Header:DockMargin( 4, 4, 4, 4 )
	Header:Dock( TOP )
	Header.Paint = function(self, w, h )
		draw.SimpleText( "Client Settings", "LSCS_FONT", 4, h * 0.5, menu_text, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end

	local Line = vgui.Create( "DPanel", PerfSettings )
	Line:SetSize( PanelSizeX, 1)
	Line:Dock( TOP )
	Line:DockMargin( 0, 4, 4, 4 )
	Line.Paint = function(self, w, h )
		surface.SetDrawColor( menu_text )
		surface.SetMaterial( gradient_mat )
		surface.DrawTexturedRect( 0, 0, w, h )
	end

	local pLeft = vgui.Create( "DPanel", PerfSettings )
	pLeft:SetSize( PanelSizeX * 0.5, 0 )
	pLeft:DockMargin( 0, 0, 0, 0 )
	pLeft:Dock( LEFT )
	pLeft.Paint = function(self, w, h ) end

	local pRight = vgui.Create( "DPanel", PerfSettings )
	pRight:SetSize( PanelSizeX * 0.5, 0 )
	pRight:DockMargin( 0, 0, 0, 0 )
	pRight:Dock( LEFT )
	pRight.Paint = function(self, w, h ) end

	local T = vgui.Create( "DPanel", pLeft )
	T:Dock( TOP )
	T:DockMargin( 4, 4, 0, 0 )
	T.Paint = function(self, w, h )
		draw.SimpleText( "Performance", "LSCS_FONT_SMALL", 0, h * 0.5, menu_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end

	local DCheckbox = vgui.Create( "DCheckBoxLabel", pLeft )
	DCheckbox:Dock( TOP )
	DCheckbox:DockMargin( 4, 4, 0, 0 )
	DCheckbox:SetText("Dynamic Light")	
	DCheckbox:SetConVar("lscs_dynamiclight")
	DCheckbox:SizeToContents()

	local DCheckbox = vgui.Create( "DCheckBoxLabel", pLeft )
	DCheckbox:Dock( TOP )
	DCheckbox:DockMargin( 4, 4, 0, 0 )
	DCheckbox:SetText("High Quality Impact Effects")	
	DCheckbox:SetConVar("lscs_impacteffects")
	DCheckbox:SizeToContents()

	local DSlider = vgui.Create( "DNumSlider", pLeft )
	DSlider:Dock( TOP )
	DSlider:DockMargin( 4, 4, 0, 0 )
	DSlider:SetText( "Trail Effect Detail" )
	DSlider:SetMin( 0 )
	DSlider:SetMax( 100 )
	DSlider:SetDecimals( 0 )
	DSlider:SetConVar( "lscs_traildetail" )	

	local T = vgui.Create( "DPanel", pRight )
	T:Dock( TOP )
	T:DockMargin( 4, 4, 0, 0 )
	T.Paint = function(self, w, h )
		draw.SimpleText( "Hud", "LSCS_FONT_SMALL", 0, h * 0.5, menu_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end

	local DCheckbox = vgui.Create( "DCheckBoxLabel", pRight )
	DCheckbox:Dock( TOP )
	DCheckbox:DockMargin( 4, 4, 0, 0 )
	DCheckbox:SetText("Show HUD")	
	DCheckbox:SetConVar("lscs_drawhud")
	DCheckbox:SizeToContents()


	local SVSettings = vgui.Create( "DPanel", Panel )
	SVSettings:SetSize( 0, 302 )
	SVSettings:DockMargin( 4, 0, 4, 4 )
	SVSettings:Dock( TOP )
	SVSettings.Paint = function(self, w, h )
		surface.SetDrawColor( menu_dim )
		surface.DrawRect( 0, 0, w, h )
	end

	local Header = vgui.Create( "DPanel", SVSettings )
	Header:SetSize( 0, 40 )
	Header:DockMargin( 4, 4, 4, 4 )
	Header:Dock( TOP )
	Header.Paint = function(self, w, h )
		draw.SimpleText( "Server Settings", "LSCS_FONT", 4, h * 0.5, menu_text, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.SetMaterial( adminMat )
		surface.DrawTexturedRect( w - 20,  4, 16, 16 )
	end

	local Line = vgui.Create( "DPanel", SVSettings )
	Line:SetSize( PanelSizeX, 1)
	Line:Dock( TOP )
	Line:DockMargin( 0, 4, 4, 4 )
	Line.Paint = function(self, w, h )
		surface.SetDrawColor( menu_text )
		surface.SetMaterial( gradient_mat )
		surface.DrawTexturedRect( 0, 0, w, h )
	end
	local T = vgui.Create( "DPanel", SVSettings )
	T:Dock( TOP )
	T:DockMargin( 4, 4, 0, 0 )
	T.Paint = function(self, w, h )
		draw.SimpleText( "Saber Attacking", "LSCS_FONT_SMALL", 0, h * 0.5, menu_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	local slider = vgui.Create( "DNumSlider", SVSettings )
	slider:Dock( TOP )
	slider:DockMargin( 4, 4, 0, 0 )
	slider:SetText( "Damage" )
	slider:SetMin( 0 )
	slider:SetMax( 2000 )
	slider:SetDecimals( 0 )
	slider:SetConVar( "lscs_sv_saberdamage" )
	function slider:OnValueChanged( val )
		net.Start("lscs_admin_setconvar")
			net.WriteString("lscs_sv_saberdamage")
			net.WriteString( tostring( val ) )
		net.SendToServer()
	end

	local Line = vgui.Create( "DPanel", SVSettings )
	Line:SetSize( PanelSizeX, 1)
	Line:Dock( TOP )
	Line:DockMargin( 0, 4, 4, 4 )
	Line.Paint = function(self, w, h )
		surface.SetDrawColor( menu_text )
		surface.SetMaterial( gradient_mat )
		surface.DrawTexturedRect( 0, 0, w, h )
	end
	local T = vgui.Create( "DPanel", SVSettings )
	T:Dock( TOP )
	T:DockMargin( 4, 4, 0, 0 )
	T.Paint = function(self, w, h )
		draw.SimpleText( "Saber Bullet Deflecting", "LSCS_FONT_SMALL", 0, h * 0.5, menu_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end

	local slider = vgui.Create( "DNumSlider", SVSettings )
	slider:Dock( TOP )
	slider:DockMargin( 4, 4, 0, 0 )
	slider:SetText( "Deflect Force Drain Multiplier" )
	slider:SetMin( 0 )
	slider:SetMax( 1 )
	slider:SetDecimals( 2 )
	slider:SetConVar( "lscs_sv_forcedrain_per_bullet_mul" )
	function slider:OnValueChanged( val )
		net.Start("lscs_admin_setconvar")
			net.WriteString("lscs_sv_forcedrain_per_bullet_mul")
			net.WriteString( tostring( val ) )
		net.SendToServer()
	end

	local slider = vgui.Create( "DNumSlider", SVSettings )
	slider:Dock( TOP )
	slider:DockMargin( 4, 4, 0, 0 )
	slider:SetText( "Minimum ForceDrain per Deflect" )
	slider:SetMin( 0 )
	slider:SetMax( 10 )
	slider:SetDecimals( 0 )
	slider:SetConVar( "lscs_sv_forcedrain_per_bullet_min" )
	function slider:OnValueChanged( val )
		net.Start("lscs_admin_setconvar")
			net.WriteString("lscs_sv_forcedrain_per_bullet_min")
			net.WriteString( tostring( val ) )
		net.SendToServer()
	end

	local slider = vgui.Create( "DNumSlider", SVSettings )
	slider:Dock( TOP )
	slider:DockMargin( 4, 4, 0, 0 )
	slider:SetText( "Maximum ForceDrain per Deflect" )
	slider:SetMin( 0 )
	slider:SetMax( 100 )
	slider:SetDecimals( 0 )
	slider:SetConVar( "lscs_sv_forcedrain_per_bullet_max" )
	function slider:OnValueChanged( val )
		net.Start("lscs_admin_setconvar")
			net.WriteString("lscs_sv_forcedrain_per_bullet_max")
			net.WriteString( tostring( val ) )
		net.SendToServer()
	end

	local DCheckbox = vgui.Create( "DCheckBoxLabel", SVSettings )
	DCheckbox:Dock( TOP )
	DCheckbox:DockMargin( 4, 4, 0, 0 )
	DCheckbox:SetText("Player Bullets Interrupt Saber Attack")	
	DCheckbox:SetConVar("lscs_sv_bullet_can_interrupt_attack")
	DCheckbox:SizeToContents()
	function DCheckbox:OnChange( val )
		net.Start("lscs_admin_setconvar")
			net.WriteString("lscs_sv_bullet_can_interrupt_attack")
			net.WriteString( val and "1" or "0" )
		net.SendToServer()
	end

	LSCS:SetActivePanel( Panel )
	LSCS:SideBar( Frame )

	Frame.ID = 6
end

function LSCS:RefreshMenu()
	if not IsValid( Frame ) then return end

	if Frame.ID == 2 then
		LSCS:BuildInventory( Frame )
	end
	if Frame.ID == 3 then
		LSCS:BuildSaberMenu( Frame )
	end
	if Frame.ID == 4 then
		LSCS:BuildStanceMenu( Frame )
	end
	if Frame.ID == 5 then
		LSCS:BuildForceMenu( Frame )
	end
	if Frame.ID == 6 then
		LSCS:BuildSettings( Frame )
	end
end

function LSCS:OpenMenu()
	if not IsValid( Frame ) then
		Frame = vgui.Create( "DFrame" )
		Frame:SetSize( FrameSizeX, FrameSizeY )
		Frame:SetTitle( "" )
		Frame:SetDraggable( true )
		Frame:SetScreenLock( true )
		Frame:MakePopup()
		Frame:Center()
		Frame.Paint = function(self, w, h )
			draw.RoundedBox( 8, 0, 0, w, h, menu_light )
			draw.RoundedBoxEx( 8, 0, 0, w, FrameBarHeight, menu_dark, true, true, false, false)
			draw.SimpleText( "[LSCS] - Control Panel ", "LSCS_FONT", 5, 11, menu_white_dim , TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		end
		Frame.GetSideBar = function(self)
			return self.SideBar 
		end
		Frame.SideBarIsActivated = function( self )
			return self._smSB == SelectorWidthActive
		end
		Frame.SideBarIsActive = function( self )
			return self._isActive == true
		end
		Frame.SideBarSetActive = function( self, active )
			self._isActive = active
		end
		Frame.oldThink = Frame.Think
		Frame.Think = function( self )
			self:oldThink()

			local Rate = RealFrameTime() * 1000
			local Active = self:SideBarIsActive()
			local TargetWidth = Active and SelectorWidthActive or SelectorWidth

			local X, Y = self:CursorPos()

			if Active then
				if X < 0 or X > SelectorWidthActive or Y < 0 or Y > FrameSizeY then
					self:SideBarSetActive( false )
				end
			else
				if X > 0 and X < SelectorWidth and Y > 0 and Y < FrameSizeY then
					self:SideBarSetActive( true )
				end
			end

			self._smSB = self._smSB and (self._smSB + math.Clamp(TargetWidth - self._smSB,-Rate,Rate)) or SelectorWidth

			if self._smSB ~= self.old_smSB then
				self.old_smSB = self._smSB

				local SB = self:GetSideBar()
				if IsValid( SB ) then
					SB:SetSize( self._smSB, SelectorHeight )
				end
			end
		end

		LSCS:BuildMainMenu( Frame )
	end
end

list.Set( "DesktopWindows", "LSCSMenu", {
	title = "[LSCS] Menu",
	icon = "lscs/ui/icon64.png",
	init = function( icon, window )
		LSCS:OpenMenu()
	end
} )

concommand.Add( "lscs_openmenu", function( ply, cmd, args ) LSCS:OpenMenu() end )

--addons/lvs_base/lua/lvs_framework/autorun/cl_fonts.lua:
local THE_FONT = {
	font = "Verdana",
	extended = false,
	size = 14,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = true,
	additive = false,
	outline = false,
}
surface.CreateFont( "LVS_VERSION", THE_FONT )

THE_FONT.extended = false
THE_FONT.size = 20
THE_FONT.weight = 2000
surface.CreateFont( "LVS_FONT", THE_FONT )

THE_FONT.size = 16
surface.CreateFont( "LVS_FONT_SWITCHER", THE_FONT )

THE_FONT.font = "Arial"
THE_FONT.size = 14
THE_FONT.weight = 1
THE_FONT.shadow = false
surface.CreateFont( "LVS_FONT_PANEL", THE_FONT )

THE_FONT.size = 20
THE_FONT.weight = 2000
surface.CreateFont( "LVS_FONT_HUD", THE_FONT )

THE_FONT.size = 40
THE_FONT.weight = 2000
THE_FONT.shadow = true
surface.CreateFont( "LVS_FONT_HUD_LARGE", THE_FONT )
--lua/autorun/mandalorian_player.lua:
list.Set( "PlayerOptionsModel", "Mandalorain Bounty Hunter", "models/Porky-da-Corgi/StarWars/Mandalorians/bountyhunter.mdl" )
player_manager.AddValidModel( "Mandalorain Bounty Hunter", "models/Porky-da-Corgi/StarWars/Mandalorians/bountyhunter.mdl" )
--addons/billy_gas/lua/openpermissions/cl.lua:
local L = OpenPermissions.L
local Lf = OpenPermissions.Lf

local function DMenuOption_ColorIcon(option, color)
	option:SetIcon("icon16/box.png")
	function option.m_Image:Paint(w,h)
		surface.SetDrawColor(color)
		surface.DrawRect(0,0,w,h)
	end
end
local function GreenToRed_DMenu(i, max, option)
	DMenuOption_ColorIcon(option, Color(i / max * 255, 1 - (i / max) * 255, 0))
end

surface.CreateFont("OpenPermissions_14px", {
	font = "Roboto",
	size = 14,
})
surface.CreateFont("OpenPermissions_Tip", {
	font = "Roboto",
	size = 22,
})

function OpenPermissions:AddTooltip(pnl, options)
	pnl.OpenPermissions_Tooltip_OnCursorEntered = pnl.OnCursorEntered
	pnl.OpenPermissions_Tooltip_OnCursorExited = pnl.OnCursorExited

	function pnl:OnCursorEntered(...)
		pnl.OpenPermissions_Tooltip = vgui.Create("OpenPermissions.Tooltip")
		pnl.OpenPermissions_Tooltip:SetText(options.Text)
		pnl.OpenPermissions_Tooltip.VGUI_Element = pnl

		if (self.OpenPermissions_Tooltip_OnCursorEntered) then
			return self.OpenPermissions_Tooltip_OnCursorEntered(self, ...)
		end
	end

	function pnl:OnCursorExited(...)
		if (IsValid(self.OpenPermissions_Tooltip)) then
			self.OpenPermissions_Tooltip:Remove()
		end
		self.OpenPermissions_Tooltip = nil
		if (self.OpenPermissions_Tooltip_OnCursorExited) then
			return self.OpenPermissions_Tooltip_OnCursorExited(self, ...)
		end
	end
end
function OpenPermissions:RemoveTooltip(pnl)
	if (IsValid(pnl.OpenPermissions_Tooltip)) then
		pnl.OpenPermissions_Tooltip:Remove()
	end
	pnl.OpenPermissions_Tooltip = nil
	pnl.OnCursorEntered = pnl.OpenPermissions_Tooltip_OnCursorEntered
	pnl.OnCursorExited = pnl.OpenPermissions_Tooltip_OnCursorExited
end

local blur = Material("pp/blurscreen")
function OpenPermissions:OpenMenu(specific_addon)
	if (IsValid(OpenPermissions_Menu)) then
		OpenPermissions_Menu:Close()
	end

	OpenPermissions_Menu = vgui.Create("DFrame")

	local AccessGroups
	local PermissionsSave

	local Menu = OpenPermissions_Menu
	Menu:SetSize(850,500)
	Menu:SetTitle("OpenPermissions")
	Menu:SetIcon("icon16/shield.png")
	Menu:Center()
	Menu:MakePopup()

	local Tabs = vgui.Create("DPropertySheet", Menu)
	Tabs:Dock(FILL)

	local PermissionsTab = vgui.Create("DPanel", Tabs)
	PermissionsTab.Paint = nil

		local AccessGroupsDivider = vgui.Create("OpenPermissions.HorizontalDivider", PermissionsTab)
		AccessGroupsDivider:Dock(FILL)
		AccessGroupsDivider:SetDividerWidth(5)
		AccessGroupsDivider:SetLeftWidth(200)
		AccessGroupsDivider:SetRightMin(465)
		AccessGroupsDivider:SetLeftMin(150)

		local AddonsContainer = vgui.Create("OpenPermissions.ColumnLayout", AccessGroupsDivider)
		AccessGroupsDivider:SetRight(AddonsContainer)
		AddonsContainer:SetColumns(OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW, OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW, OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW)
		AddonsContainer:SetPaddings(5,5)

		local AddonContentContainer = vgui.Create("DPanel", PermissionsTab)
		AddonContentContainer.Paint = nil
		AddonContentContainer:SetVisible(false)
		AddonContentContainer:Dock(FILL)
		AddonContentContainer:DockMargin(5,0,0,0)

			local AddonContent = vgui.Create("DPropertySheet", AddonContentContainer)
			AddonContent:Dock(FILL)
			function AddonContent:PaintOver(w,h)
				if (not self.ShowOverlay) then return end
				local x,y = self:LocalToScreen(0,0)
				local scrW,scrH = ScrW(), ScrH()
				surface.SetDrawColor(255,255,255)
				surface.SetMaterial(blur)
				for i=1,2 do
					blur:SetFloat("$blur", (i / 2) * 2)
					blur:Recompute()
					render.UpdateScreenEffectTexture()
					surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
				end

				surface.SetDrawColor(0,0,0,240)
				surface.DrawRect(0,0,w,h)

				draw.SimpleTextOutlined(L"select_an_access_group", "OpenPermissions_Tip", w / 2, h / 2, OpenPermissions.COLOR_WHITE, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 2, OpenPermissions.COLOR_BLACK)
			end

			local PermissionsContent = vgui.Create("OpenPermissions.HorizontalDivider", AddonContent)
			PermissionsContent:SetDividerWidth(5)
			PermissionsContent:SetRightMin(150)
			PermissionsContent:SetLeftMin(150)
			PermissionsContent.Paint = nil

				local PermissionsTree = vgui.Create("OpenPermissions.Tree", PermissionsContent)

				local PropertiesContent = vgui.Create("OpenPermissions.ScrollPanel", PermissionsContent)
				PropertiesContent:DockMargin(5,0,0,0)
				PropertiesContent:SetWide(150)
				PropertiesContent:SetDrawBackground(true)
				function PropertiesContent:AddProperty(options, indent_level, no_checkbox)
					local permission_row = vgui.Create("DPanel", PropertiesContent)
					permission_row.Paint = nil
					permission_row:Dock(TOP)
					permission_row:SetTall(16)
					permission_row:DockMargin(5 + ((indent_level or 0) * (16 + 5)),5,5,0)

					OpenPermissions:AddTooltip(permission_row, {Text = options.Tip or options.Label})

					local checkbox
					if (not no_checkbox) then
						permission_row:SetMouseInputEnabled(true)
						permission_row:SetCursor("hand")

						checkbox = vgui.Create("OpenPermissions.Checkbox", permission_row)
						checkbox:SetCrossable(true)
						checkbox:Dock(LEFT)
						checkbox:DockMargin(0,0,5,0)

						function permission_row:OnMouseReleased(m)
							if (m == MOUSE_LEFT) then
								checkbox:DoClick()
							elseif (m == MOUSE_RIGHT) then
								checkbox:DoRightClick()
							end
						end
					end

					if (options.Icon) then
						local icon = vgui.Create("DImage", permission_row)
						icon:Dock(LEFT)
						icon:SetSize(16,16)
						icon:DockMargin(0,0,5,0)
						icon:SetImage(options.Icon)
						icon:SetMouseInputEnabled(false)
					elseif (options.Color) then
						local col_icon = vgui.Create("DPanel", permission_row)
						col_icon:Dock(LEFT)
						col_icon:SetSize(16,16)
						col_icon:DockMargin(0,0,5,0)
						col_icon:SetMouseInputEnabled(false)
						function col_icon:Paint(w,h)
							surface.SetDrawColor(options.Color)
							surface.DrawRect(0,0,w,h)
						end
					end

					local label = vgui.Create("DLabel", permission_row)
					label:Dock(FILL)
					label:SetTextColor(OpenPermissions.COLOR_BLACK)
					label:SetText(options.Label)
					label:SetContentAlignment(4)
					label:SetMouseInputEnabled(false)

					return checkbox
				end

				PermissionsContent:SetLeft(PermissionsTree)
				PermissionsContent:SetRight(PropertiesContent)
				PermissionsContent:BalanceWidths()

			AddonContent:AddSheet(L"permissions", PermissionsContent, "icon16/group.png")

			local OperationsContainer = vgui.Create("OpenPermissions.ScrollPanel", AddonContent)
			AddonContent:AddSheet(L"operations", OperationsContainer, "icon16/wrench_orange.png")

			function AddonContent:SetShowOverlay(show)
				self.ShowOverlay = show
				self:SetMouseInputEnabled(not show)
				for _,v in ipairs(self:GetItems()) do
					v.Panel:SetMouseInputEnabled(not show)
				end
			end
			AddonContent:SetShowOverlay(true)

				local DeleteAccessGroup = vgui.Create("DButton", OperationsContainer)
				DeleteAccessGroup:SetSize(250,30)
				DeleteAccessGroup:SetText(L"delete_access_group")
				DeleteAccessGroup:SetIcon("icon16/delete.png")

				local CopyPasteContainer = vgui.Create("DPanel", OperationsContainer)
				CopyPasteContainer.Paint = nil
				CopyPasteContainer:SetSize(250,30)
				CopyPasteContainer:AlignTop(DeleteAccessGroup:GetTall() + 5)

					local CopyPermissions = vgui.Create("DButton", CopyPasteContainer)
					CopyPermissions:SetText(L"copy")
					CopyPermissions:SetIcon("icon16/page_copy.png")
					CopyPermissions:DockMargin(0,0,5,0)

					local PastePermissions = vgui.Create("DButton", CopyPasteContainer)
					PastePermissions:SetText(L"paste")
					PastePermissions:SetIcon("icon16/page_paste.png")
					PastePermissions:DockMargin(0,0,5,0)
					PastePermissions:SetDisabled(true)

					function CopyPermissions:DoClick()
						PastePermissions:SetDisabled(false)
						PastePermissions.PermissionsData = {}
						local copied_clashes = false
						for _,line in ipairs(AccessGroups:GetSelected()) do
							local identifier = line.Data.Enum .. " " .. line.Data.Value
							if (not OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] or not OpenPermissions.PermissionsRegistryEditing[line.Data.Value]) then continue end
							for access_group, perms in pairs(OpenPermissions.PermissionsRegistryEditing[line.Data.Enum]) do
								for permission_id, checked in pairs(perms) do
									if (PastePermissions.PermissionsData[permission_id] == nil) then
										local has_clashed = false
										for _,line_2 in ipairs(AccessGroups:GetSelected()) do
											local identifier_2 = line_2.Data.Enum .. " " .. line_2.Data.Value
											if (not OpenPermissions.PermissionsRegistryEditing[line_2.Data.Enum] or not OpenPermissions.PermissionsRegistryEditing[line_2.Data.Value]) then continue end
											if (identifier_2 == identifier) then continue end
											if (OpenPermissions.PermissionsRegistryEditing[line_2.Data.Enum][line_2.Data.Value][permission_id] ~= checked) then
												copied_clashes, has_clashed = true, true
												break
											end
										end
										if (not has_clashed) then
											PastePermissions.PermissionsData[permission_id] = checked
										else
											PastePermissions.PermissionsData[permission_id] = nil
										end
									elseif (PastePermissions.PermissionsData[permission_id] ~= checked) then
										copied_clashes = true
										PastePermissions.PermissionsData[permission_id] = nil
									end
								end
							end
						end
						if (copied_clashes) then
							Derma_Message(L"permission_clash_msg", "OpenPermissions", L"ok")
						end
					end
					function PastePermissions:DoClick()
						for _,line in ipairs(AccessGroups:GetSelected()) do
							OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] = OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] or {}
							OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] = OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] or {}
							table.Merge(OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value], PastePermissions.PermissionsData)
						end
					end

					function CopyPasteContainer:PerformLayout(w,h)
						CopyPermissions:SetSize((w - 2.5) / 2,h)
						CopyPermissions:AlignLeft(0)
						PastePermissions:SetSize((w - 2.5) / 2,h)
						PastePermissions:AlignRight(0)
					end

			local AddonNav = vgui.Create("DPanel", AddonContentContainer)
			AddonNav.Paint = nil
			AddonNav:Dock(BOTTOM)
			AddonNav:DockMargin(0,5,0,0)
			AddonNav:SetTall(30)

				PermissionsSave = vgui.Create("DButton", AddonNav)
				PermissionsSave:Dock(LEFT)
				PermissionsSave:SetWide(100)
				PermissionsSave:DockMargin(0,0,5,0)
				PermissionsSave:SetText(L"save")
				PermissionsSave:SetIcon("icon16/disk.png")
				PermissionsSave:SetDisabled(true)

				function PermissionsSave:RememberPermission(permission_id, checked)
					local is_disabled = true
					for _,line in ipairs(AccessGroups:GetSelected()) do
						if (checked == OpenPermissions.CHECKBOX.INHERIT or checked == false) then
							if (OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] ~= nil) then
								OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value][permission_id] = nil
								if (OpenPermissions:table_IsEmpty(OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value])) then
									OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] = nil
									if (OpenPermissions:table_IsEmpty(OpenPermissions.PermissionsRegistryEditing[line.Data.Enum])) then
										OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] = nil
									end
								end
							end
						else
							OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] = OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] or {}
							OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] = OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] or {}
							OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value][permission_id] = checked
						end
						if (is_disabled) then
							if ((OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] ~= nil) ~= (OpenPermissions.PermissionsRegistry[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistry[line.Data.Enum][line.Data.Value] ~= nil)) then
								is_disabled = false
							else
								if (OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] ~= nil and OpenPermissions.PermissionsRegistry[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistry[line.Data.Enum][line.Data.Value] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value][permission_id] ~= OpenPermissions.PermissionsRegistry[line.Data.Enum][line.Data.Value][permission_id]) then
									is_disabled = false
								elseif (not OpenPermissions:table_IsIdentical(OpenPermissions.PermissionsRegistryEditing, OpenPermissions.PermissionsRegistry)) then
									is_disabled = false
								end
							end
						end
					end
					self:SetDisabled(is_disabled)
				end
				function PermissionsSave:CheckedFromMemory(permission_id, checkbox)
					local checked
					for _,line in ipairs(AccessGroups:GetSelected()) do
						local should_be_checked = OpenPermissions.CHECKBOX.INHERIT
						if (OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value][permission_id] ~= nil) then
							should_be_checked = OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value][permission_id]
						elseif (OpenPermissions.DefaultPermissions[permission_id] ~= nil) then
							should_be_checked = OpenPermissions.DefaultPermissions[permission_id]
						end
						if (checked == nil) then
							checked = should_be_checked
						else
							if (should_be_checked ~= checked) then
								checkbox:SetAmbigious(true)
								return
							end
						end
					end
					checkbox:SetChecked(checked)
					checkbox:SetAmbigious(false)
				end
				function PermissionsSave:DoClick()
					OpenPermissions.PermissionsRegistry = table.Copy(OpenPermissions.PermissionsRegistryEditing)
					self:SetDisabled(true)
					surface.PlaySound("garrysmod/content_downloaded.wav")
					
					OpenPermissions:SerializeRegistry(OpenPermissions.REGISTRY.FLAT_FILE)
					net.Start("OpenPermissions.SavePermissions")
						OpenPermissions:StartNetworkTable(OpenPermissions.PermissionsRegistry)
					net.SendToServer()
					file.Delete("openpermissions_v2.dat")
				end

				local AddonBack = vgui.Create("DButton", AddonNav)
				AddonBack:Dock(LEFT)
				AddonBack:SetWide(100)
				AddonBack:DockMargin(0,0,5,0)
				AddonBack:SetText(L"back_btn")
				function AddonBack:DoClick()
					AddonsContainer:SetVisible(true)
					AddonContentContainer:SetVisible(false)

					AccessGroupsDivider:SetRight(AddonsContainer)
				end

				local AddonSelect = vgui.Create("OpenPermissions.ComboBox", AddonNav)
				AddonSelect:Dock(FILL)
				AddonSelect.AddonBtns = {}

				AddonSelect:SetSortItems(false)
				AddonSelect:AddChoice(L"all_addons", true, false, "icon16/layers.png")
				AddonSelect:AddSpacer()

				function AddonSelect:OnSelect(i, v, d)
					PropertiesContent:Clear()
					if (d == true) then
						function AccessGroups:OnRowSelected(i, row)
							AddonContent:SetShowOverlay(false)
							PermissionsTree:Clear()
							PropertiesContent:Clear()
							for id, data in pairs(OpenPermissions.Addons) do
								PermissionsTab:LoadPermissions(id, data, true)
							end
						end
						if (AccessGroups:GetSelectedLine() ~= nil) then
							AccessGroups:OnRowSelected()
						end
					else
						self.AddonBtns[d]:DoClick()
					end
				end

		local NavContent = vgui.Create("DPanel", PermissionsTab)
		AccessGroupsDivider:SetLeft(NavContent)
		NavContent.Paint = nil
		NavContent:Dock(LEFT)
		NavContent:SetWide(200)

			AccessGroups = vgui.Create("OpenPermissions.ListView", NavContent)
			AccessGroups:AddColumn(L"type"):SetFixedWidth(65)
			AccessGroups:AddColumn(L"access_group")
			AccessGroups:Dock(FILL)
			AccessGroups.Data = {}

			local KeyCategory = vgui.Create("DCollapsibleCategory", NavContent)
			KeyCategory:Dock(TOP)
			KeyCategory:SetTall(130)
			KeyCategory:DockMargin(0,0,0,5)
			KeyCategory:SetLabel(L"key")
			KeyCategory:SetExpanded(false)

				local KeyInfo = vgui.Create("OpenPermissions.ScrollPanel", NavContent)
				KeyInfo:SetDrawBackground(true)

				for name, enum in pairs(OpenPermissions.ACCESS_GROUP) do
					local Key = vgui.Create("DPanel", KeyInfo)
					Key:Dock(TOP)
					Key:DockMargin(5,5,5,0)

					local KeyColor = OpenPermissions.ACCESS_GROUP_KEY[enum]
					local KeyName = L("ACCESS_GROUP_" .. name)
					local KeyPoly = {
						{x = 9, y = 0},
						{x = 18, y = 9},
						{x = 9, y = 18},
						{x = 0, y = 9},
					}
					function Key:Paint(w,h)
						surface.SetDrawColor(KeyColor)
						draw.NoTexture()
						surface.DrawPoly(KeyPoly)

						draw.SimpleText(KeyName, "DermaDefault", 18 + 5, 8, OpenPermissions.COLOR_BLACK, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
					end
				end

				KeyCategory:SetContents(KeyInfo)
			
			local MultipleTip = vgui.Create("DLabel", NavContent)
			MultipleTip:Dock(TOP)
			MultipleTip:SetContentAlignment(5)
			MultipleTip:DockMargin(0,0,0,5)
			MultipleTip:SetText(L"hold_ctrl_to_select_multiple")
			MultipleTip:SetTextColor(OpenPermissions.COLOR_BLACK)

			local AddAccessGroup = vgui.Create("DButton", NavContent)
			AddAccessGroup:SetText(L"add_access_group")
			AddAccessGroup:SetIcon("icon16/add.png")
			AddAccessGroup:Dock(BOTTOM)
			AddAccessGroup:DockMargin(0,5,0,0)
			AddAccessGroup:SetTall(30)

			function AddAccessGroup:Add(enum, text, value)
				local val = value or text
				if (AccessGroups.Data[enum] and AccessGroups.Data[enum][val]) then
					Derma_Message(L"access_group_exists", L"error", L"ok")
				else
					local type
					for name, _enum in pairs(OpenPermissions.ACCESS_GROUP) do
						if (_enum == enum) then
							type = name
							break
						end
					end
					local line = AccessGroups:AddLine(L("ACCESS_GROUP_" .. type), text)
					line.Data = {
						Enum = enum,
						Value = val
					}
					function line:Paint(w,h)
						derma.SkinHook("Paint", "ListViewLine", self, w, h)

						surface.SetDrawColor(OpenPermissions.ACCESS_GROUP_KEY[enum])
						surface.DrawRect(0,0,w,h)
					end
					AccessGroups.Data[enum] = AccessGroups.Data[enum] or {}
					AccessGroups.Data[enum][val] = true
				end
			end
			for enum, accessors in pairs(OpenPermissions.PermissionsRegistry) do
				for val, vals in pairs(accessors) do
					enum = tonumber(enum)
					if (enum == OpenPermissions.ACCESS_GROUP.STEAMID) then
						AddAccessGroup:Add(enum, OpenPermissions:AccountIDToSteamID(tonumber(val)), tonumber(val))
					elseif (enum == OpenPermissions.ACCESS_GROUP.TEAM) then
						local team_index = OpenPermissions:GetTeamFromIdentifier(val)
						if (team_index) then
							AddAccessGroup:Add(enum, team.GetName(team_index), val)
						end
					elseif (enum == OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY) then
						if (OpenPermissions.IsDarkRP) then
							local category_index = OpenPermissions:DarkRP_GetCategoryFromIdentifier(val)
							if (category_index) then
								AddAccessGroup:Add(enum, DarkRP.getCategories().jobs[category_index].name, val)
							end
						end
					else
						AddAccessGroup:Add(enum, val)
					end
				end
			end

			function AddAccessGroup:DoClick()
				local menu = DermaMenu()
				
				local ACCESS_GROUP_USERGROUP, _ = menu:AddSubMenu(L"ACCESS_GROUP_USERGROUP") _:SetIcon("icon16/group.png")

					ACCESS_GROUP_USERGROUP:AddOption(L"custom_ellipsis", function()
						Derma_StringRequest(L"add_access_group", L"enter_usergroup", LocalPlayer():GetUserGroup(), function(usergroup)
							AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.USERGROUP, usergroup)
						end)
					end):SetIcon("icon16/pencil.png")

					local usergroups = {superadmin = true, admin = true, user = true}
					for _,ply in ipairs(player.GetHumans()) do
						for usergroup in pairs(OpenPermissions:GetUserGroups(ply)) do
							usergroups[usergroup] = true
						end
					end
					usergroups = table.GetKeys(usergroups)
					table.sort(usergroups)
					for i,usergroup in ipairs(usergroups) do
						GreenToRed_DMenu(i, #usergroups, ACCESS_GROUP_USERGROUP:AddOption(usergroup, function()
							AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.USERGROUP, usergroup)
						end))
					end

				local ACCESS_GROUP_STEAMID, _ = menu:AddSubMenu(L"ACCESS_GROUP_STEAMID") _:SetIcon("icon16/user_gray.png")

					ACCESS_GROUP_STEAMID:AddOption(L"custom_ellipsis", function()
						Derma_StringRequest(L"add_access_group", Lf("enter_steamid", LocalPlayer():SteamID(), LocalPlayer():SteamID64()), LocalPlayer():SteamID(), function(_input)
							local steamid64
							if (_input:find("^STEAM_%d:%d:%d+$")) then
								steamid64 = util.SteamIDTo64(_input)
							elseif (_input:find("^7656119%d+$")) then
								steamid64 = _input
							else
								Derma_Message(L"invalid_steamid", L"error", L"ok")
								return
							end
							local steamid = util.SteamIDFrom64(steamid64)
							AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.STEAMID, steamid, OpenPermissions:SteamIDToAccountID(steamid))
						end)
					end):SetIcon("icon16/pencil.png")

					local steamids = {}
					for _,ply in ipairs(player.GetHumans()) do
						table.insert(steamids, {Distance = ply:GetPos():DistToSqr(LocalPlayer():GetPos()), Name = ply:Nick(), SteamID = ply:SteamID(), AccountID = ply:AccountID(), Color = team.GetColor(ply:Team())})
					end
					table.SortByMember(steamids, "Distance", true)
					for i,item in ipairs(steamids) do
						DMenuOption_ColorIcon(ACCESS_GROUP_STEAMID:AddOption(item.Name, function()
							AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.STEAMID, item.SteamID, item.AccountID)
						end), item.Color)
					end

				local ACCESS_GROUP_TEAM, _ = menu:AddSubMenu(L"ACCESS_GROUP_TEAM") _:SetIcon("icon16/flag_green.png")

					if (OpenPermissions.IsDarkRP) then
						local categories = {}
						for i,c in ipairs(DarkRP.getCategories().jobs) do
							if (GAS:table_IsEmpty(c.members)) then continue end
							table.insert(categories, {name = c.name, color = c.color, members = c.members})
						end
						table.SortByMember(categories, "name", true)
						for i,c in ipairs(categories) do
							local submenu, _submenu = ACCESS_GROUP_TEAM:AddSubMenu(c.name)
							DMenuOption_ColorIcon(_submenu, c.color)

							local members = {}
							for _,member in ipairs(c.members) do
								table.insert(members, {name = member.name, color = member.color, index = member.team})
							end
							table.SortByMember(members, "name", true)
							for _,member in ipairs(members) do
								DMenuOption_ColorIcon(submenu:AddOption(member.name, function()
									AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.TEAM, member.name, OpenPermissions:GetTeamIdentifier(member.index))
								end), member.color)
							end
						end
					else
						local teams = {}
						for i,t in ipairs(team.GetAllTeams()) do
							table.insert(teams, {Name = t.Name, Index = i, Color = t.Color})
						end
						table.SortByMember(teams, "Name", true)
						for i,item in ipairs(teams) do
							DMenuOption_ColorIcon(ACCESS_GROUP_TEAM:AddOption(item.Name, function()
								AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.TEAM, item.Name, OpenPermissions:GetTeamIdentifier(i))
							end), item.Color)
						end
					end

				local ACCESS_GROUP_LUA_FUNCTION, _ = menu:AddSubMenu(L"ACCESS_GROUP_LUA_FUNCTION") _:SetIcon("icon16/script.png")
					local lua_functions = table.GetKeys(OpenPermissions.LuaFunctions)
					if (#lua_functions == 0) then
						ACCESS_GROUP_LUA_FUNCTION:AddOption(L"none_info")
					else
						table.sort(lua_functions)
						for i,lua_func_name in ipairs(lua_functions) do
							GreenToRed_DMenu(i, #lua_functions, ACCESS_GROUP_LUA_FUNCTION:AddOption(lua_func_name, function()
								AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.LUA_FUNCTION, lua_func_name)
							end))
						end
					end

				if (OpenPermissions.IsDarkRP) then
					local ACCESS_GROUP_DARKRP_CATEGORY, _ = menu:AddSubMenu(L"ACCESS_GROUP_DARKRP_CATEGORY") _:SetIcon("icon16/wrench_orange.png")
					local darkrp_categories = {}
					for i,category in ipairs(DarkRP.getCategories().jobs) do
						table.insert(darkrp_categories, {Name = category.name, Color = category.color, Category = category})
					end
					table.SortByMember(darkrp_categories, "Name", true)
					for i,item in ipairs(darkrp_categories) do
						DMenuOption_ColorIcon(ACCESS_GROUP_DARKRP_CATEGORY:AddOption(item.Name, function()
							AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY, item.Name, OpenPermissions:DarkRP_GetCategoryIdentifier(i))
						end), item.Color)
					end
				end

				hook.Run("OpenPermissions:AddAccessGroup", menu)

				menu:Open()
			end

		local function permissions_node_clicked(self, addon_id, v)
			PropertiesContent:Clear()

			local indent_level = 0
			local function _r(tbl, permission_id, my_parent, i)
				i = (i or 0) + 1
				local final_checkbox
				for i,v in ipairs(tbl) do
					local my_permission_id = permission_id
					if (v[2].Value) then
						my_permission_id = my_permission_id .. "/" .. v[2].Value
					end
					local new_checkbox = PropertiesContent:AddProperty(v[2], indent_level)
					final_checkbox = new_checkbox
					v[3] = new_checkbox
					v[4] = my_parent

					function new_checkbox:CheckAmbigious()
						if (my_parent) then
							local all_state
							local ambigious = false
							for _,_v in ipairs(my_parent[1]) do
								if (not IsValid(_v[3])) then continue end
								if (_v[3]:IsAmbigious()) then
									ambigious = true
									break
								elseif (all_state == nil) then
									all_state = _v[3]:GetChecked()
								elseif (all_state ~= _v[3]:GetChecked()) then
									ambigious = true
									break
								end
							end
							my_parent[3]:SetAmbigious(ambigious)
							if (not ambigious) then
								my_parent[3]:SetChecked(all_state)
							end
							my_parent[3]:CheckAmbigious()
						end
					end
					function new_checkbox:OnChange()
						self:CheckAmbigious()
						if (#v[1] > 0) then
							local function __r(tbl)
								for _,_v in ipairs(tbl) do
									_v[3]:SetChecked(self:GetChecked())
									_v[3]:OnChange()
									__r(_v[1])
								end
							end
							__r(v[1])
						else
							PermissionsSave:RememberPermission(my_permission_id, self:GetChecked())
						end
					end

					PermissionsSave:CheckedFromMemory(my_permission_id, new_checkbox)

					if (#v[1] > 0) then
						indent_level = indent_level + 1
						_r(v[1], my_permission_id, v, i)
					end
				end
				if (final_checkbox) then
					final_checkbox:CheckAmbigious()
				end
				indent_level = indent_level - 1
			end
			_r(v[1], addon_id)
		end
		function PermissionsTab:LoadPermissions(addon_id, addon_data, shouldnt_clear)
			PermissionsTab.AddonID, PermissionsTab.AddonData = addon_id, addon_data

			if (not shouldnt_clear) then
				PermissionsTree:Clear()
				PropertiesContent:Clear()
			end

			local tree = addon_data[1]
			local addon_options = addon_data[2]

			local root_node = PermissionsTree:AddNode(addon_options.Name or addon_id, addon_options.Icon)
			if (not shouldnt_clear) then root_node:SetExpanded(true) end
			function root_node:DoClick()
				-- show all permissions
				permissions_node_clicked(self, addon_id, addon_data)
			end

			local is_root = true
			local function r(tbl, node, permission_id, prev_options)
				local lowest_level = true
				for _,v in ipairs(tbl) do
					if (#v[1] > 0) then
						lowest_level = false
						break
					end
				end
				if (not is_root and lowest_level) then
					-- if we can't go any deeper then show property checkboxes
					-- when the node is clicked
					function node:DoClick()
						PropertiesContent:Clear()

						if (#tbl > 1) then
							local checkboxes = {}
							local master_checkbox = PropertiesContent:AddProperty(prev_options)
							function master_checkbox:OnChange()
								self:SetAmbigious(false)
								for _,v in ipairs(checkboxes) do
									v:SetChecked(self:GetChecked())
									v:OnChange()
								end
							end

							for i,v in ipairs(tbl) do
								local my_permission_id = permission_id
								if (v[2].Value) then
									my_permission_id = my_permission_id .. "/" .. v[2].Value
								end
								local checkbox = PropertiesContent:AddProperty(v[2], 1)
								table.insert(checkboxes, checkbox)
								function checkbox:CheckAmbigious()
									local all_state
									local ambigious = false
									for _,v in ipairs(checkboxes) do
										if (v:IsAmbigious()) then
											ambigious = true
											break
										elseif (all_state == nil) then
											all_state = v:GetChecked()
										elseif (all_state ~= v:GetChecked()) then
											ambigious = true
											break
										end
									end
									master_checkbox:SetAmbigious(ambigious)
									if (not ambigious) then master_checkbox:SetChecked(all_state) end
								end
								function checkbox:OnChange()
									PermissionsSave:RememberPermission(my_permission_id, self:GetChecked())
									self:CheckAmbigious()
								end
								PermissionsSave:CheckedFromMemory(my_permission_id, checkbox)
							end
							checkboxes[1]:CheckAmbigious()
						else
							local my_permission_id = permission_id
							if (tbl[1][2].Value) then
								my_permission_id = my_permission_id .. "/" .. tbl[1][2].Value
							end
							local checkbox = PropertiesContent:AddProperty(tbl[1][2])
							function checkbox:OnChange()
								PermissionsSave:RememberPermission(my_permission_id, self:GetChecked())
							end
							PermissionsSave:CheckedFromMemory(my_permission_id, checkbox)
						end
					end
				else
					is_root = false
				end

				for _,v in ipairs(tbl) do
					local my_permission_id = permission_id
					if (v[2].Value) then
						my_permission_id = my_permission_id .. "/" .. v[2].Value
					end
					local new_node = node:AddNode(v[2].Label)
					if (v[2].Icon) then
						new_node:SetIcon(v[2].Icon)
					elseif (v[2].Color) then
						function new_node.Icon:PaintOver(w,h)
							surface.SetDrawColor(v[2].Color)
							surface.DrawRect(0,0,w,h)
						end
					end
					if (#v[1] == 0) then
						function new_node:DoClick()
							PropertiesContent:Clear()
							local checkbox = PropertiesContent:AddProperty(v[2])
							function checkbox:OnChange()
								PermissionsSave:RememberPermission(my_permission_id, self:GetChecked())
							end
							PermissionsSave:CheckedFromMemory(my_permission_id, checkbox)
						end
					else
						function new_node:DoClick()
							permissions_node_clicked(self, my_permission_id, v)
						end
						r(v[1], new_node, my_permission_id, v[2])
					end
				end
			end
			r(tree, root_node, addon_id)
		end

	local TesterTab = vgui.Create("DPanel", Tabs)
	TesterTab.Paint = nil

	local HelpTabContent = vgui.Create("DPanel", Tabs)
	HelpTabContent.Paint = nil

	Tabs:AddSheet(L"permissions", PermissionsTab, "icon16/group.png")
	Tabs:AddSheet(L"tester", TesterTab, "icon16/wrench_orange.png")
	local HelpTab = Tabs:AddSheet(L"help", HelpTabContent, "icon16/help.png")

	local HelpContent
	function Tabs:OnActiveTabChanged(old, new)
		if (new == HelpTab.Tab) then
			if (IsValid(HelpContent)) then
				HelpContent:SetVisible(true)
			else
				HelpContent = vgui.Create("DPanel", HelpTabContent)
				HelpContent.Paint = nil
				HelpContent:Dock(FILL)

				local HelpControls = vgui.Create("DHTMLControls", HelpContent)
				HelpControls:Dock(TOP)
				HelpControls.HomeURL = "https://gmodadminsuite.github.io/OpenPermissions"

				local HelpHTML = vgui.Create("DHTML", HelpContent)
				HelpHTML:Dock(FILL)
				HelpHTML:OpenURL(HelpControls.HomeURL)

				HelpControls:SetHTML(HelpHTML)
			end
		elseif (IsValid(HelpContent)) then
			HelpContent:SetVisible(false)
		end
	end

	--## Create Dynamic Content ##--

	function DeleteAccessGroup:DoClick()
		for i,line in pairs(AccessGroups:GetLines()) do
			if (not line:IsLineSelected()) then continue end
			if (AccessGroups.Data[line.Data.Enum][line.Data.Value] ~= nil) then
				AccessGroups.Data[line.Data.Enum][line.Data.Value] = nil
			end
			if (OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] ~= nil) then
				OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] = nil
			end
			AccessGroups:RemoveLine(i)
		end
		AddonContent:SetShowOverlay(true)
		AddonContent:SwitchToName(L"permissions")
		PermissionsTree:Clear()
		PropertiesContent:Clear()

		PermissionsSave:SetDisabled(false)
	end

	local sorted_addons = {}
	for id, data in pairs(OpenPermissions.Addons) do
		local options = data[2]
		table.insert(sorted_addons, {name = options.Name or id, id = id, data = data})
	end
	table.SortByMember(sorted_addons, "name", true)

	local AddonQueue = {}
	local ActiveAddon
	for _,addon_data in ipairs(sorted_addons) do
		local id, data = addon_data.id, addon_data.data
		local options = data[2]
		AddonSelect:AddChoice(options.Name or id, id, false, options.Icon)

		local Addon = vgui.Create("OpenPermissions.Addon", AddonsContainer)

		if (specific_addon == id) then
			ActiveAddon = Addon
		end

		AddonSelect.AddonBtns[id] = Addon

		Addon:SetSize(200,120)
		Addon:Setup(id, options)
		if (Addon.Addon.Logo) then
			OpenPermissions:AddTooltip(Addon, {
				Text = options.Name
			})
		end

		function Addon:DoClick()
			PropertiesContent:Clear()

			AddonSelect:SetValue(options.Name or id)

			AddonsContainer:SetVisible(false)
			AddonContentContainer:SetVisible(true)

			AccessGroupsDivider:SetRight(AddonContentContainer)

			CopyPermissions:SetDisabled(#AccessGroups:GetSelected() > 1)
			PastePermissions:SetDisabled(true)

			function AccessGroups:OnRowSelected(i, row)
				AddonContent:SetShowOverlay(false)
				PropertiesContent:Clear()
				PermissionsTab:LoadPermissions(id, data)
			end
			if (AccessGroups:GetSelectedLine() ~= nil) then
				AccessGroups:OnRowSelected()
			end
		end

		table.insert(AddonQueue, Addon)
		if (#AddonQueue == 3) then
			AddonsContainer:AddRow(AddonQueue[1], AddonQueue[2], AddonQueue[3])
			AddonQueue = {}
		end
	end
	if (#AddonQueue > 0) then
		AddonsContainer:AddRow(AddonQueue[1], AddonQueue[2], AddonQueue[3])
	end
	if (ActiveAddon) then
		ActiveAddon:DoClick()
	end
end

net.Receive("OpenPermissions.OpenMenu", function()
	OpenPermissions.Addons = OpenPermissions:ReceiveNetworkTable()
	OpenPermissions.PermissionsRegistryEditing = table.Copy(OpenPermissions.PermissionsRegistry)

	local specific_addon = net.ReadBool()
	if (specific_addon) then
		OpenPermissions:OpenMenu(net.ReadString())
	else
		OpenPermissions:OpenMenu()
	end
end)

concommand.Add("openpermissions", function(_, __, args)
	net.Start("OpenPermissions.OpenMenu")
		net.WriteString(table.concat(args, " "))
	net.SendToServer()
end, function(cmd, args)
	local stuff = {}
	if (OpenPermissions.Addons ~= nil) then
		if (#string.Trim(args) > 0) then
			for name in pairs(OpenPermissions.Addons) do
				if (name:lower():find(string.Trim(args):lower())) then
					stuff[#stuff + 1] = "openpermissions " .. name
				end
			end
		else
			for name in pairs(OpenPermissions.Addons) do
				stuff[#stuff + 1] = "openpermissions " .. name
			end
		end
	end
	table.sort(stuff)
	return stuff
end)

net.Receive("OpenPermissions.NoPermissions", function()
	OpenPermissions:ChatPrint(L"operator_only_menu", "[ERROR]", OpenPermissions.COLOR_RED)
end)

net.Receive("OpenPermissions.NotAnAddon", function()
	OpenPermissions:ChatPrint(L"not_an_addon", "[ERROR]", OpenPermissions.COLOR_RED)
end)
--addons/tools/lua/autorun/rb655_ext_props_wpn_slct.lua:

AddCSLuaFile()

local extraItems = {
	{ ClassName = "weapon_alyxgun", PrintName = "#weapon_alyxgun", Category = "Half-Life 2", Author = "VALVe", Spawnable = true },
	{ ClassName = "weapon_oldmanharpoon", PrintName = "#weapon_oldmanharpoon", Category = "Half-Life 2", Author = "VALVe", Spawnable = true },
	{ ClassName = "weapon_annabelle", PrintName = "#weapon_annabelle", Category = "Half-Life 2", Author = "VALVe", Spawnable = true },
	{ ClassName = "weapon_citizenpackage", PrintName = "#weapon_citizenpackage", Category = "Half-Life 2", Author = "VALVe", Spawnable = true },
	{ ClassName = "weapon_citizensuitcase", PrintName = "#weapon_citizensuitcase", Category = "Half-Life 2", Author = "VALVe", Spawnable = true }
}

local function GiveWeapon( ply, ent, args )
	if ( !args or !args[ 1 ] or !isstring( args[ 1 ] ) ) then return end

	local className = args[ 1 ]

	local swep = list.Get( "Weapon" )[ className ]
	if ( swep == nil ) then
		for id, t in pairs( extraItems ) do
			if ( t.ClassName == className ) then swep = t end
		end
	end
	if ( swep == nil ) then return end

	-- Cannot validate if the player is admin for admin weapons if we got no player object (saves)
	if ( IsValid( ply ) ) then
		if ( ( !swep.Spawnable && !ply:IsAdmin() ) or ( swep.AdminOnly && !ply:IsAdmin() ) ) then return end
		if ( !hook.Run( "PlayerGiveSWEP", ply, className, swep ) ) then return end
	end

	ent:Give( className )
	if ( SERVER ) then duplicator.StoreEntityModifier( ent, "rb655_npc_weapon", args ) end
end
duplicator.RegisterEntityModifier( "rb655_npc_weapon", GiveWeapon )

local function changeWep( it, ent, wep )
	it:MsgStart()
		net.WriteEntity( ent )
		net.WriteString( wep )
	it:MsgEnd()
end

local nowep = {
	"cycler", "npc_furniture", "monster_generic",

	-- HL2
	"npc_seagull", "npc_crow", "npc_piegon", "npc_rollermine", "npc_turret_floor", "npc_stalker", "npc_turret_ground",
	"npc_combine_camera", "npc_turret_ceiling", "npc_cscanner", "npc_clawscanner", "npc_manhack", "npc_sniper",
	"npc_combinegunship", "npc_combinedropship", "npc_helicopter", "npc_antlion_worker", "npc_headcrab_black",
	"npc_hunter", "npc_vortigaunt", "npc_antlion", "npc_antlionguard", "npc_barnacle", "npc_headcrab",
	"npc_dog", "npc_gman", "npc_antlion_grub", "npc_strider", "npc_fastzombie", "npc_fastzombie_torso",
	"npc_headcrab_poison", "npc_headcrab_fast", "npc_poisonzombie", "npc_zombie", "npc_zombie_torso", "npc_zombine",

	-- HLS
	"monster_scientist", "monster_zombie", "monster_headcrab", "class C_AI_BaseNPC", "monster_tentacle",
	"monster_alien_grunt", "monster_alien_slave", "monster_human_assassin", "monster_babycrab", "monster_bullchicken",
	"monster_cockroach", "monster_alien_controller", "monster_gargantua", "monster_bigmomma", "monster_human_grunt",
	"monster_houndeye", "monster_nihilanth", "monster_barney", "monster_snark", "monster_turret", "monster_miniturret", "monster_sentry"
}

AddEntFunctionProperty( "rb655_npc_weapon_strip", "Strip Weapon", 651, function( ent )
	if ( ent:IsNPC() && IsValid( ent:GetActiveWeapon() ) && !table.HasValue( nowep, ent:GetClass() ) ) then return true end
	return false
end, function( ent )
	ent:GetActiveWeapon():Remove()
end, "icon16/gun.png" )

properties.Add( "rb655_npc_weapon", {
	MenuLabel = "Change Weapon (Popup)",
	MenuIcon = "icon16/gun.png",
	Order = 650,
	Filter = function( self, ent, ply )
		if ( !IsValid( ent ) or !gamemode.Call( "CanProperty", ply, "rb655_npc_weapon", ent ) ) then return false end
		if ( ent:IsNPC() && !table.HasValue( nowep, ent:GetClass() ) ) then return true end
		return false
	end,
	Action = function( self, ent )
		if ( !IsValid( ent ) ) then return false end

		local frame = vgui.Create( "DFrame" )
		frame:SetSize( ScrW() / 1.2, ScrH() / 1.1 )
		frame:SetTitle( "Change weapon of " .. language.GetPhrase( "#" .. ent:GetClass() ) )
		frame:Center()

		frame:MakePopup()

		frame:SetDraggable( false )

		function frame:Paint( w, h )
			Derma_DrawBackgroundBlur( self, self.m_fCreateTime )
			draw.RoundedBox( 0, 0, 0, w, h, Color( 0, 0, 0, 200 ) )
		end

		local PropPanel = vgui.Create( "ContentContainer", frame )
		PropPanel:SetTriggerSpawnlistChange( false )
		PropPanel:Dock( FILL )

		local Categorised = {}

		-- Add the hidden NPC only weapons
		Categorised[ "Half-Life 2" ] = table.Copy( extraItems )

		for k, weapon in pairs( list.Get( "Weapon" ) ) do
			if ( !weapon.Spawnable && !weapon.AdminSpawnable ) then continue end

			local cat = weapon.Category or "Other"
			if ( !isstring( cat ) ) then cat = tostring( cat ) end

			Categorised[ cat ] = Categorised[ cat ] or {}
			table.insert( Categorised[ cat ], weapon )
		end

		for CategoryName, v in SortedPairs( Categorised ) do
			local Header = vgui.Create( "ContentHeader", PropPanel )
			Header:SetText( CategoryName )
			PropPanel:Add( Header )

			for k, WeaponTable in SortedPairsByMemberValue( v, "PrintName" ) do
				if ( WeaponTable.AdminOnly && !LocalPlayer():IsAdmin() ) then continue end

				local icon = vgui.Create( "ContentIcon", PropPanel )
				icon:SetMaterial( "entities/" .. WeaponTable.ClassName .. ".png" )
				icon:SetName( WeaponTable.PrintName or "#" .. WeaponTable.ClassName )
				icon:SetAdminOnly( WeaponTable.AdminOnly or false )

				icon.DoClick = function()
					changeWep( self, ent, WeaponTable.ClassName )
					frame:Close()
				end

				PropPanel:Add( icon )
			end
		end

		local WarningThing = vgui.Create( "Panel", frame )
		WarningThing:SetHeight( 70 )
		WarningThing:Dock( BOTTOM )
		WarningThing:DockMargin( 0, 5, 0, 0 )
		function WarningThing:Paint( w, h )
			draw.RoundedBox( 0, 0, 0, w, h, Color( 255, 0, 0 ) )
		end

		local WarningText = vgui.Create( "DLabel", WarningThing )
		WarningText:Dock( TOP )
		WarningText:SetHeight( 35 )
		WarningText:SetContentAlignment( 5 )
		WarningText:SetTextColor( color_white )
		WarningText:SetFont( "DermaLarge" )
		WarningText:SetText( "WARNING! Not all NPCs can use weapons and not all weapons are usable by NPCs." )

		local WarningText2 = vgui.Create( "DLabel", WarningThing )
		WarningText2:Dock( TOP )
		WarningText2:SetHeight( 35 )
		WarningText2:SetContentAlignment( 5 )
		WarningText2:SetTextColor( color_white )
		WarningText2:SetFont( "DermaLarge" )
		WarningText2:SetText( "This is entirely dependent on the Addon the weapon and the NPC are from. This mod cannot change that." )
	end,
	Receive = function( self, length, ply )
		local ent = net.ReadEntity()
		if ( !IsValid( ent ) ) then return end
		if ( !ent:IsNPC() or table.HasValue( nowep, ent:GetClass() ) ) then return end

		local wep = net.ReadString()

		GiveWeapon( ply, ent, { wep } )
	end
} )

--addons/tools/lua/autorun/rb655_legacy_addon_props.lua:

AddCSLuaFile()

if ( SERVER ) then return end

language.Add( "spawnmenu.category.addonslegacy", "Addons - Legacy" )
language.Add( "spawnmenu.category.addonslegacy", "Addons - Legacy" )
language.Add( "spawnmenu.category.downloads", "Downloads" )

local function AddRecursive( pnl, folder )
	local files, folders = file.Find( folder .. "*", "GAME" )

	for k, v in pairs( files or {} ) do
		if ( !string.EndsWith( v, ".mdl" ) ) then continue end

		local cp = spawnmenu.GetContentType( "model" )
		if ( cp ) then
			local mdl = folder .. v
			mdl = string.sub( mdl, string.find( mdl, "models/" ), string.len( mdl ) )
			mdl = string.gsub( mdl, "models/models/", "models/" )
			cp( pnl, { model = mdl } )
		end
	end

	for k, v in pairs( folders or {} ) do AddRecursive( pnl, folder .. v .. "/" ) end
end

local function CountRecursive( folder )
	local files, folders = file.Find( folder .. "*", "GAME" )
	local val = 0

	for k, v in pairs( files or {} ) do if ( string.EndsWith( v, ".mdl" ) ) then val = val + 1 end end
	for k, v in pairs( folders or {} ) do val = val + CountRecursive( folder .. v .. "/" ) end
	return val
end

-- Calculate this as soon as we start, so the spawnmenu loading times are better.
local files, folders = file.Find( "addons/*", "GAME" )
local addons = {}
for _, f in pairs( folders ) do

	if ( !file.IsDir( "addons/" .. f .. "/models/", "GAME" ) ) then continue end

	local count = CountRecursive( "addons/" .. f .. "/models/", "GAME" )
	if ( count == 0 ) then continue end

	table.insert( addons, {
		name = f,
		count = count,
		path = "addons/" .. f .. "/models/"
	} )

end

hook.Add( "PopulateContent", "LegacyAddonProps", function( pnlContent, tree, node )

	if ( !IsValid( node ) || !IsValid( pnlContent ) ) then
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR LEGACY ADDONS!!!" )
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR LEGACY ADDONS!!!" )
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR LEGACY ADDONS!!!" )
		return
	end

	local ViewPanel = vgui.Create( "ContentContainer", pnlContent )
	ViewPanel:SetVisible( false )

	local LegacyAddons = node:AddNode( "#spawnmenu.category.addonslegacy", "icon16/folder_database.png" )
	for _, f in SortedPairsByMemberValue( addons, "name" ) do

		local models = LegacyAddons:AddNode( f.name .. " (" .. f.count .. ")", "icon16/bricks.png" )
		models.DoClick = function()
			ViewPanel:Clear( true )
			AddRecursive( ViewPanel, f.path )
			pnlContent:SwitchPanel( ViewPanel )
		end

	end

	--[[ -------------------------- DOWNLOADS -------------------------- ]]

	local fi, fo = file.Find( "download/models", "GAME" )
	if ( !fi && !fo ) then return end

	local Downloads = node:AddFolder( "#spawnmenu.category.downloads", "download/models", "GAME", false, false, "*.*" )
	Downloads:SetIcon( "icon16/folder_database.png" )

	Downloads.OnNodeSelected = function( self, node )
		ViewPanel:Clear( true )

		local path = node:GetFolder()

		if ( !string.EndsWith( path, "/" ) && string.len( path ) > 1 ) then path = path .. "/" end
		local path_mdl = string.sub( path, string.find( path, "/models/" ) + 1 )

		for k, v in pairs( file.Find( path .. "/*.mdl", node:GetPathID() ) ) do

			local cp = spawnmenu.GetContentType( "model" )
			if ( cp ) then
				cp( ViewPanel, { model = path_mdl .. "/" .. v } )
			end

		end

		pnlContent:SwitchPanel( ViewPanel )
	end

end )

--[[ -------------------------------------------------------------------------- The addon info -------------------------------------------------------------------------- ]]

concommand.Add( "extsm_addoninfo", function()
	local frame = vgui.Create( "DFrame" )
	frame:SetSize( ScrW() - 100, ScrH() - 100 )
	frame:Center()
	frame:MakePopup()

	local sp = frame:Add( "DScrollPanel" )
	sp:Dock( FILL )

	local info = sp:Add( "rb655_addonInfo" )
end )

hook.Add( "AddToolMenuCategories", "LegacyAddonPropsInfoCategory", function()
	spawnmenu.AddToolCategory( "Utilities", "Robotboy655", "#Robotboy655" )
end )

hook.Add( "PopulateToolMenu", "LegacyAddonPropsInfoThing", function()
	spawnmenu.AddToolMenuOption( "Utilities", "Robotboy655", "LegacyInfoPanel", "Addon Information", "", "", function( panel )
		panel:ClearControls()
		panel:Button( "Open addon data window", "extsm_addoninfo" )
	end )
end )

----------------------------------

function ScreenScaleH( size )
	return size * ( ScrH() / 480.0 )
end

surface.CreateFont( "AddonInfo_Header", {
	font	= "Helvetica",
	size	= ScreenScaleH( 24 ),
	weight	= 1000
} )

surface.CreateFont( "AddonInfo_Text", {
	font	= "Helvetica",
	size	= ScreenScaleH( 9 ),
	weight	= 1000
} )

surface.CreateFont( "AddonInfo_Small", {
	font	= "Helvetica",
	size	= ScreenScaleH( 8 )
} )

local function GetWorkshopLeftovers()

	local subscriptions = {}

	for id, t in pairs( engine.GetAddons() ) do
		subscriptions[ tonumber( t.wsid ) ] = true
	end

	local t = {}
	for id, fileh in pairs( file.Find( "addons/*.gma", "GAME" ) ) do
		local a = string.StripExtension( fileh )
		a = string.Explode( "_", a )
		a = tonumber( a[ #a ] )
		if ( !subscriptions[ a ] ) then
			table.insert( t, fileh )
		end
	end

	return t

end

local function GetSize( b )
	b = b / 1000

	if ( b < 1000 ) then
		return math.floor( b * 10 ) / 10 .. " KB"
	end

	b = b / 1000

	if ( b < 1000 ) then
		return math.floor( b * 10 ) / 10 .. " MB"
	end

	b = b / 1000

	return math.floor( b * 10 ) / 10 .. " GB"
end

local function DrawText( txt, font, x, y, clr )
	draw.SimpleText( txt, font, x, y, clr )

	surface.SetFont( font )
	return surface.GetTextSize( txt )
end

local PANEL = {}

function PANEL:Init()
	self.Computed = false
end

function PANEL:Compute()

	self.WorkshopSize = 0
	for id, fle in pairs( file.Find( "addons/*.gma", "GAME" ) ) do
		self.WorkshopSize = self.WorkshopSize + ( file.Size( "addons/" .. fle, "GAME" ) or 0 )
	end

	self.WorkshopWaste = 0
	self.WorkshopWasteFiles = {}
	for id, fle in pairs( GetWorkshopLeftovers() ) do
		self.WorkshopWaste = self.WorkshopWaste + ( file.Size( "addons/" .. fle, "GAME" ) or 0 )
		table.insert( self.WorkshopWasteFiles, { "addons/" .. fle, ( file.Size( "addons/" .. fle, "GAME" ) or 0 ) } )
	end

	-- -------------------------------------------

	local files, folders = file.Find( "addons/*", "MOD" )

	self.LegacyAddons = {}
	for k, v in pairs( folders or {} ) do
		self.LegacyAddons[ "addons/" .. v .. "/" ] = "Installed"

		if ( file.IsDir( "addons/" .. v .. "/models/", "MOD" ) ) then
			self.LegacyAddons[ "addons/" .. v .. "/" ] = "Installed (Has Models)"
		end

		local a, b = file.Find( "addons/" .. v .. "/*", "MOD" )
		if ( table.Count( b or {} ) < 1 ) then
			self.LegacyAddons[ "addons/" .. v .. "/" ] = "Installed (Empty)"
		end

		if ( !file.IsDir( "addons/" .. v .. "/models/", "MOD" ) && !file.IsDir(  "addons/" .. v .. "/materials/", "MOD" ) && !file.IsDir(  "addons/" .. v .. "/lua/", "MOD" ) && !file.IsDir(  "addons/" .. v .. "/sound/", "MOD" ) ) then
			self.LegacyAddons[ "addons/" .. v .. "/" ] = "Installed Incorrectly!"
		end
	end

	-- -------------------------------------------

	local files = file.Find( "cache/lua/*", "MOD" )  -- Too many files to count actual size!
	self.LuaCacheSize = #files * 1400
	self.LuaCacheFiles = #files

	local files = file.Find( "cache/workshop/*", "MOD" )
	self.WSCacheSize = 0
	for id, fle in pairs( files ) do
		self.WSCacheSize = self.WSCacheSize + ( file.Size( "cache/workshop/" .. fle, "GAME" ) or 0 )
	end
	self.WSCacheFiles = #files

	self.Computed = true

end

function PANEL:Paint( w, h )

	if ( !self.Computed ) then
		self:Compute()
	end

	local txtW = self:GetParent():GetWide()
	local txtH = 0

	-- -----------------------

	local tW, tH = DrawText( "Cache Sizes", "AddonInfo_Header", 0, txtH, color_white )
	txtH = txtH + tH

	local localH = 0
	local localW = 0

	-- -----------------------

	local tW, tH = DrawText( "~" .. GetSize( self.LuaCacheSize or 0 ) .. " (" .. self.LuaCacheFiles .. " files)", "AddonInfo_Small", 0, txtH + localH, Color( 220, 220, 220 ) )
	localH = localH + tH
	localW = math.max( localW, tW )

	local tW, tH = DrawText( "~" .. GetSize( self.WSCacheSize or 0 ) .. " (" .. self.WSCacheFiles .. " files)", "AddonInfo_Small", 0, txtH + localH, Color( 220, 220, 220 ) )
	localH = localH + tH
	localW = math.max( localW, tW )

	-- -----------------------

	localW = localW + 25

	local tW, tH = DrawText( "Server Lua cache", "AddonInfo_Small", localW, txtH, color_white )
	txtH = txtH + tH

	local tW, tH = DrawText( "Workshop download cache", "AddonInfo_Small", localW, txtH, color_white )
	txtH = txtH + tH

	-- -------------------------------------------

	txtH = txtH + ScreenScaleH( 8 )
	local tW, tH = DrawText( "Workshop Subscriptions", "AddonInfo_Header", 0, txtH, color_white )
	txtH = txtH + tH

	-- -------------------------------------------

	local tW, tH = DrawText( "Used Size:  ", "AddonInfo_Text", 0, txtH, color_white )
	local maxW = tW
	txtH = txtH + tH

	local tW, tH = DrawText( "Wasted Space:  ", "AddonInfo_Text", 0, txtH, color_white )
	maxW = math.max( maxW, tW )
	txtH = txtH + tH

	local tW, tH = DrawText( "Total Size:  ", "AddonInfo_Text", 0, txtH, color_white )
	maxW = math.max( maxW, tW )
	txtH = txtH - tH * 2

	-- -------------------------------------------

	local tW, tH = DrawText( GetSize( ( self.WorkshopSize - self.WorkshopWaste ) or 0 ), "AddonInfo_Text", maxW, txtH, Color( 220, 220, 220 ) )
	txtH = txtH + tH

	local tW, tH = DrawText( GetSize( self.WorkshopWaste or 0 ), "AddonInfo_Text", maxW, txtH, Color( 220, 220, 220 ) )
	txtH = txtH + tH

	local tW, tH = DrawText( GetSize( self.WorkshopSize or 0 ), "AddonInfo_Text", maxW, txtH, Color( 220, 220, 220 ) )
	txtH = txtH + tH * 2

	-- -------------------------------------------

	local tW, tH = DrawText( "Files that aren't used: ( Safe to delete )", "AddonInfo_Text", 0, txtH, color_white )
	txtH = txtH + tH

	local localH = 0
	local localW = 0
	for id, t in pairs( self.WorkshopWasteFiles or {} ) do
		local tW, tH = DrawText( GetSize( t[ 2 ] ) .. "    ", "AddonInfo_Small", 0, txtH + localH, Color( 220, 220, 220 ) )
		localH = localH + tH
		localW = math.max( localW, tW )
	end

	for id, t in pairs( self.WorkshopWasteFiles or {} ) do
		local tW, tH = DrawText( t[ 1 ], "AddonInfo_Small", localW, txtH, color_white )
		txtH = txtH + tH
	end

	-- -------------------------------------------

	local tW, tH = DrawText( "Legacy Addons", "AddonInfo_Header", 0, txtH + ScreenScaleH( 8 ), color_white )
	txtH = txtH + tH + ScreenScaleH( 8 )

	-- -------------------------------------------

	local tW, tH = DrawText( "Legacy Addons with models:", "AddonInfo_Text", 0, txtH, color_white )
	txtH = txtH + tH

	if ( table.Count( self.LegacyAddons or {} ) > 0 ) then
		local maxNameW = 0
		local oldH = txtH
		for path, status in pairs( self.LegacyAddons or {} ) do
			local tW, tH = DrawText( path, "AddonInfo_Small", 0, txtH, color_white )
			maxNameW = math.max( maxNameW, tW )
			txtH = txtH + tH
		end

		maxNameW = maxNameW + 25
		txtH = oldH

		for path, status in pairs( self.LegacyAddons or {} ) do
			local tW, tH = DrawText( status, "AddonInfo_Small", maxNameW, txtH, Color( 220, 220, 220 ) )
			txtH = txtH + tH
		end
	else
		local tW, tH = DrawText( "None.", "AddonInfo_Small", 0, txtH, color_white )
		txtH = txtH + tH
	end

	if ( !system.IsWindows() ) then
		txtH = txtH + tH

		local tW, tH = DrawText( "OSX AND LINUX USERS BEWARE:", "AddonInfo_Text", 0, txtH, color_white )
		txtH = txtH + tH
		local tW, tH = DrawText( "MAKE SURE ALL FILE AND FOLDER NAMES", "AddonInfo_Text", 0, txtH, color_white )
		txtH = txtH + tH
		local tW, tH = DrawText( "IN ALL ADDONS ARE LOWERCASE ONLY", "AddonInfo_Text", 0, txtH, color_white )
		txtH = txtH + tH
		local tW, tH = DrawText( "INCLUDING ALL SUB FOLDERS", "AddonInfo_Text", 0, txtH, color_white )
		txtH = txtH + tH
	end

	txtH = txtH + tH

	-- -------------------------------------------

	self:SetSize( txtW, txtH )
end

vgui.Register( "rb655_addonInfo", PANEL, "Panel" )

--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]

-- I spent too much time on this than I care to admit
hook.Add( "PopulatePropMenu", "rb655_LoadLegacySpawnlists", function()

	local sid = 0 --table.Count( spawnmenu.GetPropTable() )

	local added = false

	for id, spawnlist in pairs( file.Find( "settings/spawnlist/*.txt", "MOD" ) ) do
		local content = file.Read( "settings/spawnlist/" .. spawnlist, "MOD" )
		if ( !content ) then continue end

		--[[local is = string.find( content, "TableToKeyValues" )
		if ( is != nil ) then continue end

		for id, t in pairs( spawnmenu.GetPropTable() ) do -- This somehow freezes the game when opening Q menu => FUCK THIS SHIT
			if ( t.name == "Legacy Spawnlists" ) then
				added = true
				sid = t.id
			end
		end

		if ( !added ) then
			spawnmenu.AddPropCategory( "rb655_legacy_spawnlists", "Legacy Spawnlists", {}, "icon16/folder.png", sid, 0 )
			added = true
		end]]

		content = util.KeyValuesToTable( content )

		if ( !content.entries or content.contents ) then continue end

		local contents = {}

		for id, ply in pairs( content.entries ) do
			if ( type( ply ) == "table" ) then ply = ply.model end
			table.insert( contents, { type = "model", model = ply } )
		end

		if ( !content.information ) then content.information = { name = spawnlist } end

		spawnmenu.AddPropCategory( "settings/spawnlist/" .. spawnlist, content.information.name, contents, "icon16/page.png", sid + id, sid )

	end

end )

--addons/admin_sam/lua/sam/libs/sh_globals.lua:
if SAM_LOADED then return end

local sam, netstream = sam, sam.netstream

local globals

if SERVER then
	globals = {}
	local order = {}

	local get_order_key = function(key)
		for i = 1, #order do
			if order[i] == key then
				return i
			end
		end
	end

	function sam.set_global(key, value, force)
		if force or globals[key] ~= value then
			globals[key] = value

			if value ~= nil then
				if not get_order_key(key) then
					table.insert(order, key)
				end
			else
				local i = get_order_key(key)
				if i then
					table.remove(order, i)
				end
			end

			netstream.Start(nil, "SetGlobal", key, value)
		end
	end

	hook.Add("SAM.PlayerNetReady", "SAM.SendGlobals", function(ply)
		netstream.StartCompressed(ply, "SendGlobals", globals, order)
	end)
end

if CLIENT then
	function sam.set_global(key, value)
		if globals then
			globals[key] = value
			hook.Call("SAM.ChangedGlobalVar", nil, key, value)
		end
	end
	netstream.Hook("SetGlobal", sam.set_global)

	netstream.Hook("SendGlobals", function(vars, order)
		globals = vars

		for _, key in ipairs(order) do
			hook.Call("SAM.ChangedGlobalVar", nil, key, vars[key])
		end
	end)
end

function sam.get_global(key, default)
	if globals then
		local value = globals[key]
		if value ~= nil then
			return value
		end
	end

	return default
end

--addons/aocrp_pixelui/lua/pixelui/core/sh_formatting.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

do
    local currencySymbol = "$"
    local currencyLeft = true

    hook.Add("PostGamemodeLoaded", "PIXEL.UI.GetMoneyFormatSettings", function()
        local config = (GM or GAMEMODE).Config
        if not config then return end

        if config.currency then currencySymbol = config.currency end
        if config.currencyLeft then currencyLeft = config.currencyLeft end
    end)

    local function addCurrency(str)
        return currencyLeft and (currencySymbol .. str) or (str .. currencySymbol)
    end

    do
        local tostring = tostring
        local find = string.find
        local abs = math.abs
        local round = math.Round

        function PIXEL.FormatMoney(val)
            if not val then return addCurrency("0") end

            val = round(val)

            if val >= 1e14 then return addCurrency(tostring(val)) end
            if val <= -1e14 then return "-" .. addCurrency(tostring(abs(val))) end

            local negative = val < 0

            val = tostring(abs(val))
            local dp = find(val, "%.") or #val + 1

            for i = dp - 4, 1, -3 do
                val = val:sub(1, i) .. "," .. val:sub(i + 1)
            end

            if val[#val - 1] == "." then
                val = val .. "0"
            end

            return (negative and "-" or "") .. addCurrency(val)
        end
    end
end

local floor, format = math.floor, string.format
function PIXEL.FormatTime(time)
    if not time then return end

    local s = time % 60
    time = floor(time / 60)

    local m = time % 60
    time = floor(time / 60)

    local h = time % 24
    time = floor(time / 24)

    local d = time % 7
    local w = floor(time / 7)

    if w ~= 0 then
        return format("%iw %id %ih %im %is", w, d, h, m, s)
    elseif d ~= 0 then
        return format("%id %ih %im %is", d, h, m, s)
    elseif h ~= 0 then
        return format("%ih %im %is", h, m, s)
    end

    return format("%im %is", m, s)
end
--addons/aocrp_pixelui/lua/pixelui/elements/cl_frame.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

AccessorFunc(PANEL, "Draggable", "Draggable", FORCE_BOOL)
AccessorFunc(PANEL, "Sizable", "Sizable", FORCE_BOOL)
AccessorFunc(PANEL, "MinWidth", "MinWidth", FORCE_NUMBER)
AccessorFunc(PANEL, "MinHeight", "MinHeight", FORCE_NUMBER)
AccessorFunc(PANEL, "ScreenLock", "ScreenLock", FORCE_BOOL)
AccessorFunc(PANEL, "RemoveOnClose", "RemoveOnClose", FORCE_BOOL)

AccessorFunc(PANEL, "Title", "Title", FORCE_STRING)
AccessorFunc(PANEL, "ImgurID", "ImgurID", FORCE_STRING)

PIXEL.RegisterFont("UI.FrameTitle", "Open Sans Bold", 22)

function PANEL:Init()
	self.CloseButton = vgui.Create("PIXEL.ImgurButton", self)
	self.CloseButton:SetImgurID("z1uAU0b")
	self.CloseButton:SetNormalColor(PIXEL.Colors.PrimaryText)
	self.CloseButton:SetHoverColor(PIXEL.Colors.Negative)
	self.CloseButton:SetClickColor(PIXEL.Colors.Negative)
	self.CloseButton:SetDisabledColor(PIXEL.Colors.DisabledText)

	self.CloseButton.DoClick = function(s)
		self:Close()
	end

	self.ExtraButtons = {}

	self:SetTitle("PIXEL Frame")

	self:SetDraggable(true)
	self:SetScreenLock(true)
	self:SetRemoveOnClose(true)

	local size = PIXEL.Scale(200)
	self:SetMinWidth(size)
	self:SetMinHeight(size)

	local oldMakePopup = self.MakePopup
	function self:MakePopup()
		oldMakePopup(self)
		self:Open()
	end
end

function PANEL:DragThink(targetPanel, hoverPanel)
	local scrw, scrh = ScrW(), ScrH()
	local mousex, mousey = math.Clamp(gui.MouseX(), 1, scrw - 1), math.Clamp(gui.MouseY(), 1, scrh - 1)

	if targetPanel.Dragging then
		local x = mousex - targetPanel.Dragging[1]
		local y = mousey - targetPanel.Dragging[2]

		if targetPanel:GetScreenLock() then
			x = math.Clamp(x, 0, scrw - targetPanel:GetWide())
			y = math.Clamp(y, 0, scrh - targetPanel:GetTall())
		end

		targetPanel:SetPos(x, y)
	end

	local _, screenY = targetPanel:LocalToScreen(0, 0)
	if (hoverPanel or targetPanel).Hovered and targetPanel:GetDraggable() and mousey < (screenY + PIXEL.Scale(30)) then
		targetPanel:SetCursor("sizeall")
		return true
	end
end

function PANEL:SizeThink(targetPanel, hoverPanel)
	local scrw, scrh = ScrW(), ScrH()
	local mousex, mousey = math.Clamp(gui.MouseX(), 1, scrw - 1), math.Clamp(gui.MouseY(), 1, scrh - 1)

	if targetPanel.Sizing then
		local x = mousex - targetPanel.Sizing[1]
		local y = mousey - targetPanel.Sizing[2]
		local px, py = targetPanel:GetPos()

		local screenLock = self:GetScreenLock()
		if x < targetPanel.MinWidth then x = targetPanel.MinWidth elseif x > scrw - px and screenLock then x = scrw - px end
		if y < targetPanel.MinHeight then y = targetPanel.MinHeight elseif y > scrh - py and screenLock then y = scrh - py end

		targetPanel:SetSize(x, y)
		targetPanel:SetCursor("sizenwse")
		return true
	end

	local screenX, screenY = targetPanel:LocalToScreen(0, 0)
	if (hoverPanel or targetPanel).Hovered and targetPanel.Sizable and mousex > (screenX + targetPanel:GetWide() - PIXEL.Scale(20)) and mousey > (screenY + targetPanel:GetTall() - PIXEL.Scale(20)) then
		(hoverPanel or targetPanel):SetCursor("sizenwse")
		return true
	end
end

function PANEL:Think()
	if self:DragThink(self) then return end
	if self:SizeThink(self) then return end

	self:SetCursor("arrow")

	if self.y < 0 then
		self:SetPos(self.x, 0)
	end
end

function PANEL:OnMousePressed()
	local screenX, screenY = self:LocalToScreen(0, 0)
	local mouseX, mouseY = gui.MouseX(), gui.MouseY()

	if self.Sizable and mouseX > (screenX + self:GetWide() - PIXEL.Scale(30)) and mouseY > (screenY + self:GetTall() - PIXEL.Scale(30)) then
		self.Sizing = {mouseX - self:GetWide(), mouseY - self:GetTall()}
		self:MouseCapture(true)
		return
	end

	if self:GetDraggable() and mouseY < (screenY + PIXEL.Scale(30)) then
		self.Dragging = {mouseX - self.x, mouseY - self.y}
		self:MouseCapture(true)
		return
	end
end

function PANEL:OnMouseReleased()
	self.Dragging = nil
	self.Sizing = nil
	self:MouseCapture(false)
end

function PANEL:CreateSidebar(defaultItem, imgurID, imgurScale, imgurYOffset, buttonYOffset)
	if IsValid(self.SideBar) then return end
	self.SideBar = vgui.Create("PIXEL.Sidebar", self)

	if defaultItem then
		timer.Simple(0, function()
			if not IsValid(self.SideBar) then return end
			self.SideBar:SelectItem(defaultItem)
		end)
	end

	if imgurID then self.SideBar:SetImgurID(imgurID) end
	if imgurScale then self.SideBar:SetImgurScale(imgurScale) end
	if imgurYOffset then self.SideBar:SetImgurOffset(imgurYOffset) end
	if buttonYOffset then self.SideBar:SetButtonOffset(buttonYOffset) end

	return self.SideBar
end

function PANEL:AddHeaderButton(elem, size)
	elem.HeaderIconSize = size or .45
	return table.insert(self.ExtraButtons, elem)
end

function PANEL:LayoutContent(w, h) end

function PANEL:PerformLayout(w, h)
	local headerH = PIXEL.Scale(30)
	local btnPad = PIXEL.Scale(6)
	local btnSpacing = PIXEL.Scale(6)

	if IsValid(self.CloseButton) then
		local btnSize = headerH * .45
		self.CloseButton:SetSize(btnSize, btnSize)
		self.CloseButton:SetPos(w - btnSize - btnPad, (headerH - btnSize) / 2)

		btnPad = btnPad + btnSize + btnSpacing
	end

	for _, btn in ipairs(self.ExtraButtons) do
		local btnSize = headerH * btn.HeaderIconSize
		btn:SetSize(btnSize, btnSize)
		btn:SetPos(w - btnSize - btnPad, (headerH - btnSize) / 2)
		btnPad = btnPad + btnSize + btnSpacing
	end

	if IsValid(self.SideBar) then
		self.SideBar:SetPos(0, headerH)
		self.SideBar:SetSize(PIXEL.Scale(200), h - headerH)
	end

	local padding = PIXEL.Scale(6)
	self:DockPadding(self.SideBar and PIXEL.Scale(200) + padding or padding, headerH + padding, padding, padding)

	self:LayoutContent(w, h)
end

function PANEL:Open()
	self:SetAlpha(0)
	self:SetVisible(true)
	self:AlphaTo(255, .1, 0)
end

function PANEL:Close()
	self:AlphaTo(0, .1, 0, function(anim, pnl)
		if not IsValid(pnl) then return end
		pnl:SetVisible(false)
		pnl:OnClose()
		if pnl:GetRemoveOnClose() then pnl:Remove() end
	end)
end

function PANEL:OnClose() end

function PANEL:PaintHeader(x, y, w, h)
	PIXEL.DrawRoundedBoxEx(PIXEL.Scale(6), x, y, w, h, PIXEL.Colors.Header, true, true)

	local imgurID = self:GetImgurID()
	if imgurID then
		local iconSize = h * .6
		PIXEL.DrawImgur(PIXEL.Scale(6), x + (h - iconSize) / 2, y + iconSize, iconSize, imgurID, color_white)
		PIXEL.DrawSimpleText(self:GetTitle(), "UI.FrameTitle", x + PIXEL.Scale(12) + iconSize, y + h / 2, PIXEL.Colors.PrimaryText, nil, TEXT_ALIGN_CENTER)
		return
	end

	PIXEL.DrawSimpleText(self:GetTitle(), "UI.FrameTitle", x + PIXEL.Scale(6), y + h / 2, PIXEL.Colors.PrimaryText, nil, TEXT_ALIGN_CENTER)
end

function PANEL:Paint(w, h)
	PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, 0, w, h, PIXEL.Colors.Background)
	self:PaintHeader(0, 0, w, PIXEL.Scale(30))
end

vgui.Register("PIXEL.Frame", PANEL, "EditablePanel")

--addons/aocrp_pixelui/lua/pixelui/elements/cl_labelled_checkbox.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

function PANEL:Init()
    self.Checkbox = vgui.Create("PIXEL.Checkbox", self)

    self.Checkbox.OnToggled = function(s, enabled)
        self:OnToggled(enabled)
    end

    self.LabelHolder = vgui.Create("Panel", self)
    self.Label = vgui.Create("PIXEL.Label", self.LabelHolder)
    self.Label:SetAutoWidth(true)
    self.Label:SetAutoHeight(true)

    self.LabelHolder.PerformLayout = function(s, w, h)
        self.Label:CenterVertical()
        s:SizeToChildren(true, true)
        self:SizeToChildren(true, true)
    end
end

function PANEL:PerformLayout(w, h)
    self.Checkbox:Dock(LEFT)
    self.Checkbox:SetWide(h)
    self.Checkbox:DockMargin(0, 0, PIXEL.Scale(6), 0)

    self.LabelHolder:Dock(LEFT)
end

function PANEL:OnToggled(enabled) end

function PANEL:SetText(text) self.Label:SetText(text) end
function PANEL:GetText() return self.Label:GetText() end

function PANEL:SetFont(font) self.Label:SetFont(font) end
function PANEL:GetFont() return self.Label:GetFont() end

function PANEL:SetTextColor(col) self.Label:SetTextColor(col) end
function PANEL:GetTextColor() return self.Label:GetTextColor() end

function PANEL:SetAutoWrap(enabled) self.Label:SetAutoWrap(enabled) end
function PANEL:GetAutoWrap() return self.Label:GetAutoWrap() end

vgui.Register("PIXEL.LabelledCheckbox", PANEL, "Panel")
--addons/aocrp_pixelui/lua/pixelui/elements/cl_navbar.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

AccessorFunc(PANEL, "Name", "Name", FORCE_STRING)
AccessorFunc(PANEL, "Color", "Color")

PIXEL.RegisterFont("UI.NavbarItem", "Open Sans SemiBold", 22)

function PANEL:Init()
    self:SetName("N/A")
    self:SetColor(PIXEL.Colors.Primary)

    self.NormalCol = PIXEL.Colors.PrimaryText
    self.HoverCol = PIXEL.Colors.SecondaryText

    self.TextCol = PIXEL.CopyColor(self.NormalCol)
end

function PANEL:GetItemSize()
    PIXEL.SetFont("UI.NavbarItem")
    return PIXEL.GetTextSize(self:GetName())
end

function PANEL:Paint(w, h)
    local textCol = self.NormalCol

    if self:IsHovered() then
        textCol = self.HoverCol
    end

    local animTime = FrameTime() * 12
    self.TextCol = PIXEL.LerpColor(animTime, self.TextCol, textCol)

    PIXEL.DrawSimpleText(self:GetName(), "UI.NavbarItem", w / 2, h / 2, self.TextCol, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end

vgui.Register("PIXEL.NavbarItem", PANEL, "PIXEL.Button")

PANEL = {}

function PANEL:Init()
    self.Items = {}

    self.SelectionX = 0
    self.SelectionW = 0
    self.SelectionColor = Color(0, 0, 0)

    self.BackgroundCol = PIXEL.OffsetColor(PIXEL.Colors.Background, 10)
end

function PANEL:AddItem(id, name, doClick, order, color)
    local btn = vgui.Create("PIXEL.NavbarItem", self)

    btn:SetName(name:upper())
    btn:SetZPos(order or table.Count(self.Items) + 1)
    btn:SetColor((IsColor(color) and color) or PIXEL.Colors.Primary)
    btn.Function = doClick

    btn.DoClick = function(s)
        self:SelectItem(id)
    end

    self.Items[id] = btn
end

function PANEL:RemoveItem(id)
    local item = self.Items[id]
    if not item then return end

    item:Remove()
    self.Items[id] = nil

    if self.SelectedItem != id then return end
    self:SelectItem(next(self.Items))
end

function PANEL:SelectItem(id)
    local item = self.Items[id]
    if not item then return end

    if self.SelectedItem and self.SelectedItem == id then return end
    self.SelectedItem = id

    for k,v in pairs(self.Items) do
        v:SetToggle(false)
    end

    item:SetToggle(true)
    item.Function(item)
end

function PANEL:PerformLayout(w, h)
    for k,v in pairs(self.Items) do
        v:Dock(LEFT)
        v:SetWide(v:GetItemSize() + PIXEL.Scale(30))
    end
end

function PANEL:Paint(w, h)
    surface.SetDrawColor(self.BackgroundCol)
    surface.DrawRect(0, 0, w, h)

    if not self.SelectedItem then
        self.SelectionX = Lerp(FrameTime() * 10, self.SelectionX, 0)
        self.SelectionW = Lerp(FrameTime() * 10, self.SelectionX, 0)
        self.SelectionColor = PIXEL.LerpColor(FrameTime() * 10, self.SelectionColor, PIXEL.Colors.Primary)
        return
    end

    local selectedItem = self.Items[self.SelectedItem]
    self.SelectionX = Lerp(FrameTime() * 10, self.SelectionX, selectedItem.x)
    self.SelectionW = Lerp(FrameTime() * 10, self.SelectionW, selectedItem:GetWide())
    self.SelectionColor = PIXEL.LerpColor(FrameTime() * 10, self.SelectionColor, selectedItem:GetColor())

    local selectorH = PIXEL.Scale(6)
    surface.SetDrawColor(self.SelectionColor)
    surface.DrawRect(self.SelectionX + 2, h - selectorH, self.SelectionW - 4, selectorH / 2)
end

vgui.Register("PIXEL.Navbar", PANEL, "Panel")
--addons/aocrp_pixelui/lua/pixelui/menus/cl_query_popup.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

AccessorFunc(PANEL, "Text", "Text", FORCE_STRING)
AccessorFunc(PANEL, "ButtonText", "ButtonText", FORCE_STRING)

PIXEL.RegisterFont("UI.Message", "Open Sans SemiBold", 18)

function PANEL:Init()
    self:SetDraggable(true)
    self:SetSizable(true)

    self:SetMinWidth(PIXEL.Scale(240))
    self:SetMinHeight(PIXEL.Scale(80))

    self.Message = vgui.Create("PIXEL.Label", self)
    self.Message:SetTextAlign(TEXT_ALIGN_CENTER)
    self.Message:SetFont("UI.Message")

    self.BottomPanel = vgui.Create("Panel", self)
    self.ButtonHolder = vgui.Create("Panel", self.BottomPanel)

    self.Buttons = {}
end

function PANEL:AddOption(name, callback)
    callback = callback or function() end

    local btn = vgui.Create("PIXEL.TextButton", self.ButtonHolder)
    btn:SetText(name)
    btn.DoClick = function()
        self:Close(true)
        callback()
    end
    table.insert(self.Buttons, btn)
end

function PANEL:LayoutContent(w, h)
    self.Message:SetSize(self.Message:CalculateSize())
    self.Message:Dock(TOP)
    self.Message:DockMargin(0, 0, 0, PIXEL.Scale(8))

    for k,v in ipairs(self.Buttons) do
        v:SizeToText()
        v:Dock(LEFT)
        v:DockMargin(PIXEL.Scale(4), 0, PIXEL.Scale(4), 0)
    end

    self.ButtonHolder:SizeToChildren(true)

    local firstBtn = self.Buttons[1]

    self.BottomPanel:Dock(TOP)
    self.BottomPanel:SetTall(firstBtn:GetTall())
    self.ButtonHolder:SetTall(firstBtn:GetTall())

    self.ButtonHolder:CenterHorizontal()

    if self.ButtonHolder:GetWide() < firstBtn:GetWide() then
        self.ButtonHolder:SetWide(firstBtn:GetWide())
    end

    if self.BottomPanel:GetWide() < self.ButtonHolder:GetWide() then
        self.BottomPanel:SetWide(self.ButtonHolder:GetWide())
    end

    if self:GetWide() < PIXEL.Scale(240) then
        self:SetWide(240)
        self:Center()
    end

    if self.HasSized and self.HasSized > 1 then return end
    self.HasSized = (self.HasSized or 0) + 1

    self:SizeToChildren(true, true)
    self:Center()
end

function PANEL:SetText(text) self.Message:SetText(text) end
function PANEL:GetText(text) return self.Message:GetText() end

vgui.Register("PIXEL.Query", PANEL, "PIXEL.Frame")

PIXEL.UI.Overrides.Derma_Query = PIXEL.UI.Overrides.Derma_Query or Derma_Query

Derma_Query = PIXEL.UI.CreateToggleableOverride(PIXEL.UI.Overrides.Derma_Query, function(text, title, ...)
    local msg = vgui.Create("PIXEL.Query")
    msg:SetTitle(title)
    msg:SetText(text)

    local args = {...}
    for i = 1, #args, 2 do
        msg:AddOption(args[i], args[i + 1])
    end

    msg:MakePopup()
    msg:DoModal()

    return msg
end, PIXEL.UI.ShouldOverrideDermaPopups)
--lua/autorun/starwars17654457.lua:
player_manager.AddValidModel( "ewoks", "models/ewoks.mdl" );
list.Set( "PlayerOptionsModel", "ewoks", "models/ewoks.mdl" );
player_manager.AddValidModel( "stalker_doc", "models/stalker_doc.mdl" );
list.Set( "PlayerOptionsModel", "stalker_doc", "models/stalker_doc.mdl" );
player_manager.AddValidHands( "ewoks", "models/ewok_arm.mdl", 0, "0000000" )
--addons/sse_101/lua/sse/cl_imgui.lua:
local imgui = {}

imgui.skin = {
	background = Color(0, 0, 0, 0),
	backgroundHover = Color(0, 0, 0, 0),

	border = Color(255, 255, 255),
	borderHover = Color(255, 127, 0),
	borderPress = Color(255, 80, 0),

	foreground = Color(255, 255, 255),
	foregroundHover = Color(255, 127, 0),
	foregroundPress = Color(255, 80, 0),
}

local devCvar = GetConVar("developer")
function imgui.IsDeveloperMode()
	return not imgui.DisableDeveloperMode and devCvar:GetInt() > 0
end

local _devMode = false -- cached local variable updated once in a while

function imgui.Hook(name, id, callback)
	local hookUniqifier = "SSEnt"
	hook.Add(name, "IMGUI / " .. id .. " / " .. hookUniqifier, callback)
end

local localPlayer
local gState = {}

local function shouldAcceptInput()
	-- don't process input during non-main renderpass
	if render.GetRenderTarget() ~= nil then
		return false
	end

	-- don't process input if we're doing VGUI stuff (and not in context menu)
	if vgui.CursorVisible() and vgui.GetHoveredPanel() ~= g_ContextMenu then
		return false
	end

	return true
end

imgui.Hook("PreRender", "Input", function()
	-- calculate mouse state
	if shouldAcceptInput() then
		local useBind = input.LookupBinding("+use", true)
		local attackBind = input.LookupBinding("+attack", true)
		local USE = useBind and input.GetKeyCode(useBind)
		local ATTACK = attackBind and input.GetKeyCode(attackBind)

		local wasPressing = gState.pressing
		gState.pressing = (USE and input.IsButtonDown(USE)) or (ATTACK and input.IsButtonDown(ATTACK))
		gState.pressed = not wasPressing and gState.pressing
	end
end)

hook.Add("NotifyShouldTransmit", "IMGUI / ClearRenderBounds", function(ent, shouldTransmit)
	if shouldTransmit and ent._imguiRBExpansion then
		ent._imguiRBExpansion = nil
	end
end)

local traceResultTable = {}
local traceQueryTable = { output = traceResultTable, filter = {} }
local function isObstructed(eyePos, hitPos, ignoredEntity)
	local q = traceQueryTable
	q.start = eyePos
	q.endpos = hitPos
	q.filter[1] = localPlayer
	q.filter[2] = ignoredEntity

	local tr = util.TraceLine(q)
	if tr.Hit then
		return true, tr.Entity
	else
		return false
	end
end

function imgui.Start3D2D(pos, angles, scale, distanceHide, distanceFadeStart)
	if not IsValid(localPlayer) then
		localPlayer = LocalPlayer()
	end

	if gState.shutdown == true then
		return
	end

	if gState.rendering == true then
		print(
			"[IMGUI] Starting a new IMGUI context when previous one is still rendering" ..
			"Shutting down rendering pipeline to prevent crashes.."
		)
		gState.shutdown = true
		return false
	end

	_devMode = imgui.IsDeveloperMode()

	local eyePos = localPlayer:EyePos()
	local eyePosToPos = pos - eyePos

	-- OPTIMIZATION: Test that we are in front of the UI
	do
		local normal = angles:Up()
		local dot = eyePosToPos:Dot(normal)

		if _devMode then gState._devDot = dot end

		-- since normal is pointing away from surface towards viewer, dot<0 is visible
		if dot >= 0 then
			return false
		end
	end

	-- OPTIMIZATION: Distance based fade/hide
	if distanceHide then
		local distance = eyePosToPos:Length()
		if distance > distanceHide then
			return false
		end

		if _devMode then
			gState._devDist = distance
			gState._devHideDist = distanceHide
		end

		if distanceHide and distanceFadeStart and distance > distanceFadeStart then
			local blend = math.min(math.Remap(distance, distanceFadeStart, distanceHide, 1, 0), 1)
			render.SetBlend(blend)
			surface.SetAlphaMultiplier(blend)
		end
	end

	gState.rendering = true
	gState.pos = pos
	gState.angles = angles
	gState.scale = scale

	cam.Start3D2D(pos, angles, scale)

	-- calculate mousepos
	if not vgui.CursorVisible() or vgui.IsHoveringWorld() then
		local tr = localPlayer:GetEyeTrace()
		local eyepos = tr.StartPos
		local eyenormal

		if vgui.CursorVisible() and vgui.IsHoveringWorld() then
			eyenormal = gui.ScreenToVector(gui.MousePos())
		else
			eyenormal = tr.Normal
		end

		local planeNormal = angles:Up()

		local hitPos = util.IntersectRayWithPlane(eyepos, eyenormal, pos, planeNormal)
		if hitPos then
			local obstructed, obstructer = isObstructed(eyepos, hitPos, gState.entity)
			if obstructed then
				gState.mx = nil
				gState.my = nil

				if _devMode then gState._devInputBlocker = "collision " .. obstructer:GetClass() .. "/" .. obstructer:EntIndex() end
			else
				local diff = pos - hitPos

				-- This cool code is from Willox's keypad CalculateCursorPos
				local x = diff:Dot(-angles:Forward()) / scale
				local y = diff:Dot(-angles:Right()) / scale

				gState.mx = x
				gState.my = y
			end
		else
			gState.mx = nil
			gState.my = nil

			if _devMode then gState._devInputBlocker = "not looking at plane" end
		end
	else
		gState.mx = nil
		gState.my = nil

		if _devMode then gState._devInputBlocker = "not hovering world" end
	end

	if _devMode then gState._renderStarted = SysTime() end

	return true
end

function imgui.Entity3D2D(ent, lpos, lang, scale, ...)
	gState.entity = ent
	local ret = imgui.Start3D2D(ent:LocalToWorld(lpos), ent:LocalToWorldAngles(lang), scale, ...)
	if not ret then
		gState.entity = nil
	end
	return ret
end

local function calculateRenderBounds(x, y, w, h)
	local pos = gState.pos
	local fwd, right = gState.angles:Forward(), gState.angles:Right()
	local scale = gState.scale
	local firstCorner, secondCorner =
		pos + fwd * x * scale + right * y * scale,
		pos + fwd * (x + w) * scale + right * (y + h) * scale

	local minrb, maxrb = Vector(math.huge, math.huge, math.huge), Vector(-math.huge, -math.huge, -math.huge)

	minrb.x = math.min(minrb.x, firstCorner.x, secondCorner.x)
	minrb.y = math.min(minrb.y, firstCorner.y, secondCorner.y)
	minrb.z = math.min(minrb.z, firstCorner.z, secondCorner.z)
	maxrb.x = math.max(maxrb.x, firstCorner.x, secondCorner.x)
	maxrb.y = math.max(maxrb.y, firstCorner.y, secondCorner.y)
	maxrb.z = math.max(maxrb.z, firstCorner.z, secondCorner.z)

	return minrb, maxrb
end

function imgui.ExpandRenderBoundsFromRect(x, y, w, h)
	local ent = gState.entity
	if IsValid(ent) then
		-- make sure we're not applying same expansion twice
		local expansion = ent._imguiRBExpansion
		if expansion then
			local ex, ey, ew, eh = unpack(expansion)
			if ex == x and ey == y and ew == w and eh == h then
				return
			end
		end

		local minrb, maxrb = calculateRenderBounds(x, y, w, h)

		ent:SetRenderBoundsWS(minrb, maxrb)
		if _devMode then
			print("[IMGUI] Updated renderbounds of ", ent, " to ", minrb, "x", maxrb)
		end

		ent._imguiRBExpansion = {x, y, w, h}
	else
		if _devMode then
			print("[IMGUI] Attempted to update renderbounds when entity is not valid!! ", debug.traceback())
		end
	end
end

local devOffset = Vector(0, 0, 30)
local devColours = {
	background = Color(0, 0, 0, 200),
	title = Color(78, 205, 196),
	mouseHovered = Color(0, 255, 0),
	mouseUnhovered = Color(255, 0, 0),
	pos = Color(255, 255, 255),
	distance = Color(200, 200, 200, 200),
	ang = Color(255, 255, 255),
	dot = Color(200, 200, 200, 200),
	angleToEye = Color(200, 200, 200, 200),
	renderTime = Color(255, 255, 255),
	renderBounds = Color(0, 0, 255)
}

local function developerText(str, x, y, clr)
	draw.SimpleText(
		str, "DefaultFixedDropShadow", x, y, clr, TEXT_ALIGN_CENTER, nil
	)
end

local function drawDeveloperInfo()
	local camAng = localPlayer:EyeAngles()
	camAng:RotateAroundAxis(camAng:Right(), 90)
	camAng:RotateAroundAxis(camAng:Up(), -90)

	cam.IgnoreZ(true)
	cam.Start3D2D(gState.pos + devOffset, camAng, 0.15)

	local bgCol = devColours["background"]
	surface.SetDrawColor(bgCol.r, bgCol.g, bgCol.b, bgCol.a)
	surface.DrawRect(-100, 0, 200, 140)

	local titleCol = devColours["title"]
	developerText("imgui developer", 0, 5, titleCol)

	surface.SetDrawColor(titleCol.r, titleCol.g, titleCol.b)
	surface.DrawLine(-50, 16, 50, 16)

	local mx, my = gState.mx, gState.my
	if mx and my then
		developerText(
			string.format("mouse: hovering %d x %d", mx, my),
			0, 20, devColours["mouseHovered"]
		)
	else
		developerText(
			string.format("mouse: %s", gState._devInputBlocker or ""),
			0, 20, devColours["mouseUnhovered"]
		)
	end

	local pos = gState.pos
	developerText(
		string.format("pos: %.2f %.2f %.2f", pos.x, pos.y, pos.z),
		0, 40, devColours["pos"]
	)

	developerText(
		string.format("distance %.2f / %.2f", gState._devDist or 0, gState._devHideDist or 0),
		0, 53, devColours["distance"]
	)

	local ang = gState.angles
	developerText(string.format("ang: %.2f %.2f %.2f", ang.p, ang.y, ang.r), 0, 75, devColours["ang"])
	developerText(string.format("dot %d", gState._devDot or 0), 0, 88, devColours["dot"])

	local angToEye = (pos - localPlayer:EyePos()):Angle()
	angToEye:RotateAroundAxis(ang:Up(), -90)
	angToEye:RotateAroundAxis(ang:Right(), 90)

	developerText(
		string.format("angle to eye (%d,%d,%d)", angToEye.p, angToEye.y, angToEye.r),
		0, 100, devColours["angleToEye"]
	)

	developerText(
		string.format("rendertime avg: %.2fms", (gState._devBenchAveraged or 0) * 1000),
		0, 120, devColours["renderTime"]
	)

	cam.End3D2D()
	cam.IgnoreZ(false)

	local ent = gState.entity
	if IsValid(ent) and ent._imguiRBExpansion then
		local ex, ey, ew, eh = unpack(ent._imguiRBExpansion)
		local minrb, maxrb = calculateRenderBounds(ex, ey, ew, eh)
		render.DrawWireframeBox(vector_origin, angle_zero, minrb, maxrb, devColours["renderBounds"])
	end
end

function imgui.End3D2D()
	if gState then
		if _devMode then
			local renderTook = SysTime() - gState._renderStarted
			gState._devBenchTests = (gState._devBenchTests or 0) + 1
			gState._devBenchTaken = (gState._devBenchTaken or 0) + renderTook
			if gState._devBenchTests == 100 then
				gState._devBenchAveraged = gState._devBenchTaken / 100
				gState._devBenchTests = 0
				gState._devBenchTaken = 0
			end
		end

		gState.rendering = false
		cam.End3D2D()
		render.SetBlend(1)
		surface.SetAlphaMultiplier(1)

		if _devMode then
			drawDeveloperInfo()
		end

		gState.entity = nil
	end
end

function imgui.CursorPos()
	local mx, my = gState.mx, gState.my
	return mx, my
end

function imgui.IsHovering(x, y, w, h)
	local mx, my = gState.mx, gState.my
	return mx and my and mx >= x and mx <= (x + w) and my >= y and my <= (y + h)
end
function imgui.IsPressing()
	return shouldAcceptInput() and gState.pressing
end
function imgui.IsPressed()
	return shouldAcceptInput() and gState.pressed
end

-- String->Bool mappings for whether font has been created
local _createdFonts = {}

-- Cached IMGUIFontNamd->GModFontName
local _imguiFontToGmodFont = {}



local EXCLAMATION_BYTE = string.byte("!")
function imgui.xFont(font, defaultSize)
	-- special font
	if string.byte(font, 1) == EXCLAMATION_BYTE then

		local existingGFont = _imguiFontToGmodFont[font]
		if existingGFont then
			return existingGFont
		end

		-- Font not cached; parse the font
		local name, size = font:match("!([^@]+)@(.+)")
		if size then size = tonumber(size) end

		if not size and defaultSize then
			name = font:match("^!([^@]+)$")
			size = defaultSize
		end

		local fontName = string.format("IMGUI_%s_%d", name, size)
		_imguiFontToGmodFont[font] = fontName
		if not _createdFonts[fontName] then
			surface.CreateFont(fontName, {
				font = name,
				size = size
			})
			_createdFonts[fontName] = true
		end

		return fontName
	end
	return font
end

function imgui.xButton(x, y, w, h, borderWidth, borderClr, hoverClr, pressColor)
	local bw = borderWidth or 1

	local bgColor = imgui.IsHovering(x, y, w, h) and imgui.skin.backgroundHover or imgui.skin.background
	local borderColor =
		((imgui.IsPressing() and imgui.IsHovering(x, y, w, h)) and (pressColor or imgui.skin.borderPress))
		or (imgui.IsHovering(x, y, w, h) and (hoverClr or imgui.skin.borderHover))
		or (borderClr or imgui.skin.border)

	surface.SetDrawColor(bgColor)
	surface.DrawRect(x, y, w, h)

	if bw > 0 then
		surface.SetDrawColor(borderColor)

		surface.DrawRect(x, y, w, bw)
		surface.DrawRect(x, y + bw, bw, h - bw * 2)
		surface.DrawRect(x, y + h-bw, w, bw)
		surface.DrawRect(x + w - bw + 1, y, bw, h)
	end

	return shouldAcceptInput() and imgui.IsHovering(x, y, w, h) and gState.pressed
end

function imgui.xCursor(x, y, w, h)
	local fgColor = imgui.IsPressing() and imgui.skin.foregroundPress or imgui.skin.foreground
	local mx, my = gState.mx, gState.my

	if not mx or not my then return end

	if x and w and (mx < x or mx > x + w) then return end
	if y and h and (my < y or my > y + h) then return end

	local cursorSize = math.ceil(0.3 / gState.scale)
	surface.SetDrawColor(fgColor)
	surface.DrawLine(mx - cursorSize, my, mx + cursorSize, my)
	surface.DrawLine(mx, my - cursorSize, mx, my + cursorSize)
end

function imgui.xTextButton(text, font, x, y, w, h, borderWidth, color, hoverClr, pressColor)
	local fgColor =
		((imgui.IsPressing() and imgui.IsHovering(x, y, w, h)) and (pressColor or imgui.skin.foregroundPress))
		or (imgui.IsHovering(x, y, w, h) and (hoverClr or imgui.skin.foregroundHover))
		or (color or imgui.skin.foreground)

	local clicked = imgui.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)

	font = imgui.xFont(font, math.floor(h * 0.618))
	draw.SimpleText(text, font, x + w / 2, y + h / 2, fgColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

	return clicked
end

return imgui
--addons/star_wars_mortar/lua/autorun/swm_mortar_runner.lua:
if (SERVER) then
    resource.AddFile("resource/fonts/UbuntuMono-Regular.ttf")

    timer.Simple(10, function ()
        if (istable(repairDatabase)) then
            repairDatabase["mortar"] = function (fc, mortar)
                if (mortar:Health() < mortar:GetMaxHealth()) then
                    local newHealth = mortar:Health() + 50
                    if (newHealth <= mortar:GetMaxHealth()) then
                        mortar:SetHealth(newHealth)
                    else
                        mortar:SetHealth(mortar:GetMaxHealth())
                    end
                    return true
                end
                return false
            end
        end
    end)
end

hook.Add("CalcMainActivity", "SWMortarSeatAnimOverride", function (ply, vel)
    local seat = ply:GetVehicle()

    if (not IsValid(seat) or not IsValid(seat:GetParent()) or seat:GetParent():GetClass() ~= "mortar") then return end

    ply.CalcIdeal = ACT_CROUCH
    ply.CalcSeqOverride = ply:LookupSequence("pose_ducking_01")

    return ply.CalcIdeal, ply.CalcSeqOverride
end)

hook.Add("CalcView", "SWMortarCalcViewMortarSeat", function (ply, pos, angles, fov)
    local seat = LocalPlayer():GetVehicle()
    if (IsValid(seat) and IsValid(seat:GetParent()) and seat:GetParent():GetClass() == "mortar") then
        local view = {
            origin = pos + angles:Up() * 50 - angles:Forward() * 100,
            angles = angles,
            fov = fov,
            drawviewer = true
        }

        return view
    end
end)

local visorMaterial = Material("models/dolunity/starwars/visor-final.png")
hook.Add("HUDPaint", "SWMortarHUD", function ()
    local seat = LocalPlayer():GetVehicle()
    if (IsValid(seat) and IsValid(seat:GetParent()) and seat:GetParent():GetClass() == "mortar") then
        local mortar = seat:GetParent()
        local barrelId = mortar:LookupBone("Barrel")
        local barrelAngle = mortar:GetManipulateBoneAngles(barrelId) + Angle(rot,0,ang)
        barrelAngle.z = math.Clamp(barrelAngle.z, mortar.AnglingMin, mortar.AnglingMax)

        surface.SetDrawColor(255,255,255)
        surface.SetMaterial(visorMaterial)
        local height = ScrH() * 0.25
        local width = height * 1.27
        surface.DrawTexturedRect((ScrW() - width) / 2, ScrH() - height * 0.9, width, height)

        surface.SetFont("swmFont")
        surface.SetTextColor(255, 255, 255)
        local rText
        local bax = math.abs((barrelAngle.x + mortar:GetLocalAngles().y) % 360 - 360)
        if (math.Round(bax, 2) >= 0) then
            rText = "R   >  " .. math.Round(bax, 2) .. "°"
        else
            rText = "R   >  " .. math.Round(bax, 2) .. "°"
        end
        local rWidth, rHeight = surface.GetTextSize(rText)
        surface.SetTextPos((ScrW() - width) / 2 + width * 0.1, ScrH() - height + rHeight + height * 0.11)
        surface.DrawText(rText)
        local aText = "Mil >  " .. (math.abs(math.Round(barrelAngle.z, 2) - mortar.AnglingMax) * 25 + 800)
        local aWidth, aHeight = surface.GetTextSize(aText)
        surface.SetTextPos((ScrW() - width) / 2 + width * 0.1, ScrH() - height + rHeight + aHeight + height * 0.16)
        surface.DrawText(aText)
        local sText = "Amm >  " .. table.GetKeys(mortar.ShellClasses)[mortar:GetShellClassId()]
        local sWidth, sHeight = surface.GetTextSize(aText)
        surface.SetTextPos((ScrW() - width) / 2 + width * 0.1, ScrH() - height + rHeight + aHeight + sHeight + height * 0.21)
        surface.DrawText(sText)

        local fPosX = (ScrW() - width) / 2 + width * 0.72
        local fPosY = ScrH() - height + height * 0.23
        if (mortar:GetNextFire() > CurTime()) then
            surface.SetDrawColor(100,0,0,255)
        else
            surface.SetDrawColor(255,0,0,255)
        end
        draw.NoTexture()
        surface.DrawPoly({
            {x = fPosX + 0,y = fPosY + 100},
            {x = fPosX + 30,y = fPosY + 0},
            {x = fPosX + 60,y = fPosY + 100}
        })

        draw.RoundedBox(0,(ScrW() - width) / 2 + width * 0.1, ScrH() - height * 0.375, width * 0.8, height * 0.02, Color(50,100,255, 50))
        draw.RoundedBox(0,(ScrW() - width) / 2 + width * 0.1, ScrH() - height * 0.375, width * 0.8 * (math.max(mortar:Health(), 0) / mortar:GetMaxHealth()), height * 0.02, Color(0,75,255))
    end
end)

if (CLIENT) then
    surface.CreateFont("swmFont", {
        font = "Ubuntu Mono", --  Use the font-name which is shown to you by your operating system Font Viewer, not the file name
        extended = false,
        size = 28,
        weight = 500,
        blursize = 0,
        scanlines = 0,
        antialias = true,
    })
end

--lua/autorun/venator_border_toggle.lua:
// Created by Airfox aka. Konsti
// Huge thanks to him!

if game.GetMap() ~= "rp_venator_extensive_v1_4" then return end

local nextTick = nextTick or 0
local material = Material("kingpommes/map_borders/red_opacity3")
local defaultTexture = "kingpommes/map_borders/red_opacity3"
local invisibleTexture = "kingpommes/starwars/venator/invis"
local borderVisible = true
material:SetTexture("$basetexture", defaultTexture)

if SERVER then
	util.AddNetworkString("Venator_Ext_BorderNet")

	-- Networks current state to every new player that joins the server.
	hook.Add("PlayerInitialSpawn", "Venator_Ext_BorderConnectSync", function(ply)
		net.Start("Venator_Ext_BorderNet")
			net.WriteBool(borderVisible)
		net.Send(ply)
	end)
end

hook.Add("Think", "Venator_Ext_BorderThink", function()
	if nextTick > CurTime() then return end

	nextTick = CurTime() + 1
	
	if SERVER then
		-- Finds all entities with this name.
		local entities = ents.FindByName("border_target")

		-- Checks if an entity has been found and alarm is on. Also if the network has already been sent.
		if #entities >= 1 and borderVisible then
			borderVisible = false
			net.Start("Venator_Ext_BorderNet")
				net.WriteBool(borderVisible)
			net.Broadcast()
			
			if material:GetTexture("$basetexture"):GetName() == defaultTexture then
				material:SetTexture("$basetexture", invisibleTexture)
			end
		elseif #entities == 0 and not borderVisible then
			borderVisible = true
			net.Start("Venator_Ext_BorderNet")
				net.WriteBool(borderVisible)
			net.Broadcast()

			if material:GetTexture("$basetexture"):GetName() == invisibleTexture then
				material:SetTexture("$basetexture", defaultTexture)
			end
		end
	elseif CLIENT then
		-- Checks if alarm is on. 
		if not borderVisible then
			-- Changes between textured.
			if material:GetTexture("$basetexture"):GetName() == defaultTexture then
				material:SetTexture("$basetexture", invisibleTexture)
			end
		else
			-- Resets the texture to default, when the border should be visible.
			if material:GetTexture("$basetexture"):GetName() == invisibleTexture then
				material:SetTexture("$basetexture", defaultTexture)
			end
		end
	end
end)

if CLIENT then
	-- Receives current state.
	net.Receive("Venator_Ext_BorderNet", function(len)
		borderVisible = net.ReadBool()
	end)
end
--lua/autorun/venator_visual_alarm.lua:
// Created by Airfox aka. Konsti
// Huge thanks to him!

if game.GetMap() ~= "rp_venator_extensive_v1_4" then return end

-- Set default values (thats why it also resists a lua refresh)
local nextTick = 0

local materialWallLamp = Material("kingpommes/starwars/venator/corridor_wall_lamps")
local materialCorridorLamp = Material("kingpommes/starwars/venator/corridor_lights")
local materialCorridorLampb = Material("kingpommes/starwars/venator/corridor_lightsb")
local materialLightDecal = Material("kingpommes/starwars/venator/lights_decal")

local defaultTextureWallLamp = "kingpommes/starwars/venator/corridor_wall_lamps"
local defaultTextureCorridorLamp = "kingpommes/starwars/venator/corridor_lights"
local defaultTextureCorridorLampb = "kingpommes/starwars/venator/corridor_lightsb"
local defaultTextureLightDecal = "kingpommes/starwars/venator/lights_decal"

local redAlarmTextureWallLamp = "kingpommes/starwars/venator/corridor_wall_lamps_red"
local redAlarmTextureCorridorLamp = "kingpommes/starwars/venator/corridor_lights_red"
local redAlarmTextureCorridorLampb = "kingpommes/starwars/venator/corridor_lightsb_red"
local redAlarmTextureLightDecal = "kingpommes/starwars/venator/lights_decal_red"

local alarmOn = false
local networkSend = false

materialWallLamp:SetTexture("$basetexture", defaultTextureWallLamp)
materialCorridorLamp:SetTexture("$basetexture", defaultTextureCorridorLamp)
materialCorridorLampb:SetTexture("$basetexture", defaultTextureCorridorLampb) 
materialLightDecal:SetTexture("$basetexture", defaultTextureLightDecal)

if SERVER then
	util.AddNetworkString("Venator_Ext_AlarmNet")

	-- Networks current alarm state to every new player that joins the server.
	hook.Add("PlayerInitialSpawn", "Venator_Ext_AlarmConnectSync", function(ply)
		net.Start("Venator_Ext_AlarmNet")
			net.WriteBool(alarmOn)
		net.Send(ply)
	end)
end

function EnableVisualAlarm()
	net.Start("Venator_Ext_AlarmNet")
	net.WriteBool(true)
	net.Broadcast()
	
	alarmOn = true
	networkSend = true
end

function DisableVisualAlarm()
	net.Start("Venator_Ext_AlarmNet")
	net.WriteBool(false)
	net.Broadcast()
	networkSend = false
	alarmOn = false
end

hook.Add("Think", "Venator_Ext_AlarmThink", function()
	if CurTime() > nextTick then
		nextTick = CurTime() + 0.56
		
		-- Checks if alarm is on.
		if CLIENT and alarmOn then
			-- Changes between textured.
			if materialWallLamp:GetTexture("$basetexture"):GetName() == defaultTextureWallLamp then
				materialWallLamp:SetTexture("$basetexture", redAlarmTextureWallLamp)
				materialCorridorLamp:SetTexture("$basetexture", redAlarmTextureCorridorLamp)
				materialCorridorLampb:SetTexture("$basetexture", redAlarmTextureCorridorLampb) 
				materialLightDecal:SetTexture("$basetexture", redAlarmTextureLightDecal)
				
			elseif materialWallLamp:GetTexture("$basetexture"):GetName() == redAlarmTextureWallLamp then
				materialWallLamp:SetTexture("$basetexture", defaultTextureWallLamp)
				materialCorridorLamp:SetTexture("$basetexture", defaultTextureCorridorLamp)
				materialCorridorLampb:SetTexture("$basetexture", defaultTextureCorridorLampb) 
				materialLightDecal:SetTexture("$basetexture", defaultTextureLightDecal)
			end
		elseif CLIENT and not alarmOn then
			-- If the alarm is off and texture is not resetted, reset it.
			if materialWallLamp:GetTexture("$basetexture"):GetName() == redAlarmTextureWallLamp then
				materialWallLamp:SetTexture("$basetexture", defaultTextureWallLamp)
				materialCorridorLamp:SetTexture("$basetexture", defaultTextureCorridorLamp)
				materialCorridorLampb:SetTexture("$basetexture", defaultTextureCorridorLampb) 
				materialLightDecal:SetTexture("$basetexture", defaultTextureLightDecal)
			end
		end
	end
end)

hook.Add("PostCleanupMap", "Venator_Ext_AlarmCleanup", function()
	alarmOn = false
end)

if CLIENT then
	-- Receives current alarm state.
	net.Receive("Venator_Ext_AlarmNet", function(len)
		alarmOn = net.ReadBool()
	end)
end
--addons/vyhub-gmod/lua/vyhub/client/cl_chattag.lua:
local f = string.format

local color_red = Color(255, 0, 0)

if VyHub.Config.chat_tags and not DarkRP then
	hook.Add("OnPlayerChat", "vyhub_chattag_OnPlayerChat", function(ply, msg)
		if IsValid(ply) then
			local group = VyHub.Group:get(ply:GetUserGroup())

			if group then
				local teamcolor = team.GetColor(ply:Team())
				local deadTag = ""

				if not ply:Alive() then
					deadTag = f("*%s* ", VyHub.lang.other.dead)
				end

				chat.AddText(VyHub.Util:hex2rgb(group.color), "[", group.name, "]", " ", color_red, deadTag, teamcolor, ply:Nick(), color_white, ": ", msg)

				return true
			end
		end
	end)
end
--addons/vyhub-gmod/lua/vyhub/client/cl_ply.lua:
local meta_ply = FindMetaTable("Player")

VyHub.user_id = VyHub.user_id or nil

function meta_ply:VyHubID()
    if IsValid(self) then
        if self == LocalPlayer() then        
            return VyHub.user_id
        else
            MsgN("ERROR: Cannot get VyHubID of other users on the client side.")
        end
    end
end

net.Receive("vyhub_user_id", function ()
    VyHub.user_id = net.ReadString()
end)

--lua/wos/anim_extension/extensions/wos_bs.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Blade Symphony" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted animation extension: Blade Symphony\n" )
--lua/wos/anim_extension/holdtypes/g_restart.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "g_restart"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "restart_base_layer" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "restart_base_layer" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "wos_judge_a_idle"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--lua/wos/anim_extension/holdtypes/slashdown.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "slashdown"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "slashdown" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "slashdown" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--lua/wos/anim_extension/holdtypes/slashready.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "slashready"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "slashready" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "slashready" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--addons/z_anticrash_v1.4.6/lua/z_anticrash/languages/de.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

local de = {
	
	-- Stats
	lag = "LAG",
	collisions = "ZUSAMMENSTÖßE",
	props = "PROPS",
	propsFrozen = "GEFRORENE PROPS",
	npcs = "NPCS",
	vehicles = "FAHRZEUGE",
	players = "SPIELER",
	uptime = "UPTIME",
	entities = "ENTITIES",
	spawned = "GESPAWNT",
	fps = "FPS",
	tickrate = "TICKRATE",
	runAntiLagMeasures = "ANTI-LAG STARTEN",
	
	-- Users
	search = "Suchen",
	constraints = "VERBINDUNGEN",
	showEntities = "Entities anzeigen",
	hideEntities = "Entities verstecken",
	resetMap = "Map zurücksetzen",
	freezeEntities = "Entities einfrieren",
	removeEntities = "Entities entfernen",
	
	-- Global
	noCollideEntities = "No-Collide Entities",
	
	-- Lag
	heavyLag = "Starken Lag detektiert!",
	lagIsStuck = "Warnung: es gibt zu viel Lag!",
	crashPrevented = "Server crash verhindert!",
	cleaningMap = "+ Räume die Map auf...",
	removingEnts = "+ Entferne %s Entities",
	revertChanges = "+ Entferne %s Entities die in den letzten %s Minuten erstellt wurden",
	freezeingEnts = "+ Friere %s Entities ein",
	noCollidingEnts = "+ No-Colliding %s Entities",
	offenderWarning = "%s hat eine verdächtige Anzahl an Entities (%s) brechene Lag!",
	freezingAllEntities = "Friere alle Entities ein (%s)",
	
	-- Dupes
	dupesNotEnabled = "Dupes sind auf diesem Server nicht erlaubt!",
	advDupesNotEnabled = "Advanced Dupes sind auf diesem Server nicht erlaubt!",
	dupeExceedsSize = "Dieser Dupe is bigger then the max size! (size:%s, max:%s)",
	dupeInformation = "%s spawnt einen Dupe der %s Entities und %s Verbindungen enthält",
	
	-- Notifications
	triggeredAntiLagMeasures = "Anti-lag wurde gestartet!",
	ranAntilagMeasures = "Anti-lag wurde durchgeführt!",
	hasNoEntities = "hat keine Entities!",
	youRemovedFrom = "Du hast %s Entities von %s entfernt!",
	removedYourObjects = "deine gespawnten Objekte wurden entfernt!",
	youFrozeFrom = "Du hast %s Entities von %s eingefroren!",
	frozeYourObjects = "deine gespawnten Objekte wurden eingefroren!",
	enabledSpawnAbility = "du kannst jetzt wieder Objekte spawnen!",
	disabledSpawnAbility = "deine Fähigkeit Objekte zu spawnen wurde deaktiviert!",
	youEnabledSpawnAbility = "Du hast %ss Fähigkeit Objekte zu spawnen aktiviert!",
	youDisabledSpawnAbility = "Du hast %ss Fähigkeit Objekte zu spawnen deaktiviert!",
	
	resetTheMap = "Die Map zurücksetzen!",
	noEntNameFound = "Es wurde kein %s gefunden!",
	noEntitiesFound = "Es wurden keine Entities gefunden!",
	noUnfrozenEntsFound = "Es wurden keine ungefrorenen Entities gefunden!",
	noUnCollidedEntsFound = "Es wurden keine no-collideden Entities gefunden!",
	freezeAllEnts = "%s hat alle %s eingefroren! (%s)",
	noCollideAllEnts = "%s hat alle %s no-collided! (%s)",
	removedAllEntName = "%s hat alle %s entfernt! (%s)",
	entitiesLowCase = "entities",
	
	-- Console Log
	removedEntitiesFrom = "%s hat alle %s entities von %s entfernt!",
	frozeEntitiesFrom = "%s hat alle %s entities vib %s eingefroren!",
	enabledSpawningCapabilities = "%s hat die Fähigkeit Objekte zu spawnen für %s wirderhergestellt!",
	disabledSpawningCapabilities = "%s hat die Fähigkeit Objekte zu spawnen für %s blockiert!",
	removingHighCollision = "Entferne hohe Kollisionen %s (%s) von %s!",
	
}

return de
--addons/z_anticrash_v1.4.6/lua/z_anticrash/client/cl_menu.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER]]

local menu = nil
local lastOpened = 0

function CL_ANTICRASH.MenuIsOpen()
	return menu ~= nil and menu:IsVisible()
end

function CL_ANTICRASH.ToggleMenu(forceClose)

	if !SH_ANTICRASH.HasAccess() then return end
	
	if forceClose or CL_ANTICRASH.MenuIsOpen() then

		if menu ~= nil then
			
			for _, child in pairs(menu:GetChildren()) do
				child:Remove()
			end
		
			menu:Remove()
			
			menu = nil
			
		end
		
	else
	
		menu = vgui.Create( "p_anticrash_menu" )
		
		-- show one-time notification if new version is available
		if !SH_ANTICRASH.VARS.LATESTVERSION then
		
			SH_ANTICRASH.VARS.LATESTVERSION = true
			
			notification.AddLegacy( SH_ANTICRASH.VARS.LATESTVERSIONMSG, NOTIFY_GENERIC, 15 )
			
		end
		
	end

end

local function OpenMenuByConCommand( ply, cmd, args )
	CL_ANTICRASH.ToggleMenu()
end
concommand.Add( "anticrash_open", OpenMenuByConCommand)

--lua/autorun/ziro.lua:
player_manager.AddValidModel( "ziro", "models/player/valley/ziro.mdl" ) 
list.Set( "PlayerOptionsModel",  "ziro", "models/player/valley/ziro.mdl" ) 

--addons/wos-passiveevent-ageo/lua/wos/pes/vars/io_logic.lua:

local VAR = {}

VAR.Name = "IOLogic"
VAR.UseTool = true

VAR.ToolTips = {
    { text = "Select the entity to pull IO functions from", key = "gui/lmb.png", },
}

VAR.IsValid = function(varTable, value)
    if not istable(value) then return false end
	if not value.Function then return false end
	
	return true
end

VAR.DermaElement = function(varTable, varData)
	
	local DermaPanel = vgui.Create("DScrollPanel")
	DermaPanel:SetTall( 100 )
	DermaPanel.varData = varData or {}

	local ioLogic = wOS.PES.Modules:Get("io_logic")

	local rebuildOptions = function( class, ent )
		local actions = ioLogic:GetIOTable( class, ent )
		for _, name in ipairs(actions) do
			local button = vgui.Create("DButton", DermaPanel)	
			button:SetText(name)
			button:SetTall(20)
			button:Dock(TOP)
			button.FName = name
			button:DockMargin(0, 0, 5, 0)
			button.DoClick = function( pan )
				if not ent and not DermaPanel.varData.Class then return end
				local class = DermaPanel.varData.Class
				if ent then class = ent:GetClass() end
				DermaPanel.varData = { Class = class, Function = pan.FName }
				if DermaPanel.ClickedButton then
					DermaPanel.ClickedButton:SetText( DermaPanel.ClickedButton.FName )
				end
				pan:SetText( "->  " .. pan.FName .. " <-" )
				DermaPanel.ClickedButton = pan
			end

			if DermaPanel.varData.Function and DermaPanel.varData.Function == name then
				button:SetText( "->  " .. button.FName .. " <-" )
				DermaPanel.ClickedButton = button
			end

		end

	end

	local rebuildBase = function(ent)
		DermaPanel:Clear()

		if !IsValid(ent) then 
			local dlabel = vgui.Create("DLabel", DermaPanel)
			dlabel:SetText("No entity selected")
			dlabel:SetTall(20)
			dlabel:Dock(TOP)
			dlabel:DockMargin(0, 0, 5, 0)
			return 
		end
		
		rebuildOptions( ent:GetClass(), ent )
	end


	if DermaPanel.varData.Class then
		rebuildOptions( DermaPanel.varData.Class )
	end

	DermaPanel.RebuildBase = rebuildBase

	return DermaPanel
end

VAR.GetValue = function(element, varData)
	return element.varData
end

VAR.PrimaryAttack = function(wep, ply, dermaElement)
	local ent = ply:GetEyeTrace().Entity

	dermaElement.varData = {}
	dermaElement.RebuildBase(ent)
	ply:ChatPrint( "Entity Class Updated: " .. ent:GetClass() )
end

return VAR
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/list.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "List"
VAR.DirtyValidate = true
VAR.IsValid = function(varTable, value)
    if not istable(value) then
        return false
    end

    for _, entry in pairs(value) do
        if not isstring(entry) then
            return false
        end
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local listView = vgui.Create("DListView")
    listView:SetTall(200)
    listView:SetMultiSelect(true)
    
    if istable(value) then
        listView.SelectedValues = value
    elseif istable(varTable.Default) then
        listView.SelectedValues = varTable.Default
    else
        listView.SelectedValues = {}
    end

    if isstring(varTable.Header) then
        listView:AddColumn(varTable.Header)
    else
        listView:AddColumn("Multi-Select")
    end
    
    if isstring( varTable.Values ) and string.Left(varTable.Values, 6) == "FUNC::" then
        local func_name = string.Replace( varTable.Values, "FUNC::", "" )
        local layers = string.Split( func_name, "." )

        local func = _G
        for _, layer in ipairs( layers ) do
            func = func[ layer ] 
        end
        varTable.Values = func()

    end

    for _, entry in pairs(varTable.Values or {}) do
        local line = listView:AddLine(entry)
        if table.HasValue(listView.SelectedValues, entry) then
            line:SetSelected(true)
        end
    end

    function listView:OnRowRightClick(index, line)
        line:SetSelected(false)

        table.RemoveByValue(listView.SelectedValues, line:GetValue(1))
    end
    function listView:OnRowSelected(index, line)
        line:SetSelected(true)

        -- Keeping Everything active.
        for k, otherLine in pairs(self:GetLines()) do
            if table.HasValue(listView.SelectedValues, otherLine:GetValue(1)) then
                otherLine:SetSelected(true)
            end
        end

        if table.HasValue( listView.SelectedValues, line:GetValue(1) ) then return end
        table.insert(listView.SelectedValues, line:GetValue(1))
        
    end

    return listView
end

VAR.GetValue = function(listView)
    return listView.SelectedValues
end

return VAR
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/multi_select.lua:

local VAR = {}

VAR.Name = "Multi Select"

VAR.IsValid = function(varTable, value)
	if (value == nil) then return false end
	if (type(value) != "table") then return false end

	return true
end

VAR.GetValue = function(dermaElement)

	local lines = dermaElement:GetSelected()

	local value = {}

	for k, v in pairs(lines) do
		local a = dermaElement.varTable.Values[v:GetColumnText(1)]
		value[k] = a  
	end

	return value
end

VAR.DermaElement = function(varTable, value)
	value = value or {}

	local bgPanel = vgui.Create("DListView")
	bgPanel.varTable = varTable
	bgPanel:AddColumn("Name")
	bgPanel.Values = value

	for k, v in pairs(varTable.Values) do
		local pnl = bgPanel:AddLine(k)
		
		if value[k] then
			bgPanel:SelectItem(pnl)
		end
	end
		
	bgPanel:SetTall(300)
	
	return bgPanel
end

return VAR

--addons/wos-passiveevent-ageo/lua/wos/css/core/cl_net.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.CombatSim = wOS.CombatSim or {}

//PES STUFF

net.Receive("wOS.CSS.OpenToolMenu", function()
	local simulator = net.ReadEntity()
	if not IsValid( simulator ) then return end
	wOS.CombatSim:OpenToolMenu(simulator)
end)


net.Receive( "wOS.CSS.CreateNewSimulation", function( len, ply )
	local simulator = net.ReadEntity()
	if not IsValid( simulator ) then return end
	wOS.CombatSim:OpenSimulationCreator(simulator)
end )

net.Receive( "wOS.CSS.GetEditableChallenges", function(len, ply)
	local wep = LocalPlayer():GetActiveWeapon()
	if not IsValid( wep ) or wep:GetClass() != "wos_simulation_tool" then return end
	
	local sim = wep:GetSelectedSimulator()
	if not IsValid( sim ) or sim == wep then return end

	local challenges = net.ReadTable()

	wOS.CombatSim:OpenToolPreChallengeMenu( challenges )
end )

//CSS ORIGINAL STUFF


















net.Receive("wOS.CombatSim.GetChallenges", function()
	local ply = LocalPlayer()

	local simulator = net.ReadEntity()

	if IsValid(simulator) and simulator:GetClass() == "wos_simulation_system" then
		wOS.CombatSim:OpenToolMenu(simulator)
	end
end)

net.Receive("wOS.CombatSim.OpenChallenges", function()
	local ply = LocalPlayer()

	local simulator = net.ReadEntity()
	if IsValid(simulator) and simulator:GetClass() == "wos_simulation_system" then
		local challenges = net.ReadTable()

		wOS.CombatSim:OpenSimulatorMenu(simulator, challenges)
	end
end)

net.Receive("wOS.CombatSim.UpdateWallCollisions", function()
	local wall = net.ReadEntity()
	if not IsValid( wall ) then return end
	local vertices = net.ReadTable()

	if IsValid(wall) and isfunction(wall.ApplyCustomCollisions) then
		wall:ApplyCustomCollisions(vertices)
	end
end)

net.Receive("wOS.CombatSim.GetGameInfo", function()
	local simulator = net.ReadEntity()
	if IsValid(simulator) and simulator:GetClass() == "wos_simulation_system" then
		local gameInfo = net.ReadTable()
		local partyQueue = net.ReadTable()

		wOS.CombatSim:UpdateSimulatorMenuGameInfo(simulator, gameInfo)
		wOS.CombatSim:UpdateSimulatorMenuQueue(simulator, partyQueue)
	end
end)
--addons/billy_gas/lua/vgui/bvgui/gauge.lua:
local PANEL = {}

function PANEL:Init()
	self.Color = Color(192,57,43)
	self.Progress = 0
	self.ProgressAngle = 0

	self.ProgressCircle = GAS_NewCircle(CIRCLE_OUTLINED)
	self.ProgressCircle:SetAngles(180,360)
	self.ProgressCircle:SetThickness(20)
	self.ProgressCircle:SetVertices(64)

	self.ProgressBackgroundCircle = GAS_NewCircle(CIRCLE_OUTLINED)
	self.ProgressBackgroundCircle:SetAngles(180,360)
	self.ProgressBackgroundCircle:SetThickness(20)
	self.ProgressBackgroundCircle:SetVertices(64)

	self.BackgroundCircle = GAS_NewCircle(CIRCLE_FILLED)
	self.BackgroundCircle:SetAngles(180,360)
	self.BackgroundCircle:SetVertices(64)

	self.Text = vgui.Create("DLabel", self)
	self.Text:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 18))
	self.Text:SetTextColor(COLOR_WHITE)
	self.Text:SetText("")

	self.SubText = vgui.Create("DLabel", self)
	self.SubText:SetVisible(false)
	self.SubText:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
	self.SubText:SetTextColor(COLOR_WHITE)
	self.SubText:SetText("")
end

function PANEL:SetColor(col_from, col_to)
	if (IsColor(col_from) and col_to == nil) then
		self.Color = col_from
		self.ColorFrom = nil
		self.ColorTo = nil
	elseif (IsColor(col_from) and IsColor(col_to)) then
		self.Color = table.Copy(col_from)
		self.ColorFrom = col_from
		self.ColorTo = col_to
	end
end

function PANEL:SetProgress(progress)
	self.Progress = math.Clamp(progress, 0, 100)
end

function PANEL:SetText(txt)
	self.Text:SetText(txt)
end

function PANEL:SetSubText(txt)
	if (txt == nil or #txt == 0) then
		self.SubText:SetVisible(false)
	else
		self.SubText:SetVisible(true)
		self.SubText:SetText(txt)
	end
end

function PANEL:PerformLayout(w, h)
	self.Text:SizeToContents()

	if (self.SubText:IsVisible()) then
		self.SubText:SizeToContents()

		self.Text:SetPos((w - self.Text:GetWide()) / 2, ((w - self.Text:GetTall()) / 2) - 20 - (self.SubText:GetTall() / 2))
		self.SubText:SetPos((w - self.SubText:GetWide()) / 2, ((w - self.Text:GetTall()) / 2) - 20 + (self.Text:GetTall() / 2))
	else
		self.Text:SetPos((w - self.Text:GetWide()) / 2, ((w - self.Text:GetTall()) / 2) - 20)
	end
end

function PANEL:Paint(w,h)
	draw.NoTexture()

	local r = w / 2

	surface.SetDrawColor(45,45,45,255)
	self.ProgressBackgroundCircle:SetPos(w / 2, w / 2)
	self.ProgressBackgroundCircle:SetRadius(r)
	self.ProgressBackgroundCircle()

	local progress_frac = (self.Progress / 100)
	if (self.ColorFrom and self.ColorTo) then
		self.Color.r = Lerp(0.05, self.Color.r, self.ColorFrom.r + ((self.ColorTo.r - self.ColorFrom.r) * progress_frac))
		self.Color.g = Lerp(0.05, self.Color.g, self.ColorFrom.g + ((self.ColorTo.g - self.ColorFrom.g) * progress_frac))
		self.Color.b = Lerp(0.05, self.Color.b, self.ColorFrom.b + ((self.ColorTo.b - self.ColorFrom.b) * progress_frac))
	end
	self.ProgressAngle = Lerp(0.05, self.ProgressAngle, progress_frac * 180)

	surface.SetDrawColor(self.Color)
	self.ProgressCircle:SetAngles(180, 180 + self.ProgressAngle)
	self.ProgressCircle:SetPos(w / 2, w / 2)
	self.ProgressCircle:SetRadius(r)
	self.ProgressCircle()

	surface.SetDrawColor(60,60,60,255)
	self.BackgroundCircle:SetPos(w / 2, w / 2)
	self.BackgroundCircle:SetRadius(r - 20)
	self.BackgroundCircle()
end

derma.DefineControl("bVGUI.Gauge", nil, PANEL, "DPanel")
--addons/billy_gas/lua/vgui/bvgui/player_tooltip.lua:
if (bVGUI.PlayerTooltip) then
	if (IsValid(bVGUI.PlayerTooltip.Panel)) then
		bVGUI.PlayerTooltip.Panel:Remove()
	end
end

bVGUI.PlayerTooltip = {}
bVGUI.PlayerTooltip.Close = function()
	if (IsValid(bVGUI.PlayerTooltip.Panel)) then
		if (bVGUI.PlayerTooltip.Panel.Focused ~= true) then
			bVGUI.PlayerTooltip.Panel:Remove()
		end
	end
end
bVGUI.PlayerTooltip.Create = function(options)
	if (IsValid(bVGUI.PlayerTooltip.Panel)) then
		if (bVGUI.PlayerTooltip.Panel.Focused ~= true) then
			bVGUI.PlayerTooltip.Panel:Remove()
		end
	end

	if (not IsValid(options.player) and options.account_id) then
		local ply = player.GetByAccountID(options.account_id)
		if (IsValid(ply)) then
			options.player = ply
		end
	elseif (not IsValid(options.player) and options.steamid64) then
		local ply = player.GetBySteamID64(options.steamid64)
		if (IsValid(ply)) then
			options.player = ply
		end
	end

	local data = {}
	data.nick = "Loading..."
	data.usergroup = "Loading..."
	data.team_name = "(offline)"
	data.team_color = bVGUI.BUTTON_COLOR_RED
	if (IsValid(options.player)) then
		data.account_id = options.player:AccountID()
		data.steamid = options.player:SteamID()
		data.steamid64 = options.player:SteamID64()
		data.team_name = team.GetName(options.player:Team())
		data.team_color = team.GetColor(options.player:Team())
		data.nick = options.player:Nick()
		data.usergroup = options.player:GetUserGroup()
	elseif (options.steamid64) then
		data.account_id = GAS:SteamID64ToAccountID(options.steamid64)
		data.steamid = util.SteamIDFrom64(options.steamid64)
		data.steamid64 = options.steamid64
	elseif (options.account_id) then
		data.account_id = options.account_id
		data.steamid = GAS:AccountIDToSteamID(options.account_id)
		data.steamid64 = util.SteamIDTo64(data.steamid)
	end

	bVGUI.PlayerTooltip.Panel = vgui.Create("bVGUI.Frame")
	local pnl = bVGUI.PlayerTooltip.Panel
	pnl.Options = options
	pnl.CreatorPanel = options.creator
	pnl:ShowFullscreenButton(false)
	pnl:SetSize(316, 234)
	pnl:SetPos(gui.MouseX() + 15, gui.MouseY() + 15)
	pnl:DockPadding(10,24 + 10,10,10)
	pnl:MakePopup()
	pnl:SetMouseInputEnabled(false)
	pnl:SetKeyBoardInputEnabled(false)
	pnl:SetDrawOnTop(true)
	pnl.OriginalTitle = data.nick

	function pnl:OnRemove()
		timer.Simple(1, function()
			if (not IsValid(bVGUI.PlayerTooltip.Panel)) then
				bVGUI.PlayerTooltip.MouseX = false 
				bVGUI.PlayerTooltip.MouseY = false
			end
		end)
	end

	function pnl:PostPerformLayout(w, h)
		if (options.focustip) then
			pnl:SetTitle(bVGUI.EllipsesText(data.nick, bVGUI.FONT(bVGUI.FONT_RUBIK, "BOLD", 14), w / 3) .. " · " .. options.focustip)
		else
			pnl:SetTitle(data.nick)
		end
	end

	function pnl:OnFocusChanged(got)
		if got then return end 
		if self.Pinned then return end 
		if not GAS.LocalConfig.ClosePlayerPopups then return end		
		self:Close()
	end

	pnl.OldPaint = pnl.Paint
	function pnl:Paint(w,h)
		if (not self.Focused) then
			surface.SetAlphaMultiplier(0.5)
		end
		self:OldPaint(w,h)

		if (self.Focused ~= true) then
			local x,y = gui.MouseX(), gui.MouseY()
			bVGUI.PlayerTooltip.MouseX = Lerp(FrameTime() * 10, bVGUI.PlayerTooltip.MouseX or x, x)
			bVGUI.PlayerTooltip.MouseY = Lerp(FrameTime() * 10, bVGUI.PlayerTooltip.MouseY or y, y)

			self:SetPos(bVGUI.PlayerTooltip.MouseX + 15, bVGUI.PlayerTooltip.MouseY + 15)
		end

		if (not self.Focused) then
			if (not system.HasFocus()) then
				self:Remove()
			elseif (self.CreatorPanel) then
				if (not IsValid(self.CreatorPanel)) then
					self:Remove()
				elseif (vgui.GetHoveredPanel() ~= self.CreatorPanel) then
					if (self.HoverFrameNumber) then
						if (FrameNumber() > self.HoverFrameNumber) then
							self:Remove()
						end
					else
						self.HoverFrameNumber = FrameNumber() + 1
					end
				end
			end
		end
	end

	local avatar_container = vgui.Create("bVGUI.BlankPanel", pnl)
	avatar_container:SetMouseInputEnabled(true)
	avatar_container:Dock(LEFT)
	avatar_container:DockMargin(0,0,10,0)
	avatar_container:SetWide(110)

	local avatar = vgui.Create("AvatarImage", avatar_container)
	avatar:Dock(TOP)
	avatar:SetSize(avatar_container:GetWide(), avatar_container:GetWide())
	if (IsValid(options.player)) then
		avatar:SetPlayer(options.player, 128)
	else
		avatar:SetSteamID(data.steamid64, 128)
	end

	local usergroup = vgui.Create("bVGUI.InfoBar", avatar_container)
	usergroup:Dock(TOP)
	usergroup:DockMargin(0,10,0,10)
	usergroup:SetText(data.usergroup)
	usergroup:AllowCopy(options.copiedphrase)
	usergroup:SetColor(bVGUI.INFOBAR_COLOR_PURPLE)
	bVGUI.AttachTooltip(usergroup, {Text = "Usergroup"})

	local job = vgui.Create("bVGUI.InfoBar", avatar_container)
	job:Dock(TOP)
	job:DockMargin(0,0,0,10)
	job:SetText(data.team_name)
	job:AllowCopy(options.copiedphrase)
	job:SetColor(data.team_color)
	if (DarkRP) then
		bVGUI.AttachTooltip(job, {Text = "Job"})
	else
		bVGUI.AttachTooltip(job, {Text = "Team"})
	end

	local info_container = vgui.Create("bVGUI.BlankPanel", pnl)
	info_container:Dock(FILL)
	info_container:SetMouseInputEnabled(true)
	info_container.SIG = true

	local nick = vgui.Create("bVGUI.InfoBar", info_container)
	nick:Dock(TOP)
	nick:DockMargin(0,0,0,10)
	nick:SetText(data.nick)
	nick:AllowCopy(options.copiedphrase)
	nick:SetColor(bVGUI.INFOBAR_COLOR_PURPLE)

	local steamid = vgui.Create("bVGUI.InfoBar", info_container)
	steamid:Dock(TOP)
	steamid:DockMargin(0,0,0,10)
	steamid:SetText(data.steamid)
	steamid:AllowCopy(options.copiedphrase)

	local steamid64 = vgui.Create("bVGUI.InfoBar", info_container)
	steamid64:Dock(TOP)
	steamid64:DockMargin(0,0,0,10)
	steamid64:SetText(data.steamid64)
	steamid64:AllowCopy(options.copiedphrase)

	local steam_profile = vgui.Create("bVGUI.Button", info_container)
	steam_profile:Dock(TOP)
	steam_profile:DockMargin(0,0,0,10)
	steam_profile:SetText(bVGUI.L("open_steam_profile"))
	steam_profile:SetColor(bVGUI.BUTTON_COLOR_BLUE)
	function steam_profile:DoClick()
		if (GAS) then
			GAS:OpenURL("https://steamcommunity.com/profiles/" .. steamid64:GetText())
		else
			gui.OpenURL("https://steamcommunity.com/profiles/" .. steamid64:GetText())
		end
	end

	local context_menu = vgui.Create("bVGUI.Button", info_container)
	context_menu:Dock(TOP)
	context_menu:DockMargin(0,0,0,10)
	context_menu:SetText(bVGUI.L("open_context_menu"))
	context_menu:SetColor(bVGUI.BUTTON_COLOR_RED)
	context_menu:SetDisabled(not IsValid(options.player))
	function context_menu:DoClick()
		if (IsValid(options.player)) then
			if (GAS) then GAS:PlaySound("popup") end
			properties.OpenEntityMenu(options.player, LocalPlayer():GetEyeTrace())
		else
			if (GAS) then GAS:PlaySound("error") end
			self:SetDisabled(true)
		end
	end
	
	if (not IsValid(options.player)) then
		pnl.GetPlayerData = function()
			GAS:untimer("PlayerTooltip:Load:" .. data.account_id)
			GAS.OfflinePlayerData:AccountID(tonumber(data.account_id), function(success, offline_data)
				if (not IsValid(pnl)) then return end
				if (success) then
					data.nick = offline_data.nick
					data.usergroup = offline_data.usergroup

					pnl.OriginalTitle = offline_data.nick
					nick:SetText(offline_data.nick)
					usergroup:SetText(offline_data.usergroup)
					if (options.focustip) then
						pnl:SetTitle(offline_data.nick .. " · " .. options.focustip)
					else
						pnl:SetTitle(offline_data.nick)
					end
				else
					data.nick = "(unknown)"
					data.usergroup = "(unknown)"

					pnl.OriginalTitle = bVGUI.L("unknown")
					nick:SetText(bVGUI.L("unknown"))
					usergroup:SetText(bVGUI.L("unknown"))
					if (options.focustip) then
						pnl:SetTitle(bVGUI.L("unknown") .. " · " .. options.focustip)
					else
						pnl:SetTitle(bVGUI.L("unknown"))
					end
				end
			end)
			pnl.GetPlayerData = nil
		end
		if (GAS.OfflinePlayerData.data[data.account_id] ~= nil) then
			pnl.GetPlayerData()
		else
			GAS:timer("PlayerTooltip:Load:" .. data.account_id, .5, 1, function()
				if (not IsValid(pnl)) then return end
				pnl.GetPlayerData()
			end)
		end
	end

	return pnl
end
bVGUI.PlayerTooltip.Focus = function()
	if (IsValid(bVGUI.PlayerTooltip.Panel)) then
		if (GAS) then GAS:PlaySound("flash") end
		bVGUI.PlayerTooltip.Panel.Focused = true
		bVGUI.PlayerTooltip.Panel:MakePopup()
		bVGUI.PlayerTooltip.Panel:MoveToFront()
		bVGUI.PlayerTooltip.Panel:SetTitle(bVGUI.PlayerTooltip.Panel.OriginalTitle)
		bVGUI.PlayerTooltip.Panel:SetDrawOnTop(false)
		if (bVGUI.PlayerTooltip.Panel.GetPlayerData) then
			bVGUI.PlayerTooltip.Panel.GetPlayerData()
		end
	end
end

bVGUI.PlayerTooltip.Attach = function(pnl, options)
	options.creator = pnl
	if (pnl.bVGUI_PlayerTooltipOptions) then
		pnl.bVGUI_PlayerTooltipOptions = options
		return
	else
		pnl.bVGUI_PlayerTooltipOptions = options
	end

	pnl.bVGUI_PLAYER_TOOLTIP_OLD_CURSOR_ENTER = pnl.OnCursorEntered
	pnl.bVGUI_PLAYER_TOOLTIP_OLD_CURSOR_EXIT = pnl.OnCursorExited
	function pnl:OnCursorEntered(...)
		bVGUI.PlayerTooltip.Create(self.bVGUI_PlayerTooltipOptions)
		if (self.bVGUI_PLAYER_TOOLTIP_OLD_CURSOR_ENTER) then self.bVGUI_PLAYER_TOOLTIP_OLD_CURSOR_ENTER(self, ...) end
	end
	function pnl:OnCursorExited(...)
		bVGUI.PlayerTooltip.Close()
		if (self.bVGUI_PLAYER_TOOLTIP_OLD_CURSOR_EXIT) then self.bVGUI_PLAYER_TOOLTIP_OLD_CURSOR_EXIT(self, ...) end
	end
end

bVGUI.PlayerTooltip.Unattach = function(pnl)
	pnl.bVGUI_PlayerTooltipOptions = nil
	pnl.OnCursorEntered = pnl.bVGUI_PLAYER_TOOLTIP_OLD_CURSOR_ENTER
	pnl.OnCursorExited = pnl.bVGUI_PLAYER_TOOLTIP_OLD_CURSOR_EXIT
end
--addons/billy_gas/lua/vgui/bvgui/progressbar.lua:
local PANEL = {}

function PANEL:Init()
	self.Min = 0
	self.Max = 0
	self.Progress = 0
	self.Fraction = 0
	self.Decimals = false

	self.Text = vgui.Create("DLabel", self)
	self.Text:SetText("")
	self.Text:SetTextColor(bVGUI.COLOR_WHITE)
	self.Text:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "BOLD", 14))

	self.ProgressBar_X = -1
	self.ProgressBar_Col = -1
end

function PANEL:Paint(w,h)
	surface.SetDrawColor(bVGUI.COLOR_SLATE)
	surface.DrawRect(0,0,w,h)

	--surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT)
	--surface.DrawTexturedRect(0,0,w,h)

	local w_frac = self.Fraction * w
	if (self.ProgressBar_X == -1) then
		self.ProgressBar_X = w_frac
	else
		self.ProgressBar_X = Lerp(FrameTime() * 10, self.ProgressBar_X, w_frac)
	end

	local frac_255 = self.Fraction * 255
	if (self.ProgressBar_Col == -1) then
		self.ProgressBar_Col = frac_255
	else
		self.ProgressBar_Col = Lerp(FrameTime() * 10, self.ProgressBar_Col, frac_255)
	end

	surface.SetDrawColor(255 - self.ProgressBar_Col, self.ProgressBar_Col, 0, 255)
	surface.DrawRect(0, 0, self.ProgressBar_X, h)

	--surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT)
	--surface.DrawTexturedRect(0, 0, self.ProgressBar_X, h)

	surface.SetDrawColor(bVGUI.COLOR_BLACK)
	surface.DrawOutlinedRect(0,0,w,h)
end

function PANEL:Think()
	self.Fraction = (self.Progress - self.Min) / (self.Max - self.Min)
	if (self.Decimals == false and tostring(self.Fraction * 100):find("%.")) then
		self.Decimals = true
	end

	if (self.Fraction > 0) then
		if (self.Decimals) then
			local percentage = math.Round(self.Fraction * 100, 1)
			if (percentage % 1 == 0 and self.Fraction ~= 1) then
				percentage = percentage .. ".0"
			end
			self.Text:SetText(percentage .. "%")
		else
			self.Text:SetText(math.Round(self.Fraction * 100, 1) .. "%")
		end
		self.Text:SizeToContents()
		self.Text:Center()
	elseif (self.Text:GetText() ~= "") then
		self.Text:SetText("")
	end
end

derma.DefineControl("bVGUI.ProgressBar", nil, PANEL, "DPanel")
--addons/tools/lua/vgui/dparticle.lua:
local PANEL = {}
PANEL.Zoom = 100
DEFINE_BASECLASS( "ContentIcon")

function PANEL:Init()
    self:SetPaintBackground( false )
	self:SetSize( 128, 128 )
	self:SetText( "" )
end

function PANEL:Setup(name, part)
    self.partName = name
    self:SetName(self.partName)

    PrecacheParticleSystem(self.partName)
    self.Particle = CreateParticleSystemNoEntity(self.partName, Vector(0, 0, 0), Angle(0, 0, 0))
    if not self.Particle then
        self:SetName("-Invalid particle system-")
        return
    end
    self.Particle:SetShouldDraw(false)
end

PANEL.WasValid = false
function PANEL:Paint(w, h)
    baseclass.Get("ContentIcon").Paint(self, w, h)
    if not self.Particle then return end
    if self.Particle:IsValid() then
        for k = 1, self.Particle:GetHighestControlPoint() do
            self.Particle:SetControlPoint(k, Vector(0, 0, k * 4))
        end
        self.Particle:SetControlPointEntity(0, LocalPlayer())
        self.WasValid = true
        local x, y = self:LocalToScreen(0, 0)
        local origin = Vector(45, 45, self.Zoom / 40)
        local ang = origin:Angle()
        ang:RotateAroundAxis(ang:Up(), 90)
        cam.Start3D(origin, -ang, self.Zoom, x + 8, y + 8, w - 16, h - 16, 0, 1024)
        self.Particle:Render()
        cam.End3D()
    elseif not self.Particle:IsValid() and self.WasValid then
        self.Particle = CreateParticleSystemNoEntity(self.partName, Vector(0, 0, 0), Angle(0, 0, 0))
        self.Particle:SetShouldDraw(false)
    end
end

function PANEL:OnMousePressed(m)
    if m == MOUSE_RIGHT then
        local menu = DermaMenu()
        menu:AddOption("Spawn Particle", function()
            RunConsoleCommand("gparticles_particle", self.partName)
            spawnmenu.ActivateTool( "gparticles" )
        end):SetIcon("icon16/fire.png")
        menu:AddOption("+Zoom", function()
            self.Zoom = self.Zoom - self.Zoom / 4
        end):SetIcon("icon16/add.png")
        menu:AddOption("-Zoom", function()
            self.Zoom = self.Zoom + self.Zoom / 4
        end):SetIcon("icon16/delete.png")
        menu:AddOption("Copy name", function()
            SetClipboardText(self.partName)
        end):SetIcon("icon16/help.png")
        menu:AddOption("Copy path", function()
            SetClipboardText("game.AddParticles(\"particles/" .. self.partName .. ".pcf\")")
        end):SetIcon("icon16/house_link.png")
        menu:AddOption("Cancel")
        menu:Open()
        return
    elseif m == MOUSE_LEFT then
        RunConsoleCommand("gparticles_particle", self.partName)
    end

    self:DoClick()
end

function PANEL:OnRemove()
    if self.Particle and self.Particle:IsValid() then
        self.Particle:StopEmissionAndDestroyImmediately()
    end
end

vgui.Register("ParticleControllerUI", PANEL, "ContentIcon")

spawnmenu.AddContentType( "particles", function( container, obj )

	if ( !obj.name ) then return end
	if ( !obj.part ) then return end

	local icon = vgui.Create( "ParticleControllerUI", container )
	icon:Setup( obj.name, obj.part )

	container:Add( icon )

end )

--gamemodes/starwarsrp/gamemode/modules/permaprops/cl_menu.lua:
/*
   ____          _          _   ____          __  __       _ _                     
  / ___|___   __| | ___  __| | | __ ) _   _  |  \/  | __ _| | |__   ___  _ __ ___  
 | |   / _ \ / _` |/ _ \/ _` | |  _ \| | | | | |\/| |/ _` | | '_ \ / _ \| '__/ _ \ 
 | |__| (_) | (_| |  __/ (_| | | |_) | |_| | | |  | | (_| | | |_) | (_) | | | (_) |
  \____\___/ \__,_|\___|\__,_| |____/ \__, | |_|  |_|\__,_|_|_.__/ \___/|_|  \___/ 
                                      |___/                                        
*/

surface.CreateFont( "pp_font", {
	font = "Arial",
	size = 20,
	weight = 700,
	shadow = false
} )

local function pp_open_menu(data)


	local Content = {}
	Content.PropsList = {}
	for k, v in pairs(data) do
		Content.PropsList[k] = util.JSONToTable(v.content)
	end

	Content.TProps = #Content.PropsList


 	local Main = vgui.Create( "DFrame" )
	Main:SetSize( 600, 355 )
	Main:Center()
	Main:SetTitle("")
	Main:SetVisible( true )
	Main:SetDraggable( true )
	Main:ShowCloseButton( true )
	Main:MakePopup()
	Main.Paint = function(self)

		draw.RoundedBox( 0, 0, 0, self:GetWide(), self:GetTall(), Color(155, 155, 155, 220) )
		surface.SetDrawColor( 17, 148, 240, 255 )
		surface.DrawOutlinedRect( 0, 0, self:GetWide(), self:GetTall() )	

		draw.RoundedBox( 0, 0, 0, self:GetWide(), 25, Color(17, 148, 240, 200) )
		surface.SetDrawColor( 17, 148, 240, 255 )
		surface.DrawOutlinedRect( 0, 0, self:GetWide(), 25 )
		draw.DrawText( "PermaProps Config", "pp_font", 10, 2.2, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT )

	end

	local BSelect
	local PSelect

	local MainPanel = vgui.Create( "DPanel", Main )
	MainPanel:SetPos( 190, 51 )
	MainPanel:SetSize( 390, 275 )
	MainPanel.Paint = function( self )
		surface.SetDrawColor( 50, 50, 50, 200 ) 
		surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
		surface.DrawOutlinedRect(0, 15, self:GetWide(), 40)
	end
	PSelect = MainPanel

	local MainLabel = vgui.Create("DLabel", MainPanel)
	MainLabel:SetFont("pp_font")
	MainLabel:SetPos(140, 25) 
	MainLabel:SetColor(Color(50, 50, 50, 255)) 
	MainLabel:SetText("Hey ".. LocalPlayer():Nick() .." !") 
	MainLabel:SizeToContents()

	local MainLabel2 = vgui.Create("DLabel", MainPanel)
	MainLabel2:SetFont("pp_font")
	MainLabel2:SetPos(80, 80) 
	MainLabel2:SetColor(Color(50, 50, 50, 255)) 
	MainLabel2:SetText("There are ".. ( Content.TProps or 0 ) .." props in the DB.") 
	MainLabel2:SizeToContents()

	local RemoveMapProps = vgui.Create( "DButton", MainPanel )
	RemoveMapProps:SetText( " Clear map props " )
	RemoveMapProps:SetFont("pp_font")
	RemoveMapProps:SetSize( 370, 30)
	RemoveMapProps:SetPos( 10, 160 )
	RemoveMapProps:SetTextColor( Color( 50, 50, 50, 255 ) )
	RemoveMapProps.DoClick = function()
		net.Start("pp_info_send")
			net.WriteTable({CMD = "CLR_MAP"})
		net.SendToServer()
	end
	RemoveMapProps.Paint = function(self)
		surface.SetDrawColor(50, 50, 50, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end

	local ClearMapProps = vgui.Create( "DButton", MainPanel )
	ClearMapProps:SetText( " Clear map props in the DB " )
	ClearMapProps:SetFont("pp_font")
	ClearMapProps:SetSize( 370, 30)
	ClearMapProps:SetPos( 10, 200 )
	ClearMapProps:SetTextColor( Color( 50, 50, 50, 255 ) )
	ClearMapProps.DoClick = function()

		Derma_Query("Are you sure you want clear map props in the db ?\nYou can't undo this action !", "PermaProps 4.0", "Yes", function() net.Start("pp_info_send") net.WriteTable({CMD = "DEL_MAP"}) net.SendToServer() end, "Cancel")

	end
	ClearMapProps.Paint = function(self)
		surface.SetDrawColor(50, 50, 50, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end

	local ClearAllProps = vgui.Create( "DButton", MainPanel )
	ClearAllProps:SetText( " Clear all props in the DB " )
	ClearAllProps:SetFont("pp_font")
	ClearAllProps:SetSize( 370, 30)
	ClearAllProps:SetPos( 10, 240 )
	ClearAllProps:SetTextColor( Color( 50, 50, 50, 255 ) )
	ClearAllProps.DoClick = function()

		Derma_Query("Are you sure you want clear all props in the db ?\nYou can't undo this action !", "PermaProps 4.0", "Yes", function() net.Start("pp_info_send") net.WriteTable({CMD = "DEL_ALL"}) net.SendToServer() end, "Cancel")

	end
	ClearAllProps.Paint = function(self)
		surface.SetDrawColor(50, 50, 50, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end

	local BMain = vgui.Create("DButton", Main)
	BSelect = BMain
	BMain:SetText("Main")
	BMain:SetFont("pp_font")
	BMain:SetSize(160, 50)
	BMain:SetPos(15, 27 + 25)
	BMain:SetTextColor( Color( 255, 255, 255, 255 ) )
	BMain.PaintColor = Color(17, 148, 240, 100)
	BMain.Paint = function(self)

		draw.RoundedBox(0, 0, 0, self:GetWide(), self:GetTall(), self.PaintColor)
		surface.SetDrawColor(17, 148, 240, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())

	end
	BMain.DoClick = function( self )

		if BSelect then BSelect.PaintColor = Color(0, 0, 0, 0) end
		BSelect = self
		self.PaintColor = Color(17, 148, 240, 100)

		if PSelect then PSelect:Hide() end
		MainPanel:Show()
		PSelect = MainPanel

	end

	--[[ local ConfigPanel = vgui.Create( "DPanel", Main )
	ConfigPanel:SetPos( 190, 51 )
	ConfigPanel:SetSize( 390, 275 )
	ConfigPanel.Paint = function( self )
		surface.SetDrawColor( 50, 50, 50, 200 ) 
		surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	end
	ConfigPanel:Hide()

	local CheckCustom = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckCustom:SetPos( 5, 30 )
	CheckCustom:SetText( "Custom permissions" )
	CheckCustom:SetValue( 0 )
	CheckCustom:SizeToContents()
	CheckCustom:SetTextColor( Color( 0, 0, 0, 255) )
	CheckCustom:SetDisabled( true )

	local GroupsList = vgui.Create( "DComboBox", ConfigPanel )
	GroupsList:SetPos( 5, 5 )
	GroupsList:SetSize( 125, 20 )
	GroupsList:SetValue( "Select a group..." )

	local CheckBox1 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox1:SetPos( 150, 10 )
	CheckBox1:SetText( "Menu" )
	CheckBox1:SizeToContents()
	CheckBox1:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox1:SetDisabled( true )
	CheckBox1.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Menu", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox2 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox2:SetPos( 150, 30 )
	CheckBox2:SetText( "Edit permissions" )
	CheckBox2:SizeToContents()
	CheckBox2:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox2:SetDisabled( true )
	CheckBox2.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Permissions", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox3 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox3:SetPos( 150, 50 )
	CheckBox3:SetText( "Physgun permaprops" )
	CheckBox3:SizeToContents()
	CheckBox3:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox3:SetDisabled( true )
	CheckBox3.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Physgun", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox4 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox4:SetPos( 150, 70 )
	CheckBox4:SetText( "Tool permaprops" )
	CheckBox4:SizeToContents()
	CheckBox4:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox4:SetDisabled( true )
	CheckBox4.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Tool", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox5 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox5:SetPos( 150, 90 )
	CheckBox5:SetText( "Property permaprops" )
	CheckBox5:SizeToContents()
	CheckBox5:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox5:SetDisabled( true )
	CheckBox5.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Property", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox6 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox6:SetPos( 150, 110 )
	CheckBox6:SetText( "Save props" )
	CheckBox6:SizeToContents()
	CheckBox6:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox6:SetDisabled( true )
	CheckBox6.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Save", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox7 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox7:SetPos( 150, 130 )
	CheckBox7:SetText( "Delete permaprops" )
	CheckBox7:SizeToContents()
	CheckBox7:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox7:SetDisabled( true )
	CheckBox7.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Delete", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox8 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox8:SetPos( 150, 150 )
	CheckBox8:SetText( "Update permaprops" )
	CheckBox8:SizeToContents()
	CheckBox8:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox8:SetDisabled( true )
	CheckBox8.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Update", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	GroupsList.OnSelect = function( panel, index, value )
		
		CheckCustom:SetDisabled( false )
		CheckCustom:SetChecked( Content.Permissions[value].Custom )

		CheckBox1:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox1:SetChecked( Content.Permissions[value].Menu )
		CheckBox2:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox2:SetChecked( Content.Permissions[value].Permissions )
		CheckBox3:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox3:SetChecked( Content.Permissions[value].Physgun )
		CheckBox4:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox4:SetChecked( Content.Permissions[value].Tool )
		CheckBox5:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox5:SetChecked( Content.Permissions[value].Property )
		CheckBox6:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox6:SetChecked( Content.Permissions[value].Save )
		CheckBox7:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox7:SetChecked( Content.Permissions[value].Delete )
		CheckBox8:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox8:SetChecked( Content.Permissions[value].Update )

	end

	for k, v in pairs(Content.Permissions) do
		
		GroupsList:AddChoice(k)

	end

	CheckCustom.OnChange = function(Self, Value)

		CheckBox1:SetDisabled( !Value )
		CheckBox2:SetDisabled( !Value )
		CheckBox3:SetDisabled( !Value )
		CheckBox4:SetDisabled( !Value )
		CheckBox5:SetDisabled( !Value )
		CheckBox6:SetDisabled( !Value )
		CheckBox7:SetDisabled( !Value )
		CheckBox8:SetDisabled( !Value )

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Custom", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local BConfig = vgui.Create("DButton", Main)
	BConfig:SetText("Configuration")
	BConfig:SetFont("pp_font")
	BConfig:SetSize(160, 50)
	BConfig:SetPos(15, 71 + 55)
	BConfig:SetTextColor( Color( 255, 255, 255, 255 ) )
	BConfig.PaintColor = Color(0, 0, 0, 0)
	BConfig.Paint = function(self)
		draw.RoundedBox(0, 0, 0, self:GetWide(), self:GetTall(), self.PaintColor)
		surface.SetDrawColor(17, 148, 240, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end
	BConfig.DoClick = function( self )

		if BSelect then BSelect.PaintColor = Color(0, 0, 0, 0) end
		BSelect = self
		self.PaintColor = Color(17, 148, 240, 100)

		if PSelect then PSelect:Hide() end
		ConfigPanel:Show()
		PSelect = ConfigPanel

	end
 ]]
	local PropsPanel = vgui.Create( "DPanel", Main )
	PropsPanel:SetPos( 190, 51 )
	PropsPanel:SetSize( 390, 275 )
	PropsPanel.Paint = function( self )
		surface.SetDrawColor( 50, 50, 50, 200 ) 
		surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	end
	PropsPanel:Hide()

	local PropsList = vgui.Create( "DListView", PropsPanel )
	PropsList:SetMultiSelect( false )
	PropsList:SetSize( 390, 275 )
	local ColID = PropsList:AddColumn( "ID" )
	local ColEnt = PropsList:AddColumn( "Entity" )
	local ColMdl = PropsList:AddColumn( "Model" )
	ColID:SetMinWidth(50)
	ColID:SetMaxWidth(50)
	PropsList.Paint = function( self )
		surface.SetDrawColor(17, 148, 240, 255)
	end

	PropsList.OnRowRightClick = function(panel, line)

		local MenuButtonOptions = DermaMenu()
	    MenuButtonOptions:AddOption("Draw entity", function() 

	    	if not LocalPlayer().DrawPPEnt or not istable(LocalPlayer().DrawPPEnt) then LocalPlayer().DrawPPEnt = {} end

	    	if LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] and LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)]:IsValid() then return end

		    local ent = ents.CreateClientProp( Content.PropsList[PropsList:GetLine(line):GetValue(1)].Model ) 
			ent:SetPos( Content.PropsList[PropsList:GetLine(line):GetValue(1)].Pos )
			ent:SetAngles( Content.PropsList[PropsList:GetLine(line):GetValue(1)].Angle )

			LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] = ent

		end )

		if LocalPlayer().DrawPPEnt and LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] then
			
			MenuButtonOptions:AddOption("Stop Drawing", function() 

				LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)]:Remove()
				LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] = nil

			end )

		end

		if LocalPlayer().DrawPPEnt != nil and istable(LocalPlayer().DrawPPEnt) and table.Count(LocalPlayer().DrawPPEnt) > 0 then

			MenuButtonOptions:AddOption("Stop Drawing All", function() 

				for k, v in pairs(LocalPlayer().DrawPPEnt) do
					
					LocalPlayer().DrawPPEnt[k]:Remove()
					LocalPlayer().DrawPPEnt[k] = nil

				end

			end )
			
		end

	    MenuButtonOptions:AddOption("Remove", function()

	    	net.Start("pp_info_send")
	    		net.WriteTable({CMD = "DEL", Val = PropsList:GetLine(line):GetValue(1)})
	    	net.SendToServer()

	    	if LocalPlayer().DrawPPEnt and LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] != nil then

	    		LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)]:Remove()
				LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] = nil
				
	    	end

	    	PropsList:RemoveLine(line)


		end )
	    MenuButtonOptions:Open()
		
	end

	for k, v in pairs(Content.PropsList) do
		
		PropsList:AddLine(k, v.Class, v.Model)

	end

	local BProps = vgui.Create("DButton", Main)
	BProps:SetText("Props List")
	BProps:SetFont("pp_font")
	BProps:SetSize(160, 50)
	BProps:SetPos(15, 115 + 85)
	BProps:SetTextColor( Color( 255, 255, 255, 255 ) )
	BProps.PaintColor = Color(0, 0, 0, 0)
	BProps.Paint = function(self)
		draw.RoundedBox(0, 0, 0, self:GetWide(), self:GetTall(), self.PaintColor)
		surface.SetDrawColor(17, 148, 240, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end
	BProps.DoClick = function( self )

		if BSelect then BSelect.PaintColor = Color(0, 0, 0, 0) end
		BSelect = self
		self.PaintColor = Color(17, 148, 240, 100)

		if PSelect then PSelect:Hide() end
		PropsPanel:Show()
		PSelect = PropsPanel

	end

end

local function loadDataFromAPIAndThenPPOpen()
	AOCRP.API:Request("getpermaprops", function(data) 
	
		pp_open_menu(data)
	
	end, {["map"] = game.GetMap()})
end

net.Receive("pp_open_menu", loadDataFromAPIAndThenPPOpen)

--gamemodes/starwarsrp/gamemode/modules/mychar/cl_mychar.lua:
AOCRP.MyChar = AOCRP.MyChar or {}


AOCDerma:RegisterFont("AOCRP_MyChar_Name", "Agency FB", 80, 1000)
AOCDerma:RegisterFont("AOCRP_MyChar_Ribbons", "Agency FB", 50, 1000)
AOCDerma:RegisterFont("AOCRP_MyChar_Bodygroup", "Agency FB", 30, 100)



local function btnSwitch(btnTbl, btn)
    for k, v in pairs(btnTbl) do
        v.akzent = Color(200,200,200,255)
        v.akzenthover = Color(255,255,255,255)

        v.textcolor = Color(200,200,200,255)
        v.textcolorhover = Color(255,255,255,255)
    end
    btn.akzent = Color(0,200,0,255)
    btn.akzenthover = Color(0,255,0,255)

    btn.textcolor = Color(255,255,255,255)
    btn.textcolorhover = Color(255,255,255,255)
end


function InverseLerp( pos, p1, p2 )

	local range = 0
	range = p2-p1

	if range == 0 then return 1 end

	return ((pos - p1)/range)

end

function AOCRP.MyChar:AbilityMenu()

    if ValidPanel(self.FRAME) then self.FRAME:Remove() end

    self.FRAME = AOCDerma:DefaultFrame("Mein Charakter")
    self.FRAME:SetSize(AOCW(1600),AOCH(900))
    self.FRAME:Center()

	self.pmodel = vgui.Create("DModelPanel", self.FRAME)
	self.pmodel:SetSize( AOCW(600), AOCH(800))
	self.pmodel:SetPos( AOCW(18), AOCH(80) )

	self.pmodel:SetModel( LocalPlayer():GetModel() )

	for k, v in pairs(LocalPlayer():GetMaterials()) do
		if LocalPlayer():GetSubMaterial( k ) != "" then
			self.pmodel.Entity:SetSubMaterial(k, LocalPlayer():GetSubMaterial( k ))
		end
	end


	self.pmodel:SetLookAt( Vector(0,0,72/2) )
	self.pmodel:SetCamPos( Vector(64,0,72/2))




	--self.pmodel:SetLookAng( Angle(0,0,0) )

	self.pmodel.Entity:SetEyeTarget( self.pmodel.Entity:GetPos() + Vector(200,0,64) )

	self.pmodel:SetAmbientLight( Color(10,15,50) )
	self.pmodel:SetDirectionalLight( BOX_TOP, Color(220,190,100) )

	self.pmodel.rot = 115.2
	self.pmodel.fov = 38.36


	self.pmodel:SetFOV( self.pmodel.fov )
	self.pmodel.dragging = false -- left click
	self.pmodel.dragging2 = false -- right click
	self.pmodel.ux = 0
	self.pmodel.uy = 0
	self.pmodel.spinmul = 0.4
	self.pmodel.zoommul = 0.09

	self.pmodel.xmod = 0
	self.pmodel.ymod = 0
	
	self.ClientModelPanel = self.pmodel

	self.pmodel.Entity:SetSkin( LocalPlayer():GetSkin() )

	-- set self.pmodel's bodygroups
	local curgroups = LocalPlayer():GetBodyGroups()
	--PrintTable( curgroups )

	for k,v in pairs( curgroups ) do
		local ent = self.pmodel.Entity
		local cur_bgid = LocalPlayer():GetBodygroup( v.id )
		ent:SetBodygroup( v.id, cur_bgid )
	end

	function self.pmodel.Entity:GetPlayerColor()
		return LocalPlayer():GetPlayerColor()
	end

	function self.pmodel:PaintOver( w, h )
		--surface.SetDrawColor( Color(255,255,255) )
		--surface.DrawOutlinedRect(0,0,w,h)
		--ArizardShadowText(BODYMAN.HelpText, "Bodygroups_Medium", 0,0, Color(255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1 )
	end

	function self.pmodel:LayoutEntity( ent )

		local newrot = self.rot
		local newfov = self:GetFOV()

		if self.dragging == true then
			newrot = self.rot + (gui.MouseX() - self.ux)*self.spinmul
			newfov = self.fov + (self.uy - gui.MouseY()) * self.zoommul
			if newfov < 20 then newfov = 20 end
			if newfov > 75 then newfov = 75 end
		end

		local newxmod, newymod = self.xmod, self.ymod

		if self.dragging2 == true then
			newxmod = self.xmod + (self.ux - gui.MouseX())*0.02
			newymod = self.ymod + (self.uy - gui.MouseY())*0.02
		end

		newxmod = math.Clamp( newxmod, -16, 16 )
		newymod = math.Clamp( newymod, -16, 16 )

		ent:SetAngles( Angle(0,0,0) )
		self:SetFOV( newfov )


        


		-- calculate if we should look at the face
		local height = 72/2
		-- fov between 20 and 75,
		-- height between 72/2 and 72
		local frac = InverseLerp( newfov, 75, 20 )
		height = Lerp( frac, 72/2, 64 )

		-- calculate look ang
		local norm = (self:GetCamPos() - Vector(0,0,64))
		norm:Normalize()
		local lookAng = norm:Angle()

		self:SetLookAt( Vector(0,0,height-(2*frac) ) - Vector( 0, 0, newymod*2*(1-frac) ) - lookAng:Right()*newxmod*2*(1-frac) )
		self:SetCamPos( Vector( 64*math.sin( newrot * (math.pi/180)), 64*math.cos( newrot * (math.pi/180)), height + 4*(1-frac)) - Vector( 0, 0, newymod*2*(1-frac) ) - lookAng:Right()*newxmod*2*(1-frac) )


	end

	function self.pmodel:OnMousePressed( k )
		self.ux = gui.MouseX()
		self.uy = gui.MouseY()
		self.dragging = (k == MOUSE_LEFT) or false 
		self.dragging2 = (k == MOUSE_RIGHT) or false 
	end

	function self.pmodel:OnMouseReleased( k )
		if self.dragging == true then
			self.rot = self.rot + (gui.MouseX() - self.ux)*self.spinmul
			self.fov = self.fov + (self.uy - gui.MouseY()) * self.zoommul
			self.fov = math.Clamp( self.fov, 20, 75 )
		end

		if self.dragging2 == true then
			self.xmod = self.xmod + (self.ux - gui.MouseX())*0.02
			self.ymod = self.ymod + (self.uy - gui.MouseY())*0.02

			self.xmod = math.Clamp( self.xmod, -16, 16 )
			self.ymod = math.Clamp( self.ymod, -16, 16 )
		end

		self.dragging = false 
		self.dragging2 = false


	end

	function self.pmodel:OnCursorExited()
		if self.dragging == true or self.dragging2 == true then
			self:OnMouseReleased()
		end
	end

    local sidepanel = vgui.Create("DPanel", self.FRAME)
    sidepanel:Dock(RIGHT)
    sidepanel:SetWide(AOCW(950))
    sidepanel:SetPaintBackground(false)


    local namePanel = vgui.Create("DPanel", sidepanel)
    namePanel:Dock(TOP)
    namePanel:SetTall(AOCH(85))

    function namePanel:Paint(w,h)
        AOCDerma:DrawTextShadow(LocalPlayer():Name(), AOCDerma:Font("AOCRP_MyChar_Name"), w/2, 0, Color(255,255,255), TEXT_ALIGN_CENTER)
        --draw.RoundedBox(0,0,h-2,w,2,Color(255,255,255))
    end

    local navBar = vgui.Create("DPanel", sidepanel)
    navBar:Dock(TOP)
    navBar:SetTall(AOCH(50))
    navBar:SetPaintBackground(false)
    
    function navBar:Paint(w,h)

        draw.RoundedBox(0,0,h-3,w,3,Color(200,200,200))
    end

    local buttons = {}
    buttons.Kleidung = AOCDerma:Button(navBar, "Kleidung", function(self) btnSwitch(buttons, self) AOCRP.MyChar:OpenCloset() end, "b")
    buttons.Kleidung:Dock(LEFT)
    buttons.Kleidung:DockMargin(0,0,10,0)


    buttons.Ribbons = AOCDerma:Button(navBar, "Ribbons", function(self) btnSwitch(buttons, self) AOCRP.MyChar:OpenRibbons() end, "b")
    buttons.Ribbons:Dock(LEFT)
    buttons.Ribbons:DockMargin(0,0,10,0)


    buttons.Stats = AOCDerma:Button(navBar, "Stats", function(self) btnSwitch(buttons, self) AOCRP.MyChar:OpenStats() end, "b")
    buttons.Stats:Dock(LEFT)
    buttons.Stats:DockMargin(0,0,10,0)

    buttons.Skins = AOCDerma:Button(navBar, "Skins", function(self) btnSwitch(buttons, self) AOCRP.MyChar:OpenSkins() end, "b")
    buttons.Skins:Dock(LEFT)
    buttons.Skins:DockMargin(0,0,10,0)

    buttons.Skills = AOCDerma:Button(navBar, "Fähigkeiten", function(self) btnSwitch(buttons, self)  AOCRP.MyChar:OpenSkills() end, "b")
    buttons.Skills:Dock(LEFT)
    buttons.Skills:DockMargin(0,0,10,0)


    self.contentPanel =  AOCDerma:ScrollBar(sidepanel) 
    self.contentPanel:Dock(TOP)
    self.contentPanel:SetTall(AOCH(655))

    btnSwitch(buttons, buttons.Kleidung) AOCRP.MyChar:OpenCloset() 



--[[     local cpanlist = vgui.Create("DIconLayout", contentPanel)
	cpanlist:SetSize( contentPanel:GetWide()-8, contentPanel:GetTall() - 8 )
	cpanlist:SetPos( 4, 4 )
	cpanlist:SetSpaceX( 4 )
	cpanlist:SetSpaceY( 4 )

    BODYMAN.cpanlist = contentPanel
	BODYMAN.cpanscroll = contentPanel

	BODYMAN:RefreshAppearanceMenu( ) ]]


end


concommand.Add( "aocrp_mychar", function( ply, cmd, args )
    AOCRP.MyChar:AbilityMenu()
end )

function AOCRP.MyChar:OpenStats()
    self.contentPanel:Clear()

    AOCDerma:QuickLabel(" ", self.contentPanel)
    AOCDerma:QuickLabel("Gesundheit: "..LocalPlayer():GetMaxHealth(), self.contentPanel)
    AOCDerma:QuickLabel("Rüstung: "..LocalPlayer():GetMaxArmor(), self.contentPanel)
    AOCDerma:QuickLabel(" ", self.contentPanel)
    AOCDerma:QuickLabel("Geschwindigkeit: "..LocalPlayer():GetRunSpeed(), self.contentPanel)
    AOCDerma:QuickLabel("Sprungkraft: "..LocalPlayer():GetJumpPower(), self.contentPanel)

end


AOCDerma:RegisterFont("SkinName", "Agency FB", 45, 1000)

function AOCRP.MyChar:OpenSkins()
    self.contentPanel:Clear()

    for k, v in pairs(AOCRP.GTM.Items) do
        if table.HasValue({"Körperskins","Helmskins","Skinbundles","CustomSkins","CustomAttachments"}, v.category) then
            if v.limitFunc(LocalPlayer()) then
                if AOCRP.GTM:HasItem(LocalPlayer(), k) then

                    local skinPanel = vgui.Create("DPanel", self.contentPanel)
                    skinPanel:Dock(TOP)
                    skinPanel:SetTall(AOCH(75))
                    skinPanel:DockMargin(0,0,0,AOCH(5))
                    skinPanel:DockPadding(0,AOCH(10),AOCW(15), AOCH(10))
                    function skinPanel:Paint(w,h) 
                        
                        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))
                        AOCDerma:DrawTextShadow(v.name, AOCDerma:Font("SkinName"), AOCW(10), AOCH(15), Color(255,255,255), TEXT_ALIGN_LEFT)
                    end 

                    local btn = AOCDerma:Button(skinPanel, "Ausrüsten", function() 
                        net.Start("AOCRP.GTM.PlayerApply")
                        net.WriteString(k)
                        net.SendToServer()
                    end, "b")
                    btn:Dock(RIGHT)
                    btn:DockMargin(AOCW(10),0,0,0)
                    local btn = AOCDerma:Button(skinPanel, "Anschauen", function() 
                        v.applyFunc(self.pmodel.Entity)
                    
                    end, "b")
                    btn:DockMargin(AOCW(10),0,0,0)
                    btn:Dock(RIGHT)
                end
            end
        end
    end

    for k, v in pairs(AOCRP.GTM.Items) do
        if table.HasValue({"Körperskins","Helmskins","Skinbundles","CustomSkins","CustomAttachments"}, v.category) then
            if v.limitFunc(LocalPlayer()) then
                if !AOCRP.GTM:HasItem(LocalPlayer(), k) then

                    local skinPanel = vgui.Create("DPanel", self.contentPanel)
                    skinPanel:Dock(TOP)
                    skinPanel:SetTall(AOCH(75))
                    skinPanel:DockMargin(0,0,0,AOCH(5))
                    skinPanel:DockPadding(0,AOCH(10),AOCW(15), AOCH(10))
                    function skinPanel:Paint(w,h) 
                        
                        draw.RoundedBox(0,0,0,w,h,Color(32,0,0,200))
                        AOCDerma:DrawTextShadow(v.name, AOCDerma:Font("SkinName"), AOCW(10), AOCH(15), Color(255,255,255), TEXT_ALIGN_LEFT)
                    end 

         

                    local btn = AOCDerma:Button(skinPanel, "Kaufen", function() 
                        AOCRP.GTM:OpenItem(k)
                    end, "b")
                    btn:DockMargin(AOCW(10),0,0,0)
                    btn:Dock(RIGHT)

                    local btn = AOCDerma:Button(skinPanel, "Anschauen", function() 
                        v.applyFunc(self.pmodel.Entity)
                    end, "b")
                    btn:DockMargin(AOCW(10),0,0,0)
                    btn:Dock(RIGHT)
                end
            end
        end
    end

end


function AOCRP.MyChar:OpenRibbons()
    self.contentPanel:Clear()

    
--[[     local myRibbonsPanel = vgui.Create("DPanel", self.contentPanel)
    myRibbonsPanel:Dock(TOP)
    function myRibbonsPanel:Paint(w,h)
        AOCDerma:DrawTextShadow("Deine Ribbons", AOCDerma:Font("AOCRP_MyChar_Ribbons"), 10, 0, Color(255,255,255), TEXT_ALIGN_LEFT)
    end
    myRibbonsPanel:SetTall(AOCH(50))
    myRibbonsPanel:DockPadding(0,AOCH(50),0,0)
    myRibbonsPanel:DockMargin(0,AOCH(30),0,0) ]]
    
--[[     local otherRibbons = vgui.Create("DPanel", self.contentPanel)
    otherRibbons:Dock(TOP)
    otherRibbons:DockMargin(0,AOCH(50),0,0)

    function otherRibbons:Paint(w,h)
        AOCDerma:DrawTextShadow("Ribbons die du nicht hast", AOCDerma:Font("AOCRP_MyChar_Ribbons"), 10, 0, Color(255,255,255), TEXT_ALIGN_LEFT)
    end
    otherRibbons:SetTall(AOCH(50))
    otherRibbons:DockPadding(0,AOCH(50),0,0) ]]

    local button =  AOCDerma:Button(AOCRP.MyChar.contentPanel, "Alle Ribbons", function() AOCRP.MyChar:AllRibbons() AOCRP.MyChar.FRAME:Remove() end, "b")
    button:Dock(TOP)

    local myribs = {}

    AOCRP.API:Request("getmyribbons", function(result) 
        

        
        if istable(result) and #result > 0 then
            

            for k, v in pairs(result) do
                AOCRP.MyChar:AddRibbonToPnl(v.ribbonid, AOCRP.MyChar.contentPanel,false) 
                table.insert(myribs, v.ribbonid)
            end
            --myRibbonsPanel:SetTall(AOCH(85*#result)+AOCH(80))
            	
  
 
        end
    
    
    end, {["charid"]=tostring(LocalPlayer():GetCloneID())}, function() end)


end

function AOCRP.MyChar:AllRibbons()

    AOCRP.API:Request("getribbons", function(secondresult) 

        AOCRP.MyChar.AllFrame = AOCDerma:DefaultFrame("Alle Ribbons")
        AOCRP.MyChar.AllFrame:SetSize(ScrW()*0.5, ScrH()*0.8)
        AOCRP.MyChar.AllFrame:Center()
        local panel = AOCDerma:ScrollBar(AOCRP.MyChar.AllFrame) 
        panel:Dock(FILL)

        if istable(secondresult) and #secondresult > 0 then
            PrintTable(secondresult)
            for k, v in pairs(secondresult) do
                AOCRP.MyChar:AddRibbonToPnl(v.ribbonid, panel,true) 
            end
        end
    end, {}, function() end)

end


local function SendActiveRequest(ribbon, slot)
    net.Start("AOCRP.Ribbons.SetActive")
    net.WriteInt(ribbon, 14)
    net.WriteString(slot)
    net.SendToServer()
end
local function ClearSlots()
    net.Start("AOCRP.Ribbons.SetActive")
    net.WriteInt(0, 14)
    net.WriteString("1")
    net.SendToServer()
    net.Start("AOCRP.Ribbons.SetActive")
    net.WriteInt(0, 14)
    net.WriteString("2")
    net.SendToServer()
    net.Start("AOCRP.Ribbons.SetActive")
    net.WriteInt(0, 14)
    net.WriteString("3")
    net.SendToServer()
end


AOCDerma:RegisterFont("AOCRP.Ribbon.Title", "Agency FB", 40, 50)
AOCDerma:RegisterFont("AOCRP.Ribbon.Description", "Agency FB", 20, 10)
function AOCRP.MyChar:AddRibbonToPnl(ribbonid, pnl,blocked) 

    if ValidPanel(pnl) then
        if AOCRP.Ribbons:Exists(ribbonid) then
            print(ribbonid.." exists")
            local ribbonData = AOCRP.Ribbons:GetRibbon(ribbonid)
            if ribbonid == 46 then 
                PrintTable(ribbonData)
            end
            local ribbonPnl = vgui.Create("DButton", pnl)
            ribbonPnl:Dock(TOP)
            ribbonPnl:SetTall(AOCH(80))
            ribbonPnl.ribbonData = ribbonData
            ribbonPnl:SetText("")
            ribbonPnl:DockMargin(0,AOCH(5),0,0)

            function ribbonPnl:Paint(w,h)
                draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))
                PIXEL.DrawImgur(AOCW(5), AOCH(5), AOCW(200), AOCH(70), self.ribbonData.url, Color(255,255,255))
                AOCDerma:DrawTextShadow(self.ribbonData.name, AOCDerma:Font("AOCRP.Ribbon.Title"), AOCW(220), AOCH(5), Color(255,255,255), TEXT_ALIGN_LEFT)
                AOCDerma:DrawTextShadow(self.ribbonData.description,  AOCDerma:Font("AOCRP.Ribbon.Description"), AOCW(220), AOCH(50), Color(255,255,255), TEXT_ALIGN_LEFT)


                if AOCRP.Ribbons:RibbonActive(LocalPlayer(), ribbonid) then
                    surface.SetDrawColor(0,255,0)
                    surface.DrawOutlinedRect(0, 0, w, h,1)
                end
            end

            function ribbonPnl:DoClick()
                if blocked then return end
                local menu = DermaMenu() 
                menu:AddOption( "Ribbon-Slot 1", function() SendActiveRequest(ribbonid, "1") end )
                menu:AddOption( "Ribbon-Slot 2", function() SendActiveRequest(ribbonid, "2") end )
                menu:AddOption( "Ribbon-Slot 3", function() SendActiveRequest(ribbonid, "3") end )
                menu:AddOption( "Alle Slots leeren", function() ClearSlots() end )
                menu:Open()
            end
        end
    end
end

AOCDerma:RegisterFont("AOCRP.Skills.Icon", "Aurebesh", 40, 50)
AOCDerma:RegisterFont("AOCRP.Skills.Title", "Agency FB", 30, 1000)
AOCDerma:RegisterFont("AOCRP.Skills.Description", "Agency FB", 20, 10)
function AOCRP.MyChar:OpenSkills()
    self.contentPanel:Clear()

    AOCDerma:QuickLabel("", self.contentPanel)
    AOCDerma:QuickLabel("Erfahrungspunkte: "..LocalPlayer():GetXP().."/"..AOCRP.Config.XPForPoint.." -- Fähigkeitspunkte: "..LocalPlayer():GetFP(), self.contentPanel)


    local AbilityPanels = {}

    local AOCRP_ABILITY = {}
    AOCRP.API:Request("getabilitybychar", function(data) 

		if (type(data) == "table" and #data > 0) then
            for k, v in pairs(data) do
                AOCRP_ABILITY[v.ability] = v
            end
        end;
    



        for k, v in SortedPairs(AOCRP.Ability.Items) do

            if v.requires != nil then
                if !AOCRP_ABILITY[v.requires] then continue end

                if AOCRP_ABILITY[k] then
                    AbilityPanels[v.requires]:Remove()
                end
            end

            local abilityPanel = vgui.Create("DPanel",self.contentPanel)
            abilityPanel:Dock(TOP)
            abilityPanel:SetTall(AOCH(75))
            abilityPanel:DockMargin(0,0,0,AOCH(5))

            function abilityPanel:Paint(w,h) 
                draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))
                draw.DrawText(v.icon, AOCDerma:Font("AOCRP.Skills.Icon"), AOCW(10),AOCH(20),Color(255,255,255),TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

                draw.DrawText(v.name, AOCDerma:Font("AOCRP.Skills.Title"), AOCW(130),AOCH(10),Color(255,255,255),TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
                draw.DrawText(v.desc.." - Abklingzeit: "..v.delay.."s", AOCDerma:Font("AOCRP.Skills.Description"), AOCW(130),AOCH(40),Color(255,255,255),TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
            end 


            if AOCRP_ABILITY[k] then
                if !v.passive then 

                    local btn = AOCDerma:Button(abilityPanel, "Auswählen", function() 
                    
                        net.Start("AOCRP.Ability.Select")
                            net.WriteString(k)
                        net.SendToServer()

                        if ValidPanel(self.FRAME) then self.FRAME:Remove() end
                    end, "b")
                    btn:DockMargin(0,AOCH(15),AOCW(10),AOCH(15))
                    btn:Dock(RIGHT)
                else 
                    local btn = AOCDerma:Button(abilityPanel, "Im Besitz (passiv)", function() end, "b")
                    btn:DockMargin(0,AOCH(15),AOCW(10),AOCH(15))
                    btn:Dock(RIGHT)
                end
            else
                local btn = AOCDerma:Button(abilityPanel, "Für "..v.cost.." FP erlernen", function() 
                
                    net.Start("AOCRP.Ability.Buy")
                    net.WriteString(k)

                    
                    if ValidPanel(self.FRAME) then self.FRAME:Remove() end

                net.SendToServer()
                end, "b")
                
            btn:DockMargin(0,AOCH(15),AOCW(10),AOCH(15))
                btn:Dock(RIGHT)
            end 

            AbilityPanels[k] = abilityPanel 

        end
    end, {cloneid=LocalPlayer():GetCloneID()})

end   



function AOCRP.MyChar:OpenComingSoon()
    self.contentPanel:Clear()

    local myRibbonsPanel = vgui.Create("DPanel", self.contentPanel)
    myRibbonsPanel:Dock(TOP)
    function myRibbonsPanel:Paint(w,h)
        AOCDerma:DrawTextShadow("Bald verfügbar!", AOCDerma:Font("AOCRP_MyChar_Ribbons"), 10, 0, Color(255,255,255), TEXT_ALIGN_LEFT)
    end
    myRibbonsPanel:SetTall(AOCH(50))
    myRibbonsPanel:DockPadding(0,AOCH(50),0,0)
    myRibbonsPanel:DockMargin(0,AOCH(30),0,0)

end


AOCDerma:RegisterFont("AOCRP_KleiderschrankBtns", "Agency FB", 30, 1000)
AOCDerma:RegisterFont("AOCRP_KleiderschrankBtnsModels", "Agency FB", 20, 1000)

function AOCRP.MyChar:OpenCloset()
    self.contentPanel:Clear()

    local allowedbodygroups = {}

    local ply = LocalPlayer()
    for bgIndex, bg in pairs(ply:GetBodyGroups()) do
        for k,v in pairs( bg ) do
            if k == "name" then
                allowedbodygroups[v] = {}
                for k2, v2 in pairs( bg["submodels"] ) do
                    table.insert( allowedbodygroups[v], k2 )
                end
            end
        end	
    end



	local job = AOCRP.Gear:PlayerGetGearData(LocalPlayer())


        local bodygroupPanel = vgui.Create("DPanel", self.contentPanel)
        bodygroupPanel:Dock(TOP)
        function bodygroupPanel:Paint(w,h)
            draw.RoundedBox(0,0,0,w,h,Color(0,0,0,150))
            AOCDerma:DrawTextShadow("Model", AOCDerma:Font("AOCRP_MyChar_Bodygroup"), 15, 10, Color(255,255,255), TEXT_ALIGN_LEFT)
        end
        bodygroupPanel:SetTall(AOCH(50))
        --bodygroupPanel:DockPadding(0,AOCH(30),0,0)
        bodygroupPanel:DockMargin(0,AOCH(10),0,0)

        local playermodels = job.models

		for k=1,#playermodels do
			local mdl = playermodels[k]

            --if BODYMAN:HasBodyGroup( LocalPlayer(), bgname, i ) then


			local btn = AOCDerma:Button(bodygroupPanel, k, function() 
				AOCRP.MyChar.ClientModelPanel:SetModel( mdl )

				net.Start("AOCRP.Closet.Model")
				net.WriteString(mdl)
				net.SendToServer()

				AOCRP.MyChar:OpenCloset()
			end, "b" )

                btn:Dock(RIGHT)
                btn.textfont = AOCDerma:Font("AOCRP_KleiderschrankBtns")
                btn:DockMargin(0,0,AOCW(5),0)


            --end
        end





    local skintable = {}

	for i=0,LocalPlayer():SkinCount()-1 do
		table.insert( skintable, i )
	end


        local bodygroupPanel = vgui.Create("DPanel", self.contentPanel)
        bodygroupPanel:Dock(TOP)
        function bodygroupPanel:Paint(w,h)
            draw.RoundedBox(0,0,0,w,h,Color(0,0,0,150))
            AOCDerma:DrawTextShadow("Skin", AOCDerma:Font("AOCRP_MyChar_Bodygroup"), 15, 10, Color(255,255,255), TEXT_ALIGN_LEFT)
        end
        bodygroupPanel:SetTall(AOCH(50))
        --bodygroupPanel:DockPadding(0,AOCH(30),0,0)
        bodygroupPanel:DockMargin(0,AOCH(10),0,0)

        for _,i in ipairs(skintable) do

            --if BODYMAN:HasBodyGroup( LocalPlayer(), bgname, i ) then


            local btn = AOCDerma:Button(bodygroupPanel, tostring(i), function() 
                AOCRP.MyChar.ClientModelPanel.Entity:SetSkin( i )

                net.Start("AOCRP.Closet.Skin")
                net.WriteInt(i, 8)
                net.SendToServer()
            end, "b" )

                btn:Dock(RIGHT)
                btn.textfont = AOCDerma:Font("AOCRP_KleiderschrankBtns")
                btn:DockMargin(0,0,AOCW(5),0)


            --end
        end






    for bgname, bgtable in pairs( allowedbodygroups ) do
        local bodygroupPanel = vgui.Create("DPanel", self.contentPanel)
        bodygroupPanel:Dock(TOP)
        function bodygroupPanel:Paint(w,h)
            draw.RoundedBox(0,0,0,w,h,Color(0,0,0,150))
            AOCDerma:DrawTextShadow(bgname, AOCDerma:Font("AOCRP_MyChar_Bodygroup"), 15, 10, Color(255,255,255), TEXT_ALIGN_LEFT)
        end
        bodygroupPanel:SetTall(AOCH(50))
        --bodygroupPanel:DockPadding(0,AOCH(30),0,0)
        bodygroupPanel:DockMargin(0,AOCH(10),0,0)

        for _,i in ipairs(bgtable) do

            --if BODYMAN:HasBodyGroup( LocalPlayer(), bgname, i ) then

                local btn = AOCDerma:Button(bodygroupPanel, tostring(i), function() 
                
                    local ent = AOCRP.MyChar.ClientModelPanel.Entity
                    local bgid = ent:FindBodygroupByName( bgname )
                    if bgid ~= -1 then
                        ent:SetBodygroup( bgid, i )

                        net.Start("AOCRP.Closet.Bodygroup")
                        net.WriteInt(bgid, 6)
                        net.WriteInt(i, 6)
                        net.SendToServer()
                    end
                
                
                end, "b")

                btn:Dock(RIGHT)
                btn.textfont = AOCDerma:Font("AOCRP_KleiderschrankBtns")
                btn:DockMargin(0,0,AOCW(5),0)


            --end
        end
    end


    
    local btn = AOCDerma:Button(self.contentPanel, "Als Standard speichern", function() 
        net.Start("AOCRP.Closet.Save")
        net.SendToServer()
    
    end, "bc")
    btn:Dock(TOP)
    btn:DockMargin(0,AOCH(10),0,0)

end











--gamemodes/starwarsrp/gamemode/modules/gtm/cl_gtm.lua:
AOCRP.GTM = AOCRP.GTM or {}

CreateClientConVar("aocrp_gtm_crosshair", "default", true, false)
CreateClientConVar("aocrp_gtm_hud", "default", true, false)
CreateClientConVar("aocrp_gtm_skin_kopf", "default", true, true)
CreateClientConVar("aocrp_gtm_skin_body", "default", true, true)
CreateClientConVar("aocrp_gtm_helmoverlay", "", true, true)
CreateClientConVar("aocrp_gtm_scoreboardplayer", "false", true, true)


AOCRP.GTM.CategoryPrio = {}


AOCRP.GTM.CategoryPrio["Eventcharaktere"] = 1
AOCRP.GTM.CategoryPrio["Helmskins"] = 10
AOCRP.GTM.CategoryPrio["Körperskins"] = 11
AOCRP.GTM.CategoryPrio["Waffen"] = 20
AOCRP.GTM.CategoryPrio["Waffenzubehör"] = 21
AOCRP.GTM.CategoryPrio["Charms"] = 22

function AOCRP.GTM:GetCategorys()
    local categorys = {}

    for k, v in pairs(AOCRP.GTM.Items) do
        if v.limitFunc(LocalPlayer()) then
            if !table.HasValue(categorys,v.category) then
                categorys[v.category] = 99

                if AOCRP.GTM.CategoryPrio[v.category] then 
                    categorys[v.category] = AOCRP.GTM.CategoryPrio[v.category] 
                end
            end
        end
    end
    return categorys
end

local function FormatMoney(amount)
    return AOCDerma:FormatMoney(amount)
end

PIXEL.RegisterFont("AOCRP.GTM.CategoryTitle", "Agency FB", 30, 1000)
PIXEL.RegisterFont("AOCRP.GTM.MyMoney", "Aurebesh", 30, 10)
function AOCRP.GTM:OpenMenu()
    if ValidPanel(self.FRAME) then self.FRAME:Remove() end
    self.FRAME = AOCDerma:DefaultFrame()
    self.FRAME:SetSize(AOCW(1800),AOCH(1000))
    self.FRAME:Center()
    self.FRAME:SetNewTitle("Galactic Trade Market")
    self.FRAME:SetSizable(false)
    self.FRAME:SetDraggable(false)

    local topBar = vgui.Create("DPanel",self.FRAME )
    topBar:SetPaintBackground(false)
    topBar:Dock(TOP)
    topBar:SetTall(AOCH(50))

    local moneyPanel = vgui.Create("DPanel", topBar)
    moneyPanel:Dock(RIGHT)
    moneyPanel:SetTall(50)
    moneyPanel:SetWide(300)
    moneyPanel:DockMargin(10,0,0,0)
    moneyPanel.Paint = function(self, w, h)
        draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 203))

        draw.DrawText(FormatMoney(LocalPlayer():getMoney()), PIXEL.UI.RegisteredFonts["AOCRP.GTM.MyMoney"], w/2, 12, Color(0,201,10), TEXT_ALIGN_CENTER)

        surface.SetDrawColor( 255, 255, 255, 128 )
        surface.DrawOutlinedRect(0,0,w,h,1)

    end

    local searchBar = AOCDerma:TextEntry(topBar,"Artikel suchen...")
    searchBar:Dock(TOP)
    searchBar.Paint = function(self, w, h)
        draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 203))
        self:DrawTextEntryText(Color(255, 255, 255), Color(74, 168, 255, 176), Color(255, 255, 255))
    end
    self.ItemCategorys = {}
    self.ItemCategorysHeaders = {}
    searchBar:SetPlaceholderText("Artikel suchen...")
    searchBar:SetUpdateOnType(true)
    searchBar:SetTabbingDisabled( true )
    searchBar:SetTall(AOCH(50))
    searchBar:DockMargin(0,0,0,AOCH(10))
    searchBar.OnValueChange = function(text)
        AOCRP.GTM:AddItems(searchBar:GetText())
    end



    local itemScroll = AOCDerma:ScrollBar( self.FRAME) 
    itemScroll:Dock(FILL)
    --itemScroll:DockMargin(AOCW(50),AOCH(65),AOCW(50),AOCH(10))


    for k, v in SortedPairsByValue(AOCRP.GTM:GetCategorys()) do
            local DCollapsible = vgui.Create( "DCollapsibleCategory", itemScroll )	-- Create a collapsible category
            DCollapsible:SetLabel("")						-- Set the name ( label )
            DCollapsible.NewLabel = k
            DCollapsible:SetExpanded( true )	-- Start collapsed
                   DCollapsible.Header:SetTall(AOCH(40))
            DCollapsible:Dock(TOP)

			DCollapsible.Paint = function() end
			DCollapsible.Header.Paint = function(self, w,h)
			    draw.SimpleText( DCollapsible.NewLabel .. " ("..#AOCRP.GTM.ItemCategorys[k]:GetChildren()..")", PIXEL.UI.RegisteredFonts["AOCRP.GTM.CategoryTitle"], AOCW(10), h/2, Color(255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
                surface.SetDrawColor(Color(255,255,255,10))
                surface.DrawRect(0, h-1, w, 1)
			end
            DCollapsible:DockMargin(0,0,0,AOCH(15))

            local items = vgui.Create("DTileLayout", DCollapsible)
            items:SetBaseSize(AOCH(200)) -- Tile size
            --items:SetTall(500)
            items:DockMargin(AOCW(15),AOCH(10),0,0)
            items:Dock(TOP)
        
            //Draw a background so we can see what it's doing
            items:SetPaintBackground(false)
            items:SetBackgroundColor(Color(0, 100, 100))
            items:SetSpaceX( AOCW(10) )
            items:SetSpaceY( AOCH(10) )

            self.ItemCategorys[k] = items
            self.ItemCategorysHeaders[k] = DCollapsible
    end
    
    AOCRP.GTM:AddItems()
end


function AOCRP.GTM:AddItems(searchfilter)

    for k, v in pairs(self.ItemCategorys) do
     v:Clear()
    end

    if !searchfilter then
        for k,v in pairs(AOCRP.GTM.Items) do 
            if v.limitFunc(LocalPlayer()) then
                AOCRP.GTM:CreateItem(k,self.ItemCategorys[v.category])
            end
        end 
    else
        for k,v in pairs(AOCRP.GTM.Items) do 
            if string.find( string.lower(v.name), string.lower(searchfilter) ) then
                if v.limitFunc(LocalPlayer()) then
                    AOCRP.GTM:CreateItem(k,self.ItemCategorys[v.category])
                end
            end
        end   
    end


   
end



PIXEL.RegisterFont("AOCRP.GTM.ItemPrice", "Aurebesh", 15, 100)
PIXEL.RegisterFont("AOCRP.GTM.ItemName", "Agency FB", 30, 100)
PIXEL.RegisterFont("AOCRP.GTM.ItemTag", "Agency FB", 30, 1000)

function AOCRP.GTM:CreateItem(itemid,parent)
    local itemData = AOCRP.GTM.Items[itemid]

    if !itemData.canBuy and !AOCRP.GTM:HasItem(LocalPlayer(), itemid) then return end

    local item = vgui.Create("DPanel", parent)
    item:SetSize(AOCH(200),AOCH(200))

    function item:Paint(w,h)
        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))

    end

    function item:PaintOver(w,h)
        draw.RoundedBox(0,0,AOCH(150),w,AOCH(50),Color(0,0,0,200))

        draw.DrawText(FormatMoney(itemData.price), PIXEL.UI.RegisteredFonts["AOCRP.GTM.ItemPrice"], w/2, AOCH(180), Color(0,201,10), TEXT_ALIGN_CENTER)
        draw.DrawText(itemData.name, PIXEL.UI.RegisteredFonts["AOCRP.GTM.ItemName"], w/2, AOCH(150), Color(255,255,255), TEXT_ALIGN_CENTER)

        if AOCRP.GTM:HasItem(LocalPlayer(), itemid) then
            surface.SetDrawColor( 122, 255, 70, 128)
        else
            if itemData.vipFree then
                surface.SetDrawColor( 195, 0, 255, 128)
            else 
                surface.SetDrawColor( 255, 255, 255, 128 )
            end

        end
        surface.DrawOutlinedRect(0,0,w,h,1)

        if itemData.vipOnly then
            draw.DrawText("VIP", PIXEL.UI.RegisteredFonts["AOCRP.GTM.ItemTag"], AOCW(5), 0, Color(201,0,0), TEXT_ALIGN_LEFT)
        end
        if itemData.sale then
            draw.DrawText("% SALE %", PIXEL.UI.RegisteredFonts["AOCRP.GTM.ItemTag"], w - AOCW(5), 0, Color(201,0,0), TEXT_ALIGN_RIGHT)
        end
    end  
    
    local icon = vgui.Create("DPanel", item)
    icon:Dock(FILL)
    icon:SetPaintBackground(false)
    --icon:DockMargin(1,1,1,200)
    
    itemData.iconFunc(icon)

    local itemBtn = vgui.Create("DButton", item)
    itemBtn:SetSize(AOCH(200),AOCH(200))
    itemBtn:SetText("")
    function itemBtn:Paint(w,h)
    end
    function itemBtn:DoClick()
        AOCRP.GTM:OpenItem(itemid)
    end

    return item
end



PIXEL.RegisterFont("AOCRP.GTM.ItemPreviewPrice", "Aurebesh", 30, 100)
PIXEL.RegisterFont("AOCRP.GTM.ItemPreviewName", "Agency FB", 50, 100)
PIXEL.RegisterFont("AOCRP.GTM.ItemPreviewDesc", "Agency FB", 30, 100)





function AOCRP.GTM:OpenItem(item)
    if ValidPanel(self.FRAME) then self.FRAME:Remove() end

    if !AOCRP.GTM:ItemExists(item) then return end

    local itemData = AOCRP.GTM:GetItemData(item)
    self.FRAME = AOCDerma:DefaultFrame()
    self.FRAME:SetSize(AOCW(550),AOCH(1000))
    self.FRAME:Center()
    self.FRAME:SetNewTitle("GTM: "..itemData.name)
    self.FRAME:SetSizable(false)
    self.FRAME:SetDraggable(false)

    local previewFrame = vgui.Create("DPanel",self.FRAME)
    previewFrame:Dock(TOP)
    previewFrame:SetTall(AOCH(500))
    previewFrame:SetPaintBackground(false)
    previewFrame:DockMargin(0,0,0,AOCH(10))
    function previewFrame:PaintOver(w,h)
        surface.SetDrawColor( 255, 255, 255, 128 )
        surface.DrawOutlinedRect(0,0,w,h,1)
    end 
    itemData.previewFunc(previewFrame)

    local infoNBuy = vgui.Create("DPanel",self.FRAME)
    infoNBuy:Dock(FILL)

    function infoNBuy:Paint(w,h)
        draw.DrawText(FormatMoney(itemData.price), PIXEL.UI.RegisteredFonts["AOCRP.GTM.ItemPreviewPrice"], w/2, AOCH(60), Color(0,201,10), TEXT_ALIGN_CENTER)
        draw.DrawText(itemData.name, PIXEL.UI.RegisteredFonts["AOCRP.GTM.ItemPreviewName"], w/2, AOCH(10), Color(255,255,255), TEXT_ALIGN_CENTER)    
        
        draw.DrawText(AOCDerma:AddLineBreaks(itemData.desc,70), PIXEL.UI.RegisteredFonts["AOCRP.GTM.ItemPreviewDesc"], w/2, AOCH(100), Color(255,255,255), TEXT_ALIGN_CENTER)  
    end

--[[     AOCRP.GTM.PlayerBuy
    AOCRP.GTM.PlayerSell
    AOCRP.GTM.PlayerApply
 ]]
    if itemData.permanent then
        if AOCRP.GTM:HasItem(LocalPlayer(), item) then
            if itemData.apply then
                local buy = AOCDerma:Button(infoNBuy, "Anwenden", function() 
                    net.Start("AOCRP.GTM.PlayerApply")
                    net.WriteString(item)
                    net.SendToServer()
                    if ValidPanel(self.FRAME) then self.FRAME:Remove() end
                end, "b")
                buy:Dock(TOP)
                buy:DockMargin(0,AOCH(200),0,0)
            end
            if itemData.canSell then
               
                    local sell = AOCDerma:Button(infoNBuy, "Verkaufen (80%)", function() 

                        if itemData.vipFree and LocalPlayer():GetAOCVIP() then
                            LocalPlayer():ChatPrint("*** Dieses Item wurde dir Gratis zu Verfügung gestellt. Du kannst es nicht verkaufen.")
                        else 
                            net.Start("AOCRP.GTM.PlayerSell")
                            net.WriteString(item)
                            net.SendToServer()  
                            if ValidPanel(self.FRAME) then self.FRAME:Remove() end  
                        end
        
                    end, "b")
                    sell:Dock(TOP)    
                    if !itemData.apply then
                        sell:DockMargin(0,AOCH(200),0,0)
                    end   

            end 
        else
            local sell = AOCDerma:Button(infoNBuy, "Kaufen", function()

                if !itemData.canBuy then AOCDerma:Derma_Message( "Das Item verkauf ich derzeit nicht.", "Ey yo", "Schade" ) return end
                if LocalPlayer():canAfford(itemData.price) then
                    net.Start("AOCRP.GTM.PlayerBuy")
                    net.WriteString(item)
                    net.SendToServer()   
                    if ValidPanel(self.FRAME) then self.FRAME:Remove() end 
                else 
                    AOCDerma:Derma_Message( "Du kannst dir das nicht leisten", "Fehler", "Schade" )
                end             
            end, "b")
            sell:Dock(TOP) 
            sell:DockMargin(0,AOCH(200),0,0)   

        end
    else
        local buy = AOCDerma:Button(infoNBuy, "Kaufen", function()
            net.Start("AOCRP.GTM.PlayerBuy")
            net.WriteString(item)
            net.SendToServer()       
            if ValidPanel(self.FRAME) then self.FRAME:Remove() end      
        end, "b")
        buy:Dock(TOP)
        buy:DockMargin(0,AOCH(200),0,0)   
        buy:DockMargin(0,AOCH(200),0,0)   
    end
    

    local back = AOCDerma:Button(infoNBuy, "Zurück", function() AOCRP.GTM:OpenMenu() end, "b")
    back:Dock(BOTTOM)

end


--AOCRP.GTM:OpenItem("imgur_test")

net.Receive( "AOCRP.GTM.OpenItem", function( len, ply )
    local item = net.ReadString()
    AOCRP.GTM:OpenItem(item)
end )






--gamemodes/starwarsrp/gamemode/modules/gamemec/sh_globalsystems.lua:



function AOCRP:GetComlinkUp()
    return !GetGlobalNetVar("AOCRP_FUNKAUS", false) 
end







if SERVER then
util.AddNetworkString("AOCRP.SoundWithDistance")
end

function AOCRP:DoubleSoundPlay(close, distant, range, pos)

    if CLIENT then
        
        local dist = LocalPlayer():GetPos():DistToSqr(pos)

        LocalPlayer():ChatPrint(range*range.. " > "..dist)
        
        if dist > range*range then
            surface.PlaySound(distant)
        else 
            surface.PlaySound(close)
        end
    end

    if SERVER then
        net.Start("AOCRP.SoundWithDistance")
            net.WriteString(close)
            net.WriteString(distant)
            net.WriteFloat(range)
            net.WriteVector(pos)
        net.Broadcast()
    end
end

net.Receive("AOCRP.SoundWithDistance", function(len, ply)
    AOCRP:DoubleSoundPlay(net.ReadString(), net.ReadString(), net.ReadFloat(), net.ReadVector())
end)



--addons/wos-passiveevent-ageo/lua/wos/pes/addons/camera/cl_core.lua:

local pesCameraPathInfo = {}

local removeCamera = function( id )
	hook.Remove("CalcView", "!!wOS.PES.CameraPath" .. id)
	hook.Remove("Think", "!!wOS.PES.CameraPath" .. id)
	pesCameraPathInfo[id] = nil

	LocalPlayer().AOCRP_Kamerafahrt = false
end

local startCamera = function(id, path, speed)
	pesCameraPathInfo[id] = {}
	pesCameraPathInfo[id].path = path
	pesCameraPathInfo[id].speed = speed
	pesCameraPathInfo[id].current = 1

	hook.Add("CalcView", "!!wOS.PES.CameraPath" .. id, function(ply, pos, ang, fov, znear, zfar)
	
		LocalPlayer().AOCRP_Kamerafahrt = true

		if pesCameraPathInfo[id].current > #pesCameraPathInfo[id].path then
			removeCamera()
			return
		end

		local currentVal = math.floor(pesCameraPathInfo[id].current)

		local current = pesCameraPathInfo[id].path[currentVal]
		local next = pesCameraPathInfo[id].path[currentVal + 1]

		if not current or not next then return end

		local lerpVal = pesCameraPathInfo[id].current - currentVal
		local pos = LerpVector(lerpVal, current.Vector, next.Vector)
		local ang = LerpAngle(lerpVal, current.Angle, next.Angle)

		return {
			origin = pos,
			angles = ang,
			fov = fov,
			znear = znear,
			zfar = zfar,
			drawviewer = true
		}
	end)

	hook.Add("Think", "!!wOS.PES.CameraPath" .. id, function()
		pesCameraPathInfo[id].current = pesCameraPathInfo[id].current + pesCameraPathInfo[id].speed * FrameTime()

		if pesCameraPathInfo[id].current > #pesCameraPathInfo[id].path then
			removeCamera( id )
			return
		end
	end)

end
net.Receive("wOS.PES.StartCamera", function(len)
	local id = net.ReadUInt( 32 )
	local path = net.ReadTable()
	local speed = net.ReadFloat()
	
	startCamera(id, path, speed)
end)

net.Receive("wOS.PES.EndCamera", function(len)
	local id = net.ReadUInt( 32 )
	removeCamera( id )
end)
--addons/wos-passiveevent-ageo/lua/wos/pes/addons/scene/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































local addon = {}

local recordingScenes = {}

local textData = {
	Color(255,150,150),
	"[Scene System] "
}

net.Receive("wOS.PES.Scene.StartRecording", function()

	local entIndex = net.ReadDouble()

	for index, dermaE in pairs(recordingScenes) do
		if !IsValid(dermaE) then continue end
		if table.HasValue( dermaE.data, entIndex ) then return end
		dermaE.data[#dermaE.data + 1] = entIndex
	end
end)

addon.StartRecording = function(dermaElement)
	for index, dermaE in pairs(recordingScenes) do
		if IsValid(dermaE) then continue end
		table.RemoveByValue(recordingScenes, dermaE)
	end

	local len = #recordingScenes

	recordingScenes[len + 1] = dermaElement

	if len == 0 then
		chat.AddText(textData[1], textData[2], color_white, "Please spawn props and position them how you want to. Once you are finished open the menu again and press the recording button, ", Color(150,150,150), "if you dont do this it won't save!!!")
	end

	chat.AddText( textData[1], textData[2], color_white, tostring(len + 1), " Active Recordings")

	local decomp = dermaElement.data or {}
	local comp = wOS.SFS_EXTERN:Compress( decomp )

	local checksum = SysTime()

    local NET_CAP = 55000
    if #comp < NET_CAP then
        net.Start( "wOS.PES.Scene.StartRecording" )
            net.WriteDouble( checksum )
            net.WriteUInt( 1, 32 )
            net.WriteUInt( 1, 32 )
            net.WriteUInt( #comp, 32 )
            net.WriteData( comp )
        net.SendToServer()
        return
    end

    local total_segments = math.ceil( #comp / NET_CAP )

    for i=1, total_segments do
        local lim
        if i != total_segments then
            lim = i*NET_CAP
        end
		local str = string.sub( comp, ( (i - 1)*NET_CAP ) + 1, lim )
		timer.Simple( (i-1)*0.5, function() 
			net.Start( "wOS.PES.Scene.StartRecording" )
				net.WriteDouble( checksum )
				net.WriteUInt( total_segments, 32 )
				net.WriteUInt( i, 32 )
				net.WriteUInt( #str, 32 )
				net.WriteData( str )       
			net.SendToServer()
		end )
    end

end

addon.StopRecording = function(dermaElement)
	table.RemoveByValue(recordingScenes, dermaElement)
	if #recordingScenes > 0 then return end
	net.Start("wOS.PES.Scene.StopRecording")
	net.SendToServer()
end

hook.Add("HUDPaint", "wOS.PES.SceneRecord", function()
	if #recordingScenes <= 0 then return end
	draw.SimpleText("You are currently recording a scene","DermaLarge", ScrW()/2, ScrH()- 100, color_white, 1)
end)

local function ClearRecording()
	net.Start( "wOS.PES.Scene.ClearRecording" )
	net.SendToServer()
	recordingScenes = {}
end

hook.Add( "wOS.PES.OnCreatorClose", "wOS.PES.Scene.DeleteStuff", function( creator_type )
	if #recordingScenes <= 0 then return end
	ClearRecording()
end )

hook.Add( "wOS.PES.OnNodeDelete", "wOS.PES.Scene.DeleteStuff", function( node )
	timer.Simple( 0, function()
		if #recordingScenes <= 0 then return end
		for k, dea in pairs( recordingScenes ) do
			if IsValid( dea ) then continue end
			recordingScenes[ k ] = nil
		end
		if #recordingScenes > 0 then return end
		ClearRecording()
	end )
end ) 

wOS.PES.Modules:RegisterAddon( "scene", addon )
--addons/arccw_base_modified/lua/weapons/arccw_base/sh_attach.lua:
-- Used to prevent stack overflow. Set false here so luarefresh clears it
ArcCW.BuffStack = false

ArcCW.ConVar_BuffMults = {
    ["Mult_Damage"] = "arccw_mult_damage",
    ["Mult_DamageMin"] = "arccw_mult_damage",
    ["Mult_DamageNPC"] = "arccw_mult_npcdamage",
    ["Mult_HipDispersion"] = "arccw_mult_hipfire",
    ["Mult_ReloadTime"] = "arccw_mult_reloadtime",
    ["Mult_SightTime"] = "arccw_mult_sighttime",
    ["Mult_RPM"] = "arccw_mult_rpm",
    ["Mult_CycleTime"] = "arccw_mult_rpm",
    ["Mult_Range"] = "arccw_mult_range",
    ["Mult_Recoil"] = "arccw_mult_recoil",
    ["Mult_MoveDispersion"] = "arccw_mult_movedisp",
    ["Mult_AccuracyMOA"] = "arccw_mult_accuracy",
    ["Mult_Penetration"] = "arccw_mult_penetration",
    ["Mult_Sway"] = "arccw_mult_sway",
    ["Mult_MeleeDamage"] = "arccw_mult_meleedamage",
    ["Mult_MeleeTime"] = "arccw_mult_meleetime",
}

ArcCW.ConVar_BuffAdds = {
    ["Add_Sway"] = "arccw_add_sway",
}

ArcCW.ConVar_BuffOverrides = {
    ["Override_ShootWhileSprint"] = "arccw_mult_shootwhilesprinting"
}

SWEP.TickCache_Overrides = {}
SWEP.TickCache_Adds = {}
SWEP.TickCache_Mults = {}
SWEP.TickCache_Hooks = {}
SWEP.TickCache_IsShotgun = nil

SWEP.TickCache_Tick_Overrides = {}
SWEP.TickCache_Tick_Adds = {}
SWEP.TickCache_Tick_Mults = {}

SWEP.AttCache_Hooks = {}

-- debug: enable/disable modified caching
local MODIFIED_CACHE = true
-- print if a variable presumed to never change actually changes (this also happens right after attaching/detaching)
-- only works if MODIFIED_CACHE is false
local VERIFY_MODIFIED_CACHE = false

-- Conditions not listed are are presumed to never change; this is done for optimization purposes
SWEP.ModifiedCache = {}

function SWEP:RecalcAllBuffs()
    self.TickCache_Overrides = {}
    self.TickCache_Adds = {}
    self.TickCache_Mults = {}
    self.TickCache_Hooks = {}
    self.TickCache_IsShotgun = nil

    self.TickCache_Tick_Overrides = {}
    self.TickCache_Tick_Adds = {}
    self.TickCache_Tick_Mults = {}

    self.ReferencePosCache = {}

    self.AttCache_Hooks = {}

    self.NextMalfunction = nil

    -- for the customization page
    if CLIENT then
        self.Infos_Stats = nil
        self.Infos_Ballistics = nil
        self.Infos_Breakpoints = nil
    end

    -- this function is not always called right before AdjustAtts
    --self.ModifiedCache = {}
end

function SWEP:GetIsShotgun()
    if self.TickCache_IsShotgun == nil then
        local shotgun = self:GetBuff_Override("Override_IsShotgun")
        if shotgun != nil then
            self.TickCache_IsShotgun = shotgun
        end

        local num = self.Num
        if self.TickCache_IsShotgun == nil and num > 1 then self.TickCache_IsShotgun = true end
    end

    return self.TickCache_IsShotgun
end

function SWEP:GetIsManualAction()
    local manual = self:GetBuff_Override("Override_ManualAction")

    if manual != false then
        manual = manual or self.ManualAction
    end

    -- A manual action gun CAN have automatic firemode, this is intended behavior!!!
    -- It's used for slamfiring
    --[[]
    local mode = self:GetCurrentFiremode().Mode

    if mode != 0 and mode != 1 then
        return false
    end
    ]]

    return manual
end

-- ONE FUNCTION TO RULE THEM ALL
function SWEP:GetBuff(buff, defaultnil, defaultvar)
    local stable = self:GetTable()

    local result = stable[buff] or defaultvar
    if !result and defaultnil then
        result = nil
    elseif !result then
        result = 1
    end

    result = self:GetBuff_Override("Override_" .. buff, result)

    if isnumber(result) then
        result = self:GetBuff_Add("Add_" .. buff) + result
        result = self:GetBuff_Mult("Mult_" .. buff) * result
    end

    return result
end

function SWEP:GetBuff_Stat(buff, slot)
    local slottbl = self.Attachments[slot]
    if !slottbl then return end
    local atttbl = ArcCW.AttachmentTable[slottbl.Installed]
    if !atttbl then return end
    local num = slottbl.ToggleNum or 1

    if atttbl.ToggleStats and atttbl.ToggleStats[num] and (atttbl.ToggleStats[num][buff] != nil) then
        return atttbl.ToggleStats[num][buff]
    else
        return atttbl[buff]
    end
end

function SWEP:GetBuff_Hook(buff, data, defaultnil)
    -- call through hook function, args = data. return nil to do nothing. return false to prevent thing from happening.

    if !self.AttCache_Hooks[buff] then
        self.AttCache_Hooks[buff] = {}

        for i, k in pairs(self.Attachments) do
            if !k.Installed then continue end

            local atttbl = ArcCW.AttachmentTable[k.Installed]

            if !atttbl then continue end

            if isfunction(atttbl[buff]) then
                table.insert(self.AttCache_Hooks[buff], {atttbl[buff], atttbl[buff .. "_Priority"] or 0})
            elseif atttbl.ToggleStats and k.ToggleNum and atttbl.ToggleStats[k.ToggleNum] and isfunction(atttbl.ToggleStats[k.ToggleNum][buff]) then
                table.insert(self.AttCache_Hooks[buff], {atttbl.ToggleStats[k.ToggleNum][buff], atttbl.ToggleStats[k.ToggleNum][buff .. "_Priority"] or 0})
            end
        end

        local cfm = self:GetCurrentFiremode()

        if cfm and isfunction(cfm[buff]) then
            table.insert(self.AttCache_Hooks[buff], {cfm[buff], cfm[buff .. "_Priority"] or 0})
        end

        for i, e in pairs(self:GetActiveElements()) do
            local ele = self.AttachmentElements[e]

            if ele and ele[buff] then
                table.insert(self.AttCache_Hooks[buff], {ele[buff], ele[buff .. "_Priority"] or 0})
            end
        end

        if isfunction(self:GetTable()[buff]) then
            table.insert(self.AttCache_Hooks[buff], {self:GetTable()[buff], self:GetTable()[buff .. "_Priority"] or 0})
        end

        table.sort(self.AttCache_Hooks[buff], function(a, b) return a[2] >= b[2] end)shouldsort = true
    end

    local retvalue = nil
    for i, k in ipairs(self.AttCache_Hooks[buff]) do
        local ret = k[1](self, data)
        if ret == false then
            return
        elseif ret != nil then
            retvalue = ret
            break
        end
    end

    if retvalue then data = retvalue
    elseif defaultnil then data = nil end

    data = hook.Call(buff, nil, self, data) or data

    return data
end

function SWEP:GetBuff_Override(buff, default)

    local level = 0
    local current = nil
    local winningslot = nil

    if MODIFIED_CACHE and !self.ModifiedCache[buff] then
        -- ArcCW.ConVar_BuffOverrides[buff] isn't actually implemented??

        if !ArcCW.BuffStack then
            ArcCW.BuffStack = true
            local out = (self:GetBuff_Hook("O_Hook_" .. buff, {buff = buff}) or {})
            current = out.current or current
            winningslot = out.winningslot or winningslot
            ArcCW.BuffStack = false
        end

        return current or default, winningslot
    end

    if self.TickCache_Overrides[buff] then
        current = self.TickCache_Overrides[buff][1]
        winningslot = self.TickCache_Overrides[buff][2]

        local data = {
            buff = buff,
            current = current,
            winningslot = winningslot
        }

        if !ArcCW.BuffStack then

            ArcCW.BuffStack = true

            local out = (self:GetBuff_Hook("O_Hook_" .. buff, data) or {})

            current = out.current or current
            winningslot = out.winningslot or winningslot

            ArcCW.BuffStack = false

        end

        if current == nil then
            return default
        else
            return current, winningslot
        end
    end

    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end

        local atttbl = ArcCW.AttachmentTable[k.Installed]

        if !atttbl then continue end

        if atttbl[buff] != nil then
            local pri = atttbl[buff .. "_Priority"] or 1
            if level == 0 or (pri > level) then
                current = atttbl[buff]
                level = pri
                winningslot = i
            end
        end

        if atttbl.ToggleStats and k.ToggleNum and atttbl.ToggleStats[k.ToggleNum] and atttbl.ToggleStats[k.ToggleNum][buff] then
            local pri = atttbl.ToggleStats[k.ToggleNum][buff .. "_Priority"] or 1
            if level == 0 or (pri > level) then
                current = atttbl.ToggleStats[k.ToggleNum][buff]
                level = pri
                winningslot = i
            end
        end
    end

    if !ArcCW.BuffStack then

        ArcCW.BuffStack = true

        local cfm = self:GetCurrentFiremode()

        if cfm and cfm[buff] != nil then
            local pri = cfm[buff .. "_Priority"] or 1
            if level == 0 or (pri > level) then
                current = cfm[buff]
                level = pri
            end
        end

        ArcCW.BuffStack = false

    end

    if !ArcCW.BuffStack then

        ArcCW.BuffStack = true

        for i, e in pairs(self:GetActiveElements()) do
            local ele = self.AttachmentElements[e]

            if ele and ele[buff] != nil then
                local pri = ele[buff .. "_Priority"] or 1
                if level == 0 or (pri > level) then
                    current = ele[buff]
                    level = pri
                    winningslot = i
                end
            end
        end

        ArcCW.BuffStack = false

    end

    if self:GetTable()[buff] != nil then
        local pri = self:GetTable()[buff .. "_Priority"] or 1
        if level == 0 or (pri > level) then
            current = self:GetTable()[buff]
            level = pri
        end
    end

    self.TickCache_Overrides[buff] = {current, winningslot}

    if VERIFY_MODIFIED_CACHE and !self.ModifiedCache[buff] and current != nil then
        print("ArcCW: Presumed non-changing buff '" .. buff .. "' is modified (" .. tostring(current) .. ")!")
    end

    local data = {
        buff = buff,
        current = current,
        winningslot = winningslot
    }

    if !ArcCW.BuffStack then

        ArcCW.BuffStack = true

        current = (self:GetBuff_Hook("O_Hook_" .. buff, data) or {}).current or current

        ArcCW.BuffStack = false

    end

    if current == nil then
        current = default
    end

    return current, winningslot
end

function SWEP:GetBuff_Mult(buff)

    local mult = 1

    if MODIFIED_CACHE and !self.ModifiedCache[buff] then
        if !ArcCW.BuffStack then
            ArcCW.BuffStack = true
            mult = (self:GetBuff_Hook("M_Hook_" .. buff, {buff = buff, mult = 1}) or {}).mult or mult
            ArcCW.BuffStack = false
        end
        if ArcCW.ConVar_BuffMults[buff] then
            if buff == "Mult_CycleTime" then
                mult = mult / GetConVar(ArcCW.ConVar_BuffMults[buff]):GetFloat()
            else
                mult = mult * GetConVar(ArcCW.ConVar_BuffMults[buff]):GetFloat()
            end
        end
        return mult
    end

    if self.TickCache_Mults[buff] then
        mult = self.TickCache_Mults[buff]
        local data = {
            buff = buff,
            mult = mult
        }

        if !ArcCW.BuffStack then

            ArcCW.BuffStack = true

            mult = (self:GetBuff_Hook("M_Hook_" .. buff, data) or {}).mult or mult

            ArcCW.BuffStack = false

        end

        if ArcCW.ConVar_BuffMults[buff] then
            if buff == "Mult_CycleTime" then
                mult = mult / GetConVar(ArcCW.ConVar_BuffMults[buff]):GetFloat()
            else
                mult = mult * GetConVar(ArcCW.ConVar_BuffMults[buff]):GetFloat()
            end
        end

        return mult
    end

    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end

        local atttbl = ArcCW.AttachmentTable[k.Installed]

        if atttbl[buff] then
            mult = mult * atttbl[buff]
        end

        if atttbl.ToggleStats and k.ToggleNum and atttbl.ToggleStats[k.ToggleNum] and atttbl.ToggleStats[k.ToggleNum][buff] then
            mult = mult * atttbl.ToggleStats[k.ToggleNum][buff]
        end
    end

    local cfm = self:GetCurrentFiremode()

    if cfm and cfm[buff] then
        mult = mult * cfm[buff]
    end

    if self:GetTable()[buff] then
        mult = mult * self:GetTable()[buff]
    end

    for i, e in pairs(self:GetActiveElements()) do
        local ele = self.AttachmentElements[e]

        if ele and ele[buff] then
            mult = mult * ele[buff]
        end
    end

    self.TickCache_Mults[buff] = mult

    if VERIFY_MODIFIED_CACHE and !self.ModifiedCache[buff] and mult != 1 then
        print("ArcCW: Presumed non-changing buff '" .. buff .. "' is modified (" .. tostring(mult) .. ")!")
    end

    if ArcCW.ConVar_BuffMults[buff] then
        if buff == "Mult_CycleTime" then
            mult = mult / GetConVar(ArcCW.ConVar_BuffMults[buff]):GetFloat()
        else
            mult = mult * GetConVar(ArcCW.ConVar_BuffMults[buff]):GetFloat()
        end
    end

    local data = {
        buff = buff,
        mult = mult
    }

    if !ArcCW.BuffStack then

        ArcCW.BuffStack = true

        mult = (self:GetBuff_Hook("M_Hook_" .. buff, data) or {}).mult or mult

        ArcCW.BuffStack = false

    end

    return mult
end

function SWEP:GetBuff_Add(buff)
    local add = 0

    if MODIFIED_CACHE and !self.ModifiedCache[buff] then
        if !ArcCW.BuffStack then
            ArcCW.BuffStack = true
            add = (self:GetBuff_Hook("A_Hook_" .. buff, {buff = buff, add = 0}) or {}).add or add
            ArcCW.BuffStack = false
        end
        if ArcCW.ConVar_BuffAdds[buff] then
            add = add + GetConVar(ArcCW.ConVar_BuffAdds[buff]):GetFloat()
        end
        return add
    end

    if self.TickCache_Adds[buff] then
        add = self.TickCache_Adds[buff]

        local data = {
            buff = buff,
            add = add
        }

        if !ArcCW.BuffStack then

            ArcCW.BuffStack = true

            add = (self:GetBuff_Hook("A_Hook_" .. buff, data) or {}).add or add

            ArcCW.BuffStack = false

        end

        if ArcCW.ConVar_BuffAdds[buff] then
            add = add + GetConVar(ArcCW.ConVar_BuffAdds[buff]):GetFloat()
        end

        return add
    end

    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end

        local atttbl = ArcCW.AttachmentTable[k.Installed]

        if atttbl[buff] then
            add = add + atttbl[buff]
        end

        if atttbl.ToggleStats and k.ToggleNum and atttbl.ToggleStats[k.ToggleNum] and atttbl.ToggleStats[k.ToggleNum][buff] then
            add = add + atttbl.ToggleStats[k.ToggleNum][buff]
        end
    end

    local cfm = self:GetCurrentFiremode()

    if cfm and cfm[buff] then
        add = add + cfm[buff]
    end

    for i, e in pairs(self:GetActiveElements()) do
        local ele = self.AttachmentElements[e]

        if ele and ele[buff] then
            add = add + ele[buff]
        end
    end

    self.TickCache_Adds[buff] = add

    if VERIFY_MODIFIED_CACHE and !self.ModifiedCache[buff] and add != 0 then
        print("ArcCW: Presumed non-changing buff '" .. buff .. "' is modified (" .. tostring(add) .. ")!")
    end

    if ArcCW.ConVar_BuffAdds[buff] then
        add = add + GetConVar(ArcCW.ConVar_BuffAdds[buff]):GetFloat()
    end

    local data = {
        buff = buff,
        add = add
    }

    if !ArcCW.BuffStack then

        ArcCW.BuffStack = true

        add = (self:GetBuff_Hook("A_Hook_" .. buff, data) or {}).add or add

        ArcCW.BuffStack = false

    end

    return add
end

SWEP.ActiveElementCache = nil

function SWEP:GetActiveElements(recache)
    if self.ActiveElementCache and !recache then return self.ActiveElementCache end
    if ArcCW.Overflow and self.ActiveElementCache then return self.ActiveElementCache end

    local eles = {}

    for _, i in pairs(self.Attachments) do
        if !i.Installed then
            if i.DefaultEles then
                table.Add(eles, i.DefaultEles)
            end
            continue
        end

        if i.InstalledEles and i.Installed != i.EmptyFallback then
            table.Add(eles, i.InstalledEles)
        end

        local atttbl = ArcCW.AttachmentTable[i.Installed]

        if atttbl.ActivateElements then
            table.Add(eles, atttbl.ActivateElements)
        end

        local num = i.ToggleNum or 1
        if atttbl.ToggleStats and atttbl.ToggleStats[num] and (atttbl.ToggleStats[num]["ActivateElements"] != nil) then
            table.Add(eles, atttbl.ToggleStats[num]["ActivateElements"])
            --atttbl.ToggleStats[num][buff]
        end

        local slots = atttbl.Slot

        if isstring(slots) then
            slots = {slots}
        end

        table.Add(eles, slots or {})

        table.insert(eles, i.Installed)
    end

    table.Add(eles, self.DefaultElements)

    local mode = self:GetCurrentFiremode()
    table.Add(eles, (mode or {}).ActivateElements or {})

    local eles2 = {}

    ArcCW.Overflow = true

    for f, i in pairs(eles) do
        local e = self.AttachmentElements[i]

        if !e then continue end

        if !self:CheckFlags(e.ExcludeFlags, e.RequireFlags) then continue end

        local a = false
        local c = 0

        for g = f, table.Count(eles) do
            if eles[g] == i then c = c + 1 end
            if a then continue end

            if c > 1 then a = true end
        end

        if a then continue end

        table.insert(eles2, i)
    end

    table.Add(eles2, self:GetWeaponFlags())

    ArcCW.Overflow = false

    self.ActiveElementCache = eles2

    return eles2
end

function SWEP:GetMuzzleDevice(wm)
    local model = self.WM
    local muzz = self.WMModel or self

    if !wm then
        model = self.VM
        muzz = self:GetOwner():GetViewModel()
    end

    if model then
        for _, ele in pairs(model) do
            if ele.IsMuzzleDevice then
                muzz = ele.Model or muzz
            end
        end
    end

    if self:GetInUBGL() then
        local _, slot = self:GetBuff_Override("UBGL")

        if wm then
            muzz = (self.Attachments[slot].WMuzzleDeviceElement or {}).Model or muzz
        else
            muzz = (self.Attachments[slot].VMuzzleDeviceElement or {}).Model or muzz
        end
    end

    return muzz
end

function SWEP:GetTracerOrigin()
    local ow = self:GetOwner()
    local wm = nil
    local muzz = nil

    if !ow:IsNPC() and !ow:IsNextBot() and ow:IsValid() then
        wm = !ow:GetViewModel():IsValid() or ow:ShouldDrawLocalPlayer()
        muzz = self:GetMuzzleDevice(wm)
    end

    if muzz and muzz:IsValid() then
        local posang = muzz:GetAttachment(self:GetBuff_Override("Override_MuzzleEffectAttachment", self.MuzzleEffectAttachment) or 1)
        if !posang then return muzz:GetPos() end
        local pos = posang.Pos

        return pos
    end
end

function SWEP:CheckFlags(reject, need)
    local flags
    if ArcCW.Overflow then
        flags = self:GetWeaponFlags()
    else
        flags = self:GetActiveElements()
    end

    reject = reject or {}
    need = need or {}

    if !istable(reject) then reject = {reject} end
    if !istable(need) then need = {need} end

    for _, i in pairs(reject) do
        if table.HasValue(flags, i) then
            return false
        end
    end

    for _, i in pairs(need) do
        if !table.HasValue(flags, i) then
            return false
        end
    end

    return true
end

function SWEP:GetWeaponFlags()
    local flags = {}

    if self.DefaultFlags then table.Add(flags, self.DefaultFlags) end

    for id, i in pairs(self.Attachments) do
        if !i.Installed then
            if i.DefaultFlags then
                table.Add(flags, i.DefaultFlags)
            end
            continue
        end

        local buff = self:GetBuff_Stat("GivesFlags", id)
        if buff then
            table.Add(flags, buff)
        end

        if i.GivesFlags then
            table.Add(flags, i.GivesFlags)
        end

        local extras = {}
        self:GetBuff_Hook("Hook_ExtraFlags", extras)
        table.Add(flags, extras)

        table.Add(flags, {i.Installed})
    end

    return flags
end

function SWEP:PlayerOwnsAtt(att)
    local qty = ArcCW:PlayerGetAtts(self:GetOwner(), att)

    return qty > 0
end

function SWEP:NetworkWeapon(sendto)
    net.Start("arccw_networkatts")
    net.WriteEntity(self) -- self entity

    net.WriteUInt(table.Count(self.Attachments), 8)

    for _, i in pairs(self.Attachments) do
        if !i.Installed then net.WriteUInt(0, ArcCW.GetBitNecessity()) continue end

        local atttbl = ArcCW.AttachmentTable[i.Installed]
        local id = atttbl.ID

        net.WriteUInt(id, ArcCW.GetBitNecessity())

        if i.SlideAmount then
            net.WriteFloat(i.SlidePos or 0.5)
        end

        if atttbl.ToggleStats then
            net.WriteUInt(i.ToggleNum or 1, 8) -- look if you want more than 255 fucking toggle options you're insane and stupid just don't ok
        end

        -- if atttbl.ColorOptionsTable then
        --     net.WriteUInt(i.ColorOptionIndex or 1, 8) -- look if you want more than 256 fucking color options you're insane and stupid and just don't ok
        -- end
    end

    if sendto then
        net.Send(sendto)
    else
        -- net.SendPVS(self:GetPos())
        net.Broadcast()
    end
end

function SWEP:SendDetail_ColorIndex(slot)
    net.Start("arccw_colorindex")
    net.WriteUInt(slot, 8)
    net.WriteUInt(self.Attachments[slot].ColorOptionIndex)
    net.SendToServer()
end

function SWEP:SendDetail_SlidePos(slot, hmm)
    if !self.Attachments then return end
    if !self.Attachments[slot].SlidePos then return end

    net.Start("arccw_slidepos")
    net.WriteUInt(slot, 8)
    net.WriteFloat(self.Attachments[slot].SlidePos or 0.5)
    net.SendToServer()
end

function SWEP:SendDetail_ToggleNum(slot, hmm)
    if !self.Attachments or !self.Attachments[slot] then return end
    if !self.Attachments[slot].ToggleNum then return end

    net.Start("arccw_togglenum")
    net.WriteUInt(slot, 8)
    net.WriteUInt(self.Attachments[slot].ToggleNum or 1, 8)
    net.SendToServer()
end


function SWEP:SendAllDetails()
    for i, k in pairs(self.Attachments) do
        self:SendDetail_SlidePos(i, true)
        self:SendDetail_ToggleNum(i, true)
    end
end

function SWEP:CountAttachments()
    local total = 0

    for _, i in pairs(self.Attachments) do
        if i.Installed and !i.FreeSlot then
            local ins = ArcCW.AttachmentTable[i.Installed]
            if ins and !ins.IgnorePickX then
                total = total + 1
            end
        end
    end

    return total
end

function SWEP:SetBodygroupTr(ind, bg)
    self.Bodygroups[ind] = bg
end

function SWEP:RefreshBGs()
    local vm

    local vmm = self:GetBuff_Override("Override_VMMaterial") or self.VMMaterial or ""
    local wmm = self:GetBuff_Override("Override_WMMaterial") or self.WMMaterial or  ""

    local vmc = self:GetBuff_Override("Override_VMColor") or self.VMColor or Color(255, 255, 255)
    local wmc = self:GetBuff_Override("Override_WMColor") or self.WMColor or Color(255, 255, 255)

    local vms = self:GetBuff_Override("Override_VMSkin") or self.DefaultSkin
    local wms = self:GetBuff_Override("Override_WMSkin") or self.DefaultWMSkin

    local vmp = self.DefaultPoseParams
    local wmp = self.DefaultWMPoseParams

    if self.MirrorVMWM then
        wmm = vmm
        wmc = vmc
        wms = vms
        wmp = vmp
    end

    if self:GetOwner():IsPlayer() then
        vm = self:GetOwner():GetViewModel()
    end

    if vm and vm:IsValid() then
        ArcCW.SetBodyGroups(vm, self.DefaultBodygroups)
        vm:SetMaterial(vmm)
        vm:SetColor(vmc)
        vm:SetSkin(vms)

        vmp["BaseClass"] = nil

        for i, k in pairs(vmp) do
            vm:SetPoseParameter(i, k)
        end
    end

    self:SetMaterial(wmm)
    self:SetColor(wmc)
    self:SetSkin(wms)

    if self.WMModel and self.WMModel:IsValid() then
        ArcCW.SetBodyGroups(self.WMModel, self.MirrorVMWM and self.DefaultBodygroups or self.DefaultWMBodygroups)

        self.WMModel:SetMaterial(wmm)
        self.WMModel:SetColor(wmc)
        self.WMModel:SetSkin(wms)

        wmp["BaseClass"] = nil

        for i, k in pairs(wmp) do
            self.WMModel:SetPoseParameter(i, k)
        end
    end

    local ae = self:GetActiveElements()

    for _, e in pairs(ae) do
        local ele = self.AttachmentElements[e]

        if !ele then continue end

        if ele.VMPoseParams and vm and IsValid(vm) then
            ele.VMPoseParams["BaseClass"] = nil
            for i, k in pairs(ele.VMPoseParams) do
                vm:SetPoseParameter(i, k)
            end
        end

        if self.WMModel and self.WMModel:IsValid() then
            if self.MirrorVMWM and ele.VMPoseParams then
                ele.VMPoseParams["BaseClass"] = nil
                for i, k in pairs(ele.VMPoseParams) do
                    self.WMModel:SetPoseParameter(i, k)
                end
            end
            if ele.WMPoseParams then
                ele.WMPoseParams["BaseClass"] = nil
                for i, k in pairs(ele.WMPoseParams) do
                    self.WMModel:SetPoseParameter(i, k)
                end
            end
        end

        if ele.VMSkin and vm and IsValid(vm) then
            vm:SetSkin(ele.VMSkin)
        end

        if self.WMModel and self.WMModel:IsValid() then
            if self.MirrorVMWM and ele.VMSkin then
                self.WMModel:SetSkin(ele.VMSkin)
                self:SetSkin(ele.VMSkin)
            end
            if ele.WMSkin then
                self.WMModel:SetSkin(ele.WMSkin)
                self:SetSkin(ele.WMSkin)
            end
        end

        if ele.VMColor and vm and IsValid(vm) then
            vm:SetColor(ele.VMColor)
        end

        if self.WMModel and self.WMModel:IsValid() then
            if self.MirrorVMWM and ele.VMSkin then
                self.WMModel:SetColor(ele.VMColor or color_white)
                self:SetColor(ele.VMColor or color_white)
            end
            if ele.WMSkin then
                self.WMModel:SetColor(ele.WMColor or color_white)
                self:SetColor(ele.WMColor or color_white)
            end
        end

        if ele.VMMaterial and vm and IsValid(vm) then
            vm:SetMaterial(ele.VMMaterial)
        end

        if self.WMModel and self.WMModel:IsValid() then
            if self.MirrorVMWM and ele.VMMaterial then
                self.WMModel:SetMaterial(ele.VMMaterial)
                self:SetMaterial(ele.VMMaterial)
            end
            if ele.WMMaterial then
                self.WMModel:SetMaterial(ele.WMMaterial)
                self:SetMaterial(ele.WMMaterial)
            end
        end

        if ele.VMBodygroups then
            for _, i in pairs(ele.VMBodygroups) do
                if !i.ind or !i.bg then continue end

                if vm and IsValid(vm) and vm:GetBodygroup(i.ind) != i.bg then
                    vm:SetBodygroup(i.ind, i.bg)
                end
            end

            if self.MirrorVMWM then
                for _, i in pairs(ele.VMBodygroups) do
                    if !i.ind or !i.bg then continue end

                    if self.WMModel and IsValid(self.WMModel) and self.WMModel:GetBodygroup(i.ind) != i.bg then
                        self.WMModel:SetBodygroup(i.ind, i.bg)
                    end

                    if self:GetBodygroup(i.ind) != i.bg then
                        self:SetBodygroup(i.ind, i.bg)
                    end
                end
            end
        end

        if ele.WMBodygroups then
            for _, i in pairs(ele.WMBodygroups) do
                if !i.ind or !i.bg then continue end

                if self.WMModel and IsValid(self.WMModel) and self.WMModel:GetBodygroup(i.ind) != i.bg then
                    self.WMModel:SetBodygroup(i.ind, i.bg)
                end

                if self:GetBodygroup(i.ind) != i.bg then
                    self:SetBodygroup(i.ind, i.bg)
                end
            end
        end

        if ele.VMBoneMods then
            for bone, i in pairs(ele.VMBoneMods) do
                local boneind = vm:LookupBone(bone)

                if !boneind then continue end

                vm:ManipulateBonePosition(boneind, i)
            end

            if self.MirrorVMWM then
                for bone, i in pairs(ele.VMBoneMods) do
                    if !(self.WMModel and self.WMModel:IsValid()) then break end
                    local boneind = self:LookupBone(bone)

                    if !boneind then continue end

                    self:ManipulateBonePosition(boneind, i)
                end
            end
        end

        if ele.WMBoneMods then
            for bone, i in pairs(ele.WMBoneMods) do
                if !(self.WMModel and self.WMModel:IsValid()) then break end
                local boneind = self:LookupBone(bone)

                if !boneind then continue end

                self:ManipulateBonePosition(boneind, i)
            end
        end

        if SERVER then
            self:SetupShields()
        end
    end

    local tpmdl = IsValid(self.WMModel) and self.WMModel or self

    if IsValid(vm) then
        for i = 0, (vm:GetNumBodyGroups()) do
            if self.Bodygroups[i] then
                vm:SetBodygroup(i, self.Bodygroups[i])
            end
        end
        self:GetBuff_Hook("Hook_ModifyBodygroups", {vm = vm, eles = ae, wm = false})
    end

    for i = 0, (tpmdl:GetNumBodyGroups()) do
        if self.Bodygroups[i] then
            tpmdl:SetBodygroup(i, self.Bodygroups[i])
        end
    end
    self:GetBuff_Hook("Hook_ModifyBodygroups", {vm = tpmdl, eles = ae, wm = true})

    for slot, v in pairs(self.Attachments) do
        if !v.Installed then continue end

        local func = self:GetBuff_Stat("Hook_ModifyAttBodygroups", slot)
        if func and v.VElement and IsValid(v.VElement.Model) and IsValid(vm) then
            func(self, {vm = vm, element = v.VElement, slottbl = v, wm = false})
        end
        if func and v.WElement and IsValid(v.WElement.Model)  then
            func(self, {vm = tpmdl, element = v.WElement, slottbl = v, wm = true})
        end
    end
end

function SWEP:GetPickX()
    return ArcCW.ConVars["atts_pickx"]:GetInt()
end

function SWEP:Attach(slot, attname, silent, noadjust)
    silent = silent or false
    local attslot = self.Attachments[slot]
    if !attslot then return end
    if attslot.Installed == attname then return end
    if attslot.Internal then return end

    -- Make an additional check to see if we can detach the current attachment
    if attslot.Installed and !ArcCW:PlayerCanAttach(self:GetOwner(), self, attslot.Installed, slot, attname) then
        if CLIENT and !silent then
            surface.PlaySound("items/medshotno1.wav")
        end
        return
    end

    if !ArcCW:PlayerCanAttach(self:GetOwner(), self, attname, slot, false) then
        if CLIENT and !silent then
            surface.PlaySound("items/medshotno1.wav")
        end
        return
    end

    local pick = self:GetPickX()

    if pick > 0 and self:CountAttachments() >= pick and !attslot.FreeSlot
            and !attslot.Installed then
        if CLIENT and !silent then
            surface.PlaySound("items/medshotno1.wav")
        end
        return
    end

    local atttbl = ArcCW.AttachmentTable[attname]

    if !atttbl then return end
    if !ArcCW:SlotAcceptsAtt(attslot.Slot, self, attname) then return end
    if !self:CheckFlags(atttbl.ExcludeFlags, atttbl.RequireFlags) then return end
    if !self:PlayerOwnsAtt(attname) then return end

    local max = atttbl.Max

    if max then
        local amt = 0

        for i, k in pairs(self.Attachments) do
            if k.Installed == attname then amt = amt + 1 end
        end

        if amt >= max then return end
    end

    if attslot.SlideAmount then
        attslot.SlidePos = 0.5
    end

    if atttbl.MountPositionOverride then
        attslot.SlidePos = atttbl.MountPositionOverride
    end

    if atttbl.AdditionalSights then
        self.SightMagnifications = {}
    end

    if atttbl.ToggleStats then
        attslot.ToggleNum = 1
    end

    attslot.ToggleLock = atttbl.ToggleLockDefault or false

    if CLIENT then
        -- we are asking to attach something

        self:SendAllDetails()

        net.Start("arccw_asktoattach")
        net.WriteUInt(slot, 8)
        net.WriteUInt(atttbl.ID, 24)
        net.SendToServer()

        if !silent then
            surface.PlaySound(atttbl.AttachSound or "weapons/arccw/install.wav")
        end
    else
        self:DetachAllMergeSlots(slot)

        for i, k in pairs(self.Attachments) do
            if table.HasValue(k.MergeSlots or {}, slot) then
                self:DetachAllMergeSlots(i)
            end
        end
    end

    attslot.Installed = attname

    if atttbl.Health then
        attslot.HP = self:GetAttachmentMaxHP(slot)
    end

    if atttbl.ColorOptionsTable then
        attslot.ColorOptionIndex = 1
    end

    ArcCW:PlayerTakeAtt(self:GetOwner(), attname)

    --[[]
    local fmt = self:GetBuff_Override("Override_Firemodes") or self.Firemodes
    local fmi = self:GetFireMode()

    if fmi > table.Count(fmt) then
        self:SetFireMode(1)
    end
    ]]

    --self.UnReady = false

    if SERVER then
        self:NetworkWeapon()
        self:SetupModel(false)
        self:SetupModel(true)
        ArcCW:PlayerSendAttInv(self:GetOwner())

        if engine.ActiveGamemode() == "terrortown" then
            self:TTT_PostAttachments()
        end
    else
        self:SetupActiveSights()

        self.LHIKAnimation = 0
        self.LHIKAnimationStart = 0
        self.LHIKAnimationTime = 0

        self.LHIKDelta = {}
        self.LHIKDeltaAng = {}

        self.ViewModel_Hit = Vector(0, 0, 0)

        if !silent then
            self:SavePreset("autosave")
        end
    end

    for s, i in pairs(self.Attachments) do
        if !self:CheckFlags(i.ExcludeFlags, i.RequireFlags) then
            self:Detach(s, true, true)
        end
    end

    if !noadjust then
        self:AdjustAtts()
    end

    if atttbl.UBGL then
        local ubgl_ammo = self:GetBuff_Override("UBGL_Ammo")
        local ubgl_clip = self:GetBuff_Override("UBGL_Capacity")
        if self:GetOwner():IsPlayer() and ArcCW.ConVars["atts_ubglautoload"]:GetBool() and ubgl_ammo then
            local amt = math.min(ubgl_clip - self:Clip2(), self:GetOwner():GetAmmoCount(ubgl_ammo))
            self:SetClip2(self:Clip2() + amt)
            self:GetOwner():RemoveAmmo(amt, ubgl_ammo)
        end
    end

    self:RefreshBGs()
    return true
end

function SWEP:DetachAllMergeSlots(slot, silent)
    local slots = {slot}

    table.Add(slots, (self.Attachments[slot] or {}).MergeSlots or {})

    for _, i in pairs(slots) do
        self:Detach(i, silent, nil, true)
    end
end

function SWEP:Detach(slot, silent, noadjust, nocheck)
    if !slot then return end
    if !self.Attachments[slot] then return end

    if !self.Attachments[slot].Installed then return end

    if self.Attachments[slot].Internal then return end

    if !nocheck and !ArcCW:PlayerCanAttach(self:GetOwner(), self, self.Attachments[slot].Installed, slot, true) then
        if CLIENT and !silent then
            surface.PlaySound("items/medshotno1.wav")
        end
        return
    end

    if self.Attachments[slot].Installed == self.Attachments[slot].EmptyFallback then
        return
    end

    local previnstall = self.Attachments[slot].Installed

    local atttbl = ArcCW.AttachmentTable[previnstall]

    if atttbl.UBGL then
        local clip = self:Clip2()

        local ammo = atttbl.UBGL_Ammo or "smg1_grenade"

        if SERVER and IsValid(self:GetOwner()) then
            self:GetOwner():GiveAmmo(clip, ammo, true)
        end

        self:SetClip2(0)
        self:DeselectUBGL()
    end

    if self.Attachments[slot].EmptyFallback then -- is this a good name
        self.Attachments[slot].Installed = self.Attachments[slot].EmptyFallback
    else
        self.Attachments[slot].Installed = nil
    end

    if self.Attachments[slot].SubAtts then
        for i, k in pairs(self.Attachments[slot].SubAtts) do
            self:Detach(k, true, true)
        end
    end

    if self:GetAttachmentHP(slot) >= self:GetAttachmentMaxHP(slot) then
        ArcCW:PlayerGiveAtt(self:GetOwner(), previnstall)
    end

    if CLIENT then
        self:SendAllDetails()

        -- we are asking to detach something
        net.Start("arccw_asktodetach")
        net.WriteUInt(slot, 8)
        net.SendToServer()

        if !silent then
            surface.PlaySound(atttbl.DetachSound or "weapons/arccw/uninstall.wav")
        end

        self:SetupActiveSights()

        self.LHIKAnimation = 0
        self.LHIKAnimationStart = 0
        self.LHIKAnimationTime = 0

        if !silent then
            self:SavePreset("autosave")
        end
    else
        self:NetworkWeapon()
        self:SetupModel(false)
        self:SetupModel(true)
        ArcCW:PlayerSendAttInv(self:GetOwner())

        if engine.ActiveGamemode() == "terrortown" then
            self:TTT_PostAttachments()
        end
    end

    self:RefreshBGs()

    if !noadjust then
        self:AdjustAtts()
    end
    return true
end

function SWEP:ToggleSlot(slot, num, silent, back)
    local atttbl = ArcCW.AttachmentTable[self.Attachments[slot].Installed]
    if !atttbl.ToggleStats then return end

    local amt = 1

    if back then amt = -1 end

    if !num then
        self.Attachments[slot].ToggleNum = (self.Attachments[slot].ToggleNum or 1) + amt
        if self.Attachments[slot].ToggleNum > #atttbl.ToggleStats then
            self.Attachments[slot].ToggleNum = 1
        elseif self.Attachments[slot].ToggleNum < 1 then
            self.Attachments[slot].ToggleNum = #atttbl.ToggleStats
        end
    else
        self.Attachments[slot].ToggleNum = math.Clamp(num, 1, #catttbl.ToggleStats)
    end

    if CLIENT then
        self:SendDetail_ToggleNum(slot)
        self:SetupActiveSights()
    elseif SERVER then
        self:NetworkWeapon()
        self:SetupModel(false)
        self:SetupModel(true)
    end

    self:AdjustAtts()

    for s, i in pairs(self.Attachments) do
        if !self:CheckFlags(i.ExcludeFlags, i.RequireFlags) then
            self:Detach(s, true)
        end
    end

    self:RefreshBGs()

    if CLIENT and !silent and self:GetBuff_Stat("ToggleSound", slot) != false then
        surface.PlaySound(self:GetBuff_Stat("ToggleSound", slot) or (atttbl.ToggleStats[slot] or {}).ToggleSound or "weapons/arccw/firemode.wav")
    end
end

function SWEP:AdjustAmmo(old_inf)

    local new_inf = self:HasInfiniteAmmo()

    local wpn = weapons.Get(self:GetClass())
    local ammo = self:GetBuff_Override("Override_Ammo", wpn.Primary.Ammo)
    local oldammo = self.OldAmmo or self.Primary.Ammo

    if old_inf and (!new_inf or ammo != oldammo) then
        self:SetClip1(0)
    elseif (!old_inf and new_inf) or ammo != oldammo then
        self:Unload()
    end

    self.Primary.Ammo = ammo
    self.OldAmmo = self.Primary.Ammo
end

function SWEP:AdjustAtts()
    local old_inf = self:HasInfiniteAmmo()

    self:RecalcAllBuffs()

    -- Recalculate active elements so dependencies aren't fucked
    self.ActiveElementCache = nil
    self:GetActiveElements(true)
    self.ModifiedCache = {}

    -- Tempoarily disable modified cache, since we're building it right now
    MODIFIED_CACHE = false

    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end
        local ok = true

        if !ArcCW:SlotAcceptsAtt(k.Slot, self, k.Installed) then ok = false end
        if ok and !self:CheckFlags(k.ExcludeFlags, k.RequireFlags) then ok = false end

        local atttbl = ArcCW.AttachmentTable[k.Installed]

        if !atttbl then continue end
        if ok and !self:CheckFlags(atttbl.ExcludeFlags, atttbl.RequireFlags) then ok = false end

        if !ok then
            self:Detach(i, true)
            continue
        end

        -- Cache all possible value modifiers
        for var, v in pairs(atttbl) do
            self.ModifiedCache[var] = true
            if var == "ToggleStats" or var == "Override_Firemodes" then
                for _, v2 in pairs(v) do
                    for var2, _ in pairs(v2) do
                        self.ModifiedCache[var2] = true
                    end
                end
            end
        end
    end

    for _, e in pairs(self.AttachmentElements) do
        if !istable(e) then continue end
        for var, v in pairs(e) do
            self.ModifiedCache[var] = true
        end
    end

    for _, e in pairs(self.Firemodes) do
        if !istable(e) then continue end
        for var, v in pairs(e) do
            self.ModifiedCache[var] = true
        end
    end

    MODIFIED_CACHE = true

    if SERVER then
        local cs = self:GetCapacity() + self:GetChamberSize()

        if self:Clip1() > cs and self:Clip1() != ArcCW.BottomlessMagicNumber then
            local diff = self:Clip1() - cs
            self:SetClip1(cs)

            if self:GetOwner():IsValid() and !self:GetOwner():IsNPC() then
                self:GetOwner():GiveAmmo(diff, self.Primary.Ammo, true)
            end
        end
    else
        local se = self:GetBuff_Override("Override_ShootEntity") or self.ShootEntity
        if se then
            local path = "arccw/weaponicons/" .. self:GetClass()
            local mat = Material(path)

            if !mat:IsError() then
                local tex = mat:GetTexture("$basetexture")
                local texpath = tex:GetName()

                killicon.Add(se, texpath, Color(255, 255, 255))
            end
        end
    end

    local ubgl_ammo = self:GetBuff_Override("UBGL_Ammo")
    local ubgl_clip = self:GetBuff_Override("UBGL_Capacity")

    self.Secondary.ClipSize = ubgl_clip or -1
    self.Secondary.Ammo = ubgl_ammo or "none"

    --[[]
    if ubgl_clip then
        self.Secondary.ClipSize = ubgl_clip
        if self:GetOwner():IsPlayer() and ArcCW.ConVars["atts_ubglautoload"]:GetBool() and ubgl_ammo then
            local amt = math.min(ubgl_clip - self:Clip2(), self:GetOwner():GetAmmoCount(ubgl_ammo))
            self:SetClip2(self:Clip2() + amt)
            self:GetOwner():RemoveAmmo(amt, ubgl_ammo)
        end
    else
        self.Secondary.ClipSize = -1
    end
    ]]



    self:RebuildSubSlots()

    local fmt = self:GetBuff_Override("Override_Firemodes", self.Firemodes)
    fmt["BaseClass"] = nil

    local fmi = self:GetFireMode()
    if !fmt[fmi] then self:SetFireMode(1) end

    self:AdjustAmmo(old_inf)
end

function SWEP:GetAttachmentMaxHP(slot)
    if !self.Attachments[slot] then return 100 end
    if !self.Attachments[slot].Installed then return 100 end
    local maxhp = 100
    local atttbl = ArcCW.AttachmentTable[self.Attachments[slot].Installed]

    if atttbl.Health then
        maxhp = atttbl.Health
    end

    return maxhp
end

function SWEP:GetAttachmentHP(slot)
    if !self.Attachments[slot] then return 100 end
    if !self.Attachments[slot].Installed then return 100 end

    if self.Attachments[slot].HP then return self.Attachments[slot].HP end

    self.Attachments[slot].HP = self:GetAttachmentMaxHP(slot)

    return self.Attachments[slot].HP
end

function SWEP:ApplyAttachmentShootDamage()
    local any = false
    for j, i in pairs(self.Attachments) do
        if !i.Installed then continue end
        local atttbl = ArcCW.AttachmentTable[i.Installed]

        if !atttbl.Health then continue end

        if atttbl.DamageOnShoot then
            self:DamageAttachment(j, atttbl.DamageOnShoot)
            any = true
        end
    end

    if any then
        self:SendAttHP()
    end
end

function SWEP:DamageAttachment(slot, dmg)
    if !self.Attachments[slot] then return end
    if !self.Attachments[slot].Installed then return end

    self.Attachments[slot].HP = self:GetAttachmentHP(slot) - dmg

    if self:GetAttachmentHP(slot) <= 0 then
        local atttbl = ArcCW.AttachmentTable[self.Attachments[slot].Installed]

        if atttbl.Hook_AttDestroyed then
            atttbl.Hook_AttDestroyed(self, {slot = slot, dmg = dmg})
        end

        self:Detach(slot, true)
    end
end

function SWEP:SendAttHP()
    net.Start("arccw_sendatthp")
    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end
        local atttbl = ArcCW.AttachmentTable[k.Installed]

        if atttbl.Health then
            net.WriteBool(true)
            net.WriteUInt(i, 8)
            net.WriteFloat(self:GetAttachmentHP(i))
        end
    end
    net.WriteBool(false)
    net.Send(self:GetOwner())
end

-- local node = {b = {}, i = "" t = 0}
-- b: branches
-- i: installed
-- t: toggle
-- s: slide
-- h: hp

-- recursive function
-- gets a tree of all the attachments installed in subslots subordinate to a particular slot
function SWEP:GetSubSlotTree(i)
    if !self.Attachments[i] then return nil end
    if !self.Attachments[i].Installed then return nil end
    if !self.Attachments[i].SubAtts then return
        {
        b = {},
        i = self.Attachments[i].Installed,
        t = self.Attachments[i].ToggleNum,
        s = self.Attachments[i].SlidePos,
        h = self.Attachments[i].Health}
    end

    local ss = {}
    for j, k in pairs(self.Attachments[i].SubAtts) do
        if k == i then continue end
        local sst = self:GetSubSlotTree(k)
        if sst then
            ss[j] = sst
        end
    end

    return {b = ss, i = self.Attachments[i].Installed}
end

function SWEP:SubSlotTreeReinstall(slot, subslottree)
    for i, k in pairs(self.Attachments[slot].SubAtts or {}) do
        -- i = index
        -- k = slot
        self.Attachments[k].Installed = subslottree[i].i
        self.Attachments[k].ToggleNum = subslottree[i].t
        self.Attachments[k].SlidePos = subslottree[i].s
        self.Attachments[k].Health = subslottree[i].h

        if subslottree.b[i] then
            self:SubSlotTreeReinstall(i, subslottree.b[i])
        end
    end
end

function SWEP:RebuildSubSlots()
    -- this function rebuilds the subslots while preserving installed attachment data
    local subslottrees = {}

    local baseatts = table.Count(weapons.Get(self:GetClass()).Attachments)

    self.Attachments.BaseClass = nil

    for i = 1, baseatts do
        subslottrees[baseatts] = self:GetSubSlotTree(i)
    end

    -- remove all sub slots
    for i, k in pairs(self.Attachments) do
        if !isnumber(i) then continue end
        if !istable(k) then continue end
        if i > baseatts then
            self.Attachments[i] = nil
        else
            self.Attachments[i].SubAtts = nil
        end
    end

    self.SubSlotCount = 0
    -- add the sub slots back
    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end
        local att = ArcCW.AttachmentTable[k.Installed]
        if !att then continue end
        if !istable(k) then continue end

        if att.SubSlots then
            self:AddSubSlot(i, k.Installed)
        end
    end
    -- add the sub slot data back

    for i, k in pairs(subslottrees) do
        self:SubSlotTreeReinstall(i, k)
    end
end

function SWEP:AddSubSlot(i, attname)
    local baseatts = table.Count(weapons.Get(self:GetClass()).Attachments)
    local att = ArcCW.AttachmentTable[attname]
    if att.SubSlots then
        self.Attachments[i].SubAtts = {}
        local og_slot = self.Attachments[i]
        for ind, slot in pairs(att.SubSlots) do
            if !istable(slot) then continue end
            self.SubSlotCount = self.SubSlotCount + 1
            local index = baseatts + self.SubSlotCount
            self.Attachments[index] = slot
            self.Attachments[index].Bone = og_slot.Bone
            self.Attachments[index].WMBone = og_slot.WMBone
            self.Attachments[index].ExtraSightDist = 0--self.Attachments[index].ExtraSightDist or og_slot.ExtraSightDist
            self.Attachments[index].CorrectivePos = og_slot.CorrectivePos
            self.Attachments[index].CorrectiveAng = og_slot.CorrectiveAng
            og_slot.SubAtts[ind] = index

            if slot.MergeSlots then
                self.Attachments[index].MergeSlots = {}
                for _, k2 in pairs(slot.MergeSlots) do
                    table.insert(self.Attachments[index].MergeSlots, k2 + index)
                end
            end

            if slot.Offset then
                self.Attachments[index].Offset = {
                    vpos = Vector(0, 0, 0),
                    vang = Angle(0, 0, 0),
                    wpos = Vector(0, 0, 0),
                    wang = Angle(0, 0, 0)
                }

                if slot.Offset.vang then
                    self.Attachments[index].Offset.vang = slot.Offset.vang + (og_slot.Offset.vang or Angle(0, 0, 0))
                end

                if slot.Offset.wang then
                    self.Attachments[index].Offset.wang = slot.Offset.wang + (og_slot.Offset.wang or Angle(0, 0, 0))
                end

                if slot.Offset.vpos then
                    self.Attachments[index].Offset.vpos = LocalToWorld(slot.Offset.vpos, self.Attachments[index].Offset.vang, og_slot.Offset.vpos, og_slot.Offset.vang or Angle(0, 0, 0))
                end

                if slot.Offset.wpos then
                    self.Attachments[index].Offset.wpos = LocalToWorld(slot.Offset.wpos, self.Attachments[index].Offset.wang, og_slot.Offset.wpos, og_slot.Offset.wang or Angle(0, 0, 0))
                end
            end

            self.Attachments[index].SubAtts = {}
        end
    end
end

function SWEP:OnReloaded()
    self:RecalcAllBuffs()
    self:SetupActiveSights()
end
--addons/arccw_base_modified/lua/weapons/arccw_base/sh_grenade.lua:
SWEP.GrenadePrimeTime = 0

function SWEP:PreThrow()

    if self:GetNWState() == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint() then return end

    local bot, inf = self:HasBottomlessClip(), self:HasInfiniteAmmo()
    local aps = self:GetBuff("AmmoPerShot")

    if !inf and (bot and self:Ammo1() or self:Clip1()) < aps then
        if self:Ammo1() == 0 and self:Clip1() == 0 and !self:GetBuff_Override("Override_KeepIfEmpty", self.KeepIfEmpty) then
            self:GetOwner():StripWeapon(self:GetClass())
        end
        return
    end

    if self:GetGrenadePrimed() then return end

    if engine.ActiveGamemode() == "terrortown" and GetRoundState and GetRoundState() == ROUND_PREP and
        ((GetConVar("ttt_no_nade_throw_during_prep") and GetConVar("ttt_no_nade_throw_during_prep"):GetBool())
            or (GetConVar("ttt_nade_throw_during_prep") and !GetConVar("ttt_nade_throw_during_prep"):GetBool())) then
        return
    end

    self.GrenadePrimeTime = CurTime()
    local alt = self:GetOwner():KeyDown(IN_ATTACK2)
    self:SetGrenadeAlt(alt)
    self:SetGrenadePrimed(true)

    local pulltime = self:GetBuff("PullPinTime")
    local anim = alt and self:SelectAnimation("pre_throw_alt") or self:SelectAnimation("pre_throw")
    self:PlayAnimation(anim, self.PullPinTime / pulltime, true, 0, true, nil, true)

    self.isCooked = (!alt and self:GetBuff("CookPrimFire", true)) or (alt and self:GetBuff("CookAltFire", true)) or nil

    self:SetNextPrimaryFire(CurTime() + pulltime)
    self:SetPriorityAnim(CurTime() + pulltime)

    self:SetShouldHoldType()

    self:GetBuff_Hook("Hook_PreThrow")

    if pulltime == 0 then
        self:Throw()
        return
    end
end

function SWEP:Throw()
    if self:GetNextPrimaryFire() > CurTime() then return end

    local isCooked = self.isCooked
    self:SetGrenadePrimed(false)
    self.isCooked = nil

    local alt = self:GetGrenadeAlt()

    local anim = alt and self:SelectAnimation("throw_alt") or self:SelectAnimation("throw")
    self:PlayAnimation(anim, self:GetBuff_Mult("Mult_ThrowTime"), false, 0, true)

    local animevent = alt and self:GetBuff_Override("Override_AnimShootAlt", self.AnimShootAlt) or self:GetBuff_Override("Override_AnimShoot", self.AnimShoot)
    self:GetOwner():DoAnimationEvent(animevent)

    local heldtime = CurTime() - self.GrenadePrimeTime

    local mv = 0

    if alt then
        mv = self:GetBuff("MuzzleVelocityAlt", true) or self:GetBuff("MuzzleVelocity")
    else
        mv = self:GetBuff("MuzzleVelocity")
        local chg = self:GetBuff("WindupTime")
        if chg > 0 then
            mv = Lerp(math.Clamp(heldtime / chg, 0, 1), mv * self:GetBuff("WindupMinimum"), mv)
        end
    end

    local force = mv * ArcCW.HUToM

    self:SetTimer(self:GetBuff("ShootEntityDelay"), function()

        local ft = self:GetBuff("FuseTime", true)
        local data = {
            dodefault = true,
            force = force,
            shootentity = self:GetBuff_Override("Override_ShootEntity", self.ShootEntity),
            fusetime = ft and (ft - (isCooked and heldtime or 0)),
        }
        local ovr = self:GetBuff_Hook("Hook_Throw", data)
        if !ovr or ovr.dodefault then
            local rocket = self:FireRocket(self:GetBuff_Override("Override_ShootEntity", self.ShootEntity), force / ArcCW.HUToM)
            if !rocket then return end

            if ft then
                if isCooked then
                    rocket.FuseTime = ft - heldtime
                else
                    rocket.FuseTime = ft
                end
            else
                rocket.FuseTime = math.huge
            end

            local phys = rocket:GetPhysicsObject()

            local inertia = self:GetBuff_Override("Override_ThrowInertia", self.ThrowInertia)
            if inertia == nil then inertia = ArcCW.ConVars["throwinertia"]:GetBool() end
            if inertia and mv > 100 then
                phys:AddVelocity(self:GetOwner():GetVelocity())
            end

            phys:AddAngleVelocity( Vector(0, 750, 0) )
        end
        if !self:HasInfiniteAmmo() then
            local aps = self:GetBuff("AmmoPerShot")
            local a1 = self:Ammo1()
            if self:HasBottomlessClip() or a1 >= aps then
                self:TakePrimaryAmmo(aps)
            elseif a1 < aps then
                self:SetClip1(math.min(self:GetCapacity() + self:GetChamberSize(), self:Clip1() + a1))
                self:TakePrimaryAmmo(a1)
            end

            if (self.Singleton or self:Ammo1() == 0) and !self:GetBuff_Override("Override_KeepIfEmpty", self.KeepIfEmpty) then
                self:GetOwner():StripWeapon(self:GetClass())
                return
            end
        end

    end)
    local t = self:GetAnimKeyTime(anim) * self:GetBuff_Mult("Mult_ThrowTime")
    self:SetPriorityAnim(CurTime() + t)
    self:SetTimer(t, function()
        if !self:IsValid() then return end
        local a = self:SelectAnimation("reload") or self:SelectAnimation("draw")
        self:PlayAnimation(a, self:GetBuff_Mult("Mult_ReloadTime"), true, 0, nil, nil, true)
        self:SetPriorityAnim(CurTime() + self:GetAnimKeyTime(a, true) * self:GetBuff_Mult("Mult_ReloadTime"))
    end)

    self:SetNextPrimaryFire(CurTime() + self:GetFiringDelay())

    self:SetGrenadeAlt(false)

    self:SetShouldHoldType()

    self:GetBuff_Hook("Hook_PostThrow")
end

function SWEP:GrenadeDrop(doammo)
    local rocket = self:FireRocket(self.ShootEntity, 0)

    if IsValid(rocket) then
        local phys = rocket:GetPhysicsObject()

        if ArcCW.ConVars["throwinertia"]:GetBool() then
            phys:AddVelocity(self:GetOwner():GetVelocity())
        end

        local ft = self:GetBuff_Override("Override_FuseTime") or self.FuseTime

        if ft then
            if self.isCooked then
                rocket.FuseTime = ft - (CurTime() - self.GrenadePrimeTime)
            else
                rocket.FuseTime = ft
            end
        end
    end

    if doammo then
        if !self:HasInfiniteAmmo() then
            local aps = self:GetBuff("AmmoPerShot")
            local a1 = self:Ammo1()
            if self:HasBottomlessClip() or a1 >= aps then
                self:TakePrimaryAmmo(aps)
            elseif a1 < aps then
                self:SetClip1(math.min(self:GetCapacity() + self:GetChamberSize(), self:Clip1() + a1))
                self:TakePrimaryAmmo(a1)
            end

            if (self.Singleton or self:Ammo1() == 0) and !self:GetBuff_Override("Override_KeepIfEmpty", self.KeepIfEmpty) then
                self:GetOwner():StripWeapon(self:GetClass())
                return
            end
        end

        self:SetNextPrimaryFire(CurTime() + 1)
        self:SetGrenadePrimed(false)
    end
end
--addons/arccw_base_modified/lua/weapons/arccw_base/sh_rocket.lua:
function SWEP:FireRocket(ent, vel, ang, dontinheritvel)
    if CLIENT then return end

    local rocket = ents.Create(ent)

    ang = ang or (self:GetOwner():EyeAngles() + self:GetFreeAimOffset())

    local src = self:GetShootSrc()

    if !rocket:IsValid() then print("!!! INVALID ROUND " .. ent) return end

    local rocketAng = Angle(ang.p, ang.y, ang.r)
    if ang and self.ShootEntityAngleCorrection then
        local up = ang:Up()
        local right = ang:Right()
        local forward = ang:Forward()
        rocketAng:RotateAroundAxis(up, self.ShootEntityAngleCorrection.y)
        rocketAng:RotateAroundAxis(right, self.ShootEntityAngleCorrection.p)
        rocketAng:RotateAroundAxis(forward, self.ShootEntityAngleCorrection.r)
    end

    rocket:SetAngles(rocketAng)
    rocket:SetPos(src)

    rocket:SetOwner(self:GetOwner())

    rocket.Inflictor = self

    local randfactor = self:GetBuff("DamageRand")
    local mul = 1
    if randfactor > 0 then
        mul = mul * math.Rand(1 - randfactor, 1 + randfactor)
    end
    rocket.Damage = self:GetBuff("Damage") * mul

    if self.BlastRadius then
        local r_randfactor = self:GetBuff("DamageRand")
        local r_mul = 1
        if r_randfactor > 0 then
            r_mul = r_mul * math.Rand(1 - r_randfactor, 1 + r_randfactor)
        end
        rocket.BlastRadius = self:GetBuff("BlastRadius") * r_mul
    end

    local RealVelocity = (!dontinheritvel and self:GetOwner():GetAbsVelocity() or Vector(0, 0, 0)) + ang:Forward() * vel
    rocket.CurVel = RealVelocity -- for non-physical projectiles that move themselves

    rocket:Spawn()
    rocket:Activate()
    if !rocket.NoPhys and rocket:GetPhysicsObject():IsValid() then
        rocket:SetCollisionGroup(rocket.CollisionGroup or COLLISION_GROUP_DEBRIS)
        rocket:GetPhysicsObject():SetVelocityInstantaneous(RealVelocity)
    end

    if rocket.Launch and rocket.SetState then
        rocket:SetState(1)
        rocket:Launch()
    end

    if rocket.ArcCW_Killable == nil then
        rocket.ArcCW_Killable = true
    end

    rocket.ArcCWProjectile = true

    self:GetBuff_Hook("Hook_PostFireRocket", rocket)

    return rocket
end
--addons/arccw_base_modified/lua/weapons/arccw_base/sh_sights.lua:
SWEP.Sighted = false
SWEP.Sprinted = false

local function linearlerp(a, b, c)
    return b + (c - b) * a
end

function SWEP:GetSightTime()
    return self:GetBuff("SightTime")
end

function SWEP:EnterSprint()
    if engine.ActiveGamemode() == "terrortown" and !(TTT2 and self:GetOwner().isSprinting) then return end
    if self:GetState() == ArcCW.STATE_SPRINT then return end
    if self:GetState() == ArcCW.STATE_CUSTOMIZE then return end
    if self:GetTriggerDelta() > 0 then return end
    if self:GetGrenadePrimed() and !self:CanShootWhileSprint() then return end
    self:SetState(ArcCW.STATE_SPRINT)
    self.Sighted = false
    self.Sprinted = true

    local ct = CurTime()

    -- self.SwayScale = 1
    -- self.BobScale = 5

    self:SetShouldHoldType()

    local s = self:CanShootWhileSprint()

    if !s and self:GetNextPrimaryFire() <= ct then
        self:SetNextPrimaryFire(ct)
    end

    local anim = self:SelectAnimation("enter_sprint")
    if anim and !s and self:GetNextSecondaryFire() <= ct then
        self:PlayAnimation(anim, self:GetBuff("SightTime") / self:GetAnimKeyTime(anim, true), true, nil, false, nil, false, false)
    end
end

function SWEP:ExitSprint()
    if self:GetState() == ArcCW.STATE_IDLE then return end

    local delta = self:GetNWSprintDelta()
    local ct = CurTime()

    self:SetState(ArcCW.STATE_IDLE)
    self.Sighted = false
    self.Sprinted = false

    -- self.SwayScale = 1
    -- self.BobScale = 1.5

    self:SetShouldHoldType()

    local s = self:CanShootWhileSprint()

    if !s and self:GetNextPrimaryFire() <= ct then
        self:SetNextPrimaryFire(ct + self:GetSprintTime() * delta)
    end

    if self:GetOwner():KeyDown(IN_ATTACK2) then
        self:EnterSights()
    end

    local anim = self:SelectAnimation("exit_sprint")
    if anim and !s then -- and self:GetNextSecondaryFire() <= ct
        self:PlayAnimation(anim, self:GetBuff("SightTime") / self:GetAnimKeyTime(anim, true), true, nil, false, nil, false, false)
    end
end

-- defined above already?

function SWEP:EnterSights()
    local asight = self:GetActiveSights()
    if !asight then return end
    if self:GetState() != ArcCW.STATE_IDLE then return end
    if self:GetCurrentFiremode().Mode == 0 then return end
    if !self.ReloadInSights and (self:GetReloading() or self:GetOwner():KeyDown(IN_RELOAD)) then return end
    if self.LockSightsInPriorityAnim and self:GetPriorityAnim() then return end
    if self:GetBuff_Hook("Hook_ShouldNotSight") then return end
    if (!game.SinglePlayer() and !IsFirstTimePredicted()) then return end

    self:SetupActiveSights()

    self:SetState(ArcCW.STATE_SIGHTS)
    self.Sighted = true
    self.Sprinted = false

    self:SetShouldHoldType()

    self:MyEmitSound(asight.SwitchToSound or "", 75, math.Rand(95, 105), 0.5, CHAN_AUTO)

    local anim = self:SelectAnimation("enter_sight")
    if anim then
        self:PlayAnimation(anim, 1 * self:GetBuff_Mult("Mult_SightTime"), true)
    end

    self:GetBuff_Hook("Hook_SightToggle", true)
end

function SWEP:ExitSights()
    local asight = self:GetActiveSights()
    if self:GetState() != ArcCW.STATE_SIGHTS then return end
    if self.LockSightsInReload and self:GetReloading() then return end
    if self.LockSightsInPriorityAnim and self:GetPriorityAnim() then return end
    if (!game.SinglePlayer() and !IsFirstTimePredicted()) then return end

    self:SetState(ArcCW.STATE_IDLE)
    self.Sighted = false
    self.Sprinted = false

    self:SetShouldHoldType()

    self:MyEmitSound(asight.SwitchFromSound or "", 75, math.Rand(80, 90), 0.5, CHAN_AUTO)

    if self:InSprint() then
        self:EnterSprint()
    end

    self:MyEmitSound(asight.SwitchFromSound or "", 75, math.Rand(80, 90), 0.5, CHAN_AUTO)

    local anim = self:SelectAnimation("exit_sight")
    if anim then
        self:PlayAnimation(anim, 1 * self:GetBuff_Mult("Mult_SightTime"), true)
    end

    self:GetBuff_Hook("Hook_SightToggle", false)
end

function SWEP:GetSprintTime()
    return self:GetSightTime()
end

SWEP.SightTable = {}
SWEP.SightMagnifications = {}

function SWEP:SetupActiveSights()
    if !self.IronSightStruct then return end
    if self:GetBuff_Hook("Hook_ShouldNotSight") then return false end

    if !self:GetOwner():IsPlayer() then return end

    local sighttable = {}
    local vm = self:GetOwner():GetViewModel()

    if !vm or !vm:IsValid() then return end

    local kbi = self.KeepBaseIrons or true
    local bif = self.BaseIronsFirst or true

    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end

        local atttbl = ArcCW.AttachmentTable[k.Installed]

        local addsights = self:GetBuff_Stat("AdditionalSights", i)
        if !addsights then continue end

        if !k.KeepBaseIrons and !atttbl.KeepBaseIrons then kbi = false end
        if !k.BaseIronsFirst and !atttbl.BaseIronsFirst then bif = false end

        for _, s in pairs(addsights) do
            local stab = table.Copy(s)

            stab.Slot = i

            if stab.HolosightData then atttbl = stab.HolosightData end

            stab.HolosightData = atttbl

            if atttbl.HolosightMagnification then
                stab.MagnifiedOptic = true
                stab.ScopeMagnification = atttbl.HolosightMagnification or 1

                if atttbl.HolosightMagnificationMin then
                    stab.ScopeMagnificationMin = atttbl.HolosightMagnificationMin
                    stab.ScopeMagnificationMax = atttbl.HolosightMagnificationMax

                    stab.ScopeMagnification = math.max(stab.ScopeMagnificationMax, stab.ScopeMagnificationMin)

                    if !i and self.SightMagnifications[0] then
                        stab.ScopeMagnification = self.SightMagnifications[0]
                    elseif self.SightMagnifications[i] then
                        stab.ScopeMagnification = self.SightMagnifications[i]
                    end
                else
                    stab.ScopeMagnification = atttbl.HolosightMagnification
                end
            end

            if atttbl.Holosight then
                stab.Holosight = true
            end

            if !k.Bone then return end

            local boneid = vm:LookupBone(k.Bone)

            if !boneid then return end

            if CLIENT then

                if atttbl.HolosightPiece then
                    stab.HolosightPiece = (k.HSPElement or {}).Model
                end

                if atttbl.Holosight then
                    stab.HolosightModel = (k.VElement or {}).Model
                end

                local bpos, bang = self:GetFromReference(boneid)

                local offset
                local offset_ang

                local vmang = Angle()

                offset = k.Offset.vpos or Vector(0, 0, 0)

                local attslot = k

                local delta = attslot.SlidePos or 0.5

                local vmelemod = nil
                local slidemod = nil

                for _, e in pairs(self:GetActiveElements()) do
                    local ele = self.AttachmentElements[e]

                    if !ele then continue end

                    if ((ele.AttPosMods or {})[i] or {}).vpos then
                        vmelemod = ele.AttPosMods[i].vpos
                    end

                    if ((ele.AttPosMods or {})[i] or {}).slide then
                        slidemod = ele.AttPosMods[i].slide
                    end

                    -- Refer to sh_model Line 837
                    if ((ele.AttPosMods or {})[i] or {}).SlideAmount then
                        slidemod = ele.AttPosMods[i].SlideAmount
                    end
                end

                offset = vmelemod or attslot.Offset.vpos or Vector()

                if slidemod or attslot.SlideAmount then
                    offset = LerpVector(delta, (slidemod or attslot.SlideAmount).vmin, (slidemod or attslot.SlideAmount).vmax)
                end

                offset_ang = k.Offset.vang or Angle(0, 0, 0)
                offset_ang = offset_ang + (atttbl.OffsetAng or Angle(0, 0, 0))

                offset_ang = k.VMOffsetAng or offset_ang

                bpos, bang = WorldToLocal(Vector(0, 0, 0), Angle(0, 0, 0), bpos, bang)

                bpos = bpos + bang:Forward() * offset.x
                bpos = bpos + bang:Right() * offset.y
                bpos = bpos + bang:Up() * offset.z

                bang:RotateAroundAxis(bang:Right(), offset_ang.p)
                bang:RotateAroundAxis(bang:Up(), -offset_ang.y)
                bang:RotateAroundAxis(bang:Forward(), offset_ang.r)

                local vpos = Vector()

                vpos.y = -bpos.x
                vpos.x = bpos.y
                vpos.z = -bpos.z

                local corpos = (k.CorrectivePos or Vector(0, 0, 0))

                vpos = vpos + bang:Forward() * corpos.x
                vpos = vpos + bang:Right() * corpos.y
                vpos = vpos + bang:Up() * corpos.z

                -- vpos = vpos + (bang:Forward() * s.Pos.x)
                -- vpos = vpos - (bang:Right() * s.Pos.y)
                -- vpos = vpos + (bang:Up() * s.Pos.z)

                vmang:Set(-bang)

                bang.r = -bang.r
                bang.p = -bang.p
                bang.y = -bang.y

                corang = k.CorrectiveAng or Angle(0, 0, 0)

                bang:RotateAroundAxis(bang:Right(), corang.p)
                bang:RotateAroundAxis(bang:Up(), corang.y)
                bang:RotateAroundAxis(bang:Forward(), corang.r)

                -- vpos = LocalToWorld(s.Pos + Vector(0, self.ExtraSightDist or 0, 0), Angle(0, 0, 0), vpos, bang)

                -- local vmf = (vmang):Forward():GetNormalized()
                -- local vmr = (vmang):Right():GetNormalized()
                -- local vmu = (vmang):Up():GetNormalized()

                -- print(" ----- vmf, vmr, vmu")
                -- print(vmf)
                -- print(vmr)
                -- print(vmu)

                -- vmf = -vmf
                -- vmf.x = -vmf.x

                -- local r = vmf.y
                -- vmf.y = vmf.z
                -- vmf.z = r

                -- vmr = -vmr
                -- vmr.y = -vmr.y

                -- -- local r = vmr.y
                -- -- vmr.y = vmr.z
                -- -- vmr.z = r

                -- vmu = -vmu
                -- vmu.z = vmu.z

                -- local evpos = Vector(0, 0, 0)

                -- evpos = evpos + (vmf * (s.Pos.x + k.CorrectivePos.x))
                -- evpos = evpos - (vmr * (s.Pos.y + (self.ExtraSightDist or 0) + k.CorrectivePos.y))
                -- evpos = evpos + (vmu * (s.Pos.z + k.CorrectivePos.z))

                -- print(vmang:Forward())

                local evpos = s.Pos

                evpos = evpos * (k.VMScale or Vector(1, 1, 1))

                if atttbl.Holosight and !atttbl.HolosightMagnification then
                    evpos = evpos + Vector(0, k.ExtraSightDist or self.ExtraSightDist or 0, 0)
                end

                evpos = evpos + (k.CorrectivePos or Vector(0, 0, 0))

                stab.Pos, stab.Ang = vpos, bang

                stab.EVPos = evpos
                stab.EVAng = s.Ang

                if s.GlobalPos then
                    stab.EVPos = Vector(0, 0, 0)
                    stab.Pos = s.Pos
                end

                if s.GlobalAng then
                    stab.Ang = Angle(0, 0, 0)
                end

            end

            table.insert(sighttable, stab)
        end
    end

    if kbi then
        local extra = self.ExtraIrons
        if extra then
            for _, ot in pairs(extra) do
                local t = table.Copy(ot)
                t.IronSight = true
                if bif then
                    table.insert(sighttable, 1, t)
                else
                    table.insert(sighttable, t)
                end
            end
        end

        local t = table.Copy(self:GetBuff_Override("Override_IronSightStruct") or self.IronSightStruct)
        t.IronSight = true
        if bif then
            table.insert(sighttable, 1, t)
        else
            table.insert(sighttable, t)
        end
    end

    self.SightTable = sighttable
end

function SWEP:SwitchActiveSights()
    if table.Count(self.SightTable) == 1 then return end

    self.ActiveSight = (self.ActiveSight or 1) + 1

    if self.ActiveSight > table.Count(self.SightTable) then
        self.ActiveSight = 1
    end

    local asight = self:GetActiveSights()

    local tbl = self:GetBuff_Hook("Hook_SwitchActiveSights", {active = self.ActiveSight, asight = asight})

    self.ActiveSight = tbl.active or self.ActiveSight

    if self.ActiveSight > table.Count(self.SightTable) then
        self.ActiveSight = 1
    end

    local asight2 = self:GetActiveSights()

    if asight2.SwitchToSound then
        self:MyEmitSound(asight2.SwitchToSound, 75, math.Rand(95, 105), 0.5, CHAN_VOICE2)
    end
end

function SWEP:GetActiveSights()
    if (self.ActiveSight or 1) > table.Count(self.SightTable) then
        self.ActiveSight = 1
    end

    if table.Count(self.SightTable) == 0 then
        return self.IronSightStruct
    else
        return self.SightTable[self.ActiveSight or 1]
    end
end

local function ScaleFOVByWidthRatio( fovDegrees, ratio )
    local halfAngleRadians = fovDegrees * ( 0.5 * math.pi / 180 )
    local t = math.tan( halfAngleRadians )
    t = t * ratio
    local retDegrees = ( 180 / math.pi ) * math.atan( t )
    return retDegrees * 2
end

function SWEP:QuickFOVix( fov )
    return ScaleFOVByWidthRatio( fov, (ScrW and ScrW() or 4)/(ScrH and ScrH() or 3)/(4/3) )
end

SWEP.LastTranslateFOV = 0
function SWEP:TranslateFOV(fov)
    local irons = self:GetActiveSights()

    if CLIENT and ArcCW.ConVars["dev_benchgun"]:GetBool() then self.CurrentFOV = fov self.CurrentViewModelFOV = fov return fov end

    self.ApproachFOV = self.ApproachFOV or fov
    self.CurrentFOV = self.CurrentFOV or fov

    -- Only update every tick (this function is called multiple times per tick)
    if self.LastTranslateFOV == UnPredictedCurTime() then return self.CurrentFOV end
    local timed = UnPredictedCurTime() - self.LastTranslateFOV
    self.LastTranslateFOV = UnPredictedCurTime()

    local app_vm = self.ViewModelFOV + self:GetOwner():GetInfoNum("arccw_vm_fov", 0)
    if CLIENT then
        app_vm = app_vm * (LocalPlayer():GetFOV()/GetConVar("fov_desired"):GetInt())
    end

    if self:GetState() == ArcCW.STATE_SIGHTS then
        local asight = self:GetActiveSights()
        local mag = asight and asight.ScopeMagnification or 1

        local delta = math.pow(self:GetSightDelta(), 2)

        if CLIENT then
            local addads = math.Clamp(ArcCW.ConVars["vm_add_ads"]:GetFloat() or 0, -2, 14)
            local csratio = math.Clamp(GetConVar("arccw_cheapscopesv2_ratio"):GetFloat() or 0, 0, 1)
            local pfov = GetConVar("fov_desired"):GetInt()

            if ArcCW.ConVars["cheapscopes"]:GetBool() and mag > 1 then
                fov = (pfov / (asight and asight.Magnification or 1)) / (mag / (1 + csratio * mag) + (addads or 0) / 3)
            else
                fov = ( (pfov / (asight and asight.Magnification or 1)) * (1 - delta)) + (GetConVar("fov_desired"):GetInt() * delta)
            end

            app_vm = irons.ViewModelFOV or 45

            app_vm = app_vm - (asight.MagnifiedOptic and (addads or 0) * 3 or 0)
        end
    end

    self.ApproachFOV = fov

    -- magic number? multiplier of 10 seems similar to previous behavior
    self.CurrentFOV = math.Approach(self.CurrentFOV, self.ApproachFOV, timed * 10 * (self.CurrentFOV - self.ApproachFOV))

    self.CurrentViewModelFOV = self.CurrentViewModelFOV or self.ViewModelFOV
    self.CurrentViewModelFOV = math.Approach(self.CurrentViewModelFOV, app_vm, timed * 10 * (self.CurrentViewModelFOV - app_vm))

    return self.CurrentFOV
end

function SWEP:SetShouldHoldType()
    if self:GetCurrentFiremode().Mode == 0 then
        self:SetHoldType(self.HoldtypeHolstered)
        return
    end

    if IsValid(self:GetOwner()) and self:GetOwner():IsNPC() and self.HoldtypeNPC then
        self:SetHoldType(self.HoldtypeNPC)
        return
    end

    local ht = "normal"

    if self:GetState() == ArcCW.STATE_SIGHTS then
        ht = self:GetBuff_Override("Override_HoldtypeSights", self.HoldtypeSights)
    elseif self:GetState() == ArcCW.STATE_SPRINT then
        if self:CanShootWhileSprint() then
            ht = self:GetBuff_Override("Override_HoldtypeSprintShoot", self.HoldtypeSprintShoot) or self:GetBuff_Override("Override_HoldtypeActive", self.HoldtypeActive)
        else
            ht = self:GetBuff_Override("Override_HoldtypeHolstered", self.HoldtypeHolstered)
        end
    elseif self:GetState() == ArcCW.STATE_CUSTOMIZE then
        ht = self:GetBuff_Override("Override_HoldtypeCustomize", self.HoldtypeCustomize)
    elseif self:GetCurrentFiremode().Mode == 0 then
        ht = self:GetBuff_Override("Override_HoldtypeHolstered", self.HoldtypeHolstered)
    elseif self.Throwing and self:GetGrenadePrimed() then
        ht = self:GetBuff_Override("Override_HoldtypeSights", self.HoldtypeSights)
    else
        ht = self:GetBuff_Override("Override_HoldtypeActive", self.HoldtypeActive)
    end

    self:SetHoldType(ht)
end

--addons/arccw_weapons/lua/weapons/arccw_dc17m_shotgun_v2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "DC-17m Shotgun"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "High tech DC-17m Shotgun, preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/viewmodels/c_dc17m_shotgun.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_DC-17m_shotgun.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(-26, 11, -4),
    ang = Angle(170, 180, 0),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.IconOverride = "materials/entities/rw_sw_dc17m_shotgun.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "0310000000"

SWEP.Damage = 35
SWEP.RangeMin = 23
SWEP.DamageMin = 19
SWEP.Range = 50
SWEP.Penetration = 1
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 400



SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 5

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.18

SWEP.Delay = 60 / 160
SWEP.Num = 6
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 30 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 410 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 100

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100


SWEP.DistantShootSound = "shared/SW01_Weapons_LongBlasters_Shared_Corebass_Close_VAR_01 0 0 0.ogg"
SWEP.ShootSound = "dc17m/dc17mshotgun.wav"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-6.53, -8, 0.9),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(2.5, -2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(0.2, -1, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"", ""}

SWEP.AttachmentElements = {
}

--SWEP.Attachments 
SWEP.Attachments = {
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        Bone = "optic", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.05, 0.4, 3.15),
            vang = Angle(90, 0, -90),
            wpos = Vector(7, 1.5, -7),
            wang = Angle(-10, 0, 180)
        },
        -- CorrectiveAng = Angle(-2.4, -0, 0)
    },
    {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"foregrip"},
        Bone = "optic", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.2, 4.8, 6.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(10, 1.5, -3),
            wang = Angle(170, 180, 0),
        },
    },          
    {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol","tac"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1.8, 0.75, 12),
            vang = Angle(90, 0, 40),
            wpos = Vector(16, 3, -8),
            wang = Angle(-10, 0, -60)
        },
    },
    {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle","dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.05, 1.15, 19.45),
            vang = Angle(90, 0, -90),
            wpos = Vector(22.1, 1.51, -8.7),
            wang = Angle(-10, 0, -90)
        },
    },    
    {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, 2.3, -3),
            vang = Angle(0, 0, 0),
        },
    },         
    {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1.4, 1.6, 2),
            vang = Angle(90, 0, -70),
            wpos = Vector(6, 3, -5),
            wang = Angle(-10 , 0, 180)
        },
    },    
    {
        PrintName = "Killcounter", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"killcounter"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 2, 2),
            vang = Angle(90, 0, -90),
        },
    },   
    {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },    
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "Fire"
    },
    ["draw"] = {
        Source = "Draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "Holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "Reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            --{s = "viper/weapons/sierra552/wfoly_ar_sierra552_reload_xmag_fast_empty_end.ogg", t = 20 / 60},
            {s = "dc17m/reload/SW02_Weapons_Overheat_ManualCooling_VAR_04 0 0 0.ogg", v = 10 , t = 23 / 60},
            {s = "dc17m/reload/magin.ogg", t = 115 / 60},
            {s = "dc17m/reload/maghit.ogg", t = 132 / 60},
            {s = "dc17m/reload/SCIMisc_Ammo Replenish_01.ogg", t = 139 / 60} --s sound file
        },
    },
}


-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Damage = 100
SWEP.DamageMin = 50
SWEP.RangeMin = 50
SWEP.Range = 200
SWEP.Delay = 60 / 135
SWEP.Primary.ClipSize = 8
SWEP.Category = 'REP'
--addons/arccw_weapons/lua/weapons/arccw_dual_se14.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Droidenwaffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Dual SE-14"
SWEP.Trivia_Class = "CIS Dual Blaster Carbine"
SWEP.Trivia_Desc = "High tech compact Dual SE-14 Blaster Carbine."
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel = "models/arccw/weapons/synbf3/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dual_se14.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 120
SWEP.DamageMin = 17
SWEP.Range = 345
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.NoHideLeftHandInCustomization = true

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20*2

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 1.4
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 380
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },    
}

SWEP.AccuracyMOA = 0.75 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 800 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/se14c.wav"

SWEP.MuzzleFlashColor = Color(255, 0, 0, 50)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1.2,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -4)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)

SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)
SWEP.DrawCrosshair = true

SWEP.BarrelLength = 44
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"se14c", "se14c+"}

SWEP.AttachmentElements = {
    ["se14c"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/2019/se14_pistol.mdl",
                Bone = "LeftHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(05, -1.5, -0.75),
                    ang = Angle(-8, -2, 90)
                }
            }
        },
    },
    ["se14c+"] = {
         VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/2019/se14_pistol.mdl",
                Bone = "RightHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),                
                Offset = {
                    pos = Vector(-5, 1.5, 0.75),
                    ang = Angle(4, 178, 90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/2019/se14_pistol.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(40.5, 10, 20.75),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/sw_battlefront/weapons/2019/se14_pistol.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-40, 230, -25),
                    ang = Angle(180, -180, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/sw_battlefront/weapons/2019/se14_pistol.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-12, -4, 2.5),
            vang = Angle(170, 0, 0),
        },
    },    
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    }
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_lw", "shoot_rw"},
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}


-- AOCRP WAFFENSTATS arccw_dual_se14 - 02.06.2024
SWEP.Damage = 30
SWEP.DamageMin = 15
SWEP.RangeMin = 90
SWEP.Range = 350
SWEP.Delay = 60 / 586
SWEP.Primary.ClipSize = 46
SWEP.Category = 'KUS'
--addons/arccw_weapons/lua/weapons/arccw_munni_box.lua:

SWEP.Base = "arccw_base_nade"
--SWEP.Base = "arccw_grenade_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "ArcCW - Starwars [Dec]" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "Ammo Crate"
SWEP.Trivia_Desc = "A throable munnitons box"
SWEP.Trivia_Manufacturer = "Blas-Tech Industries"
SWEP.Trivia_Mechanism = "Gives the ammo your holding if you are not holding a weappon it gives Puls ammo"
SWEP.Trivia_Country = "GAR"

SWEP.Slot = 3

SWEP.CamAttachment = 3

SWEP.NotForNPCs = false

SWEP.UseHands = false

SWEP.ViewModel = "models/weapons/nade_frag.mdl"
SWEP.WorldModel = "models/weapons/w_nade_frag.mdl"
SWEP.HideViewmodel = true
SWEP.MirrorVMWM = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    scale = 0.1
}

SWEP.IconOverride = "materials/entities/flash_grenade_meeks.png"

SWEP.FuseTime = 1.5
SWEP.PullPinTime = 0.5

SWEP.ViewModelFOV = 70

SWEP.Primary.Ammo = "AR2AltFire"

SWEP.Primary.ClipSize = 1

SWEP.MuzzleVelocityAlt = 600
SWEP.MuzzleVelocity = 450
SWEP.ShootEntity = "arccw_ammo_chargepack_thr"

SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "Crate",
    },
}

SWEP.DefaultElements = {"chargepack"}

SWEP.AttachmentElements = {
    ["chargepack"] = {
        VMElements = {
            {
                Model = "models/cs574/objects/ammo_box.mdl",
                Bone = "def_c_base",
                Scale = Vector(.8, .8, .8),
                Offset = {
                    pos = Vector(-6.4, 4.4, -2.2),
                    ang = Angle(-0, 0, -45)
                }
            }
        },
        WMElements = {
            {
                Model = "models/cs574/objects/ammo_box.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.9, 0.9, 0.9),
                Offset = {
                    pos = Vector(0, 0, 0),
                    ang = Angle(0, 0, 180)
                }
            }
        },
    },
}

WMOverride = "models/cs574/objects/ammo_box.mdl"


SWEP.Animations = {
    ["draw"] = {
        Source = "deploy",
        SoundTable = {
            {
                t = 0,
                s = "arccw/mun/grenade_throw.wav",
                c = CHAN_WEAPON
            }
        }
    },
    ["throw"] = {
        Source = "throw",
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
        SoundTable = {
            {
                t = 0,
                s = "arccw/mun/grenade_throw.wav",
                c = CHAN_WEAPON
            }
        }
    }
}

sound.Add({
    name = "ARCCW_MUN.Draw",
    channel = 16,
    volume = 1.0,
    sound = "arccw/mun/grenade_throw.wav"
})
--addons/arccw_weapons/lua/weapons/arccw_nade_inc.lua:

SWEP.Base = "arccw_base_nade"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "AOCRP - Eingestellte Waffen" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "Incendiary Grenade"
SWEP.Trivia_Class = "Hand Grenade"
SWEP.Trivia_Desc = "Eine Professionele Bradgranate fuer die nutzung durch Clon Pionire und ARCs"
SWEP.Trivia_Manufacturer = "Blas-Tech Industries"
SWEP.Trivia_Mechanism = "Entflambare Fluessigkeit und Kleiner sprengsatz zur entzuendung und verteilung"
SWEP.Trivia_Country = "GAR"

SWEP.Slot = 3
SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/nade_frag.mdl"
SWEP.WorldModel = "models/weapons/w_nade_frag.mdl"
SWEP.HideViewmodel = true
SWEP.MirrorVMWM = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    scale = 0.09
}

SWEP.ProceduralViewBobIntensity = 0

SWEP.FuseTime = false

SWEP.Throwing = true

SWEP.Primary.ClipSize = 1

SWEP.MuzzleVelocity = 1000
SWEP.ShootEntity = "arccw_thr_inc"

SWEP.TTTWeaponType = "weapon_zm_molotov"
SWEP.NPCWeaponType = "weapon_grenade"
SWEP.NPCWeight = 50

SWEP.PullPinTime = 1

SWEP.DefaultElements = {"shock_grenade"}

SWEP.AttachmentElements = {
    ["shock_grenade"] = {
        VMElements = {
            {
                Model = "models/arccw/shock_grenade.mdl",
                Bone = "def_c_base",
                Scale = Vector(0.8, 0.8, 0.8),
                Offset = {
                    pos = Vector(-.5, -0.1, -.1),
                    ang = Angle(-35, -190, 90)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/shock_grenade.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.8, 0.8, 0.8),
                Offset = {
                    pos = Vector(35, 25, 0),
                    ang = Angle(0, 0, 0)
                }
            }
        },
    },
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {Source = "sprint", Mult = 0.9},
    ["enter_sprint"] = {Source = "sprint_in", Mult = 0.1},
    ["exit_sprint"] = {Source = "sprint_out", Mult = 0.1},
    ["ready"] = {
        Source = "draw",
        SoundTable = {
           {s = "ArcCW_ThermalDet.firstdeploy1", t = 0 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = "misc/gunfoley_blaster_sheathe_var_03.mp3", t = 0 / 30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = "ArcCW_ThermalDet.holster1", t = 0 / 30}
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "ArcCW_primer.button", t = 0 / 30},
        },
        MinProgress = 0.5,
    },
    ["fire"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "ArcCW_primer.button", t = 0 / 30},
        },
    },
    ["throw"] = {
        Source = {"toss_overhead"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
    },
    ["throw_alt"] = {
        Source = {"underhand"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
    },
    ["enter_inspect"] = {
        Source = "inspect_in",
        LHIK = true,
    },
    ["exit_inspect"] = {
        Source = "inspect_out",
        LHIK = true,
    },
    ["idle_inspect"] = {
        Source = "inspect",
        LHIK = true,
    },
}

sound.Add({
    name = "ARCCW_INC.Draw",
    channel = 16,
    volume = 1.0,
    sound = "arccw/inc/inc_draw.wav"
})
--addons/arccw_weapons/lua/weapons/arccw_nn14.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "[P] NN-14"
SWEP.Trivia_Class = "Galactic Heavy Blaster Pistol"
SWEP.Trivia_Desc = "A Heavy Blaster pistol for shooting enviroments"
SWEP.Trivia_Manufacturer = "Forged Armory"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_nn14.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 32
SWEP.RangeMin = 135
SWEP.DamageMin = 24
SWEP.Range = 325
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 15

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 145
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(250, 0, 0)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/nn14.wav"
SWEP.IronSightStruct = {
    Pos = Vector(-3.6, -8, 0.8),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterpistol_04.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, -4, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -10,-20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(20.824, -16, 4.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"nn14"}

SWEP.AttachmentElements = {
    ["nn14"] = {
        VMElements = {
            {
                Model = "models/arccw/cs574/weapons/nn14.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-0.35, -06, -01.2),
                    ang = Angle(0, 90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/cs574/weapons/nn14.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(100, 20, -15.3),
                    ang = Angle(-15, 0, 180)
                }
            }
        },
    },
}
WMOverride = "models/arccw/cs574/weapons/nn14.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "swoptic_module",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.35, -5, 3.8),
            vang = Angle(0, 180, 0),
            wpos = Vector(90, 20, -70),
            wang = Angle(-15, 90, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9), -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-.4, -10, 2.5),
            vang = Angle(0, 90, 0),
            wpos = Vector(135, 20, -65),
            wang = Angle(-15, 0, 180)
        },
    },    
    [5] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(8, 8, 8),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1.2, 0.5, 6),
            vang = Angle(90, 0, -90),
            wpos = Vector(100, 30, -60),
            wang = Angle(-10, 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
 --       Time = 3.35,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_sg6.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Droidenwaffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "SG-6"
SWEP.Trivia_Class = "CIS Shotgun Blaster"
SWEP.Trivia_Desc = "High tech CIS Shotgun Blaster"
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_dlt19.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_dlt19.mdl"
SWEP.ViewModelFOV = 70
SWEP.MirrorVMWM = false -- Copy the viewmodel, along with all its attachments, to the worldmodel. Super convenient!
SWEP.MirrorWorldModel = false
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_sg6.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 27
SWEP.RangeMin = 16
SWEP.DamageMin = 14
SWEP.Range = 50
SWEP.Penetration = 1
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 6

SWEP.Recoil = 1.5
SWEP.RecoilSide = 0.6
SWEP.RecoilPunch = 0.8
SWEP.RecoilRise = 1

SWEP.Delay = 90 / 240
SWEP.Num = 6
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 50 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 450 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 100

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(250, 0, 0)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/sg6.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-3.05, -6, -0.3),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 70,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(2, .8, -2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(2, -3, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.DefaultElements = {"sg6", "muzzle"}

SWEP.AttachmentElements = {
    ["sg6"] = {
        VMElements = {
            {
                Model = "models/arccw/swbf3/weapons/cisshotgun.mdl",
                Bone = "v_dlt19_reference001",
                Scale = Vector(1.2, 1.1, 1.2),
                Offset = {
                    pos = Vector(0.8, 0, 1.5),
                    ang = Angle(0, 89.5, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt19_sight",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-0.5, 4, 14),
                   ang = Angle(90, 0, 0)
               },
               IsMuzzleDevice = true
           }
       },
        WMElements = {
            {
                Model = "models/arccw/swbf3/weapons/cisshotgun.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(200, 100, -100),
                    ang = Angle(-15, 180, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(2100, 0, -600),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },            
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/swbf3/weapons/cisshotgun.mdl"
--SWEP.Attachments
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.13, -1.5, -3),
            vang = Angle(90, 0, -90),
            wpos = Vector(500, 75, -600),
            wang = Angle(-15, 0, 180)
        },
    }, 
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 3, 9),
            vang = Angle(90, 0, -90),
            wpos = Vector(2000, 90, -530),
            wang = Angle(-15, 0, 180)
        },
    },    
    [3] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.1, 3.4, 3.4),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
            vmin = Vector(-0.2, 2.5, 6),
            vmax = Vector(-0.2, 2.5, 12),
            wmin = Vector(1700, 70, -590), 
            wmax = Vector(1700, 70, -590)
        }, 
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        NoWM = true,
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.3, 2.05, 12),
            vang = Angle(90, 0, -90),
        },
    },             
    [5] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [6] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [7] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 2.1, 0),
            vang = Angle(90, 0, -70),
            wpos = Vector(900, 200, -400),
            wang = Angle(0 , 0, 180)
        },
    },          
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
    },
    ["holster"] = {
        Source = "holster",
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15a.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/heavy.wav"
    }),
}


-- AOCRP WAFFENSTATS arccw_sg6 - 02.06.2024
SWEP.Damage = 90
SWEP.DamageMin = 50
SWEP.RangeMin = 50
SWEP.Range = 200
SWEP.Delay = 60 / 135
SWEP.Primary.ClipSize = 20
SWEP.Category = 'KUS'
--addons/arccw_weapons/lua/weapons/arccw_sops_773firepuncher.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "REP"
SWEP.Credits = "Kraken"
SWEP.PrintName = "'773 Firepuncher"
SWEP.Trivia_Class = "Blaster-Experimental Sniper Rifle"
SWEP.Trivia_Desc = "The 773 Firepuncher rifle, also known as the 773 Firepuncher, was a model of sniper rifle manufactured by Merr-Sonn Munitions, Inc. that featured ablative coating and a wide-beam 'burning' mode."
SWEP.IconOverride = "entities/sopsmisc/firepuncher.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = false
SWEP.ViewModel = "models/arccw/masita/viewmodels/base_rifle_animations.mdl"
SWEP.WorldModel = "models/weapons/synbf3/w_t21.mdl"
SWEP.ViewModelFOV = 66
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 178
SWEP.RangeMin = 702
SWEP.DamageMin = 101
SWEP.Range = 1240
SWEP.Penetration = 2
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 22

SWEP.Recoil = 1.02
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.78
SWEP.Delay = 60 / 102

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.1
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/firepuncher.wav"
SWEP.ShootSound = "sops-v2/weapons/firepuncher.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-4.1, 0, 1.5),
    Ang = Angle(1, -0.5, -3),
     Magnification = 2,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/holo_773firepuncher.mdl",
                Bone = "E11S_CONTR",
                ModelBodygroups = "00000",
                Scale = Vector(0.7, 0.7, 0.7),
                Offset = {
                    pos = Vector(-0.9, 7, -1.5),
                    ang = Angle(0, 180, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-3, 48, -8),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/holo_773firepuncher.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.7, 0.7, 0.7),
                ModelBodygroups = "00000",
                Offset = {
                    pos = Vector(170, 10, -56),
                    ang = Angle(-15, 90, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(480, 15, -150),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/holo_773firepuncher.mdl"


SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.9, -3, 1.1),
            vang = Angle(0, -90, 0),
            wpos = Vector(52, 10, -56),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0)
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR", 
        Offset = {
            vpos = Vector(-0.9, 29, -1.1),
            vang = Angle(0, -90, 0),
            wpos = Vector(480, 10, -140),
            wang = Angle(-15, 0, -180)
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = "foregrip",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.9, 14, -2.1),
            vang = Angle(0, -90, 0),
            wpos = Vector(200, 10, -55),
            wang = Angle(-15, 0, 180)
        },          
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},  
    },    
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(11, 11, 11),
        Offset = {
            vpos = Vector(0.3, 0, 0),
            vang = Angle(0, -90, 0),
            wpos = Vector(100, 24, -50),
            wang = Angle(-15, 0, 180)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(11, 11, 11),
        VMScale = Vector(1, 1, 1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.3, -5, 0),
            vang = Angle(0, -90, 0),
            wpos = Vector(50, 23, -40),
            wang = Angle(-15, 0, 180)
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 120 / 60},
        },
    },
}

--addons/arccw_weapons/lua/weapons/arccw_sops_a280cfe.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3




SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "A-280CFE"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "BlasTech A Serie - Prototyp 5"
SWEP.IconOverride = "entities/sopsmisc/a280cfe.png"

SWEP.DefaultBodygroups  = "000102"
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops-v2/c_a280cfe.mdl"
SWEP.WorldModel = "models/arccw/kraken/sops-v2/w_a280cfe.mdl"
SWEP.ViewModelFOV = 58
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-12, 4.5, -5),
    ang = Angle(-10, 0, 180),
    scale = 1.2,
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 35
SWEP.RangeMin = 500
SWEP.DamageMin = 10
SWEP.Range = 3500
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.78
SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0.56
SWEP.Delay = 60 / 500

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.06
SWEP.HipDispersion = 470
SWEP.MoveDispersion = 267

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/a280cfe.wav"
SWEP.ShootSound = "sops-v2/weapons/a280cfe.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-3.875, -12.188, 2.5),
    Ang = Angle(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -3, 2)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.AttachmentElements = {
    ["a280cfe_barrel_short"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
        AttPosMods = {
            [2] = {
                vpos = Vector(-0.175, -1.65, 15.5   ),
            },
        }
    },
    ["a280cfe_barrel_sniper"] = {
        NameChange = "Sniper A-280CFE",
        VMBodygroups = {{ind = 1, bg = 2}},
        AttPosMods = {
            [2] = {
                vpos = Vector(-0.175, -1.65, 24),
            },
        }
    },
    ["a280cfe_powerpack"] = {
        VMBodygroups = {
            {ind = 4, bg = 1},
        },
    },
    ["a280cfe_stock_assault"] = {
        VMBodygroups = {
            {ind = 5, bg = 0},
        },
    },
    ["a280cfe_stock_heavy"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
        },
    },
}

SWEP.Attachments = {   
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    {
        PrintName = "Optic",
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "a280cfe",
        Offset = {
            vpos = Vector(-0.175, -2.6, 0),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, -0.025),
    }, 
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "a280cfe",
        Offset = {
            vpos = Vector(-0.175, -1.7, 19.2),
            vang = Angle(90, 0, -90),

        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "a280cfe",
        Offset = {
            vpos = Vector(0.4, -1.7, 11),
            vang = Angle(90, 0, 20),
        },
    },  
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        Bone = "a280cfe",
        Offset = {
            vpos = Vector(-0.175, -0.6, 11),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Stock",
        DefaultAttName = "None",
        Slot = {"cfe_stock"},
    },  
    {
        PrintName = "Powerpack", 
        DefaultAttName = "None",
        Slot = {"cfe_powerpack"},
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "a280cfe",
        VMScale = Vector(0.8, 0.8, 0.8),
        Offset = {
            vpos = Vector(0.3, -1.7, 1),
            vang = Angle(90, 0, -70),
        },
    },     
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "a280cfe",
        VMScale = Vector(0.5, 0.5, 0.5),
        Offset = {
            vpos = Vector(0.35, -0.8, 1),
            vang = Angle(90, 0, -90),
        },
    },   
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        LHIK = true,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        Mult = 0.9,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_manualcooling_var_02.mp3", t = 5 / 30},
            {s = "weapon_hand/reload_gentle/mag_eject/023d-00001014.mp3", t = 10 / 30},
            {s = "weapon_hand/reload_gentle/mag_load/023d-00000dda.mp3", t = 60 / 30},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_04.mp3", t = 70 / 30},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_deathwatchblaster.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "Deathwatch Blaster"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "This blaster carbine was a popular blaster carbine manufactured by the Mandalorian arms giant Concordian Crescent Technologies. It was named after the galaar, a common bird of prey that was native to the planet Mandalore. It was a sleek, short-barreled rifle constructed from high-quality materials and was covered in shock-resistant polycarbonate. And while relatively rare, this blaster was a frequent item that appeared on the black market. Due to its high-quality design, the rifle became a popular weapon among bounty hunters and other professional killers. Its popularity allowed arms dealers to charge a premium for this weapon, with even used weapons going above their standard value.."
SWEP.IconOverride = "entities/sopsmisc/deathwatch_blaster.png"

-- Viewmodel & Entity Properties
SWEP.ViewModel = "models/arccw/masita/viewmodels/base_rifle_animations.mdl"
SWEP.WorldModel = "models/weapons/synbf3/w_t21.mdl"
SWEP.ViewModelFOV = 66
SWEP.UseHands = true
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 28
SWEP.RangeMin = 175
SWEP.DamageMin = 222
SWEP.Range = 398
SWEP.Penetration = 2
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_orange"
SWEP.TracerCol = Color(250, 140, 0)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 34

SWEP.Recoil = 0.54
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.78
SWEP.Delay = 60 / 506

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = -3
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.3
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 100

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/deathwatch.wav"
SWEP.ShootSound = "sops-v2/weapons/deathwatch.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_orange"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 140, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.35, 0, 0.7),
    Ang = Angle(1, -0.5, -3),
     Magnification = 2,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 2, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/deathwatch_blaster.mdl",
                Bone = "E11S_CONTR",
                ModelBodygroups = "00000",
                Scale = Vector(1.2, 1.2, 1.2),
                Offset = {
                    pos = Vector(0.5, -2, -6.5),
                    ang = Angle(0, 0, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-4, 14, -6),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/deathwatch_blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.2, 1.2, 1.2),
                ModelBodygroups = "00000",
                Offset = {
                    pos = Vector(80, 20, 20),
                    ang = Angle(-15, -90, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(250, 15, -90),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/deathwatch_blaster.mdl"


SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.1, -3, 2.5),
            vang = Angle(0, -90, 0),
            wpos = Vector(45, 13, -73),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0)
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(8, 8, 8),
        Bone = "E11S_CONTR", 
        Offset = {
            vpos = Vector(0.5, 12, 0.5),
            vang = Angle(0, -90, 90),
            wpos = Vector(220, 22, -95),
            wang = Angle(-15, 0, -90)
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = "foregrip",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.1, 6, -0.5),
            vang = Angle(0, -90, 0),
            wpos = Vector(140, 14, -68),
            wang = Angle(-15, 0, 180)
        },          
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        WMScale = Vector(11, 11, 11),
        VMScale = Vector(1.5, 1.5, 1.5),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.1, 15, 0.5),
            vang = Angle(0, -90, 0),
            wpos = Vector(245, 14, -104),
            wang = Angle(-15, 0, 180)
        },     
    },    
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(9, 9, 9),
        Offset = {
            vpos = Vector(0.2, -0.7, -1.7),
            vang = Angle(0, -90, 0),
            wpos = Vector(80, 17.5, -35),
            wang = Angle(-15, 0, 180)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(11, 11, 11),
        VMScale = Vector(1, 1, 1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.9, -2, 0.5),
            vang = Angle(0, -90, 0),
            wpos = Vector(100, 23, -65),
            wang = Angle(-15, 0, 180)
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 120 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_ee4.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = "Kraken"
SWEP.PrintName = "[SMG] EE-4"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "The EE-4 carbine, also known as the EE-4 blaster rifle, was a powerful medium-ranged blaster carbine model that was manufactured by BlasTech Industries during the reign of the Galactic Empire. Successor to the EE-3 carbine rifle, the EE-4's shorter and stubbier barrel allowed the blaster rifle to fire more effectively at close range with spread shots but at the cost of a reduced accuracy at range compared to its predecessor."
SWEP.IconOverride = "entities/sopsmisc/ee4.png"

SWEP.UseHands = true
SWEP.DefaultBodygroups  = "00111"
SWEP.ViewModel = "models/arccw/kraken/sops-v2/c_ee4.mdl"
SWEP.WorldModel = "models/arccw/kraken/sops-v2/c_ee4.mdl"
SWEP.ViewModelFOV = 60
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-12, 6, -4),
    ang = Angle(-10, 0, 180),
    scale = 1.2,
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.3,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 24
SWEP.RangeMin = 202
SWEP.DamageMin = 26
SWEP.Range = 401
SWEP.Penetration = 2
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30

SWEP.Recoil = 0.78
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.56
SWEP.Delay = 60 / 375

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = -3
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.2
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 100

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/ee4.wav"
SWEP.ShootSound = "sops-v2/weapons/ee4.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight Struct
SWEP.IronSightStruct = {
    Pos = Vector(-5.090, -8.242, 2.068),
    Ang = Angle(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "smg"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 5, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)


-- Attachments
SWEP.Attachments = {
    {
        PrintName = "Opctic",
        DefaultAttName = "None", 
        Slot = "optic", 
        Bone = "ee4",
        VMScale = Vector(0.8, 0.8, 0.8),
        Offset = {
            vpos = Vector(-0.050, -2, -0.5),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },   
    {
        PrintName = "Muzzle", 
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "ee4",
        Offset = {
            vpos = Vector(0, -0.650, 12.4),
            vang = Angle(90, 0, -90),
        },
    },   
    {
        PrintName = "Tactical", 
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.5, 0.5, 0.5),
        Bone = "ee4",
        Offset = {
            vpos = Vector(1.2, -0.8, 9),
            vang = Angle(90, 0, 0),
        },
    },        
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "ee4",
        Offset = {
            vpos = Vector(0.8, -0.350, -0.425),
            vang = Angle(90, 0, -90),
        },
    },       
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "ee4",
        Offset = {
            vpos = Vector(0.650, -1.4, 0.750),
            vang = Angle(90, 0, -70),
        },
    },        
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "shoot",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = false,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 105 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_mw20.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "MW-20"
SWEP.Trivia_Class = "Blaster Revolver"
SWEP.Trivia_Desc = "Heavy-Powered blaster revolver produced by BlastTech Industries for the galactic citizens."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/sopsmisc/mw20.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/masita/viewmodels/blasterpistol_template.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 66
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 48
SWEP.RangeMin = 202
SWEP.DamageMin = 31
SWEP.Range = 404
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_orange"
SWEP.TracerCol = Color(250, 133, 0)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 17

SWEP.Recoil = 1.32
SWEP.RecoilSide = 0.12
SWEP.RecoilRise = 0.98
SWEP.Delay = 60 / 154

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.1
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 100

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/mw20.wav"
SWEP.ShootSound = "sops-v2/weapons/mw20.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_orange"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 133, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-5.1, -10, 1),
    Ang = Angle(0, 0.4, 0),
     Magnification = 1.3,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(-4, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, -20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(10, -13, 0)
SWEP.CustomizeAng = Angle(12, 50.5, 45)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/mw20.mdl",
                Bone = "DC-15SA",
                Scale = Vector(1.2, 1.2, 1.2),
                Offset = {
                    pos = Vector(0, 4.5, -3.5),
                    ang = Angle(0, 0, -90)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "DC-15SA",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2, 5, 12),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/mw20.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.2, 1.2, 1.2),
                Offset = {
                    pos = Vector(70, 20, 20),
                    ang = Angle(-15, -90, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(125, 20, -30),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/mw20.mdl"

SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(-0.16, -2.4, -2),
            vang = Angle(90, 0, -90),
            wpos = Vector(85, 17.5, -64),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 0, 0)
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9),
        Bone = "DC-15SA", 
        Offset = {
            vpos = Vector(-0.1, 1.2, 2.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(130, 17.5, -33),
            wang = Angle(-15, 0, 180)
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(-0.1, -1.4, 5.3),
            vang = Angle(90, 0, -90),
            wpos = Vector(150, 17.5, -70),
            wang = Angle(-15, 0, 180)

        },
    },    
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(9, 9, 9),
        Offset = {
            vpos = Vector(0.5, -0.5, -2),
            vang = Angle(90, 0, -90),
            wpos = Vector(65, 25, -37),
            wang = Angle(-15, 0, 180)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.4, -0.75, 2.3),
            vang = Angle(90, 0, -90),
            wpos = Vector(120, 26, -60),
            wang = Angle(-15, 0, 180)
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false
    },
    ["fire"] = {
        Source = {"Fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 105 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_quadblaster_empire.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "Quad-Blaster (Empire)"
SWEP.Trivia_Class = "Blaster Heavy Repeater"
SWEP.Trivia_Desc = "The reciprocating quad blaster, often shortened to 'Cip-Quad' was an experimental weapon developed during the Clone Wars by Merr-Sonn Munitions."
SWEP.IconOverride = "entities/sopsmisc/quadblaster_i.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/masita/v_quadblaster_i.mdl"
SWEP.WorldModel = "models/arccw/masita/w_quadblaster_i.mdl"
SWEP.ViewModelFOV = 55
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-7, 6, -8),
    ang = Angle(0, 5, 180)
}

-- Special Properties
SWEP.InfiniteAmmo = true

-- Damage & Tracer
SWEP.Damage = 29
SWEP.RangeMin = 127
SWEP.DamageMin = 24
SWEP.Range = 328
SWEP.Penetration = 7

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 150
SWEP.ExtendedClipSize = 250
SWEP.ReducedClipSize = 75

SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 0.5

SWEP.Recoil = 0.76
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.62

SWEP.Num = 1
SWEP.Delay = 60 / 420
SWEP.Firemode = 2
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 0
    }
}

SWEP.AccuracyMOA = 0.1
SWEP.HipDispersion = 100 
SWEP.MoveDispersion = 250

-- Speed Mult
SWEP.SpeedMult = 0.68
SWEP.SightedSpeedMult = 0.83
SWEP.SightTime = 0.23

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 110 
SWEP.ShootPitch = 87
SWEP.ShootPitchVariation = 0.1

SWEP.FirstShootSound = "sops-v2/weapons/quadblaster/quadblaster_republic.wav"
SWEP.ShootSound = "sops-v2/weapons/quadblaster/quadblaster_republic.wav"
SWEP.ShootSoundSilenced = "weapon/venator/dc17_badbatch.wav"

SWEP.NoFlash = true
SWEP.MuzzleEffectAttachment = "1"
SWEP.ProceduralViewBobAttachment = 1

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = false

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = "duel"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 14, -5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(0.2, -1, 2)
SWEP.HolsterAng = Angle(-15, 30, -15)

SWEP.CustomizePos = Vector(20.9, -10, 3.9)
SWEP.CustomizeAng = Angle(12.1, 50.5, 45)

SWEP.Attachments = {     
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "ammo_masita", "ammo_stun"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = {"perk", "mw3_pro"},
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },
}


-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle_deployed"
    },
    ["fire"] = {
        Source = "shooting"
    },
    ["draw"] = {
        Source = "deploy",
        SoundTable = {
            {
                s = "sops-v2/weapons/quadblaster/draw.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "retract",
        SoundTable = {
            {
                s = "sops-v2/weapons/quadblaster/out.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}

if CLIENT then
    function SWEP:PlaceHandsOnGun()
        local leftElbow = self:GetOwner():LookupBone("ValveBiped.Bip01_L_Forearm")
        self:GetOwner():ManipulateBoneAngles(leftElbow, Angle(20, -20, 0))

        local rightShoulder = self:GetOwner():LookupBone("ValveBiped.Bip01_R_UpperArm")
        self:GetOwner():ManipulateBoneAngles(rightShoulder, Angle(0, 15, 0))

        local rightElbow = self:GetOwner():LookupBone("ValveBiped.Bip01_R_Forearm")
        self:GetOwner():ManipulateBoneAngles(rightElbow, Angle(-30, -40, 0))
    end

    function SWEP:ResetBoneAngles()
        local leftElbow = self:GetOwner():LookupBone("ValveBiped.Bip01_L_Forearm")
        self:GetOwner():ManipulateBoneAngles(leftElbow, Angle(0, 0, 0))

        local rightShoulder = self:GetOwner():LookupBone("ValveBiped.Bip01_R_UpperArm")
        self:GetOwner():ManipulateBoneAngles(rightShoulder, Angle(0, 0, 0))

        local rightElbow = self:GetOwner():LookupBone("ValveBiped.Bip01_R_Forearm")
        self:GetOwner():ManipulateBoneAngles(rightElbow, Angle(0, 0, 0))
    end
end

function SWEP:DrawWorldModel()
    if IsValid(self.Owner) then 
        self:SetPoseParameter("head_pitch", self.Owner:EyeAngles()[1])
        self:InvalidateBoneCache()
    end
    self:DrawModel()
end

function SWEP:Deploy()
    if SERVER then
        self:SetSequence(2)
        self:GetOwner():GetViewModel():SendViewModelMatchingSequence(2)
    end
end

function SWEP:Holster()
    if SERVER then
        self:SetSequence(4)
    end
    if CLIENT then
        self:ResetBoneAngles()
    end

    return true
end

function SWEP:ReloadTicker()end

function SWEP:Anims() end

function SWEP:Reload()
    if self:GetCurrentFiremode().Mode == 2 then
        if CurTime() > (self.ReloadWaitTime or 0) then
            if self:Clip1() < self:GetMaxClip1() and self:GetOwner():GetAmmoCount(self:GetPrimaryAmmoType()) > 0 then
                local ammo = math.Clamp(50, 0, self:GetOwner():GetAmmoCount(self:GetPrimaryAmmoType()))
                ammo = math.min(ammo, self:GetMaxClip1() - self:Clip1())
                self:SetClip1(math.Clamp(self:Clip1() + ammo, 0, self:GetMaxClip1()))
                self:GetOwner():RemoveAmmo(ammo, self:GetPrimaryAmmoType())

                if self:Clip1() == self:GetMaxClip1() then
                    self.ReloadWaitTime = 0
                else
                    self.ReloadWaitTime = CurTime() + 0.5
                end
            end
        end
    end
end

function SWEP:ShouldReload()
    return self:GetCurrentFiremode().Mode == 2 and CurTime() > (self.ReloadWaitTime or 0) and self:Clip1() < self:GetMaxClip1() and self:GetOwner():GetAmmoCount(self:GetPrimaryAmmoType()) > 0
end

function SWEP:Think()

    self.Anims()
    self.ReloadTicker()
    
    if SERVER then
        if self:GetCurrentFiremode().Mode == 2 then
            self:GetOwner():GetViewModel():SendViewModelMatchingSequence(3)
            self:SetHoldType("normal")
            self:SetSequence(1)
            self.ReloadTicker = function()
                if self:GetCurrentFiremode().Mode == 0 then
                    if CurTime() then
                        if self:Clip1() < self:GetMaxClip1() and self:GetOwner():GetAmmoCount(self:GetPrimaryAmmoType()) > 0 then
                            local ammo = math.Clamp(50, 0, self:GetOwner():GetAmmoCount(self:GetPrimaryAmmoType()))
                            ammo = math.min(ammo, self:GetMaxClip1()-self:Clip1())
                            self:SetClip1(math.Clamp(self:Clip1() + ammo, 0, self:GetMaxClip1()))
                            self:GetOwner():RemoveAmmo( ammo, self:GetPrimaryAmmoType() )
                            if self:Clip1() == self:GetMaxClip1() then
                                self.ReloadTicker = function()end
                            else
                                self.ReloadWaitTime = CurTime() + 0.5
                            end
                        end
                    end
                else
                    self.ReloadTicker = function()end
                end
            end
        end
        if self:GetCurrentFiremode().Mode == 0 then
            self:SetSequence(3)
        end
        if self:GetOwner():KeyDown(IN_ATTACK) then
            self:SetSequence(5)
            self:GetOwner():GetViewModel():SendViewModelMatchingSequence(5)
            self:SetHoldType("duel")
        end
        if self:GetOwner():KeyReleased(IN_ATTACK) then
            self:SetSequence(1)
        end
        if self:GetSequence() == 5 then
            self:SetCycle( math.min(self:GetCycle() + 5*FrameTime(), 1))
        else
            self:SetCycle( math.min(self:GetCycle() + 0.5*FrameTime(), 1))
        end
        if self:GetCycle() >= 1 then
            if tonumber(self:GetSequence()) == 5 then
                self:SetCycle( 0 )
            end
        end
    end
    self:NextThink(CurTime())
    return true
end
--addons/arccw_weapons/lua/weapons/arccw_x8.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "X-8"
SWEP.Trivia_Class = "Galactic Heavy Blaster Pistol"
SWEP.Trivia_Desc = "A Blaster pistol for shooting enviroments"
SWEP.Trivia_Manufacturer = "Forged Armory"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_x8.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 55
SWEP.RangeMin = 135
SWEP.DamageMin = 22
SWEP.Range = 325
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1


SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(255, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 12

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 90
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(250, 0, 0)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/x8.wav"
SWEP.IronSightStruct = {
    Pos = Vector(-3.63, -8, 2.7),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterpistol_04.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(2, -4, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -10,-20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(20.824, -16, 4.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"x8"}

SWEP.AttachmentElements = {
    ["x8"] = {
        VMElements = {
            {
                Model = "models/arccw/hauptmann/star wars/weapons/x8_sniper.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-0.3, -03.5, -4.5),
                    ang = Angle(0, 90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/hauptmann/star wars/weapons/x8_sniper.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(80, 10, 15.3),
                    ang = Angle(-15, 0, 180)
                }
            }
        },
    },
}
WMOverride = "models/arccw/hauptmann/star wars/weapons/x8_sniper.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "swoptic_module",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.3, -2.9, 1.9),
            vang = Angle(0, 180, 0),
            wpos = Vector(70, 10, -50),
            wang = Angle(-15, 90, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment",
        VMScale = Vector(0.8, 0.8, 0.8), -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(9, 9, 9),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.5, -8, 1.2),
            vang = Angle(0, 90, 0),
            wpos = Vector(100, 10, -56),
            wang = Angle(-15, 0, 180)
        },
    },    
    [3] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 0.3, 8.6),
            vang = Angle(90, 0, -90),
        },
    },        
    [4] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [5] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [6] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(8, 8, 8),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.8, 1.5, 5),
            vang = Angle(90, 0, -90),
            wpos = Vector(60, 14, -35),
            wang = Angle(-10, 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
 --       Time = 3.35,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_z6_pak.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Z-6 (V2)"
SWEP.Trivia_Class = "Rotary Blaster Cannon"
SWEP.Trivia_Desc = "A powerful chain gun."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Heavy Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/viewmodels/z6-rotatory-blaster.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_z6_me.mdl"
SWEP.ViewModelFOV = 60
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(9.5, 0, 0),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

SWEP.IconOverride = "materials/entities/z6_pub.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.NoHideLeftHandInCustomization = true

SWEP.Damage = 25
SWEP.RangeMin = 120
SWEP.DamageMin = 11
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 150

SWEP.Recoil = 0.28
SWEP.RecoilSide = 0.25
SWEP.RecoilPunch = 2
SWEP.VisualRecoilMult = 0
SWEP.RecoilRise = 0.34

SWEP.Hook_ModifyRPM = function(wep, delay)
    return delay / Lerp(wep:GetBurstCount() / 15, 1, 3)
end

SWEP.Delay = 60 / 330
SWEP.Num = 1

SWEP.BobMult = 1

SWEP.TriggerDelay = true

SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 2,
        Mult_RPM = 2800 / 2400,
        PrintName = "2800RPM"
    },
    {
        Mode = 0
    }
}

SWEP.AccuracyMOA = 0.55 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 330 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.Bipod_Integral = true -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 0.8 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 0.5 -- Bipod recoil for Integral bipods

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17" 
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(0, 0, 255)

SWEP.SpeedMult = 0.5
SWEP.SightedSpeedMult = 0.8
SWEP.SightTime = 1

------- Melee Stuff ---
SWEP.MeleeDamage = 25
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.02

SWEP.ShootSound = "firing/SW02_Blasters_Z6RotaryBlaster_Laser_Close_VAR_01.wav"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.IronSightStruct = {
    Pos = Vector(0, -6, 0),
    Ang = Angle(0, 2, 0),
    Magnification = 1,
    SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_05.mp3",
    CrosshairInSights = true
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "crossbow"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(-2, 0, -3)
SWEP.ActiveAng = Angle(0, 2, 0)

SWEP.SprintPos = Vector(0, -15, -20)
SWEP.SprintAng = Angle(40, 0, -10)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(-2.824, -8, -14.897)
SWEP.CustomizeAng = Angle(30.149, 0.547, 0)


SWEP.DefaultElements = {""}
-- SWEP.AttachmentElements = {
--     ["nil"] = {
--          VMElements = {},
--         WMElements = {
--             {
--                 Model = "models/starwars/grady/props/weapons/z6-rotatory-blaster.mdl",
--                 Bone = "ValveBiped.Bip01_R_Hand",
--                 Scale = Vector(1, 1, 1),
--                 Offset = {
--                     pos = Vector(-140, 100, -170),
--                     ang = Angle(0, 0, 180)
--                 }
--             },
--             {
--                 Model = "models/hunter/plates/plate.mdl",
--                 Bone = "ValveBiped.Bip01_R_Hand",
--                 Scale = Vector(0, 0, 0),
--                 Offset = {
--                     pos = Vector(500, 0, -80),
--                     ang = Angle(-0, 0, 180)
--                 },
--                 IsMuzzleDevice = true
--             },            
--         }, -- change the world model to something else. Please make sure it's compatible with the last one.
--     }
-- }

SWEP.Jamming = true
SWEP.HeatGain = 0.65 -- heat gained per shot
SWEP.HeatCapacity = 75 -- rounds that can be fired non-stop before the gun jams, playing the "fix" animation
SWEP.HeatDissipation = 10 -- rounds' worth of heat lost per second
SWEP.HeatLockout = true -- overheating means you cannot fire until heat has been fully depleted
SWEP.HeatDelayTime = 0.5

--SWEP.Attachments 
SWEP.Attachments = {                 
    [1] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [2] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },          
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"fire_1","fire_2", "fire_3"},
    },
    ["draw"] = {
        Source = "draw",
        Time = 2.1,
        SoundTable = {
            {
                s = "draw/blasters_deathray_foley_undeploy_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 200, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/blasters_deathray_foley_undeploy_var_02.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["trigger"] = {
        Source = {"fire_2"},
        SoundTable = {
        {s = "firing/SW02_Blasters_Z6RotaryBlaster_Start_Short_VAR_01.ogg", v = 75,t = 0 / 30, c = CHAN_ITEM},
        },
        Time = 0.9,
    },
    ["bash"] = {
        Source = {"melee_hit_01"},
        SoundTable = {
        {s = "weapons/arccw/melee_hitworld.wav", v = 75,t = 0 / 30, c = CHAN_ITEM},
        },
    },
    ["exit_inspect"] = {
        Source = {"idle"},
    },
    ["reload"] = {
        Source = "reload",
        Time = 4, 
        SoundTable = {
            {s = "reload/in/overheat_overheated_var_01.mp3", t = 0 / 30},
            {s = "reload/out/gunfoley_blaster_draw_var_01.mp3", t = 44 / 30},
            {s = "reload/misc/blasters_deathray_foley_undeploy_var_03.mp3", t = 2.6}, --s sound file
        },
    },
}
--lua/weapons/demonic_katana/shared.lua:
SWEP.Author       = "Killua"
SWEP.PrintName    = "Demonic katana"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Demonic"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack, Special +damage"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee2"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 50
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-47.778, 0, 0) }
}
SWEP.VElements = {
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 45, 0), size = Vector(0.05, 0.039, 0.109), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/car_tire", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/combine_helicopter/helicopter_bomb01.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.8), angle = Angle(180, 90, 0), size = Vector(0.059, 0.059, 0.059), color = Color(40, 40, 40, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/triangles/1x1x1carved025.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 15), angle = Angle(180, 45, 0), size = Vector(0.014, 0.014, 0.5), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/smallwheel_side", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(40, 40, 40, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["blade"] = { type = "Model", model = "models/hunter/triangles/1x1x1carved025.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 15), angle = Angle(180, 45, 0), size = Vector(0.014, 0.014, 0.5), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/smallwheel_side", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/combine_helicopter/helicopter_bomb01.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.8), angle = Angle(180, 90, 0), size = Vector(0.059, 0.059, 0.059), color = Color(40, 40, 40, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 50, 8), size = Vector(0.05, 0.039, 0.109), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/car_tire", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(40, 40, 40, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} }
}


SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 32
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.26
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 16

SWEP.Secondary.Life        = true
SWEP.Secondary.Damage 	   = 64
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Primary.Damage = self.Primary.Damage + 5
		self.Secondary.Damage = self.Secondary.Damage + 5
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Primary.Damage = self.Primary.Damage + 5
		self.Secondary.Damage = self.Secondary.Damage + 5
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/tools/lua/weapons/gmod_tool/stools/stacker_improved.lua:
--[[--------------------------------------------------------------------------
	Improved Stacker Tool

	Note:
		Please DO NOT reupload this tool (verbatim or small tweaks) to the workshop or other public file-sharing websites.
		I actively maintain this tool, so reuploading it may lead to people using outdated, buggy, or malicious copies.
		If there is an issue with the tool, LET ME KNOW via one of the following pages:
		
		- GitHub:    https://github.com/Mista-Tea/improved-stacker
		- Workshop:  http://steamcommunity.com/sharedfiles/filedetails/?id=264467687
		- Facepunch: https://facepunch.com/showthread.php?t=1399120
	
	Author:
		- Original            :: OverloadUT (STEAM_0:1:5250809)
		- Updated for GMod 13 :: Marii      (STEAM_0:1:16015332)
		- Rewritten           :: Mista Tea  (STEAM_0:0:27507323)
	
	Changelog:
		- May 27th, 2014 :: Added to GitHub 
		- May 28th, 2014 :: Added to Workshop 
		- Jun 5th,  2014 :: Massive overhaul 
		- Jul 24th, 2014 :: Large update 
		- Aug 12th, 2014 :: Optimizations 
		- Jun 30th, 2015 :: Bug fixes/features 
		- Jul 11th, 2015 :: Bug fixes 
		- Oct 26th, 2015 :: Bug fixes
		- Aug 3rd,  2016 :: Bug fixes
		- Aug 31st, 2016 :: Bug fixes
		- Sep 2nd,  2016 :: Added Bulgarian language support
		- Sep 26th, 2017 :: Added ability to toggle use of SHIFT key with LMB/RMB
		- Oct 27th, 2017 :: Small client optimization, reverted nocollide implementation back to original
		- Apr 14th, 2018 :: Added French language support
		- Oct 12th, 2018 :: Added Polish language support
		- Jul 21st, 2019 :: Added Russian language support
		- Jul 23rd, 2019 :: Added Simplified Chinese language support
		- May 10th, 2020 :: Fixed unstable clientside ghosts caused by ents.CreateClientProp changes
		- Jun 18th, 2020 :: Clientside performance improvement when tool is not selected
		- Apr 30th, 2021 :: Added German language support
		
		Fixes:
			- Prevented crash from players using very high X/Y/Z offset values.
			- Prevented crash from players using very high P/Y/R rotate values.
			- Prevented crash from very specific constraint settings.
			- Fixed the halo option for ghosted props not working.
			- Fixed massive FPS drop from halos being rendered in a Think hook instead of a PreDrawHalos hook.
			- Fixed materials and color saving when duping stacked props.
			- Fixed incorrect stack angles when trying to create a stack on an existing stack.
			
		Tweaks:
			- Added convenience functions to retrieve the client convars.
			- Added option to enable/disable automatically applying materials to the stacked props.
			- Added option to enable/disable automatically applying colors to the stacked props.
			- Added option to enable/disable automatically applying physical properties (gravity, physics material, weight) to the stacked props.
			- Added support for props with multiple skins.
			- Added support for external prop protections/anti-spam addons with the StackerEntity hook.
			- Modified NoCollide to actually no-collide each stacker prop with every other prop in the stack.
			
			- Added console variables for server operators to limit various parts of stacker.
				> stacker_improved_max_per_player         <-inf/inf> (less than 0 == no limit)
				> stacker_improved_max_per_stack          <-inf/inf> (less than 0 == no limit)
				> stacker_improved_max_offsetx            <-inf/inf>
				> stacker_improved_max_offsety            <-inf/inf>
				> stacker_improved_max_offsetz            <-inf/inf>
				> stacker_improved_force_stayinworld         <0/1>
				> stacker_improved_force_weld                <0/1>
				> stacker_improved_force_freeze              <0/1>
				> stacker_improved_force_nocollide           <0/1>
				> stacker_improved_force_nocollide_all       <0/1>
				> stacker_improved_delay                     <0/inf>

			- Added console commands for server admins to control the console variables that limit stacker.
				> stacker_improved_set_max_per_player     <-inf/inf> (less than 0 == no limit)
				> stacker_improved_set_max_per_stack      <-inf/inf> (less than 0 == no limit)
				> stacker_improved_set_maxoffset          <-inf/inf>
				> stacker_improved_set_maxoffsetx         <-inf/inf>
				> stacker_improved_set_maxoffsety         <-inf/inf>
				> stacker_improved_set_maxoffsetz         <-inf/inf>
				> stacker_improved_set_force_stayinworld     <0/1>
				> stacker_improved_set_weld                  <0/1>
				> stacker_improved_set_freeze                <0/1>
				> stacker_improved_set_nocollide             <0/1>
				> stacker_improved_set_nocollide_all         <0/1>
				> stacker_improved_set_delay                 <0/inf>

----------------------------------------------------------------------------]]

local mode = TOOL.Mode -- defined by the name of this file (default should be stacker_improved)

--[[--------------------------------------------------------------------------
-- Modules & Dependencies
--------------------------------------------------------------------------]]--

-- needed for localization support (depends on GMod locale: "gmod_language")
include( "improvedstacker/localify.lua" )
localify.LoadSharedFile( "improvedstacker/localization.lua" ) -- loads the file containing localized phrases
local L = localify.Localize                                   -- used for translating string tokens into localized phrases
local prefix = "#tool."..mode.."."                            -- prefix used for this tool's localization tokens

-- needed for various stacker functionality
include( "improvedstacker/improvedstacker.lua" )
improvedstacker.Initialize( mode )

--[[--------------------------------------------------------------------------
-- Localized Functions & Variables
--------------------------------------------------------------------------]]--

-- localizing global functions/tables is an encouraged practice that improves code efficiency,
-- since accessing a local value is considerably faster than a global value
local bit = bit
local cam = cam
local net = net
local util = util
local math = math
local undo = undo
local halo = halo
local game = game
local ents = ents
local draw = draw
local hook = hook
local list = list
local pairs = pairs
local table = table
local Angle = Angle
local Color = Color
local render = render
local Vector = Vector
local tobool = tobool
local CurTime = CurTime
local surface = surface
local IsValid = IsValid
local localify = localify
local language = language
local tonumber = tonumber
local GetConVar = GetConVar
local construct = construct
local duplicator = duplicator
local constraint = constraint
local concommand = concommand
local LocalPlayer = LocalPlayer
local CreateConVar = CreateConVar
local improvedstacker = improvedstacker
local GetConVarNumber = GetConVarNumber
local RunConsoleCommand = RunConsoleCommand

local IN_USE = IN_USE
local NOTIFY_ERROR = NOTIFY_ERROR or 1
local MOVETYPE_NONE = MOVETYPE_NONE
local SOLID_VPHYSICS = SOLID_VPHYSICS
local RENDERMODE_TRANSALPHA = RENDERMODE_TRANSALPHA

local TRANSPARENT = Color( 255, 255, 255, 150 )

local MIN_NOTIFY_BITS = 3 -- the minimum number of bits needed to send a NOTIFY enum
local NOTIFY_DURATION = 5 -- the number of seconds to display notifications

local MAX_ANGLE = 180

local showSettings = false

--[[--------------------------------------------------------------------------
-- Tool Settings
--------------------------------------------------------------------------]]--

TOOL.Category = "Construction"
TOOL.Name     = L(prefix.."name")

TOOL.Information = {
	"left",
	"right",
	{ 
		name  = "shift_left",
		icon2  = "gui/e.png",
		icon = "gui/lmb.png",
		
	},
	{
		name  = "shift_right",
		icon2  = "gui/e.png",
		icon = "gui/rmb.png",
	},
	"reload",
}

if ( CLIENT ) then

	TOOL.ClientConVar[ "mode" ]          = improvedstacker.MODE_PROP
	TOOL.ClientConVar[ "direction" ]     = improvedstacker.DIRECTION_UP
	TOOL.ClientConVar[ "count" ]         = "1"
	TOOL.ClientConVar[ "freeze" ]        = "1"
	TOOL.ClientConVar[ "weld" ]          = "1"
	TOOL.ClientConVar[ "nocollide" ]     = "1"
	TOOL.ClientConVar[ "ghostall" ]      = "1"
	TOOL.ClientConVar[ "material" ]      = "1"
	TOOL.ClientConVar[ "physprop" ]      = "1"
	TOOL.ClientConVar[ "color" ]         = "1"
	TOOL.ClientConVar[ "offsetx" ]       = "0"
	TOOL.ClientConVar[ "offsety" ]       = "0"
	TOOL.ClientConVar[ "offsetz" ]       = "0"
	TOOL.ClientConVar[ "pitch" ]         = "0"
	TOOL.ClientConVar[ "yaw" ]           = "0"
	TOOL.ClientConVar[ "roll" ]          = "0"
	TOOL.ClientConVar[ "relative" ]      = "1"
	TOOL.ClientConVar[ "draw_halos" ]    = "0"
	TOOL.ClientConVar[ "halo_r" ]        = "255"
	TOOL.ClientConVar[ "halo_g" ]        = "0"
	TOOL.ClientConVar[ "halo_b" ]        = "0"
	TOOL.ClientConVar[ "halo_a" ]        = "255"
	TOOL.ClientConVar[ "draw_axis" ]     = "1"
	TOOL.ClientConVar[ "axis_labels" ]   = "1"
	TOOL.ClientConVar[ "axis_angles" ]   = "0"
	TOOL.ClientConVar[ "opacity" ]       = "100"
	TOOL.ClientConVar[ "use_shift_key" ] = "0"

	--[[--------------------------------------------------------------------------
	-- Language Settings
	--------------------------------------------------------------------------]]--

--[[ 	language.Add( "tool."..mode..".name",         L(prefix.."name") )
	language.Add( "tool."..mode..".desc",         L(prefix.."desc") )
	language.Add( "tool."..mode..".0",            L(prefix.."0") )
	language.Add( "tool."..mode..".left",         L(prefix.."left") )
	language.Add( "tool."..mode..".shift_left",   L(prefix.."shift_left") )
	language.Add( "tool."..mode..".right",        L(prefix.."right") )
	language.Add( "tool."..mode..".shift_right",  L(prefix.."shift_right") )
	language.Add( "tool."..mode..".reload",       L(prefix.."reload") )
	language.Add( "Undone_"..mode,                L("Undone_"..mode) )
	 ]]
	--[[--------------------------------------------------------------------------
	-- Net Messages
	--------------------------------------------------------------------------]]--
	
	--[[--------------------------------------------------------------------------
	-- 	Net :: <toolmode>_error( string )
	--]]--
	net.Receive( mode.."_error", function( bytes )
		surface.PlaySound( "buttons/button10.wav" )
		notification.AddLegacy( net.ReadString(), net.ReadUInt(MIN_NOTIFY_BITS), NOTIFY_DURATION )
	end )
	
end

--[[--------------------------------------------------------------------------
-- Console Variables
--------------------------------------------------------------------------]]--

-- This is solely for backwards compatibility.
-- We're essentially copying everyone's old cvar values over since we're switching from 'stacker' to 'stacker_improved'.
-- If we didn't do this, we'd run the risk of ruining someone's custom setup
--[[local oldMaxTotal    = GetConVar( "stacker_max_total" )       and GetConVar( "stacker_max_total" ):GetInt()       or -1
local oldMaxCount    = GetConVar( "stacker_max_count" )       and GetConVar( "stacker_max_count" ):GetInt()       or 15
local oldMaxOffX     = GetConVar( "stacker_max_offsetx" )     and GetConVar( "stacker_max_offsetx" ):GetFloat()   or 200
local oldMaxOffY     = GetConVar( "stacker_max_offsety" )     and GetConVar( "stacker_max_offsety" ):GetFloat()   or 200
local oldMaxOffZ     = GetConVar( "stacker_max_offsetz" )     and GetConVar( "stacker_max_offsetz" ):GetFloat()   or 200
local oldStayInWorld = GetConVar( "stacker_stayinworld" )     and GetConVar( "stacker_stayinworld" ):GetInt()     or 1
local oldFreeze      = GetConVar( "stacker_force_freeze" )    and GetConVar( "stacker_force_freeze" ):GetInt()    or 0
local oldWeld        = GetConVar( "stacker_force_weld" )      and GetConVar( "stacker_force_weld" ):GetInt()      or 0
local oldNoCollide   = GetConVar( "stacker_force_nocollide" ) and GetConVar( "stacker_force_nocollide" ):GetInt() or 0
local oldDelay       = GetConVar( "stacker_delay" )           and GetConVar( "stacker_delay" ):GetFloat()         or 0.25
]]
local cvarFlags, cvarFlagsNotify

if ( SERVER ) then
	cvarFlags      = bit.bor( FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE )
	cvarFlagsNotif = bit.bor( cvarFlags, FCVAR_NOTIFY )
elseif ( CLIENT ) then
	cvarFlags      = bit.bor( FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE )
	cvarFlagsNotif = bit.bor( cvarFlags, FCVAR_NOTIFY )
end

local oldMaxTotal    = CreateConVar( "stacker_max_total",        -1, cvarFlagsNotif, "Defines the max amount of props that a player can have spawned from stacker" )
local oldMaxCount    = CreateConVar( "stacker_max_count",        15, cvarFlagsNotif, "Defines the max amount of props that can be stacked at a time" )
local oldDelay       = CreateConVar( "stacker_delay",           0.5, cvarFlagsNotif, "Determines the amount of time that must pass before a player can use stacker again" )
local oldMaxOffX     = CreateConVar( "stacker_max_offsetx",     200, cvarFlagsNotif, "Defines the max distance on the x plane that stacked props can be offset (for individual control)" )
local oldMaxOffY     = CreateConVar( "stacker_max_offsety",     200, cvarFlagsNotif, "Defines the max distance on the y plane that stacked props can be offset (for individual control)" )
local oldMaxOffZ     = CreateConVar( "stacker_max_offsetz",     200, cvarFlagsNotif, "Defines the max distance on the z plane that stacked props can be offset (for individual control)" )
local oldFreeze      = CreateConVar( "stacker_force_freeze",      0, cvarFlagsNotif, "Determines whether props should be forced to spawn frozen or not" )
local oldWeld        = CreateConVar( "stacker_force_weld",        0, cvarFlagsNotif, "Determines whether props should be forced to spawn welded or not" )
local oldNoCollide   = CreateConVar( "stacker_force_nocollide",   0, cvarFlagsNotif, "Determines whether props should be forced to spawn nocollided or not" )
local oldStayInWorld = CreateConVar( "stacker_stayinworld",       1, cvarFlagsNotif, "Determines whether props should be restricted to spawning inside the world or not (addresses possible crashes)" )

local cvarMaxPerPlayer = CreateConVar( mode.."_max_per_player",      oldMaxTotal:GetInt(),    cvarFlags,      "Defines the max amount of props that a player can have spawned from stacker" )
local cvarMaxPerStack  = CreateConVar( mode.."_max_per_stack",       oldMaxCount:GetInt(),    cvarFlags,      "Defines the max amount of props that can be stacked at a time" )
local cvarDelay        = CreateConVar( mode.."_delay",               oldDelay:GetFloat(),     cvarFlags,      "Determines the amount of time that must pass before a player can use stacker again" )
local cvarMaxOffX      = CreateConVar( mode.."_max_offsetx",         oldMaxOffX:GetFloat(),   cvarFlags,      "Defines the max distance on the x plane that stacked props can be offset (for individual control)" )
local cvarMaxOffY      = CreateConVar( mode.."_max_offsety",         oldMaxOffY:GetFloat(),   cvarFlags,      "Defines the max distance on the y plane that stacked props can be offset (for individual control)" )
local cvarMaxOffZ      = CreateConVar( mode.."_max_offsetz",         oldMaxOffZ:GetFloat(),   cvarFlags,      "Defines the max distance on the z plane that stacked props can be offset (for individual control)" )
local cvarFreeze       = CreateConVar( mode.."_force_freeze",        oldFreeze:GetInt(),      cvarFlagsNotif, "Determines whether props should be forced to spawn frozen or not" )
local cvarWeld         = CreateConVar( mode.."_force_weld",          oldWeld:GetInt(),        cvarFlagsNotif, "Determines whether props should be forced to spawn welded or not" )
local cvarNoCollide    = CreateConVar( mode.."_force_nocollide",     oldNoCollide:GetInt(),   cvarFlagsNotif, "Determines whether props should be forced to spawn nocollided or not" )
local cvarNoCollideAll = CreateConVar( mode.."_force_nocollide_all", 0,                       cvarFlags,      "(EXPERIMENTAL, DISABLED) Determines whether props should be nocollide with everything except players, vehicles, and npcs" )
local cvarStayInWorld  = CreateConVar( mode.."_force_stayinworld",   oldStayInWorld:GetInt(), cvarFlagsNotif, "Determines whether props should be restricted to spawning inside the world or not (addresses possible crashes)" )

--[[--------------------------------------------------------------------------
-- Console Commands
--------------------------------------------------------------------------]]--

if ( CLIENT ) then
	
	concommand.Add( mode.."_reset_offsets", function( ply, cmd, args )
		-- reset all of the offset values to 0
		RunConsoleCommand( mode.."_offsetx", "0.00" )
		RunConsoleCommand( mode.."_offsety", "0.00" )
		RunConsoleCommand( mode.."_offsetz", "0.00" )
	end	)
	
	concommand.Add( mode.."_reset_angles", function( ply, cmd, args )
		-- reset all of the angle values to 0
		RunConsoleCommand( mode.."_pitch",   "0.00" )
		RunConsoleCommand( mode.."_yaw",     "0.00" )
		RunConsoleCommand( mode.."_roll",    "0.00" )
	end )
	
	concommand.Add( mode.."_reset_admin", function( ply, cmd, args )
		for cmd, val in pairs( improvedstacker.SETTINGS_DEFAULT ) do
			RunConsoleCommand( cmd, val )
		end
	end )
	
elseif ( SERVER ) then

	local function validateCommand( ply, cmd, arg )
		-- run our hook to see if the server is manually allowing/blocking this player from changing the cvar
		-- true:          allow
		-- false:         block
		-- nil (default): fallback to a ply:IsAdmin() check
		local result, reason = hook.Run( "StackerConVar", ply, cmd, arg )

		-- if a player ran the command and the server didn't explicitly allow them to change the cvar
		if ( IsValid( ply ) and result ~= true ) then
			-- if the server blocked the change, send the player an error
			if ( result == false )                     then
				ply:PrintMessage( HUD_PRINTTALK, L(prefix.."error_blocked_by_server", localify.GetLocale( ply )) .. (isstring(reason) and ": " .. reason or "") )
				return false
			end
			-- if the server didn't give a response, fallback to a ply:IsAdmin() check
			if ( result == nil and not ply:IsAdmin() ) then
				ply:PrintMessage( HUD_PRINTTALK, L(prefix.."error_not_admin", localify.GetLocale( ply )) .. ": " .. cmd )
				return false
			end
		end
		
		-- lastly, ensure the argument is a valid number before returning true
		if ( not tonumber( arg ) ) then
			ply:PrintMessage( HUD_PRINTTALK, L(prefix.."error_invalid_argument", localify.GetLocale( ply )) )
			return false
		end
		
		return true
	end
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_per_player", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_per_player", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_per_player", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_per_stack", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_per_stack", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_per_stack", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_offset", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_offset", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_offsetx", args[1] )
		RunConsoleCommand( mode.."_max_offsety", args[1] )
		RunConsoleCommand( mode.."_max_offsetz", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_offsetx", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_offsetx", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_offsetx", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_offsety", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_offsety", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_offsety", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_offsetz", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_offsetz", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_offsetz", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_force_stayinworld", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_force_stayinworld", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_force_stayinworld", tobool( args[1] ) and "1" or "0" )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_force_freeze", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_force_freeze", args[1] ) ) then return false end	
		RunConsoleCommand( mode.."_force_freeze", tobool( args[1] ) and "1" or "0" )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_force_weld", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_force_weld", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_force_weld", tobool( args[1] ) and "1" or "0" )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_force_nocollide", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_force_nocollide", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_force_nocollide", tobool( args[1] ) and "1" or "0" )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_force_nocollide_all", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_force_nocollide_all", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_force_nocollide_all", tobool( args[1] ) and "1" or "0" )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_delay", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_delay", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_delay", args[1] )
	end )

	
	util.AddNetworkString( mode.."_error" )

	--[[--------------------------------------------------------------------------
	--	TOOL:SendError( str )
	--	Convenience function for sending an error to the tool owner.
	--]]--
	function TOOL:SendError( str )		
		net.Start( mode.."_error" )
			net.WriteString( str )
			net.WriteUInt( NOTIFY_ERROR, MIN_NOTIFY_BITS )
		net.Send( self:GetOwner() )
	end

end

--[[--------------------------------------------------------------------------
-- Convenience Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
-- 	TOOL:GetMaxPerPlayer() and TOOL:GetNumberPlayerEnts()
--
--	The total number of props a player has spawned from the Stacker tool is recorded
--	on them via ply.TotalStackerEnts. When a player removes a prop that has been spawned
--	from Stacker, the total count is decreased by 1.
--
--	In combination with the stacker_max_per_player cvar, this function can prevent players
--	from crashing the server by stacking dozens of welded props and unfreezing them.
--
--	By default, the number of stacker props is -1 (infinite). This is done to not interfere
--	with servers that don't want to limit the number of Stacker props a player can spawn directly.
--	They may still hit cvars like sbox_maxprops before ever hitting stacker_max_per_player.
--
--	As an example case, if players are crashing your servers by spawning 50 welded chairs 
--	and unfreezing them all at once, you can set stacker_max_per_player to 30 so that at any
--	given time they can only have 30 props created by Stacker. Trying to stack any more props
--	would give the player an error message.
--]]--
function TOOL:GetMaxPerPlayer()     return cvarMaxPerPlayer:GetInt() end
function TOOL:GetNumberPlayerEnts() return improvedstacker.GetEntCount( self:GetOwner(), 0 ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetStackSize()
--	Gets the amount of props that the client wants to stack at once.
--]]--
function TOOL:GetStackSize() return self:GetClientNumber( "count" ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetMaxPerStack()
--	Gets the maximum amount of props that can be stacked at a time.
--]]--
function TOOL:GetMaxPerStack() return cvarMaxPerStack:GetInt() end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetDirection()
--	Gets the direction to stack the props.
--]]--
function TOOL:GetDirection()
	local direction = self:GetClientNumber( "direction" )
	return improvedstacker.Directions[ direction ] and direction or improvedstacker.DIRECTION_FRONT
end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetStackerMode()
--	Gets the stacker mode (1 = MODE_WORLD, 2 = MODE_PROP).
--]]--
function TOOL:GetStackerMode()
	local stackMode = self:GetClientNumber( "mode" )
	return improvedstacker.Modes[ stackMode ] and stackMode or improvedstacker.MODE_PROP
end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetOffsetX(), TOOL:GetOffsetY(), TOOL:GetOffsetZ(), TOOL:GetOffsetVector()
--	Gets the distance to offset the position of the stacked props.
--	These values are clamped to prevent server crashes from players
--	using very high offset values.
--]]--
function TOOL:GetOffsetX()      return math.Clamp( self:GetClientNumber( "offsetx" ), -cvarMaxOffX:GetFloat(), cvarMaxOffX:GetFloat() ) end
function TOOL:GetOffsetY()      return math.Clamp( self:GetClientNumber( "offsety" ), -cvarMaxOffY:GetFloat(), cvarMaxOffY:GetFloat() ) end
function TOOL:GetOffsetZ()      return math.Clamp( self:GetClientNumber( "offsetz" ), -cvarMaxOffZ:GetFloat(), cvarMaxOffZ:GetFloat() ) end
function TOOL:GetOffsetVector() return Vector( self:GetOffsetX(), self:GetOffsetY(), self:GetOffsetZ() ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetRotateP(), TOOL:GetRotateY(), TOOL:GetRotateR(), TOOL:GetRotationAngle()
--	Gets the value to rotate the angle of the stacked props.
--	These values are clamped to prevent server crashes from players
--	using very high rotation values.
--]]--
function TOOL:GetRotateP()     return math.Clamp( self:GetClientNumber( "pitch" ), -MAX_ANGLE, MAX_ANGLE ) end
function TOOL:GetRotateY()     return math.Clamp( self:GetClientNumber( "yaw" ),   -MAX_ANGLE, MAX_ANGLE ) end
function TOOL:GetRotateR()     return math.Clamp( self:GetClientNumber( "roll" ),  -MAX_ANGLE, MAX_ANGLE ) end
function TOOL:GetRotationAngle() return Angle( self:GetRotateP(), self:GetRotateY(), self:GetRotateR() ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldFreeze()
--	Returns true if the stacked props should be spawned frozen.
--]]--
function TOOL:ShouldApplyFreeze() return self:GetClientNumber( "freeze" ) == 1 end
function TOOL:ShouldForceFreeze() return cvarFreeze:GetBool() end
--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldWeld()
--	Returns true if the stacked props should be welded together.
--]]--
function TOOL:ShouldApplyWeld() return self:GetClientNumber( "weld" ) == 1 end
function TOOL:ShouldForceWeld() return cvarWeld:GetBool() end
--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldNoCollide()
--	Returns true if the stacked props should be nocollided with each other.
--]]--
function TOOL:ShouldApplyNoCollide() return self:GetClientNumber( "nocollide" ) == 1 end
function TOOL:ShouldForceNoCollide() return cvarNoCollide:GetBool() end
--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldStackRelative()
--	Returns true if the stacked props should be stacked relative to the new rotation.
--	Using this setting will allow you to create curved structures out of props.
--]]--
function TOOL:ShouldStackRelative() return self:GetClientNumber( "relative" ) == 1 end
--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldGhostAll()
--	Returns true if the stacked props should all be ghosted or if only the 
--	first stacked prop should be ghosted.
--]]--
function TOOL:ShouldGhostAll() return self:GetClientNumber( "ghostall" ) == 1 end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldAddHalos(), TOOL:GetHaloR(), TOOL:GetHaloG(), TOOL:GetHaloB() TOOL:GetHaloA() TOOL:GetHaloColor()
--	Returns true if the stacked props should have halos drawn on them for added visibility.
--	Gets the RGBA values of the halo color.
--]]--
function TOOL:ShouldAddHalos() return self:GetClientNumber( "draw_halos" ) == 1 end
function TOOL:GetHaloR()       return math.Clamp( self:GetClientNumber( "halo_r" ), 0, 255 ) end
function TOOL:GetHaloG()       return math.Clamp( self:GetClientNumber( "halo_g" ), 0, 255 ) end
function TOOL:GetHaloB()       return math.Clamp( self:GetClientNumber( "halo_b" ), 0, 255 ) end
function TOOL:GetHaloA()       return math.Clamp( self:GetClientNumber( "halo_a" ), 0, 255 ) end
function TOOL:GetHaloColor()   return Color( self:GetHaloR(), self:GetHaloG(), self:GetHaloB(), self:GetHaloA() ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldApplyMaterial()
--	Returns true if the stacked props should have the original prop's material applied.
--]]--
function TOOL:ShouldApplyMaterial() return self:GetClientNumber( "material" ) == 1 end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldApplyColor()
--	Returns true if the stacked props should have the original prop's color applied.
--]]--
function TOOL:ShouldApplyColor() return self:GetClientNumber( "color" ) == 1 end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldApplyPhysicalProperties()
--	Returns true if the stacked props should have the original prop's physicsl properties
--	applied, including gravity, physics material, and weight.
--]]--
function TOOL:ShouldApplyPhysicalProperties() return self:GetClientNumber( "physprop" ) == 1 end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetDelay()
--	Returns the time in seconds that must pass before a player can use stacker again.
--	For example, if stacker_delay is set to 3, a player must wait 3 seconds in between each
--	use of stacker's left click. A delay of <= 0 means stacks can be created instantly.
--]]--
function TOOL:GetDelay() return cvarDelay:GetFloat() end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetOpacity()
--	Returns the alpha value (opacity) of the ghosted props seen on the client.
--	Should be between 0 (invisible) and 255 (fully visible).
--]]--
function TOOL:GetOpacity() return self:GetClientNumber( "opacity" ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetUseShiftKey()
--	Returns true if the client has enabled the alternate use of SHIFT in combination
--	with left and right clicking. If enable, holding SHIFT and pressing LMB/RMB will
--	have the same effect as holding E and pressing LMB/RMB.
--]]--
function TOOL:GetUseShiftKey() return self:GetClientNumber( "use_shift_key" ) == 1 end
--[[--------------------------------------------------------------------------
-- Tool Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
-- 	TOOL:LeftClick( table, boolean = nil )
--
--	Attempts to create a stack of props relative to the entity being left clicked.
--]]--
function TOOL:LeftClick( tr, isRightClick )
	local ply = self:GetOwner()
	
	-- check if the player is holding E or SHIFT (as long as they've enabled it)
	if ( ply:KeyDown( IN_USE ) or (self:GetUseShiftKey() and ply:KeyDown( IN_SPEED )) ) then
		if ( CLIENT ) then return false end
		-- increase their stack count by 1 (until it hits the stack max)
		local newCount = self:GetStackSize() >= self:GetMaxPerStack() and self:GetMaxPerStack() or self:GetStackSize() + 1
		ply:ConCommand( mode.."_count "..newCount )
		return false
	end

	if ( not IsValid( tr.Entity ) or tr.Entity:GetClass() ~= "prop_physics" ) then return false end
	if ( CLIENT ) then return true end
	
	-- otherwise, stack 1 if right-clicking or get the client's stack size value
	local count = (isRightClick and 1) or self:GetStackSize()
	-- check if the server wants to control how many props the player can use in the stack
	local maxCount = hook.Run( "StackerMaxPerStack", ply, count, isRightClick ) or self:GetMaxPerStack()

	-- check if the player's stack size is higher than the server's max allowed size (but only if the server didn't explictly override it)
	if ( maxCount >= 0 ) then
		if ( count > maxCount ) then self:SendError( L(prefix.."error_max_per_stack", localify.GetLocale( self:GetOwner() )) .. maxCount ) end
		count = math.Clamp( count, 0, maxCount )
	end
	
	-- get the player's last stacker usage time, defaulting to 0 if it hasn't been set
	local lastStackTime = improvedstacker.GetLastStackTime( ply, 0 )
	
	-- retrieve the time delay between stacker usage
	-- we call StackerDelay to let external mods to set their own delays (less than or equal to 0 means no delay)
	-- delay time is in seconds (e.g. 0.1 is a tenth of a second)
	local delay = hook.Run( "StackerDelay", ply, lastStackTime ) or self:GetDelay()
	
	-- check if the player is trying to use stacker too quickly
	if ( lastStackTime + delay > CurTime() ) then self:SendError( L(prefix.."error_too_quick", localify.GetLocale( self:GetOwner() )) ) return false end
	improvedstacker.SetLastStackTime( ply, CurTime() )
	
	local stackDirection = self:GetDirection()
	local stackMode      = self:GetStackerMode()
	local stackOffset    = self:GetOffsetVector()
	local stackRotation  = self:GetRotationAngle()
	local stackRelative  = self:ShouldStackRelative()
	
	-- determines whether the stacked props are allowed to be positioned outside of the world or not
	local stayInWorld   = cvarStayInWorld:GetBool()

	-- store the properties of the original prop so we can apply them to the stacked props
	local ent = tr.Entity
	local entPos   = ent:GetPos()
	local entAng   = ent:GetAngles()
	local entMod   = ent:GetModel()
	local entSkin  = ent:GetSkin()
	local entMat   = ent:GetMaterial()
	local physMat  = ent:GetPhysicsObject():GetMaterial()
	local physGrav = ent:GetPhysicsObject():IsGravityEnabled()
	
	-- setup a table to hold the original prop's color data so that we can apply it to the stacked props
	local colorData = {
		Color      = ent:GetColor(), 
		RenderMode = ent:GetRenderMode(), 
		RenderFX   = ent:GetRenderFX()
	}	
		
	local newEnt
	local newEnts = { ent }
	local lastEnt = ent
	
	local direction, offset
	-- we only need to calculate the distance once based on the direction the user selected
	local distance = improvedstacker.GetDistance( stackMode, stackDirection, ent )
	
	-- setup a new undo block so the player can undo the whole stack at once
	undo.Create( mode )
	
	-- check if the server wants to control how many stacker entities this player can create
	local maxPerPlayer = hook.Run( "StackerMaxPerPlayer", ply, self:GetNumberPlayerEnts() ) or self:GetMaxPerPlayer()
	
	-- loop for every prop to create in the stack and allow external addons to dictate control over the new stacked entities
	for i = 1, count do
		
		-- check if the player has too many active stacker props spawned out already
		local stackerEntsSpawned = self:GetNumberPlayerEnts()
		if ( maxPerPlayer >= 0 and stackerEntsSpawned >= maxPerPlayer ) then self:SendError( ("%s (%s)"):format(L(prefix.."error_max_per_player", localify.GetLocale( self:GetOwner() )), maxPerPlayer) ) break end
		-- check if the player has exceeded the sbox_maxprops cvar
		if ( not self:GetSWEP():CheckLimit( "props" ) )            then break end
		-- check if external admin mods are blocking this entity
		if ( hook.Run( "PlayerSpawnProp", ply, entMod ) == false ) then break end
		
		-- if we're positioning the first entity in the stack (regardless of relative to PROP or WORLD), or
		-- if we're stacking relative to PROP and on the previous rotation, update the new direction and offset
		if ( i == 1 or ( stackMode == improvedstacker.MODE_PROP and stackRelative ) ) then
			direction = improvedstacker.GetDirection( stackMode, stackDirection, entAng )
			offset    = improvedstacker.GetOffset( stackMode, stackDirection, entAng, stackOffset )
		end

		-- calculate the next stacked entity's position
		entPos = entPos + (direction * distance) + offset
		-- rotate the next stacked entity's angle by the client's rotation values
		improvedstacker.RotateAngle( stackMode, stackDirection, entAng, stackRotation )
		
		
		-- check if the stacked props would be spawned outside of the world
		if ( stayInWorld and not util.IsInWorld( entPos ) ) then self:SendError( L(prefix.."error_not_in_world", localify.GetLocale( self:GetOwner() )) ) break end
		
		-- create the new stacked entity
		newEnt = ents.Create( "prop_physics" )
		newEnt:SetModel( entMod )
		newEnt:SetPos( entPos )
		newEnt:SetAngles( entAng )
		newEnt:SetSkin( entSkin )
		newEnt:Spawn()

		-- this hook is for external prop protections and anti-spam addons.
		-- it is called before undo, ply:AddCount, and ply:AddCleanup to allow developers to
		-- remove or mark this entity so that those same functions (if overridden) can
		-- detect that the entity came from Stacker
		if ( not IsValid( newEnt ) or hook.Run( "StackerEntity", newEnt, ply ) ~= nil )             then break end
		if ( not IsValid( newEnt ) or hook.Run( "PlayerSpawnedProp", ply, entMod, newEnt ) ~= nil ) then break end

		-- disabling this for now due to problems with ShouldCollide
		--improvedstacker.MarkEntity( self:GetOwner(), newEnt )
		
		-- increase the total number of active stacker props spawned by the player by 1
		improvedstacker.IncrementEntCount( ply )
		
		-- decrement the total number of active stacker props spawned by the player by 1
		-- when the prop gets removed in any way
		newEnt:CallOnRemove( "UpdateStackerTotal", function( ent, ply )
			-- if the player is no longer connected, there is nothing to do
			if ( not IsValid( ply ) ) then return end
			improvedstacker.DecrementEntCount( ply )
		end, ply )
		
		self:ApplyMaterial( newEnt, entMat )
		self:ApplyColor( newEnt, colorData )
		self:ApplyFreeze( ply, newEnt )
		
		-- attempt to nocollide the new entity with the last, or break out of the loop if CBaseEntityList::AddNonNetworkableEntity fails
		if ( not self:ApplyNoCollide( lastEnt, newEnt ) ) then
			newEnt:Remove()
			break
		end
		
		-- attempt to weld the new entity with the last, or break out of the loop if CBaseEntityList::AddNonNetworkableEntity fails
		if ( not self:ApplyWeld( lastEnt, newEnt ) ) then
			newEnt:Remove()
			break
		end
		
		self:ApplyPhysicalProperties( ent, newEnt, tr.PhysicsBone, { GravityToggle = physGrav, Material = physMat } )
		
		lastEnt = newEnt
		table.insert( newEnts, newEnt )
		
		undo.AddEntity( newEnt )
		ply:AddCleanup( "props", newEnt )
	end
	
	newEnts = nil
	
	undo.SetPlayer( ply )
	undo.Finish()

	-- disabling this for now due to problems with ShouldCollide
	--improvedstacker.MarkEntity( self:GetOwner(), ent )
	
	return true
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:RightClick( trace )
--
--	Performs a LeftClick operation but only creates a single stacked entity.
--	Alternatively, if the player is holding down their USE key, this will
--	decrease their stack count by 1.
--]]--
function TOOL:RightClick( tr )
	local ply = self:GetOwner()

	-- check if the player is holding E or SHIFT (as long as they've enabled it)
	if ( ply:KeyDown( IN_USE ) or (self:GetUseShiftKey() and ply:KeyDown( IN_SPEED )) ) then
		if ( CLIENT ) then return false end
		-- decrease the player's stack count by 1 (until a minimum of 1)
		local count = self:GetStackSize()
		local newCount = (count <= 1 and 1) or count - 1
		ply:ConCommand( mode.."_count " .. newCount )
		return false
	else
		-- create a single entity in the stack
		return self:LeftClick( tr, true )
	end
	
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:Reload()
--
--	Switches the client's stack direction.
--]]--
function TOOL:Reload()
	if ( CLIENT ) then return false end

	local ply = self:GetOwner()
	local direction = self:GetDirection()
	
	-- if they were at the last numerical direction (6), wrap around to the first (1)
	if ( direction == improvedstacker.DIRECTION_DOWN ) then
		direction = improvedstacker.DIRECTION_FRONT
	-- otherwise just increment to the next direction
	else
		direction = direction + 1
	end
	
	-- make the player update their client direction setting
	ply:ConCommand( mode.."_direction " .. direction )
	
	return false
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyMaterial( entity, string )
--
--	Applies the original entity's material onto the stacked props.
--]]--
function TOOL:ApplyMaterial( ent, material )
	if ( not self:ShouldApplyMaterial() ) then ent:SetMaterial( "" ) return end
	
	-- From: gamemodes/sandbox/entities/weapons/gmod_tool/stools/material.lua
	-- "Make sure this is in the 'allowed' list in multiplayer - to stop people using exploits"
	if ( not game.SinglePlayer() and not list.Contains( "OverrideMaterials", material ) and material ~= "" ) then return end

	ent:SetMaterial( material )
	duplicator.StoreEntityModifier( ent, "material", { MaterialOverride = material } )
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyColor( entity, color )
--
--	Applies the original entity's color onto the stacked props.
--]]--
function TOOL:ApplyColor( ent, data )
	if ( not self:ShouldApplyColor() ) then return end

	ent:SetColor( data.Color )
	ent:SetRenderMode( data.RenderMode )
	ent:SetRenderFX( data.RenderFX )
	
	duplicator.StoreEntityModifier( ent, "colour", table.Copy( data ) )
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyFreeze( player, entity )
--
--	Attempts to freeze the stacked props in place.
--]]--
function TOOL:ApplyFreeze( ply, ent )
	if ( self:ShouldForceFreeze() or self:ShouldApplyFreeze() ) then
		ent:GetPhysicsObject():EnableMotion( false )
	else
		ent:GetPhysicsObject():Wake()
	end
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyWeld( entity, entity )
--
--	Attempts to weld the new entity to the last entity.
--]]--
function TOOL:ApplyWeld( lastEnt, newEnt )
	if ( not self:ShouldForceWeld() and not self:ShouldApplyWeld() ) then return true end
	
	local forceLimit    = 0
	local isNocollided  = self:ShouldForceNoCollide() or self:ShouldApplyNoCollide()
	local deleteOnBreak = false
	
	local ok, err = pcall( constraint.Weld, lastEnt, newEnt, 0, 0, forceLimit, isNocollided, deleteOnBreak )
	
	if ( not ok ) then
		print( mode .. ": " .. L(prefix.."error_max_constraints") .." (error: " .. err .. ")" )
		self:SendError( mode .. ": " .. L(prefix.."error_max_constraints", localify.GetLocale( self:GetOwner() )) )
	end
	
	return ok
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyNoCollide( entity, entity )
--
--	Attempts to nocollide the new entity to the last entity.
--]]--
function TOOL:ApplyNoCollide( lastEnt, newEnt )
	if ( not self:ShouldForceNoCollide() and not self:ShouldApplyNoCollide() ) then return true end
	-- we can skip this function if the client is trying to weld -and- nocollide, because
	-- constraint.Weld already has a nocollide parameter
	if ( self:ShouldForceWeld() or self:ShouldApplyWeld() ) then return true end
	
	local ok, err = pcall( constraint.NoCollide, lastEnt, newEnt, 0, 0 )
	
	if ( not ok ) then
		print( mode .. ": " .. L(prefix.."error_max_constraints") .." (error: " .. err .. ")" )
		self:SendError( mode .. ": " .. L(prefix.."error_max_constraints", localify.GetLocale( self:GetOwner() )) )
	end
	
	return ok
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyPhysicalProperties( entity, entity, number, table )
--
--	Attempts to apply the original entity's Gravity/Physics Material properties 
--	and weight onto the stacked propa.
--	
--]]--
function TOOL:ApplyPhysicalProperties( original, newEnt, boneID, properties )
	if ( not self:ShouldApplyPhysicalProperties() ) then return end
	
	if ( boneID ) then construct.SetPhysProp( nil, newEnt, boneID, nil, properties ) end
	newEnt:GetPhysicsObject():SetMass( original:GetPhysicsObject():GetMass() )
end

if ( CLIENT ) then
	
	-- get the cvars if they're valid (e.g., editing and auto-refreshing this file).
	-- otherwise they won't be valid yet when first ran and we have to wait until
	-- TOOL:Init() gets called (below) to set them up
	local cvarTool       = GetConVar( "gmod_toolmode" )
	local cvarCount      = GetConVar( mode.."_count" )
	local cvarMode       = GetConVar( mode.."_mode" )
	local cvarDirection  = GetConVar( mode.."_direction" )
	local cvarOffsetX    = GetConVar( mode.."_offsetx" )
	local cvarOffsetY    = GetConVar( mode.."_offsety" )
	local cvarOffsetZ    = GetConVar( mode.."_offsetz" )
	local cvarPitch      = GetConVar( mode.."_pitch" )
	local cvarYaw        = GetConVar( mode.."_yaw" )
	local cvarRoll       = GetConVar( mode.."_roll" )
	local cvarRelative   = GetConVar( mode.."_relative" )
	local cvarMaterial   = GetConVar( mode.."_material" )
	local cvarColor      = GetConVar( mode.."_color" )
	local cvarGhostAll   = GetConVar( mode.."_ghostall" )
	local cvarOpacity    = GetConVar( mode.."_opacity" )
	local cvarHalo       = GetConVar( mode.."_draw_halos" )
	local cvarHaloR      = GetConVar( mode.."_halo_r" )
	local cvarHaloG      = GetConVar( mode.."_halo_g" )
	local cvarHaloB      = GetConVar( mode.."_halo_b" )
	local cvarHaloA      = GetConVar( mode.."_halo_a" )	
	local cvarHalo       = GetConVar( mode.."_draw_halos" )
	local cvarAxis       = GetConVar( mode.."_draw_axis" )
	local cvarAxisLbl    = GetConVar( mode.."_axis_labels" )
	local cvarAxisAng    = GetConVar( mode.."_axis_angles" )
	
	-- offsets for drawing the axis arrows
	local o1 = Vector(     0, 0,  0.05 )
	local o2 = Vector(     0, 0, -0.05 )
	local o3 = Vector(  0.05, 0,     0 )
	local o4 = Vector( -0.05, 0,     0 )
	local ao = 2.5
	
	-- colors for the axis arrows
	local RED   = Color( 255,  50,  50 )
	local GREEN = Color(   0, 255,   0 )
	local BLUE  = Color(  50, 150, 255 )
	local BLACK = Color(   0,   0,   0 )
	
	surface.CreateFont( mode.."_direction", {
		font = "Arial",
		size = 24,
		weight = 700,
		antialias = true
	})
	
	
	-- we're creating a bunch of local functions here using the cvars above so that we don't have to
	-- rely on the TOOL object (which can be problematic when trying to use it inside a hook).
	-- these should be pretty much identical to the TOOL functions created near the top of this file
	local function getStackSize()        return cvarCount:GetInt()       end
	local function getMaxPerStack()      return cvarMaxPerStack:GetInt() end
	local function getStackerMode()      return cvarMode:GetInt()        end
	local function getDirection()        return cvarDirection:GetInt()   end
	local function getOpacity()          return cvarOpacity:GetInt()     end	
	local function shouldGhostAll()      return cvarGhostAll:GetBool()   end
	local function shouldStackRelative() return cvarRelative:GetBool()   end
	local function shouldApplyMaterial() return cvarMaterial:GetBool()   end
	local function shouldApplyColor()    return cvarColor:GetBool()      end
	local function shouldAddHalos()      return cvarHalo:GetBool()       end
	
	local function getOffsetVector()
		return Vector( math.Clamp( cvarOffsetX:GetFloat(), -cvarMaxOffX:GetFloat(), cvarMaxOffX:GetFloat() ), 
	                   math.Clamp( cvarOffsetY:GetFloat(), -cvarMaxOffY:GetFloat(), cvarMaxOffY:GetFloat() ),
	                   math.Clamp( cvarOffsetZ:GetFloat(), -cvarMaxOffZ:GetFloat(), cvarMaxOffZ:GetFloat() ) )
	end

	local function getRotationAngle()
		return Angle( math.Clamp( cvarPitch:GetFloat(), -MAX_ANGLE, MAX_ANGLE ),
                      math.Clamp( cvarYaw:GetFloat(),   -MAX_ANGLE, MAX_ANGLE ),
                      math.Clamp( cvarRoll:GetFloat(),  -MAX_ANGLE, MAX_ANGLE ) )
	end
	
	local function getHaloColor()
		return Color( cvarHaloR:GetInt(),
                      cvarHaloG:GetInt(),
                      cvarHaloB:GetInt(),
	                  cvarHaloA:GetInt() )
	end
	
	--[[--------------------------------------------------------------------------
	--
	-- 	TOOL:Init()
	--
	--]]--
	function TOOL:Init()
		-- now the convars are truly valid, so reassign the upvalues
		cvarTool       = GetConVar( "gmod_toolmode" )
		cvarCount      = GetConVar( mode.."_count" )
		cvarMode       = GetConVar( mode.."_mode" )
		cvarDirection  = GetConVar( mode.."_direction" )
		cvarOffsetX    = GetConVar( mode.."_offsetx" )
		cvarOffsetY    = GetConVar( mode.."_offsety" )
		cvarOffsetZ    = GetConVar( mode.."_offsetz" )
		cvarPitch      = GetConVar( mode.."_pitch" )
		cvarYaw        = GetConVar( mode.."_yaw" )
		cvarRoll       = GetConVar( mode.."_roll" )
		cvarRelative   = GetConVar( mode.."_relative" )
		cvarMaterial   = GetConVar( mode.."_material" )
		cvarColor      = GetConVar( mode.."_color" )
		cvarGhostAll   = GetConVar( mode.."_ghostall" )
		cvarOpacity    = GetConVar( mode.."_opacity" )
		cvarHalo       = GetConVar( mode.."_draw_halos" )
		cvarHaloR      = GetConVar( mode.."_halo_r" )
		cvarHaloG      = GetConVar( mode.."_halo_g" )
		cvarHaloB      = GetConVar( mode.."_halo_b" )
		cvarHaloA      = GetConVar( mode.."_halo_a" )
		cvarHalo       = GetConVar( mode.."_draw_halos" )
		cvarAxis       = GetConVar( mode.."_draw_axis" )
		cvarAxisLbl    = GetConVar( mode.."_axis_labels" )
		cvarAxisAng    = GetConVar( mode.."_axis_angles" )
	end
	
	--[[--------------------------------------------------------------------------
	--
	-- 	createGhostStack( entity, vector, angle )
	--
	--	Attempts to create a stack of ghosted props on the prop the player is currently
	--	looking at before they actually left click to create the stack. This acts
	--	as a visual aid for the player so they can see the results without actually creating
	--	the entities yet (if in multiplayer).
	--]]--
	local function createGhostStack( ent )
		if ( improvedstacker.GetGhosts() ) then improvedstacker.ReleaseGhosts() end

		-- truncate the stack size to the maximum allowed by the server
		local count    = getStackSize()
		local maxCount = getMaxPerStack()
		if ( not shouldGhostAll() and count ~= 0 ) then count = 1 end
		if ( maxCount >= 0 and count > maxCount )  then count = maxCount end

		local entMod  = ent:GetModel()
		local entSkin = ent:GetSkin()
		
		local ghosts = {}
		local ghost
		
		-- loop for the total stack size and create a new ghost prop
		for i = 1, count do
			ghost = ClientsideModel( entMod )
			
			if ( not IsValid( ghost ) ) then continue end

			ghost:SetModel( entMod )
			ghost:SetSkin( entSkin )
			ghost:Spawn()

			ghost:SetRenderMode( RENDERMODE_TRANSALPHA )
			
			table.insert( ghosts, ghost )
		end
		
		-- store the ghost array for later use
		improvedstacker.SetGhosts( ghosts )
		
		return true
	end

	--[[--------------------------------------------------------------------------
	--
	-- 	validateGhostStack()
	--
	--	Attempts to validate the status of the ghosted props in the stack.
	--		True:  all good, ready to update
	--		False: something is invalid or missing, clear it
	--]]--
	local function validateGhostStack()
		-- check if the array of ghosts is valid
		local ghosts = improvedstacker.GetGhosts()
		if ( not ghosts ) then return false end
		
		-- check if all the ghost entities are valid
		for i = 1, #ghosts do
			if ( not IsValid( ghosts[ i ] ) ) then return false end
		end
		
		-- clamp the client's ghost stack to the server's maximum allowed size
		local count    = getStackSize()
		local maxCount = getMaxPerStack()
		if ( maxCount >= 0 and count > maxCount ) then count = maxCount end
		
		-- check if the number of ghosts in the stack matches the client's setting
		if     ( #ghosts ~= count and     shouldGhostAll() ) then return false
		-- number of ghosts matches client's setting, so check if we should only be ghosting one
		elseif ( #ghosts ~= 1     and not shouldGhostAll() ) then return false end
		
		return true
	end

	--[[--------------------------------------------------------------------------
	--
	-- 	updateGhostStack( entity )
	--
	--	Attempts to update the positions and angles of all ghosted props in the stack.
	--]]--
	local function updateGhostStack( ent )		
		local stackMode      = getStackerMode()
		local stackDirection = getDirection()
		local stackOffset    = getOffsetVector()
		local stackRotation  = getRotationAngle()
		local stackRelative  = shouldStackRelative()
		
		local applyMat  = shouldApplyMaterial()
		local applyCol  = shouldApplyColor()
		
		local lastEnt = ent
		local entPos = ent:GetPos()
		local entAng = ent:GetAngles()
		local entMat = ent:GetMaterial()
		local entCol = ent:GetColor()
			  entCol.a = getOpacity()
		
		local direction, offset
		-- we only need to calculate the distance once based on the direction the user selected
		local distance = improvedstacker.GetDistance( stackMode, stackDirection, ent )
		
		local ghost
		local ghosts = improvedstacker.GetGhosts()
		
		for i = 1, #ghosts do
			-- if we're positioning the first entity in the stack (regardless of relative to PROP or WORLD), or
			-- if we're stacking relative to PROP and on the previous rotation, update the new direction and offset
			if ( i == 1 or ( stackMode == improvedstacker.MODE_PROP and stackRelative ) ) then
				direction = improvedstacker.GetDirection( stackMode, stackDirection, entAng )
				offset    = improvedstacker.GetOffset( stackMode, stackDirection, entAng, stackOffset )
			end

			-- calculate the next stacked entity's position
			entPos = entPos + (direction * distance) + offset
			-- rotate the next stacked entity's angle by the client's rotation values
			improvedstacker.RotateAngle( stackMode, stackDirection, entAng, stackRotation )
			
			local ghost = ghosts[ i ]
			ghost:SetPos( entPos )
			ghost:SetAngles( entAng )
			ghost:SetMaterial( ( applyMat and entMat ) or "" )
			ghost:SetColor( ( applyCol and entCol ) or TRANSPARENT )
			ghost:SetNoDraw( false )
			
			lastEnt = ghost
		end
	end
	
	
	--[[--------------------------------------------------------------------------
	--
	-- 	Hook :: PreDrawHalos
	--
	--	Loads the hook that draws halos on the ghosted entities in the stack. 
	--
	--	This is the appropriate hook to create halos, NOT TOOL:Think(). The latter 
	--	will be called way more than it needs to be and causes horrible FPS drops in singleplayer.
	--]]--
	hook.Add( "PreDrawHalos", mode.."_predrawhalos", function()
		-- check if the player has fully initialized
		local ply = LocalPlayer()
		if ( not IsValid( ply ) ) then return end
		
		-- check if they have the toolgun out and have stacker selected
		local wep = ply:GetActiveWeapon()
		if ( not ( IsValid( wep ) and wep:GetClass() == "gmod_tool" and cvarTool and cvarTool:GetString() == mode ) ) then
			improvedstacker.ReleaseGhosts()
			improvedstacker.SetLookedAt( nil )
			return
		end
		
		-- check if we're looking at a valid entity
		local lookingAt = ply:GetEyeTrace().Entity
		if ( not ( IsValid( lookingAt ) and lookingAt:GetClass() == "prop_physics" ) ) then
			improvedstacker.ReleaseGhosts()
			improvedstacker.SetLookedAt( nil )
			return
		end
		
		-- check if the current toolobject is valid before trying to use it --
		-- commenting this out for now since I refactored these TOOL functions
		-- into just local functions to ditch the need for the tool object
		--[[local tool = wep.GetToolObject and wep:GetToolObject() 
		if ( not ( tool and tool.GetOwner and IsValid( tool:GetOwner() ) ) ) then
			return
		end]]
		
		-- specify the entity that the client is currently looking at for future reference
		improvedstacker.SetLookingAt( lookingAt )
		-- get the entity that the client was last (successfully) looking at
		local lookedAt = improvedstacker.GetLookedAt()
		
		-- if we're still looking at the same entity from the previous frame
		if ( lookingAt == lookedAt ) then
			-- if the ghost stack is still valid (nothing got deleted, etc)
			if ( validateGhostStack() ) then
				-- reposition the stack to the client's most recent stack settings
				updateGhostStack( lookingAt )
			else
				-- something is wrong in the stack, so remove the ghost entities
				improvedstacker.ReleaseGhosts()
				improvedstacker.SetLookedAt( nil )
				return
			end
		-- we looked at something else since the last frame
		else
			-- try to initialize a new ghost stack
			if ( createGhostStack( lookingAt ) ) then
				-- ghost stack was successfully created
				improvedstacker.SetLookedAt( lookingAt )
			end
		end
		
		-- check if we want to add halos to the ghost stack
		if ( not shouldAddHalos() ) then return end
		
		-- check if there are any ghosts to add halos to at all
		local ghosts = improvedstacker.GetGhosts()
		if ( not ghosts or #ghosts <= 0 ) then return end

		halo.Add( ghosts, getHaloColor() )
	end )
	
	--[[--------------------------------------------------------------------------
	--
	-- 	Hook :: PostDrawTranslucentRenderables
	--
	--	Draws the 2D x/y/z axis when looking at entities with the stacker tool.
	--]]--
	
	hook.Add( "PostDrawTranslucentRenderables", mode.."_directions", function( drawingDepth, drawingSky )
		if ( drawingSky ) then return end
		
		-- check if the player has fully initialized
		local ply = LocalPlayer()
		if ( not IsValid( ply ) ) then return end
		
		-- check if we want to draw the axis at all
		if ( not ( cvarAxis and cvarAxis:GetBool() ) ) then return end
		
		-- check if they have the toolgun out and have stacker selected
		local wep = ply:GetActiveWeapon()
		if ( not ( IsValid( wep ) and wep:GetClass() == "gmod_tool" and cvarTool and cvarTool:GetString() == mode ) ) then
			return
		end
		
		-- check if we're looking at a valid entity
		local ent = ply:GetEyeTrace().Entity
		if ( not IsValid( ent ) ) then
			return
		end
		
		local pos = ent:GetPos()
		
		local f = ent:GetForward()
		local r = ent:GetRight()
		local u = ent:GetUp()
		
		-- draw the front arrow (red)
		render.DrawLine( pos,    pos + (f*50),      RED, false )
		render.DrawLine( pos + (f*50) - f*ao + Vector(0,0,ao), pos + (f*50), RED, false )
		render.DrawLine( pos + (f*50) - f*ao - Vector(0,0,ao), pos + (f*50), RED, false )
		render.DrawLine( pos+o1, pos + (f*50) + o1, RED, false )
		render.DrawLine( pos+o2, pos + (f*50) + o2, RED, false )
		
		-- draw the right arrow (green)
		render.DrawLine( pos,    pos + (r*50),      GREEN, false )
		render.DrawLine( pos + (r*50) - r*ao + f*ao, pos + (r*50), GREEN, false )
		render.DrawLine( pos + (r*50) - r*ao - f*ao, pos + (r*50), GREEN, false )
		render.DrawLine( pos+o1, pos + (r*50) + o1, GREEN, false )
		render.DrawLine( pos+o2, pos + (r*50) + o2, GREEN, false )
		
		-- draw the upward arrow (blue)
		render.DrawLine( pos,    pos + (u*50),      BLUE, false )
		render.DrawLine( pos + (u*50) - u*ao + r*ao, pos + (u*50), BLUE, false )
		render.DrawLine( pos + (u*50) - u*ao - r*ao, pos + (u*50), BLUE, false )
		render.DrawLine( pos+o3, pos + (u*50) + o3, BLUE, false )
		render.DrawLine( pos+o4, pos + (u*50) + o4, BLUE, false )
		
		-- check if we want to draw the axis labels
		if ( not ( cvarAxisLbl           and cvarAxisAng ) )           then return end
		if ( not ( cvarAxisLbl:GetBool() or  cvarAxisAng:GetBool() ) ) then return end
		
		local fs = (pos + f*50 - u*5):ToScreen()
		local rs = (pos + r*50 - u*5):ToScreen()
		local us = (pos + u*55):ToScreen()
		
		local ang = ent:GetAngles()
		
		local front = ("%s%s"):format( cvarAxisLbl:GetBool() and L(prefix.."hud_front").." " or "", cvarAxisAng:GetBool() and "("..ang.x..")" or "" )
		local right = ("%s%s"):format( cvarAxisLbl:GetBool() and L(prefix.."hud_right").." " or "", cvarAxisAng:GetBool() and "("..ang.y..")" or "" )
		local upwrd = ("%s%s"):format( cvarAxisLbl:GetBool() and L(prefix.."hud_up").." "    or "", cvarAxisAng:GetBool() and "("..ang.z..")" or "" )
		
		cam.Start2D()
			draw.SimpleTextOutlined( front, mode.."_direction", fs.x, fs.y, RED,   0, 0, 1, BLACK )
			draw.SimpleTextOutlined( right, mode.."_direction", rs.x, rs.y, GREEN, 0, 0, 1, BLACK )
			draw.SimpleTextOutlined( upwrd, mode.."_direction", us.x, us.y, BLUE,  1, 0, 1, BLACK )
		cam.End2D()
		
	end )
	
end

if ( CLIENT ) then
	--[[--------------------------------------------------------------------------
	--
	-- 	TOOL.BuildCPanel( panel )
	--
	--	Builds the control panel menu that can be seen when holding Q and accessing
	--	the stacker menu.
	--]]--
	local function buildCPanel( cpanel )
		-- quick presets for default settings
		local presets = { 
			Label      = "Presets",
			MenuButton = 1,
			Folder     = mode,
			Options = {
				[L(prefix.."combobox_default")] = {
					[mode.."_mode"]        = tostring(improvedstacker.MODE_PROP),
					[mode.."_direction"]   = tostring(improvedstacker.DIRECTION_UP),
					[mode.."_count"]       = "1",
					[mode.."_freeze"]      = "1",
					[mode.."_weld"]        = "1",
					[mode.."_nocollide"]   = "1",
					[mode.."_ghostall"]    = "1",
					[mode.."_material"]    = "1",
					[mode.."_physprop"]    = "1",
					[mode.."_color"]       = "1",
					[mode.."_offsetx"]     = "0",
					[mode.."_offsety"]     = "0",
					[mode.."_offsetz"]     = "0",
					[mode.."_pitch"]       = "0",
					[mode.."_yaw"]         = "0",
					[mode.."_roll"]        = "0",
					[mode.."_relative"]    = "1",
					[mode.."_draw_halos"]  = "0",
					[mode.."_halo_r"]      = "255",
					[mode.."_halo_g"]      = "0",
					[mode.."_halo_b"]      = "0",
					[mode.."_halo_a"]      = "255",
					[mode.."_draw_axis"]   = "1",
					[mode.."_axis_labels"] = "1",
					[mode.."_axis_angles"] = "0",
				},
			},
			CVars = { 
				mode.."_mode",
				mode.."_direction",
				mode.."_count",
				mode.."_freeze",
				mode.."_weld",
				mode.."_nocollide",
				mode.."_ghostall",
				mode.."_material",
				mode.."_physprop",
				mode.."_color",
				mode.."_offsetx",
				mode.."_offsety",
				mode.."_offsetz",
				mode.."_pitch",
				mode.."_yaw",
				mode.."_roll",
				mode.."_relative",
				mode.."_draw_halos",
				mode.."_halo_r",
				mode.."_halo_g",
				mode.."_halo_b",
				mode.."_halo_a",
				mode.."_draw_axis",
				mode.."_axis_labels",
				mode.."_axis_angles",
			}
		}
		
		local relativeOptions = {
			[L(prefix.."combobox_world")] = { [mode.."_mode"] = improvedstacker.MODE_WORLD },
			[L(prefix.."combobox_prop")]  = { [mode.."_mode"] = improvedstacker.MODE_PROP  },
		}
		
		local relative = { Label = L(prefix.."label_relative"), MenuButton = "0", Options = relativeOptions }
		
		local directionOptions = {
			["1 - "..L(prefix.."combobox_direction_front")] = { [mode.."_direction"] = improvedstacker.DIRECTION_FRONT },
			["2 - "..L(prefix.."combobox_direction_back")]  = { [mode.."_direction"] = improvedstacker.DIRECTION_BACK  },
			["3 - "..L(prefix.."combobox_direction_right")] = { [mode.."_direction"] = improvedstacker.DIRECTION_RIGHT },
			["4 - "..L(prefix.."combobox_direction_left")]  = { [mode.."_direction"] = improvedstacker.DIRECTION_LEFT  },
			["5 - "..L(prefix.."combobox_direction_up")]    = { [mode.."_direction"] = improvedstacker.DIRECTION_UP    },
			["6 - "..L(prefix.."combobox_direction_down")]  = { [mode.."_direction"] = improvedstacker.DIRECTION_DOWN  },
		}
		
		local directions = { Label = L(prefix.."label_direction"), MenuButton = "0", Options = directionOptions }
		
		-- populate the table of valid languages that clients can switch between
		local languageOptions = {}
		
		for code, tbl in pairs( localify.GetLocalizations() ) do
			if ( not L(prefix.."language_"..code, code) ) then continue end
			
			languageOptions[ L(prefix.."language_"..code, code) ] = { localify_language = code }
		end
		
		local languages = {
			Label      = L(prefix.."label_language"),
			MenuButton = 0,
			Options    = languageOptions,
		}
		
		cpanel:AddControl( "ComboBox", languages )
		cpanel:ControlHelp( "\n" .. L(prefix.."label_credits") )
		cpanel:AddControl( "Label",    { Text = L(prefix.."label_presets") } )
		cpanel:AddControl( "ComboBox", presets )
		cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_freeze"),    Command = mode.."_freeze" } )
		cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_weld"),      Command = mode.."_weld" } )
		cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_nocollide"), Command = mode.."_nocollide" } )	
		cpanel:AddControl( "ComboBox", relative )	
		cpanel:AddControl( "ComboBox", directions )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_count"), Min = 1, Max = cvarMaxPerStack:GetInt(), Command = mode.."_count", Description = "How many props to create in each stack" } )
		cpanel:AddControl( "Button",   { Label = L(prefix.."label_reset_offsets"), Command = mode.."_reset_offsets" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_x"),     Type = "Float", Min = - cvarMaxOffX:GetInt(), Max = cvarMaxOffX:GetInt(), Value = 0, Command = mode.."_offsetx" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_y"),     Type = "Float", Min = - cvarMaxOffY:GetInt(), Max = cvarMaxOffY:GetInt(), Value = 0, Command = mode.."_offsety" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_z"),     Type = "Float", Min = - cvarMaxOffZ:GetInt(), Max = cvarMaxOffZ:GetInt(), Value = 0, Command = mode.."_offsetz" } )
		cpanel:AddControl( "Button",   { Label = L(prefix.."label_reset_angles"),  Command = mode.."_reset_angles" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_pitch"), Type = "Float", Min = -MAX_ANGLE,  Max = MAX_ANGLE,  Value = 0, Command = mode.."_pitch" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_yaw"),   Type = "Float", Min = -MAX_ANGLE,  Max = MAX_ANGLE,  Value = 0, Command = mode.."_yaw" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_roll"),  Type = "Float", Min = -MAX_ANGLE,  Max = MAX_ANGLE,  Value = 0, Command = mode.."_roll" } )
		
		cpanel:AddControl( "Button",   { Label = L(prefix.."label_"..(showSettings and "hide" or "show").."_settings"),   Command = mode.."_show_settings" } )
		
		if ( showSettings ) then
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_use_shift_key"), Command = mode.."_use_shift_key", Description = "Toggles the ability to hold SHIFT and click the left and right mouse buttons to change stack size" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_relative"),      Command = mode.."_relative",      Description = "Stacks each prop relative to the prop right before it. This allows you to create curved stacks" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_material"),      Command = mode.."_material",      Description = "Applies the material of the original prop to all stacked props" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_color"),         Command = mode.."_color",         Description = "Applies the color of the original prop to all stacked props" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_physprop"),      Command = mode.."_physprop",      Description = "Applies the physical properties of the original prop to all stacked props" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_ghost"),         Command = mode.."_ghostall",      Description = "Creates every ghost prop in the stack instead of just the first ghost prop" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_axis"),          Command = mode.."_draw_axis", } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_axis_labels"),   Command = mode.."_axis_labels", } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_axis_angles"),   Command = mode.."_axis_angles", } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_halo"),          Command = mode.."_draw_halos", Description = "Gives halos to all of the props in to ghosted stack" } )
			cpanel:AddControl( "Slider",   { Label = L(prefix.."label_opacity"), Type = "Integer", Min = 0, Max = 255, Command = mode.."_opacity" } )
			cpanel:AddControl( "Color",    { Label = L(prefix.."checkbox_halo_color"), Red = mode.."_halo_r", Green = mode.."_halo_g", Blue = mode.."_halo_b", Alpha = mode.."_halo_a" } )
		end
	end
	
	concommand.Add( mode.."_show_settings", function( ply, cmd, args )
		local cpanel = controlpanel.Get( mode )
		if ( not IsValid( cpanel ) ) then return end
		showSettings = not showSettings
		cpanel:ClearControls()
		buildCPanel( cpanel )
	end )

	-- listen for changes to the localify language and reload the tool's menu to update the localizations
	cvars.AddChangeCallback( "localify_language", function( name, old, new )
		local cpanel = controlpanel.Get( mode )
		if ( not IsValid( cpanel ) ) then return end
		cpanel:ClearControls()
		buildCPanel( cpanel )
	end, "improvedstacker" )
	
	TOOL.BuildCPanel = buildCPanel

	--[[--------------------------------------------------------------------------
	--
	-- 	PopulateToolMenu
	--
	--	Builds the admin settings control panel in the utility menu. This allows server
	--	operators to quickly and easily save/change Stacker server settings.
	--]]--
	hook.Add( "PopulateToolMenu", mode.."AdminUtilities", function()
		spawnmenu.AddToolMenuOption( "Utilities", "Admin", mode.."_utils", L(prefix.."name"), "", "", function( cpanel )
			
			-- quick presets for default settings
			local presets = {
				label      = "Presets",
				menubutton = 1,
				folder     = mode.."_admin",
				options = {
					[L(prefix.."combobox_default")]      = improvedstacker.SETTINGS_DEFAULT,
					[L(prefix.."combobox_sandbox")]      = improvedstacker.SETTINGS_SANDBOX,
					[L(prefix.."combobox_darkrp")]       = improvedstacker.SETTINGS_DARKRP,
					[L(prefix.."combobox_singleplayer")] = improvedstacker.SETTINGS_SINGLEPLAYER,
				},
				cvars = {
					{ CVar = mode.."_max_per_player",    CCmd = mode.."_set_max_per_player" },
					{ CVar = mode.."_max_per_stack",     CCmd = mode.."_set_max_per_stack" },
					{ CVar = mode.."_delay",             CCmd = mode.."_set_delay" },
					{ CVar = mode.."_max_offsetx",       CCmd = mode.."_set_max_offsetx" },
					{ CVar = mode.."_max_offsety",       CCmd = mode.."_set_max_offsety" },
					{ CVar = mode.."_max_offsetz",       CCmd = mode.."_set_max_offsetz" },
					{ CVar = mode.."_force_freeze",      CCmd = mode.."_set_force_freeze" },
					{ CVar = mode.."_force_weld",        CCmd = mode.."_set_force_weld" },
					{ CVar = mode.."_force_nocollide",   CCmd = mode.."_set_force_nocollide" },
					{ CVar = mode.."_force_stayinworld", CCmd = mode.."_set_force_stayinworld" },
				},
			}
			
			local ctrl = vgui.Create( "StackerControlPresets", cpanel )
			ctrl:SetPreset( presets.folder )
			for k, v in pairs( presets.options ) do
				ctrl:AddOption( k, v )
			end
			for k, v in pairs( presets.cvars ) do
				ctrl:AddConVar( v )
			end			
			cpanel:AddItem( ctrl )
			--cpanel:AddControl( "ComboBox", presets )
			
			
			local bg = Color( 210, 210, 210 ) or Color( 179, 216, 255 )
			local fg = Color( 240, 240, 240 ) or Color( 229, 242, 255 )
			
			local sliders = {
				{ String = "max_per_player", Min = -1, Max = 2048,  Decimals = 0 },
				{ String = "max_per_stack",  Min =  1, Max = 100,   Decimals = 0 },
				{ String = "delay",          Min =  0, Max = 5,                  },
				{ String = "max_offsetx",    Min =  0, Max = 10000,              },
				{ String = "max_offsety",    Min =  0, Max = 10000,              },
				{ String = "max_offsetz",    Min =  0, Max = 10000,              },
			}
			
			local sliderlist = vgui.Create( "DListLayout", cpanel )
			sliderlist:DockPadding( 3, 1, 3, 3 )
			sliderlist:SetPaintBackground( true )
			function sliderlist:Paint( w, h )
				draw.RoundedBox( 0, 0, 0, w, h, bg )
			end
			cpanel:AddItem( sliderlist )
			
			for k, data in pairs( sliders ) do
				local list = vgui.Create( "DListLayout", sliderlist )
				list:DockPadding( 5, 0, 5, 5 )
				list:DockMargin( 0, 2, 0, 0 )
				list:SetPaintBackground( true )
				function list:Paint( w, h )
					draw.RoundedBox( 0, 0, 0, w, h, fg )
				end
			
				local decimals = data.Decimals or 2
			
				local slider = vgui.Create( "StackerDNumSlider", list )
				slider:SetText( L(prefix.."label_"..data.String) )
				slider.Label:SetFont( "DermaDefaultBold" )
				slider:SetMinMax( data.Min, data.Max )
				slider:SetDark( true )
				slider:SizeToContents()
				slider:SetDecimals( decimals )
				slider:SetValue( decimals == 0 and GetConVar( mode.."_"..data.String ):GetInt() or GetConVar( mode.."_"..data.String ):GetFloat(), true )
				
				local cmd = mode.."_set_"..data.String
				
				function slider:OnValueChanged( value )
					value = math.Round( value, decimals )
					RunConsoleCommand( cmd, value )
				end
				
				if ( L(prefix.."help_"..data.String) ) then
					local help = vgui.Create( "DLabel", list )
					help:SetText( L(prefix.."help_"..data.String) )
					help:DockMargin( 10, 0, 5, 0 )
					help:SetWrap( true )
					help:SetDark( true )
					help:SetAutoStretchVertical( true )
					help:SetFont( "DermaDefault" )
				end
				
				if ( L(prefix.."warning_"..data.String) ) then
					local help = vgui.Create( "DLabel", list )
					help:SetText( L(prefix.."warning_"..data.String) )
					help:DockMargin( 10, 0, 5, 0 )
					help:SetWrap( true )
					help:SetDark( true )
					help:SetAutoStretchVertical( true )
					help:SetFont( "DermaDefault" )
					help:SetTextColor( Color( 200, 0, 0 ) )
				end
				
				cvars.AddChangeCallback( mode.."_"..data.String, function( name, old, new )
					if ( not IsValid( slider ) ) then return end
					slider:SetValue( GetConVar( mode.."_"..data.String ):GetFloat(), true )
				end, mode.."_"..data.String.."_utilities" )
			end
			
			
			
			local checkboxes = {
				"freeze",
				"weld",
				"nocollide",
				"nocollide_all",
				"stayinworld",
			}

			local cblist = vgui.Create( "DListLayout", cpanel )
			cblist:DockPadding( 3, 1, 3, 3 )
			cblist:SetPaintBackground( true )
			function cblist:Paint( w, h )
				draw.RoundedBox( 0, 0, 0, w, h, bg )
			end
			cpanel:AddItem( cblist )
			
			for k, data in pairs( checkboxes ) do
				local list = vgui.Create( "DListLayout", cblist )
				list:DockPadding( 5, 5, 5, 5 )
				list:DockMargin( 0, 2, 0, 0 )
				list:SetPaintBackground( true )
				function list:Paint( w, h )
					draw.RoundedBox( 0, 0, 0, w, h, fg )
				end
			
				local cb = vgui.Create( "DCheckBoxLabel", list )
				cb:SetText( L(prefix.."checkbox_"..data) )
				cb:SetChecked( GetConVar( mode.."_force_"..data ):GetBool() )
				cb.Label:SetFont( "DermaDefaultBold" )
				cb:SizeToContents()
				cb:SetDark( true )
				-- we don't want this value to be changed while the server is running, so disable the checkbox
				if ( data == "nocollide_all" ) then
					cb:SetDisabled( true )
				end
				
				function cb:OnChange( bool ) RunConsoleCommand( mode.."_set_force_"..data, bool and "1" or "0" ) end
				
				cvars.AddChangeCallback( mode.."_force_"..data, function( name, old, new )
					if ( not IsValid( cb ) ) then return end
					cb:SetChecked( tobool( new ) )
				end, mode.."_"..data.."_utilities" )
				
				if ( L(prefix.."help_"..data) ) then
					local help = vgui.Create( "DLabel", list )
					help:SetText( L(prefix.."help_"..data) )
					help:DockMargin( 25, 5, 5, 0 )
					help:SetWrap( true )
					help:SetDark( true )
					help:SetAutoStretchVertical( true )
					help:SetFont( "DermaDefault" )
				end
				
				if ( L(prefix.."warning_"..data) ) then
					local help = vgui.Create( "DLabel", list )
					help:SetText( L(prefix.."warning_"..data) )
					help:DockMargin( 25, 5, 5, 0 )
					help:SetWrap( true )
					help:SetDark( true )
					help:SetAutoStretchVertical( true )
					help:SetFont( "DermaDefault" )
					help:SetTextColor( Color( 200, 0, 0 ) )
				end
			end
		end )
	end )
end
--addons/weapons_other/lua/weapons/keypad_cracker.lua:
-- This is sorta horrible

AddCSLuaFile()

local keypad_crack_time = CreateConVar("keypad_crack_time", "30", {FCVAR_ARCHIVE}, "Seconds for keypad cracker to crack keypad")

if SERVER then
	util.AddNetworkString("KeypadCracker_Hold")
	util.AddNetworkString("KeypadCracker_Sparks")
end

if CLIENT then
	SWEP.PrintName = "Keypad Cracker"
	SWEP.Slot = 4
	SWEP.SlotPos = 1
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = true
end

SWEP.Author = "Willox"
SWEP.Instructions = "Left click to crack keypad"
SWEP.Contact = ""
SWEP.Purpose = ""

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.ViewModel = Model("models/weapons/v_c4.mdl")
SWEP.WorldModel = Model("models/weapons/w_c4.mdl")

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.AnimPrefix = "python"

SWEP.Sound = Sound("weapons/deagle/deagle-1.wav")

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

SWEP.KeyCrackSound = Sound("buttons/blip2.wav")

SWEP.IdleStance = "slam"

function SWEP:Initialize()
	self:SetHoldType(self.IdleStance)

	if SERVER then
		net.Start("KeypadCracker_Hold")
			net.WriteEntity(self)
			net.WriteBit(true)
		net.Broadcast()

		self:SetCrackTime( keypad_crack_time:GetInt() )
	end
end	

function SWEP:SetupDataTables()
	self:NetworkVar( "Int", 0, "CrackTime" )
end

function SWEP:PrimaryAttack()
	self:SetNextPrimaryFire(CurTime() + 0.4)


	
	if self.IsCracking or not IsValid(self.Owner) then return end

	local tr = self.Owner:GetEyeTrace()
	local ent = tr.Entity

	if IsValid(ent) and tr.HitPos:Distance(self.Owner:GetShootPos()) <= 50 and ent.IsKeypad then
		self.IsCracking = true
		self.StartCrack = CurTime()
		self.EndCrack = CurTime() + self:GetCrackTime()

		self:SetWeaponHoldType("pistol") -- TODO: Send as networked message for other clients to receive

		
		if SERVER then
			net.Start("KeypadCracker_Hold")
				net.WriteEntity(self)
				net.WriteBit(true)
			net.Broadcast()

			timer.Create("KeyCrackSounds: "..self:EntIndex(), 1, self:GetCrackTime(), function()
				if IsValid(self) and self.IsCracking then
					self:EmitSound(self.KeyCrackSound, 100, 100)
					
				end
			end)
		else
			self.Dots = self.Dots or ""
			
			local entindex = self:EntIndex()
			timer.Create("KeyCrackDots: "..entindex, 0.5, 0, function()
				if not IsValid(self) then
					timer.Destroy("KeyCrackDots: "..entindex)
				else
					local len = string.len(self.Dots)
					local dots = {[0] = ".", [1] = "..", [2]= "...", [3] = ""}

					self.Dots = dots[len]
				end
			end)
		end
	end
end

function SWEP:Holster()
	self.IsCracking = false

	if SERVER then
		timer.Destroy("KeyCrackSounds: "..self:EntIndex())
	else
		timer.Destroy("KeyCrackDots: "..self:EntIndex())
	end

	return true
end

function SWEP:Reload()
	return true
end

function SWEP:Succeed()
	self.IsCracking = false

	local tr = self.Owner:GetEyeTrace()
	local ent = tr.Entity
	self:SetWeaponHoldType(self.IdleStance)

	if SERVER and IsValid(ent) and tr.HitPos:Distance(self.Owner:GetShootPos()) <= 50 and ent.IsKeypad then
		ent:Process(true)

		net.Start("KeypadCracker_Hold")
			net.WriteEntity(self)
			net.WriteBit(true)
		net.Broadcast()

		net.Start("KeypadCracker_Sparks")
			net.WriteEntity(ent)
		net.Broadcast()
	end

	if SERVER then
		timer.Destroy("KeyCrackSounds: "..self:EntIndex())
	else
		timer.Destroy("KeyCrackDots: "..self:EntIndex())
	end
end

function SWEP:Fail()
	self.IsCracking = false

	self:SetWeaponHoldType(self.IdleStance)

	if SERVER then
		net.Start("KeypadCracker_Hold")
			net.WriteEntity(self)
			net.WriteBit(true)
		net.Broadcast()

		timer.Destroy("KeyCrackSounds: "..self:EntIndex())
	else
		timer.Destroy("KeyCrackDots: "..self:EntIndex())
	end
end

function SWEP:Think()
	if not self.StartCrack then
		self.StartCrack = 0
		self.EndCrack = 0
	end

	if self.IsCracking and IsValid(self.Owner) then
		local tr = self.Owner:GetEyeTrace()

		if not IsValid(tr.Entity) or tr.HitPos:Distance(self.Owner:GetShootPos()) > 50 or not tr.Entity.IsKeypad then
			self:Fail()
		elseif self.EndCrack <= CurTime() then
			self:Succeed()
		end
	else
		self.StartCrack = 0
		self.EndCrack = 0
	end
	
	self:NextThink(CurTime())
	return true
end

if(CLIENT) then
	SWEP.BoxColor = Color(10, 10, 10, 100)

	surface.CreateFont("KeypadCrack", {
		font = "Trebuchet",
		size = 18,
		weight = 600,
	})

	function SWEP:DrawHUD()
		if self.IsCracking then
			if not self.StartCrack then
				self.StartCrack = CurTime()
				self.EndCrack = CurTime() + self:GetCrackTime()
			end

			local frac = math.Clamp((CurTime() - self.StartCrack) / (self.EndCrack - self.StartCrack), 0, 1) -- Between 0 and 1 (a fraction omg segregation)
			
			local dots = self.Dots or ""
			
			local w, h = ScrW(), ScrH()
			
			local x, y = (w / 2) - 150, (h / 2) - 25
			local w, h = 300, 50
			
			draw.RoundedBox(4, x, y, w, h, self.BoxColor)
			
			surface.SetDrawColor(Color(255 + (frac * -255), frac * 255, 40))			
			surface.DrawRect(x + 5, y + 5, frac * (w - 10), h - 10)
			
			surface.SetFont("KeypadCrack")
			local fontw, fonth = surface.GetTextSize("Cracking")
			local fontx, fonty = (x + (w / 2)) - (fontw / 2), (y + (h / 2)) - (fonth / 2)
			
			surface.SetTextPos(fontx + 1, fonty+1)
			surface.SetTextColor(color_black)
			surface.DrawText("Cracking"..dots)
			
			surface.SetTextPos(fontx, fonty)
			surface.SetTextColor(color_white)
			surface.DrawText("Cracking"..dots)
		end
	end
	
	SWEP.DownAngle = Angle(-10, 0, 0)
	
	SWEP.LowerPercent = 1
	SWEP.SwayScale = 0
	
	function SWEP:GetViewModelPosition(pos, ang)
		
		
		if self.IsCracking then
			local delta = FrameTime() * 3.5
			self.LowerPercent = math.Clamp(self.LowerPercent - delta, 0, 1)
		else
			local delta = FrameTime() * 5
			self.LowerPercent = math.Clamp(self.LowerPercent + delta, 0, 1)
		end
		
		ang:RotateAroundAxis(ang:Forward(), self.DownAngle.p * self.LowerPercent)
		ang:RotateAroundAxis(ang:Right(), self.DownAngle.p * self.LowerPercent)

		return self.BaseClass.GetViewModelPosition(self, pos, ang)
	end

	net.Receive("KeypadCracker_Hold", function()
		local ent = net.ReadEntity()
		local state = (net.ReadBit() == 1)

		if IsValid(ent) and ent:IsWeapon() and ent:GetClass():lower() == "keypad_cracker" and not game.SinglePlayer() and ent.SetWeaponHoldType then
			if not state then
				ent:SetWeaponHoldType(ent.IdleStance)
				ent.IsCracking = false
			else
				ent:SetWeaponHoldType("pistol")
				ent.IsCracking = true
			end
		end
	end)
	
	net.Receive("KeypadCracker_Sparks", function()
		local ent = net.ReadEntity()
		
		if IsValid(ent) then
			local vPoint = ent:GetPos()
			local effect = EffectData()
			effect:SetStart(vPoint)
			effect:SetOrigin(vPoint)
			effect:SetEntity(ent)
			effect:SetScale(2)
			util.Effect("cball_bounce", effect)
			
			ent:EmitSound("buttons/combine_button7.wav", 100, 100)
		end
	end)
end
--addons/arccw_weapons/lua/weapons/masita_dc15a.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-15a"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The DC-15A blaster rifle, known simply as the DC-15 blaster rifle, was a heavy blaster rifle manufactured by BlasTech Industries, as part of the DC-15 family. It was one of the standard-issue weapons of the Galactic Republic's clone troopers, an army of cloned soldiers in the Grand Army of the Republic, during the Clone Wars against the Confederacy of Independent Systems."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15a.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.NoHideLeftHandInCustomization = true
SWEP.ViewModel = "models/servius/weapons/viewmodels/c_dc15a.mdl"
SWEP.WorldModel = "models/servius/weapons/worldmodels/w_dc-15a.mdl"
SWEP.ViewModelFOV = 56

SWEP.DefaultBodygroups = "010"
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 36
SWEP.RangeMin = 243
SWEP.DamageMin = 24
SWEP.Range = 510
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 55

SWEP.Recoil = 0.43
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.63
SWEP.Delay = 60 / 324
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
		Mode = -2
	},
    {
        Mode = 0
    },            
}

SWEP.AccuracyMOA = 0.50
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 50

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc15.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.66, -12.75, 2.529),
    Ang = Angle(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 2, 3)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(15, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true 
SWEP.BipodDispersion = 1
SWEP.BipodRecoil = 1 

-- Attachments
SWEP.DefaultElements = {"dc15"}
SWEP.AttachmentElements = {
    ["dc15"] = {
        WMElements = {
            {
                Model = "models/servius/weapons/worldmodels/w_dc-15a.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                WBodygroups = {{ind = 0, bg = 0}},
                Offset = {
                    pos = Vector(-550, 0, 470),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(4150, 0, -1100),
                    ang = Angle(-15, 0, 100)
                },
                IsMuzzleDevice = true
            },
        },
    },
}
WMOverride = "models/servius/weapons/worldmodels/w_dc-15a.mdl"

SWEP.Attachments = {
    {
        PrintName = "Sight",
        DefaultAttName = "Standard", 
        Slot = "optic", 
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(0.110, -3.771, 2.1),
            vang = Angle(0, -90, 0),
            wpos = Vector(420, 50, -450),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },          
    {
        PrintName = "Magazine Capacity",
        DefaultAttName = "Standard",
        Slot = {"dc15a_magazine_75"},
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(0, -3.7, 0.5),
            vang = Angle(0, 0, 90),
            wpos = Vector(550, 115, -250),
            wang = Angle(-15, -90, -90)
        },
    },      
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },   
    {
        PrintName = "Ammo", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(1.3, -6.739, 0.504),
            vang = Angle(0, -90, 0),
            wpos = Vector(115, 180, -125),
            wang = Angle(-10 , 0, 180)
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(1.1, -9, 0.7),
            vang = Angle(0, -90, 0),
            wpos = Vector(-100, 180, -75),
            wang = Angle(-15 , 0, 180)
        },
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Neutral"
    },
    ["fire"] = {
        Time = 2.3,
        Source = {"shoot", "shoot2"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_lgequip.wav",
                p = 100, 
                v = 75,
                t = 0, 
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_medequip.wav",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "dc15a_reload1", t = 2 / 10},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_03.mp3", t = 2 },
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 2 / 30},
        },
    },


sound.Add({
    name =          "dc15a_reload1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "armas/misc/dc17s_reload.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/masita_dc17_stun.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Stun DC-17"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DC-17 hand blaster, also known as DC-17 blaster pistol, was a heavy blaster pistol wielded by the clone troopers of the Grand Army of the Galactic Republic during the Clone Wars. An advanced firearm, it was fielded to elite soldiers in the army, most notably Advanced Recon Commandos, clone trooper commanders, and clone jet troopers."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc17_stun.png"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = true

SWEP.ViewModel = "models/venator/weapons/viewmodels/c_dc17.mdl"
SWEP.WorldModel = "models/venator/weapons/worldmodels/w_dc-17.mdl"
SWEP.ViewModelFOV = 58
SWEP.WorldModelOffset = {
    pos = Vector(-11.3, 4.3, -3),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 29
SWEP.RangeMin = 102
SWEP.DamageMin = 23
SWEP.Range = 299
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.98
SWEP.RecoilPunch = 0.8
SWEP.RecoilSide = 0.17
SWEP.RecoilRise = 0.24

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
		Mode = -2
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 
SWEP.HipDispersion = 530
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

---- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.922, -4.125, 0.237),
    Ang = Vector(0.158, -3.961, 0),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

SWEP.Primary.Ammo = "ar2"

-- Sound & Holdtype
SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "armas/disparos/dc17_2.wav"
SWEP.ShootSound = "armas/disparos/dc17_1.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(1, 6, 1)
SWEP.ActiveAng = Angle(-3.2, -3, 0)

SWEP.SprintPos = Vector(1, -6, -10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(10, 0, -1.08)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Attachments 
SWEP.AttachmentElements = {
    ["dc17_powerpack"] = {
        VMBodygroups = {
            {ind = 4, bg = 1},
        },
    },
    ["dc17_cooling"] = {
        VMBodygroups = {
            {ind = 3, bg = 1},
        },
    },
}


SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0, -2.3, 0),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(9, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        WMScale = Vector(0.7, 0.7, 0.7),
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0, -0.3, 2.7),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Muzzle", 
        DefaultAttName = "None", 
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0, -1.2, 3.442),
            vang = Angle(90, 0, -90),
        },
    }, 
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },        
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "sw_ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Cooling System",
        DefaultAttName = "None",
        Slot = "dc17_cooling",
    },
    {
        PrintName = "Powerpack",
        DefaultAttName = "None",
        Slot = "dc17_powerpack",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7,0.7,0.7),
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0.7, -0.848, 0.184),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0.7, -0.848, -3),
            vang = Angle(90, 0, -90),
        },
    },   
}


SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        SoundTable = {
            {s = "dc17_1", t = 1 / 60}, --s sound file
        },
    },


sound.Add({
    name =          "dc17_1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "armasclasicas/wpn_wristrocket_reload.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/masita_sb2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "SB-2"
SWEP.Trivia_Class = "Blaster Heavy Shotgun"
SWEP.Trivia_Desc = "The SB-2 was a type of blaster that could pierce through enemy defenses. It was used by the Grand Army of the Republic's clone troopers during the Clone Wars between the Galactic Republic and the Confederacy of Independent Systems. The DP-23 fired blue blaster bolts, and had a ridged barrel with a pointed muzzle, a black stock, and a small foregrip."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/sb2.png"

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/servius/weapons/viewmodels/c_sb-2.mdl"
SWEP.WorldModel = "models/servius/weapons/worldmodels/w_sb-2.mdl"
SWEP.ViewModelFOV = 55
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-5, 5, -6),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.DefaultBodygroups = "000000000000"

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1.5,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 30
SWEP.NoLastCycle = true
SWEP.ManualAction = true
SWEP.ShotgunReload = true
SWEP.RangeMin = 20
SWEP.DamageMin = 17
SWEP.Range = 50
SWEP.Penetration = 1
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 12

SWEP.Recoil = 2
SWEP.RecoilSide = 2
SWEP.RecoilPunch = 0.9
SWEP.RecoilRise = 0.9

SWEP.Delay = 60 / 73
SWEP.Num = 5
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 50 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 450 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 100

SWEP.NoFlash = nil -- disable light flash

SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "armas/disparos/sb2.wav"
SWEP.ShootSoundSilenced = "armas/disparos/silenced_sniper.mp3"

SWEP.IronSightStruct = {
    Pos = Vector(-3.724, -3.964, 2.733),
    Ang = Vector(0, 0, 3),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(-1, 4, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(.5, -6, -12)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -3, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard",
        Slot = "optic",
        Bone = "w_sb2",
        Offset = {
            vpos = Vector(0.261, 0.523, 2.338),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    }, 
    {
        PrintName = "Tactical", 
        DefaultAttName = "None",
        Slot = {"tactical","tac_pistol"},
        Bone = "w_sb2", 
        Offset = {
            vpos = Vector(0.894, 8.522, 1.233),
            vang = Angle(0, -90, 90),
        },
    },    
    {
        PrintName = "Muzzle", 
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "w_sb2",
        Offset = {
            vpos = Vector(0.2, 15.5, 1.1),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "shotgun_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None", 
        Slot = {"charm"},
        Bone = "w_sb2", 
        Offset = {
            vpos = Vector(0.796, -0.996, 1.276),
            vang = Angle(0, -90, 0),
        },
    },          
}
SWEP.Animations = {
    ["idle"] = {
        Source = "neutral"
    },
    ["fire"] = {
        Source = "shoot",
    },
    ["cycle"] = {
        Source = "pump",
        Time = 0.9,
        SoundTable = {
            {s = "armas/disparos/sb2_pump.wav", t = 0.1 / 30}, 
        },
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_10.mp3",
                p = 100, 
                v = 75, 
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["sgreload_start"] = {
        Source = "reload_start",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {
			{s = "everfall/weapons/handling/misc_handling/hard_pickups/023d-0000106a.mp3", 	t = 0/30},
			{s = "weapons/fesiugmw2/foley/wpfoly_winchester_reload_loop_v1.wav", 	t = 14/30},
		},
    },
    ["sgreload_insert"] = {
        Source = "reload_insert",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {{s = "everfall/weapons/handling/reload_shells/heavy_shells/023d-00000777.mp3", 		t = 3/30}},
        RestoreAmmo = 1,
    },
    ["sgreload_finish"] = {
        Source = {"reload_finish"},
        SoundTable = {{s = "armas/disparos/sb2_pump.wav", 		t = 8/30}},
    },


sound.Add({
    name =          "ArcCW_dc15a.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/heavy.wav"
    }),
}

--lua/weapons/tesla_katana/shared.lua:
SWEP.Author       = "Killua"
SWEP.PrintName    = "Tesla katana"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Tesla"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee2"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 50
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-47.778, 0, 0) }
}
SWEP.VElements = {
	["hils++"] = { type = "Model", model = "models/items/battery.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, -0.201, 4.8), angle = Angle(0, 90, 0), size = Vector(0.1, 0.3, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/items/battery.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0.2, 4.8), angle = Angle(0, -90, 0), size = Vector(0.1, 0.3, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blade++"] = { type = "Model", model = "models/hunter/triangles/1x1x1carved025.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 15), angle = Angle(180, 45, 0), size = Vector(0.014, 0.014, 0.5), color = Color(0, 255, 255, 255), surpresslightning = false, material = "effects/tp_eyefx/tpeye2", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/triangles/1x1x1carved025.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 15), angle = Angle(180, 45, 0), size = Vector(0.014, 0.014, 0.5), color = Color(0, 255, 255, 255), surpresslightning = false, material = "effects/tvscreen_noise002a", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/hunter/triangles/1x1x1carved025.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 15), angle = Angle(180, 45, 0), size = Vector(0.014, 0.014, 0.5), color = Color(0, 255, 255, 255), surpresslightning = false, material = "effects/tp_eyefx/tpeye", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 45, 0), size = Vector(0.05, 0.039, 0.109), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/bluemetal", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils++"] = { type = "Model", model = "models/items/battery.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, -0.201, 4.8), angle = Angle(0, 90, 0), size = Vector(0.1, 0.3, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} },
	["blade++"] = { type = "Model", model = "models/hunter/triangles/1x1x1carved025.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 15), angle = Angle(180, 45, 0), size = Vector(0.014, 0.014, 0.5), color = Color(0, 255, 255, 255), surpresslightning = false, material = "effects/tp_eyefx/tpeye2", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 50, 8), size = Vector(0.05, 0.039, 0.109), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/bluemetal", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/items/battery.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0.2, 4.8), angle = Angle(0, -90, 0), size = Vector(0.1, 0.3, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/triangles/1x1x1carved025.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 15), angle = Angle(180, 45, 0), size = Vector(0.014, 0.014, 0.5), color = Color(0, 255, 255, 255), surpresslightning = false, material = "effects/tvscreen_noise002a", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/hunter/triangles/1x1x1carved025.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 15), angle = Angle(180, 45, 0), size = Vector(0.014, 0.014, 0.5), color = Color(0, 255, 255, 255), surpresslightning = false, material = "effects/tp_eyefx/tpeye", skin = 0, bodygroup = {} }
}


SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 34
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.26
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 16

SWEP.Secondary.Life        = true
SWEP.Secondary.Damage 	   = 68
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
dmg:SetDamageType(DMG_DISSOLVE)
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"
bullet.Callback = function(attacker, trace, dmginfo)
		dmginfo:SetDamageType(DMG_DISSOLVE)
	end

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
dmg:SetDamageType(DMG_DISSOLVE)
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/weapons_other/lua/weapons/weapon_breachingcharge/shared.lua:
////////////////////////////////////////////////////////////////
//  Breaching Charge, Weapon
//  Programmed by Sevan Buechele
//  @   Copyright 2018 © Sevan Buechele
//  @   All Rights Reserved.
/////////////////////////////////////////////////////////////

/*|Prevent Item Stack|*/
hook.Add("PlayerCanPickupWeapon","PreventItemStack",function(ply,wep)
	if string.StartWith(wep:GetClass(),"weapon_breachingcharge") then
		if ply:HasWeapon(wep:GetClass()) then
			return false
		end
	end
end)

/*|Weapon Configuration|*/
SWEP.Category		= "AOCRP - Eingestellte Waffen"
SWEP.PrintName		= "Detpack"
SWEP.Author			= "Sevan Buechele"
SWEP.Contact		= "STEAM_0:1:65313765"
SWEP.Spawnable		= true
SWEP.AdminOnly		= true
SWEP.WorldModel		= "models/props/starwars/weapons/detpack.mdl"
SWEP.ViewModelFOV	= 60
SWEP.UseHands		= false
AddCSLuaFile()

/*Weapon Initialization|*/
function SWEP:Initialize()
	self.Instructions			=	"Primary fire to detonate. Secondary fire to plant."
	self.AutoSwitchFrom			=	false
	self.Primary.ClipSize		=	-1
	self.Primary.DefaultClip	=	-1
	self.Primary.Automatic		=	false
	self.Primary.Ammo			=	"none"
	self.Secondary.ClipSize		=	-1
	self.Secondary.DefaultClip	=	-1
	self.Secondary.Automatic	=	false
	self.Secondary.Ammo			=	"none"
	self.DrawAmmo				=	false
	self.DrawCrosshair			=	false
	self.Weight					=	300
	self.SwayScale				=	1
	self.BobScale				=	1.2
	self.offset_roll			=	0
	self.offset_pitch			=	0
	self.bombs					=	{}
	self.firstgiven				=	false
	self.reloadclock			=	CurTime()
	self:SetHoldType("slam")
	if CLIENT then
		self.wmodel				=	ClientsideModel("models/props/starwars/weapons/detpack.mdl")
		self.wmodel:SetNoDraw(true)
		self.wmodel2			=	ClientsideModel("models/minic23/csgo/breach_charge_detonator.mdl")
		self.wmodel2:SetNoDraw(true)
		self.wmodel2:SetBodygroup(0,1)
		self.vmodel				=	ClientsideModel("models/props/starwars/weapons/detpack.mdl",RENDERGROUP_VIEWMODEL)
		self.vmodel:SetNoDraw(true)
		self.vmodel2			=	ClientsideModel("models/minic23/csgo/breach_charge_detonator.mdl",RENDERGROUP_VIEWMODEL)
		self.vmodel2:SetNoDraw(true)
		self.vmodel2:SetBodygroup(0,1)
		util.PrecacheModel("models/minic23/csgo/breach_charge.mdl")
	end
	local vmfix = GetConVar("sv_breachingcharge_debughands"):GetInt()
	if vmfix == 1 then
		self.ValveBiped = ""
		self.ViewModel = "models/weapons/v_slam.mdl"
	else
		self.ValveBiped = "ValveBiped."
		self.ViewModel = "models/weapons/c_slam.mdl"
	end
end

/*|Equip|*/
function SWEP:Equip(ply)
	if self.firstgiven == false then
		local ammo = 6
	--	local cvar = GetConVar("sv_breachingcharge_startingammo")
		if cvar then
			ammo = cvar:GetInt()
		end
		ply:GiveAmmo(ammo,"ammo_breachingcharge")
		self.firstgiven = true
	end
	self.Owner = ply
	self.LOwner = self.Owner
	self:CreatePreview("models/props/starwars/weapons/detpack.mdl",Vector(0,0,0),Angle(0,0,0))
end

/*|Deploy|*/
function SWEP:Deploy()
end

/*|Trigger|*/
function SWEP:PrimaryAttack()
	if IsFirstTimePredicted() then
		if SERVER and self.bombs then
			for k,v in pairs(self.bombs) do
				if v:IsValid() then
					v:Explode()
				end
			end
		end
		self.bombs = {}
		if self.Owner:IsValid() then
			if self.Owner:GetAmmoCount("ammo_breachingcharge") <= 0 then
				self:EmitSound("weapons/pistol/pistol_empty.wav")
			end
		end
		self:SetNextPrimaryFire(CurTime()+0.5)
	end
end
function SWEP:SecondaryAttack()
	if IsFirstTimePredicted() then
		local pos,ang = self:GetSelection()
		if pos ~= Vector(0,0,0) and self.Owner:GetAmmoCount("ammo_breachingcharge") > 0 then
			self:EmitSound("npc/combine_soldier/gear5.wav")
			if SERVER then
				local ent = ents.Create("sent_breachingcharge")
				ent:SetPos(pos)
				ent:SetAngles(ang)
				ent:SetModel("models/props/starwars/weapons/detpack.mdl")
				ent:Spawn()
				table.insert(self.bombs,ent)
				if self.doorparent then
					ent:SetParent(self.doorparent)
				elseif self.otherparent then
					ent:SetParent(self.otherparent)
				end
			end
			self.Owner:SetAmmo(math.Clamp(self.Owner:GetAmmoCount("ammo_breachingcharge")-1,0,11),"ammo_breachingcharge")
		end
		self:SetNextSecondaryFire(CurTime()+0.5)
	end
end

--[[/*|Reload|*/
function SWEP:Reload()
	if game.SinglePlayer() == false then
		if IsFirstTimePredicted() then
			self.LOwner = self.Owner
			if SERVER then
				self.Owner:DropWeapon(self)
			end
			self:Holster()
		end
	else
		if self.reloadclock < CurTime() then
			self.Owner:ChatPrint("You cannot drop this in single player.")
			self.reloadclock = CurTime()+1
			if self.Owner:GetAmmoCount("ammo_breachingcharge") < 1 then
				self:Remove()
			end
		end
	end
end
]]

/*|Selection Result|*/
function SWEP:GetSelection()
	--local cvar = GetConVar("sv_breachingcharge_canplace"):GetInt()
--	local cvar == "2"
	local pos,ang = Vector(0,0,0),Angle(0,0,0)
	local trace = self.Owner:GetEyeTrace()
	local ondoor
	if trace.Entity:IsValid() then
		ondoor = (trace.Entity:GetClass() == "func_door" || trace.Entity:GetClass() == "prop_door_rotating" || trace.Entity:GetClass() == "func_door_rotating")
	end
	if ondoor then
		self.doorparent = trace.Entity
	elseif trace.Entity:IsValid() and trace.HitWorld == false then
		self.otherparent = trace.Entity
	end
	if (trace.HitWorld || ondoor) and trace.HitPos:DistToSqr(self.Owner:GetPos()) <= 10000 then
		pos = trace.HitPos
		ang = trace.HitNormal:Angle()
		ang:RotateAroundAxis(trace.HitNormal:Angle():Forward(),-180)
		ang:RotateAroundAxis(trace.HitNormal:Angle():Right(),90)
	end
	return pos,ang
end

/*|Viewmodel Reset|*/
function SWEP:Holster()
	if self.Owner:IsValid() and self:IsValid() then
		local vm = self.Owner:GetViewModel()
		if !(vm:IsValid()) then return end
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale(i,Vector(1,1,1))
			vm:ManipulateBoneAngles(i,Angle(0,0,0))
			vm:ManipulateBonePosition(i,Vector(0,0,0))
		end
	end
	self:DeletePreview()
	return true
end
function SWEP:OnRemove()
	if CLIENT then
		self.wmodel:Remove()
		self.wmodel2:Remove()
		self.vmodel:Remove()
	end
	self:PrimaryAttack()
	self:Holster()
end
function SWEP:OwnerChanged()
	if self.LOwner and self:IsValid() then
		local vm = self.LOwner:GetViewModel()
		if !(vm:IsValid()) then return end
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale(i,Vector(1,1,1))
			vm:ManipulateBoneAngles(i,Angle(0,0,0))
			vm:ManipulateBonePosition(i,Vector(0,0,0))
		end
	end
end

/*|Viewmodel Overide|*/
function SWEP:ViewModelDrawn()
	local vm = self.Owner:GetViewModel()
	local righthand = vm:LookupBone(self.ValveBiped.."Bip01_R_Clavicle")
	local lefthand = vm:LookupBone(self.ValveBiped.."Bip01_L_Clavicle")
	local base = vm:LookupBone("Slam_base")
	local deto = vm:LookupBone("Detonator")
	local bonematrix = vm:GetBoneMatrix(vm:LookupBone(self.ValveBiped.."Bip01_R_Hand"))
	vm:ManipulateBonePosition(base,Vector(0,-100,0))
	vm:ManipulateBonePosition(deto,Vector(0,-100,0))
	vm:ManipulateBonePosition(lefthand,Vector(0,-100,0))
	if self.Owner:GetAmmoCount("ammo_breachingcharge") > 0 and bonematrix then
		local offset = self.vmoffset or Vector(6,4,2)
		local angle = self.vmangle or Angle(120,190,-50)
		local posm,angm = LocalToWorld(offset,angle,bonematrix:GetTranslation(),bonematrix:GetAngles())
		self.vmodel:SetPos(posm)
		self.vmodel:SetAngles(angm)
		self.vmodel:SetModelScale(1.3,0)
		self.vmodel:SetupBones()
		self.vmodel:DrawModel()
	elseif self.Owner:GetAmmoCount("ammo_breachingcharge") <= 0 and bonematrix then
		local offset = self.vmoffset or Vector(3,-2,0)
		local angle = self.vmangle or Angle(180,230,0)
		local posm,angm = LocalToWorld(offset,angle,bonematrix:GetTranslation(),bonematrix:GetAngles())
		self.vmodel2:SetPos(posm)
		self.vmodel2:SetAngles(angm)
		self.vmodel2:SetModelScale(1.6,0)
		self.vmodel2:SetupBones()
		self.vmodel2:DrawModel()
	end
end
function SWEP:GetViewModelPosition(pos,ang)
	if !self.Owner:IsValid() then return end
	if self.Owner:KeyDown(IN_MOVELEFT) then
		self.offset_roll = Lerp(2*RealFrameTime(),self.offset_roll,-12)
	elseif self.Owner:KeyDown(IN_MOVERIGHT) then
		self.offset_roll = Lerp(2*RealFrameTime(),self.offset_roll,6)
	else
		self.offset_roll = Lerp(2*RealFrameTime(),self.offset_roll,0)
	end
	if math.abs(self.offset_roll) < 0.1 then
		self.offset_roll = 0
	end
	if self.Owner:KeyDown(IN_FORWARD) then
		if self.Owner:KeyDown(IN_SPEED) then
			self.offset_pitch = Lerp(2*RealFrameTime(),self.offset_pitch,2)
		else
			self.offset_pitch = Lerp(2*RealFrameTime(),self.offset_pitch,1)
		end
	else
		self.offset_pitch = Lerp(2*0.01,self.offset_pitch,0)
	end
	ang = ang+Angle(self.offset_pitch,0,self.offset_roll)
	if self.Owner:GetAmmoCount("ammo_breachingcharge") <= 0 then
		local vm = self.Owner:GetViewModel()
		local bone = vm:LookupBone(self.ValveBiped.."Bip01_R_Clavicle")
		vm:ManipulateBonePosition(bone,Vector(-1,0,-7))
	else
		ang:RotateAroundAxis(ang:Right(),6)
		local vm = self.Owner:GetViewModel()
		local bone = vm:LookupBone(self.ValveBiped.."Bip01_R_Clavicle")
		vm:ManipulateBonePosition(bone,Vector(-3,0,-6))
	end
	return pos,ang
end
function SWEP:DrawWorldModel()
	if self.Owner:IsValid() then
		local wm = self.Owner
		local bone = wm:LookupBone(self.ValveBiped.."Bip01_R_Hand")
		local bonematrix = wm:GetBoneMatrix(bone)
		if bonematrix then
			local mdl
			local offset
			local angle
			local pos,ang
			if IsValid(mdl) then
				if self.Owner:GetAmmoCount("ammo_breachingcharge") <= 0 then
					mdl = self.wmodel2
					offset = self.wmoffset or Vector(2,-2,0)
					angle = self.wmangle or Angle(200,200,-4)
					pos,ang = LocalToWorld(offset,angle,bonematrix:GetTranslation(),bonematrix:GetAngles())
					mdl:SetModelScale(1.2,0)
				else
					mdl = self.wmodel
					offset = self.wmoffset or Vector(6,-5,0)
					angle = self.wmangle or Angle(110,200,-4)
					pos,ang = LocalToWorld(offset,angle,bonematrix:GetTranslation(),bonematrix:GetAngles())
				--	mdl:SetModelScale(1,0)
				end
		--		mdl:SetPos(pos)
				mdl:SetAngles(ang)
				mdl:SetupBones()
				mdl:DrawModel()
			end
		end
	else
		if self then
			self:DrawModel()
		end
	end
end

/*|Display Overide|*/
if CLIENT then
	function SWEP:CustomAmmoDisplay()
		self.AmmoDisplay = self.AmmoDisplay or {}
		self.AmmoDisplay.Draw = false
		return self.AmmoDisplay
	end
end

/*|Selection Preview|*/
function SWEP:CreatePreview(mdl,pos,ang)
	util.PrecacheModel(mdl)
	if SERVER and game.SinglePlayer() == false then return end
	if self.PreviewLastDelete and self.PreviewLastDelete + 0.4 > CurTime() then return end
	self:DeletePreview()
	if util.IsValidProp(mdl) then
		if CLIENT then
			self.PreviewEnt = ents.CreateClientProp(mdl)
		else
			self.PreviewEnt = ents.Create("prop_physics")
		end
		if self.PreviewEnt:IsValid() == false then
			self.PreviewEnt = nil
			print("Failed to create preview.")
		end
		self.PreviewEnt:SetModel(mdl)
		self.PreviewEnt:SetModelScale(1.4,0)
		self.PreviewEnt:SetPos(pos)
		self.PreviewEnt:SetAngles(ang)
		self.PreviewEnt:PhysicsInit(SOLID_VPHYSICS)
		self.PreviewEnt:SetNotSolid(true)
		self.PreviewEnt:SetRenderMode(RENDERMODE_TRANSALPHA)
		self.PreviewEnt:SetMoveType(MOVETYPE_NONE)
		self.PreviewEnt:Spawn()
		self.PreviewEnt:SetColor(Color(140,200,255))
		self.PreviewEnt:SetMaterial("models/wireframe")
		self.PreviewEnt:SetNoDraw(true)
	end
end
function SWEP:DeletePreview()
	if self.PreviewEnt then
		if self.PreviewEnt:IsValid() == false then
			self.PreviewEnt = nil
			print("Could not find preview to delete.")
		else
			self.PreviewLastDelete = CurTime()
			self.PreviewEnt:Remove()
			self.PreviewEnt = nil
		end
	end
end
function SWEP:UpdatePreview(ent,ply)
	if ent == nil then return end
	if ent:IsValid() then
		pos,ang = self:GetSelection()
		ent:SetPos(pos)
		ent:SetAngles(ang)
		ent:SetNoDraw(false)
	end
	if self.Owner:GetAmmoCount("ammo_breachingcharge") > 0 then
		return
	else
		ent:SetNoDraw(true)
	end
end
function SWEP:Think()
	if CLIENT then
		if !IsValid(self.PreviewEnt) or self.PreviewEnt:GetModel()!=self.pview then
			self.pview = "models/props/starwars/weapons/detpack.mdl"
			self:CreatePreview(self.pview,Vector(0,0,0),Angle(0,0,0))
		end
		self:UpdatePreview(self.PreviewEnt,self.Owner)
	end
end
--addons/weapons_other/lua/weapons/weapon_cuff_base.lua:
-------------------------------------

---------------- Cuffs --------------

-------------------------------------

-- Copyright (c) 2015 Nathan Healy --

-------- All rights reserved --------

-------------------------------------

-- weapon_cuff_base.lua     SHARED --

--                                 --

-- Base swep for handcuffs.        --

-------------------------------------



AddCSLuaFile()



SWEP.Base = "weapon_base"



SWEP.Category = "Handcuffs"

SWEP.Author = "my_hat_stinks"

SWEP.Instructions = ""



SWEP.Spawnable = false

SWEP.AdminOnly = false

SWEP.AdminSpawnable = false



SWEP.Slot = 3

SWEP.PrintName = "UnnamedHandcuff"



SWEP.ViewModelFOV = 60

SWEP.Weight = 5

SWEP.AutoSwitchTo = false

SWEP.AutoSwitchFrom = false



SWEP.WorldModel = "models/weapons/w_toolgun.mdl"

SWEP.ViewModel = "models/weapons/c_bugbait.mdl"

SWEP.UseHands = true



SWEP.Primary.Recoil = 1

SWEP.Primary.Damage = 5

SWEP.Primary.NumShots = 1

SWEP.Primary.Cone = 0

SWEP.Primary.Delay = 0.25



SWEP.Primary.ClipSize = -1

SWEP.Primary.DefaultClip = -1

SWEP.Primary.Automatic = true

SWEP.Primary.Ammo = "none"

SWEP.Primary.ClipMax = -1



SWEP.Secondary.ClipSize = -1

SWEP.Secondary.DefaultClip = -1

SWEP.Secondary.Automatic = false

SWEP.Secondary.Ammo = "none"

SWEP.Secondary.ClipMax = -1



SWEP.DeploySpeed = 1.5



SWEP.Spawnable = false

SWEP.AdminSpawnable = false

SWEP.AdminOnly = false



SWEP.PrimaryAnim = ACT_VM_PRIMARYATTACK

SWEP.ReloadAnim = ACT_VM_RELOAD

SWEP.HoldType = "slam"



SWEP.Spawnable = false

SWEP.AdminSpawnable = false

SWEP.AdminOnly = false



//

// Handcuff Vars

SWEP.CuffTime = 1.0 // Seconds to handcuff

SWEP.CuffSound = Sound( "buttons/lever7.wav" )



SWEP.CuffMaterial = "phoenix_storms/metalfloor_2-3"

SWEP.CuffRope = "cable/cable2"



SWEP.CuffStrength = 1

SWEP.CuffRegen = 1

SWEP.RopeLength = 0



SWEP.CuffReusable = false // Can reuse (ie, not removed on use)

SWEP.CuffRecharge = 10 // Time before re-use



SWEP.CuffBlindfold = false

SWEP.CuffGag = false



SWEP.CuffStrengthVariance = 0 // Randomise strangth

SWEP.CuffRegenVariance = 0 // Randomise regen



//

// Network Vars

function SWEP:SetupDataTables()

	self:NetworkVar( "Bool", 0, "IsCuffing" )

	self:NetworkVar( "Entity", 0, "Cuffing" )

	self:NetworkVar( "Float", 0, "CuffTime" )

end



//

// Standard SWEP functions

function SWEP:PrimaryAttack()

	if self:GetIsCuffing() then return end

	

	self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )

	self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )

	

	if CLIENT then return end

	if self:GetCuffTime()>CurTime() then return end // On cooldown

	

	local tr = self:TargetTrace()

	if not tr then return end

	

	self:SetCuffTime( CurTime() + self.CuffTime )

	self:SetIsCuffing( true )

	self:SetCuffing( tr.Entity )

	

	sound.Play( self.CuffSound, self.Owner:GetShootPos(), 75, 100, 1 )

end

function SWEP:SecondaryAttack()

end

function SWEP:Reload()

end



function SWEP:Initialize()

	self:SetHoldType( self.HoldType )

	

	if engine.ActiveGamemode()=="dayz" then self.CuffReusable = false end

end

function SWEP:Holster()

	if CLIENT and IsValid(self.Owner) and self.Owner==LocalPlayer() then

		local vm = self.Owner:GetViewModel()

		if not IsValid(vm) then return end

		

		vm:SetMaterial( "" )

	end

	if IsValid(self.cmdl_RightCuff) then self.cmdl_RightCuff:Remove() end

	if IsValid(self.cmdl_LeftCuff) then self.cmdl_LeftCuff:Remove() end

	

	return true

end

SWEP.OnRemove = SWEP.Holster



//

// Handcuff

function SWEP:DoHandcuff( target )

	if not (target and IsValid(target)) then return end

	if target:IsHandcuffed() then return end

	if not IsValid(self.Owner) then return end

	

	local cuff = target:Give( "weapon_handcuffed" )

	cuff:SetCuffStrength( self.CuffStrength + (math.Rand(-self.CuffStrengthVariance,self.CuffStrengthVariance)) )

	cuff:SetCuffRegen( self.CuffRegen + (math.Rand(-self.CuffRegenVariance,self.CuffRegenVariance)) )

	

	cuff:SetCuffMaterial( self.CuffMaterial )

	cuff:SetRopeMaterial( self.CuffRope )

	

	cuff:SetKidnapper( self.Owner )

	cuff:SetRopeLength( self.RopeLength )

	

	cuff:SetCanBlind( self.CuffBlindfold )

	cuff:SetCanGag( self.CuffGag )

	

	cuff.CuffType = self:GetClass() or ""

	

	hook.Call( "OnHandcuffed", GAMEMODE, self.Owner, target, cuff )

	

	if not self.CuffReusable then

		if IsValid(self.Owner) then self.Owner:ConCommand( "lastinv" ) end

		self:Remove()

	end

end



//

// Think

function SWEP:Think()

	if SERVER then

		if self:GetIsCuffing() then

			local tr = self:TargetTrace()

			if (not tr) or tr.Entity~=self:GetCuffing() then

				self:SetIsCuffing(false)

				self:SetCuffTime( 0 )

				return

			end

			

			if CurTime()>self:GetCuffTime() then

				self:SetIsCuffing( false )

				self:SetCuffTime( CurTime() + self.CuffRecharge )

				self:DoHandcuff( self:GetCuffing() )

			end

		end

	end

end



//

// Get Target

function SWEP:TargetTrace()

	if not IsValid(self.Owner) then return end

	

	local tr = util.TraceLine( {start=self.Owner:GetShootPos(), endpos=(self.Owner:GetShootPos() + (self.Owner:GetAimVector()*50)), filter={self, self.Owner}} )

	if IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity~=self.Owner and not tr.Entity:IsHandcuffed() then

		if hook.Run( "CuffsCanHandcuff", self.Owner, tr.Entity )==false then return end

		return tr

	end

end



//

// HUD

local Col = {

	Text = Color(255,255,255), TextShadow = Color(0,0,0),

	

	BoxOutline = Color(0,0,0), BoxBackground = Color(255,255,255,20), BoxLeft = Color(255,0,0), BoxRight = Color(0,255,0),

}

local matGrad = Material( "gui/gradient" )

function SWEP:DrawHUD()

	if not self:GetIsCuffing() then

		if self:GetCuffTime()<=CurTime() then return end

		

		local w,h = (ScrW()/2), (ScrH()/2)

		

		surface.SetDrawColor( Col.BoxOutline )

		surface.DrawOutlinedRect( w-101, h+54, 202, 22 )

		surface.SetDrawColor( Col.BoxBackground )

		surface.DrawRect( w-100, h+55, 200, 20 )

		

		local CuffingPercent = math.Clamp( ((self:GetCuffTime()-CurTime())/self.CuffRecharge), 0, 1 )

		render.SetScissorRect( w-100, h+55, (w-100)+(CuffingPercent*200), h+75, true )

			surface.SetDrawColor( Col.BoxRight )

			surface.DrawRect( w-100,h+55, 200,20 )

			

			surface.SetMaterial( matGrad )

			surface.SetDrawColor( Col.BoxLeft )

			surface.DrawTexturedRect( w-100,h+55, 200,20 )

		render.SetScissorRect( 0,0,0,0, false )

		

		return

	end

	

	local w,h = (ScrW()/2), (ScrH()/2)

	

	draw.SimpleText( "Lege Handschellen an...", "HandcuffsText", w+1, h+31, Col.TextShadow, TEXT_ALIGN_CENTER )

	draw.SimpleText( "Lege Handschellen an...", "HandcuffsText", w, h+30, Col.Text, TEXT_ALIGN_CENTER )

	

	surface.SetDrawColor( Col.BoxOutline )

	surface.DrawOutlinedRect( w-101, h+54, 202, 22 )

	surface.SetDrawColor( Col.BoxBackground )

	surface.DrawRect( w-100, h+55, 200, 20 )

	

	local CuffingPercent = math.Clamp( 1-((self:GetCuffTime()-CurTime())/self.CuffTime), 0, 1 )

	

	render.SetScissorRect( w-100, h+55, (w-100)+(CuffingPercent*200), h+75, true )

		surface.SetDrawColor( Col.BoxRight )

		surface.DrawRect( w-100,h+55, 200,20 )

		

		surface.SetMaterial( matGrad )

		surface.SetDrawColor( Col.BoxLeft )

		surface.DrawTexturedRect( w-100,h+55, 200,20 )

	render.SetScissorRect( 0,0,0,0, false )

end



//

// Rendering

local renderpos = {

	left = {pos=Vector(0,0,0), vel=Vector(0,0,0), gravity=1, ang=Angle(0,30,90)},

	right = {bone = "ValveBiped.Bip01_R_Hand", pos=Vector(3.2,2.1,0.4), ang=Angle(-2,0,80), scale = Vector(0.045,0.045,0.03)},

	rope = {l = Vector(0,0,2.0), r = Vector(2.3,-1.9,2.7)},

}

local CuffMdl = "models/hunter/tubes/tube2x2x1.mdl"

local RopeCol = Color(255,255,255)

function SWEP:ViewModelDrawn( vm )

	if not IsValid(vm) then return end

	

	vm:SetMaterial( "engine/occlusionproxy" )

	

	if not IsValid(self.cmdl_LeftCuff) then

		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )

		self.cmdl_LeftCuff:SetNoDraw( true )

		self.cmdl_LeftCuff:SetParent( vm )

		

		renderpos.left.pos = self.Owner:GetPos()

	end

	if not IsValid(self.cmdl_RightCuff) then

		self.cmdl_RightCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )

		self.cmdl_RightCuff:SetNoDraw( true )

		self.cmdl_RightCuff:SetParent( vm )

	end

	

	-- local lpos, lang = self:GetBonePos( renderpos.left.bone, vm )

	local rpos, rang = self:GetBonePos( renderpos.right.bone, vm )

	if not (rpos and rang) then return end

	

	// Right

	local fixed_rpos = rpos + (rang:Forward()*renderpos.right.pos.x) + (rang:Right()*renderpos.right.pos.y) + (rang:Up()*renderpos.right.pos.z)

	self.cmdl_RightCuff:SetPos( fixed_rpos )

	local u,r,f = rang:Up(), rang:Right(), rang:Forward() // Prevents moving axes

	rang:RotateAroundAxis( u, renderpos.right.ang.y )

	rang:RotateAroundAxis( r, renderpos.right.ang.p )

	rang:RotateAroundAxis( f, renderpos.right.ang.r )

	self.cmdl_RightCuff:SetAngles( rang )

	

	local matrix = Matrix()

	matrix:Scale( renderpos.right.scale )

	self.cmdl_RightCuff:EnableMatrix( "RenderMultiply", matrix )

	

	self.cmdl_RightCuff:SetMaterial( self.CuffMaterial )

	self.cmdl_RightCuff:DrawModel()

	

	// Left

	if CurTime()>(renderpos.left.NextThink or 0) then

		local dist = renderpos.left.pos:Distance( fixed_rpos )

		if dist>100 then

			renderpos.left.pos = fixed_rpos

			renderpos.left.vel = Vector(0,0,0)

		elseif dist > 10 then

			local target = (fixed_rpos - renderpos.left.pos)*0.3

			renderpos.left.vel.x = math.Approach( renderpos.left.vel.x, target.x, 1 )

			renderpos.left.vel.y = math.Approach( renderpos.left.vel.y, target.y, 1 )

			renderpos.left.vel.z = math.Approach( renderpos.left.vel.z, target.z, 3 )

		end

		

		renderpos.left.vel.x = math.Approach( renderpos.left.vel.x, 0, 0.5 )

		renderpos.left.vel.y = math.Approach( renderpos.left.vel.y, 0, 0.5 )

		renderpos.left.vel.z = math.Approach( renderpos.left.vel.z, 0, 0.5 )

		-- if renderpos.left.vel:Length()>10 then renderpos.left.vel:Mul(0.1) end

		

		local targetZ = ((fixed_rpos.z - 10) - renderpos.left.pos.z) * renderpos.left.gravity

		renderpos.left.vel.z = math.Approach( renderpos.left.vel.z, targetZ, 3 )

		

		renderpos.left.pos:Add( renderpos.left.vel )

		

		-- renderpos.left.NextThink = CurTime()+0.01

	end

	

	self.cmdl_LeftCuff:SetPos( renderpos.left.pos )

	self.cmdl_LeftCuff:SetAngles( renderpos.left.ang )

	

	-- self.cmdl_LeftCuff:SetAngles( rang )

	local matrix = Matrix()

	matrix:Scale( renderpos.right.scale )

	self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )

	

	self.cmdl_LeftCuff:SetMaterial( self.CuffMaterial )

	self.cmdl_LeftCuff:DrawModel()

	

	// Rope

	if not self.RopeMat then self.RopeMat = Material(self.CuffRope) end

	

	render.SetMaterial( self.RopeMat )

	render.DrawBeam( renderpos.left.pos + renderpos.rope.l,

		rpos + (rang:Forward()*renderpos.rope.r.x) + (rang:Right()*renderpos.rope.r.y) + (rang:Up()*renderpos.rope.r.z),

		0.7, 0, 5, RopeCol )

end



SWEP.wrender = {

	left = {pos=Vector(0,0,0), vel=Vector(0,0,0), gravity=1, ang=Angle(0,30,90)},

	right = {bone = "ValveBiped.Bip01_R_Hand", pos=Vector(2.95,2.5,-0.2), ang=Angle(30,0,90), scale = Vector(0.044,0.044,0.044)},

	rope = {l = Vector(0,0,2), r = Vector(3,-1.65,1)},

}

function SWEP:DrawWorldModel()

	if not IsValid(self.Owner) then return end

	local wrender = self.wrender

	

	if not IsValid(self.cmdl_LeftCuff) then

		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )

		self.cmdl_LeftCuff:SetNoDraw( true )

	end

	if not IsValid(self.cmdl_RightCuff) then

		self.cmdl_RightCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )

		self.cmdl_RightCuff:SetNoDraw( true )

	end

	

	local rpos, rang = self:GetBonePos( wrender.right.bone, self.Owner )

	if not (rpos and rang) then return end

	

	// Right

	local fixed_rpos = rpos + (rang:Forward()*wrender.right.pos.x) + (rang:Right()*wrender.right.pos.y) + (rang:Up()*wrender.right.pos.z)

	self.cmdl_RightCuff:SetPos( fixed_rpos )

	local u,r,f = rang:Up(), rang:Right(), rang:Forward() // Prevents moving axes

	rang:RotateAroundAxis( u, wrender.right.ang.y )

	rang:RotateAroundAxis( r, wrender.right.ang.p )

	rang:RotateAroundAxis( f, wrender.right.ang.r )

	self.cmdl_RightCuff:SetAngles( rang )

	

	local matrix = Matrix()

	matrix:Scale( wrender.right.scale )

	self.cmdl_RightCuff:EnableMatrix( "RenderMultiply", matrix )

	

	self.cmdl_RightCuff:SetMaterial( self.CuffMaterial )

	self.cmdl_RightCuff:DrawModel()

	

	// Left

	if CurTime()>(wrender.left.NextThink or 0) then

		local dist = wrender.left.pos:Distance( fixed_rpos )

		if dist>100 then

			wrender.left.pos = fixed_rpos

			wrender.left.vel = Vector(0,0,0)

		elseif dist > 10 then

			local target = (fixed_rpos - wrender.left.pos)*0.3

			wrender.left.vel.x = math.Approach( wrender.left.vel.x, target.x, 1 )

			wrender.left.vel.y = math.Approach( wrender.left.vel.y, target.y, 1 )

			wrender.left.vel.z = math.Approach( wrender.left.vel.z, target.z, 3 )

		end

		

		wrender.left.vel.x = math.Approach( wrender.left.vel.x, 0, 0.5 )

		wrender.left.vel.y = math.Approach( wrender.left.vel.y, 0, 0.5 )

		wrender.left.vel.z = math.Approach( wrender.left.vel.z, 0, 0.5 )

		-- if wrender.left.vel:Length()>10 then wrender.left.vel:Mul(0.1) end

		

		local targetZ = ((fixed_rpos.z - 10) - wrender.left.pos.z) * wrender.left.gravity

		wrender.left.vel.z = math.Approach( wrender.left.vel.z, targetZ, 3 )

		

		wrender.left.pos:Add( wrender.left.vel )

		

		-- wrender.left.NextThink = CurTime()+0

	end

	

	self.cmdl_LeftCuff:SetPos( wrender.left.pos )

	self.cmdl_LeftCuff:SetAngles( wrender.left.ang )

	

	local matrix = Matrix()

	matrix:Scale( wrender.right.scale )

	self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )

	

	self.cmdl_LeftCuff:SetMaterial( self.CuffMaterial )

	self.cmdl_LeftCuff:DrawModel()

	

	// Rope

	if not self.RopeMat then self.RopeMat = Material(self.CuffRope) end

	

	render.SetMaterial( self.RopeMat )

	render.DrawBeam( wrender.left.pos + wrender.rope.l,

		rpos + (rang:Forward()*wrender.rope.r.x) + (rang:Right()*wrender.rope.r.y) + (rang:Up()*wrender.rope.r.z),

		0.7, 0, 5, RopeCol )

end



//

// Bones

function SWEP:GetBonePos( bonename, vm )

	local bone = vm:LookupBone( bonename )

	if not bone then return end

	

	local pos,ang = Vector(0,0,0),Angle(0,0,0)

	local matrix = vm:GetBoneMatrix( bone )

	if matrix then

		pos = matrix:GetTranslation()

		ang = matrix:GetAngles()

	end

	

	if self.ViewModelFlip then ang.r = -ang.r end

	

	-- if pos.x==0 and pos.y==0 and pos.z==0 then print( bonename, vm ) end

	return pos, ang

end


--gamemodes/starwarsrp/entities/weapons/weapon_rakghoul/shared.lua:
SWEP.Base 				= "weapon_base"

SWEP.PrintName			= "Rakghoul SWEP"
SWEP.Category			= "Other"

SWEP.Author				= "Deltaa"
SWEP.Purpose			= "Linksklick: Schlage einen Spieler \nRechtsklick: Springe!"
SWEP.Slot				= 0
SWEP.SlotPos			= 1
SWEP.DrawAmmo			= false

SWEP.Spawnable			= false
SWEP.AdminOnly			= true
SWEP.ViewModel 			= "models/weapons/c_arms_citizen.mdl"
SWEP.WorldModel			= ""
SWEP.ViewModelFOV 		= 50
SWEP.ViewModelFlip 		= false
SWEP.DrawCrosshair		= false

SWEP.Weight				= 1
SWEP.AutoSwitchTo		= true
SWEP.AutoSwitchFrom		= false

SWEP.Primary 			= {}
SWEP.Primary.Damage		= 50
SWEP.Primary.Automatic	= true

SWEP.AnimDelay      	= 0
SWEP.ReloadDelay    	= 0

SWEP.NextHealth 		= 0

SWEP.AttackAnims		= {
	"fists_left",
	"fists_right"
}

SWEP.FleshSound	= {
	"physics/flesh/flesh_squishy_impact_hard1.wav",
	"physics/flesh/flesh_squishy_impact_hard2.wav",
	"physics/flesh/flesh_squishy_impact_hard3.wav",
	"physics/flesh/flesh_squishy_impact_hard4.wav"
}

SWEP.AttackSound = {
	"npc/antlion_guard/angry1.wav",
	"npc/antlion_guard/angry2.wav",
	"npc/antlion_guard/angry3.wav"
}

SWEP.HitSound	= {
	"npc/zombie/claw_strike1.wav",
	"npc/zombie/claw_strike2.wav",
	"npc/zombie/claw_strike3.wav"
}

SWEP.SwingSound	= {
	"npc/zombie/claw_miss1.wav",
	"npc/zombie/claw_miss2.wav"
}

function SWEP:Initialize()
	self:SetHoldType("knife")
	self:SendWeaponAnim(ACT_HL2MP_IDLE_KNIFE)

	self.NextHealthReg = CurTime()
end

function SWEP:Think()
	if self.AnimDelay > CurTime() then return end

	local owner = self:GetOwner()

	if owner:KeyDown(IN_FORWARD) and !owner:KeyDown(IN_DUCK) and owner:IsOnGround() then
		owner:DoAnimationEvent(ACT_HL2MP_RUN_ZOMBIE_FAST)

		self.AnimDelay = CurTime() + 0.4
	elseif !owner:IsOnGround() then
		owner:DoAnimationEvent(ACT_ZOMBIE_LEAPING)

		self.AnimDelay = CurTime() + 0.4
	end

	if SERVER and self.NextHealthReg <= CurTime() then
		self:RegenerateHealth()
	end
end

function SWEP:Deploy()
	local vm = self:GetOwner():GetViewModel()
	vm:ResetSequence(vm:LookupSequence("fists_draw"))
end



--addons/aoc_nextbots/lua/entities/acorp_nextbot_droid.lua:
AddCSLuaFile()

ENT.Base = "summe_nextbot"
ENT.PrintName = "Trandoshaner"
ENT.Category = "AOCRP | Nextbots"
ENT.Spawnable = false
ENT.AdminOnly = false

ENT.Model = {
    "models/player/swtor/droids/enforcerdroid_npc.mdl",
    "models/player/swtor/droids/combatmedic_npc.mdl"
}

ENT.Weapon = "weapon_npc_scatter"
ENT.HP = 300
ENT.ShootingRange = 400
ENT.LooseRadius = 3000
ENT.Proficiency = 0.3
ENT.Speed = 100

ENT.Melee = true
ENT.MeleeDamage = 25
ENT.MeleeDelay = 3

ENT.ThrowGrenades = true
ENT.Grenades = {"summe_gr_grenade"}

ENT.Sounds = {}

ENT.ActivitiesEnabled = true
ENT.Activities = {
    ["idle"] = ACT_IDLE,
    ["shoot"] = ACT_IDLE_ANGRY_SMG1,
    ["reload"] = ACT_RELOAD,
    ["walk_slow"] = ACT_WALK_RIFLE,
    ["walk_fast"] = ACT_RUN_RIFLE,
    ["melee"] = ACT_MELEE_ATTACK1,
    ["jump"] = ACT_WALK_RIFLE
}

function ENT:OnNPCSpawn()
    self:PlayAnimation("idle")
end
--gamemodes/starwarsrp/entities/entities/aoc_lua_marker.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Vectormarker (Nicht ohne Einweisung nutzen)"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP - Spawns"
ENT.Spawnable       = true


if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/hunter/plates/plate1x1.mdl" )
        self:DrawShadow( false )
        self:SetColor(Color(225,0,255))
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_NONE)
        self:SetSolid(SOLID_VPHYSICS)
        self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
    end

end



if CLIENT then

    function ENT:Draw()
        if LocalPlayer():GetMoveType() == MOVETYPE_NOCLIP then
            self:DrawModel() 
        end
    end

end
--gamemodes/starwarsrp/entities/entities/aoc_waffenkontrolle.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Waffenkonsole"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP"
ENT.Spawnable       = true
ENT.AOCRPInteract = true

if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/lordtrilobite/starwars/isd/imp_console_medium02.mdl" )
        self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
        self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
        self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
    
        self:SetUseType( SIMPLE_USE )


            local phys = self:GetPhysicsObject()
        if (phys:IsValid()) then
            phys:Wake()
        end
    end
    

    util.AddNetworkString("AOCRP_WAFFENKONSOLE")

    function ENT:Use( activator, caller )
        net.Start("AOCRP_WAFFENKONSOLE")
        net.Send(activator)
    end
end



if CLIENT then



    function ENT:Draw()
        self.BaseClass.Draw(self)  -- We want to override rendering, so don't call baseclass.
                                    -- Use this when you need to add to the rendering.
        --self:DrawEntityOutline( 1.0 ) -- Draw an outline of 1 world unit.
        --self:DrawModel()       -- Draw the model.


    end

end




if SERVER then
     
    util.AddNetworkString( "AOCRP_WAFFENKONSOLE_SELECT" )
   
    
    
    net.Receive( "AOCRP_WAFFENKONSOLE_SELECT", function( len, ply )
        local ent = net.ReadEntity()

        ply:SetNetVar("AOC_ReturnPos", ply:GetPos() )
        ent:Use(ply)


    end)

    

    
end
        
    
    if CLIENT then
    
        function AOCRP_Waffenkonsole() 
            if ValidPanel(AOCWaffenKonsoleFrame) then AOCWaffenKonsoleFrame:Remove() end
            AOCWaffenKonsoleFrame = AOCDerma:DefaultFrame()
            AOCWaffenKonsoleFrame:SetSize(AOCW(500),AOCH(600))
            AOCWaffenKonsoleFrame:Center()
            AOCWaffenKonsoleFrame:SetNewTitle("Waffensteuerung")
            AOCWaffenKonsoleFrame:SetSizable(false)
            AOCWaffenKonsoleFrame:SetDraggable(false)
    
            local content = AOCDerma:ScrollBar(AOCWaffenKonsoleFrame) 
            content:Dock(FILL)
            local newTable = {}

            for k, v in pairs(ents.FindByClass("lvs_turbo_laser")) do
    
                local btn = AOCDerma:Button(content, "Turbolaser #"..v:EntIndex(), function() 
                    if ValidPanel(AOCWaffenKonsoleFrame) then AOCWaffenKonsoleFrame:Remove() end
                    if !IsValid(v:GetDriver()) then
                        net.Start("AOCRP_WAFFENKONSOLE_SELECT")
                        net.WriteEntity(v)
                        net.SendToServer()
                    end
                end, "lc")

                btn:Dock(TOP)
                btn:DockMargin(5,10,5,0)


    
    
            end        
        end
        net.Receive( "AOCRP_WAFFENKONSOLE", function( len, ply )
            AOCRP_Waffenkonsole()
        
        end)

    end

    
--addons/aoc_nextbots/lua/entities/aocrp_nextbot_b1_heavy.lua:
AddCSLuaFile()

ENT.Base = "summe_nextbot"
ENT.PrintName = "B1 Heavy"
ENT.Category = "AOCRP | Nextbots"
ENT.Spawnable = false
ENT.AdminOnly = false

ENT.Model = "models/cis_npc/b1_battledroids/heavy/b1_battledroid_heavy.mdl"
ENT.Weapon = "weapon_npc_e5c"
ENT.HP = 400
ENT.ShootingRange = 2000
ENT.LooseRadius = 4000
ENT.Proficiency = 0.3
ENT.Speed = 100

ENT.Melee = true
ENT.MeleeDamage = 25
ENT.MeleeDelay = 3

ENT.ThrowGrenades = false
ENT.Grenades = {"summe_gr_grenade"}

ENT.Sounds = {
    ["killed"] = {
        "aoc/nextbot/b1/killed/scream1.wav",
        "aoc/nextbot/b1/killed/scream2.wav",
        "aoc/nextbot/b1/killed/scream3.wav",
        "aoc/nextbot/b1/killed/scream4.wav",
        "aoc/nextbot/b1/killed/scream5.wav"
    },

    ["attacking"] = {
        "aoc/nextbot/b1/attack/ausloeschen.wav",
        "aoc/nextbot/b1/attack/roger-roger.wav",
        "aoc/nextbot/b1/attack/scanne-das-ziel.wav",
        "aoc/nextbot/b1/attack/scanne-feindeinheit.wav",
        "aoc/nextbot/b1/attack/siegt.wav",
        "aoc/nextbot/b1/attack/ziel-erfasst.wav",
    },

    ["kill"] = {
        "aoc/nextbot/b1/kill/knapp.wav",
        "aoc/nextbot/b1/kill/nimm-das.wav",
        "aoc/nextbot/b1/kill/yeah.wav"
    }
}

ENT.Anims = {
    ["idle"] = {0},
    ["shoot"] = {"Smg1angryidle1"},
    ["reload"] = {"reload_smg1"},
    ["walk_slow"] = {"walk_all"},
    ["walk_fast"] = {"run_all"},
    ["melee"] = {"swing"},
}
--addons/arccw_base_modified/lua/entities/arccw_ammo_ar2_large.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"
ENT.RenderGroup               = RENDERGROUP_TRANSLUCENT

ENT.PrintName                 = "Rifle Ammo (Large)"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/rifle_ammo.mdl"
ENT.Scale = 1.5

ENT.AmmoType = "ar2"
ENT.AmmoCount = 150

ENT.DetonationDamage = 50
ENT.DetonationRadius = 256
ENT.DetonationSound = "weapons/ar1/ar1_dist2.wav"
--addons/arccw_base_modified/lua/entities/arccw_ammo_sniper.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"

ENT.PrintName                 = "Sniper Ammo"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/sniper_ammo.mdl"

ENT.AmmoType = "SniperPenetratedRound"
ENT.AmmoCount = 10
ENT.MaxHealth = 20
if engine.ActiveGamemode() == "terrortown" then
    ENT.AmmoType = "357"
end

ENT.DetonationDamage = 80
ENT.DetonationRadius = 128
ENT.DetonationSound = "npc/sniper/echo1.wav"
--lua/entities/arccw_uc_40mm_he.lua:
AddCSLuaFile()

ENT.Base = "arccw_uc_riflegrenade"
ENT.PrintName = "40mm HE"

ENT.GrenadeDamage = false
ENT.GrenadeRadius = 300
ENT.DragCoefficient = 0.25

ENT.Model = "models/items/ar2_grenade.mdl"
--lua/entities/arccw_uc_fire.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Fire Particle"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/Items/AR2_Grenade.mdl"

ENT.FireTime = 20

ENT.Armed = false

ENT.NextDamageTick = 0

ENT.Ticks = 0

ENT.ArcCW_Killable = false

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        local maxs = Vector(1, 1, 1)
        local mins = -maxs
        self:PhysicsInitBox(mins, maxs)
        self:DrawShadow( false )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.SpawnTime = CurTime()
        self:Detonate()

        self.FireTime = math.Rand(self.FireTime - 1, self.FireTime + 1)
    end
end

local fired = {
    "sprites/flamelet1",
    "sprites/flamelet2",
    "sprites/flamelet3",
    "sprites/flamelet4",
    "sprites/flamelet5",
}
local function GetFireParticle()
    return fired[math.random(#fired)]
end

function ENT:Think()
    if !self.SpawnTime then self.SpawnTime = CurTime() end

    if CLIENT then
        local emitter = ParticleEmitter(self:GetPos())

        if !self:IsValid() or self:WaterLevel() > 2 then return end
        if !IsValid(emitter) then return end

        if math.random(1, 100) < 10 then
            local fire = emitter:Add(GetFireParticle(), self:GetPos() + (VectorRand() * 16))
            fire:SetVelocity( VectorRand() * 500 * VectorRand() )
            fire:SetGravity( Vector(0, 0, 100) )
            fire:SetDieTime( math.Rand(0.5, 0.75) )
            fire:SetStartAlpha( 255 )
            fire:SetEndAlpha( 0 )
            fire:SetStartSize( 25 )
            fire:SetEndSize( 100 )
            fire:SetRoll( math.Rand(-180, 180) )
            fire:SetRollDelta( math.Rand(-0.2,0.2) )
            fire:SetColor( 255, 255, 255 )
            fire:SetAirResistance( 150 )
            fire:SetPos( self:GetPos() )
            fire:SetLighting( false )
            fire:SetCollide(true)
            fire:SetBounce(0.75)
            fire:SetNextThink( CurTime() + FrameTime() )
            fire:SetThinkFunction( function(pa)
                if !pa then return end
                local col1 = Color(255, 255, 255)
                local col2 = Color(0, 0, 0)

                local col3 = col1
                local d = pa:GetLifeTime() / pa:GetDieTime()
                col3.r = Lerp(d, col1.r, col2.r)
                col3.g = Lerp(d, col1.g, col2.g)
                col3.b = Lerp(d, col1.b, col2.b)

                pa:SetColor(col3.r, col3.g, col3.b)
                pa:SetNextThink( CurTime() + FrameTime() )
            end )
        end

        if math.random(1, 100) < 5 then
            local fire = emitter:Add("particles/smokey", self:GetPos())
                fire:SetVelocity( VectorRand() * 25 )
                fire:SetGravity( Vector(0, 0, 1500) )
                fire:SetDieTime( math.Rand(0.25, 1) )
                fire:SetStartAlpha( 255 )
                fire:SetEndAlpha( 0 )
                fire:SetStartSize( 10 )
                fire:SetEndSize( 150 )
                fire:SetRoll( math.Rand(-180, 180) )
                fire:SetRollDelta( math.Rand(-0.2,0.2) )
                fire:SetColor( 255, 255, 255 )
                fire:SetAirResistance( 150 )
                fire:SetPos( self:GetPos() )
                fire:SetLighting( false )
                fire:SetCollide(true)
                fire:SetBounce(0.75)
                fire:SetNextThink( CurTime() + FrameTime() )
                fire:SetThinkFunction( function(pa)
                    if !pa then return end
                    local col1 = Color(255, 135, 0)
                    local col2 = Color(150, 150, 150)

                    local col3 = col1
                    local d = pa:GetLifeTime() / pa:GetDieTime()
                    col3.r = Lerp(d, col1.r, col2.r)
                    col3.g = Lerp(d, col1.g, col2.g)
                    col3.b = Lerp(d, col1.b, col2.b)

                    pa:SetColor(col3.r, col3.g, col3.b)
                    pa:SetNextThink( CurTime() + FrameTime() )
                end )
        end

        emitter:Finish()

        self.Ticks = self.Ticks + 1
    else

        if self:GetVelocity():LengthSqr() <= 32 then
            self:SetMoveType( MOVETYPE_NONE )
        end

        if self.NextDamageTick > CurTime() then return end

        if self:WaterLevel() > 2 then self:Remove() return end

        local dmg = DamageInfo()
        dmg:SetDamageType(DMG_BURN)
        dmg:SetDamage(math.Round(math.random() * 2 + 3))
        dmg:SetInflictor(self)
        dmg:SetAttacker(self:GetOwner())
        util.BlastDamageInfo(dmg, self:GetPos(), 200)

        self.NextDamageTick = CurTime() + 0.15

        if self.SpawnTime + self.FireTime <= CurTime() then self:Remove() return end
    end
end

function ENT:OnRemove()
    if !self.FireSound then return end
    self.FireSound:Stop()
end

function ENT:Detonate()
    if !self:IsValid() then return end

    self.Armed = true

    if self.Order and self.Order != 1 then return end

    self.FireSound = CreateSound(self, "arccw_go/molotov/fire_loop_1.wav")
    self.FireSound:Play()

    self.FireSound:ChangePitch(80, self.FireTime)

    timer.Simple(self.FireTime - 1, function()
        if !IsValid(self) then return end

        self.FireSound:ChangeVolume(0, 1)
    end)

    timer.Simple(self.FireTime, function()
        if !IsValid(self) then return end

        self:Remove()
    end)
end

function ENT:Draw()
    -- cam.Start3D() -- Start the 3D function so we can draw onto the screen.
    --     render.SetMaterial( GetFireParticle() ) -- Tell render what material we want, in this case the flash from the gravgun
    --     render.DrawSprite( self:GetPos(), math.random(200, 250), math.random(200, 250), Color(255, 255, 255) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
    -- cam.End3D()
end
--addons/arccw_weapons/lua/entities/emp_nade/shared.lua:
ENT.Type 			= "anim"  
ENT.PrintName			= "EMP Nade"  
ENT.Spawnable			= false
ENT.AdminSpawnable		= false

--local rSound = Sound("Missile.Accelerate")

if SERVER then
	AddCSLuaFile( "shared.lua" )

	function ENT:Initialize()   
		self.flightvector = self.Entity:GetForward() * ((90*15.5)/2)
		self.timeleft = CurTime() + 2
		self.Owner = self:GetOwner()
		self.Entity:SetModel( "models/sw_battlefront/weapons/rocketprojectile.mdl" )
		self.Entity:PhysicsInit( SOLID_VPHYSICS )	
		self.Entity:SetMoveType( MOVETYPE_NONE )
		self.Entity:SetSolid( SOLID_VPHYSICS )
		--self.Entity:EmitSound(rSound, 75, 100)
		self.Entity:SetNWBool("smoke", 10, true)
	end   

	function ENT:Think()

			if self.timeleft < CurTime() then
				self:Explosion()
				self.Entity:Remove()
			end

		Table	={} 			//Table name is table name
		Table[1]	=self.Owner 		//The person holding the gat
		Table[2]	=self.Entity 		//The cap

		local trace = {}
			trace.start = self.Entity:GetPos()
			trace.endpos = self.Entity:GetPos() + self.flightvector
			trace.filter = Table
		local tr = util.TraceLine( trace )
		

			if tr.HitSky then
				self:Explosion()
				self.Entity:Remove()
				return true
			end

			local dmg = math.Rand( 250, 275 )
			util.BlastDamage(self.Entity, self:OwnerGet(), tr.HitPos, 10, dmg)
		
			if tr.Hit then
					local effectdata = EffectData()
						effectdata:SetOrigin(tr.HitPos)
						effectdata:SetNormal(tr.HitNormal)
						--effectdata:SetEntity(self.Entity)
						effectdata:SetScale(3)
						effectdata:SetRadius(tr.MatType)
						effectdata:SetMagnitude(18)
						util.Effect( "emp_exp_effect", effectdata )
						--util.BlastDamage(self.Entity, self:OwnerGet(), tr.HitPos, 500, dmg)
						util.Decal("Scorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)
						self.Entity:SetNWBool("smoke", false)
				self:Explosion()
				self.Entity:Remove()	
			end
		
		self.Entity:SetPos(self.Entity:GetPos() + self.flightvector)
		self.flightvector = self.flightvector - (self.flightvector/1500)  + Vector(math.Rand(-0.2,0.2), math.Rand(-0.2,0.2),math.Rand(-0.2,0.2)) + Vector(0,0,-0.05)
		self.Entity:SetAngles(self.flightvector:Angle() + Angle(0,0,0))
		self.Entity:NextThink( CurTime() )
		return true
	end
	
	function ENT:Explosion()
		self:EmitSound("everfall/explosions/ion/destruction_explosions_modular_medium_iondisruption_close_var_01.mp3", 500, 100)	
		for k, v in pairs( ents.FindInSphere( self:GetPos(), 250 ) ) do
			if IsValid( v ) then
				if v.LFS then
					v:StopEngine()
					v:SetShield(0)
					v:SetHP( v:GetHP()/10 )
				end
				if v.LVS then
					v:StopEngine()
					v:SetShield(0)
					v:SetHP( v:GetHP()/10 )
				end
				if v:IsPlayer() or v:IsNPC() then
					damage = DamageInfo()
					damage:SetDamage( 5000000 )
					damage:SetAttacker( self:GetOwner() )
					damage:SetDamageType( DMG_DISSOLVE )
					v:TakeDamageInfo( damage )
				end
			end 
	end
end

function ENT:OwnerGet()
	if IsValid(self.Owner) then
		return self.Owner
	else
		return self.Entity
	end
end

end

if CLIENT then

    function ENT:Draw()
     pos = self:GetPos()
     render.SetMaterial(Material("particle/particle_glow_04_additive"))
     render.DrawSprite(pos, 30, 30, Color(50, 195, 255))
     render.SetMaterial(Material("particle/particle_glow_04_additive"))
     render.DrawSprite(pos, 15, 15, Color(50, 195, 255))
     render.SetMaterial(Material("particle/particle_glow_04_additive"))
     render.DrawSprite(pos, 5, 5, Color(50, 195, 255))
    end
 
    function ENT:Initialize()
        pos = self:GetPos()
        self.emitter = ParticleEmitter( pos )
    end
 
    function ENT:Think()
    end

end
--addons/aoc_fire_system/lua/entities/fire/cl_init.lua:
include( "shared.lua" )

function ENT:Draw()
end

function ENT:Initialize()	
	self.LastFireEffect = 0
	
	self.RandomSound = math.random( 1, 2 )
	
	if self.RandomSound == 1 then
		self.FireSound = CreateSound(self, Sound("ambient/fire/fire_med_loop1.wav"))
		self.SoundDuration = 6.5
	elseif self.RandomSound == 2 then
		self.FireSound = CreateSound(self, Sound("ambient/fire/firebig.wav"))
		self.SoundDuration = 5
	else
		self.FireSound = CreateSound(self, Sound("ambient/fire/fire_big_loop1.wav"))
		self.SoundDuration = 5
	end
	
	self.LastPlay = 0
end

function ENT:Think()	
	if not LocalPlayer():CanSee( self ) and not LocalPlayer():InVehicle() then return end

	if self.LastFireEffect + .25 < CurTime() then
		self.LastFireEffect = CurTime()

		local FireEffect = EffectData()
		FireEffect:SetOrigin(self:GetPos())
		util.Effect( "fire_effect", FireEffect )
	end

	if self.LastPlay + self.SoundDuration < CurTime() then
		self.FireSound:Stop()
		self.FireSound:Play()
		self.LastPlay = CurTime()
	end
end

function ENT:OnRemove()
	self.FireSound:Stop()
end
--addons/tools/lua/entities/heart_turbolaser_spawner/shared.lua:
ENT.Type = "point";
ENT.Base = "base_gmodentity";
ENT.Author = "drunken hearted";

ENT.Spawnable = false;
--addons/lvs_addons/lua/entities/laat_hatch/shared.lua:
ENT.Base            = "base_entity"
ENT.Type            = "anim"

ENT.PrintName       = "Hatch"
ENT.Author          = "!Ben"
ENT.Information     = ""
ENT.Category        = "[LFS] - Star Wars Pack"

ENT.Spawnable		= false
ENT.AdminSpawnable	= false

ENT.RenderGroup = RENDERGROUP_BOTH

ENT.AutomaticFrameAdvance = true
--addons/lvs_addons/lua/entities/laat_rocketlauncher/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel() 
end
--lua/entities/ls_vehicle_mine.lua:
AddCSLuaFile("ls_vehicle_mine.lua")

if CLIENT then
    language.Add("ls_vehicle_mine", "Anti-Vehicle Mine")
end

ENT.Base = "ls_base_mine"
ENT.Type = "anim"

ENT.PrintName = "Anti-Vehicle Mine"
ENT.Category = "Star Wars - Mines"
ENT.Author = "List-Scripts"
ENT.Spawnable = true
ENT.AdminOnly = false

ENT.Model = "models/props/starwars/weapons/lasertrap.mdl"
ENT.TriggerBrush = "ls_brush_box"
ENT.TriggerSize = 200
ENT.ExplosionRadius = 300

-- if true, mine will explode when the victim leaves the trigger area
ENT.ExplodeOnLeave = false

ENT.HP = 50
ENT.Damage = 2000

if not SERVER then return end

function ENT:canTrigger(ent)
    return ent:IsVehicle() or ent.LVS
end
--addons/weapon_jedi/lua/entities/lscs_stance_base.lua:
AddCSLuaFile()

ENT.Base = "lscs_holocron_base"
DEFINE_BASECLASS( "lscs_holocron_base" )

ENT.Spawnable		= false
ENT.AdminSpawnable		= false

ENT.GlowMat = Material( "sprites/light_glow02_add" )
ENT.GlowCol = Color(255,200,0,255)

if CLIENT then
	function ENT:DrawTranslucent()
		self:DrawModel()
	end

	function ENT:Draw()
		-- ironic, in order to look nice the translucent sprite has to be rendered normal while the solid model has to be rendered translucent
		render.SetMaterial( self.GlowMat )
		render.DrawSprite( self:GetPos(), 64, 64, self.GlowCol )
	end
end
--addons/lvs_addons/lua/entities/lvs_arc/shared.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "ARC 170"
ENT.Author = "htog"
ENT.Information = ""
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/arc170.mdl"
ENT.GibModels = {
	"models/salza/arc170_gib1.mdl",
	"models/salza/arc170_gib2.mdl",
	"models/salza/arc170_gib3.mdl",
	"models/salza/arc170_gib4.mdl",
	"models/salza/arc170_gib5.mdl",
	"models/salza/arc170_gib6.mdl"
}

ENT.AITEAM = 2

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 800
ENT.MaxShield = 100

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )
	self:AddDT( "Entity", "TailGunnerSeat" )

	if SERVER then
		self:NetworkVarNotify( "Foils", self.OnFoilsChanged )
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(207.65,-303.52,-48.35),
		Vector(207.65,303.52,-48.35),
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 1000
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		if not ent:GetFoils() then
			ent:SetHeat( ent:GetHeat() + 0.5 )
		end
	
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( CurPos )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 30
		bullet.Damage	= 120
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,255,0) ) 
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		else
			ent.SNDRight:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
		if ent.SetFoils then ent:SetFoils( true ) end
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 12
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( 90, (ent._swapMissile and -304 or 304), -32 )

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_protontorpedo" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:LocalToWorldAngles( Angle(0,ent._swapMissile and 2 or -2,0) ) )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )


	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.Attack = function( ent )
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()

		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 60 then return true end

		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()


		local bullet = {}
		bullet.Src = veh:LocalToWorld( ent.SwapTopBottom and Vector(-175.81,0,50.26) or Vector(-171.69,0,5.81) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.03,  0.03, 0.03 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 120
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )
		ent:EmitSound("lvs/vehicles/arc170/fire_gunner.mp3")
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		if not IsValid( base ) then 
			return LVS:CalcView( ent, ply, pos, angles, fov, pod )
		end

		if pod:GetThirdPersonMode() then
			pos = pos + base:GetUp() * 100
		end

		return LVS:CalcView( base, ply, pos, angles, fov, pod )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 60) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 3 )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/arc170/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/arc170/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}






ENT.MDL = "models/sdog/arc170ch.mdl"
ENT.GibModels = {
	"models/salza/arc170_gib1.mdl",
	"models/salza/arc170_gib2.mdl",
	"models/salza/arc170_gib3.mdl",
	"models/salza/arc170_gib4.mdl",
	"models/salza/arc170_gib5.mdl",
	"models/salza/arc170_gib6.mdl"
}

ENT.AITEAM = 2

ENT.Mass = 5000
ENT.Inertia = Vector(400000,400000,400000)
ENT.Drag = 1

ENT.SeatPos = Vector(55,0,3.5)
ENT.SeatAng = Angle(0,-90,11)

ENT.IdleRPM = 1
ENT.MaxRPM = 2700
ENT.LimitRPM = 3300

ENT.RotorPos = Vector(220,0,10)
ENT.WingPos = Vector(100,0,10)
ENT.ElevatorPos = Vector(-200,0,0)
ENT.RudderPos = Vector(-200,0,0)

ENT.MaxVelocity = 2600

ENT.MaxThrust = 50000

ENT.MaxTurnPitch = 600
ENT.MaxTurnYaw = 600
ENT.MaxTurnRoll = 400

ENT.MaxPerfVelocity = 1500

ENT.MaxHealth = 1700
ENT.MaxShield = 800

ENT.Stability = 0.7

ENT.VerticalTakeoff = true
ENT.VtolAllowInputBelowThrottle = 10
ENT.MaxThrustVtol = 12000

ENT.MaxPrimaryAmmo = 1000
ENT.MaxSecondaryAmmo = 9

sound.Add( {
	name = "arclaz",
	channel = CHAN_ITEM,
	volume = 1.0,
	level = 105,
	pitch = {0, 0},
	sound = {
		"lfs/arc170ch/arcls1.wav",
		"lfs/arc170ch/arcls2.wav",
		"lfs/arc170ch/arcls3.wav",
		"lfs/arc170ch/arcls4.wav",
		"lfs/arc170ch/arcls5.wav",
		"lfs/arc170ch/arcls6.wav",
		"lfs/arc170ch/arcls7.wav",
		"lfs/arc170ch/arcls8.wav",
	}
} )

sound.Add( {
	name = "arctail",
	channel = CHAN_ITEM,
	volume = 1.0,
	level = 105,
	pitch = {0, 0},
	sound = {
		"lfs/arc170ch/arctail1.wav",
		"lfs/arc170ch/arctail2.wav",
		"lfs/arc170ch/arctail3.wav",
		"lfs/arc170ch/arctail4.wav",
		"lfs/arc170ch/arctail5.wav",
		"lfs/arc170ch/arctail6.wav",
	}
} )

sound.Add( {
	name = "tonnnn",
	channel = CHAN_STATIC,
	volume = 0.9,
	level = 110,
	sound = "lfs/arc170ch/arcton.wav"
} )

sound.Add( {
	name = "arcproton",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 105,
	sound = "lfs/arc170ch/arcproton.wav"
} )

sound.Add( {
	name = "tonnnn2",
	channel = CHAN_STATIC,
	volume = 0.9,
	level = 110,
	sound = "lfs/arc170ch/arcton2.wav"
} )

sound.Add( {
	name = "foilss",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 100,
	sound = "lfs/arc170ch/arcfoils.wav"
} )
--addons/lvs_addons/lua/entities/lvs_base_fakehover/shared.lua:

ENT.Base = "lvs_base"

ENT.PrintName = "[LVS] Generic Fake Hover"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 1

ENT.MaxVelocityX = 300
ENT.MaxVelocityY = 300

ENT.MaxTurnRate = 1

ENT.BoostAddVelocityX = 200
ENT.BoostAddVelocityY = 200

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.DisableBallistics = true

function ENT:SetupDataTables()
	self:CreateBaseDT()

	self:AddDT( "Vector", "AIAimVector" )
	self:AddDT( "Bool", "Disabled" )

	if SERVER then
		self:NetworkVarNotify( "Disabled", self.OnDisabled )
	end
end

function ENT:HitGround()
	local data = {
		start = self:LocalToWorld( self:OBBCenter() ),
		endpos = self:LocalToWorld( Vector(0,0,self:OBBMins().z - self.GroundTraceLength) ),
		mins = Vector( -self.GroundTraceHull, -self.GroundTraceHull, 0 ),
		maxs = Vector( self.GroundTraceHull, self.GroundTraceHull, 0 ),
		filter = self:GetCrosshairFilterEnts()
	}

	local trace = util.TraceHull( data )

	data.mask = MASK_WATER

	local traceWater = util.TraceHull( data )

	return ((trace.Hit or (traceWater.Hit and self.GroundTraceHitWater)) and not trace.HitSky)
end

function ENT:GetThrottle()
	return math.min( self:GetVelocity():Length() / math.abs( self.MaxVelocityX + self.BoostAddVelocityX, self.MaxVelocityY + self.BoostAddVelocityY ), 1 )
end

function ENT:GetMaxThrottle()
	return 1
end

function ENT:GetThrustStrenght()
	return 0
end

function ENT:GetVehicleType()
	return "fakehover"
end
--addons/lvs_addons/lua/entities/lvs_base_turret/shared.lua:

ENT.Base = "lvs_base"

ENT.PrintName = "[LVS] Base Starfighter"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

ENT.MaxVelocity = 3000
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.ThrottleRateUp = 0.6
ENT.ThrottleRateDown = 0.6

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

function ENT:SetupDataTables()
	self:CreateBaseDT()

	self:AddDT( "Vector", "Steer" )
	self:AddDT( "Vector", "AIAimVector" )
	self:AddDT( "Vector", "NWVtolMove" )
	self:AddDT( "Float", "NWThrottle" )
	self:AddDT( "Float", "MaxThrottle" )

	if SERVER then
		self:SetMaxThrottle( 1 )
	end
end

function ENT:PlayerDirectInput( ply, cmd )--[[
	local Pod = self:GetDriverSeat()

	local Delta = FrameTime()

	local KeyLeft = ply:lvsKeyDown( "-ROLL_SF" )
	local KeyRight = ply:lvsKeyDown( "+ROLL_SF" )
	local KeyPitchUp = ply:lvsKeyDown( "+PITCH_SF" )
	local KeyPitchDown = ply:lvsKeyDown( "-PITCH_SF" )

	local MouseX = cmd:GetMouseX()
	local MouseY = cmd:GetMouseY()

	if ply:lvsKeyDown( "FREELOOK" ) and not Pod:GetThirdPersonMode() then
		MouseX = 0
		MouseY = 0
	else
		ply:SetEyeAngles( Angle(0,90,0) )
	end

	local SensX, SensY, ReturnDelta = ply:lvsMouseSensitivity()

	if KeyPitchDown then MouseY = 10 * ReturnDelta end
	if KeyPitchUp then MouseY = -10 * ReturnDelta end

	local Input = Vector( MouseX * 0.4 * SensX, MouseY * SensY, 0 )

	local Cur = self:GetSteer()

	local Rate = Delta * 3 * ReturnDelta

	local New = Vector(Cur.x, Cur.y, 0) - Vector( math.Clamp(Cur.x * Delta * 5 * ReturnDelta,-Rate,Rate), math.Clamp(Cur.y * Delta * 5 * ReturnDelta,-Rate,Rate), 0)

	local Target = New + Input * Delta * 0.8

	local Fx = math.Clamp( Target.x, -1, 1 )
	local Fy = math.Clamp( Target.y, -1, 1 )

	local TargetFz = (KeyLeft and 1 or 0) - (KeyRight and 1 or 0)
	local Fz = Cur.z + math.Clamp(TargetFz - Cur.z,-Rate * 3,Rate * 3)

	local F = Cur + (Vector( Fx, Fy, Fz ) - Cur) * math.min(Delta * 100,1)

	self:SetSteer( F )]]
end

function ENT:PlayerMouseAim( ply, cmd )--[[
	if CLIENT then return end

	local Pod = self:GetDriverSeat()

	local PitchUp = ply:lvsKeyDown( "+PITCH_SF" )
	local PitchDown = ply:lvsKeyDown( "-PITCH_SF" )
	local YawRight = ply:lvsKeyDown( "+YAW_SF" )
	local YawLeft = ply:lvsKeyDown( "-YAW_SF" )
	local RollRight = ply:lvsKeyDown( "+ROLL_SF" )
	local RollLeft = ply:lvsKeyDown( "-ROLL_SF" )

	local FreeLook = ply:lvsKeyDown( "FREELOOK" )

	local EyeAngles = Pod:WorldToLocalAngles( ply:EyeAngles() )

	if FreeLook then
		if isangle( self.StoredEyeAngles ) then
			EyeAngles = self.StoredEyeAngles
		end
	else
		self.StoredEyeAngles = EyeAngles
	end

	local OverridePitch = 0
	local OverrideYaw = 0
	local OverrideRoll = (RollRight and 1 or 0) - (RollLeft and 1 or 0)

	if PitchUp or PitchDown then
		EyeAngles = self:GetAngles()

		self.StoredEyeAngles = Angle(EyeAngles.p,EyeAngles.y,0)

		OverridePitch = (PitchUp and 1 or 0) - (PitchDown and 1 or 0)
	end

	if YawRight or YawLeft then
		EyeAngles = self:GetAngles()

		self.StoredEyeAngles = Angle(EyeAngles.p,EyeAngles.y,0)

		OverrideYaw = (YawRight and 1 or 0) - (YawLeft and 1 or 0) 
	end

	self:ApproachTargetAngle( EyeAngles, OverridePitch, OverrideYaw, OverrideRoll, FreeLook )]]
end

function ENT:CalcThrottle( ply, cmd )--[[
	if CLIENT then return end

	local Delta = FrameTime()

	local ThrottleUp =  ply:lvsKeyDown( "+THRUST_SF" ) and self.ThrottleRateUp or 0
	local ThrottleDown = ply:lvsKeyDown( "-THRUST_SF" ) and -self.ThrottleRateDown or 0

	local Throttle = (ThrottleUp + ThrottleDown) * Delta

	self:SetThrottle( self:GetThrottle() + Throttle )]]
end

function ENT:CalcVtolThrottle( ply, cmd )--[[
	local Delta = FrameTime()

	local ThrottleZero = self:GetThrottle() <= 0

	local VtolX = ThrottleZero and (ply:lvsKeyDown( "-VTOL_X_SF" ) and -1 or 0) or 0
	local VtolY = ((ply:lvsKeyDown( "+VTOL_Y_SF" ) and 1 or 0) - (ply:lvsKeyDown( "-VTOL_Y_SF" ) and 1 or 0))
	local VtolZ = ((ply:lvsKeyDown( "+VTOL_Z_SF" ) and 1 or 0) - (ply:lvsKeyDown( "-VTOL_Z_SF" ) and 1 or 0))

	local DesiredVtol = Vector(VtolX,VtolY,VtolZ)
	local NewVtolMove = self:GetNWVtolMove() + (DesiredVtol - self:GetNWVtolMove()) * self.ThrustRateVtol * Delta

	if not ThrottleZero or self:WorldToLocal( self:GetPos() + self:GetVelocity() ).x > 100 then
		NewVtolMove.x = 0
	end

	self:SetVtolMove( NewVtolMove )]]
end

function ENT:SetVtolMove( NewMove )--[[
	if self:GetEngineActive() then
		self:SetNWVtolMove( NewMove )
	else
		self:SetNWVtolMove( Vector(0,0,0) )
	end]]
end

function ENT:SetThrottle( NewThrottle )--[[
	if self:GetEngineActive() then
		self:SetNWThrottle( math.Clamp(NewThrottle,0,self:GetMaxThrottle()) )
	else
		self:SetNWThrottle( 0 )
	end]]
end

function ENT:GetThrottle()--[[
	if self:GetEngineActive() then
		return self:GetNWThrottle()
	else
		return 0
	end]]
end

function ENT:GetVtolMove()--[[
	if self:GetEngineActive() and not self:GetAI() then
		return self:GetNWVtolMove() * self.ThrustVtol * (1 - math.min( self:GetThrottle(), 1 ))
	else
		return Vector(0,0,0)
	end]]
end

function ENT:StartCommand( ply, cmd )--[[
	if self:GetDriver() ~= ply then return end

	if SERVER then
		local KeyJump = ply:lvsKeyDown( "VSPEC" )

		if self._lvsOldKeyJump ~= KeyJump then
			self._lvsOldKeyJump = KeyJump

			if KeyJump then
				self:ToggleVehicleSpecific()
			end
		end
	end

	if ply:lvsMouseAim() then
		self:PlayerMouseAim( ply, cmd )
	else
		self:PlayerDirectInput( ply, cmd )
	end

	self:CalcThrottle( ply, cmd )
	self:CalcVtolThrottle( ply, cmd )]]
end

function ENT:GetThrustStrenght()--[[
	local ForwardVelocity = self:WorldToLocal( self:GetPos() + self:GetVelocity() ).x

	return (self.MaxVelocity * self:GetThrottle() - ForwardVelocity) / self.MaxVelocity]]
end

--addons/lvs_addons/lua/entities/lvs_fakehover_snail/shared.lua:
ENT.Type = "anim"
ENT.Base = "lvs_base_fakehover"
ENT.PrintName = "NR-N99 Snail Tank"
ENT.Author = "Dec"
ENT.Information = "NR-N99 Snail Tank Droid"
ENT.Category = "AOCRP - KUS - Fahrzeuge"

ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.MDL = "models/KingPommes/starwars/nr_n99/main.mdl"
ENT.GibModels = {
	"models/KingPommes/starwars/nr_n99/gib01.mdl",
	"models/KingPommes/starwars/nr_n99/gib02a.mdl",
	"models/KingPommes/starwars/nr_n99/gib02b.mdl",
	"models/KingPommes/starwars/nr_n99/gib03a.mdl",
	"models/KingPommes/starwars/nr_n99/gib03b.mdl",
	"models/KingPommes/starwars/nr_n99/gib04a.mdl",
	"models/KingPommes/starwars/nr_n99/gib04b.mdl",
	"models/KingPommes/starwars/nr_n99/gib05.mdl",
	"models/KingPommes/starwars/nr_n99/gib06.mdl",
	"models/KingPommes/starwars/nr_n99/gib07.mdl",
	"models/KingPommes/starwars/nr_n99/gib08.mdl",
	"models/KingPommes/starwars/nr_n99/gib09.mdl",
	"models/KingPommes/starwars/nr_n99/gib10.mdl",
}

ENT.AITEAM = 1

ENT.MaxVelocityY = 0
ENT.BoostAddVelocityY = 0

ENT.ForceAngleMultiplier = 4
ENT.ForceAngleDampingMultiplier = 4

ENT.ForceLinearMultiplier = 2
ENT.ForceLinearRate = 0.8

ENT.MaxVelocityZ = 0
ENT.BoostAddVelocityZ = 0

ENT.MaxHealth = 4500
ENT.MaxVelocityX = 650
ENT.BoostAddVelocitX = 850
ENT.IgnoreWater = false

ENT.MaxTurnRate = 0.65

ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

function ENT:OnSpawn()

end

function ENT:OnSetupDataTables()

end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.18
	weapon.Ammo = 3000
	weapon.HeatRateUp = 0.2
	weapon.HeatRateDown = 0.4
	weapon.Attack = function( ent )

        --if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()
		
		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 25 then return true end

		local trace = ent:GetEyeTrace()

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
		
		local gun1 = self:GetAttachment(self:LookupAttachment("barrel_small_left"))
		local gun2 = self:GetAttachment(self:LookupAttachment("barrel_small_right"))

		local fP = { gun1.Pos, gun2.Pos }

		self.NumPrim = self.NumPrim and self.NumPrim + 1 or 1
		if self.NumPrim > 2 then self.NumPrim = 1 end

		local bullet = {}
		bullet.Src = fP[self.NumPrim]
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_red_short"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 100
		bullet.Velocity = 12000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,0,0) ) 
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:TakeAmmo()
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 25) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.25
	weapon.Ammo = 250
	weapon.HeatRateUp = 0.8
	weapon.HeatRateDown = 0.1
	weapon.Attack = function( ent )
        --if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()
		
		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 25 then return true end

		local trace = ent:GetEyeTrace()

		local veh = ent:GetVehicle()

		veh.SNDBig:PlayOnce( 100 + math.Rand(-3,3), 1 )
		
		local gun1 = self:GetAttachment(self:LookupAttachment("barrel_small_left"))
		local gun2 = self:GetAttachment(self:LookupAttachment("barrel_small_right"))

		local fP = { gun1.Pos, gun2.Pos }

		self.NumPrim = self.NumPrim and self.NumPrim + 1 or 1
		if self.NumPrim > 2 then self.NumPrim = 1 end

		local bullet = {}
		bullet.Src = fP[self.NumPrim]
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_red_aat"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 350
		bullet.SplashDamage	= 150
		bullet.SplashDamageRadius	= 250
		bullet.Velocity = 12000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,0,0) ) 
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion_aat", effectdata )
		end
		ent:TakeAmmo()
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 25) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon )
end

function ENT:CalcMainActivityPassenger( ply )

end


ENT.EngineSounds = {
	{
		sound = "snailtank/engine_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 200,
	},
	{
		sound = "snailtank/engine_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 150,
	},
	{
		sound = "snailtank/engine_on.wav",
		Pitch = 40,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 40,
	},
}



--addons/lvs_addons/lua/entities/lvs_fakehover_turbotank/cl_init.lua:
include("shared.lua")



ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.LightGlow = Material( "sprites/light_glow02_add" )
ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.Red = Color( 255, 0, 0, 255)
ENT.SignalSprite = Material( "sprites/light_glow02_add" )
ENT.Spotlight = Material( "effects/lvs/spotlight_projectorbeam" )

function ENT:Initialize()
	self.weelpos = 0
end

function ENT:OnFrame()

	self:AnimDrive()

end

function ENT:AnimDrive()
    if not self:GetEngineActive() then return end
	local driver = self:GetDriver()
	local speed = self:GetThrottle() * 12
	if IsValid(self:GetDriver()) then
		if self:GetAI() == false then
			if driver:KeyDown( 16 ) == true then 
				speed = speed * -1
			end
		end
	end
	self.weelpos = self.weelpos + speed
	if self.weelpos >= 360 then
		self.weelpos = 0
	end
	if self.weelpos <= -360 then
		self.weelpos = 0
	end

    local angl = Angle(self.weelpos, 0, 0)

	if self:GetThrottle() > 0.2 then 
		self:ManipulateBoneAngles(self:LookupBone("wheel_1_R"), angl)
		self:ManipulateBoneAngles(self:LookupBone("wheel_2_R"), angl)
		self:ManipulateBoneAngles(self:LookupBone("wheel_3_R"), angl)
		self:ManipulateBoneAngles(self:LookupBone("wheel_4_R"), angl)
		self:ManipulateBoneAngles(self:LookupBone("wheel_5_R"), angl)
	
		self:ManipulateBoneAngles(self:LookupBone("wheel_1_L"), -angl)
		self:ManipulateBoneAngles(self:LookupBone("wheel_2_L"), -angl)
		self:ManipulateBoneAngles(self:LookupBone("wheel_3_L"), -angl)
		self:ManipulateBoneAngles(self:LookupBone("wheel_4_L"), -angl)
		self:ManipulateBoneAngles(self:LookupBone("wheel_5_L"), -angl)
	end
end

function ENT:RemoveLight()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end

	if IsValid( self.frojector ) then
		self.frojector:Remove()
		self.frojector = nil
	end
end

function ENT:OnRemoved()
	self:RemoveLight()
end

ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.GlowMaterial = Material( "sprites/light_glow02_add" )

ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.GlowMaterial = Material( "sprites/light_glow02_add" )

function ENT:PreDrawTranslucent()
	if self:GetSpotlightToggle() == false then 
		self:RemoveLight()
		return false
	end

	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 35 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( false ) 
		thelamp:SetFarZ( 10000 ) 
		thelamp:SetNearZ( 1 ) 
		thelamp:SetFOV( 100 )
		self.projector = thelamp
	end


	local Start1 = self:LocalToWorld( Vector(275,-125,150) )
	local Start2 = self:LocalToWorld( Vector(275,125,150) )

	local Dir1 = self:LocalToWorldAngles( Angle(0,5,0) ):Forward()
	local Dir2 = self:LocalToWorldAngles( Angle(0,-5,0) ):Forward()

	render.SetMaterial( self.GlowMaterial )
	render.DrawSprite( Start1, 32, 32, Color( 100, 100, 100, 255) )
	render.DrawSprite( Start2, 32, 32, Color( 100, 100, 100, 255) )

	render.SetMaterial( self.LightMaterial )
	render.DrawBeam( Start1,  Start1 + Dir1 * 400, 150, 0, 0.99, Color( 100, 100, 100, 5) ) 
	render.DrawBeam( Start2,  Start2 + Dir2 * 400, 150, 0, 0.99, Color( 100, 100, 100, 5) ) 

	if IsValid( self.projector ) then
		self.projector:SetPos( self:LocalToWorld( Vector(60,0,10.5) ) )
		self.projector:SetAngles( self:LocalToWorldAngles( Angle(15,0,0) ) )
		self.projector:Update()
	end

	return false
end

local COLOR_RED = Color(255,0,0,255)
local COLOR_WHITE = Color(255,255,255,255)


function ENT:CalcEngineSound( RPM, Pitch, Doppler )
	if self.ENG then
		self.ENG:ChangePitch(  math.Clamp(math.Clamp(  60 + Pitch * 50, 80,255) + Doppler,0,255) )
		self.ENG:ChangeVolume( math.Clamp( -1 + Pitch * 6, 0.5,1) )
	end
	
	if self.DIST then
		self.DIST:ChangePitch(  math.Clamp(math.Clamp(  50 + Pitch * 60, 50,255) + Doppler,0,255) )
		self.DIST:ChangeVolume( math.Clamp( -1 + Pitch * 6, 0,1) )
	end
end

function ENT:OnRemove()
	self:SoundStop()
end

function ENT:SoundStop()
	if self.DIST then
		self.DIST:Stop()
	end
	
	if self.ENG then
		self.ENG:Stop()
	end
end

--addons/lvs_addons/lua/entities/lvs_fakehover_turbotank/shared.lua:
ENT.Type = "anim"
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Turbotank / Juggernaut"
ENT.Author = "Dec"
ENT.Information = ""
ENT.Category = "[LVS] - Republik"

ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.MDL = "models/vehicles/sky/turbotank/turbotank_s.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxVelocityY = 0
ENT.BoostAddVelocityY = 0

ENT.ForceAngleMultiplier = 0
ENT.ForceAngleDampingMultiplier = 0

ENT.ForceLinearMultiplier = 2
ENT.ForceLinearRate = 0.8

ENT.MaxVelocityZ = 0
ENT.BoostAddVelocityZ = 0

ENT.MaxHealth = 12000
ENT.MaxVelocityX = 650
ENT.BoostAddVelocitX = 850
ENT.IgnoreWater = false

ENT.MaxTurnRate = 0

ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.Stopturn = false

function ENT:OnSpawn()
	self:CreateBonePoseParameter( "rocketl", self:LookupBone("rocket_a"), Angle(0,0,0), Angle(0,0,0), Vector(0,0,0), Vector(-40,0,0) )
	self:CreateBonePoseParameter( "rocketr", self:LookupBone("rocket_b"), Angle(0,0,0), Angle(0,0,0), Vector(0,0,0), Vector(40,0,0) )
end

function ENT:OnSetupDataTables()
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Entity", "SecondGunnerSeat" )
	self:AddDT( "Entity", "ThirdGunnerSeat" )
	self:AddDT( "Bool", "SpotlightToggle" )
end

function ENT:NoTurn( ent )
	if self:GetThrottle() > 0.1 then 
		ent.ForceAngleMultiplier = 1
		ent.ForceAngleDampingMultiplier = 1
		ent.MaxTurnRate = 0.5
		ent.Stopturn = false

	else
		timer.Simple( 1.5, function()
			if ent.Stopturn == false then
				self:StopEngine()
				self:StartEngine()
				ent.Stopturn = true
			end
			ent.ForceAngleMultiplier = 0
			ent.ForceAngleDampingMultiplier = 0
			ent.MaxTurnRate = 0
		end )
	end
end



function ENT:InitWeapons()
	
	self.FirePositions = {
		Vector(300,-32,100),
		Vector(300,-42,100),
		Vector(300,59,100), 
		Vector(300,49,100),
	}

	self.RocketPositions = {
		Vector(275,-125,250),
		Vector(275,125,250),
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.35
	weapon.Ammo = 300
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end
        --if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()
		
		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 15 then return true end

		local trace = ent:GetEyeTrace()

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
		
		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld( CurPos )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_blue_long"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 100
		bullet.Velocity = 18000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,0,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:TakeAmmo()
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
		self:SetBodygroup(self:FindBodygroupByName( "rockets" ),0)
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 15) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		if self:GetSpotlightToggle() == true then
			self:SetSpotlightToggle(false)
		else
			self:SetSpotlightToggle(true)
		end
	end
	weapon.OnSelect = function( ent ) 
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav") 
		self:SetBodygroup(self:FindBodygroupByName( "rockets" ),0)
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 160
	weapon.Delay = 1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0.08
	weapon.Attack = function( ent )

		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.RocketPositions then ent.NumPrim = 1 end

		--if not ent:WeaponsInRange() then return true end
		local veh = ent:GetVehicle()
		local Driver = ent:GetDriver()

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()

		local RurPos = ent.RocketPositions[ent.NumPrim]

		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 100 then return true end

		for i = 1, 20 do
			timer.Simple( (i / 7) * 0.75, function()
				if not IsValid( ent ) then return end

				if ent:GetAmmo() <= 0 then ent:SetHeat( 1 ) return end
	
				ent:TakeAmmo()
				local trace = ent:GetEyeTrace()
				local Start = RurPos
				local Dir = (ent:GetEyeTrace().HitPos - veh:LocalToWorld(Start)):GetNormalized()
				local projectile = ents.Create( "lvs_missile" )
				projectile:SetPos(veh:LocalToWorld(Start))
				projectile:SetAngles( Dir:Angle() )
				projectile:SetParent( )
				projectile:Spawn()
				projectile:Activate()
				projectile.GetTarget = function( missile ) return missile end
				projectile.GetTargetPos = function( missile )
					return missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-10,10) )
				end
				projectile:SetAttacker( IsValid( Driver ) and Driver or self )
				projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
				projectile:SetDamage( 550 )
				projectile:SetRadius( 350 )
				projectile:Enable()
				projectile:EmitSound( "LVS.TURUB.FIRE_MISSILE" )
				projectile:EmitSound( "LVS.TURUB.FLY_MISSILE" )
			end)
		end

		ent:SetHeat( 1 )
		ent:SetOverheated( true )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 30) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
		self:SetBodygroup(self:FindBodygroupByName( "rockets" ),1)
	end
	self:AddWeapon( weapon )
	--self:InitTurret()

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.10
	weapon.Ammo = 1000
	weapon.Attack = function( ent )
        --if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()
		
		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 360 then return true end

		local trace = ent:GetEyeTrace()

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
		
		local bullet = {}
		bullet.Src = (self:GetBonePosition( self:LookupBone("muzzle_top")) - self:GetManipulateBonePosition( self:LookupBone("muzzle_top")))
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 65
		bullet.Velocity = 10000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,0,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:TakeAmmo()
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 360) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.4
	weapon.Ammo = 200
	weapon.HeatRateDown = 0.1
	weapon.Attack = function( ent )
        --if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()
		
		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 360 then return true end

		local trace = ent:GetEyeTrace()

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 70 + math.Rand(-3,3), 1 )
		
		local bullet = {}
		bullet.Src = (self:GetBonePosition( self:LookupBone("muzzle_end")) - self:GetManipulateBonePosition( self:LookupBone("muzzle_end")))
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 150
		bullet.SplashDamage	= 100
		bullet.SplashDamageRadius	= 250
		bullet.Velocity = 20000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,0,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_concussion_explosion", effectdata )
		end
		ent:TakeAmmo()
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 360) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 3 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.10
	weapon.Ammo = 1000
	weapon.Attack = function( ent )
        --if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()
		
		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 80 then return true end

		local trace = ent:GetEyeTrace()
		
		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
		
		local bullet = {}
		bullet.Src = veh:LocalToWorld(  Vector(335,-0,300) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 55
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,0,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:TakeAmmo()
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 80) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 4 )
end

function ENT:CalcMainActivityPassenger( ply )

end


ENT.EngineSounds = {
	{
		sound = "turbo_tank/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 110,
	},
	{
		sound = "turbo_tank/stop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 70,
	},
	{
		sound = "turbo_tank/startup.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 70,
	},
	{
		sound = "turbo_tank/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 100,
	},
	{
		sound = "turbo_tank/dist.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 80,
	},
}

sound.Add{ {
	name = "LVS.TURUB.FIRE_MISSILE",
	channel = CHAN_WEAPON,
	volume = 6.0,
	level = 3000,
	pitch = 105,
	sound = "sound/turbo_tank/missile_launch.wav"
 } }

 sound.Add{ {
	name = "LVS.TURUB.FLY_MISSILE",
	volume = 8.0,
	level = 2000,
	pitch = 105,
	sound = "sound/turbo_tank/missile_flight.wav"
 } }

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-350,0,-200)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

--lua/entities/lvs_fall_missel.lua:
AddCSLuaFile()

ENT.Base = "lvs_fall_missel_base"

ENT.Type            = "anim"

ENT.PrintName = "Proton Torpedo"
ENT.Author = "Luna"
ENT.Information = "geht ab wie'n z�pfchen"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= true

ENT.ExplosionEffect = "lvs_explosion"
ENT.GlowColor = Color( 0, 117, 245, 235 )

if SERVER then
	function ENT:GetDamage() return
		(self._dmg or 8500)
	end

	function ENT:GetRadius() 
		return (self._radius or 250)
	end

	return
end

ENT.GlowMat = Material( "sprites/light_glow02_add" )

function ENT:Enable()	
	if self.IsEnabled then return end

	self.IsEnabled = true

	self.snd = CreateSound(self, "npc/combine_gunship/gunship_crashing1.wav")
	self.snd:SetSoundLevel( 80 )
	self.snd:Play()

	local effectdata = EffectData()
		effectdata:SetOrigin( self:GetPos() )
		effectdata:SetEntity( self )
	util.Effect( "lvs_proton_trail", effectdata )
end

function ENT:Draw()
	if not self:GetActive() then return end

	self:DrawModel()

	render.SetMaterial( self.GlowMat )

	local pos = self:GetPos()
	local dir = self:GetForward()

	for i = 0, 30 do
		local Size = ((30 - i) / 30) ^ 2 * 128

		render.DrawSprite( pos - dir * i * 7, Size, Size, self.GlowColor )
	end
end
--addons/lvs_addons/lua/entities/lvs_laatle_patrolgunship_imp/shared.lua:
ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "LAAT/le Gunship"
ENT.Author = "Durian"
ENT.Information = ""
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

ENT.MDL = "models/kingpommes/starwars/patrol_transport/main.mdl"
ENT.GibModels = {
}

ENT.AITEAM = 2

ENT.MaxVelocity = 1250
ENT.MaxThrust = 1250

ENT.MaxPitch = 60

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 2

ENT.TurnRatePitch = 0.7
ENT.TurnRateYaw = 0.7
ENT.TurnRateRoll = 0.66

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 700
ENT.MaxShield = 400

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "WingsDown" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Bool", "SpotlightToggle" )
	self:AddDT( "Bool", "DoorsClose")

	if SERVER or CLIENT then
		self:NetworkVarNotify( "WingsDown", self.OnWingsChanged )
	end
end

function ENT:InitWeapons()

	local weapon = {}
		weapon.Icon = Material("lvs/weapons/concussionmissile.png")
		weapon.Ammo = 20
		weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
		weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
		weapon.HeatRateDown = 0.25
		weapon.Attack = function( ent )
			local T = CurTime()

			if IsValid( ent._ConcussionMissile ) then
				if (ent._nextMissleTracking or 0) > T then return end

				ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

				ent._ConcussionMissile:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

				return
			end

			if (ent._nextMissle or 0) > T then return end

			ent._nextMissle = T + 0.5

			ent._swapMissile = not ent._swapMissile

			local Pos = Vector( 180, (ent._swapMissile and -35 or 35), 20 )Vector(180.79,35.9,22.68)

			local Driver = self:GetDriver()

			local projectile = ents.Create( "lvs_concussionmissile" )
			projectile:SetPos( ent:LocalToWorld( Pos ) )
			projectile:SetAngles( ent:GetAngles() )
			projectile:SetParent( ent )
			projectile:Spawn()
			projectile:Activate()
			projectile:SetAttacker( IsValid( Driver ) and Driver or self )
			projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
			projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )
			projectile:SetDamage( 800 )
			projectile:SetRadius( 300 )

			ent._ConcussionMissile = projectile

			ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
		end
		weapon.FinishAttack = function( ent )
			if not IsValid( ent._ConcussionMissile ) then return end

			local projectile = ent._ConcussionMissile

			projectile:Enable()
			projectile:EmitSound( "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
			ent:TakeAmmo()

			ent._ConcussionMissile = nil

			local NewHeat = ent:GetHeat() + 0.75

			ent:SetHeat( NewHeat )
			if NewHeat >= 1 then
				ent:SetOverheated( true )
			end
		end
		weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
		weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/vehicles/imperial/overheat.wav") end
	self:AddWeapon( weapon )

	local weapon = {}		
		weapon.Icon = Material("lvs/weapons/dual_hmg.png")
		weapon.Ammo = 1250
		weapon.Delay = 0.25
		weapon.HeatRateUp = 0.3
		weapon.HeatRateDown = 0.3
		weapon.Attack = function( ent )
			local pod = ent:GetDriverSeat()

			if not IsValid( pod ) then return end

			if ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= 61 then return true end

			ent.FirePositions = {
				Vector(180.79,-35.9,22.68),
				Vector(180.79,35.9,22.68)
,
			}
			
			
			ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
			if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

			local startpos = pod:LocalToWorld( pod:OBBCenter() )
			local trace = ent:GetEyeTrace()

			local bullet = {}
			bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
			bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
			bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
			bullet.TracerName = "lvs_laser_green"
			bullet.Force	= 10
			bullet.HullSize 	= 25
			bullet.Damage	= 60
			bullet.Velocity = 60000
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
					effectdata:SetStart( Vector(50,255,50) ) 
					effectdata:SetOrigin( tr.HitPos )
					effectdata:SetNormal( tr.HitNormal )
				util.Effect( "lvs_laser_impact", effectdata )
			end
			ent:LVSFireBullet( bullet )

			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:TakeAmmo()

			veh = ent:GetVehicle()

			veh.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
		weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
		weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/vehicles/imperial/overheat.wav") end
		weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
			local base = ent:GetVehicle()

			if not IsValid( base ) then 
				return LVS:CalcView( ent, ply, pos, angles, fov, pod )
			end

			if pod:GetThirdPersonMode() then
				pos = pos + base:GetUp() * 100
			end

			return LVS:CalcView( base, ply, pos, angles, fov, pod )
		end
		weapon.HudPaint = function( ent, X, Y, ply )
			local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 60) and COLOR_RED or COLOR_WHITE

			local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

			local base = ent:GetVehicle()
			base:PaintCrosshairCenter( Pos2D, Col )
			base:PaintCrosshairOuter( Pos2D, Col )
			base:LVSPaintHitMarker( Pos2D )
		end
		weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
			local view = {}
			view.origin = pos
			view.angles = angles
			view.fov = fov
			view.drawviewer = false

			local mn = self:OBBMins()
			local mx = self:OBBMaxs()
			local radius = ( mn - mx ):Length()
			local radius = radius + radius * pod:GetCameraDistance()

			local clamped_angles = pod:WorldToLocalAngles( angles )
			clamped_angles.p = math.max( clamped_angles.p, -20 )
			clamped_angles = pod:LocalToWorldAngles( clamped_angles )

			local StartPos = self:LocalToWorld( Vector(-150,0,150) ) + clamped_angles:Up() * 150
			local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * radius * 0.2

			local WallOffset = 4

			local tr = util.TraceHull( {
				start = StartPos,
				endpos = EndPos,
				filter = function( e )
					local c = e:GetClass()
					local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

					return collide
				end,
				mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
				maxs = Vector( WallOffset, WallOffset, WallOffset ),
			} )

			view.angles = angles + Angle(5,0,0)
			view.origin = tr.HitPos
			view.drawviewer = true

			if tr.Hit and  not tr.StartSolid then
				view.origin = view.origin + tr.HitNormal * WallOffset
			end

			return view
		end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		if self:GetSpotlightToggle() == true then
			self:SetSpotlightToggle(false)
		else
			self:SetSpotlightToggle(true)
		end
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_sidedoor.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function( ent )
		if self:GetAI() then return end
	
		if self.t1 > CurTime() then return end
		if(self.Doors:GetSequence() == self.Doors:LookupSequence("DoorsOpen")) then
			self.Doors:ResetSequence(self.Doors:LookupSequence("DoorsClose"))
			self:SetDoorsClose(false)
		else				
			self.Doors:ResetSequence(self.Doors:LookupSequence("DoorsOpen"))
			self:SetDoorsClose(true)
		end
		self.t1 = CurTime() + 0.5
	end
	self:AddWeapon( weapon )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/laat/flyby"..math.random(1,2,3,4,5)..".wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/laat/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
	{
		sound = "^lvs/vehicles/laat/dist.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0.35,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		VolumeMin = 0,
		VolumeMax = 1,
		SoundLevel = 110,
	},
}

function ENT:CalcMainActivity( ply )
	local Pod = ply:GetVehicle()

	if Pod == self:GetDriverSeat() or Pod == self:GetGunnerSeat() then return end

	if ply.m_bWasNoclipping then 
		ply.m_bWasNoclipping = nil 
		ply:AnimResetGestureSlot( GESTURE_SLOT_CUSTOM ) 

		if CLIENT then 
			ply:SetIK( true )
		end 
	end 

	ply.CalcIdeal = ACT_STAND
	ply.CalcSeqOverride = ply:LookupSequence( "idle_all_02" )

	if ply:GetAllowWeaponsInVehicle() and IsValid( ply:GetActiveWeapon() ) then

		local holdtype = ply:GetActiveWeapon():GetHoldType()

		if holdtype == "smg" then 
			holdtype = "smg1"
		end

		local seqid = ply:LookupSequence( "idle_" .. holdtype )

		if seqid ~= -1 then
			ply.CalcSeqOverride = seqid
		end
	end

	return ply.CalcIdeal, ply.CalcSeqOverride
end
--addons/lvs_addons/lua/entities/lvs_nuclass_attack_shuttle/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
end

ENT.EngineColor = Color( 101, 181, 212)
ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EnginePos = {
	Vector(-450,34,185),
	Vector(-450,-34,185),
	Vector(-450,34,250),
	Vector(-450,-34,250),
	Vector(-475,210,170),
	Vector(-475,-210,170),
	Vector(-475,202,152.5),
	Vector(-475,-202,152.5),
	Vector(-475,195,135),
	Vector(-475,-195,135),
	Vector(-475,190,120),
	Vector(-475,-190,120),

	Vector(-475,130,203),
	Vector(-475,-130,203),
	Vector(-475,124,187.5),
	Vector(-475,-124,187.5),
	Vector(-475,115,170),
	Vector(-475,-115,170),
	Vector(-475,170,185),
	Vector(-475,-170,185),
	Vector(-475,160,165),
	Vector(-475,-160,165),
	Vector(-475,150,145),
	Vector(-475,-150,145),
	
}

function ENT:OnSpawn()
end

function ENT:OnFrame()
	self:EngineEffects()
end

function ENT:OnWingsChanged()
end

function ENT:StartWindSounds()
    self:StopWindSounds()

    if LocalPlayer():lvsGetVehicle() ~= self then return end

    self._WaterSFX = CreateSound( self, "LVS.Physics.Water" )
    self._WaterSFX:PlayEx(0,100)
end   

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "sprites/bluecore", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.025 )
		particle:SetStartAlpha(255)
		particle:SetEndAlpha(255)
		particle:SetStartSize(25.5)
		particle:SetEndSize(18)
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor(255,255,255)
	end
end

function ENT:PostDrawTranslucent()
    if not self:GetEngineActive() then return end

    local Size = 80 + self:GetThrottle() * 120 + self:GetBoost() * 2

    render.SetMaterial( self.EngineGlow )

    for _, pos in pairs( self.EnginePos ) do
        render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
    end
end

function ENT:OnStartBoost()
	self:EmitSound( "^lvs/vehicles/shuttle/flyby.wav", 85 )
end

function ENT:OnStopBoost()
end
--addons/lvs_addons/lua/entities/lvs_repshuttle_swtor/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-151,87,15), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-151,-87,15), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-151,87,-15), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-151,-87,-15), 0, 20, 2, 1000, 150 )
end
 
-- Engine Particles start

ENT.EngineColor = Color( 0, 140, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	Vector(-91.18,456.16,58.83),
	Vector(-91.18,-456.16,58.83),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-34,326,-13), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-34,-326,-13), 0, 20, 2, 1000, 150 )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 1)
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(100,125) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 0, 140, 255)
	end
end

function ENT:OnFrame()
	self:EngineEffects()
end


-- Engine Particles End

 
function ENT:PostDraw()
	if not self:GetEngineActive() then return end
 
end
 
function ENT:OnStartBoost()
	self:EmitSound( "ophra/ships/powerstart3.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "ophra/ships/shutdown.wav", 85 )
end


--addons/lvs_addons/lua/entities/lvs_repulsorlift_gunship/sh_wingturret.lua:

function ENT:SetNextRearGunFire( delay )
	self._NextRGFire = CurTime() + delay
end

function ENT:CanFireRearGun()
	return (self._NextRGFire or 0) < CurTime()
end

function ENT:GetRearGunInRange( ent )
	return ent:AngleBetweenNormal( ent:GetAimVector(), -ent:GetForward() ) < 35
end

function ENT:HandleRearGun( ent, ShouldFire )
	local trace = ent:GetEyeTrace()

	local Pos,Ang = WorldToLocal( Vector(0,0,0), (trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,180,0) ) )

	if not self:GetRearGunInRange( ent ) then 
		self:SetPoseParameter("reargun_yaw", 0 )

		return false
	end

	self:SetPoseParameter("reargun_pitch", -Ang.p )
	self:SetPoseParameter("reargun_yaw", -Ang.y )

	if not ShouldFire or not self:CanFireRearGun() then self:GetRearGunInRange( ent ) return end

	local ID = self:LookupAttachment( "muzzle_reargun" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return self:GetRearGunInRange( ent ) end

	self:SetNextRearGunFire( 0.3 )

	local bullet = {}
	bullet.Src 	= Muzzle.Pos
	bullet.Dir 	= (trace.HitPos - Muzzle.Pos):GetNormalized()
	bullet.Spread 	= Vector( 0.03,  0.03, 0.03 )
	bullet.TracerName = "lvs_laser_green"
	bullet.Force	= 10
	bullet.HullSize 	= 25
	bullet.Damage	= 65
	bullet.Velocity = 30000
	bullet.Attacker 	= ent:GetDriver()
	bullet.Callback = function(att, tr, dmginfo)
		local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) ) 
			effectdata:SetOrigin( tr.HitPos )
			effectdata:SetNormal( tr.HitNormal )
		util.Effect( "lvs_laser_impact", effectdata )
	end
	ent:LVSFireBullet( bullet )

	local NewHeat = ent:GetHeat() + 0.4


	ent:SetHeat( NewHeat )
	if NewHeat >= 1 then
		ent:SetOverheated( true )
	end

	if not IsValid( self.SNDTail ) then return end

	self.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
end

function ENT:InitWeaponGunner()
	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)
	local MaxRange = 60
	local MaxTailRange = 35

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function( ent )
		ent.ShouldFire = true
	end
	weapon.FinishAttack = function( ent )
		ent.ShouldFire = false

		local base = ent:GetVehicle()

		local snd = {
			[-1] = base.WingLeftSND,
			[1] = base.WingRightSND,
		}

		for _, sound in pairs( snd ) do
			if not IsValid( sound ) then continue end

			sound:Stop()
		end
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		local ShouldFire = (ent.ShouldFire == true) and ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) < MaxRange
	
		if base:HandleRearGun( ent, ent.ShouldFire ) then
			ShouldFire = false
		end

		if base:SetWingTurretFire() ~= ShouldFire then
			base:SetWingTurretFire( ShouldFire ) 
		end

		local snd = {
			[-1] = base.WingLeftSND,
			[1] = base.WingRightSND,
		}

		if ent._oldShouldFire ~= ShouldFire then
			ent._oldShouldFire = ShouldFire
			if ShouldFire then
				for _, sound in pairs( snd ) do
					if not IsValid( sound ) then continue end

					sound:EmitSound( "lvs/vehicles/laat/ballturret_fire.mp3", 110 )
				end
			end
		end

		if not ShouldFire then
			for _, sound in pairs( snd ) do
				if not IsValid( sound ) then continue end
				sound:Stop()
			end

			ent:SetHeat( ent:GetHeat() - FrameTime() )

			return
		end
	
		if not active then
			return
		end

		local trace = ent:GetEyeTrace()
		local DesEndPos = trace.HitPos

		base:SetWingTurretTarget( DesEndPos )

		if not base:GetWingTurretFire() then return end

		local DesStartPos

		if base:WorldToLocal( DesEndPos ).z < 0 then
			DesStartPos = Vector(-172.97,334.04,93.25)
		else
			DesStartPos = Vector(-174.79,350.05,125.98)
		end

		local NewHeat = ent:GetHeat()

		for i = -1,1,2 do
			local StartPos = self:LocalToWorld( DesStartPos * Vector(1,i,1) )
			local beam = util.TraceLine( { start = StartPos, endpos = DesEndPos} )

			self:BallturretDamage( beam.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - StartPos):GetNormalized() )

			if not IsValid( snd[i] ) then continue end

			if beam.Entity ~= base then
				snd[i]:Play()
				NewHeat = NewHeat + FrameTime() * 0.25
			else
				snd[i]:Stop()
			end
		end

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local radius = 800
		radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )

		local StartPos = base:LocalToWorld( base:OBBCenter() ) + clamped_angles :Up() * (250 + radius * pod:GetCameraHeight())
		local EndPos = StartPos - clamped_angles:Forward() * radius

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "player" ) and not e.LVS
				
				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.drawviewer = true
		view.origin = tr.HitPos

		if tr.Hit and not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local WingInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= MaxRange
		local RearGunInRange = not base:GetRearGunInRange( ent )

		local Col = (WingInRange and RearGunInRange) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end
--addons/lvs_addons/lua/entities/lvs_repulsorlift_stap/cl_init.lua:
include("shared.lua")

ENT.EngineFXPos = {
	Vector(-60.77,103.87,31.04),
}

function ENT:OnSpawn()

end

function ENT:CalcViewOverride(ply, pos, angles, fov, pod)
	if pod:GetThirdPersonMode() then
        pos = self:LocalToWorld(Vector(200, 0, 0))
		return pos, angles, fov
	end

	return pos, angles, fov
end


function ENT:OnFrame()
	self:EngineEffects()
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, v in pairs( self.EngineFXPos ) do
		local Sub = Mirror and 1 or -1
		local vOffset = self:LocalToWorld( v )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5


		if not particle then continue end

		particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,50) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		
		particle:SetColor( 255, 172, 28 )
	end
end
function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/vwing/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vwing/brake.wav", 85 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_alligator/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-160,155,35), 0, 20, 2, 600, 150 )
	self:RegisterTrail( Vector(-160,-155,35), 0, 20, 2, 600, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
	self:AnimAstromech()
end

function ENT:PostDrawTranslucent()
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01
	
		local emitter = ParticleEmitter( self:GetPos(), false )
		local Pos = {
			Vector(-200,0,35),
			}

		if emitter then
			for _, v in pairs( Pos ) do
				local Sub = Mirror and 1 or -1
				local vOffset = self:LocalToWorld( v )
				local vNormal = -self:GetForward()

				vOffset = vOffset + vNormal * 5

				local particle = emitter:Add( "sprites/heatwave", vOffset )
				if not particle then return end

				particle:SetVelocity( vNormal * math.Rand(1500,1000) + self:GetVelocity() )
				particle:SetLifeTime( 0 )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( 255 )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(15,30) )
				particle:SetEndSize( math.Rand(0,10) )
				particle:SetRoll( math.Rand(-1,1) * 100 )
				
				particle:SetColor( 255, 255, 255 )
			
				Mirror = true
			end
			
			emitter:Finish()
		end
end

function ENT:AnimAstromech()
	local T = CurTime()

	if (self.nextAstro or 0) < T then
		self.nextAstro = T + math.Rand(2,5)

		local HasShield = self:GetShield() > 0

		if self.OldShield == true and not HasShield then
			self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/astromech/shieldsdown"..math.random(1,2)..".ogg" )
		else
			if math.random(0,4) == 3 then
				self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/astromech/"..math.random(1,11)..".ogg" )
			end
		end
		
		self.OldShield = HasShield
	end
end

function ENT:AnimCockpit()
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/boost.wav", 125 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/brake.wav", 125 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_alligator/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Alligator Fighter"
ENT.Author = "Nashatok"
ENT.Information = "Light Interceptor designed by MandalMotors, popular among pirates and militias"
ENT.Category = "[LVS] - Star Wars"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/alligator/rep_alligator_servius.mdl"

ENT.AITEAM = 2

ENT.MaxVelocity = 2750
ENT.MaxThrust = 2750

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 350
ENT.MaxShield = 80

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(65,155,35),
		Vector(65,-155,35),
	}
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 1200
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.2
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		self.NumPrim = self.NumPrim and self.NumPrim + 1 or 1
		if self.NumPrim > 2 then self.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 40
		bullet.Damage	= 30
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )
		
		ent:LVSFireBullet( bullet )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
	
	self:AddWeapon( LVS:GetWeaponPreset( "TURBO" ) )
end

ENT.FlyByAdvance = 0.75
ENT.FlyBySound = "lvs/vehicles/vwing/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/vwing/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_ig2000/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-320,190,100), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-320,-190,100), 0, 20, 2, 1000, 150 )
	
	self:RegisterTrail( Vector(-240,0,60), 0, 20, 2, 700, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost()
	local Mirror = false

	render.SetMaterial( self.EngineGlow )
	render.DrawSprite( self:LocalToWorld( Vector(-250,0,60) ), Size, Size, Color( 255, 200, 100, 255) )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	local vOffset = self:LocalToWorld( Vector(-250,0,60) )
	local vNormal = -self:GetForward()

	vOffset = vOffset + vNormal * 5

	local particle = emitter:Add( "effects/muzzleflash2", vOffset )
	if not particle then return end

	particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
	particle:SetLifeTime( 0 )
	particle:SetDieTime( 0.1 )
	particle:SetStartAlpha( 255 )
	particle:SetEndAlpha( 0 )
	particle:SetStartSize( math.Rand(15,25) )
	particle:SetEndSize( math.Rand(0,10) )
	particle:SetRoll( math.Rand(-1,1) * 100 )
				
	particle:SetColor( 255, 255, 255 )
end

function ENT:AnimAstromech()
end

function ENT:AnimCockpit()
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/boost.wav", 125 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/brake.wav", 125 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_nbt630/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color( 50, 100, 255, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	Vector(-160,0,60),
	Vector(-200,200,65),
	Vector(-200,-200,65),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-34,326,-13), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-34,-326,-13), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )
		if not particle then return end
		
		particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(100,125) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		
		particle:SetColor( 10, 100, 255 )
	end
end

function ENT:AnimGunner()
	local Pod = self:GetTailGunnerSeat()
end

function ENT:AnimAstromech()
end

function ENT:AnimWings()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost() * 2

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/arc170/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/arc170/brake.wav", 85 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_soundemitter.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false
ENT.DoNotDuplicate = true

ENT._LVS = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
end

if SERVER then
	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
		debugoverlay.Cross( self:GetPos(), 40, 5, Color( 255, 255, 255 ) )
	end

	function ENT:CheckWater( Base )
		if bit.band( util.PointContents( self:GetPos() ), CONTENTS_WATER ) ~= CONTENTS_WATER then
			if self.CountWater then
				self.CountWater = nil
			end

			return
		end

		if Base.WaterLevelAutoStop > 3 then return end

		self.CountWater = (self.CountWater or 0) + 1

		if self.CountWater < 4 then return end

		Base:StopEngine()
	end

	function ENT:Think()

		local Base = self:GetBase()

		if IsValid( Base ) and Base:GetEngineActive() then
			self:CheckWater( Base )
		end

		self:NextThink( CurTime() + 1 )

		return true
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:UpdateTransmitState() 
		return TRANSMIT_ALWAYS
	end

	return
end

ENT._oldEnActive = false
ENT._ActiveSounds = {}

function ENT:Initialize()
end

function ENT:StopSounds()
	for id, sound in pairs( self._ActiveSounds ) do
		if istable( sound ) then
			for _, snd in pairs( sound ) do
				if snd then
					snd:Stop()
				end
			end
		else
			sound:Stop()
		end
		self._ActiveSounds[ id ] = nil
	end
end

function ENT:HandleEngineSounds( vehicle )
	local ply = LocalPlayer()
	local pod = ply:GetVehicle()
	local Throttle = vehicle:GetThrottle() - vehicle:GetThrustStrenght() * vehicle:GetThrottle() * 0.5
	local Doppler = vehicle:CalcDoppler( ply )

	local DrivingMe = ply:lvsGetVehicle() == vehicle

	local FirstPerson = false
	if IsValid( pod ) then
		local ThirdPerson = pod:GetThirdPersonMode()

		if ThirdPerson ~= self._lvsoldTP then
			self._lvsoldTP = ThirdPerson
			VolumeSetNow = DrivingMe
		end

		FirstPerson = DrivingMe and not ThirdPerson
	end

	if DrivingMe ~= self._lvsoldDrivingMe then
		self._lvsoldDrivingMe = DrivingMe

		self:StopSounds()

		self._oldEnActive = nil

		return
	end

	local FT = RealFrameTime()

	self._smTHR = self._smTHR and self._smTHR + (Throttle - self._smTHR) * FT or 0

	for id, sound in pairs( self._ActiveSounds ) do
		if not sound then continue end

		local data = self.EngineSounds[ id ]

		local Pitch = math.Clamp( data.Pitch + self._smTHR * data.PitchMul, data.PitchMin, data.PitchMax )
		local PitchMul = data.UseDoppler and Doppler or 1

		local InActive = self._smTHR > data.FadeOut or self._smTHR < data.FadeIn
		if data.FadeOut >= 1 and self._smTHR > 1 then
			InActive = false
		end

		local Volume = InActive and 0 or LVS.EngineVolume

		if data.VolumeMin and data.VolumeMax and not InActive then
			Volume = math.max(self._smTHR - data.VolumeMin,0) / (1 - data.VolumeMin) * data.VolumeMax * LVS.EngineVolume
		end

		if istable( sound ) then
			sound.ext:ChangePitch( math.Clamp( Pitch * PitchMul, 0, 255 ), 0.2 )
			if sound.int then sound.int:ChangePitch( math.Clamp( Pitch, 0, 255 ), 0.2 ) end

			local fadespeed = VolumeSetNow and 0 or data.FadeSpeed

			if FirstPerson then
				sound.ext:ChangeVolume( 0, 0 )

				if vehicle:HasActiveSoundEmitters() then
					Volume = Volume * 0.25
					fadespeed = fadespeed * 0.5
				end

				if sound.int then sound.int:ChangeVolume( Volume, fadespeed ) end
			else
				sound.ext:ChangeVolume( Volume, fadespeed )
				if sound.int then sound.int:ChangeVolume( 0, 0 ) end
			end
		else
			sound:ChangePitch( math.Clamp( Pitch * PitchMul, 0, 255 ), 0.2 )
			sound:ChangeVolume( Volume, data.FadeSpeed )
		end
	end
end

function ENT:OnEngineActiveChanged( Active )
	if not Active then self:StopSounds() return end

	local ply = LocalPlayer()
	local DrivingMe = ply:lvsGetVehicle() == self:GetBase()

	for id, data in pairs( self.EngineSounds ) do
		if not isstring( data.sound ) then continue end

		self.EngineSounds[ id ].Pitch = data.Pitch or 80
		self.EngineSounds[ id ].PitchMin = data.PitchMin or 0
		self.EngineSounds[ id ].PitchMax = data.PitchMax or 255
		self.EngineSounds[ id ].PitchMul = data.PitchMul or 100
		self.EngineSounds[ id ].UseDoppler = data.UseDoppler ~= false
		self.EngineSounds[ id ].FadeIn = data.FadeIn or 0
		self.EngineSounds[ id ].FadeOut = data.FadeOut or 1
		self.EngineSounds[ id ].FadeSpeed = data.FadeSpeed or 1.5
		self.EngineSounds[ id ].SoundLevel = data.SoundLevel or 85

		if data.sound_int and data.sound_int ~= data.sound and DrivingMe then
			local sound = CreateSound( self, data.sound )
			sound:SetSoundLevel( data.SoundLevel )
			sound:PlayEx(0,100)

			if data.sound_int == "" then
				self._ActiveSounds[ id ] = {
					ext = sound,
					int = false,
				}
			else
				local sound_interior = CreateSound( self, data.sound_int )
				sound_interior:SetSoundLevel( data.SoundLevel )
				sound_interior:PlayEx(0,100)

				self._ActiveSounds[ id ] = {
					ext = sound,
					int = sound_interior,
				}
			end
		else
			local sound = CreateSound( self, data.sound )
			sound:SetSoundLevel( data.SoundLevel )
			sound:PlayEx(0,100)

			self._ActiveSounds[ id ] = sound
		end
	end
end

function ENT:Think()
	local vehicle = self:GetBase()

	if not IsValid( vehicle ) then return end

	if not self.EngineSounds then
		self.EngineSounds = vehicle.EngineSounds

		return
	end

	local EngineActive = vehicle:GetEngineActive()

	if self._oldEnActive ~= EngineActive then
		self._oldEnActive = EngineActive
		self:OnEngineActiveChanged( EngineActive )
	end

	if EngineActive then
		self:HandleEngineSounds( vehicle )
	else
		self._smTHR = 0
	end
end

function ENT:OnRemove()
	self:StopSounds()
end

function ENT:Draw()
end

function ENT:DrawTranslucent()
end

--addons/lvs_addons/lua/entities/lvs_starfighter_t42/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-20,360,20), 0, 20, 2, 600, 150 )
	self:RegisterTrail( Vector(-20,-360,20), 0, 20, 2, 600, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
	self:AnimAstromech()
end

local mat = Material( "sprites/light_glow02_add" )
function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost()
	
	render.SetMaterial( mat )
	render.DrawSprite( self:LocalToWorld( Vector(-270,0,25) ), Size, Size, Color( 255, 49, 0, 255) )
	render.DrawSprite( self:LocalToWorld( Vector(-270,60,38) ), Size, Size, Color( 255, 49, 0, 255) )
	render.DrawSprite( self:LocalToWorld( Vector(-270,-60,38) ), Size, Size, Color( 255, 49, 0, 255) )
	render.DrawSprite( self:LocalToWorld( Vector(-270,60,118) ), Size, Size, Color( 255, 49, 0, 255) )
	render.DrawSprite( self:LocalToWorld( Vector(-270,-60,118) ), Size, Size, Color( 255, 49, 0, 255) )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01
	
		local emitter = ParticleEmitter( self:GetPos(), false )
		local Pos = {
			Vector(-270,0,25),
			Vector(-270,60,38),
			Vector(-270,-60,38),
			Vector(-270,60,118),
			Vector(-270,-60,118),
			}

		if emitter then
			for _, v in pairs( Pos ) do
				local Sub = Mirror and 1 or -1
				local vOffset = self:LocalToWorld( v )
				local vNormal = -self:GetForward()

				vOffset = vOffset + vNormal * 5

				local particle = emitter:Add( "effects/muzzleflash2", vOffset )
				if not particle then return end

				particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
				particle:SetLifeTime( 0 )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( 255 )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(15,25) )
				particle:SetEndSize( math.Rand(0,10) )
				particle:SetRoll( math.Rand(-1,1) * 100 )
				
				particle:SetColor( 255, 50, 200 )
			
				Mirror = true
			end
			
			emitter:Finish()
		end
end

function ENT:AnimAstromech()
	local T = CurTime()

	if (self.nextAstro or 0) < T then
		self.nextAstro = T + math.Rand(2,5)

		local HasShield = self:GetShield() > 0

		if self.OldShield == true and not HasShield then
			self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/astromech/shieldsdown"..math.random(1,2)..".ogg" )
		else
			if math.random(0,4) == 3 then
				self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/astromech/"..math.random(1,11)..".ogg" )
			end
		end
		
		self.OldShield = HasShield
	end
end

function ENT:AnimCockpit()
end

function ENT:OnStartBoost()
	self:EmitSound( "w_wing_by_1.wav", 125 )
end

function ENT:OnStopBoost()
	self:EmitSound( "w_wing_by_2.wav", 125 )
end

--addons/lvs_base/lua/entities/lvs_turret.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_wire_entity" )

ENT.PrintName		= "Projectile Turret"
ENT.WireDebugName = "Projectile Turret"

ENT.Author		= "Blu-x92"
ENT.Information		= "Projectile Turret"
ENT.Category		= "[LVS]"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false

ENT.Editable = true

ENT.TracerOptions = {
	["LaserBlue"] = "lvs_laser_blue",
	["LaserRed"] = "lvs_laser_red",
	["LaserGreen"] = "lvs_laser_green",
	["TracerGreen"] = "lvs_tracer_green",
	["TracerOrange"] = "lvs_tracer_orange",
	["TracerWhite"] = "lvs_tracer_white",
	["TracerYellow"] = "lvs_tracer_yellow",
	["AutoCannon"] = "lvs_tracer_autocannon",
	["Cannon"] = "lvs_tracer_cannon",
}

ENT.SplashTypeOptions = {
	Shrapnel = "lvs_bullet_impact",
	Explosive = "lvs_bullet_impact_explosive"
}

function ENT:SetupDataTables()
	local TracerOptions = {}

	for id, name in pairs( self.TracerOptions ) do
		if not file.Exists( "effects/"..name..".lua", "LUA" ) then continue end

		TracerOptions[ id ] = name
	end

	self:NetworkVar( "Float",1, "ShootDelay", { KeyName = "Shoot Delay", Edit = { type = "Float", order = 1,min = 0, max = 2, category = "Options"} } )
	self:NetworkVar( "Float",2, "Damage", { KeyName = "Damage", Edit = { type = "Float", order = 2,min = 0, max = 1000, category = "Options"} } )
	self:NetworkVar( "Float",3, "Speed", { KeyName = "Speed", Edit = { type = "Float", order = 3,min = 10000, max = 100000, category = "Options"} } )
	self:NetworkVar( "Float",4, "Size", { KeyName = "Size", Edit = { type = "Float", order = 4,min = 0, max = 50, category = "Options"} } )
	self:NetworkVar( "Float",5, "Spread", { KeyName = "Spread", Edit = { type = "Float", order = 5,min = 0, max = 1, category = "Options"} } )
	self:NetworkVar( "Float",6, "Penetration", { KeyName = "Armor Penetration (mm)", Edit = { type = "Float", order = 6,min = 0, max = 500, category = "Options"} } )
	self:NetworkVar( "Float",7, "SplashDamage", { KeyName = "Splash Damage", Edit = { type = "Float", order = 7,min = 0, max = 1000, category = "Options"} } )
	self:NetworkVar( "Float",8, "SplashDamageRadius", { KeyName = "Splash Damage Radius", Edit = { type = "Float", order = 8,min = 0, max = 750, category = "Options"} } )

	self:NetworkVar( "String", 1, "SplashDamageType", { KeyName = "Splash Damage Type", Edit = { type = "Combo",	order = 9,values = self.SplashTypeOptions,category = "Options"} } )

	self:NetworkVar( "String", 2, "Tracer", { KeyName = "Tracer", Edit = { type = "Combo",	order = 10,values = TracerOptions,category = "Options"} } )

	if SERVER then
		self:SetShootDelay( 0.05 )
		self:SetSpeed( 30000 )
		self:SetDamage( 15 )
		self:SetTracer( "lvs_tracer_orange" )
		self:SetSplashDamageType( "lvs_bullet_impact" )
	end
end

if CLIENT then
	function ENT:GetCrosshairFilterEnts()
		if not istable( self.CrosshairFilterEnts ) then
			self.CrosshairFilterEnts = {self}

			-- lets ask the server to build the filter for us because it has access to constraint.GetAllConstrainedEntities() 
			net.Start( "lvs_player_request_filter" )
				net.WriteEntity( self )
			net.SendToServer()
		end

		return self.CrosshairFilterEnts
	end

	return
end

function ENT:GetCrosshairFilterEnts()
	if not istable( self.CrosshairFilterEnts ) then
		self.CrosshairFilterEnts = {}

		for _, Entity in pairs( constraint.GetAllConstrainedEntities( self ) ) do
			if not IsValid( Entity ) then continue end

			table.insert( self.CrosshairFilterEnts , Entity )
		end

		for _, Parent in pairs( self.CrosshairFilterEnts ) do
			for _, Child in pairs( Parent:GetChildren() ) do
				if not IsValid( Child ) then continue end

				table.insert( self.CrosshairFilterEnts , Child )
			end
		end
	end

	return self.CrosshairFilterEnts
end

function ENT:SpawnFunction( ply, tr, ClassName )

	if not tr.Hit then return end

	local ent = ents.Create( ClassName )
	ent.Attacker = ply
	ent:SetPos( tr.HitPos + tr.HitNormal * 5 )
	ent:Spawn()
	ent:Activate()

	return ent

end

function ENT:TriggerInput( name, value )
	if name == "Fire" then
		self.TriggerFire = value >= 1
	end
end

function ENT:Initialize()	
	self:SetModel( "models/props_junk/PopCan01a.mdl" )
	self:PhysicsInit( SOLID_VPHYSICS )
	self:SetMoveType( MOVETYPE_VPHYSICS )
	self:SetSolid( SOLID_VPHYSICS )
	self:SetCollisionGroup( COLLISION_GROUP_WEAPON  ) 
	
	self:PhysWake()
	
	self.Inputs = WireLib.CreateInputs( self,{"Fire"} )
end

function ENT:SetNextShoot( time )
	self.NextShoot = time
end

function ENT:CanShoot()
	if not self.TriggerFire then return false end
	
	self.NextShoot = self.NextShoot or 0
	
	return self.NextShoot < CurTime()
end

local IsCannon = {
	["lvs_tracer_autocannon"] = 0.25,
	["lvs_tracer_cannon"] = 1,
}

function ENT:Shoot()
	if not self:CanShoot() then return end

	local Tracer = self:GetTracer()

	local bullet = {}
	bullet.Src 	= self:GetPos()
	bullet.Dir 	= self:GetUp()
	bullet.Spread 	= Vector(self:GetSpread(),self:GetSpread(),self:GetSpread())
	bullet.TracerName = Tracer
	bullet.Force	= self:GetPenetration() * 100
	bullet.HullSize 	= self:GetSize()
	bullet.Damage	= self:GetDamage()
	bullet.Velocity = self:GetVelocity():Length() + self:GetSpeed()

	if IsCannon[ Tracer ] then
		self:SetShootDelay( math.max( self:GetShootDelay(), IsCannon[ Tracer ] ) )
	end

	local SplashDamage = self:GetSplashDamage()
	local SplashDamageRadius = self:GetSplashDamageRadius()

	if SplashDamage ~= 0 and SplashDamageRadius ~= 0 then
		bullet.SplashDamage = SplashDamage
		bullet.SplashDamageRadius = SplashDamageRadius

		local SplashEffect = self:GetSplashDamageType()
		local BlastDamage = SplashEffect == "lvs_bullet_impact_explosive"

		bullet.SplashDamageEffect = SplashEffect
		bullet.SplashDamageType = BlastDamage and DMG_BLAST or DMG_SONIC

		if BlastDamage then
			self:SetShootDelay( math.max( self:GetShootDelay(), 0.5 ) )
		end
	end

	bullet.Attacker = IsValid( self.Attacker ) and self.Attacker or self

	bullet.Entity = self
	bullet.SrcEntity = vector_origin

	LVS:FireBullet( bullet )

	self:SetNextShoot( CurTime() + self:GetShootDelay() )
end

function ENT:Think()	

	self.BaseClass.Think( self )
	
	self:Shoot()

	self:NextThink( CurTime() )
	
	return true
end
--addons/lvs_addons/lua/entities/lvs_turret_ai_red/shared.lua:
ENT.Base = "lvs_base_turret"

ENT.PrintName = "Anti-Infantry Turret"
ENT.Author = "Luna"
ENT.Information = "Infantry Problem? Rotary laser cannon says 'Not Anymore.'"
ENT.Category = "[LVS] - Turrets (CIS)"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/antiinfantryturret/Anti-InfantryTurret.mdl"

ENT.AITEAM = 1

ENT.MaxVelocity = 3000
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

ENT.MaxHealth = 4800

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Float", "TurretPitch" )
	self:AddDT( "Float", "TurretYaw" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:TraceTurret()
	local ID = self:LookupAttachment( "muzzle" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:GetAimAngles( ent )
    local trace = ent:GetEyeTrace()
    local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,60) ) ):GetNormalized():Angle() )

    return AimAngles
end

function ENT:WeaponsInRange( ent )
    local AimAngles = self:GetAimAngles( ent )

    return not (AimAngles.p >= 19 or AimAngles.p <= -24)
end

function ENT:InitWeapons()
	local weapon = {}
    weapon.Icon = Material("lvs/weapons/mg.png")
    weapon.Delay = 0.08
    weapon.HeatRateUp = .2
    weapon.HeatRateDown = .3
    weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local base = ent:GetVehicle()

		local ID = self:LookupAttachment( "muzzle" )
		local Muzzle = self:GetAttachment( ID )

		if not Muzzle then return end	

		local Pos = Muzzle.Pos
		local Dir = Muzzle.Ang:Up()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.015,  0.015, 0.015 )
		bullet.TracerName = "lvs_laser_red_short"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 20000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		base.PrimarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )
		ent:LVSFireBullet( bullet )
		
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )	
		if ent:GetVehicle():GetIsCarried( ent ) then
			self:SetPoseParameter("turret_pitch", 0 )
			self:SetPoseParameter("turret_yaw", 0 )
		end
		
		local AimAngles = self:GetAimAngles( ent )

		self:SetPoseParameter("turret_pitch", AimAngles.p )
		self:SetPoseParameter("turret_yaw", AimAngles.y )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"
--addons/lvs_addons/lua/entities/lvs_walker_atte/cl_ikfunctions.lua:

function ENT:OnRemoved()
	self:LegClearAll()
end

local debugred = Color(255,0,0,255)
local debugblue = Color(0,0,255,255)
local debuggreen = Color(0,255,0,255)

function ENT:LegClearAll()
	if istable( self.IK_Joints ) then 
		for _, tab in pairs( self.IK_Joints ) do
			for _,prop in pairs( tab ) do
				if IsValid( prop ) then
					prop:Remove()
				end
			end
		end
		
		self.IK_Joints = nil
	end
end

function ENT:GetLegEnts( index, L1, L2, JOINTANG, STARTPOS, ENDPOS, ATTACHMENTS )
	if not istable( self.IK_Joints ) then self.IK_Joints = {} end

	if self.IK_Joints[ index ] then
		if IsValid( self.IK_Joints[ index ].LegBaseRot ) and IsValid( self.IK_Joints[ index ].LegRotCalc ) then
			if (self.IK_Joints[ index ].LegBaseRot:GetPos() - STARTPOS):Length() > 1 or (self.IK_Joints[ index ].LegRotCalc:GetPos() - STARTPOS):Length() > 1 then
				for k, v in pairs( self.IK_Joints[ index ] ) do
					if IsValid( v ) then
						v:Remove()
					end
				end
				self.IK_Joints[ index ] = nil
			end
		end
	end

	if not self.IK_Joints[ index ] then
		self.IK_Joints[ index ] = {}

		local BaseProp = ents.CreateClientProp()
		BaseProp:SetPos( STARTPOS )
		BaseProp:SetAngles( JOINTANG )
		BaseProp:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		BaseProp:SetParent( self )
		BaseProp:Spawn()

		local LegRotCalc = ents.CreateClientProp()
		LegRotCalc:SetPos( STARTPOS )
		LegRotCalc:SetAngles( JOINTANG )
		LegRotCalc:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		LegRotCalc:SetParent( self )
		LegRotCalc:Spawn()

		local prop1 = ents.CreateClientProp()
		prop1:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 * 0.5) ) )
		prop1:SetAngles( JOINTANG )
		prop1:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop1:SetParent( self )
		prop1:Spawn()

		local prop2 = ents.CreateClientProp()
		prop2:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 + L2) ) )
		prop2:SetAngles( JOINTANG )
		prop2:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop2:SetParent( self )
		prop2:Spawn()

		local prop3 = ents.CreateClientProp()
		prop3:SetPos( STARTPOS )
		prop3:SetAngles( JOINTANG )
		prop3:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop3:SetParent( LegRotCalc )
		prop1:SetParent( prop3 )
		prop3:Spawn()

		local prop4 = ents.CreateClientProp()
		prop4:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1) ) )
		prop4:SetAngles( JOINTANG )
		prop4:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop4:SetParent( prop1 )
		prop2:SetParent( prop4 )
		prop4:Spawn()
		
		self.IK_Joints[ index ].LegBaseRot = BaseProp
		self.IK_Joints[ index ].LegRotCalc = LegRotCalc
		self.IK_Joints[ index ].LegEnt1 = prop1
		self.IK_Joints[ index ].LegEnt2 = prop2
		self.IK_Joints[ index ].LegEnt3 = prop3
		self.IK_Joints[ index ].LegEnt4 = prop4

		for _, v in pairs( self.IK_Joints[ index ] ) do
			v:SetColor( Color( 0, 0, 0, 0 ) )
			v:SetRenderMode( RENDERMODE_TRANSALPHA )
		end

		if ATTACHMENTS then
			if ATTACHMENTS.Leg1 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop3:LocalToWorld( ATTACHMENTS.Leg1.Pos ) )
				prop:SetAngles( prop3:LocalToWorldAngles( ATTACHMENTS.Leg1.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg1.MDL )
				prop:SetParent( prop3 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment1 = prop
			end
			if ATTACHMENTS.Leg2 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop4:LocalToWorld( ATTACHMENTS.Leg2.Pos ) )
				prop:SetAngles( prop4:LocalToWorldAngles( ATTACHMENTS.Leg2.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg2.MDL )
				prop:SetParent( prop4 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment2 = prop
			end
			if ATTACHMENTS.Foot then
				local prop = ents.CreateClientProp()
				prop:SetModel( ATTACHMENTS.Foot.MDL )
				prop:SetParent( prop2 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment3 = prop
			end
		end
	end

	if not IsValid( self.IK_Joints[ index ].LegRotCalc ) or not IsValid( self.IK_Joints[ index ].LegBaseRot ) or not IsValid( self.IK_Joints[ index ].LegEnt1 ) or not IsValid( self.IK_Joints[ index ].LegEnt2 ) or not IsValid( self.IK_Joints[ index ].LegEnt3 ) or not IsValid( self.IK_Joints[ index ].LegEnt4 ) then
		self:LegClearAll()

		return
	end

	self.IK_Joints[ index ].LegRotCalc:SetAngles(self.IK_Joints[ index ].LegBaseRot:LocalToWorldAngles( self.IK_Joints[ index ].LegBaseRot:WorldToLocal( ENDPOS ):Angle() ) )

	local LegRotCalcPos = self.IK_Joints[ index ].LegRotCalc:GetPos()

	local Dist = math.min( (LegRotCalcPos - ENDPOS ):Length(), L1 + L2)
	local Angle1 = 90 - math.deg( math.acos( (Dist ^ 2 + L1 ^ 2 - L2 ^ 2) / (2 * Dist * L1) ) )
	local Angle2 = math.deg( math.acos( (Dist ^ 2 + L2 ^ 2 - L1 ^ 2) / (2 * Dist * L2) ) ) + 90

	self.IK_Joints[ index ].LegEnt3:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle1,180,180) ) )
	self.IK_Joints[ index ].LegEnt4:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle2,180,180) ) )

	if self.IK_Joints[ index ].Attachment3 then
		self.IK_Joints[ index ].Attachment3:SetAngles( self:LocalToWorldAngles( ATTACHMENTS.Foot.Ang ) )
		self.IK_Joints[ index ].Attachment3:SetPos(self.IK_Joints[ index ].LegEnt2:GetPos() + self:GetForward() * ATTACHMENTS.Foot.Pos.x  + self:GetRight() * ATTACHMENTS.Foot.Pos.y + self:GetUp() * ATTACHMENTS.Foot.Pos.z )
	end


	--debug code
	local RFT = RealFrameTime()
	debugoverlay.Cross( self.IK_Joints[ index ].LegBaseRot:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegRotCalc:GetPos(), self.IK_Joints[ index ].LegEnt4:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt4:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegEnt4:GetPos(), self.IK_Joints[ index ].LegEnt2:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt2:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt1:GetPos(), 4, RFT, debugblue, true )
	debugoverlay.Sphere( self.IK_Joints[ index ].LegEnt3:GetPos(), 10, RFT, debugblue, true )
end

--addons/lvs_addons/lua/entities/lvs_walker_atte/sh_turret.lua:

function ENT:SetPosTurret()
	local Turret = self:GetTurretSeat()

	if not IsValid( Turret ) then return end

	local ID = self:LookupAttachment( "driver_turret" )
	local Att = self:GetAttachment( ID )

	if not Att then return end

	local PosL = self:WorldToLocal( Att.Pos + Att.Ang:Right() * 20 - Att.Ang:Up() * 5 )
	Turret:SetLocalPos( PosL )
end

function ENT:SetPoseParameterTurret( weapon )
	if self:GetIsCarried() then
		self:SetPoseParameter("cannon_pitch", 0 )
		self:SetPoseParameter("cannon_yaw", 180 )

		if self.TurretWasSet then
			self.TurretWasSet = nil

			self:SetTurretPitch( 0 )
			self:SetTurretYaw( 180 )
		end

		return
	end

	self.TurretWasSet = true

	if not IsValid( weapon:GetDriver() ) and not weapon:GetAI() then return end

	local AimAng = weapon:WorldToLocal( weapon:GetPos() + weapon:GetAimVector() ):Angle()
	AimAng:Normalize()

	local AimRate = self.TurretTurnRate * FrameTime() 

	self:SetTurretPitch( math.ApproachAngle( self:GetTurretPitch(), AimAng.p, AimRate ) )
	self:SetTurretYaw( math.ApproachAngle( self:GetTurretYaw(), AimAng.y, AimRate ) )

	self:SetPoseParameter("cannon_pitch", self:GetTurretPitch() )
	self:SetPoseParameter("cannon_yaw", self:GetTurretYaw() )
end

function ENT:InitTurret()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 160
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0.6
	weapon.HeatRateDown = 0.25
	weapon.OnOverheat = function( ent ) end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then ent:SetHeat( 0 ) return true end

		base:PlayAnimation( "fire_turret" )

		local ID = base:LookupAttachment( "muzzle_cannon" )
		local Muzzle = base:GetAttachment( ID )

		if not Muzzle then return end

		local bullet = {}
		bullet.Src 	= Muzzle.Pos
		bullet.Dir 	= Muzzle.Ang:Up()
		bullet.Spread 	= Vector(0,0,0)
		bullet.TracerName = "lvs_tracer_proton"
		bullet.Force	= 150000
		bullet.HullSize 	= 1
		bullet.Damage	= 400
		bullet.SplashDamage = 200
		bullet.SplashDamageRadius = 250
		bullet.SplashDamageEffect = "lvs_proton_explosion"
		bullet.SplashDamageType = DMG_AIRBOAT
		bullet.Velocity = 25000
		bullet.Attacker 	= ent:GetDriver()
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(0,0,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Muzzle.Ang:Up() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		if not IsValid( base.SNDTurret ) then return end

		base.SNDTurret:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )		
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetPoseParameterTurret( ent )
		base:SetPosTurret()
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local ID = base:LookupAttachment( "driver_turret" )
		local Att = base:GetAttachment( ID )

		if Att then
			local Pos,_= LocalToWorld( Vector(0,25,110), Angle(0,0,0), Att.Pos, Att.Ang )
			view.origin = Pos
		end

		if not pod:GetThirdPersonMode() then
			return view
		end

		local mn = self:OBBMins()
		local mx = self:OBBMaxs()
		local radius = ( mn - mx ):Length()
		local radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )

		local StartPos = self:LocalToWorld( Vector(95,0,280) )
		local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * (radius * 0.2 + radius * pod:GetCameraHeight())

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.angles = angles + Angle(5,0,0)
		view.origin = tr.HitPos

		if tr.Hit and  not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return end

		local ID = base:LookupAttachment( "muzzle_cannon" )
		local Muzzle = base:GetAttachment( ID )

		if not Muzzle then return end

		local dir = Muzzle.Ang:Up()
		local pos = Muzzle.Pos

		local trace = util.TraceLine( {
			start = pos,
			endpos = (pos + dir * 50000),
			filter = function( entity ) 
				if base:GetCrosshairFilterLookup()[ entity:EntIndex() ] or entity:GetClass():StartWith( "lvs_protontorpedo" ) then
					return false
				end

				return true
			end,
		} )

		local Pos2D = trace.HitPos:ToScreen()

		self:PaintCrosshairCenter( Pos2D )
		self:PaintCrosshairOuter( Pos2D )
		self:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/vehicles/atte/overheat.mp3", 85) end
	self:AddWeapon( weapon, 2 )
end
--addons/lvs_addons/lua/entities/lvs_walker_atte_component.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.AutomaticFrameAdvance = true
ENT.DoNotDuplicate = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
end

if SERVER then
	function ENT:Initialize()	
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
	end

	function ENT:Think()
		return false
	end

	function ENT:OnTakeDamage( dmginfo )
		local base = self:GetBase()

		if not IsValid( base ) then return end

		base:OnTakeDamage( dmginfo )
	end

	function ENT:PhysicsCollide( data, phys )
		local base = self:GetBase()

		if not IsValid( base ) then return end

		base:PhysicsCollide( data, phys )
	end

	function ENT:Use( ply )
		if (ply._lvsNextUse or 0) > CurTime() then return end

		local base = self:GetBase()

		if not IsValid( base ) then return end

		base:Use( ply )
	end

	function ENT:UpdateTransmitState() 
		return TRANSMIT_ALWAYS
	end

	return
end

function ENT:Draw()
	self:DrawModel()
end

function ENT:Think()
end

function ENT:OnRemove()
end
--addons/lvs_addons/lua/entities/lvs_walker_hsd_leg.lua:
AddCSLuaFile()

ENT.Type            = "anim"

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
	self:NetworkVar( "String",0, "LocationIndex" )
end

if SERVER then
	function ENT:Initialize()	
		self:SetModel( "models/blu/hsd_leg_1.mdl" )
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
	end

	function ENT:Think()
		return false
	end
else 
	include( "entities/lvs_walker_atte/cl_ikfunctions.lua" )

	local Length1 = 140
	local Length2 = 300

	local Length3 = 20
	local Length4 = 20

	local LegData1 = {
		Leg1 = {MDL = "models/blu/hsd_leg_2.mdl", Ang = Angle(0,-90,-90), Pos = Vector(0,0,0)},
		Leg2 = {MDL = "models/blu/hsd_leg_4.mdl", Ang = Angle(180,90,4), Pos = Vector(20,0,-12)},
		Foot = {MDL = "models/blu/hsd_foot.mdl", Ang = Angle(0,0,0), Pos = Vector(0,-2,0)}
	}

	local LegData2 = {
		Leg1 = {MDL = "models/blu/hsd_leg_3.mdl", Ang = Angle(0,90,-90), Pos = Vector(0,0,0)},
	}

	local StartPositions = {
		["FL"] = Vector(150,270,0),
		["FR"] = Vector(150,-270,0),
		["RL"] = Vector(-150,270,0),
		["RR"] = Vector(-150,-270,0),
	}

	local LocToID = {
		[1] = "RL",
		[2] = "FL",
		[3] = "RR",
		[4] = "FR",
	}

	function ENT:Think()
		local Base = self:GetBase()

		if not IsValid( Base ) then return end

		if Base:GetIsRagdoll() then 
			self:LegClearAll()

			return
		end

		local LocIndex = self:GetLocationIndex()

		if not Base:HitGround() then
			local Pos = Base:LocalToWorld( StartPositions[ LocIndex ] )

			self:RunIK( Pos, Base )
			self._OldPos = Pos
			self._smPos = Pos

			return
		end

		local Up = Base:GetUp()
		local Forward = Base:GetForward()
		local Vel = Base:GetVelocity()

		local Speed = Vel:Length()
		local VelForwardMul = math.min( Speed / 100, 1 )
		local VelForward = Vel:GetNormalized() * VelForwardMul + Forward * (1 - VelForwardMul)

		local TraceStart = Base:LocalToWorld( StartPositions[ LocIndex ] ) + VelForward * math.Clamp( 400 - Speed * 2, 100, 200 ) * VelForwardMul

		local trace = util.TraceLine( { 
			start = TraceStart + Vector(0,0,200),
			endpos = TraceStart - Vector(0,0,100), 
			filter = function( ent ) 
				if ent == Base or Base.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end 

				return true
			end,
		} )

		local UpdateLeg = LocToID[ Base:GetUpdateLeg() ] == LocIndex

		self._OldPos = self._OldPos or trace.HitPos
		self._smPos = self._smPos or self._OldPos

		if self._OldUpdateLeg ~= UpdateLeg then
			self._OldUpdateLeg = UpdateLeg

			if UpdateLeg then
				self.UpdateNow = true
			end
		end

		if self.UpdateNow and not self.MoveLeg then
			sound.Play( Sound( "lvs/vehicles/hsd/hydraulic_stop0"..math.random(1,2)..".wav" ), self:GetPos(), SNDLVL_100dB )

			self.UpdateNow = nil
			self.MoveLeg = true
			self.MoveDelta = 0
		end

		local ShaftOffset = 0
		local ENDPOS = self._smPos + Up * 20

		if self.MoveLeg then
			local traceWater = util.TraceLine( {
				start = TraceStart + Vector(0,0,200),
				endpos = ENDPOS,
				filter = Base:GetCrosshairFilterEnts(),
				mask = MASK_WATER,
			} )

			if traceWater.Hit then
				local T = CurTime()

				if (self._NextFX or 0) < T then
					self._NextFX = T + 0.05
	
					local effectdata = EffectData()
						effectdata:SetOrigin( traceWater.HitPos )
						effectdata:SetEntity( Base )
						effectdata:SetMagnitude( 50 )
					util.Effect( "lvs_hover_water", effectdata )
				end
			end

			if self.MoveDelta >= 1 then
				self.MoveLeg = false
				self.MoveDelta = nil

				sound.Play( Sound( "lvs/vehicles/hsd/footstep0"..math.random(1,3)..".wav" ), ENDPOS, SNDLVL_100dB )

				local effectdata = EffectData()
					effectdata:SetOrigin( trace.HitPos )
				util.Effect( "lvs_walker_stomp", effectdata )

				sound.Play( Sound( "lvs/vehicles/hsd/hydraulic_start0"..math.random(1,2)..".wav" ), self:GetPos(), SNDLVL_100dB )
			else
				self.MoveDelta = math.min( self.MoveDelta + RealFrameTime() * 2, 1 )
	
				self._smPos = LerpVector( self.MoveDelta, self._OldPos, trace.HitPos )

				local MulZ =  math.max( math.sin( self.MoveDelta * math.pi ), 0 )

				ShaftOffset = MulZ ^ 2 * 30
				ENDPOS = ENDPOS + Up * MulZ * 50
			end
		else
			self._OldPos = self._smPos
		end

		self:RunIK( ENDPOS, Base, ShaftOffset )
	end

	function ENT:RunIK( ENDPOS, Base, shaftoffset )
		shaftoffset = shaftoffset or 0

		local Ang = Base:WorldToLocalAngles( (ENDPOS - self:GetPos()):Angle() )

		self:SetAngles( Base:LocalToWorldAngles( Angle(0,Ang.y + 90,0) ) )

		local ID = self:LookupAttachment( "lower" )
		local Att = self:GetAttachment( ID )

		if not Att then return end

		local Pos, Ang = WorldToLocal( ENDPOS, (ENDPOS - Att.Pos):Angle(), Att.Pos, self:LocalToWorldAngles( Angle(0,-90,0) ) )

		local STARTPOS = Att.Pos

		self:GetLegEnts( 1, Length1, Length2, self:LocalToWorldAngles( Angle(0,180,135) ), STARTPOS, ENDPOS, LegData1 )

		if not self.IK_Joints[ 1 ] or not IsValid( self.IK_Joints[ 1 ].Attachment2 ) then return end

		local shaft = self.IK_Joints[ 1 ].Attachment2

		shaft:SetPoseParameter( "extrude", shaftoffset )
		shaft:InvalidateBoneCache()

		local ID1 = self:LookupAttachment( "upper" )
		local Start = self:GetAttachment( ID1 )

		if not Start then return end

		local ID2 = shaft:LookupAttachment( "upper_end" )
		local End = shaft:GetAttachment( ID2 )

		if not End then return end

		self:GetLegEnts( 2, Length3, Length4, self:LocalToWorldAngles( Angle(0,0,-45) ), Start.Pos, End.Pos, LegData2 )

		if not self.IK_Joints[ 2 ] or not IsValid( self.IK_Joints[ 2 ].Attachment1 ) then return end

		local strut = self.IK_Joints[ 2 ].Attachment1
		strut:SetPoseParameter( "extrude", (Start.Pos - End.Pos):Length() )
		strut:InvalidateBoneCache()
	end

	function ENT:OnRemove()
		self:OnRemoved()
	end

	function ENT:Draw()
		local Base = self:GetBase()

		if not IsValid( Base ) then return end

		if Base:GetIsRagdoll() then return end

		self:DrawModel()
	end
end
--addons/joes_stuff/lua/entities/shield_bubble_personal/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName= "Personal Shield"
ENT.Author= "Joe + JackJack + Nvc"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Category = "Joe"
ENT.AutomaticFrameAdvance = true

function ENT:TestCollision( startpos, delta, isbox, extents, mask )
	local rad = self:GetRadius()
	local dist = startpos:DistToSqr(self:GetPos())
	if rad and dist < rad ^ 2 and bit.band( mask, CONTENTS_EMPTY ) == 0 then
		return false
	else
		return true
	end
end

function ENT:SetupDataTables()

	self:NetworkVar( "Int", 0, "Radius" )
 	self:NetworkVar( "Entity", 0, "ShieldOwner" )

end

--addons/sse_101/lua/entities/sse_base.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "SSE_Base"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "SSE"
ENT.Spawnable       = false
ENT.Editable = false

ENT.ConfigName = "DefaultEntity"
ENT.ClientInteraction = false
ENT.NoHudName = false

function ENT:ConfigValue(key)

    if !SSE.Config[self.ConfigName] then print("!!!!!!! You messed something up in the SSE-Config ("..self.ConfigName.." missing)") end
    if !SSE.Config[self.ConfigName][key] then print("!!!!!! You messed something up in the SSE-Config ("..self.ConfigName.."/"..key.." missing)") end

    return SSE.Config[self.ConfigName][key]
end

function ENT:ConfigValueNoPrint(key)

    return SSE.Config[self.ConfigName][key]
end

function ENT:Initialize()

    self:SetModel( self:ConfigValue("Model") )
    self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
    self:SetSolid( SOLID_VPHYSICS )         -- Toolbox


    if !self.NoHudName then
        self.SSE_HUDName = self:ConfigValue("HUDName")
    end
 
    if SERVER then 
        self:PhysicsInit( SOLID_VPHYSICS ) 
        self:SetUseType( SIMPLE_USE )
    end
    self:PhysWake()
end

if SERVER then 

    util.AddNetworkString("SSE_ClientInteraction")
    util.AddNetworkString("SSE_InvalidateUseConfirm")

    function ENT:Use( activator, caller )

        if self.ClientInteraction then 
            if SSE:AntiSpam(activator) then return end
            activator.SSE_CurrentEntity = self
            net.Start("SSE_ClientInteraction")
                net.WriteEntity(self)
            net.Send(activator)
        end
    end

    function ENT:ConfirmUse(ply)
        if !IsValid(ply) then return false end
        if ply.SSE_CurrentEntity != self then return false end

        return true
    end

    function ENT:InvalidateUseConfirm(ply)
        if self:ConfirmUse(ply) then
            ply.SSE_CurrentEntity = nil
        end
    end

    net.Receive("SSE_InvalidateUseConfirm", function(len, ply)
        local ent = net.ReadEntity()
       
        ent:InvalidateUseConfirm(ply)
    end)

end 


if CLIENT then 

    function ENT:ClientUse()
       print("Client use set to true, but no ClientUse function defined.")
    end

    net.Receive("SSE_ClientInteraction", function(len, ply)
        local ent = net.ReadEntity()

       
        ent:ClientUse()
    end)

    function ENT:InvalidateUseConfirm(ply)
        local ply = LocalPlayer()

        net.Start("SSE_InvalidateUseConfirm")
        net.WriteEntity(self)
        net.SendToServer()
    end


    function ENT:Draw()
        self:DrawModel()
    end
end

--addons/sse_101/lua/entities/sse_closet.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "sse_base"

ENT.PrintName		= "Closet"
ENT.Spawnable       = true
ENT.ConfigName = "Closet"
ENT.ClientInteraction = true
ENT.Category        = "SSE"

if SERVER then
        


        util.AddNetworkString("SSE_Closet_SetModel")
        util.AddNetworkString("SSE_Closet_SetSkin")
        util.AddNetworkString("SSE_Closet_SetBodygroup")
    

        local function handleModelChange(len, ply)

            if SSE:AntiSpam(ply) then return end
            local model = net.ReadString()
            local closetEntity = net.ReadEntity()
            if not IsValid(ply) or not ply:IsPlayer() or not ply:Alive() then return end
            if !closetEntity:ConfirmUse(ply) then return end
    
            local getModelFunc = closetEntity:ConfigValue("GetModels")
            local modelTable = getModelFunc(ply)
            if table.HasValue(modelTable, model) then
                ply:SetModel(model)
            end
        end
        net.Receive("SSE_Closet_SetModel", handleModelChange)
    
        local function handleSkinChange(len, ply)

            --if SSE:AntiSpam(ply) then return end
            local skin = net.ReadInt(8)
            local closetEntity = net.ReadEntity()
            if not IsValid(ply) or not ply:IsPlayer() or not ply:Alive() then return end
            if !closetEntity:ConfirmUse(ply) then return end

            if skin < 0 or skin >= ply:SkinCount() then return end

            ply:SetSkin(skin)
           
        end
        net.Receive("SSE_Closet_SetSkin", handleSkinChange)
    
        local function handleBodygroupChange(len, ply)

            --if SSE:AntiSpam(ply) then return end
            local bodygroup = net.ReadInt(8)
            local submodel = net.ReadInt(8)
            local closetEntity = net.ReadEntity()
            if not IsValid(ply) or not ply:IsPlayer() or not ply:Alive() then return end
            if !closetEntity:ConfirmUse(ply) then return end

            if bodygroup < 0 or bodygroup >= ply:GetNumBodyGroups() then return end
            if submodel < 0 or submodel >= ply:GetBodygroupCount(bodygroup) then return end

            ply:SetBodygroup(bodygroup, submodel)
        end
        net.Receive("SSE_Closet_SetBodygroup", handleBodygroupChange)
    end
    
    if CLIENT then
        local function createClosetSection(name, parent)
            local section = vgui.Create("DPanel", parent)
            section:Dock(TOP)
            section:DockMargin(0, 0, 0, 5)
            section:SetTall(SSEH(80)) -- Default initial height for just the label
            section:SetDrawBackground(false)
        
            local sectionLabel = vgui.Create("DLabel", section)
            sectionLabel:Dock(TOP)
            sectionLabel:SetWide(SSEW(200))
            sectionLabel:SetTall(SSEH(40))
            sectionLabel:SetFont(SSE.xFont("!Agency FB@45#1000"))
            sectionLabel:SetText(name)
            sectionLabel:SetTextColor(Color(255, 255, 255))
        
            local sectionContent = vgui.Create("DIconLayout", section)
            sectionContent:Dock(FILL)
            sectionContent:SetSpaceY(5) -- Reduced spacing to avoid excessive height
            sectionContent:SetSpaceX(5)

        
            -- Adjust the section height based on the number of rows
            function sectionContent:adjustSectionHeight()
                local parentWidth = SSE_ClosetFrame:GetWide() * 0.48
                local totalWidth = 0
                local rows = 0

                for _, child in ipairs(self:GetChildren()) do
                    totalWidth = totalWidth + SSEW(35) + 5

                    if totalWidth > parentWidth then
                        rows = rows + 1
                        totalWidth = SSEW(35) + 5 -- Reset totalWidth for the next row
                    end
                end

                section:SetTall(SSEH(80) + rows * SSEH(45))
            end
        
            return sectionContent
        end
        
        
        function SSE_OpenClosetMenu(closetEnt)
            if !IsValid(LocalPlayer()) then return end
            if !IsValid(closetEnt) then return end 
            if !closetEnt:GetClass() == "sse_closet" then return end

            if SSE_ClosetFrame then SSE_ClosetFrame:Remove() end
            SSE_ClosetFrame = SSE:DefaultFrame("Closet")
            SSE_ClosetFrame:SetSize(SSEW(1200), ScrH() * 0.8)
            SSE_ClosetFrame:Center()

            function SSE_ClosetFrame:OnRemove()
                if IsValid(closetEnt) then
                    closetEnt:InvalidateUseConfirm(LocalPlayer())
                end
            end
    
            local leftPanel = vgui.Create("DPanel", SSE_ClosetFrame)
            leftPanel:Dock(LEFT)
            leftPanel:SetWide(SSE_ClosetFrame:GetWide() * 0.48)
            leftPanel.Paint = nil
    
            local saveBtns = vgui.Create("DPanel", leftPanel)
            saveBtns:Dock(TOP)
            saveBtns:SetTall(SSEH(50))
            saveBtns.Paint = nil
    
            local function saveCurrentState()
                local playerModel = LocalPlayer():GetModel()
                local bodygroups = {}
                for k, v in pairs(LocalPlayer():GetBodyGroups()) do
                    bodygroups[v.id] = LocalPlayer():GetBodygroup(v.id)
                end
                local skin = LocalPlayer():GetSkin()
                local saveData = {bodygroups = bodygroups, skin = skin}
                cookie.Set("SSE-Closet-"..playerModel, util.TableToJSON(saveData))
    
                SSE_OpenClosetMenu(closetEnt)
            end
    
            local function loadSavedState()
                local playerModel = LocalPlayer():GetModel()
                local savedData = cookie.GetString("SSE-Closet-"..playerModel)
                if savedData then
                    savedData = util.JSONToTable(savedData)
    
                    net.Start("SSE_Closet_SetSkin")
                    net.WriteInt(savedData.skin, 8)
                    net.WriteEntity(closetEnt)
                    net.SendToServer()
    
                    SSE_ClosetFrame.modelViewer.Entity:SetSkin(savedData.skin)
                    for id, bodygroup in pairs(savedData.bodygroups) do
                        net.Start("SSE_Closet_SetBodygroup")
                        net.WriteInt(id,8)
                        net.WriteInt(bodygroup,8)
                        net.WriteEntity(closetEnt)
                        net.SendToServer()
    
                        SSE_ClosetFrame.modelViewer.Entity:SetBodygroup(id, bodygroup)
                    end
                end
            end
    
            local saveBtn = SSE:Button(saveBtns, closetEnt:ConfigValue("Save"), function() saveCurrentState() end, "bc")
            saveBtn:Dock(RIGHT)
            saveBtn:DockMargin(5, 0, 5, 0)
    
            local loadBtn = SSE:Button(saveBtns, closetEnt:ConfigValue("Load"), function() loadSavedState() end, "bc")
            loadBtn:Dock(RIGHT)
            loadBtn:DockMargin(5, 0, 5, 0)
    
            local playerModel = LocalPlayer():GetModel()
            local savedData = cookie.GetString("SSE-Closet-"..playerModel)
            if not savedData then
                loadBtn:SetVisible(false)
            end
    
            SSE_ClosetFrame.modelViewer = vgui.Create("DModelPanel", leftPanel)
            SSE_ClosetFrame.modelViewer:Dock(FILL)
            SSE_ClosetFrame.modelViewer:SetModel(LocalPlayer():GetModel())
            SSE_ClosetFrame.modelViewer:SetFOV(40)
    
            function SSE_ClosetFrame.modelViewer:UpdateModel()
                self.Entity:SetSkin(LocalPlayer():GetSkin())
                for _, v in pairs(LocalPlayer():GetBodyGroups()) do
                    self.Entity:SetBodygroup(v.id, LocalPlayer():GetBodygroup(v.id))
                end
                for k, v in pairs(LocalPlayer():GetMaterials()) do
                    if LocalPlayer():GetSubMaterial(k) ~= "" then
                        self.Entity:SetSubMaterial(k, LocalPlayer():GetSubMaterial(k))
                    end
                end
            end
    
            SSE_ClosetFrame.modelViewer:UpdateModel()
    
            function SSE_ClosetFrame.modelViewer:LayoutEntity(ent)
                if (self.bAnimated) then self:RunAnimation() end
                if (self.Dragging) then
                    local mx, my = gui.MousePos()
                    self.Angles = self.Angles - Angle(0, (self.Dragging[1] - mx) * 0.5, 0)
                    self.Dragging[1] = mx
                end
    
                if (self.Holding) then
                    local mx, my = gui.MousePos()
                    self.Angles = self.Angles - Angle((self.Holding[2] - my) * 0.5, 0, 0)
                    self.Holding[2] = my
                end
    
                SSE_ClosetFrame.modelViewer:SetLookAt(Vector(0, 0, 50))
                SSE_ClosetFrame.modelViewer:SetCamPos(Vector(64, 0, 50))
                self.Entity:SetAngles(self.Angles)
            end
    
            function SSE_ClosetFrame.modelViewer:OnMousePressed(mousecode)
                if (mousecode == MOUSE_LEFT) then
                    self.Dragging = {gui.MousePos()}
                    self:MouseCapture(true)
                end
            end
    
            function SSE_ClosetFrame.modelViewer:OnMouseReleased(mousecode)
                if (mousecode == MOUSE_LEFT) then
                    self.Dragging = nil
                    self:MouseCapture(false)
                end
            end
    
            function SSE_ClosetFrame.modelViewer:OnMouseWheeled(delta)
                local minZoom, maxZoom = 20, 100
                local zoom = self:GetFOV() - delta * 5
                zoom = math.Clamp(zoom, minZoom, maxZoom)
                self:SetFOV(zoom)
                return true
            end
    
            SSE_ClosetFrame.modelViewer:SetLookAt(Vector(0, 0, 50))
            SSE_ClosetFrame.modelViewer:SetCamPos(Vector(64, 0, 50))
            SSE_ClosetFrame.modelViewer.Angles = Angle(0, 0, 0)
    
            local rightPanel = vgui.Create("DPanel", SSE_ClosetFrame)
            rightPanel:Dock(RIGHT)
            rightPanel:SetWide(SSE_ClosetFrame:GetWide() * 0.48)
            rightPanel.Paint = function(self, w, h)
                draw.RoundedBox(0, 0, 0, 1, h, Color(255, 255, 255, 200))
            end
            rightPanel:DockPadding(SSEW(10), SSEH(10), 0, SSEH(10))
    
            local scrollPanel = SSE:ScrollBar(rightPanel)
            scrollPanel:Dock(FILL)
    
            local modelSection = createClosetSection("Models", scrollPanel)
            local getModelsFunc = closetEnt:ConfigValue("GetModels")
            local models = getModelsFunc(LocalPlayer())
            if istable(models) then
                for name, model in pairs(models) do


    
                        local btn = SSE:Button(modelSection, name, function()
                            net.Start("SSE_Closet_SetModel")
                            net.WriteString(model)
                            net.WriteEntity(closetEnt)
                            net.SendToServer()
                            SSE_ClosetFrame:Remove()
                        end, "bc")
                        btn:SetWide(SSEW(35))  



                end
            end
            modelSection:adjustSectionHeight()
    
            if LocalPlayer():SkinCount() - 1 > 1 then
                local skinSection = createClosetSection("Skins", scrollPanel)
                for i = 0, LocalPlayer():SkinCount() - 1 do
                    local btn = SSE:Button(skinSection, i, function()
                        net.Start("SSE_Closet_SetSkin")
                        net.WriteInt(i, 8)
                        net.WriteEntity(closetEnt)
                        net.SendToServer()
                        SSE_ClosetFrame.modelViewer.Entity:SetSkin(i)
                    end, "bc")
                    btn:SetWide(SSEW(35))
                end
                skinSection:adjustSectionHeight()
            end
    
            local bodygroups = {}
            for _, group in pairs(LocalPlayer():GetBodyGroups()) do
                local groupName = group.name
                bodygroups[groupName] = {}
                for submodel in pairs(group.submodels) do
                    table.insert(bodygroups[groupName], submodel)
                end
            end
    
            for groupName, submodels in pairs(bodygroups) do
                if #submodels < 2 then continue end
                local bodygroupSection = createClosetSection(groupName, scrollPanel)
                for submodelIndex, submodelName in pairs(submodels) do
                    local btn = SSE:Button(bodygroupSection, submodelName, function()
                        net.Start("SSE_Closet_SetBodygroup")
                        net.WriteInt(LocalPlayer():FindBodygroupByName(groupName),8)
                        net.WriteInt(submodelName,8)
                        net.WriteEntity(closetEnt)
                        net.SendToServer()
                        SSE_ClosetFrame.modelViewer.Entity:SetBodygroup(SSE_ClosetFrame.modelViewer.Entity:FindBodygroupByName(groupName), submodelName)
                    end, "bc")
                    btn:SetWide(SSEW(35))
                end
                bodygroupSection:adjustSectionHeight()
            end
        end
    
        function ENT:ClientUse()
            SSE_OpenClosetMenu(self)
         end
    end
    


--addons/aoc_nextbots/lua/entities/summe_boarding_pod_landed/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
 
ENT.PrintName = "Boarding Pod (landed)"
ENT.Category = "Summe"
ENT.Spawnable = false
ENT.Editable = true

ENT.NPCs = {
    "aocrp_nextbot_b1",
    "aocrp_nextbot_b1_heavy",
    "aocrp_nextbot_b2",
}
--addons/aoc_nextbots/lua/entities/summe_dispenser_flying/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
 
ENT.PrintName = "Dispenser Pod"
ENT.Category = "Summe"
ENT.Spawnable = false
ENT.Editable = true

ENT.NPCs = {
    "aocrp_nextbot_b1",
    "aocrp_nextbot_b1_heavy",
    "aocrp_nextbot_b2",
}

function ENT:SetupDataTables()
    self:NetworkVar("Bool", 0, "Landed", { KeyName = "Landed", Edit = { type = "Boolean", order = 1, category = "Settings"}})
end
--addons/aoc_nextbots/lua/entities/summe_dispenser_landed/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
 
ENT.PrintName = "Dispenser Pod"
ENT.Category = "Summe"
ENT.Spawnable = false
ENT.Editable = true

ENT.NPCs = {
    "aocrp_nextbot_b1",
    "aocrp_nextbot_b1_heavy",
    "aocrp_nextbot_b2",
}
--lua/entities/swrp_stretcher/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Medical Stretcher"
ENT.Author = "Owain Owjo"
ENT.Category = "StarWarsRP - Owain"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = true
ENT.AdminSpawnable = true


--addons/arccw_weapons/lua/entities/thermal_thrown/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Thermal Detonator (Thrown)"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/ThermalDetonator_thrown.mdl"
ENT.FuseTime = 2
ENT.ArmTime = 0
ENT.ImpactFuse = false

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
	    phys:SetMass(10)
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.kt = CurTime() + self.FuseTime
        self.at = CurTime() + self.ArmTime
    end
end

function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        if data.Speed > 75 then
            self:EmitSound(Sound("weapons/star_wars_battlefront/common/imp_grenade_stone_0" .. math.random(1,3) .. ".wav"))
        elseif data.Speed > 25 then
            self:EmitSound(Sound("weapons/star_wars_battlefront/common/imp_grenade_dirt_0" .. math.random(1,3) .. ".wav"))
        end
		self:SetAngles(Angle(0,0,0))
        if self.at <= CurTime() and self.ImpactFuse then
            self:Detonate()
	

        end
    end
end

function ENT:Think()
	
    if SERVER and CurTime() >= self.kt then
        self:Detonate()
    end
end

function ENT:Detonate()
    if SERVER then
        if not self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_thermal_detonator", self:GetPos(), self:GetAngles() )
sound.Play( "weapons/star_wars_battlefront/common/exp_ord_thermalDetonator0" .. math.random(1,2) .. ".wav",  self:GetPos(), 100, 100 )
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        util.BlastDamage(self, attacker, self:GetPos(), 350, 175)
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),18000,500,1.2,2048)
        self:Remove()

    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()
		
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/swbf/flare0") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(30, 40), math.random(30, 40), Color(155, 50, 50) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
      
    end
end
--addons/tools/lua/entities/vanilla_shipdestruction/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:Think()
end

function ENT:OnRemove()
end

--addons/arccw_weapons/lua/effects/arccw_apex_melee_blur/init.lua:
local ang

EFFECT.ParticleName = "weapon_melee_blur"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment() or 1
    self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt:IsFirstPerson() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.Forward = self.Forward or data:GetNormal()
    self.Angle = self.Forward:Angle()

    self.Right = self.Angle:Right()
    self.vOffset = self.Position
    dir = self.Forward

    ParticleEffectAttach( self.ParticleName, PATTACH_POINT_FOLLOW, self.WeaponEnt, self.Attachment)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end

--addons/arccw_weapons/lua/effects/arccw_apex_muzzle_energy_medium/init.lua:
local ang

EFFECT.ParticleName = "tfa_apex_energy_muzzle_medium"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment() or 1
    self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt:IsFirstPerson() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.Forward = self.Forward or data:GetNormal()
    self.Angle = self.Forward:Angle()
    
    local dlight = DynamicLight(self.WeaponEnt:EntIndex())
    if (dlight) then
        dlight.pos = self.Position + self.Angle:Up() * 3 + self.Angle:Right() * -2
        dlight.r = 85
        dlight.g = 178
        dlight.b = 255
        dlight.brightness = 5
        dlight.Size = math.Rand(32, 64)
        dlight.Decay = math.Rand(32, 64) / 0.05
        dlight.DieTime = CurTime() + 0.05
    end
    
    self.Right = self.Angle:Right()
    self.vOffset = self.Position
    dir = self.Forward

    ParticleEffectAttach( self.ParticleName, PATTACH_POINT_FOLLOW, self.WeaponEnt, self.Attachment)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end

--addons/arccw_weapons/lua/effects/arccw_apex_muzzle_energy_shotty/init.lua:
local ang

EFFECT.ParticleName = "tfa_apex_energy_muzzle_shotgun"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment() or 1
    self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt:IsFirstPerson() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.Forward = self.Forward or data:GetNormal()
    self.Angle = self.Forward:Angle()
    
    local dlight = DynamicLight(self.WeaponEnt:EntIndex())
    if (dlight) then
        dlight.pos = self.Position + self.Angle:Up() * 3 + self.Angle:Right() * -2
        dlight.r = 85
        dlight.g = 178
        dlight.b = 255
        dlight.brightness = 5
        dlight.Size = math.Rand(32, 64)
        dlight.Decay = math.Rand(32, 64) / 0.05
        dlight.DieTime = CurTime() + 0.05
    end
    
    self.Right = self.Angle:Right()
    self.vOffset = self.Position
    dir = self.Forward

    ParticleEffectAttach( self.ParticleName, PATTACH_POINT_FOLLOW, self.WeaponEnt, self.Attachment)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end

--addons/arccw_weapons/lua/effects/arccw_apex_tracer_ar/init.lua:
EFFECT.TracerName = "tfa_apex_tracer_ar"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    --print(self.ParticleName)
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment() or 1
    self.Position = self:GetTracerShootPos(data:GetStart(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.EndPos = data:GetOrigin()
    -- util.ParticleTracerEx(self.ParticleName, self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_POINT, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(0,self.Position)
        pcf:SetControlPoint(1,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(5.0, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--addons/arccw_weapons/lua/effects/arccw_apex_tracer_smg/init.lua:
EFFECT.TracerName = "tfa_apex_tracer_smg"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    --print(self.ParticleName)
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment() or 1
    self.Position = self:GetTracerShootPos(data:GetStart(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.EndPos = data:GetOrigin()
    -- util.ParticleTracerEx(self.ParticleName, self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_POINT, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(0,self.Position)
        pcf:SetControlPoint(1,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(5.0, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--addons/arccw_weapons/lua/effects/astw2_halo2_explosion_rocket/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 225
            light.g = 155
            light.b = 200
            light.Brightness = 3
            light.Decay = 10
            light.Size = 512
            light.DieTime = CurTime() + 0.3
        end
    local particle = emitter:Add("effects/halo3/8pt_ringed_star_flare", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.2 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(5,15) )
    particle:SetEndSize( math.Rand(150,300) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(0,0) )
    particle:SetColor( 255, 255, 255 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )
	

    for i= 0,5 do
   local particle = emitter:Add("effects/halo3/smoke_dark", self.Origin)

    particle:SetVelocity( Vector(math.Rand(-100, 100),math.Rand(-100, 100),math.Rand(250, 400)) )
    particle:SetDieTime( math.Rand(2,3) )
    particle:SetStartAlpha( 25 )
    particle:SetEndAlpha( 100 )
    particle:SetStartSize( math.Rand(95,100) )
    particle:SetEndSize( math.Rand(125,135) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(-0.5,0.5) )
    particle:SetColor( 155, 155, 155 )
    particle:SetAirResistance( 55 )
    particle:SetGravity( Vector( 0, 0, math.Rand(-325,-425) ) )
    particle:SetLighting( true )
    particle:SetCollide( false )
	end

		for i= 0,5 do
        particle = emitter:Add( "effects/halo2/explosion_0" .. math.random(1,2) , self.Origin )
        particle:SetVelocity( 7 * Vector(math.Rand(-50, 50),math.Rand(-50, 50),math.Rand(20, 50)) )
        particle:SetDieTime( math.Rand(0.5, 0.9) )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(50,75) )
        particle:SetEndSize( math.Rand(125,150) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,math.Rand( 200, 225 ),math.Rand( 175, 200 ) )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,25) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
	end

    for i = 0,5 do
        particle = emitter:Add( "effects/halo2/explosion_01" , self.Origin )

        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.5, 0.7) )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(200,275) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,255,200 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
    end

    particle = emitter:Add( "effects/halo3/explosive_burst", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.25, 0.3) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(250,400) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,200,50 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--addons/arccw_weapons/lua/effects/effect_astw2_halo2_tracer_spiker/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 64;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo3/trails/trail_ar" );
local MaterialFront			= Material( "effects/halo3/flare1" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 8, 8, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 10, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_halo3_impact_sentinel_beam/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/swbf/sparks" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/swrc/elite_beam_impact", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.5 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 25, 30 ) );
			particle:SetEndSize( 20 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo3_impact_spartan_laser/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/halo3/8pt_ringed_star_flare" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
	
	
	for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/electric_arcs", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.2, 0.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 25, 30 ) );
			particle:SetEndSize( 55 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 200, 200);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		for i = 1, 4 do

			local particle = emitter:Add( "effects/halo3/flash_large", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.1, 0.15 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 55, 60 ) );
			particle:SetEndSize( 5 );
			particle:SetRoll( math.Rand(-60, 60) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 175, 175);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		for i = 1, 4 do

			local particle = emitter:Add( "effects/halo3/flash_large", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.2, 0.45 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 75, 85 ) );
			particle:SetEndSize( 15 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 175, 175);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		
		for i = 1, 5 do

			local particle = emitter:Add( "effects/halo3/muzzle_flash_round_gaseous", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.5 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 10, 15 ) );
			particle:SetEndSize( 85 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );
			particle:SetColor(255, 100, 100, 100);
		end
		emitter:Finish();
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( 255, 100, 100, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo3_tracer_beam/init.lua:

local Tracer = Material( "effects/halo2/plasma_contrail" )
local Tracer2  = Material( "effects/halo2/plasma_contrail" )
local Width = 5
local Width2 = 2

function EFFECT:Init( data )

	-- self.Position = data:GetStart()
	self.Entity=data:GetEntity()
	if !IsValid(self.Entity) then return end
	self.Position = self.Entity:GetAttachment(1).Pos
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.05
	self.LifeTime2 = 0.07
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 100, 75, v * 155 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 100, 75, (v2 * 100)*3/2.5 ) )

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo3_tracer_carbine/init.lua:

local Tracer = Material( "effects/halo3/energy_braids" )
local Tracer2  = Material( "effects/halo3/energy_trail" )
local Width = 4
local Width2 = 8

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.25
	self.LifeTime2 = 0.15
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 115, 255, 50, v * 155 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 185, 255, 115, (v2 * 100)*3/2.5 ) )

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_plasma_pink_burn/init.lua:

local Tracer = Material( "effects/halo2/c_gun_turret_contrail" )
local Tracer2  = Material( "effects/halo3/spartanlaser" )
local Width = 10
local Width2 = 5

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.1
	self.LifeTime2 = 0.15
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 205, 255, v * 200 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 220, 255, 185, (v2 * 155)*1 ) )

end

--addons/arccw_weapons/lua/effects/effect_astw2_haloreach_tracer_hunter_beam/init.lua:

local Tracer = Material( "effects/halo3/hunter_beam_final" )
local Tracer2  = Material( "effects/halo3/energy_trail" )
local Width = 65
local Width2 = 50

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.1
	self.LifeTime2 = 0.15
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 205, 255, v * 200 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 220, 255, 185, (v2 * 155)*1 ) )

end

--addons/arccw_weapons/lua/effects/effect_laserig/init.lua:

EFFECT.Mat = Material( "cable/redlaser" )


function EFFECT:Init( data )

	self.texcoord = math.Rand( 0, 20 )/3
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	

	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self.EndPos = data:GetOrigin()
	

	self.Entity:SetCollisionBounds( self.StartPos -  self.EndPos, Vector( 110, 110, 110 ) )
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos, Vector()*8 )
	
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	
	self.Alpha = 255
	self.FlashA = 255
	
end


function EFFECT:Think( )

	self.FlashA = self.FlashA - 2050 * FrameTime()
	if (self.FlashA < 0) then self.FlashA = 0 end

	self.Alpha = self.Alpha - 1650 * FrameTime()
	if (self.Alpha < 0) then return false end
	
	return true

end


function EFFECT:Render( )
	
	self.Length = (self.StartPos - self.EndPos):Length()
	
	local texcoord = self.texcoord
	
		render.SetMaterial( self.Mat )
		render.DrawBeam( self.StartPos, 										// Start
					 self.EndPos,											// End
					 4,													// Width
					 texcoord,														// Start tex coord
					 texcoord + self.Length / 256,									// End tex coord
					 Color( 255, 255, 255, math.Clamp(self.Alpha, 0,255)) )		// Color (optional)'
					 
end

--addons/lvs_addons/lua/effects/hmp_concussion_trail.lua:
EFFECT.Offset = Vector(-8,0,0)

local GlowMat = Material( "effects/select_ring" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.OldPos = self.Entity:LocalToWorld( self.Offset )

		self.Emitter = ParticleEmitter( self.Entity:LocalToWorld( self.OldPos ), false )
	end
end

function EFFECT:doFX( pos )
	if not IsValid( self.Entity ) then return end

	if IsValid( self.Emitter ) then
		local emitter = self.Emitter

		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )
		if particle then
			particle:SetGravity( Vector(0,0,100) + VectorRand() * 50 ) 
			particle:SetVelocity( -self.Entity:GetForward() * 200  )
			particle:SetAirResistance( 600 ) 
			particle:SetDieTime( math.Rand(2,3) )
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( math.Rand(5,6) )
			particle:SetEndSize( math.Rand(12,30) )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 255,255,255 )
			particle:SetCollide( false )
		end

		local particle = emitter:Add( "particles/flamelet"..math.random(1,5), pos )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * math.Rand(250,800) + self.Entity:GetVelocity())
			particle:SetDieTime( math.Rand(0.2,0.4) )
			particle:SetAirResistance( 0 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( math.Rand(20,15) )
			particle:SetEndSize( 5 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, 0 ) )
			particle:SetCollide( false )
		end
		
		local particle = emitter:Add( "particles/flamelet"..math.random(1,5), self.Entity:GetPos() )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * 200 + VectorRand() * 50 )
			particle:SetDieTime( 0.25 )
			particle:SetAirResistance( 600 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( math.Rand(6,10) )
			particle:SetEndSize( math.Rand(2,3) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, 0 ) )
			particle:SetCollide( false )
		end
	end
end

function EFFECT:Think()
	if IsValid( self.Entity ) then
		self.nextDFX = self.nextDFX or 0
		
		if self.nextDFX < CurTime() then
			self.nextDFX = CurTime() + 0.02

			local oldpos = self.OldPos
			local newpos = self.Entity:LocalToWorld( self.Offset )
			self:SetPos( newpos )

			local Sub = (newpos - oldpos)
			local Dir = Sub:GetNormalized()
			local Len = Sub:Length()

			self.OldPos = newpos

			for i = 0, Len, 45 do
				local pos = oldpos + Dir * i

				self:doFX( pos )
			end
		end

		return true
	end

	if IsValid( self.Emitter ) then
		self.Emitter:Finish()
	end

	return false
end

function EFFECT:Render()
	local ent = self.Entity
	local pos = ent:LocalToWorld( self.Offset )

	render.SetMaterial( GlowMat )

	render.DrawSprite( pos, 100, 100, Color( 0, 0, 0, 0 ) )
end

--addons/lvs_addons/lua/effects/lfs_fb_wingrocket.lua:
EFFECT.Offset = Vector(-8, 0, 0)
EFFECT.mat = Material("sprites/light_glow02_add")
EFFECT.Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.OldPos = self.Entity:LocalToWorld( self.Offset )

		self.Emitter = ParticleEmitter( self.Entity:LocalToWorld( self.OldPos ), false )
	end
end

function EFFECT:doFX( pos )
	if not IsValid(self.Entity) then return end

	if self.Emitter then
		local emitter = self.Emitter
        local particle = emitter:Add(self.Materials[math.random(1, table.Count(self.Materials))], pos)
        
        if particle then
            particle:SetGravity(Vector(0, 0, 100) + VectorRand() * 50) 
            particle:SetVelocity(-self.Entity:GetForward() * 500)
            particle:SetAirResistance(600) 
            particle:SetDieTime(math.Rand(2,3))
            particle:SetStartAlpha(150)
            particle:SetStartSize(math.Rand(6,12))
            particle:SetEndSize(math.Rand(40,90))
            particle:SetRoll(math.Rand( -1, 1 ))
            particle:SetColor(50, 50, 50)
            particle:SetCollide(false)
        end

        local particle = emitter:Add("particles/flamelet"..math.random(1 ,5), pos)
        if particle then
            particle:SetVelocity(-self.Entity:GetForward() * 300 + self.Entity:GetVelocity())
            particle:SetDieTime(0.1)
            particle:SetAirResistance(0) 
            particle:SetStartAlpha(255)
            particle:SetStartSize(4)
            particle:SetEndSize(0)
            particle:SetRoll(math.Rand(-1,1))
            particle:SetColor(255, 255, 255)
            particle:SetGravity(Vector(0, 0, 0))
            particle:SetCollide(false)
        end
	end
end


function EFFECT:doFXbroken( pos )
	if not IsValid( self.Entity ) then return end

	if self.Emitter then
		local emitter = self.Emitter

		local particle = emitter:Add(self.Materials[math.random(1, table.Count(self.Materials))], pos)
		if particle then
			particle:SetGravity(Vector(0, 0, 100) + VectorRand() * 50) 
			particle:SetVelocity(-self.Entity:GetForward() * 500)
			particle:SetAirResistance(600) 
			particle:SetDieTime(math.Rand(2, 3))
			particle:SetStartAlpha(150 )
			particle:SetStartSize(math.Rand(6, 12))
			particle:SetEndSize(math.Rand(40, 90))
			particle:SetRoll(math.Rand(-1, 1))
			particle:SetColor(50, 50, 50)
			particle:SetCollide(false)
		end

		local particle = emitter:Add("particles/flamelet"..math.random(1, 5), pos)
		if particle then
			particle:SetVelocity(-self.Entity:GetForward() * 500 + VectorRand() * 50)
			particle:SetDieTime(0.25)
			particle:SetAirResistance(600) 
			particle:SetStartAlpha(255)
			particle:SetStartSize(math.Rand(25,40))
			particle:SetEndSize(math.Rand(10,15))
			particle:SetRoll(math.Rand(-1,1))
			particle:SetColor(255, 255, 255)
			particle:SetGravity(Vector(0, 0, 0))
			particle:SetCollide(false)
		end
	end
end

function EFFECT:Think()
	if IsValid( self.Entity ) then
		self.nextDFX = self.nextDFX or 0
		
		if self.nextDFX < CurTime() then
			self.nextDFX = CurTime() + 0.02

			self.Disabled = self.Entity:GetDisabled()

			local oldpos = self.OldPos
			local newpos = self.Entity:LocalToWorld( self.Offset )
			self:SetPos( newpos )

			local Sub = (newpos - oldpos)
			local Dir = Sub:GetNormalized()
			local Len = Sub:Length()

			self.OldPos = newpos

			for i = 0, Len, 45 do
				local pos = oldpos + Dir * i

				if self.Disabled then
					self:doFXbroken( pos )
				else
					self:doFX( pos )
				end
			end
		end

		return true
	end

	if self.Emitter then
		self.Emitter:Finish()
	end

	return false
end

local effectcolor = Color(0, 127, 255, 255)
function EFFECT:Render()
	if self.Disabled then return end

	local ent = self.Entity
	local pos = ent:LocalToWorld(self.Offset)

	render.SetMaterial(self.mat)
        
    for i =0,10 do
        local Size = (10 - i) * 25.6
        render.DrawSprite(pos - ent:GetForward() * i * 5, Size, Size, effectcolor)
    end

	render.DrawSprite(pos, 256, 256, effectcolor)
end

--addons/laat_g/lua/effects/lvs_concussion_explosion_large.lua:

local GlowMat = Material( "sprites/light_glow02_add" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	local emitter = ParticleEmitter( self.Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,30 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 800 )
			particle:SetDieTime( math.Rand(4,6) )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( math.Rand(30,60) )
			particle:SetEndSize( math.Rand(100,150) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 50,50,50 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/light_glow02_add", self.Pos )
		
		local vel = VectorRand() * 400
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.4,0.8) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(24,48) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetColor( 255, 40, 100 )
			particle:SetGravity( Vector(0,0,-600) )

			particle:SetAirResistance( 0 )
			
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
		end
	end
	
	for i = 0, 40 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( 0.14 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 )
			particle:SetEndSize( math.Rand(30,60) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local Pos = self.Pos
	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 1000000
		if delay <= 0.9 then
			sound.Play( "ambient/explosions/explode_9.wav", Pos, 85, 100, 1 - delay * 8 )
		end

		timer.Simple( delay, function()
			sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( GlowMat )
	render.DrawSprite( self.Pos, 1000 * Scale, 1000 * Scale, Color( 255, 40, 100, 255) )
	render.DrawSprite( self.Pos, 800 * Scale, 800 * Scale, Color( 255, 255, 255, 255) )
end

--addons/lvs_addons/lua/effects/lvs_hsd_dish_projector.lua:
EFFECT.Mat = Material( "effects/lvs/ballturret_projectorbeam" )
EFFECT.HitMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.ID = self.Entity:LookupAttachment( "muzzle_primary" )

		if self.ID then
			local Muzzle = self.Entity:GetAttachment( self.ID )

			self:SetRenderBoundsWS( self.Entity:GetPos(), -Muzzle.Ang:Right() * 50000 )
		end
	end

	self.SpawnTime = CurTime()
end

function EFFECT:Think()
	if not IsValid( self.Entity ) or not self.ID or not self.Entity:GetProjectorBeam() then
		return false
	end

	return true
end

function EFFECT:Render()
	if not self.ID or not IsValid( self.Entity ) then return end

	local T = CurTime()

	local Mul = math.min( math.max( 1.5 - (T - self.SpawnTime), 0 ) ^ 2, 1 )

	local Muzzle = self.Entity:GetAttachment( self.ID )

	local Dir = -Muzzle.Ang:Right()
	local StartPos = Muzzle.Pos
	local Trace = util.TraceLine( { start = StartPos, endpos = StartPos + Dir * 50000, filter = self } )
	local EndPos = Trace.HitPos

	self:SetRenderBoundsWS( StartPos, EndPos )

	render.SetMaterial( self.Mat )
	render.DrawBeam( StartPos, EndPos, (16 + math.random(0,3)) * Mul, 1, 0, Color(255,0,0,255) )
	render.DrawBeam( StartPos, EndPos, (4 + math.random(0,2)) * Mul, 1, 0, Color(255,255,255,255) )

	render.SetMaterial( self.HitMat )
	local A = 150 + math.random(0,20)
	local B = 70 + math.random(0,20)
	render.DrawSprite( StartPos, A * Mul, A * Mul, Color(255,0,0,255) )
	render.DrawSprite( StartPos, B * Mul, B * Mul, Color(255,255,255,255) )

	render.DrawSprite( EndPos, A, A, Color(255,0,0,255) )
	render.DrawSprite( EndPos + VectorRand() * 10, B, B, Color(255,255,255,255) )

	if (self._Next or 0) > T then return end

	self._Next = T + 0.02

	local emitter = ParticleEmitter( EndPos, false )

	if not emitter or not IsValid( emitter ) then return end

	local dir = (self.Entity:GetPos() - EndPos):GetNormalized()
	
	for i = 0, 3 do
		local particle = emitter:Add( "sprites/light_glow02_add", EndPos )

		local vel = VectorRand() * 250 + Trace.HitNormal

		if not particle then continue end

		particle:SetVelocity( vel )
		particle:SetAngles( vel:Angle() + Angle(0,90,0) )
		particle:SetDieTime( math.Rand(0.2,0.4) )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(12,24) )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand(-100,100) )
		particle:SetRollDelta( math.Rand(-100,100) )
		particle:SetColor( 255, 0, 0 )
		particle:SetGravity( Vector(0,0,-600) )

		particle:SetAirResistance( 0 )

		particle:SetCollide( true )
		particle:SetBounce( 1 )
	end

	local Dist = (StartPos - EndPos):Length()

	local invMul = (1 - Mul)

	for i = 0, Dist, 25 do
		local Pos = StartPos + Dir * i

		local particle = emitter:Add( "sprites/rico1", Pos )
		
		local vel = VectorRand()  * 150
		
		if not particle then continue end

		particle:SetVelocity( vel + vel * invMul )
		particle:SetDieTime( 0.1 + 0.15 * invMul )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand( 1, 5 ) + invMul * 2 )
		particle:SetEndSize( 0 )
		particle:SetColor( 50 + 205 * Mul, 0, 0 )
		particle:SetAirResistance( 0 )
		particle:SetRoll( math.Rand(-10,10) )
		particle:SetRollDelta( math.Rand(-10,10) )
		particle:SetGravity( Vector(0,0,-600 * invMul) )

		particle:SetAirResistance( 0 )
	end

	emitter:Finish()
end

--addons/lvs_addons/lua/effects/lvs_laser_purple.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1000 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 2, endpos + dir * len * 2, 200, 1, 0, Color(200, 0, 255, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 200, 0, 255, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--addons/lvs_addons/lua/effects/lvs_laser_red_aat.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )
EFFECT.MatSmoke = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )

	local emitter = ParticleEmitter( pos, false )

	if not IsValid( emitter ) then return end

	local trace = util.TraceLine( {
		start = pos,
		endpos = pos - Vector(0,0,500),
		mask = MASK_SOLID_BRUSHONLY,
	} )

	if not trace.Hit then return end

	local VecCol = (render.GetLightColor( trace.HitPos + trace.HitNormal ) * 0.8 + Vector(0.17,0.15,0.1)) * 255
	for i = 1,24 do
		local particle = emitter:Add( self.MatSmoke[math.random(1,#self.MatSmoke)], trace.HitPos )
		
		if not particle then continue end

		local ang = i * 15
		local X = math.cos( math.rad(ang) )
		local Y = math.sin( math.rad(ang) )

		particle:SetVelocity( Vector(X,Y,0) * 3000 )
		particle:SetDieTime( math.Rand(0.5,1) )
		particle:SetAirResistance( 500 ) 
		particle:SetStartAlpha( 100 )
		particle:SetStartSize( 50 )
		particle:SetEndSize( 240 )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
		particle:SetGravity( Vector(0,0,150) + dir * 2000 )
		particle:SetCollide( false )
	end

	emitter:Finish()

	local ply = LocalPlayer()

	if not IsValid( ply ) then return end

	local ViewEnt = ply:GetViewEntity()

	if not IsValid( ViewEnt ) then return end

	local Intensity = ply:InVehicle() and 8 or 80
	local Ratio = math.min( 250 / (ViewEnt:GetPos() - trace.HitPos):Length(), 1 )

	if Ratio < 0 then return end

	util.ScreenShake( trace.HitPos, Intensity * Ratio, 0.1, 0.5, 250 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 100 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 8, endpos + dir * len * 8, 200, 1, 0, Color( 255, 0, 0, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 60, 1, 0, Color( 255, 0, 0, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 30, 1, 0, Color( 255, 255, 255, 255 ) )
end

--addons/lvs_base/lua/effects/lvs_physics_scrape.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	if not LVS.ShowPhysicsEffects then
		self.LifeTime = 0
		self.DieTime = 0

		return
	end

	self.Pos = data:GetOrigin()

	self.mat = Material( "sprites/light_glow02_add" )

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()
	local Strength = data:GetMagnitude()

	local emitter = ParticleEmitter( Pos, false )

	for i = 0,1 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], Pos )
		
		local vel = VectorRand() * 100 + Dir * 40
		
		if particle then			
			particle:SetVelocity( vel )
			particle:SetDieTime( 1 )
			particle:SetAirResistance( 1000 ) 
			particle:SetStartAlpha( 10 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( 12 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 40, 30, 20 )
			particle:SetGravity( Dir * 50 )
			particle:SetCollide( false )
		end
	end

	for i = 0, 3 do
		local particle = emitter:Add( "sprites/rico1", Pos )
		
		local vel = VectorRand() * 25 * (1 - Strength) + (VectorRand() * 100 + Dir * 150) * Strength
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( 2 )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( 0.25 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 255, 200, 0 )
			particle:SetGravity( Vector(0,0,-600) )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then
		return false
	end

	return true
end

local mat = Material( "sprites/light_glow02_add" )
function EFFECT:Render()
	if not LVS.ShowPhysicsEffects then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( mat )
	render.DrawSprite( self.Pos, 32, 32, Color( 255 * Scale, 175 * Scale, 80 * Scale, 255) ) 
end


--addons/lvs_base/lua/effects/lvs_tracer_green.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1600 * bullet:GetLength()

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 3, 1, 0, Color( 225, 255, 225, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 10, 1, 0, Color( 150, 200, 150, 255 ) )
end

--addons/lvs_base/lua/effects/lvs_tracer_white.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1600 * bullet:GetLength()

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 3, 1, 0, Color( 255, 255, 255, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 10, 1, 0, Color( 150, 150, 150, 255 ) )
end

--addons/arccw_weapons/lua/effects/tfa_tracer_red/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(255, 0, 0)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(255, 0, 0)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 255
        dlight.g = 0
        dlight.b = 0
        dlight.brightness = 3
        dlight.Decay = 1000
        dlight.Size = 300
        dlight.DieTime = CurTime() + 3
    end
end
end
--addons/arccw_weapons/lua/effects/tracer_purple/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(148, 0, 211)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(148, 0, 211)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 148
        dlight.g = 0
        dlight.b = 211
        dlight.brightness = 7
        dlight.Decay = 1000
        dlight.Size = 500
        dlight.DieTime = CurTime() + 3
    end
end
end
--addons/arccw_weapons/lua/effects/tracer_stun/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "star/effects/blue_shockwave" );
local MaterialFront			= Material( "star/effects/blue_shockwave" );

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 35, 35, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--addons/lvs_addons/lua/effects/tx_130_projector.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

EFFECT.Mat = Material( "effects/lfs_base/ballturret_projectorbeam" )
EFFECT.HitMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Entity = data:GetEntity()
	
	if IsValid( self.Entity ) then
		self.ID = self.Entity:LookupAttachment( "lazer_cannon_muzzle" )
		
		if self.ID then
			local Muzzle = self.Entity:GetAttachment( self.ID )

			self:SetRenderBoundsWS( self.Entity:GetPos(), Muzzle.Ang:Up() * 50000 )
		end
	end
end

function EFFECT:Think()
	if not IsValid( self.Entity ) or not self.ID or not self.Entity:GetBTLFire() then
		return false
	end
	
	return true
end


function EFFECT:Render()
	if not self.ID or not IsValid( self.Entity ) then return end
	
	local Muzzle = self.Entity:GetAttachment( self.ID )
	
	local Dir = Muzzle.Ang:Up()
	local StartPos = Muzzle.Pos
	local Trace = util.TraceLine( { start = StartPos, endpos = StartPos + Dir * 50000, filter = self } )
	local EndPos = Trace.HitPos
	
	self:SetRenderBoundsWS( StartPos, EndPos )
	
	render.SetMaterial( self.Mat )
	render.DrawBeam( StartPos, EndPos, 14 + math.random(0,4), 1, 0, Color(0,0,255,255) )
	render.DrawBeam( StartPos, EndPos, 3 + math.random(0,4), 1, 0, Color(255,255,255,255) )
	
	render.SetMaterial( self.HitMat )
	local A = 150 + math.random(0,20)
	local B = 70 + math.random(0,20)
	render.DrawSprite( StartPos, A, A, Color(0,0,255,255) )
	render.DrawSprite( StartPos, B, B, Color(255,255,255,255) )
	
	render.DrawSprite( EndPos, A, A, Color(0,0,255,255) )
	render.DrawSprite( EndPos + VectorRand() * 10, B, B, Color(255,255,255,255) )
	
	if math.random(0,5) == 1 then
		local emitter = ParticleEmitter( EndPos, false )
		local dir = (self.Entity:GetPos() - EndPos):GetNormalized()
		
		for i = 0, 10 do
			local particle = emitter:Add( "sprites/rico1", EndPos )
			
			local vel = VectorRand()  * 100 + dir * 40
			
			if particle then
				particle:SetVelocity( vel )
				particle:SetAngles( vel:Angle() + Angle(0,90,0) )
				particle:SetDieTime( math.Rand(0.1,0.3) * 0.5 )
				particle:SetStartAlpha( math.Rand( 200, 255 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(1,30) )
				particle:SetEndSize( 0 )
				particle:SetRoll( math.Rand(-100,100) )
				particle:SetRollDelta( math.Rand(-100,100) )

				particle:SetAirResistance( 0 )
			end
		end
		
		emitter:Finish()
	end
end

--addons/billy_gas_logging/lua/gmodadminsuite/modules/logging/cl_livelogs.lua:
local function L(phrase, discriminator)
	return GAS:Phrase(phrase, "logging", discriminator)
end

if (IsValid(GAS_Logging_LiveLogs)) then
	GAS_Logging_LiveLogs:Remove()
end

surface.CreateFont("gas_logging_livelogs", {
	font = "Rubik",
	size = 14
})

GAS.Logging.LiveLogs_DefaultConfig = {width = 500, rows = 15, color = true, x = 10, y = 10, padding = 5, show_logs_for = 8, enabled = false, bgcolor = Color(0,0,0,225), print_to_console = true}
GAS.Logging.LiveLogs_Config = GAS:GetLocalConfig("logging_livelogs", GAS.Logging.LiveLogs_DefaultConfig)

function GAS.Logging:OpenLiveLogs()
	if (IsValid(GAS_Logging_LiveLogs)) then
		GAS_Logging_LiveLogs:Remove()
	end

	GAS:netStart("logging:LiveLogs")
		net.WriteBool(true)
	net.SendToServer()

	GAS_Logging_LiveLogs = vgui.Create("DPanel")
	GAS_Logging_LiveLogs:SetSize(GAS.Logging.LiveLogs_Config.width, ScrH())
	GAS_Logging_LiveLogs:AlignLeft(GAS.Logging.LiveLogs_Config.x)
	GAS_Logging_LiveLogs:AlignTop(GAS.Logging.LiveLogs_Config.y)
	GAS_Logging_LiveLogs:DockPadding(GAS.Logging.LiveLogs_Config.padding, GAS.Logging.LiveLogs_Config.padding, GAS.Logging.LiveLogs_Config.padding, GAS.Logging.LiveLogs_Config.padding)
	GAS_Logging_LiveLogs.Logs = {}

	function GAS_Logging_LiveLogs:AddLog(logtbl)
		local max_width = self:GetWide() - (GAS.Logging.LiveLogs_Config.padding * 2)
		
		local markupObj = markup.Parse("<font=gas_logging_livelogs>" .. GAS.Logging:FormatMarkupLog(logtbl, GAS.Logging.LiveLogs_Config.color) .. "</font>", max_width)

		local created_livelog = table.insert(GAS_Logging_LiveLogs.Logs, markupObj)
		GAS_Logging_LiveLogs.Logs[created_livelog].CreatedAt = CurTime()

		local MsgC_Args = {}
		for i, blk in ipairs(markupObj.blocks) do
			table.insert(MsgC_Args, Color(blk.colour.r, blk.colour.g, blk.colour.b, blk.colour.a))
			table.insert(MsgC_Args, blk.text)
		end
		table.insert(MsgC_Args, "\n")
		MsgC(unpack(MsgC_Args))
	end

	function GAS_Logging_LiveLogs:Antispam()
		local max_width = self:GetWide() - (GAS.Logging.LiveLogs_Config.padding * 2)
		GAS_Logging_LiveLogs.Logs[table.insert(GAS_Logging_LiveLogs.Logs, markup.Parse("<font=gas_logging_livelogs>" .. GAS:EscapeMarkup(L"live_log_antispam") .. "</font>", max_width))].CreatedAt = CurTime()
	end

	local markup_h = 0
	local y_align = GAS.Logging.LiveLogs_Config.padding
	function GAS_Logging_LiveLogs:Paint(w,h)
		if (not GAS) then return end
		if (not GAS.Logging) then return end
		if (not GAS_Logging_LiveLogs) then return end
		if (not GAS_Logging_LiveLogs.Logs) then return end
		local logs_len = #GAS_Logging_LiveLogs.Logs
		if (logs_len > 0) then
			if (GAS.Logging.LiveLogs_Config.bgcolor.a > 0) then
				surface.SetDrawColor(GAS.Logging.LiveLogs_Config.bgcolor)
				surface.DrawRect(0,0,w,y_align - 2 + GAS.Logging.LiveLogs_Config.padding)
			end
			markup_h = 0
			y_align = GAS.Logging.LiveLogs_Config.padding
			for i=logs_len, 1, -1 do
				local v = GAS_Logging_LiveLogs.Logs[i]
				if (v.CreatedAt < CurTime() - GAS.Logging.LiveLogs_Config.show_logs_for or (logs_len > GAS.Logging.LiveLogs_Config.rows and logs_len - (i - 1) > GAS.Logging.LiveLogs_Config.rows)) then
					if (not v.LerpAlpha) then
						v.LerpAlpha = 255
						v.LerpStarted = CurTime()
					end
					v.LerpAlpha = Lerp(math.TimeFraction(v.LerpStarted, v.LerpStarted + 5, CurTime()), v.LerpAlpha, 0)
				end
				if (v.LerpAlpha and math.floor(v.LerpAlpha) == 0) then
					table.remove(GAS_Logging_LiveLogs.Logs, i)
				else
					v:Draw(GAS.Logging.LiveLogs_Config.padding,y_align,TEXT_ALIGN_LEFT,TEXT_ALIGN_TOP,v.LerpAlpha or 255)
					markup_h = markup_h + v:GetHeight()
					y_align = y_align + v:GetHeight() + 2
				end
			end
		end
	end
end

GAS:netReceive("logging:LiveLog", function(len)
	local data = GAS:DeserializeTable(util.Decompress(net.ReadData(len)))
	if (not GAS.Logging.Config) then return end
	if (IsValid(GAS_Logging_LiveLogs)) then
		GAS_Logging_LiveLogs:AddLog(data)
	else
		GAS:netStart("logging:LiveLogs")
			net.WriteBool(false)
		net.SendToServer()
	end
end)

GAS:netReceive("logging:LiveLogAntispam", function()
	if (IsValid(GAS_Logging_LiveLogs)) then
		GAS_Logging_LiveLogs:Antispam()
	end
end)

if (GAS.Logging.LiveLogs_Config.enabled == true) then
	GAS:InitPostEntity(function()
		timer.Simple(10, function()
			GAS.Logging:OpenLiveLogs()
		end)
	end)
end