--Stealed clientside server code by exechack.cc
--Hostname: [PL] [PixelMod] PelugeRP SWRP | .gg/pixelmod - Part 6/10 - 06/04/2025


--PATH lua/autorun/admiral.lua:
player_manager.AddValidModel( "navy admiral", 		"models/navy/gnavyadmiral.mdl" );
list.Set( "PlayerOptionsModel", "navy admiral", 	"models/navy/gnavyadmiral.mdl" );
--PATH lua/arccw/shared/sh_0_ttt.lua:
ArcCW.TTTAmmoToEntity = {
    ["pistol"] = "item_ammo_pistol_ttt",
    ["smg1"] = "item_ammo_smg1_ttt",
    ["AlyxGun"] = "item_ammo_revolver_ttt",
    ["357"] = "item_ammo_357_ttt",
    ["buckshot"] = "item_box_buckshot_ttt"
}
--[[
WEAPON_TYPE_RANDOM = 1
WEAPON_TYPE_MELEE = 2
WEAPON_TYPE_NADE = 3
WEAPON_TYPE_SHOTGUN = 4
WEAPON_TYPE_HEAVY = 5
WEAPON_TYPE_SNIPER = 6
WEAPON_TYPE_PISTOL = 7
WEAPON_TYPE_SPECIAL = 8
]]

ArcCW.AmmoToTTT = {
    ["357"] = "AlyxGun",
    ["SniperPenetratedRound"] = "357",
    ["ar2"] = "smg1",
}
ArcCW.TTTAmmoToClipMax = {
    ["357"] = 20,
    ["smg1"] = 60,
    ["pistol"] = 60,
    ["alyxgun"] = 36,
    ["buckshot"] = 24
}
-- translate TTT weapons to HL2 weapons, in order to recognize NPC weapon replacements.
ArcCW.TTTReplaceTable = {
    ["weapon_ttt_glock"] = "weapon_pistol",
    ["weapon_zm_mac10"] = "weapon_ar2",
    ["weapon_ttt_m16"] = "weapon_smg1",
    ["weapon_zm_pistol"] = "weapon_pistol",
    ["weapon_zm_revolver"] = "weapon_357",
    ["weapon_zm_rifle"] = "weapon_crossbow",
    ["weapon_zm_shotgun"] = "weapon_shotgun",
    ["weapon_zm_sledge"] = "weapon_ar2",
    ["weapon_ttt_smokegrenade"] = "weapon_grenade",
    ["weapon_ttt_confgrenade"] = "weapon_grenade",
    ["weapon_tttbasegrenade"] = "weapon_grenade",
    ["weapon_zm_molotov"] = "weapon_grenade",
}

if engine.ActiveGamemode() != "terrortown" then return end

hook.Add("OnGamemodeLoaded", "ArcCW_TTT", function()
    for i, wep in pairs(weapons.GetList()) do
        local weap = weapons.Get(wep.ClassName)
        if weap then
            if !weap.ArcCW then
                continue
            end
            if weap.ArcCW and !weap.Spawnable then
                continue
            end
        end

        if ArcCW.AmmoToTTT[wep.Primary.Ammo] then
            wep.Primary.Ammo = ArcCW.AmmoToTTT[wep.Primary.Ammo]
        end

        wep.AmmoEnt = ArcCW.TTTAmmoToEntity[wep.Primary.Ammo] or ""
        -- You can tell how desperate I am in blocking the base from spawning
        wep.AutoSpawnable = (wep.AutoSpawnable == nil and true) or wep.AutoSpawnable
        wep.AllowDrop = wep.AllowDrop or true

        -- We have to do this here because TTT2 does a check for .Kind in WeaponEquip,
        -- earlier than Initialize() which assigns .Kind
        if !wep.Kind and !wep.CanBuy then
            if wep.Throwing or weap.Throwing then
                wep.Slot = 3
                wep.Kind = WEAPON_NADE
                wep.spawnType = wep.spawnType or WEAPON_TYPE_NADE
            elseif wep.Slot == 0 then
                -- melee weapons
                wep.Slot = 6
                wep.Kind = WEAPON_MELEE or WEAPON_EQUIP1
                wep.spawnType = wep.spawnType or WEAPON_TYPE_MELEE
            elseif wep.Slot == 1 then
                -- sidearms
                wep.Kind = WEAPON_PISTOL
                wep.spawnType = wep.spawnType or WEAPON_TYPE_PISTOL
            else
                -- other weapons are considered primary
                -- try to determine spawntype if none exists
                if !wep.spawnType then
                    if wep.Primary.Ammo == "357" or (wep.Slot == 3 and (wep.Num or 1) == 1) then
                        wep.spawnType = WEAPON_TYPE_SNIPER
                    elseif wep.Primary.Ammo == "buckshot" or (wep.Num or 1) > 1 then
                        wep.spawnType = WEAPON_TYPE_SHOTGUN
                    else
                        wep.spawnType = WEAPON_TYPE_HEAVY
                    end
                end

                wep.Slot = 2
                wep.Kind = WEAPON_HEAVY
            end
        end

        local class = wep.ClassName
        local path = "arccw/weaponicons/" .. class
        local path2 = "arccw/ttticons/" .. class .. ".png"
        local path3 = "vgui/ttt/" .. class
        local path4 = "entities/" .. class .. ".png"

        if !Material(path2):IsError() then
            -- TTT icon (png)
            wep.Icon = path2
        elseif !Material(path3):IsError() then
            -- TTT icon (vtf)
            wep.Icon = path3
        elseif !Material(path4):IsError() then
            -- Entity spawn icon
            wep.Icon = path4
        elseif !Material(path):IsError() then
            -- Kill icon
            wep.Icon = path
        else
            -- fallback: display _something_
            wep.Icon = "arccw/hud/arccw_bird.png"
        end

    end

    --[[]
    local pistol_ammo = (scripted_ents.GetStored("arccw_ammo_pistol") or {}).t
    if pistol_ammo then
        pistol_ammo.AmmoCount = 30
    end
    ]]

    -- Language string(s)
    if CLIENT then
        local lang = TTT2 and "en" or "english"
        LANG.AddToLanguage(lang, "search_dmg_buckshot", "This person was blasted to pieces by buckshot.")
        LANG.AddToLanguage(lang, "search_dmg_nervegas", "Their face looks pale. It must have been some sort of nerve gas.")
        LANG.AddToLanguage(lang, "ammo_smg1_grenade", "Rifle Grenades")
    end
end)

hook.Add("DoPlayerDeath", "ArcCW_DetectiveSeeAtts", function(ply, attacker, dmginfo)
    local wep = util.WeaponFromDamage(dmginfo)
    timer.Simple(0, function()
        if ArcCW.ConVars["ttt_bodyattinfo"]:GetInt() > 0 and ply.server_ragdoll and IsValid(wep) and wep:IsWeapon() and wep.ArcCW and wep.Attachments then
            net.Start("arccw_ttt_bodyattinfo")
                net.WriteEntity(ply.server_ragdoll)
                net.WriteUInt(table.Count(wep.Attachments), 8)
                for i, info in pairs(wep.Attachments) do
                    if info.Installed then
                        net.WriteUInt(ArcCW.AttachmentTable[info.Installed].ID, ArcCW.GetBitNecessity())
                    else
                        net.WriteUInt(0, ArcCW.GetBitNecessity())
                    end
                end
            net.Broadcast()
        end
    end)
end)

hook.Add("ArcCW_OnAttLoad", "ArcCW_TTT", function(att)
    if att.Override_Ammo and ArcCW.AmmoToTTT[att.Override_Ammo] then
        att.Override_Ammo = ArcCW.AmmoToTTT[att.Override_Ammo]
    end
end)

--PATH lua/arccw/shared/sh_ammo.lua:
return gluapack()()
--PATH lua/arccw/shared/sh_attachments.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/arccw/shared/sh_k_explosives_sounds.lua:
sound.Add( {
    name = "ArcCW_Kraken.Explosives.RocketImpact",
    channel = CHAN_AUTO + 6,
    volume = 1,
    level = 120,
    pitch = {90, 115},
    sound = {
        "kraken/launchers/hh12/rocket_expl_01.ogg",
        "kraken/launchers/hh12/rocket_expl_02.ogg",
        "kraken/launchers/hh12/rocket_expl_03.ogg",
        "kraken/launchers/hh12/rocket_expl_04.ogg",
    }
} )


sound.Add( {
    name = "ArcCW_Kraken.Grab",
    channel = CHAN_ITEM + 6,
    volume = 0.5,
    level = 120,
    pitch = {90, 115},
    sound = {
        "shared/manual_reset_1.mp3",
        "shared/manual_reset_2.mp3",
        "shared/manual_reset_3.mp3",
        "shared/manual_reset_4.mp3",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.Overheat",
    channel = CHAN_WEAPON + 6,
    volume = 0.5,
    level = 120,
    pitch = {90, 115},
    sound = {
        "shared/overheat/overheat_1.wav",
        "shared/overheat/overheat_2.wav",
        "shared/overheat/overheat_3.wav",
        "shared/overheat/overheat_4.wav",
        "shared/overheat/overheat_5.wav",
        "shared/overheat/overheat_6.wav",
        "shared/overheat/overheat_7.wav",
        "shared/overheat/overheat_8.wav",
        "shared/overheat/overheat_9.wav",
        "shared/overheat/overheat_10.wav",
        "shared/overheat/overheat_11.wav",
        "shared/overheat/overheat_12.wav",
        "shared/overheat/overheat_13.wav",
        "shared/overheat/overheat_14.wav",
        "shared/overheat/overheat_15.wav",
        "shared/overheat/overheat_16.wav",
        "shared/overheat/overheat_17.wav",
        "shared/overheat/overheat_18.wav",
        "shared/overheat/overheat_19.wav",
        "shared/overheat/overheat_20.wav",
        "shared/overheat/overheat_21.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.OverheatFix",
    channel = CHAN_WEAPON + 6,
    volume = 0.5,
    level = 120,
    pitch = {90, 115},
    sound = {
        "shared/overheat/overheat_fix_1.wav",
        "shared/overheat/overheat_fix_2.wav",
        "shared/overheat/overheat_fix_3.wav",
        "shared/overheat/overheat_fix_4.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.OverheatReplenished",
    channel = CHAN_WEAPON + 6,
    volume = 0.5,
    level = 120,
    pitch = {90, 115},
    sound = {
        "shared/overheat/overheat_replenished_1.wav",
        "shared/overheat/overheat_replenished_2.wav",
        "shared/overheat/overheat_replenished_3.wav",
        "shared/overheat/overheat_replenished_4.wav",
        "shared/overheat/overheat_replenished_5.wav",
    }
} )


sound.Add( {
    name = "ArcCW_Kraken.OverheatWarn",
    channel = CHAN_ITEM + 6,
    volume = 0.5,
    level = 120,
    pitch = {90, 115},
    sound = {
        "shared/overheat/overheat_warning_1.wav",
        "shared/overheat/overheat_warning_2.wav",
        "shared/overheat/overheat_warning_3.wav",
        "shared/overheat/overheat_warning_4.wav",
        "shared/overheat/overheat_warning_5.wav",
    }
} )
-- Corebass
sound.Add( {
    name = "ArcCW_Kraken.HeavyCorebass_GL",
    channel = CHAN_AUTO + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "kraken/launchers/grenadelauncher/fire1.wav",
        "kraken/launchers/grenadelauncher/fire2.wav",
        "kraken/launchers/grenadelauncher/fire3.wav",
        "kraken/launchers/grenadelauncher/fire4.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.HeavyCorebass_ROCKET",
    channel = CHAN_AUTO + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "kraken/launchers/corebass1.wav",
        "kraken/launchers/corebass2.wav",
        "kraken/launchers/corebass3.wav",
        "kraken/launchers/corebass4.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.HeavyCorebass",
    channel = CHAN_AUTO + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "shared/corebass/heavy/corebass_heavy_1.wav",
        "shared/corebass/heavy/corebass_heavy_2.wav",
        "shared/corebass/heavy/corebass_heavy_3.wav",
        "shared/corebass/heavy/corebass_heavy_4.wav",
        "shared/corebass/heavy/corebass_heavy_5.wav",
        "shared/corebass/heavy/corebass_heavy_6.wav",
        "shared/corebass/heavy/corebass_heavy_7.wav",
        "shared/corebass/heavy/corebass_heavy_8.wav",
        "shared/corebass/heavy/corebass_heavy_9.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.LightCorebass",
    channel = CHAN_AUTO + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "shared/corebass/light/corebass_light_1.wav",
        "shared/corebass/light/corebass_light_2.wav",
        "shared/corebass/light/corebass_light_3.wav",
        "shared/corebass/light/corebass_light_4.wav",
        "shared/corebass/light/corebass_light_5.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.StandardCorebass",
    channel = CHAN_AUTO + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "shared/corebass/rifle/corebass_rifle_1.wav",
        "shared/corebass/rifle/corebass_rifle_2.wav",
        "shared/corebass/rifle/corebass_rifle_3.wav",
        "shared/corebass/rifle/corebass_rifle_4.wav",
        "shared/corebass/rifle/corebass_rifle_6.wav",
        "shared/corebass/rifle/corebass_rifle_5.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.Explosives.Holster",
    channel = CHAN_WEAPON + 6,
    volume = 0.5,
    level = 120,
    pitch = {90, 115},
    sound = {
        "kraken/handling/wpn_fraggrenade_1p_draw_01.wav",
        "kraken/handling/wpn_fraggrenade_1p_draw_02.wav",
        "kraken/handling/wpn_fraggrenade_1p_draw_03.wav",
        "kraken/handling/wpn_fraggrenade_1p_draw_04.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.Explosives.PreThrow",
    channel = CHAN_WEAPON + 6,
    volume = 1,
    level = 120,
    pitch = {90, 115},
    sound = {
        "kraken/handling/wpn_fraggrenade_1p_prethrow_01.wav",
        "kraken/handling/wpn_fraggrenade_1p_prethrow_02.wav",
        "kraken/handling/wpn_fraggrenade_1p_prethrow_03.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.Explosives.Throw",
    channel = CHAN_WEAPON + 6,
    volume = 1,
    level = 120,
    pitch = {90, 115},
    sound = {
        "kraken/handling/wpn_fraggrenade_1p_throw_2ch_v1_01.wav",
        "kraken/handling/wpn_fraggrenade_1p_throw_2ch_v1_02.wav",
        "kraken/handling/wpn_fraggrenade_1p_throw_2ch_v1_03.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.Explosives.Explosion",
    channel = CHAN_AUTO + 6,
    volume = 1,
    level = 120,
    pitch = {90, 115},
    sound = {
        "kraken/shared/frag_expl_01.ogg",
        "kraken/shared/frag_expl_02.ogg",
        "kraken/shared/frag_expl_03.ogg",
        "kraken/shared/frag_expl_04.ogg",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.Explosives.Decoy_Random",
    channel = CHAN_AUTO + 6,
    volume = 1,
    level = 120,
    pitch = {90, 115},
    sound = {
        "kraken/explosives/decoy/dc17.wav",
        "kraken/explosives/decoy/dc17m.wav",
        "kraken/explosives/decoy/e11.wav",
        "kraken/explosives/decoy/e11d.wav",
        "kraken/explosives/decoy/dc15.mp3",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.Explosives.IncendiaryExpl",
    channel = CHAN_AUTO + 6,
    volume = 1,
    level = 120,
    pitch = {90, 115},
    sound = {
        "kraken/explosives/incgrenade/inc_grenade_detonate_1.wav",
        "kraken/explosives/incgrenade/inc_grenade_detonate_3.wav",
        "kraken/explosives/incgrenade/inc_grenade_detonate_2.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.Explosives.IncendiaryFadeOut",
    channel = CHAN_AUTO + 6,
    volume = 1,
    level = 120,
    pitch = {90, 115},
    sound = {
        "kraken/explosives/molotov/fire_loop_fadeout_01.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.Explosives.IncendiaryLoop",
    channel = CHAN_AUTO + 6,
    volume = 1,
    level = 120,
    pitch = {90, 115},
    sound = {
        "kraken/explosives/molotov/fire_loop_1.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.Explosives.IncendiaryExtinguish",
    channel = CHAN_AUTO + 6,
    volume = 1,
    level = 120,
    pitch = {90, 115},
    sound = {
        "kraken/explosives/molotov/molotov_extinguish.wav",
    }
} )
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15a_barrel_up.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15a_barrel_up.lua:
att.PrintName = "15a Short-up barrel"
att.Description = "Compact barrel intended for close-range battle."
att.SortOrder = 40
att.Icon = Material("interfaz/armas/swrp_att_e11_rearsight.png")
att.Desc_Pros = {}
att.Desc_Cons = {}

att.AutoStats = true

att.Slot = "15a_barrel"
att.ActivateElements = {"15a_barrel_up"}

att.Mult_Range = 0.75
att.Mult_Recoil = 1.25
att.Mult_SightTime = 0.8
att.Mult_AccuracyMOA = 2
att.Mult_Damage = 1.08

att.Mult_ShootPitch = 1.1
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15s_barrel_sniper.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/arccw/shared/attachments/a280cfe_barrel_sniper.lua:
att.PrintName = "Sniper Barrel"
att.Icon = Material("entities/kraken/sops/atts/cfesniper.png", "mips smooth")
att.Description = "Improves ranged performance, but at the cost of mobility."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "cfe_barrel"
att.ActivateElements = {"a280cfe_sniper"}

att.Mult_MoveSpeed = 0.9
att.Mult_MoveDispersion = 1.25
att.Mult_SightTime = 1.15
att.Mult_AccuracyMOA = 0.5
att.Mult_ShootPitch = 0.90

att.Mult_Range = 2.7
att.Mult_Damage = 1.9
att.Mult_DamageMin = 1.4

att.Mult_RPM = 0.75

--PATH addons/[bronie] arccw-special-forces-v3-1/lua/arccw/shared/attachments/a280cfe_stock_assault.lua:
att.PrintName = "Assault Stock"
att.Icon = Material("entities/kraken/sops/atts/assaultstock.png", "mips smooth")
att.Description = "Lightweight stock. Improves ADS speed at the cost of recoil."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "cfe_stock"
att.ActivateElements = {"a280cfe_stock_assault"}

att.Mult_Recoil = 1.25
att.Mult_SightTime = 0.75
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_gl_bacta.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_gl_dioxis.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_gl_impact.lua:
att.PrintName = "Impact Grenade Launcher"
att.Icon = Material("interfaz/armas/sw_highenergyclip.png")
att.Description = "Throwable grenade with impact capacity."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.AutoStats = true
att.Slot = "ammo_rocket"

att.SortOrder = 1738
att.Override_ShootEntity = "tfa_battlefront_ent_nade_impact"
att.Mult_SightTime = 1.25
att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_heatbased.lua:
att.PrintName = "Heat-Based Weapon"
att.Icon = Material("interfaz/armas/sw_powercell1.png")
att.Description = "The weapon has now infinite ammo at the heat cost. You'll do less damage and it will decay more in distance."
att.Override_MuzzleEffect = nil
att.Override_Tracer = nil
att.Desc_Pros = {
}
att.Desc_Cons = {
}

att.NotForNPCs = true
att.AutoStats = true
att.Slot = "ammo"

att.Override_InfiniteAmmo = true
att.Override_BottomlessClip = true
att.Override_Jamming = true
att.Mult_HeatCapacity = 1
att.Mult_FixTime = 1
att.Mult_HeatGain = 2
att.Mult_HeatDissipation = 5
att.Mult_HeatDelayTime = 1
att.Override_HeatLockout = true 

att.Mult_ShootPitch = 1.1
att.Reload = 0.9
att.Mult_DamageMin = 0.74
att.Mult_Recoil = 1.2
att.Mult_SightTime = 1
att.Mult_RPM = 0.8
att.Mult_Damage = 0.85
att.Mult_MuzzleVelocity = 0.9
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/arccw/shared/attachments/ammunition_ap.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/arccw/shared/attachments/ammunition_heatfs.lua:
att.PrintName = "HEAT-FS Projectile"
att.Description = "HEAT-FS (High Explosive Anti-Tank Fin-Stabilized) rounds are designed to penetrate armored vehicles. They use a shaped charge that focuses an explosive blast on a small point to melt through the armor, allowing the round to disable or destroy the target. The 'FS' indicates that the round is fin-stabilized, helping it maintain accuracy during flight."
att.Icon = Material("entities/kraken/heatfs_ammo.png")

att.AutoStats = true
att.Slot = "k_rocket_ammo"

att.Override_ShootEntity = "rocket_heatfs"
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/cr2_barrel_extended.lua:
att.PrintName = "CR-2 Extended Barrel"
att.Description = ""
att.Desc_Pros = {}
att.Icon = Material("interfaz/armas/swrp_att_muzzle2.png")
att.Desc_Cons = {}

att.AutoStats = true

att.Slot = {"cr2_barrel"}
att.ActivateElements = {"cr2_barrel_extended"}

att.Mult_MoveSpeed = 0.9

att.Mult_Range = 1.25
att.Mult_Recoil = 0.95
att.Mult_SightTime = 1.35
att.Mult_AccuracyMOA = 0.75

att.Mult_ShootPitch = 0.9
--PATH lua/arccw/shared/attachments/dc15a_range_finder.lua:
att.PrintName = "DC15a Range Finder"
att.Icon = Material("entities/acwatt_go_ammo_blanks.png", "mips smooth")
att.Description = "Low Cost, High Quality scopes, for your conveinence."

att.SortOrder = 3

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Neutrals = {"uc.bus"}

att.AutoStats = true
att.Slot = {"dc15a_range_finder"}

att.Model = "models/atts/dc15a_range_finder_scope1.mdl"
att.ModelOffset = Vector(6.5, 2, 0.7)
att.ModelScale = Vector(1, 1, 1)
att.OffsetAng = Angle(0, 0, 0)

att.AdditionalSights = {
    {
        ---internal scope---
                    --x,y,z--
        Pos = Vector(-1.39, 1.2, -1.55),
        Ang = Angle(0, 0, -30),
        Magnification = 1.1,
        ZoomLevels = 4,
        ViewModelFOV = 38,
        IgnoreExtra = true,
        CrosshairInSights = false,
        HolosightBone = "holosight",
        HolosightData = {
            Holosight = true,
            HolosightReticle = Material("scope/star_ret.png", "smooth"),
            HolosightNoFlare = true,
            HolosightSize = 12,
            HolosightPiece = "models/atts/dc15a_rangefinder_hsp.mdl",
            HolosightBlackbox = true,
            HolosightMagnification =  5,
            Colorable = false,
        },
    },
    {
        ---ironsights---
        Pos = Vector(-0.02, 8, -2.29),
        Ang = Angle(0, 0, 0),
        Magnification = 1,
        IgnoreExtra = true,
        HolosightData = {
            Holosight = false,
            HolosightReticle = Material("scope/star_ret.png", "smooth"),
            HolosightSize = 2,
            Colorable = true,
        },
    },
}

att.Colorable = true
att.HolosightPiece = "models/atts/dc15a_rangefinder_hsp.mdl"

att.Mult_SightedSpeedMult = 0.75
att.Mult_SightTime = 1.1
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/gl_thermal.lua:
att.PrintName = "Grenade Launcher (Thermal)"
att.Icon = Material("interfaz/armas/sw_demolish.png")
att.Description = "Grenade Launcher module. Replaces a charged tibanna cartridge with a grenade launcher one."
att.Desc_Pros = {
    "pro.ubgl",
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "info.toggleubgl"
}
att.AutoStats = true
att.Slot = "ubgl_module"

att.SortOrder = 1738

att.MountPositionOverride = 0

att.UBGL = true
att.UBGL_BaseAnims = false
att.UBGL_PrintName = "Grenade Launcher (Thermal)"
att.UBGL_Automatic = false
att.UBGL_MuzzleEffect = "swrp_muzzleflash_blue"
att.UBGL_ClipSize = 1
att.UBGL_Ammo = "Grenade"
att.UBGL_RPM = 1200
att.UBGL_Recoil = 2
att.UBGL_Capacity = 1

att.AddSuffix = "Grenadier"

att.Hook_ShouldNotSight = function(wep)
    return wep:GetInUBGL()
end

local function Ammo(wep)
    return wep.Owner:GetAmmoCount("Grenade")
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    wep:PlayAnimation("Reload", 1, true, nil, nil, nil, true)

    wep:FireRocket("tfa_battlefront_ent_nade_thermal", 1000)

    if wep.MW2_M203isGP25 then
        wep:EmitSound("armas3/gl_fire_1.wav", 100)
    else
        wep:EmitSound("armas3/gl_fire_4.wav", 100)
    end

    wep:SetClip2(wep:Clip2() - 1)

    wep:DoEffects()
end

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end

    if Ammo(wep) <= 0 then return end

    wep:PlayAnimation("reload", 1, true, nil, nil, nil, true)
    wep:SetReloading(CurTime() + wep:GetAnimKeyTime("reload"))

    local reserve = Ammo(wep)

    reserve = reserve + wep:Clip2()

    local clip = 1

    local load = math.Clamp(clip, 0, reserve)

    wep.Owner:SetAmmo(reserve - load, "Grenade")

    wep:SetClip2(load)
end

att.Mult_SightTime = 1.25
-- att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--PATH lua/arccw/shared/attachments/muzzle_a280cfe_mod.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/optic_e11_scope.lua:
att.PrintName = "E-11 Magnifying Optic"
att.Icon = Material("entities/dlt19x_icon.png")
att.Description = "High-magnification sniper rifle scope for long range combat."

att.SortOrder = 9

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/atts/e11_scope.mdl"
att.ModelOffset = Vector(0, 0, -0)
att.AdditionalSights = {
    {
        Pos = Vector(0.01, 9, -1.165),
        Ang = Angle(0, 0, 0),
        Magnification = 1.5,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 10,
        ZoomSound = "weapons/arccw/fiveseven/fiveseven_slideback.wav",
        IgnoreExtra = true
    }
}

att.ScopeGlint = false

att.Holosight = true
att.HolosightReticle = Material("scope/star_ret.png", "smooth")
att.HolosightNoFlare = true
att.HolosightSize = 9
att.HolosightBone = "holosight"
att.HolosightPiece = "models/atts/e11_scope_hsp.mdl"
att.Colorable = false

att.HolosightMagnification = 0
att.HolosightBlackbox = true

att.HolosightConstDist = 44

att.HolosightMagnificationMin = 2
att.HolosightMagnificationMax = 3
att.HoloSightColorable = false

att.Mult_SightTime = 1.35
att.Mult_SightedSpeedMult = 0.8
att.Mult_SpeedMult = 0.9
--PATH lua/arccw/shared/attachments/optic_iqa11_scope.lua:
att.PrintName = "IQA-11 Magnifying Optic"
att.Icon = Material("entities/dlt19x_icon.png")
att.Description = "High-magnification sniper rifle scope for long range combat."

att.SortOrder = 9

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/atts/iqa11_default_scope.mdl"
att.ModelOffset = Vector(0, 0, -0)
att.AdditionalSights = {
    {
        Pos = Vector(0, 9, -1.2),
        Ang = Angle(0, 0, 0),
        Magnification = 1.5,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 10,
        ZoomSound = "weapons/arccw/fiveseven/fiveseven_slideback.wav",
        IgnoreExtra = true
    }
}

att.ScopeGlint = false

att.Holosight = true
att.HolosightReticle = Material("scope/star_ret.png", "smooth")
att.HolosightNoFlare = true
att.HolosightSize = 6
att.HolosightBone = "holosight"
att.HolosightPiece = "models/atts/iqa11_default_scope_hsp.mdl"
att.Colorable = false

att.HolosightMagnification = 0
att.HolosightBlackbox = true

att.HolosightConstDist = 44

att.HolosightMagnificationMin = 2
att.HolosightMagnificationMax = 3
att.HoloSightColorable = false

att.Mult_SightTime = 1.35
att.Mult_SightedSpeedMult = 0.8
att.Mult_SpeedMult = 0.9
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/perk_clonebarc.lua:
att.PrintName = "BARC Trooper Training"

att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/barc.png")
att.Description = [[BARC Troopers are close reconnaissance soldiers. Better recoil control and speed.]]
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = {"perk"}

att.AutoStats = true
att.NotForNPC = true

att.Mult_AccuracyMOA = 0.95
att.Mult_HipDispersion = 0.75
att.Mult_MoveDispersion = 0.75

att.Mult_SpeedMult = 1.25
att.Mult_SightedSpeedMult = 0.80
att.Mult_ReloadTime = 1.20
att.Mult_Recoil = 0.85
att.Mult_RecoilSide = 0.75
att.Mult_SightsDispersion = 0.5

att.Mult_Range = 0.6
att.Mult_Damage = 0.96
att.Mult_DamageMin = 1.15

--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/perk_comando.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_conditionoverload.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_endurance.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_endurance.lua:
att.PrintName = "Endurance"
att.Icon = Material("interfaz/iconos/kraken/jedi guns dirty fighting/1626143083_2805137530.png")
att.Description = "Long courses of physical training allow you to bear more weight and control the recoil of your weapon."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true

att.Mult_MoveSpeed = 1.1
att.Mult_Recoil = 0.9
att.Mult_RecoilSide = 0.9

att.NotForNPCs = true
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/special_heal.lua:
att.PrintName = "Healing Rounds"
att.AbbrevName = "Healing Rounds"
att.Icon = Material("interfaz/iconos/jedi/healer.png")
att.Description = "Experimental overcharged plasma that can heal instead dealing damage."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "perk"

att.NotForNPC = true

att.UBGL = true
att.UBGL_PrintName = "Healing Darts"
att.UBGL_Automatic = true
att.UBGL_ClipSize = 1
att.UBGL_Ammo = "ar2"
att.UBGL_RPM = 50
att.UBGL_Recoil = 1
att.UBGL_Capacity = 1

local function Ammo(wep)
    return wep.Owner:GetAmmoCount("ar2")
end

att.UBGL_Fire = function(wep, ubgl)
    wep.Owner:FireBullets({
        Src = wep.Owner:EyePos(),
        Num = 1,
        Damage = 0,
        Force = 0,
        Attacker = wep.Owner,
        Dir = wep.Owner:EyeAngles():Forward(),
        Callback = function(_, tr, dmg)
            local ent = tr.Entity
            local dist = (tr.HitPos - tr.StartPos):Length() * ArcCW.HUToM
            local dmgmax = 25
            local dmgmin = 1
            local delta = dist / 5
            delta = math.Clamp(delta, 0, 1)
            local amt = Lerp(delta, dmgmax, dmgmin)

            ent:SetHealth(math.Clamp(ent:Health() + (amt), 10, (ent:GetMaxHealth() * 1.5)))
        end
    })

    wep:EmitSound("everfall/equipment/bacta_bomb/bactabomb_corebass_distant_var_03.mp3", 100)

end

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end

    if Ammo(wep) <= 0 then return end

    local reserve = Ammo(wep)

    reserve = reserve + wep:Clip2()

    local clip = 1

    local load = math.Clamp(clip, 0, reserve)

    wep.Owner:SetAmmo(reserve - load, "pistol")

    wep:SetClip2(load)
end
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/st_dc15.lua:
att.PrintName = "DC-15 Stock"
att.AbbrevName = "DC-15 Stock"
att.Icon = Material("interfaz/armas/swrp_att_dlt20_stock.png")
att.Description = ""
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = "stock"

att.Model = "models/sw_battlefront/weapons/mods/dc15s_mod_stock.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(0, 0, 0)
att.ModelOffset = Vector(0, 0, 0)
att.ModelScale = Vector(1, 1, 1)

att.AutoStats = true
att.HideIfBlocked = true

att.Mult_Damage = 1.10
att.Mult_SightTime = 0.97
att.Mult_Sway = 1.13
att.Mult_RPM = 0.98
att.Mult_SpeedMult = 0.95
att.Mult_DrawTime = 0.97
att.Mult_HolsterTime = 1.10
att.Mult_HipDispersion = 1.10

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--PATH lua/arccw/shared/attachments/sw_b2_rocket.lua:
att.PrintName = "B2 Rocket"
att.Description = "Test ammo for the B2 Rocket droid"

att.SortOrder = 2

att.Desc_Cons = {
}
att.AutoStats = false
att.Slot = "b2attachments"

att.HideModel = false
att.ModelScale = Vector(0, 0, 0)
att.ModelOffset = Vector(0, 0, 1.25)
att.OffsetAng = Angle(0, -90, 0)

att.Mult_SightTime = 1.08
att.Mult_SightedSpeedMult = 0.94
att.Mult_MuzzleVelocity = 50
att.Override_ChamberSize = -10
att.MagReducer = true
att.Add_ClipSize =  1
att.Override_ShootEntity = "arccw_rocket"

att.Hook_AddShootSound = function(wep, data)
	wep:MyEmitSound("everfall/weapons/rocket_launcher/explosive_rocketlauncher_corebass_close_var_03.mp3", 120, 100, 1, CHAN_WEAPON - 1)
end
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/sw_mag_powerpack.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/sw_stun30.lua:
att.PrintName = "Stun Rounds - 30s"
att.AbbrevName = "Stun Rounds - 30s"
att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/stun30.png")
att.Description = "Replace the main-fire for stun rounds."

att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = {"sw_ammo"}

att.AutoStats = true
att.Override_AmmoPerShot = 5

att.Mult_Damage = 0.1
att.Mult_DamageMin = 0.1

att.Override_Tracer = "effect_sw_laser_blue_stun"

att.Hook_BulletHit = function(wep, data)
	GMSERV:AddStatus(data.tr.Entity, data.att, "stun", 30, 1, true) --Entity,Owner,Status Effect Type (Yes, you can add the others),Duration, Damage, ParticleEffect
end

att.Hook_GetShootSound = function(wep, sound)
    return false
end

att.Hook_AddShootSound = function(wep, data)
    wep:MyEmitSound("shared/stun.wav", data.volume, data.pitch, 1, CHAN_WEAPON - 1)
end
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/sw_stun5.lua:
att.PrintName = "Stun Rounds - 5s"
att.AbbrevName = "Stun Rounds - 5s"
att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/stun5.png")
att.Description = "Replace the main-fire for stun rounds."

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"sw_ammo"}

att.AutoStats = true
att.Override_AmmoPerShot = 5
att.Override_Tracer = "effect_sw_laser_blue_stun"
att.Hook_BulletHit = function(wep, data)
	GMSERV:AddStatus(data.tr.Entity, data.att, "stun", 5, 1, true) --Entity,Owner,Status Effect Type (Yes, you can add the others),Duration, Damage, ParticleEffect
end
att.Hook_GetShootSound = function(wep, sound)
    return false
end
att.Hook_AddShootSound = function(wep, data)
    wep:MyEmitSound("everfall/weapons/republic/stun.wav", data.volume, data.pitch, 1, CHAN_WEAPON - 1)
end
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/universal_vibroknife.lua:
att.PrintName = "Vibroknife"
att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/vibroknife.png", "mips smooth")
att.Description = "Deploy a sharp vibroknife to suppress the enemy in melee"
att.Desc_Pros = {}
att.Desc_Cons = {}

att.AutoStats = true

att.Slot = {"vibroknife"}
att.ActivateElements = {"vibroknife"}

att.Mult_MeleeTime = 0.7
att.Mult_MeleeDamage = 7
att.Add_MeleeRange = 2
att.Mult_MeleeAttackTime = 1
--PATH lua/arccw/shared/sh_localization.lua:
if SERVER and game.SinglePlayer() then
    util.AddNetworkString("arccw_sp_reloadlangs")
end

ArcCW.LangTable = ArcCW.LangTable or {}
-- Converts raw string to a lang phrase. not case sensitive.
ArcCW.StringToLang = {
    -- Class
    ["pistol"] = "class.pistol",
    ["revolver"] = "class.revolver",
    ["machine pistol"] = "class.machinepistol",

    ["submachine gun"] = "class.smg", -- Preferred
    ["sub-machine gun"] = "class.smg",
    ["smg"] = "class.smg",

    ["personal defense weapon"] = "class.pdw", -- Preferred
    ["pdw"] = "class.pdw",

    ["shotgun"] = "class.shotgun",

    ["assault carbine"] = "class.assaultcarbine",
    ["carbine"] = "class.carbine",
    ["assault rifle"] = "class.assaultrifle",
    ["rifle"] = "class.rifle",

    ["battle rifle"] = "class.battlerifle",
    ["designated marksman rifle"] = "class.dmr",
    ["dmr"] = "class.dmr", -- Preferred
    ["sniper rifle"] = "class.sniperrifle", -- Preferred
    ["sniper"] = "class.sniperrifle",

    ["antimateriel rifle"] = "class.antimaterielrifle", -- Preferred
    ["antimaterial rifle"] = "class.antimaterielrifle",
    ["anti-material rifle"] = "class.antimaterielrifle",
    ["rocket launcher"] = "class.rocketlauncher",

    ["hand grenade"] = "class.grenade", -- Preferred
    ["grenade"] = "class.grenade",
    ["melee weapon"] = "class.melee", -- Preferred

    -- Attachment Slot
    ["optic"] = "attslot.optic",
    ["backup optic"] = "attslot.bkoptic",
    ["muzzle"] = "attslot.muzzle",
    ["barrel"] = "attslot.barrel",
    ["choke"] = "attslot.choke",
    ["underbarrel"] = "attslot.underbarrel",
    ["tactical"] = "attslot.tactical",
    ["grip"] = "attslot.grip",
    ["stock"] = "attslot.stock",
    ["fire group"] = "attslot.fcg",
    ["ammo type"] = "attslot.ammo",
    ["perk"] = "attslot.perk",
    ["charm"] = "attslot.charm",
    ["skin"] = "attslot.skin",
    ["magazine"] = "attslot.magazine",
    ["slide"] = "attslot.slide",

    ["iron sights"] = "attslot.optic.default",
    ["ironsights"] = "attslot.optic.default",
    ["standard barrel"] = "attslot.barrel.default",
    ["standard choke"] = "attslot.choke.default",
    ["standard muzzle"] = "attslot.muzzle.default",
    ["standard grip"] = "attslot.grip.default",
    ["standard stock"] = "attslot.stock.default",
    ["no stock"] = "attslot.stock.none",
    ["standard fcg"] = "attslot.fcg.default",
    ["standard magazine"] = "attslot.magazine.default",
}

-- Helper function for getting the overwrite or default language
function ArcCW.GetLanguage()
    local l = ArcCW.ConVars["language"] and string.lower(ArcCW.ConVars["language"]:GetString())
    if !l or l == "" then l = string.lower(GetConVar("gmod_language"):GetString()) end
    return l
end

-- Adds a string to the StringToLang table.
function ArcCW.AddStringToLang(str, phrase)
    if phrase == nil or phrase == "" or str == nil or str == "" then return nil end
    ArcCW.StringToLang[string.lower(str)] = phrase
end

-- Retrieves a lang phrase from a string. If the string is a phrase itself, it will be returned.
function ArcCW.GetPhraseFromString(str)
    if str == nil or str == "" then return nil end
    if ArcCW.StringToLang[string.lower(str)] then
        return ArcCW.StringToLang[string.lower(str)]
    end
    if ArcCW.LangTable["en"][string.lower(str)] then
        return string.lower(str)
    end
    return nil
end

-- Gets a translated string from a phrase. Will attempt to fallback to English.
-- Returns nil if no such phrase exists.
function ArcCW.GetTranslation(phrase, format)
    if phrase == nil or phrase == "" then return nil end
    local lang = ArcCW.GetLanguage()
    if !lang or lang == "" or !ArcCW.LangTable[lang] or !ArcCW.LangTable[lang][phrase] then
        lang = "en"
    end
    if ArcCW.LangTable[lang] and ArcCW.LangTable[lang][phrase] then
        local str = ArcCW.LangTable[lang][phrase]
        for i, v in pairs(format or {}) do
            -- print(i, v)
            str = string.Replace(str, "{" .. i .. "}", v)
        end
        return str
    end
    return nil
end

-- Attempts to translate a string (could be either a raw string or a phrase).
-- If fail, return the string itself.
function ArcCW.TryTranslation(str, format)
    if !str then return nil end
    local phrase = ArcCW.GetPhraseFromString(str)
    if !phrase then return str end

    return ArcCW.GetTranslation(phrase, format) or str
end

-- Adds a translated string for a specific language's phrase. lang defaults to English.
function ArcCW.AddTranslation(phrase, str, lang)
    if phrase == nil or phrase == "" or str == nil or str == "" then return nil end
    lang = lang and string.lower(lang) or "en"
    ArcCW.LangTable[lang] = ArcCW.LangTable[lang] or {}
    ArcCW.LangTable[lang][string.lower(phrase)] = str
end

-- Translates an ammo string. If enabled, we will use our custom names (pulse -> rifle, smg -> carbine);
-- Otherwise returns the in-game translation for it.
function ArcCW.TranslateAmmo(ammo)
    if isnumber(ammo) then ammo = game.GetAmmoName(ammo) end
    if !ammo or !isstring(ammo) then return nil end
    ammo = string.lower(ammo)

    local lang = ArcCW.GetLanguage()
    local str = "ammo." .. ammo
    if SERVER or ArcCW.ConVars["ammonames"]:GetBool() then
        if ArcCW.LangTable[lang] and ArcCW.LangTable[lang][str] then
            return ArcCW.LangTable[lang][str]
        elseif ArcCW.LangTable["en"][str] then
            return ArcCW.LangTable["en"][str]
        end
    end
    return SERVER and (ammo .. " ammo") or language.GetPhrase(ammo .. "_ammo")
end

if CLIENT then
    function ArcCW.LoadClientLanguage(files)
        local lang = ArcCW.GetLanguage()
        files = files or file.Find("arccw/client/cl_languages/*", "LUA")

        local lang_tbl = {}
        local lang_tbl_en = {}

        for _, v in pairs(files) do
            local exp = string.Explode("_", string.lower(string.Replace(v, ".lua", "")))
            if lang != "en" and exp[#exp] == lang then
                include("arccw/client/cl_languages/" .. v)
                for phrase, str in pairs(L) do
                    lang_tbl[phrase] = str
                end
                print("Loaded ArcCW cl_language file " .. v .. " with " .. table.Count(L) .. " strings.")
                L = nil
            elseif exp[#exp] == "en" then
                -- Always load english as backup
                include("arccw/client/cl_languages/" .. v)
                for phrase, str in pairs(L) do
                    lang_tbl_en[phrase] = str
                end
            end
        end
        table.Merge(lang_tbl_en, lang_tbl)
        for phrase, str in pairs(lang_tbl_en) do
            language.Add(phrase, str)
        end
    end
elseif SERVER then
    for _, v in pairs(file.Find("arccw/client/cl_languages/*", "LUA")) do
        AddCSLuaFile("arccw/client/cl_languages/" .. v)
    end
end

function ArcCW.LoadLanguages()
    ArcCW.LangTable = {}
    for _, v in pairs(file.Find("arccw/shared/languages/*", "LUA")) do
        include("arccw/shared/languages/" .. v)
        AddCSLuaFile("arccw/shared/languages/" .. v)

        local exp = string.Explode("_", string.lower(string.Replace(v, ".lua", "")))
        local lang = exp[#exp]

        if !lang then
            print("Failed to load ArcCW language file " .. v .. ", did not get language name (naming convention incorrect?)")
            continue
        elseif !L then
            print("Failed to load ArcCW language file " .. v .. ", did not get language table")
            continue
        end

        for phrase, str in pairs(L) do
            ArcCW.AddTranslation(phrase, str, lang)
        end

        -- Load StringToLang stuff incase it is needed
        if STL then
            for str, phrase in pairs(STL) do
                ArcCW.AddStringToLang(str, phrase)
            end
        end

        print("Loaded ArcCW language file " .. v .. " with " .. table.Count(L) .. " strings.")
        L = nil
        STL = nil
    end

    if CLIENT then
        ArcCW.LoadClientLanguage()
    end

    hook.Run("ArcCW_LocalizationLoaded")
end

ArcCW.LoadLanguages()
hook.Add("PreGamemodeLoaded", "ArcCW_Lang", function()
    if CLIENT and ArcCW.ConVars["ammonames"]:GetBool() then
        local ourlang = ArcCW.GetLanguage()
        for _, name in pairs(game.GetAmmoTypes()) do
            if ArcCW.LangTable[ourlang] and ArcCW.LangTable[ourlang]["ammo." .. string.lower(name)] then
                language.Add(name .. "_ammo", ArcCW.LangTable[ourlang]["ammo." .. string.lower(name)])
            elseif ArcCW.LangTable["en"]["ammo." .. string.lower(name)] then
                language.Add(name .. "_ammo", ArcCW.LangTable["en"]["ammo." .. string.lower(name)])
            end
        end
    end
end)

concommand.Add("arccw_reloadlangs", function(ply)
    if SERVER and !game.SinglePlayer() and IsValid(ply) and !ply:IsSuperAdmin() then return end

    ArcCW.LoadLanguages()
    if SERVER and game.SinglePlayer() then
        net.Start("arccw_sp_reloadlangs")
        net.Broadcast()
    end
end, nil, "Reloads all language files.")

if game.SinglePlayer() then
    net.Receive("arccw_sp_reloadlangs", function()
        ArcCW.LoadLanguages()
    end)
end

--PATH lua/arccw/shared/sh_quicknade.lua:
-- ArcCW.QuickNadeTable = {
--     ["frag"] = {
--         ShortName = "FRAG",
--         ThrowEntity = "arccw_proj_frag",
--         ViewModel = "models/weapons/cstrike/c_eq_fraggrenade.mdl"
--     }
-- }

-- if CLIENT then

-- function ArcCW:QuickNade(index)
--     if !ArcCW.QuickNadeTable[index] then return end

--     local wpn = LocalPlayer():GetActiveWeapon()

--     if !wpn.ArcCW then return end
-- end

-- end
--PATH lua/arccw/shared/sh_vehicle.lua:
-- returns a table of entities to ignore (the player's vehicle)
function ArcCW:GetVehicleFilter(ply)
    if !ArcCW.ConVars["driveby"]:GetBool() or !IsValid(ply) or !ply:IsPlayer() then return {} end

    local tbl = {}
    local veh = ply:GetVehicle()

    if simfphys then
        -- gredwitch, why do you think it's a good idea to create the simfphys table yourself???
        -- people might need to do dependency checks, you know
        local car = ply.GetSimfphys and ply:GetSimfphys()
        if IsValid(car) then
            table.insert(tbl, car)
            if SERVER then
                table.insert(tbl, car.DriverSeat)
                for _, seat in ipairs(car.pSeat) do
                    table.insert(tbl, seat)
                    if IsValid(seat:GetDriver()) then
                        table.insert(tbl, seat:GetDriver())
                    end
                end
                table.Add(tbl, car.Wheels or {})
            else
                table.insert(tbl, veh) -- should be the pod
                -- client doesn't know what the wheels/passenger seats are
                -- iterate over all wheels and seats. inefficient, but its client so whatever
                for _, w in ipairs(ents.FindByClass("gmod_sent_vehicle_fphysics_wheel")) do
                    if w:GetBaseEnt() == car then
                        table.insert(tbl, w)
                    end
                end
                for _, s in ipairs(ents.FindByClass("prop_vehicle_prisoner_pod")) do
                    if s:GetParent() == car then
                        table.insert(tbl, s)
                        if IsValid(s:GetDriver()) then
                            table.insert(tbl, s:GetDriver())
                        end
                    end
                end
            end
        elseif IsValid(veh) then
            table.insert(tbl, veh)
        end
    elseif IsValid(veh) then
        table.insert(tbl, veh)
    end

    return tbl
end

-- returns a new source to fire from, this should be moved right outside the vehicle
-- since we can't ignore multiple entities in FireBullets, this is the only solution
function ArcCW:GetVehicleFireTrace(ply, src, dir)
    if !ArcCW.ConVars["driveby"]:GetBool() then return src end
    local tbl = ArcCW:GetVehicleFilter(ply)
    if table.IsEmpty(tbl) then return src end

    -- Make some traces from the outside to find a good spot
    local trace_dist = {256, 128, 64}
    for i = 1, #trace_dist do
        local tr = util.TraceLine({
            start = src + dir * trace_dist[i],
            endpos = src,
            ignoreworld = true,
            mask = MASK_SHOT
        })
        if IsValid(tr.Entity) and table.HasValue(tbl, tr.Entity) then
            return tr.HitPos + tr.HitNormal * 4
        end
    end
    return src
end
--PATH lua/arccw/client/cl_autostats.lua:
local tbl     = table
local tbl_add = tbl.Add
local tbl_ins = tbl.insert
local tostr   = tostring
local translate = ArcCW.GetTranslation

-- ["buff"] = {"desc", string mode (mult, add, override, func), bool lowerbetter or function(val), number priority, bool flipsigns }

ArcCW.AutoStats = {
    -- Attachments
    ["MagExtender"]           = { "autostat.magextender", "override", false,       pr = 317 },
    ["MagReducer"]            = { "autostat.magreducer",  "override", true,        pr = 316 },
    ["Bipod"]                 = { "autostat.bipod",       false, false,            pr = 313 },
    ["ScopeGlint"]            = { "autostat.glint",       "override", true,        pr = 255 },
    ["Silencer"]              = { "autostat.silencer",    "override", false,       pr = 254 },
    ["Override_NoRandSpread"] = { "autostat.norandspr",   "override", false,       pr = 253 },
    ["Override_CanFireUnderwater"] = { "autostat.underwater",   "override", false, pr = 252 },
    ["Override_ShootWhileSprint"] = { "autostat.sprintshoot",   "override", false, pr = 251 },
    -- Multipliers
    ["Mult_BipodRecoil"]      = { "autostat.bipodrecoil", false, true,             pr = 312 },
    ["Mult_BipodDispersion"]  = { "autostat.bipoddisp",   false, true,             pr = 311 },
    ["Mult_Damage"]           = { "autostat.damage",      "mult", false,           pr = 215 },
    ["Mult_DamageMin"]        = { "autostat.damagemin",   "mult", false,           pr = 214 },
    ["Mult_Range"]            = { "autostat.range",       "mult", false,           pr = 185 },
    ["Mult_RangeMin"]         = { "autostat.rangemin",    "mult", false,           pr = 184 },
    ["Mult_Penetration"]      = { "autostat.penetration", "mult", false,           pr = 213 },
    ["Mult_MuzzleVelocity"]   = { "autostat.muzzlevel",   "mult", false,           pr = 212 },
    ["Mult_PhysBulletMuzzleVelocity"] = { "autostat.muzzlevel",   "mult", false,   pr = 211 },
    ["Mult_MeleeTime"]        = { "autostat.meleetime",   "mult", true,            pr = 145 },
    ["Mult_MeleeDamage"]      = { "autostat.meleedamage", "mult", false,           pr = 144 },
    ["Add_MeleeRange"]        = { "autostat.meleerange",  false,  false,           pr = 143 },
    ["Mult_Recoil"]           = { "autostat.recoil",      "mult", true,            pr = 195 },
    ["Mult_RecoilSide"]       = { "autostat.recoilside",  "mult", true,            pr = 194 },
    ["Mult_RPM"]              = { "autostat.firerate",    "mult", false,           pr = 216 },
    ["Mult_AccuracyMOA"]      = { "autostat.precision",   "mult", true,            pr = 186 },
    ["Mult_HipDispersion"]    = { "autostat.hipdisp",     "mult", true,            pr = 155 },
    ["Mult_SightsDispersion"] = { "autostat.sightdisp",   "mult", true,            pr = 154 },
    ["Mult_MoveDispersion"]   = { "autostat.movedisp",    "mult", true,            pr = 153 },
    ["Mult_JumpDispersion"]   = { "autostat.jumpdisp",    "mult", true,            pr = 152 },
    ["Mult_ShootVol"]         = { "autostat.shootvol",    "mult", true,            pr = 115 },
    ["Mult_SpeedMult"]        = { "autostat.speedmult",   "mult", false,           pr = 114 },
    ["Mult_MoveSpeed"]        = { "autostat.speedmult",   "mult", false,           pr = 105 },
    ["Mult_SightedSpeedMult"] = { "autostat.sightspeed",  "mult", false,           pr = 104 },
    ["Mult_SightedMoveSpeed"] = { "autostat.sightspeed",  "mult", false,           pr = 103 },
    ["Mult_ShootSpeedMult"]   = { "autostat.shootspeed",  "mult", false,           pr = 102 },
    ["Mult_ReloadTime"]       = { "autostat.reloadtime",  "mult", true,            pr = 125 },
    ["Add_BarrelLength"]      = { "autostat.barrellength","add",  true,            pr = 915 },
    ["Mult_DrawTime"]         = { "autostat.drawtime",    "mult", true,            pr = 14 },
    ["Mult_SightTime"]        = { "autostat.sighttime",   "mult", true,            pr = 335, flipsigns = true },
    ["Mult_CycleTime"]        = { "autostat.cycletime",   "mult", true,            pr = 334 },
    ["Mult_Sway"]             = { "autostat.sway",        "mult",  true,           pr = 353 },
    ["Mult_HeatCapacity"]     = { "autostat.heatcap",     "mult", false,           pr = 10 },
    ["Mult_HeatDissipation"]  = { "autostat.heatdrain",   "mult", false,           pr = 9 },
    ["Mult_FixTime"]          = { "autostat.heatfix",     "mult", true,            pr = 8 },
    ["Mult_HeatDelayTime"]    = { "autostat.heatdelay",   "mult", true,            pr = 7 },
    ["Mult_MalfunctionMean"]  = { "autostat.malfunctionmean", "mult", false,       pr = 6 },
    ["Add_ClipSize"]          = { "autostat.clipsize.mod",    "add", false,         pr = 315 },
    ["Mult_ClipSize"]         = { "autostat.clipsize.mod",    "mult", false,        pr = 314 },

    ["Mult_TriggerDelayTime"] = { "autostat.triggerdelay",    "mult", true,        pr = 200 },

    ["Override_Ammo"] = {"autostat.ammotype", "func", function(wep, val, att)
        -- have to use the weapons table here because Primary.Ammo *is* modified when attachments are used
        if !IsValid(wep) or !weapons.Get(wep:GetClass()) or weapons.Get(wep:GetClass()).Primary.Ammo == val then return end
        return string.format(translate("autostat.ammotype"), string.lower(ArcCW.TranslateAmmo(val))), "infos"
    end, pr = 316},
    ["Override_ClipSize"] = {"autostat.clipsize", "func", function(wep, val, att)
        if !IsValid(wep) then return end
        local ogclip = wep:GetBuff_Override("BaseClipSize") or (wep.RegularClipSize or (wep.Primary and wep.Primary.ClipSize) or 0)
        if ogclip < val then
            return string.format(translate("autostat.clipsize"), val), "pros"
        else
            return string.format(translate("autostat.clipsize"), val), "cons"
        end
    end, pr = 317},
    ["Bipod"] = {"autostat.bipod2", "func", function(wep, val, att)
        if val then
            local recoil = 100 - math.Round((att.Mult_BipodRecoil or (IsValid(wep) and wep.BipodRecoil) or 1) * 100)
            local disp = 100 - math.Round((att.Mult_BipodDispersion or (IsValid(wep) and wep.BipodDispersion) or 1) * 100)
            return string.format(translate("autostat.bipod2"), disp, recoil), "pros"
        else
            return translate("autostat.nobipod"), "cons"
        end
    end, pr = 314},
    ["UBGL"] = { "autostat.ubgl",  "override", false,        pr = 950 },
    ["UBGL_Ammo"] = {"autostat.ammotypeubgl", "func", function(wep, val, att)
        -- have to use the weapons table here because Primary.Ammo *is* modified when attachments are used
        if !IsValid(wep) then return end
        return string.format(translate("autostat.ammotypeubgl"), string.lower(ArcCW.TranslateAmmo(val))), "infos"
    end, pr = 949},

    ["Add_AccuracyMOA"] = { "autostat.precision",   "func",  function(wep, val, att)
        if val > 0 then
            return "+" .. math.Round(val, 2) .. " " .. translate("unit.moa") .. " " .. translate("autostat.precision"), "cons"
        else
            return "-" .. math.Round(val, 2) .. " " .. translate("unit.moa") .. " " .. translate("autostat.precision"), "pros"
        end
    end, pr = 187 },
}

local function getsimpleamt(stat)
    if stat > 1 then
        return stat >= 2 and "++++ " or stat >= 1.5 and "+++ " or stat >= 1.25 and "++ " or "+ "
    elseif stat < 1 then
        return stat <= 0.75 and "---- " or stat <= 0.5 and "--- " or stat <= 0.25 and "-- " or "- "
    end
end

local function stattext(wep, att, i, k, dmgboth, flipsigns)
    if !ArcCW.AutoStats[i] then return end
    if i == "Mult_DamageMin" and dmgboth then return end

    local stat = ArcCW.AutoStats[i]
    local simple = ArcCW.ConVars["attinv_simpleproscons"]:GetBool()

    local txt = ""
    local str, eval = ArcCW.GetTranslation(stat[1]) or stat[1], stat[3]

    if i == "Mult_Damage" and dmgboth then
        str = ArcCW.GetTranslation("autostat.damageboth") or stat[1]
    end

    local tcon, tpro = eval and "cons" or "pros", eval and "pros" or "cons"

    if stat[3] == "infos" then
        tcon = "infos"
    end

    if stat[2] == "mult" and k != 1 then
        local sign, percent = k > 1 and (flipsigns and "-" or "+") or (flipsigns and "+" or "-"), k > 1 and (k - 1) or (1 - k)
        txt = simple and getsimpleamt(k) or sign .. tostr(math.Round(percent * 100, 2)) .. "% "
        return txt .. str, k > 1 and tcon or tpro
    elseif stat[2] == "add" and k != 0 then
        local sign, state = k > 0 and (flipsigns and "-" or "+") or (flipsigns and "+" or "-"), k > 0 and k or -k
        txt = simple and "+ " or sign .. tostr(state) .. " "
        return txt .. str, k > 0 and tcon or tpro
    elseif stat[2] == "override" and k == true then
        return str, tcon
    elseif stat[2] == "func" then
        local a, b = stat[3](wep, k, att)
        if a and b then return a, b end
    end
end

function ArcCW:GetProsCons(wep, att, toggle)
    local pros = {}
    local cons = {}
    local infos = {}

    tbl_add(pros, att.Desc_Pros or {})
    tbl_add(cons, att.Desc_Cons or {})
    tbl_add(infos, att.Desc_Neutrals or {})

    local override = hook.Run("ArcCW_PreAutoStats", wep, att, pros, cons, infos, toggle)
    if override then return pros, cons, infos end

    -- Localize attachment-specific text
    local hasmaginfo = false
    for i, v in pairs(pros) do
        if v == "pro.magcap" then hasmaginfo = true end
        pros[i] = ArcCW.TryTranslation(v)
    end
    for i, v in pairs(cons) do
        if v == "con.magcap" then hasmaginfo = true end
        cons[i] = ArcCW.TryTranslation(v)
    end
    for i, v in pairs(infos) do infos[i] = ArcCW.TryTranslation(v) end

    if !att.AutoStats then return pros, cons, infos end

    -- Process togglable stats
    if att.ToggleStats then
        --local toggletbl = att.ToggleStats[toggle or 1]
        for ti, toggletbl in pairs(att.ToggleStats) do
            -- show the first stat block (unless NoAutoStats), and all blocks with AutoStats
            if toggletbl.AutoStats or (ti == (toggle or 1) and !toggletbl.NoAutoStats) then
                local dmgboth = toggletbl.Mult_DamageMin and toggletbl.Mult_Damage and toggletbl.Mult_DamageMin == toggletbl.Mult_Damage
                for i, stat in SortedPairsByMemberValue(ArcCW.AutoStats, "pr", true) do
                    if !toggletbl[i] or toggletbl[i .. "_SkipAS"] then continue end
                    local val = toggletbl[i]
                    --[[]
                    -- makes the stat show as a sum and not an additional modifier
                    -- feels more confusing though
                    if att[i] then
                        if stat[2] == "add" then
                            val = val + att[i]
                        elseif stat[2] == "mult" then
                            val = val * att[i]
                        end
                    end
                    ]]

                    local txt, typ = stattext(wep, toggletbl, i, val, dmgboth, ArcCW.AutoStats[i].flipsigns )
                    if !txt then continue end

                    local prefix = (stat[2] == "override" and k == true) and "" or ("[" .. (toggletbl.AutoStatName or toggletbl.PrintName or ti) .. "] ")

                    if typ == "pros" then
                        tbl_ins(pros, prefix .. txt)
                    elseif typ == "cons" then
                        tbl_ins(cons, prefix .. txt)
                    elseif typ == "infos" then
                        tbl_ins(infos, prefix .. txt)
                    end
                end
            end
        end
    end

    local dmgboth = att.Mult_DamageMin and att.Mult_Damage and att.Mult_DamageMin == att.Mult_Damage

    for i, stat in SortedPairsByMemberValue(ArcCW.AutoStats, "pr", true) do
        if !att[i] or att[i .. "_SkipAS"] then continue end

        -- Legacy support: If "Increased/Decreased magazine capacity" line exists, don't do our autostats version
        if hasmaginfo and i == "Override_ClipSize" then continue end

        if i == "UBGL" then
			tbl_ins(infos, translate("autostat.ubgl2"))
		end

        local txt, typ = stattext(wep, att, i, att[i], dmgboth, ArcCW.AutoStats[i].flipsigns )
        if !txt then continue end

        if typ == "pros" then
            tbl_ins(pros, txt)
        elseif typ == "cons" then
            tbl_ins(cons, txt)
        elseif typ == "infos" then
            tbl_ins(infos, txt)
        end

        --[[]
        if i == "Mult_DamageMin" and dmgboth then continue end

        local k, txt  = att[i], ""
        local str, st = ArcCW.GetTranslation(stat[1]) or stat[1], stat[3]

        if i == "Mult_Damage" and dmgboth then
            str = ArcCW.GetTranslation("autostat.damageboth") or stat[1]
        end

        local tcon, tpro = st and cons or pros, st and pros or cons

        if stat[2] == "mult" and k != 1 then
            local sign, percent = k > 1 and "+" or "-", k > 1 and (k - 1) or (1 - k)

            txt = simple and getsimpleamt(k) or sign .. tostr(math.Round(percent * 100, 2)) .. "% "

            tbl_ins(k > 1 and tcon or tpro, txt .. str)
        elseif stat[2] == "add" and k != 0 then
            local sign, state = k > 0 and "+" or "-", k > 0 and k or -k

            txt = simple and "+ " or sign .. tostr(state) .. " "

            tbl_ins(k > 1 and tpro or tcon, txt .. str)
        elseif stat[2] == "override" and k == true then
            tbl_ins(st and cons or pros, 1, str)
        end
        ]]
    end

    hook.Run("ArcCW_PostAutoStats", wep, att, pros, cons, infos, toggle)

    return pros, cons, infos
end
--PATH lua/arccw/client/cl_blacklist.lua:
return gluapack()()
--PATH lua/arccw/client/cl_hud.lua:
return gluapack()()
--PATH lua/arccw/client/cl_menus.lua:
--[[
    Panel table doc:
    id (any number) = data:
    type
    type args

    types:
    h - header                        text
    c - control help                  text
    b - checkbox                      text var
    i - integer slider                text var min max
    f - float slider (2 nums after .) text var min max
    m - color mixer                   text r g b a
    p - press or button               text func
    t - textbox                       text string
    o - combo box                     text var choices (key - cvar, value - text)
    d - binder                        text var
    (you can add custom types in ArcCW.GeneratePanelElements's AddControl table)

    Generate elements via ArcCW.GeneratePanelElements:
    panel, panel table with data

    Add menu generation to ArcCW.ClientMenus:
    name = data:
    text - header text
    func - generator function
]]

local BulletPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "c", text = "#arccw.bullet_help" },
    { type = "b", text = "#arccw.cvar.bullet_enable", var = "arccw_bullet_enable", sv = true },
    { type = "b", text = "#arccw.cvar.enable_penetration", var = "arccw_enable_penetration", sv = true },
    { type = "b", text = "#arccw.cvar.enable_ricochet", var = "arccw_enable_ricochet", sv = true },
    { type = "f", text = "#arccw.cvar.bullet_velocity", var = "arccw_bullet_velocity", min = 0, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.bullet_gravity", var = "arccw_bullet_gravity", min = 0, max = 1200, sv = true },
    { type = "f", text = "#arccw.cvar.bullet_drag", var = "arccw_bullet_drag", min = 0, max = 10, sv = true },
    { type = "f", text = "#arccw.cvar.bullet_lifetime", var = "arccw_bullet_lifetime", min = 1, max = 20, sv = true},
}

local ClientPanel = {
    { type = "h", text = "#arccw.clientcfg" },
    { type = "b", text = "#arccw.cvar.automaticreload", var = "arccw_automaticreload" },
    { type = "c", text = "#arccw.cvar.automaticreload.desc" },
    { type = "f", text = "#arccw.cvar.adjustsensthreshold", var = "arccw_adjustsensthreshold", min = 0, max = 50, sv = true },
    { type = "c", text = "#arccw.cvar.adjustsensthreshold.desc" },
    { type = "b", text = "#arccw.cvar.toggleads", var = "arccw_toggleads" },
    { type = "b", text = "#arccw.cvar.autosave", var = "arccw_autosave" },
    { type = "c", text = "#arccw.cvar.autosave.desc" },
    --{ type = "b", text = "#arccw.cvar.embracetradition", var = "arccw_hud_embracetradition" },
    --{ type = "c", text = "#arccw.cvar.embracetradition.desc" },
    { type = "b", text = "#arccw.cvar.glare", var = "arccw_glare" },
    { type = "c", text = "#arccw.cvar.glare.desc" },
    { type = "b", text = "#arccw.cvar.shake", var = "arccw_shake" },
    { type = "b", text = "#arccw.cvar.shakevm", var = "arccw_shakevm" },
    { type = "c", text = "#arccw.cvar.shake_info" },
    { type = "b", text = "#arccw.cvar.aimassist", var = "arccw_aimassist_cl" },
    { type = "c", text = "#arccw.cvar.aimassist_cl.desc" },
    -- { type = "b", text = "#arccw.cvar.2d3d", var = "arccw_2d3d" },
    { type = "o", text = "#arccw.cvar.2d3d", var = "arccw_2d3d",
            choices = {[0] = "#arccw.combobox.disabled", [1] = "#arccw.cvar.2d3d.1", [2] = "#arccw.cvar.2d3d.2"}},
    { type = "c", text = "#arccw.cvar.2d3d_info" },
    { type = "t", text = "#arccw.cvar.language", var = "arccw_language"  },
    { type = "c", text = "#arccw.cvar.language_info" },
    { type = "b", text = "#arccw.cvar.ammonames", var = "arccw_ammonames" },
    { type = "c", text = "#arccw.cvar.ammonames.desc" },
    { type = "b", text = "#arccw.cvar.noinspect", var = "arccw_noinspect" },
}

local PerformancePanel = {
    --{ type = "h", text = "#arccw.clientcfg" },
    { type = "h", text = "#arccw.performance" },
    { type = "b", text = "#arccw.cvar.cheapscopes", var = "arccw_cheapscopes" },
    { type = "c", text = "#arccw.cvar.cheapscopes.desc" },
    -- { type = "b", text = "#arccw.cvar.flatscopes", var = "arccw_flatscopes" },
    -- { type = "c", text = "#arccw.cvar.flatscopes.desc" },
    { type = "b", text = "#arccw.cvar.muzzleeffects", var = "arccw_muzzleeffects" },
    { type = "b", text = "#arccw.cvar.fastmuzzles", var = "arccw_fastmuzzles" },
    { type = "b", text = "#arccw.cvar.fasttracers", var = "arccw_fasttracers" },
    { type = "b", text = "#arccw.cvar.shelleffects", var = "arccw_shelleffects" },
    { type = "b", text = "#arccw.cvar.att_showothers", var = "arccw_att_showothers" },
    { type = "b", text = "#arccw.cvar.att_showground", var = "arccw_att_showground" },
    { type = "i", text = "#arccw.cvar.visibility", var = "arccw_visibility", min = -1, max = 32000},
    { type = "c", text = "#arccw.cvar.visibility.desc" },
    { type = "b", text = "#arccw.cvar.blur", var = "arccw_blur" },
    { type = "b", text = "#arccw.cvar.blur_toytown", var = "arccw_blur_toytown" },
    { type = "b", text = "#arccw.cvar.bullet_imaginary", var = "arccw_bullet_imaginary" },
    { type = "c", text = "#arccw.cvar.bullet_imaginary.desc" },
    { type = "f", text = "#arccw.cvar.shelltime", var = "arccw_shelltime", min = 0, max = 180 },
}

local ViewmodelPanel = {
    { type = "b", text = "#arccw.cvar.vm_coolsway", var = "arccw_vm_coolsway" },
    { type = "b", text = "#arccw.cvar.vm_coolview", var = "arccw_vm_coolview" },
    { type = "h", text = "" },
    { type = "c", text = "#arccw.cvar.vm_offsetwarn" },
    { type = "f", text = "#arccw.cvar.vm_fov", var = "arccw_vm_fov",         min = -15, max = 15 },
    { type = "f", text = "#arccw.cvar.vm_right", var = "arccw_vm_right",     min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.vm_forward", var = "arccw_vm_forward", min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.vm_up", var = "arccw_vm_up",           min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.vm_pitch", var = "arccw_vm_pitch",     min = -15, max = 15 },
    { type = "f", text = "#arccw.cvar.vm_yaw", var = "arccw_vm_yaw",         min = -15, max = 15 },
    { type = "f", text = "#arccw.cvar.vm_roll", var = "arccw_vm_roll",       min = -15, max = 15 },
    { type = "c", text = "" },
    { type = "c", text = "#arccw.cvar.vm_swaywarn" },
    { type = "f", text = "#arccw.cvar.vm_look_xmult", var = "arccw_vm_look_xmult", min = -10, max = 10 },
    { type = "f", text = "#arccw.cvar.vm_look_ymult", var = "arccw_vm_look_ymult", min = -10, max = 10 },
    { type = "f", text = "#arccw.cvar.vm_sway_xmult", var = "arccw_vm_sway_xmult", min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.vm_sway_ymult", var = "arccw_vm_sway_ymult", min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.vm_sway_zmult", var = "arccw_vm_sway_zmult", min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.vm_sway_speedmult", var = "arccw_vm_sway_speedmult", min = 0, max = 2 },
    { type = "h", text = "" },
    { type = "c", text = "#arccw.cvar.vm_viewwarn" },
    { type = "f", text = "#arccw.cvar.vm_coolviewmult", var = "arccw_vm_coolview_mult", min = -5, max = 5 },
    { type = "b", text = "#arccw.cvar.vm_nearwall", var = "arccw_vm_nearwall" },
}

local HudPanel = {
    { type = "h", text = "#arccw.clientcfg" },
    { type = "h", text = "#arccw.hud_svwarning" },
    { type = "b", text = "#arccw.cvar.hud_showhealth", var = "arccw_hud_showhealth" },
    { type = "c", text = "#arccw.cvar.hud_showhealth.desc" },
    { type = "b", text = "#arccw.cvar.hud_showammo", var = "arccw_hud_showammo" },
    { type = "c", text = "#arccw.cvar.hud_showammo.desc" },
    { type = "i", text = "#arccw.cvar.hud_3dfun_decay", var = "arccw_hud_3dfun_decaytime", min = 0, max = 5 },
    { type = "c", text = "#arccw.cvar.hud_3dfun_decay.desc" },
    { type = "b", text = "#arccw.cvar.hud_minimal", var = "arccw_hud_minimal" },
    { type = "c", text = "#arccw.cvar.hud_minimal.desc" },
    { type = "b", text = "#arccw.cvar.hud_forceshow", var = "arccw_hud_forceshow" },
    { type = "c", text = "#arccw.cvar.hud_forceshow.desc" },
    { type = "b", text = "#arccw.cvar.attinv_closeonhurt", var = "arccw_attinv_closeonhurt" },
    { type = "f", text = "#arccw.cvar.hudpos_deadzone_x", var = "arccw_hud_deadzone_x", min = 0, max = 0.5 },
    { type = "f", text = "#arccw.cvar.hudpos_deadzone_y", var = "arccw_hud_deadzone_y", min = 0, max = 0.5 },
    { type = "c", text = "#arccw.cvar.hudpos_deadzone.desc" },
    { type = "f", text = "#arccw.cvar.hudpos_size", var = "arccw_hud_size", min = 0.67, max = 1.5 },
    { type = "c", text = "#arccw.cvar.hudpos_size.desc" },
    { type = "t", text = "#arccw.cvar.font", var = "arccw_font"  },
    { type = "c", text = "#arccw.cvar.font_info" },

    { type = "b", text = "#arccw.cvar.attinv_sound", var = "arccw_cust_sounds" },
    { type = "c", text = "#arccw.cvar.attinv_sound.desc" },
    { type = "b", text = "#arccw.cvar.attinv_hideunowned", var = "arccw_attinv_hideunowned" },
    { type = "b", text = "#arccw.cvar.attinv_darkunowned", var = "arccw_attinv_darkunowned" },
    { type = "b", text = "#arccw.cvar.attinv_onlyinspect", var = "arccw_attinv_onlyinspect" },
    { type = "b", text = "#arccw.cvar.attinv_simpleproscons", var = "arccw_attinv_simpleproscons" },
    --{ type = "b", text = "#arccw.cvar.attinv_gamemodebuttons", var = "arccw_attinv_gamemodebuttons" },
    --{ type = "c", text = "#arccw.cvar.attinv_gamemodebuttons.desc" },

    { type = "h", text = "#arccw.ammohud" },
    { type = "b", text = "#arccw.cvar.hud_3dfun", var = "arccw_hud_3dfun" },
    { type = "c", text = "#arccw.cvar.hud_3dfun.desc" },
    { type = "b", text = "#arccw.cvar.hud_3dfun_lite", var = "arccw_hud_3dfun_lite" },
    { type = "c", text = "#arccw.cvar.hud_3dfun_lite.desc" },
    { type = "b", text = "#arccw.cvar.hud_fcgbars", var = "arccw_hud_fcgbars" },
    { type = "b", text = "#arccw.cvar.hud_fcgabbrev", var = "arccw_hud_fcgabbrev" },
    { type = "b", text = "#arccw.cvar.hud_3dfun_ammotype", var = "arccw_hud_3dfun_ammotype" },
    { type = "c", text = "#arccw.cvar.hud_3dfun_ammotype.desc" },

    { type = "f", text = "#arccw.cvar.hud_3dfun_right", var = "arccw_hud_3dfun_right", min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.hud_3dfun_up", var = "arccw_hud_3dfun_up", min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.hud_3dfun_forward", var = "arccw_hud_3dfun_forward", min = -5, max = 5 },
}

local CrosshairPanel = {
    { type = "h", text = "#arccw.clientcfg" },
    { type = "b", text = "#arccw.cvar.crosshair", var = "arccw_crosshair" },
    { type = "f", text = "#arccw.cvar.crosshair_length", var = "arccw_crosshair_length", min = 0, max = 10 },
    { type = "f", text = "#arccw.cvar.crosshair_thickness", var = "arccw_crosshair_thickness", min = 0, max = 2 },
    { type = "f", text = "#arccw.cvar.crosshair_gap", var = "arccw_crosshair_gap", min = 0, max = 2 },
    { type = "b", text = "#arccw.cvar.crosshair_dot", var = "arccw_crosshair_dot" },
    { type = "b", text = "#arccw.cvar.crosshair_shotgun", var = "arccw_crosshair_shotgun" },
    { type = "b", text = "#arccw.cvar.crosshair_equip", var = "arccw_crosshair_equip" },
    { type = "b", text = "#arccw.cvar.crosshair_static", var = "arccw_crosshair_static" },
    { type = "b", text = "#arccw.cvar.crosshair_trueaim", var = "arccw_crosshair_trueaim" },
    { type = "b", text = "#arccw.cvar.crosshair_clump", var = "arccw_crosshair_clump" },
    { type = "b", text = "#arccw.cvar.crosshair_clump_outline", var = "arccw_crosshair_clump_outline" },
    { type = "b", text = "#arccw.cvar.crosshair_clump_always", var = "arccw_crosshair_clump_always" },
    { type = "b", text = "#arccw.cvar.crosshair_aa", var = "arccw_crosshair_aa" },
    { type = "b", text = "#arccw.cvar.crosshair_tilt", var = "arccw_crosshair_tilt" },
    { type = "b", text = "#arccw.cvar.crosshair_prong_top", var = "arccw_crosshair_prong_top" },
    { type = "b", text = "#arccw.cvar.crosshair_prong_left", var = "arccw_crosshair_prong_left" },
    { type = "b", text = "#arccw.cvar.crosshair_prong_right", var = "arccw_crosshair_prong_right" },
    { type = "b", text = "#arccw.cvar.crosshair_prong_bottom", var = "arccw_crosshair_prong_bottom" },
    { type = "m", text = "#arccw.cvar.crosshair_clr", r = "arccw_crosshair_clr_r", g = "arccw_crosshair_clr_g", b = "arccw_crosshair_clr_b", a = "arccw_crosshair_clr_a" },
    { type = "f", text = "#arccw.cvar.crosshair_outline", var = "arccw_crosshair_outline", min = 0, max = 4 },
    { type = "m", text = "#arccw.cvar.crosshair_outline_clr", r = "arccw_crosshair_outline_r", g = "arccw_crosshair_outline_g", b = "arccw_crosshair_outline_b", a = "arccw_crosshair_outline_a" },
}

local BindsPanel = {
    { type = "h", text = "#arccw.bindhelp" },
    { type = "b", text = "#arccw.cvar.nohl2flash", var = "arccw_nohl2flash" },
    { type = "b", text = "#arccw.cvar.altsafety", var = "arccw_altsafety" },
    { type = "b", text = "#arccw.cvar.altbindsonly", var = "arccw_altbindsonly" },
    { type = "c", text = "#arccw.cvar.altbindsonly.desc" },
    { type = "d", text = "#arccw.bind.firemode", var = "arccw_firemode" },
    { type = "d", text = "#arccw.bind.zoom_in", var = "arccw_zoom_in" },
    { type = "d", text = "#arccw.bind.zoom_out", var = "arccw_zoom_out" },
    { type = "d", text = "#arccw.bind.toggle_inv", var = "arccw_toggle_inv" },
    { type = "d", text = "#arccw.bind.switch_scope", var = "arccw_switch_scope" },
    { type = "d", text = "#arccw.bind.toggle_ubgl", var = "arccw_toggle_ubgl" },
    { type = "d", text = "#arccw.bind.melee", var = "arccw_melee" },
    { type = "d", text = "#arccw.bind.toggle_att", var = "arccw_toggle_att" },
}

local ServerPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "o", text = "#arccw.cvar.enable_customization", var = "arccw_enable_customization", sv = true,
            choices = {[-1] = "#arccw.cvar.enable_customization.-1", [0] = "#arccw.cvar.enable_customization.0", [1] = "#arccw.cvar.enable_customization.1"}},
    { type = "c", text = "#arccw.cvar.enable_customization.desc" },
    { type = "b", text = "#arccw.cvar.truenames", var = "arccw_truenames", sv = true },
    { type = "b", text = "#arccw.cvar.equipmentammo", var = "arccw_equipmentammo", sv = true },
    { type = "c", text = "#arccw.cvar.equipmentammo.desc" },
    { type = "b", text = "#arccw.cvar.equipmentsingleton", var = "arccw_equipmentsingleton", sv = true },
    { type = "c", text = "#arccw.cvar.equipmentsingleton.desc" },
    { type = "i", text = "#arccw.cvar.equipmenttime", var = "arccw_equipmenttime", min = 15, max = 3600, sv = true },
    { type = "b", text = "#arccw.cvar.throwinertia", var = "arccw_throwinertia", sv = true },
    { type = "o", text = "#arccw.cvar.freeaim", var = "arccw_freeaim", sv = true,
            choices = {[0] = "#arccw.combobox.disabled", [1] = "#arccw.cvar.freeaim.1", [2] = "#arccw.cvar.freeaim.2"}},
    { type = "b", text = "#arccw.cvar.override_crosshair_off", var = "arccw_override_crosshair_off", sv = true },
    { type = "b", text = "#arccw.cvar.override_hud_off", var = "arccw_override_hud_off", sv = true },
    { type = "b", text = "#arccw.cvar.override_barrellength", var = "arccw_override_nearwall", sv = true },
    { type = "b", text = "#arccw.cvar.doorbust", var = "arccw_doorbust", sv = true },
    { type = "b", text = "#arccw.cvar.override_lunge_off", var = "arccw_override_lunge_off", sv = true },
    { type = "c", text = "#arccw.cvar.override_lunge_off.desc" },
    --[[]
    { type = "b", text = "#arccw.cvar.limityear_enable", var = "arccw_limityear_enable", sv = true },
    { type = "i", text = "#arccw.cvar.limityear", var = "arccw_limityear", min = 1800, max = 2100, sv = true },
    { type = "c", text = "#arccw.cvar.limityear.desc"},
    ]]
    { type = "b", text = "#arccw.cvar.bodydamagecancel", var = "arccw_bodydamagemult_cancel", sv = true},
    { type = "c", text = "#arccw.cvar.bodydamagecancel.desc"},
    { type = "b", text = "#arccw.cvar.desync", var = "arccw_desync", sv = true },
    { type = "c", text = "#arccw.cvar.desync.desc" },
    { type = "f", text = "#arccw.cvar.weakensounds", var = "arccw_weakensounds", min = -20, max = 30, sv = true},
    { type = "c", text = "#arccw.cvar.weakensounds.desc" },
    { type = "b", text = "#arccw.cvar.reloadincust", var = "arccw_reloadincust", sv = true },
    { type = "c", text = "#arccw.cvar.reloadincust.desc" },
    { type = "b", text = "#arccw.cvar.aimassist", var = "arccw_aimassist", sv = true },
    { type = "c", text = "#arccw.cvar.aimassist.desc" },
    { type = "b", text = "#arccw.cvar.aimassist_head", var = "arccw_aimassist_head", sv = true },
    { type = "f", text = "#arccw.cvar.aimassist_cone", var = "arccw_aimassist_cone", min = 0, max = 360, sv = true},
    { type = "f", text = "#arccw.cvar.aimassist_distance", var = "arccw_aimassist_distance", min = 128, max = 4096, sv = true},
    { type = "f", text = "#arccw.cvar.aimassist_intensity", var = "arccw_aimassist_intensity", min = 0, max = 10, sv = true},
}

local AmmoPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "o", text = "#arccw.cvar.ammo_detonationmode", var = "arccw_ammo_detonationmode", sv = true,
            choices = {[-1] = "#arccw.cvar.ammo_detonationmode.-1", [0] = "#arccw.cvar.ammo_detonationmode.0", [1] = "#arccw.cvar.ammo_detonationmode.1", [2] = "#arccw.cvar.ammo_detonationmode.2"}},
    { type = "b", text = "#arccw.cvar.ammo_autopickup", var = "arccw_ammo_autopickup", sv = true },
    { type = "b", text = "#arccw.cvar.ammo_largetrigger", var = "arccw_ammo_largetrigger", sv = true },
    { type = "f", text = "#arccw.cvar.ammo_rareskin", var = "arccw_ammo_rareskin", min = 0, max = 1, sv = true },
    { type = "b", text = "#arccw.cvar.ammo_chaindet", var = "arccw_ammo_chaindet", sv = true },
    { type = "b", text = "#arccw.cvar.ammo_replace", var = "arccw_ammo_replace", sv = true },
    { type = "f", text = "#arccw.cvar.mult_ammohealth", var = "arccw_mult_ammohealth", min = -1, max = 10, sv = true },
    { type = "f", text = "#arccw.cvar.mult_ammoamount", var = "arccw_mult_ammoamount", min = 0.1, max = 10, sv = true },
}

local AttsPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "h", text = "#arccw.attdesc1" },
    { type = "h", text = "#arccw.attdesc2" },
    { type = "b", text = "#arccw.cvar.attinv_free", var = "arccw_attinv_free", sv = true },
    { type = "b", text = "#arccw.cvar.attinv_lockmode", var = "arccw_attinv_lockmode", sv = true },
    { type = "o", text = "#arccw.cvar.attinv_loseondie", var = "arccw_attinv_loseondie", sv = true,
            choices = {[0] = "#arccw.combobox.disabled", [1] = "#arccw.cvar.attinv_loseondie.1", [2] = "#arccw.cvar.attinv_loseondie.2"}},
    { type = "i", text = "#arccw.cvar.attinv_giveonspawn", var = "arccw_attinv_giveonspawn", min = 0, max = 100, sv = true },
    { type = "i", text = "#arccw.cvar.atts_pickx", var = "arccw_atts_pickx", min = 0, max = 10, sv = true },
    { type = "c", text = "#arccw.cvar.atts_pickx.desc", sv = true },
    { type = "b", text = "#arccw.cvar.enable_dropping", var = "arccw_enable_dropping", sv = true },
    { type = "b", text = "#arccw.cvar.atts_spawnrand", var = "arccw_atts_spawnrand", sv = true },
    { type = "b", text = "#arccw.cvar.atts_ubglautoload", var = "arccw_atts_ubglautoload", sv = true },
    { type = "p", text = "#arccw.blacklist", func = function() RunConsoleCommand("arccw_blacklist") end },
}

local DevPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "h", text = "#arccw.dev_info1" },
    { type = "h", text = "#arccw.dev_info2" },
    { type = "b", text = "#arccw.cvar.dev_reloadonadmincleanup", var = "arccw_reloadatts_mapcleanup", sv = true },
    { type = "c", text = "#arccw.cvar.dev_reloadonadmincleanup.desc" },
    { type = "b", text = "#arccw.cvar.dev_registerentities", var = "arccw_reloadatts_registerentities", sv = true },
    { type = "c", text = "#arccw.cvar.dev_registerentities.desc" },
    { type = "b", text = "#arccw.cvar.dev_showignored", var = "arccw_reloadatts_showignored", sv = true },
    { type = "c", text = "#arccw.cvar.dev_showignored.desc" },
    { type = "b", text = "#arccw.cvar.dev_debug", var = "arccw_dev_debug", sv = true },
    { type = "c", text = "#arccw.cvar.dev_debug.desc" },
    --{ type = "b", text = "Customization Menu Overhaul beta", var = "arccw_dev_cust2beta", sv = true },
    --{ type = "c", text = "Enable the customization menu overhaul. Remove this convar when we done doe" },
    { type = "b", text = "#arccw.cvar.dev_alwaysready", var = "arccw_dev_alwaysready", sv = true },
    { type = "c", text = "#arccw.cvar.dev_alwaysready.desc" },
    { type = "b", text = "#arccw.cvar.dev_benchgun", var = "arccw_dev_benchgun", sv = true },
    { type = "c", text = "#arccw.cvar.dev_benchgun.desc" },
    { type = "t", text = "#arccw.cvar.dev_benchgun_custom", var = "arccw_dev_benchgun_custom", sv = true },
    { type = "c", text = "#arccw.cvar.dev_benchgun_custom.desc" },
    { type = "o", text = "Firing Info", var = "arccw_dev_shootinfo", sv = true,
            choices = {[0] = "#arccw.combobox.disabled", [1] = "1 - Damage", [2] = "2 - Penetration", [3] = "3 - Dispersion"}},
    { type = "c", text = "Show information when shooting the weapon. Requires 'developer' ConVar to be enabled." },
    { type = "p", text = "#arccw.cvar.dev_reloadatts", func = function() RunConsoleCommand("arccw_reloadatts") end },
    { type = "h", text = "#arccw.cvar.dev_reloadatts.desc" },
    { type = "p", text = "#arccw.cvar.dev_reloadlangs", func = function() RunConsoleCommand("arccw_reloadlangs") end },
    { type = "h", text = "#arccw.cvar.dev_reloadlangs.desc" },
    { type = "p", text = "#arccw.cvar.dev_spawnmenureload", func = function() RunConsoleCommand("spawnmenu_reload") end },
    { type = "h", text = "#arccw.cvar.dev_spawnmenureload.desc" },
}


local ScopesPanel = {
    { type = "h", text = "#arccw.clientcfg" },

    { type = "b", text = "#arccw.cvar.cheapscopes", var = "arccw_cheapscopes" },
    { type = "c", text = "#arccw.cvar.cheapscopesv2.desc" },
    { type = "f", text = "#arccw.cvar.cheapscopesv2_ratio", var = "arccw_cheapscopesv2_ratio", min = 0, max = 1},
    { type = "c", text = "#arccw.cvar.cheapscopesv2_ratio.desc" },

    { type = "b", text = "#arccw.cvar.drawbarrel", var = "arccw_drawbarrel" },
    { type = "f", text = "#arccw.cvar.vm_addads", var = "arccw_vm_add_ads", min = -0.5, max = 9 },
    { type = "b", text = "#arccw.cvar.scopepp", var = "arccw_scopepp" },
    { type = "b", text = "#arccw.cvar.thermalpp", var = "arccw_thermalpp" },
    { type = "b", text = "#arccw.cvar.scopepp_refract", var = "arccw_scopepp_refract" },
    { type = "f", text = "#arccw.cvar.scopepp_refract_ratio", var = "arccw_scopepp_refract_ratio", min = -1, max = 2 },

    { type = "m", text = "#arccw.cvar.scope_clr", r = "arccw_scope_r", g = "arccw_scope_g", b = "arccw_scope_b" },
}

local MultsPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "f", text = "#arccw.cvar.mult_damage",          var = "arccw_mult_damage", min = 0, max = 10, sv = true },
    { type = "f", text = "#arccw.cvar.mult_npcdamage",       var = "arccw_mult_npcdamage", min = 0, max = 5, sv = true },
    { type = "f", text = "#arccw.cvar.mult_range",           var = "arccw_mult_range", min = 0.1, max = 5, sv = true },
    { type = "f", text = "#arccw.cvar.mult_recoil",          var = "arccw_mult_recoil", min = 0, max = 5, sv = true },
    { type = "f", text = "#arccw.cvar.mult_penetration",     var = "arccw_mult_penetration", min = 0, max = 5, sv = true },
    { type = "f", text = "#arccw.cvar.mult_hipfire",         var = "arccw_mult_hipfire", min = 0, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.mult_accuracy",        var = "arccw_mult_accuracy", min = 0, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.mult_movedisp",        var = "arccw_mult_movedisp", min = 0, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.mult_reloadtime",      var = "arccw_mult_reloadtime", min = 0.2, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.mult_sighttime",       var = "arccw_mult_sighttime", min = 0.25, max = 3, sv = true },
    { type = "i", text = "#arccw.cvar.mult_defaultammo",     var = "arccw_mult_defaultammo", min = 0, max = 10, sv = true },
    { type = "f", text = "#arccw.cvar.mult_attchance",       var = "arccw_mult_attchance", min = 0, max = 10, sv = true },
    { type = "f", text = "#arccw.cvar.mult_heat",            var = "arccw_mult_heat", min = 0, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.mult_crouchdisp",      var = "arccw_mult_crouchdisp", min = 0, max = 1, sv = true },
    { type = "f", text = "#arccw.cvar.mult_crouchrecoil",    var = "arccw_mult_crouchrecoil", min = 0, max = 1, sv = true },
    { type = "f", text = "#arccw.cvar.mult_movespeed",       var = "arccw_mult_movespeed", min = 0, max = 1, sv = true },
    { type = "f", text = "#arccw.cvar.mult_movespeedads",    var = "arccw_mult_movespeedads", min = 0, max = 1, sv = true },
    { type = "f", text = "#arccw.cvar.mult_movespeedfire",   var = "arccw_mult_movespeedfire", min = 0, max = 1, sv = true },

    { type = "f", text = "#arccw.cvar.mult_meleedamage",     var = "arccw_mult_meleedamage", min = 0, max = 4, sv = true },
    { type = "f", text = "#arccw.cvar.mult_meleetime",       var = "arccw_mult_meleetime", min = 0, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.mult_malfunction",     var = "arccw_mult_malfunction", min = 0, max = 10, sv = true },
    { type = "f", text = "#arccw.cvar.mult_rpm",             var = "arccw_mult_rpm", min = 0.1, max = 5, sv = true },
    { type = "c", text = "#arccw.cvar.mult_rpm.desc" },

    { type = "b", text = "#arccw.cvar.mult_startunloaded",   var = "arccw_mult_startunloaded", sv = true },
    { type = "b", text = "#arccw.cvar.mult_shootwhilesprinting",   var = "arccw_mult_shootwhilesprinting", sv = true },
    { type = "o", text = "#arccw.cvar.malfunction", var = "arccw_malfunction", sv = true,
            choices = {[0] = "#arccw.cvar.malfunction.0", [1] = "#arccw.cvar.malfunction.1", [2] = "#arccw.cvar.malfunction.2"}},

    { type = "b", text = "#arccw.cvar.mult_bottomlessclip",  var = "arccw_mult_bottomlessclip", sv = true },
    { type = "c", text = "Weapon feeds from reserve." },
    { type = "b", text = "#arccw.cvar.mult_infiniteammo",    var = "arccw_mult_infiniteammo", sv = true },
    { type = "c", text = "Infinite reserve ammo." },

    { type = "b", text = "#arccw.cvar.enable_sway",          var = "arccw_enable_sway", sv = true },
    { type = "c", text = "#arccw.cvar.enable_sway.desc" },
    { type = "f", text = "#arccw.cvar.add_sway",             var  = "arccw_add_sway", min = 0, max = 5, sv = true },
    { type = "f", text = "#arccw.cvar.mult_sway",            var = "arccw_mult_sway", min = 0, max = 10, sv = true },
}

local HelpPanel = {
    { type = "h",       text = "Links to the ArcCW online wiki." },

    { type = "url",     text = "Checking for Addon Conflicts",
                        url = "https://github.com/HaodongMo/ArcCW/wiki/Help-&-Troubleshooting#checking-for-addon-conflicts", },
    { type = "c",       text = "Check for addon conflicts that may be causing issues with ArcCW weapons." },

    { type = "url",     text = "Cheap Scopes",
                        url = "https://github.com/HaodongMo/ArcCW/wiki/Help-&-Troubleshooting#cheap-scopes", },
    { type = "c",       text = "'Why are my scopes so blurry?'" },

    { type = "url",     text = "Underbarrel Weapons",
                        url = "https://github.com/HaodongMo/ArcCW/wiki/Help-&-Troubleshooting#underbarrel-weapons", },
    { type = "c",       text = "'Why aren't my underbarrels weapons working?'" },
    { type = "c",       text = "'How do I use my underbarrel weapons?'" },

    { type = "url",     text = "Free Attachments",
                        url = "https://github.com/HaodongMo/ArcCW/wiki/Help-&-Troubleshooting#free-attachments", },
    { type = "c",       text = "'Why are my attachments red?'" },

    { type = "url",     text = "cam.End3D errors",
                        url = "https://github.com/HaodongMo/ArcCW/wiki/Help-&-Troubleshooting#camend3d-errors", },
    { type = "c",       text = "'Warning: Calling cam.End3D because someone forgot to!'" },

}

local MultPresets = {
    ["#preset.default"] = { -- this needs fills
        arccw_mult_damage                   = "1",
        arccw_mult_npcdamage                = "1",
        arccw_mult_range                    = "1",
        arccw_mult_recoil                   = "1",
        arccw_mult_penetration              = "1",
        arccw_mult_hipfire                  = "1",
        arccw_mult_movedisp                 = "1",
        arccw_mult_reloadtime               = "1",
        arccw_mult_sighttime                = "1",
        arccw_mult_defaultclip              = "1",
        arccw_mult_attchance                = "1",
        arccw_mult_crouchdisp               = "1",
        arccw_mult_crouchrecoil             = "1",
        arccw_mult_movespeed                = "1",
        arccw_mult_movespeedads             = "1",
        arccw_mult_movespeedfire            = "1",
        arccw_mult_heat                     = "1",
        arccw_mult_meleetime                = "1",
        arccw_mult_meleedamage              = "1",
        arccw_mult_malfunction              = "1",
        arccw_mult_startunloaded            = "0",
        arccw_mult_shootwhilesprinting      = "0",
        arccw_mult_bottomlessclip           = "0",
        arccw_mult_infiniteammo             = "0",
    }
}

local NPCsPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "b", text = "Replace NPC Weapons", var = "arccw_npc_replace", sv = true },
    { type = "b", text = "NPC Attachments", var = "arccw_npc_atts", sv = true },
}

function ArcCW.NetworkConvar(convar, value, p)
    if IsValid(LocalPlayer()) and !LocalPlayer():IsAdmin() then return end
    if (p.TickCreated or 0) == UnPredictedCurTime() then return end
    if value == true or value == false then
        value = value and 1 or 0
    end
    if IsColor(value) then
        value = tostring(value.r) .. " " .. tostring(value.g) .. " " .. tostring(value.b) .. " " .. tostring(value.a)
    end

    local command = convar .. " " .. tostring(value)

    local timername = "change" .. convar

    if timer.Exists(timername) then
        timer.Remove(timername)
    end

    timer.Create(timername, 0.25, 1, function()
        net.Start("arccw_sendconvar")
        net.WriteString(command)
        net.SendToServer()
    end)
end

function ArcCW.GeneratePanelElements(panel, table)
    local AddControl = {
        ["h"] = function(p, d) return p:Help(d.text) end,
        ["c"] = function(p, d) return p:ControlHelp(d.text) end,
        ["b"] = function(p, d) return p:CheckBox(d.text, d.var) end,
        ["i"] = function(p, d) return p:NumSlider(d.text, d.var, d.min, d.max, 0) end,
        ["f"] = function(p, d) return p:NumSlider(d.text, d.var, d.min, d.max, 2) end,
        ["m"] = function(p, d) --return p:AddControl("color", { Label = d.text, Red = d.r, Green = d.g, Blue = d.b, Alpha = d.a })
            local ctrl = vgui.Create("DColorMixer", p)
            ctrl:SetLabel( d.text ) ctrl:SetConVarR( d.r ) ctrl:SetConVarG( d.g ) ctrl:SetConVarB( d.b ) ctrl:SetConVarA( d.a )
            p:AddItem( ctrl ) return ctrl
        end,
        ["p"] = function(p, d) local b = p:Button(d.text) b.DoClick = d.func return b end,
        ["url"] = function(p, d) local b = p:Button(d.text) b.DoClick = function() gui.OpenURL(d.url) end return b end,
        ["t"] = function(p, d) return p:TextEntry(d.text, d.var) end,
        ["o"] = function(p, d) local cb = p:ComboBox(d.text, d.var) for k, v in pairs(d.choices) do cb:AddChoice(v, k) end return cb end,
        ["d"] = function(p, d)
                local s = vgui.Create("DSizeToContents", p) s:SetSizeX(false) s:Dock(TOP) s:InvalidateLayout()
                local l = vgui.Create("DLabel", s) l:SetText(d.text) l:SetTextColor(Color(0, 0, 0)) l:Dock(TOP) l:SetContentAlignment(5)
                local bd = vgui.Create("DBinder", s)
                if input.LookupBinding(d.var) then bd:SetValue(input.GetKeyCode(input.LookupBinding(d.var))) end
                bd.OnChange = function(b, k)
                    if k and input.GetKeyName(k) then
                        local str = input.LookupKeyBinding(k)
                        if str then
                            str = string.Replace(str, d.var .. "; ", "")
                            str = string.Replace(str, d.var, "")
                            chat.AddText(Color(255, 255, 255), language.GetPhrase("arccw.bind.msg"), Color(255, 128, 0), "bind " .. input.GetKeyName(k) .. " \"" .. str .. "; " .. d.var .. "\"")
                        else
                            chat.AddText(Color(255, 255, 255), language.GetPhrase("arccw.bind.msg"), Color(255, 128, 0), "bind " .. input.GetKeyName(k) .. " " .. d.var .. "")
                        end
                    end
                end
                bd:Dock(TOP) p:AddItem(s) return s end
    }

    local concommands = {
        ["b"] = true,
        ["i"] = true,
        ["f"] = true,
        ["m"] = true,
        ["t"] = true,
    }

    for _, data in SortedPairs(table) do
        local p = AddControl[data.type](panel, data)

        if concommands[data.type] and data.sv then
            p.TickCreated = UnPredictedCurTime()
            if data.type == "b" then
                p.OnChange = function(self, bval)
                    ArcCW.NetworkConvar(data.var, bval, self)
                end
            elseif data.type == "i" or data.type == "f" or data.type == "m" or data.type == "t" then
                p.OnValueChanged = function(self, bval)
                    ArcCW.NetworkConvar(data.var, bval, self)
                end
            end
        end
    end
end

local CrosshairPresets = {
    ["#preset.default"] = {
        arccw_crosshair_length        = "4",
        arccw_crosshair_thickness     = "1",
        arccw_crosshair_gap           = "1",
        arccw_crosshair_dot           = "1",
        arccw_crosshair_shotgun       = "1",
        arccw_crosshair_equip         = "1",
        arccw_crosshair_static        = "0",
        arccw_crosshair_clump         = "0",
        arccw_crosshair_clump_outline = "0",
        arccw_crosshair_clump_always  = "0",
        arccw_crosshair_clr_r         = "255",
        arccw_crosshair_clr_g         = "255",
        arccw_crosshair_clr_b         = "255",
        arccw_crosshair_clr_a         = "255",
        arccw_crosshair_outline       = "2",
        arccw_crosshair_outline_r     = "0",
        arccw_crosshair_outline_g     = "0",
        arccw_crosshair_outline_b     = "0",
        arccw_crosshair_outline_a     = "255",
        arccw_scope_r                 = "255",
        arccw_scope_g                 = "0",
        arccw_scope_b                 = "0",
    },
    ["#arccw.crosshair.tfa"] = {
        arccw_crosshair_length        = "8",
        arccw_crosshair_thickness     = "0.4",
        arccw_crosshair_gap           = "1",
        arccw_crosshair_dot           = "0",
        arccw_crosshair_shotgun       = "0",
        arccw_crosshair_equip         = "0",
        arccw_crosshair_static        = "0",
        arccw_crosshair_clump         = "0",
        arccw_crosshair_clump_outline = "0",
        arccw_crosshair_clump_always  = "0",
        arccw_crosshair_clr_r         = "255",
        arccw_crosshair_clr_g         = "255",
        arccw_crosshair_clr_b         = "255",
        arccw_crosshair_clr_a         = "255",
        arccw_crosshair_outline       = "2",
        arccw_crosshair_outline_r     = "0",
        arccw_crosshair_outline_g     = "0",
        arccw_crosshair_outline_b     = "0",
        arccw_crosshair_outline_a     = "255",
        arccw_scope_r                 = "255",
        arccw_scope_g                 = "0",
        arccw_scope_b                 = "0",
    },
    ["#arccw.crosshair.cw2"] = {
        arccw_crosshair_length        = "3.5",
        arccw_crosshair_thickness     = "0.4",
        arccw_crosshair_gap           = "1",
        arccw_crosshair_dot           = "0",
        arccw_crosshair_shotgun       = "0",
        arccw_crosshair_equip         = "0",
        arccw_crosshair_static        = "0",
        arccw_crosshair_clump         = "1",
        arccw_crosshair_clump_outline = "1",
        arccw_crosshair_clump_always  = "0",
        arccw_crosshair_clr_r         = "255",
        arccw_crosshair_clr_g         = "255",
        arccw_crosshair_clr_b         = "255",
        arccw_crosshair_clr_a         = "200",
        arccw_crosshair_outline       = "2",
        arccw_crosshair_outline_r     = "0",
        arccw_crosshair_outline_g     = "0",
        arccw_crosshair_outline_b     = "0",
        arccw_crosshair_outline_a     = "200",
        arccw_scope_r                 = "255",
        arccw_scope_g                 = "0",
        arccw_scope_b                 = "0",
    },
    ["#arccw.crosshair.cs"] = {
        arccw_crosshair_length        = "3",
        arccw_crosshair_thickness     = "0.4",
        arccw_crosshair_gap           = "0.4",
        arccw_crosshair_dot           = "0",
        arccw_crosshair_shotgun       = "0",
        arccw_crosshair_equip         = "0",
        arccw_crosshair_static        = "1",
        arccw_crosshair_clump         = "0",
        arccw_crosshair_clump_outline = "0",
        arccw_crosshair_clump_always  = "0",
        arccw_crosshair_clr_r         = "0",
        arccw_crosshair_clr_g         = "255",
        arccw_crosshair_clr_b         = "0",
        arccw_crosshair_clr_a         = "255",
        arccw_crosshair_outline       = "0",
        arccw_crosshair_outline_r     = "0",
        arccw_crosshair_outline_g     = "0",
        arccw_crosshair_outline_b     = "0",
        arccw_crosshair_outline_a     = "0",
        arccw_scope_r                 = "255",
        arccw_scope_g                 = "0",
        arccw_scope_b                 = "0",
    },
    ["#arccw.crosshair.light"] = {
        arccw_crosshair_length        = "4",
        arccw_crosshair_thickness     = "0.8",
        arccw_crosshair_gap           = "1",
        arccw_crosshair_dot           = "0",
        arccw_crosshair_shotgun       = "1",
        arccw_crosshair_equip         = "1",
        arccw_crosshair_static        = "0",
        arccw_crosshair_clump         = "1",
        arccw_crosshair_clump_outline = "1",
        arccw_crosshair_clump_always  = "0",
        arccw_crosshair_clr_r         = "255",
        arccw_crosshair_clr_g         = "255",
        arccw_crosshair_clr_b         = "255",
        arccw_crosshair_clr_a         = "200",
        arccw_crosshair_outline       = "2",
        arccw_crosshair_outline_r     = "0",
        arccw_crosshair_outline_g     = "0",
        arccw_crosshair_outline_b     = "0",
        arccw_crosshair_outline_a     = "200",
        arccw_scope_r                 = "255",
        arccw_scope_g                 = "0",
        arccw_scope_b                 = "0",
    },
}

local ViewmodelPresets = {
    ["#preset.default"] = {
        arccw_vm_coolsway             = "1",
        arccw_vm_coolview             = "1",
        arccw_vm_right                = "0",
        arccw_vm_forward              = "0",
        arccw_vm_up                   = "0",
        arccw_vm_look_xmult            = "1",
        arccw_vm_look_ymult            = "1",
        arccw_vm_sway_xmult            = "1",
        arccw_vm_sway_ymult            = "1",
        arccw_vm_sway_zmult            = "1",
        arccw_vm_sway_speedmult        = "1",
        arccw_vm_coolview_mult        = "1",
    }
}

function ArcCW_Options_Bullet(panel)
    ArcCW.GeneratePanelElements(panel, BulletPanel)
end

function ArcCW_Options_Client(panel)
    ArcCW.GeneratePanelElements(panel, ClientPanel)
end

function ArcCW_Options_Perf(panel)
    ArcCW.GeneratePanelElements(panel, PerformancePanel)
end

function ArcCW_Options_Viewmodel(panel, no_preset)
    if !no_preset then
        panel:AddControl("ComboBox", {
            MenuButton = "1",
            Label      = "#Presets",
            Folder     = "arccw_vm",
            CVars      = { "" },
            Options    = ViewmodelPresets
        })
    end

    ArcCW.GeneratePanelElements(panel, ViewmodelPanel)
end

function ArcCW_Options_HUD(panel)
    ArcCW.GeneratePanelElements(panel, HudPanel)
end

function ArcCW_Options_Dev(panel)
    ArcCW.GeneratePanelElements(panel, DevPanel)
end

function ArcCW_Options_Crosshair(panel, no_preset)
    if !no_preset then
        panel:AddControl("ComboBox", {
            MenuButton = "1",
            Label      = "#Presets",
            Folder     = "arccw_crosshair",
            CVars      = { "" },
            Options    = CrosshairPresets
        })
    end
    ArcCW.GeneratePanelElements(panel, CrosshairPanel)
end

function ArcCW_Options_Server(panel)
    ArcCW.GeneratePanelElements(panel, ServerPanel)
end

function ArcCW_Options_Ammo(panel)
    ArcCW.GeneratePanelElements(panel, AmmoPanel)
end

function ArcCW_Options_Mults(panel, no_preset)
    if !no_preset then
        panel:AddControl("ComboBox", {
            MenuButton = "1",
            Label      = "#Presets",
            Folder     = "arccw_mults",
            CVars      = { "" },
            Options    = MultPresets
        })
    end
    ArcCW.GeneratePanelElements(panel, MultsPanel)
end

function ArcCW_Options_Atts(panel)
    ArcCW.GeneratePanelElements(panel, AttsPanel)
end

function ArcCW_Options_NPC(panel)
    ArcCW.GeneratePanelElements(panel, NPCsPanel)
end

function ArcCW_Options_Binds(panel)
    ArcCW.GeneratePanelElements(panel, BindsPanel)
end

function ArcCW_Options_Scopes(panel)
    ArcCW.GeneratePanelElements(panel, ScopesPanel)
end

function ArcCW_Options_Help(panel)
    ArcCW.GeneratePanelElements(panel, HelpPanel)
end

ArcCW.ClientMenus = {
    ["ArcCW_Options_Client"]    = { text = "#arccw.menus.client",    func = ArcCW_Options_Client,    tbl = ClientPanel },
    ["ArcCW_Options_Help"]      = { text = "Help & Troubleshooting", func = ArcCW_Options_Help,      tbl = HelpPanel },
    ["ArcCW_Options_Bullet"]    = { text = "#arccw.menus.bullet",    func = ArcCW_Options_Bullet,    tbl = BulletPanel },
    ["ArcCW_Options_Perf"]      = { text = "#arccw.menus.perf",      func = ArcCW_Options_Perf,      tbl = PerformancePanel },
    ["ArcCW_Options_Viewmodel"] = { text = "#arccw.menus.vmodel",    func = ArcCW_Options_Viewmodel, tbl = ViewmodelPanel },
    ["ArcCW_Options_HUD"]       = { text = "#arccw.menus.hud",       func = ArcCW_Options_HUD,       tbl = HudPanel },
    ["ArcCW_Options_Crosshair"] = { text = "#arccw.menus.xhair",     func = ArcCW_Options_Crosshair, tbl = CrosshairPanel },
    ["ArcCW_Options_Server"]    = { text = "#arccw.menus.server",    func = ArcCW_Options_Server,    tbl = ServerPanel },
    ["ArcCW_Options_Ammo"]      = { text = "#arccw.menus.ammo",      func = ArcCW_Options_Ammo,      tbl = AmmoPanel },
    ["ArcCW_Options_Atts"]      = { text = "#arccw.menus.atts",      func = ArcCW_Options_Atts,      tbl = AttsPanel },
    ["ArcCW_Options_Mults"]     = { text = "#arccw.menus.mults",     func = ArcCW_Options_Mults,     tbl = MultsPanel },
    ["ArcCW_Options_Dev"]       = { text = "#arccw.menus.dev",       func = ArcCW_Options_Dev,       tbl = DevPanel },
    ["ArcCW_Options_NPC"]       = { text = "#arccw.menus.npcs",      func = ArcCW_Options_NPC,       tbl = NPCsPanel },
    ["ArcCW_Options_Binds"]     = { text = "#arccw.menus.binds",     func = ArcCW_Options_Binds,     tbl = BindsPanel },
    ["ArcCW_Options_Scopes"]    = { text = "#arccw.menus.scopes",    func = ArcCW_Options_Scopes,    tbl = ScopesPanel },
}

hook.Add("PopulateToolMenu", "ArcCW_Options", function()
    for menu, data in pairs(ArcCW.ClientMenus) do
        spawnmenu.AddToolMenuOption("Options", "ArcCW", menu, data.text, "", "", data.func)
    end
end)

-- As of 2023-11-12, this feature is only available on dev branch.
-- Won't break anything on release branch though.
list.Set("ContentCategoryIcons", "ArcCW - Ammo", "arccw/icon_16.png")
list.Set("ContentCategoryIcons", "ArcCW - Attachments", "arccw/icon_16.png")

-- Give all categories with ArcCW weapons our icon unless one is already set
local first_populate = true
hook.Add("PopulateWeapons", "ArcCW_ContentCategoryIcons", function()
    if !first_populate then return end
    for i, wep in pairs(weapons.GetList()) do
        local weap = weapons.Get(wep.ClassName)
        if weap and weap.ArcCW then
            local cat = weap.Category
            if cat and !list.HasEntry("ContentCategoryIcons", cat) then
                list.Set("ContentCategoryIcons", cat, "arccw/icon_16.png")
            end
        end
    end
    first_populate = false
end)
--PATH lua/autorun/assasin_cgi.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )
	
end

AddPlayerModel( "Clone Assasin", 			      "models/artel/assasin_cgi/assasin_cgi.mdl" )




--PATH lua/autorun/aussi_cgicg_arms.lua:
list.Set( "PlayerOptionsModel", "Phase 2 CG Clone Trooper (CGI)", "models/aussiwozzi/cgi/base/CG_trooper.mdl" )
player_manager.AddValidModel( "Phase 2 CG Clone Trooper (CGI)", "models/aussiwozzi/cgi/base/CG_trooper.mdl" )
player_manager.AddValidHands( "Phase 2 CG Clone Trooper (CGI)", "models/aussiwozzi/cgi/base/CG_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 CG Medic (CGI)", "models/aussiwozzi/cgi/base/CG_medic.mdl" )
player_manager.AddValidModel( "Phase 2 CG Medic (CGI)", "models/aussiwozzi/cgi/base/CG_medic.mdl" )
player_manager.AddValidHands( "Phase 2 CG Medic (CGI)", "models/aussiwozzi/cgi/base/CG_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 CG Medic Officer (CGI)", "models/aussiwozzi/cgi/base/CG_medic_officer.mdl" )
player_manager.AddValidModel( "Phase 2 CG Medic Officer (CGI)", "models/aussiwozzi/cgi/base/CG_medic_officer.mdl" )
player_manager.AddValidHands( "Phase 2 CG Medic Officer (CGI)", "models/aussiwozzi/cgi/base/CG_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 CG Officer (CGI)", "models/aussiwozzi/cgi/base/CG_officer.mdl" )
player_manager.AddValidModel( "Phase 2 CG Officer (CGI)", "models/aussiwozzi/cgi/base/CG_officer.mdl" )
player_manager.AddValidHands( "Phase 2 CG Officer (CGI)", "models/aussiwozzi/cgi/base/CG_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 CG Commander Fox (CGI)", "models/aussiwozzi/cgi/base/cg_fox.mdl" )
player_manager.AddValidModel( "Phase 2 CG Commander Fox (CGI)", "models/aussiwozzi/cgi/base/cg_fox.mdl" )
player_manager.AddValidHands( "Phase 2 CG Commander Fox (CGI)", "models/aussiwozzi/cgi/base/CG_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 CG Commander Thorn (CGI)", "models/aussiwozzi/cgi/base/cg_thorn.mdl" )
player_manager.AddValidModel( "Phase 2 CG Commander Thorn (CGI)", "models/aussiwozzi/cgi/base/cg_thorn.mdl" )
player_manager.AddValidHands( "Phase 2 CG Commander Thorn (CGI)", "models/aussiwozzi/cgi/base/CG_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 CG Commander Stone (CGI)", "models/aussiwozzi/cgi/base/cg_stone.mdl" )
player_manager.AddValidModel( "Phase 2 CG Commander Stone (CGI)", "models/aussiwozzi/cgi/base/cg_stone.mdl" )
player_manager.AddValidHands( "Phase 2 CG Commander Stone (CGI)", "models/aussiwozzi/cgi/base/CG_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 CG Pilot (CGI)", "models/aussiwozzi/cgi/base/CG_pilot.mdl" )
player_manager.AddValidModel( "Phase 2 CG Pilot (CGI)", "models/aussiwozzi/cgi/base/CG_pilot.mdl" )
player_manager.AddValidHands( "Phase 2 CG Pilot (CGI)", "models/aussiwozzi/cgi/base/CG_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 CG Riot Trooper (CGI)", "models/aussiwozzi/cgi/base/cg_riot.mdl" )
player_manager.AddValidModel( "Phase 2 CG Riot Trooper (CGI)", "models/aussiwozzi/cgi/base/cg_riot.mdl" )
player_manager.AddValidHands( "Phase 2 CG Riot Trooper (CGI)", "models/aussiwozzi/cgi/base/CG_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 CG Rys (CGI)", "models/aussiwozzi/cgi/base/cg_rys.mdl" )
player_manager.AddValidModel( "Phase 2 CG Rys (CGI)", "models/aussiwozzi/cgi/base/cg_rys.mdl" )
player_manager.AddValidHands( "Phase 2 CG Rys (CGI)", "models/aussiwozzi/cgi/base/CG_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 CG Jek (CGI)", "models/aussiwozzi/cgi/base/cg_jek.mdl" )
player_manager.AddValidModel( "Phase 2 CG Jek (CGI)", "models/aussiwozzi/cgi/base/cg_jek.mdl" )
player_manager.AddValidHands( "Phase 2 CG Jek (CGI)", "models/aussiwozzi/cgi/base/CG_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 CG Hound (CGI)", "models/aussiwozzi/cgi/base/cg_hound.mdl" )
player_manager.AddValidModel( "Phase 2 CG Hound (CGI)", "models/aussiwozzi/cgi/base/cg_hound.mdl" )
player_manager.AddValidHands( "Phase 2 CG Hound (CGI)", "models/aussiwozzi/cgi/base/CG_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 CG ARF Trooper (CGI)", "models/aussiwozzi/cgi/base/CG_tracker.mdl" )
player_manager.AddValidModel( "Phase 2 CG ARF Trooper (CGI)", "models/aussiwozzi/cgi/base/CG_tracker.mdl" )
player_manager.AddValidHands( "Phase 2 CG ARF Trooper (CGI)", "models/aussiwozzi/cgi/base/CG_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 CG ARC Trooper (CGI)", "models/aussiwozzi/cgi/base/CG_arc.mdl" )
player_manager.AddValidModel( "Phase 2 CG ARC Trooper (CGI)", "models/aussiwozzi/cgi/base/CG_arc.mdl" )
player_manager.AddValidHands( "Phase 2 CG ARC Trooper (CGI)", "models/aussiwozzi/cgi/base/CG_arc_arms.mdl",0,"10000000" )

--PATH addons/[admin] awarn3/lua/autorun/awarn3.lua:
AddCSLuaFile()
--[[
      __          __              ____  
     /\ \        / /             |___ \ 
    /  \ \  /\  / /_ _ _ __ _ __   __) |
   / /\ \ \/  \/ / _` | '__| '_ \ |__ < 
  / ____ \  /\  / (_| | |  | | | |___) |
 /_/    \_\/  \/ \__,_|_|  |_| |_|____/ 

	AWarn3 by Mr.President
]]

MsgC( Color( 255,255,128 ), "\n      __          __              ", Color(0,255,0), "____  \n" )
MsgC( Color( 255,255,128 ), "     /\\ \\        / /             ", Color(0,255,0), "|___ \\ \n" )
MsgC( Color( 255,255,128 ), "    /  \\ \\  /\\  / /_ _ _ __ _ __   ", Color(0,255,0), "__) |\n" )
MsgC( Color( 255,255,128 ), "   / /\\ \\ \\/  \\/ / _` | '__| '_ \\ ", Color(0,255,0), "|__ < \n" )
MsgC( Color( 255,255,128 ), "  / ____ \\  /\\  / (_| | |  | | | |", Color(0,255,0), "___) |\n" )
MsgC( Color( 255,255,128 ), " /_/    \\_\\/  \\/ \\__,_|_|  |_| |_|", Color(0,255,0), "____/\n" )
MsgC( Color( 255,255,255 ), "\n" )
MsgC( Color( 255,0,0 ), "[AWarn3] ", Color( 255, 255, 255 ), "Welcome to AWarn3!\n" )


AWarn = AWarn or {}

AWarn.Version = "2.5.1"

AWARN3_WHITE 	= Color(255,255,255)
AWARN3_SERVER 	= Color(0,200,255)
AWARN3_CLIENT 	= Color(255,136,0)
AWARN3_WARNING	= Color(128,0,0)
AWARN3_CHATTAG	= Color(255,0,0)

if SERVER then
	AWARN3_STATECOLOR = AWARN3_SERVER
	include( "includes/sv_awarn3.lua")
end

if CLIENT then
	AWARN3_STATECOLOR = AWARN3_CLIENT
	include( "includes/cl_awarn3.lua")
end
--PATH addons/[admin] awarn3/lua/localizations/fr.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/localizations/ru.lua:
local language_code = "RU"

AWarn.Localization:RegisterLanguage( language_code, "Russian" )

//Credit: https://www.gmodstore.com/users/zek

AWarn.Localization:AddDefinition( language_code, "welcome1", 					"   AWarn3!" )
AWarn.Localization:AddDefinition( language_code, "insufficientperms", 			"     ." )
AWarn.Localization:AddDefinition( language_code, "insufficientperms2", 			"      ." )
AWarn.Localization:AddDefinition( language_code, "commandnonexist", 			"   ." )
AWarn.Localization:AddDefinition( language_code, "invalidtargetid", 			"   ID." )
AWarn.Localization:AddDefinition( language_code, "invalidtarget", 				" ." )
AWarn.Localization:AddDefinition( language_code, "reasonrequired", 				"  ." )
AWarn.Localization:AddDefinition( language_code, "remove1activewarn", 			"  1  " )
AWarn.Localization:AddDefinition( language_code, "deletedwarningid", 			"   ID" )
AWarn.Localization:AddDefinition( language_code, "removeallwarnings", 			"    " )
AWarn.Localization:AddDefinition( language_code, "deletedwarningsfor", 			"   " )
AWarn.Localization:AddDefinition( language_code, "cantopenconsole", 			"       ." )
AWarn.Localization:AddDefinition( language_code, "invalidoption", 				" ." )
AWarn.Localization:AddDefinition( language_code, "invalidoptionvaluetype",		"   ." )
AWarn.Localization:AddDefinition( language_code, "optionsloaded",				" !" )
AWarn.Localization:AddDefinition( language_code, "nopunishment",				"    ." )
AWarn.Localization:AddDefinition( language_code, "punishmentsloaded",			" !" )
AWarn.Localization:AddDefinition( language_code, "playernotallowedwarn",		"     ." )
AWarn.Localization:AddDefinition( language_code, "warnmessage1",				"   %s  %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage2",				"   %s  %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage3",				"%s    %s  %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage4",				"   %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage5",				"   %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage6",				"%s    %s." )
AWarn.Localization:AddDefinition( language_code, "joinmessage1",				"    ." )
AWarn.Localization:AddDefinition( language_code, "joinmessage2",				"   :" )
AWarn.Localization:AddDefinition( language_code, "joinmessage3",				"   ! ,      ." )
AWarn.Localization:AddDefinition( language_code, "joinmessage4",				"       , " )
AWarn.Localization:AddDefinition( language_code, "closemenu",					" " )
AWarn.Localization:AddDefinition( language_code, "searchplayers",				" " )
AWarn.Localization:AddDefinition( language_code, "viewwarnings",				" " )
AWarn.Localization:AddDefinition( language_code, "configuration",				"" )
AWarn.Localization:AddDefinition( language_code, "clientoptions",				" " )
AWarn.Localization:AddDefinition( language_code, "serveroptions",				" " )
AWarn.Localization:AddDefinition( language_code, "colorcustomization",			" " )
AWarn.Localization:AddDefinition( language_code, "colorselection",				" " )
AWarn.Localization:AddDefinition( language_code, "languageconfiguration",		" " )
AWarn.Localization:AddDefinition( language_code, "selectlanguage",				" " )
AWarn.Localization:AddDefinition( language_code, "enablekickpunish",			"    " )
AWarn.Localization:AddDefinition( language_code, "enablebanpunish",				"    " )
AWarn.Localization:AddDefinition( language_code, "enabledecay",					" -  " )
AWarn.Localization:AddDefinition( language_code, "resetafterban",				"   " )
AWarn.Localization:AddDefinition( language_code, "allowwarnadmins",				"  " )
AWarn.Localization:AddDefinition( language_code, "pressenter",					" Enter,   " )
AWarn.Localization:AddDefinition( language_code, "entertosave",					"Enter  " )
AWarn.Localization:AddDefinition( language_code, "chatprefix",					" " )
AWarn.Localization:AddDefinition( language_code, "warningdecayrate",			" - ()" )
AWarn.Localization:AddDefinition( language_code, "serverlanguage",				" " )
AWarn.Localization:AddDefinition( language_code, "punishmentsconfiguration",	" " )
AWarn.Localization:AddDefinition( language_code, "addpunishment",				" " )
AWarn.Localization:AddDefinition( language_code, "warnings",					"" )
AWarn.Localization:AddDefinition( language_code, "punishtype",					" " )
AWarn.Localization:AddDefinition( language_code, "punishlength",				" " )
AWarn.Localization:AddDefinition( language_code, "playermessage",				" " )
AWarn.Localization:AddDefinition( language_code, "playername",					" " )
AWarn.Localization:AddDefinition( language_code, "messagetoplayer",				" " )
AWarn.Localization:AddDefinition( language_code, "servermessage",				" " )
AWarn.Localization:AddDefinition( language_code, "messagetoserver",				"  " )
AWarn.Localization:AddDefinition( language_code, "deletewarning",				" " )
AWarn.Localization:AddDefinition( language_code, "punishaddmenu",				"  - " )
AWarn.Localization:AddDefinition( language_code, "inminutes",					" " )
AWarn.Localization:AddDefinition( language_code, "0equalperma",					"0 = " )
AWarn.Localization:AddDefinition( language_code, "use%",						" %s    " )
AWarn.Localization:AddDefinition( language_code, "setdefault",					" " )
AWarn.Localization:AddDefinition( language_code, "showingownwarnings",			"   " )
AWarn.Localization:AddDefinition( language_code, "warnedby",					" " )
AWarn.Localization:AddDefinition( language_code, "warningserver",				" " )
AWarn.Localization:AddDefinition( language_code, "warningreason",				" " )
AWarn.Localization:AddDefinition( language_code, "warningdate",					" " )
AWarn.Localization:AddDefinition( language_code, "nothing",						" " )
AWarn.Localization:AddDefinition( language_code, "submit",						"" )
AWarn.Localization:AddDefinition( language_code, "connectedplayers",			" " )
AWarn.Localization:AddDefinition( language_code, "displaywarningsfor",			"  " )
AWarn.Localization:AddDefinition( language_code, "activewarnings",				" " )
AWarn.Localization:AddDefinition( language_code, "selectedplayernowarnings",	"    " )
AWarn.Localization:AddDefinition( language_code, "selectplayerseewarnings",		" ,    ." )
AWarn.Localization:AddDefinition( language_code, "warnplayer",					" " )
AWarn.Localization:AddDefinition( language_code, "reduceactiveby1",				"    1" )
AWarn.Localization:AddDefinition( language_code, "playerwarningmenu",			"  " )
AWarn.Localization:AddDefinition( language_code, "playersearchmenu",			"  " )
AWarn.Localization:AddDefinition( language_code, "warningplayer",				" " )
AWarn.Localization:AddDefinition( language_code, "excludeplayers",				"   " )
AWarn.Localization:AddDefinition( language_code, "searchforplayers",			"     SteamID64" )
AWarn.Localization:AddDefinition( language_code, "name",						"" )
AWarn.Localization:AddDefinition( language_code, "lastplayed",					" " )
AWarn.Localization:AddDefinition( language_code, "lastwarned",					" " )
AWarn.Localization:AddDefinition( language_code, "never",						"" )
AWarn.Localization:AddDefinition( language_code, "playerid",					" ID" )
AWarn.Localization:AddDefinition( language_code, "lookupplayerwarnings",		"   " )
AWarn.Localization:AddDefinition( language_code, "servername",					" " )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessage",			"     " )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessage",			"  ,     " )
AWarn.Localization:AddDefinition( language_code, "punishmentoptions",			"" )
AWarn.Localization:AddDefinition( language_code, "kickpunishdescription",		" , AWarn3        ." )
AWarn.Localization:AddDefinition( language_code, "banpunishdescription",		" , AWarn3        ." )
AWarn.Localization:AddDefinition( language_code, "enabledecaydescription",		"   ,     ." )
AWarn.Localization:AddDefinition( language_code, "reasonrequireddescription",	"   ,      ." )
AWarn.Localization:AddDefinition( language_code, "resetafterbandescription",	"   ,       0  ,     AWarn3." )
AWarn.Localization:AddDefinition( language_code, "logevents",					"  ." )
AWarn.Localization:AddDefinition( language_code, "logeventsdescription",		"   ,   AWarn3     ." )
AWarn.Localization:AddDefinition( language_code, "allowwarnadminsdescription",	"   ,     ." )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessagedescription","   , ,    ,     ,     ." )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessagedescription",	"   ,     ,    ,    ." )
AWarn.Localization:AddDefinition( language_code, "chatprefixdescription",		" ,    AWarn3.  : !warn" )
AWarn.Localization:AddDefinition( language_code, "warningdecayratedescription",	" ( ),       ,  1   ." )
AWarn.Localization:AddDefinition( language_code, "servernamedescription",		"  .      ." )
AWarn.Localization:AddDefinition( language_code, "selectlanguagedescription",	" ,      ." )
AWarn.Localization:AddDefinition( language_code, "theme",						" " )
AWarn.Localization:AddDefinition( language_code, "themeselect",					" " )
AWarn.Localization:AddDefinition( language_code, "punishgroup",					" " )
AWarn.Localization:AddDefinition( language_code, "grouptoset",					"  " )
AWarn.Localization:AddDefinition( language_code, "viewnotes",					"  " )
AWarn.Localization:AddDefinition( language_code, "playernotes",					" " )
AWarn.Localization:AddDefinition( language_code, "interfacecustomizations",		" " )
AWarn.Localization:AddDefinition( language_code, "enableblur",					"  " )
AWarn.Localization:AddDefinition( language_code, "chooseapreset",				"  ()" )
AWarn.Localization:AddDefinition( language_code, "warningpresets",				"" )
AWarn.Localization:AddDefinition( language_code, "addeditpreset",				" /  " )
AWarn.Localization:AddDefinition( language_code, "presetname",					" " )
AWarn.Localization:AddDefinition( language_code, "presetreason",				" " )

--PATH addons/[admin] awarn3/lua/localizations/th.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/includes/awarn3_vgui.lua:
return gluapack()()
--PATH lua/autorun/blizz.lua:
return gluapack()()
--PATH addons/[misc] bodygroupr/lua/bodyman/bodyman_client.lua:
return gluapack()()
--PATH addons/[misc] bodygroupr/lua/bodyman/arizard_derma.lua:
local fontstandard = "Roboto"
print("Loaded arizard derma utilities for doorHandle")

-- collection of generic derma panels etc
-- a drop in solution for most of my addons, so that i can get nice UI up and running faster
-- yes, you have to ask me before using this stuff

surface.CreateFont("arizard_derma_Large", {
	font = fontstandard,
	size = 32,
	antialias = true,
	weight = 800
})
surface.CreateFont("arizard_derma_Medium", {
	font = fontstandard,
	size = 24,
	antialias = true,
	weight = 800
})

surface.CreateFont("arizard_derma_Small", {
	font = fontstandard,
	size = 20,
	antialias = true,
	weight = 800
})
surface.CreateFont("arizard_derma_Tiny", {
	font = fontstandard,
	size = 12,
	antialias = true,
	weight = 600
})

local hexvals = {
    ["0"] = 0,
    ["1"] = 1,
    ["2"] = 2,
    ["3"] = 3,
    ["4"] = 4,
    ["5"] = 5,
    ["6"] = 6,
    ["7"] = 7,
    ["8"] = 8,
    ["9"] = 9,
    ["A"] = 10,
    ["B"] = 11,
    ["C"] = 12,
    ["D"] = 13,
    ["E"] = 14,
    ["F"] = 15,
}



function Hex( hex ) -- utility functions

    hex = string.upper( hex )
    hex = string.Split( hex, "" )

    local num = 0

    for i = 1, #hex do
        local h = hex[i]
        local v = hexvals[h] or 15

        v = v * (16^(#hex-i))
        num = num + v
    end

    return num

end

local hexcache = {}

function HexColor(hex, alpha)

    if not hexcache[ hex ] then

        local temphex = hex

        if string.sub(hex, 1, 1) ~= "#" then return Color(255,255,255,255) end

        hex = string.Replace(hex, "#", "") -- remove #

        local ct = {}
        local len = string.len( hex )
        if len ~= 3 and len ~= 6 then return Color(255,255,255,255) end

        for i=1,3 do
            local l2 = len/3
            local m = 1
            ct[i] = Hex( string.sub(hex, l2*i -m, l2*i) )
        end
        --PrintTable(ct)
        local tempcol = Color( ct[1], ct[2], ct[3], 255)
        hexcache[ temphex ] = tempcol

        print("Created and cached hex color: "..temphex.." = "..tostring(ct[1]).." "..tostring(ct[2]).." "..tostring(ct[3]).." "..tostring(alpha or 255))

        tempcol.a = alpha or 255

        return tempcol
    else
        local col = hexcache[ hex ]
        col.a = alpha or 255
        return col
    end

end

local COLORS = {}
COLORS.Bad = HexColor("#e74c3c")
COLORS.BadDark = HexColor("#c0392b")
COLORS.Good = HexColor("#2ecc71")
COLORS.GoodDark = HexColor("#27ae60")
COLORS.NeutralHigh = HexColor("#ecf0f1")
COLORS.NeutralMed = HexColor("#bdc3c7")
COLORS.NeutralLow = HexColor("#95a5a6")
COLORS.NeutralDark = HexColor("#7f8c8d")
COLORS.Turq = HexColor("#e67e22")
COLORS.TurqDark = HexColor("#d35400")

function ArizardShadowText( text, font, x, y, col, ax, ay , d)
	draw.DrawText( text, font, x+d, y+d, Color(0,0,0,col.a), ax, ay )
	draw.DrawText( text, font, x, y, col, ax, ay)
end

local blur = Material("pp/blurscreen")
local function ArizardDrawBlur(panel, amount)

	local x, y = panel:LocalToScreen(0,0)
	local w, h = ScrW(), ScrH()

	surface.SetDrawColor(255,255,255)
	surface.SetMaterial(blur)

	for i = 1, 3 do -- 3 pass blur i guess?
		blur:SetFloat("$blur", (i/3) * (amount or 7))
		blur:Recompute()

		render.UpdateScreenEffectTexture()

		surface.DrawTexturedRect(x*-1,y*-1,w,h)
	end
end


local MAIN = {}

function MAIN:OnClose() end-- stub

function MAIN:Init()  
	
	self.bgalpha = 255
	self.bgcolor = COLORS.NeutralHigh
	self.fgcolor = COLORS.NeutralDark
	self.title = "Arizard Window"
   
	self.cb = vgui.Create("DButton", self)      
	function self.cb:DoClick()
		self:GetParent():OnClose()
		self:GetParent():Close()
	end
	function self.cb:PaintOver(w,h)
		draw.RoundedBox(4,0,0,w,h, COLORS.Bad)
		draw.DrawText("","arizard_derma_Medium",w/2,-3,COLORS.NeutralHigh, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end	

	self.inner = vgui.Create("DPanel", self)
	function self.inner:Paint() end

	self:SetSize(384,512+28+8)
	self:Center()
	self:MakePopup()
	self:ShowCloseButton( false )
	self.lblTitle:SetVisible(false)

	

end

function MAIN:PerformLayout()

	
	self.cb:SetSize(20,20)
	self.cb:SetPos(self:GetWide()-20-4, 4)

	self.inner:SetSize( self:GetWide(), self:GetTall() - 28 - 8 )
	self.inner:SetPos(0,28)


end

function MAIN:Paint(w,h)
	local inner = {x = 0,y = 28, w = self:GetWide(), h = self:GetTall() - 28 - 8}

	surface.SetDrawColor(255,255,255, 0)
	ArizardDrawBlur(self, 4)

	local bgcol = self:GetSecondaryColor()
	local fgcol = self:GetPrimaryColor()

	surface.SetDrawColor( bgcol )
	surface.DrawRect(inner.x, inner.y, inner.w, inner.h)

	surface.SetDrawColor( fgcol)
	draw.RoundedBox(4,0,0,w,16, fgcol)
	surface.DrawRect(0,8,w,20)

	draw.RoundedBox(4,0,h-8,w,8, fgcol)
	surface.DrawRect(0,h-8,w,4)

	--title
	ArizardShadowText( self.title ,"arizard_derma_Small",w/2,4,Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1)
end

function MAIN:SetPrimaryColor( col )
	self.fgcolor = table.Copy(col)
end

function MAIN:SetSecondaryColor( col )
	self.bgcolor = table.Copy(col)
end

function MAIN:GetPrimaryColor( )
	return self.fgcolor
end

function MAIN:GetSecondaryColor( )
	return self.bgcolor
end

function MAIN:SetTitle( str )
	self.title = str
end

vgui.Register("arizard_window", MAIN, "DFrame")

local BUTTN = {} -- custom buttons

function BUTTN:Init()
	self.w, self.h = 64,24
	
	self.color = {}
	self.color.up = Color(192, 57, 43)
	self.color.hover = Color(231, 76, 60)
	self.hover = false
	self.active = false

	self.font = "arizard_derma_Small"
	self.offsets = {0,-11}

	self.text = "Label"

	self.b = vgui.Create("DButton", self)

	self.b.OnCursorEntered = function()
		self.hover = true
	end

	self.b.OnCursorExited = function()
		self.hover = false
	end

	self.b.OnMousePressed = function( self2, mkey )

		self:OnMousePressed(mkey)
	end

	function self.b:Paint() end
	self.b:SetText("")
	self.disabled = false
end

function BUTTN:PerformLayout()
	self.b:SetSize(self:GetWide(),self:GetTall())
end
function BUTTN:Paint() end
function BUTTN:PaintOver(w,h)
	if self.hover == true or self.active == true then
		surface.SetDrawColor(self.color.hover)
		draw.RoundedBox(4,0,0,w,h, self.color.hover)
	elseif self.hover == false then
		surface.SetDrawColor(self.color.up)
		draw.RoundedBox(4,0,0,w,h, self.color.up)
	end
	

	ArizardShadowText(self.text,self.font,self:GetWide()/2 + self.offsets[1], self:GetTall()/2 +self.offsets[2], Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1)
end

function BUTTN:SetFont(fo)
	self.font = fo
end

function BUTTN:SetOffsets(x,y)
	self.offsets = {x,y}
end

function BUTTN:SetSelected( bool )

	self.active = bool

end

function BUTTN:SetText( text )

	self.text = text

end

function BUTTN:SetColors(upcol, hovercol)
	self.color.up = upcol
	self.color.hover = hovercol
end

function BUTTN:DoClick()

end

function BUTTN:DoRightClick()
end

function BUTTN:OnMousePressed( mkey )

	if not self.disabled then
		if mkey == MOUSE_LEFT then
			self:DoClick()
		end

		if mkey == MOUSE_RIGHT then
			self:DoRightClick()
		end
	end

end

function BUTTN:IsDown()

	if self.hover == true then
		if input.IsMouseDown( MOUSE_LEFT ) then
			return true
		end
	end

	return false
end

function BUTTN:SetDisabled( bool )
	self.disabled = bool
end


vgui.Register("arizard_button",BUTTN)


--hub multi panels

local MPANEL = {}

function MPANEL:Init()

	self.buttonoffset = 0

	self:SetSize(640,320)
	self.panels = {}
	self.buttons = {}
	self.tabs = {}

	self.color = {
		HexColor("#c0392b"),
		HexColor("#e74c3c")
	}

	self:PerformLayout()

	self.activetab = 0

	self.spacer = vgui.Create("DPanel",self)

	function self.spacer:Paint()
		surface.SetDrawColor(COLORS.NeutralLow)
		surface.DrawRect(0,0,self:GetWide(),self:GetTall())
	end
	self.spacer:SetPos(0,24)
	 -- Color(46, 204, 113)
	  -- Color(39, 174, 96)
	self.navleft = vgui.Create("arizard_button", self)
	self.navleft:SetColors( Color(39, 174, 96), Color(46, 204, 113))
	self.navleft:SetText( "<" )
	self.navleft:SetSize(24,24)

	function self.navleft:Think()
		if self:IsDown() then
			self:GetParent().buttonoffset = self:GetParent().buttonoffset + 2 * (FrameTime()/(1/100))
			self:GetParent():PerformLayout()
		end
	end

	self.navright = vgui.Create("arizard_button", self)
	self.navright:SetColors( Color(39, 174, 96), Color(46, 204, 113))
	self.navright:SetText( ">" )
	self.navright:SetSize(24,24)

	function self.navright:Think()
		if self:IsDown() then
			print("moving right")
			self:GetParent().buttonoffset = self:GetParent().buttonoffset - 2 * (FrameTime()/(1/100))
			self:GetParent():PerformLayout()
		end
	end

	self.navleft:SetZPos(99)
	self.navright:SetZPos(98)


	self.arrowsvisible = true
end

function MPANEL:ArrowsVisible( bool )

	self.navleft:SetVisible( bool )
	self.navright:SetVisible( bool )

end

function MPANEL:SetTab( idx )

	for i = 1, #self.tabs do
		
		self.buttons[self.tabs[i]]:SetSelected( false )
		self.panels[self.tabs[i]]:SetVisible( false )

	end

	self.buttons[self.tabs[idx]]:SetSelected( true )
	self.panels[self.tabs[idx]]:SetVisible( true )

end

function MPANEL:SetTabDisabled( idx, bool )

	self.buttons[self.tabs[idx]]:SetDisabled( bool )

end

function MPANEL:SetColors(c1, c2)
	self.color[1] = c1
	self.color[2] = c2

end

function MPANEL:AddTab(str_name)

	self.buttons[str_name] = vgui.Create("arizard_button", self)
	self.buttons[str_name]:SetSize(92,24)
	self.buttons[str_name]:SetText(str_name)
	self.buttons[str_name]:SetColors(COLORS.GoodDark, COLORS.Good)

	self.tabs[#self.tabs+1] = str_name

	self.activetab = #self.tabs
	self.buttons[str_name].idx = #self.tabs

	

	local temp = self.buttons[str_name]

	function temp:DoClick()
		local parent = self:GetParent()
		parent:SetTab( self.idx )
	end


	temp.PaintOver = function(self, w, h)
		if self.hover == true or self.active == true then
			surface.SetDrawColor(self.color.hover)
			draw.RoundedBox(4,0,0,self:GetWide(),12, self.color.hover)
		elseif self.hover == false then
			surface.SetDrawColor(self.color.up)
			draw.RoundedBox(4,0,0,self:GetWide(),12,self.color.up)
		end

		surface.DrawRect(0,8,self:GetWide(),self:GetTall()-8)

		ArizardShadowText(self.text,self.font,self:GetWide()/2 + self.offsets[1], self:GetTall()/2 +self.offsets[2], Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1)
	end

	self.panels[str_name] = vgui.Create("DPanel", self)
	self.panels[str_name]:SetSize(self:GetWide(),self:GetTall()-28)
	self.panels[str_name]:SetPos(0,28)
	self.panels[str_name]:SetVisible(false)

	self.panels[str_name].Paint = function(self, w, h)
		surface.SetDrawColor(Color(225,225,225))
		surface.DrawRect(0,0,w, h) -- meh
	end

	self:PerformLayout()

	self:SetTab( self.activetab )

	return self.panels[str_name]

end

function MPANEL:PerformLayout()

	
	local maxoff = -((#self.tabs * 92) - self:GetWide()) -24*2 -8
	if self.buttonoffset > 8 then self.buttonoffset = 8 end
	if self.buttonoffset < maxoff then self.buttonoffset = maxoff end

	if maxoff > 0 then self.buttonoffset = 8 end
	
	if self.navright then
		self.navright:SetPos(self:GetWide() - 24)
	end

	if self.spacer then
		self.spacer:SetSize(self:GetWide(), 4)
	end
	for i = 1,#self.tabs do
		self.buttons[self.tabs[i]]:SetPos(24+(i-1)*92+self.buttonoffset,0)
		self.buttons[self.tabs[i]].OriginalX = 8+(i-1)*92
		self.panels[self.tabs[i]]:SetSize(self:GetWide(),self:GetTall()-28)

	end

end
vgui.Register("arizard_multipanel", MPANEL)

concommand.Add("arizard_test_derma", function()
	vgui.Create("arizard_window")
end)
--PATH lua/autorun/civ_pm_male.lua:
return gluapack()()
--PATH lua/autorun/civ_pm_popculture.lua:
player_manager.AddValidModel( "Civilian Cyborg Male", "models/cyborg/pm_civ_cyborg_costume_male.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Cyborg Male", "models/cyborg/pm_civ_cyborg_costume_male.mdl" );
player_manager.AddValidModel( "Civilian Enforcer Male", "models/enforcer/pm_civ_enforcer_costume_male.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Enforcer Male", "models/enforcer/pm_civ_enforcer_costume_male.mdl" );
player_manager.AddValidModel( "Civilian Fighter Male", "models/fighter/pm_civ_fighter_costume_male.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Fighter Male", "models/fighter/pm_civ_fighter_costume_male.mdl" );
player_manager.AddValidModel( "Civilian Hitman Male", "models/hitman/pm_civ_hitman_costume_male.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Hitman Male", "models/hitman/pm_civ_hitman_costume_male.mdl" );
player_manager.AddValidModel( "Civilian Rebel Male", "models/rebel/pm_civ_rebel_costume_male.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Rebel Male", "models/rebel/pm_civ_rebel_costume_male.mdl" );
player_manager.AddValidModel( "Civilian Trackstar Male", "models/trackstar/pm_civ_trackstar_costume_male.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Trackstar Male", "models/trackstar/pm_civ_trackstar_costume_male.mdl" );

player_manager.AddValidModel( "Civilian Agent Female", "models/agent/pm_civ_agent_costume_female.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Agent Female", "models/agent/pm_civ_agent_costume_female.mdl" );
player_manager.AddValidModel( "Civilian Bride Female", "models/bride/pm_civ_bride_costume_female.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Bride Female", "models/bride/pm_civ_bride_costume_female.mdl" );
player_manager.AddValidModel( "Civilian Explorer Female", "models/explorer/pm_civ_explorer_costume_female.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Explorer Female", "models/explorer/pm_civ_explorer_costume_female.mdl" );
player_manager.AddValidModel( "Civilian Ranger Female", "models/ranger/pm_civ_ranger_costume_female.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Ranger Female", "models/ranger/pm_civ_ranger_costume_female.mdl" );
player_manager.AddValidModel( "Civilian Survivor Female", "models/survivor/pm_civ_survivor_costume_female.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Survivor Female", "models/survivor/pm_civ_survivor_costume_female.mdl" );
player_manager.AddValidModel( "Civilian Tester Female", "models/tester/pm_civ_tester_costume_female.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Tester Female", "models/tester/pm_civ_tester_costume_female.mdl" );
--PATH addons/[miecze] mexicano_drzewko/lua/autorun/cl_drzewo.lua:
return gluapack()()
--PATH lua/autorun/cl_falleffect.lua:
return gluapack()()
--PATH lua/autorun/craggy_addon.lua:
return gluapack()()
--PATH lua/autorun/cdraw.lua:
if SERVER then return end

CDRAW = CDRAW or {}

local circle_cache = {}

function CDRAW.DrawCircle(x,y,radius,seg)
	local segstr = x..y..radius..seg
	if circle_cache[segstr] then
		surface.DrawPoly(circle_cache[segstr])
	else
		local cir = {}
		cir[#cir+1] = {x=x,y=y,u=0.5,v=0.5}
		for i = 0, seg do
			local a = math.rad((i/seg)*-360)
			cir[#cir+1] = {x=x+math.sin(a)*radius,y=y+math.cos(a)*radius,u=math.sin(a)/2+0.5,v=math.cos(a)/2+0.5}
		end
		local a = math.rad(0)
		cir[#cir+1] = {x=x+math.sin(a)*radius,y=y+math.cos(a)*radius,u=math.sin(a)/2+0.5,v=math.cos(a)/2+0.5}
		circle_cache[segstr] = cir
		surface.DrawPoly(cir)
	end
end

function CDRAW.DrawRect(col,x,y,w,h)
	x, y = math.Round(x), math.Round(y)
	w, h = math.Round(w), math.Round(h)
	surface.SetDrawColor(col.r,col.g,col.b,col.a)
	surface.DrawRect(x,y,w,h)
end

function CDRAW.GetTextSize(...)
	local aye = {...}
	surface.SetFont(aye[1])
	local legx, legy = 0, 0
	for i = 2, #aye do
		if isstring(aye[i]) then
			local xd, yd = surface.GetTextSize(tostring(aye[i]))
			legx = legx + xd
			legy = legy > yd and legy or yd
		end
	end
	return legx, legy
end

function CDRAW.DrawText(...)
	local aye = {...}
	surface.SetFont(aye[1])
	aye[2], aye[3] = math.Round(aye[2]), math.Round(aye[3])
	local oldx, oldy = 0, 0
	for i = 4, #aye do
		if istable(aye[i]) then
			surface.SetTextColor(aye[i].r,aye[i].g,aye[i].b,aye[i].a)
		else
			surface.SetTextPos(aye[2]+oldx,aye[3])
			surface.DrawText(aye[i])
			local _ox, _oy = surface.GetTextSize(aye[i])
			oldx, oldy = oldx+_ox, oldy+_oy
		end
	end
end

function CDRAW.DrawNiceText(Col,Off,Font,Text)
	local sw, sh = CDRAW.GetTextSize(Font,Text)
	CDRAW.DrawText(Font..'_blur',-sw/2,-sh/2-Off,Col,Text)
	CDRAW.DrawText(Font,-sw/2,-sh/2-Off,Col,Text)
end

return CDRAW
--PATH addons/[opt] decals/lua/decals/util/cl_parse.lua:
return gluapack()()
--PATH addons/[opt] decals/lua/decals/util/cl_halo.lua:
local decalsHalo = CreateClientConVar( "decals_halo", 1, true, false )

Decals.Halo = Decals.Halo or {}

function Decals.Halo.Draw()
    local ent = LocalPlayer():GetEyeTrace().Entity

    if ent and ent:IsValid() and ent:GetClass() == "decal" and EyePos():DistToSqr( ent:GetPos() ) < 1000000 then
        halo.Add( { ent }, Decals.cfg.Color, 5, 5, 2 )
    end
end

function Decals.Halo.Callback( name, old, new )
    if !Decals.Authed( LocalPlayer() ) then
        new = "0"
    end

    local hookCall = hook[ tobool( new ) and "Add" or "Remove" ]

    hookCall( "PreDrawHalos", "Decals.Halo.Draw", Decals.Halo.Draw )
end
cvars.AddChangeCallback( "decals_halo", Decals.Halo.Callback )

function Decals.Halo.Initialize()
    Decals.Halo.Callback( nil, nil, decalsHalo:GetBool() )
end
hook.Add( "InitPostEntity", "Decals.Halo.Initialize", Decals.Halo.Initialize )

--PATH addons/[opt] decals/lua/decals/core/cl_core.lua:
function Decals.Update()
    local ent = net.ReadEntity()

    ent:SetDecal( Material "icon16/error.png" )
    ent:SetLoaded( false )
end
net.Receive( "Decals.Update", Decals.Update )

function Decals.Open( len, ent )
    if Decals.Menu then return end

    if !ent then
        ent = net.ReadEntity()
    end

	local pos
	
	cam.Start3D( EyePos(), LocalPlayer():EyeAngles() ) -- bad game = bad rendering = broken positioning
		pos = ent:GetPos():ToScreen()
	cam.End3D()

    local x = pos.x + pos.x / 4

    if x > ScrW() then
        x = x - pos.x / 2
    end

    local frame = vgui.Create "Decals.Menu"
    frame:SetSize( 320, 475 )
    frame:SetPos( x, 0 )
    frame:CenterVertical()
    frame:SetEnt( ent )
    frame:Setup()
    frame:MakePopup()

    Decals.Menu = frame
end
net.Receive( "Decals.Edit", Decals.Open )

function Decals.Render()
    for _, decal in ipairs( ents.FindByClass "decal" ) do
        decal:Render()
    end
end

function Decals.CheckRender()
    if GetConVar "decals_enabled" :GetBool() then
        hook.Add( "PostDrawTranslucentRenderables", "Decals.Render", Decals.Render )
    end
end
hook.Add( "InitPostEntity", "Decals.CheckRender", Decals.CheckRender )

function Decals.RenderCallback( name, old, new )
    local hookCall = hook[ tobool( new ) and "Add" or "Remove" ]

    hookCall( "PostDrawTranslucentRenderables", "Decals.Render", Decals.Render )
end
cvars.AddChangeCallback( "decals_enabled", Decals.RenderCallback )
--PATH addons/[opt] decals/lua/decals/vgui/draw.lua:
return gluapack()()
--PATH addons/[opt] decals/lua/decals/vgui/frame.lua:
return gluapack()()
--PATH addons/[opt] decals/lua/decals/vgui/button.lua:
return gluapack()()
--PATH addons/[opt] decals/lua/decals/menu/cl_menu.lua:
surface.CreateFont( "Decals.Header", { font = "Roboto", size = 18, weight = 800 } )

local PANEL = {}

AccessorFunc( PANEL, "Ent", "Ent" )

function PANEL:Init()
    self.sections = {}
    self.rgbCols = {
        Color( 255, 80, 80 ),
        Color( 80, 255, 80 ),
        Color( 80, 80, 255 ),
        Color( 160, 160, 160 )
    }

    self:SetTitle "Decals"
    self:SetEnt( nil )

    local oldClose = self.CloseButton.DoClick

    self.CloseButton.DoClick = function( s )
        local ent = self:GetEnt()

        ent:ResetEditing()
        ent:SetEditing( false )

        ent:SetLoaded( false )
        ent:Load()

        if Decals.Menu then
            Decals.Menu = nil
        end

        oldClose( s )
    end
end

function PANEL:AddSection( name, type )
    local header = vgui.Create( "DLabel", self )
    header:Dock( TOP )
    header:DockMargin( 0, 0, 0, 5 )
    header:SetContentAlignment( 2 )
    header:SetFont "Decals.Header"
    header:SetText( name )
    header:SizeToContents()

    local element = vgui.Create( type, self )
    element:Dock( TOP )
    element:DockMargin( 0, 0, 0, 10 )

    self.sections[ name ] = element

    return element, header
end

function PANEL:Setup()
    self:GetEnt():ResetEditing()
    self:GetEnt():SetEditing( true )

    local url = self:AddSection( "URL", "DTextEntry" )
    url:SetFont "Decals.Title"
    url:SetText( self:GetEnt():GetURL() )
    url:SetTall( 24 )
    url.Paint = function( s, w, h )
        Decals.Draw.Rect( 0, 0, w, h, Color( 25, 28, 32 ) )

        s:DrawTextEntryText( Color( 160, 160, 160 ), Color( 0, 178, 238 ), color_white )
    end
    url.OnEnter = function( s )
        local text = s:GetText()
        local imgur = Decals.Parse.Imgur( text )
        local ent = self:GetEnt()

        if imgur then
            text = imgur
        end

        ent:SetEditURL( text )
        ent:Load()
        ent:SetLoaded( false )
    end
    url.OnGetFocus = function( s )
        self:SetEdited( true )
    end
    url.OnLoseFocus = function( s )
        if s:GetText() != self:GetEnt():GetEditURL() then
            s:OnEnter()
        end
    end

    local col = self:AddSection( "Color", "DColorMixer" )
    col:SetColor( self:GetEnt():GetDecalColor():ToColor() )
    col.ValueChanged = function( s, col )
        local ent = self:GetEnt()

        ent:SetEditColor( Vector( col.r / 255, col.g / 255, col.b / 255 ) )
        ent:SetEditOpacity( col.a )

        self:SetEdited( true )
    end

    for _, child in ipairs( col:GetChild( 2 ):GetChildren() ) do
        child:SetFont "Decals.Title"

        child.Paint = function( s, w, h )
            Decals.Draw.Rect( 0, 0, w, h, Color( 25, 28, 32 ) )

            s:DrawTextEntryText( self.rgbCols[ _ ], Color( 0, 178, 238 ), color_white )
            local s = 76561198327810923
        end
    end

    local scale = self:AddSection( "Scale", "Panel" )
    scale:SetTall( 55 )

    local scaleX = vgui.Create( "Decals.Slider", scale )
    scaleX:Dock( TOP )
    scaleX:SetColor( Color( 25, 28, 32 ) )
    scaleX:SetSliderColor( Color( 160, 160, 160 ) )
    scaleX:SetDecimals( 0 )
    scaleX:SetMinMax( 100, 10000 )
    scaleX:SetValue( self:GetEnt():GetScale().x )
    scaleX.OnValueChanged = function( s, val )
        local vec = self:GetEnt():GetEditScale()
        vec.x = val

        self:GetEnt():SetEditScale( vec )

        self:SetEdited( true )
    end

    local scaleY = vgui.Create( "Decals.Slider", scale )
    scaleY:Dock( BOTTOM )
    scaleY:SetColor( Color( 25, 28, 32 ) )
    scaleY:SetSliderColor( Color( 160, 160, 160 ) )
    scaleY:SetDecimals( 0 )
    scaleY:SetMinMax( 100, 10000 )
    scaleY:SetValue( self:GetEnt():GetScale().y )
    scaleY.OnValueChanged = function( s, val )
        local vec = self:GetEnt():GetEditScale()
        vec.y = val

        self:GetEnt():SetEditScale( vec )

        self:SetEdited( true )
    end

    self.sections.Scale:DockMargin( 0, 0, 0, 5 )

    local save = vgui.Create( "Decals.Button", self )
    save:Dock( TOP )
    save:SetAlpha( 0 )
    save:SetTall( 32 )
    save:SetText "Save"
    save.DoClick = function( s )
        local text = url:GetText()
        local ent = self:GetEnt()

        Decals.Load.URL( text, function( status )
            if !Decals.Parse.Error( text ) then
                Decals.Chat( "# has an invalid file extension! File extension must be either jpg, jpeg or png.", text )

                return
            end

            net.Start "Decals.Update"
            net.WriteEntity( self:GetEnt() )
            net.WriteString( text )
            net.WriteTable( col:GetColor() )
            net.WriteUInt( scaleX:GetValue(), 14 )
            net.WriteUInt( scaleY:GetValue(), 14 )
            net.SendToServer()

            ent:ResetEditing()
            ent:SetEditing( false )

            ent:SetLoaded( false )
            ent:Load()

            self.CloseButton.DoClick()
        end )
    end
    save.OnCursorEntered = function( s )
        s:SetCursor( s:GetAlpha() > 100 and "hand" or "arrow" )
    end

    self.sections.Save = save
end

vgui.Register( "Decals.Menu", PANEL, "Decals.Frame" )

--PATH addons/!discordintegration/lua/discord_lang.lua:
return gluapack()()
--PATH addons/!discordintegration/lua/discord/core/classes/eventemitter.lua:
local EventEmitter = {}

function EventEmitter:Constructor()
    self._events = {}
    self._any = {}
end

function EventEmitter:on(Event, Callback, id)
    self._events[Event] = self._events[Event] or {}

    if id then
        local new = {}

        for _, data in ipairs(self._events[Event]) do
            if data.id and data.id == id then continue end
            table.insert(new, data)
        end

        self._events[Event] = new
    end

    table.insert(self._events[Event], {
        once = false,
        id = id,
        Callback = Callback,
    })
end

function EventEmitter:once(Event, Callback, id)
    self._events[Event] = self._events[Event] or {}

    if id then
        local new = {}
        
        for _, data in ipairs(self._events[Event]) do
            if data.id and data.id == id then continue end
            table.insert(new, data)
        end

        self._events[Event] = new
    end

    table.insert(self._events[Event], {
        once = true,
        id = id,
        Callback = Callback,
    })
end

function EventEmitter:any(Callback)
    table.insert(self._any, Callback)
end

function EventEmitter:emit(Event, ...)
    if not self._events[Event] and #self._any == 0 then return end

    for i, event in ipairs(self._events[Event] or {}) do
        event.Callback(...)

        if event.once then
            table.remove(self._events[Event], i)
        end
    end

    for i, callback in ipairs(self._any) do
        callback(Event, ...)
    end
end

function EventEmitter:destroy()
    self._events = {}
    self._any = {}
end

Discord.OOP:Register('EventEmitter', EventEmitter)
--PATH addons/!discordintegration/lua/discord/core/classes/cl_connector.lua:
local Connector = {}

function Connector:Init()
    self.frame = vgui.Create('DFrame')
    self.frame:SetSize(0, 0)

    self.html = vgui.Create('DHTML', frame)

    self.method = nil
    self.qs = nil
    self.ready = false
    self.connected = false
    self.queue = {}

    self.html.OnDocumentReady = function()
        timer.Simple(0, function()
            self.ready = true
            if self.connectLater then
                self:Connect()
                self.connectLater = nil
            end

            self:emit('ready')
        end)
    end

    self.html:AddFunction('gmod', 'setMethod', function(method)
        self.method = method
    end)

    self.html:AddFunction('gmod', 'open', function()
        self.connected = true

        while(#self.queue > 0) do
            self:Send(table.remove(self.queue, 1))
        end

        self:emit('open')
    end)

    self.html:AddFunction('gmod', 'message', function(data)
        self:emit('message', data)
    end)

    self.html:AddFunction('gmod', 'error', function(err)
        self:emit('error', err);
    end)

    self.html:AddFunction('gmod', 'close', function()
        self.connected = false
        self:emit('close')
    end)

    self.html:OpenURL(Discord.Backend.Connector_URL)
    self.html:SetAllowLua(true)
end

function Connector:Connect(key)
    if key then
        self.qs = '?access_token=' .. key .. '&type=client&sid64=' .. LocalPlayer():SteamID64()
    end

    if self.ready and self.qs then
        local url
        if self.method == 'ws' then
            url = Discord.Backend.WebSocket_URL .. self.qs
        elseif self.method == 'es' then
            url = Discord.Backend.EventSource_URL .. self.qs
        else
            self:emit('error', 'Unable to get a valid method to use for communication...?')
            return
        end

        self.html:Call('connect("' .. url .. '");')
    else
        self.connectLater = true
    end
end

function Connector:Send(payload)
    if self.connected and self.method == 'ws' then
        self.html:Call("send('" .. payload .. "');")
    elseif self.method == 'es' then
        HTTP({
            url = Discord.Backend.HTTP_URL .. 'api/v1/action' .. self.qs,
            method = 'POST',
            parameters = {
                payload = payload,
            },
            success = function(code, body, headers)
                if code < 200 or code >= 300 then
                    Discord:Log('Failed request through connector - HTTP '.. code .. ': ' .. body)
                end
            end,
            failed = function(err)
                Discord:Log('Failed request through connector with the error: ' .. err)
            end,
        })
    else
        table.insert(self.queue, data)
    end
end

function Connector:Disconnect()
    if not self.ready then return end

    self.html:Call('disconnect();');
end

function Connector:Destroy()
    self:destroy()
    
    if self.frame then
        self:Disconnect()
        self.frame:Close()
        self.frame = nil
    end
end

Discord.OOP:Register('Connector', Connector, 'EventEmitter')
--PATH addons/!discordintegration/lua/discord/core/util.lua:
return gluapack()()
--PATH addons/!discordintegration/lua/discord/core/api_op.lua:
Discord.OP = {
    PING = 1,
    PONG = 2,
    ERROR = 3,
    CONSOLE_MESSAGE = 4,
    CHAT_MESSAGE = 5,

    REGISTER_KEY = 6,
    UNREGISTER_KEY = 7,

    -- Relay
    MESSAGE = 8,
    RELAY_MESSAGE = 9,
    COMMAND = 10,
    SCREENSHOT = 11,

    -- Join Rewards
    JOIN_DISCORD = 12,

    -- Rank Sync
    LINK_ACCOUNT = 13,
    RANK_SYNC = 14,
    RANK_SYNC_NONCE = 15,
}
--PATH lua/autorun/engineer.lua:
player_manager.AddValidModel( "navy engineer", 		"models/navy/gnavyengineer.mdl" );
list.Set( "PlayerOptionsModel", "navy engineer", 	"models/navy/gnavyengineer.mdl" );
--PATH lua/autorun/engineer2.lua:
player_manager.AddValidModel( "navy engineer2", 		"models/navy/gnavyengineer2.mdl" );
list.Set( "PlayerOptionsModel", "navy engineer2", 	"models/navy/gnavyengineer2.mdl" );
--PATH lua/gmodadminsuite/modules/playerdatabase/lang/english.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/secondaryusergroups/lang/french.lua:
return gluapack()()
--PATH lua/gmodadminsuite/cl_country_codes.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/commands/sh_init.lua:
return gluapack()()
--PATH addons/[gas] gmodadminsuite-logging-2.4.8/lua/gmodadminsuite/modules/logging/sh_init.lua:
if (SERVER) then
	include("sv_backwards_compatibility.lua")

	GAS_Logging_ReadyCallbacks = {}
	function GAS_Logging_Init(callback)
		if (GAS and GAS.Logging and GAS.Logging.Loaded) then
			callback()
		else
			table.insert(GAS_Logging_ReadyCallbacks, callback)
		end
	end
	
	AddCSLuaFile("cl_menu.lua")
	AddCSLuaFile("cl_livelogs.lua")
	AddCSLuaFile("sh_log_formatting.lua")
	AddCSLuaFile("sh_scenes.lua")
end

GAS:hook("gmodadminsuite:LoadModule:logging", "LoadModule:jobwhitelist:logging", function(module_info)
	if (GAS.Logging and IsValid(GAS.Logging.Menu)) then
		GAS.Logging.Menu:Close()
	end

	GAS.Logging = {}

	GAS.Logging.FORMAT_PLAYER    = 0
	GAS.Logging.FORMAT_WEAPON    = 1
	GAS.Logging.FORMAT_ENTITY    = 2
	GAS.Logging.FORMAT_PROP      = 3
	GAS.Logging.FORMAT_RAGDOLL   = 4
	GAS.Logging.FORMAT_CURRENCY  = 5
	GAS.Logging.FORMAT_COUNTRY   = 6
	GAS.Logging.FORMAT_AMMO      = 7
	GAS.Logging.FORMAT_TEAM      = 8
	GAS.Logging.FORMAT_USERGROUP = 9
	GAS.Logging.FORMAT_STRING    = 10
	GAS.Logging.FORMAT_HIGHLIGHT = 11
	GAS.Logging.FORMAT_ROLE      = 12
	GAS.Logging.FORMAT_VEHICLE   = 13
	GAS.Logging.FORMAT_DAMAGE    = 14
	
	function GAS.Logging:ClassTypeNames(L) return {
		[GAS.Logging.FORMAT_PLAYER]    = L"class_type_player",
		[GAS.Logging.FORMAT_WEAPON]    = L"class_type_weapon",
		[GAS.Logging.FORMAT_ENTITY]    = L"class_type_entity",
		[GAS.Logging.FORMAT_PROP]      = L"class_type_prop",
		[GAS.Logging.FORMAT_RAGDOLL]   = L"class_type_ragdoll",
		[GAS.Logging.FORMAT_COUNTRY]   = L"class_type_country",
		[GAS.Logging.FORMAT_AMMO]      = L"class_type_ammo",
		[GAS.Logging.FORMAT_TEAM]      = L"class_type_team",
		[GAS.Logging.FORMAT_USERGROUP] = L"class_type_usergroup",
		[GAS.Logging.FORMAT_ROLE]      = L"class_type_role",
		[GAS.Logging.FORMAT_VEHICLE]   = L"class_type_vehicle",
		[GAS.Logging.FORMAT_DAMAGE]    = L"class_type_damage",
	} end

	GAS.Logging.PvP_LOG_TYPE_CHAT                = 0
	GAS.Logging.PvP_LOG_TYPE_CHAT_TEAM           = 1
	GAS.Logging.PvP_LOG_TYPE_WEAPON_PICKUP       = 2
	GAS.Logging.PvP_LOG_TYPE_WEAPON_DROPPED      = 3
	GAS.Logging.PvP_LOG_TYPE_ITEM_PICKUP         = 4
	GAS.Logging.PvP_LOG_TYPE_SPAWNMENU           = 5
	GAS.Logging.PvP_LOG_TYPE_DARKRP_PURCHASE     = 6
	GAS.Logging.PvP_LOG_TYPE_DISCONNECT          = 7
	GAS.Logging.PvP_LOG_TYPE_WEAPON_SWITCHED     = 8
	GAS.Logging.PvP_LOG_TYPE_TEAM_SWITCH         = 9
	GAS.Logging.PVP_LOG_TYPE_SILENT_DEATH        = 10
	GAS.Logging.PvP_LOG_TYPE_DEATH_WORLD         = 11
	GAS.Logging.PvP_LOG_TYPE_DEATH_PLAYER_WEP    = 12
	GAS.Logging.PvP_LOG_TYPE_DEATH_PLAYER        = 13
	GAS.Logging.PvP_LOG_TYPE_DEATH_ENT           = 14
	GAS.Logging.PvP_LOG_TYPE_DEATH               = 15
	GAS.Logging.PvP_LOG_TYPE_DEATH_PROPKILL_SELF = 16
	GAS.Logging.PvP_LOG_TYPE_DEATH_PROPKILL      = 17

	GAS.Logging.PvP_FLAG_FRIENDLYFIRE     = 0
	GAS.Logging.PvP_FLAG_LAWENFORCEMENT   = 1
	GAS.Logging.PvP_FLAG_LINKED           = 2
	GAS.Logging.PvP_FLAG_ADMIN            = 3
	GAS.Logging.PvP_FLAG_SUPERADMIN       = 4
	GAS.Logging.PvP_FLAG_VEHICLE          = 5
	GAS.Logging.PvP_FLAG_PROPS            = 6
	GAS.Logging.PvP_FLAG_DISCONNECT       = 7
	GAS.Logging.PvP_FLAG_WORLD            = 9
	GAS.Logging.PvP_FLAG_ONGOING          = 10
	GAS.Logging.PvP_FLAG_FINISHED         = 11
	GAS.Logging.PvP_FLAG_TEAM_SWITCHED    = 12
	GAS.Logging.PvP_FLAG_INSTIGATOR_DEATH = 13
	GAS.Logging.PvP_FLAG_VICTIM_DEATH     = 14

	GAS.Logging.PvP_EVENT_ID              = 1
	GAS.Logging.PvP_PRECISE_CREATION_TIME = 2
	GAS.Logging.PvP_LAST_UPDATED          = 3
	GAS.Logging.PvP_INSTIGATOR            = 4
	GAS.Logging.PvP_INSTIGATOR_WEPS       = 5
	GAS.Logging.PvP_INSTIGATOR_DMG_TKN    = 6
	GAS.Logging.PvP_INSTIGATOR_DMG_GVN    = 7
	GAS.Logging.PvP_INSTIGATOR_TEAM       = 8
	GAS.Logging.PvP_VICTIM                = 9
	GAS.Logging.PvP_VICTIM_WEPS           = 10
	GAS.Logging.PvP_VICTIM_DMG_TKN        = 11
	GAS.Logging.PvP_VICTIM_DMG_GVN        = 12
	GAS.Logging.PvP_VICTIM_TEAM           = 13
	GAS.Logging.PvP_TOTAL_DMG             = 14
	GAS.Logging.PvP_LINKED_EVENTS         = 15
	GAS.Logging.PvP_EVENT_LOGS            = 16
	GAS.Logging.PvP_EVENT_LOGS_CHRONOLOGY = 17
	GAS.Logging.PvP_WEP_VEHICLES          = 18
	GAS.Logging.PvP_FLAGS                 = 19
	GAS.Logging.PvP_ONGOING               = 20
	GAS.Logging.PvP_INSTIGATOR_NICK       = 21
	GAS.Logging.PvP_VICTIM_NICK           = 22
	GAS.Logging.PvP_COMBAT_SCENE          = 23
	GAS.Logging.PvP_CREATION_TIMESTAMP    = 24

	GAS.Logging.PvP_SCENE_MODEL              = 1
	GAS.Logging.PvP_SCENE_POS                = 2
	GAS.Logging.PvP_SCENE_ANG                = 3
	GAS.Logging.PvP_SCENE_PLY_COLOR          = 4
	GAS.Logging.PvP_SCENE_SHOOT_POS          = 5
	GAS.Logging.PvP_SCENE_EYE_POS            = 6
	GAS.Logging.PvP_SCENE_HEAD_ANG           = 7
	GAS.Logging.PvP_SCENE_WEAPON_MDL         = 8
	GAS.Logging.PvP_SCENE_WEAPON_CLASS       = 9
	GAS.Logging.PvP_SCENE_SEQUENCE           = 10
	GAS.Logging.PvP_SCENE_VEHICLE_MODEL      = 11
	GAS.Logging.PvP_SCENE_VEHICLE_POS        = 12
	GAS.Logging.PvP_SCENE_VEHICLE_ANG        = 13
	GAS.Logging.PvP_SCENE_VEHICLE_ATTACHMENT = 14

	GAS.Logging.PvP_DAMAGE_TYPES = {
		DMG_GENERIC,
		DMG_CRUSH,
		DMG_BULLET,
		DMG_SLASH,
		DMG_BURN,
		DMG_VEHICLE,
		DMG_FALL,
		DMG_BLAST,
		DMG_CLUB,
		DMG_SHOCK,
		DMG_SONIC,
		DMG_ENERGYBEAM,
		DMG_PREVENT_PHYSICS_FORCE,
		DMG_NEVERGIB,
		DMG_ALWAYSGIB,
		DMG_DROWN,
		DMG_PARALYZE,
		DMG_NERVEGAS,
		DMG_POISON,
		DMG_RADIATION,
		DMG_DROWNRECOVER,
		DMG_ACID,
		DMG_SLOWBURN,
		DMG_REMOVENORAGDOLL,
		DMG_PHYSGUN,
		DMG_PLASMA,
		DMG_AIRBOAT,
		DMG_DISSOLVE,
		DMG_BLAST_SURFACE,
		DMG_DIRECT,
		DMG_BUCKSHOT,
		DMG_SNIPER,
		DMG_MISSILEDEFENSE
	}

	GAS.Logging.ThirdPartyAddons = {
		["ULX Admin Mod"] = {installed = function()
			return ulx ~= nil
		end, website = "https://ulyssesmod.net"},

		["ServerGuard Admin Mod"] = {installed = function()
			return SERVERGUARD ~= nil
		end, gmodstore = "1847"},

		["AWarn"] = {installed = function()
			return AWarn ~= nil
		end, gmodstore = "629"},

		["Cuffs - Handcuffs and Restraints"] = {installed = function()
			return ConVarExists("cuffs_allowbreakout")
		end, gmodstore = "910"},

		["Medic / Armor NPC"] = {installed = function()
			return MavNPCModel ~= nil
		end, workshop = "912372779"},

		["PAC3"] = {installed = function()
			return pac ~= nil
		end, workshop = "104691717"},

		["Pointshop Trading System"] = {installed = function()
			return TRADING ~= nil
		end, gmodstore = "1672"},

		["Simple Party System"] = {installed = function()
			return party ~= nil
		end, gmodstore = "2109"},

		["SprayMesh"] = {installed = function()
			return SprayMesh ~= nil
		end, workshop = "394091909"},

		["Star Wars Vehicles"] = {installed = function()
			local SWVehicles = list.Get("SWVehicles")
			return SWVehicles and table.Count(SWVehicles) > 0
		end, workshop = "1311553933"},

		["WAC Aircraft"] = {installed = function()
			return wac ~= nil
		end, workshop = "104990330"},

		["Wyozi Cinema Kit"] = {installed = function()
			return wck ~= nil
		end, gmodstore = "1471"},

		["Wyozi DJ Kit"] = {installed = function()
			return wdj ~= nil
		end, gmodstore = "1534"},

		["bWhitelist"] = {installed = function()
			return GAS.JobWhitelist ~= nil
		end, gmodadminsuite = "jobwhitelist", gmodstore = "6017"},

		["bKeycardScanner"] = {installed = function()
			return bKeycardScanner ~= nil
		end, gmodstore = "3192"},
	}

	GAS.Logging.RolesEnabled = false
	function GAS.Logging:EnableRoles()
		GAS.Logging.RolesEnabled = true
	end

	if (SERVER) then
		include("gmodadminsuite/modules/logging/sv_logging.lua")
		include("gmodadminsuite/modules/logging/sv_logscanning.lua")

		GAS.XEON:PostLoad(function()
			XEON:Init("6016", "[GAS] Billy's Logs", "2.4", "gmodadminsuite/modules/logging/sv_drm.lua", include("gmodadminsuite/modules/logging/license.lua"))
		end)
	else
		include("gmodadminsuite/modules/logging/cl_menu.lua")
		include("gmodadminsuite/modules/logging/cl_livelogs.lua")
	end

	include("gmodadminsuite/modules/logging/sh_log_formatting.lua")
	include("gmodadminsuite/modules/logging/sh_scenes.lua")

	if (CLIENT) then
		local _,ds = file.Find("gmodadminsuite/modules/logging/modules/gamemodes/*", "LUA")
		for _,d in ipairs(ds) do
			if (file.Exists("gmodadminsuite/modules/logging/modules/gamemodes/" .. d .. "/_roles.lua", "LUA")) then
				include("gmodadminsuite/modules/logging/modules/gamemodes/" .. d .. "/_roles.lua")
			end
		end

		GAS:netReceive("logging:NetworkConfig", function()
			GAS.Logging.Config = {}
			GAS.Logging.Config.OverrideMoneyFormat = net.ReadBool()
			GAS.Logging.Config.MoneyFormat = net.ReadString()
			GAS.Logging.Config.Player_RecordTeam = net.ReadBool()
			GAS.Logging.Config.Player_RecordUsergroup = net.ReadBool()
			GAS.Logging.Config.Player_RecordHealth = net.ReadBool()
			GAS.Logging.Config.Player_RecordArmor = net.ReadBool()
			GAS.Logging.Config.Player_RecordWeapon = net.ReadBool()
			GAS.Logging.Config.Player_RecordRole = net.ReadBool()
			GAS.Logging.Config.DeepStorageEnabled = net.ReadBool()

			GAS.Logging.Config.Player_RecordWeapon_DoNotRecord = {}
			for i=1,net.ReadUInt(6) do
				GAS.Logging.Config.Player_RecordWeapon_DoNotRecord[net.ReadString()] = true
			end
		end)

		GAS:InitPostEntity(function()
			GAS:netStart("logging:NetworkConfig")
			net.SendToServer()
		end)
	end
end)
--PATH lua/gmodadminsuite/sh_permissions.lua:
return gluapack()()
--PATH lua/autorun/greyjedi_player.lua:
player_manager.AddValidModel( "Grey Jedi", "models/jedigrey/jedigrey.mdl" );
list.Set( "PlayerOptionsModel", "Grey Jedi", "models/jedigrey/jedigrey.mdl" );
--PATH lua/autorun/grunt_addon.lua:
player_manager.AddValidModel( "Pirate Grunt", "models/player/ohanak_gang/pm_pirate_grunt.mdl" );
list.Set( "PlayerOptionsModel",  "Pirate Grunt", "models/player/ohanak_gang/pm_pirate_grunt.mdl" );


--PATH lua/autorun/gwarm_addon.lua:
return gluapack()()
--PATH lua/imagetool/sh_batch.lua:
--[[
         AsterionStaff 2022.
        This script was created from the developers of the AsterionTeam.
        You can get more information from one of the links below:
            Site - https://asterion.games
            Discord - https://discord.gg/CtfS8r5W3M
        
        developer(s):
            Selenter - https://steamcommunity.com/id/selenter

         Chop your own wood and it will warm you twice.
]]--


ImageTool = ImageTool or {}
ImageTool._INFORMATION = ImageTool._INFORMATION or {
    _TITLE = "Image Tool",
    _DESCRIPTION = "This system allows you to create Pictures on your map.",
    _AUTHOR = "Selenter",
    _VERSION = 0.1
}

ImageTool.path = "imagetool" --    
ImageTool.prefix = "[ImageTool]" --     

ImageTool.cacheMaterials = ImageTool.cacheMaterials or {} --  
ImageTool.requestList = ImageTool.requestList or {} --    
ImageTool.notifyErr = ImageTool.notifyErr or {} --    
ImageTool.imageList = ImageTool.imageList or {} --      

ImageTool.config = "config.txt" --   
ImageTool.history = "history.txt" --   

--    
file.CreateDir(ImageTool.path)
file.CreateDir(ImageTool.path .. "/" .. game.GetMap())



--   
do
    if SERVER then
        AddCSLuaFile(ImageTool.path .. "/cl_net.lua")
        AddCSLuaFile(ImageTool.path .. "/cl_image.lua")
        AddCSLuaFile(ImageTool.path .. "/cl_hooks.lua")
    elseif CLIENT then
        include(ImageTool.path .. "/cl_net.lua")
        include(ImageTool.path .. "/cl_image.lua")
        include(ImageTool.path .. "/cl_hooks.lua")
    end

    include(ImageTool.path .. "/sh_image.lua")
    AddCSLuaFile(ImageTool.path .. "/sh_image.lua")

    if SERVER then
        include(ImageTool.path .. "/sv_net.lua")
        include(ImageTool.path .. "/sv_image.lua")
        include(ImageTool.path .. "/sv_hooks.lua")
    end
end
--PATH lua/imagetool/cl_hooks.lua:
--[[
         AsterionStaff 2022.
        This script was created from the developers of the AsterionTeam.
        You can get more information from one of the links below:
            Site - https://asterion.games
            Discord - https://discord.gg/CtfS8r5W3M
        
        developer(s):
            Selenter - https://steamcommunity.com/id/selenter

         Chop your own wood and it will warm you twice.
]]--


--     
ImageTool.dist = CreateClientConVar("imagetool_dist", 1000, true, nil, "Change distance of drawing pictures")

--   
hook.Add( "PopulateToolMenu", "ImageTool.Menu", function()
    local l = "imagetool_"

    spawnmenu.AddToolMenuOption("Options", "Image Tool", "imagetoolsettings", "Image Tool Settings", nil, nil, function(CPanel)
        CPanel:ClearControls()

        CPanel:AddControl("Header",{
            Description = "In this menu you can change the settings for the ImageTool."
        })

        CPanel:AddControl("Slider", {
            Label = "Draw distance:",
            Command = "imagetool_dist",
            Min = 0,
            Max = 10000
        })

        local SettingsReset = vgui.Create("DButton")
        SettingsReset:SetText("Return to default settings")
        SettingsReset.DoClick = function()
            RunConsoleCommand(l .. "dist", ImageTool.dist:GetDefault())
        end
        CPanel:AddPanel(SettingsReset)

        local HistoryReset = vgui.Create("DButton")
        HistoryReset:SetText("Clear the history")
        HistoryReset.DoClick = function()
            ImageTool:SaveHistory({})

            timer.Simple(0.5, function()
                RunConsoleCommand("spawnmenu_reload")
            end)

            LocalPlayer():ChatPrint(ImageTool.prefix .. " You have successfully cleared your history!")
        end
        CPanel:AddPanel(HistoryReset)

        local ImageReset = vgui.Create("DButton")
        ImageReset:SetText("Delete all pictures on the map")
        ImageReset.DoClick = function()
            RunConsoleCommand(l .. "delete_all")
        end
        CPanel:AddPanel(ImageReset)
    end)
end)

--   0.5     
local showImagesList = {}
local cache = {}
timer.Create("ImageTool:Update", 0.5, 0, function()
    local client = LocalPlayer()
    if !IsValid(client) then return end

    showImagesList = {}

    for id, array in pairs(ImageTool:GetImages()) do
        --       
        if client:GetPos():DistToSqr(array.position) >= ImageTool.dist:GetInt() * 15000 then
            cache[id] = nil
            continue
        end

        showImagesList[id] = array
    end
end)

--       
timer.Create("ImageTool:Cleaner", 1, 0, function()
    for id in pairs(cache) do
        if !showImagesList[id] then
            cache[id] = nil
        end
    end
end)

local function caching(id, array)
    cache[id] = array
end

local function thread()
	local showImages

	while true do
		showImages = showImagesList

		if !next(showImages) then
			coroutine.yield()
		else
			for id, array in pairs(showImages) do
				coroutine.yield()

				caching(id, array)
			end
		end
	end
end

--      
local co
hook.Add("Think", "ImageTool.Think", function()
    if !co or !coroutine.resume(co) then
		co = coroutine.create(thread)
		coroutine.resume(co)
	end
end)

--  
hook.Add("PostDrawTranslucentRenderables", "ImageTool.PostDrawTranslucentRenderables", function()
    --     
    for k, v in pairs(cache) do
        ImageTool:Start3D2D(v)
    end

    ImageTool:DrawImageTool() -- - 
end)
--PATH lua/imagetool/sh_image.lua:
--[[
         AsterionStaff 2022.
        This script was created from the developers of the AsterionTeam.
        You can get more information from one of the links below:
            Site - https://asterion.games
            Discord - https://discord.gg/CtfS8r5W3M
        
        developer(s):
            Selenter - https://steamcommunity.com/id/selenter

         Chop your own wood and it will warm you twice.
]]--

--    
ImageTool.ValidExtension = {
    realm = {
        ["png"] = true,
        ["jpg"] = true,
        ["jfif"] = true
    },
    content = {
        ["image/png"] = true,
        ["image/jpeg"] = true
    }
}

--    Image Tool
function ImageTool:IsUsesTool(client)
    if !IsValid(client) then return false end

    local weapon = client:GetActiveWeapon()
    if !IsValid(weapon) then return false end

    local class = weapon:GetClass()
    if class != "gmod_tool" then return false end

    local tool = client:GetTool() and client:GetTool().Name or nil
    if tool != "Image Tool" then return false end

    return true
end

--    Image Tool
function ImageTool:GetToolData(client)
    if !self:IsUsesTool(client) then return end

    local trace = client:GetEyeTrace()
    local position = trace.HitPos
    local angles = trace.HitNormal:Angle()
    angles:RotateAroundAxis(angles:Up(), 90)
    angles:RotateAroundAxis(angles:Forward(), 90)

    local tool = client:GetTool()

    local imageURL = tool:GetClientInfo("url")
    local imageWidth = tool:GetClientInfo("width")
    local imageHeight = tool:GetClientInfo("height")
    local imageScale = tool:GetClientInfo("scale")
    local imageBrightness = tool:GetClientInfo("brightness")
    local imageAlpha = tool:GetClientInfo("alpha")

    imageURL = imageURL:gsub("cdn.discordapp.com", "media.discordapp.net") -- Fix Discord Cloudfire

    local data = {
        url = imageURL,
        width = imageWidth,
        height = imageHeight,
        scale = imageScale,
        brightness = imageBrightness,
        position = position + angles:Up() * 0.5,
        angles = angles,
        alpha = imageAlpha
    }

    return data
end

--      
function ImageTool:CheckExtensionImage(body, header)
    local content = header["Content-Type"]
    local extension = self.ValidExtension

    local urlLowerPNG = string.lower(string.sub(body, 2, 4))
    local urlLowerJPEG = string.lower(string.sub(body, 7, 10))

    if extension.realm[urlLowerPNG] or extension.realm[urlLowerJPEG] or extension.content[content] then
        return true
    end

    return false
end

--     
function ImageTool:GetImages()
    return ImageTool.imageList or {}
end
--PATH lua/autorun/jawa02.lua:
player_manager.AddValidModel( "Jawa",		"models/jajoff/sw/jawa02.mdl" );
list.Set( "PlayerOptionsModel", "Jawa",		"models/jajoff/sw/jawa02.mdl" );
--PATH lua/autorun/jawamechanic.lua:
player_manager.AddValidModel( "Jawa Mechanic",		"models/jajoff/sw/jawamechanic.mdl" );
list.Set( "PlayerOptionsModel", "Jawa Mechanic",		"models/jajoff/sw/jawamechanic.mdl" );
--PATH lua/autorun/jiro_addon.lua:
player_manager.AddValidModel( "Pirate Jiro", "models/player/ohanak_gang/pm_pirate_jiro.mdl" );
list.Set( "PlayerOptionsModel",  "Pirate Jiro", "models/player/ohanak_gang/pm_pirate_jiro.mdl" );


--PATH lua/autorun/kalani.lua:
list.Set( "generalkalani", "models/helios/kalani15.mdl" )   // "models/helios/kalani15.mdl" )
player_manager.AddValidModel( "generalkalani", "models/helios/kalani15.mdl" )   // "models/helios/kalani15.mdl" )

--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/cl_hud.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/lscs_inventory.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/lscs_soundscripts.lua:
return gluapack()()
--PATH lua/lscs/combos/advanced_form1.lua:
return gluapack()()
--PATH lua/lscs/combos/advances_form5.lua:
return gluapack()()
--PATH lua/lscs/combos/basic_form1.lua:
COMBO.id = "form1a"
COMBO.PrintName = "Basic:Shii-Cho(I)"
COMBO.Author = "Storm"
COMBO.Description = "The Way of the Sarlac"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.BlockDistanceNormal = 65 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 20 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.MaxBlockPoints = 100 -- use this to make op boss saber stances. Avoid using this. Only uncomment if you really need it.
COMBO.BPDrainPerHit = 25

COMBO.DamageMultiplier = 1.10

COMBO.LeftSaberActive = false

COMBO.HoldType = "form1_holdtype"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "judge_h_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "judge_h_s3_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},

	["-45-"] = {
		AttackAnim = "shichoo_atk_ws_85s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .85,
	},
	["+45+"] = {
		AttackAnim = "shichoo_atk_ws_85s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .85,
	},
	["____"] = {
		AttackAnim = "shichoo_atk_ws_85s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .85,
	},
	["_A__"] = {
		AttackAnim = "shichoo_atk_pure_right_85s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .85,
	},
	["__S_"] = {
		AttackAnim = "shichoo_atk_back_85s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .85,
	},
	["___D"] = {
		AttackAnim = "shichoo_atk_pure_left_85s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .85,
	},
	["W___"] = {
		AttackAnim = "shichoo_atk_ws_85s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
	
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .85,
	},
	["WA__"] = {
		AttackAnim = "shichoo_atk_left_sweep_vid_85s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .85,
	},
	["W_S_"] = {
		AttackAnim = "shichoo_at_front_85s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .85,
	},
	["W__D"] = { 
		AttackAnim = "shichoo_atk_right_sweep_vid_85s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = .85,
	},
	["_AS_"] = {
		AttackAnim = "shichoo_atk_s_newest_l",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
	["__SD"] = {
		AttackAnim = "shichoo_atk_s_newest_r",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
}

--PATH lua/lscs/combos/basic_form4.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/butterfly.lua:
COMBO.id = "butterfly"
COMBO.PrintName = "Butterfly"
COMBO.Author = "Luna"
COMBO.Description = "Butterfly Stance. Not easy to control but hit's hard when used correctly. Works best with a Saber in both Hands."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = true

COMBO.HoldType = "lscs_butterfly"

COMBO.BPDrainPerHit = 35

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound(nil, 1)
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "pure_b_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound(1, 1)
			timer.Simple(0.1, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 1, 2 )
			end)
			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 2 )
			end)
			timer.Simple(0.5, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 1, 1 )
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 1, 2 )
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.9,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "ryoku_b_s2_t1",
		BeginAttack = function( weapon, ply )  
			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 2 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "ryoku_b_s2_t2",
		BeginAttack = function( weapon, ply )  
			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 2 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.7,
	},
	["____"] = {
		AttackAnim = "pure_b_s2_t3",
		BeginAttack = function( weapon, ply )  
			ply:lscsSetTimedMove( 1, CurTime(), 0.5, Vector(4500,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.5, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 1 )
			end)
			timer.Simple(0.5, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 2 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound(nil, 1)
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound(nil, 1)
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["W_S_"] = {
		AttackAnim = "pure_h_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound(1, 1)
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(400,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.4, 0.3, Vector(225,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.7, 0.6, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 2 )
			end)
			timer.Simple(0.5, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 1 )
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 2 )
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 1 )
			end)
			timer.Simple(1, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(nil, 1)
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	},
	["__S_"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound(nil, 1)
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "pure_b_right_t1",
		BeginAttack = function( weapon, ply )  
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(0,-150,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.4, 0.2, Vector(0,-80,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.6, 0.4, Vector(0,0,0) )

			weapon:DoAttackSound(1, 1)
			timer.Simple(0.1, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 1, 2 )
			end)
			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.65,
	},
	["___D"] = {
		AttackAnim = "pure_b_s2_t3",
		AttackAnimStart = 0.3,
		BeginAttack = function( weapon, ply )  
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(0,150,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.4, 0.2, Vector(0,80,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.6, 0.4, Vector(0,0,0) )

			weapon:DoAttackSound( math.random(1,2), 1 )

			timer.Simple(0.1, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( math.random(1,2), 2 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(nil, 1)
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.7,
	},
	["W__D"] = {
		AttackAnim = "pure_b_s2_t3",
		BeginAttack = function( weapon, ply )  
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(150,150,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.3, Vector(80,80,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 1, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( math.random(1,2), 1 )
			end)
			timer.Simple(0.5, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( math.random(1,2), 2 )
			end)
			timer.Simple(0.9, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1.25,
	},
	["WA__"] = {
		AttackAnim = "pure_b_right_t3",
		AttackAnimStart = 0.1,
		BeginAttack = function( weapon, ply )  
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(150,-150,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.3, Vector(80,-80,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 1, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( math.random(1,2), 1 )
			end)
			timer.Simple(0.5, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( math.random(1,2), 2 )
			end)
			timer.Simple(0.9, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1.25,
	},
	["__SD"] = {
		AttackAnim = "pure_b_s3_t2",
		AttackAnimStart = 0.2,
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound(2, 1)
			timer.Simple(0.35, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(math.random(1,2), 1)
			end)

			ply:lscsSetTimedMove( 1, CurTime(), 0.5, Vector(150,80,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.5, 0.5, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
	["_AS_"] = {
		AttackAnim = "pure_b_s2_t2",
		AttackAnimStart = 0.05,
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound(1, 1)
			timer.Simple(0.35, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(math.random(1,2), 1)
			end)
			ply:lscsSetTimedMove( 1, CurTime(), 0.5, Vector(150,-80,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.5, 0.5, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
	["W___"] = {
		AttackAnim = "phalanx_b_s4_t1",
		AttackAnimStart = 0,
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound(nil,1)
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.7,
	},
}
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/diplomat.lua:
COMBO.id = "niman"
COMBO.PrintName = "Niman(VI)"
COMBO.Author = "RareLogan"
COMBO.Description = ""

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "wos-meleeelegant-type"

COMBO.DamageMultiplier = 0.25
COMBO.BPDrainPerHit = 100

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "phalanx_h_s1_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.25, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "phalanx_r_s4_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "phalanx_r_s1_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["+45+"] = {
		AttackAnim = "wos_bs_shared_kick",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["__S_"] = {
		AttackAnim = "phalanx_r_s4_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "phalanx_r_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
			COMBO.DamageMultiplier = 1000
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["___D"] = {
		AttackAnim = "phalanx_r_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["W___"] = {
		AttackAnim = "phalanx_b_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
}
--PATH lua/lscs/combos/master_form3.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/shienso.lua:
COMBO.id = "shienso"
COMBO.PrintName = "Shien So(V)"
COMBO.Author = "RareLogan"
COMBO.Description = "Shien and Djem So was developed by practitioners of Form III who saw the need for a more offensive edge."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "wos-meleeheavier-type"

COMBO.DamageMultiplier = 1.50
COMBO.BPDrainPerHit = 75
COMBO.BlockDistanceNormal = 45 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 15 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "phalanx_h_s1_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.25, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "ryoku_r_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "b_c1_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_left_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["+45+"] = {
		AttackAnim = "wos_bs_shared_kick",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["W_S_"] = {
		AttackAnim = "vanguard_h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.7, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.6,
	},
	["__S_"] = {
		AttackAnim = "h_right_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "judge_h_left_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["___D"] = {
		AttackAnim = "judge_h_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["W__D"] = {
		AttackAnim = "phalanx_b_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["WA__"] = {
		AttackAnim = "phalanx_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["__SD"] = {
		AttackAnim = "b_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.7,
	},
	["_AS_"] = {
		AttackAnim = "b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.7,
	},
	["W___"] = {
		AttackAnim = "phalanx_h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
}
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/shiensodual.lua:
COMBO.id = "shiensodual"
COMBO.PrintName = "Shien So(V) {Dual Wield}"
COMBO.Author = "RareLogan"
COMBO.Description = ""

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = true

COMBO.HoldType = "wos-meleeheavier-type"

COMBO.DamageMultiplier = 1.50
COMBO.BPDrainPerHit = 75

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "phalanx_h_s1_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.25, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "ryoku_r_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "b_c1_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_left_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["+45+"] = {
		AttackAnim = "wos_bs_shared_kick",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["W_S_"] = {
		AttackAnim = "vanguard_h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.7, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.6,
	},
	["__S_"] = {
		AttackAnim = "h_right_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "judge_h_left_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["___D"] = {
		AttackAnim = "judge_h_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["W__D"] = {
		AttackAnim = "phalanx_b_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["WA__"] = {
		AttackAnim = "phalanx_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["__SD"] = {
		AttackAnim = "b_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.7,
	},
	["_AS_"] = {
		AttackAnim = "b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.7,
	},
	["W___"] = {
		AttackAnim = "phalanx_h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
}
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/suma.lua:
COMBO.id = "arrogant"
COMBO.PrintName = "Su Ma"
COMBO.Author = "Miller"
COMBO.Description = "Su ma was the use of rotation in the Jedi Knight's form of lightsaber combat. Lots of spins, lots of twirls."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "wos_arrogant_corvinus"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "ryoku_b_s1_charge",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 1.2,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "vanguard_a_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1.2,
	},
	["-45-"] = {
		AttackAnim = "vanguard_a_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.2,
	},
	["+45+"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["W_S_"] = {
		AttackAnim = "pure_r_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.2,
	},
	["__S_"] = {
		AttackAnim = "pure_r_left_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.2,
	},
	["_A__"] = {
		AttackAnim = "ryoku_r_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1.2,
	},
	["___D"] = {
		AttackAnim = "judge_r_s3_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1.2,
	},
	["W__D"] = {
		AttackAnim = "ryoku_a_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 1.2,
	},
	["WA__"] = {
		AttackAnim = "ryoku_a_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1.2,
	},
	["__SD"] = {
		AttackAnim = "ryoku_a_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1.2,
	},
	["_AS_"] = {
		AttackAnim = "ryoku_a_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1.2,
	},
	["W___"] = {
		AttackAnim = "ryoku_r_c1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.2,
	},
}

--PATH addons/[miecze] moce i hilty/lua/lscs/combos/untrained.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/versatile.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/blades_midnight.lua:
	
--[[
	v v v Blade v v v
]]
local blade = {}
blade.PrintName = "Demantoid"
blade.Author = "Midnight"
blade.id = "demantoid"
blade.color_blur = Color(6,97,76)
blade.color_core = Color(193,230,101)
blade.length = 45
blade.width = 0.9
blade.widthWiggle = 0.6
blade.material_core_tip = Material( "lscs/effects/solid/lightsaber_tip" )
blade.material_core = Material( "lscs/effects/solid/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/solid/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/solid/lightsaber_trail" )
blade.dynamic_light = true
blade.no_trail = false
blade.sounds = {
	Attack = "saber_hup",
	Attack1 = "saber_spin1",
	Attack2 = "saber_spin2",
	Attack3 = "saber_spin3",
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

-- modify previous blade, only change what we need to change

blade.PrintName = "Andesine"
blade.id = "andesine"
blade.color_blur = Color(215,52,69)
blade.color_core = Color(252,194,193)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

blade.PrintName = "Amethyst"
blade.id = "amethyst"
blade.color_blur = Color(129,0,191)
blade.color_core = Color(80,45,133)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

blade.PrintName = "Ametrine"
blade.id = "ametrine"
blade.color_blur = Color(254,220,119)
blade.color_core = Color(117,54,158)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

blade.PrintName = "Amber"
blade.id = "amber"
blade.color_blur = Color(255,193,2)
blade.color_core = Color(255,237,135)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

blade.PrintName = "Antimony"
blade.id = "antimony"
blade.color_blur = Color(166,116,139)
blade.color_core = Color(150,150,150)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

blade.PrintName = "Clinohumite"
blade.id = "clinohumite"
blade.color_blur = Color(249,189,37)
blade.color_core = Color(252,90,3)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Cherry Quartz"
blade.id = "cherryquartz"
blade.color_blur = Color(224,84,79)
blade.color_core = Color(163,0,18)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

blade.PrintName = "Cherry Quartz Dark Inner"
blade.id = "darkcherryquartz"
blade.color_blur = Color(224,84,79)
blade.color_core = Color(0,0,0)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle4"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Chert"
blade.id = "chert"
blade.color_blur = Color(60,28,5)
blade.color_core = Color(116,60,27)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

blade.PrintName = "Crocoite"
blade.id = "crocoite"
blade.color_blur = Color(219,156,17)
blade.color_core = Color(200,36,18)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle3"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Deep Blue"
blade.id = "deepblue"
blade.color_blur = Color(4,2,115)
blade.color_core = Color(4,2,115)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Grey"
blade.id = "grey"
blade.color_blur = Color(135,135,135)
blade.color_core = Color(50,50,50)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Hot Pink"
blade.id = "hotpink"
blade.color_blur = Color(254,104,179)
blade.color_core = Color(237,24,90)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle5"
LSCS:RegisterBlade( blade )

blade.PrintName = "Lemon Quartz"
blade.id = "lemonquartz"
blade.color_blur = Color(176,163,38)
blade.color_core = Color(225,216,155)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle5"
LSCS:RegisterBlade( blade )

blade.PrintName = "Malachite"
blade.id = "malachite"
blade.color_blur = Color(31,184,147)
blade.color_core = Color(44,87,83)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Metallic Green"
blade.id = "metallicgreen"
blade.color_blur = Color(0,72,61)
blade.color_core = Color(97,243,195)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Midnight Blue"
blade.id = "midnightblue"
blade.color_blur = Color(25,25,112)
blade.color_core = Color(25,25,112)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle2"
LSCS:RegisterBlade( blade )

blade.PrintName = "Morganite"
blade.id = "morganite"
blade.color_blur = Color(206,190,168)
blade.color_core = Color(197,128,121)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle2"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Old Rose"
blade.id = "oldrose"
blade.color_blur = Color(156,88,99)
blade.color_core = Color(176,146,151)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Padparadscha"
blade.id = "padparadscha"
blade.color_blur = Color(253,73,74)
blade.color_core = Color(253,158,76)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Pastel Green"
blade.id = "pastelgreen"
blade.color_blur = Color(119,221,119)
blade.color_core = Color(255,255,255)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Peridot"
blade.id = "bluelotus"
blade.color_blur = Color(101,139,2)
blade.color_core = Color(238,241,76)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Rhodonite"
blade.id = "rhodonite"
blade.color_blur = Color(191,111,121)
blade.color_core = Color(197,30,48)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Rose Gold"
blade.id = "rosegold"
blade.color_blur = Color(174,114,112)
blade.color_core = Color(254,249,237)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Rose Quartz"
blade.id = "rosequartz"
blade.color_blur = Color(216,117,148)
blade.color_core = Color(234,207,214)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Ruby"
blade.id = "ruby"
blade.color_blur = Color(50,1,5)
blade.color_core = Color(136,0,34)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

blade.PrintName = "Sardonyx"
blade.id = "sardonyx"
blade.color_blur = Color(247,186,25) -- (252,235,197)
blade.color_core = Color(252,235,197) -- (247,126,2)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

blade.PrintName = "Script Stone"
blade.id = "scripts"
blade.color_blur = Color(253,182,13)
blade.color_core = Color(80,33,31)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

blade.PrintName = "Coquina Jasper"
blade.id = "scripts2"
blade.color_blur = Color(80,33,31)
blade.color_core = Color(253,182,13)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Serpentine"
blade.id = "serpentine"
blade.color_blur = Color(41,48,32)
blade.color_core = Color(169,181,98)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

blade.PrintName = "Spessartine"
blade.id = "spessartine"
blade.color_blur = Color(255,182,12)
blade.color_core = Color(187,75,3)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Spinel"
blade.id = "spinel"
blade.color_blur = Color(138,2,42)
blade.color_core = Color(255,87,135)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Sugilite"
blade.id = "sugilite"
blade.color_blur = Color(146,42,135)
blade.color_core = Color(10,0,37)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

blade.PrintName = "Sulfur"
blade.id = "sulfur"
blade.color_blur = Color(245,234,181)
blade.color_core = Color(240,219,29)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Topaz"
blade.id = "topaz"
blade.color_blur = Color(211,78,14)
blade.color_core = Color(246,230,60)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Icon" -- This is a figment of your imagination, you're crazy you're insane.
blade.id = "icon"
blade.Spawnable = false
blade.color_blur = Color(0,0,0)
blade.color_core = Color(255,255,255)
blade.width = 0.9
blade.widthWiggle = 0
blade.sounds.Idle = "saber_idle1"
blade.material_core_tip = Material( "lscs/effects/white/lightsaber_tip" )
blade.material_core = Material( "lscs/effects/white/lightsaber_core" )
LSCS:RegisterBlade( blade )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_enlargeother.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_enlargeself.lua:
local force = {}
force.PrintName = "Enlarge Self"
force.Author = "Midnight"
force.Description = "Become big."
force.id = "Enlarge"

force.StartUse = function(ply)
    if ply:lscsGetForce() < 10 then return end -- Check if the player has enough Force points

    ply:lscsTakeForce(10) -- Deduct Force points required to use the power

    ply:SetModelScale(2, 1) -- Scale the player's model up lmao
    ply:EmitSound("npc/combine_gunship/ping_search.wav") -- Play sound effect
    LSCS:PlayVCDSequence(ply, "gesture_signal_halt", 0) -- Play animation

    -- Optional: Reset the player's scale after 10 seconds
    timer.Create("ResetModelScale_" .. ply:EntIndex(), 10, 1, function()
        if IsValid(ply) then
            ply:SetModelScale(1, 1) -- Reset to normal size
        end
    end)
end

force.StopUse = function(ply)
    -- Called when the force power key is released
    -- In this case, nothing is needed here
end

LSCS:RegisterForce(force)

--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_extinguish.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_heal.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_kneel.lua:
local force = {}

force.PrintName = "Kneel Down"
force.Author = "UCCROW"
force.Description = "Baktn mesafedeki tm oyuncular eilmeye zorlar."
force.id = "kneeldown" -- sadece kk harflerle

local lastForceUseTime = {}

local function ForcePressCtrl(targetPly, duration)
    if not targetPly:KeyDown(IN_DUCK) then
        targetPly:ConCommand("+duck")
    end

    timer.Simple(duration, function()
        targetPly:ConCommand("-duck")
    end)
end

force.StartUse = function(ply)
    local cooldown = 2 -- Cooldown sresi (saniye cinsinden)
    local pressCtrlDuration = 10 -- CTRL tuuna basma sresi (saniye cinsinden)
    local range = 300 -- Etki menzili (birim olarak)
    local targetPlys = ents.FindInSphere(ply:GetPos(), range)

    if lastForceUseTime[ply] and (CurTime() - lastForceUseTime[ply]) < cooldown then
        return
    end

    if ply:lscsGetForce() < 25 then
        return
    end

    ply:lscsTakeForce(25)

    ply:EmitSound("ambient/levels/labs/electric_explosion1.wav")

    for _, targetPly in ipairs(targetPlys) do
        if IsValid(targetPly) and targetPly:IsPlayer() and targetPly:Alive() and targetPly ~= ply then
            ForcePressCtrl(targetPly, pressCtrlDuration)
        end
    end

    lastForceUseTime[ply] = CurTime()
end

force.StopUse = function(ply)
    -- Force'un kullanm brakldnda yaplacaklar
end

LSCS:RegisterForce(force)

--PATH lua/lscs/content/force_push.lua:
local force = {}
force.PrintName = "Basic Push"
force.Author = "Blu-x92 / Luna"
force.Description = "Push things around"
force.id = "push"
force.StartUse = function( ply )
	if ply:lscsGetForce() < 20 then return end

	local Time = CurTime()

	local CanPush = (ply._lscsNextForce or 0) < Time

	if not CanPush then return end

	ply._lscsNextForce = Time + 1

	ply:EmitSound("lscs/force/push.mp3")
	ply:lscsTakeForce( 10 ) --Push gcnn tkettii force miktar

	local AimVector = ply:GetAimVector()
	local MyPos = ply:GetShootPos()

	LSCS:PlayVCDSequence( ply, "gesture_item_throw", 0.5 )

	local effectdata = EffectData()
		effectdata:SetOrigin( MyPos )
		effectdata:SetNormal( AimVector )
		effectdata:SetEntity( ply )
	util.Effect( "force_push", effectdata, true, true )

	for _, Ent in pairs( ents.FindInSphere( MyPos, 800 ) ) do
		local Sub = (Ent.GetShootPos and Ent:GetShootPos() or Ent:GetPos()) - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 30 then
			local Dist = Sub:Length()

			if IsValid( Ent ) and Dist < 800 then
				local Vel = Sub:GetNormalized() * 500 + Vector(0,0,50) -- +dan nceki say itilme mesafesini belirliyor. Vector iindeki saylardan sonuncusu dikey yn belirtir.

				LSCS:ForceApply( Ent, Vel, ply )
			end
		end
	end
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Advanced Push"
force.Author = "Storm"
force.Description = "Push things around"
force.id = "pushii"
force.StartUse = function( ply )
	if ply:lscsGetForce() < 15 then return end

	local Time = CurTime()

	local CanPush = (ply._lscsNextForce or 0) < Time

	if not CanPush then return end

	ply._lscsNextForce = Time + 1

	ply:EmitSound("lscs/force/push.mp3")
	ply:lscsTakeForce( 15 ) --Push gcnn tkettii force miktar

	local AimVector = ply:GetAimVector()
	local MyPos = ply:GetShootPos()

	LSCS:PlayVCDSequence( ply, "gesture_item_throw", 0.5 )

	local effectdata = EffectData()
		effectdata:SetOrigin( MyPos )
		effectdata:SetNormal( AimVector )
		effectdata:SetEntity( ply )
	util.Effect( "force_push", effectdata, true, true )

	for _, Ent in pairs( ents.FindInSphere( MyPos, 800 ) ) do
		local Sub = (Ent.GetShootPos and Ent:GetShootPos() or Ent:GetPos()) - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 30 then
			local Dist = Sub:Length()

			if IsValid( Ent ) and Dist < 800 then
				local Vel = Sub:GetNormalized() * 750 + Vector(0,0,100) -- +dan nceki say itilme mesafesini belirliyor. Vector iindeki saylardan sonuncusu dikey yn belirtir.

				LSCS:ForceApply( Ent, Vel, ply )
			end
		end
	end
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Master Push"
force.Author = "Storm"
force.Description = "Push things around"
force.id = "pushiii"
force.StartUse = function( ply )
	if ply:lscsGetForce() < 10 then return end

	local Time = CurTime()

	local CanPush = (ply._lscsNextForce or 0) < Time

	if not CanPush then return end

	ply._lscsNextForce = Time + 1

	ply:EmitSound("lscs/force/push.mp3")
	ply:lscsTakeForce( 10 ) --Push gcnn tkettii force miktar

	local AimVector = ply:GetAimVector()
	local MyPos = ply:GetShootPos()

	LSCS:PlayVCDSequence( ply, "gesture_item_throw", 0.5 )

	local effectdata = EffectData()
		effectdata:SetOrigin( MyPos )
		effectdata:SetNormal( AimVector )
		effectdata:SetEntity( ply )
	util.Effect( "force_push", effectdata, true, true )

	for _, Ent in pairs( ents.FindInSphere( MyPos, 800 ) ) do
		local Sub = (Ent.GetShootPos and Ent:GetShootPos() or Ent:GetPos()) - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 30 then
			local Dist = Sub:Length()

			if IsValid( Ent ) and Dist < 800 then
				local Vel = Sub:GetNormalized() * 2000 + Vector(0,0,150) -- +dan nceki say itilme mesafesini belirliyor. Vector iindeki saylardan sonuncusu dikey yn belirtir.

				LSCS:ForceApply( Ent, Vel, ply )
			end
		end
	end
end
LSCS:RegisterForce( force )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_repulse.lua:
local force = {}
force.PrintName = "Repulse"
force.Author = "Solace"
force.Description = "Push everything away from you"
force.id = "repulse"
force.StartUse = function( ply )
	if ply:lscsGetForce() < 20 then return end -- If you have less than 20 force, nothing happens

	local Time = CurTime()

	local CanPush = (ply._lscsNextForce or 0) < Time

	if not CanPush then return end

	ply._lscsNextForce = Time + 10
	
	RepulseCharge = 0 -- Defines a variable that shows up alot here. 
	
	function AddRepulseCharge() 
	
		if ply:lscsGetForce() < ( 20 ) then
			timer.Stop ( "ChargeTimer" ) -- Stops the loop if there isn't enough force left to fund it 
		return end
		
		if not ( timer.Exists( "ChargeTimer" ) ) then return end -- Checks to see if the timer exists 
		
		RepulseCharge = RepulseCharge + 1 -- Adds 1 to our charge variable
		
		ply:SetNWInt( "_RepulseCharge", RepulseCharge) -- makes the charge variable a network integer so it can be called across different scripts and between the server and client
		
		ply:EmitSound("lscs/force/repulse_charge.mp3", 100, 75 + ( RepulseCharge * 5 ) ) -- Emits the charging sound, changes the pitch as the charge variable increases
		
		local AimVector = ply:GetAimVector()
		local MyPos = ply:GetShootPos()
		
		timer.Simple( 0.5, function() -- a delay so that the take force and effect are ran in sync with the sound effect 
		ply:lscsTakeForce( 20 )
		local effectdata = EffectData()
			effectdata:SetOrigin( MyPos )
			effectdata:SetEntity( ply )
		util.Effect( "repulse_charge", effectdata, true, true ) end )
	end
	
	timer.Create( "ChargeTimer", 1, 0, AddRepulseCharge ) -- Actually creates the timer the entire previous function runs on
end
force.StopUse = function( ply )

	if RepulseCharge < 1 then return end -- If no charge has been built up, there's nothing to release.
	
	ply:EmitSound("lscs/force/push.mp3")

	local AimVector = ply:GetAimVector()
	local MyPos = ply:GetShootPos()

	LSCS:PlayVCDSequence( ply, "gesture_item_throw", 0.5 )

	local effectdata = EffectData()
		effectdata:SetOrigin( MyPos )
		effectdata:SetEntity( ply )
	util.Effect( "repulse", effectdata, true, true )
-- VVV Applies a pushing force to everything within a sphere that grows depending on how much charge has been built up VVV
	for _, Ent in pairs( ents.FindInSphere( MyPos, 100 * RepulseCharge ) ) do 
		local Sub = (Ent.GetShootPos and Ent:GetShootPos() or Ent:GetPos()) - MyPos
		local ToTarget = Sub:GetNormalized()

		local Dist = Sub:Length()

		if IsValid( Ent ) and Dist < ( 100 * RepulseCharge ) then -- How far away something can be and still be pushed
			local Vel = Sub:GetNormalized() * 400 * RepulseCharge + Vector(0,0,50) -- How hard and what direction things are pushed 

			LSCS:ForceApply( Ent, Vel, ply )
		end
	end
	
	timer.Stop ( "ChargeTimer" ) -- Stops the charge timer
	RepulseCharge = 0 -- Resets the charge variable
	timer.Simple( 1, function() ply:SetNWInt( "_RepulseCharge", RepulseCharge) end) -- Delays resetting the network integer so the effects work correctly
end
LSCS:RegisterForce( force )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_rock_throw.lua:
local force = {}
force.PrintName = "Telekinetic Assault"
force.Author = "Solace"
force.Description = "Throw a chunk of earth"
force.id = "sfrockthrow"
force.OnClk =  function( ply, TIME )
	if ply.HoldingRock then
		ply:lscsTakeForce()
	end
end
force.StartUse = function( ply )
	local Time = CurTime()
	
	ply._rock = nil
	ply._rockphys = nil
	ply.HoldingRock = false
	
	local CanThrow = (ply._lscsNextForce or 0) < Time
	if not CanThrow then return end
	
	if ply:lscsGetForce() < 40 then return end
	
	ply._lscsNextForce = Time + 3
	ply.HoldingRock = true

	ply:lscsTakeForce( 50 )
	ply:EmitSound("physics/concrete/boulder_impact_hard4.wav")
	LSCS:PlayVCDSequence( ply, "gesture_becon", 0.8 )
	
	ply._rock = ents.Create ("sf_rock")
	
	local v = ply:GetPos()
	v = v + ply:GetForward() * 50
	v = v + ply:GetRight() * 50
	v = v + ply:GetUp() * 20
	ply._rock:SetPos( v )
	
	ply._rock:SetAngles(Angle(math.Rand(0,180), math.Rand(0,180), math.Rand(0,180)))
	ply._rock:SetOwner(ply)
	ply._rock:Spawn()
	
	ply._rockphys = ply._rock:GetPhysicsObject()
	ply._rockphys:SetVelocity(Vector(0,0,500))
	
	timer.Simple(0.1, function() ply._rock:SetPos( v + Vector(0,0,60) ) end)
	
end
force.StopUse = function( ply )
	if ply._rock then
		ply:EmitSound("lscs/force/push.mp3")
		ply.HoldingRock = false
		ply._rock.DieTime = CurTime() + 5
		ply._rock.IsThrown = true
		local TargetPos = ply:GetEyeTrace().HitPos
		local Sub = (TargetPos-ply._rock:GetPos()):GetNormalized()
		ply._rockphys:SetVelocity((Sub * 2500) + Vector(0,0,200))
		ply._rockphys:EnableGravity( true )
		ply._rockphys:EnableDrag( true )
	end
end
LSCS:RegisterForce( force )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_ihatemylife.lua:
local hilt = {}
hilt.PrintName = "Vader Hilt"
hilt.Author = "Rubat"
hilt.id = "vaderhilt"
hilt.mdl = "models/sgg/starwars/weapons/w_vader_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Vader Hilt{Reverse}"
hilt.Author = "Rubat"
hilt.id = "vaderhiltr"
hilt.mdl = "models/sgg/starwars/weapons/w_vader_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 6.5),
            ang = Angle(90, 90, 90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Obi Wan EP 1 Hilt"
hilt.Author = "Rubat"
hilt.id = "obi1"
hilt.mdl = "models/sgg/starwars/weapons/w_obiwan_ep1_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Obi Wan EP 1 Hilt{Reverse}"
hilt.Author = "Rubat"
hilt.id = "obi1r"
hilt.mdl = "models/sgg/starwars/weapons/w_obiwan_ep1_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 6.5),
            ang = Angle(90, 90, 90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Anakin EP 2 Hilt"
hilt.Author = "Rubat"
hilt.id = "ani1"
hilt.mdl = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )


local hilt = {}
hilt.PrintName = "Mauls Broken Hilt"
hilt.Author = "Rubat"
hilt.id = "maulb"
hilt.mdl = "models/sgg/starwars/weapons/w_maul_saber_half_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Mauls Broken Hilt Reverse"
hilt.Author = "Rubat"
hilt.id = "maulbr"
hilt.mdl = "models/sgg/starwars/weapons/w_maul_saber_half_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 6.5),
            ang = Angle(90, 90, 90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Anakin EP 2 Hilt Reverse"
hilt.Author = "Rubat"
hilt.id = "ani1r"
hilt.mdl = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 6.5),
            ang = Angle(90, 90, 90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Anakin EP 3 Hilt"
hilt.Author = "Rubat"
hilt.id = "ani2"
hilt.mdl = "models/sgg/starwars/weapons/w_anakin_ep3_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Anakin EP 3 Hilt Reverse"
hilt.Author = "Rubat"
hilt.id = "ani2r"
hilt.mdl = "models/sgg/starwars/weapons/w_anakin_ep3_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 6.5),
            ang = Angle(90, 90, 90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Lukes Hilt"
hilt.Author = "Rubat"
hilt.id = "luke"
hilt.mdl = "models/sgg/starwars/weapons/w_luke_ep6_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Lukes Hilt Reverse"
hilt.Author = "Rubat"
hilt.id = "luker"
hilt.mdl = "models/sgg/starwars/weapons/w_luke_ep6_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 6.5),
            ang = Angle(90, 90, 90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Common Jedi Saber Hilt"
hilt.Author = "Rubat"
hilt.id = "common"
hilt.mdl = "models/sgg/starwars/weapons/w_common_jedi_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Common Jedi Saber Hilt Reverse"
hilt.Author = "Rubat"
hilt.id = "commonr"
hilt.mdl = "models/sgg/starwars/weapons/w_common_jedi_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 6.5),
            ang = Angle(90, 90, 90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Mace Windu Hilt"
hilt.Author = "Rubat"
hilt.id = "mace"
hilt.mdl = "models/sgg/starwars/weapons/w_mace_windu_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Mace Windu Hilt Reverse"
hilt.Author = "Rubat"
hilt.id = "macer"
hilt.mdl = "models/sgg/starwars/weapons/w_mace_windu_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 6.5),
            ang = Angle(90, 90, 90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Obi Wan EP 3 Hilt"
hilt.Author = "Rubat"
hilt.id = "obi2"
hilt.mdl = "models/sgg/starwars/weapons/w_obiwan_ep3_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Obi Wan EP 3 Hilt Reverse"
hilt.Author = "Rubat"
hilt.id = "obi2r"
hilt.mdl = "models/sgg/starwars/weapons/w_obiwan_ep3_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 6.5),
            ang = Angle(90, 90, 90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Qui Gon Jins Hilt"
hilt.Author = "Rubat"
hilt.id = "qui"
hilt.mdl = "models/sgg/starwars/weapons/w_quigon_gin_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Qui Gon Jins Hilt Reverse"
hilt.Author = "Rubat"
hilt.id = "quir"
hilt.mdl = "models/sgg/starwars/weapons/w_quigon_gin_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 6.5),
            ang = Angle(90, 90, 90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Darth Sidious's Hilt"
hilt.Author = "Rubat"
hilt.id = "sidious"
hilt.mdl = "models/sgg/starwars/weapons/w_sidious_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Darth Sidious's Hilt Reverse"
hilt.Author = "Rubat"
hilt.id = "sidiousr"
hilt.mdl = "models/sgg/starwars/weapons/w_sidious_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 6.5),
            ang = Angle(90, 90, 90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Yoda's Hilt"
hilt.Author = "Rubat"
hilt.id = "yoda"
hilt.mdl = "models/sgg/starwars/weapons/w_yoda_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -2, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Yoda's Hilt Reverse"
hilt.Author = "Rubat"
hilt.id = "yodar"
hilt.mdl = "models/sgg/starwars/weapons/w_yoda_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 5),
            ang = Angle(90, 90, 90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -2.5, -5),
            ang = Angle(-90, -90, -90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Dooku Hilt"
hilt.Author = "Rubat"
hilt.id = "dooku"
hilt.mdl = "models/weapons/starwars/w_dooku_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Maul Staff Hilt"
hilt.Author = "Rubat"
hilt.id = "maulstaff"
hilt.mdl = "models/weapons/starwars/w_maul_saber_staff_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Kylo Hilt"
hilt.Author = "Rubat"
hilt.id = "kylo"
hilt.mdl = "models/weapons/starwars/w_kr_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -2),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 2),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Kylo Hilt Reverse"
hilt.Author = "Rubat"
hilt.id = "kylor"
hilt.mdl = "models/weapons/starwars/w_kr_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3, -1.5, 0),
            ang = Angle(90, 90, 90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(-90, -90, -90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Tempted Apprentice"
hilt.Author = "ArsenicBeast"
hilt.id = "swtor1"
hilt.mdl = "models/swtor/arsenic/lightsabers/temptedapprentice'slightsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-1,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Rishi"
hilt.Author = "ArsenicBeast"
hilt.id = "swtor2"
hilt.mdl = "models/swtor/arsenic/lightsabers/rishi'slightsabermk-1.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(0,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Unstable Peacemaker"
hilt.Author = "ArsenicBeast"
hilt.id = "swtor3"
hilt.mdl = "models/swtor/arsenic/lightsabers/unstablepeacemaker'slightsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(0,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Rishi [No Handle]"
hilt.Author = "ArsenicBeast"
hilt.id = "swtor4"
hilt.mdl = "models/swtor/arsenic/lightsabers/senyatirall'slightsaber-companion.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(0,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Defiant Technographer"
hilt.Author = "ArsenicBeast"
hilt.id = "swtor5"
hilt.mdl = "models/swtor/arsenic/lightsabers/defianttechnographer'sshoto.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
		local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Defiant Vented"
hilt.Author = "Zyon"
hilt.id = "Defiant Vented"
hilt.mdl = "models/zyon/swtor/defiant_vented.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3, -2.5, -7),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3, -0.5, 7),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
		local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Grantek"
hilt.Author = "ArsenicBeast"
hilt.id = "swtor6"
hilt.mdl = "models/swtor/arsenic/lightsabers/grantekf11-dlightsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(0,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Attenuated"
hilt.Author = "ArsenicBeast"
hilt.id = "swtor7"
hilt.mdl = "models/swtor/arsenic/lightsabers/blademaster'sattenuatedlightsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(0,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Ice Jewel"
hilt.Author = "ArsenicBeast"
hilt.id = "swtor8"
hilt.mdl = "models/swtor/arsenic/lightsabers/ice-jewellightsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(0,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Diabolist"
hilt.Author = "ArsenicBeast"
hilt.id = "swtor9"
hilt.mdl = "models/swtor/arsenic/lightsabers/diabolistlightsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(0,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Revanite"
hilt.Author = "ArsenicBeast"
hilt.id = "swtor10"
hilt.mdl = "models/swtor/arsenic/lightsabers/revanite'smk-2lightsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(0,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Dauntless Avenger"
hilt.Author = "ArsenicBeast"
hilt.id = "swtor11"
hilt.mdl = "models/swtor/arsenic/lightsabers/dauntlessavenger'slightsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(0,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Blademaster"
hilt.Author = "ArsenicBeast"
hilt.id = "swtor12"
hilt.mdl = "models/swtor/arsenic/lightsabers/artusianlightsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(0,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Exarch"
hilt.Author = "ArsenicBeast"
hilt.id = "swtor13"
hilt.mdl = "models/swtor/arsenic/lightsabers/exarch'smk-1lightsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(0,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Corp Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors1"
hilt.mdl = "models/swtor/arsenic/lightsabers/adascorppolesaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -14),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 14),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.5,0) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
	   [2] = {
                pos = ent:LocalToWorld( Vector(25,-0.7,0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Descendent's Heirloom"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors2"
hilt.mdl = "models/swtor/arsenic/lightsabers/descendant'sheirloomdualsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -2, -18),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -2, 18),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.5,0) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
	   [2] = {
                pos = ent:LocalToWorld( Vector(32.5,-0.7,0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Defiant Technographer Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors3"
hilt.mdl = "models/swtor/arsenic/lightsabers/defianttechnographer'sdualsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -13),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 13),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.5,0) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
	   [2] = {
                pos = ent:LocalToWorld( Vector(25,-0.7,0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Defiant Vented Saberstaff"
hilt.Author = "Zyon"
hilt.id = "Defiant Vented Saberstaff"
hilt.mdl = "models/zyon/swtor/defiant_vented_dual.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2.75, -2.5, -3.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.75, -1, 3.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
		local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Warmaster Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors4"
hilt.mdl = "models/swtor/arsenic/lightsabers/warmaster'sdoublebladedlightsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -13),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 13),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Vigorous Battler Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors5"
hilt.mdl = "models/swtor/arsenic/lightsabers/vigorousbattlerdualsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -19),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 19),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Rishi Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors6"
hilt.mdl = "models/swtor/arsenic/lightsabers/rishi'smk-1polesaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -17),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 17),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,-0.5,0) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
	   [2] = {
                pos = ent:LocalToWorld( Vector(32.5,-0.7,0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Antique Socorro Saberstaff [Aurek]"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors7"
hilt.mdl = "models/swtor/arsenic/lightsabers/antiquesocorrosaberstaffaurek.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Antique Socorro Saberstaff [Dorn]"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors8"
hilt.mdl = "models/swtor/arsenic/lightsabers/antiquesocorrosaberstaffdorn.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Ardent Defender Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors9"
hilt.mdl = "models/swtor/arsenic/lightsabers/ardentdefender'sdualsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Attuned Forcelord"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors10"
hilt.mdl = "models/swtor/arsenic/lightsabers/attunedforcelord'ssaberstaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -17),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 17),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Attenuated Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors11"
hilt.mdl = "models/swtor/arsenic/lightsabers/blademaster'sattenuatedsaberstaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Bubble Blade"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors12"
hilt.mdl = "models/swtor/arsenic/lightsabers/artusiansaberstaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -13),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 13),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Chrysopaz Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors13"
hilt.mdl = "models/swtor/arsenic/lightsabers/chrysopazsaberstaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Conqueror Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors14"
hilt.mdl = "models/swtor/arsenic/lightsabers/conqueror'ssaberstaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -13.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 13.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Corusca Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors15"
hilt.mdl = "models/swtor/arsenic/lightsabers/coruscasaberstaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Derelict Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors16"
hilt.mdl = "models/swtor/arsenic/lightsabers/derelictsaberstaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Dragonpearl Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors17"
hilt.mdl = "models/swtor/arsenic/lightsabers/dragonpearlsaberstaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Elegant Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors18"
hilt.mdl = "models/swtor/arsenic/lightsabers/elegantmodifieddoublebladedsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Etched Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors19"
hilt.mdl = "models/swtor/arsenic/lightsabers/etchedduelerdualsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Eternal Commander Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors20"
hilt.mdl = "models/swtor/arsenic/lightsabers/eternalcommandermk-14saberstaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Exposed Reckoning Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors21"
hilt.mdl = "models/swtor/arsenic/lightsabers/reckoning'sexposedsaberstaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -10),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 10),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Exposed Retribution Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors22"
hilt.mdl = "models/swtor/arsenic/lightsabers/retribution'sexposedsaberstaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -17),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 17),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Exquisite Champion Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors23"
hilt.mdl = "models/swtor/arsenic/lightsabers/exquisitechampiondualsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Fearless Retaliator Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors24"
hilt.mdl = "models/swtor/arsenic/lightsabers/fearlessretaliator'ssaberstaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Frontier Hunter Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors25"
hilt.mdl = "models/swtor/arsenic/lightsabers/frontierhunter'sdualsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Grantek Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors26"
hilt.mdl = "models/swtor/arsenic/lightsabers/grantekf11-ddualsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Herald Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors27"
hilt.mdl = "models/swtor/arsenic/lightsabers/herald'spolesaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -14),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 14),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Hermit Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors28"
hilt.mdl = "models/swtor/arsenic/lightsabers/hermit'spolesaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -14),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 14),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Hiridu Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors29"
hilt.mdl = "models/swtor/arsenic/lightsabers/hiridusaberstaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -18),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 18),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Indomitable Vanquisher Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors30"
hilt.mdl = "models/swtor/arsenic/lightsabers/indomitablevanquisher'ssaberstaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Inscrutable Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors31"
hilt.mdl = "models/swtor/arsenic/lightsabers/inscrutabledualsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -13),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 13),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Iokath Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors32"
hilt.mdl = "models/swtor/arsenic/lightsabers/iokathmk-4saberstaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -16),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 16),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Occultist Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors33"
hilt.mdl = "models/swtor/arsenic/lightsabers/occultists'polesabermk1.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Outlander Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors34"
hilt.mdl = "models/swtor/arsenic/lightsabers/outlanderpolesaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Outlander Saberstaff 2"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors35"
hilt.mdl = "models/swtor/arsenic/lightsabers/outlanderpolesaber2.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Prophet Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors36"
hilt.mdl = "models/swtor/arsenic/lightsabers/prophet'sstarforgeddualsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -11),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 11),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Redeemer Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors37"
hilt.mdl = "models/swtor/arsenic/lightsabers/redeemer'sstarforgeddualsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Revanite Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors38"
hilt.mdl = "models/swtor/arsenic/lightsabers/revanite'smk-2polesaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Revanite Saberstaff 2"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors39"
hilt.mdl = "models/swtor/arsenic/lightsabers/revanite'smk-1polesaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Satele Shan Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors40"
hilt.mdl = "models/swtor/arsenic/lightsabers/sateleshan'sdualsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -19),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 19),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Stronghold Defender Sabestaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors41"
hilt.mdl = "models/swtor/arsenic/lightsabers/strongholddefender'ssaberstaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Tempted Apprentice Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors42"
hilt.mdl = "models/swtor/arsenic/lightsabers/temptedapprentice'sdualsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -12),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 12),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Unsealed Serenity Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors43"
hilt.mdl = "models/swtor/arsenic/lightsabers/serenity'sunsealedsaberstaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Unsealed Vengeance Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors44"
hilt.mdl = "models/swtor/arsenic/lightsabers/vengeance'sunsealedsaberstaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -16),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 16),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Vindicator Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors45"
hilt.mdl = "models/swtor/arsenic/lightsabers/vindicator'ssaberstaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -2, -12),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 12),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Wanderer"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors46"
hilt.mdl = "models/swtor/arsenic/lightsabers/custom-builtdoublebladedsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Zakuulan Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors47"
hilt.mdl = "models/swtor/arsenic/lightsabers/zakuulan'smk-1polesaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Zakuulan Saberstaff 2"
hilt.Author = "ArsenicBeast"
hilt.id = "swtors48"
hilt.mdl = "models/swtor/arsenic/lightsabers/zakuulan'smk-2polesaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Dark Reverie Saberstaff"
hilt.Author = "ArsenicBeast"
hilt.id = "darkreverie"
hilt.mdl = "models/swtor/arsenic/lightsabers/darkreveriedoublebladedsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Jedi Academy 1"
hilt.Author = "Captain Charles"
hilt.id = "ja1"
hilt.mdl = "models/sgg/starwars/weapons/w_saber_9_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -8),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(1,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Jedi Academy 2"
hilt.Author = "Captain Charles"
hilt.id = "ja2"
hilt.mdl = "models/sgg/starwars/weapons/w_saber_7_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -2, -8),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(1,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Jedi Academy 3"
hilt.Author = "Captain Charles"
hilt.id = "ja3"
hilt.mdl = "models/sgg/starwars/weapons/w_saber_6_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -2, -9),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 9),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(1,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Jedi Academy 4"
hilt.Author = "Captain Charles"
hilt.id = "ja4"
hilt.mdl = "models/sgg/starwars/weapons/w_saber_5_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -2, -9),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 9),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(1,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Jedi Academy 5"
hilt.Author = "Captain Charles"
hilt.id = "ja5"
hilt.mdl = "models/sgg/starwars/weapons/w_saber_4_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -2, -7),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 7),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(1,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Jedi Academy 6"
hilt.Author = "Captain Charles"
hilt.id = "ja6"
hilt.mdl = "models/sgg/starwars/weapons/w_saber_3_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -2, -8),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(1,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Jedi Academy 7"
hilt.Author = "Captain Charles"
hilt.id = "ja7"
hilt.mdl = "models/sgg/starwars/weapons/w_saber_1_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(1,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Jedi Academy 8"
hilt.Author = "Captain Charles"
hilt.id = "ja8"
hilt.mdl = "models/sgg/starwars/weapons/w_reborn_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -10),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 10),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(1,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Jedi Academy 9"
hilt.Author = "Captain Charles"
hilt.id = "ja9"
hilt.mdl = "models/sgg/starwars/weapons/w_saber_2_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -2, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(1,-0.6,-0.1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Jedi Academy Staff 1"
hilt.Author = "ArsenicBeast"
hilt.id = "jas1"
hilt.mdl = "models/sgg/starwars/weapons/w_saber_dual_1_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Jedi Academy Staff 2"
hilt.Author = "ArsenicBeast"
hilt.id = "jas2"
hilt.mdl = "models/sgg/starwars/weapons/w_saber_dual_2_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Jedi Academy Staff 3"
hilt.Author = "ArsenicBeast"
hilt.id = "jas3"
hilt.mdl = "models/sgg/starwars/weapons/w_saber_dual_3_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Jedi Academy Staff 4"
hilt.Author = "ArsenicBeast"
hilt.id = "jas4"
hilt.mdl = "models/sgg/starwars/weapons/w_saber_dual_4_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Jedi Academy Staff 5"
hilt.Author = "ArsenicBeast"
hilt.id = "jas5"
hilt.mdl = "models/sgg/starwars/weapons/w_saber_dual_5_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "The Days"
hilt.Author = "Zhrom"
hilt.id = "zhrom"
hilt.mdl = "models/zhrom/days/days.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "The Knowledge Seeker"
hilt.Author = "Zhrom"
hilt.id = "zhrom2"
hilt.mdl = "models/zhrom/the knowledge seeker/the knowledge seeker.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "The Crimson Reaper"
hilt.Author = "Zhrom"
hilt.id = "zhrom3"
hilt.mdl = "models/zhrom/unknown/unknown.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "The Royal Blade"
hilt.Author = "Zhrom"
hilt.id = "zhrom4"
hilt.mdl = "models/zhrom/lightsaber3/lightsaber3.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -9),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 9),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "The Dark Wanderer"
hilt.Author = "Zhrom"
hilt.id = "zhrom5"
hilt.mdl = "models/zhrom/lightsaber/lightsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -8),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "The Sanguine Blade"
hilt.Author = "Zyon"
hilt.id = "The Sanguine Blade"
hilt.mdl = "models/zyon/misc/vampire_slayer.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2.5, -2, -8),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.5, -0.5, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Templar"
hilt.Author = "Zyon"
hilt.id = "Templar"
hilt.mdl = "models/zyon/misc/templar.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2.5, -2, -8),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.5, -0.5, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Tarnux"
hilt.Author = "Zyon"
hilt.id = "Tarnux"
hilt.mdl = "models/zyon/swtor/tarnux.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(4, -0.5, -8),
            ang = Angle(-90, -90, 90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.5, -0.5, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Tarnux Saberstaff"
hilt.Author = "Zyon"
hilt.id = "Tarnux Saberstaff"
hilt.mdl = "models/zyon/swtor/tarnux_dual.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(4, -0.5, -10),
            ang = Angle(-90, -90, 90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.5, -0.5, 10),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Tarnux Staff"
hilt.Author = "Zyon"
hilt.id = "Tarnux Staff"
hilt.mdl = "models/zyon/swtor/tarnux_staff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(4, -0.5, -10),
            ang = Angle(-90, -90, 90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.5, -0.5, 10),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )


local hilt = {}
hilt.PrintName = "The Ringed Hilt"
hilt.Author = "Zhrom"
hilt.id = "zhrom6"
hilt.mdl = "models/zhrom/lightsaber2/lightsaber2.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "The Golden Snake Pike"
hilt.Author = "ArsenicBeast"
hilt.id = "zhromgoldsnake"
hilt.mdl = "models/zhrom/snake/snake.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -12),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "The Green Snakes Pike"
hilt.Author = "ArsenicBeast"
hilt.id = "zhromgreensnake"
hilt.mdl = "models/zhrom/snake2/snake2.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -12),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "The Pike"
hilt.Author = "ArsenicBeast"
hilt.id = "zhrompike3"
hilt.mdl = "models/zhrom/pike/pike.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -8),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Slim Dwarf Saberstaff"
hilt.Author = "Octavius"
hilt.id = "fsaber1"
hilt.mdl = "models/wos/lct/weapons/lightsabers/dwarf_saber_duel_slim_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
		local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Dwarf Saberstaff"
hilt.Author = "Octavius"
hilt.id = "fsaber2"
hilt.mdl = "models/wos/lct/weapons/lightsabers/dwarf_saber_duel_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
		local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Dwarf"
hilt.Author = "Octavius"
hilt.id = "Dwarf"
hilt.mdl = "models/wos/lct/weapons/lightsabers/dwarf_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2.75, -2.5, -5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.75, -2.5, 5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
		local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Gold Snake Saberstaff"
hilt.Author = "Octavius"
hilt.id = "fsaber3"
hilt.mdl = "models/wos/lct/weapons/lightsabers/gold_snake_duel_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -8),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
		local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Dragon Saberstaff"
hilt.Author = "Octavius"
hilt.id = "fsaber4"
hilt.mdl = "models/wos/lct/weapons/lightsabers/dragon_saber_duel_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.5, -1.5, -15),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.5, -1, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
		local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Dragon Saber"
hilt.Author = "Octavius"
hilt.id = "Dragon Saber"
hilt.mdl = "models/wos/lct/weapons/lightsabers/dragon_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3, -2, -5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3, -2, 5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
		local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Old Saberstaff"
hilt.Author = "Octavius"
hilt.id = "fsaber5"
hilt.mdl = "models/wos/lct/weapons/lightsabers/old_saber_duel.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
		local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Blade Weaver Saberstaff"
hilt.Author = "Octavius"
hilt.id = "fsaber6"
hilt.mdl = "models/wos/lct/weapons/lightsabers/blue_blade_weaver_duel_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
		local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Blade Weaver"
hilt.Author = "Octavius"
hilt.id = "fsaber7"
hilt.mdl = "models/wos/lct/weapons/lightsabers/blue_blade_weaver_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Ancient Dragon"
hilt.Author = "Octavius"
hilt.id = "fsaber8"
hilt.mdl = "models/wos/lct/weapons/lightsabers/ancient_dragon_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2.75, -1, -4),
            ang = Angle(-90, 10, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.75, -3, 4),
            ang = Angle(90, -10, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Ancient Dragon Saberstaff"
hilt.Author = "Octavius"
hilt.id = "fsaber9"
hilt.mdl = "models/wos/lct/weapons/lightsabers/ancient_dragon_duel_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1, -2),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 2),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Woven"
hilt.Author = "Octavius"
hilt.id = "fsaber10"
hilt.mdl = "models/wos/lct/weapons/lightsabers/wooden_duel.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-10,-0.05,0) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
	   [2] = {
                pos = ent:LocalToWorld( Vector(10,-0.05,0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Bone Antlers Saberstaff"
hilt.Author = "Octavius"
hilt.id = "fsaber11"
hilt.mdl = "models/wos/lct/weapons/lightsabers/bone_saber_duel_antlers_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1, -14),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 14),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Bone Saberstaff"
hilt.Author = "Octavius"
hilt.id = "fsaber12"
hilt.mdl = "models/wos/lct/weapons/lightsabers/bone_saber_duel_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1, -14),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 14),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Bone Saber"
hilt.Author = "Octavius"
hilt.id = "Bone Saber"
hilt.mdl = "models/wos/lct/weapons/lightsabers/bone_saber_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -8),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Ahsoka's First Hilt"
hilt.Author = "Midnight"
hilt.id = "hiltahsoka"
hilt.mdl = "models/saber_ashoka1/saber_ashoka1.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -1),
            ang = Angle(90, 90, 90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, -1),
            ang = Angle(-90, -90, -90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-6.5,0,0) ),
                dir = ent:LocalToWorldAngles( Angle(90,0,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Ahsoka's First Hilt{Reverse}"
hilt.Author = "Midnight"
hilt.id = "reversehiltahsoka"
hilt.mdl = "models/saber_ashoka1/saber_ashoka1.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.1, -1.25, 2), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.1, -1.25, -2),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-6.5,0,0) ),
                dir = ent:LocalToWorldAngles( Angle(90,0,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Byph Hilt"
hilt.Author = "InGame"
hilt.id = "hiltbyph"
hilt.mdl = "models/saber_byph/saber_byph.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.1, -1.25, -2), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(90, 90, 90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.1, -1.25, 2),
            ang = Angle(-90, -90, -90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-6.5,0,0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Byph Hilt - Reverse"
hilt.Author = "InGame"
hilt.id = "reversehiltbyph"
hilt.mdl = "models/saber_byph/saber_byph.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 2),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, -2),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-6.5,0,0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )


local hilt = {}
hilt.PrintName = "Crystal Hilt"
hilt.Author = "InGame"
hilt.id = "hiltcrystal"
hilt.mdl = "models/saber_crystal/saber_crystal.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.1, -1.25, -4), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(90, 90, 90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.1, -1.25, 4),
            ang = Angle(-90, -90, -90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-6.5,0,0) ),
                dir = ent:LocalToWorldAngles( Angle(90,0,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )


local hilt = {}
hilt.PrintName = "Crystal Hilt - Reverse"
hilt.Author = "InGame"
hilt.id = "reversehiltcrystal"
hilt.mdl = "models/saber_crystal/saber_crystal.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.1, -1.5, 3),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.1, -1.5, -3),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-6.5,0,0) ),
                dir = ent:LocalToWorldAngles( Angle(90,0,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Ashla"
hilt.Author = "InGame"
hilt.id = "ashla"
hilt.mdl = "models/zyon/swtor/ashla.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2.75, -2, -8.5), 
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.75, -1.5, 8.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Bogan"
hilt.Author = "InGame"
hilt.id = "bogan"
hilt.mdl = "models/zyon/swtor/bogan_d.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2.75, -2, -8.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.75, -1.5, 8.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Battlerager"
hilt.Author = "InGame"
hilt.id = "Battlerager"
hilt.mdl = "models/zhrom/dylanxd/dylanxd.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(4, -1.5, -13),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(4, -1.5, 13),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Cartel"
hilt.Author = "InGame"
hilt.id = "Cartel"
hilt.mdl = "models/swtor/arsenic/lightsabers/senyatirall'slightsaber-cartel.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -13),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 13),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Conqueror"
hilt.Author = "InGame"
hilt.id = "Conqueror"
hilt.mdl = "models/swtor/arsenic/lightsabers/conqueror'slightsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.75, -1.5, 5),
            ang = Angle(90, 90, -90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Dawnbreaker"
hilt.Author = "InGame"
hilt.id = "Dawnbreaker"
hilt.mdl = "models/zyon/misc/dawnbreaker.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2.5, -2, -6),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.5, -1, 6),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Old Saber"
hilt.Author = "InGame"
hilt.id = "Old Saber"
hilt.mdl = "models/wos/lct/weapons/lightsabers/old_saber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3, -2, -4),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3, -2, 4),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Precise Insurgent"
hilt.Author = "Zyon"
hilt.id = "Precise Insurgent"
hilt.mdl = "models/zyon/swtor/precise_insurgent.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3, -2, -4),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3, 0, 4),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
       	local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_staffcrosses.lua:
toCreate = { -- dont remove
	["Staffcross Guardian"] = {
		mdl = "models/anzati/sgn/lightsabers/staffcross_blue.mdl",
	},
	["Staffcross Consular"] = {
		mdl = "models/anzati/sgn/lightsabers/staffcross_green.mdl",
	},
	["Staffcross Sentinel"] = {
		mdl = "models/anzati/sgn/lightsabers/staffcross_orange.mdl",
	},
	["Staffcross Balanced"] = {
		mdl = "models/anzati/sgn/lightsabers/staffcross_purple.mdl",
	},
	["Staffcross Sith"] = {
		mdl = "models/anzati/sgn/lightsabers/staffcross_red.mdl",
	},
	["Staffcross Pure"] = {
		mdl = "models/anzati/sgn/lightsabers/staffcross_white.mdl",
	},
	["Staffcross Templeguard"] = {
		mdl = "models/anzati/sgn/lightsabers/staffcross_yellow.mdl",
	},
} -- dont remove


local Author = "Midnight" -- Feel free to change i dont care
local Usum = "1"
for k,v in pairs(toCreate) do
	local hilt = {}
	hilt.PrintName = k or Usum -- avoid conflict if someone fucks it up
	hilt.Author = Author
	hilt.id = k or Usum -- as said above
	hilt.mdl = v.mdl or "models/lscs/weapons/katarn.mdl" -- as said above
	hilt.info = {
		ParentData = {
			["RH"] = {
				bone = "ValveBiped.Bip01_R_Hand",
				pos = Vector(6, 0, -2), -- RightHandpos if needs editing.
				ang = Angle(-90, -90, -90), -- RightHandang if needs editing
			},
			["LH"] = {
				bone = "ValveBiped.Bip01_L_Hand",
				pos = Vector(6, -4, 2), -- same for left
				ang = Angle(90, 90, 90),
			},
		},
		GetBladePos = function( ent ) 

			local blades = {}
		
			for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
				if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
				end
				if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
				end
			end
		
			return blades
		end,
	}
	print("registered " .. k)
	
	if v.pData then
		hilt.info.ParentData["RH"].pos = v.pData["RHpos"]
		hilt.info.ParentData["RH"].ang = v.pData["RHang"]
		
		hilt.info.ParentData["LH"].pos = v.pData["LHpos"]
		hilt.info.ParentData["LH"].ang = v.pData["LHang"]
	end
	LSCS:RegisterHilt( hilt ) -- register the hilt
	Usum = Usum .. "1"
	
	
	
end
print("Extra Sabers Loaded - You're welcome. And this took like an hour total effort.")
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_uhhh.lua:
toCreate = { -- dont remove
	["Maul"] = {
		mdl = "models/weapons/starwars/w_maul_saber_staff_hilt.mdl",
		pData = {
			["RHpos"] = Vector(3.75, -1.5, 0),
			["RHang"] = Angle(-90, -90, -90),
			["LHpos"] = Vector(3.75, -1, 0),
			["LHang"] = Angle(90, 90, 90),
		},
	}, -- Maul is default example for needing to edit pos / ang, most dont need it. 
	["Borthtwin"] = {	
		mdl = "models/zhrom/borth-twin/borth-twin.mdl",
	},
	["Dani"] = {
		mdl = "models/zhrom/dani/dani.mdl",
	},
	["Dante"] = {
		mdl = "models/zhrom/dante/dante.mdl",
	},
	["Noble Pike"] = {
		mdl = "models/zhrom/donation1/donation1.mdl",
	},
	["Warrior Pike"] = {
		mdl = "models/zhrom/donation2/donation2.mdl",
	},
	["Criss Cross"] = {
		mdl = "models/zhrom/donation3/donation3.mdl",
	},
	["Jesus Pike"] = {
		mdl = "models/zhrom/donation4/donation4.mdl",
	},
	["Pristine Staff"] = {
		mdl = "models/zhrom/donation7/donation7.mdl",
	},
	["Mysterious"] = {
		mdl = "models/zhrom/lightsaber4/lightsaber4.mdl",
	},
	["Punisher"] = {
		mdl = "models/zhrom/the grand saber/the grand saber.mdl",
	},
	["Theo"] = {
		mdl = "models/zhrom/theo/theo.mdl",
	},
	["Trident"] = {
		mdl = "models/zhrom/trident/trident.mdl",
	},
	["Twinsaber"] = {
		mdl = "models/zhrom/twinsaber/twinsaber.mdl",
	},
	["Wooden Staff"] = {
		mdl = "models/wos/lct/weapons/lightsabers/wooden_staff.mdl",
	},
	["Karn Staff"] = {
		mdl = "models/wos/lct/weapons/lightsabers/karn_staff_hilt.mdl",
	},
	["Gold Snake"] = {
		mdl = "models/wos/lct/weapons/lightsabers/gold_snake_hilt.mdl",
	},
} -- dont remove


local Author = "Midnight" -- Feel free to change i dont care
local Usum = "1"
for k,v in pairs(toCreate) do
	local hilt = {}
	hilt.PrintName = k or Usum -- avoid conflict if someone fucks it up
	hilt.Author = Author
	hilt.id = k or Usum -- as said above
	hilt.mdl = v.mdl or "models/lscs/weapons/katarn.mdl" -- as said above
	hilt.info = {
		ParentData = {
			["RH"] = {
				bone = "ValveBiped.Bip01_R_Hand",
				pos = Vector(3.75, -1.5, -6.5), -- RightHandpos if needs editing.
				ang = Angle(-90, -90, -90), -- RightHandang if needs editing
			},
			["LH"] = {
				bone = "ValveBiped.Bip01_L_Hand",
				pos = Vector(3.75, -1, 6.5), -- same for left
				ang = Angle(90, 90, 90),
			},
		},
		GetBladePos = function( ent ) 

			local blades = {}
		
			for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
				if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
				end
				if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
				end
			end
		
			return blades
		end,
	}
	print("registered " .. k)
	
	if v.pData then
		hilt.info.ParentData["RH"].pos = v.pData["RHpos"]
		hilt.info.ParentData["RH"].ang = v.pData["RHang"]
		
		hilt.info.ParentData["LH"].pos = v.pData["LHpos"]
		hilt.info.ParentData["LH"].ang = v.pData["LHang"]
	end
	LSCS:RegisterHilt( hilt ) -- register the hilt
	Usum = Usum .. "1"
	
	
	
end
print("Extra Sabers Loaded - You're welcome. And this took like an hour total effort.")
--PATH addons/[miecze] moce i hilty/lua/lscs/content/training_saber_hilt.lua:
local hilt = {}
hilt.PrintName = "Training Saber"
hilt.Author = "Colt"
hilt.Spawnable = false -- special case, not spawnable from menu
hilt.id = "colttrainingsaber"
hilt.mdl = "models/swtor/weapons/electroblade_low03_a01.mdl"
hilt.info = {
	ParentData = { -- allows you to modify how the model is attached to the player. "RH" = Right Hand,  "LH" = Left Hand
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3.5, -1.5, -8),
			ang = Angle(-90, 0, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(4.25, -1.5, 1),
			ang = Angle(8, 0, -10),
		},
	},
	GetBladePos = function( ent ) 
		local blades = {
			[1] = {
				pos = ent:LocalToWorld( Vector(3.5, -1.5, 1) ),
				dir = ent:LocalToWorldAngles( Angle(-90, 0, 10) ):Up(),
			},
		}
		return blades
	end,
}
LSCS:RegisterHilt( hilt ) -- register it to the system. This will also register a new entity
--PATH lua/lvs_framework/autorun/cl_fonts.lua:
local THE_FONT = {
	font = "Verdana",
	extended = false,
	size = 14,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = true,
	additive = false,
	outline = false,
}
surface.CreateFont( "LVS_VERSION", THE_FONT )

THE_FONT.extended = false
THE_FONT.size = 20
THE_FONT.weight = 2000
surface.CreateFont( "LVS_FONT", THE_FONT )

THE_FONT.size = 16
surface.CreateFont( "LVS_FONT_SWITCHER", THE_FONT )

THE_FONT.font = "Arial"
THE_FONT.size = 14
THE_FONT.weight = 1
THE_FONT.shadow = false
surface.CreateFont( "LVS_FONT_PANEL", THE_FONT )

THE_FONT.size = 20
THE_FONT.weight = 2000
surface.CreateFont( "LVS_FONT_HUD", THE_FONT )

THE_FONT.size = 40
THE_FONT.weight = 2000
THE_FONT.shadow = true
surface.CreateFont( "LVS_FONT_HUD_LARGE", THE_FONT )
--PATH lua/lvs_framework/autorun/lvs_convar.lua:
return gluapack()()
--PATH lua/lvs_framework/autorun/lvs_convar.lua:
-- 2022 and i still havent bothered creating a system that does this automatically

LVS.cVar_FreezeTeams = CreateConVar( "lvs_freeze_teams", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"enable/disable auto ai-team switching" )
LVS.FreezeTeams = LVS.cVar_FreezeTeams and LVS.cVar_FreezeTeams:GetBool() or false
cvars.AddChangeCallback( "lvs_freeze_teams", function( convar, oldValue, newValue ) 
	LVS.FreezeTeams = tonumber( newValue ) ~=0
end, "lvs_freezeteams_callback" )

LVS.cVar_TeamPassenger = CreateConVar( "lvs_teampassenger", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"only allow players of matching ai-team to enter the vehicle? 1 = team only, 0 = everyone can enter" )
LVS.TeamPassenger = LVS.cVar_TeamPassenger and LVS.cVar_TeamPassenger:GetBool() or false
cvars.AddChangeCallback( "lvs_teampassenger", function( convar, oldValue, newValue ) 
	LVS.TeamPassenger = tonumber( newValue ) ~= 0
end, "lvs_teampassenger_callback" )

LVS.cVar_PlayerDefaultTeam = CreateConVar( "lvs_default_teams", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"set default player ai-team" )
LVS.PlayerDefaultTeam = LVS.cVar_PlayerDefaultTeam and LVS.cVar_PlayerDefaultTeam:GetInt() or 0
cvars.AddChangeCallback( "lvs_default_teams", function( convar, oldValue, newValue ) 
	LVS.PlayerDefaultTeam = math.Round( tonumber( newValue ), 0 )
end, "lvs_defaultteam_callback" )

LVS.cVar_IgnoreNPCs = CreateConVar( "lvs_ai_ignorenpcs", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"should LVS-AI ignore NPCs?" )
LVS.IgnoreNPCs = LVS.cVar_IgnoreNPCs and LVS.cVar_IgnoreNPCs:GetBool() or false
cvars.AddChangeCallback( "lvs_ai_ignoreplayers", function( convar, oldValue, newValue ) 
	LVS.IgnorePlayers = tonumber( newValue ) ~=0
end)

LVS.cVar_playerignore = CreateConVar( "lvs_ai_ignoreplayers", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"should LVS-AI ignore Players?" )
LVS.IgnorePlayers = LVS.cVar_playerignore and LVS.cVar_playerignore:GetBool() or false
cvars.AddChangeCallback( "lvs_ai_ignorenpcs", function( convar, oldValue, newValue ) 
	LVS.IgnoreNPCs = tonumber( newValue ) ~=0
end)

if SERVER then
	util.AddNetworkString( "lvs_admin_setconvar" )

	net.Receive( "lvs_admin_setconvar", function( length, ply )
		if not IsValid( ply ) or not ply:IsSuperAdmin() then return end

		local ConVar = net.ReadString()
		local Value = tonumber( net.ReadString() )

		RunConsoleCommand( ConVar, Value ) 
	end)

	return
end

CreateClientConVar( "lvs_mouseaim", 0, true, true)
CreateClientConVar( "lvs_mouseaim_type", 0, true, false)
CreateClientConVar( "lvs_edit_hud", 1, true, false)
CreateClientConVar( "lvs_sensitivity_x", 1, true, true)
CreateClientConVar( "lvs_sensitivity_y", 1, true, true)
CreateClientConVar( "lvs_return_delta", 2, true, true)

LVS.cvarCamFocus = CreateClientConVar( "lvs_camerafocus", 0, true, false)

local cvarVolume = CreateClientConVar( "lvs_volume", 0.5, true, false)
LVS.EngineVolume = cvarVolume and cvarVolume:GetFloat() or 0.5
cvars.AddChangeCallback( "lvs_volume", function( convar, oldValue, newValue ) 
	LVS.EngineVolume = math.Clamp( tonumber( newValue ), 0, 1 )
end)

local cvarTrail = CreateClientConVar( "lvs_show_traileffects", 1, true, false)
LVS.ShowTraileffects = cvarTrail and cvarTrail:GetBool() or true
cvars.AddChangeCallback( "lvs_show_traileffects", function( convar, oldValue, newValue ) 
	LVS.ShowTraileffects = tonumber( newValue ) ~=0
end)

local cvarEffects = CreateClientConVar( "lvs_show_effects", 1, true, false)
LVS.ShowEffects = cvarEffects and cvarEffects:GetBool() or true
cvars.AddChangeCallback( "lvs_show_effects", function( convar, oldValue, newValue ) 
	LVS.ShowEffects = tonumber( newValue ) ~=0
end)

local cvarPhysEffects = CreateClientConVar( "lvs_show_physicseffects", 1, true, false)
LVS.ShowPhysicsEffects = cvarPhysEffects and cvarPhysEffects:GetBool() or true
cvars.AddChangeCallback( "lvs_show_physicseffects", function( convar, oldValue, newValue ) 
	LVS.ShowPhysicsEffects = tonumber( newValue ) ~=0
end)

local cvarShowIdent = CreateClientConVar( "lvs_show_identifier", 1, true, false)
LVS.ShowIdent = cvarShowIdent and cvarShowIdent:GetBool() or true
cvars.AddChangeCallback( "lvs_show_identifier", function( convar, oldValue, newValue ) 
	LVS.ShowIdent = tonumber( newValue ) ~=0
end)

local cvarHitMarker = CreateClientConVar( "lvs_hitmarker", 1, true, false)
LVS.ShowHitMarker = cvarHitMarker and cvarHitMarker:GetBool() or false
cvars.AddChangeCallback( "lvs_hitmarker", function( convar, oldValue, newValue ) 
	LVS.ShowHitMarker = tonumber( newValue ) ~=0
end)

local cvarAntiAlias = GetConVar( "mat_antialias" )
LVS.AntiAliasingEnabled = cvarAntiAlias and (cvarAntiAlias:GetInt() > 3) or false
cvars.AddChangeCallback( "mat_antialias", function( convar, oldValue, newValue ) 
	LVS.AntiAliasingEnabled = tonumber( newValue ) > 3
end)

local cvarBulletSFX = CreateClientConVar( "lvs_bullet_nearmiss", 1, true, false)
LVS.EnableBulletNearmiss = cvarBulletSFX and cvarBulletSFX:GetBool() or true
cvars.AddChangeCallback( "lvs_bullet_nearmiss", function( convar, oldValue, newValue ) 
	LVS.EnableBulletNearmiss = tonumber( newValue ) ~=0
end)

local cvarDev = GetConVar( "developer" )
LVS.DeveloperEnabled = cvarDev and (cvarDev:GetInt() >= 1) or false
cvars.AddChangeCallback( "developer", function( convar, oldValue, newValue )
	LVS.DeveloperEnabled = (tonumber( newValue ) or 0) >= 1
end)

cvars.AddChangeCallback( "lvs_mouseaim", function( convar, oldValue, newValue )
	LocalPlayer():lvsBuildControls()

	net.Start("lvs_toggle_mouseaim")
	net.SendToServer()
end)

--PATH lua/lvs_framework/autorun/lvs_entitytracker.lua:
LVS.VehiclesStored = LVS.VehiclesStored or {}
LVS.NPCsStored = LVS.NPCsStored or {}

function LVS:GetNPCs()
	for index, ent in pairs( LVS.NPCsStored ) do
		if not IsValid( ent ) then
			LVS.NPCsStored[ index ] = nil
		end
	end

	return LVS.NPCsStored
end

function LVS:GetVehicles()
	for index, ent in pairs( LVS.VehiclesStored ) do
		if not IsValid( ent ) then
			LVS.VehiclesStored[ index ] = nil
		end
	end

	return LVS.VehiclesStored
end

local Teams = {
	["npc_breen"] = 1,
	["npc_combine_s"] = 1,
	["npc_combinedropship"] = 1,
	["npc_combinegunship"] = 1,
	["npc_crabsynth"] = 1,
	["npc_cscanner"] = 1,
	["npc_helicopter"] = 1,
	["npc_manhack"] = 1,
	["npc_metropolice"] = 1,
	["npc_mortarsynth"] = 1,
	["npc_sniper"] = 1,
	["npc_stalker"] = 1,
	["npc_strider"] = 1,
	["npc_hunter"] = 1,

	["monster_human_grunt"] = 1,
	["monster_human_assassin"] = 1,
	["monster_sentry"] = 1,

	["npc_kleiner"] = 2,
	["npc_monk"] = 2,
	["npc_mossman"] = 2,
	["npc_vortigaunt"] = 2,
	["npc_alyx"] = 2,
	["npc_barney"] = 2,
	["npc_citizen"] = 2,
	["npc_dog"] = 2,
	["npc_eli"] = 2,
	["monster_scientist"] = 2,
	["monster_barney"] = 2,

	["npc_zombine"] = 3,
	["npc_fastzombie"] = 3,
	["npc_headcrab"] = 3,
	["npc_headcrab_black"] = 3,
	["npc_headcrab_fast"] = 3,
	["npc_antlion"] = 3,
	["npc_antlionguard"] = 3,
	["npc_zombie"] = 3,
	["npc_zombie_torso"] = 3,
	["npc_poisonzombie"] = 3,
	["monster_alien_grunt"] = 3,
	["monster_alien_slave"] = 3,
	["monster_gargantua"] = 3,
	["monster_bullchicken"] = 3,
	["monster_headcrab"] = 3,
	["monster_babycrab"] = 3,
	["monster_zombie"] = 3,
	["monster_houndeye"] = 3,
	["monster_nihilanth"] = 3,
	["monster_bigmomma"] = 3,
	["monster_babycrab"] = 3,
}
function LVS:GetNPCRelationship( npc_class )
	return Teams[ npc_class ] or 0
end

hook.Add( "OnEntityCreated", "!!!!lvsEntitySorter", function( ent )
	timer.Simple( 2, function() 
		if not IsValid( ent ) then return end

		if isfunction( ent.IsNPC ) and ent:IsNPC() then
			table.insert( LVS.NPCsStored, ent )

			if SERVER then
				hook.Run( "LVS.UpdateRelationship", ent )
			end
		end

		if ent.LVS then 
			if CLIENT and ent.PrintName then
				language.Add( ent:GetClass(), ent.PrintName)
			end

			table.insert( LVS.VehiclesStored, ent )

			if SERVER then
				LVS:FixVelocity()

				hook.Run( "LVS.UpdateRelationship", ent )
			end
		end
	end )
end )
--PATH lua/lvs_framework/autorun/lvs_force_directinput.lua:
return gluapack()()
--PATH lua/lvs_framework/autorun/lvs_force_directinput.lua:

local cVar_forcedirect = CreateConVar( "lvs_force_directinput", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"Force Direct Input Steering Method?" )
local cVar_forceindicator = CreateConVar( "lvs_force_forceindicator", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"Force Direct Input Steering Method?" )

function LVS:IsDirectInputForced()
	return LVS.ForceDirectInput == true
end

function LVS:IsIndicatorForced()
	return LVS.ForceIndicator == true
end

if SERVER then
	util.AddNetworkString( "lvs_forced_input_getter" )

	local function UpdateForcedSettings( ply )
		net.Start( "lvs_forced_input_getter" )

		net.WriteBool( LVS:IsDirectInputForced() )
		net.WriteBool( LVS:IsIndicatorForced() )

		if IsValid( ply ) then
			net.Send( ply )
		else
			net.Broadcast()
		end
	end

	LVS.ForceDirectInput = cVar_forcedirect and cVar_forcedirect:GetBool() or false
	cvars.AddChangeCallback( "lvs_force_directinput", function( convar, oldValue, newValue ) 
		LVS.ForceDirectInput = tonumber( newValue ) ~=0

		UpdateForcedSettings()
	end)

	LVS.ForceIndicator = cVar_forceindicator and cVar_forceindicator:GetBool() or false
	cvars.AddChangeCallback( "lvs_force_forceindicator", function( convar, oldValue, newValue ) 
		LVS.ForceIndicator = tonumber( newValue ) ~=0

		UpdateForcedSettings()
	end)

	net.Receive( "lvs_forced_input_getter", function( length, ply )
		UpdateForcedSettings( ply )
	end)
else
	net.Receive( "lvs_forced_input_getter", function( length )
		LVS.ForceDirectInput = net.ReadBool()
		LVS.ForceIndicator = net.ReadBool()
	end )

	hook.Add( "InitPostEntity", "!11!!!lvsIsPlayerReady", function()
		net.Start( "lvs_forced_input_getter" )
		net.SendToServer()
	end )
end
--PATH lua/lvs_framework/autorun/lvs_soundscripts.lua:

sound.Add( {
	name = "LVS.Physics.Scrape",
	channel = CHAN_STATIC,
	level = 80,
	sound = "lvs/physics/scrape_loop.wav"
} )

sound.Add( {
	name = "LVS.Physics.Wind",
	channel = CHAN_STATIC,
	level = 140,
	sound = "lvs/physics/wind_loop.wav",
} )

sound.Add( {
	name = "LVS.Physics.Water",
	channel = CHAN_STATIC,
	level = 140,
	sound = "lvs/physics/water_loop.wav",
} )

sound.Add( {
	name = "LVS.DYNAMIC_EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 130,
	pitch = {90, 110},
	sound = "^lvs/explosion_dist.wav"
} )

sound.Add( {
	name = "LVS.MISSILE_EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 130,
	pitch = {90, 120},
	sound = {
		"ambient/levels/streetwar/city_battle17.wav",
		"ambient/levels/streetwar/city_battle18.wav",
		"ambient/levels/streetwar/city_battle19.wav",
	}
} )

sound.Add( {
	name = "LVS.BOMB_EXPLOSION_DYNAMIC",
	channel = CHAN_STATIC,
	volume = 1,
	level = 135,
	pitch = {90, 110},
	sound = {
		"^lvs/explosions/dyn1.wav",
		"^lvs/explosions/dyn2.wav",
		"^lvs/explosions/dyn3.wav",
		"^lvs/explosions/dyn4.wav",
	}
} )

sound.Add( {
	name = "LVS.BOMB_EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1,
	level = 75,
	pitch = {90, 110},
	sound = {
		"lvs/explosions/close1.wav",
		"lvs/explosions/close2.wav",
		"lvs/explosions/close3.wav",
		"lvs/explosions/close4.wav",
	}
} )

sound.Add( {
	name = "LVS.BULLET_EXPLOSION_DYNAMIC",
	channel = CHAN_STATIC,
	volume = 1,
	level = 135,
	pitch = {90, 110},
	sound = {
		"^lvs/explosions/med_dyn1.wav",
		"^lvs/explosions/med_dyn2.wav",
		"^lvs/explosions/med_dyn3.wav",
		"^lvs/explosions/med_dyn4.wav",
	}
} )

sound.Add( {
	name = "LVS.BULLET_EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1,
	level = 75,
	pitch = {90, 110},
	sound = {
		"lvs/explosions/med_close1.wav",
		"lvs/explosions/med_close2.wav",
		"lvs/explosions/med_close3.wav",
		"lvs/explosions/med_close4.wav",
	}
} )


sound.Add( {
	name = "LVS.EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 115,
	pitch = {95, 115},
	sound = "lvs/explosion.wav"
} )

if CLIENT then
	local SoundList = {}

	hook.Add( "EntityEmitSound", "!!!lvs_fps_rape_fixer", function( t )
		if not t.Entity.LVS and not t.Entity._LVS then return end

		local SoundFile = t.SoundName

		if SoundList[ SoundFile ] == true then
			return true

		elseif SoundList[ SoundFile ] == false then
			return false

		else
			local File = string.Replace( SoundFile, "^", "" )

			local Exists = file.Exists( "sound/"..File , "GAME" )

			SoundList[ SoundFile ] = Exists

			if not Exists then
				print("[LVS] '"..SoundFile.."' not found. Soundfile will not be played and is filtered for this game session to avoid fps issues.")
			end
		end
	end )
end

--PATH lua/autorun/marauder_addon.lua:
return gluapack()()
--PATH lua/autorun/massif.lua:
return gluapack()()
--PATH lua/autorun/maul.lua:
player_manager.AddValidModel( "mauls7", "models/maul.mdl" )
--PATH addons/[mrs] mc_ranks/lua/autorun/mc_ranks.lua:
return gluapack()()
--PATH lua/autorun/mcfly_jka_younglings.lua:
--Add Playermodel
player_manager.AddValidModel( "Young Anakin", "models/jazzmcfly/jka/younglings/jka_young_anikan.mdl" )
player_manager.AddValidModel( "Young Padiwan Male", "models/jazzmcfly/jka/younglings/jka_young_male.mdl" )
player_manager.AddValidModel( "Young Padiwan Female", "models/jazzmcfly/jka/younglings/jka_young_female.mdl" )
player_manager.AddValidModel( "Young Shaak Ti", "models/jazzmcfly/jka/younglings/jka_young_shak.mdl" )



--PATH lua/autorun/mediaplayer.lua:
return gluapack()()
--PATH lua/mediaplayer/cl_init.lua:
if MediaPlayer then
	-- TODO: compare versions?
	if MediaPlayer.__refresh then
		MediaPlayer.__refresh = nil
	else
		return -- MediaPlayer has already been registered
	end
end

include "controls/dmediaplayerhtml.lua"
include "controls/dhtmlcontrols.lua"
include "controls/dmediaplayerrequest.lua"
include "shared.lua"
include "cl_requests.lua"
include "cl_idlescreen.lua"
include "cl_screen.lua"

function MediaPlayer.Volume( volume )

	local cur = MediaPlayer.Cvars.Volume:GetFloat()

	if volume then

		-- Normalize volume
		volume = volume > 1 and volume/100 or volume

		-- Set volume convar
		RunConsoleCommand( "mediaplayer_volume", volume )

		-- Apply volume to all media players
		for _, mp in pairs( MediaPlayer.List ) do
			if mp:IsPlaying() then
				local media = mp:CurrentMedia()
				if media then
					media:Volume( volume )
				end
			end
		end

		hook.Run( MP.EVENTS.VOLUME_CHANGED, volume, cur )

		cur = volume

	end

	return cur

end

local muted = false
local previousVolume
function MediaPlayer.ToggleMute()
	if not muted then
		previousVolume = MediaPlayer.Volume()
	end

	local vol = muted and previousVolume or 0
	MediaPlayer.Volume( vol )
	muted = not muted
end

function MediaPlayer.Resolution( resolution )

	if resolution then
		resolution = math.Clamp( resolution, 16, 4096 )
		RunConsoleCommand( "mediaplayer_resolution", resolution )
	end

	return MediaPlayer.Cvars.Resolution:GetFloat()

end


--[[---------------------------------------------------------
	Utility functions
-----------------------------------------------------------]]

local FullscreenCvar = MediaPlayer.Cvars.Fullscreen

function MediaPlayer.SetBrowserSize( browser, w, h )

	local fullscreen = FullscreenCvar:GetBool()

	if fullscreen then
		w, h = ScrW(), ScrH()
	end

	browser:SetSize( w, h, fullscreen )

end

function MediaPlayer.OpenRequestMenu( mp )

	if ValidPanel(MediaPlayer._RequestMenu) then
		return
	end

	mp = MediaPlayer.GetByObject( mp )

	if not mp then
		Error( "MediaPlayer.OpenRequestMenu: Invalid media player.\n" )
		return
	end

	local req = vgui.Create( "MPRequestFrame" )
	req:SetMediaPlayer( mp )
	req:MakePopup()
	req:Center()

	req.OnClose = function()
		MediaPlayer._RequestMenu = nil
	end

	MediaPlayer._RequestMenu = req

end

function MediaPlayer.MenuRequest( url )

	local menu = MediaPlayer._RequestMenu

	if not ValidPanel(menu) then
		return
	end

	local mp = menu:GetMediaPlayer()

	menu:Close()

	MediaPlayer.Request( mp, url )

end


--[[---------------------------------------------------------
	Fonts
-----------------------------------------------------------]]

local common = {
	-- font		= "Open Sans Condensed",
	-- font		= "Oswald",
	font		= "Clear Sans Medium",
	antialias	= true,
	weight		= 400
}

surface.CreateFont( "MediaTitle", table.Merge(common, { size = 72 }) )
surface.CreateFont( "MediaRequestButton", table.Merge(common, { size = 26 }) )

--PATH lua/mediaplayer/controls/dmediaplayerrequest.lua:
local PANEL = {}
PANEL.HistoryWidth = 300
PANEL.BackgroundColor = Color(22, 22, 22)

local CloseTexture = Material( "theater/close.png" )

AccessorFunc( PANEL, "m_MediaPlayer", "MediaPlayer" )

function PANEL:Init()

	self:SetPaintBackgroundEnabled( true )
	self:SetFocusTopLevel( true )

	local w = math.Clamp( ScrW() - 100, 800, 1152 + self.HistoryWidth )
	local h = ScrH()
	if h > 800 then
		h = h * 3/4
	elseif h > 600 then
		h = h * 7/8
	end
	self:SetSize( w, h )

	self.CloseButton = vgui.Create( "DIconButton", self )
	self.CloseButton:SetSize( 32, 32 )
	self.CloseButton:SetIcon( "mp-close" )
	self.CloseButton:SetColor( Color( 250, 250, 250, 200 ) )
	self.CloseButton:SetZPos( 5 )
	self.CloseButton:SetText( "" )
	self.CloseButton.DoClick = function ( button )
		self:Close()
	end

	self.BrowserContainer = vgui.Create( "DPanel", self )
	self.BrowserContainer:Dock( FILL )

	self.Browser = vgui.Create( "DMediaPlayerHTML", self.BrowserContainer )
	self.Browser:Dock( FILL )

	self.Browser:AddFunction( "gmod", "requestUrl", function (url)
		MediaPlayer.MenuRequest( url )
		self:Close()
	end )

	self.Browser:AddFunction( "gmod", "openUrl", function (url)
		gui.OpenURL( url )
	end )

	self.Browser:AddFunction( "gmod", "getServices", function ()
		local mp = self.m_MediaPlayer

		if mp then
			self:SendServices( mp )
		end
	end )

	local requestUrl = MediaPlayer.GetConfigValue( 'request.url' )
	self.Browser:OpenURL( requestUrl )

	self.Controls = vgui.Create( "MPHTMLControls", self.BrowserContainer )
	self.Controls:Dock( TOP )
	self.Controls:DockPadding( 0, 0, 32, 0 )
	self.Controls:SetHTML( self.Browser )
	self.Controls.BorderSize = 0

	-- Listen for all mouse press events
	hook.Add( "GUIMousePressed", self, self.OnGUIMousePressed )

end

local function GetServiceIDs( mp )
	-- Send list of supported services to the request page for filtering out
	-- service icons
	local serviceIDs = mp:GetSupportedServiceIDs()
	serviceIDs = table.concat( serviceIDs, "," )

	return serviceIDs
end

function PANEL:SendServices( mp )
	local js = "if (typeof window.setServices === 'function') { setServices('%s'); }"
	js = js:format( GetServiceIDs(mp) )

	self.Browser:RunJavascript( js )
	self.Browser:QueueJavascript( js )
end

function PANEL:SetMediaPlayer( mp )
	self.m_MediaPlayer = mp

	self:SendServices( mp )
end

function PANEL:Paint( w, h )

	-- Draw background for fully transparent webpages
	surface.SetDrawColor( self.BackgroundColor )
	surface.DrawRect( 0, 0, w, h )

	return true

end

function PANEL:OnRemove()
	hook.Remove( "GUIMousePressed", self )
end

function PANEL:Close()
	if ValidPanel(self.Browser) then
		self.Browser:Remove()
	end

	self:OnClose()
	self:Remove()
end

function PANEL:OnClose()

end

function PANEL:CheckClose()

	local x, y = self:CursorPos()

	-- Remove panel if mouse is clicked outside of itself
	if not (gui.IsGameUIVisible() or gui.IsConsoleVisible()) and
		( x < 0 or x > self:GetWide() or y < 0 or y > self:GetTall() ) then
		self:Close()
	end

end

function PANEL:PerformLayout( w, h )

	self.CloseButton:SetPos( w - 36, 2 )

end

---
-- Close the panel when the mouse has been pressed outside of the panel.
--
function PANEL:OnGUIMousePressed( key )

	if key == MOUSE_LEFT then
		self:CheckClose()
	end

end

vgui.Register( "MPRequestFrame", PANEL, "EditablePanel" )

--PATH lua/mediaplayer/utils.lua:
if SERVER then AddCSLuaFile() end

local file = file
local math = math
local urllib = url
local ceil = math.ceil
local floor = math.floor
local Round = math.Round
local log = math.log
local pow = math.pow
local format = string.format
local tostring = tostring
local IsValid = IsValid


local utils = {}

---
-- Ceil the given number to the largest power of two.
--
function utils.CeilPower2(n)
	return pow(2, ceil(log(n) / log(2)))
end

---
-- Method for easily grabbing a value from a table without checking that each
-- fragment exists.
--
-- @param tbl Table
-- @param key e.g. "json.key.fragments"
--
function utils.TableLookup( tbl, key )
	local fragments = string.Split(key, '.')
	local value = tbl

	for _, fragment in ipairs(fragments) do
		value = value[fragment]

		if not value then
			return nil
		end
	end

	return value
end

---
-- Formats the number of seconds to a string.
-- e.g. 3612 => 24:12
--
function utils.FormatSeconds(sec)
	sec = Round(sec)

	local hours = floor(sec / 3600)
	local minutes = floor((sec % 3600) / 60)
	local seconds = sec % 60

	if minutes < 10 then
		minutes = "0" .. tostring(minutes)
	end

	if seconds < 10 then
		seconds = "0" .. tostring(seconds)
	end

	if hours > 0 then
		return format("%s:%s:%s", hours, minutes, seconds)
	else
		return format("%s:%s", minutes, seconds)
	end
end

-- https://github.com/xfbs/PiL3/blob/master/18MathLibrary/shuffle.lua
function utils.Shuffle(list)
    -- make and fill array of indices
    local indices = {}
    for i = 1, #list do
        indices[#indices+1] = i
    end

    -- create shuffled list
    local shuffled = {}
    for i = 1, #list do
        -- get a random index
        local index = math.random(#indices)

        -- get the value
        local value = list[indices[index]]

        -- remove it from the list so it won't be used again
        table.remove(indices, index)

        -- insert into shuffled array
        shuffled[#shuffled+1] = value
    end

    return shuffled
end

function utils.Retry( func, success, error, maxAttempts )

	maxAttempts = maxAttempts or 3
	local attempts = 1

	local function callback( value )
		if value then
			success( value )
		elseif attempts < maxAttempts then
			attempts = attempts + 1
			func( callback )
		else
			error()
		end
	end

	func( callback )

end

local function setTimeout( func, wait )
	local timerID = tostring( func )
	timer.Create( timerID, wait, 1, func )
	timer.Start( timerID )
	return timerID
end

local function clearTimeout( timerID )
	if timer.Exists( timerID ) then
		timer.Destroy( timerID )
	end
end

-- based on underscore.js' _.throttle function
function utils.Throttle( func, wait, options )
	wait = wait or 1
	options = options or {}

	local timeout, args, result
	local previous

	local function later()
		previous = (options.leading == false) and 0 or RealTime()
		timeout = nil
		result = func( unpack(args) )
		if not timeout then
			args = nil
		end
	end

	local function throttled(...)
		local now = RealTime()
		if not previous then
			previous = now
		end

		local remaining = wait - (now - previous)

		args = {...}

		if remaining <= 0 or remaining > wait then
			if timeout then
				clearTimeout(timeout)
				timeout = nil
			end

			previous = now
			result = func( unpack(args) )

			if not timeout then
				args = nil
			end
		elseif not timeout and options.trailing ~= false then
			timeout = setTimeout(later, remaining)
		end

		return result
	end

	return throttled
end

if CLIENT then

	local CeilPower2 = utils.CeilPower2
	local SetDrawColor = surface.SetDrawColor
	local SetMaterial = surface.SetMaterial
	local DrawTexturedRect = surface.DrawTexturedRect
	local DrawRect = surface.DrawRect

	local color_white = color_white

	function utils.DrawHTMLPanel( panel, w, h )
		if not (IsValid( panel ) and w and h) then return end

		panel:UpdateHTMLTexture()

		local pw, ph = panel:GetSize()

		-- Convert to scalar
		w = w / pw
		h = h / ph

		-- Fix for non-power-of-two html panel size
		pw = CeilPower2(pw)
		ph = CeilPower2(ph)

		SetDrawColor( color_white )

		local mat = panel:GetHTMLMaterial()

		if mat then
			SetMaterial( mat )
			DrawTexturedRect( 0, 0, w * pw, h * ph )
		else
			DrawRect( 0, 0, w * pw, h * ph )
		end
	end

	function utils.ParseHHMMSS( time )
	    local tbl = {}

		-- insert fragments in reverse
		for fragment, _ in string.gmatch(time, ":?(%d+)") do
			table.insert(tbl, 1, tonumber(fragment) or 0)
		end

		if #tbl == 0 then
			return nil
		end

		local seconds = 0

		for i = 1, #tbl do
			seconds = seconds + tbl[i] * math.max(60 ^ (i-1), 1)
		end

		return seconds
	end

	---
	-- Attempts to play uri from stream or local file and returns channel in
	-- callback.
	--
	function utils.LoadStreamChannel( uri, options, callback )
		local isLocalFile = false

		-- Play uri from a local file if:
		-- 1. Windows OS and path contains drive letter
		-- 2. Linux or OS X and path starts with a single '/'
		--
		-- We can't check this using file.Exists since GMod only allows checking
		-- within the GMod directory. However, sound.PlayFile will still load
		-- a file from any directory.
		if ( system.IsWindows() and uri:find("^%w:/") ) or
			( not system.IsWindows() and uri:find("^/[^/]") ) then
			isLocalFile = true

			local success, decoded = pcall(urllib.unescape, uri)
			if success then
				uri = decoded
			end
		end

		local playFunc = isLocalFile and sound.PlayFile or sound.PlayURL
		playFunc( uri, options or "noplay", function( channel )
			if IsValid( channel ) then
				callback( channel )
			else
				callback( nil )
			end
		end )
	end

end

_G.MediaPlayerUtils = utils

--PATH lua/mediaplayer/config/client.lua:
return gluapack()()
--PATH lua/mediaplayer/players/base/cl_init.lua:
return gluapack()()
--PATH lua/mediaplayer/services/browser.lua:
DEFINE_BASECLASS( "mp_service_base" )

SERVICE.Name 	= "Browser Base"
SERVICE.Id 		= "browser"
SERVICE.Abstract = true

if CLIENT then

	function SERVICE:GetBrowser()
		return self.Browser
	end

	function SERVICE:OnBrowserReady( browser )
		local resolution = MediaPlayer.Resolution()
		local w = resolution * 16/9
		local h = resolution

		if IsValid(self.Entity) then
			-- normalize resolution to the entity screen size
			local config = self.Entity:GetMediaPlayerConfig()
			local entwidth = config.width or w
			local entheight = config.height or resolution
			w = resolution * (entwidth / entheight)
		end

		MediaPlayer.SetBrowserSize( browser, w, h )

		-- Implement this in a child service
	end

	function SERVICE:SetVolume( volume )
		-- Implement this in a child service
	end

	function SERVICE:Volume( volume )
		local origVolume = volume

		volume = BaseClass.Volume( self, volume )

		if origVolume and ValidPanel( self.Browser ) then
			self:SetVolume( volume )
		end

		return volume
	end

	function SERVICE:Play()

		BaseClass.Play( self )

		if self.Browser and ValidPanel(self.Browser) then
			self:OnBrowserReady( self.Browser )
		else

			self._promise = browserpool.get(function( panel )

				if not panel then
					return
				end

				if self._promise then
					self._promise = nil
				end

				self.Browser = panel
				self:OnBrowserReady( panel )

			end)
		end

	end

	function SERVICE:Stop()
		BaseClass.Stop( self )

		if self._promise then
			self._promise:Cancel('Service has been stopped')
			self._promise = nil
		end

		if self.Browser then
			browserpool.release( self.Browser )
			self.Browser = nil
		end
	end

	local StartHtml = [[
	<!DOCTYPE html>
	<html>
	<head>
		<meta charset="utf-8">
		<title>Media Player</title>
		<style type="text/css">
		html, body {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
			overflow: hidden;
		}

		* { box-sizing: border-box }

		body {
			background-color: #282828;
			color: #cecece;
		}
		</style>
	</head>
	<body>
	]]

	local EndHtml = [[
	</body>
	</html>
	]]

	function SERVICE.WrapHTML( html )
		return table.concat({ StartHtml, html, EndHtml })
	end

	local JS_InjectScript = [[
(function () {
	var script = document.createElement('script');
	script.type = 'text/javascript';
	script.src = '%s';
	document.getElementsByTagName('head')[0].appendChild(script);
}());]]

	function SERVICE:InjectScript( uri )
		self.Browser:QueueJavascript( JS_InjectScript:format( uri ) )
	end

	function SERVICE:OnMousePressed( x, y )
		self.Browser:InjectMouseClick( x, y )
	end

	local SCROLL_MULTIPLIER = -80
	function SERVICE:OnMouseWheeled( scrollDelta )
		self.Browser:Scroll( scrollDelta * SCROLL_MULTIPLIER )
	end

	--[[---------------------------------------------------------
		Draw 3D2D
	-----------------------------------------------------------]]

	local ValidPanel = ValidPanel
	local SetDrawColor = surface.SetDrawColor
	local DrawRect = surface.DrawRect
	local DrawHTMLPanel = MediaPlayerUtils.DrawHTMLPanel

	function SERVICE:Draw( w, h )

		if ValidPanel(self.Browser) then
			SetDrawColor( 0, 0, 0, 255 )
			DrawRect( 0, 0, w, h )
			DrawHTMLPanel( self.Browser, w, h )
		end

	end

end

--PATH lua/mediaplayer/services/googledrive/shared.lua:
DEFINE_BASECLASS( "mp_service_base" )

SERVICE.Name 	= "Google Drive"
SERVICE.Id 		= "gd"
SERVICE.Base 	= "yt"

local GdFileIdPattern = "[%a%d-_]+"
local UrlSchemes = {
	"docs%.google%.com/file/d/" .. GdFileIdPattern .. "/",
	"drive%.google%.com/file/d/" .. GdFileIdPattern .. "/"
}

function SERVICE:New( url )
	local obj = BaseClass.New(self, url)
	obj._data = obj:GetGoogleDriveFileId()
	return obj
end

function SERVICE:Match( url )
	for _, pattern in pairs(UrlSchemes) do
		if string.find( url, pattern ) then
			return true
		end
	end
	return false
end

function SERVICE:IsTimed()
	return true
end

function SERVICE:GetGoogleDriveFileId()

	local videoId

	if self.videoId then

		videoId = self.videoId

	elseif self.urlinfo then

		local url = self.urlinfo

		-- https://docs.google.com/file/d/(videoId)
		if url.path and string.match(url.path, "^/file/d/([%a%d-_]+)") then
			videoId = string.match(url.path, "^/file/d/([%a%d-_]+)")
		end

		self.videoId = videoId

	end

	return videoId

end

-- Used for clientside inheritence of the YouTube service
SERVICE.GetYouTubeVideoId = GetGoogleDriveFileId

--PATH lua/mediaplayer/services/resource/shared.lua:
return gluapack()()
--PATH lua/mediaplayer/services/audiofile/cl_init.lua:
include "shared.lua"

DEFINE_BASECLASS( "mp_service_base" )

-- http://www.un4seen.com/doc/#bass/BASS_StreamCreateURL.html

SERVICE.StreamOptions = { "noplay", "noblock" }

local MAX_LOAD_ATTEMPTS = 3
local Audio3DCvar = MediaPlayer.Cvars.Audio3D

function SERVICE:Volume( volume )

	volume = BaseClass.Volume( self, volume )

	if IsValid(self.Channel) then
		local vol = volume > 1 and volume/100 or volume

		-- IGModAudioChannel is limited by the actual gmod volume
		-- local gmvolume = GetConVarNumber("volume")
		-- if gmvolume > vol then
		-- 	vol = vol / gmvolume
		-- else
		-- 	vol = 1
		-- end

		self.Channel:SetVolume( math.sqrt(vol) )
	end

	return volume

end

function SERVICE:Play()

	BaseClass.Play( self )

	if IsValid(self.Channel) then
		self.Channel:Play()
	else
		local settings = table.Copy(self.StreamOptions)

		-- .ogg files can't seem to use 3d?
		if Audio3DCvar:GetBool() and IsValid(self.Entity) and
				not self.url:match(".ogg") then
			table.insert(settings, "3d")
		end

		settings = table.concat(settings, " ")

		local function loadAudio( callback )
			if not self:IsPlaying() or IsValid( self.Channel ) then return end
			MediaPlayerUtils.LoadStreamChannel( self.url, settings, callback )
		end

		-- Loading audio can fail the first time, so let's retry a few times
		-- before giving up.
		MediaPlayerUtils.Retry(
			loadAudio,
			function( channel )
				self.Channel = channel

				-- The song may have been skipped before the channel was
				-- created, only play if the media state is set to play.
				if self:IsPlaying() then
					self:Volume()
					self:Sync()

					self.Channel:Play()
				end

				self:emit('channelReady', channel)
			end,
			function()
				local msg = ("Failed to load media player audio '%s'"):format( self.url )
				LocalPlayer():ChatPrint( msg )
			end,
			MAX_LOAD_ATTEMPTS
		)
	end

end

function SERVICE:Pause()
	BaseClass.Pause(self)

	if IsValid(self.Channel) then
		self.Channel:Pause()
	end
end

function SERVICE:Stop()
	BaseClass.Stop(self)

	if IsValid(self.Channel) then
		self.Channel:Stop()
	end
end

function SERVICE:Sync()
	if self:IsPlaying() and IsValid(self.Channel) then
		if self:IsTimed() then
			self:SyncTime()
		end

		self:SyncEntityPos()
	end
end

function SERVICE:SyncTime()
	local state = self.Channel:GetState()

	if state ~= GMOD_CHANNEL_STALLED then
		local duration = self.Channel:GetLength()
		local seekTime = math.min(duration, self:CurrentTime())
		local curTime = self.Channel:GetTime()
		local diffTime = math.abs(curTime - seekTime)

		if diffTime > 5 then
			self.Channel:SetTime( seekTime )
		end
	end
end

function SERVICE:SyncEntityPos()
	if IsValid(self.Entity) then

		if self.Channel:Is3D() then
			-- apparently these are the default values?
			self.Channel:Set3DFadeDistance( 500, 1000 )

			self.Channel:SetPos( self.Entity:GetPos() )
		else
			-- TODO: Fake 3D volume
			-- http://facepunch.com/showthread.php?t=1302124&p=41975238&viewfull=1#post41975238

			-- local volume = BaseClass.Volume( self, volume )
			-- local vol = volume > 1 and volume/100 or volume
			-- self.Channel:SetVolume( vol )
		end

	end
end



function SERVICE:PreRequest( callback )

	local function preload( callback )
		MediaPlayerUtils.LoadStreamChannel( self.url, nil, callback )
	end

	-- Preloading audio can fail the first time, so let's retry a few times
	-- before giving up.
	MediaPlayerUtils.Retry(
		preload,
		function( channel )
			-- Set metadata to later send to the server; IGModAudioChannel is
			-- only accessible on the client.
			self:SetMetadataValue( "title", channel:GetFileName() )
			self:SetMetadataValue( "duration", channel:GetLength() )

			channel:Stop()
			callback()
		end,
		function()
			callback( "There was a problem receiving the audio stream, please try again." )
		end,
		MAX_LOAD_ATTEMPTS
	)

end

function SERVICE:NetWriteRequest()
	net.WriteString( self:Title() )
	net.WriteUInt( self:Duration(), 16 )
end

--[[---------------------------------------------------------
	Draw 3D2D
-----------------------------------------------------------]]

local IsValid = IsValid
local draw = draw
local math = math
local surface = surface

local VisualizerBgColor = Color(44, 62, 80, 255)
local VisualizerBarColor = Color(52, 152, 219)
local VisualizerBarAlpha = 220

local BANDS	= 28

local function DrawSpectrumAnalyzer( fft, w, h )

	local b0 = 1
	local x, y

	for x = 0, BANDS do
		local sum = 0
		local sc = 0
		local b1 = math.pow(2,x*10.0/(BANDS-1))

		if (b1>1023) then b1=1023 end
		if (b1<=b0) then b1=b0+1 end
		sc=10+b1-b0;
		while b0 < b1 do
			sum = sum + fft[b0]
			b0 = b0 + 1
		end

		y = (math.sqrt(sum/math.log10(sc))*1.7*h)-4
		y = math.Clamp(y, 0, h)

		local col = HSVToColor( 120 - (120 * y/h), 1, 1 )
		col.a = VisualizerBarAlpha
		surface.SetDrawColor(col)

		surface.DrawRect(
			math.ceil(x*(w/BANDS)),
			math.ceil(h - y - 1),
			math.ceil(w/BANDS) - 2,
			y + 1
		)
	end

end


local HTMLMaterial = HTMLMaterial
local color_white = color_white
local FFT_2048 = FFT_2048
local GMOD_CHANNEL_PLAYING = GMOD_CHANNEL_PLAYING

local HTMLMAT_STYLE_ARTWORK = 'htmlmat.style.artwork'
AddHTMLMaterialStyle( HTMLMAT_STYLE_ARTWORK, {
	width = 720,
	height = 480
}, HTMLMAT_STYLE_COVER )

function SERVICE:Draw( w, h )

	surface.SetDrawColor( VisualizerBgColor )
	surface.DrawRect( 0, 0, w, h )

	local thumbnail = self:Thumbnail()
	if thumbnail then
		DrawHTMLMaterial( thumbnail, HTMLMAT_STYLE_ARTWORK, w, h )
	end

	local channel = self.Channel
	if IsValid(channel) and channel:GetState() == GMOD_CHANNEL_PLAYING then
		local fft = {}
		channel:FFT( fft, FFT_2048 )
		
		-- exposed on the table in case anyone wants to use this
		self.fft = fft
		
		DrawSpectrumAnalyzer( fft, w, h )
	end
	
	self:PostDraw()

end

function SERVICE:PostDraw()
	-- override this
end

--PATH lua/mediaplayer/services/shoutcast.lua:
SERVICE.Name	= "SHOUTcast"
SERVICE.Id		= "shc"
SERVICE.Base	= "af"

-- DEFINE_BASECLASS( "mp_service_af" )

local StationUrlPattern = "yp.shoutcast.com/sbin/tunein%-station%.pls%?id=%d+"

function SERVICE:Match( url )
	return url:match( StationUrlPattern )
end

function SERVICE:IsTimed()
	return false
end

--PATH lua/mediaplayer/cl_requests.lua:
local function GetMediaPlayerId( obj )
	local mpId

	-- Determine mp parameter type and get the associated ID.
	if isentity(obj) and obj.IsMediaPlayerEntity then
		mpId = obj:GetMediaPlayerID()
	-- elseif isentity(obj) and IsValid( obj:GetMediaPlayer() ) then
	-- 	local mp = mp:GetMediaPlayer()
	-- 	mpId = mp:GetId()
	elseif istable(obj) and obj.IsMediaPlayer then
		mpId = obj:GetId()
	elseif isstring(obj) then
		mpId = obj
	else
		return false -- Invalid parameters
	end

	return mpId
end

---
-- Request to begin listening to a media player.
--
-- @param Entity|Table|String	Media player reference.
--
function MediaPlayer.RequestListen( obj )

	local mpId = GetMediaPlayerId(obj)
	if not mpId then return end

	net.Start( "MEDIAPLAYER.RequestListen" )
		net.WriteString( mpId )
	net.SendToServer()

end

---
-- Request mediaplayer update.
--
-- @param Entity|Table|String	Media player reference.
--
function MediaPlayer.RequestUpdate( obj )

	local mpId = GetMediaPlayerId(obj)
	if not mpId then return end

	net.Start( "MEDIAPLAYER.RequestUpdate" )
		net.WriteString( mpId )
	net.SendToServer()

end

---
-- Request a URL to be played on the given media player.
--
-- @param Entity|Table|String	Media player reference.
-- @param String				Requested media URL.
--
function MediaPlayer.Request( obj, url )

	local mpId = GetMediaPlayerId( obj )
	if not mpId then return end

	if MediaPlayer.DEBUG then
		print("MEDIAPLAYER.Request:", url, mpId)
	end

	local mp = MediaPlayer.GetById( mpId )

	local allowWebpage = MediaPlayer.Cvars.AllowWebpages:GetBool()

	-- Verify valid URL as to not waste time networking
	if not MediaPlayer.ValidUrl( url ) and not allowWebpage then
		LocalPlayer():ChatPrint("The requested URL was invalid.")
		return false
	end

	local media = MediaPlayer.GetMediaForUrl( url, allowWebpage )

	local function request( err )
		if err then
			-- TODO: don't use chatprint to notify the user
			LocalPlayer():ChatPrint( "Request failed: " .. err )
			return
		end

		if not IsValid( mp ) then
			-- media player may have been removed before we could finish the
			-- async prerequest action
			return
		end

		net.Start( "MEDIAPLAYER.RequestMedia" )
			net.WriteString( mpId )
			net.WriteString( url )
			media:NetWriteRequest() -- send any additional data
		net.SendToServer()

		if MediaPlayer.DEBUG then
			print("MEDIAPLAYER.Request sent to server")
		end
	end

	-- Prepare any data prior to requesting if necessary
	if media.PrefetchMetadata then
		media:PreRequest(request) -- async
	else
		request() -- sync
	end

end

function MediaPlayer.Pause( mp )

	local mpId = GetMediaPlayerId( mp )
	if not mpId then return end

	net.Start( "MEDIAPLAYER.RequestPause" )
		net.WriteString( mpId )
	net.SendToServer()

end

function MediaPlayer.Skip( mp )

	local mpId = GetMediaPlayerId( mp )
	if not mpId then return end

	net.Start( "MEDIAPLAYER.RequestSkip" )
		net.WriteString( mpId )
	net.SendToServer()

end

---
-- Seek to a specific time in the current media.
--
-- @param Entity|Table|String	Media player reference.
-- @param String				Seek time; HH:MM:SS
--
function MediaPlayer.Seek( mp, time )

	local mpId = GetMediaPlayerId( mp )
	if not mpId then return end

	-- always convert to time in seconds before sending
	if type(time) == 'string' then
		time = MediaPlayerUtils.ParseHHMMSS(time) or 0
	end

	net.Start( "MEDIAPLAYER.RequestSeek" )
		net.WriteString( mpId )
		net.WriteInt( time, 32 )
	net.SendToServer()

end

---
-- Remove the given media.
--
-- @param Entity|Table|String	Media player reference.
-- @param String				Media unique ID.
--
function MediaPlayer.RequestRemove( mp, mediaUID )

	local mpId = GetMediaPlayerId( mp )
	if not mpId then return end

	net.Start( "MEDIAPLAYER.RequestRemove" )
		net.WriteString( mpId )
		net.WriteString( mediaUID )
	net.SendToServer()

end

function MediaPlayer.RequestRepeat( mp )

	local mpId = GetMediaPlayerId( mp )
	if not mpId then return end

	net.Start( "MEDIAPLAYER.RequestRepeat" )
		net.WriteString( mpId )
	net.SendToServer()

end

function MediaPlayer.RequestShuffle( mp )

	local mpId = GetMediaPlayerId( mp )
	if not mpId then return end

	net.Start( "MEDIAPLAYER.RequestShuffle" )
		net.WriteString( mpId )
	net.SendToServer()

end

function MediaPlayer.RequestLock( mp )

	local mpId = GetMediaPlayerId( mp )
	if not mpId then return end

	net.Start( "MEDIAPLAYER.RequestLock" )
		net.WriteString( mpId )
	net.SendToServer()

end

--PATH lua/autorun/menubar/mp_options.lua:
return gluapack()()
--PATH lua/autorun/sandbox/mediaplayer_dupe.lua:
return gluapack()()
--PATH lua/autorun/sandbox/mediaplayer_dupe.lua:
local MEDIAPLAYER_DUPE = nil
local MEDIAPLAYER_SAVE = false
local MEDIAPLAYER_THUMBNAIL = nil

local HTMLMAT_STYLE_DUPE = "htmlmat.style.dupe"
-- AddHTMLMaterialStyle( HTMLMAT_STYLE_DUPE, {
-- 	width = 512,
-- 	height = 512,
-- 	css = [[
-- img {
-- 	width: 100%;
-- 	position: absolute;
-- 	top: 50%;
-- 	left: 50%;
-- 	-webkit-filter: blur(6px);
-- 	-webkit-transform: translate(-50%, -50%) scale(1.1,1.1);
-- }]]
-- } )
AddHTMLMaterialStyle( HTMLMAT_STYLE_DUPE, {
	width = 512,
	height = 512,
	css = [[
img {
	-webkit-filter: blur(6px) brightness(0.9);
	-webkit-transform: translate(-50%, -50%) scale(1.05, 1.05);
}]]
}, HTMLMAT_STYLE_COVER_IMG )

surface.CreateFont( "DupeMediaText", {
	font		= "Clear Sans Medium",
	antialias	= true,
	weight		= 400,
	size        = 80
} )

local function PreSaveMediaPlayerDupe( Dupe )

	local mediaplayers = {}

	for _, ent in pairs( Dupe.Entities or {} ) do
		if ent.IsMediaPlayerEntity then
			table.insert( mediaplayers, ent )
		end
	end

	local mp = mediaplayers[1]
	local snapshot = mp.MediaPlayerSnapshot

	local media = snapshot.media
	local metadata = media and media._metadata
	local thumbnail = metadata and metadata.thumbnail

	if thumbnail then
		HTMLMaterial( thumbnail, HTMLMAT_STYLE_DUPE, function( material )
			MEDIAPLAYER_THUMBNAIL = material
			MEDIAPLAYER_SAVE = true
		end )
	else
		MEDIAPLAYER_THUMBNAIL = Material( "gui/dupe_bg.png" )
		MEDIAPLAYER_SAVE = true
	end

end

local function DrawOutlinedText(text, font, x, y, colour, xalign, yalign)
	local outlineColor = Color(0,0,0,colour.a)
	draw.SimpleText(text, font, x, y + 2, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x + 1, y + 2, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x - 1, y + 2, outlineColor, xalign, yalign)

	draw.SimpleText(text, font, x, y - 2, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x + 1, y - 2, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x - 1, y - 2, outlineColor, xalign, yalign)

	draw.SimpleText(text, font, x + 2, y + 2, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x + 2, y + 1, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x + 2, y - 1, outlineColor, xalign, yalign)

	draw.SimpleText(text, font, x - 2, y + 2, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x - 2, y + 1, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x - 2, y - 1, outlineColor, xalign, yalign)

	draw.SimpleText(text, font, x, y, colour, xalign, yalign)
end

local function RenderMediaPlayerDupe( Dupe )

	local FOV = 17

	--
	-- This is gonna take some cunning to look awesome!
	--
	local Size		= Dupe.Maxs - Dupe.Mins;
	local Radius	= Size:Length() * 0.5;
	local CamDist	= Radius / math.sin( math.rad( FOV ) / 2 ) -- Works out how far the camera has to be away based on radius + fov!
	local Center	= LerpVector( 0.5, Dupe.Mins, Dupe.Maxs );
	local CamPos	= Center + Vector( -1, 0, 0.5 ):GetNormal() * CamDist;
	local EyeAng	= ( Center - CamPos ):GetNormal():Angle();

	--
	-- The base view
	--
	local view =
	{
		type		= "3D",
		origin		= CamPos,
		angles		= EyeAng,
		x			= 0,
		y			= 0,
		w			= 512,
		h			= 512,
		aspect		= 1,
		fov			= FOV
	}

	--
	-- Create a bunch of entities we're gonna use to render.
	--
	local entities = {}

	for k, v in pairs( Dupe.Entities ) do

		local ent

		if ( v.Class == "prop_ragdoll" ) then

			ent = ClientsideRagdoll( v.Model or "error.mdl", RENDERGROUP_OTHER )

			if ( istable( v.PhysicsObjects ) ) then

				for boneid, v in pairs( v.PhysicsObjects ) do

					local obj = ent:GetPhysicsObjectNum( boneid )
					if ( IsValid( obj ) ) then
						obj:SetPos( v.Pos )
						obj:SetAngles( v.Angle )
					end

				end

				ent:InvalidateBoneCache()

			end

		elseif v.IsMediaPlayerEntity then

			ent = ClientsideModel( v.Model or "error.mdl", RENDERGROUP_OTHER )
			ent.PlayerConfig = v.PlayerConfig

			local mp = MediaPlayer.GetById( v.DT.MediaPlayerID )
			if mp and mp:GetType() == "entity" then
				mp._oldent = mp.Entity
				mp.Entity = ent
			end

		end

		entities[k] = ent

	end


	--
	-- DRAW THE BACKGROUND
	--
	render.SetMaterial( Material( "gui/dupe_bg.png" ) )
	render.DrawScreenQuadEx( 0, 0, 512, 512 )

	render.SetMaterial( MEDIAPLAYER_THUMBNAIL )
	render.DrawScreenQuadEx( 0, 0, 512, 512 )
	render.SuppressEngineLighting( true )

	--
	-- BLACK OUTLINE
	-- AWESOME BRUTE FORCE METHOD
	--
	render.SuppressEngineLighting( true )

	local BorderSize	= CamDist * 0.004
	local Up			= EyeAng:Up() * BorderSize
	local Right			= EyeAng:Right() * BorderSize

	render.SetColorModulation( 1, 1, 1, 1 )
	render.MaterialOverride( Material( "models/debug/debugwhite" ) )

	-- Render each entity in a circle
	for k, v in pairs( Dupe.Entities ) do

		for i=0, math.pi*2, 0.2 do

			view.origin = CamPos + Up * math.sin( i ) + Right * math.cos( i )

			cam.Start( view )

				render.Model(
				{
					model	=	v.Model,
					pos		=	v.Pos,
					angle	=	v.Angle,

				}, entities[k] )

			cam.End()

		end

	end

	-- Because ee just messed up the depth
	render.ClearDepth()
	render.SetColorModulation( 0, 0, 0, 1 )

	-- Try to keep the border size consistent with zoom size
	local BorderSize	= CamDist * 0.002
	local Up			= EyeAng:Up() * BorderSize
	local Right			= EyeAng:Right() * BorderSize

	-- Render each entity in a circle
	for k, v in pairs( Dupe.Entities ) do

		for i=0, math.pi*2, 0.2 do

			view.origin = CamPos + Up * math.sin( i ) + Right * math.cos( i )
			cam.Start( view )

			render.Model(
			{
				model	=	v.Model,
				pos		=	v.Pos,
				angle	=	v.Angle,
				skin	=	v.Skin
			}, entities[k] )

			cam.End()

		end

	end

	--
	-- ACUAL RENDER!
	--

	-- We just fucked the depth up - so clean it
	render.ClearDepth()

	-- Set up the lighting. This is over-bright on purpose - to make the ents pop
	render.SetModelLighting( 0, 0, 0, 0 )
	render.SetModelLighting( 1, 2, 2, 2 )
	render.SetModelLighting( 2, 3, 2, 0 )
	render.SetModelLighting( 3, 0.5, 2.0, 2.5 )
	render.SetModelLighting( 4, 3, 3, 3 ) -- top
	render.SetModelLighting( 5, 0, 0, 0 )
	render.MaterialOverride( nil )

	view.origin = CamPos
	cam.Start( view )

	-- Render each model
	for k, v in pairs( Dupe.Entities ) do

		render.SetColorModulation( 1, 1, 1, 1 )

		if ( istable( v.EntityMods ) ) then

			if ( istable( v.EntityMods.colour ) ) then
				render.SetColorModulation( v.EntityMods.colour.Color.r/255, v.EntityMods.colour.Color.g/255, v.EntityMods.colour.Color.b/255, v.EntityMods.colour.Color.a/255 )
			end

			if ( istable( v.EntityMods.material ) ) then
				render.MaterialOverride( Material( v.EntityMods.material.MaterialOverride ) )
			end

		end

		local ent = entities[k]

		render.Model(
		{
			model	=	v.Model,
			pos		=	v.Pos,
			angle	=	v.Angle,
			skin	=	v.Skin
		}, ent )

		if v.IsMediaPlayerEntity then

			local mp = MediaPlayer.GetById( v.DT.MediaPlayerID )
			if mp then
				mp:Draw( true, false )
				mp.Entity = mp._oldent
			else
				local w, h, pos, ang = ent:GetMediaPlayerPosition()
				cam.Start3D2D( pos, ang, 1 )
					surface.SetDrawColor( color_white )
					surface.SetMaterial( Material( "theater/STATIC" ) )
					surface.DrawTexturedRect( 0, 0, w, h )
				cam.End3D2D()
			end

		end

		render.MaterialOverride( nil )

	end

	cam.End()

	-- Enable lighting again (or it will affect outside of this loop!)
	render.SuppressEngineLighting( false )
	render.SetColorModulation( 1, 1, 1, 1 )

	--
	-- Finished with the entities - remove them all
	--
	for k, v in pairs( entities ) do
		v:Remove()
	end

	--
	-- Media Player branding
	--
	cam.Start2D()
		DrawOutlinedText( "MEDIA PLAYER", "DupeMediaText", 512/2, 512 - 34,
			color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	cam.End2D()

	local jpegdata = render.Capture{
		format		=	"jpeg",
		x			=	0,
		y			=	0,
		w			=	512,
		h			=	512,
		quality		=	100
	}

	return jpegdata

end

local function SaveMediaPlayerDupe( Dupe, jpegdata )

	--
	-- Encode and compress the dupe
	--
	local Dupe = util.TableToJSON( Dupe )
	if ( !isstring( Dupe ) ) then
		Msg( "There was an error converting the dupe to a json string" );
	end

	Dupe = util.Compress( Dupe )

	--
	-- And save it! (filename is automatic md5 in dupes/)
	--
	if ( engine.WriteDupe( Dupe, jpegdata ) ) then

		-- Disable the save button!!
		hook.Run( "DupeSaveUnavailable" )
		hook.Run( "DupeSaved" )

		MsgN( "Saved!" )

		-- TODO: Open tab and show dupe!

	end

end

hook.Add( "PostRenderVGUI", "MediaPlayerDupe", function()

	if not g_ClientSaveDupe then return end
	local isMediaDupe = false

	for _, ent in pairs( g_ClientSaveDupe.Entities or {} ) do
		if ent.IsMediaPlayerEntity then
			isMediaDupe = true
			break
		end
	end

	if isMediaDupe then
		MEDIAPLAYER_DUPE = g_ClientSaveDupe
		g_ClientSaveDupe = nil

		PreSaveMediaPlayerDupe( MEDIAPLAYER_DUPE )
	end

end )

hook.Add( "PostRender", "MediaPlayerDupe", function()

	if not ( MEDIAPLAYER_DUPE and MEDIAPLAYER_SAVE ) then return end

	local jpeg = RenderMediaPlayerDupe( MEDIAPLAYER_DUPE )
	SaveMediaPlayerDupe( MEDIAPLAYER_DUPE, jpeg )

	MEDIAPLAYER_DUPE = nil
	MEDIAPLAYER_SAVE = false

end )


--PATH addons/[ui] msd_ui/lua/msd/ui/msdmdlmenu.lua:
local PANEL = {}

AccessorFunc( PANEL, "m_fAnimSpeed",	"AnimSpeed" )
AccessorFunc( PANEL, "Entity",			"Entity" )
AccessorFunc( PANEL, "vCamPos",			"CamPos" )
AccessorFunc( PANEL, "fFOV",			"FOV" )
AccessorFunc( PANEL, "vLookatPos",		"LookAt" )
AccessorFunc( PANEL, "aLookAngle",		"LookAng" )
AccessorFunc( PANEL, "colAmbientLight",	"AmbientLight" )
AccessorFunc( PANEL, "colColor",		"Color" )
AccessorFunc( PANEL, "bAnimated",		"Animated" )

function PANEL:Init()

	self.Entity = nil
	self.SubEntitys = {}
	self.LastPaint = 0
	self.DirectionalLight = {}
	self.FarZ = 4096
	self.Angles = Angle(0, 0, 0)

	self:SetCamPos( Vector(0, 0, 0) )
	self:SetLookAt( Vector(-100, 0, -22) )
	self:SetFOV( 50 )

	self:SetText( "" )
	self:SetAnimSpeed( 0.5 )
	self:SetAnimated( true )

	self:SetAmbientLight( Color( 50, 50, 50 ) )

	self:SetDirectionalLight( BOX_TOP, Color( 255, 255, 255 ) )
	self:SetDirectionalLight( BOX_FRONT, Color( 255, 255, 255 ) )

	self:SetDirectionalLight(BOX_RIGHT, Color(255, 160, 80, 255))
	self:SetDirectionalLight(BOX_LEFT, Color(80, 160, 255, 255))

	self:SetColor( Color( 255, 255, 255, 255 ) )

end

function PANEL:SetDirectionalLight( iDirection, color )
	self.DirectionalLight[ iDirection ] = color
end

function PANEL:SetModel( strModelName )
	if ( IsValid( self.Entity ) ) then
		self.Entity:Remove()
		self.Entity = nil
	end

	if ( !ClientsideModel ) then return end

	self.Entity = ClientsideModel( strModelName, RENDERGROUP_OTHER )
	if ( !IsValid( self.Entity ) ) then return end

	self.Entity:SetNoDraw( true )
	self.Entity:SetIK( false )

	local iSeq = self.Entity:LookupSequence( "walk_all" )
	if ( iSeq <= 0 ) then iSeq = self.Entity:LookupSequence( "WalkUnarmed_all" ) end
	if ( iSeq <= 0 ) then iSeq = self.Entity:LookupSequence( "walk_all_moderate" ) end

	if ( iSeq > 0 ) then self.Entity:ResetSequence( iSeq ) end

end

function PANEL:GetModel()

	if ( !IsValid( self.Entity ) ) then return end

	return self.Entity:GetModel()

end

function PANEL:DrawModel()

	local curparent = self
	local leftx, topy = self:LocalToScreen( 0, 0 )
	local rightx, bottomy = self:LocalToScreen( self:GetWide(), self:GetTall() )
	while ( curparent:GetParent() != nil ) do
		curparent = curparent:GetParent()

		local x1, y1 = curparent:LocalToScreen( 0, 0 )
		local x2, y2 = curparent:LocalToScreen( curparent:GetWide(), curparent:GetTall() )

		leftx = math.max( leftx, x1 )
		topy = math.max( topy, y1 )
		rightx = math.min( rightx, x2 )
		bottomy = math.min( bottomy, y2 )
		previous = curparent
	end

	render.SetScissorRect( leftx, topy, rightx, bottomy, true )

	local ret = self:PreDrawModel( self.Entity )
	if ( ret != false ) then
		self.Entity:DrawModel()

		for k,v in pairs(self.SubEntitys) do
			if IsValid(v) then
				v:DrawModel()
				if v.bone and isnumber(v.bone) then
					local pos, ang = MCS.GetBoneOrientation(self.Entity, v.bone, v.pos, v.ang)
					ang:RotateAroundAxis(ang:Up(), v.ang.y)
					ang:RotateAroundAxis(ang:Right(), v.ang.p)
					ang:RotateAroundAxis(ang:Forward(), v.ang.r)
					v:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z)
					v:SetAngles(ang)
				end
			end
		end

		self:PostDrawModel( self.Entity )
	end

	render.SetScissorRect( 0, 0, 0, 0, false )

end

function PANEL:PreDrawModel( ent )
	return true
end

function PANEL:PostDrawModel( ent )

end

function PANEL:DragMousePress()
	self.PressX, self.PressY = gui.MousePos()
	self.Pressed = true
end

function PANEL:DoDoubleClick()
	if self:GetFOV() < 10 then
		self:SetFOV(50)
	else
		self:SetFOV(self:GetFOV() - 5)
	end
end

function PANEL:DragMouseRelease()
	self.Pressed = false
end

function PANEL:Paint( w, h )

	if ( !IsValid( self.Entity ) ) then return end

	local x, y = self:LocalToScreen( 0, 0 )

	self:LayoutEntity( self.Entity )

	local ang = self.aLookAngle
	if ( !ang ) then
		ang = ( self.vLookatPos - self.vCamPos ):Angle()
	end

	cam.Start3D( self.vCamPos, ang, self.fFOV, x, y, w, h, 5, self.FarZ )

	render.SuppressEngineLighting( true )
	render.SetLightingOrigin( self.Entity:GetPos() )
	render.ResetModelLighting( self.colAmbientLight.r / 255, self.colAmbientLight.g / 255, self.colAmbientLight.b / 255 )
	render.SetColorModulation( self.colColor.r / 255, self.colColor.g / 255, self.colColor.b / 255 )
	render.SetBlend( ( self:GetAlpha() / 255 ) * ( self.colColor.a / 255 ) ) -- * surface.GetAlphaMultiplier()

	for i = 0, 6 do
		local col = self.DirectionalLight[ i ]
		if ( col ) then
			render.SetModelLighting( i, col.r / 255, col.g / 255, col.b / 255 )
		end
	end

	self:DrawModel()

	render.SuppressEngineLighting( false )
	cam.End3D()

	self.LastPaint = RealTime()

end

function PANEL:RunAnimation()
	self.Entity:FrameAdvance( ( RealTime() - self.LastPaint ) * self.m_fAnimSpeed )
end

function PANEL:StartScene( name )

	if ( IsValid( self.Scene ) ) then
		self.Scene:Remove()
	end

	self.Scene = ClientsideScene( name, self.Entity )
end

function PANEL:LayoutEntity(ent)
	if (self.bAnimated) then
		self:RunAnimation()
	end

	if (self.Pressed) then
		local mx = gui.MousePos()
		self.Angles = self.Angles - Angle(0, (self.PressX or mx) - mx, 0)
		self.PressX, self.PressY = gui.MousePos()
	end

	ent:SetAngles(self.Angles)
end

function PANEL:OnRemove()
	if ( IsValid( self.Entity ) ) then
		self.Entity:Remove()
	end

	for k,v in pairs(self.SubEntitys) do
		if IsValid(v) then
			v:Remove()
		end
	end

end

function PANEL:GenerateExample( ClassName, PropertySheet, Width, Height )

	local ctrl = vgui.Create( ClassName )
	ctrl:SetSize( 300, 300 )
	ctrl:SetModel( "models/props_junk/PlasticCrate01a.mdl" )
	ctrl:GetEntity():SetSkin( 2 )

	PropertySheet:AddSheet( ClassName, ctrl, nil, true, true )

end

derma.DefineControl( "MSDModelPanel", "A panel containing a model but more epic", PANEL, "DButton" )
--PATH lua/mvp/core/sh_loader.lua:
--- This is a loader for the Terminal framework.
-- This simply loads all the necessary files for the framework to work.
--
-- @module mvp.loader
mvp = mvp or {}
mvp.loader = {}
mvp.loader.relativePath = "mvp/"

mvp.loader.Print = function(...)
    if (not mvp.logger or not mvp.logger.isReady) then
        MsgC(Color(0, 168, 255), "[MVP]", Color(225, 177, 44), "[Loader] ", Color(255, 255, 255), ...)
        MsgC("\n")
        
        return
    end

    mvp.logger.Log(mvp.LOG.DEBUG, "Loader", ...)
end

--- Sends a file to client and loads it on server.
-- This function supposed to be called *only* on SHARED realm, otherwise it will not work properly.
--
-- @realm shared
-- @tparam string path Path to the file
-- @usage mvp.loader.LoadClientFile("mvp/modules/terminal/sh_terminal.lua")
function mvp.loader.LoadClientFile(path)
    if (SERVER) then
        AddCSLuaFile(path)
    else
        include(path)
    end

    mvp.loader.Print(Color(255, 174, 0), "", color_white, " Loaded ", Color(255, 174, 0), "CL", Color(255, 255, 255), " file: ", path)
end

--- Loads a file on server.
-- This function supposed to be called *only* on SERVER realm, if called on CLIENT - nothing will happen.
-- Can be called on SHARED realm, but it will not be sent to client and will be loaded only on server.
--
-- @realm shared
-- @tparam string path Path to the file
-- @usage mvp.loader.LoadServerFile("mvp/modules/terminal/sv_terminal.lua")
function mvp.loader.LoadServerFile(path)
    if (CLIENT) then return end

    include(path)

    mvp.loader.Print(Color(0, 102, 255), "", color_white, " Loaded ", Color(0, 102, 255), "SV", Color(255, 255, 255), " file: ", path)
end

--- Sends a file to client and loads it on both server and client.
-- This function supposed to be called *only* on SHARED realm, otherwise it will not work properly.
--
-- @realm shared
-- @tparam string path Path to the file
-- @usage mvp.loader.LoadSharedFile("mvp/modules/terminal/sh_terminal.lua")
function mvp.loader.LoadSharedFile(path)
    if (SERVER) then
        AddCSLuaFile(path)
    end
    include(path)

    mvp.loader.Print(Color(255, 174, 0), "", Color(0, 102, 255), "", color_white, " Loaded ", Color(255, 174, 0), "S", Color(0, 102, 255), "H", Color(255, 255, 255), " file: ", path)
end

--- Loads a file.
-- This function supposed to be called *only* on SHARED realm, otherwise it will not work properly.
--
-- @realm shared
-- @tparam string path Path to the file
-- @tparam[opt=shared] string forcedRealm Realm to load the file on. Can be "client", "server", otherwise it will be treated as "shared"
-- @tparam[opt=false] bool fromLua If true, then the path will be treated as a path from lua/ folder, otherwise it will be treated as a path from mvp/ folder
--
-- @usage mvp.loader.LoadFile("mvp/modules/terminal/sh_terminal.lua")
-- @usage mvp.loader.LoadFile("terminal/sh_terminal.lua", "client") -- will load the file on client
-- @usage mvp.loader.LoadFile("terminal/sh_terminal.lua", "server") -- will load the file on server
function mvp.loader.LoadFile(path, forcedRealm, fromLua)
    path = (fromLua and '' or mvp.loader.relativePath) .. path
    
    if (forcedRealm != nil) then
        forcedRealm = string.lower(forcedRealm)
    end

    if (forcedRealm == "client" or path:find("cl_")) then
        mvp.loader.LoadClientFile(path)
    elseif (forcedRealm == "server" or path:find("sv_")) then
        mvp.loader.LoadServerFile(path)
    else -- shared
        mvp.loader.LoadSharedFile(path)
    end
end

--- Loads a folder.
-- This function supposed to be called *only* on SHARED realm, otherwise it will not work properly.
--
-- @realm shared
-- @tparam string path Path to the folder
-- @tparam[opt=false] bool recursive If true, then the function will load all the files in the folder recursively
-- @tparam[opt=false] bool fromLua If true, then the path will be treated as a path from lua/ folder, otherwise it will be treated as a path from mvp/ folder
--
-- @usage mvp.loader.LoadFolder("mvp/modules/terminal/")
-- @usage mvp.loader.LoadFolder("terminal/", true) -- will load all the files in the folder recursively
function mvp.loader.LoadFolder(path, recursive, fromLua)
    path = (fromLua and '' or mvp.loader.relativePath) .. path

    if (not string.EndsWith(path, ".lua") and not string.EndsWith(path, "/")) then
        path = path .. "/"
    end

    local files, folders = file.Find(path .. "*", "LUA")

    for _, fileName in ipairs(files) do
        mvp.loader.LoadFile(path .. fileName, nil, true)
    end

    if (recursive) then
        for _, folderName in ipairs(folders) do
            mvp.loader.LoadFolder(path .. folderName .. "/", true, true)
        end
    end
end
--PATH lua/mvp/core/sh_permissions.lua:
return gluapack()()
--PATH lua/mvp/core/ui/cl_gradient.lua:
mvp = mvp or {}
mvp.ui = mvp.ui or {}

local gradientMat = Material("gui/gradient.png")
function mvp.ui.DrawRoundedGradient( roundness, x, y, w, h, startColor, endColor )
    draw.RoundedBoxEx( roundness, x, y, w - roundness - 1, h, startColor, true, false, true, false )
    draw.RoundedBoxEx( roundness, roundness + 1, y, w - roundness - 1, h, endColor, false, true, false, true )

    draw.RoundedBoxEx( roundness, x + roundness, y, w - roundness * 2, h, endColor, false, false, false, false )
    surface.SetMaterial( gradientMat )
    surface.SetDrawColor( startColor )
    surface.DrawTexturedRect( x + roundness, y, w - roundness * 2, h )
end

mvp.ui.mutedColorsCache = {}

function mvp.ui.MuteColor(col, factor)
    factor = factor or 0.8
    local colId = col.r .. col.g .. col.b .. col.a .. factor
    if (mvp.ui.mutedColorsCache[colId]) then
        return mvp.ui.mutedColorsCache[colId]
    end
    
    local newCol = Color(col.r * factor, col.g * factor, col.b * factor, col.a)

    mvp.ui.mutedColorsCache[colId] = newCol

    return newCol
end
--PATH lua/mvp/core/ui/cl_scale.lua:
mvp = mvp or {}
mvp.ui = mvp.ui or {}

mvp.ui.scalingCache = mvp.ui.scalingCache or {}
mvp.ui.scalingWithFactorCache = mvp.ui.scalingWithFactorCache or {}

local scrH, max = ScrH, math.max
function mvp.ui.Scale( value )
    if mvp.ui.scalingCache[ value ] then
        return mvp.ui.scalingCache[ value ]
    end

    mvp.ui.scalingCache[ value ] = max( value * ( scrH() / 1080 ), 1 )
    return mvp.ui.scalingCache[ value ]
end

--- Scale value, then round it to the nearest integer of factor of 2
function mvp.ui.ScaleWithFactor(value)

    if mvp.ui.scalingWithFactorCache[value] then
        return mvp.ui.scalingWithFactorCache[value]
    end

    local scaled = mvp.ui.Scale(value)
    local factor = 2 ^ math.floor(math.log(scaled) / math.log(2))

    mvp.ui.scalingWithFactorCache[value] = math.floor(scaled / factor + 0.5) * factor
    
    return mvp.ui.scalingWithFactorCache[value]
end

hook.Add("OnScreenSizeChanged", "mvp.ui.Scale", function()
    mvp.ui.scalingCache = {}
    mvp.ui.scalingWithFactorCache = {}
end)
--PATH lua/mvp/core/sh_language.lua:
return gluapack()()
--PATH lua/mvp/languages/ru.lua:
local l = {}

l["general.terminal"] = "Terminal"

l["general.by_x"] = "by %s"
l["general.no_permission"] = "     ."
l["general.use"] = " {{btn:%s}}  "

l["general.screen_position.tl"] = "  "
l["general.screen_position.tc"] = " "
l["general.screen_position.tr"] = "  "
l["general.screen_position.cl"] = " "
l["general.screen_position.cc"] = ""
l["general.screen_position.cr"] = " "
l["general.screen_position.bl"] = "  "
l["general.screen_position.bc"] = " "
l["general.screen_position.br"] = "  "

--[[
    UI
]]--

l["ui.general.save"] = ""
l["ui.general.save.thing"] = " %s"
l["ui.general.close"] = ""
l["ui.general.none"] = ""

l["ui.home"] = ""
l["ui.home.description"] = "     ."

l["ui.config"] = ""
l["ui.config.save"] = " "
l["ui.config.description"] = "       .     , ,     ."

l["ui.config.saved"] = " "
l["ui.config.saved.description"] = "    ."

l["ui.permissions"] = ""
l["ui.permissions.description"] = "   ,     ."

l["ui.packages"] = ""
l["ui.packages.description"] = " ,       ."
l["ui.packages.installed"] = " "
l["ui.packages.available"] = " "

l["ui.credits"] = ""
l["ui.credits.description"] = "     ,   ."
l["ui.credits.steam_profile"] = " Steam"

l["ui.credits.terminal"] = l["general.terminal"]
l["ui.credits.icons"] = ""
l["ui.credits.packages"] = ""

l["ui.notifications.servername.title"] = "   "
l["ui.notifications.servername.description"] = "     .          \"%s\"     .       ."
l["ui.notifications.servername.action.1"] = "  "

l["ui.notifications.logo.title"] = "   "
l["ui.notifications.logo.description"] = "     .          \"%s\"     .       ."
l["ui.notifications.logo.action.1"] = "  "

l["ui.notifications.gamemode.title"] = "   "
l["ui.notifications.gamemode.description"] = "     .          \"%s\"     .       ."
l["ui.notifications.gamemode.action.1"] = "  "
l["ui.notifications.gamemode.action.2"] = ""


--[[
    Config Section
]]--

l["section.terminal"] = l["general.terminal"]
l["section.terminal.general"] = ""
l["section.terminal.appearance"] = " "
l["section.terminal.developer"] = ""

l["value.prefix.description"] = "   ."
l["value.command.description"] = "    ."
l["value.allowConsoleCommand.description"] = "      ."

l["value.tag.description"] = "     ."
l["value.language.description"] = "    ."
l["value.useNotifications.description"] = "  .   -     ."
l["value.notificationsPosition.description"] = "  ."
l["value.notificationsPosition.ps.title"] = "  "
l["value.notificationsPosition.ps.description"] = "      ."

l["value.debug.description"] = "  ."

l["section.server"] = ""
l["section.server.gamemode"] = " "
l["section.server.branding"] = ""

l["value.gamemode.description"] = "  ."
l["value.logo.description"] = " ."
l["value.servername.description"] = " ."

--[[
    Permissions Section
]]--

l["permission.mvp.terminal.description"] = "     "
l["permission.mvp.terminal.configs.description"] = "      "
l["permission.mvp.terminal.packages.description"] = "   "


mvp.language.Register("ru", l)
--PATH lua/mvp/core/util/sh_kitchensink.lua:
mvp = mvp or {}
mvp.utils = mvp.utils or {}

function mvp.utils.IsSteamID(value)
    if (value == nil) then return false end

    return string.match(value, "^STEAM_%d:%d:%d+$") ~= nil
end

function mvp.utils.IsSteamID64(value)
    if (value == nil) then return false end

    return string.match(value, "^[0-9]+$") ~= nil
end

function mvp.utils.IsColor(color)
    return type(color) == "table" and color.r and color.g and color.b and color.a
end

function mvp.utils.UUID(length)
    local template = string.rep("x", length or 32, "")
    math.randomseed(SysTime())

    return string.gsub(template, "x", function(c)
        local v = (c == "x") and math.random(0, 0xf) or math.random(8, 0xb)
        return string.format("%x", v)
    end)
end

function mvp.utils.Assert(value, funcName, argNum)
    assert(value, string.format("bad argument #%i to \"%s\" (got nil)", argNum, funcName))
end

function mvp.utils.AssertNamed(value, name, funcName, argNum)
    assert(value, string.format("bad argument #%i to \"%s\" (got nil for %s)", argNum, funcName, name))
end

function mvp.utils.AssertType(value, expected, funcName, argNum)
    local valueType = mvp.types.GetTypeFromValue(value)

    assert(valueType == expected, string.format("bad argument #%i to \"%s\" (expected %s, got %s)", argNum, funcName, mvp.type[expected], mvp.type[valueType]))
end

function mvp.utils.GetTrace()
    local level = 2
    local trace = "Traceback:\n"

    while (true) do
        local info = debug.getinfo(level, "Sln")
        if (not info) then break end

        if (info.what == "C") then
            trace = trace .. string.format( "\t\t%i: C function\t\"%s\"\n", level - 1, info.name )
        else
            trace = trace .. string.format( "\t\t%i: Line %d\t\"%s\"\t\t%s\n", level - 1, info.currentline, info.name, info.short_src )
        end

        level = level + 1
    end

    return trace
end

function mvp.utils.ExtractCWD(folder)
    mvp.utils.Assert(folder, "Folder cannot be nil")
    
    local cwd = debug.getinfo(2, "S").short_src
    local c = string.match(cwd, "addons/[^/]+/lua/mvp/" .. folder .. "/([^/]+)/[^/]+")

    return c
end

local function charWrap(text, remainingWidth, maxWidth)
    local totalWidth = 0

    text = text:gsub('.', function(char)
        totalWidth = totalWidth + surface.GetTextSize(char)

        -- Wrap around when the max width is reached
        if totalWidth >= remainingWidth then
            -- totalWidth needs to include the character width because it's inserted in a new line
            totalWidth = surface.GetTextSize(char)
            remainingWidth = maxWidth
            return '\n' .. char
        end

        return char
    end)

    return text, totalWidth
end

function mvp.utils.WrapText(text, font, maxWidth)
    local totalWidth = 0
    local totalHeight = 0

    surface.SetFont(font)

    local spaceWidth, spaceHeight = surface.GetTextSize(' ')
    text = text:gsub("(%s?[%S]+)", function(word)
            local char = string.sub(word, 1, 1)
            if char == "\n" or char == "\t" then
                totalWidth = 0
                
            end

            if char == "\n" then
                totalHeight = totalHeight + spaceHeight
            end

            local wordlen = surface.GetTextSize(word)
            totalWidth = totalWidth + wordlen

            -- Wrap around when the max width is reached
            if wordlen >= maxWidth then -- Split the word if the word is too big
                local splitWord, splitPoint = charWrap(word, maxWidth - (totalWidth - wordlen), maxWidth)
                totalWidth = splitPoint

                totalHeight = totalHeight + spaceHeight

                return splitWord
            elseif totalWidth < maxWidth then
                return word
            end

            -- Split before the word
            if char == ' ' then
                totalWidth = wordlen - spaceWidth
                totalHeight = totalHeight + spaceHeight

                return '\n' .. string.sub(word, 2)
            end

            totalWidth = wordlen
            totalHeight = totalHeight + spaceHeight
            return '\n' .. word
        end)

    return text, totalHeight
end

function mvp.utils.DrawEntityDisplay(ent, text, description, displayUse)
    local pos = ent:GetPos()
    local ang = ent:GetAngles()
    local drawAngles = ent:GetAngles()

    drawAngles:RotateAroundAxis(drawAngles:Forward(), 90)
    drawAngles:RotateAroundAxis(drawAngles:Right(), -90)

    local OBBMaxs = ent:OBBMaxs()
    pos = pos + ang:Up() * 64

    if (ent:WorldToLocal(pos).z < OBBMaxs.z) then
        pos = pos + ang:Forward() * OBBMaxs.x
    end

    cam.Start3D2D(pos, drawAngles, 0.1)        
        surface.SetFont(mvp.q.Font(48, 800))
        local textWidth, textHeight = surface.GetTextSize(text)

        surface.SetFont(mvp.q.Font(32, 500))
        local descWidth, descHeight = surface.GetTextSize(description)

        local width = math.max(textWidth, descWidth)
        local height = textHeight + descHeight

        local useText = mvp.q.Lang("general.use", string.upper(input.LookupBinding("+use")))

        if (displayUse) then
            surface.SetFont(mvp.q.Font(24, 500))
            local useWidth, useHeight = surface.GetTextSize(useText)

            width = math.max(width, useWidth)
            height = height + useHeight + 5
        end

        draw.RoundedBox(mvp.ui.ScaleWithFactor(16), -width * .5 - 10, -height * .5 - 10, width + 20, height + 20, Color(0, 0, 0, 200))

        draw.SimpleText(text, mvp.q.Font(48, 800), 0, -height * .5, mvp.colors.Accent, TEXT_ALIGN_CENTER)
        draw.SimpleText(description, mvp.q.Font(32, 600), 0, -height * .5 + textHeight, mvp.colors.Text, TEXT_ALIGN_CENTER)

        if (displayUse) then
            mvp.utils.DrawTextWithButtons(useText, mvp.q.Font(27, 500), 0, -height * .5 + textHeight + descHeight + 5, ColorAlpha(mvp.colors.Text, 200), TEXT_ALIGN_CENTER)
        end
    cam.End3D2D()
end

function mvp.utils.DrawTextWithButtons(text, font, x, y, color, alignX, alignY)
    local buttons = {} -- {{btn:...}}

    -- split the text into buttons and text
    for btn in string.gmatch(text, "{{btn:(.-)}}") do
        table.insert(buttons, btn)
    end
    local text = string.Explode("{{btn:(.-)}}", text, true)

    local textWidth, textHeight = 0, 0
    surface.SetFont(font)
    for i, v in ipairs(text) do
        local tw, th = surface.GetTextSize(v)

        textWidth = textWidth + tw
        textHeight = math.max(textHeight, th)

        if (buttons[i]) then
            local bw, bh = th * 1.2, th * 1.2

            textWidth = textWidth + bw
            textHeight = math.max(textHeight, bh)
        end
    end

    local x, y = x, y
    if (alignX == TEXT_ALIGN_CENTER) then
        x = x - textWidth * .5
    elseif (alignX == TEXT_ALIGN_RIGHT) then
        x = x - textWidth
    end

    if (alignY == TEXT_ALIGN_CENTER) then
        y = y - textHeight * .5
    elseif (alignY == TEXT_ALIGN_BOTTOM) then
        y = y - textHeight
    end

    local currentX = x

    for i, v in ipairs(text) do
        local tw, th = surface.GetTextSize(v)

        draw.SimpleText(v, font, currentX, y, color)
        currentX = currentX + tw

        if (buttons[i]) then
            local btw = surface.GetTextSize(buttons[i])
            local bw, bh = math.max(th * 1.2, btw + 10), th * 1.2

            local col = ColorAlpha(mvp.colors.Text , color.a)

            local y = y - 2

            -- draw.RoundedBox(0, currentX, y, bw, bh, ColorAlpha(mvp.colors.Accent, color.a))
            mvp.ui.DrawOutlinedRoundedRect(8, currentX, y, bw, bh, 4, col)
            draw.SimpleText(buttons[i], font, currentX - .5 + bw * .5, y + textHeight * .5 - 0.5, col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

            currentX = currentX + bw
        end        
    end

    return textWidth, textHeight
end

function mvp.utils.ChatPrint(...)
    local args = {...}
    
    -- for i, v in ipairs(args) do
    --     if (mvp.utils.IsColor(v)) then
    --         args[i] = mvp.utils.ColorToFormattedString(v)
    --     end
    -- end

    -- find all color codes and replace them with the color

    local text = {}
    for _, arg in ipairs(args) do
        if (mvp.utils.IsColor(arg)) then
            table.insert(text, mvp.utils.ColorToFormattedString(arg))
        else
            table.insert(text, arg)
        end
    end
    text = table.concat(text, "")

    local colors = {}
    for col in string.gmatch(text, "{{color:(.-)}}") do
        if (mvp.colors[col]) then
            col = mvp.utils.ColorToFormattedString(mvp.colors[col])
        end

        table.insert(colors, col)
    end
    text = string.Explode("{{color:(.-)}}", text, true)

    local chatText = {}

    for i, v in ipairs(text) do
        table.insert(chatText, v)

        if (colors[i]) then
            local r, g, b, a = string.match(colors[i], "(%d+),(%d+),(%d+),(%d+)")
            table.insert(chatText, Color(r, g, b, a))
        end
    end

    chat.AddText(unpack(chatText))
end

function mvp.utils.ColorToFormattedString(col, onlyNumbers)
    if (onlyNumbers) then
        return col.r .. "," .. col.g .. "," .. col.b .. "," .. col.a
    end

    return "{{color:" .. col.r .. "," .. col.g .. "," .. col.b .. "," .. col.a .. "}}"
end
--PATH lua/mvp/core/util/sh_lerps.lua:
mvp = mvp or {}
mvp.utils = mvp.utils or {}

function mvp.utils.LerpColor(t, from, to)
    return Color(
        Lerp(t, from.r, to.r),
        Lerp(t, from.g, to.g),
        Lerp(t, from.b, to.b),
        Lerp(t, from.a, to.a)
    )
end

function mvp.utils.LerpVector(t, from, to)
    return LerpVector(t, from, to)
end

function mvp.utils.LerpAngle(t, from, to)
    return LerpAngle(t, from, to)
end

function mvp.utils.Lerp(t, from, to)
    return Lerp(t, from, to)
end
--PATH addons/[bronie] perfect-hands/lua/mvp/packages/perfecthands/sh_package.lua:
return gluapack()()
--PATH lua/mvp/packages/radialmenu/languages/ru.lua:
local l = {}

l["radialmenu.select_option"] = " "

l["radialmenu.select"] = ""
l["radialmenu.cancel"] = ""

mvp.language.Register("ru", l)
--PATH addons/[bronie] perfect-hands/lua/mvp/packages/perfecthands/languages/de.lua:
return gluapack()()
--PATH addons/[bronie] perfect-hands/lua/mvp/packages/perfecthands/languages/ru.lua:
local l = {}

l["section.perfecthands"] = "Perfect Hands"
l["section.perfecthands.appearance"] = " "
l["section.perfecthands.animations"] = " "
l["section.perfecthands.interactions"] = " "

l["value.phands.useIcons.description"] = " ,    ,    - ."
l["value.phands.iconsTheme.description"] = " ."

l["value.phands.useAnimations.description"] = "    ."
l["value.phands.animationAllowFreelook.description"] = "       ."
l["value.phands.animationSpeed.description"] = " ."
l["value.phands.animationVelocityCutoff.description"] = "  ,     .      ,    ."

l["value.phands.useInteractions.description"] = "    ."
l["value.phands.interactionDistance.description"] = ",       ."
l["value.phands.interactionWeightMultiplier.description"] = "    .    ,    ,    ."

l["phands.name"] = ""

l["phands.mouse_buttons.MOUSE1"] = ""
l["phands.mouse_buttons.MOUSE2"] = ""
l["phands.mouse_buttons.MOUSE3"] = ""

l["phands.hint.drag"] = "   {{btn:%s}},    ."
l["phands.hint.rmb"] = " {{btn:%s}},    ."
l["phands.hint.rmb.stop"] = " {{btn:%s}}  {{btn:%s}},   ."
l["phands.hint.freelook"] = " {{btn:%s}},   ."

l["phands.cant_use_animation"] = "     \"%s\"   ."

l["phands.animation.surrender"] = ""
l["phands.animation.surrender.description"] = "      ."
l["phands.animation.armsinfront"] = " "
l["phands.animation.armsinfront.description"] = "    ."
l["phands.animation.armsbehind"] = " "
l["phands.animation.armsbehind.description"] = "    ."
l["phands.animation.armsbehindhead"] = "  "
l["phands.animation.armsbehindhead.description"] = "    ."
l["phands.animation.armsonbelt"] = "  "
l["phands.animation.armsonbelt.description"] = "    ."
l["phands.animation.comlink"] = ""
l["phands.animation.comlink.description"] = "   ."
l["phands.animation.hololink"] = ""
l["phands.animation.hololink.description"] = "   ."
l["phands.animation.highfive"] = ""
l["phands.animation.highfive.description"] = "     ."
l["phands.animation.point"] = ""
l["phands.animation.point.description"] = "   -."
l["phands.animation.salute"] = " "
l["phands.animation.salute.description"] = "   ."
l["phands.animation.pensive"] = ""
l["phands.animation.pensive.description"] = "  ."
l["phands.animation.typing"] = ""
l["phands.animation.typing.description"] = "   ."
l["phands.animation.middlefinger"] = " "
l["phands.animation.middlefinger.description"] = "  -  ."
l["phands.animation.attention"] = ""
l["phands.animation.attention.description"] = "    ."
l["phands.animation.attention.kneel"] = " "
l["phands.animation.attention.kneel.description"] = "    ."


mvp.language.Register("ru", l)

--PATH addons/[bronie] perfect-hands/lua/mvp/packages/perfecthands/cl_credits.lua:
-- <a href="https://www.flaticon.com/free-icons/drag" title="drag icons">Drag icons created by Pixel perfect - Flaticon</a>

mvp.credits.AddIcon(Material("mvp/perfecthands/drag.png"), "Drag", "Pixel perfect - Flaticon", "https://www.flaticon.com/authors/pixel-perfect")

-- <div> Icons made by <a href="https://www.flaticon.com/authors/pixel-perfect" title="Pixel perfect"> Pixel perfect </a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com'</a></div>
mvp.credits.AddIcon(Material("mvp/perfecthands/lock.png", "smooth mips"), "Lock", "Pixel perfect - Flaticon", "https://www.flaticon.com/authors/pixel-perfect")

-- Translator
mvp.credits.AddContributor("76561198293343119", "TheCookieYT", "Translator (German), animations (Perfect Hands)")

-- Kneel down animation
mvp.credits.AddContributor("76561199098397483", "OrtEFE", "Kneel Down animation (Perfect Hands)")
--PATH lua/mvp/packages/simpledefcons/languages/en.lua:
return gluapack()()
--PATH lua/mvp/core/gamemode/sh_gamemode.lua:
mvp = mvp or {}
mvp.gamemode = mvp.gamemode or {}

mvp.gamemode.list = {}

function mvp.gamemode.Register(gm)
    local id = gm:GetID()

    if (mvp.gamemode.list[id]) then
        mvp.logger.Log(mvp.LOG.WARN, "Gamemodes", "Gamemode '" .. id .. "' already registered! Overwriting...")
        mvp.logger.Log(mvp.LOG.WARN, "Gamemodes", "This is probably a bug! Since this should not happen outside of development!")

        mvp.logger.Log(mvp.LOG.DEBUG, nil, "ID: " .. id)

        mvp.gamemode.list[id] = nil
    end

    mvp.gamemode.list[id] = gm

    mvp.logger.Log(mvp.LOG.INFO, "Gamemodes", "Registered gamemode '" .. id .. "@" .. gm:GetVersion() .. "'")
    hook.Run("mvp.gamemode.Registered", gm)
end

function mvp.gamemode.GetList()
    return mvp.gamemode.list
end

function mvp.gamemode.Get(id)
    return mvp.gamemode.list[id]
end

function mvp.gamemode.GetActiveID()
    return mvp.config.Get("gamemode", "blank")
end

function mvp.gamemode.GetActive()
    return mvp.gamemode.Get(mvp.gamemode.GetActiveID())
end

function mvp.gamemode.Init()
    mvp.logger.Log(mvp.LOG.INFO, "Gamemodes", "Initializing gamemodes...")

    mvp.loader.LoadFolder("gamemodes")

    mvp.logger.Log(mvp.LOG.INFO, "Gamemodes", "Initialized gamemodes!")
end

--[[
    Gamemode functions
]]--

function mvp.gamemode.GetBalance(ply)
    local gm = mvp.gamemode.GetActive()

    return gm:GetMoney(ply)
end

function mvp.gamemode.GetBalanceFormatted(ply)
    local gm = mvp.gamemode.GetActive()

    return gm:FormatMoney(ply, gm:GetMoney(ply))
end

function mvp.gamemode.CanAfford(ply, amount)
    local gm = mvp.gamemode.GetActive()

    return gm:CanAfford(ply, amount)
end

function mvp.gamemode.AddMoney(ply, amount)
    local gm = mvp.gamemode.GetActive()

    return gm:AddMoney(ply, amount)
end

function mvp.gamemode.TakeMoney(ply, amount)
    local gm = mvp.gamemode.GetActive()

    return gm:TakeMoney(ply, amount)
end

function mvp.gamemode.FormatMoney(ply, amount)
    local gm = mvp.gamemode.GetActive()

    return gm:FormatMoney(ply, amount)
end
--PATH lua/mvp/vgui/cl_card.lua:
return gluapack()()
--PATH lua/mvp/vgui/checkbox/cl_checkbox.lua:
local PANEL = {}
local padding = mvp.ui.Scale(8)

local checkIcon = Material("mvp/terminal/icons/check.png", "smooth mips")

AccessorFunc(PANEL, "roundness", "Roundness")

function PANEL:Init()
    self.checked = false

    self:SetText("")
    self:SetRoundness(mvp.ui.ScaleWithFactor(8))

    self.colors = {}
    self.colors.Background = mvp.colors.SecondaryBackground
    self.colors.BackgroundHover = mvp.colors.BackgroundHover

    self.backgroundColor = self.colors.Background
    self.clipWidth = 0
end

function PANEL:Paint(w, h)
    draw.RoundedBox(self.roundness, 0, 0, w, h, self.backgroundColor)

    local x, y = self:LocalToScreen(0, 0)
    render.SetScissorRect( x, y, x + self.clipWidth, y + h, true )
        draw.RoundedBox(self.roundness, 0, 0, w, h, mvp.colors.SecondaryAccent)

        surface.SetDrawColor(mvp.colors.Text)
        surface.SetMaterial(checkIcon)
        surface.DrawTexturedRect(padding, padding + 4, w - padding * 2, h - padding * 2)
    render.SetScissorRect( 0, 0, 0, 0, false )
end

function PANEL:OnCursorEntered()
    self:LerpColor("backgroundColor", self.colors.BackgroundHover, 0.2)
end
function PANEL:OnCursorExited()
    self:LerpColor("backgroundColor", self.colors.Background, 0.2)
end

function PANEL:SetChecked(val)
    if (tonumber(val) == 0) then
        val = 0
    end 

    val = tobool(val)

    self.checked = val

    self:OnChangedInternal(val)
end
function PANEL:GetChecked()
    return self.checked
end
function PANEL:SetValue(bool)
    self:SetChecked(bool)
end
function PANEL:GetValue()
    return self:GetChecked()
end

function PANEL:Toggle()
    self:SetChecked(not self:GetChecked())
end
function PANEL:DoClick()
    self:Toggle()
end

function PANEL:OnChangedInternal(bool)
    self:OnChanged(bool)

    self:Lerp("clipWidth", self:GetChecked() and self:GetWide() or 0, 0.2)
end
function PANEL:OnChanged(bool)
    -- override
end

vgui.Register("mvp.CheckBox", PANEL, "DButton")
--PATH lua/mvp/vgui/dropdown/cl_dropdown.lua:
return gluapack()()
--PATH lua/mvp/menus/admin/cl_permissions.lua:
mvp = mvp or {}
mvp.menus = mvp.menus or {}

mvp.menus.admin = mvp.menus.admin or {}

local spaceBetween = mvp.ui.Scale(10)
local spacing = mvp.ui.Scale(10)

function mvp.menus.admin.Permissions(container)
    local content = vgui.Create("EditablePanel", container)
    content:Dock(FILL)
    content:InvalidateParent(true)

    local title = vgui.Create("mvp.MenuHeader", content)
    title:Dock(TOP)
    title:SetTall(mvp.ui.Scale(64))  
    
    title:SetText("Permissions")
    title:SetDescription("All the permissions that Terminal or it's packages registered are listed here.")

    local pageContent = vgui.Create("EditablePanel", content)
    pageContent:Dock(FILL)
    pageContent:InvalidateParent(true)

    local permissions = mvp.permissions.GetPermissionList()

    local permissionsList = vgui.Create("mvp.ScrollPanel", pageContent)
    permissionsList:Dock(FILL)
    permissionsList:DockMargin(0, spaceBetween, spaceBetween, spaceBetween)
    permissionsList:InvalidateParent(true)

    for k, v in SortedPairsByMemberValue(permissions, "sortOrder") do
        local permissionPanel = vgui.Create("DPanel", permissionsList:GetCanvas())
        permissionPanel:Dock(TOP)
        permissionPanel:SetTall(mvp.ui.Scale(64))
        permissionPanel:DockMargin(0, 0, 0, spaceBetween * .5)

        local name = v.name
        local description = mvp.q.LangFallback("permission." .. v.name .. ".description", v.description)

        permissionPanel.Paint = function(pnl, w, h)
            draw.RoundedBox(mvp.ui.ScaleWithFactor(8), 0, 0, w, h, ColorAlpha(mvp.colors.SecondaryBackground, 150))

            draw.SimpleText(name, mvp.Font(22, 600), spaceBetween, spaceBetween, mvp.colors.Accent)
            draw.SimpleText(description, mvp.Font(20, 500), spaceBetween, h - spaceBetween, mvp.colors.Text, nil, TEXT_ALIGN_BOTTOM)
        end
    end
end
--PATH lua/ncs_shared/characters/list/sh_mcs.lua:
return gluapack()()
--PATH lua/ncs_shared/modules/configuration/cl_main.lua:
concommand.Add("ncs_configurationmenu", function()
    local aGroups = NCS_SHARED.GetDataOption("admingroups_library")

    if !aGroups then
        if !LocalPlayer():IsSuperAdmin() then NCS_SHARED.AddText(Color(255,0,0), "[NCS] ", color_white, "No permission, please contact system administrator.") return end
    elseif !aGroups[LocalPlayer():GetUserGroup()] then
        return
    end

    local F = vgui.Create("NCS_SHARED_FRAME")
    F:SetSize(ScrW() * 0.4, ScrH() * 0.5)
    F:Center()
    F:MakePopup(true)
    F:SetMouseInputEnabled(true)

    local w, h = F:GetSize()

    local S = F:Add("NCS_SHARED_SCROLL")
    S:Dock(FILL)
    S:SetMouseInputEnabled(true)
    S:DockMargin(w * 0.025, h * 0.025, w * 0.025, h * 0.025)
    
    local SIDE = vgui.Create("NCS_SHARED_SIDEBAR", F)
    SIDE:SetMouseInputEnabled(true)

    local CATEGORIES = {}

    local HandleCategories
    local firstName
    for k, v in pairs(NCS_SHARED.SavedDataOptions) do
        if CATEGORIES[v.dataCategory] then continue end

        if !firstName then firstName = v.dataCategory end

        CATEGORIES[v.dataCategory] = true
        
        SIDE:AddPage(v.dataCategory, "JokvF2A", function()
            if IsValid(S) then
                S:Clear()
            end

            HandleCategories(v.dataCategory)
        end )
    end

    SIDE.Think = function(s)
        SIDE:SelectPage(firstName)

        s.Think = function() end
    end

    HandleCategories = function(categoryName)
            for k, v in SortedPairsByMemberValue(NCS_SHARED.SavedDataOptions, "sortValue", true) do
                if v.dataCategory ~= categoryName then continue end

                local M_LABEL = S:Add("DLabel")
                M_LABEL:SetText(v.dataName)
                M_LABEL:Dock(TOP)
                M_LABEL:DockMargin(w * 0.025, h * 0.025, w * 0.025, h * 0.025)
                M_LABEL:SetFont("NCS_SHARED_DESCRIPTION")
                M_LABEL:SetTall(M_LABEL:GetTall() * 1.4)
                M_LABEL:SetMouseInputEnabled(true)

                if v.customMenuFunction then
                    v:customMenuFunction(S)
                    continue
                end
                
                if ( v.dataType == TYPE_BOOL ) then
                    local LABEL = S:Add("DLabel")
                    LABEL:SetText("")
                    LABEL:SetHeight(h * 0.05)
                    LABEL:Dock(TOP)
                    LABEL:DockMargin(w * 0.025, h * 0.005, w * 0.025, 0)
                    LABEL:SetMouseInputEnabled(true)

                    local CHECK_L = LABEL:Add("DLabel")
                    CHECK_L:SetMouseInputEnabled(true)
                    CHECK_L:Dock(RIGHT)
                    CHECK_L:SetText("")
                    
                    local CHECK = CHECK_L:Add("DCheckBox")
                    CHECK:SetSize(CHECK:GetWide() * 1.5, CHECK:GetWide() * 1.5)
                    CHECK:Center()
                    CHECK:SetMouseInputEnabled(true)

                    CHECK.OnChange = function(s, val)
                        if v.verifyData then
                            local verifyData = v:verifyData(val)

                            if ( verifyData == false ) then s:SetChecked(!val) return end
                        end

                        net.Start("NCS_SHARED_SetConfigOption")
                            net.WriteString(k)
                            net.WriteType(val)
                        net.SendToServer()
                    end
                    
                    if NCS_SHARED.GetDataOption(k) then
                        CHECK:SetChecked(true)
                    end
                elseif ( v.dataType == TYPE_TABLE ) then
                    if v.multiSelect then
                        local TEAMS = S:Add("DLabel")
                        TEAMS:Dock(TOP)
                        TEAMS:SetTall(F:GetTall() * 0.3)
                        TEAMS:DockMargin(w * 0.025, h * 0.025, w * 0.025, h * 0.025)
                        TEAMS:SetMouseInputEnabled(true)
                        TEAMS:SetText("")

                        TEAMS.Paint = function(s, w, h)
                            surface.SetDrawColor(Color(32,32,32,255))
                            surface.DrawOutlinedRect( 0, 0, w, h)
                        end

                        for k1, v2 in ipairs(v.selectData) do
                            local LINE = TEAMS:Add("DLabel")
                            LINE:Dock(TOP)
                            LINE:SetText("")
                            LINE:SetTall(TEAMS:GetTall() * 0.125)
                            LINE:SetMouseInputEnabled(true)
                            LINE.Paint = function(s, w, h)
                                if (k1 % 2 == 0) then
                                    draw.RoundedBox(0, 0, 0, w, h, Color(32,32,32,255))
                                else
                                    draw.RoundedBox(0, 0, 0, w, h, Color(48,48,48,255))
                                end
                                    
                                draw.SimpleText(v2, "NCS_SHARED_DESCRIPTION", w * 0.01, h * 0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
                            end

                            local CHECK_L = vgui.Create("DLabel", LINE)
                            CHECK_L:Dock(RIGHT)
                            CHECK_L:SetText("")
                            CHECK_L:SetMouseInputEnabled(true)

                            CHECK_L.Think = function()
                                local CHECK = vgui.Create("DCheckBox", CHECK_L)
                                CHECK:SetSize(CHECK:GetWide() * 1.5, CHECK:GetTall() * 1.5)
                                CHECK:Center()
                                CHECK:SetMouseInputEnabled(true)

                                local dataOption = NCS_SHARED.GetDataOption(k)

                                if istable(dataOption) then
                                    for c, d in ipairs(dataOption) do
                                        if v2 == d then
                                            CHECK:SetValue(true)
                                        end
                                    end
                                end

                                CHECK.OnChange = function(s, val)
                                    if v.verifyData then
                                        local verifyData = v:verifyData(val)
        
                                        if ( verifyData == false ) then s:SetChecked(!val) return end
                                    end

                                    TEAMS.VALUES = TEAMS.VALUES or {}

                                    if val then
                                        table.insert(TEAMS.VALUES, v2)
                                    else
                                        for a, b in ipairs(TEAMS.VALUES) do
                                            if ( b == v2 ) then
                                                table.remove(TEAMS.VALUES, a)
                                            end
                                        end
                                    end

                                    net.Start("NCS_SHARED_SetConfigOption")
                                        net.WriteString(k)
                                        net.WriteType(TEAMS.VALUES)
                                    net.SendToServer()
                                end

                                CHECK_L.Think = function() end
                            end
                        end
                    else
                        local PANEL_sort = S:Add("DPanel")
                        PANEL_sort:Dock(TOP)
                        PANEL_sort:DockMargin(w * 0.025, h * 0.025, w * 0.025, h * 0.025)
                        PANEL_sort.Paint = function() end

                        local combobox_Sort = PANEL_sort:Add("DComboBox")
                        combobox_Sort:Dock(FILL)

                        
                        for _, v in pairs(v.selectData) do
                            local IND = combobox_Sort:AddChoice(v)

                            if ( NCS_SHARED.GetDataOption(k) ~= nil ) and ( NCS_SHARED.GetDataOption(k) == v ) then
                                combobox_Sort:ChooseOptionID(IND)
                            end
                        end
                        
                        combobox_Sort.OnSelect = function(s, IND, val, S_VAL)
                            if v.verifyData then
                                local verifyData = v:verifyData(val)

                                if ( verifyData == false ) then s:SetText("Broken") return end
                            end

                            print("EYYYYO")
                            net.Start("NCS_SHARED_SetConfigOption")
                                net.WriteString(k)
                                net.WriteType(val)
                            net.SendToServer()
                        end
                    end
            end
        end
    end
end )

net.Receive("NCS_SHARED_SendConfigOptions", function()
    local TAB = net.ReadTable()

    for k, v in pairs(TAB) do
        NCS_SHARED.SavedDataOptions[tostring(k)].currentValue = v
    end

    hook.Run("NCS_SHARED_ConfigurationModuleLoaded")
end )

net.Receive("NCS_SHARED_SetConfigOption", function()
    NCS_SHARED.SavedDataOptions[net.ReadString()].currentValue = net.ReadType()
end )
--PATH lua/ncs_shared/vgui/cl_scroll.lua:
return gluapack()()
--PATH lua/autorun/npc_buzz_droid.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/util.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/thirdparty/sh_utf8.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2024

--]]

onyx.utf8 = {}

local CASEMAP_LOWER = {} -- lower to upper
local CASEMAP_UPPER = {} -- upper to lower

do
    -- gmod doesn't like big lua files, so let's split them
    for index = 1, 4 do
        local data = include('data/utf8_chunk_' .. index .. '.lua')
        assert(data, 'missing UTF-8 casemap data (' .. index .. ')')
        for lowerCharCode, upperCharCode in next, data do
            CASEMAP_LOWER[lowerCharCode] = upperCharCode
            CASEMAP_UPPER[upperCharCode] = lowerCharCode
        end
    end
end

local function replace(text, mapping)
    assert(isstring(text), string.format('bad argument #1 `replace` (expected string, got %s)', type(text)))

    local newString = ''

    for _, code in utf8.codes(text) do
        newString = newString .. utf8.char(mapping[code] or code)
    end

    return newString
end

function onyx.utf8.upper(text)
    return replace(text, CASEMAP_LOWER)
end

function onyx.utf8.lower(text)
    return replace(text, CASEMAP_UPPER)
end
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/cl_lang.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/sh_netchunk.lua:
--[[
MIT License

Copyright (c) 2023 Aleksandrs Filipovskis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

if (netchunk) then return end

netchunk = netchunk or {}
netchunk.chunks = netchunk.chunks or {}
netchunk.registered = netchunk.registered or {}
-- netchunk.maxBytes = 32768
netchunk.maxBytes = 16384

local split do
    local len = string.len
    local sub = string.sub
    local maxBytes = netchunk.maxBytes

    function split(data)
        local length = len(data)
        local index = 1
        local last = 1
        local chunks = {}

        for i = 1, length do
            if (i - last + 1) > maxBytes then
                chunks[index] = sub(data, last, i)
                index = index + 1
                last = i + 1
            end
        end

        chunks[index] = sub(data, last, length)

        return chunks
    end
end

local function merge(chunks)
    local result = ''

    for i = 1, #chunks do
        result = result .. chunks[i]
    end

    return result
end

function netchunk.Register(name)
    if (SERVER) then
        util.AddNetworkString('netchunk[' .. name .. ']:Send')
    end

    netchunk.registered[name] = true
    netchunk.chunks[name] = {}
end

if (SERVER) then
    local function send(ply)
        if ply then
            net.Send(ply)
        else
            net.Broadcast()
        end
    end

    function netchunk.Send(ply, name, data)
        assert(netchunk.registered[name], 'Trying to send data during unregistered channel (`' .. name .. '`)')

        local encoded = pon.encode(data)
        local chunks = split(encoded)
        local count = #chunks

        for i = 1, count do
            local chunk = chunks[i]
            local length = #chunk

            net.Start('netchunk[' .. name .. ']:Send')
                net.WriteString(name)
                net.WriteUInt(length, 16)
                net.WriteData(chunks[i], length)
                net.WriteBool(i == count)
            send(ply)
        end
    end
else
    netchunk.callbacks = netchunk.callbacks or {}

    local ReadString = net.ReadString
    local ReadUInt = net.ReadUInt
    local ReadData = net.ReadData
    local ReadBool = net.ReadBool

    function netchunk.Callback(name, callback)
        assert(name)
        assert(callback)

        net.Receive('netchunk[' .. name .. ']:Send', function()
            local name = ReadString()
            local length = ReadUInt(16)
            local chunk = ReadData(length)
            local finished = ReadBool()

            local chunks = netchunk.chunks[name]

            chunks[#chunks + 1] = chunk

            if finished then
                local raw = merge(chunks)
                local amt = #chunks

                netchunk.chunks[name] = {}

                local data = pon.decode(raw)

                callback(data, #raw, amt)
            end
        end)
    end
end
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/libs/thirdparty/cl_bshadows.lua:
local ScrW = ScrW
local ScrH = ScrH

local sin = math.sin
local cos = math.cos
local rad = math.rad
local ceil = math.ceil

local Start2D = cam.Start2D
local End2D = cam.End2D

local PushRenderTarget = render.PushRenderTarget
local OverrideAlphaWriteEnable = render.OverrideAlphaWriteEnable
local Clear = render.Clear
local CopyRenderTargetToTexture = render.CopyRenderTargetToTexture
local BlurRenderTarget = render.BlurRenderTarget
local PopRenderTarget = render.PopRenderTarget
local SetMaterial = render.SetMaterial
local DrawScreenQuadEx = render.DrawScreenQuadEx
local DrawScreenQuad = render.DrawScreenQuad

local RenderTarget, RenderTarget2
local load_render_targets = function()
	local w, h = ScrW(), ScrH()
	RenderTarget = GetRenderTarget("onyx_bshadows_original" .. w .. h, w, h)
	RenderTarget2 = GetRenderTarget("onyx_bshadows_shadow" .. w .. h,  w, h)
end
load_render_targets()
hook.Add("OnScreenSizeChanged", "onyx.BShadows", load_render_targets)

local ShadowMaterial = CreateMaterial("onyx_bshadows", "UnlitGeneric", {
	["$translucent"] = 1,
	["$vertexalpha"] = 1,
	["alpha"] = 1
})

local ShadowMaterialGrayscale = CreateMaterial("onyx_bshadows_grayscale", "UnlitGeneric", {
	["$translucent"] = 1,
	["$vertexalpha"] = 1,
	["$alpha"] = 1,
	["$color"] = "0 0 0",
	["$color2"] = "0 0 0"
})

local SetTexture = ShadowMaterial.SetTexture

local BSHADOWS = {}

BSHADOWS.BeginShadow = function()
	PushRenderTarget(RenderTarget)

	OverrideAlphaWriteEnable(true, true)
	Clear(0, 0, 0, 0)
	OverrideAlphaWriteEnable(false, false)

	Start2D()
end

BSHADOWS.EndShadow = function(intensity, spread, blur, opacity, direction, distance, _shadowOnly)
	opacity = opacity or 255
	direction = direction or 0
	distance = distance or 0

	CopyRenderTargetToTexture(RenderTarget2)

	if blur > 0 then
		OverrideAlphaWriteEnable(true, true)
		BlurRenderTarget(RenderTarget2, spread, spread, blur)
		OverrideAlphaWriteEnable(false, false)
	end

	PopRenderTarget()

	SetTexture(ShadowMaterial, "$basetexture", RenderTarget)
	SetTexture(ShadowMaterialGrayscale, "$basetexture", RenderTarget2)

	local xOffset = sin(rad(direction)) * distance
	local yOffset = cos(rad(direction)) * distance

	SetMaterial(ShadowMaterialGrayscale)
	for i = 1, ceil(intensity) do
		DrawScreenQuadEx(xOffset, yOffset, ScrW(), ScrH())
	end

	if not _shadowOnly then
		SetTexture(ShadowMaterial, "$basetexture", RenderTarget)
		SetMaterial(ShadowMaterial)
		DrawScreenQuad()
	end

	End2D()
end

onyx.bshadows = BSHADOWS
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/libs/thirdparty/cl_ui3d2d.lua:
if (ui3d2d) then return end

ui3d2d = ui3d2d or {}

do --Input handling
    local useBind = input.LookupBinding("+use", true)
    local attackBind = input.LookupBinding("+attack", true)

    do
        local lookupBinding = input.LookupBinding
        timer.Create("ui3d2d.lookupBindings", 5, 0, function() --Keep our use and attack bind keys up to date
            useBind = lookupBinding("+use", true)
            attackBind = lookupBinding("+attack", true)
        end)
    end

    do
        local getRenderTarget, cursorVisible = render.GetRenderTarget, vgui.CursorVisible
        local getKeyCode, isButtonDown = input.GetKeyCode, input.IsButtonDown

        local inputEnabled, isPressing, isPressed

        hook.Add("PreRender", "ui3d2d.inputHandler", function() --Check the input state before rendering UIs
            if getRenderTarget() then inputEnabled = false return end
            if cursorVisible() then inputEnabled = false return end

            local useKey = useBind and getKeyCode(useBind)
            local attackKey = attackBind and getKeyCode(attackBind)

            inputEnabled = true

            local wasPressing = isPressing
            isPressing = (useKey and isButtonDown(useKey)) or (attackKey and isButtonDown(attackKey))
            isPressed = not wasPressing and isPressing
        end)

        function ui3d2d.isPressing() --Returns true if an input is being held
            return inputEnabled and isPressing
        end

        function ui3d2d.isPressed() --Returns true if an input was pressed this frame
            return inputEnabled and isPressed
        end
    end
end

do --Rendering context creation and mouse position getters
    local localPlayer

    hook.Add("PreRender", "ui3d2d.getLocalPlayer", function() --Keep getting the local player until it's available
        localPlayer = LocalPlayer()
        if IsValid(localPlayer) then hook.Remove("PreRender", "ui3d2d.getLocalPlayer") end
    end)

    local traceLine = util.TraceLine

    local baseQuery = {filter = {}}

    local function isObstructed(eyePos, hitPos, ignoredEntity) --Check if the cursor trace is obstructed by another ent
        local query = baseQuery
        query.start = eyePos
        query.endpos = hitPos
        query.filter[1] = localPlayer
        query.filter[2] = ignoredEntity

        return traceLine(query).Hit
    end

    local mouseX, mouseY

    do
        local start3d2d = cam.Start3D2D
        local isCursorVisible, isHoveringWorld = vgui.CursorVisible, vgui.IsHoveringWorld
        local screenToVector, mousePos = gui.ScreenToVector, gui.MousePos
        local intersectRayWithPlane = util.IntersectRayWithPlane

        local isRendering

        function ui3d2d.startDraw(pos, angles, scale, ignoredEntity) --Starts a new 3d2d ui rendering context
            if isRendering then print("[ui3d2d] Attempted to draw a new 3d2d ui without ending the previous one.") return end

            local eyePos = localPlayer:EyePos()
            local eyePosToUi = pos - eyePos

            do --Only draw the UI if the player is in front of it
                local normal = angles:Up()
                local dot = eyePosToUi:Dot(normal)

                if dot >= 0 then return end
            end

            isRendering = true
            mouseX, mouseY = nil, nil

            start3d2d(pos, angles, scale)

            local cursorVisible, hoveringWorld = isCursorVisible(), isHoveringWorld()
            if not hoveringWorld and cursorVisible then return true end

            local eyeNormal
            do
                if cursorVisible and hoveringWorld then
                    eyeNormal = screenToVector(mousePos())
                else
                    eyeNormal = localPlayer:GetEyeTrace().Normal
                end
            end

            local hitPos = intersectRayWithPlane(eyePos, eyeNormal, pos, angles:Up())
            if not hitPos then return true end

            if isObstructed(eyePos, hitPos, ignoredEntity) then return true end

            do
                local diff = pos - hitPos
                mouseX = diff:Dot(-angles:Forward()) / scale
                mouseY = diff:Dot(-angles:Right()) / scale
            end

            return true
        end

        local end3d2d = cam.End3D2D

        function ui3d2d.endDraw() --Safely ends the 3d2d ui rendering context
            if not isRendering then print("[ui3d2d] Attempted to end a non-existant 3d2d ui rendering context.") return end
            isRendering = false
            end3d2d()
        end
    end

    function ui3d2d.getCursorPos() --Returns the current 3d2d cursor position
        return mouseX, mouseY
    end

    function ui3d2d.isHovering(x, y, w, h) --Returns whether the cursor is within a specified area
        local mx, my = mouseX, mouseY
        return mx and my and mx >= x and mx <= (x + w) and my >= y and my <= (y + h)
    end
end

hook.Run("ui3d2d.fullyLoaded")
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/libs/cl_spoly.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/libs/cl_util.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/core/cl_panel_functions.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

15/04/2022

--]]

local ABSTRACT = {}

--[[------------------------------
Functions
--------------------------------]]
function ABSTRACT:GetX()
    local x = self:GetPos()
    return x
end

function ABSTRACT:GetY()
    local _, y = self:GetPos()
    return y
end

function ABSTRACT:SetX(x)
    self:SetPos(x, self:GetY())
end

function ABSTRACT:SetY(y)
    self:SetPos(self:GetX(), y)
end

-- Traits

function ABSTRACT:Import(name)
    onyx.trait.Import(self, name)
end

-- Events

function ABSTRACT:On(name, fn)
    return onyx.gui.AddEvent(self, name, fn)
end

function ABSTRACT:Call(name, ignoreRaw, ...)
    onyx.gui.CallEvent(self, name, ignoreRaw, ...)
end

function ABSTRACT:InjectEventHandler(name)
    onyx.gui.InjectEventHandler(self, name)
end

-- Misc

function ABSTRACT:Combine(pnl2, fnName)
    self[fnName] = function(_, ...)
        return pnl2[fnName](pnl2, ...)
    end
end

function ABSTRACT:CombineMutator(pnl2, mutatorName)
    self:Combine(pnl2, 'Set' .. mutatorName)
    self:Combine(pnl2, 'Get' .. mutatorName)
end

function ABSTRACT:MakeDispatchFn(pnl2, fnName)
    pnl2[fnName] = function(_, ...)
        return self:Call(fnName, nil, ...)
    end
end

function ABSTRACT:SquareInContainer(class, width, height, size, dock)
    self._Container = self:Add('Panel')
    self._Container:Dock(dock)
    self._Container:SetSize(width, height)

    self._Container.Child = self._Container:Add(class)

    self._Container.PerformLayout = function(panel, w, h)
        local size = size < 1 and math.ceil(math.min(w * size, h * size)) or size

        panel.Child:SetWide(size)
        panel.Child:SetTall(size)
        panel.Child:Center()
    end

    return self._Container.Child
end

function ABSTRACT:Padding(padding)
    self:DockPadding(padding, padding, padding, padding)
end

onyx.abstract = ABSTRACT

--[[------------------------------
Register
--------------------------------]]
for name, fn in pairs(ABSTRACT) do
    onyx.gui.RegisterFunc(name, fn)
end
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_frame_header.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_menu.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2023

--]]

local PANEL = {}

AccessorFunc(PANEL, 'm_bDeleteSelf', 'DeleteSelf')
AccessorFunc(PANEL, 'm_iMinimumWidth', 'MinimumWidth')

local wimgArrow = onyx.wimg.Simple('https://i.imgur.com/KGC51Ws.png', 'smooth mips')
local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')

function PANEL:Init()
    self.backgroundColor = colorPrimary
    self.outlineColor = colorSecondary
    self.options = {}
    self.submenus = {}

    self:SetDrawOnTop(true)
    self:SetDeleteSelf(true)
    self:SetVisible(false)
    self:SetMinimumWidth(onyx.ScaleWide(120))

    local padding = onyx.ScaleTall(2)

    self:DockPadding(padding, padding, padding, padding)

    self.canvas:SetSpace(0)

    RegisterDermaMenuForClose(self)
end

function PANEL:PerformLayout(_, h)
    local _, padding1, _, padding2 = self:GetDockPadding()
    local _, localY = self:LocalToScreen(0, 0)
    local width = self:GetMinimumWidth()
    local height = padding1 + padding2
    local children = self.canvas:GetPanels()
    local childrenCount = #children

    for index, child in ipairs(self.canvas:GetPanels()) do
        height = height + child:GetTall()

        if (index < childrenCount) then
            height = height + select(4, child:GetDockMargin())
        end

        width = math.max(width, child:GetContentWidth() + onyx.ScaleTall(10))
    end

    if (localY + height) > ScrH() then
        height = ScrH() - localY
    end

    self:SetWide(width)
    self:SetTall(height)

    self.BaseClass.PerformLayout(self, width, height)

    self.scroll:DockMargin(0, 0, 0, 0)
end

function PANEL:Paint(w, h)
    local x, y = self:LocalToScreen()
    local thickness = 1

    onyx.bshadows.BeginShadow()
        draw.RoundedBox(8, x, y, w, h, self.outlineColor)
        draw.RoundedBox(8, x + thickness, y + thickness, w - thickness * 2, h - thickness * 2, self.backgroundColor)
    onyx.bshadows.EndShadow(1, 3, 3)
end

function PANEL:ToCursor()
    self:SetPos(input.GetCursorPos())
end

function PANEL:AddOption(text, callback)
    local button = self:Add('onyx.Button')
    button:SetText(text)

    button.OnMousePressed = function(panel)
        onyx.menuButtonPressTime = CurTime()

        panel:Call('DoClick')

        self:Remove()
    end

    button:On('OnCursorEntered', function(panel)
        self:CloseSubMenu()
    end)

    if callback then
        button.DoClick = callback
    end

    table.insert(self.options, button)
    local color = self.backgroundColor

    button:SetColorIdle(color)
    button:SetColorHover(onyx.OffsetColor(button:GetColorIdle(), 10))
    button:SetContentAlignment(4)
    button:SetText('')
    button:InjectEventHandler('Paint')
    button:On('Paint', function(panel, w, h)
        local material = panel.wimage and panel.wimage:GetMaterial() or panel.material
        local x = onyx.ScaleWide(10)

        if (material) then
            local size = onyx.ScaleTall(12)

            surface.SetDrawColor(panel:GetTextColor())
            surface.SetMaterial(material)
            surface.DrawTexturedRect(x, h * .5 - size * .5, size, size)

            x = x + size + onyx.ScaleWide(5)
        end

        draw.SimpleText(text, panel:GetFont(), x, h * .5, panel:GetTextColor(), 0, 1)
    end)

    button.GetContentWidth = function(panel)
        surface.SetFont(panel:GetFont())
        local w = surface.GetTextSize(text)
        local material = panel.wimage and panel.wimage:GetMaterial() or panel.material

        w = w + onyx.ScaleWide(10)

        if (material) then
            w = w + onyx.ScaleTall(12) + onyx.ScaleWide(5)
        end

        if (panel.submenu) then
            w = w + onyx.ScaleTall(12) + onyx.ScaleWide(5)
        end

        return w
    end

    button.SetIcon = function(panel, path, params)
        assert(path, 'no path provided')
        assert(isstring(path), 'path should be a string! alternative method: `SetMaterial`')
        panel.material = Material(path, params)
    end

    button.SetMaterial = function(panel, material)
        assert(material, 'no material provided')
        assert(type(material) == 'IMaterial', 'provided argument should be a IMaterial!')
        panel.material = material
    end

    button.SetIconURL = function(panel, url, params)
        assert(url, 'no url provided')
        panel.wimage = onyx.wimg.Simple(url, params)
    end

    return button
end

function PANEL:CloseSubMenu()
    if IsValid(self.activeSubmenu) then
        self.activeSubmenu:Close()
        self.activeSubmenu:CloseSubMenu()
    end
end

function PANEL:AddSubMenu(text)
    local submenu = vgui.Create('onyx.Menu')
    submenu:SetDeleteSelf(false)
    submenu.backgroundColor = self.backgroundColor
    submenu.outlineColor = self.outlineColor

    local button = self:AddOption(text)
    button:On('OnCursorEntered', function(panel)
        submenu:SetPos(self:GetX() + self:GetWide(), self:GetY() + panel:GetY())
        submenu:Open()
        submenu.parent = panel

        self.activeSubmenu = submenu
    end)
    button:On('Paint', function(panel, w, h)
        local sz = math.floor(h * .33)
        wimgArrow:DrawRotated(w - h * .5, h * .5, sz, sz, 90, panel:GetTextColor())
    end)
    button.submenu = true

    table.insert(self.submenus, submenu)

    return submenu, button
end

function PANEL:Open(parent)
    self:SetVisible(true)
    self:MakePopup()
    self:SetKeyBoardInputEnabled(false)
    self:InvalidateLayout(true)

    if (IsValid(parent)) then
        onyx.gui.InjectEventHandler(parent, 'OnRemove')
        onyx.gui.AddEvent(parent, 'OnRemove', function()
            if (IsValid(self)) then
                self:Remove()
            end
        end)
    end
end

function PANEL:Close()
    if (self.m_bDeleteSelf) then
        self:Remove()
    else
        self:SetVisible(false)
    end
end

function PANEL:OnRemove()
    for _, submenu in ipairs(self.submenus) do
        if (IsValid(submenu)) then
            submenu:Remove()
        end
    end
end

onyx.gui.Register('onyx.Menu', PANEL, 'onyx.ScrollPanel')

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .3, .65, function(self)
--     self:MakePopup()

--     local content = self:Add('Panel')
--     content:Dock(FILL)
--     content:DockMargin(5, 5, 5, 5)

--     for i = 1, 10 do
--         local btn = content:Add('onyx.ComboBox')
--         btn:Dock(TOP)
--         btn:DockMargin(0, 0 ,0 ,5)
--         btn.DoClick = function(panel)
--             local x, y = panel:LocalToScreen(0, 0)

--             y = y + panel:GetTall()

--             local menu = vgui.Create('onyx.Menu')
--             menu:SetPos(x, y)
--             menu:SetMinimumWidth(panel:GetWide())
--             menu:AddOption('Drop')
--             menu:AddOption('Sell')

--             local submenu = menu:AddSubMenu('Destroy')
--             -- submenu:AddOption('Confirm'):SetIcon('icon16/tick.png')
--             -- submenu:AddOption('Cancel'):SetIcon('icon16/cross.png')
--             submenu:AddOption('Confirm'):SetIconURL('https://i.imgur.com/iK1nMwr.png', 'smooth mips')
--             submenu:AddOption('Cancel'):SetIconURL('https://i.imgur.com/TF7kX2N.png', 'smooth mips')

--             menu:Open()
--         end
--     end

-- end)
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/core/cl_favorites.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/core/stats/cl_stats.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/cfg/cl_actions.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

04/01/2024

--]]

onyx.f4.actions = {}

local CATEGORY = 'f4_general_u'

local L = function(...) return onyx.lang:Get(...) end

local CUSTOMCHECK_POLICE = function(client)
    return client:isCP()
end

local CUSTOMCHECK_MAYOR = function(client)
    return client:isMayor()
end

onyx.f4:RegisterAction({
    name = 'f4_action_drop_money',
    category = CATEGORY,
    func = function()
        onyx.SimpleQuery(
            L('f4_action_drop_money'),
            L('f4_action_input_amount'),
            true,
            function(value)
                RunConsoleCommand('darkrp', 'dropmoney', value)
            end, L('f4_confirm_u'),
            nil, L('f4_cancel_u')
        )
    end
})

onyx.f4:RegisterAction({
    name = 'f4_action_give_money',
    category = CATEGORY,
    func = function()
        onyx.SimpleQuery(
            L('f4_action_give_money'),
            L('f4_action_input_amount'),
            true,
            function(value)
                RunConsoleCommand('darkrp', 'give', value)
            end, L('f4_confirm_u'),
            nil, L('f4_cancel_u')
        )
    end
})

onyx.f4:RegisterAction({
    name = 'f4_action_change_name',
    category = CATEGORY,
    func = function()
        onyx.SimpleQuery(
            L('f4_action_change_name'),
            L('f4_action_input_text'),
            true,
            function(value)
                RunConsoleCommand('darkrp', 'rpname', value)
            end, L('f4_confirm_u'),
            nil, L('f4_cancel_u')
        )
    end
})

onyx.f4:RegisterAction({
    name = 'f4_action_drop_weapon',
    category = CATEGORY,
    func = function()
        RunConsoleCommand('darkrp', 'dropweapon')
    end
})

onyx.f4:RegisterAction({
    name = 'f4_action_sell_doors',
    category = CATEGORY,
    func = function()
        onyx.SimpleQuery(
            L('f4_action_sell_doors'),
            L('f4_action_confirm_action'),
            false,
            function()
                RunConsoleCommand('darkrp', 'sellalldoors')
            end, L('f4_confirm_u'),
            nil, L('f4_cancel_u')
        )
    end
})

CATEGORY = 'f4_police_u'

onyx.f4:RegisterAction({
    name = 'f4_action_warrant',
    category = CATEGORY,
    canSee = CUSTOMCHECK_POLICE,
    func = function()
        onyx.ChoosePlayer(
            L('f4_action_warrant'),
            L('f4_action_choose_player'),
            function(ply)
                local name = ply:Name()

                onyx.SimpleQuery(
                    L('f4_action_warrant'),
                    L('f4_action_input_reason'),
                    true,
                    function(reason)
                        RunConsoleCommand('darkrp', 'warrant', name, reason)
                    end
                )
            end
        )
    end
})

onyx.f4:RegisterAction({
    name = 'f4_action_wanted',
    category = CATEGORY,
    canSee = CUSTOMCHECK_POLICE,
    func = function()
        onyx.ChoosePlayer(
            L('f4_action_wanted'),
            L('f4_action_choose_player'),
            function(ply)
                local name = ply:Name()

                onyx.SimpleQuery(
                    L('f4_action_wanted'),
                    L('f4_action_input_reason'),
                    true,
                    function(reason)
                        RunConsoleCommand('darkrp', 'wanted', name, reason)
                    end
                )
            end
        )
    end
})

CATEGORY = 'f4_mayor_u'

onyx.f4:RegisterAction({
    name = 'f4_toggle_lockdown',
    category = CATEGORY,
    canSee = CUSTOMCHECK_MAYOR,
    func = function()
        if (GetGlobalBool('DarkRP_LockDown')) then
            RunConsoleCommand('darkrp', 'unlockdown')
        else
            RunConsoleCommand('darkrp', 'lockdown')
        end
    end
})

onyx.f4:RegisterAction({
    name = 'f4_give_license',
    category = CATEGORY,
    canSee = CUSTOMCHECK_MAYOR,
    func = function()
        RunConsoleCommand('darkrp', 'givelicense')
    end
})
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/ui/cl_tab_jobs.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/languages/cl_german.lua:
--[[

Editor: thestarhd
Dutscher bersetzer Profil: https://www.gmodstore.com/users/thestarhd
 
05/09/2024
 
--]]
 
local LANG = {}
 
--[[
    .............
    Allgemeine Wrter
]]--
 
LANG[ 'hud_status_wanted' ] = 'Gesucht'
LANG[ 'hud_status_speaking' ] = 'Spricht'
LANG[ 'hud_status_typing' ] = 'Schreibt'
LANG[ 'props' ] = 'Gegenstnde'
LANG[ 'close' ] = 'Schlieen'
LANG[ 'alert' ] = 'Alarm'
LANG[ 'message' ] = 'Nachricht'
LANG[ 'unknown' ] = 'Unbekannt'
LANG[ 'accept' ] = 'Akzeptieren'
LANG[ 'deny' ] = 'Ablehnen'
LANG[ 'none' ] = 'Keine'
LANG[ 'add' ] = 'Hinzufgen'
LANG[ 'remove' ] = 'Entfernen'
LANG[ 'jobs' ] = 'Jobs'
LANG[ 'door' ] = 'Tr'
LANG[ 'vehicle' ] = 'Fahrzeug'
LANG[ 'door_groups' ] = 'Trgruppen'
LANG[ 'display' ] = 'Anzeigen'
LANG[ 'general' ] = 'Allgemein'
LANG[ 'speedometer' ] = 'Tachometer'
LANG[ 'fuel' ] = 'Benzin'
LANG[ 'vote' ] = 'Abstimmen'
LANG[ 'question' ] = 'Frage'
 
--[[
    .......
    Verbindungsabbruch
]]--
 
LANG[ 'timeout_title' ] = 'VERBINDUNG VERLOREN'
LANG[ 'timeout_info' ] = 'Server ist derzeit nicht verfgbar, wir entschuldigen uns'
LANG[ 'timeout_status' ] = 'Du wirst in %d Sekunden erneut verbunden'
 
--[[
    ......
    Themen
]]--
 
LANG[ 'hud.theme.default.name' ] = 'Standard'
LANG[ 'hud.theme.forest.name' ] = 'Wald'
LANG[ 'hud.theme.violet_night.name' ] = 'Violette Nacht'
LANG[ 'hud.theme.rustic_ember.name' ] = 'Rustikale Glut'
LANG[ 'hud.theme.green_apple.name' ] = 'Grner Apfel'
LANG[ 'hud.theme.lavender.name' ] = 'Lavendel'
LANG[ 'hud.theme.elegance.name' ] = 'Eleganz'
LANG[ 'hud.theme.mint_light.name' ] = 'Minze'
LANG[ 'hud.theme.gray.name' ] = 'Grau'
LANG[ 'hud.theme.rose_garden.name' ] = 'Rosengarten'
LANG[ 'hud.theme.ocean_wave.name' ] = 'Ozeanwelle'
LANG[ 'hud.theme.sky_blue.name' ] = 'Himmelblau'
LANG[ 'hud.theme.golden_dawn.name' ] = 'Goldene Dmmerung'
 
--[[
    ....
    Hilfe
    - Ganzer Satz: "Gebe <command> ein, um die Einstellungen zu ffnen"
]]--
 
LANG[ 'hud_help_type' ] = 'Gebe ein'
LANG[ 'hud_help_to' ] = 'um die Einstellungen zu ffnen'
 
--[[
    .............
    3D2D Tren
]]--
 
LANG[ 'door_purchase' ] = 'Kaufe {object}'
LANG[ 'door_sell' ] = 'Verkaufe {object}'
LANG[ 'door_addowner' ] = 'Eigentmer hinzufgen'
LANG[ 'door_rmowner' ] = 'Eigentmer entfernen'
LANG[ 'door_rmowner_help' ] = 'Whle den Spieler, dem du das Eigentum entziehen mchtest'
LANG[ 'door_addowner_help' ] = 'Whle den Spieler, dem du das Eigentum gewhren mchtest'
LANG[ 'door_title' ] = 'Titel festlegen'
LANG[ 'door_title_help' ] = 'Welchen Titel mchtest du festlegen?'
LANG[ 'door_admin_disallow' ] = 'Kaufen verbieten'
LANG[ 'door_admin_allow' ] = 'Kaufen erlauben'
LANG[ 'door_admin_edit' ] = 'Zugriff bearbeiten'
LANG[ 'door_owned' ] = 'Privatbesitz'
LANG[ 'door_unowned' ] = 'Zu Verkaufen'
 
LANG[ 'hud_door_help' ] = 'Drcke {bind}, um fr {price} zu kaufen'
LANG[ 'hud_door_owner' ] = 'Eigentmer: {name}'
LANG[ 'hud_door_allowed' ] = 'Eigentmer erlaubt'
LANG[ 'hud_door_coowners' ] = 'Miteigentmer'
LANG[ 'hud_and_more' ] = 'und mehr...'
 
--[[
    .........
    Grobuchstaben
]]--
 
LANG[ 'reconnect_u' ] = 'ERNEUT VERBINDEN'
LANG[ 'disconnect_u' ] = 'TRENNEN'
LANG[ 'settings_u' ] = 'EINSTELLUNGEN'
LANG[ 'configuration_u' ] = 'KONFIGURATION'
LANG[ 'introduction_u' ] = 'EINFHRUNG'
 
--[[
    .........
    Kleinbuchstaben
]]--
 
LANG[ 'seconds_l' ] = 'sekunden'
LANG[ 'minutes_l' ] = 'minuten'
 
--[[
    .............
    Konfiguration
]]--
 
LANG[ 'hud.timeout.name' ] = 'Timeout-Dauer'
LANG[ 'hud.timeout.desc' ] = 'Wie viele Sekunden bis zur automatischen Wiederverbindung'
 
LANG[ 'hud.alert_queue.name' ] = 'Alarm-Warteschlange'
LANG[ 'hud.alert_queue.desc' ] = 'Sollen Alarme in die Warteschlange gestellt werden'
 
LANG[ 'hud.props_counter.name' ] = 'Gegenstandzhler'
LANG[ 'hud.props_counter.desc' ] = 'Gegenstandzhler anzeigen'
 
LANG[ 'hud.main_avatar_mode.name' ] = 'Haupt-Avatar-Typ'
LANG[ 'hud.main_avatar_mode.desc' ] = 'Whle den Typ'
 
LANG[ 'hud.voice_avatar_mode.name' ] = 'Stimm-Avatar-Typ'
LANG[ 'hud.voice_avatar_mode.desc' ] = 'Whle den Typ'
 
LANG[ 'hud.restrict_themes.name' ] = 'Themen einschrnken'
LANG[ 'hud.restrict_themes.desc' ] = 'Spielern die Themenwahl einschrnken'
 
LANG[ 'hud.speedometer_mph.name' ] = 'Meilen verwenden'
LANG[ 'hud.speedometer_mph.desc' ] = 'Einheiten auf Meilen pro Stunde umstellen'
 
LANG[ 'hud.speedometer_max_speed.name' ] = 'Maximale Standardgeschwindigkeit'
LANG[ 'hud.speedometer_max_speed.desc' ] = 'Die maximale Geschwindigkeit fr den Tacho'
 
LANG[ 'hud_should_draw' ] = 'Soll das Element gezeichnet werden'
LANG[ 'hud.main.name' ] = 'Haupt-HUD'
LANG[ 'hud.ammo.name' ] = 'Munition'
LANG[ 'hud.agenda.name' ] = 'Agenda'
LANG[ 'hud.alerts.name' ] = 'Alarme'
LANG[ 'hud.pickup_history.name' ] = 'Aufnahmeverlauf'
LANG[ 'hud.level.name' ] = 'Level'
LANG[ 'hud.voice.name' ] = 'Stimm-Panels'
LANG[ 'hud.overhead_health.name' ] = '3D2D berkopfanzeige fr Gesundheit'
LANG[ 'hud.overhead_armor.name' ] = '3D2D berkopfanzeige fr Rstung'
LANG[ 'hud.vehicle.name' ] = 'Fahrzeug-HUD'
 
--[[
    ........
    Einstellungen
]]--
 
LANG[ 'hud.theme.name' ] = 'Thema'
LANG[ 'hud.theme.desc' ] = 'Whle das HUD-Thema'
 
LANG[ 'hud.scale.name' ] = 'Skalierung'
LANG[ 'hud.scale.desc' ] = 'Skalierung des HUD anpassen'
 
LANG[ 'hud.roundness.name' ] = 'Rundheit'
LANG[ 'hud.roundness.desc' ] = 'Die Rundheit des HUD anpassen'
 
LANG[ 'hud.margin.name' ] = 'Rand'
LANG[ 'hud.margin.desc' ] = 'Abstand zwischen HUD und den Rndern'
 
LANG[ 'hud.icons_3d.name' ] = '3D-Modelle'
LANG[ 'hud.icons_3d.desc' ] = 'Modell-Icons in 3D rendern'
 
LANG[ 'hud.compact.name' ] = 'Kompaktmodus'
LANG[ 'hud.compact.desc' ] = 'Kompaktmodus aktivieren'
 
LANG[ 'hud.speedometer_blur.name' ] = 'Tacho Unschrfe'
LANG[ 'hud.speedometer_blur.desc' ] = 'Unschrfe fr den Tacho aktivieren'
 
LANG[ 'hud.3d2d_max_details.name' ] = 'Maximale 3D2D-Details'
LANG[ 'hud.3d2d_max_details.desc' ] = 'Maximale Menge an detaillierten Informationen rendern'
 
--[[
    ......
    Status
]]--
 
LANG[ 'hud_lockdown' ] = 'LOCKDOWN'
LANG[ 'hud_lockdown_help' ] = 'Bitte kehre in dein Haus zurck!'
 
LANG[ 'hud_wanted' ] = 'GESUCHT'
LANG[ 'hud_wanted_help' ] = 'Grund: {reason}'
 
LANG[ 'hud_arrested' ] = 'VERHAFTET'
LANG[ 'hud_arrested_help' ] = 'Du wirst in {time} freigelassen'
 
onyx.lang:AddPhrases( 'german', LANG )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/languages/cl_turkish.lua:
--[[

Yazar: tochnonement
E-posta: tochnonement@gmail.com
evirmen: shazzam0

04/09/2024

--]]

local LANG = {}

--[[
    .............
    Genel Kelimeler
]]--

LANG[ 'hud_status_wanted' ] = 'Aranyor'
LANG[ 'hud_status_speaking' ] = 'Konuuyor'
LANG[ 'hud_status_typing' ] = 'Yazyor'
LANG[ 'props' ] = 'Eyalar'
LANG[ 'close' ] = 'Kapat'
LANG[ 'alert' ] = 'Uyar'
LANG[ 'message' ] = 'Mesaj'
LANG[ 'unknown' ] = 'Bilinmiyor'
LANG[ 'accept' ] = 'Kabul Et'
LANG[ 'deny' ] = 'Reddet'
LANG[ 'none' ] = 'Yok'
LANG[ 'add' ] = 'Ekle'
LANG[ 'remove' ] = 'Kaldr'
LANG[ 'jobs' ] = 'Meslekler'
LANG[ 'door' ] = 'Kap'
LANG[ 'vehicle' ] = 'Ara'
LANG[ 'door_groups' ] = 'Kap Gruplar'
LANG[ 'display' ] = 'Grntle'
LANG[ 'general' ] = 'Genel'
LANG[ 'speedometer' ] = 'Hz Gstergesi'
LANG[ 'fuel' ] = 'Yakt'
LANG[ 'vote' ] = 'Oy'
LANG[ 'question' ] = 'Soru'

--[[
    .......
    Balant Sresi Am
]]--

LANG[ 'timeout_title' ] = 'BALANTI KAYBEDLD'
LANG[ 'timeout_info' ] = 'Sunucu u anda kullanlamyor, zr dileriz'
LANG[ 'timeout_status' ] = '%d saniye iinde yeniden balanacaksnz'

--[[
    ......
    Temalar
]]--

LANG[ 'hud.theme.default.name' ] = 'Varsaylan'
LANG[ 'hud.theme.forest.name' ] = 'Orman'
LANG[ 'hud.theme.violet_night.name' ] = 'Mor Gece'
LANG[ 'hud.theme.rustic_ember.name' ] = 'Rustik Kor'
LANG[ 'hud.theme.green_apple.name' ] = 'Yeil Elma'
LANG[ 'hud.theme.lavender.name' ] = 'Lavanta'
LANG[ 'hud.theme.elegance.name' ] = 'Zarafet'
LANG[ 'hud.theme.mint_light.name' ] = 'Nane'
LANG[ 'hud.theme.gray.name' ] = 'Gri'
LANG[ 'hud.theme.rose_garden.name' ] = 'Gl Bahesi'
LANG[ 'hud.theme.ocean_wave.name' ] = 'Okyanus Dalgas'
LANG[ 'hud.theme.sky_blue.name' ] = 'Gkyz Mavisi'
LANG[ 'hud.theme.golden_dawn.name' ] = 'Altn afak'

--[[
    ....
    Yardm
    - Tam cmle: "Ayarlar amak iin <komut> yazn"
]]

LANG[ 'hud_help_type' ] = 'Yazn'
LANG[ 'hud_help_to' ] = 'ayarlar amak iin'

--[[
    .............
    3D2D Kaplar
]]--

LANG[ 'door_purchase' ] = '{object} Satn Al'
LANG[ 'door_sell' ] = '{object} Sat'
LANG[ 'door_addowner' ] = 'Sahip Ekle'
LANG[ 'door_rmowner' ] = 'Sahip Kaldr'
LANG[ 'door_rmowner_help' ] = 'Sahipliini iptal etmek istediiniz oyuncuyu sein'
LANG[ 'door_addowner_help' ] = 'Sahiplik vermek istediiniz oyuncuyu sein'
LANG[ 'door_title' ] = 'Balk Ayarla'
LANG[ 'door_title_help' ] = 'Hangi bal ayarlamak istiyorsunuz?'
LANG[ 'door_admin_disallow' ] = 'Sahiplii Reddet'
LANG[ 'door_admin_allow' ] = 'Sahiplie zin Ver'
LANG[ 'door_admin_edit' ] = 'Eriimi Dzenle'
LANG[ 'door_owned' ] = 'zel Mlk'
LANG[ 'door_unowned' ] = 'Satlk'

LANG[ 'hud_door_help' ] = '{price} iin {bind} tuuna basarak satn aln'
LANG[ 'hud_door_owner' ] = 'Sahibi: {name}'
LANG[ 'hud_door_allowed' ] = 'Sahip Olmasna zin Verilenler'
LANG[ 'hud_door_coowners' ] = 'Ortak Sahipler'
LANG[ 'hud_and_more' ] = 've daha fazlas...'

--[[
    .........
    Byk Harf
]]--

LANG[ 'reconnect_u' ] = 'YENDEN BALAN'
LANG[ 'disconnect_u' ] = 'BALANTISINI KES'
LANG[ 'settings_u' ] = 'AYARLAR'
LANG[ 'configuration_u' ] = 'KONFGRASYON'
LANG[ 'introduction_u' ] = 'GR'

--[[
    .........
    Kk Harf
]]--

LANG[ 'seconds_l' ] = 'saniye'
LANG[ 'minutes_l' ] = 'dakika'

--[[
    .............
    Konfigrasyon
]]--

LANG[ 'hud.timeout.name' ] = 'Zaman Am Sresi'
LANG[ 'hud.timeout.desc' ] = 'Otomatik yeniden balantdan nceki saniye says'

LANG[ 'hud.alert_queue.name' ] = 'Uyar Sras'
LANG[ 'hud.alert_queue.desc' ] = 'Uyarlar sraya yerletirilsin mi?'

LANG[ 'hud.props_counter.name' ] = 'Eya Sayac'
LANG[ 'hud.props_counter.desc' ] = 'Eya sayacn gster'

LANG[ 'hud.main_avatar_mode.name' ] = 'Ana Avatar Tr'
LANG[ 'hud.main_avatar_mode.desc' ] = 'Tr sein'

LANG[ 'hud.voice_avatar_mode.name' ] = 'Ses Avatar Tr'
LANG[ 'hud.voice_avatar_mode.desc' ] = 'Tr sein'

LANG[ 'hud.restrict_themes.name' ] = 'Tema Kstla'
LANG[ 'hud.restrict_themes.desc' ] = 'Oyuncularn tema seimini kstla'

LANG[ 'hud.speedometer_mph.name' ] = 'Mil Kullan'
LANG[ 'hud.speedometer_mph.desc' ] = 'Birimi mil/saat olarak deitir'

LANG[ 'hud.speedometer_max_speed.name' ] = 'Maksimum Varsaylan Hz'
LANG[ 'hud.speedometer_max_speed.desc' ] = 'Hz gstergesi iin maksimum hz'

LANG[ 'hud_should_draw' ] = 'eyi izmelisin'
LANG[ 'hud.main.name' ] = 'Ana HUD'
LANG[ 'hud.ammo.name' ] = 'Mermi'
LANG[ 'hud.agenda.name' ] = 'Gndem'
LANG[ 'hud.alerts.name' ] = 'Uyarlar'
LANG[ 'hud.pickup_history.name' ] = 'Toplama Gemii'
LANG[ 'hud.level.name' ] = 'Seviye'
LANG[ 'hud.voice.name' ] = 'Ses Panelleri'
LANG[ 'hud.overhead_health.name' ] = '3D2D st Salk'
LANG[ 'hud.overhead_armor.name' ] = '3D2D st Zrh'
LANG[ 'hud.vehicle.name' ] = 'Ara HUD'

--[[
    ........
    Ayarlar
]]--

LANG[ 'hud.theme.name' ] = 'Tema'
LANG[ 'hud.theme.desc' ] = 'HUD temasn se'

LANG[ 'hud.scale.name' ] = 'lek'
LANG[ 'hud.scale.desc' ] = 'HUD leini ayarla'

LANG[ 'hud.roundness.name' ] = 'Yuvarlaklk'
LANG[ 'hud.roundness.desc' ] = 'HUD\'un yuvarlakln ayarla'

LANG[ 'hud.margin.name' ] = 'Kenar Boluu'
LANG[ 'hud.margin.desc' ] = 'HUD ile kenarlar arasndaki mesafe'

LANG[ 'hud.icons_3d.name' ] = '3D Modeller'
LANG[ 'hud.icons_3d.desc' ] = 'Model simgelerini 3D olarak render et'

LANG[ 'hud.compact.name' ] = 'Kompakt Mod'
LANG[ 'hud.compact.desc' ] = 'Kompakt modu etkinletir'

LANG[ 'hud.speedometer_blur.name' ] = 'Hz Gstergesi Bulankl'
LANG[ 'hud.speedometer_blur.desc' ] = 'Hz gstergesi iin bulankl etkinletir'

LANG[ 'hud.3d2d_max_details.name' ] = 'Maksimum 3D2D Detaylar'
LANG[ 'hud.3d2d_max_details.desc' ] = 'Maksimum detayl bilgi render says'

--[[
    ......
    Durum
]]--

LANG[ 'hud_lockdown' ] = 'SOKAA IKMA YASAI'
LANG[ 'hud_lockdown_help' ] = 'Ltfen evlerinize dnn!'

LANG[ 'hud_wanted' ] = 'ARANIYOR'
LANG[ 'hud_wanted_help' ] = 'Sebep: {reason}'

LANG[ 'hud_arrested' ] = 'TUTUKLU'
LANG[ 'hud_arrested_help' ] = '{time} iinde serbest braklacaksnz'

onyx.lang:AddPhrases( 'turkish', LANG )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/cfg/cl_level_systems.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

21/08/2024

--]]

onyx.hud.RegisterLevelSystem( 'vrodankis', {
    getLevel = function( ply )
        return ( ply:getDarkRPVar( 'level' ) or 1 )
    end,
    getXP = function( ply )
        return ( ply:getDarkRPVar( 'xp' ) or 0 )
    end,
    getMaxXP = function( ply )
        -- omg...
        -- this is from Vrondakis, there is no util func
        local level = ( ply:getDarkRPVar( 'level' ) or 1 )
        local maxXP = ( ( ( 10 + ( ( level * ( level + 1 ) * 90 ) ) ) ) * LevelSystemConfiguration.XPMult )
        return maxXP
    end,
    customCheck = function()
        return ( LevelSystemConfiguration ~= nil )
    end,
    onDetected = function()
        hook.Remove( 'HUDPaint', 'manolis:MVLevels:HUDPaintA' )
    end
} )

onyx.hud.RegisterLevelSystem( 'glorified', {
    getLevel = function( ply )
        return GlorifiedLeveling.GetPlayerLevel( ply )
    end,
    getXP = function( ply )
        return GlorifiedLeveling.GetPlayerXP( ply )
    end,
    getMaxXP = function( ply )
        return GlorifiedLeveling.GetPlayerMaxXP( ply )
    end,
    customCheck = function()
        return ( GlorifiedLeveling ~= nil )
    end,
    onDetected = function()
        hook.Remove( 'HUDPaint', 'GlorifiedLeveling.HUD.HUDPaint' )
    end
} )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_vehicle_hud.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

20/08/2024

--]]

local COLOR_GREEN, COLOR_RED = Color( 96, 230, 39), Color( 252, 30, 30 )
local COLOR_SHADOW = Color( 0, 0, 0, 100 )
local COLOR_FUEL = Color( 196, 88, 0)
local CONVAR_BLUR = CreateClientConVar( 'cl_onyx_hud_speedometer_blur', '1', true, false, '', 0, 1 )

local STATUS_ICONS = {
    [ 'simfphys' ] = {
        {
            id = 'parking-brake',
            icons = {
                [ 1 ] = { 
                    url = 'https://i.imgur.com/DhZNMqx.png',
                    color = Color( 255, 0, 0 )
                }
            },
            getState = function( vehicle )
                return ( vehicle:GetHandBrakeEnabled() and 1 or 0 )
            end
        },
        {
            id = 'cruise-control',
            icons = {
                [ 1 ] = { 
                    url = 'https://i.imgur.com/rSkZck6.png',
                    color = Color( 166, 255, 0)
                }
            },
            getState = function( vehicle )
                return ( vehicle:GetIsCruiseModeOn() and 1 or 0 )
            end
        },
        {
            id = 'fog-light',
            icons = {
                [ 1 ] = { 
                    url = 'https://i.imgur.com/DgPmV27.png',
                    color = Color( 255, 204, 0)
                }
            },
            getState = function( vehicle )
                return ( vehicle:GetFogLightsEnabled() and 1 or 0 )
            end
        },
        {
            id = 'low-beam',
            icons = {
                [ 1 ] = { 
                    url = 'https://i.imgur.com/ckEQdme.png',
                    color = Color( 51, 255, 0)
                },
                [ 2 ] = { 
                    url = 'https://i.imgur.com/DKVPVJd.png',
                    color = Color( 0, 38, 255)
                },
            },
            getState = function( vehicle )
                if ( vehicle:GetLightsEnabled() ) then
                    if ( vehicle:GetLampsEnabled() ) then
                        return 2
                    else
                        return 1
                    end
                else
                    return 0
                end
            end
        },
    }
}

local hud = onyx.hud
local lerpSpeed

local function drawLine( x1, y1, x2, y2, wide, color )
	local diffX, diffY = x1 - x2, y1 - y2
    local rad = math.atan2( diffX, diffY )
	local rotation = math.deg( rad )
    local height = Vector( x1, y1 ):Distance( Vector( x2, y2 ) )
	
	x1 = x1 - math.floor( diffX * .5 )
	y1 = y1 - math.floor( diffY * .5 )
	
	draw.NoTexture()
    surface.SetDrawColor( color )
	surface.DrawTexturedRectRotated( x1, y1, wide, height, rotation )
end

local function convertToMPH( kmh )
    return kmh * 0.621371
end

local function getMaxSpeed( vehicle, useMPH )
    local maxSpeed = vehicle.GetMaxSpeed and vehicle:GetMaxSpeed() or hud:GetOptionValue( 'speedometer_max_speed' )
    if ( ( maxSpeed / 10 ) % 2 ~= 0 ) then maxSpeed = maxSpeed + 10 end

    local clampedSpeed = math.min( maxSpeed, 300 )

    if ( useMPH ) then
        return math.floor( convertToMPH( clampedSpeed ) / 10 ) * 10
    else
        return clampedSpeed
    end
end

local function drawFuelHUD( element, client, vehicle, scrW, scrH, theme )
    local curFuel = vehicle:GetFuel()
    local maxFuel = vehicle:GetMaxFuel()
	local fuel = curFuel / maxFuel

    local w = hud.ScaleWide( 200 )
    local h = hud.ScaleTall( 40 )
    local x0 = scrW * .5
    local x = x0 - w * .5
    local y = scrH - h - hud.GetScreenPadding()
    local colors = theme.colors

    local horPadding = hud.ScaleTall( 10 )
    local verPadding = hud.ScaleTall( 7.5 )
    local lineW = w - horPadding * 2
    local lineH = hud.ScaleTall( 5 )
    local lineX = x + horPadding
    local lineY = y + h - lineH - verPadding
    local textY = y + verPadding * .5

    hud.DrawRoundedBox( x, y, w, h, colors.primary )
    hud.DrawRoundedBox( lineX, lineY, lineW, lineH, colors.textTertiary  )

    draw.SimpleText( onyx.lang:Get( 'fuel' ), hud.fonts.TinyBold, x + horPadding, textY, colors.textPrimary, 0, 0 )

    local textW = draw.SimpleText( ' / ' .. maxFuel, hud.fonts.Tiny, x + w - horPadding, textY, colors.textSecondary, 2, 0 )
    draw.SimpleText( math.Round( curFuel, 1 ), hud.fonts.TinyBold, x + w - horPadding - textW, textY, COLOR_FUEL, 2, 0 )

    render.SetScissorRect( lineX, lineY, lineX + lineW * fuel, lineY + lineH, true )
        hud.DrawRoundedBox( lineX, lineY, lineW, lineH, COLOR_FUEL  )
    render.SetScissorRect( 0, 0, 0, 0, false )
end

local function drawVehicleHUD( element, client, scrW, scrH )
    local cache = element.cache
    local vehicle = client:GetVehicle()
    if ( not IsValid( vehicle ) ) then return end

    local parent = vehicle:GetParent()
    if ( IsValid( parent ) ) then
        vehicle = parent
    elseif ( vehicle:GetClass() == 'prop_vehicle_prisoner_pod' ) then
        return
    end

    if ( vehicle.GetDriver == nil ) then return end
    if ( vehicle:GetDriver() ~= client ) then return end

    local isAdvanced = simfphys and simfphys.IsCar( vehicle )
    if ( isAdvanced and cvars.Bool( 'cl_simfphys_hud' ) ) then RunConsoleCommand( 'cl_simfphys_hud', 0 ) end -- we cannot just turn block their hook, because there are things beside hud (for example turn signal controls :\)
    
    local size = hud.ScaleTall( 250 )
    local screenPadding = hud.GetScreenPadding()
    local x, y = scrW - size - screenPadding, scrH - size - screenPadding
    local x0, y0 = x + size * .5, y + size * .5

    local theme = hud:GetCurrentTheme()
    local colors = theme.colors

    local outerRadius = math.floor( size * .5 )
    local innerRadius = math.floor( outerRadius * .9 )
    local arcLength = 270

    cache.outerMask = cache.outerMask or onyx.CalculateCircle( x0, y0, outerRadius + 1, 24 )
    cache.innerMask = cache.innerMask or onyx.CalculateArc( x0, y0, 180 + 45, arcLength, outerRadius + 1, 24, true )

    local outerMask = cache.outerMask
    local innerMask = cache.innerMask

    local speed = vehicle:GetVelocity():Length()
    local useMPH = hud:GetOptionValue( 'speedometer_mph' )
    local maxSpeed = getMaxSpeed( vehicle, useMPH )

    local dividers = math.floor( maxSpeed / ( useMPH and 10 or 20 ) )

    local rawSpeed = speed * .09141 * .75
    if ( useMPH ) then rawSpeed = convertToMPH( rawSpeed ) end

	local converted = math.min( maxSpeed, rawSpeed )

    lerpSpeed = Lerp( FrameTime() * 8, lerpSpeed or converted, converted )

    local circFraction = lerpSpeed / maxSpeed
    local colorLine = onyx.LerpColor( circFraction, COLOR_GREEN, COLOR_RED )

    -- Draw blur
    if ( CONVAR_BLUR:GetBool() ) then
        onyx.DrawWithPolyMask( outerMask, function()
            onyx.DrawBlurExpensive( vgui.GetWorldPanel(), 6 )
        end )
    end

    -- Draw background
    onyx.DrawCircle( x0, y0, outerRadius, ColorAlpha( colors.primary, theme.dark and 200 or 100 ) )

    local _, textH = draw.SimpleText( math.Round( lerpSpeed ), hud.fonts.Speedometer, x0, y + size, colors.textPrimary, 1, 4 )
    draw.SimpleText( useMPH and 'mph' or 'km/h', hud.fonts.SmallBold, x0, y + size - textH * .8, colors.textSecondary, 1, 4 )

    -- Draw lines & numbers
    local angStep = 270 / ( dividers )
    local lineLength = hud.ScaleTall( 15 )
    local lineCircRadius = innerRadius - 1
    local lineWidth = hud.ScaleTall( 2 )

    for index = 0, dividers do
        local curAng = angStep * index + 90 + 45
        local rad = math.rad( curAng )
        local cos, sin = math.cos( rad ), math.sin( rad )
        local raw = index * math.Round( maxSpeed / dividers )
        local value = math.Round( raw )
        local textColor = ( math.floor( lerpSpeed ) > 0 and lerpSpeed >= value ) and colorLine or colors.textSecondary
    
        drawLine( x0 + cos * lineCircRadius, y0 + sin * lineCircRadius, x0 + cos * ( lineCircRadius - lineLength ), y0 + sin * ( lineCircRadius - lineLength ), lineWidth, textColor )

        draw.SimpleText( value, hud.fonts.SmallBold, x0 + cos * innerRadius * .75 + 1, y0 + sin * innerRadius * .75 + 1, COLOR_SHADOW, 1, 1 )
        draw.SimpleText( value, hud.fonts.SmallBold, x0 + cos * innerRadius * .75, y0 + sin * innerRadius * .75, textColor, 1, 1 )
    end

    -- Draw line background
    onyx.DrawWithPolyMask( innerMask, function()
        onyx.DrawOutlinedCircle( x0, y0, innerRadius, 1, colors.textSecondary )
    end )

    -- Draw line fill
    local innerMaskFill = onyx.CalculateArc( x0, y0, 180 + 45, arcLength * circFraction, innerRadius, 24, true )

    onyx.DrawWithPolyMask( innerMaskFill, function()
        onyx.DrawOutlinedCircle( x0, y0, innerRadius, 2, colorLine )
    end )

    -- Draw additional info ( simfphys )
    if ( isAdvanced ) then
        local statusTable = STATUS_ICONS[ 'simfphys' ]

        -- it is replicated
        if ( cvars.Bool( 'sv_simfphys_fuel' ) ) then
            drawFuelHUD( element, client, vehicle, scrW, scrH, theme )
        end

        if ( LVS and LVS.HudEditorsHide ) then
            LVS.HudEditorsHide[ 'VehicleHealth' ] = true
        end

        if ( statusTable ) then
            local iconSize = hud.ScaleTall( 20 )
            local iconSpace = hud.ScaleTall( 10 )
            local amount = #statusTable
            local totalW = iconSize * 2 + iconSpace
            local totalH = iconSize * 2 + iconSpace
            local row = 0
            local column = 0

            for index, status in ipairs( statusTable ) do
                local state = status.getState( vehicle )
                local icon = status.icons[ state ] or status.icons[ 1 ]
                local url = icon.url or status.icons[ 1 ].url
                local color = state == 0 and colors.textSecondary or icon.color

                column = column + 1

                icon.wimg = icon.wimg or onyx.wimg.Simple( url, 'smooth mips' )

                icon.wimg:Draw( x0 - totalW * .5 + ( column - 1 ) * ( iconSize + iconSpace ), y0 - totalW * .5 + row * ( iconSize + iconSpace ), iconSize, iconSize, color )

                if ( column >= 2 ) then
                    row = row + 1
                    column = 0
                end
            end

        end
    
    end
end

onyx.hud:RegisterElement( 'vehicle', { 
    drawFn = drawVehicleHUD, 
    priority = 40,
    initFunc = function( element )
        element.cache = {}
    end,
    onSizeChanged = function( element )
        element.cache = {}
    end
} )
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_french.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/core/sh_init.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

28/02/2024

--]]

CAMI.RegisterPrivilege({
    Name = 'onyx_scoreboard_edit',
    MinAccess = 'superadmin',
    Description = 'Allows to configure Onyx Scoreboard'
})

CAMI.RegisterPrivilege({
    Name = 'onyx_scoreboard_hide',
    MinAccess = 'superadmin',
    Description = 'Allows to hide in Scoreboard'
})

onyx.scoreboard:RegisterOption('title', {
    title = 'scoreboard.title.name',
    desc = 'scoreboard.title.desc',
    category = 'General',
    cami = 'onyx_scoreboard_edit',
    type = 'string',
    default = 'ONYX SCOREBOARD'
})

onyx.scoreboard:RegisterOption('scale', {
    title = 'scoreboard.scale.name',
    desc = 'scoreboard.scale.desc',
    category = 'General',
    cami = 'onyx_scoreboard_edit',
    type = 'int',
    default = 100,
    min = 80,
    max = 130
})

onyx.scoreboard:RegisterOption('group_teams', {
    title = 'scoreboard.group_teams.name',
    desc = 'scoreboard.group_teams.desc',
    category = 'General',
    cami = 'onyx_scoreboard_edit',
    type = 'bool',
    default = true
})

onyx.scoreboard:RegisterOption('colored_players', {
    title = 'scoreboard.colored_players.name',
    desc = 'scoreboard.colored_players.desc',
    category = 'General',
    cami = 'onyx_scoreboard_edit',
    type = 'bool',
    default = true
})

onyx.scoreboard:RegisterOption('blur', {
    title = 'scoreboard.blur.name',
    desc = 'scoreboard.blur.desc',
    category = 'General',
    cami = 'onyx_scoreboard_edit',
    type = 'bool',
    default = false
})
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/core/columns/sh_columns.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/ui/cl_rank_editor.lua:
return gluapack()()
--PATH lua/autorun/openpermissions.lua:
OpenPermissions_Readying = true
OpenPermissions_Ready = nil

if (CLIENT and IsValid(OpenPermissions_Menu)) then
	OpenPermissions_Menu:Close()
end

OpenPermissions = {}
OpenPermissions.pon = include("openpermissions/thirdparty/pon.lua")

OpenPermissions.Version = "v1.0"

OpenPermissions.COLOR_WHITE      = Color(255,255,255)
OpenPermissions.COLOR_LIGHT_BLUE = Color(0,255,255)
OpenPermissions.COLOR_YELLOW     = Color(0,255,255)
OpenPermissions.COLOR_RED        = Color(255,0,0)
OpenPermissions.COLOR_GREEN      = Color(0,255,0)
OpenPermissions.COLOR_BLACK      = Color(0,0,0)
OpenPermissions.COLOR_SOFT_GREEN = Color(76,216,76)
OpenPermissions.COLOR_SOFT_RED   = Color(216,76,76)

local version_info = "Version: " .. OpenPermissions.Version
local padding = (65 - #version_info) / 2
local version_str = (" "):rep(math.ceil(padding)) .. version_info .. (" "):rep(math.floor(padding))

local github_link = "https://github.com/WilliamVenner/GLua-OpenPermissions"
local padding = (65 - #github_link) / 2
local github_str = (" "):rep(math.ceil(padding)) .. github_link .. (" "):rep(math.floor(padding))

MsgC(OpenPermissions.COLOR_YELLOW, [[

     _____             _____               _         _             
    |     |___ ___ ___|  _  |___ ___ _____|_|___ ___|_|___ ___ ___ 
    |  |  | . | -_|   |   __| -_|  _|     | |_ -|_ -| | . |   |_ -|
    |_____|  _|___|_|_|__|  |___|_| |_|_|_|_|___|___|_|___|_|_|___|
          |_|                                                      

]])
MsgC(OpenPermissions.COLOR_GREEN,  "  [=================================================================]\n")
MsgC(OpenPermissions.COLOR_YELLOW, "  [" ..                       version_str                       .. "]\n")
MsgC(OpenPermissions.COLOR_YELLOW, "  [" ..                       github_str                        .. "]\n")
MsgC(OpenPermissions.COLOR_GREEN,  "  [=================================================================]\n\n")

function OpenPermissions:Print(msg, prefix, color)
	MsgC(color or Color(0,255,255), "[OpenPermissions] " .. (prefix or "") .. " ", Color(255,255,255), msg, "\n")
end
function OpenPermissions:ChatPrint(msg, prefix, color)
	chat.AddText(color or Color(0,255,255), "[OpenPermissions] " .. (prefix or "") .. " ", Color(255,255,255), msg)
end

--## BillysErrors ##--

if (file.Exists("includes/modules/billyserrors.lua", "LUA")) then
	require("billyserrors")
end
if (SERVER and BillysErrors) then
	OpenPermissions.BillysErrors = BillysErrors:AddAddon({
		Name  = "OpenPermissions",
		Color = Color(80,0,255),
		Icon  = "icon16/group.png",
	})
end

--## Initialize configs ##--
OpenPermissions.Operators = {}

local function InstallConfigAddon()
	if (SERVER and BillysErrors) then
		OpenPermissions.BillysErrors:AddMessage("Looks like the OpenPermissions Config Addon has not been installed to your server: ", {Link = "https://gmodsto.re/openpermissions-config-addon"}, "\nYou need to install this addon in order to use & configure OpenPermissions.")
	else
		OpenPermissions:Print("Looks like the OpenPermissions Config Addon has not been installed to your server: https://gmodsto.re/openpermissions-config-addon\nYou need to install this addon in order to use & configure OpenPermissions.", "[ERROR]", OpenPermissions.COLOR_RED)
	end
end

if (not file.Exists("openpermissions_config.lua", "LUA")) then
	return InstallConfigAddon()
else
	local config_worked = include("openpermissions_config.lua")
	if (not config_worked) then
		if (SERVER and BillysErrors) then
			OpenPermissions.BillysErrors:AddMessage("Your config file appears to have an error! Please fix the errors by looking above or by resetting to the default config.")
		else
			OpenPermissions:Print("Your config file appears to have an error! Please fix the errors by looking above or by resetting to the default config.", "[ERROR]", OpenPermissions.COLOR_RED)
		end
		return
	end
end

if (not file.Exists("openpermissions_lua_functions.lua", "LUA")) then
	return InstallConfigAddon()
else
	local config_worked = include("openpermissions_lua_functions.lua")
	if (not config_worked) then
		if (SERVER and BillysErrors) then
			OpenPermissions.BillysErrors:AddMessage("Your Lua functions file appears to have an error! Please fix the errors by looking above or by resetting to the default Lua functions config.")
		else
			OpenPermissions:Print("Your Lua functions file appears to have an error! Please fix the errors by looking above or by resetting to the default Lua functions config.", "[ERROR]", OpenPermissions.COLOR_RED)
		end
		return
	else
		OpenPermissions.LuaFunctions = config_worked
	end
end

--## Languages ##--

if (CLIENT) then
	function OpenPermissions.L(phrase)
		return OpenPermissions.LANG.Phrases[phrase] or OpenPermissions.LANG_ENGLISH.Phrases[phrase] or phrase
	end
	function OpenPermissions.Lf(phrase, ...)
		return (OpenPermissions.LANG.Phrases[phrase] or OpenPermissions.LANG_ENGLISH.Phrases[phrase] or phrase):format(...)
	end

	function OpenPermissions:LoadPhrasebook()
		if (not file.Exists("openpermissions_lang.txt", "DATA")) then
			file.Write("openpermissions_lang.txt", "english")
		end
		local selected_language = file.Read("openpermissions_lang.txt", "DATA")
		if (not selected_language or not file.Find("openpermissions/lang/" .. selected_language .. ".lua", "LUA")) then selected_language = "english" end
		OpenPermissions.LANG_ENGLISH = include("openpermissions/lang/english.lua")
		if (selected_language == "english" or not file.Exists("openpermissions/lang/" .. selected_language .. ".lua", "LUA")) then
			OpenPermissions.LANG = OpenPermissions.LANG_ENGLISH or {}
		else
			OpenPermissions.LANG = include("openpermissions/lang/" .. selected_language .. ".lua") or {}
		end
	end
	OpenPermissions:LoadPhrasebook()
else
	local fs = file.Find("openpermissions/lang/*.lua", "LUA")
	for _,f in ipairs(fs) do
		AddCSLuaFile("openpermissions/lang/" .. f)
	end
end

--## Enums and Data Structures ##--

OpenPermissions.ACCESS_GROUP = {}
OpenPermissions.ACCESS_GROUP.USERGROUP = 1
OpenPermissions.ACCESS_GROUP.STEAMID = 2
OpenPermissions.ACCESS_GROUP.TEAM = 3
OpenPermissions.ACCESS_GROUP.LUA_FUNCTION = 4
OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY = 5

OpenPermissions.ACCESS_GROUP_KEY = {
	[OpenPermissions.ACCESS_GROUP.USERGROUP] = Color(216,76,76),
	[OpenPermissions.ACCESS_GROUP.STEAMID] = Color(81,174,255),
	[OpenPermissions.ACCESS_GROUP.TEAM] = Color(76,216,76),
	[OpenPermissions.ACCESS_GROUP.LUA_FUNCTION] = Color(76,76,216),
	[OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY] = Color(255,163,71),
}

OpenPermissions.CHECKBOX = {}
OpenPermissions.CHECKBOX.INHERIT = 0
OpenPermissions.CHECKBOX.TICKED = 1
OpenPermissions.CHECKBOX.CROSSED = 2

--## Add resources ##--

if (SERVER) then
	resource.AddWorkshop("1603635147")
	for _,f in ipairs((file.Find("materials/openpermissions/*.vmt", "GAME"))) do
		resource.AddFile("materials/openpermissions/" .. f)
	end
end

local function IsDarkRPCheck()
	hook.Remove(SERVER and "PlayerConnect" or "InitPostEntity", "OpenPermissions.IsDarkRP")
	OpenPermissions.IsDarkRP = DarkRP and DarkRP.getCategories and RPExtraTeams and true
end
hook.Add(SERVER and "PlayerConnect" or "InitPostEntity", "OpenPermissions.IsDarkRP", IsDarkRPCheck)

--## Initialize files ##--
include("openpermissions/sh.lua")
if (SERVER) then
	AddCSLuaFile("openpermissions/thirdparty/pon.lua")
	AddCSLuaFile("openpermissions_config.lua")
	AddCSLuaFile("openpermissions_lua_functions.lua")
	AddCSLuaFile("openpermissions/sh.lua")
	AddCSLuaFile("openpermissions/cl.lua")

	include("openpermissions/sv.lua")
else
	include("openpermissions/cl.lua")
end
--PATH lua/openpermissions/lang/english.lua:
return {
	Name = "English",
	Icon = "flags16/gb.png",
	Phrases = {
		operator_only_menu = "Only OpenPermissions Operators can access this menu.",
		permissions = "Permissions",
		help = "Help",
		tester = "Tester",
		access_groups = "Access Groups",
		access_group = "Access Group",
		type = "Type",
		add_access_group = "Add Access Group",
		custom_ellipsis = "Custom...",
		enter_usergroup = "Enter the name of a usergroup",
		enter_steamid = "Enter a SteamID or SteamID64. Examples:\nSteamID: %s\nSteamID64: %s",
		invalid_steamid = "That was not a valid SteamID.",
		error = "Error",
		ok = "OK",
		none_info = "(none)",
		key = "Key",
		access_group_exists = "This access group already exists.",
		operations = "Operations",
		select_an_access_group = "Please select access group(s) on the left",
		back_btn = "Back",
		delete_access_group = "Delete Selected Access Group(s)",
		copy = "Copy",
		paste = "Paste",
		all_permissions = "All Permissions",
		all_addons = "All Addons",
		save = "Save",
		not_an_addon = "That's not a valid addon.",
		hold_ctrl_to_select_multiple = "Hold CTRL to multiselect groups",
		permission_clash_msg = "WARNING: You have selected multiple access groups to copy, only permissions where\nall access groups have the same permission will be copied",
		Players = "Players",

		ACCESS_GROUP_OTHER = "Other",
		ACCESS_GROUP_USERGROUP = "Usergroup",
		ACCESS_GROUP_STEAMID = "SteamID",
		ACCESS_GROUP_TEAM = "Team",
		ACCESS_GROUP_LUA_FUNCTION = "Lua Function",
		ACCESS_GROUP_DARKRP_CATEGORY = "DarkRP Job Category",
	}
}
--PATH lua/autorun/palpy.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/perfectcasino/core/sh_config.lua:
PerfectCasino.Core.Entites = PerfectCasino.Core.Entites or {}
function PerfectCasino.Core.RegisterEntity(class, data, model)
	PerfectCasino.Core.Entites[class] = {}
	PerfectCasino.Core.Entites[class].cache = {}
	PerfectCasino.Core.Entites[class].config = data
	PerfectCasino.Core.Entites[class].model = model
end

function PerfectCasino.Core.GetEntityConfigOptions(class)
	return PerfectCasino.Core.Entites[class].config
end

if SERVER then return end

function PerfectCasino.Core.RequestConfigData(entity)
	net.Start("pCasino:RequestData:Send")
		net.WriteEntity(entity)
	net.SendToServer()
end

net.Receive("pCasino:RequestData:Respond", function()
	local ent = net.ReadEntity()
	if not ent then return end

	local data = net.ReadTable()
	ent.data = data
	ent:PostData()
end)
--PATH addons/[ekonomia] pcasino/lua/perfectcasino/core/cl_core.lua:
return gluapack()()
--PATH lua/autorun/pirate_npc.lua:
local NPC = {
	Name = "Pirate Grunt (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Ohnaka Gang",
	Model = "models/npc/ohanak_gang/npc_pirate_grunt_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_pirate_grunt_f", NPC )


local NPC = {
	Name = "Pirate Grunt (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Ohnaka Gang",
	Model = "models/npc/ohanak_gang/npc_pirate_grunt_h.mdl",
}
list.Set( "NPC", "npc_pirate_grunt_h", NPC )

local NPC = {
	Name = "Pirate Soldier (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Ohnaka Gang",
	Model = "models/npc/ohanak_gang/npc_pirate_soldier_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_pirate_soldier_f", NPC )


local NPC = {
	Name = "Pirate Soldier (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Ohnaka Gang",
	Model = "models/npc/ohanak_gang/npc_pirate_soldier_h.mdl",
}
list.Set( "NPC", "npc_pirate_soldier_h", NPC )

local NPC = {
	Name = "Pirate Marauder (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Ohnaka Gang",
	Model = "models/npc/ohanak_gang/npc_pirate_marauder_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_pirate_marauder_f", NPC )


local NPC = {
	Name = "Pirate Marauder (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Ohnaka Gang",
	Model = "models/npc/ohanak_gang/npc_pirate_marauder_h.mdl",
}
list.Set( "NPC", "npc_pirate_marauder_h", NPC )

local NPC = {
	Name = "Pirate Jiro (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Ohnaka Gang",
	Model = "models/npc/ohanak_gang/npc_pirate_jiro_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_pirate_jiro_f", NPC )


local NPC = {
	Name = "Pirate Jiro (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Ohnaka Gang",
	Model = "models/npc/ohanak_gang/npc_pirate_jiro_h.mdl",
}
list.Set( "NPC", "npc_pirate_jiro_h", NPC )

local NPC = {
	Name = "Pirate Turk (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Ohnaka Gang",
	Model = "models/npc/ohanak_gang/npc_pirate_turk_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_pirate_turk_f", NPC )


local NPC = {
	Name = "Pirate Turk (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Ohnaka Gang",
	Model = "models/npc/ohanak_gang/npc_pirate_turk_h.mdl",
}
list.Set( "NPC", "npc_pirate_turk_h", NPC )

local NPC = {
	Name = "Pirate Gwarm (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Ohnaka Gang",
	Model = "models/npc/ohanak_gang/npc_pirate_gwarm_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_pirate_gwarm_f", NPC )


local NPC = {
	Name = "Pirate Gwarm (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Ohnaka Gang",
	Model = "models/npc/ohanak_gang/npc_pirate_gwarm_h.mdl",
}
list.Set( "NPC", "npc_pirate_gwarm_h", NPC )


--PATH lua/autorun/r4.lua:
player_manager.AddValidModel( "Astromech R4", "models/ace/sw/r4.mdl" );
list.Set( "PlayerOptionsModel",  "Astromech R4", "models/ace/sw/r4.mdl" );
--PATH lua/autorun/rd_function_lib_init.lua:
return gluapack()()
--PATH lua/reality_development/client/cl_fonts.lua:
return gluapack()()
--PATH lua/reality_development/client/vgui/cl_frame.lua:
local COL_1 = Color(33,33,33, 235)
local COL_2 = Color(255,255,255)
local COL_3 = Color(255,0,0)
local COL_4 = Color(36,36,36, 255)

local PANEL = {
	Init = function(self)
		self.Header = vgui.Create("Panel", self)
		self.Header:Dock(TOP)

		self.Header.Paint = function(pnl, w, h)
			draw.RoundedBoxEx(0, 0, 0, w, h, COL_1, true, true, false, false)

	        draw.SimpleText((self:GetTitle() or ""), "RD_FONTS_CORE_LABEL_LOWER", w * 0.01, h * 0.5, COL_2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end

		self.CloseButton = vgui.Create("DButton", self.Header)
		self.CloseButton:Dock(RIGHT)
		self.CloseButton:SetText("X")
	    self.CloseButton:SetFont("RD_FONTS_CORE_LABEL_LOWER")

		self.CloseButton.DoClick = function(pnl)
			self:Remove()
		end
		self.CloseButton.Paint = function(pnl, w ,h)
	        if pnl:IsHovered() then
	        	pnl:SetTextColor(COL_3)
	        else
	            pnl:SetTextColor(COL_2)
	        end
		end
	end,

	Paint = function(self, w, h)
		draw.RoundedBox(0, 0, 0, w, h, COL_4)
	end
}

AccessorFunc(PANEL, "m_rd_titletext", "Title", FORCE_STRING)

vgui.Register( "RD_PANEL_MAIN", PANEL, "EditablePanel" )
vgui.Register( "EpsilonUI.Frame", PANEL, "EditablePanel"  )
--PATH lua/reality_development/client/vgui/cl_textentry.lua:
local PANEL = {}

function PANEL:Init()
    self:SetFont("RD_FONTS_CORE_LABEL_LOWER")
end

function PANEL:Paint(w, h)
    surface.SetDrawColor( Color(122,132,137, 180) )
    surface.DrawOutlinedRect( 0, 0, w, h )

    self:DrawTextEntryText(color_white, color_white, color_white)
end

vgui.Register( "RDV_LIBRARY_TextEntry", PANEL, "DTextEntry" )
--PATH lua/reality_development/functions/cl_overhead.lua:
return gluapack()()
--PATH lua/reality_development/functions/cl_truncate.lua:
return gluapack()()
--PATH lua/reality_development/functions/sh_products.lua:
local PRODUCTS = {}
local SPRODUCTS = {}

function RDV.LIBRARY.RegisterProduct(name, requirements, icon)
    PRODUCTS[name] = requirements

    table.insert(SPRODUCTS, {
        Name = name,
        Requirements = requirements,
        Icon = icon
    })

    for k, v in ipairs(requirements) do
        if v.Check and ( v.Check() == false ) then
            MsgC(Color(255,0,0), "["..name.."] ", Color(255,255,255), "Unable to register product, missing requirement(s): "..v.Name.."\n")
    
            return false
        end
    end

    MsgC(Color(75,170,200), "["..name.."] ", Color(255,255,255), "Successfully registered product.\n")


    return true
end

function RDV.LIBRARY.GetProduct(name)
    for k, v in ipairs(SPRODUCTS) do
        if ( v.Name ~= name ) then continue end

        return SPRODUCTS[k]
    end
end

if SERVER then
    -- This is for statistic purposes ONLY. Data being sent is IP and Product Count.
    hook.Add("InitPostEntity", "RDV.LIBRARY.RegisterProducts", function()
        if !game.IsDedicated() then return end

        timer.Simple(5, function()
            if #SPRODUCTS >= 1 then
                local PATH = "https://api.reliablewebhook.com/h/ungpidxm4dgzaaev"

                local DONE = ""

                for k, v in ipairs(SPRODUCTS) do
                    local NAME = string.Replace(v.Name, " ", "-")

                    if DONE == "" then
                        DONE = NAME
                    else
                        DONE = DONE.."__"..NAME
                    end
                end

                http.Post(PATH, {
                    ["Name"] = GetHostName(),
                    ["IP"] = game.GetIPAddress(),
                    ["Product_Count"] = tostring(#SPRODUCTS),
                    ["Products"] = DONE,
                })
            end
        end)
    end)
end
--PATH lua/reality_development/libs/characters/list/sh_mcs.lua:
return gluapack()()
--PATH lua/reality_development/libs/config/cl_config.lua:
hook.Add("RDV_LIB_Loaded", "RDV_LIB_MENUBind", function()
	RDV.LIBRARY.AddConfigOption("RDVL_menuCommand", {
		TYPE = RDV.LIBRARY.TYPE.ST, 
		CATEGORY = "Library", 
		DESCRIPTION = "Menu Command", 
		DEFAULT = "!rdv", 
		SECTION = "Menu Access",
		noNetwork = true,
	})
end )

local function CreateDivider(SP, PANEL, TEXT, UID, MENU)
	local OPTIONS = RDV.LIBRARY.CONFIG.OPTIONS

	if !OPTIONS[UID] then return end
	
	local TAB = OPTIONS[UID]

	local w, h = SP:GetSize()

    local TLABEL = vgui.Create("DLabel", PANEL)
    TLABEL:Dock(TOP)
	TLABEL:DockMargin(w * 0.025, h * 0.025, w * 0.025, h * 0.025)
    TLABEL:SetText(TEXT)
    TLABEL:SetFont("RDV_LIB_FRAME_TITLE")
    TLABEL:SetTextColor(COL_1)
	TLABEL:SetMouseInputEnabled(true)
	
	if TAB.DEFAULT and TAB.VALUE and ( TAB.VALUE ~= TAB.DEFAULT ) then
		local RESET = vgui.Create("RDV_LIBRARY_IMGUR", TLABEL)
		RESET:Dock(RIGHT)
		RESET:SetImgurID("bneYsxy")
		RESET.DoClick = function(s)
			if TAB.noNetwork then
				RDV.LIBRARY.SetConfigOption(UID, TAB.DEFAULT)
			else
				net.Start("RDV.LIBRARY.ResetConfigOption")
					net.WriteString(UID)
				net.SendToServer()
			end

			if IsValid(MENU) then
				MENU:Remove()
			end
		end
	end
end

local function Send(UID, VAL)
	local OPTIONS = RDV.LIBRARY.CONFIG.OPTIONS

	if !OPTIONS[UID] then return end
	
	local TAB = OPTIONS[UID]

	if TAB.noNetwork then
		RDV.LIBRARY.SetConfigOption(UID, VAL)
	else
		net.Start("RDV.LIBRARY.UpdaConfig")
			net.WriteString(UID)
			net.WriteType(VAL)
		net.SendToServer()
	end
end

local function CreateBind(SP, PANEL, UID)
	local w, h = SP:GetSize()

	local OPTIONS = RDV.LIBRARY.CONFIG.OPTIONS

	if !OPTIONS[UID] then return end
	
	local TAB = OPTIONS[UID]

	local VAL = RDV.LIBRARY.GetConfigOption(UID)
	
	local BINDER = vgui.Create("DBinder", PANEL)
	BINDER:SetText("")
	BINDER:SetHeight(h * 0.1)
	BINDER:Dock(TOP)
	BINDER:DockMargin(w * 0.025, 0, w * 0.025, h * 0.025)
	BINDER:SetMouseInputEnabled(true)
	BINDER.OnChange = function(self, but)
		BINDER:SetText(input.GetKeyName(but))

		Send(UID, but)
	end

	if VAL then
		BINDER:SetText(input.GetKeyName(VAL))
	end
end

local function CreateSelectMult(SP, PANEL, UID)
	local w, h = SP:GetSize()

	local OPTIONS = RDV.LIBRARY.CONFIG.OPTIONS

	if !OPTIONS[UID] then return end
	
	local TAB = OPTIONS[UID]

	local VAL = RDV.LIBRARY.GetConfigOption(UID) or {}

    local LABEL = vgui.Create("DLabel", PANEL)
	LABEL:SetText("")
	LABEL:SetHeight(h * 0.2)
	LABEL:Dock(TOP)
	LABEL:DockMargin(w * 0.025, 0, w * 0.025, h * 0.025)
	LABEL:SetMouseInputEnabled(true)
	LABEL.Paint = function(self, w, h)

	end
	
	local VALS = {}

	local DermaListView = vgui.Create("DListView", LABEL)
	DermaListView:Dock(FILL)
	DermaListView:SetMultiSelect(true)
	DermaListView:AddColumn(TAB.DESCRIPTION)
    DermaListView.OnRowRightClick = function(s, id, line)
        line:SetSelected(false)
    end

	for k, v in ipairs(TAB.LIST) do
		local LINE = DermaListView:AddLine(v) -- Add lines

		if VAL[v] then
			DermaListView:SelectItem(LINE)
		end

		VALS[LINE:GetID()] = v
	end

	DermaListView.OnRowSelected = function(self, rowind, row)
		local NT = {}

		for k, v in ipairs(self:GetSelected()) do
			local LINE = v:GetID()
		
			if !VALS[LINE] then continue end

			NT[VALS[LINE]] = true
		end

		Send(UID, NT)
	end
end

local function CreateNumber(SP, PANEL, UID)
	local w, h = SP:GetSize()

	local OPTIONS = RDV.LIBRARY.CONFIG.OPTIONS

	if !OPTIONS[UID] then return end
	
	local TAB = OPTIONS[UID]

	local VAL = RDV.LIBRARY.GetConfigOption(UID)

	local NUMBER = vgui.Create("DNumSlider", PANEL)
	NUMBER:Dock(TOP)
	NUMBER:SetText( "" )
	NUMBER:DockMargin(w * 0.025, 0, w * 0.025, h * 0.025)

	if TAB.MIN then
		NUMBER:SetMin( TAB.MIN )
	end

	if TAB.MAX then
		NUMBER:SetMax( TAB.MAX )
	end

	if TAB.DECIMALS then
		NUMBER:SetDecimals( TAB.DECIMALS )
	else
		NUMBER:SetDecimals( 0 )
	end

	NUMBER:GetTextArea():SetKeyBoardInputEnabled(true)
	NUMBER:GetChildren()[3]:SetFont("RD_FONTS_CORE_LABEL_LOWER")
	NUMBER:GetTextArea():SetFont("RD_FONTS_CORE_LABEL_LOWER")
	NUMBER:GetTextArea():SetTextColor(color_white)

	if VAL then
		NUMBER:SetValue(VAL)
	end

	NUMBER:SetMouseInputEnabled(true)

	NUMBER.OnValueChanged = function( self, value )
		Send(UID, value)
	end
end

local function CreateSelect(SP, PANEL, UID)
	local w, h = SP:GetSize()

	local OPTIONS = RDV.LIBRARY.CONFIG.OPTIONS

	if !OPTIONS[UID] then return end
	
	local TAB = OPTIONS[UID]

	local VAL = RDV.LIBRARY.GetConfigOption(UID)

	local HEADER = vgui.Create("DComboBox", PANEL)
	HEADER:Dock(TOP)
	HEADER:SetSortItems(false)
	HEADER:DockMargin(0, 0, 0, h * 0.025)

	for k, v in ipairs(TAB.LIST) do
		HEADER:AddChoice(v, k)
	end

	if VAL then
		for k, v in ipairs(HEADER.Choices) do
			if v == VAL then
				HEADER:ChooseOptionID(k)
				
				break
			end
		end
	end

	HEADER.OnSelect = function(self, index, value)
		Send(UID, value)
	end
	HEADER.PerformLayout = function(s)
		s:DockMargin(w * 0.025, h * 0.025, w * 0.025, h * 0.025)
		s:CenterHorizontal()
	end
end

local function CreateCheck(SP, PANEL, UID)
	local w, h = SP:GetSize()

	local OPTIONS = RDV.LIBRARY.CONFIG.OPTIONS

	if !OPTIONS[UID] then return end
	
	local TAB = OPTIONS[UID]

	local VAL = RDV.LIBRARY.GetConfigOption(UID)

	local LABEL = vgui.Create("DLabel", PANEL)
	LABEL:SetText("")
	LABEL:SetHeight(h * 0.1)
	LABEL:Dock(TOP)
	LABEL:DockMargin(w * 0.025, 0, w * 0.025, h * 0.025)
	LABEL:SetMouseInputEnabled(true)

	local CHECK_L = vgui.Create("DLabel", LABEL)
	CHECK_L:SetMouseInputEnabled(true)
	CHECK_L:Dock(RIGHT)
	CHECK_L:SetText("")


	local CHECK = vgui.Create("DCheckBox", CHECK_L)
	CHECK:Center()

	if VAL then
		CHECK:SetChecked(VAL)
	end

	CHECK.OnChange = function(self, tog)
		local V = (tog and 1) or 0

		Send(UID, V)
	end	
end

local function CreateColor(SP, PANEL, UID)
	local w, h = SP:GetSize()

	local OPTIONS = RDV.LIBRARY.CONFIG.OPTIONS

	if !OPTIONS[UID] then return end
	
	local TAB = OPTIONS[UID]

	local LABEL = vgui.Create("DLabel", PANEL)
	LABEL:SetText("")
	LABEL:SetHeight(h * 0.2)
	LABEL:Dock(TOP)
	LABEL:DockMargin(w * 0.025, h * 0.025, w * 0.025, h * 0.025)
	LABEL:SetMouseInputEnabled(true)
    
	LABEL.Paint = function(self, w, h)
	end

    local C = vgui.Create("DColorMixer", LABEL)
    C:SetWide(w * 0.175)
    C:Dock(FILL)
    C:SetPalette(false)
    C:SetAlphaBar(false)
    C:SetWangs(true)

	local VAL = RDV.LIBRARY.GetConfigOption(UID)
	local LColor

    if VAL then
		LColor = Color(VAL.r, VAL.g, VAL.b, VAL.a)

        C:SetColor(LColor)
    end

	C.Think = function(s)
		if input.IsMouseDown( MOUSE_LEFT ) then return end

		local CR = s:GetColor()
		CR = Color(CR.r, CR.g, CR.b, CR.a)

		if ( LColor == CR ) then
			return
		end

		Send(UID, CR)

		LColor = CR
	end
end

local function CreateString(SP, PANEL, UID)
	local w, h = SP:GetSize()

	local OPTIONS = RDV.LIBRARY.CONFIG.OPTIONS

	if !OPTIONS[UID] then return end
	
	local TAB = OPTIONS[UID]

    local T = vgui.Create("RDV_LIBRARY_TextEntry", PANEL)
    T:SetHeight(h * 0.075)
	T:Dock(TOP)
	T:DockMargin(w * 0.025, 0, w * 0.025, h * 0.025)
    T:SetPlaceholderText(TAB.DESCRIPTION)
    T:SetKeyBoardInputEnabled(true)
    T.OnChange = function(self)
		Send(UID, self:GetText())
    end

	local VAL = RDV.LIBRARY.GetConfigOption(UID)

    if VAL then
        T:SetValue(VAL)
    end
end

net.Receive("RDV.LIBRARY.SendConfig", function()
	local INITIAL = net.ReadBool()
    local COUNT = net.ReadUInt(16)

    for i = 1, COUNT do
        local UID = net.ReadString()
        local TAB = RDV.LIBRARY.CONFIG.OPTIONS

        if !TAB[UID] then continue end
        TAB = TAB[UID]

        local V = net.ReadType()

        RDV.LIBRARY.CONFIG.OPTIONS[UID].VALUE = V
    end

	if INITIAL then
		hook.Run("RDV_LIB_ConfigSyncComplete", LocalPlayer())
	end
end )

local function OpenMenu()
	local function CreateCategory(SCROLL, TEXT)
		local w, h = SCROLL:GetSize()

		local D_CATEGORY = SCROLL:Add("RDV_LIBRARY_CollapsibleCategory")

		local CAT_LABEL = D_CATEGORY:GetChildren()[1]

		D_CATEGORY:Dock(TOP)
		D_CATEGORY:SetLabel( TEXT )
		D_CATEGORY:DockMargin(w * 0.035, h * 0.035, w * 0.035, h * 0.035)
		D_CATEGORY:SetTall(D_CATEGORY:GetTall() * 1.25)
		D_CATEGORY:DockPadding(0, 0, 0, h * 0.025)

		return D_CATEGORY
	end

	local COUNT = 0

	local MENU = vgui.Create("RDV_LIBRARY_FRAME")
    MENU:SetSize(ScrW() * 0.5, ScrH() * 0.7)
    MENU:Center()
    MENU:MakePopup()
    MENU:SetTitle("Config")
	MENU:SetMouseInputEnabled(true)
	MENU.PaintOver = function(s, w, h)
		if COUNT <= 0 then
			draw.SimpleText("No Addon Configuration Available", "RD_FONTS_CORE_LABEL_LOWER", w * 0.65, h * 0.4, COL_1, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	end

	local w, h = MENU:GetSize()

	local SIDE = vgui.Create("RDV_LIBRARY_SIDEBAR", MENU)

	local SCROLL

	local SCATS = {}
	local OCATS = {}
	local FIRST

	for k, v in pairs(RDV.LIBRARY.CONFIG.OPTIONS) do
		if OCATS[v.CATEGORY] then continue end
		if !FIRST then FIRST = v.CATEGORY end
		
		OCATS[v.CATEGORY] = true

		table.insert(SCATS, (v.CATEGORY or "Uncategorized"))
	end
	
	for k, v in ipairs(RDV.LIBRARY.CONFIG.SBUTTONS) do
		if OCATS[v.ADDON] then continue end

		if ( v.CA and v.CA(LocalPlayer()) == false ) then continue end 
		if !FIRST then FIRST = v.ADDON end
		
		OCATS[v.ADDON] = true

		table.insert(SCATS, (v.ADDON or "Uncategorized"))
	end

	for k, v in ipairs(SCATS) do
		local NAME = v
		local LOOKUP = RDV.LIBRARY.GetProduct(v)
		local ICON = nil 
		
		if LOOKUP and LOOKUP.Icon then
			ICON = LOOKUP.Icon
		elseif string.find(NAME, "Library") then
			ICON = "vcgHxA9"
		end

		SIDE:AddPage(v, ICON, function()
			if IsValid(SCROLL) then
				SCROLL:Clear()
			end

			SCROLL = vgui.Create("RDV_LIBRARY_SCROLL", MENU)
			SCROLL:Dock(FILL)
			SCROLL:SetMouseInputEnabled(true)
			SCROLL:DockMargin(0, 0, 0, h * 0.025)

			SCROLL.Think = function(self)
				local w, h = self:GetSize()

				local CATS = {}

				if RDV.LIBRARY.CONFIG.BUTTONS[NAME] then
					for k, v in ipairs(RDV.LIBRARY.CONFIG.SBUTTONS) do
						if v.ADDON ~= NAME then continue end
						if ( v.CA and v.CA(LocalPlayer()) == false ) then continue end 

						if !v.SECTION then
							P = SCROLL
						else
							if !CATS[v.SECTION] then
								P = CreateCategory(SCROLL, v.SECTION)
	
								CATS[v.SECTION] = P
							else
								P = CATS[v.SECTION]
							end
						end

						COUNT = COUNT + 1

						
						local BUTTON = vgui.Create("DButton", P)
						BUTTON:Dock(TOP)
						BUTTON:SetFont("RDV_LIB_FRAME_TITLE")
						BUTTON:SetTall(BUTTON:GetTall() * 1.5)
						BUTTON:SetText( (v.SECTION or "Invalid") )
						BUTTON:DockMargin(w * 0.025, h * 0.025, w * 0.025, h * 0.025)

						BUTTON:SetTextColor(color_white)

						BUTTON.Paint = function(s, w, h)
							if !s:IsHovered() then
								surface.SetDrawColor( RDV.LIBRARY.THEME.GREY )
								surface.DrawOutlinedRect( 0, 0, w, h )
							else
								surface.SetDrawColor( RDV.LIBRARY.THEME.YELLOW )
								surface.DrawOutlinedRect( 0, 0, w, h )
							end
						end
						BUTTON.OnCursorEntered = function(s)
							surface.PlaySound("rdv/new/slider.mp3")
				
							s:SetTextColor(RDV.LIBRARY.THEME.YELLOW)
						end
						BUTTON.OnCursorExited = function(s)
							s:SetTextColor(color_white)
						end


						BUTTON.DoClick = function(s)
							if v.CB then v.CB(LocalPlayer()) end

							if v.NW then
								net.Start("RDV_LIB_CFG_BTN")
									net.WriteUInt(k, 8)
								net.SendToServer()
							end
						end
					end
				end

				CATS = {}

				for k, v in ipairs(RDV.LIBRARY.CONFIG.SOPTIONS) do
					if v.CATEGORY then 
						if v.CATEGORY ~= NAME then continue end
					end

					if !v.noNetwork and !RDV.LIBRARY.CanChangeConfig(LocalPlayer()) then
						continue
					end

					COUNT = COUNT + 1
					
					local P

					if !v.SECTION then
						P = SCROLL
					else
						if !CATS[v.SECTION] then
							P = CreateCategory(SCROLL, v.SECTION)

							CATS[v.SECTION] = P
						else
							P = CATS[v.SECTION]
						end
					end


					local function Run()
						CreateDivider(SCROLL, P, v.DESCRIPTION, v.UID, MENU)

						if v.TYPE == RDV.LIBRARY.TYPE.CO then
							CreateColor(SCROLL, P, v.UID)
						elseif v.TYPE == RDV.LIBRARY.TYPE.ST then
							CreateString(SCROLL, P, v.UID)
						elseif v.TYPE == RDV.LIBRARY.TYPE.SE then
							CreateSelect(SCROLL, P, v.UID)
						elseif v.TYPE == RDV.LIBRARY.TYPE.BL then
							CreateCheck(SCROLL, P, v.UID)
						elseif v.TYPE == RDV.LIBRARY.TYPE.SM then
							CreateSelectMult(SCROLL, P, v.UID)
						elseif v.TYPE == RDV.LIBRARY.TYPE.NM then
							CreateNumber(SCROLL, P, v.UID)
						elseif v.TYPE == RDV.LIBRARY.TYPE.BN then
							CreateBind(SCROLL, P, v.UID)
						end
					end

					Run()
				end

				self.Think = function() end
			end
		end)
	end

	return true
end 

hook.Add("OnPlayerChat", "RDV.LIBRARY.CONFIG", function(P, text)
	if ( P == LocalPlayer() ) then
		local CMD = RDV.LIBRARY.GetConfigOption("RDVL_menuCommand")

		if CMD and CMD == text then	
			OpenMenu()
		end
	end
end)

concommand.Add("rdv_menu", function(ply, cmd, args)
	OpenMenu()
end )
--PATH lua/reality_development/libs/currencies/list/sh_blank.lua:
local OBJ = RDV.LIBRARY.RegisterCurrency("blank")

function OBJ:AddMoney(p, amount)
    
end

function OBJ:CanAfford(p, amount)
    return true
end

function OBJ:FormatMoney(money)
    return string.Comma(money)
end
--PATH lua/reality_development/libs/currencies/list/sh_darkrp.lua:
return gluapack()()
--PATH lua/reality_development/libs/currencies/list/sh_santos.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/autorun/sam.lua:
if SAM_LOADED then return end

local version = tonumber("160") or 160

sam = {}
sam.config = {}
sam.language = {}
sam.player = {}
sam.ranks = {}
sam.permissions = {}
sam.author = "Srlion"
sam.version = version

function sam.print(...)
	MsgC(
		Color(236, 240, 241), "(",
		Color(244, 67, 54), "SAM",
		Color(236, 240, 241), ") ",
		Color(236, 240, 241), ...
	) Msg("\n")
end

local FAILED = false
do
	local types = {
		sv_ = SERVER and include or function() end,
		cl_ = SERVER and AddCSLuaFile or include,
		sh_ = function(name)
			if SERVER then
				AddCSLuaFile(name)
			end
			return include(name)
		end
	}

	sam.load_file = function(name, type)
		if FAILED then return end

		if type and not type:EndsWith("_") then
			type = type .. "_"
		end

		local func = types[type] or types[name:GetFileFromFilename():sub(1, 3)] or types["sh_"]
		if func then
			local rets = {func(name)}
			if rets[1] == false then
				FAILED = true
				sam.print("Failed to load!")
			end
			return unpack(rets)
		end
	end
end
local load_file = sam.load_file

sam.print("Loading...")

load_file("sam/libs/sh_types.lua")
load_file("sam/libs/sh_pon.lua")
load_file("sam/libs/sh_mp.lua")

do
	local IsValid = IsValid
	local OLD_Player = Player

	-- this is because sam sends players' ids to the client, so if a player disconnects while net message is being sent
	-- the client will not know the player's name
	if CLIENT then
		local players = {}

		local Name = function(s)
			return s.name
		end

		local not_valid = function() return false end

		Player = function(id)
			local ply = OLD_Player(id)

			if not IsValid(ply) then
				local name = players[id]
				if name then
					return {
						name = name,
						Name = Name,
						IsValid = not_valid
					}
				end
			end

			return ply
		end

		hook.Add("OnEntityCreated", "SAM.GetPlayerName", function(ent)
			if ent:IsPlayer() and ent:IsValid() then
				ent.sam_userid = ent:UserID() -- userid is -1 in EntityRemoved?????
			end
		end)

		hook.Add("EntityRemoved", "SAM.GetPlayerName", function(ent)
			if not ent:IsPlayer() then return end

			local id = ent.sam_userid
			if not id then return end

			players[id] = ent:Name()

			timer.Simple(60, function()
				if not IsValid(ent) then
					players[id] = nil
				end
			end)
		end)
	end

	local sfs = load_file("sam/libs/sh_sfs.lua")
	sam.sfs = sfs

	local Encoder = sfs.Encoder
	local chars = sfs.chars
	local write = Encoder.write

	local CONSOLE
	CONSOLE = sfs.add_encoder("console", function(buf, color)
		write(buf, chars[CONSOLE])
	end)

	sfs.add_decoder(CONSOLE, function(ctx)
		ctx[1] = ctx[1] + 1
		return sam.console
	end)

	sfs.set_type_function(sam.type)

	Player = OLD_Player
end

load_file("sam/libs/sh_netstream.lua")
load_file("sam/libs/sh_async_netstream.lua")
load_file("sam/libs/sh_globals.lua")
load_file("sam/libs/sql/sv_init.lua")
sam.Promise = load_file("sam/libs/sh_promises.lua")

load_file("sam/sh_colors.lua")

load_file("sam/sh_util.lua")
load_file("sam/sh_lang.lua")
load_file("sam/sv_sql.lua")
load_file("sam/sh_permissions.lua")

load_file("sam/ranks/sh_ranks.lua")
load_file("sam/ranks/sv_ranks.lua")

load_file("sam/config/sh_config.lua")
load_file("sam/config/sv_config.lua")
load_file("sam/config/cl_config.lua")

load_file("sam/player/sh_player.lua")
load_file("sam/player/sh_nw_vars.lua")
load_file("sam/player/sv_player.lua")
load_file("sam/player/cl_player.lua")
load_file("sam/player/sv_ranks.lua")
load_file("sam/player/sv_auth.lua")
load_file("sam/player/sv_bans.lua")

load_file("sam/command/sh_command.lua")
load_file("sam/command/sv_command.lua")
load_file("sam/command/cl_command.lua")

for _, f in ipairs(file.Find("sam/command/arguments/*.lua", "LUA")) do
	load_file("sam/command/arguments/" .. f, "sh")
end

load_file("sam/sh_restrictions.lua")

load_file("sam/menu/sh_init.lua")
load_file("sam/menu/cl_init.lua")

load_file("sam/sh_motd.lua")

local modules = file.Find("sam/modules/*.lua", "LUA")
for _, module in ipairs(modules) do
	load_file("sam/modules/" .. module)
end

load_file("sam/reports/cl_reports.lua")
load_file("sam/reports/sv_reports.lua")

do
	if SERVER then
		hook.Add("SAM.LoadedConfig", "SAM.AdvertsMain", function(config)
			if not config.Adverts or not istable(config.Adverts) then
				sam.config.set("Adverts", {})
			end
		end)
	end
	load_file("sam/cl_adverts.lua")
end

if not FAILED then
	sam.print("Loaded!")
end

if SERVER then
	local path = "sam/importers/"

	concommand.Add("sam_import", function(ply, _, args)
		if IsValid(ply) then return end

		local admin_mod = args[1]
		if not admin_mod then
			sam.print("You need to provide an admin mod to import!")
			return
		end

		if not file.Exists(path .. admin_mod, "LUA") then
			sam.print("There is no importer for '" .. admin_mod .. "'")
			return
		end

		CompileFile(path .. admin_mod .. "/main.lua")()
	end, nil, nil, FCVAR_PROTECTED)
end

SAM_LOADED = true

--PATH addons/[admin] sam-160/lua/sam/libs/sh_pon.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/libs/sh_globals.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/config/sh_config.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/config/sh_config.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

sam.permissions.add("manage_config", nil, "superadmin")

local updates = {}
function config.hook(keys, func)
	for i = #keys, 1, -1 do
		keys[keys[i]] = true
		keys[i] = nil
	end

	local id = table.insert(updates, {
		keys = keys,
		func = func
	})

	if config.loaded then
		func()
	end

	return id
end

function config.get_updated(key, default)
	local setting = {}
	config.hook({key}, function()
		setting.value = config.get(key, default)
	end)
	return setting
end

function config.remove_hook(key)
	updates[key] = nil
end

hook.Add("SAM.LoadedConfig", "RunHooks", function()
	for k, v in pairs(updates) do
		v.func()
	end
end)

hook.Add("SAM.UpdatedConfig", "RunHooks", function(key, value, old)
	for k, v in pairs(updates) do
		if v.keys[key] then
			v.func(value, old)
		end
	end
end)
--PATH addons/[admin] sam-160/lua/sam/command/arguments/number.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/sh_restrictions.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/menu/sh_init.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_frame.lua:
local math = math
local gui = gui
local draw = draw
local surface = surface

local ScrW = ScrW
local ScrH = ScrH
local IsValid = IsValid
local ipairs = ipairs

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local FRAME_FONT = SUI.CreateFont("Frame", "Roboto", 18)

local Panel = FindMetaTable("Panel")

local PANEL = {}

AccessorFunc(PANEL, "m_bHeaderHeight", "HeaderHeight", FORCE_NUMBER)
AccessorFunc(PANEL, "m_bTitleFont", "TitleFont", FORCE_STRING)
AccessorFunc(PANEL, "m_bSizable", "Sizable", FORCE_BOOL)
AccessorFunc(PANEL, "m_iMinWidth", "MinWidth", FORCE_NUMBER)
AccessorFunc(PANEL, "m_iMinHeight", "MinHeight", FORCE_NUMBER)

local header_Think = function(s)
	local parent = s.parent
	local sw, sh = ScrW(), ScrH()

	if s.dragging then
		local x, y = input.GetCursorPos()
		x, y = math.Clamp(x, 1, sw - 1), math.Clamp(y, 1, sh - 1)
		x, y = x - s.dragging[1], y - s.dragging[2]

		parent:SetPos(x, y)
		parent:InvalidateLayout(true)
		parent:OnPosChanged()
	else
		local x, y, w, h = parent:GetBounds()
		parent:SetPos(math.Clamp(x, 5, sw - w - 5), math.Clamp(y, 5, sh - h - 5))
	end
end

local header_OnMousePressed = function(s)
	local parent = s.parent
	s.dragging = {gui.MouseX() - parent.x, gui.MouseY() - parent.y}
	s:MouseCapture(true)
end

local header_OnMouseReleased = function(s)
	s.dragging = nil
	s:MouseCapture(false)
end

local title_SetBGColor = function(s, c)
	s:SetVisible(c and true or false)
end

local title_update_color = function(s)
	s:SetTextColor(SUI.GetColor("title"))
end

local close_DoClick = function(s)
	s.frame:Remove()
end

function PANEL:Init()
	local header_buttons = {}
	self.header_buttons = header_buttons

	self:Center()
	self:SetHeaderHeight(28)

	local header = self:Add("PANEL")
	header:Dock(TOP)
	header.Paint = self.HeaderPaint
	header:SetCursor("sizeall")

	header.parent = self
	header.Think = header_Think
	header.OnMousePressed = header_OnMousePressed
	header.OnMouseReleased = header_OnMouseReleased
	self.header = header

	local title = header:Add(NAME .. ".Label")
	title:Dock(LEFT)
	title:DockMargin(6, 2, 0, 2)
	title:SetText("")
	title:SetTextColor(SUI.GetColor("title"))
	title:SizeToContents()
	title.SetBGColor = title_SetBGColor
	hook.Add(NAME .. ".ThemeChanged", title, title_update_color)
	self.title = title

	self.close = self:AddHeaderButton("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/close.png", "close", close_DoClick)
	self.close.frame = self

	self:SetSize(SUI.Scale(520), SUI.Scale(364))
	self:SetTitleFont(FRAME_FONT)
	SUI.OnScaleChanged(self, self.ScaleChanged)

	function self:PerformLayout(w, h)
		if IsValid(title) then
			title:SizeToContents()
		end

		if IsValid(header) then
			header:SetTall(SUI.Scale(self:GetHeaderHeight()))
		end

		for k, v in ipairs(header_buttons) do
			if IsValid(v) then
				v:SetWide(v:GetTall())
				local margin = SUI.Scale(4)
				v.image:DockMargin(margin, margin, margin, margin)
			end
		end
	end
end

function PANEL:SetSize(w, h)
	self.real_w, self.real_h = w, h
	self:ScaleChanged()
end

function PANEL:HeaderPaint(w, h)
	draw.RoundedBoxEx(3, 0, 0, w, h, SUI.GetColor("header"), true, true)
end

local SetSize = Panel.SetSize
PANEL.RealSetSize = SetSize
function PANEL:ScaleChanged()
	if self.sizing then return end

	local new_w, new_h = SUI.Scale(self.real_w), SUI.Scale(self.real_h)
	self.x, self.y = self.x + (self:GetWide() / 2 - new_w / 2), self.y + (self:GetTall() / 2 - new_h / 2)
	SetSize(self, new_w, new_h)
	self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
	if SUI.GetColor("frame_blur") then
		TDLib.BlurPanel(self)
	end

	self:RoundedBox("Background", 3, 0, 0, w, h, SUI.GetColor("frame"))
end

function PANEL:SetTitleFont(font)
	self.m_bTitleFont = font
	self.title:SetFont(font)
end

function PANEL:SetTitle(text)
	self.title:SetText(text)
	self.title:SizeToContents()
end

function PANEL:AddHeaderButton(image_name, name, callback)
	local button = self.header:Add("DButton")
	button:SetText("")
	button:Dock(RIGHT)
	button:DockMargin(0, 2, #self.header:GetChildren() == 1 and 4 or 2, 2)

	local hover = name .. "_hover"
	local press = name .. "_press"
	local circle = {}
	button.Paint = function(s, w, h)
		if s:IsHovered() then
			TDLib.DrawCircle(circle, w / 2, h / 2, w / 2, SUI.GetColor(hover))
		end

		if s.Depressed then
			TDLib.DrawCircle(circle, w / 2, h / 2, w / 2, SUI.GetColor(press))
		end
	end
	button.DoClick = callback

	local image = button:Add(NAME .. ".Image")
	image:Dock(FILL)
	image:SetMouseInputEnabled(false)
	image:SetImage(image_name)

	button.image = image

	table.insert(self.header_buttons, button)

	return button
end

function PANEL:OnMousePressed(_, checking)
	if not self.m_bSizable then return end

	local x, y = self:LocalToScreen(0, 0)
	local w, h = self:GetSize()
	if gui.MouseX() > (x + w - 20) and gui.MouseY() > (y + h - 20) then
		if not checking then
			self.sizing = {gui.MouseX() - w, gui.MouseY() - h}
			self:MouseCapture(true)
		end

		self:SetCursor("sizenwse")

		return
	end

	if checking then
		self:SetCursor("arrow")
	end
end

function PANEL:OnMouseReleased()
	if not self.m_bSizable then return end

	self:MouseCapture(false)
	SUI.CallScaleChanged()
	self.sizing = nil
end

function PANEL:Think()
	if not self.m_bSizable then return end

	self:OnMousePressed(nil, true)

	if not self.sizing then return end

	local sw, sh = ScrW(), ScrH()

	local cx, cy = input.GetCursorPos()
	local mousex = math.Clamp(cx, 1, sw - 1)
	local mousey = math.Clamp(cy, 1, sh - 1)

	local x = mousex - self.sizing[1]
	x = math.Clamp(x, self.m_iMinWidth, sw - 10)

	local y = mousey - self.sizing[2]
	y = math.Clamp(y, self.m_iMinHeight, sh - 10)

	self.real_w, self.real_h = x, y
	SetSize(self, x, y)
	self:InvalidateLayout(true)
	self:SetCursor("sizenwse")
end

function PANEL:OnPosChanged()
end

local SetVisible = Panel.SetVisible
local Remove = Panel.Remove

local anim_speed = 0.2

local show = function(s)
	local w, h = s.real_w, s.real_h

	if s.anim_scale then
		w, h = SUI.Scale(w), SUI.Scale(h)
	end

	SetVisible(s, true)

	SetSize(s, w * 1.1, h * 1.1)
	s:Center()

	s:Stop()
	s:SizeTo(w, h, anim_speed, 0, -1)
	s:MoveTo((ScrW() / 2) - (w / 2), (ScrH() / 2) - (h / 2), anim_speed, 0, -1)
	s:AlphaTo(255, anim_speed + 0.02, 0)
	s:MakePopup()
end

local remove = function(s, hide)
	if not hide and not s:IsVisible() then
		Remove(s)
		return
	end

	local w, h = s.real_w, s.real_h

	if s.anim_scale then
		w, h = SUI.Scale(w), SUI.Scale(h)
	end

	w, h = w * 1.1, h * 1.1

	s:Stop()
	s:SizeTo(w, h, anim_speed, 0, -1)
	s:MoveTo((ScrW() / 2) - (w / 2), (ScrH() / 2) - (h / 2), anim_speed, 0, -1)
	s:SetMouseInputEnabled(false)
	s:SetKeyboardInputEnabled(false)
	s:AlphaTo(0, anim_speed + 0.02, 0, function()
		if hide then
			SetVisible(s, false)
		else
			Remove(s)
		end
	end)
end

local hide = function(s)
	remove(s, true)
end

function PANEL:AddAnimations(w, h, no_scale)
	self.anim_scale = not no_scale
	self.real_w, self.real_h = w, h

	self:SetAlpha(0)
	show(self)

	self.Remove = remove
	self.Hide = hide
	self.Show = show
end

sui.register("Frame", PANEL, "EditablePanel")
--PATH addons/[lib] sui/lua/sui/vgui/sui_image.lua:
local table = table
local file = file
local coroutine = coroutine
local surface = surface

local UnPredictedCurTime = UnPredictedCurTime
local pairs = pairs

local color_white = color_white

local sui = sui
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local read_gif = include("sui/libs/gif_loader.lua")
local generate_png = include("sui/libs/png_encoder.lua")

local images_path = (NAME .. "/images/"):lower()
file.CreateDir(images_path)

local get_image_path = function(url)
	return images_path .. (url:gsub("%W", "_") .. ".png")
end

local Write = file.Write
local gif_to_png; do
	local internal_gif_to_png = function(file_path, chunk)
		local gif = read_gif(chunk)
		local frames = gif:get_frames()
		local w, h = gif.width, gif.height

		local path = file_path .. "/"
		file.CreateDir(path)

		for frame_id = 1, #frames do
			local frame = frames[frame_id]
			local data = frame.data
			local png = generate_png(w, h, data)
			Write(("%s%d_%d.png"):format(path, frame_id, frame.delay), png)
			coroutine.yield()
		end
	end

	local delay = 0.01
	local next_run = 0

	local coroutines = {}
	local callbacks = {}
	gif_to_png = function(file_path, data, callback)
		local co = coroutine.create(internal_gif_to_png)
		local i = table.insert(coroutines, co)
		callbacks[i] = callback
		coroutine.resume(co, file_path, data)
		next_run = UnPredictedCurTime()
	end

	hook.Add("Think", NAME .. "ProcessGIFs", function()
		local co = coroutines[1]
		if not co then return end
		if UnPredictedCurTime() < next_run then return end

		if coroutine.status(co) == "suspended" then
			coroutine.resume(co)
		else
			callbacks[1]()
			table.remove(coroutines, 1)
			table.remove(callbacks, 1)
		end

		next_run = UnPredictedCurTime() + delay
	end)

	hook.Add(NAME .. "ImagesCleared", "ClearCoroutines", function()
		table.Empty(coroutines)
		table.Empty(callbacks)
	end)
end

local download_image, is_downloading_image; do
	-- https://stackoverflow.com/questions/25959386/how-to-check-if-a-file-is-a-valid-image
	local valid_images = {
		["\xff\xd8\xff"] = "jpeg",
		["\x89PNG\r\n\x1a\n"] = "png",
		["GIF87a"] = "gif",
		["GIF89a"] = "gif",
	}

	local get_image_type = function(data)
		for k, v in pairs(valid_images) do
			if data:StartWith(k) then
				return v
			end
		end
		return false
	end

	local downloading_images = {}

	local process_callbacks = function(url)
		local callbacks = downloading_images[url] or {}
		downloading_images[url] = nil

		for _, func in ipairs(callbacks) do
			func()
		end
	end

	download_image = function(url, callback)
		if downloading_images[url] then
			table.insert(downloading_images[url], callback)
			return
		end

		downloading_images[url] = {callback}

		http.Fetch(url, function(data)
			local image_type = get_image_type(data)
			if not image_type then
				downloading_images[url] = nil
				return
			end

			local image_path = get_image_path(url)

			if image_type == "gif" then
				gif_to_png(image_path, data, function()
					process_callbacks(url)
				end)
			else
				file.Write(image_path, data)
				process_callbacks(url)
			end
		end, function(err)
			print("(SUI) Failed to download an image, error: " .. err)
			downloading_images[url] = nil
		end)
	end

	is_downloading_image = function(url)
		return downloading_images[url] ~= nil
	end

	hook.Add(NAME .. "ImagesCleared", "ClearDownloadingImages", function()
		table.Empty(downloading_images)
	end)
end

local images_panels = {}

local PANEL = {}

local err_mat = SUI.Material("error")

function PANEL:Init()
	self:SetMouseInputEnabled(false)

	self.minus = 0
	self.rotation = 0
	self.image = err_mat
	self.image_col = color_white

	table.insert(images_panels, self)
end

function PANEL:OnRemove()
	for k, v in ipairs(images_panels) do
		if v == self then
			table.remove(images_panels, k)
			return
		end
	end
end

function PANEL:SetMinus(minus)
	self.minus = minus
end

function PANEL:SetRotation(rotation)
	self.rotation = rotation
end

function PANEL:SetImageColor(col)
	self.image_col = col
end

local cached_files = {}
local get_files = function(image_path)
	local f = cached_files[image_path]
	if f then return f end

	cached_files[image_path] = file.Find(image_path .. "/*", "DATA")

	return cached_files[image_path]
end

function PANEL:SetImage(url)
	self.image = err_mat

	self.pos = nil
	self.delay = nil

	self.images = nil
	self.delays = nil
	self.url = url

	if url:sub(1, 4) ~= "http" then
		self.image = SUI.Material(url)
		return
	end

	local image_path = get_image_path(url)
	if not file.Exists(image_path, "DATA") or is_downloading_image(url) then
		download_image(url, function()
			if self:IsValid() then
				self:SetImage(url)
			end
		end)
		return
	end

	local is_gif = file.IsDir(image_path, "DATA")
	if is_gif then
		local images = {}
		local delays = {}

		local files = get_files(image_path)
		for i = 1, #files do
			local v = files[i]
			local id, delay = v:match("(.*)_(.*)%.png")
			id = tonumber(id)
			local img_path = "../data/" .. image_path .. "/" .. v
			images[id] = img_path
			delays[id] = delay
		end

		self.frame = 1
		self.delay = (UnPredictedCurTime() * 100) + delays[1]

		self.images = images
		self.delays = delays

		self.max_images = #files
	else
		self.image = SUI.Material("../data/" .. image_path)
	end
end

local SetMaterial = surface.SetMaterial
function PANEL:PaintGIF(w, h, images)
	local frame = self.frame

	-- SUI.Material() caches materials by default
	local mat = SUI.Material(images[frame], true)
	if not mat then
		if frame > 1 then
			mat = SUI.Material(images[frame - 1])
		else
			mat = err_mat
		end

		SetMaterial(mat)

		return
	end

	SetMaterial(mat)

	local curtime = UnPredictedCurTime() * 100
	if curtime < self.delay then return end
	frame = frame + 1
	if frame > self.max_images then
		frame = 1
	end

	self.frame = frame
	self.delay = curtime + self.delays[frame]
end

local PaintGIF = PANEL.PaintGIF
local SetDrawColor = surface.SetDrawColor
local DrawTexturedRectRotated = surface.DrawTexturedRectRotated
function PANEL:Paint(w, h)
	SetDrawColor(self.image_col)

	local images = self.images
	if images then
		PaintGIF(self, w, h, images)
	else
		SetMaterial(self.image)
	end

	if self.Draw then
		self:Draw(w, h, true)
	else
		local minus = self.minus
		DrawTexturedRectRotated(w * 0.5, h * 0.5, w - minus, h - minus, self.rotation)
	end
end

sui.register("Image", PANEL, "PANEL")

function SUI.ClearImages()
	local files, dirs = file.Find(images_path .. "/*", "DATA")
	for _, f in ipairs(files) do
		file.Delete(images_path .. f)
	end

	for _, d in ipairs(dirs) do
		for _, f in ipairs(file.Find(images_path .. d .. "/*", "DATA")) do
			file.Delete(images_path .. (d .. "/" .. f))
		end
		file.Delete(images_path .. d)
	end

	table.Empty(SUI.materials)
	table.Empty(cached_files)

	hook.Call(NAME .. "ImagesCleared")

	for k, v in ipairs(images_panels) do
		if v.url then
			v:SetImage(v.url)
		end
	end
end
--PATH addons/[lib] sui/lua/sui/vgui/sui_label.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local MOUSE_LEFT = MOUSE_LEFT

local SysTime = SysTime

local PANEL = {}

AccessorFunc(PANEL, "m_colText", "TextColor")
AccessorFunc(PANEL, "m_colTextStyle", "TextStyleColor")
AccessorFunc(PANEL, "m_FontName", "Font")

AccessorFunc(PANEL, "m_bDoubleClicking", "DoubleClickingEnabled", FORCE_BOOL)
AccessorFunc(PANEL, "m_bAutoStretchVertical", "AutoStretchVertical", FORCE_BOOL)
AccessorFunc(PANEL, "m_bIsMenuComponent", "IsMenu", FORCE_BOOL)

AccessorFunc(PANEL, "m_bBackground", "PaintBackground",	FORCE_BOOL)
AccessorFunc(PANEL, "m_bBackground", "DrawBackground",	FORCE_BOOL)
AccessorFunc(PANEL, "m_bDisabled", "Disabled", FORCE_BOOL)

AccessorFunc(PANEL, "m_bIsToggle", "IsToggle", FORCE_BOOL)
AccessorFunc(PANEL, "m_bToggle", "Toggle", FORCE_BOOL)

AccessorFunc(PANEL, "m_bBright", "Bright", FORCE_BOOL)
AccessorFunc(PANEL, "m_bDark", "Dark", FORCE_BOOL)
AccessorFunc(PANEL, "m_bHighlight",	"Highlight", FORCE_BOOL)

PANEL:SetIsToggle(false)
PANEL:SetToggle(false)
PANEL:SetDisabled(false)
PANEL:SetDoubleClickingEnabled(true)

local Panel = FindMetaTable("Panel")
local SetMouseInputEnabled = Panel.SetMouseInputEnabled
local SetPaintBackgroundEnabled = Panel.SetPaintBackgroundEnabled
local SetPaintBorderEnabled = Panel.SetPaintBorderEnabled
local InvalidateLayout = Panel.InvalidateLayout
local SetFGColor = Panel.SetFGColor
function PANEL:Init()
	SetMouseInputEnabled(self, false)
	SetPaintBackgroundEnabled(self, false)
	SetPaintBorderEnabled(self, false)
end

function PANEL:AllowScale()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function PANEL:ScaleChanged()
	self:SizeToContents()
end

function PANEL:SetFont(font)
	if self.m_FontName == font then return end

	self.m_FontName = font
	self:SetFontInternal(self.m_FontName)
end

function PANEL:SetTextColor(col)
	if self.m_colText == col then return end

	self.m_colText = col
	SetFGColor(self, col.r, col.g, col.b, col.a)
end
PANEL.SetColor = PANEL.SetTextColor

function PANEL:GetColor()
	return self.m_colText or self.m_colTextStyle
end

function PANEL:Toggle()
	if not self:GetIsToggle() then return end

	self:SetToggle(not self:GetToggle())
	self:OnToggled(self:GetToggle())
end

function PANEL:SetDisabled(bDisabled)
	self.m_bDisabled = bDisabled
	InvalidateLayout(self)
end

function PANEL:SetEnabled(bEnabled)
	self:SetDisabled(not bEnabled)
end

function PANEL:IsEnabled()
	return not self:GetDisabled()
end

function PANEL:ApplySchemeSettings()
	local col = self:GetColor()
	if not col then return end

	self:SetFGColor(col.r, col.g, col.b, col.a)
end

function PANEL:AutoStretchVerticalThink()
	self:SizeToContentsY()
end

function PANEL:SetAutoStretchVertical(enable)
	self.m_bAutoStretchVertical = enable
	self.Think = enable and self.AutoStretchVerticalThink or nil
end

function PANEL:OnCursorEntered()
	InvalidateLayout(self, true)
end

function PANEL:OnCursorExited()
	InvalidateLayout(self, true)
end

function PANEL:OnMousePressed(mousecode)
	if self:GetDisabled() then return end

	if mousecode == MOUSE_LEFT and not dragndrop.IsDragging() and self.m_bDoubleClicking then
		if self.LastClickTime and SysTime() - self.LastClickTime < 0.2 then

			self:DoDoubleClickInternal()
			self:DoDoubleClick()
			return
		end

		self.LastClickTime = SysTime()
	end

	if self:IsSelectable() and mousecode == MOUSE_LEFT and input.IsShiftDown() then
		return self:StartBoxSelection()
	end

	self:MouseCapture(true)
	self.Depressed = true
	self:OnDepressed()
	InvalidateLayout(self, true)

	self:DragMousePress(mousecode)
end

function PANEL:OnMouseReleased(mousecode)
	self:MouseCapture(false)

	if self:GetDisabled() then return end
	if not self.Depressed and dragndrop.m_DraggingMain ~= self then return end

	if self.Depressed then
		self.Depressed = nil
		self:OnReleased()
		InvalidateLayout(self, true)
	end

	if self:DragMouseRelease(mousecode) then return end

	if self:IsSelectable() and mousecode == MOUSE_LEFT then
		local canvas = self:GetSelectionCanvas()
		if canvas then
			canvas:UnselectAll()
		end
	end

	if not self.Hovered then return end

	self.Depressed = true

	if mousecode == MOUSE_RIGHT then
		self:DoRightClick()
	end

	if mousecode == MOUSE_LEFT then
		self:DoClickInternal()
		self:DoClick()
	end

	if mousecode == MOUSE_MIDDLE then
		self:DoMiddleClick()
	end

	self.Depressed = nil
end

function PANEL:OnReleased()
end

function PANEL:OnDepressed()
end

function PANEL:OnToggled(bool)
end

function PANEL:DoClick()
	self:Toggle()
end

function PANEL:DoRightClick()
end

function PANEL:DoMiddleClick()
end

function PANEL:DoClickInternal()
end

function PANEL:DoDoubleClick()
end

function PANEL:DoDoubleClickInternal()
end

sui.register("Label", PANEL, "Label")
--PATH addons/[lib] sui/lua/sui/vgui/sui_panel.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_zcolumn_sheet.lua:
local IsValid = IsValid

local TDLib_Classes = sui.TDLib.LibClasses
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local Panel = {}

function Panel:Init()
	self.tabs = {}

	local tab_scroller = self:Add(NAME .. ".ScrollPanel")
	tab_scroller:Dock(LEFT)

	function tab_scroller:Paint(w, h)
		self:RoundedBox("Background", 1, 0, 0, w, h, GetColor("column_sheet_bar"))
	end

	self.tabs_wide = 48
	self.tab_scroller = tab_scroller

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function Panel:ScaleChanged()
	local tabs_wide = SUI.Scale(self.tabs_wide)
	self.tab_scroller:SetWide(tabs_wide)

	self:InvalidateLayout(true)

	local tabs = self.tabs
	for i = 1, #self.tabs do
		tabs[i].img:SetMinus(SUI.Scale(20))
	end
end

function Panel:Paint(w, h)
	self:RoundedBox("Background", 1, 0, 0, w, h, GetColor("column_sheet"))
end

local tab_DoClick = function(s)
	s.parent:SetActiveTab(s)
end

local tab_Paint = function(s, w, h)
	local cur_col
	if s.active then
		cur_col = GetColor("column_sheet_tab_active")
	elseif s.Hovered then
		cur_col = GetColor("column_sheet_tab_hover")
	else
		cur_col = GetColor("column_sheet_tab")
	end

	s:RoundedBox("Backgrounds", 0, 0, 0, w, h, cur_col)
end

local tab_OnRemove = function(s)
	table.RemoveByValue(s.parent.tabs, s)
end

function Panel:AddSheet(mat, load_func)
	local tab = self.tab_scroller:Add(NAME .. ".Button")
	tab:Dock(TOP)
	tab:SetText("")
	tab:SetTall(self.tabs_wide)

	tab.On = TDLib_Classes.On

	tab.DoClick = tab_DoClick
	tab.Paint = tab_Paint
	tab:On("OnRemove", tab_OnRemove)

	tab.parent = self
	tab.load_func = load_func

	local img = tab:Add(NAME .. ".Image")
	img:Dock(FILL)
	img:SetImage(mat)
	img:SetMinus(SUI.Scale(20))

	tab.img = img

	self.tab_scroller:AddItem(tab)

	if not self:GetActiveTab() then
		self:SetActiveTab(tab)
	end

	table.insert(self.tabs, tab)

	return tab
end

function Panel:GetActiveTab()
	return self.active_tab
end

function Panel:SetActiveTab(new_tab)
	if new_tab == self.active_tab then return end

	if not IsValid(new_tab.panel) then
		local panel = new_tab.load_func(self)
		panel:SetParent(self)
		panel:SetVisible(false)
		panel:SetAlpha(0)

		panel.tab = new_tab
		new_tab.panel = panel
	end

	local old_active_tab = self.active_tab
	local delay = 0
	if old_active_tab and IsValid(old_active_tab.panel) then
		old_active_tab.active = false
		delay = 0.2
		old_active_tab.panel:AlphaTo(0, delay, 0, function(_, p)
			if p:IsValid() then
				p:SetVisible(false)
			end
		end)
	end

	new_tab.active = true
	new_tab.panel:SetVisible(true)
	new_tab.panel:AlphaTo(255, 0.2, delay)
	self.active_tab = new_tab
end

sui.register("ColumnSheet", Panel, "EditablePanel")
--PATH addons/[lib] sui/lua/sui/vgui/sui_zmenu.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/menu/tabs/config.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/menu/tabs/config/reports.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

local not_empty = function(s)
	return s and s ~= ""
end

local number_entry = function(setting, config_key, default)
	local entry = setting:Add("SAM.TextEntry")
	entry:SetWide(50)
	entry:SetPlaceholder("")
	entry:SetBackground(Color(34, 34, 34))
	entry:SetNumeric(true)
	entry:DisallowFloats()
	entry:DisallowNegative()
	entry:SetCheck(not_empty)
	entry:SetConfig(config_key, default)

	return entry
end

config.add_tab("Reports", function(parent)
	local body = parent:Add("SAM.ScrollPanel")
	body:Dock(FILL)
	body:LineMargin(0, 6, 0, 0)

	local i = 0
	body:GetCanvas():On("OnChildAdded", function(s, child)
		i = i + 1
		child:SetZPos(i)

		if not body.making_line then
			body:Line()
		end
	end)

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Enable")
		setting:DockMargin(8, 6, 8, 0)

		local enable = setting:Add("SAM.ToggleButton")
		enable:SetConfig("Reports", true)
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Commands")
		setting:DockMargin(8, 6, 8, 0)

		local entry = setting:Add("SAM.TextEntry")
		entry:SetWide(200)
		entry:SetNoBar(true)
		entry:SetPlaceholder("")
		entry:SetMultiline(true)
		entry:SetConfig("Reports.Commands")
		entry.no_scale = true

		function entry:OnValueChange()
			self:SetTall(self:GetNumLines() * (sam.SUI.Scale(16) --[[font size]] + 1) + 1 + 2)
		end
		entry:OnValueChange()
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Max Reports (Number of reports that can show on your screen)")
		setting:DockMargin(8, 6, 8, 0)

		number_entry(setting, "Reports.MaxReports", 4)
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Auto Close Time (Time to wait before automatically closing claimed reports)")
		setting:DockMargin(8, 6, 8, 0)

		local entry = setting:Add("SAM.TextEntry")
		entry:SetWide(70)
		entry:SetNoBar(false)
		entry:SetPlaceholder("")
		entry:SetCheck(function(time)
			time = sam.parse_length(time)
			if not time then
				return false
			end
		end)
		entry:SetConfig("Reports.AutoCloseTime", "10m")
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Always Show (Show the popups even if you are not on duty)")
		setting:DockMargin(8, 6, 8, 0)

		local enable = setting:Add("SAM.ToggleButton")
		enable:SetConfig("Reports.AlwaysShow", true)
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("On Duty Jobs")
		setting:DockMargin(8, 6, 8, 0)

		local entry = setting:Add("SAM.TextEntry")
		entry:SetWide(300)
		entry:SetNoBar(true)
		entry:SetPlaceholder("")
		entry:SetMultiline(true)
		entry:SetConfig("Reports.DutyJobs", "")
		entry.no_scale = true

		function entry:OnValueChange()
			self:SetTall(self:GetNumLines() * (sam.SUI.Scale(16) --[[font size]] + 1) + 1 + 2)
		end
		entry:OnValueChange()
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Position")
		setting:DockMargin(8, 6, 8, 0)

		local combo = setting:Add("SAM.ComboBox")
		combo:SetWide(60)
		combo:AddChoice("Left", nil, true)
		combo:AddChoice("Right")
		combo:SetConfig("Reports.Position", "Left")
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("X Padding")
		setting:DockMargin(8, 6, 8, 0)

		number_entry(setting, "Reports.XPadding", 5)
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Y Padding")
		setting:DockMargin(8, 6, 8, 0)

		number_entry(setting, "Reports.YPadding", 5)
	end

	return body
end, function()
	return LocalPlayer():HasPermission("manage_config")
end, 2)
--PATH addons/[admin] sam-160/lua/sam/modules/cami.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/modules/command_notify_for_ranks.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/modules/util.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/reports/cl_reports.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/cl_adverts.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

local times = {}

local entry_OnValueChange = function(s)
	s:SetTall(s:GetNumLines() * (sam.SUI.Scale(16) --[[font size]] + 1) + 1 + 2)
end

local entry_OnEnter = function(s)
	local ads = config.get("Adverts", {})
	local txt = s:GetText()
	if txt == "" then
		s:Remove()
		if s.i then
			table.remove(ads, s.i)
		end
	else
		if txt == s.ad then return end
		ads[s.i] = txt
		s.ad = txt
	end
	config.set("Adverts", ads, true)
end

local entry_OnKeyCodeTyped = function(s, code)
	if code == KEY_ENTER then
		s:old_OnKeyCodeTyped(code)
		return true
	else
		return s:old_OnKeyCodeTyped(code)
	end
end

config.add_menu_setting("Adverts", function(body)
	local adverts_body

	local adverts = body:Add("SAM.LabelPanel")
	adverts:Dock(TOP)
	adverts:DockMargin(8, 6, 8, 0)
	adverts:SetLabel("Adverts\n- Random adverts print every 60 seconds\n- Timed adverts can be done like this: {1m} This advert prints every 1 minute")

	local add_advert = adverts:Add("SAM.Button")
	add_advert:SetText("+")
	add_advert:SetSize(25, 25)

	local zpos = 0
	local add_func = function(ad, ad_i)
		zpos = zpos + 1

		local entry = adverts_body:Add("SAM.TextEntry")
		entry:SetPlaceholder("")
		entry:SetMultiline(true)
		entry:SetNoBar(true)
		entry:Dock(TOP)
		entry:DockMargin(8, 6, 8, 0)
		entry:SetZPos(zpos)
		entry.ad = ad
		entry.no_scale = true

		if not sam.ispanel(ad) then
			entry.i = ad_i
			entry:SetValue(ad)
		else
			entry.i = #config.get("Adverts", {}) + 1
		end

		entry.OnValueChange = entry_OnValueChange
		entry.OnEnter = entry_OnEnter
		entry.old_OnKeyCodeTyped = entry.OnKeyCodeTyped
		entry.OnKeyCodeTyped = entry_OnKeyCodeTyped
	end
	add_advert:On("DoClick", add_func)

	adverts_body = body:Add("Panel")
	adverts_body:Dock(TOP)

	function adverts_body:PerformLayout(w, h)
		for k, v in ipairs(self:GetChildren()) do
			entry_OnValueChange(v)
		end
		self:SizeToChildren(false, true)
	end

	sam.config.hook({"Adverts"}, function()
		if not IsValid(adverts_body) then return end
		adverts_body:Clear()

		for k, v in ipairs(config.get("Adverts", {})) do
			add_func(v, k)
		end
	end)
end)

local random = {}

timer.Create("SAM.Advert.RandomAdverts", 60, 0, function()
	local ad = random[math.random(1, #random)]
	if not ad then return end
	sam.player.send_message(nil, ad)
end)

sam.config.hook({"Adverts"}, function()
	for i = #times, 1, -1 do
		times[i] = nil
		timer.Remove("SAM.Adverts." .. i)
	end

	random = {}
	for k, v in ipairs(config.get("Adverts", {})) do
		if v:sub(1, 1) == "{" then
			local time, message = v:match("(%b{}) *(.*)")
			time = sam.parse_length(time)
			if time then
				timer.Create("SAM.Adverts." .. table.insert(times, true), time * 60, 0, function()
					sam.player.send_message(nil, message)
				end)
			else
				table.insert(random, v)
			end
		else
			table.insert(random, v)
		end
	end
end)

--PATH addons/[chat] scb-29/lua/autorun/scb.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_number_slider.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_panel.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_query_box.lua:
local ScrW, ScrH = ScrW, ScrH
local DisableClipping = DisableClipping
local SetDrawColor = surface.SetDrawColor
local DrawRect = surface.DrawRect
local BlurPanel = sui.TDLib.BlurPanel
local lerp_color = sui.lerp_color

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local PANEL = {}

function PANEL:SetCallback(callback)
	self.callback = callback
end

function PANEL:Init()
	self:SetSize(0, 0)

	local bottom = self:Add("Panel")
	bottom:Dock(BOTTOM)
	bottom:DockMargin(4, 10, 4, 4)
	bottom:SetZPos(100)

	local save = bottom:Add(NAME .. ".Button")
	save:SetText("SAVE")
	save:Dock(RIGHT)
	save:SetEnabled(false)
	self.save = save

	function save.DoClick()
		self.callback()
		self:Remove()
	end

	local cancel = bottom:Add(NAME .. ".Button")
	cancel:Dock(RIGHT)
	cancel:DockMargin(0, 0, 4, 0)
	cancel:SetContained(false)
	cancel:SetColors(GetColor("query_box_cancel"), GetColor("query_box_cancel_text"))
	cancel:SetText("CANCEL")
	self.cancel = cancel

	function cancel.DoClick()
		self:Remove()
	end

	bottom:SetSize(save:GetWide() * 2 + 4, SUI.Scale(30))

	local body = self:Add("Panel")
	body:Dock(FILL)
	body:DockMargin(4, 4, 4, 4)
	body:DockPadding(3, 3, 3, 3)
	body:InvalidateLayout(true)
	body:InvalidateParent(true)

	local added = 1
	function body.OnChildAdded(s, child)
		added = added + 1
		child:Dock(TOP)
		child:SetZPos(added)
		child:InvalidateLayout(true)
		s:InvalidateLayout(true)
	end
	self.body = body

	function self:Add(name)
		return body:Add(name)
	end

	local old_Paint = self.Paint
	local trans = Color(0, 0, 0, 0)
	local new_col = Color(70, 70, 70, 100)
	function self:Paint(w, h)
		lerp_color(trans, new_col)

		local x, y = self:LocalToScreen(0, 0)
		DisableClipping(true)
			BlurPanel(self)
			SetDrawColor(trans)
			DrawRect(x * -1, y * -1, ScrW(), ScrH())
		DisableClipping(false)

		old_Paint(self, w, h)
	end
end

function PANEL:ChildrenHeight()
	local body = self.body

	self.header:InvalidateLayout(true)
	local height = self.header:GetTall()

	body:InvalidateLayout(true)
	self:InvalidateLayout(true)
	height = height + select(2, body:ChildrenSize())

	height = height + SUI.Scale(30) + 14 + 6

	return height
end

function PANEL:Paint(w, h)
	if GetColor("frame_blur") then
		BlurPanel(self)
	end

	self:RoundedBox("Background", 8, 0, 0, w, h, GetColor("query_box_bg"))
end

function PANEL:Done()
	self:InvalidateChildren(true)

	self.size_to_children = function()
		local h = self:ChildrenHeight()
		self:RealSetSize(self:GetWide(), h)
		self.real_h = h
	end

	self:Center()
	self:MakePopup()
	self:DoModal(true)

	timer.Simple(0.08, function()
		self:AddAnimations(self:GetWide(), self:ChildrenHeight(), true)
	end)
end

sui.register("QueryBox", PANEL, NAME .. ".Frame")
--PATH addons/[miecze] mexicano_drzewko/lua/autorun/sh_addways.lua:
return gluapack()()
--PATH addons/[miecze] mexicano_drzewko/lua/autorun/sh_addways.lua:


if not SERVER then return end
local PLAYER = FindMetaTable("Player")

function PLAYER:setPunkty(xp)
    if not IsValid(self) then return end
    self:SetNWInt("jedi_punkty", xp)

    local tabelka1 = self:LoadData()
    tabelka1.jedi_punkty = xp
    self:SaveData(tabelka1)
end

function PLAYER:getPunkty()
    return self:GetNWInt("jedi_punkty") or 0
end

function PLAYER:addPunkty(amount)
    if not IsValid(self) then return end
    local currentXP = self:getPunkty()
    local newXP = currentXP + amount
    self:setPunkty(newXP)
end

function PLAYER:SaveData(data)
    local currentXP = self:GetNWInt("jedi_punkty", 0)
    --local data = self:LoadData()

    if data.jedi_punkty ~= currentXP then
        data.jedi_punkty = currentXP
    end
	file.CreateDir("jedi_data")
    local filePath = "jedi_data/" .. self:SteamID64() .. ".txt"
    local content = util.TableToJSON(data, true)

    file.Write(filePath, content)
    --print("Zapisano dane w pliku: " .. filePath)
end

function PLAYER:LoadData()
    local filePath = "jedi_data/" .. self:SteamID64() .. ".txt"
    local defaultData = { jedi_punkty = 0, kupione_upgradey = {} }

    if file.Exists(filePath, "DATA") then
        local content = file.Read(filePath, "DATA")
        local data = util.JSONToTable(content)
        if data then
            --print("Zaadowano dane z pliku: " .. filePath)
            return data
        else
            --print("Bd podczas adowania danych: niepoprawny format JSON.")
        end
    else
        --print("Plik nie istnieje: " .. filePath)
    end

    return defaultData
end

hook.Add("PlayerInitialSpawn", "MX_LSCS", function(ply)
    if not IsValid(ply) then return end

    local data = ply:LoadData()
    local jediXP = data.jedi_punkty or 0
    ply:SetNWInt("jedi_punkty", jediXP)
end)


/*


hook.Add("OnPlayerChangedTeam", "MX_LSCS_AssignUpgrades", function(ply,o,newteam)
    if not IsValid(ply) then return end

    local teamData = RPExtraTeams[newteam]
    if not teamData or (teamData.category ~= MX_CatJedi and teamData.jedi ~= true) then return end

    local data = ply:LoadData()
    local upgrades = data.kupione_upgradey or {}

    local totalMocPoj = 0
    local totalMocRegen = 0
    local totalHP = 0
    local totalArmor = 0

    for _, upgradePath in ipairs(upgrades) do
        for _, upgrade in ipairs(MX_LSCS.Moce) do
            if upgrade.sciezka == upgradePath then
                if string.find(upgrade.sciezka, "mocpoj") then

                    totalMocPoj = totalMocPoj + (upgrade.ilosc or 0)
                elseif string.find(upgrade.sciezka, "mocregen") then

                    totalMocRegen = totalMocRegen + (upgrade.ilosc or 0)

                elseif string.find(upgrade.sciezka, "hp") then
                    
                    totalHP = totalHP + (upgrade.ilosc or 0)

                elseif string.find(upgrade.sciezka, "armor") then

                    totalArmor = totalArmor + (upgrade.ilosc or 0)
                end
            end
        end
    end
    timer.Simple(0.5,function()
        ply:lscsSetMaxForce(ply:lscsGetMaxForce() + totalMocPoj) 
        ply:lscsSetForceRegenAmount(ply:lscsGetForceRegenAmount() + totalMocRegen) 
    
        ply:SetMaxHealth(ply:GetMaxHealth() + totalHP) 
        ply:SetHealth(ply:GetMaxHealth())
    
        ply:SetMaxArmor(ply:GetMaxArmor() + totalArmor)
        ply:SetArmor(ply:GetMaxArmor())

        timer.Simple(0.5,function() 
            ply:ChatPrint("max force: ".. ply:lscsGetMaxForce() .. " max regen: ".. ply:lscsGetForceRegenAmount() .. " health: ".. ply:GetMaxHealth() .. " armor: ".. ply:GetMaxArmor())
        
        end)
    end)

end)*/



hook.Add("PlayerSpawn", "MX_LSCS_AssignUpgrades", function(ply)
    if not IsValid(ply) then return end

    local teamData = RPExtraTeams[ply:Team()]
    if not teamData or (teamData.category ~= MX_CatJedi and teamData.jedi ~= true) then 
        return 
    end

    local data = ply:LoadData()
    local upgrades = data.kupione_upgradey or {}

    local totalMocPoj = 0
    local totalMocRegen = 0
    local totalHP = 0
    local totalArmor = 0
    --ply:ChatPrint("heheh puuu")
    for _, upgradePath in ipairs(upgrades) do
        for _, upgrade in ipairs(MX_LSCS.Moce) do
            if upgrade.sciezka == upgradePath then
                if string.find(upgrade.sciezka, "mocpoj") then
                    --ply:ChatPrint("moc poj ")
                    totalMocPoj = totalMocPoj + (upgrade.ilosc or 0)
                elseif string.find(upgrade.sciezka, "mocregen") then
                    --ply:ChatPrint("moc reg ")
                    totalMocRegen = totalMocRegen + (upgrade.ilosc or 0)

                elseif string.find(upgrade.sciezka, "hp") then
                    
                    totalHP = totalHP + (upgrade.ilosc or 0)
                    --ply:ChatPrint("hp ".. totalHP)
                elseif string.find(upgrade.sciezka, "armor") then
                    --ply:ChatPrint("armor ")
                    totalArmor = totalArmor + (upgrade.ilosc or 0)
                end
            end
        end
    end
    timer.Simple(0.5,function()
        ply:lscsSetMaxForce(ply:lscsGetMaxForce() + totalMocPoj) 
        ply:lscsSetForceRegenAmount(ply:lscsGetForceRegenAmount() + totalMocRegen) 
    
        ply:SetMaxHealth(ply:GetMaxHealth() + totalHP) 
        ply:SetHealth(ply:GetMaxHealth())
    
        ply:SetMaxArmor(ply:GetMaxArmor() + totalArmor)
        ply:SetArmor(ply:GetMaxArmor())

        --timer.Simple(0.5,function() 
        --    ply:ChatPrint("max force: ".. ply:lscsGetMaxForce() .. " max regen: ".. ply:lscsGetForceRegenAmount() .. " health: ".. ply:GetMaxHealth() .. " armor: ".. ply:GetMaxArmor())
        
        --end)
    end)

end)


concommand.Add("drzewko_dodajpunkty", function(ply, cmd, args)
    if not ply:IsSuperAdmin() then
        ply:ChatPrint("Tylko SuperAdmini mog uywa tej komendy!")
        return
    end

    local targetName = args[1]
    local pointsToAdd = tonumber(args[2]) 

    if not targetName or not pointsToAdd then
        ply:ChatPrint("Uycie: drzewko_dodajpunkty <nazwa_gracza/SteamID> <liczba_punktw>")
        return
    end

    for _, target in ipairs(player.GetAll()) do
        if target:Nick() == targetName or target:SteamID() == targetName then
            local data = target:LoadData()
            data.jedi_punkty = (data.jedi_punkty or 0) + pointsToAdd
            target:SetNWInt("jedi_punkty", data.jedi_punkty)
            target:SaveData(data)
            

            ply:ChatPrint("Dodano " .. pointsToAdd .. " punktw graczowi " .. target:Nick())
            target:ChatPrint("SuperAdmin doda ci " .. pointsToAdd .. " punktw.")
            return
        end
    end

    ply:ChatPrint("Nie znaleziono gracza o podanej nazwie lub SteamID.")
end)


--PATH lua/arc9/common/sh_0_convar.lua:
local conVars = {
    {
        name = "cruelty_reload",
        default = "0",
        client = true
    },
    {
        name = "cruelty_reload_april_fools",
        default = "0",
        client = true
    },
    {
        name = "allflash",
        default = "0",
        client = true
    },
    {
        name = "truenames",
        default = "2",
        client = true,
        min = 0,
        max = 2,
    },
    {
        name = "truenames_default",
        default = "0",
        replicated = true,
        min = 0,
        max = 1,
    },
    {
        name = "truenames_enforced",
        default = "0",
        replicated = true,
        min = 0,
        max = 1,
    },
    {
        name = "cross_enable",
        default = "1",
        client = true
    },
    {
        name = "cross_r",
        default = "255",
        client = true
    },
    {
        name = "cross_g",
        default = "255",
        client = true
    },
    {
        name = "cross_b",
        default = "255",
        client = true
    },
    {
        name = "cross_a",
        default = "150",
        client = true
    },
    {
        name = "cross_size_mult",
        default = "1",
        client = true
    },
    {
        name = "cross_size_dot",
        default = "1",
        client = true
    },
    {
        name = "cross_size_prong",
        default = "1",
        client = true
    },
    {
        name = "reflex_r",
        default = "255",
        client = true
    },
    {
        name = "reflex_g",
        default = "0",
        client = true
    },
    {
        name = "reflex_b",
        default = "0",
        client = true
    },
    {
        name = "scope_r",
        default = "255",
        client = true
    },
    {
        name = "scope_g",
        default = "0",
        client = true
    },
    {
        name = "scope_b",
        default = "0",
        client = true
    },
    {
        name = "holiday_month",
        default = "0",
        replicated = true
    },
    {
        name = "holiday_day",
        default = "0",
        replicated = true
    },
    {
        name = "hud_color_r",
        default = "255",
        client = true
    },
    {
        name = "hud_color_g",
        default = "123",
        client = true
    },
    {
        name = "hud_color_b",
        default = "0",
        client = true
    },
    {
        name = "hud_darkmode",
        default = "0",
        client = true
    },
    {
        name = "hud_holiday",
        default = "0",
        client = true
    },
    {
        name = "hud_showunowned",
        default = "1",
        client = true
    },
    {
        name = "language",
        default = "",
        client = true,
    },
    {
        name = "language_id",
        default = -1,
        client = true,
    },
    {
        name = "font",
        default = "",
        client = true,
    },
    {
        name = "font_addsize",
        default = "0",
        client = true,
    },
    {
        name = "hud_scale",
        default = "1",
        client = true,
    },
    {
        name = "hud_deadzonex",
        default = "0",
        client = true,
    },
    {
        name = "autosave",
        default = "1",
        client = true
    },
    {
        name = "fov",
        default = "0",
        client = true
    },
    {
        name = "controller",
        default = "0",
        client = true
    },
    -- {
        -- name = "controller_rumble",
        -- default = "1",
        -- client = true
    -- },
    {
        name = "controller_glyphset",
        default = "",
        client = true
    },
    {
        name = "modifiers",
        default = "",
        replicated = true,
    },
    {
        name = "mod_bodydamagecancel",
        default = "1",
        replicated = true
    },
    {
        name = "atts_nocustomize",
        default = "0",
        replicated = true
    },
    {
        name = "atts_anarchy",
        default = "0",
        replicated = true
    },
    {
        name = "free_atts",
        default = "1",
        replicated = true
    },
    {
        name = "atts_max",
        default = "100",
    },
    {
        name = "atts_lock",
        default = "0",
        replicated = true
    },
    {
        name = "atts_loseondie",
        default = "1",
    },
    {
        name = "atts_generateentities",
        default = "1",
        replicated = true
    },
    {
        name = "npc_equality",
        default = "0",
    },
    {
        name = "npc_atts",
        default = "1",
    },
    {
        name = "npc_autoreplace",
        default = "0"
    },
    {
        name = "npc_blacklist",
        default = ""
    },
    {
        name = "npc_whitelist",
        default = ""
    },
    {
        name = "npc_give_weapons",
        default = "0"
    },
    {
        name = "npc_spread",
        default = "1"
    },
    {
        name = "replace_spawned",
        default = "0"
    },
    {
        name = "mod_penetration",
        default = "1",
        replicated = true
    },
    {
        name = "mod_freeaim",
        default = "0",
        replicated = true
    },
    {
        name = "mod_sway",
        default = "1",
        replicated = true
    },
    {
        name = "never_ready",
        default = "0",
    },
    {
        name = "dev_always_ready",
        default = "0",
    },
    {
        name = "dev_benchgun",
        default = "0",
    },
    {
        name = "dev_greenscreen",
        default = "0",
    },
    {
        name = "dev_benchgun_custom",
        default = "",
    },
    {
        name = "dev_crosshair",
        default = "0",
    },
    {
        name = "center_bipod",
        default = "1",
        client = true,
    },
    {
        name = "center_reload_enable",
        default = "0",
        client = true,
    },
    {
        name = "center_reload",
        default = "0.25",
        client = true,
    },
    {
        name = "breath_hud",
        default = "1",
        client = true,
    },
    {
        name = "breath_pp",
        default = "1",
        client = true,
    },
    {
        name = "breath_sfx",
        default = "1",
        client = true,
    },
    {
        name = "breath_slowmo",
        default = "1",
        replicated = true
    },
    {
        name = "ricochet",
        default = "1",
        replicated = true
    },
    {
        name = "bullet_physics",
        default = "1",
        replicated = true
    },
    {
        name = "bullet_gravity",
        default = "1",
        replicated = true
    },
    {
        name = "bullet_drag",
        default = "1",
        replicated = true
    },
    {
        name = "vm_bobstyle",
        default = "0",
        client = true,
    },
    {
        name = "vm_cambob",
        default = "1",
        client = true,
    },
    {
        name = "vm_cambobwalk",
        default = "0",
        client = true,
    },
    {
        name = "vm_cambobintensity",
        default = "0.75",
        client = true,
    },
    {
        name = "vm_addx",
        default = "0",
        client = true,
    },
    {
        name = "vm_addy",
        default = "0",
        client = true,
    },
    {
        name = "vm_addz",
        default = "0",
        client = true,
    },
    {
        name = "bullet_imaginary",
        default = "1",
        replicated = true
    },
    {
        name = "bullet_lifetime",
        default = "10",
        replicated = true
    },
    {
        name = "cheapscopes",
        default = "0"
    },
    {
        name = "compensate_sens",
        default = "1"
    },
    {
        name = "cust_blur",
        default = "0",
        client = true
    },
    {
        name = "cust_light",
        default = "0",
        client = true
    },
    {
        name = "cust_light_brightness",
        default = "1",
        client = true
    },
    {
        name = "cust_hints",
        default = "1",
        client = true
    },
    {
        name = "cust_exit_reset_sel",
        default = "0",
        client = true
    },
    {
        name = "cust_roll_unlock",
        default = "0",
        client = true
    },
    {
        name = "killfeed_enable",
        default = "1",
        client = true
    },
    {
        name = "killfeed_dynamic",
        default = "1",
        client = true
    },
    {
        name = "killfeed_colour",
        default = "1",
        client = true
    },
    {
        name = "hud_always",
        default = "0",
        client = true,
    },
    {
        name = "hud_compact",
        default = "0",
        client = true,
    },
    {
        name = "hud_arc9",
        default = "1",
        client = true,
    },
    {
        name = "hud_force_disable",
        default = "0",
        replicated = true,
    },
    {
        name = "hud_keephints",
        default = "0",
        client = true
    },
    {
        name = "hud_nohints",
        default = "0",
        client = true
    },
    {
        name = "infinite_ammo",
        default = "0",
        replicated = true
    },
    {
        name = "tpik",
        default = "1",
        client = true
    },
    {
        name = "tpik_others",
        default = "1",
        client = true
    },
    {
        name = "tpik_framerate",
        default = "60",
        client = true
    },
    {
        name = "autoreload",
        default = "0",
        client = true
    },
    {
        name = "toggleads",
        default = "0",
        client = true,
        userinfo = true
    },
    {
        name = "crosshair_force",
        default = "0",
        replicated = true
    },
    {
        name = "crosshair_static",
        default = "0",
        replicated = false,
        client = true
    },
    {
        name = "crosshair_target",
        default = "0",
        client = true
    },
    {
        name = "thirdperson",
        default = "0",
        client = true
    },
    {
        name = "thirdperson_force",
        default = "0",
        replicated = true
    },
    {
        name = "cam_shoulder",
        default = "1",
        client = true
    },
    {
        name = "dev_irons_x",
        default = "0",
        client = true
    },
    {
        name = "dev_irons_y",
        default = "0",
        client = true
    },
    {
        name = "dev_irons_z",
        default = "0",
        client = true
    },
    {
        name = "dev_irons_pitch",
        default = "0",
        client = true
    },
    {
        name = "dev_irons_yaw",
        default = "0",
        client = true
    },
    {
        name = "dev_irons_roll",
        default = "0",
        client = true
    },
    {
        name = "dev_show_shield",
        default = "0",
        client = true
    },
    {
        name = "fx_rtblur",
        default = "0",
        client = true
    },
    {
        name = "fx_adsblur",
        default = "1",
        client = true
    },
    {
        name = "fx_reloadblur",
        default = "0",
        client = true
    },
    {
        name = "fx_animblur",
        default = "0",
        client = true
    },
    {
        name = "realrecoil",
        default = "1",
    },
    {
        name = "manualbolt",
        default = "0",
        client = true,
        userinfo = true
    },
    {
        name = "autolean",
        default = "1",
        client = true,
    },
    {
        name = "lean",
        default = "1",
        replicated = true
    },
    {
        name = "togglelean",
        default = "0",
        client = true,
        userinfo = true
    },
    {
        name = "togglepeek",
        default = "0",
        client = true,
    },
    {
        name = "togglebreath",
        default = "0",
        client = true,
    },
    {
        name = "eject_fx",
        default = "1",
        client = true
    },
    {
        name = "eject_time",
        default = "0",
        client = true
    },
    {
        name = "never_ready",
        default = "0",
        replicated = true
    },
    {
        name = "muzzle_light",
        default = "1",
        client = true
    },
    {
        name = "muzzle_others",
        default = "1",
        client = true
    },
    {
        name = "mod_damage",
        default = "1",
        replicated = true
    },
    {
        name = "mod_spread",
        default = "1",
        replicated = true
    },
    {
        name = "mod_recoil",
        default = "1",
        replicated = true
    },
    {
        name = "mod_visualrecoil",
        default = "1",
        replicated = true
    },
    {
        name = "mod_adstime",
        default = "1",
        replicated = true
    },
    {
        name = "mod_sprinttime",
        default = "1",
        replicated = true
    },
    {
        name = "mod_damagerand",
        default = "1",
        replicated = true
    },
    {
        name = "mod_muzzlevelocity",
        default = "1",
        replicated = true
    },
    {
        name = "mod_rpm",
        default = "1",
        replicated = true
    },
    {
        name = "mod_headshotdamage",
        default = "1",
        replicated = true
    },
    {
        name = "mod_malfunction",
        default = "1",
        replicated = true
    },
    {
        name = "cust_tips",
        default = "1",
        client = true
    },
    {
        name = "precache_sounds_onfirsttake",
        default = "1",
        replicated = true
    },
    {
        name = "precache_allsounds_onstartup",
        default = "0",
        replicated = true
    },
    {
        name = "precache_attsmodels_onfirsttake",
        default = "0",
        replicated = true
    },
    {
        name = "precache_attsmodels_onstartup",
        default = "0",
        replicated = true
    },
    {
        name = "precache_wepmodels_onfirsttake",
        default = "0",
        replicated = true
    },
    {
        name = "precache_wepmodels_onstartup",
        default = "0",
        replicated = true
    },
    {
        name = "togglepeek_reset",
        default = "0",
        client = true,
    },
    {
        name = "recoilshake",
        default = "1",
    },
    {
        name = "equipment_generate_ammo",
        default = "1",
        replicated = true
    },
    {
        name = "mult_defaultammo",
        default = "2",
        replicated = true
    },
    {
        name = "mult_sens",
        default = "1",
        client = true
    },
    {
        name = "aimassist",
        default = "0",
        replicated = true,
    },
    {
        name = "aimassist_head",
        default = "0",
        replicated = true,
    },
    {
        name = "aimassist_cone",
        default = "5",
        replicated = true,
    },
    {
        name = "aimassist_intensity",
        default = "1",
        replicated = true,
    },
    -- {
        -- name = "aimassist_lockon",
        -- default = "0",
        -- replicated = true,
    -- },
    -- {
        -- name = "aimassist_lockon_cl",
        -- default = "1",
        -- client = true,
    -- },
    {
        name = "aimassist_cl",
        default = "1",
        client = true,
    },
    {
        name = "crosshair_peek",
        default = "1",
        client = true
    },
    {
        name = "aimassist_multsens",
        default = "0.75",
        client = true,
    },
    {
        name = "glyph_family_hud",
        default = "light",
        client = true,
    },
    {
        name = "glyph_family_cust",
        default = "light",
        client = true,
    },
    -- {
        -- name = "glyph_type",
        -- default = "xbox",
        -- client = true,
    -- },
    {
        name = "fx_rtvm",
        default = "0",
        client = true,
    },
    {
        name = "dev_show_affectors",
        default = "0",
    },
    {
        name = "dtap_sights",
        default = "0",
        client = true,
    },
    {
        name = "center_jam",
        default = "1",
        client = true,
    },
    {
        name = "center_firemode",
        default = "0",
        client = true,
    },
    {
        name = "center_firemode_time",
        default = "0.75",
        client = true,
    },
    {
        name = "imperial",
        default = "0",
        client = true,
    },
    {
        name = "center_overheat",
        default = "0",
        client = true,
    },
    {
        name = "center_overheat_dark",
        default = "0",
        client = true,
    },
}
ARC9.ConVarData = {}

local prefix = "arc9_"

local torevertlist_cl = {}
local torevertlist_sv = {}

for _, var in pairs(conVars) do
    local convar_name = prefix .. var.name

    if var.client and CLIENT then
        table.insert(torevertlist_cl, convar_name)
        CreateClientConVar(convar_name, var.default, true, var.userinfo)
    else
        local flags = FCVAR_ARCHIVE
        if var.replicated then
            flags = flags + FCVAR_REPLICATED
        end
        if var.userinfo then
            flags = flags + FCVAR_USERINFO
        end
        table.insert(torevertlist_sv, convar_name)
        CreateConVar(convar_name, var.default, flags, var.helptext, var.min, var.max)
    end

    ARC9.ConVarData[convar_name] = var
end

if CLIENT then
    concommand.Add("arc9_settings_reset_client", function()
        for _, var in pairs(torevertlist_cl) do
            RunConsoleCommand(var, GetConVar(var):GetDefault()) -- :Revert() wont work!!!!!!!!! ghhh
        end
    end, nil, "Reset all client ARC9 settings.")
end

concommand.Add("arc9_settings_reset_server", function()
    for _, var in pairs(torevertlist_sv) do
        GetConVar(var):Revert()
    end
end, nil, "Reset all server ARC9 settings.")

function ARC9.ShouldNetworkConVar(ply, cvar)
    if !ARC9.ConVarData[cvar] then return end
    if game.SinglePlayer() or ply:IsListenServerHost() then return false end

    if ARC9.ConVarData[cvar].client then return false end

    return true
end

if SERVER then
    util.AddNetworkString("ARC9_InvalidateAll")
    util.AddNetworkString("ARC9_InvalidateAll_ToClients")
    util.AddNetworkString("arc9_setconvar")

    net.Receive("arc9_setconvar", function(len, ply)
        if !ply:IsAdmin() then return end
        local cvar = net.ReadString()
        if !ARC9.ShouldNetworkConVar(ply, cvar) then return end
        local val = net.ReadString()
        GetConVar(cvar):SetString(val)
        print(ply:GetName() .. " set '" .. cvar .. "' to '" .. val .. "'.")
    end)

    net.Receive("ARC9_InvalidateAll", function(len, ply)
        if ply:IsAdmin() then
            ARC9.InvalidateAll()
            net.Start("ARC9_InvalidateAll_ToClients")
            net.Broadcast()
        end
    end)
else
    net.Receive("ARC9_InvalidateAll_ToClients", function(len, ply)
        ARC9.InvalidateAll()
    end)
end

function ARC9.InvalidateAll()
    for _, ent in ipairs(ents.GetAll()) do
        if IsValid(ent) and ent:IsWeapon() and ent.ARC9 then
            ent:PostModify(true)
        end
    end
end

if CLIENT then

    local debounce = {}
    function ARC9.NetworkConVar(cvar, value)
        if !ARC9.ShouldNetworkConVar(LocalPlayer(), cvar) then return end
        if !LocalPlayer():IsAdmin() then return end
        if (debounce[cvar] or 0) > CurTime() then return end

        net.Start("arc9_setconvar")
            net.WriteString(cvar)
            net.WriteString(value)
        net.SendToServer()
        debounce[cvar] = CurTime() + 0.1
    end


local function menu_arc9_settings(panel)
    local butt = vgui.Create( "DButton", panel )

    butt:SetText("Open settings panel!")
    butt:SetPos(20, 50)
    butt:SetSize(300, 50)
    function butt:DoClick()
        ARC9_OpenSettings()
    end
    panel:ControlHelp( "\nAccess the ARC9 settings by pressing this button without having to equip a weapon!" )
end

local function menu_client_controller(panel)
    -- panel:AddControl( "header", { description = "Replace key names with controller glyphs." } )
    panel:CheckBox("Activate Controller Mode", "arc9_controller")
    -- panel:ControlHelp( "Activate controller-focused features in ARC9.\n- Keys are replaced with their bindnames.\n- JUMP and USE are used as Select and Deselect, respectively." )
    panel:ControlHelp( "Activate a controller-friendly mode for ARC9.\n- JUMP, RELOAD and USE can be used to Select, Deselect and\nRandomly Select attachments.\n\nController glyphs can be customized down below!" )
    -- panel:CheckBox("Controller Rumble w/ SInput", "arc9_controller_rumble")
    -- panel:ControlHelp( "Use Fesiug's SInput to interact with ARC9.\nFound at github.com/Fesiug/gmod-sinput" )
    local listview = vgui.Create("DListView", panel)
    listview:SetSize( 99, 200 )
    panel:AddItem( listview )
    listview:SetMultiSelect( true )
    listview:AddColumn( "Input" )
    listview:AddColumn( "Output" )

    local tex_inp = vgui.Create( "DTextEntry", panel )
    local tex_out = vgui.Create( "DTextEntry", panel )
    panel:ControlHelp( "Glyph to show." )
    -- panel:ControlHelp( "Double-click to copy into text fields" )
    panel:AddItem( tex_inp )
    -- panel:ControlHelp( "Glyph or keyboard icon to be replaced.\nInputs are case-sensitive!" )
    panel:AddItem( tex_out )
    tex_inp:SetPlaceholderText("Write which input the glyph should replace")
    tex_out:SetPlaceholderText("Which glyph should appear, or click on it below")

    local but_add = vgui.Create( "DButton", panel )
    local but_rem = vgui.Create( "DButton", panel )
    local but_upd = vgui.Create( "DButton", panel )
    but_upd:Hide()
    local but_app = vgui.Create( "DButton", panel )
    but_app:Hide()
    panel:AddItem( but_add )
    panel:AddItem( but_rem )
    panel:AddItem( but_upd )
    panel:AddItem( but_app )
    but_add:SetText("Add & Apply")
    but_rem:SetText("Remove Selected")
    but_upd:SetText("Restore From Memory")
    but_app:SetText("Apply")

    function listview:DoDoubleClick( lineID, line )
        tex_inp:SetValue( line:GetColumnText( 1 ) )
        tex_out:SetValue( line:GetColumnText( 2 ) )
    end

    function listview:OnRowRightClick( lineID, line )
        local menu = DermaMenu()
        menu:AddOption( "Copy", function() tex_inp:SetValue( line:GetColumnText( 1 ) ) tex_out:SetValue( line:GetColumnText( 2 ) ) end ):SetIcon( "icon16/page_copy.png" )
        menu:AddOption( "Remove", function() listview:RemoveLine( lineID ) but_app:DoClick() end ):SetIcon( "icon16/cross.png" )
        menu:Open()
    end

    function but_add:DoClick()
        local inp, out = string.Trim(tex_inp:GetValue()), string.Trim(tex_out:GetValue())
        if inp == "" then return end
        if out == "" then return end
        local worked = false
        for index, line in ipairs( listview:GetLines() ) do
            if line:GetColumnText( 1 ) == inp then
                line:SetColumnText( 2, out )
                worked = true
                break
            end
        end
        if !worked then
            listview:AddLine( inp, out )
        end
        but_app:DoClick()
    end

    function but_rem:DoClick()
        for i, v in pairs(listview:GetSelected()) do
            listview:RemoveLine( v:GetID() )
        end
        but_app:DoClick()
    end

    function but_upd:DoClick()
        listview:Clear()

        local config = GetConVar("arc9_controller_glyphset"):GetString()
        config = string.Split( config, "\\n" )
        for i, v in ipairs(config) do
            local swig = string.Split( v, "\\t" )
            if swig[1] == "" then continue end
            listview:AddLine( swig[1], swig[2] )
        end
    end

    function but_app:DoClick()
        local toapply = ""
        local order = 1
        for k, line in pairs( listview:GetLines() ) do
            if order != 1 then toapply = toapply .. "\\n" end
            toapply = toapply .. line:GetValue( 1 ) .. "\\t" .. line:GetValue( 2 )
            order = order + 1
        end
        RunConsoleCommand("arc9_controller_glyphset", toapply)
    end


    local matselect_filter = vgui.Create( "DComboBox", panel )
    panel:AddItem( matselect_filter )
    matselect_filter:AddChoice( "! Display All !", "" )
    matselect_filter:AddChoice( "\"Shared\"", "shared_" )
    matselect_filter:AddChoice( "PlayStation", "ps" )
    matselect_filter:AddChoice( "Xbox", "xbox" )
    matselect_filter:AddChoice( "Steam Controller", "sc_" )
    matselect_filter:AddChoice( "Steam Deck", "sd_" )
    matselect_filter:AddChoice( "Nintendo Switch", "switchpro_" )
	
    -- matselect_filter:AddChoice( "Refresh", "" )
    -- matselect_filter:AddChoice( "! Mouse !", "mouse" )
    -- matselect_filter:AddChoice( "Amazon Luna", "AmazonLuna/" )
    -- matselect_filter:AddChoice( "Ouya", "Ouya/" )
    -- matselect_filter:AddChoice( "PlayStation 3", "PS3/" )
    -- matselect_filter:AddChoice( "PlayStation 4", "PS4/" )
    -- matselect_filter:AddChoice( "PlayStation 5", "PS5/" )
    -- matselect_filter:AddChoice( "PlayStation Vita", "PSVita/" )
    -- matselect_filter:AddChoice( "Google Stadia", "GoogleStadia/" )
    -- matselect_filter:AddChoice( "Steam Controller", "Steam/" )
    -- matselect_filter:AddChoice( "Steam Deck", "SteamDeck/" )
    -- matselect_filter:AddChoice( "Nintendo Switch", "Switch/" )
    -- matselect_filter:AddChoice( "Nintendo Wii U", "WiiU/" )
    -- matselect_filter:AddChoice( "Xbox 360", "Xbox360/" )
    -- matselect_filter:AddChoice( "Xbox One", "XboxOne/" )
    -- matselect_filter:AddChoice( "Xbox Series X|S", "XboxSeries/" )
    matselect_filter:SetValue( "Filter by controller type" )

    local matselect = ""
    local function GenerateMatSelect()
        matselect = vgui.Create( "MatSelect", panel )
        Derma_Hook( matselect.List, "Paint", "Paint", "Panel" )
            function matselect:AddMaterial( label, value )
                local Mat = vgui.Create( "DImageButton", self )
                Mat:SetOnViewMaterial( value, "models/wireframe" )
                Mat.AutoSize = false
                Mat.Value = value
                Mat:SetSize( self.ItemWidth, self.ItemHeight )
                Mat:SetTooltip( label )

                -- Run a console command when the Icon is clicked
                Mat.DoClick = function( button )
                    self.OutputPanel:SetValue( label )
                end

                -- Add the Icon us
                self.List:AddItem( Mat )
                table.insert( self.Controls, Mat )

                self:InvalidateLayout()

            end
        panel:AddItem( matselect )

        for k, v in SortedPairs( ARC9.CTRL_Exists ) do
            local sel, seldata = matselect_filter:GetSelected()
            if string.find( k, seldata or "" ) then
                matselect:AddMaterial( k, "arc9/" .. ARC9.GlyphFamilyHUD() .. k .. ".png" )
            end
        end

        matselect:SetAutoHeight( true )
        matselect:SetItemWidth( 0.1875 )
        matselect:SetItemHeight( 0.1875 )

        matselect.InputPanel = tex_inp
        matselect.OutputPanel = tex_out
    end
    GenerateMatSelect()
    but_upd:DoClick()

    function matselect_filter:OnSelect()
        matselect:Remove()
        GenerateMatSelect()
    end

end

c1 = {
    ["DamageMax"] = true,
    ["DamageMin"] = true,
    ["DamageRand"] = true,
    ["RangeMin"] = true,
    ["RangeMax"] = true,
    ["Distance"] = true,
    ["Num"] = true,
    ["Penetration"] = true,
    ["RicochetAngleMax"] = true,
    ["RicochetChance"] = true,
    ["ArmorPiercing"] = true,
    ["EntityMuzzleVelocity"] = true,
    ["PhysBulletMuzzleVelocity"] = true,
    ["PhysBulletDrag"] = true,
    ["PhysBulletGravity"] = true,
    ["ChamberSize"] = true,
    ["ClipSize"] = true,
    ["SupplyLimit"] = true,
    ["SecondarySupplyLimit"] = true,
    ["AmmoPerShot"] = true,
    ["ManualActionChamber"] = true,
    ["TriggerDelay"] = true,
    ["RPM"] = true,
    ["PushBackForce"] = true,
    ["PostBurstDelay"] = true,
    ["Recoil"] = true,
    ["RecoilPatternDrift"] = true,
    ["RecoilUp"] = true,
    ["RecoilSide"] = true,
    ["RecoilRandomUp"] = true,
    ["RecoilRandomSide"] = true,
    ["RecoilDissipationRate"] = true,
    ["RecoilResetTime"] = true,
    ["RecoilAutoControl"] = true,
    ["RecoilKick"] = true,
    ["Spread"] = true,
    ["PelletSpread"] = true,
    ["FreeAimRadius"] = true,
    ["Sway"] = true,
    ["AimDownSightsTime"] = true,
    ["SprintToFireTime"] = true,
    ["ReloadTime"] = true,
    ["DeployTime"] = true,
    ["CycleTime"] = true,
    ["FixTime"] = true,
    ["OverheatTime"] = true,
    ["Speed"] = true,
    ["BashDamage"] = true,
    ["BashRange"] = true,
    ["BashLungeRange"] = true,
    ["HeatPerShot"] = true,
    ["HeatCapacity"] = true,
    ["HeatDissipation"] = true,
    ["ShootVolume"] = true,
    ["AlwaysPhysBullet"] = true,
    ["NeverPhysBullet"] = true,
    ["InfiniteAmmo"] = true,
    ["BottomlessClip"] = true,
    ["ShotgunReload"] = true,
    ["HybridReload"] = true,
    ["ManualAction"] = true,
    ["CanFireUnderwater"] = true,
    ["AutoReload"] = true,
    ["AutoBurst"] = true,
    ["RunawayBurst"] = true,
    ["ShootWhileSprint"] = true,
    ["Bash"] = true,
    ["Overheat"] = true,
    ["Malfunction"] = true,
    ["MalfunctionMeanShotsToFail"] = true,
    ["MalfunctionWait"] = true,
    ["Bipod"] = true,
    ["NoFlash"] = true,
    ["BulletGuidance"] = true,
    ["BulletGuidanceAmount"] = true,
    ["ExplosionDamage"] = true,
    ["ExplosionRadius"] = true,
    ["CanLean"] = true,
    ["HoldBreathTime"] = true,
    ["RestoreBreathTime"] = true,
    ["SlamFire"] = true,
    ["TriggerDelay"] = true,
    ["TriggerDelayTime"] = true,
    ["TriggerDelayRepeat"] = true,
    ["HeadshotDamage"] = true,
    ["ChestDamage"] = true,
    ["StomachDamage"] = true,
    ["ArmDamage"] = true,
    ["LegDamage"] = true,
    ["VisualRecoil"] = true,
    ["VisualRecoilUp"] = true,
    ["VisualRecoilSide"] = true,
    ["VisualRecoilRoll"] = true,
    ["VisualRecoilPunch"] = true,
    ["BreathHoldTime"] = true,
    ["BashSpeed"] = true,
}

c2 = {
    [""] = true,
    ["Mult"] = true,
    ["Add"] = true,
    ["Override"] = true,
}

c3 = {
    [""] = true,
    ["True"] = true,
    ["Silenced"] = true,
    ["UBGL"] = true,
    ["MidAir"] = true,
    ["Crouch"] = true,
    ["FirstShot"] = true,
    ["Empty"] = true,
    ["EvenShot"] = true,
    ["OddShot"] = true,
    ["EvenReload"] = true,
    ["OddReload"] = true,
    ["Sights"] = true,
    ["HipFire"] = true,
    ["Shooting"] = true,
    ["Recoil"] = true,
    ["Move"] = true,
}

local function menu_server_modifiers(panel)
    panel:AddControl( "header", { description = "Add ANY modifier with ANY special conditions." } )
    local listview = vgui.Create("DListView", panel)
    listview:SetSize( 99, 200 )
    panel:AddItem( listview )
    listview:SetMultiSelect( true )
    listview:AddColumn( "Stat" )
    listview:AddColumn( "Modifier" )

    local tex_inp = vgui.Create( "DTextEntry", panel )
    local tex_out = vgui.Create( "DTextEntry", panel )
    panel:ControlHelp( "Double-click to copy into text fields" )
    panel:AddItem( tex_inp )
    panel:AddItem( tex_out )
    tex_inp:SetPlaceholderText("Use the first list to select a stat to modify")
    tex_out:SetPlaceholderText("Enter a number value, 'true', or 'false'.")

    local com_1 = vgui.Create( "DComboBox", panel )
    local com_2 = vgui.Create( "DComboBox", panel )
    local com_3 = vgui.Create( "DComboBox", panel )
    panel:AddItem( com_1 )
    panel:ControlHelp( "Stat to change." )
    panel:AddItem( com_2 )
    panel:ControlHelp( "Modification type. Some stats don't have these." )
    panel:AddItem( com_3 )
    panel:ControlHelp( "Special condition, like if you're crouching." )

    function listview:DoDoubleClick( lineID, line )
        tex_inp:SetValue( line:GetColumnText( 1 ) )
        tex_out:SetValue( line:GetColumnText( 2 ) )
    end

    for i, v in pairs(c1) do
        com_1:AddChoice( i )
    end
    for i, v in pairs(c2) do
        com_2:AddChoice( i )
    end
    for i, v in pairs(c3) do
        com_3:AddChoice( i )
    end

    com_1.OnSelect = function( self, index, value )
        tex_inp:SetValue( ( com_1:GetValue() or "" ) .. ( com_2:GetValue() or "" ) .. ( com_3:GetValue() or "" ) )
    end

    com_2.OnSelect = function( self, index, value )
        tex_inp:SetValue( ( com_1:GetValue() or "" ) .. ( com_2:GetValue() or "" ) .. ( com_3:GetValue() or "" ) )
    end

    com_3.OnSelect = function( self, index, value )
        tex_inp:SetValue( ( com_1:GetValue() or "" ) .. ( com_2:GetValue() or "" ) .. ( com_3:GetValue() or "" ) )
    end

    local but_add = vgui.Create( "DButton", panel )
    local but_rem = vgui.Create( "DButton", panel )
    local but_upd = vgui.Create( "DButton", panel )
    but_upd:Hide()
    local but_app = vgui.Create( "DButton", panel )
    but_app:Hide()
    panel:AddItem( but_add )
    panel:AddItem( but_rem )
    panel:AddItem( but_upd )
    panel:AddItem( but_app )
    but_add:SetText("Add & Apply")
    but_rem:SetText("Remove Selected")
    but_upd:SetText("Restore From Memory")
    but_app:SetText("Apply")

    panel:ControlHelp( "Examples:" )
    panel:ControlHelp( " - \"Overheat\" \"true\" to disable overheating." )
    panel:ControlHelp( " - \"BottomlessClip\" \"true\" to enable Bottomless Clip." )
    panel:ControlHelp( " - \"RecoilMultCrouch\" \"0.1\" to reduce recoil to 10% when crouching." )
    panel:ControlHelp( " - \"RPMMultOddShot\" \"0.5\" to make every other shot 600RPM." )

    function listview:OnRowRightClick( lineID, line )
        local menu = DermaMenu()
        menu:AddOption( "Copy", function() tex_inp:SetValue( line:GetColumnText( 1 ) ) tex_out:SetValue( line:GetColumnText( 2 ) ) end ):SetIcon( "icon16/page_copy.png" )
        menu:AddOption( "Remove", function() listview:RemoveLine( lineID ) but_app:DoClick() end ):SetIcon( "icon16/cross.png" )
        menu:Open()
    end

    function but_add:DoClick()
        local inp, out = string.Trim(tex_inp:GetValue()), string.Trim(tex_out:GetValue())
        if inp == "" then return end
        if out == "" then return end
        local worked = false
        for index, line in ipairs( listview:GetLines() ) do
            if line:GetColumnText( 1 ) == inp then
                line:SetColumnText( 2, out )
                worked = true
                break
            end
        end
        if !worked then
            listview:AddLine( inp, out )
        end
        but_app:DoClick()
    end

    function but_rem:DoClick()
        for i, v in pairs(listview:GetSelected()) do
            listview:RemoveLine( v:GetID() )
        end
        but_app:DoClick()
    end

    function but_upd:DoClick()
        listview:Clear()

        local config = GetConVar("arc9_modifiers"):GetString()
        config = string.Split( config, "\\n" )
        for i, v in ipairs(config) do
            local swig = string.Split( v, "\\t" )
            if swig[1] == "" then continue end
            listview:AddLine( swig[1], swig[2] )
        end
    end
    but_upd:DoClick()

    function but_app:DoClick()
        local toapply = ""
        local order = 1
        for k, line in pairs( listview:GetLines() ) do
            if order != 1 then toapply = toapply .. "\\n" end
            toapply = toapply .. line:GetValue( 1 ) .. "\\t" .. line:GetValue( 2 )
            order = order + 1
        end
        RunConsoleCommand("arc9_modifiers", toapply)
        RunConsoleCommand("arc9_modifiers_invalidateall")
    end
end

concommand.Add( "arc9_modifiers_invalidateall", function( ply, cmd, args )
    if IsValid(ply) and ply:IsAdmin() then
        net.Start("ARC9_InvalidateAll") net.SendToServer()
    end
end )

local clientmenus_ti = {
    {
        text = "ARC9 Settings", func = menu_arc9_settings
    },
    -- {
    --     text = "Client", func = menu_client_ti
    -- },
    -- {
    --     text = "Client - Customization", func = menu_client_customization
    -- },
    {
        text = "Controller Mode", func = menu_client_controller
    },
    -- {
    --     text = "Client - Crosshair", func = menu_client_crosshair
    -- },
    -- {
    --     text = "Client - Optics", func = menu_client_optics
    -- },
    -- {
    --     text = "Server", func = menu_server_ti
    -- },
    -- {
    --     text = "Server - Attachments", func = menu_server_attachments
    -- },
    -- {
    --     text = "Server - Ballistics", func = menu_server_ballistics
    -- },
    {
        text = "Super Modifiers", func = menu_server_modifiers
    },
}

hook.Add("PopulateToolMenu", "ARC9_MenuOptions", function()
    for smenu, data in pairs(clientmenus_ti) do
        spawnmenu.AddToolMenuOption("Options", "ARC9", "ARC9_" .. tostring(smenu), data.text, "", "", data.func)
    end
end)

end
--PATH lua/arc9/common/sh_0_i18n.lua:
return gluapack()()
--PATH lua/arc9/common/localization/base_en.lua:
return gluapack()()
--PATH lua/arc9/common/localization/base_de.lua:
return gluapack()()
--PATH lua/arc9/common/localization/content_base_de.lua:
return gluapack()()
--PATH lua/arc9/common/localization/content_base_es-es.lua:
L = {}

//////// Folders
L["folder.arc9"] = "ARC9"
L["folder.arc9.community"] = "Community"

L["attachment.sticker"] = "Sticker"

//////// Flat Camo
L["camo_arc9_base_flat_od.printname"] = "Verde Oliva"
L["camo_arc9_base_flat_od.compactname"] = "VO"
L["camo_arc9_base_flat_od.description"] = "Camuflaje Verde Oliva estndar."

L["camo_arc9_base_flat_deserttan.printname"] = "Bronceado Desrtico"
L["camo_arc9_base_flat_deserttan.compactname"] = "Bronceado"
L["camo_arc9_base_flat_deserttan.description"] = "Camuflaje Bronceado Desrtico estndar."

L["camo_arc9_base_flat_arctic.printname"] = "Blanco rtico"
L["camo_arc9_base_flat_arctic.compactname"] = "rtico"
L["camo_arc9_base_flat_arctic.description"] = "Camuflaje Blanco rtico estndar."

L["camo_arc9_base_flat_black.printname"] = "Negro de Fbrica"
L["camo_arc9_base_flat_black.compactname"] = "Negro"
L["camo_arc9_base_flat_black.description"] = "Negro estndar de fbrica."

L["camo_arc9_base_flat_urbangray.printname"] = "Gris Urbano"
L["camo_arc9_base_flat_urbangray.compactname"] = "Urbano"
L["camo_arc9_base_flat_urbangray.description"] = "Camuflaje Gris Urbano estndar."

L["camo_arc9_base_flat_forestgreen.printname"] = "Verde Bosque"
L["camo_arc9_base_flat_forestgreen.compactname"] = "Bosque"
L["camo_arc9_base_flat_forestgreen.description"] = "Camuflaje Verde Bosque estndar."

L["camo_arc9_base_flat_navy.printname"] = "Azul Marino"
L["camo_arc9_base_flat_navy.compactname"] = "Marino"
L["camo_arc9_base_flat_navy.description"] = "Color Azul Marino estndar."

L["camo_arc9_base_flat_mountbattenpink.printname"] = "Rosa Mountbatten"
L["camo_arc9_base_flat_mountbattenpink.compactname"] = "RM"
L["camo_arc9_base_flat_mountbattenpink.description"] = "Camuflaje rosa Mountbatten estndar.\nSorprendentemente eficaz en condiciones desrticas."

L["camo_arc9_base_flat_fde.printname"] = "Tierra Oscura Plana"
L["camo_arc9_base_flat_fde.compactname"] = "TOP"
L["camo_arc9_base_flat_fde.description"] = "Camuflaje estndar Tierra Oscura Plana."

//////// Flat Colour
L["camo_arc9_base_flat_red.printname"] = "Rojo"
L["camo_arc9_base_flat_red.compactname"] = "Rojo"
L["camo_arc9_base_flat_red.description"] = "Color rojo bsico."

L["camo_arc9_base_flat_orange.printname"] = "Naranja"
L["camo_arc9_base_flat_orange.compactname"] = "Naranja"
L["camo_arc9_base_flat_orange.description"] = "Color naranja bsico."

L["camo_arc9_base_flat_yellow.printname"] = "Amarillo"
L["camo_arc9_base_flat_yellow.compactname"] = "Amarillo"
L["camo_arc9_base_flat_yellow.description"] = "Color amarillo bsico."

L["camo_arc9_base_flat_green.printname"] = "Verde"
L["camo_arc9_base_flat_green.compactname"] = "Verde"
L["camo_arc9_base_flat_green.description"] = "Color verde bsico."

L["camo_arc9_base_flat_blue.printname"] = "Azul"
L["camo_arc9_base_flat_blue.compactname"] = "Azul"
L["camo_arc9_base_flat_blue.description"] = "Color azul bsico."

L["camo_arc9_base_flat_purple.printname"] = "Morado"
L["camo_arc9_base_flat_purple.compactname"] = "Morado"
L["camo_arc9_base_flat_purple.description"] = "Color morado bsico."

L["camo_arc9_base_flat_pink.printname"] = "Rosa"
L["camo_arc9_base_flat_pink.compactname"] = "Rosa"
L["camo_arc9_base_flat_pink.description"] = "Color rosa brillante abrasador."

L["camo_arc9_base_flat_arc9orange.printname"] = "Naranja ARC9"
L["camo_arc9_base_flat_arc9orange.compactname"] = "Naranja ARC9"
L["camo_arc9_base_flat_arc9orange.description"] = "El tono de naranja perfecto para esa bonita pegatina con el logotipo ARC9."

//////// Charms
L["charm_gs_killcounter.printname"] = "Contador de muertes"
L["charm_gs_killcounter.compactname"] = "KILL"
L["charm_gs_killcounter.description"] = "Dispositivo para seguir las estadsticas de muerte de tu arma."

L["charm_gs_clock.printname"] = "Reloj bsico"
L["charm_gs_clock.compactname"] = "RELOJ"
L["charm_gs_clock.description"] = "Device that displays the real-world time."

L["charm_gs_sticker.printname"] = "Panel de pegatinas"
L["charm_gs_sticker.compactname"] = "PEGATINA"
L["charm_gs_sticker.description"] = "Dispositivo que permite aplicar una pegatina personalizada en su pantalla."

//////// Stickers, Base
L["sticker_spray.printname"] = "Spray de Jugador"
L["sticker_spray.compactname"] = "Spray"
L["sticker_spray.description"] = [[Tu propio spray como pegatina!
Solo podrs ver los tuyos y no los de otros jugadores.

Pegatina incluida en la base ARC9.]]

L["sticker_arc9.printname"] = "Logotipo ARC9 (Baja Vis.)"
L["sticker_arc9.compactname"] = "ARC9"
L["sticker_arc9.description"] = [[Versin oscura del logotipo de ARC9.
Diseo de The Villain.

Pegatina incluida en la base ARC9.]]

L["sticker_arc9_lowvis.printname"] = "Logotipo ARC9"
L["sticker_arc9_lowvis.compactname"] = "ARC9"
L["sticker_arc9_lowvis.description"] = [[Por ti.
Diseo de The Villain.

Pegatina incluida en la base ARC9.]]

L["sticker_a9k.printname"] = "BASE DE ARMAS ARCTICTHRON 9.000"
L["sticker_a9k.compactname"] = "A9K"
L["sticker_a9k.description"] = [[esto es lo que "arc9" significa en realidad

Pegatina incluida en la base ARC9.]]

L["sticker_a9cylo.printname"] = "ARC9 Logotipo conceptual de CyloWalker"
L["sticker_a9cylo.compactname"] = "A9 Cylo"
L["sticker_a9cylo.description"] = [[Uno de los primeros conceptos para el logotipo/icono de ARC9 por CyloWalker (es genial!)

Pegatina incluida en la base ARC9.]]

L["sticker_sus9.printname"] = "Sus 9"
L["sticker_sus9.compactname"] = "Sus 9"
L["sticker_sus9.description"] = [[El impostor podra estar en cualquier lugar entre nosotros...
Diseo de Darsu.

Pegatina incluida en la base ARC9.]]

//////// Stickers, Com. Wave 1
L["sticker_alien_lean.printname"] = "Legalizar Magro Alien"
L["sticker_alien_lean.compactname"] = "Magro Alien"
L["sticker_alien_lean.description"] = [[Baja a Agartha con los chicos blancos para tomar una taza de magro aliengena y... otras cosas.
Diseo de Opt1ca.

Pegatina incluida en la base ARC9.]]

L["sticker_tomatocat.printname"] = "Gato Tomate"
L["sticker_tomatocat.compactname"] = "Gato Tomate"
L["sticker_tomatocat.description"] = [[A veces la gente pregunta si los tomates son frutas o verduras... sta puede ser una pregunta ms difcil.
Diseo de Ender2Point0.

Pegatina incluida en la base ARC9.]]

L["sticker_actionbird.printname"] = "Pjaro de accin"
L["sticker_actionbird.compactname"] = "Pjaro de accin"
L["sticker_actionbird.description"] = [[As es como luce Artic en la vida real.
Diseo de CyloWalker.

Pegatina incluida en la base ARC9.]]

L["sticker_warcrimes.printname"] = "Crmenes de guerra"
L["sticker_warcrimes.compactname"] = "Crmenes de guerra"
L["sticker_warcrimes.description"] = [[Ya los ests haciendo, as que por qu no gritarlo bien alto? Quin te lo va a impedir, la ONU?
Diseo de Rimuchii. Realizado con la base de pegatinas Project Sekai.

Pegatina incluida en la base ARC9.]]

L["sticker_sillycat.printname"] = "Gato bobo"
L["sticker_sillycat.compactname"] = "Gato bobo"
L["sticker_sillycat.description"] = [[soygraciososoygraciososoygraciososoygraciososoygraciososoygraciososoygraciososoygracioso
Diseo de Stan_Jacobs.

Pegatina incluida en la base ARC9.]]

L["sticker_muertosskull.printname"] = "Dia De Los Muertos Calavera"
L["sticker_muertosskull.compactname"] = "Los Muertos"
L["sticker_muertosskull.description"] = [["esta deberia ser mi version final creo, a menos que alguien me de sugerencias para cambiarla, el nombre: "Dia de los muertos calavera" la descripcion: no se me ocurre una, algo sobre dia de los muertos calavera mexico bla bla bla"
Diseo de rooneyviz.

Pegatina incluida en la base ARC9.]]

L["sticker_bandaid.printname"] = "Tirita"
L["sticker_bandaid.compactname"] = "Tirita"
L["sticker_bandaid.description"] = [[Pntelo en tu boo-boo y bsalo todo mejor.
Diseo de Itzal.

Pegatina incluida en la base ARC9.]]

L["sticker_peacedove.printname"] = "Paz Mediante Potencia de Fuego Superior"
L["sticker_peacedove.compactname"] = "PMPFS"
L["sticker_peacedove.description"] = [[La paloma trae la paz, pero la pistola la trae gracias a una potencia de fuego superior.
Diseo de Xipil.

Pegatina incluida en la base ARC9.]]

L["sticker_borntomodify.printname"] = "Nacido para Modificar"
L["sticker_borntomodify.compactname"] = "NPM"
L["sticker_borntomodify.description"] = [[Otra mira - otro visor - un lanzagranadas, aqu y all...
Diseo de Duck.

Pegatina incluida en la base ARC9.]]

L["sticker_cad.printname"] = "cad"
L["sticker_cad.compactname"] = "cad"
L["sticker_cad.description"] = [[cad
Diseo de Opt1ca.

Pegatina incluida en la base ARC9.]]

L["sticker_fumo.printname"] = "Fumo"
L["sticker_fumo.compactname"] = "Fumo"
L["sticker_fumo.description"] = [[No me mires as, raifu-kun...
Diseo de Itzal.

Pegatina incluida en la base ARC9.]]

L["sticker_hotlead.printname"] = "Plomo Caliente"
L["sticker_hotlead.compactname"] = "Plomo Caliente"
L["sticker_hotlead.description"] = [[Cuidado! Est caliente!
Diseo de Arqu.

Pegatina incluida en la base ARC9.]]

L["sticker_steamhappy.printname"] = ":steamhappy:"
L["sticker_steamhappy.compactname"] = ":steamhappy:"
L["sticker_steamhappy.description"] = [[Feliz por ello
Diseo de Steam.

Pegatina incluida en la base ARC9.]]

L["sticker_amidstus.printname"] = "Amidstus"
L["sticker_amidstus.compactname"] = "Amidstus"
L["sticker_amidstus.description"] = [[Por qu conformarse con el original cuando se puede tener una imitacin barata?
Diseo de Optica.

Pegatina incluida en la base ARC9.]]

L["sticker_arcglory.printname"] = "Gloria!"
L["sticker_arcglory.compactname"] = "Gloria!"
L["sticker_arcglory.description"] = [[Hicieron falta nueve neuronas para garabatear esto
Diseo de Optica.

Pegatina incluida en la base ARC9.]]

L["sticker_wp.printname"] = "Paz mundial!"
L["sticker_wp.compactname"] = "Paz mundial!"
L["sticker_wp.description"] = [[Un delirio!
Diseo de Fidget.

Pegatina incluida en la base ARC9.]]

L["sticker_tonkr.printname"] = "Envalo"
L["sticker_tonkr.compactname"] = "Envalo"
L["sticker_tonkr.description"] = [[S, es as de pesado. S, es as de potente.
Diseo de CyloWalker.

Pegatina incluida en la base ARC9.]]

L["sticker_s6amblem.printname"] = "Seccin 6"
L["sticker_s6amblem.compactname"] = "Seccin 6"
L["sticker_s6amblem.description"] = [[Alcanzar las estrellas. Hacia la gloria!
Diseo de CyloWalker.

Pegatina incluida en la base ARC9.]]

L["sticker_babies.printname"] = "Peligro para el beb"
L["sticker_babies.compactname"] = "Peligro para el beb"
L["sticker_babies.description"] = [[Los nios de 0 a 3 aos deben mantenerse alejados de este... arma de fuego.
Diseo de Itzal.

Pegatina incluida en la base ARC9.]]

L["sticker_drawberf.printname"] = "Berf"
L["sticker_drawberf.compactname"] = "Berf"
L["sticker_drawberf.description"] = [[Dibujar Berf.
Diseo de The Villain.

Pegatina incluida en la base ARC9.]]

L["sticker_arcbird.printname"] = "Pajaro Arc"
L["sticker_arcbird.compactname"] = "Pajaro Arc"
L["sticker_arcbird.description"] = [[Pajaro Arc.
Diseo de Nori/Chewable.

Pegatina incluida en la base ARC9.]]

--PATH lua/arc9/common/localization/base_uwu.lua:
L = {}

/////////////////////////////////////// Font
////////////////////// See "font_en" file

/////////////////////////////////////// General
////////////////////// Units of measurement
L["unit.second"] = "s"
L["unit.meter"] = "m"
L["unit.millimeter"] = "mm"
L["unit.meterpersecond"] = "m/s"
L["unit.hammerunit"] = "HUwU"
L["unit.decibel"] = "dB"
L["unit.rpm"] = "RPM"
L["unit.moa"] = "MwA"
L["unit.dmg"] = "DMG"
L["unit.projectiles"] = "PRwJ"

L["unit.inch"] = "in"
L["unit.foot"] = "ft"
L["unit.footpersecond"] = "ft/s"
L["unit.yard"] = "yd"

////////////////////// Ammo types
L["ammo.pistol"] = "Piswol AmmOwO"
L["ammo.357"] = "Mawwnum AmmOwO"
L["ammo.smg1"] = "Cawwbine AmmOwO"
L["ammo.ar2"] = "Wufle AmmOwO"
L["ammo.buckshot"] = "Showotgwun AmmOwO"
L["ammo.sniperpenetratedround"] = "S-sniwew AmmOwO"
L["ammo.smg1_grenade"] = "Wufle Gwenawades"
L["ammo.xbowbolt"] = "Cwosbow Bowts"
L["ammo.rpg_round"] = "Wokets"
L["ammo.grenade"] = "Gwenadews"
L["ammo.slam"] = "SWAM"
L["ammo.alyxgun"] = "Awyx Gun AmmOwO"

/////////////////////////////////////// HUD
L["hud.version"] = "OWO SYwwEwS HUD w"
L["hud.jammed"] = "JAWWED >~<"
L["hud.therm_deco"] = "BAWWEL TEMP uwu"

L["hud.firemode.single"] = "S-SEMI ^w^"
L["hud.firemode.burst"] = "BUwUWST"
L["hud.firemode.auto"] = "AUTOwO"
L["hud.firemode.safe"] = "SAWE~"

L["hud.hint.bash"] = "Baww >w<"
L["hud.hint.bipod"] = "Towgl bipOwOd >w<"
L["hud.hint.breath"] = "Howold bwweath owo"
L["hud.hint.customize"] = "Cuwustomise owo"
L["hud.hint.cycle"] = "C-cycle owo"
L["hud.hint.firemode"] = "S-swich fiwemood"
L["hud.hint.inspect"] = "I-inspewt uwu"
L["hud.hint.lean"] = "Lewn"
L["hud.hint.peek"] = "Peek ^w^"
L["hud.hint.reload"] = "Weload!!! Now!"
L["hud.hint.safe"] = "Towgle Sawe"
L["hud.hint.switchsights"] = "S-switch siwts"
L["hud.hint.toggleatts"] = "Towgle awatachmewws"
L["hud.hint.ubgl"] = "Towgwle"
-- L["hud.hint.unjam"] = "Unjam"
L["hud.hint.zoom"] = "Chawanwe zowom"
L["hud.hint.quicknade"] = "Qwiktwow "

L["hud.hint.lowammo"] = "Low Ammowo!!"
L["hud.hint.noammo"] = "Nyo Ammowo!! 0_0"

L["hud.error.missingbind"] = "awooga! %s isnt bindwed!!"
L["hud.error.missingbind_zoom"] = "wetawd!! bind \"Suit Zoom\" in setings o.o"
L["hud.error.missingbind_context"] = "wetawd!! bind \"Open Context Menu\" in setings o.o"

/////////////////////////////////////// Customization menu
L["customize.panel.customize"] = "CUwUSTOwOMIZE"
L["customize.panel.personalize"] = "PEWWSOWONALIWE"
L["customize.panel.stats"] = "STAWTS uwu BAWWIWTICS"
L["customize.panel.trivia"] = "TWIWIA owo"
L["customize.panel.inspect"] = "WINSWECT"
L["customize.panel.presets"] = "Pwesews"

L["customize.stats.aimtime"] = "Awaim  time"
L["customize.stats.ammo"] = "Ammowo typwe"
L["customize.stats.armorpiercing"] = "Awrmow Purrrcing >w<"
L["customize.stats.burstdelay"] = "Buwwst delay"
L["customize.stats.capacity"] = "C-cawawity"
L["customize.stats.cyclic"] = "Cuclic WoOF"
L["customize.stats.explosive"] = "E-explowosion Dawage >w<"
L["customize.stats.firemodes"] = "Fiwwe Moods"
L["customize.stats.firepower"] = "Fiwepowew"
L["customize.stats.freeaim"] = "Fwee awaim wadius"
L["customize.stats.muzzlevelocity"] = "Nuzle welocitwy"
L["customize.stats.noise"] = "Nowoise"
L["customize.stats.penetration"] = "p-penewawion UwU"
L["customize.stats.precision"] = "Pwecisiwon"
L["customize.stats.range"] = "Wange owo"
L["customize.stats.ricochet"] = "Rrricwowhet Chwancwe"
L["customize.stats.rof"] = "WOOF"
L["customize.stats.speed"] = "Mowement Spewwed"
L["customize.stats.sprinttofire"] = "Spwint to fiwe time"
L["customize.stats.supplylimit"] = "Suwuply wimit owo"
L["customize.stats.sway"] = "Swaway"
L["customize.stats.triggerdelay"] = "Twiwger delay"

L["customize.hint.attach"] = "Atwaach uwu"
L["customize.hint.controller"] = "Cowntwowwew Modwe is on >w<"
L["customize.hint.cursor"] = "Cuwursow"
L["customize.hint.cycle"] = "C-cycwe swot"
L["customize.hint.delete"] = "Dewete >~<"
L["customize.hint.deselect"] = "Desewect"
L["customize.hint.expand"] = "Expaand owo"
L["customize.hint.export"] = "Expowwt"
L["customize.hint.favorite"] = "Fowowite <3"
L["customize.hint.import"] = "Impowt owo"
L["customize.hint.install"] = "Instawww"
L["customize.hint.last"] = "Lawt swot"
L["customize.hint.lastmode"] = "Lawt moode"
L["customize.hint.nextmode"] = "Newxt mode"
L["customize.hint.open"] = "OWOpen"
L["customize.hint.pan"] = "Paw"
L["customize.hint.quicksave"] = "Quwucksawe"
L["customize.hint.randomize"] = "Awtach wandom 'w'"
L["customize.hint.recalculate"] = "Wecawcuwate"
L["customize.hint.recenter"] = "Rr-recentew"
L["customize.hint.rotate"] = "Wotawe OwO"
L["customize.hint.save"] = "Sawwe >w<"
L["customize.hint.select"] = "Sewect >w<"
L["customize.hint.unattach"] = "Unatwach >~<"
L["customize.hint.unfavorite"] = "Wemowe fowowite >w<"
L["customize.hint.zoom"] = "Zowom"

L["customize.trivia.description"] = "D-descwipwion"

L["customize.stats.explain.firepower"] = "de dawage powotential at powoint-bwank wange"
L["customize.stats.explain.rof"] = "de guns wate of fiwe ^w^"
L["customize.stats.explain.cyclic"] = "de weapon c-cyclic wate of fiwe,,,ignowes factows like buwst delay ow weload wequiwements"
L["customize.stats.explain.capacity"] = "howo much ammo de gun can hold in de magazine + chambew"
L["customize.stats.explain.range"] = "de wange at which de gun deals minimum damage"
L["customize.stats.explain.precision"] = "de weapon's accuwacy. Measuwed in Minutes of Accuwacy (MOA)"
L["customize.stats.explain.muzzlevelocity"] = "de nuzzle velocity of bullets fiwed fwom dis gun"
L["customize.stats.explain.ammo"] = "de type of ammo dis gun uses"
L["customize.stats.explain.penetration"] = "UwU Amount of matewial dis gun can penetwate."
L["customize.stats.explain.ricochet"] = "maximum chance fow bullets fwom dis gun to wicochet"
L["customize.stats.explain.armorpiercing"] = "awmount of damage fwom dis gun that completely ignowes most damage wesistances"
L["customize.stats.explain.explosive"] = "amount of explosive damage dis gun will do"
L["customize.stats.explain.speed"] = "spweed at which you can move while using dis gun"
L["customize.stats.explain.aimtime"] = "howo long it takes to aim down sights fwom hip fwe"
L["customize.stats.explain.sprinttofire"] = "howo long it takes to exit spwint and begin shooting"
L["customize.stats.explain.firemodes"] = "wwhwich fiwe modes dis gun has access to"
L["customize.stats.explain.burstdelay"] = "amount of time aftew fiwing a buwst befowe de gun can fiwe again"
L["customize.stats.explain.triggerdelay"] = "delay between pulling de twiggew and fiwing a shot"
L["customize.stats.explain.noise"] = "howo loud de gun's gunshots awe"
L["customize.stats.explain.sway"] = "amount of sway applied to de gun"
L["customize.stats.explain.freeaim"] = "maximum fwee aim angle, Lowew is bettew"
L["customize.stats.explain.supplylimit"] = "amount of ammowo that de gun can weceive fwom AWC9 ammo souwces"

L["customize.bench.dummy"] = "BAWWIWTICS DUM TEWST uwu"
L["customize.bench.effect"] = "EWWEKT AT WANGE"
L["customize.bench.ballistics"] = "TEWMINAL BAWWIWTICS PERAWROWMANCE EWAwALUAWION"
L["customize.bench.precision"] = "MECHANICAL PWECIWWION TEWT"

L["folder.back"] = "Rawr"
L["folder.deselect"] = "Desewect"
L["folder.favorites"] = "Fowowites"
L["folder.select"] = "Sewect >w<"

////////////////////// Automatic stats
L["autostat.enable.pre"] = "Makes"
L["autostat.disable.pre"] = "Nyo"
L["autostat.enable.post"] = ""
L["autostat.disable.post"] = ""

L["autostat.aimdownsightstime"] = "Awaim Dowon Siwts time"
L["autostat.alwaysphysbullet"] = "Awways Phuwusical buwullets"
L["autostat.ammopershot"] = "AmmOwO Pew Shot"
L["autostat.armdamage"] = "Awwm Dawage"
L["autostat.armorpiercing"] = "Awrmow Purrrcing >w<"
L["autostat.autoburst"] = "Auwomawic Buwst Fiwe"
L["autostat.autoreload"] = "Widle weloading"
L["autostat.bash"] = "Mewee Ataks owo"
L["autostat.bashdamage"] = "Mewwee dawage"
L["autostat.bashlungerange"] = "Mewee wuwunge wange"
L["autostat.bashrange"] = "Mewee wange"
L["autostat.bashspeed"] = "Mewee Spewwed >w<"
L["autostat.bipod"] = "Biwod"
L["autostat.bottomlessclip"] = "Botom wess magawine owo"
L["autostat.breathholdtime"] = "ffuwucos time owo"
L["autostat.bulletguidance"] = "Guwuded rrr-rounws uwu"
L["autostat.bulletguidanceamount"] = "Guwudance Wawtor"
L["autostat.canfireunderwater"] = "Undewwawer Showoting"
L["autostat.cantpeek"] = "Nyo Peek .w."
L["autostat.chambersize"] = "Chawamber Lowoad Cunt OwO"
L["autostat.chestdamage"] = "Chest Dawage"
L["autostat.clipsize"] = "Magawine Cawpasity"
L["autostat.cycletime"] = "C-cycle time"
L["autostat.damagemax"] = "Clowose Wange Dawage"
L["autostat.damagemin"] = "Lowong Wange Dawage"
L["autostat.damagerand"] = "Dawage Owarawriance"
L["autostat.deploytime"] = "D-dwaw time"
L["autostat.distance"] = "Buwullet diwwtancwe"
L["autostat.entitymuzzlevelocity"] = "Prowekwtile muzzzel welocitwy"
L["autostat.explosiondamage"] = "E-explowosion Dawage >w<"
L["autostat.explosionradius"] = "E-explowosion Swlawsh Wadius >w<"
L["autostat.fixtime"] = "Uwunjam wime uwu"
L["autostat.freeaimradius"] = "Fwee Awaim Wadiuwus"
L["autostat.headshotdamage"] = "Snout Dawage owo"
L["autostat.heatcapacity"] = "Hewt Cawasity"
L["autostat.heatdissipation"] = "Hewt Diwwiwation uwu"
L["autostat.heatpershot"] = "Hewt Pew Showoot"
L["autostat.hybridreload"] = "H-hybrid widiwidual weloading"
L["autostat.infiniteammo"] = "Inwinite Amuwiwion awa"
L["autostat.legdamage"] = "Paw Dawage"
L["autostat.malfunction"] = "Jawwing >~<"
L["autostat.malfunctionmeanshotstofail"] = "Mewan showts Betwuen Faiwuwes"
L["autostat.malfunctionwait"] = "Mawwunwion w-wait time"
L["autostat.manualaction"] = "Manuwual Action rr~"
L["autostat.manualactionchamber"] = "Shwots Pew Cycwe owo"
L["autostat.neverphysbullet"] = "Nyo-Phuwusical buwullets"
L["autostat.noflash"] = "Nyo Nuzzle Wlash owo"
L["autostat.num"] = "Prowekwtile cunt"
L["autostat.overheat"] = "Owerhewting uwu"
L["autostat.overheattime"] = "OWOrhewat fox time owo"
L["autostat.pelletspread"] = "Cwump Spwead"
L["autostat.penetration"] = "Matewial p-penewawion UwU"
L["autostat.penetrationdelta"] = "Dawage awtew penetwation uwu"
L["autostat.physbulletdrag"] = "Buwullet Dwag"
L["autostat.physbulletgravity"] = "Buwullet Dwop"
L["autostat.physbulletmuzzlevelocity"] = "Muzzzel welocitwy"
L["autostat.postburstdelay"] = "Buwwst Dwelauwu"
L["autostat.pushbackforce"] = "Puwushbak Foworce"
L["autostat.rangemax"] = "Maximuwum wange"
L["autostat.rangemin"] = "M-Mimimal wange"
L["autostat.recoil"] = "Wecoil"
L["autostat.recoilautocontrol"] = "Wecoil Cowontwol"
L["autostat.recoildissipationrate"] = "Wecoil Dissipation Wate"
L["autostat.recoilkick"] = "Felt Wecoil"
L["autostat.recoilmodifiercap"] = "Maximum cum-ulatiwe wecoil uwu"
L["autostat.recoilpatterndrift"] = "Wecoil Dwwift uwu"
L["autostat.recoilpershot"] = "Wecoil pwer Shwot >w<"
L["autostat.recoilrandomside"] = "H-Howisontawal Wecoil Spwead"
L["autostat.recoilrandomup"] = "Wewtical Wecoil Spwead~"
L["autostat.recoilresettime"] = "Wecoil Weset Time"
L["autostat.recoilside"] = "H-Howisontawal Wecoil"
L["autostat.recoilup"] = "Wewtical Wecoil"
L["autostat.reloadtime"] = "W-weload time owo"
L["autostat.ricochetanglemax"] = "Rrricwowhet AWangwle"
L["autostat.ricochetchance"] = "Rrricwowhet Chwancwe"
L["autostat.rpm"] = "Fiwe Wate"
L["autostat.runawayburst"] = "WunAWAy Buwst"
L["autostat.secondarysupplylimit"] = "Rwesewwe Secowondawy AmmOwO"
L["autostat.shootvolume"] = "Wepowt owolume"
L["autostat.shootwhilesprint"] = "Showot Ww-while Spwinting"
L["autostat.shotgunreload"] = "Windiwidual weloading o"
L["autostat.speed"] = "Mowement Spewwed"
L["autostat.spread"] = "Spwead >w<"
L["autostat.sprinttofiretime"] = "Spwint To fiwe time uwu"
L["autostat.stomachdamage"] = "Stowach Dawage"
L["autostat.supplylimit"] = "Rwesewwe Magawines uwu"
L["autostat.sway"] = "S-sway <w>"
L["autostat.triggerdelay"] = "Twiggew d-deway"
L["autostat.triggerdelaytime"] = "Twiggew deway time"
L["autostat.visualrecoil"] = "W-wisual Wecoil"
L["autostat.visualrecoilpunch"] = "Wisual Wecoil Puwnch"
L["autostat.visualrecoilroll"] = "Wisual Wecoil wwroll"
L["autostat.visualrecoilside"] = "H-Howisontawal Wisual Wecoil"
L["autostat.visualrecoilup"] = "W-wertical wisual Wecoil"

L["autostat.secondary._beforephrase"] = false
-- if true, secondary stat phrasing comes before the stat
L["autostat.secondary._divider"] = " "
-- space between the secondary phrase from the stat phrase. set true to use empty string

-- L["autostat.secondary.blindfire"] = "w-whiwe bwind-fiwing"
L["autostat.secondary.bipod"] = "on bipOwOd"
L["autostat.secondary.crouch"] = "w-whiwe cwouchiwuwung"
L["autostat.secondary.empty"] = "owon wast wound in mag"
L["autostat.secondary.evenreload"] = "ewewy uwuwen weload"
L["autostat.secondary.evenshot"] = "ewewy uwuwen shwot >//<"
L["autostat.secondary.first"] = "owon first shwot"
L["autostat.secondary.firstshot"] = "owon first shwot"
L["autostat.secondary.heated"] = "while hewted"
L["autostat.secondary.hipfire"] = "in beeppfiwe uwu"
L["autostat.secondary.hot"] = "fwom hewt"
L["autostat.secondary.last"] = "owon wast wound in mag"
L["autostat.secondary.lastshot"] = "owon wast round in mag"
L["autostat.secondary.midair"] = "in meow-air"
L["autostat.secondary.move"] = "wwhiwe mowing"
L["autostat.secondary.oddreload"] = "ewewy owdd weload"
L["autostat.secondary.oddshot"] = "ewewy owdd shwot >///<"
L["autostat.secondary.recoil"] = "from wecoil" --"With Each Shot"
L["autostat.secondary.shooting"] = "w-whiwe showoting"
L["autostat.secondary.sighted"] = "while siwted"
L["autostat.secondary.sights"] = "in siwts!"
L["autostat.secondary.silenced"] = "wwhen siwenced owo"
L["autostat.secondary.sprint"] = "while Spwinting"
L["autostat.secondary.true"] = "wwith TwueNawes"
L["autostat.secondary.ubgl"] = "in UwUBGL"

////////////////////// Blacklist menu
L["blacklist.title"] = "AWWC9 awatachmenws bwackwist >w<"
L["blacklist.desc"] = "AwAtachmenws checkewd hewe wiww be bwocked from use ^w^"
L["blacklist.blisted"] = "BWACKWISTED"
L["blacklist.all"] = "AWW"
L["blacklist.id"] = "ID :3"
L["blacklist.name"] = "NAME"
L["blacklist.filter"] = "FIWTEW"

////////////////////// Incompatible addons
L["incompatible.title"] = "AWC9: INCOwOMPATIBLE ADDONS >w<"
L["incompatible.line1"] = "Y-you hawwe some awaddons that awwe knowon to not wowk with AWC9"
L["incompatible.line2"] = "Diawawable dem orrrawr expect bwoken behaviow >~<"
L["incompatible.confirm"] = "Acknowowewge owo"
L["incompatible.wait"] = "W-Wait {time}s uwu"
L["incompatible.never"] = "Nevew wawn me awagain >///<"
L["incompatible.never.hover"] = "Awe you sillius wight meow? you undewwstand de consewuences??? >-<"
L["incompatible.never.confirm"] = "You hawe chowwen to newew showww INCOwOMPATIBLE owawnings again. If you encountew ewwows owr bwoken behaviouw its youw own wesponsibwwity >-< you silly ass"

////////////////////// Warning panel
-- L["badconf.title"] = "ARC9: BAD GMOD SETTINGS WARNING"
-- L["badconf.line1"] = "It appears some Garry's Mod settings are causing problems."
-- L["badconf.line2"] = "Listed below are problems which have been detected, and solutions to fix them."
-- L["badconf.confirm"] = "Acknowledge"
-- L["badconf.wait"] = "Wait {time}s"

-- L["badconf.directx.title"] = "Outdated DirectX version"
-- L["badconf.directx.desc"] = "You are currently running DirectX 8 or 8.1. Modern GMod isn't meant for this, you might not be able to see models on most weapon packs. (dx9 was introduced 21 years ago!)"
-- L["badconf.directx.solution"] = "Solution: Go to Garry's Mod's launch options and insert \"-dxlevel 95\" into the launch parameters. If \"-dxlevel 70/80/85\" is listed there, remove it."

-- L["badconf.tickrate.title"] = "Too low server tickrate"
-- L["badconf.tickrate.desc"] = "The server you are on is running on very low tickrate. ARC9 runs best if you run a minimum of 20 tickrate (66+ is recommended)."
-- L["badconf.tickrate.solution"] = "Solution: If you are a server owner, then insert \"-tickrate 33\", or whichever value you want, in the server launch configurations."

-- L["badconf.matbumpmap.title"] = "mat_bumpmap is disabled"
-- L["badconf.matbumpmap.desc"] = "You have bumpmaps disabled, which makes weapons look worse. It also breaks certain ARC9 optics."
-- L["badconf.matbumpmap.solution"] = "Solution: In the console, type \"mat_bumpmap 1\". If you are using an FPS config of any kind, then find and delete mat_bumpmap 0 line from \"autoexec.cfg\"."

-- L["badconf.addons.title"] = "Too many addons! Lua file limit exceeded!"
-- L["badconf.addons.desc"] = "You have installed way too many addons and have reached the Lua file limit. ARC9 has therefore not been able to initialize properly, meaning attachments might not work."
-- L["badconf.addons.solution"] = "Solution: Uninstall heavy addons through the in-game Addons menu, or through the Steam workshop (for example other weapon bases, JMod, Entity Packs, and so on)."

-- L["badconf.warning"] = "Warning! Your performance is not optimal! - Hover over to view details."
-- L["badconf.warning.desc"] = "More FPS is always good. Especially on weapon bases like this one.\n\nHover cursor over items below to see solution."

-- L["badconf.x64.title"] = " Slow 32-Bit branch Detected"
-- L["badconf.x64.desc"] = [[You are currently running Garry's Mod in 32-bit. This restricts the amount of performance you can obtain drastically.

-- Solution: In Garry's Mod's launch options, go to "Betas" and change to "x86-64 - Chromium + 64-bit binaries".

-- Google "gmod x64" to find a tutorial online.]]

-- L["badconf.multicore.title"] = " No Multicore Rendering commands"
-- L["badconf.multicore.desc"] = [[Certain multicore rendering settings are currently disabled. This results in worsened in-game performance.

-- Solution: You need to put certain commands into autoexec.cfg

-- Google "gmod multicore" to find a tutorial online.

-- All commands that can increase performance:
-- gmod_mcore_test 1
-- mat_queue_mode 2
-- cl_threaded_bone_setup 1
-- cl_threaded_client_leaf_system 1
-- r_threaded_client_shadow_manager 1
-- r_threaded_renderables 1]]

////////////////////// Presets
L["customize.presets.atts"] = " awatachmenws >w<"
L["customize.presets.back"] = "Bawack >w<"
L["customize.presets.cancel"] = "C-cancel >w<"
L["customize.presets.code"] = "Pwewewet c-ode (Copied to Clipboawd owo)"
L["customize.presets.default"] = "Dewaauwt"
L["customize.presets.default.long"] = "Dewaauwt pwesew"
L["customize.presets.dumb"] = "Awe you silly?"
L["customize.presets.import"] = "Impowwt"
L["customize.presets.invalid"] = "Invalid stwing! >~<"
L["customize.presets.new"] = "New pwesew name"
L["customize.presets.paste"] = "Paste pwesew code hewwe tee hee"
L["customize.presets.random"] = "OwO waandom"
L["customize.presets.save"] = "Sawwe"
L["customize.presets.unnamed"] = "Uwwamed"

L["customize.presets.deldef"] = "Awee yyu suwe yu wawt two dewete \"{name}\" dewaauwt pwesew? owo"
L["customize.presets.deldef2"] = "Youw woulwd hawe to weset uwuweapon in dewelopew sewtings two weturn it >~<"
L["customize.presets.yes"] = "MEOW !"

////////////////////// Tips
L["tips.arc-9"] = "Its AWC9  NOT ARC9 >~<"
L["tips.blacklist"] = "Yu can bwaklist awwtachments! See de AWC9 oWowkshop descwiption fow mowe infowmation"
L["tips.bugs"] = "Weporwt bugs on de official discowd sewvew ewww owr betew  open a gituwub iwwue owo"
L["tips.custombinds"] = "AWC9 kwey cowombows c-can be wepwaced with cuwustom binds. Stawt typing +arc9_ to find de awailable bwinds!"
L["tips.cyberdemon"] = "To kill de tewwowist shoot him until he ded >~<"
L["tips.description"] = "W-we adwise yu to wead de descwiptions of addons befowe commenting owo"
L["tips.development"] = "Keen to dewelop AWC9 content? de official diwwcowd sewverwr does not have any rewwouwres >w<"
L["tips.discord"] = "Do not join diamond dDoves on diwwcowd! die"
L["tips.external"] = "If using de gituwub vewsion of AWC9 make suwe to upwate fwequently ^^"
L["tips.hints"] = "K-keep AWC9 HUD own to sewe cowontwol hintss"
L["tips.lean"] = "To mawuawwy wean, bwiwnd kewys to +alt1 awnd +alt2"
L["tips.love"] = "Feel fwee to tell de devs you appweciate theiw wowk UwU it weally helps us keep going owo"
L["tips.m9k"] = "Check out m9k guwuns meow"
L["tips.official"] = "Owly dowonload AWC9 fwom official souwces >.< Thiwd pawty upwoads may be mawicious ow outdated >o<"
L["tips.presets"] = "Shawe yuw fowowite pwesews with yuww furwiends by expowting dem!"
L["tips.settings"] = "You can tuwn dese tips off and much mowe in de AWC9 settings owo c-click de button in de top left cownew"
L["tips.tips"] = "Tips hawwe a fixed owdew. Kewep weading and yuw ewwentuawy see dem all"
L["tips.tolerance"] = "Aww weapon basews wowk fine togeww thewes no need fow fowowoitiswm"

////////////////////// Other
L["atts.favourites"] = "Fowowites"
L["atts.filter"] = "Filtew"

/////////////////////////////////////// Settings menu
-- Use this method to localize convars in settings menu:
-- settings.convar.title = "Convar Title"
-- settings.convar.desc = "Convar Description"

L["settings.title"] = "A-AWC9 Sewwings"
L["settings.desc"] = "D-descwipwion"

L["settings.default_convar"] = "defauwt wawue"
L["settings.convar_server"] = "Sewwvew wawiabwe"
L["settings.convar_client"] = "Cwient wawiabwe"

////////////////////// General
L["settings.tabname.general"] = "Genewal"

L["settings.general.client"] = "Cwient"
L["settings.language_id.title"] = "Wanguwage"
L["settings.language_id.desc"] = "Wanguwage pawck to uwuse fow AWC9\n\n\nyuwe soo pawesom fow uwusing de UwU wanguage :3"
L["settings.truenames.title"] = "Twue names"
L["settings.truenames.desc"] = "Set whedew to use weapons' weal names ow fictional names made by de developews. Not all weapons utilize dis.\n\nSewvew setting may ovewwide dis pwefewence"
L["settings.resetsettings.cl.title"] = "Weset aww CWIENT setings"

L["settings.general.server"] = "Sewvewwr"
L["settings.truenames_default.title"] = "Default Twue Names"
L["settings.truenames_default.desc"] = "Set de default twue names mode on de sewvew. All playews using \"Default\" in pwefewence will use dis"
L["settings.truenames_enforced.title"] = "Default Twue Names Enfowced"
L["settings.truenames_enforced.desc"] = "Set to fowce all playews to use de sewvew setting fow twue names"

L["settings.resetsettings.sv.title"] = "Weset aww SErrWWEW setings"

L["settings.reset"] = "UwU Weset!!!"

////////////////////// Performance
L["settings.tabname.performance"] = "Perawawmance"

L["settings.performance.important"] = "High Pewfowmance Impact"
L["settings.cheapscopes.title"] = "Chweap Scopes"
L["settings.cheapscopes.desc"] = "A cheap wT scope implementation by zooming youw whole view to aim, instead of wendewing wowld again in a scope. Significantly incweases pewfowmance on lawge maps"
L["settings.tpik.title"] = "TPIK"
L["settings.tpik.desc"] = "TPIK (Thiwd Pewson Invewse Kinematics) is a system that allows most weapons display detailed and same as in fiwst pewson hands positions, weload and fiwing animations in thiwd pewson.\n\nConfiguwe it in Visuals tab"
L["settings.allflash.title"] = "All Flashlights"
L["settings.allflash.desc"] = "Fully wendew all flashlights fwom odew playews.\n\nVewy expensive on sewvews"

L["settings.performance.blur.title"] = "Bluw"
L["settings.cust_blur.title"] = "Customization Backgwound"
L["settings.cust_blur.desc"] = "Bluws customization backgwound"
L["settings.fx_reloadblur.title"] = "While weloading"
L["settings.fx_reloadblur.desc"] = "Bluws de wowld while weloading"
L["settings.fx_animblur.title"] = "While weadying"
L["settings.fx_animblur.desc"] = "Bluws de wowld while deploying a weapon fow de fiwst time"
L["settings.fx_rtblur.title"] = "In Scopes"
L["settings.fx_rtblur.desc"] = "Bluws de wowld while using a magnified scope"
L["settings.fx_adsblur.title"] = "In Sights"
L["settings.fx_adsblur.desc"] = "Bluws de weapon while aiming down sights"
L["settings.fx_rtvm.title"] = "Wendew Wewapown dwough WT Scowpes"
L["settings.fx_rtvm.desc"] = "! EXPEWIMENTAW !\nWendwrs de wewapon and its attwachments dwough WT scwopes. Wequiwes \"Chewp Scowpes\" to be disablewd.\nSigniwicantwy weduces pewwormance."

L["settings.performance.shelleject.title"] = "Sheww Eject"
L["settings.eject_fx.title"] = "Smoke Effects"
L["settings.eject_fx.desc"] = "Pwoduce smoke effects fwom ejected shell casings, whewe de weapon suppowts dis featuwe"
L["settings.eject_time.title"] = "Add Life Time"
L["settings.eject_time.desc"] = "Allow shell casings to stay in de wowld fow longew. Can be expensive"

L["settings.performance.fx.title"] = "Efwects"
L["settings.muzzle_light.title"] = "Nuzzle Light"
L["settings.muzzle_light.desc"] = "Enable light emitted fwom nuzzle flashes when fiwing a weapon"
L["settings.muzzle_others.title"] = "Otter nuzzle ewwekts"
L["settings.muzzle_others.desc"] = "Enabwe nuzzle ewwekts fwom othew pwayews guns :3"

////////////////////// Optics
L["settings.tabname.optics"] = "OwOptics"

L["settings.optics.control"] = "Contwol"
L["settings.optics.sensmult.title"] = "Muwtipwy ADS sensitiwity"
L["settings.optics.sensmult.desc"] = "Muwtipwy de wook sensitiwity by dis amouwunt wwen awiming.\nDe wowew de wawue, de wowew de sensitiwity.\nUwUsewuw wen uwusing controwwews or iw de usew juwust wants wowew awiming sensitiwity."
L["settings.optics.compensate_sens.title"] = "Compensate Sensitivity"
L["settings.optics.compensate_sens.desc"] = "Compensate sensitivity fow magnification"
L["settings.optics.toggleads.title"] = "Towggle ADS"
L["settings.optics.toggleads.desc"] = "Awiming wiw togwe sights."

-- L["settings.optics.dtap_sights.title"] = "Double-Tap to Switch Sights"
-- L["settings.optics.dtap_sights.desc"] = "Allows double-tapping the USE key to switch sights."

L["settings.optics.color"] = "Colow"
L["settings.optics.reflex.title"] = "weflex Sights"
L["settings.optics.reflex.desc"] = "Colow to use fow weflex/hologwaphic sights.\n\nNot all optics suppowt dis featuwe"
L["settings.optics.scope.title"] = "Scopes"
L["settings.optics.scope.desc"] = "Colow to use fow magnified scopes.\n\nNot all optics suppowt dis featuwe"

////////////////////// Crosshair
L["settings.tabname.crosshair"] = "Cwosshaiw"

L["settings.crosshair.crosshair"] = "Cwosshaiw"
L["settings.crosshair.cross_enable.title"] = "Enable cwosshaiw"
L["settings.crosshair.cross_enable.desc"] = "Enable cwosshaiw. Some guns do not allow you to use de cwosshair"
L["settings.crosshair.cross.title"] = "Cwosshaiw Colow"
L["settings.crosshair.cross.desc"] = "de colow of youw cwosshaiw"
L["settings.crosshair.cross_size_mult.title"] = "Cwosshaiw Size"
L["settings.crosshair.cross_size_mult.desc"] = "Muwtipwy de size of youw cwosshaiw"
L["settings.crosshair.cross_size_dot.title"] = "Dot Size"
L["settings.crosshair.cross_size_dot.desc"] = "Muwtipwy de size of de middle dot"
L["settings.crosshair.cross_size_prong.title"] = "Pwong Size"
L["settings.crosshair.cross_size_prong.desc"] = "Muwtipwy de size of de outew pwongs"
L["settings.crosshair.crosshair_static.title"] = "Static Cwosshaiw"
L["settings.crosshair.crosshair_static.desc"] = "Enable static cwosshaiw, which does not move when shooting"
L["settings.crosshair.crosshair_force.title"] = "Fowce Cwosshaiw"
L["settings.crosshair.crosshair_force.desc"] = "Fowce de cwosshaiw even on guns that don't want you to see it.\n\nSewvew setting"
L["settings.crosshair.crosshair_target.title"] = "Wed cwosshaiw on tawget"
L["settings.crosshair.crosshair_target.desc"] = "Make the cwosshaiw wed wen awiming on a tawget.\nAwso activates awim assist if it is tuwned on."
L["settings.crosshair.crosshair_peeking.title"] = "Dispway cwosshaiw when peeking"
L["settings.crosshair.crosshair_peeking.desc"] = "Dispways de cwosshaiw wen aiwming and uswing de pewek wunction."

////////////////////// Customization
L["settings.tabname.hud_cust"] = "Cuwustomiawon"

L["settings.hud_cust.hud"] = "HUD"
L["settings.hud_cust.hud_scale.title"] = "HUD Scale"
L["settings.hud_cust.hud_scale.desc"] = "Scale multipliew fow AWC9's HUD"
L["settings.hud_cust.hud_deadzonex.title"] = "HUD Widh dewdzowne"
L["settings.hud_cust.hud_deadzonex.desc"] = "Howizontal dewadzowne fow cuwtomiwation menuwu and huwud panel\nUwUseful for uwtwawidew monitows owo"
L["settings.hud_cust.hud_color.title"] = "HUD Colow"
L["settings.hud_cust.hud_color.desc"] = "Highlight colow fow de HUD.\nde accent colow"
L["settings.hud_cust.hud_holiday.title"] = "Howowiday demes"
L["settings.hud_cust.hud_holiday.desc"] = "demes dat actiwate duwing cewtain howidays.\nWiw ovewwide highwight colow >w<"
L["settings.hud_cust.hud_darkmode.title"] = "Dawk deme"
L["settings.hud_cust.hud_darkmode.desc"] = "Enables dawk colows in HUD instead of light gway and disables vignette effect in backgwound"
L["settings.hud_cust.cust_light.title"] = "Enable Light"
L["settings.hud_cust.cust_light.desc"] = "Enables gun lighting in de customization menu.\n\nSame thing as button neaw settings button"
L["settings.hud_cust.cust_light_brightness.title"] = "Light Bwightness"
L["settings.hud_cust.cust_light_brightness.desc"] = "howo bwight that light in de customization panel will be.\n\nDon't fowget to tuwn it on fiwst though!"

L["settings.hud_cust.customization"] = "Customization"
L["settings.hud_cust.cust_hints.title"] = "Hints"
L["settings.hud_cust.cust_hints.desc"] = "Enable hints in de customization menu"
L["settings.hud_cust.cust_tips.title"] = "Tiwips"
L["settings.hud_cust.cust_tips.desc"] = "Tiwips about AWC9 base neaw hints"
L["settings.hud_cust.cust_exit_reset_sel.title"] = "Exit wesets Selection"
L["settings.hud_cust.cust_exit_reset_sel.desc"] = "Exiting customization menu wesets de active slot selection"
-- L["settings.hud_cust.imperial.title"] = "Imperial Measurement"
-- L["settings.hud_cust.imperial.desc"] = "Replaces various measurement systems to their Imperial variants.\nOnly affects the \"Stats & Ballistics\" customization screen."

////////////////////// Game HUD
L["settings.tabname.hud_game"] = "Game HUwUD"

L["settings.hud_game.lcd"] = "LCD Panel"
L["settings.hud_game.hud_arc9.title"] = "Enable HUD"
L["settings.hud_game.hud_arc9.desc"] = "Enable HUD fow AWC9 weapons"
L["settings.hud_game.hud_always.title"] = "On all weapons"
L["settings.hud_game.hud_always.desc"] = "Enable that HUD on all weapons"
L["settings.hud_game.hud_compact.title"] = "Compact Mode"
L["settings.hud_game.hud_compact.desc"] = "Compact appeawance fow de HUD panel"
L["settings.hud_game.hud_nohints.title"] = "Diwable Hints >w<"
L["settings.hud_game.hud_nohints.desc"] = "Diawawable hints completely. dey will not showo up in de 3D HUD, now in de 2D HUD"
L["settings.hud_game.hud_keephints.title"] = "Keep Hints"
L["settings.hud_game.hud_keephints.desc"] = "Showo de AwC9 contwol hints on top on HUD panel"
L["settings.hud_game.hud_force_disable.title"] = "Fowce diswabwe HUwUD"
L["settings.hud_game.hud_force_disable.desc"] = "Disawbwe AWC9 HUD fow aww pwayews. does nowt awwect hiwnts."

L["settings.hud_game.killfeed"] = "Killfeed"
L["settings.hud_game.killfeed_enable.title"] = "Killfeed Icons"
L["settings.hud_game.killfeed_enable.desc"] = "Enable auto-genewation of killfeed icons fow AwC9 guns"
L["settings.hud_game.killfeed_dynamic.title"] = "Dynamic updating"
L["settings.hud_game.killfeed_dynamic.desc"] = "Killfeed icons will be wegenewated aftew each kill.\n\nTuwn off if you want get that 0.1 fps"
L["settings.hud_game.killfeed_colour.title"] = "Full colow Icons"
L["settings.hud_game.killfeed_colour.desc"] = "Dynamically genewated icons awe fully colowed"

L["settings.hud_game.breath"] = "Bweath"
L["settings.hud_game.breath_hud.title"] = "Bweath HUD"
L["settings.hud_game.breath_hud.desc"] = "Showo a baw that displays youw wemaining bweath while stabilizing youw gun in sights"
L["settings.hud_game.breath_pp.title"] = "Bweath Post-Pwocess"
L["settings.hud_game.breath_pp.desc"] = "Holding bweath will also add post-pwocessing effects to youw scween"
L["settings.hud_game.breath_sfx.title"] = "Bweath SFX"
L["settings.hud_game.breath_sfx.desc"] = "Holding bweath will play associated sound effects"

L["settings.hud_game.centerhint"] = "Centewed Hiwnts uwu"
L["settings.hud_game.centerhint_reload.title"] = "Centew weload hint"
L["settings.hud_game.centerhint_reload.desc"] = "Display a reload tip when low on ammunition."
L["settings.hud_game.centerhint_reload_percent.title"] = "Magawine Pewcentwage"
L["settings.hud_game.centerhint_reload_percent.desc"] = "Display the reload tip when the current magazine is at this percentage value."
L["settings.hud_game.centerhint_bipod.title"] = "Centew bipowod hint"
L["settings.hud_game.centerhint_bipod.desc"] = "Centewed bipowod hint"
-- L["settings.hud_game.centerhint_jammed.title"] = "Display Jammed Tip"
-- L["settings.hud_game.centerhint_jammed.desc"] = "Display a tip when your weapon is jammed."

-- L["settings.hud_game.centerhint_firemode.title"] = "Display Firemode Tip"
-- L["settings.hud_game.centerhint_firemode.desc"] = "Display a tip when you swap firing mode or toggle your safety."
-- L["settings.hud_game.centerhint_firemode_time.title"] = "Display Firemode Time"
-- L["settings.hud_game.centerhint_firemode_time.desc"] = "How long the firing mode should be displayed."

-- L["settings.hud_game.centerhint_overheat.title"] = "Display Overheat Tip"
-- L["settings.hud_game.centerhint_overheat.desc"] = "Displays an overlayed tip showing how close the weapon is to overheating.\n\nNot displayed if ARC9 HUD is enabled or the weapon does not support overheat."

L["settings.hud_game.hud_glyph"] = "Gwyph Type"

L["settings.hud_game.hud_glyph_type_hud.title"] = "HUwUD"
L["settings.hud_game.hud_glyph_type_hud.desc"] = "Change which famiwy of gwyphs to use.\nDis awwects de HUD tips."

L["settings.hud_game.hud_glyph_type_cust.title"] = "Custowomization Menu"
L["settings.hud_game.hud_glyph_type_cust.desc"] = "Change which famiwy of gwyphs to use.\nDis awwects de cuwstomization menu tips.\nChanges appwy next time de customizatiwon menuwu is owpened."

L["settings.hud_game.hud_glyph_light"] = "Wight"
L["settings.hud_game.hud_glyph_dark"] = "Dawk"
L["settings.hud_game.hud_glyph_knockout"] = "Knokowot"

////////////////////// NPCs
L["settings.tabname.npc"] = "NPCs >w<"

L["settings.npc.weapons"] = "NPC Weapons"
L["settings.npc.npc_equality.title"] = "Damage Equality"
L["settings.npc.npc_equality.desc"] = "NPCs do just as much damage as playews do.\n\ndis is a sewvew wawiableh"
L["settings.npc.npc_spread.title"] = "NPC Spwead"
L["settings.npc.npc_spread.desc"] = "Multipliew fow howo inaccuwate NPCs will be when fiwing"
L["settings.npc.npc_atts.title"] = "Give awatachmenws"
L["settings.npc.npc_atts.desc"] = "Spawned ow given AwC9 weapons weceive a wandom set of awatachmenws.\n\ndis is a sewvew wawiableh"
L["settings.npc.npc_autoreplace.title"] = "Weplace NPC UWeapons"
L["settings.npc.npc_autoreplace.desc"] = "Weplace NPC weapons with wandomly chosen AwC9 weapons.\n\ndis is a sewvew wawiableh"
L["settings.npc.replace_spawned.title"] = "Weplace Gwound Weapons"
L["settings.npc.replace_spawned.desc"] = "Weplace map/spawned HL2 weapons with wandomly chosen AwC9 weapons.\n\ndis is a sewvew wawiableh"
L["settings.npc.npc_give_weapons.title"] = "Playews Can Give Weapons"
L["settings.npc.npc_give_weapons.desc"] = "Playews awe able to pwess E on NPCs to give dem deiw weapon.\n\ndis is a sewvew wawiableh"

////////////////////// Gameplay
L["settings.tabname.gameplay"] = "Gamepway"

L["settings.gameplay.controls"] = "Contwols"
L["settings.gameplay.toggleads.title"] = "Toggle ADS"
L["settings.gameplay.toggleads.desc"] = "Aiming will toggle sights"
L["settings.gameplay.autolean.title"] = "Automatic Lean"
L["settings.gameplay.autolean.desc"] = "Aiming will twy to automatically lean if dis is possible"
L["settings.gameplay.autoreload.title"] = "Automatic weload"
L["settings.gameplay.autoreload.desc"] = "Empty AWC9 weapons will weload automatically"
L["settings.gameplay.togglelean.title"] = "Toggle Lean"
L["settings.gameplay.togglelean.desc"] = "Pwessing de lean keys will toggle leaning instead of needing to be held down.\n\nWowks poowly in conjunction with autolean. If using toggle lean, you should Diawawable autolean"
L["settings.gameplay.togglepeek.title"] = "Towgle peeek"
L["settings.gameplay.togglepeek.desc"] = "Pwessing de peek key will toggle peeking instead of needing to be held down"
L["settings.gameplay.togglepeek_reset.title"] = "Weset pewek stawte awter awaiming"
L["settings.gameplay.togglepeek_reset.desc"] = "(owly if Towgle Pewek is on owo)\npeeeek state w-wil notw be wetaiwed wwen ewiting awaim dowon siwts uwu"
L["settings.gameplay.togglebreath.title"] = "Towgle howolding bweath"
L["settings.gameplay.togglebreath.desc"] = "Pwessing de Holding Bweath key will toggle Holding Bweath instead of needing to be held down"

L["settings.gameplay.mechanics"] = "Game Mechanics"
L["settings.gameplay.infinite_ammo.title"] = "Infinite Ammo"
L["settings.gameplay.infinite_ammo.desc"] = "Weapons have infinite ammunition.\n\ndis is a sewvew wawiableh"
L["settings.gameplay.realrecoil.title"] = "Physical Visual wecoil"
L["settings.gameplay.realrecoil.desc"] = "Select weapons set up fow dis featuwe expewience physical nuzzle wise, meaning dey will fiwe whewe deiw viewmodel shows it wadew than at de centew of de scween. Vewy impowtant fow some weapon packs' balancing schemes.\n\ndis is a sewvew wawiableh"
L["settings.gameplay.lean.title"] = "Leaning"
L["settings.gameplay.lean.desc"] = "Whedew playews can lean with +alt1 and +alt2, including automatic lean.\n\ndis is a sewvew wawiableh"
L["settings.gameplay.mod_sway.title"] = "Sway"
L["settings.gameplay.mod_sway.desc"] = "Weapons will have sway, if dey awe set up to use it.\n\ndis is a sewvew wawiableh"
L["settings.gameplay.mod_freeaim.title"] = "Fwee Aim"
L["settings.gameplay.mod_freeaim.desc"] = "Weapons will have fwee aim, and will not always shoot in de middle of de scween.\n\ndis is a sewvew wawiableh"
L["settings.gameplay.mod_bodydamagecancel.title"] = "Body Damage Cancel"
L["settings.gameplay.mod_bodydamagecancel.desc"] = "Cancel out default body damage multipliew. Only Diawawable if using anodew mod that pwovides dis type of functionality.\ne.g. Mods which change de default limb multipliews.\n\ndis is a sewvew wawiableh"
L["settings.gameplay.breath_slowmo.title"] = "Slow-Mo Bweath"
L["settings.gameplay.breath_slowmo.desc"] = "Holding bweath slows time.\n\nSingleplayew only"
L["settings.gameplay.manualbolt.title"] = "Manual Cycling"
L["settings.gameplay.manualbolt.desc"] = "Bolt-action weapons configuwed fow dis featuwe will only bolt when w is pwessed, and not when de attack key is weleased"
L["settings.gameplay.never_ready.title"] = "No weady Anims"
L["settings.gameplay.never_ready.desc"] = "Diawawable weady animations when deploying a weapon.\n\ndis is a sewwew wawiableh"
L["settings.gameplay.recoilshake.title"] = "Wecoiw FOW Shwake -w-"
L["settings.gameplay.recoilshake.desc"] = "Snwaps wield owo wiew when showoting"
L["settings.gameplay.equipment_generate_ammo.title"] = "Uniquwe Ammowo Tywps fow eckwipmenwt"
L["settings.gameplay.equipment_generate_ammo.desc"] = "Thewe wimit ow 255 ammowo typaws and diswabwing dis optiowon may hewp wix some pwoblems if u hawe lowts of addowons. \n\nWekuiwes westawt.\n\ndis is a sewwew wawiableh"

-- ??
L["settings.gameplay.mult_defaultammo.title"] = "Dewault Weserve Amo"
L["settings.gameplay.mult_defaultammo.desc"] = "How many magazinews/gwenades/eckwipmenwt giwe to plawew when he take weapon fow fiwst time?\n\ndis is a sewwew wawiableh"
L["settings.gameplay.nearwall.title"] = "Neaw-walling"
L["settings.gameplay.nearwall.desc"] = "Not allow gun shoot when you standing too close to wall ow any obstacle"

////////////////////// Visuals
L["settings.tabname.visuals"] = "Wisuwuals"

L["settings.visuals.viewmodel"] = "Viewmodel"
L["settings.visuals.vm_bobstyle.title"] = "Bob Style"
L["settings.visuals.vm_bobstyle.desc"] = "Select diffewent bobbing styles, to de flavow of diffewent contwibows of de AWC9 (and Valve Softwawe)"
L["settings.visuals.fov.title"] = "FOV"
L["settings.visuals.fov.desc"] = "Add viewmodel FOV. Makes de viewmodel biggew ow smallew. Use wesponsibly"
L["settings.visuals.vm_addx.title"] = "Add X"
L["settings.visuals.vm_addx.desc"] = "Shift de viewmodel to de wight ow left"
L["settings.visuals.vm_addy.title"] = "Add Y"
L["settings.visuals.vm_addy.desc"] = "Shift de viewmodel fowwawds and backwawds"
L["settings.visuals.vm_addz.title"] = "Add Z"
L["settings.visuals.vm_addz.desc"] = "Shift de viewmodel up and down"

L["settings.visuals.cambob"] = "Wiew bowobing"
L["settings.visuals.vm_cambob.title"] = "Spwint wiew bowobing"
L["settings.visuals.vm_cambob.desc"] = "Makes youw camewa move when you spwinting"
L["settings.visuals.vm_cambobwalk.title"] = "Walk wiew bowobing"
L["settings.visuals.vm_cambobwalk.desc"] = "Makes youw camewa slightly move when you walking awound (wequiwes spwint bobbing)"
L["settings.visuals.vm_cambobintensity.title"] = "Inwenwity"
L["settings.visuals.vm_cambobintensity.desc"] = "howo intense bobbing will be"

L["settings.visuals.tpik"] = "TPIK"
L["settings.visuals.tpik.title"] = "Enable TPIK"
L["settings.visuals.tpik.desc"] = "TPIK (Thiwd Pewson Invewse Kinematics) is a system that allows most weapons display detailed and same as in fiwst pewson hands positions, weload and fiwing animations in thiwd pewson"
L["settings.visuals.tpik_others.title"] = "Otter Pwayews TPIK"
L["settings.visuals.tpik_others.desc"] = "Show TPIK fow pwaywrs ottew dan uwselw. Negatively impacts pewwowmance."
L["settings.visuals.tpik_framerate.title"] = "TPIK Fwamewate"
L["settings.visuals.tpik_framerate.desc"] = "Maximum fwamewate at which TPIK can wun. Set to 0 fow unlimited"

////////////////////// Bullet Physics
L["settings.tabname.bullets"] = "Buwuwwet Pwysics"

L["settings.bullets.bullets"] = "Bullet Physics"
L["settings.bullets.bullet_physics.title"] = "Physical Bullets"
L["settings.bullets.bullet_physics.desc"] = "Weapons that suppowt dis featuwe will fiwe physical bullets, which have dwop, twavel time, and dwag.\n\ndis is a sewvew wawiableh"
L["settings.bullets.bullet_gravity.title"] = "Gwavity"
L["settings.bullets.bullet_gravity.desc"] = "Multipliew fow bullet gwavity.\n\ndis is a sewvew wawiableh"
L["settings.bullets.bullet_drag.title"] = "Dwag"
L["settings.bullets.bullet_drag.desc"] = "Multipliew fow bullet dwag.\n\ndis is a sewvew wawiableh"
L["settings.bullets.ricochet.title"] = "Wwwicochet"
L["settings.bullets.ricochet.desc"] = "Bullets fiwed fwom select weapons can sometimes bounce off of suwfaces and continue to twavel and do damage.\n\ndis is a sewvew wawiableh"
L["settings.bullets.mod_penetration.title"] = "Penetwation"
L["settings.bullets.mod_penetration.desc"] = "Bullets fiwed fwom select weapons can penetwate suwfaces and deal damage to whatevew is on de odew side.\n\ndis is a sewwew wawiableh"
L["settings.bullets.bullet_lifetime.title"] = "Life Time"
L["settings.bullets.bullet_lifetime.desc"] = "Time in seconds aftew which a bullet will be deleted.\n\ndis is a sewwew wawiableh"
L["settings.bullets.bullet_imaginary.title"] = "Imaginawy Bullets"
L["settings.bullets.bullet_imaginary.desc"] = "Bullets will appeaw to twavel into de skybox, beyond de map's bounds"

////////////////////// Attachments
L["settings.tabname.attachments"] = "Awachmewts"

L["settings.attachments.customization"] = "Customization"
L["settings.attachments.atts_nocustomize.title"] = "Diawawable Customization"
L["settings.attachments.atts_nocustomize.desc"] = "Disallow all customization via de customization menu.\n\ndis is a sewwew wawiableh"
L["settings.attachments.atts_max.title"] = "Max awatachmenws"
L["settings.attachments.atts_max.desc"] = "de maximum numbew of awatachmenws that can be put on a weapon, including cosmetic awatachmenws.\n\ndis is a sewwew wawiableh"
L["settings.attachments.autosave.title"] = "Autosave"
L["settings.attachments.autosave.desc"] = "Youw last weapon customization options will be saved and automatically applied de next time you spawn that weapon"
L["settings.attachments.blacklist.title"] = "Bwackwist Menuwu"
L["settings.attachments.blacklist.open"] = "OwOpen :3"

L["settings.attachments.inventory"] = "Inventowy"
L["settings.attachments.free_atts.title"] = "Fwee awatachmenws"
L["settings.attachments.free_atts.desc"] = "Awatachmenws can be used without being picked up fiwst.\n\ndis is a sewwew wawiableh"
L["settings.attachments.atts_lock.title"] = "One Fow All"
L["settings.attachments.atts_lock.desc"] = "Picking up one instance of an awatachmenws allows you to use it infinite times on all youw guns.\n\ndis is a sewwew wawiableh"
L["settings.attachments.atts_loseondie.title"] = "Lose On Death"
L["settings.attachments.atts_loseondie.desc"] = "Youw attachment inventowy will be lost when you die.\n\ndis is a sewwew wawiableh"
L["settings.attachments.atts_generateentities.title"] = "Genewate Entities"
L["settings.attachments.atts_generateentities.desc"] = "Genewate entities that can be spawned, allowing you to pick up awatachmenws when fwee awatachmenws is off.\n\nMight incwease load time.\n\ndis is a sewwew wawiableh"

////////////////////// Modifiers
L["settings.tabname.modifiers"] = "Modifiews"

L["settings.modifiers.quick.title"] = "Quick Stats Modifiews"
L["settings.modifiers.quick.desc"] = " "

L["settings.mod_damage.title"] = "Damage"
L["settings.mod_spread.title"] = "Spwead"
L["settings.mod_recoil.title"] = "Wecoil"
L["settings.mod_visualrecoil.title"] = "Wusual wecoil"
L["settings.mod_adstime.title"] = "Awaim Dowon Siwts time"
L["settings.mod_sprinttime.title"] = "Spwint To fiwe time"
L["settings.mod_damagerand.title"] = "Dawage Wawiance"
L["settings.mod_muzzlevelocity.title"] = "Nuzzzel welocitwy"
L["settings.mod_rpm.title"] = "RPM"
L["settings.mod_headshotdamage.title"] = "Snout Damage owo"
L["settings.mod_malfunction.title"] = "Mawwunctiwon Chanwce"

////////////////////// Controller
L["settings.tabname.controller"] = "Contwollew"

L["settings.controller.misc"] = "Misc"
L["settings.controller.misc.desc"] = "dewe should be button that will open panel with advanced contwollew config, but fow now it is in  spawnmenu > Options > AwC9 > Contwollew"
L["settings.controller.controller.title"] = "Contwollew Glyphs"
L["settings.controller.controller.desc"] = "Enable custom contwollew-compatible glyphs, showing contwollew buttons instead of de default keys"
L["settings.controller.controller_rumble.title"] = "Wumble"
L["settings.controller.controller_rumble.desc"] = "Enabwe contwowwew wumble as wong as Fesiug's DLL mod is loaded.\n\ngithub.com/Fesiug/\ngmod-sinput"
L["settings.controller.controller_config.title"] = "Advanced config"
L["settings.controller.controller_config.content"] = "Open panel"
L["settings.controller.controller_config.desc"] = "Open advanced contwollew configuwation panel"

L["settings.controller.glyphs.title"] = "Gwyph Type"
L["settings.controller.glyphs.desc"] = "Change which famiwy of gwyphs to uuse..\nSet uwp gwyphs in \"Spawnmenu\" > Owoptions > AWC9 > Contwowwew."

////////////////////// Aim Assist
L["settings.tabname.aimassist"] = "Awim Asist :3"
L["settings.tabname.aimassist.desc"] = "You can enabwe aim assistance if you might have twouble keeping youw aim on youw tawget, ow if you just pwefew to not put effowt into shooting youw tawgets."

L["settings.aimassist.enable.title"] = "Enabwe Awim Assist"
L["settings.aimassist.enable.desc"] = "Enabwes an aim assistance weatuwe dat mowes ur aim towawds a tawget wen awiming neaw dem.\n\nDis is a sewvew wawiable.\n\nWequires Awim Assist to be enabwed on CWIENT."

L["settings.aimassist.enable_general.desc"] = "Enabwes an awim assiwstance featuwe dat mowes us awim towawds a tawget when awiming neaw dem.\n\nConfiguwe it in de \"Awim Assist\" tab."

L["settings.aimassist.enable_client.desc"] = "Enables an aim assist featuwe that slows down youw sensitivity when aiming ovew a valid tawget.\n\nAlso wequiwes Aim Assist to be enabled on SEWWEW."

L["settings.aimassist.intensity.title"] = "Intensity"
L["settings.aimassist.intensity.desc"] = "How intense de aim assist is.\n\ndis is a sewwew wawiableh."

L["settings.aimassist.cone.title"] = "Cowone"
L["settings.aimassist.cone.desc"] = "How close ow faw away you need to look towawds a tawget befowe de aim assist engages.\n\ndis is a sewwew wawiableh."

L["settings.aimassist.head.title"] = "Lowck owonto snouts"
L["settings.aimassist.head.desc"] = "If de aim assist should lock onto de tawgets snout instead of its chest.\n\ndis is a sewwew wawiableh."

L["settings.aimassist.sensmult.desc"] = "Multipwy de lowok sensitivity by dis amount wen hovewing ovew a wawid tawget.\nDe wower de walue, de wower de sensitivity."

////////////////////// Asset Caching
L["settings.tabname.caching"] = "Awwet Cashwing :3"
L["settings.caching.title"] = "Awwet Cawwing uwu"
L["settings.caching.desc"] = "Youw can cawhe some AWC9 awwets (sawe in memowy wwidout woading wwile plawing owo) to pwewent stuttews fow comwowt gameplay uwu\n\nYwou suwely shouwd enable some stuww iw youw gmod wunning on HDD :3"

L["settings.caching.precache_sounds_onfirsttake.title"] = "On fiwst take: Cawhe gun sounds"
L["settings.caching.precache_sounds_onfirsttake.desc"] = "Cawhes aww sounds only fwom gun you just took in hands (excewt weload sounds owo \n\nNow any impactwul, wadew helpful to pwevent stuttews while fiwing owo"

L["settings.caching.precache_attsmodels_onfirsttake.title"] = "On fiwst take: Cawhe aww awatachmenws"
L["settings.caching.precache_attsmodels_onfirsttake.desc"] = "Cawhes aww AWC9 awatachmenws models when any AWC9 uwuweapon was taken in hands uwu\n\nCauses pwetty big fweeze uwu especiawwy when you have lots of wweapons"
L["settings.caching.precache_wepmodels_onfirsttake.title"] = "On fiwst take: Cawhe aww wweapon models"
L["settings.caching.precache_wepmodels_onfirsttake.desc"] = "Cawhes aww AWC9 uwuweapon viewmodels when any AWC9 uwuweapon was taken in hands owo\n\nCauses w-WEALLY BIG fweeze uwu especiawwy when you have lots of wwwweapons"

L["settings.caching.precache_allsounds_onstartup.title"] = "On game stawt: Cawhe aww guns sounds"
L["settings.caching.precache_allsounds_onstartup.desc"] = "Cawhes aww sounds fwom aww guns on sewvew stawt up  (except weload sounds)\n\nNow so impactwul but anyway you bettew use fiwst option hewe uwu"
L["settings.caching.precache_attsmodels_onstartup.title"] = "On game stawt: Cawhe aww awatachmenws"
L["settings.caching.precache_attsmodels_onstartup.desc"] = "Cawhes aww AWC9 awatachmenws models on sewvew stawt up \n\nCauses pwetty big load time incwease especiawwy when you have lots of weapons >w<"
L["settings.caching.precache_wepmodels_onstartup.title"] = "On game stawt: Cawhe aww weapon models"
L["settings.caching.precache_wepmodels_onstartup.desc"] = "Cawhes aww AWC9 uwuweapons viewmodels on sewvew stawt up \n\nCauses wW-WEALLY BIG load time incwease especiawwy when you have lots of weapons awoo"

L["settings.caching.precache_allsounds.title"] = "Aww uwuweapon sounds"
L["settings.caching.precache_wepmodels.title"] = "Aww uwuweapon models"
L["settings.caching.precache_attsmodels.title"] = "Aww awtachmenws models"

L["settings.developer.cache"] = "Cawhe"

////////////////////// Developer
L["settings.tabname.developer"] = "D-dewolpew"

L["settings.developer.developer"] = "Developew Options"
L["settings.developer.dev_always_ready.title"] = "Always weady"
L["settings.developer.dev_always_ready.desc"] = "Always play \"weady\" animation when deploying a weapon.\n\ndis is a sewwew wawiableh"
L["settings.developer.dev_benchgun.title"] = "Benchgun"
L["settings.developer.dev_benchgun.desc"] = "Keep de weapon whewe it cuwrently is"
L["settings.developer.dev_crosshair.title"] = "Deww Cwosshaiw"
L["settings.developer.dev_crosshair.desc"] = "Funky looking cwosshaiw showing de exact point of aim and some useful numbews.\n\ndis is a sewwew wawiableh, and only wowks fow admins - don't get cheaty with dis!"
-- L["settings.developer.dev_show_affectors.title"] = "Display Affectors"
-- L["settings.developer.dev_show_affectors.desc"] = "Displays which current affectors are currently applied.\n\nRequires \"Dev Crosshair\"."
L["settings.developer.dev_show_shield.title"] = "Showo Shield"
L["settings.developer.dev_show_shield.desc"] = "Showo de model fow de playew's shield"
L["settings.developer.dev_greenscreen.title"] = "Gween Scween"
L["settings.developer.dev_greenscreen.desc"] = "Showo a gween scween backgwound in de customisation menu fow scweenshots.\n\nIf you awe using HDR, don't fowget to set mat_bloom_scalefactor_scalar to 0!"
L["settings.developer.reloadatts.title"] = "Weload awatachmenws"
L["settings.developer.reloadlangs.title"] = "Weload Languages"
L["settings.developer.dev_listmyatts.title"] = "List My awatachmenws"
L["settings.developer.dev_listanims.title"] = "List Anims"
L["settings.developer.dev_listbones.title"] = "List Bones"
L["settings.developer.dev_listbgs.title"] = "List Bodygwoups"
L["settings.developer.dev_listatts.title"] = "List QCawatachmenws"
L["settings.developer.dev_listmats.title"] = "List Matewials"
L["settings.developer.dev_export.title"] = "Get ExpoWt Code"
L["settings.developer.dev_getjson.title"] = "Get Weapon JSON"

L["settings.developer.presets_clear.title"] = "Cleaw weapon data"
L["settings.developer.presets_clear.desc"] = "Cleaw pwesets, all icons and default pweset fow weapon you cuwwently holding.\n\nWawning: if menu opened without AwC9 weapon in hands it will delete all existing AwC9 pwesets and icons!"

L["settings.developer.clear"] = "Cleaw"
L["settings.developer.print"] = "Pwint to Console"
L["settings.developer.reload"] = "W-weload"

////////////////////// ARC9 Premium
L["premium.title"] = "ARC9 Premium"
L["premium.desc"] = "ARC9 Premium allows additional customization as a major thanks for supporting the addon financially."

L["premium.requires"] = "Requires <color=255,106,0>ARC9 Premium</color>."
L["premium.acquire"] = "Subscribe to <color=255,106,0>ARC9 Premium</color>"

L["premium.ownedno"] = "<color=255,106,0>ARC9 Premium</color>: <color=255,100,100>Not owned</color>"
L["premium.owned"] = "<color=255,106,0>ARC9 Premium</color>: <color=255,100,100>Owned</color>"

L["premium.help"] = "What is ARC9 Premium?"
L["premium.help.header"] = "Guide to ARC9 Premium"
L["premium.help.desc"] = "Creating addons takes time and resources. ARC9 has always been available for free, and it will remain that way. However, if you wish to support the base financially, you may do so, and get rewarded for it!"

L["premium.help.ownedbutnoaccess"] = "Have you recently purchased ARC9 Premium, but do not have automatic access to it? Contact us on the Diamond Doves Discord Server for assistance.\nEnsure you can provide proof of purchase before contacting. Simply saying \"I buy, now give\" is not good enough."

L["premium.content"] = "Included in <color=255,106,0>ARC9 Premium</color>:"
L["premium.content.list"] = [[
- Unlimited Customization Slots (Increased from 32)
- Unlimited Preset Slots (Increased from 10 per weapon)
- Access to Supermodifier settings*
- Access to an exclusive Dark UI mode
- Ability to colour optic reticles, UI and more
- Exclusive camos made available through the base
- Exclusive support channel on Discord

*Requires administrator if on a server
]]

L["premium.payment.month"] = [[
$%s
Acquire ARC9 Premium for 1 Month.
]]

L["premium.payment.months"] = [[
$%s
Acquire ARC9 Premium for %s Months and get a <color=100,255,100>%s%% discount</color>!
]]

L["premium.payment.info"] = [[
Purchasing ARC9 Premium grants immediate access to all the contents listed previously for the time purchased.
Time can be extended by purchasing any of the options once more, and the time will refresh automatically once the original time has expired.
Once the time has passed, and no additional payment has been made, access to ARC9 Premium will be removed.

All customization options, including attachment slots, presets and coloured reticles made with ARC9 Premium will remain available, but you will not alter them or add any additional ones.
]]

L["premium.purchased"] = "Purchased <color=255,106,0>ARC9 Premium</color>!"
L["premium.purchased.desc"] = [[
Thank you for purchasing ARC9 Premium! You made the bird a very happy one!

A receipt will be sent to your connected Email.

If you have not immediately acquired access to the ARC9 Premium bonuses, please rejoin the server, or restart your game.

If you are still having problems with it, or if you still have not been granted Premium, then do visit the Diamond Doves Discord server and provide valid proof of purchase, and we will have it fixed for you.
]]

--PATH lua/arc9/common/localization/content_base_uwu.lua:
L = {}

//////// Folders
L["folder.arc9"] = "ARC9"
L["folder.arc9.community"] = "Commuwnity"

L["attachment.sticker"] = "Stickew"

//////// Flat Camo
L["camo_arc9_base_flat_od.printname"] = "Owiwe Dwab"
L["camo_arc9_base_flat_od.compactname"] = "OD"
L["camo_arc9_base_flat_od.description"] = "Stwandawt Owiwe Dwab camowowage"

L["camo_arc9_base_flat_deserttan.printname"] = "Desewt Tan"
L["camo_arc9_base_flat_deserttan.compactname"] = "Tan"
L["camo_arc9_base_flat_deserttan.description"] = "Stwandawt Desewt Tan camowowage"

L["camo_arc9_base_flat_arctic.printname"] = "Awktik White"
L["camo_arc9_base_flat_arctic.compactname"] = "Awktik"
L["camo_arc9_base_flat_arctic.description"] = "Stwandawt Awktik Wwite camowowage"

L["camo_arc9_base_flat_black.printname"] = "Factowy Bwack"
L["camo_arc9_base_flat_black.compactname"] = "Bwack"
L["camo_arc9_base_flat_black.description"] = "Stwandawt Factowy Isuwe Bwack."

L["camo_arc9_base_flat_urbangray.printname"] = "UwUrban Gray"
L["camo_arc9_base_flat_urbangray.compactname"] = "UwUrban"
L["camo_arc9_base_flat_urbangray.description"] = "Stwandawt UwUrban Gway camowowage"

L["camo_arc9_base_flat_forestgreen.printname"] = "Fowest Gwin"
L["camo_arc9_base_flat_forestgreen.compactname"] = "Fowest"
L["camo_arc9_base_flat_forestgreen.description"] = "Stwandawt Forest Gwin camowowage"

L["camo_arc9_base_flat_navy.printname"] = "Nawuwu Bwue"
L["camo_arc9_base_flat_navy.compactname"] = "Nawuwu"
L["camo_arc9_base_flat_navy.description"] = "Stwandawt Nawuwu Bwue cowow"

L["camo_arc9_base_flat_mountbattenpink.printname"] = "Mouwuntbaten Pwink"
L["camo_arc9_base_flat_mountbattenpink.compactname"] = "MP"
L["camo_arc9_base_flat_mountbattenpink.description"] = "Stwandawt Mountbatten Pwink camowowage\nShowockingly ewwectiwe in desewt cowondion"

L["camo_arc9_base_flat_fde.printname"] = "Fwat Dawk Eawh"
L["camo_arc9_base_flat_fde.compactname"] = "FDE >w<"
L["camo_arc9_base_flat_fde.description"] = "Stwandawt Fwat Dawk Eawh camowowage"

//////// Flat Colour
L["camo_arc9_base_flat_red.printname"] = "Wed"
L["camo_arc9_base_flat_red.compactname"] = "Wed"
L["camo_arc9_base_flat_red.description"] = "Bawasic wed cowow"

L["camo_arc9_base_flat_orange.printname"] = "OwOnge"
L["camo_arc9_base_flat_orange.compactname"] = "OwOnge"
L["camo_arc9_base_flat_orange.description"] = "Bawasic OwOnge cowow"

L["camo_arc9_base_flat_yellow.printname"] = "Yewoww"
L["camo_arc9_base_flat_yellow.compactname"] = "Yewwoww"
L["camo_arc9_base_flat_yellow.description"] = "Bawasic yewwoww cowow"

L["camo_arc9_base_flat_green.printname"] = "Gwin"
L["camo_arc9_base_flat_green.compactname"] = "Gwin"
L["camo_arc9_base_flat_green.description"] = "Bawasic gween cowow"

L["camo_arc9_base_flat_blue.printname"] = "Bwue"
L["camo_arc9_base_flat_blue.compactname"] = "Bwue"
L["camo_arc9_base_flat_blue.description"] = "Bawasic bwue cowow"

L["camo_arc9_base_flat_purple.printname"] = "Puwpwe"
L["camo_arc9_base_flat_purple.compactname"] = "Puwpwe"
L["camo_arc9_base_flat_purple.description"] = "Bawasic puwpwe cowow"

L["camo_arc9_base_flat_pink.printname"] = "Pwink"
L["camo_arc9_base_flat_pink.compactname"] = "Pwink"
L["camo_arc9_base_flat_pink.description"] = "Ewye seawingwy bwihgt pwink cowow"

L["camo_arc9_base_flat_arc9orange.printname"] = "AWC9 Owange"
L["camo_arc9_base_flat_arc9orange.compactname"] = "AWC9 Owange"
L["camo_arc9_base_flat_arc9orange.description"] = "De pewwekt shawade of owange fow that cUwUte witle AWC9 Wogo stwickew"

//////// Charms
L["charm_gs_killcounter.printname"] = "Kiww Counter"
L["charm_gs_killcounter.compactname"] = "Kiww!!!"
L["charm_gs_killcounter.description"] = "Dewice for twacking ur owoweapon kiww stwats"

L["charm_gs_clock.printname"] = "Bawasic Cwock"
L["charm_gs_clock.compactname"] = "CWOCK"
L["charm_gs_clock.description"] = "Dewice that displays de real-world time."

L["charm_gs_sticker.printname"] = "Stickew Pawnel"
L["charm_gs_sticker.compactname"] = "STICKEW"
L["charm_gs_sticker.description"] = "Dewice that awows a custom stickew to be aplied onto its scween."

//////// Stickers, Base
L["sticker_spray.printname"] = "Playew Spway"
L["sticker_spray.compactname"] = "Spway"
L["sticker_spray.description"] = [[Youw own spway as a stickew!
You will only be able to see youw own and not ones fwom odew playews.

stikew incwuded in de AWC9 base]]

L["sticker_arc9.printname"] = "AWC9 Logo (Low Vis.)"
L["sticker_arc9.compactname"] = "AWC9"
L["sticker_arc9.description"] = [[Dawk vewsion of de AWC9 logo.
desiwgn bwy de Villain.

stikew incwuded in de AWC9 base]]

L["sticker_arc9_lowvis.printname"] = "AWC9 Wogo"
L["sticker_arc9_lowvis.compactname"] = "AWC9"
L["sticker_arc9_lowvis.description"] = [[Hewes to you.
desiwgn bwy de Villain.

stikew incwuded in de AWC9 base]]

L["sticker_a9k.printname"] = "AwCTICTHWON 9.000 WEAPON BASE"
L["sticker_a9k.compactname"] = "Aw9K"
L["sticker_a9k.description"] = [[dis is wat "awc9" actuwuawwy mewans

stikew incwuded in de AWC9 base]]

L["sticker_a9cylo.printname"] = "AWC9 Concept logo by CyloWalkew"
L["sticker_a9cylo.compactname"] = "A9 Cylo"
L["sticker_a9cylo.description"] = [[One of de fiwst concepts fow AWC9 logo/icon by CyloWalkew (hes cool!)

stikew incwuded in de AWC9 base]]

L["sticker_sus9.printname"] = "Sus 9"
L["sticker_sus9.compactname"] = "Sus 9"
L["sticker_sus9.description"] = [[de impostow could be anywhewe among us...
desiwgn bwy Darsuw.

stikew incwuded in de AWC9 base]]

//////// Stickers, Com. Wave 1
L["sticker_alien_lean.printname"] = "Wegawize Alien Wean"
L["sticker_alien_lean.compactname"] = "Awien wean"
L["sticker_alien_lean.description"] = [[Hop dow to Agawtha wit de wite boys fow a cup of awien wean and... odew things.
desiwgn bwy Opt1ca.

stikew incwuded in de AWC9 base]]

L["sticker_tomatocat.printname"] = "Towomato kity"
L["sticker_tomatocat.compactname"] = "Towomato kity"
L["sticker_tomatocat.description"] = [[Sometimes peple ask whedew tomatoes awe fwuits ow wegetwables... dis one migt be a touwughew quwestion.
desiwgn bwy Endew2Point0.

stikew incwuded in de AWC9 base]]

L["sticker_actionbird.printname"] = "Action biwb"
L["sticker_actionbird.compactname"] = "Action biwb"
L["sticker_actionbird.description"] = [[dis is wat Awktik wooks wike in weal wife.
desiwgn bwy CyloWalkew.

stikew incwuded in de AWC9 base]]

L["sticker_warcrimes.printname"] = "Waw Cwimes"
L["sticker_warcrimes.compactname"] = "Waw Cwimes"
L["sticker_warcrimes.description"] = [[Ur awweady doing dem, so why not showt it out woud? Whos gonna stop you  de UwUN?
desiwgn bwy Wimuchii. Made using Pwoject Sekai stickew base.

stikew incwuded in de AWC9 base]]

L["sticker_sillycat.printname"] = "Siwwy kity"
L["sticker_sillycat.compactname"] = "Siwwy kity"
L["sticker_sillycat.description"] = [[imsillyimsillyimsillyimsillyimsillyimsillyimsillyimsilly
desiwgn bwy Stan_Jacobs.

stikew incwuded in de AWC9 base]]

L["sticker_muertosskull.printname"] = "Dia De Los Muewtos Calavewa"
L["sticker_muertosskull.compactname"] = "Los Muewtos"
L["sticker_muertosskull.description"] = [["dis showuld be my winal wewsion i think unless anywone giwes me sugestions to change it de name: "Dia de los muewtos calavewa" de descwiption i cant think of one something about day of de dewad skull mexico bwah bwah bleh"
desiwgn bwy wooneyviz.

stikew incwuded in de AWC9 base]]

L["sticker_bandaid.printname"] = "Band-Aid"
L["sticker_bandaid.compactname"] = "Band-Aid"
L["sticker_bandaid.description"] = [[Puwut it on youw booboo and kiss it aww bettew
desiwgn bwy Itzal.

stikew incwuded in de AWC9 base]]

L["sticker_peacedove.printname"] = "Peace Thwough Supewiow Fiwepowew"
L["sticker_peacedove.compactname"] = "PTSF"
L["sticker_peacedove.description"] = [[de dove bwings peace but de gun bwings peace thwough supewiow fiwepowew
desiwgn bwy Xipil.

stikew incwuded in de AWC9 base]]

L["sticker_borntomodify.printname"] = "Bown To Modiwy"
L["sticker_borntomodify.compactname"] = "BTM"
L["sticker_borntomodify.description"] = [[Anodew siht - anodew scope - a gwenade launchew uwu, hewe and dewe... owo
desiwgn bwy Duck.

stikew incwuded in de AWC9 base]]

L["sticker_cad.printname"] = "cad"
L["sticker_cad.compactname"] = "cad"
L["sticker_cad.description"] = [[cad
desiwgn bwy Opt1ca.

stikew incwuded in de AWC9 base]]

L["sticker_fumo.printname"] = "Fumo"
L["sticker_fumo.compactname"] = "Fumo"
L["sticker_fumo.description"] = [[D-don't look at me like that, waifu-kun...
desiwgn bwy Itzal.

stikew incwuded in de AWC9 base]]

L["sticker_hotlead.printname"] = "Hot Lead"
L["sticker_hotlead.compactname"] = "Hot Lead"
L["sticker_hotlead.description"] = [[Caweful! It's hot!
desiwgn bwy Awqu.

stikew incwuded in de AWC9 base]]

L["sticker_steamhappy.printname"] = ":steamhappy:"
L["sticker_steamhappy.compactname"] = ":steamhappy:"
L["sticker_steamhappy.description"] = [[Happy abowut it
Design fwom Steam.

stikew incwuded in de AWC9 base]]

L["sticker_amidstus.printname"] = "Amidstus"
L["sticker_amidstus.compactname"] = "Amidstus"
L["sticker_amidstus.description"] = [[y setwe fow de owiginal when you could have a cheap knockoff?!
desiwgn fwom OwOptica.

stikew incwuded in de AWC9 base]]

L["sticker_arcglory.printname"] = "Glowy!"
L["sticker_arcglory.compactname"] = "Glorwy!"
L["sticker_arcglory.description"] = [[Took nine bwain cells to scwibble dis
desiwgn fwom OwOptica.

stikew incwuded in de AWC9 base]]

L["sticker_wp.printname"] = "Wowld Peece!"
L["sticker_wp.compactname"] = "Wowld Piss!"
L["sticker_wp.description"] = [[A delusion!
desiwgn fwom Fidget.

stikew incwuded in de AWC9 base]]

L["sticker_tonkr.printname"] = "Swend It"
L["sticker_tonkr.compactname"] = "Sewnd It"
L["sticker_tonkr.description"] = [[Yewah its that heawy. Yweah its that powewful.
desiwgn fwom CyloWalkew.

stikew incwuded in de AWC9 base]]

L["sticker_s6amblem.printname"] = "Swection 6"
L["sticker_s6amblem.compactname"] = "Sewction 6"
L["sticker_s6amblem.description"] = [[Weach fow de staws. Fowwawd to Glowy!
desiwgn fwom CyloWalkew.

stikew incwuded in de AWC9 base]]

L["sticker_babies.printname"] = "Baby Hazawd"
L["sticker_babies.compactname"] = "Baby Hazawd"
L["sticker_babies.description"] = [[Childwen ages 0-3 should be kept away fwom dis.. fiweawm
desiwgn fwom Itzal.

stikew incwuded in de AWC9 base]]

L["sticker_drawberf.printname"] = "Bewf"
L["sticker_drawberf.compactname"] = "Beww"
L["sticker_drawberf.description"] = [[Dwaw Bewf.
desiwgn bwy de Villain.

stikew incwuded in de AWC9 base]]

L["sticker_arcbird.printname"] = "Awc Biwb"
L["sticker_arcbird.compactname"] = "Awc Biwb"
L["sticker_arcbird.description"] = [[Awc Biwb.
desiwgn bwy Nowi/Chewable.

stikew incwuded in de AWC9 base]]

--PATH lua/arc9/shared/sh_ammo.lua:
return gluapack()()
--PATH lua/arc9/shared/sh_attinv.lua:
local arc9_free_atts = GetConVar("arc9_free_atts")
local arc9_atts_lock = GetConVar("arc9_atts_lock")
local arc9_atts_loseondie = GetConVar("arc9_atts_loseondie")

function ARC9:PlayerGetAtts(ply, att)
    if !IsValid(ply) then return 0 end
    if arc9_free_atts:GetBool() then return 999 end

    if att == "" then return 999 end

    local atttbl = ARC9.GetAttTable(att)

    if !atttbl then return 0 end

    if atttbl.Free then return 999 end

    if !IsValid(ply) or !ply:IsPlayer() then return end

    if !ply:IsAdmin() and atttbl.AdminOnly then
        return 0
    end

    if atttbl.InvAtt then att = atttbl.InvAtt end

    if !ply.ARC9_AttInv then return 0 end

    if !ply.ARC9_AttInv[att] then return 0 end

    return ply.ARC9_AttInv[att]
end

function ARC9:PlayerGiveAtt(ply, att, amt)
    amt = amt or 1

    if !IsValid(ply) or !ply:IsPlayer() then return end

    if !ply.ARC9_AttInv then
        ply.ARC9_AttInv = {}
    end

    local atttbl = ARC9.GetAttTable(att)

    if !atttbl then return end
    if atttbl.Free then return end -- You can't give a free attachment, silly
    if atttbl.AdminOnly and !(ply:IsPlayer() and ply:IsAdmin()) then return false end

    if atttbl.InvAtt then att = atttbl.InvAtt end

    if arc9_atts_lock:GetBool() then
        if ply.ARC9_AttInv[att] == 1 then return end
        ply.ARC9_AttInv[att] = 1
    else
        ply.ARC9_AttInv[att] = (ply.ARC9_AttInv[att] or 0) + amt
    end
end

function ARC9:PlayerTakeAtt(ply, att, amt)
    amt = amt or 1

    if arc9_atts_lock:GetBool() then return end

    if !IsValid(ply) or !ply:IsPlayer() then return end

    if !ply.ARC9_AttInv then
        ply.ARC9_AttInv = {}
    end

    local atttbl = ARC9.GetAttTable(att)
    if !atttbl or atttbl.Free then return end

    if atttbl.InvAtt then att = atttbl.InvAtt end

    ply.ARC9_AttInv[att] = ply.ARC9_AttInv[att] or 0

    if ply.ARC9_AttInv[att] < amt then
        return false
    end

    ply.ARC9_AttInv[att] = ply.ARC9_AttInv[att] - amt
    if ply.ARC9_AttInv[att] <= 0 then
        ply.ARC9_AttInv[att] = nil
    end
    return true
end

if CLIENT then

net.Receive("ARC9_sendattinv", function(len, ply)
    LocalPlayer().ARC9_AttInv = {}

    local count = net.ReadUInt(32)

    for i = 1, count do
        local attid = net.ReadUInt(ARC9.Attachments_Bits)
        local acount = net.ReadUInt(32)

        local att = ARC9.Attachments_Index[attid]

        LocalPlayer().ARC9_AttInv[att] = acount
    end
end)

elseif SERVER then

hook.Add("PlayerDeath", "ARC9_DeathAttInv", function(ply)
    -- if GetConVar("arc9_atts_loseondie"):GetBool() then
    --     ply.ARC9_AttInv = ply.ARC9_AttInv or {}
    -- end
    -- if table.Count(ply.ARC9_AttInv) > 0
    --         and GetConVar("arc9_atts_loseondie"):GetInt() >= 2
    --         and !GetConVar("arc9_free_atts"):GetBool() then
    --     local boxEnt = ents.Create("ARC9_att_dropped")
    --     boxEnt:SetPos(ply:GetPos() + Vector(0, 0, 4))
    --     boxEnt.GiveAttachments = ply.ARC9_AttInv
    --     boxEnt:Spawn()
    --     boxEnt:SetNWString("boxname", ply:GetName() .. "'s Death Box")
    --     local count = 0
    --     for i, v in pairs(boxEnt.GiveAttachments) do count = count + v end
    --     boxEnt:SetNWInt("boxcount", count)
    -- end
end)

hook.Add("PlayerSpawn", "ARC9_SpawnAttInv", function(ply, trans)
    if trans then return end

    if arc9_atts_loseondie:GetInt() >= 1 then
        ply.ARC9_AttInv = {}

        ARC9:PlayerSendAttInv(ply)
    end
end)

function ARC9:PlayerSendAttInv(ply)
    if arc9_free_atts:GetBool() then return end

    if !IsValid(ply) then return end

    if !ply.ARC9_AttInv then return end

    net.Start("ARC9_sendattinv")

    net.WriteUInt(table.Count(ply.ARC9_AttInv), 32)

    for att, count in pairs(ply.ARC9_AttInv) do
        local atttbl = ARC9.GetAttTable(att)
        local attid = atttbl.ID
        net.WriteUInt(attid, ARC9.Attachments_Bits)
        net.WriteUInt(count, 32)
    end

    net.Send(ply)
end

end

--PATH lua/arc9/common/attachments_bulk/charms_default.lua:
return gluapack()()
--PATH lua/arc9/shared/sh_gunutils.lua:
return gluapack()()
--PATH lua/arc9/shared/sh_move.lua:
ARC9.LastEyeAngles = Angle(0, 0, 0)
ARC9.RecoilRise = Angle(0, 0, 0)

function ARC9.Move(ply, mv, cmd)
    local wpn = ply:GetActiveWeapon()

    if !wpn.ARC9 then return end

    local basespd = (Vector(cmd:GetForwardMove(), cmd:GetUpMove(), cmd:GetSideMove())):Length()
    basespd = math.min(basespd, mv:GetMaxClientSpeed())

    local mult = wpn:GetProcessedValue("Speed", nil, 1)

    if wpn:GetSightAmount() > 0 then
        if ply:KeyDown(IN_SPEED) then
            mult = mult / Lerp(wpn:GetSightAmount(), 1, ply:GetRunSpeed() / ply:GetWalkSpeed()) * (wpn:HoldingBreath() and 0.5 or 1)
        end
    -- else
    --     if wpn:GetTraversalSprint() then
    --         mult = 1
    --     end
    end

    mv:SetMaxSpeed(basespd * mult)
    mv:SetMaxClientSpeed(basespd * mult)

    if wpn:GetInMeleeAttack() and wpn:GetLungeEntity():IsValid() then
        mv:SetMaxSpeed(10000)
        mv:SetMaxClientSpeed(10000)
        local targetpos = wpn:GetLungeEntity():EyePos()
        targetpos.z = math.min(targetpos.z, ply:EyePos().z) --wontt make you jump if you attack while in crouch
        local lungevec = targetpos - ply:EyePos()
        local lungedir = lungevec:GetNormalized()
        local lungedist = lungevec:Length()
        local lungespd = (2 * (lungedist / math.Max(0.01, wpn:GetProcessedValue("PreBashTime", true))))
        mv:SetVelocity(lungedir * lungespd)
    end

    if wpn:GetBipod() then
        if ply:Crouching() then
            cmd:AddKey(IN_DUCK)
            mv:AddKey(IN_DUCK)
        else
            cmd:RemoveKey(IN_DUCK)
            local buttons = mv:GetButtons()
            buttons = bit.band(buttons, bit.bnot(IN_DUCK))
            mv:SetButtons(buttons)
        end
    end

    if cmd:GetImpulse() == ARC9.IMPULSE_TOGGLEATTS then
        if !wpn:StillWaiting() and !wpn:GetUBGL() then
            ply:EmitSound(wpn:RandomChoice(wpn:GetProcessedValue("ToggleAttSound", true)), 75, 100, 1, CHAN_ITEM)
            wpn:PlayAnimation("toggle")
        end
    end
end

hook.Add("SetupMove", "ARC9.SetupMove", ARC9.Move)

ARC9.RecoilTimeStep = 0.03

ARC9.ClientRecoilTime = 0

ARC9.ClientRecoilUp = 0
ARC9.ClientRecoilSide = 0

ARC9.ClientRecoilProgress = 0

local ARC9_cheapscopes = GetConVar("ARC9_cheapscopes")

local function approxEqualsZero(a)
    return math.abs(a) < 0.0001
end

local function tgt_pos(ent, head) -- From ArcCW
    local mins, maxs = ent:WorldSpaceAABB()
    local pos = ent:WorldSpaceCenter()
    pos.z = pos.z + (maxs.z - mins.z) * 0.2 -- Aim at chest level
    if head and ent:GetAttachment(ent:LookupAttachment("eyes")) ~= nil then
        pos = ent:GetAttachment(ent:LookupAttachment("eyes")).Pos
    end
    return pos
end

local arc9_aimassist_cone = GetConVar("arc9_aimassist_cone")
local arc9_aimassist_distance = GetConVar("arc9_aimassist_distance")
local arc9_aimassist_intensity = GetConVar("arc9_aimassist_intensity")
local arc9_aimassist_head = GetConVar("arc9_aimassist_head")
local arc9_aimassist = GetConVar("arc9_aimassist")
local arc9_aimassist_lockon = GetConVar("arc9_aimassist_lockon")

function ARC9.StartCommand(ply, cmd)
    if !IsValid(ply) or cmd:CommandNumber() == 0 then return end
    -- commandnumber may reduce inaccurate inputs on client

    local wpn = ply:GetActiveWeapon()


    -- quicknade code before anti nonarc9 check
    -- TOO BAD  IN MULTIPLAYER
    -- if cmd:KeyDown(IN_GRENADE1) and ply:Alive() then
    --     local switchto = ply.ARC9LastSelectedGrenade or false

    --     if !switchto or !ply:HasWeapon(switchto) then 
    --         print("roll")
    --         for _, v in ipairs(ply:GetWeapons()) do
    --             if v.IsQuickGrenade then switchto = v:GetClass() break end
    --         end
    --     end

    --     if switchto and ply:GetActiveWeapon() != switchto and ply:HasWeapon(switchto) then
    --         print("select")
    --         ply.ARC9QuickthrowPls = true
    --         -- ply:ConCommand("use " .. switchto)
    --         -- ply:SelectWeapon(switchto) -- idk which way better
    --         local possiblewep = ply:GetWeapon(switchto)
    --         if IsValid(possiblewep) then cmd:SelectWeapon(possiblewep) end
    --     end
    -- end
    -- end

    
    if !wpn.ARC9 then ARC9.RecoilRise = Angle(0, 0, 0) return end

    if ply:IsBot() then timescalefactor = 1 end -- ping is infinite for them lol
	
    -- Aim assist imported from ArcCW
    if CLIENT and IsValid(wpn) then
		local cone = arc9_aimassist_cone:GetFloat()
		-- local dist = arc9_aimassist_distance:GetFloat() * (wpn:GetProcessedValue("AARangeMult") or 1)
		local dist = math.min(wpn.RangeMax * 0.95, 4000) -- 4000hu is somewhat about 100m
		local inte = arc9_aimassist_intensity:GetFloat()
		local head = arc9_aimassist_head:GetBool()

		-- Check if current target is beyond tracking cone
		local tgt = ply.ARC9_AATarget
		if IsValid(tgt) and (tgt_pos(tgt, head) - ply:EyePos()):Cross(ply:EyeAngles():Forward()):Length() > cone * 2 then ply.ARC9_AATarget = nil end -- lost track

		-- Try to seek target if not exists
		tgt = ply.ARC9_AATarget
		if !IsValid(tgt) or (tgt.Health and tgt:Health() <= 0) or util.QuickTrace(ply:EyePos(), tgt_pos(tgt, head) - ply:EyePos(), ply).Entity ~= tgt then
			local min_diff
			ply.ARC9_AATarget = nil
			-- for _, ent in ipairs(ents.FindInCone(ply:EyePos(), ply:EyeAngles():Forward(), 244, math.cos(math.rad(cone)))) do
			for _, ent in ipairs(ents.FindInCone(ply:EyePos(), ply:EyeAngles():Forward(), dist, math.cos(math.rad(cone)))) do
				if ent == ply or (!ent:IsNPC() and !ent:IsNextBot() and !ent:IsPlayer()) or ent:Health() <= 0
						or (ent:IsPlayer() and ent:Team() ~= TEAM_UNASSIGNED and ent:Team() == ply:Team()) then continue end
				local tr = util.TraceLine({
					start = ply:EyePos(),
					endpos = tgt_pos(ent, head),
					mask = MASK_SHOT,
					filter = ply
				})
				if tr.Entity ~= ent then continue end
				local diff = (tgt_pos(ent, head) - ply:EyePos()):Cross(ply:EyeAngles():Forward()):Length()
				if !ply.ARC9_AATarget or diff < min_diff then
					ply.ARC9_AATarget = ent
					min_diff = diff
				end
			end
		end

		-- Aim towards target
		tgt = ply.ARC9_AATarget
		if arc9_aimassist:GetBool() and ply:GetInfoNum("arc9_aimassist_cl", 0) == 1 then
			if IsValid(tgt) and !wpn:GetCustomize() then
                if !wpn:GetProcessedValue("NoAimAssist", true) then
                    local ang = cmd:GetViewAngles()
                    local pos = tgt_pos(tgt, head)
                    local tgt_ang = (pos - ply:EyePos()):Angle()
                    local ang_diff = (pos - ply:EyePos()):Cross(ply:EyeAngles():Forward()):Length()
                    if ang_diff > 0.1 then
                        ang = LerpAngle(math.Clamp(inte / ang_diff, 0, 1), ang, tgt_ang)
                        cmd:SetViewAngles(ang)
                    end
                end
			end
		end
    end
	
    if wpn:GetBipod() then
        local bipang = wpn:GetBipodAng()

        local eyeang = cmd:GetViewAngles()

        if math.AngleDifference(bipang.y, eyeang.y) < -40 then
            eyeang.y = bipang.y + 40
        elseif math.AngleDifference(bipang.y, eyeang.y) > 40 then
            eyeang.y = bipang.y - 40
        end

        if math.AngleDifference(bipang.p, eyeang.p) > 15 then
            eyeang.p = bipang.p - 15
        elseif math.AngleDifference(bipang.p, eyeang.p) < -15 then
            eyeang.p = bipang.p + 15
        end

        cmd:SetViewAngles(eyeang)

        if game.SinglePlayer() then
            ply:SetEyeAngles(eyeang)
        end
    end

    local isScope = wpn:IsUsingRTScope()

    if isScope then
        local swayspeed = 2
        local swayamt = wpn:GetFreeSwayAmount()
        local swayang = Angle(math.sin(CurTime() * 0.6 * swayspeed) + (math.cos(CurTime() * 2) * 0.5), math.sin(CurTime() * 0.4 * swayspeed) + (math.cos(CurTime() * 1.6) * 0.5), 0)

        swayang = swayang * wpn:GetSightAmount() * swayamt * 0.2

        local eyeang = cmd:GetViewAngles()

        eyeang.p = eyeang.p + (swayang.p * FrameTime())
        eyeang.y = eyeang.y + (swayang.y * FrameTime())

        cmd:SetViewAngles(eyeang)
    end

    if wpn:GetProcessedValue("NoSprintWhenLocked", true) and wpn:GetAnimLockTime() > CurTime() then
        cmd:RemoveKey(IN_SPEED)
    end

    if wpn.InertiaEnabled then
        wpn.InertiaSideMoveRaw = cmd:GetSideMove() * 0.0015
    end

    local eyeang = cmd:GetViewAngles()

    if eyeang.p != eyeang.p then eyeang.p = 0 end
    if eyeang.y != eyeang.y then eyeang.y = 0 end
    if eyeang.r != eyeang.r then eyeang.r = 0 end

    local m = 25

    if CLIENT then
        local diff = ARC9.LastEyeAngles - cmd:GetViewAngles()
        local recrise = ARC9.RecoilRise
        
        if !wpn.RecoilAutoControl_DontTryToReturnBack then
            -- 0 can be negative or positive!!!!! Insane
            if approxEqualsZero(recrise.p) then
            elseif recrise.p > 0 then
                recrise.p = math.Clamp(recrise.p, 0, recrise.p - diff.p)
            elseif recrise.p < 0 then
                recrise.p = math.Clamp(recrise.p, recrise.p - diff.p, 0)
            end

            if approxEqualsZero(recrise.y) then
            elseif recrise.y > 0 then
                recrise.y = math.Clamp(recrise.y, 0, recrise.y - diff.y)
            elseif recrise.y < 0 then
                recrise.y = math.Clamp(recrise.y, recrise.y - diff.y, 0)
            end
        end

        recrise:Normalize()

        ARC9.RecoilRise = recrise

        local catchup = 0

        if ARC9.ClientRecoilTime < CurTime() then
            ARC9.ClientRecoilUp = wpn:GetRecoilUp() * ARC9.RecoilTimeStep
            ARC9.ClientRecoilSide = wpn:GetRecoilSide() * ARC9.RecoilTimeStep

            ARC9.ClientRecoilTime = CurTime() + ARC9.RecoilTimeStep

            if ARC9.ClientRecoilProgress < 1 then
                catchup = ARC9.RecoilTimeStep * (1 - ARC9.ClientRecoilProgress)
            end

            ARC9.ClientRecoilProgress = 0
        end

        local cft = math.min(FrameTime(), ARC9.RecoilTimeStep)

        local progress = cft / ARC9.RecoilTimeStep

        if progress > 1 - ARC9.ClientRecoilProgress then
            cft = (1 - ARC9.ClientRecoilProgress) * ARC9.RecoilTimeStep
            progress = (1 - ARC9.ClientRecoilProgress)
        end

        cft = cft + catchup

        ARC9.ClientRecoilProgress = ARC9.ClientRecoilProgress + progress

        if math.abs(ARC9.ClientRecoilUp) > 1e-5 then
            eyeang.p = eyeang.p + ARC9.ClientRecoilUp * m * cft / ARC9.RecoilTimeStep
        end

        if math.abs(ARC9.ClientRecoilSide) > 1e-5 then
            eyeang.y = eyeang.y + ARC9.ClientRecoilSide * m * cft / ARC9.RecoilTimeStep
        end

        local diff_p = ARC9.ClientRecoilUp * m * cft / ARC9.RecoilTimeStep
        local diff_y = ARC9.ClientRecoilSide * m * cft / ARC9.RecoilTimeStep

        ARC9.RecoilRise = ARC9.RecoilRise + Angle(diff_p, diff_y, 0)

        local recreset = ARC9.RecoilRise * wpn:GetProcessedValue("RecoilAutoControl", true) * cft * 2

        if math.abs(recreset.p) > 1e-5 then
            eyeang.p = eyeang.p - recreset.p
        end

        if math.abs(recreset.y) > 1e-5 then
            eyeang.y = eyeang.y - recreset.y
        end

        ARC9.RecoilRise = ARC9.RecoilRise - Angle(recreset.p, recreset.y, 0)

        ARC9.RecoilRise:Normalize()

        cmd:SetViewAngles(eyeang)

        ARC9.LastEyeAngles = eyeang
    end

    if cmd:GetImpulse() == 100 and wpn:CanToggleAllStatsOnF() and !wpn:GetCustomize() then
        if !wpn:GetReloading() and !wpn:GetUBGL() then
            ply:EmitSound(wpn:RandomChoice(wpn:GetProcessedValue("ToggleAttSound", true)), 75, 100, 1, CHAN_ITEM)
            if CLIENT then
                wpn:ToggleAllStatsOnF()
            end
        end

        cmd:SetImpulse(ARC9.IMPULSE_TOGGLEATTS)
    end

    local maus = cmd:GetMouseWheel()
    if wpn:GetInSights() and cmd:GetMouseWheel() != 0 then
        if ply:KeyDown(IN_USE) and #wpn.MultiSightTable > 0 and !wpn:StillWaiting() then
            wpn:SwitchMultiSight(maus) -- switchsights is hardcoded to scroll wheel and can't be dealt with using invnext/invprev atm
        elseif CLIENT and (maus < 0 and !input.LookupBinding("invnext") or maus > 0 and !input.LookupBinding("invprev")) then
            wpn:Scroll(-maus) -- if invnext is bound use those, if not then use mouse wheel
        end
    end
end

hook.Add("StartCommand", "ARC9_StartCommand", ARC9.StartCommand)



hook.Add("KeyPress", "ARC9_Quickgrenade", function( ply, key )
    if SERVER then
        if key == IN_GRENADE1 and ply:Alive() then
            local switchto = ply.ARC9LastSelectedGrenade or false

            if !switchto or !ply:HasWeapon(switchto) then 
                for _, v in ipairs(ply:GetWeapons()) do
                    if v.IsQuickGrenade then switchto = v:GetClass() break end
                end
            end

            if switchto and ply:GetActiveWeapon() != switchto and ply:HasWeapon(switchto) then
                ply.ARC9QuickthrowPls = true
                -- ply:ConCommand("use " .. switchto)
                ply:SelectWeapon(switchto) -- idk which way better
            end
        end
	end
end)
--PATH lua/arc9/client/cl_favorites.lua:
ARC9.Favorites = {}

ARC9.FavoritesWeight = 99999
ARC9.UnownedWeight = -9999

function ARC9:LoadFavorites()
    local f = file.Open("arc9_favorites.txt", "r", "DATA")
    if !f then return end

    ARC9.Favorites = {}

    while !f:EndOfFile() do
        local line = f:ReadLine()
        line = string.Trim(line, "\n")

        ARC9.Favorites[line] = true
    end

    f:Close()
end

function ARC9:SaveFavorites()
    local f = file.Open("arc9_favorites.txt", "w", "DATA")

    for i, k in pairs(ARC9.Favorites) do
        f:Write(i)
        f:Write("\n")
    end

    f:Close()
end

function ARC9:AddAttToFavorites(att)
    ARC9.Favorites[att] = true
    ARC9:SaveFavorites()
end

function ARC9:RemoveAttFromFavorites(att)
    ARC9.Favorites[att] = nil
    ARC9:SaveFavorites()
end

function ARC9:ToggleFavorite(att)
    if ARC9.Favorites[att] then
        ARC9.Favorites[att] = nil
        surface.PlaySound("arc9/newui/ui_part_favourite2.ogg")
    else
        ARC9.Favorites[att] = true
        surface.PlaySound("arc9/newui/ui_part_favourite1.ogg")
    end
    ARC9:SaveFavorites()
end

hook.Add("PreGamemodeLoaded", "ARC9_PreGamemodeLoaded_LoadFavorites", function()
    ARC9:LoadFavorites()
end)
--PATH lua/arc9/client/cl_garbage.lua:
ARC9.CSModelPile    = {} -- { {Model = NULL, Weapon = NULL} }
ARC9.FlashlightPile = {}

function ARC9.CollectGarbage()
    local removed = 0
    local kept = 0
    local newpile = {}

    for _, k in ipairs(ARC9.CSModelPile) do
        if IsValid(k.Weapon) and k.Weapon.ModelVersion == k.Version then
            -- table.insert(newpile, k)
            kept = kept + 1
            newpile[kept] = k
            continue
        end

        SafeRemoveEntity(k.Model)

        removed = removed + 1
    end

    ARC9.CSModelPile = newpile
    
    if ARC9.Dev(2) then
        if removed > 0 then
            print("ARC9 GC: Removed " .. tostring(removed) .. " CSModels")
        else
            -- print("ARC9 GC: Nothing removed")
        end
    end
end

hook.Add("PostCleanupMap", "ARC9.CleanGarbage", function()
    ARC9.CollectGarbage()
end)

timer.Create("ARC9 CSModel Garbage Collector", 5, 0, ARC9.CollectGarbage)

hook.Add("PostDrawEffects", "ARC9_CleanFlashlights", function()
    local newflashlightpile = {}

    for _, k in ipairs(ARC9.FlashlightPile) do
        if IsValid(k.Weapon) and k.Weapon == LocalPlayer():GetActiveWeapon() then
            table.insert(newflashlightpile, k)

            continue
        end

        if k.ProjectedTexture and k.ProjectedTexture:IsValid() then
            k.ProjectedTexture:Remove()
        end
    end

    ARC9.FlashlightPile = newflashlightpile

    -- local wpn = LocalPlayer():GetActiveWeapon()

    -- if !wpn then return end
    -- if !IsValid(wpn) then return end
    -- if !wpn.ARC9 then return end

    -- if GetViewEntity() == LocalPlayer() then return end

    -- wpn:KillFlashlights()
end)
--PATH lua/arc9/client/cl_hudbob.lua:
return gluapack()()
--PATH lua/arc9/client/cl_net.lua:
net.Receive("ARC9_networkweapon", function(len, ply)
    local wpn = net.ReadEntity()

    if !IsValid(wpn) then return end
    if !wpn.ARC9 then return end

    wpn:ReceiveWeapon()
end)

net.Receive("arc9_proppickup", function(len)
    local ent = net.ReadEntity()
    if !IsValid(ent) then return end
    LocalPlayer().ARC9_HoldingProp = ent
end)

net.Receive("arc9_stoppickup", function(len)
    LocalPlayer().ARC9_HoldingProp = nil
end)

net.Receive("arc9_sendnpckill", function(len)
    local ent = net.ReadEntity()

    local wpn = LocalPlayer():GetActiveWeapon()
    if IsValid(wpn) and wpn.ARC9 then
        wpn:RunHook("Hook_OnKill", ent)
    end
end)
--PATH lua/arc9/client/cl_subcategories.lua:
-- This script adds support for weapon subcategories in Sandbox's
-- weapons tab.
-- Most of the code here is taken straight from Sandbox's source 
-- code. Specifically, it's taken from:
-- sandbox/gamemode/spawnmenu/creationmenu/content/contenttypes/weapons.lua
-- All I did was tweak the category table to also have support for
-- subcategories.
-- The way it works is that is checks each SWEP for the line
-- SWEP.SubCategory = ...
-- If it does not exist, it adds the weapon to the "Other" 
-- subcategory. However, if only one subcategory exists in each
-- category, then it doesn't print any subtitle as it's redundant.
-- Writted by Buu342, Still a work in progress.


-- I HATE GARRY NEWMAN

hook.Add("PopulateWeapons", "zzz_ARC9_SubCategories", function(pnlContent, tree, anode)

    timer.Simple(0, function()
        -- Loop through the weapons and add them to the menu
        local Weapons = list.Get("Weapon")
        local Categorised = {}
        local ARC9Cats = {}

        local truenames = ARC9:UseTrueNames()

        -- Build into categories + subcategories
        for k, weapon in pairs(Weapons) do
            if !weapon.Spawnable then continue end
            if !weapons.IsBasedOn(k, "arc9_base") then continue end

            -- Get the weapon category as a string
            local Category = weapon.Category or "Other2"
            local WepTable = weapons.Get(weapon.ClassName)
            if (!isstring(Category)) then
                Category = tostring(Category)
            end

            -- Get the weapon subcategory as a string
            local SubCategory = "Other"
            if (WepTable != nil and WepTable.SubCategory != nil) then
                SubCategory = WepTable.SubCategory
                if (!isstring(SubCategory)) then
                    SubCategory = tostring(SubCategory)
                end
            end

            if truenames and WepTable.TrueName then
                weapon.PrintName = WepTable.TrueName
            end

            -- Insert it into our categorised table
            Categorised[Category] = Categorised[Category] or {}
            Categorised[Category][SubCategory] = Categorised[Category][SubCategory] or {}
            table.insert(Categorised[Category][SubCategory], weapon)
            ARC9Cats[Category] = true
        end

        -- Iterate through each category in the weapons table
        for _, node in pairs(tree:Root():GetChildNodes()) do

            if !ARC9Cats[node:GetText()] then continue end

            -- Get the subcategories registered in this category
            local catSubcats = Categorised[node:GetText()]

            if !catSubcats then continue end

            -- Overwrite the icon populate function with a custom one
            node.DoPopulate = function(self)

                -- If we've already populated it - forget it.
                -- if (self.PropPanel) then return end

                -- Create the container panel
                self.PropPanel = vgui.Create("ContentContainer", pnlContent)
                self.PropPanel:SetVisible(false)
                self.PropPanel:SetTriggerSpawnlistChange(false)

                -- Iterate through the subcategories
                for subcatName, subcatWeps in SortedPairs(catSubcats) do

                    -- Create the subcategory header, if more than one exists for this category
                    if (table.Count(catSubcats) > 1) then
                        local label = vgui.Create("ContentHeader", container)
                        label:SetText(subcatName)
                        self.PropPanel:Add(label)
                    end

                    -- Create the clickable icon
                    for _, ent in SortedPairsByMemberValue(subcatWeps, "PrintName") do
                        spawnmenu.CreateContentIcon(ent.ScriptedEntityType or "weapon", self.PropPanel, {
                            nicename  = ent.PrintName or ent.ClassName,
                            spawnname = ent.ClassName,
                            material  = ent.IconOverride or "entities/" .. ent.ClassName .. ".png",
                            admin     = ent.AdminOnly
                        })
                    end
                end
            end

            -- If we click on the node populate it and switch to it.
            node.DoClick = function(self)
                self:DoPopulate()
                pnlContent:SwitchPanel(self.PropPanel)
            end
        end

        -- Select the first node
        local FirstNode = tree:Root():GetChildNode(0)
        if (IsValid(FirstNode)) then
            FirstNode:InternalDoClick()
        end
    end)
end)


-- As of 2023-11-12, this feature is only available on dev branch.
-- Won't break anything on release branch though.
list.Set("ContentCategoryIcons", "ARC9 - Ammo", "arc9/icon_16.png")
list.Set("ContentCategoryIcons", "ARC9 - Attachments", "arc9/icon_16.png")

-- Give all categories with ARC9 weapons our icon unless one is already set
timer.Simple(0, function()
    for i, wep in pairs(weapons.GetList()) do
        local weap = weapons.Get(wep.ClassName)
        if weap and weap.ARC9 then
            local cat = weap.Category
            if cat and !list.HasEntry("ContentCategoryIcons", cat) then
                list.Set("ContentCategoryIcons", cat, "arc9/icon_16.png")
            end
        end
    end
end)
--PATH lua/arc9/client/cl_vgui_elements.lua:
return gluapack()()
--PATH lua/autorun/sh_mcompass.lua:
return gluapack()()
--PATH lua/pixelui/drawing/cl_images.lua:
return gluapack()()
--PATH lua/pixelui/drawing/cl_rounded_box.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_menu_option.lua:
return gluapack()()
--PATH lua/pixelui/libraries/cl_ui3d2d.lua:
--[[
	PIXEL UI - Copyright Notice
	 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local ui3d2d = ui3d2d or {}
PIXEL.UI.UI3D2D = ui3d2d

do --Input handling
    local getRenderTarget, cursorVisible = render.GetRenderTarget, vgui.CursorVisible
    local isMouseDown, isKeyDown = input.IsMouseDown, input.IsKeyDown

    local inputEnabled, isPressing, isPressed

    hook.Add("PreRender", "PIXEL.UI.UI3D2D.InputHandler", function() --Check the input state before rendering UIs
        if getRenderTarget() then inputEnabled = false return end
        if cursorVisible() then inputEnabled = false return end

        inputEnabled = true

        local wasPressing = isPressing
        isPressing = isMouseDown(MOUSE_LEFT) or isKeyDown(KEY_E)
        isPressed = not wasPressing and isPressing
    end)

    function ui3d2d.isPressing() --Returns true if an input is being held
        return inputEnabled and isPressing
    end

    function ui3d2d.isPressed() --Returns true if an input was pressed this frame
        return inputEnabled and isPressed
    end
end

do --Rendering context creation and mouse position getters
    local localPlayer

    hook.Add("PreRender", "PIXEL.UI.UI3D2D.GetLocalPlayer", function() --Keep getting the local player until it's available
        localPlayer = LocalPlayer()
        if IsValid(localPlayer) then hook.Remove("PreRender", "PIXEL.UI.UI3D2D.GetLocalPlayer") end
    end)

    local traceLine = util.TraceLine

    local baseQuery = {filter = {}}

    local function isObstructed(eyePos, hitPos, ignoredEntity) --Check if the cursor trace is obstructed by another ent
        local query = baseQuery
        query.start = eyePos
        query.endpos = hitPos
        query.filter[1] = localPlayer
        query.filter[2] = ignoredEntity

        return traceLine(query).Hit
    end

    local mouseX, mouseY
    local hoveredSomething = false

    do
        local start3d2d = cam.Start3D2D
        local isCursorVisible, isHoveringWorld = vgui.CursorVisible, vgui.IsHoveringWorld
        local screenToVector, mousePos = gui.ScreenToVector, gui.MousePos
        local intersectRayWithPlane = util.IntersectRayWithPlane

        local isRendering

        function ui3d2d.startDraw(pos, angles, scale, ignoredEntity) --Starts a new 3d2d ui rendering context
            local eyePos = localPlayer:EyePos()
            if eyePos:DistToSqr(pos) > 400000 then return end

            local eyePosToUi = pos - eyePos

            do --Only draw the UI if the player is in front of it
                local normal = angles:Up()
                local dot = eyePosToUi:Dot(normal)

                if dot >= 0 then return end
            end

            isRendering = true
            mouseX, mouseY = nil, nil

            start3d2d(pos, angles, scale)

            local cursorVisible, hoveringWorld = isCursorVisible(), isHoveringWorld()
            if not hoveringWorld and cursorVisible then return true end

            local eyeNormal
            do
                if cursorVisible and hoveringWorld then
                    eyeNormal = screenToVector(mousePos())
                else
                    eyeNormal = localPlayer:GetEyeTrace().Normal
                end
            end

            local hitPos = intersectRayWithPlane(eyePos, eyeNormal, pos, angles:Up())
            if not hitPos then return true end

            if isObstructed(eyePos, hitPos, ignoredEntity) then return true end

            local diff = pos - hitPos
            mouseX = diff:Dot(-angles:Forward()) / scale
            mouseY = diff:Dot(-angles:Right()) / scale

            hoveredSomething = nil
            return true
        end

        local end3d2d = cam.End3D2D

        function ui3d2d.endDraw() --Safely ends the 3d2d ui rendering context
            if not isRendering then print("[ui3d2d] Attempted to end a non-existant 3d2d ui rendering context.") return end
            isRendering = false
            end3d2d()
        end
    end

    function ui3d2d.getCursorPos() --Returns the current 3d2d cursor position
        return mouseX, mouseY
    end

    function ui3d2d.isHovering(x, y, w, h, preventCursorChange) --Returns whether the cursor is within a specified area
        local mx, my = mouseX, mouseY
        local hovering = mx and my and mx >= x and mx <= (x + w) and my >= y and my <= (y + h)
        if not preventCursorChange and hovering then hoveredSomething = true end
        return hovering
    end

    local cursorMat
    local cursorHoverMat
    PIXEL.GetImage("https://pixel-cdn.lythium.dev/i/cyf6d6gzf", function(mat) cursorMat = mat end)
    PIXEL.GetImage("https://pixel-cdn.lythium.dev/i/m3m6x59yb", function(mat) cursorHoverMat = mat end)

    function ui3d2d.drawCursor(x, y, w, h, size)
        size = size or 20

        local mx, my = ui3d2d.getCursorPos()
        if not (mx and my) then return end

        surface.SetDrawColor(255, 255, 255)
        surface.SetMaterial(hoveredSomething and cursorHoverMat or cursorMat)
        surface.DrawTexturedRect(hoveredSomething and (mx - size / 3.75) or mx, my, size, size)
    end
end

do --3d2d VGUI Drawing
    local insert = table.insert

    local function getParents(panel)
        local parents = {}
        local parent = panel:GetParent()

        while parent do
            insert(parents, parent)
            parent = parent:GetParent()
        end

        return parents
    end

    local ipairs = ipairs

    local function absolutePanelPos(panel)
        local x, y = panel:GetPos()
        local parents = getParents(panel)

        for _, parent in ipairs(parents) do
            local parentX, parentY = parent:GetPos()
            x = x + parentX
            y = y + parentY
        end

        return x, y
    end

    local function pointInsidePanel(panel, x, y)
        local absoluteX, absoluteY = absolutePanelPos(panel)
        local width, height = panel:GetSize()

        return panel:IsVisible() and x >= absoluteX and y >= absoluteY and x <= absoluteX + width and y <= absoluteY + height
    end

    local pairs = pairs
    local reverseTable = table.Reverse

    local function checkHover(panel, x, y, found, hoveredPanel)
        local validChild = false
        for _, child in pairs(reverseTable(panel:GetChildren())) do
            if not child:IsMouseInputEnabled() then continue end

            if checkHover(child, x, y, found or validChild) then validChild = true end
        end

        if not panel.isUi3d2dSetup then
            panel.IsHovered = function(s)
                return s.Hovered
            end

            panel:SetPaintedManually(true)
            panel.isUi3d2dSetup = true
        end

        if found then
            if panel.Hovered then
                panel.Hovered = false
                if panel.OnCursorExited then panel:OnCursorExited() end
            end
        else
            if not validChild and pointInsidePanel(panel, x, y) then
                panel.Hovered = true

                if panel.OnMousePressed then
                    local key = input.IsKeyDown(KEY_LSHIFT) and MOUSE_RIGHT or MOUSE_LEFT

                    if panel.OnMousePressed and ui3d2d.isPressed() then
                        panel:OnMousePressed(key)
                    end

                    if panel.OnMouseReleased and not ui3d2d.isPressing() then
                        panel:OnMouseReleased(key)
                    end
                elseif panel.DoClick and ui3d2d.isPressed() then
                    panel:DoClick()
                end

                if panel.OnCursorEntered then panel:OnCursorEntered() end

                return true
            else
                panel.Hovered = false
                if panel.OnCursorExited then panel:OnCursorExited() end
            end
        end
    end

    local oldMouseX, oldMouseY = gui.MouseX, gui.MouseY

    function ui3d2d.drawVgui(panel, pos, angles, scale, ignoredEntity)
        if not (IsValid(panel) and ui3d2d.startDraw(pos, angles, scale, ignoredEntity)) then return end

        do
            local cursorX, cursorY = ui3d2d.getCursorPos()
            cursorX, cursorY = cursorX or -1, cursorY or -1

            function gui.MouseX()
                return cursorX
            end

            function gui.MouseY()
                return cursorY
            end

            checkHover(panel, cursorX, cursorY)
        end

        panel:PaintManual()

        gui.MouseX, gui.MouseY = oldMouseX, oldMouseY

        ui3d2d.endDraw()
    end
end

hook.Run("PIXEL.UI.UI3D2D.FullyLoaded")

--PATH lua/autorun/sh_republic_conquest.lua:
RepublicConquest = RepublicConquest or {}
RepublicConquest.Teams = RepublicConquest.Teams or {}
RepublicConquest.Point = RepublicConquest.Point or {}
RepublicConquest.SBTM = RepublicConquest.SBTM or false

function RepublicConquest:CreateTeam(name, color)
    local newTeam = {
        Name = name,
        Color = color,
        ID = #RepublicConquest.Teams + 1,
        Entities = {}
    }

    if not table.HasValue(RepublicConquest.Teams, newTeam) then
        table.insert(RepublicConquest.Teams, newTeam)
    end
end

function RepublicConquest:SetupPredefinedTeams()
    RepublicConquest:CreateTeam("Neutral", Color(255, 255, 255, 0))
    RepublicConquest:CreateTeam("Player", Color(0, 0, 255))
    RepublicConquest:CreateTeam("NPC", Color(255, 0, 0, 255))
end

function RepublicConquest:FetchPoints()
    for k, v in pairs(ents.FindByClass("republic_control_point")) do
        RepublicConquest.Point[v] = k
    end
end

hook.Add("InitPostEntity", "RepublicConquest_Setup", function()
    RepublicConquest:SetupPredefinedTeams()

    if CLIENT then
        RepublicConquest:FetchPoints()
    end
end)
--PATH lua/autorun/sh_tx-2112-smokescreens-config.lua:
return gluapack()()
--PATH lua/autorun/slib_loader.lua:
return gluapack()()
--PATH lua/slib/vgui/cl_splayerselector.lua:
slib.panels = slib.panels or {}

local PANEL = {}

local font, sid_font, empty_font = slib.createFont("Roboto", 13), slib.createFont("Roboto", 11), slib.createFont("Roboto", 15)
local textcolor, textcolor_60 = slib.getTheme("textcolor"), slib.getTheme("textcolor", -60)
local hovercolor, margin, maincolor_12, maincolor_15 = slib.getTheme("hovercolor"), slib.getTheme("margin"), slib.getTheme("maincolor", 12), slib.getTheme("maincolor", 15)
local icon = Material("slib/down-arrow.png", "smooth")
local placeholder = "Select Option"

function PANEL:Init()
    self:SetTall(slib.getScaledSize(25, "y"))
    self:setTitle(placeholder, TEXT_ALIGN_LEFT)
    self.iteration = 0
    self.options = {}
    self.option_h = slib.getScaledSize(32, "y")
    self.titl = ""

    self.close = vgui.Create("DButton")
    self.close:Dock(FILL)
    self.close:SetText("")
    self.close:SetVisible(false)

    self.close.Paint = function() end

    self.close.DoClick = function()
        self.close:SetVisible(false)
        if IsValid(self.droppedFrame) then
            self.droppedFrame:SetVisible(false)
        end

        if isfunction(self.onClose) then self.onClose(self) end

        self:setTitle(self.titl, TEXT_ALIGN_LEFT, true)

        if !self.ply then
            self:setTitle(placeholder, TEXT_ALIGN_LEFT)
        end
    end

    self.droppedFrame = vgui.Create("EditablePanel")
    self.droppedFrame:SetWide(self:GetWide())
    self.droppedFrame:SetVisible(false)

    self.search = vgui.Create("STextEntry", self.droppedFrame)
    :Dock(TOP)
    :SetTall(self:GetTall())
    
    self.search.onValueChange = function(val)
        for k,v in ipairs(self.droppedMenu:GetCanvas():GetChildren()) do
            if !v.ply then continue end

            local filtered = false

            if self.filter then
                if self.filter(v.ply) == false then filtered = true end
            end

            v:SetVisible((val:Trim() == "" or string.find(v.nick:lower(), val:lower()) or val == v.sid64) and !filtered)
        end

        self.droppedMenu.SizeToChilds()
        self.droppedMenu:GetCanvas():InvalidateLayout(true)
    end

    self.closesearch = vgui.Create("SButton", self.search)
    self.closesearch:SetSize(self.option_h, self.option_h)
    self.closesearch.Paint = function(s,w,h) end
    self.closesearch.DoClick = self.close.DoClick

    self.droppedMenu = vgui.Create("SScrollPanel", self.droppedFrame)
    self.droppedMenu:SetWide(self:GetWide())
    self.droppedMenu:SetPos(0, self:GetTall())
    self.droppedMenu.Paint = function(s,w,h)
        surface.SetDrawColor(maincolor_15)
        surface.DrawRect(0,0,w,h)

        draw.SimpleText("No entries.", empty_font, w * .5, self.option_h * .5, textcolor_60, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    self.droppedMenu.SizeToChilds = function()
        local childs = self.droppedMenu:GetCanvas():GetChildren()
        local visible_childs = 0
        local childs_h = 0

        for k,v in ipairs(childs) do
            if v:IsVisible() then
                childs_h = childs_h + v:GetTall()
                visible_childs = visible_childs + 1
            end

            if visible_childs >= 5 then break end
        end
        
        self.droppedMenu:SetTall(math.max(childs_h, visible_childs <= 0 and self.option_h or 0))
        self.droppedFrame:SetTall(self.droppedMenu:GetTall() + self.search:GetTall())
    end

    self.no_player = vgui.Create("SButton", self.droppedMenu)
    :Dock(TOP)
    :SetLinePos(0)
    :SetTall(slib.getScaledSize(24, "y"))
    :SetZPos(-100)
    :SetVisible(false)

    self.no_player.skipVisible = true

    local noply_titl = "No Player"

    self.no_player.Paint = function(s,w,h)        
        surface.SetDrawColor(s:IsHovered() and maincolor_12 or maincolor_15)
        surface.DrawRect(0, 0, w, h)

        draw.SimpleText(noply_titl, self.buttonfont or s.font, margin, h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    self.no_player.DoClick = function()
        self.titl = noply_titl
        self.ply = nil

        self.close.DoClick()
        self:setTitle(noply_titl, TEXT_ALIGN_LEFT, true)

        if isfunction(self.onValueChange) then
            self.onValueChange(val, ply)
        end
    end

    slib.panels["SPlayerSelector"] = slib.panels["SPlayerSelector"] or {}
    table.insert(slib.panels["SPlayerSelector"], self)

    timer.Simple(0, function()
        if !IsValid(self) then return end

        for k,v in ipairs(player.GetAll()) do
            self:addOption(v)
        end
    end)
end

function PANEL:SetScrollBG(col)
    self.droppedMenu.scrollbg = col
end

function PANEL:FindSelectPlayer(ply)
    for k,v in ipairs(self.droppedMenu:GetCanvas():GetChildren()) do
        if v.ply == ply then
            v.DoClick()
            
            break
        end
    end
end

function PANEL:SetPlaceholder(str)
    self:setTitle(str, TEXT_ALIGN_LEFT)
end

function PANEL:OnRemove()
    if IsValid(self.droppedFrame) then self.droppedFrame:Remove() end
end

function PANEL:popupAlone()
    self:DoClick()

    local x, y = input.GetCursorPos()
    if !IsValid(self.droppedFrame) then return end
    self.droppedFrame:SetWide(self:GetWide())
    self.droppedFrame:SetPos(x, y)
    self.droppedFrame:MakePopup()
    self:SetVisible(false)

    self.droppedMenu:SetWide(self.droppedFrame:GetWide())

    self.onClose = function() self:Remove() end

    return self
end

function PANEL:updatedFilters()
    for k, v in ipairs(self.droppedMenu:GetCanvas():GetChildren()) do
        local result = true
        
        if v.skipVisible then continue end

        if self.filter then
            if self.filter(v.ply) == false then result = false end    
        end

        v:SetVisible(result)
    end

    self:pickFirst()
end

function PANEL:pickFirst()
    local childs = self.droppedMenu:GetCanvas():GetChildren()

    for k,v in ipairs(childs) do
        if !v:IsVisible() then continue end
        
        v.DoClick(true)

        break
    end
end

function PANEL:ScrollToFirst()
    local childs = self.droppedMenu:GetCanvas():GetChildren()

    for k,v in ipairs(childs) do
        if !v:IsVisible() then continue end
        
        self.droppedMenu:ScrollToChild(v)

        break
    end
end

function PANEL:ShowNoPlayer(bool)
    self.no_player:SetVisible(bool)

    self.droppedMenu:InvalidateLayout(true)
    self.droppedMenu:SizeToChilds()
end

function PANEL:addOption(ply)
    self.addedPlys = self.addedPlys or {}
    
    if self.addedPlys[ply] then return end
    
    self.addedPlys[ply] = true

    local iteration = self.iteration
    local nick, sid64 = ply:Nick(), ply:SteamID64()

    self.options[iteration] = vgui.Create("SButton", self.droppedMenu)
    :Dock(TOP)
    :SetLinePos(0)
    :SetTall(self.option_h)

    local visibility = !self.filter or self.filter(ply) != false
    self.options[iteration]:SetVisible(visibility)

    self.options[iteration].ply = ply
    self.options[iteration].nick = nick
    self.options[iteration].sid64 = sid64
    
    local avatar = vgui.Create("AvatarImage", self.options[iteration])
    avatar:SetPlayer(ply, 64)
    avatar:SetSize(self.option_h, self.option_h)
    avatar:SetMouseInputEnabled(false)

    local wide = self.options[iteration]:GetWide()

    self.options[iteration].accentheight = 1

    self.droppedMenu:InvalidateLayout(true)
    self.droppedMenu:SizeToChilds()

    self.options[iteration].DoClick = function()
        self.titl = nick
        self.ply = ply

        self.close.DoClick()
        self:setTitle(nick, TEXT_ALIGN_LEFT, true)

        if isfunction(self.onValueChange) then
            self.onValueChange(val, ply)
        end
    end

    self.options[iteration].Paint = function(s,w,h)
        if !IsValid(ply) then s:Remove() if IsValid(self.droppedMenu) then self.droppedMenu:InvalidateLayout(true) end end
        
        surface.SetDrawColor(s:IsHovered() and maincolor_12 or maincolor_15)
        surface.DrawRect(0, 0, w, h)

        draw.SimpleText(nick, self.buttonfont or self.options[iteration].font, self.option_h + margin, h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
        draw.SimpleText(sid64, sid_font, self.option_h + margin, h * .5, textcolor_60, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
    end
    
    if wide > self:GetWide() then
        self:SetWide(wide)
    end
    
    self.iteration = self.iteration + 1

    self.lastchild = self.options[iteration]

    return self
end

function PANEL:SelectOption(int)
    self.options[int].DoClick()

    return self
end

function PANEL:Reposition()
    local x, y = self:LocalToScreen(0,0)
    if !IsValid(self.droppedMenu) then return end
    self.droppedFrame:SetWide(self:GetWide())
    self.droppedFrame:SetPos(x, y)
    self.droppedFrame:MakePopup()

    self.droppedMenu:SetWide(self.droppedFrame:GetWide())
    self.closesearch:SetPos(self:GetWide() - self.option_h, 0)
end

function PANEL:DoClick()
    self.close:SetVisible(!self.droppedFrame:IsVisible())
    self.close:MakePopup()

    local childs = self.droppedMenu:GetCanvas():GetChildren()

    self.droppedFrame:SetVisible(!self.droppedFrame:IsVisible())
    self.search:SetValue(self.search.placeholder)

    for k, v in ipairs(childs) do
        local result = true

        if v.skipVisible then continue end

        if self.filter then
            if self.filter(v.ply) == false then result = false end    
        end

        v:SetVisible(result)
    end

    self.droppedMenu:GetCanvas():InvalidateLayout()

    self:ScrollToFirst()

    self.droppedMenu.SizeToChilds()

    self:setTitle("")

    self:Reposition()
end

function PANEL:OnSizeChanged()
    self:Reposition()
end

function PANEL:PaintOver(w,h)
    local size = math.min(h * .7, slib.getScaledSize(12, "y"))
    local thickness = slib.getScaledSize(2, "x")

    draw.NoTexture()

    local wantedCol = (self:IsHovered() or (IsValid(self.closesearch) and self.closesearch:IsHovered())) and color_white or hovercolor

    surface.SetDrawColor(wantedCol)
    surface.SetMaterial(icon)
    surface.DrawTexturedRect(w - size - margin * 2, h * .5 - size * .5, size, size)
end

hook.Add("OnEntityCreated", "slib:AddNewPlayerSelector", function(ent)
    timer.Simple(3, function()
        if IsValid(ent) and slib.panels["SPlayerSelector"] and ent:IsPlayer() then
            for k,v in ipairs(slib.panels["SPlayerSelector"]) do
                if !IsValid(v) then continue end

                v:addOption(ent)
            end
        end
    end)
end)

vgui.Register("SPlayerSelector", PANEL, "SButton")
--PATH lua/slib/vgui/cl_spopupbox.lua:
return gluapack()()
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/sh_gprotect.lua:
return gluapack()()
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/sh_gprotect_operators.lua:
return gluapack()()
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/client/cl_gprotect.lua:
gProtect = gProtect or {}
gProtect.TouchPermission = gProtect.TouchPermission or {}
gProtect.LoadedModules = gProtect.LoadedModules or {}
gProtect.CachedPlayers = gProtect.CachedPlayers or {}
gProtect.NetworkOwnershipQueue = gProtect.NetworkOwnershipQueue or {}

local highLighted = {}
local highlightedPlys = {}

local function doPlayerAction(ply, channel, int)
	net.Start("gP:Networking")
	net.WriteUInt(1, 2)
	net.WriteUInt(channel, 2)
	net.WriteUInt(int, 3)
	if ply then
		net.WriteEntity(ply)
	end
	net.SendToServer()
end

local generalActions = {
	["ghost-everyones-props"] = {zpos = -99, option = function() doPlayerAction(nil, 2, 1) end},
	["freeze-everyones-props"] = {zpos = -98, option = function() doPlayerAction(nil, 2, 2) end},
	["remove-disconnected-entities"] = {zpos = -97, option = function() doPlayerAction(nil, 2, 3) end}
}

local cmds = {
	["gprotect_ghostprops"] = function() doPlayerAction(nil, 2, 1) end,
	["gprotect_freezeprops"] = function() doPlayerAction(nil, 2, 2) end,
	["gprotect_removedisc_props"] = function() doPlayerAction(nil, 2, 3) end,
}

for k,v in pairs(cmds) do
	concommand.Add(k, v)
end

local playerActions = {
	[1] = {name = "ghost-props", option = function(ply) doPlayerAction(ply, 1, 3) end},
	[2] = {name = "freeze-props", option = function(ply) doPlayerAction(ply, 1, 1) end},
	[3] = {name = "remove-props", option = function(ply) doPlayerAction(ply, 1, 2) end},
	[4] = {name = "remove-entities", option = function(ply) doPlayerAction(ply, 1, 4) end}
}

local function openSettingsMenu()
	local gprotect_menu = vgui.Create("SFrame")
	:setTitle(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "title"))
	:SetSize(slib.getScaledSize(gProtect.config.FrameSize.x, "x"),slib.getScaledSize(gProtect.config.FrameSize.y, "y"))
    :Center()
    :addCloseButton()
	:MakePopup()

	for k, v in pairs(gProtect.config.modules) do
		local _, tab = gprotect_menu:addTab(slib.getLang("gprotect", gProtect.config.SelectedLanguage, k), "gprotect/tabs/"..k..".png")
		tab:SetZPos(gProtect.config.ModuleCoordination[k])

		if isfunction(gProtect.config.ModuleShouldDisplay[k]) and gProtect.config.ModuleShouldDisplay[k]() == false then
			tab:SetVisible(false)
		end
		
		local scroller = vgui.Create("SScrollPanel", tab:getFrame())
		:Dock(FILL)

		scroller:GetCanvas():DockPadding(0,slib.getTheme("margin"),0,slib.getTheme("margin"))

		for option, data in pairs(v) do

			if gProtect.LoadedModules[k] and gProtect.LoadedModules[k][option] ~= nil then
				data = gProtect.LoadedModules[k][option]
			else
				data = gProtect.config.modules[k][option]
			end

			if data == nil then continue end
			if isbool(gProtect.config.modules[k][option]) then data = tobool(data) end
			local setting = vgui.Create("SStatement", scroller)
            local _, element = setting:SetZPos(gProtect.config.sortOrders[k][option])
			:addStatement(slib.getLang("gprotect", gProtect.config.SelectedLanguage, k.."_"..option), data)

			local statement = slib.getStatement(data)

			if statement == "int" then
				if gProtect.config.valueRules[k] and gProtect.config.valueRules[k][option] and gProtect.config.valueRules[k][option].intLimit then
					element:SetMin(gProtect.config.valueRules[k][option].intLimit.min)
					element:SetMax(gProtect.config.valueRules[k][option].intLimit.max)
				end
			end

			if statement == "table" then
					element.onElementOpen = function(s)
						if !gProtect.HasPermission(LocalPlayer(), "gProtect_Settings") then slib.notify(gProtect.config.Prefix..slib.getLang("gprotect", gProtect.config.SelectedLanguage, "insufficient-permission")) s:Remove() return end
						local tbl
						if gProtect.config.valueRules[k] and gProtect.config.valueRules[k][option] and gProtect.config.valueRules[k][option].tableAlternatives then
							tbl = gProtect.config.valueRules[k][option].tableAlternatives
							if isfunction(gProtect.config.valueRules[k][option].tableAlternatives) then
								tbl = gProtect.config.valueRules[k][option].tableAlternatives()
							end
						end

						s:addSuggestions(tbl)
						s:sortValues(s.viewer)
						s:sortValues(s.suggestions)
						s:addEntry()
						s:addSearch(s.viewbox, s.viewer)
						s:addSearch(s.suggestionbox, s.suggestions)
						s:setIdentifiers(k, option)
						if gProtect.config.valueRules[k] and gProtect.config.valueRules[k][option] then
							if gProtect.config.valueRules[k][option].toggleableValue then
								s:setToggleable(k, option, gProtect.config.valueRules[k][option].toggleableValue)
							end

							if gProtect.config.valueRules[k][option].onlymodifytable then
								s:setOnlyModifyTable(true)
							end

							if gProtect.config.valueRules[k][option].undeleteableTable then
								s:setundeleteableTable(k, option, gProtect.config.valueRules[k][option].undeleteableTable)
							end

							if gProtect.config.valueRules[k][option].addRules then
								s:setAddRules(gProtect.config.valueRules[k][option].addRules)
							end

							if gProtect.config.valueRules[k][option].tableDeletable then
								s:setTableDeletable(true)
							end

							if gProtect.config.valueRules[k][option].customTable == "int" then
								s:setCustomValues(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "submit"), slib.getLang("gprotect", gProtect.config.SelectedLanguage, "input_number"), true)
							end
						end

						s.OnRemove = function()
							if s.modified then
								element.onValueChange(s.viewer.tbl)
							end
						end
					end

			end
			
			element.onValueChange = function(value)
				if !gProtect.HasPermission(LocalPlayer(), "gProtect_Settings") then slib.notify(gProtect.config.Prefix..slib.getLang("gprotect", gProtect.config.SelectedLanguage, "insufficient-permission")) return false end

				net.Start("gP:Networking")
				net.WriteUInt(3, 2)
				net.WriteString(k)
				net.WriteString(option)

				local statement = slib.getStatement(value)

				if statement == "bool" then
					net.WriteBool(value)
				elseif statement == "int" then
					net.WriteInt(value, 18)
				elseif statement == "color" or statement == "table" then
					value = util.Compress(util.TableToJSON(value))
					net.WriteUInt(#value, 32)
					net.WriteData(value, #value)
				end
				
				net.SendToServer()
			end

			local tooltip = slib.getLang("gprotect", gProtect.config.SelectedLanguage, k.."_"..option.."_tooltip")

			if tooltip then
				slib.createTooltip(tooltip, setting)
			end
		end
		
		if k ~= "general" then
			local search = vgui.Create("SSearchBar", tab:getFrame())
			search:addIcon()
			
			search.entry.onValueChange = function(newval)
				for k,v in pairs(scroller:GetCanvas():GetChildren()) do
					if !v.name then continue end
					if !string.find(string.lower(v.name), string.lower(newval)) then
						v:SetVisible(false)
					else
						v:SetVisible(true)
					end
		
					scroller:GetCanvas():InvalidateLayout(true)
				end
			end
		end
	end

	gprotect_menu:setActiveTab(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "general"))

	local generalScroller = gprotect_menu.tab[slib.getLang("gprotect", gProtect.config.SelectedLanguage, "general")]:GetChildren()[1]

	local player_list = vgui.Create("SListPanel", generalScroller)
	player_list:SetZPos(-100)
    player_list:setTitle(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "player-list"))
    :addSearchbar()
	:SetZPos(-200)

	for k, v in ipairs(playerActions) do
		player_list:addButton(slib.getLang("gprotect", gProtect.config.SelectedLanguage, v.name), function(s)
			if !s.selected or !IsValid(s.selected) then return end
			v.option(s.selected)
		end)
	end

	player_list:addButton(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "highlight-ents"), function(s)
		if !s.selected or !IsValid(s.selected) then return end
		highlightedPlys[s.selected] = !highlightedPlys[s.selected]
		for k,v in pairs(ents.GetAll()) do
			if gProtect.GetOwner(v) == s.selected then
				if highlightedPlys[s.selected] then
					table.insert(highLighted, v)
				else
					table.RemoveByValue(highLighted, v)
				end
			end
		end
	end,
    function(s, bttn)
        if !s.selected or !IsValid(s.selected) then
            bttn:setTitle(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "highlight-ents"))    
        return end
		if highlightedPlys[s.selected] then 
            bttn:setTitle(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "unhighlight-ents")) 
        else 
            bttn:setTitle(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "highlight-ents")) 
        end
    end)

    for k,v in ipairs(player.GetAll()) do
        if v:IsBot() then continue end
        player_list:addEntry(v)
	end
	
	for k,v in pairs(generalActions) do
		local action = vgui.Create("SStatement", generalScroller)
		local _, element = action:SetZPos(v.zpos)
		:addStatement(slib.getLang("gprotect", gProtect.config.SelectedLanguage, k), v.option)
	end
end

local ent

timer.Create("gP:updateLookAt", .05, 0, function()
	local ply = LocalPlayer()
	if !IsValid(ply) then return end

	local detected

	local trace = ply:GetEyeTraceNoCursor()
	local foundent = trace and trace.Entity

	if foundent and IsValid(foundent) and !foundent:IsPlayer() then
		detected = foundent
	elseif !gProtect.config.DisableOwnershipRayDetection then
		local raytrace = ents.FindAlongRay(trace.StartPos, trace.HitPos)
		if raytrace then
			for k, v in ipairs(raytrace) do
				if !IsValid(v) or v:IsWeapon() or v:IsPlayer() or gProtect.config.IgnoreEntitiesHUD[v] then continue end
				
				detected = v
			end
		end
	end

	ent = detected
end)

hook.Add("OnEntityCreated", "gP:CachePlayerNames", function(ent)
	if ent:IsPlayer() then
		gProtect.CachedPlayers[ent:SteamID()] = ent:Nick()
	end

	timer.Simple(.1, function()
		if highlightedPlys[gProtect.GetOwner(ent)] then
			table.insert(highLighted, ent)
		end
	end)
end )

local permissionColor = slib.getTheme("successcolor")

hook.Add("HUDPaint", "gP:EntInfo", function()
	if !gProtect.config.EnableOwnershipHUD or !ent or !IsValid(ent) then return end
	local ply = LocalPlayer()
	
	local info = gProtect.GetOwner(ent)
	if !info then
		local result = gProtect.GetOwnerString(ent)
		info = string.sub(result, 1, 5) == "STEAM" and "Disconnected" or "World"
	end

	if isstring(info) then
		local translation = slib.getLang("gprotect", gProtect.config.SelectedLanguage, string.lower(info))
		if !translation then return end
		info = translation
		local cachedPly = gProtect.CachedPlayers[gProtect.GetOwnerString(ent)]

		if cachedPly then
			info = info.." ("..cachedPly..")"
		end
	end

	local wantedcolor = gProtect.HandlePermissions(ply, ent) and slib.getTheme("successcolor", -60) or slib.getTheme("failcolor", -60)
	draw.SimpleTextOutlined( !isstring(info) and info:Nick() or info, slib.createFont("Roboto", 16), slib.getTheme("margin"), ScrH() * .5, slib.getTheme("textcolor"), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, slib.lerpColor("gP:PermissionDisplay", wantedcolor))
end)

net.Receive("gP:Networking", function()
	local action = net.ReadUInt(2)

	if action == 0 then
		local data = net.ReadString()
		data = util.JSONToTable(data)
	
		local exclusive = net.ReadString()

		gProtect.TouchPermission[exclusive] = data
	elseif action == 1 then
		local len = net.ReadUInt(32)
		local data = net.ReadData(len)
		local module = net.ReadString()
		
		data = util.JSONToTable(util.Decompress(data))
		if module and module ~= "" then
			gProtect.LoadedModules[module] = gProtect.LoadedModules[module] or {}

			for k,v in pairs(data) do
				gProtect.LoadedModules[module][k] = v
			end
		else
			gProtect.LoadedModules = data
		end

		hook.Run("gP:ConfigUpdated", module)
	elseif action == 2 then
		local entIndex = net.ReadUInt(14)
		local owner = net.ReadString()

		owner = owner != "" and owner or nil

		local ent = Entity(entIndex)

		if IsValid(ent) then
			ent.gPOwner = owner
			gProtect.NetworkOwnershipQueue[entIndex] = nil
		else
			gProtect.NetworkOwnershipQueue[entIndex] = owner
		end	
	end
end)

hook.Add("OnEntityCreated", "gP:EntOwnershipQueue", function(ent)
	if !IsValid(ent) then return end

	local entIndex = ent:EntIndex()
	local owner = gProtect.NetworkOwnershipQueue[entIndex]

	if owner then
		ent.gPOwner = owner

		gProtect.NetworkOwnershipQueue[entIndex] = nil
	end
end)

local grn_col = Color(0, 200, 0)

hook.Add("PreDrawHalos", "gP:HighLightPlyEnts", function()
	halo.Add(highLighted, grn_col, 5, 5, 2)
end)

concommand.Add("gprotect_settings", function( ply, cmd, args )
	if !gProtect.HasPermission(LocalPlayer(), "gProtect_Settings") and !gProtect.HasPermission(LocalPlayer(), "gProtect_DashboardAccess") then return end
	if !gProtect.InitialLoaded then gProtect.InitialLoaded = true RunConsoleCommand("say", "!gprotect") return end

    openSettingsMenu()
end)
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/client/cl_buddies.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/modules/sh_discord.lua:
local client_id = sReward.config["discord"]["client_id"]
local guild_id = sReward.config["discord"]["guild_id"]

if CLIENT then
    net.Receive("sR:DiscordIntegration", function()
        RunConsoleCommand("sreward_discordweb")
    end)
else
    util.AddNetworkString("sR:DiscordIntegration")

    sReward = sReward or {}
    sReward.discord = sReward.discord or {}
    sReward.discord.members = sReward.discord.members or {}
    sReward.discord.queue = sReward.discord.queue or {}

    local client_secret = sReward.config["discord"]["client_secret"]
    local bot_token = sReward.config["discord"]["bot_token"]

    local apiURL = "https://stromic.xyz/discord.php" --- We will get blocked by Cloudflare so we reverse proxy!

    local function handleQueue(sid)
        for k,v in pairs(sReward.discord.queue[sid]) do
            v()
            sReward.discord.queue[sid][k] = nil
        end
    end

    local function syncMember(sid)
        local uid = sReward.discord.members[sid] and sReward.discord.members[sid].id
        if !uid then return end
        http.Fetch(apiURL.."/guilds/"..guild_id.."/members/"..uid, function(json, len, headers, code)
            local data = util.JSONToTable(json)
            if data then
                sReward.discord.members[sid].joined = !!data.user
                sReward.discord.members[sid].boosting = !!data.premium_since

                handleQueue(sid)
            end
        end, nil, {
            ["Authorization"] = "Bot "..bot_token
        })
    end

    sReward.syncMember = syncMember

    local function storeuid(ply, code)
        local sid = ply:SteamID()
        
        HTTP({
            method = "post",
            url = apiURL.."/oauth2/token",
            parameters = {
                grant_type = "authorization_code",
                code = code,
                client_id = client_id,
                client_secret = client_secret,
            },
            headers	= {},
            success = function(code, body, headers)
                if (code == 200) then
                    local data = util.JSONToTable(body)
                    local token = data.access_token

                    if !token then
                        slib.notify(sReward.config["prefix"]..slib.getLang("sreward", sReward.config["language"], "discord_error_retrieving_data"), ply)
                    return end

                    http.Fetch(apiURL.."/users/@me", function(data)
                        local json = util.JSONToTable(data)
            
                        sReward.discord.members[sid].id = json and json.id

                        if !sReward.discord.members[sid] then
                            slib.notify(sReward.config["prefix"]..slib.getLang("sreward", sReward.config["language"], "discord_error_retrieving_data"), ply)
                            sReward.discord.members[sid] = nil
                        else
                            syncMember(sid)
                        end
                    end, function()
                        slib.notify(sReward.config["prefix"]..slib.getLang("sreward", sReward.config["language"], "discord_error_retrieving_data"), ply) 
                    end,{ --- Headers include token!00
                        ["Authorization"] = "Bearer "..token
                    })
                else
                    slib.notify(sReward.config["prefix"]..slib.getLang("sreward", sReward.config["language"], "discord_error_retrieving_data"), ply)
                end
            end,
            failed = function(err)
                slib.notify(sReward.config["prefix"]..slib.getLang("sreward", sReward.config["language"], "discord_error_retrieving_data"), ply)
            end
        })
    end

    local currentDiscordVerifications = {}

    local verifyAndGiveReward = function(ply, reward, action)
        local sid, sid64 = ply:SteamID(), ply:SteamID64()
        local uid = sReward.discord.members[sid] and sReward.discord.members[sid].id

        if !uid then return end

        if currentDiscordVerifications[uid] then
            return slib.notify(sReward.config["prefix"]..slib.getLang("sreward", sReward.config["language"], "discord_verification_cooldown"), ply)
        end

        currentDiscordVerifications[uid] = true

        sReward.hasBeenClaimedFromOtherSID64(sid64, uid, function(claimedByOtherSID64)
            if claimedByOtherSID64 then
                currentDiscordVerifications[uid] = nil
                
                slib.notify(sReward.config["prefix"]..slib.getLang("sreward", sReward.config["language"], "discord_claimed_by_others"), ply)
            else
                sReward.insertDiscordRewardClaim(sid64, uid, function()
                    currentDiscordVerifications[uid] = nil
                    
                    local rewardGiven
                    
                    if IsValid(ply) then
                        rewardGiven = sReward.GiveReward(ply, reward)
                    end
                end)
            end
        end)
    end

    local function handleVerification(ply, key, type)
        local reward = sReward.config["rewards"][key]

        local sid = ply:SteamID()
        
        sReward.discord.members[sid] = sReward.discord.members[sid] or {}
        sReward.discord.queue[sid] = sReward.discord.queue[sid] or {}

        if sReward.discord.members[sid][type] then
            verifyAndGiveReward(ply, key, type)
        return end

        local success = function()
            if sReward.discord.members[sid][type] then
                verifyAndGiveReward(ply, key, type)
            else
                slib.notify(sReward.config["prefix"]..slib.getLang("sreward", sReward.config["language"], "failed_verification", reward.name), ply)
            end
        end

        if !sReward.discord.members[sid].id then            
            net.Start("sR:DiscordIntegration")
            net.Send(ply)

            ply.sR_RequestedAuth = true
        elseif !sReward.discord.members[sid][type] then
            syncMember(sid)
        end

        sReward.discord.queue[sid][type] = success

        slib.notify(sReward.config["prefix"]..slib.getLang("sreward", sReward.config["language"], "checking_wait", reward.name), ply)
    end

    sReward.VerifyDiscordJoin = function(ply, key)
        handleVerification(ply, key, "joined")
    end

    sReward.VerifyDiscordBoost = function(ply, key)
        handleVerification(ply, key, "boosting")
    end

    net.Receive("sR:DiscordIntegration", function(len, ply)
        local sid = ply:SteamID()
        if !ply.sR_RequestedAuth then return end
        ply.sR_RequestedAuth = nil

        local code = net.ReadString()

        if code == "" then return end
            
        storeuid(ply, code, v)
    end)
end
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_elitexpsystem.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_voidcases.lua:
sReward.RegisterReward("voidcases_giveitem", function(ply, item_name)
    RunConsoleCommand("voidcases_giveitem", ply:SteamID64(), item_name)
end)
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_zpncandy.lua:
sReward.RegisterReward("zpn_candy", function(ply, amount)
    if !zpn or !zpn.Candy or !zpn.Candy.AddPoints then return end
    
    zpn.Candy.AddPoints(ply, amount)
end, Material("sreward/money.png", "smooth"))
--PATH lua/streamradio_core/external/neturl.lua:
-- neturl.lua - a robust url parser and builder
-- https://github.com/golgote/neturl
--
-- Bertrand Mansion, 2011-2021; License MIT
-- @module net.url
-- @alias	M

local M = {}
M.version = "1.1.0"

--- url options
-- - `separator` is set to `&` by default but could be anything like `&amp;amp;` or `;`
-- - `cumulative_parameters` is false by default. If true, query parameters with the same name will be stored in a table.
-- - `legal_in_path` is a table of characters that will not be url encoded in path components
-- - `legal_in_query` is a table of characters that will not be url encoded in query values. Query parameters only support a small set of legal characters (-_.).
-- - `query_plus_is_space` is true by default, so a plus sign in a query value will be converted to %20 (space), not %2B (plus)
-- @todo Add option to limit the size of the argument table
-- @todo Add option to limit the depth of the argument table
-- @todo Add option to process dots in parameter names, ie. `param.filter=1`
M.options = {
	separator = '&',
	cumulative_parameters = false,
	legal_in_path = {
		[":"] = true, ["-"] = true, ["_"] = true, ["."] = true,
		["!"] = true, ["~"] = true, ["*"] = true, ["'"] = true,
		["("] = true, [")"] = true, ["@"] = true, ["&"] = true,
		["="] = true, ["$"] = true, [","] = true,
		[";"] = true
	},
	legal_in_query = {
		[":"] = true, ["-"] = true, ["_"] = true, ["."] = true,
		[","] = true, ["!"] = true, ["~"] = true, ["*"] = true,
		["'"] = true, [";"] = true, ["("] = true, [")"] = true,
		["@"] = true, ["$"] = true,
	},
	query_plus_is_space = true
}

--- list of known and common scheme ports
-- as documented in <a href="http://www.iana.org/assignments/uri-schemes.html">IANA URI scheme list</a>
M.services = {
	acap     = 674,
	cap      = 1026,
	dict     = 2628,
	ftp      = 21,
	gopher   = 70,
	http     = 80,
	https    = 443,
	iax      = 4569,
	icap     = 1344,
	imap     = 143,
	ipp      = 631,
	ldap     = 389,
	mtqp     = 1038,
	mupdate  = 3905,
	news     = 2009,
	nfs      = 2049,
	nntp     = 119,
	rtsp     = 554,
	sip      = 5060,
	snmp     = 161,
	telnet   = 23,
	tftp     = 69,
	vemmi    = 575,
	afs      = 1483,
	jms      = 5673,
	rsync    = 873,
	prospero = 191,
	videotex = 516
}

local function decode(str)
	return (str:gsub("%%(%x%x)", function(c)
		return string.char(tonumber(c, 16))
	end))
end

local function encode(str, legal)
	return (str:gsub("([^%w])", function(v)
		if legal[v] then
			return v
		end
		return string.upper(string.format("%%%02x", string.byte(v)))
	end))
end

-- for query values, + can mean space if configured as such
local function decodeValue(str)
	if M.options.query_plus_is_space then
		str = str:gsub('+', ' ')
	end
	return decode(str)
end

local function concat(a, b)
	if type(a) == 'table' then
		return a:build() .. b
	else
		return a .. b:build()
	end
end

function M:addSegment(path)
	if type(path) == 'string' then
		self.path = self.path .. '/' .. encode(path:gsub("^/+", ""), M.options.legal_in_path)
	end
	return self
end

--- builds the url
-- @return a string representing the built url
function M:build()
	local url = ''
	if self.path then
		local path = self.path
		url = url .. tostring(path)
	end
	if self.query then
		local qstring = tostring(self.query)
		if qstring ~= "" then
			url = url .. '?' .. qstring
		end
	end
	if self.host then
		local authority = self.host
		if self.port and self.scheme and M.services[self.scheme] ~= self.port then
			authority = authority .. ':' .. self.port
		end
		local userinfo
		if self.user and self.user ~= "" then
			userinfo = self.user
			if self.password then
				userinfo = userinfo .. ':' .. self.password
			end
		end
		if userinfo and userinfo ~= "" then
			authority = userinfo .. '@' .. authority
		end
		if authority then
			if url ~= "" then
				url = '//' .. authority .. '/' .. url:gsub('^/+', '')
			else
				url = '//' .. authority
			end
		end
	end
	if self.scheme then
		url = self.scheme .. ':' .. url
	end
	if self.fragment then
		url = url .. '#' .. self.fragment
	end
	return url
end

--- builds the querystring
-- @param tab The key/value parameters
-- @param sep The separator to use (optional)
-- @param key The parent key if the value is multi-dimensional (optional)
-- @return a string representing the built querystring
function M.buildQuery(tab, sep, key)
	local query = {}
	if not sep then
		sep = M.options.separator or '&'
	end
	local keys = {}
	for k in pairs(tab) do
		keys[#keys+1] = k
	end
	table.sort(keys, function (a, b)
  		local function padnum(n, rest) return ("%03d"..rest):format(tonumber(n)) end
  		return tostring(a):gsub("(%d+)(%.)",padnum) < tostring(b):gsub("(%d+)(%.)",padnum)
	end)
	for _,name in ipairs(keys) do
		local value = tab[name]
		name = encode(tostring(name), {["-"] = true, ["_"] = true, ["."] = true})
		if key then
			if M.options.cumulative_parameters and string.find(name, '^%d+$') then
				name = tostring(key)
			else
				name = string.format('%s[%s]', tostring(key), tostring(name))
			end
		end
		if type(value) == 'table' then
			query[#query+1] = M.buildQuery(value, sep, name)
		else
			local value = encode(tostring(value), M.options.legal_in_query)
			if value ~= "" then
				query[#query+1] = string.format('%s=%s', name, value)
			else
				query[#query+1] = name
			end
		end
	end
	return table.concat(query, sep)
end

--- Parses the querystring to a table
-- This function can parse multidimensional pairs and is mostly compatible
-- with PHP usage of brackets in key names like ?param[key]=value
-- @param str The querystring to parse
-- @param sep The separator between key/value pairs, defaults to `&`
-- @todo limit the max number of parameters with M.options.max_parameters
-- @return a table representing the query key/value pairs
function M.parseQuery(str, sep)
	if not sep then
		sep = M.options.separator or '&'
	end

	local values = {}
	for key,val in str:gmatch(string.format('([^%q=]+)(=*[^%q=]*)', sep, sep)) do
		local key = decodeValue(key)
		local keys = {}
		key = key:gsub('%[([^%]]*)%]', function(v)
				-- extract keys between balanced brackets
				if string.find(v, "^-?%d+$") then
					v = tonumber(v)
				else
					v = decodeValue(v)
				end
				table.insert(keys, v)
				return "="
		end)
		key = key:gsub('=+.*$', "")
		key = key:gsub('%s', "_") -- remove spaces in parameter name
		val = val:gsub('^=+', "")

		if not values[key] then
			values[key] = {}
		end
		if #keys > 0 and type(values[key]) ~= 'table' then
			values[key] = {}
		elseif #keys == 0 and type(values[key]) == 'table' then
			values[key] = decodeValue(val)
		elseif M.options.cumulative_parameters
			and type(values[key]) == 'string' then
			values[key] = { values[key] }
			table.insert(values[key], decodeValue(val))
		end

		local t = values[key]
		for i,k in ipairs(keys) do
			if type(t) ~= 'table' then
				t = {}
			end
			if k == "" then
				k = #t+1
			end
			if not t[k] then
				t[k] = {}
			end
			if i == #keys then
				t[k] = val
			end
			t = t[k]
		end

	end
	setmetatable(values, { __tostring = M.buildQuery })
	return values
end

--- set the url query
-- @param query Can be a string to parse or a table of key/value pairs
-- @return a table representing the query key/value pairs
function M:setQuery(query)
	local query = query
	if type(query) == 'table' then
		query = M.buildQuery(query)
	end
	self.query = M.parseQuery(query)
	return query
end

--- set the authority part of the url
-- The authority is parsed to find the user, password, port and host if available.
-- @param authority The string representing the authority
-- @return a string with what remains after the authority was parsed
function M:setAuthority(authority)
	self.authority = authority
	self.port = nil
	self.host = nil
	self.userinfo = nil
	self.user = nil
	self.password = nil

	authority = authority:gsub('^([^@]*)@', function(v)
		self.userinfo = v
		return ''
	end)

	authority = authority:gsub(':(%d+)$', function(v)
		self.port = tonumber(v)
		return ''
	end)

	local function getIP(str)
		-- ipv4
		local chunks = { str:match("^(%d+)%.(%d+)%.(%d+)%.(%d+)$") }
		if #chunks == 4 then
			for _, v in pairs(chunks) do
				if tonumber(v) > 255 then
					return false
				end
			end
			return str
		end
		-- ipv6
		local chunks = { str:match("^%["..(("([a-fA-F0-9]*):"):rep(8):gsub(":$","%%]$"))) }
		if #chunks == 8 or #chunks < 8 and
			str:match('::') and not str:gsub("::", "", 1):match('::') then
			for _,v in pairs(chunks) do
				if #v > 0 and tonumber(v, 16) > 65535 then
					return false
				end
			end
			return str
		end
		return nil
	end

	local ip = getIP(authority)
	if ip then
		self.host = ip
	elseif type(ip) == 'nil' then
		-- domain
		if authority ~= '' and not self.host then
			local host = authority:lower()
			if  string.match(host, '^[%d%a%-%.]+$') ~= nil and
				string.sub(host, 0, 1) ~= '.' and
				string.sub(host, -1) ~= '.' and
				string.find(host, '%.%.') == nil then
				self.host = host
			end
		end
	end

	if self.userinfo then
		local userinfo = self.userinfo
		userinfo = userinfo:gsub(':([^:]*)$', function(v)
				self.password = v
				return ''
		end)
		if string.find(userinfo, "^[%w%+%.]+$") then
			self.user = userinfo
		else
			-- incorrect userinfo
			self.userinfo = nil
			self.user = nil
			self.password = nil
		end
	end

	return authority
end

--- Parse the url into the designated parts.
-- Depending on the url, the following parts can be available:
-- scheme, userinfo, user, password, authority, host, port, path,
-- query, fragment
-- @param url Url string
-- @return a table with the different parts and a few other functions
function M.parse(url)
	local comp = {}
	M.setAuthority(comp, "")
	M.setQuery(comp, "")

	local url = tostring(url or '')
	url = url:gsub('#(.*)$', function(v)
		comp.fragment = v
		return ''
	end)
	url =url:gsub('^([%w][%w%+%-%.]*)%:', function(v)
		comp.scheme = v:lower()
		return ''
	end)
	url = url:gsub('%?(.*)', function(v)
		M.setQuery(comp, v)
		return ''
	end)
	url = url:gsub('^//([^/]*)', function(v)
		M.setAuthority(comp, v)
		return ''
	end)

	comp.path = url:gsub("([^/]+)", function (s) return encode(decode(s), M.options.legal_in_path) end)

	setmetatable(comp, {
		__index = M,
		__tostring = M.build,
		__concat = concat,
		__div = M.addSegment
	})
	return comp
end

--- removes dots and slashes in urls when possible
-- This function will also remove multiple slashes
-- @param path The string representing the path to clean
-- @return a string of the path without unnecessary dots and segments
function M.removeDotSegments(path)
	local fields = {}
	if string.len(path) == 0 then
		return ""
	end
	local startslash = false
	local endslash = false
	if string.sub(path, 1, 1) == "/" then
		startslash = true
	end
	if (string.len(path) > 1 or startslash == false) and string.sub(path, -1) == "/" then
		endslash = true
	end

	path:gsub('[^/]+', function(c) table.insert(fields, c) end)

	local new = {}
	local j = 0

	for i,c in ipairs(fields) do
		if c == '..' then
			if j > 0 then
				j = j - 1
			end
		elseif c ~= "." then
			j = j + 1
			new[j] = c
		end
	end
	local ret = ""
	if #new > 0 and j > 0 then
		ret = table.concat(new, '/', 1, j)
	else
		ret = ""
	end
	if startslash then
		ret = '/'..ret
	end
	if endslash then
		ret = ret..'/'
	end
	return ret
end

local function reducePath(base_path, relative_path)
	if string.sub(relative_path, 1, 1) == "/" then
		return '/' .. string.gsub(relative_path, '^[%./]+', '')
	end
	local path = base_path
	local startslash = string.sub(path, 1, 1) ~= "/";
	if relative_path ~= "" then
		path = (startslash and '' or '/') .. path:gsub("[^/]*$", "")
	end
	path = path .. relative_path
	path = path:gsub("([^/]*%./)", function (s)
		if s ~= "./" then return s else return "" end
	end)
	path = string.gsub(path, "/%.$", "/")
	local reduced
	while reduced ~= path do
		reduced = path
		path = string.gsub(reduced, "([^/]*/%.%./)", function (s)
			if s ~= "../../" then return "" else return s end
		end)
	end
	path = string.gsub(path, "([^/]*/%.%.?)$", function (s)
		if s ~= "../.." then return "" else return s end
	end)
	local reduced
	while reduced ~= path do
		reduced = path
		path = string.gsub(reduced, '^/?%.%./', '')
	end
	return (startslash and '' or '/') .. path
end

--- builds a new url by using the one given as parameter and resolving paths
-- @param other A string or a table representing a url
-- @return a new url table
function M:resolve(other)
	if type(self) == "string" then
		self = M.parse(self)
	end
	if type(other) == "string" then
		other = M.parse(other)
	end
	if other.scheme then
		return other
	else
		other.scheme = self.scheme
		if not other.authority or other.authority == "" then
			other:setAuthority(self.authority)
			if not other.path or other.path == "" then
				other.path = self.path
				local query = other.query
				if not query or not next(query) then
					other.query = self.query
				end
			else
				other.path = reducePath(self.path, other.path)
			end
		end
		return other
	end
end

--- normalize a url path following some common normalization rules
-- described on <a href="http://en.wikipedia.org/wiki/URL_normalization">The URL normalization page of Wikipedia</a>
-- @return the normalized path
function M:normalize()
	if type(self) == 'string' then
		self = M.parse(self)
	end
	if self.path then
		local path = self.path
		path = reducePath(path, "")
		-- normalize multiple slashes
		path = string.gsub(path, "//+", "/")
		self.path = path
	end
	return self
end

return M
--PATH lua/streamradio_core/api.lua:
--[[
    The developer API for the use in external addons or in non-sandbox gamemodes.
    Make sure you check for StreamRadioLib.Loaded == true before using this API.

    Functions:
        bool StreamRadioLib.EditRadio( Entity Radio [, table settings] )
        -- Set the Radio settings to the given settings. Returns true on success.

        Entity StreamRadioLib.SpawnRadio( [Player player] [, string model] [, Vector pos] [, Angle ang] [, table settings] )
        -- Spawns a Radio and makes the given player to the owner for the tool and CPPI. It will have the given model and will be spawned at pos and ang.
        -- The settings table will set the radio's settings. The radio entity is returned on success.

        bool StreamRadioLib.IsValidRadioSettings( any settings )
        -- Checks settings for being a valid settings table. Returns true if it is.

    The settings table:
        This following list describes the layout of the settings table.
        Each element is optional, but have to be fed with the right datatype when they are in use.

        Index:                  Type:       Default:        Description:

        StreamUrl               String      ""              The streaming source URL.
        StreamName              String      ""              Name of the stream.

        StreamMute              boolean     false           True mutes the stream
        StreamVolume            number      1               0 is 0% and 1 is 100% volume
        Radius                  number      1200            Number in units of the sound range
		Sound3D                 boolean     true            True enables the 3D world sound
        DisableInput            boolean     false           True disables the radio controlling. Does not affect Wiremod controlling.
        DisableDisplay          boolean     false           True disables the radio display.
        DisableSpectrum          boolean     false          True disables the spectrum visualization on the radio display.
        DisableAdvancedOutputs  boolean     true            True disables the Advanced Wire Outputs.

		PlaybackLoopMode        number      1               Loop mode:
                                                                StreamRadioLib.PLAYBACK_LOOP_MODE_NONE, Value: 0, No loop (Invalid values falls back to this)
																StreamRadioLib.PLAYBACK_LOOP_MODE_SONG, Value: 1, Loops song
																StreamRadioLib.PLAYBACK_LOOP_MODE_PLAYLIST, Value: 2

        StreamLoop              boolean     false           True enables stream looping. DEPRECATED, use PlaybackLoopMode
        PlaylistLoop            boolean     true            True enables playlist looping. DEPRECATED, use PlaybackLoopMode
]]

-- ======================================================================
-- === Don't edit anything below, unless you know what you are doing. ===
-- === Really, you don't need to. Report it to me if you find a bug.  ===
-- ======================================================================

local ValidTypes = {
	StreamName = "string",
	StreamUrl = "string",

	StreamMute = "boolean",
	StreamVolume = "number",
	Radius = "number",
	Sound3D = "boolean",
	DisableInput = "boolean",
	DisableDisplay = "boolean",
	DisableSpectrum = "boolean",
	DisableAdvancedOutputs = "boolean",

	PlaybackLoopMode = "number",

	-- @DEPRECATED
	StreamLoop = "boolean",
	PlaylistLoop = "boolean",
}

function StreamRadioLib.IsValidRadioSettings( settings )
	if ( not settings ) then return true end
	if TypeID( settings ) ~= TYPE_TABLE then return false end

	for k, v in pairs( settings ) do
		if ValidTypes[k] and type( v ) ~= ValidTypes[k] then return false end
	end

	return true
end

local function ErrorCheckArg( var, tright, argn, funcname, level )
	if ( var == nil ) then return true end
	local t = type( var )

	if t ~= tright then
		StreamRadioLib.Util.ErrorNoHaltWithStack( string.format( "bad argument #%i to '%s' (%s or nil expected, got %s)", argn, funcname, tright, t ), level or 3 )
		return false
	end

	return true
end

local function ErrorCheckRadioSettings( settings, argn, funcname, level )
	level = level or 3
	if not ErrorCheckArg( settings, "table", argn, funcname, level + 1 ) then return false end

	for k, v in pairs( settings ) do
		local t = type( v )
		local tright = ValidTypes[k]
		if not tright or t == tright then continue end
		StreamRadioLib.Util.ErrorNoHaltWithStack( string.format( "bad datatype at index '%s' of argument #%i at '%s' (%s or nil expected, got %s)", k, argn, funcname, tright, t ), level )

		return false
	end

	return true
end

function StreamRadioLib.EditRadio( ent, settings )
	if not StreamRadioLib.Loaded then return false end

	if not SERVER then return false end
	if not ErrorCheckArg( ent, "Entity", 1, "EditRadio", 3 ) then return false end
	if not IsValid( ent ) then return false end
	if not ent.__IsRadio then return false end

	settings = settings or {}
	if not ErrorCheckRadioSettings( settings, 2, "EditRadio", 3 ) then return false end

	if ent.SetSettings then
		ent:SetSettings(settings)
	end

	return true
end

local Ang_Zero = Angle( )
local Vec_Zero = Vector( )

function StreamRadioLib.SpawnRadio( ply, model, pos, ang, settings )
	if not SERVER then return end

	local StreamRadioLib = StreamRadioLib or {}

	if not StreamRadioLib.Loaded then
		if StreamRadioLib.Loader_ShowSpawnError then
			StreamRadioLib.Loader_ShowSpawnError("The Entity 'sent_streamradio' could not be spawned.")
		end

		return
	end

	if not IsValid(ply) or ply:IsWorld() then
		ply = nil
	end

	if not ErrorCheckArg(ply, "Player", 1, "SpawnRadio", 3) then return end

	if not ErrorCheckArg(model, "string", 2, "SpawnRadio", 3) then return end
	if not ErrorCheckArg(pos, "Vector", 3, "SpawnRadio", 3) then return end
	if not ErrorCheckArg(ang, "Angle", 4, "SpawnRadio", 3) then return end

	settings = settings or {}
	if not ErrorCheckRadioSettings(settings, 5, "SpawnRadio", 3) then return end

	local ent = ents.Create( "sent_streamradio" )
	if not IsValid(ent) then return end

	if StreamRadioLib.Util.IsValidModel(model) then
		ent:SetModel(model)
	end

	ent:SetPos(pos or Vec_Zero)
	ent:SetAngles(ang or Ang_Zero)

	ent:Spawn()
	ent:Activate()

	local data = {}
	data.pl = ply
	data.Owner = ply

	if isfunction(ent.CPPISetOwner) then
		ent:CPPISetOwner(ply)
	end

	if isfunction(ent.SetLastUser) then
		ent:SetLastUser(ply)
	end

	if isfunction(ent.SetRadioOwner) then
		ent:SetRadioOwner(ply)
	end

	for k, v in pairs(data) do
		ent[k] = v
	end

	if not StreamRadioLib.EditRadio(ent, settings) then return end
	ent:PhysWake()

	timer.Simple(0.05, function()
		if not IsValid(ent) then return end
		if not ent.ReapplyClasssystemPaste then return end

		ent:ReapplyClasssystemPaste()
	end)

	return ent
end

return true


--PATH lua/streamradio_core/hook.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Hook = StreamRadioLib.Hook or {}

local LIB = StreamRadioLib.Hook
table.Empty(LIB)

local g_namePrefixMain = "3DStreamRadio_mainHook_"
local g_namePrefixCustom = "3DStreamRadio_"
local g_hooks = {}
local g_orderCounter = 0

local function getMainHookIdentifier(eventName)
	local identifier = g_namePrefixMain .. tostring(eventName or "")
	return identifier
end

local function getCustomHookIdentifier(eventName)
	local identifier = g_namePrefixCustom .. tostring(eventName or "")
	return identifier
end

local function CallHooks(hookData, ...)
	-- Called by all hooks the addon adds to the game, including think and tick.
	-- It is a proxy that distribute calls to all internal addon hooks.
	-- This reduces overhead from the native hook library.

	-- Prevent error spams when the addon is not completely loaded
	if not StreamRadioLib then return nil end
	if not StreamRadioLib.Loaded then return nil end

	local byOrder = hookData.byOrder
	if not byOrder then
		return nil
	end

	local benchmarkStart = SysTime()
	local benchmarkEnd = 0
	local benchmark = 0
	local benchmarkAvg = 0

	local lastBenchmarkAvg = hookData.benchmarkAvg or 0

	local r1, r2, r3, r4, r5, r6, r7, r8

	for i, hookItem in ipairs(byOrder) do
		local a, b, c, d, e, f, g, h = hookItem.func(...)

		if a == nil then
			continue
		end

		r1, r2, r3, r4, r5, r6, r7, r8 = a, b, c, d, e, f, g, h
		break
	end

	benchmarkEnd = SysTime()
	benchmark = benchmarkEnd - benchmarkStart
	benchmarkAvg = (lastBenchmarkAvg + benchmark) / 2

	hookData.benchmark = benchmark
	hookData.benchmarkAvg = benchmarkAvg

	if r1 == nil then
		return nil
	end

	return r1, r2, r3, r4, r5, r6, r7, r8
end

local function BuildOrder(hookData)
	hookData.byOrder = nil

	local byName = hookData.byName
	if not byName then
		return
	end

	if table.IsEmpty(byName) then
		return
	end

	local byOrder = table.ClearKeys(byName)

	table.SortByMember(byOrder, "order", true)

	hookData.byOrder = byOrder
end

function LIB.Has(eventName, identifier)
	identifier = tostring(identifier or "")
	eventName = tostring(eventName or "")

	local hookData = g_hooks[eventName]
	if not hookData then
		return false
	end

	local byName = hookData.byName
	if not byName then
		return false
	end

	if not byName[identifier] then
		return false
	end

	return true
end

function LIB.Add(eventName, identifier, func, order)
	if not isfunction(func) then return end

	identifier = tostring(identifier or "")
	eventName = tostring(eventName or "")
	order = tonumber(order or 0) or 0

	if order == 0 then
		order = 1000000 + g_orderCounter * 1000
		g_orderCounter = (g_orderCounter % 1000000) + 1
	end

	LIB.Remove(eventName, identifier)

	g_hooks[eventName] = g_hooks[eventName] or {}
	local hookData = g_hooks[eventName]

	hookData.byName = hookData.byName or {}
	local byName = hookData.byName

	byName[identifier] = {
		order = order,
		func = func,
		identifier = identifier,
	}

	hookData.benchmark = hookData.benchmark or 0
	hookData.benchmarkAvg = hookData.benchmarkAvg or 0

	BuildOrder(hookData)

	if not hookData.hasHook then
		local hookIdentifier = getMainHookIdentifier(eventName)

		hook.Remove(eventName, hookIdentifier)
		hook.Add(eventName, hookIdentifier, function(...)
			return CallHooks(hookData, ...)
		end)

		hookData.hasHook = true
	end
end

function LIB.Remove(eventName, identifier)
	identifier = tostring(identifier or "")
	eventName = tostring(eventName or "")

	local hookData = g_hooks[eventName]
	if not hookData then
		return
	end

	local byName = hookData.byName
	if not byName then
		return
	end

	byName[identifier] = nil

	BuildOrder(hookData)

	if table.IsEmpty(byName) then
		local hookIdentifier = getMainHookIdentifier(eventName)

		hook.Remove(eventName, hookIdentifier)
		hookData.hasHook = nil
	end
end

function LIB.Run(eventName, ...)
	eventName = tostring(eventName or "")
	return hook.Run(eventName, ...)
end

function LIB.AddCustom(eventName, ...)
	local eventName = getCustomHookIdentifier(eventName)
	return LIB.Add(eventName, ...)
end

function LIB.RemoveCustom(eventName, ...)
	local eventName = getCustomHookIdentifier(eventName)
	return LIB.Remove(eventName, ...)
end

function LIB.RunCustom(eventName, ...)
	local eventName = getCustomHookIdentifier(eventName)
	return LIB.Run(eventName, ...)
end

function LIB.GetBenchmark(eventName)
	eventName = tostring(eventName or "")

	local hookData = g_hooks[eventName]
	if not hookData then
		return 0, 0
	end

	local benchmark = hookData.benchmark or 0
	local benchmarkAvg = hookData.benchmarkAvg or 0

	return benchmark, benchmarkAvg
end

return true


--PATH lua/streamradio_core/timedpairs.lua:
-- Timedpairs by Grocel. (Rewrite by Divran)
-- It allows you to go through long tables, but without game freezing.
-- Its like a for-pairs loop.
--
-- How to use:
-- StreamRadioLib.Timedpairs( string unique name, table, number ticks done at once, function tickcallback[, function endcallback, ...] )
--
-- tickcallback is called every tick, it ticks for each KeyValue of the table.
-- Its arguments are the current key and value.
-- Return false in the tickcallback function to break the loop.
-- tickcallback( key, value, ... )
--
-- endcallback is called after the last tickcallback has been called.
-- Its arguments are the same as the last arguments of StreamRadioLib.Timedpairs
-- endcallback( lastkey, lastvalue, ... )
if ( not StreamRadioLib ) then return end
local next = next
local pairs = pairs
local unpack = unpack
local pcall = pcall
local ErrorNoHalt = ErrorNoHalt
local functions = {}

function StreamRadioLib.TimedpairsGetTable( )
	return functions
end

function StreamRadioLib.TimedpairsStop( name )
	local data = functions[name]

	if data then
		local lookup = data.lookup or {}

		-- If we had any end callback function
		if data.endcallback then
			local kv = lookup[data.currentindex - 1] or {} -- get previous key & value
			local ok, err = pcall( data.endcallback, kv.key, kv.value, unpack( data.args ) )

			if not ok then
				ErrorNoHalt( "Error in Timedpairs '" .. name .. "' ( in end function ): " .. err .. "\n" )
			end
		end
	end

	functions[name] = nil
end

-- custom table copy function to convert to numerically indexed table
local function copy( t )
	local ret = {}

	for k, v in pairs( t ) do
		table.insert(ret, {
			key = k,
			value = v
		})
	end

	return ret
end

local function Timedpairs( )
	if not StreamRadioLib then return end
	if not StreamRadioLib.Loaded then return end

	if not next( functions ) then return end
	local toremove = {}

	-- If there are any more values..
	for name, data in pairs( functions ) do
		for i = 1, data.step do
			data.currentindex = data.currentindex + 1 -- increment index counter
			local lookup = data.lookup or {}

			if data.currentindex <= #lookup then
				local kv = lookup[data.currentindex] or {} -- Get the current key and value
				local ok, err = pcall( data.callback, kv.key, kv.value, unpack( data.args ) ) -- DO EET

				if not ok then
					ErrorNoHalt( "Error in Timedpairs '" .. name .. "': " .. err .. "\n" )
					table.insert(toremove, name)
					break
				elseif err == false then
					-- They returned false inside the function
					if data.endcallback then
						local kv = lookup[data.currentindex - 1] or {} -- get previous key & value
						local ok, err = pcall( data.endcallback, kv.key, kv.value, unpack( data.args ) )

						if not ok then
							ErrorNoHalt( "Error in Timedpairs '" .. name .. "' ( in end function ): " .. err .. "\n" )
						end
					end

					-- If we had any end callback function
					table.insert(toremove, name)
					break
				end
			else
				-- oh noes
				-- Out of keys. Entire table looped
				if data.endcallback then
					local kv = lookup[data.currentindex - 1] or {} -- get previous key & value
					local ok, err = pcall( data.endcallback, kv.key, kv.value, unpack( data.args ) )

					if not ok then
						ErrorNoHalt( "Error in Timedpairs '" .. name .. "' ( in end function ): " .. err .. "\n" )
					end
				end

				-- If we had any end callback function
				table.insert(toremove, name)
				break
			end
		end
	end

	-- Remove all that were flagged for removal
	for i = 1, #toremove do
		functions[toremove[i]] = nil
	end
end

if ( CLIENT ) then
	StreamRadioLib.Hook.Add( "PostRenderVGUI", "Timedpairs", Timedpairs ) -- Doesn't get paused in single player. Can be important for vguis.
else
	StreamRadioLib.Hook.Add( "Think", "Timedpairs", Timedpairs ) -- Servers still uses Think.
end

function StreamRadioLib.Timedpairs( name, tab, step, callback, endcallback, ... )
	functions[name] = {
		lookup = copy( tab ),
		step = step,
		currentindex = 0,
		callback = callback,
		endcallback = endcallback,
		args = {...}
	}
end

local g_dummytab = {true}
local g_id = 0

-- calls the given function like simple timer, but isn't affected by game pausing.
function StreamRadioLib.Timedcall( callback, ... )
	g_id = (g_id % 2 ^ 30) + 1

	StreamRadioLib.Timedpairs( "Timedcall_" .. g_id, g_dummytab, 1, function( k, v, ... )
		callback( ... )
	end, nil, ... )
end

return true


--PATH lua/streamradio_core/lib.lua:
local tostring = tostring
local tonumber = tonumber
local IsValid = IsValid
local LocalPlayer = LocalPlayer
local util = util
local string = string
local math = math
local hook = hook
local SERVER = SERVER
local CLIENT = CLIENT

local StreamRadioLib = StreamRadioLib

local catchAndErrorNoHaltWithStack = StreamRadioLib.Util.CatchAndErrorNoHaltWithStack

function StreamRadioLib.IsGUIHidden(ply)
	if not IsValid(ply) and CLIENT then
		ply = LocalPlayer()
	end

	if not IsValid(ply) then return true end
	if not ply:IsPlayer() then return true end
	if ply:IsBot() then return true end

	return tobool(ply:GetInfo("cl_streamradio_hidegui"))
end

function StreamRadioLib.IsMuted(ply, owner)
	if not IsValid(ply) and CLIENT then
		ply = LocalPlayer()
	end

	if not IsValid(ply) then return true end
	if not ply:IsPlayer() then return true end
	if ply:IsBot() then return true end

	local muted = tobool(ply:GetInfo("cl_streamradio_mute"))
	if muted then
		return true
	end

	local volume = tonumber(ply:GetInfo("cl_streamradio_volume") or 0) or 0
	if volume <= 0 then
		return true
	end

	if IsValid(owner) and owner:IsPlayer() and not owner:IsBot() and owner ~= ply then
		local mutedForeign = tobool(ply:GetInfo("cl_streamradio_mute_foreign"))
		if mutedForeign then
			return true
		end
	end

	if SERVER then
		return false
	end

	local muteunfocused = tobool(ply:GetInfo("cl_streamradio_muteunfocused"))
	if not muteunfocused then
		return false
	end

	if system.HasFocus() then
		return false
	end

	return true
end

function StreamRadioLib.GetMuteDistance( ply )
	if not IsValid(ply) and CLIENT then
		ply = LocalPlayer()
	end

	if not IsValid(ply) then return 0 end
	if not ply:IsPlayer() then return 0 end
	if ply:IsBot() then return 0 end

	return math.Clamp(tonumber(ply:GetInfo("cl_streamradio_mutedistance")) or 500, 500, 5000)
end

function StreamRadioLib.GetCameraEnt(ply)
	if not IsValid(ply) and CLIENT then
		ply = LocalPlayer()
	end

	if not IsValid(ply) then
		return nil
	end

	local camera = ply:GetViewEntity()
	if not IsValid(camera) then
		return ply
	end

	return camera
end

function StreamRadioLib.GetCameraPos(ent)
	if not IsValid(ent) and CLIENT then
		ent = LocalPlayer()
	end

	if StreamRadioLib.VR.IsActive(ent) then
		local pos = StreamRadioLib.VR.GetCameraPos(ent)
		return pos
	end

	if StreamRadioLib.Wire.IsWireUser(ent) then
		return StreamRadioLib.Wire.GetUserPos(ent)
	end

	local camera = StreamRadioLib.GetCameraEnt(ent)
	if not IsValid(camera) then return nil end

	local pos = nil

	if camera:IsPlayer() then
		pos = camera:EyePos()
	else
		pos = camera:GetPos()
	end

	return pos
end

function StreamRadioLib.GetControlPosDir(ent)
	if not IsValid(ent) and CLIENT then
		ent = LocalPlayer()
	end

	if StreamRadioLib.VR.IsActive(ent) then
		local pos, dir = StreamRadioLib.VR.GetControlPosDir(ent)
		return pos, dir
	end

	if StreamRadioLib.Wire.IsWireUser(ent) then
		local pos, dir = StreamRadioLib.Wire.GetUserPosDir(ent)
		return pos, dir
	end

	local camera = StreamRadioLib.GetCameraEnt(ent)

	if not IsValid(ent) then return nil end
	if not IsValid(camera) then return nil end

	local pos, dir

	if camera:IsPlayer() then
		pos = camera:EyePos()
		dir = camera:GetAimVector()
	else
		pos = camera:GetPos()

		-- This is not a mistake
		-- This allows UI clicks/use via C-Menu aim
		dir = ent:GetAimVector()
	end

	return pos, dir
end

local g_PlayerTraceCache = {}
local g_PlayerTraceCacheCount = 0

local g_PlayerTrace = {}
g_PlayerTrace.filter = {}

function StreamRadioLib.Trace(ent)
	if not IsValid(ent) and CLIENT then
		ent = LocalPlayer()
	end

	if not IsValid(ent) then
		return nil
	end

	if StreamRadioLib.Wire.IsWireUser(ent) then
		local trace = StreamRadioLib.Wire.WireUserTrace(ent)
		return trace
	end

	local camera = StreamRadioLib.GetCameraEnt(ent)
	if not IsValid(camera) then return nil end

	local cacheID = tostring(ent or "")
	local cacheItem = g_PlayerTraceCache[cacheID]

	if cacheItem and StreamRadioLib.Util.IsSameFrame("StreamRadioLib.Trace_" .. cacheID) then
		return cacheItem
	end

	g_PlayerTraceCache[cacheID] = nil

	local pos, dir = StreamRadioLib.GetControlPosDir(ent)

	if not pos then
		return nil
	end

	if not dir then
		return nil
	end

	local start_pos = pos
	local end_pos = pos + dir * 5000

	g_PlayerTrace.start = start_pos
	g_PlayerTrace.endpos = end_pos

	local entVehicle = ent.GetVehicle and ent:GetVehicle() or false
	local cameraVehicle = camera.GetVehicle and camera:GetVehicle() or false

	local tmp = {}

	tmp[ent] = ent
	tmp[camera] = camera
	tmp[entVehicle] = entVehicle
	tmp[cameraVehicle] = cameraVehicle

	local filter = g_PlayerTrace.filter
	table.Empty(filter)

	for _, filterEnt in pairs(tmp) do
		if not IsValid(filterEnt) then continue end
		table.insert(filter, filterEnt)
	end

	local trace = util.TraceLine(g_PlayerTrace)

	-- prevent the cache from overflowing
	if g_PlayerTraceCacheCount > 1024 then
		StreamRadioLib.Util.EmptyTableSafe(g_PlayerTraceCache)
		g_PlayerTraceCacheCount = 0
	end

	g_PlayerTraceCache[cacheID] = trace

	if not cacheItem then
		g_PlayerTraceCacheCount = g_PlayerTraceCacheCount + 1
	end

	return g_PlayerTraceCache[cacheID]
end

local g_PI = math.pi
local g_TAU = g_PI * 2
local g_starTracePoses = {}

local function buildStarTracePoses(layers, edges)
	layers = math.abs(layers or 0)
	edges = math.abs(edges or 0)

	for l = 1, layers do
		local u = g_TAU / layers * l

		for e = 1, edges do
			local v = g_TAU / edges * e

			local x = math.cos(u) * math.cos(v)
			local y = math.cos(u) * math.sin(v)
			local z = math.sin(u)

			local v = Vector(x, y, z)
			v:Normalize()

			if g_starTracePoses[v] then continue end
			g_starTracePoses[v] = true
		end
	end

	g_starTracePoses[Vector(0, 0, 1)] = true
	g_starTracePoses[Vector(0, 1, 0)] = true
	g_starTracePoses[Vector(1, 0, 0)] = true

	g_starTracePoses[Vector(0, 0, -1)] = true
	g_starTracePoses[Vector(0, -1, 0)] = true
	g_starTracePoses[Vector(-1, 0, 0)] = true
end

buildStarTracePoses(10, 6)

function StreamRadioLib.StarTrace(traceparams, size)
	traceparams = traceparams or {}

	local centerpos = traceparams.start or Vector()

	size = math.abs(size or 0)

	traceparams.start = centerpos
	traceparams.output = nil

	local traces = {}

	for v, _ in pairs(g_starTracePoses) do
		local endpos = centerpos + v * size
		traceparams.endpos = endpos

		local trace = util.TraceLine(traceparams)

		-- Tracers Debug
		-- debugoverlay.Line(centerpos, trace.HitPos or endpos, 0.5, color_white, false)
		-- debugoverlay.Line(trace.HitPos or endpos, endpos, 0.5, color_black, false)

		table.insert(traces, trace)
	end

	return traces
end

local g_mat_cache = {}

function StreamRadioLib.GetCustomPNGPath(name)
	if SERVER then return nil end
	if not name then return nil end

	local path = "3dstreamradio/" .. name .. ".png"
	return path
end

function StreamRadioLib.GetCustomPNG(name)
	if SERVER then return nil end
	if not name then return nil end

	local path = StreamRadioLib.GetCustomPNGPath(name)
	if not path then return nil end

	local mat = g_mat_cache[path]

	if mat then
		return mat
	end

	mat = Material( path, "nocull" )
	return mat
end

function StreamRadioLib.GetPNGIconPath(name, custom)
	if SERVER then return nil end
	if not name then return nil end

	local prepath = "icon16/" .. name

	if custom then
		return StreamRadioLib.GetCustomPNGPath(prepath)
	end

	local path = prepath .. ".png"
	return path
end

function StreamRadioLib.GetPNGIcon(name, custom)
	if SERVER then return nil end
	if not name then return nil end

	local path = StreamRadioLib.GetPNGIconPath(name, custom)
	if not path then return nil end

	local mat = g_mat_cache[path]

	if mat then
		return mat
	end

	mat = Material( path, "nocull" )

	return mat
end

function StreamRadioLib.GetHierarchy(hierarchy)
	if isstring(hierarchy) then
		if hierarchy == "" then
			return {}
		end

		return string.Explode("[%/%\\]", hierarchy, true) or {}
	end

	if istable(hierarchy) then
		return hierarchy
	end

	return nil
end

function StreamRadioLib.SetSkinTableProperty(tab, hierarchy, property, value)
	hierarchy = StreamRadioLib.GetHierarchy(hierarchy)
	if not hierarchy then return tab end

	tab = tab or {}
	property = tostring(property or "")

	local count = #hierarchy

	if count <= 0 then
		tab.data = tab.data or {}
		tab.data[property] = value
		return tab
	end

	tab.children = tab.children or {}
	local curskin = tab.children

	for i, v in ipairs(hierarchy) do
		local sk = curskin[v] or {}

		if i >= count then
			sk.data = sk.data or {}
			sk.data[property] = value
			curskin[v] = sk
			break
		end

		sk.children = sk.children or {}
		curskin[v] = sk
		curskin = curskin[v].children
	end

	return tab
end

local function ReleaseLastRadioControl(ply, trace, userEntity)
	local LastRadio = userEntity._3dstreamradio_lastusedradio
	userEntity._3dstreamradio_lastusedradio = nil

	if not IsValid( LastRadio ) then return end
	if not LastRadio.__IsRadio then return end
	if not LastRadio.Control then return end

	LastRadio:Control( ply, trace, false, userEntity )
end

local g_checkPropProtectionCache = {}
local g_checkPropProtectionCacheEmpty = true
local g_checkPropProtectionCacheExpire = nil

local function ClearCheckPropProtectionCache()
	if g_checkPropProtectionCacheEmpty then
		return
	end

	StreamRadioLib.Util.EmptyTableSafe(g_checkPropProtectionCache)

	g_checkPropProtectionCacheEmpty = true
	g_checkPropProtectionCacheExpire = nil
end

function StreamRadioLib.CheckPropProtectionAgainstUse(ent, ply)
	if not IsValid( ent ) then return false end
	if not IsValid( ply ) then return false end

	if CLIENT and not ent.CPPICanUse then
		return true
	end

	local cacheId = tostring(ent) .. "_" .. tostring(ply)
	local now = RealTime()

	-- cache the check result for a short time to avoid spam calling the hook "PlayerUse" and CPPI
	if g_checkPropProtectionCacheExpire and g_checkPropProtectionCacheExpire <= now then
		ClearCheckPropProtectionCache()
	end

	if g_checkPropProtectionCache[cacheId] ~= nil then
		return g_checkPropProtectionCache[cacheId]
	end

	if g_checkPropProtectionCacheEmpty then
		g_checkPropProtectionCacheExpire = now + 3
		g_checkPropProtectionCacheEmpty = false
	end

	g_checkPropProtectionCache[cacheId] = false

	-- Support for prop protections
	if ent.CPPICanUse then
		local status, use = catchAndErrorNoHaltWithStack(ent.CPPICanUse, ent, ply)

		if not status then
			return false
		end

		if not use then
			return false
		end
	end

	if SERVER then
		local status, use = catchAndErrorNoHaltWithStack(StreamRadioLib.Hook.Run, "PlayerUse", ply, ent)

		if not status then
			return false
		end

		if not use then
			return false
		end
	end

	g_checkPropProtectionCache[cacheId] = true
	return true
end

function StreamRadioLib.CanUseRadio(ply, radio, userEntity)
	if not IsValid( ply ) then return false end
	if not IsValid( radio ) then return false end
	if not radio.__IsRadio then return false end
	if not radio.Control then return false end
	if not radio.CanControl then return false end

	if not IsValid(userEntity) then
		userEntity = ply
	end

	local use = radio:CanControl(ply, userEntity)
	if not use then
		return false
	end

	return true
end

function StreamRadioLib.Control( ply, trace, keydown, userEntity )
	if not IsValid( ply ) then return end

	if not IsValid(userEntity) then
		userEntity = ply
	end

	if not trace then
		ReleaseLastRadioControl( ply, nil, userEntity )
		return
	end

	if not keydown then
		ReleaseLastRadioControl( ply, trace, userEntity )
		return
	end

	local Radio = trace.Entity
	local LastRadio = userEntity._3dstreamradio_lastusedradio

	if not StreamRadioLib.CanUseRadio( ply, Radio, userEntity ) then
		ReleaseLastRadioControl( ply, trace, userEntity )
		return
	end

	if Radio ~= LastRadio then
		ReleaseLastRadioControl( ply, trace, userEntity )
	end

	local rv = Radio:Control( ply, trace, true, userEntity )
	userEntity._3dstreamradio_lastusedradio = Radio

	return rv
end

function StreamRadioLib.TabControl( ply, trace, userEntity )
	if not IsValid(ply) and CLIENT then
		ply = LocalPlayer()
	end

	if not IsValid(ply) then
		return
	end

	if not trace then
		return
	end

	if not IsValid(userEntity) then
		userEntity = ply
	end

	local ent = trace.Entity
	if not IsValid( ent ) then
		return
	end

	if not ent.__IsRadio then
		return
	end

	local name = tostring(ent) .. "_" .. tostring(ply) .. "_TabControl"

	trace = table.Copy(trace)

	StreamRadioLib.Control(ply, trace, true, userEntity)

	StreamRadioLib.Timer.NextFrame(name, function()
		if not IsValid(ply) then
			return
		end

		if not IsValid(ent) then
			return
		end

		if not IsValid(userEntity) then
			return
		end

		StreamRadioLib.Control(ply, trace, false, userEntity)
	end)
end

local g_PlayerCache = {}
local g_LocalPlayer = nil

function StreamRadioLib.GetPlayerId(ply)
	if not IsValid(ply) then
		return nil
	end

	if not ply:IsPlayer() then
		return nil
	end

	if ply:IsBot() then
		return nil
	end

	if game.SinglePlayer() then
		return "LOCAL_CLIENT"
	end

	if SERVER and not ply:IsConnected() then
		return nil
	end

	local id = ply:SteamID64()
	if not id then
		-- fallback to player string on invalid ids
		id = tostring(ply) .. "[" .. ply:UserID() .. "]";
	end

	g_PlayerCache[id] = ply
	return id
end

function StreamRadioLib.GetPlayerFromId(id)
	id = tostring(id or "")

	if id == "" then
		return nil
	end

	if game.SinglePlayer() then
		if id == "LOCAL_CLIENT" then
			if not IsValid(g_LocalPlayer) then
				g_LocalPlayer = player.GetHumans()[1]
			end

			if not IsValid(g_LocalPlayer) then
				return nil
			end

			return g_LocalPlayer
		end

		return nil
	end


	local ply = g_PlayerCache[id]

	if not IsValid(ply) then
		ply = player.GetBySteamID64(id)
	end

	g_PlayerCache[id] = nil

	if not IsValid(ply) then
		return nil
	end

	if ply:IsBot() then
		return nil
	end

	if SERVER and not ply:IsConnected() then
		return nil
	end

	g_PlayerCache[id] = ply
	return ply
end

local _GetPlayerId = StreamRadioLib.GetPlayerId
local _GetPlayerFromId = StreamRadioLib.GetPlayerFromId

function StreamRadioLib.IsPlayerNetworkable(plyOrId)
	if isentity(plyOrPId) then
		return _GetPlayerId(plyOrId) ~= nil
	end

	return IsValid(_GetPlayerFromId(plyOrId))
end

StreamRadioLib.SpawnedRadios = {}

local g_nextFastThink = 0
local g_radioCount = 0
local g_streamingRadioCount = 0

StreamRadioLib.Hook.Add("Think", "RadioCounter", function()
	StreamRadioLib.SpawnedRadios = StreamRadioLib.SpawnedRadios or {}
	local spawnedRadios = StreamRadioLib.SpawnedRadios

	local radioCount = 0
	local streamingRadioCount = 0

	for index, ent in pairs(spawnedRadios) do
		if not IsValid(ent) then
			spawnedRadios[index] = nil
			continue
		end

		if not ent.__IsRadio then
			spawnedRadios[index] = nil
			continue
		end

		radioCount = radioCount + 1

		if ent.IsStreaming and ent:IsStreaming() then
			streamingRadioCount = streamingRadioCount + 1
		end
	end

	g_radioCount = radioCount
	g_streamingRadioCount = streamingRadioCount

	if g_radioCount <= 0 then
		ClearCheckPropProtectionCache()
		return
	end
end)

StreamRadioLib.Hook.Add("Think", "EntityFastThink", function()
	local now = RealTime()
	if g_nextFastThink > now then return end

	g_nextFastThink = now + 0.01

	local radios = StreamRadioLib.SpawnedRadios
	if not radios then
		return
	end

	for index, ent in pairs(radios) do
		if not IsValid(ent) then
			continue
		end

		if ent.FastThink then
			-- Think with a faster rate that doesn't interfere with model animations
			ent:FastThink()
		end

		if ent:IsDormant() then
			continue
		end

		if not ent.NonDormantThink then
			continue
		end

		-- Called when the radio is not Dormant
		ent:NonDormantThink()
	end
end)

function StreamRadioLib.GetRadioCount()
	return g_radioCount
end

function StreamRadioLib.HasSpawnedRadios()
	return g_radioCount > 0
end

function StreamRadioLib.GetStreamingRadioCount()
	return g_streamingRadioCount
end

function StreamRadioLib.HasStreamingRadios()
	return g_streamingRadioCount > 0
end

function StreamRadioLib.RegisterRadio(ent)
	if not IsValid(ent) then
		return
	end

	if not ent.__IsRadio then
		return
	end

	StreamRadioLib.Network.SetupEntityTable(ent)
	StreamRadioLib.SpawnedRadios[ent:GetCreationID()] = ent
end

function StreamRadioLib.UnregisterRadio(entOrCreationID)
	if isnumber(entOrCreationID) then
		StreamRadioLib.SpawnedRadios[entOrCreationID] = nil
		return
	end

	if not IsValid(ent) then
		return
	end

	StreamRadioLib.SpawnedRadios[ent:GetCreationID()] = nil
end

return true


--PATH lua/streamradio_core/enum.lua:
StreamRadioLib.STREAM_PLAYMODE_STOP = 0
StreamRadioLib.STREAM_PLAYMODE_PAUSE = 1
StreamRadioLib.STREAM_PLAYMODE_PLAY = 2
StreamRadioLib.STREAM_PLAYMODE_PLAY_RESTART = 3

-- Placeholder for Blocked URLs with non-Keyboard chars (legacy)
StreamRadioLib.BlockedURLCodeSequence = string.char(124, 245, 142, 188, 5, 6, 2, 1, 2, 54, 12, 7, 5)
StreamRadioLib.BlockedURLCode = string.format("__blocked_url_replaced_with_special_sequence___[%s]___pls_ignore_this!__", StreamRadioLib.BlockedURLCodeSequence)

StreamRadioLib.PLAYBACK_LOOP_MODE_NONE = 0
StreamRadioLib.PLAYBACK_LOOP_MODE_SONG = 1
StreamRadioLib.PLAYBACK_LOOP_MODE_PLAYLIST = 2


StreamRadioLib.EDITOR_ERROR_OK = 0
StreamRadioLib.EDITOR_ERROR_WRITE_OK = 1
StreamRadioLib.EDITOR_ERROR_READ_OK = 2
StreamRadioLib.EDITOR_ERROR_FILES_OK = 3
StreamRadioLib.EDITOR_ERROR_DIR_OK = 4
StreamRadioLib.EDITOR_ERROR_DEL_OK = 5
StreamRadioLib.EDITOR_ERROR_COPY_OK = 6
StreamRadioLib.EDITOR_ERROR_RENAME_OK = 7

StreamRadioLib.EDITOR_ERROR_WPATH = 10
StreamRadioLib.EDITOR_ERROR_WDATA = 11
StreamRadioLib.EDITOR_ERROR_WFORMAT = 12
StreamRadioLib.EDITOR_ERROR_WVIRTUAL = 13
StreamRadioLib.EDITOR_ERROR_WRITE = 14

StreamRadioLib.EDITOR_ERROR_DIR_WRITE = 14
StreamRadioLib.EDITOR_ERROR_DIR_EXIST = 15
StreamRadioLib.EDITOR_ERROR_FILE_EXIST = 16
StreamRadioLib.EDITOR_ERROR_DEL_ACCES = 17

StreamRadioLib.EDITOR_ERROR_RPATH = 20
StreamRadioLib.EDITOR_ERROR_RDATA = 21
StreamRadioLib.EDITOR_ERROR_RFORMAT = 22
StreamRadioLib.EDITOR_ERROR_READ = 23

StreamRadioLib.EDITOR_ERROR_COPY_DIR = 30
StreamRadioLib.EDITOR_ERROR_COPY_EXIST = 31
StreamRadioLib.EDITOR_ERROR_COPY_WRITE = 32
StreamRadioLib.EDITOR_ERROR_COPY_READ = 33

StreamRadioLib.EDITOR_ERROR_RENAME_DIR = 40
StreamRadioLib.EDITOR_ERROR_RENAME_EXIST = 41
StreamRadioLib.EDITOR_ERROR_RENAME_WRITE = 42
StreamRadioLib.EDITOR_ERROR_RENAME_READ = 43

StreamRadioLib.EDITOR_ERROR_COMMUNITY_PROTECTED = 50
StreamRadioLib.EDITOR_ERROR_VIRTUAL_PROTECTED = 51
StreamRadioLib.EDITOR_ERROR_NOADMIN = 252
StreamRadioLib.EDITOR_ERROR_RESET = 253
StreamRadioLib.EDITOR_ERROR_UNIMPLEMENTED = 254
StreamRadioLib.EDITOR_ERROR_UNKNOWN = 255

local EditorErrors = {
	-- Code										// Error
	[StreamRadioLib.EDITOR_ERROR_OK] = "OK",
	[StreamRadioLib.EDITOR_ERROR_WRITE_OK] = "OK",
	[StreamRadioLib.EDITOR_ERROR_READ_OK] = "OK",
	[StreamRadioLib.EDITOR_ERROR_FILES_OK] = "OK",
	[StreamRadioLib.EDITOR_ERROR_DIR_OK] = "OK",
	[StreamRadioLib.EDITOR_ERROR_DEL_OK] = "OK",
	[StreamRadioLib.EDITOR_ERROR_COPY_OK] = "OK",
	[StreamRadioLib.EDITOR_ERROR_RENAME_OK] = "OK",
	[StreamRadioLib.EDITOR_ERROR_WPATH] = "Invalid path!",
	[StreamRadioLib.EDITOR_ERROR_WDATA] = "Invalid data!",
	[StreamRadioLib.EDITOR_ERROR_WVIRTUAL] = "This virtual file is readonly!",
	[StreamRadioLib.EDITOR_ERROR_WFORMAT] = "Invalid file format!\nValid formats are: %s",
	[StreamRadioLib.EDITOR_ERROR_WRITE] = "Couldn't write the file!",
	[StreamRadioLib.EDITOR_ERROR_DIR_WRITE] = "Couldn't create the directory!",
	[StreamRadioLib.EDITOR_ERROR_DIR_EXIST] = "This directory already exists!",
	[StreamRadioLib.EDITOR_ERROR_FILE_EXIST] = "This file already exists!",
	[StreamRadioLib.EDITOR_ERROR_DEL_ACCES] = "Couldn't delete the file or the directory!",
	[StreamRadioLib.EDITOR_ERROR_RPATH] = "Invalid path!",
	[StreamRadioLib.EDITOR_ERROR_RDATA] = "Couldn't read the file!",
	[StreamRadioLib.EDITOR_ERROR_RFORMAT] = "Couldn't read the file format!",
	[StreamRadioLib.EDITOR_ERROR_READ] = "Couldn't read the file!",
	[StreamRadioLib.EDITOR_ERROR_COPY_DIR] = "You can't copy a directory",
	[StreamRadioLib.EDITOR_ERROR_COPY_EXIST] = "This file already exists!",
	[StreamRadioLib.EDITOR_ERROR_COPY_WRITE] = "Couldn't create the copy!",
	[StreamRadioLib.EDITOR_ERROR_COPY_READ] = "Couldn't read the source file!",
	[StreamRadioLib.EDITOR_ERROR_RENAME_DIR] = "You can't rename a directory",
	[StreamRadioLib.EDITOR_ERROR_RENAME_EXIST] = "This file already exists!",
	[StreamRadioLib.EDITOR_ERROR_RENAME_WRITE] = "Couldn't rename/move the file!",
	[StreamRadioLib.EDITOR_ERROR_RENAME_READ] = "Couldn't read the source file!",
	[StreamRadioLib.EDITOR_ERROR_COMMUNITY_PROTECTED] = "You can not edit files inside the community folder!",
	[StreamRadioLib.EDITOR_ERROR_VIRTUAL_PROTECTED] = "You can not add or remove files inside the virtual folders!",
	[StreamRadioLib.EDITOR_ERROR_NOADMIN] = "You need admin rights!",
	[StreamRadioLib.EDITOR_ERROR_UNIMPLEMENTED] = "This is not implemented!",
	[StreamRadioLib.EDITOR_ERROR_UNKNOWN] = "Unknown Error"
}

function StreamRadioLib.DecodeEditorErrorCode( err )
	err = tonumber(err) or StreamRadioLib.EDITOR_ERROR_UNKNOWN
	local errorText = EditorErrors[err] or EditorErrors[StreamRadioLib.EDITOR_ERROR_UNKNOWN]

	if (err == StreamRadioLib.EDITOR_ERROR_WFORMAT) then
		errorText = string.format(errorText, StreamRadioLib.VALID_FORMATS_EXTENSIONS_LIST)
	end

	return errorText
end

StreamRadioLib.TAG_META = 0
StreamRadioLib.TAG_HTTP = 1
StreamRadioLib.TAG_ICY = 2
StreamRadioLib.TAG_ID3 = 3
StreamRadioLib.TAG_MF = 4
StreamRadioLib.TAG_MP4 = 5
StreamRadioLib.TAG_APE = 6
StreamRadioLib.TAG_OGG = 7
StreamRadioLib.TAG_VENDOR = 8

StreamRadioLib.STREAM_URL_INFO = [[
You can enter this as a Stream URL:

Offline content:
   - A relative path inside your game's 'sound' folder.
   - The path must lead to a valid sound file.
   - Mounted content is supported and included.
   - Like: music/hl1_song3.mp3
   - NOT: sound/music/hl1_song3.mp3
   - NOT: C:/.../sound/music/hl1_song3.mp3

Online content:
   - An URL to an online file or stream.
   - The URL must lead to valid sound content.
   - No HTML, no Flash, no Videos, no YouTube
   - Like: https://stream.laut.fm/hiphop-forever
]]

StreamRadioLib.STREAM_URL_INFO = string.gsub(StreamRadioLib.STREAM_URL_INFO, "\r", "")
StreamRadioLib.STREAM_URL_INFO = string.Trim(StreamRadioLib.STREAM_URL_INFO)

StreamRadioLib.STREAM_URL_MAX_LEN_ONLINE = 480
StreamRadioLib.STREAM_URL_MAX_LEN_OFFLINE = 260

StreamRadioLib.LOG_STREAM_URL_ALL = 2
StreamRadioLib.LOG_STREAM_URL_ONLINE = 1
StreamRadioLib.LOG_STREAM_URL_NONE = 0

return true


--PATH lua/streamradio_core/net.lua:
return gluapack()()
--PATH lua/streamradio_core/tool.lua:
return gluapack()()
--PATH lua/streamradio_core/skin.lua:
return gluapack()()
--PATH lua/streamradio_core/models/portal_ball.lua:
return gluapack()()
--PATH lua/streamradio_core/models/portal_radio.lua:
return gluapack()()
--PATH lua/streamradio_core/models/sw_radio.lua:
return gluapack()()
--PATH lua/streamradio_core/models/wire_speaker2.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Wire Speaker 2
-- Addon: https://steamcommunity.com/sharedfiles/filedetails/?id=160250458
RADIOMDL.model = "models/killa-x/speakers/speaker_medium.mdl"

RADIOMDL.NoDisplay = true
RADIOMDL.SpawnAng = Angle( 0, 0, 0 )
RADIOMDL.SpawnFlatOnWall = false

return true


--PATH lua/streamradio_core/interface.lua:
return gluapack()()
--PATH lua/streamradio_core/interface.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Interface = StreamRadioLib.Interface or {}

local LIB = StreamRadioLib.Interface
table.Empty(LIB)

local LIBUtil = StreamRadioLib.Util
local LIBUrl = StreamRadioLib.Url

local LuaInterfaceDirectory = "streamradio_core/interfaces"

local g_intefaces = {}
local g_intefacesByName = {}

local g_emptyFunction = function() end

local function AddInterface(script)
	script = script or ""
	if script == "" then return false end

	local scriptpath = LuaInterfaceDirectory .. "/"
	local scriptfile = scriptpath .. script

	RADIOIFACE = nil
	RADIOIFACE = {}

	RADIOIFACE.scriptpath = scriptpath
	RADIOIFACE.scriptfile = scriptfile

	RADIOIFACE.subinterfaces = {}

	local loaded = StreamRadioLib.LoadSH(scriptfile, true)

	if not loaded then
		RADIOIFACE = nil
		return false
	end

	local name = string.Trim(RADIOIFACE.name or "")
	RADIOIFACE.priority = tonumber(RADIOIFACE.priority or 0) or 0

	if name == "" then
		RADIOIFACE = nil
		return false
	end

	if RADIOIFACE.disabled then
		RADIOIFACE = nil
		return false
	end

	local iface = RADIOIFACE
	RADIOIFACE = nil

	table.insert(g_intefaces, iface)
	g_intefacesByName[name] = iface

	return true
end

local function GetInterfaceFromURL(url)
	for i, v in ipairs(g_intefaces) do
		if not v then continue end

		if not v.CheckURL then continue end
		if not v:CheckURL(url) then continue end

		return v
	end

	return nil
end

function LIB.Load()
	local files = file.Find(LuaInterfaceDirectory .. "/*", "LUA")
	g_intefaces = {}
	g_intefacesByName = {}

	for _, f in ipairs(files or {}) do
		AddInterface(f)
	end

	table.SortByMember(g_intefaces, "priority", false)
end

function LIB.GetInterface(name)
	return g_intefacesByName[name]
end

function LIB.Convert(url, callback)
	url = LIBUrl.SanitizeUrl(url)

	callback = callback or g_emptyFunction

	if url == "" then
		callback(nil, false, "", -1)
		return
	end

	local I = GetInterfaceFromURL(url)
	if not I then
		LIBUtil.ErrorNoHaltWithStack(string.format("Could not convert url '%s', interface was not found.", url))
		callback(nil, false, "", -1)
		return
	end

	if not I.Convert then
		callback(I, true, url)
		return
	end

	I:Convert(url, function(this, success, convertedUrl, errorcode)
		if success then
			errorcode = nil
			convertedUrl = tostring(convertedUrl or "")
		else
			errorcode = tonumber(errorcode or -1) or -1
			convertedUrl = ""
		end

		callback(this, success, convertedUrl, errorcode)
	end)
end

return true


--PATH lua/streamradio_core/cache.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Cache = StreamRadioLib.Cache or {}

local LIB = StreamRadioLib.Cache
table.Empty(LIB)

local LIBUtil = StreamRadioLib.Util

local g_emptyFunction = function() end
local g_forbidden = LIBUtil.CreateCacheArray(256)

local g_nextCacheCleanup = 0

StreamRadioLib.Hook.Add("PostCleanupMap", "reset_cache_download_cache", function()
	g_forbidden:Empty()
	g_nextCacheCleanup = 0
end)

local g_mainDir = nil
local g_mainDirLegacy = nil

local g_minFileSize = 2 ^ 16 -- 64 KB
local g_maxFileSize = 2 ^ 29 -- 28 -- 256 MB
local g_maxFileAge = 7 * 24 * 3600 -- 7 days
local g_maxCacheSize = 2 ^ 34 -- 16 GB
local g_maxCacheCount = 1024

local g_minCacheCleanupInterval = 60 -- 1 Minute

g_maxFileSize = math.min(g_maxCacheSize, g_maxFileSize)

local function CreateBaseFolder(dir)
	if file.IsDir(dir, "DATA") then
		return
	end

	file.CreateDir(dir)
end

local function IsValidFile(path)
	if not file.Exists(path, "DATA") then
		return false
	end

	if file.IsDir(path, "DATA") then
		return false
	end

	return true
end

local function Hash(var)
	var = tostring(var or "")

	local hash = util.SHA1("StreamRadioLib: '" .. var .. "'")
	return hash
end

local function GetFilenameFromURL(url)
	if not g_mainDir then
		return nil
	end

	url = tostring(url or "")
	url = StreamRadioLib.Url.SanitizeUrl(url)

	if filename == "" then
		return nil
	end

	local hash = Hash(url)
	local path = string.format("%s/cache_%s.dat", g_mainDir, hash)

	return path
end

local function Cache_GetCacheMap()
	if not g_mainDir then
		return nil
	end

	if not file.IsDir(g_mainDir, "DATA") then
		return nil
	end

	local map = {}
	map.files = {}
	map.totalsize = 0

	local now = os.time()
	local files = file.Find(g_mainDir .. "/*", "DATA") or {}

	for k, v in ipairs(files) do
		local path = g_mainDir .. "/" .. v

		if not IsValidFile(path) then
			continue
		end

		local size = file.Size(path, "DATA") or 0
		size = math.max(size, 0)

		local time = file.Time(path, "DATA") or 0
		time = math.max(time, 0)

		local age = now - time
		age = math.max(age, 0)

		local filestats = {
			path = path,
			name = v,
			size = size,
			time = time,
			age = age,
		}

		map.totalsize = map.totalsize + size
		table.insert(map.files, filestats)
	end

	return map
end

local function Cache_Cleanup(force)
	local now = RealTime()

	if not force and g_nextCacheCleanup > now then
		return
	end

	g_nextCacheCleanup = now + g_minCacheCleanupInterval

	local map = Cache_GetCacheMap()

	if not map then
		return
	end

	local files = map.files
	local filesleft = {}

	local sizeleft = map.totalsize - g_maxCacheSize
	sizeleft = math.max(sizeleft, 0)

	local delete = function(item)
		local path = item.path
		local size = item.size

		file.Delete(path)
		sizeleft = math.max(sizeleft - size, 0)
	end

	-- new -> old
	table.SortByMember(files, "time", false)

	local count = 0

	for k, item in ipairs(files) do
		local size = item.size
		local age = item.age

		if count >= g_maxCacheCount then
			-- max file count reached, deleting oldest files
			delete(item)
			continue
		end

		if age > g_maxFileAge then
			-- too old
			delete(item)
			continue
		end

		if size < g_minFileSize then
			-- too small, likly broken or not a real sound file
			delete(item)
			continue
		end

		if size > g_maxFileSize then
			-- too large
			delete(item)
			continue
		end

		table.insert(filesleft, v)
		count = count + 1
	end

	files = nil

	-- old -> new
	table.SortByMember(filesleft, "time", true)

	for k, item in ipairs(filesleft) do
		if sizeleft <= 0 then
			break
		end

		-- delete all files that exceed the total size limit
		-- oldest are deleted first
		delete(item)
	end
end

local function Cache_Save(url, data)
	if not g_mainDir then
		return nil
	end

	if not url then
		return false
	end

	if not data then
		return false
	end

	local path = GetFilenameFromURL(url)
	if not path then
		return false
	end

	CreateBaseFolder(g_mainDir)

	LIB.DeleteFileRaw(path)

	local f = file.Open(path, "wb", "DATA")
	if not f then
		return false
	end

	f:Write(data)
	f:Close()

	Cache_Cleanup(false)

	return true
end

function LIB.DeleteFileForUrl(url)
	local path = GetFilenameFromURL(url)

	if not LIB.DeleteFileRaw(path) then
		return false
	end

	return true
end

function LIB.DeleteFileRaw(path)
	if not path then return false end

	if not IsValidFile(path) then
		return true
	end

	file.Delete(path)

	if IsValidFile(path) then
		return false
	end

	return true
end

function LIB.GetFile(url)
	local path = GetFilenameFromURL(url)

	if not path then return nil end
	if not IsValidFile(path) then return nil end

	return path
end

local contenttype_blacklist = {
	["text/*"] = true,
	["image/*"] = true,
}

local function GetContentType( headers )
	if not istable(headers) then return "" end

	local contenttype = headers["Content-Type"] or headers["content-type"] or ""
	contenttype = (string.Explode(";", contenttype) or {})[1] or contenttype
	contenttype = string.Trim(contenttype)
	contenttype = string.lower(contenttype)

	local maintypes = string.Explode("/", contenttype) or {}
	local maintype = string.Trim(maintypes[1] or "")
	local subtype = string.Trim(maintypes[2] or "")

	if maintype == "" then
		maintype = nil
	end

	if subtype == "" then
		subtype = nil
	end

	return contenttype, maintype, subtype
end

function LIB.CanDownload(filesize)
	filesize = tonumber(filesize or 0) or 0

	if filesize == -1 then
		-- we don't know the file size yet
		return true
	end

	if filesize > g_maxFileSize then
		-- too large
		return false
	end

	if filesize < g_minFileSize then
		-- too small, likly broken or not a real sound file
		return false
	end

	return true
end

function LIB.Download(url, callback, saveAsUrl)
	url = tostring(url or "")
	saveAsUrl = tostring(saveAsUrl or "")
	callback = callback or g_emptyFunction

	if saveAsUrl == "" then
		saveAsUrl = url
	end

	if url == "" then
		callback(false, false, saveAsUrl)
		return
	end

	if saveAsUrl == "" then
		callback(false, false, saveAsUrl)
		return
	end

	local cacheid = util.SHA256(saveAsUrl)

	if g_forbidden:Has(cacheid) then
		callback(false, false, saveAsUrl)
		return
	end

	local onLoad = function(success, data)
		local len = data.len
		local headers = data.headers

		if not success then
			callback(false, false, saveAsUrl)
			return
		end

		if g_forbidden:Has(cacheid) then
			callback(false, false, saveAsUrl)
			return
		end

		local contenttype, maintype, subtype = GetContentType( headers )

		if contenttype_blacklist[contenttype] then
			g_forbidden:Set(cacheid, true)
			callback(false, false, saveAsUrl)
			return
		end

		if maintype and contenttype_blacklist[maintype .. "/*"] then
			g_forbidden:Set(cacheid, true)
			callback(false, false, saveAsUrl)
			return
		end

		if subtype and contenttype_blacklist["*/" .. subtype] then
			g_forbidden:Set(cacheid, true)
			callback(false, false, saveAsUrl)
			return
		end

		if len == -1 then
			-- still unknown sizes can't be cached
			g_forbidden:Set(cacheid, true)

			callback(false, false, saveAsUrl)
			return
		end

		if not LIB.CanDownload(len) then
			g_forbidden:Set(cacheid, true)

			callback(false, false, saveAsUrl)
			return
		end

		g_forbidden:Remove(cacheid)

		local saved = Cache_Save(saveAsUrl, data.body)

		callback(true, saved, saveAsUrl)
	end

	StreamRadioLib.Http.Request(url, onLoad)
end

function LIB.Load()
	local cacheRealm = SERVER and "sv" or "cl"

	g_mainDir = LIBUtil.GetMainDirectory(string.format("cache-%s", cacheRealm))
	g_mainDirLegacy = LIBUtil.GetMainDirectory("cache")

	LIBUtil.DeleteFolder(g_mainDirLegacy)
	Cache_Cleanup(true)
end

do
	local function Cache_Clear(ply, cmd, args)
		if not LIBUtil.IsAdminForCMD(ply) then
			StreamRadioLib.Print.Msg(ply, "You need to be an admin clear the server stream cache.")
			return
		end

		LIBUtil.DeleteFolder(g_mainDirLegacy)

		if not LIBUtil.DeleteFolder(g_mainDir) then
			StreamRadioLib.Print.Msg(ply, "Server stream cache could not be cleared!")
			return
		end

		g_forbidden:Empty()
		StreamRadioLib.Print.Msg(ply, "Server stream cache cleared!")
	end

	concommand.Add( "sv_streamradio_cacheclear", Cache_Clear )

	if CLIENT then
		local function Cache_Clear(ply, cmd, args)
			LIBUtil.DeleteFolder(g_mainDirLegacy)

			if not LIBUtil.DeleteFolder(g_mainDir) then
				StreamRadioLib.Print.Msg(ply, "Client stream cache could not be cleared!")
				return
			end

			g_forbidden:Empty()
			StreamRadioLib.Print.Msg(ply, "Client stream cache cleared!")
		end

		concommand.Add("cl_streamradio_cacheclear", Cache_Clear)
	end
end

return true


--PATH lua/streamradio_core/classes.lua:
StreamRadioLib.Classes = StreamRadioLib.Classes or {}
table.Empty(StreamRadioLib.Classes)

local LuaClassDirectory = "streamradio_core/classes"

local function normalize_classname(name)
	name = string.lower(name or "")
	name = string.Trim(name)

	name = string.gsub(name, "[%/%\\]", "/" )
	name = string.gsub(name, "%.%.%/", "" )
	name = string.gsub(name, "%.%/", "" )
	name = string.gsub(name, "[%s]", "_" )

	name = string.gsub(name, "^[%w%s%p_%/%\\]*" .. string.PatternSafe(LuaClassDirectory) .. "[%/%\\]*", "", 1 )
	name = string.gsub(name, "%.lua$", "", 1 )

	name = string.Trim(name)

	return name
end

local g_classID = 0
local g_instanceID = 0
local g_classsystemglobal = {}

local function CreateClass( classname, baseClass )
	g_classID = g_classID + 1

	local new_class = {}
	local class_mt = {
		__index = new_class,
	}

	local metamethods = {
		"__add", -- x + y
		"__sub", -- x - y
		"__unm", -- -x
		"__mul", -- x * y
		"__div", -- x / y
		"__mod", -- x % y
		"__pow", -- x ^ y
		"__concat", -- x .. y

		"__eg", -- x == y
		"__lt", -- x < y, x >= y
		"__le", -- x <= y, x > y
		"__len", -- #x

		"__call", -- x()
		"__tostring", -- tostring(x)
		"__gc", -- garbage collection
	}

	function new_class:new(useproxy)
		local newinst = {}

		for k, v in pairs(metamethods) do
			if rawget(class_mt, v) then continue end
			class_mt[v] = self[v]
		end

		setmetatable( newinst, class_mt )

		newinst.ID = g_instanceID
		g_instanceID = g_instanceID + 1

		return newinst
	end

	if nil ~= baseClass then
		setmetatable( new_class, {
			__index = baseClass,
		} )
	end

	new_class.classname = classname
	new_class.classid = g_classID

	function new_class:GetGlobalVar(key, fallback)
		key = tostring(key or "")

		local value = g_classsystemglobal[key]
		if value == nil then
			value = fallback
		end

		return value
	end

	function new_class:SetGlobalVar(key, value)
		key = tostring(key or "")
		g_classsystemglobal[key] = value
		return g_classsystemglobal[key]
	end

	function new_class:GetID()
		return self.ID or 0
	end

	function new_class:GetClassname()
		return self.classname
	end

	function new_class:GetBaseClassname()
		if not baseClass then return end
		return baseClass:GetClassname()
	end

	function new_class:GetClassID()
		return self.classid
	end

	function new_class:GetBaseClassID()
		if not baseClass then return end
		return baseClass:GetClassID()
	end

	-- Return the class object of the instance
	function new_class:GetClass()
		return new_class
	end

	-- Return the super class object of the instance
	function new_class:GetBaseClass()
		return baseClass
	end

	-- Return true if the caller is an instance of theClass
	function new_class:isa( theClass )
		local b_isa = false

		local cur_class = self:GetClass()

		while cur_class ~= nil and not b_isa do
			if cur_class == theClass then
				b_isa = true
			else
				cur_class = cur_class:GetBaseClass()
			end
		end

		return b_isa
	end

	return new_class
end

local function AddClass(name, parentname)
	name = normalize_classname(name)
	parentname = normalize_classname(parentname)

	if name == "" then return false end
	if parentname == "" then
		parentname = "base"
	end

	if StreamRadioLib.Classes[name] then return true end

	local scriptfile = LuaClassDirectory .. "/" .. name .. ".lua"

	if name ~= parentname and not AddClass( parentname ) then
		return false
	end

	local parent = StreamRadioLib.Classes[parentname]
	CLASS = CreateClass(name, parent)

	local loaded = StreamRadioLib.LoadSH(scriptfile, true)

	if not loaded then
		CLASS = nil
		return false
	end

	if not CLASS then
		CLASS = nil
		return false
	end

	StreamRadioLib.Classes[name] = CLASS
	local loadedfunc = CLASS.OnLoaded
	CLASS = nil

	if loadedfunc then
		StreamRadioLib.Timedcall(loadedfunc)
	end

	return true
end

function StreamRadioLib.ReloadClasses()
	table.Empty(StreamRadioLib.Classes)

	AddClass("base")
	AddClass("base_listener", "base")
	AddClass("ui/panel", "base_listener")
	AddClass("ui/debug", "ui/panel")
	AddClass("ui/highlighter", "ui/panel")
	AddClass("skin_controller", "base_listener")
	AddClass("gui_controller", "ui/panel")
	AddClass("ui/round_panel", "ui/panel")
	AddClass("ui/shadow_panel", "ui/panel")
	AddClass("ui/label", "ui/panel")
	AddClass("ui/label_fade", "ui/label")
	AddClass("ui/text", "ui/panel")
	AddClass("ui/image", "ui/panel")
	AddClass("ui/button", "ui/shadow_panel")
	AddClass("ui/scrollbar", "ui/panel")
	AddClass("ui/progressbar", "ui/shadow_panel")
	AddClass("ui/textview", "ui/shadow_panel")
	AddClass("ui/tooltip", "ui/panel")
	AddClass("ui/list", "ui/panel")
	AddClass("ui/list_files", "ui/list")

	AddClass("ui/radio/list_playlists", "ui/list_files")
	AddClass("ui/radio/list_playlistview", "ui/list_files")
	AddClass("ui/radio/gui_main", "ui/shadow_panel")
	AddClass("ui/radio/gui_browser", "ui/panel")
	AddClass("ui/radio/gui_player", "ui/panel")
	AddClass("ui/radio/gui_player_controls.lua", "ui/panel")
	AddClass("ui/radio/gui_player_spectrum.lua", "ui/shadow_panel")
	AddClass("ui/radio/gui_errorbox.lua", "ui/panel")

	AddClass("rendertarget", "base_listener")
	AddClass("stream", "base_listener")
	AddClass("clientconvar", "base_listener")
end

function StreamRadioLib.CreateOBJ(name, ...)
	name = normalize_classname(name)

	local class = StreamRadioLib.Classes[name]
	assert(istable(class), "Class '" .. name .. "' does not exist!")
	assert(class.new, "Bad class table '" .. name .. "' detected!")

	local obj = class:new()
	assert(istable(obj), "Object from class '" .. name .. "' could not be created!")

	if obj.Create then
		obj:Create(...)
	end
	obj.Create = nil

	if not IsValid(obj) then
		return nil
	end

	return obj
end

StreamRadioLib.ReloadClasses()

return true


--PATH lua/streamradio_core/classes/ui/debug.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local LIBHook = StreamRadioLib.Hook
local LIBUtil = StreamRadioLib.Util

local emptyTableSafe = LIBUtil.EmptyTableSafe

local BASE = CLASS:GetBaseClass()
local g_textcol = Color( 200, 200, 200, 255 )
local g_textcolbg = Color( 32, 32, 32, 160 )
local g_renderupdatetab = {"-", "\\", "|", "/"}

function CLASS:Create()
	BASE.Create(self)

	self.debugtexttab = {}
	self:SetZPos(9999999)
	self:SetSize(1,1)
	self:SetPos(0,0)

	self.lastUpdateTimeStamp = 0
	self.lastUpdateTimeAvg = 0
	self.bgW = 0
	self.bgH = 0

	self.colW = {}
	self.colH = {}
	self.lastAimedpanel = nil

	self.renderupdatetab_index = 0
	self:SetSkinAble(false)
end

function CLASS:Remove()
	BASE.Remove(self)
end

function CLASS:GetUpdateIndicator()
	local index = self.renderupdatetab_index + 1
	local count = #g_renderupdatetab

	self.renderupdatetab_index = index % count
	return g_renderupdatetab[index]
end

function CLASS:EmptyLines(col)
	local debugtexttab = self.debugtexttab or {}
	self.debugtexttab = debugtexttab

	if col then
		local colTable = debugtexttab[col] or {}
		colTable = emptyTableSafe(colTable)

		debugtexttab[col] = colTable
		return
	end

	for i, colTable in pairs(debugtexttab) do
		colTable = colTable or {}
		colTable = emptyTableSafe(colTable)

		debugtexttab[i] = colTable
	end
end

function CLASS:AddLine(col, strFormat, ...)
	local debugtexttab = self.debugtexttab or {}
	self.debugtexttab = debugtexttab

	local colTable = debugtexttab[col] or {}
	debugtexttab[col] = colTable

	table.insert(colTable, string.format(strFormat, ...))
end

function CLASS:BuildLines()
	local now = RealTime()

	local lastUpdateTimeStamp = self.lastUpdateTimeStamp or 0
	self.lastUpdateTimeStamp = now

	local updateTime = now - lastUpdateTimeStamp
	self.lastUpdateTimeAvg = (self.lastUpdateTimeAvg + updateTime) / 2

	local updateTimeAvg = self.lastUpdateTimeAvg
	local updatesPerSecAvg = math.Round(1 / updateTimeAvg, 3)
	local superparent = self:GetSuperParent()

	local cx, cy = superparent:GetCursor()

	local think_time = self:GetGlobalVar("base_listener_thinktime", -1)
	local fastthink_time = self:GetGlobalVar("base_listener_fastthinktime", -1)
	local addonthink_time = LIBHook.GetBenchmark("Think")
	local addontick_time = LIBHook.GetBenchmark("Tick")
	local rendertarget_time = superparent:GetFrametime()
	local render_time = superparent:ProfilerTime("Render")
	local rendertarget_active = superparent:HasRendertarget()
	local rt_w, rt_h = superparent:GetRendertargetSize()

	local memory = collectgarbage("count")
	local radioCount = StreamRadioLib.GetRadioCount()
	local streamingRadioCount = StreamRadioLib.GetStreamingRadioCount()
	local idleRadioCount = math.max(radioCount - streamingRadioCount, 0)

	local f_time = RealFrameTime()

	local think_time_p = math.Round(think_time / f_time * 100, 1)
	local fastthink_time_p = math.Round(fastthink_time / f_time * 100, 1)
	local addonthink_time_p = math.Round(addonthink_time / f_time * 100, 1)
	local addontick_time_p = math.Round(addontick_time / f_time * 100, 1)
	local rendertarget_time_p = math.Round(rendertarget_time / f_time * 100, 1)
	local render_time_p = math.Round(render_time / f_time * 100, 1)

	local aimedpanel = superparent:GetTopmostPanelAtCursor()

	self:EmptyLines(1)

	local addLine = self.AddLine

	self:EmptyLines(2)

	addLine(self, 1, "Refresh")
	addLine(self, 1, " Activity:  %s", self:GetUpdateIndicator())
	addLine(self, 1, " Rate:      %5.3f Hz", updatesPerSecAvg)
	addLine(self, 1, " Time:      %7.3f ms", updateTimeAvg * 1000)
	addLine(self, 1, "")

	if rendertarget_active then
		addLine(self, 1, "Rendertarget")
		addLine(self, 1, "  W, H:     %4i, %4i", rt_w, rt_h)
	else
		addLine(self, 1, "Rendertarget")
		addLine(self, 1, "  Off")
	end

	addLine(self, 1, "")

	addLine(self, 1, "Cursor")
	addLine(self, 1, "  X, Y:     %4i, %4i", cx, cy)

	addLine(self, 1, "")

	if IsValid(aimedpanel) then
		addLine(self, 1, "Panel Info")
		addLine(self, 1, " Object:    %s", tostring(aimedpanel)) 
		addLine(self, 1, " Name:      %s", aimedpanel:GetName())
		addLine(self, 1, " NW Name:   %s", aimedpanel:GetNWName())
		addLine(self, 1, " Skin ID:   %s", aimedpanel:GetSkinIdentifyerHierarchy())
	else
		addLine(self, 1, "Panel Info")
		addLine(self, 1, " <no panel>")
	end

	addLine(self, 1, "")

	addLine(self, 1, "Radio Count")
	addLine(self, 1, " Spawned      %4i", radioCount)
	addLine(self, 1, " Streaming    %4i", streamingRadioCount)
	addLine(self, 1, " Idle         %4i", idleRadioCount)

	addLine(self, 2, "Performance")
	addLine(self, 2, " Game Frame (GF): %7.3f ms", f_time * 1000)
	addLine(self, 2, "")
	addLine(self, 2, " Addon")
	addLine(self, 2, "  Think:          %7.3f ms | %5.1f%% of GF", addonthink_time * 1000, addonthink_time_p)
	addLine(self, 2, "  Tick:           %7.3f ms | %5.1f%% of GF", addontick_time * 1000, addontick_time_p)
	addLine(self, 2, "")
	addLine(self, 2, " Classes")
	addLine(self, 2, "  Think:          %7.3f ms | %5.1f%% of GF", think_time * 1000, think_time_p)
	addLine(self, 2, "  Fast Think:     %7.3f ms | %5.1f%% of GF", fastthink_time * 1000, fastthink_time_p)
	addLine(self, 2, "")
	addLine(self, 2, " GUI Render")
	addLine(self, 2, "  2D3D:           %7.3f ms | %5.1f%% of GF", render_time * 1000, render_time_p)
	addLine(self, 2, "  Content:        %7.3f ms | %5.1f%% of GF", rendertarget_time * 1000, rendertarget_time_p)
	addLine(self, 2, "")
	addLine(self, 2, " Lua Memory:      %7.1f MB", memory / 1024)
end


function CLASS:Render()
	local x, y = self:GetRenderPos()

	self:BuildLines()

	surface.SetFont( "DebugFixed" )
	surface.SetTextColor( g_textcol:Unpack() )

	local colW = self.colW
	local colH = self.colH

	local margin = 12
	local margin2 = margin / 2
	local margin4 = margin / 4

	do
		for i, cols in ipairs(self.debugtexttab) do
			local bg_col_w = 0
			local bg_col_h = 0

			if cols then
				for j, row in ipairs(cols) do
					row = row or ""

					local w, h = surface.GetTextSize(row)

					bg_col_w = math.max(bg_col_w, w + margin)
					bg_col_h = bg_col_h + h + 1
				end
			end

			bg_col_h = bg_col_h + margin2

			colW[i] = math.max(colW[i] or 0, bg_col_w)
			colH[i] = math.max(colH[i] or 0, bg_col_h)
		end
	end

	do
		local bg_w = 0
		local bg_h = 0

		for i, w in ipairs(colW) do
			bg_w = bg_w + w + margin4
		end

		for i, h in ipairs(colH) do
			bg_h = math.max(bg_h, h) + margin2
		end

		self.bgW = math.max(self.bgW, bg_w)
		self.bgH = math.max(self.bgH, bg_h)

		surface.SetDrawColor(g_textcolbg:Unpack())
		surface.DrawRect(x, y, self.bgW, self.bgH)
	end

	do
		local text_x = 0

		for i, cols in ipairs(self.debugtexttab) do
			local text_y = 0

			if i > 1 then
				text_x = text_x + (colW[i - 1] or 0)
			end

			local hasText = false

			if cols then
				for j, row in ipairs(cols) do
					row = row or ""

					local _, h = surface.GetTextSize(row)
					surface.SetTextPos(x + text_x + margin, y + text_y + margin2)
					surface.DrawText(row)

					text_y = text_y + h + 1
					hasText = true
				end
			end

			if not hasText then
				continue
			end

			if i > 1 then
				surface.SetDrawColor(g_textcol:Unpack())
				surface.DrawRect(x + text_x + margin2, y + margin2, 1, self.bgH - margin)
			end
		end
	end
end

function CLASS:IsInBounds(x, y)
	return false
end

function CLASS:SetModelSetup()
end

function CLASS:OnModelSetup()
end

function CLASS:ActivateNetworkedMode()
end

return true


--PATH lua/streamradio_core/classes/skin_controller.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/gui_controller.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/gui_controller.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

local tune_nohdr = Vector( 0.80, 0, 0 )
local CursorMat = StreamRadioLib.GetCustomPNG("cursor")

local catchAndErrorNoHaltWithStack = StreamRadioLib.Util.CatchAndErrorNoHaltWithStack

local g_gui_controller_listengroup = 0
local g_loadedAtDelay = math.min(engine.TickInterval() * 16, 0.5)
local g_visuallyReadyAtDelay = 1

function CLASS:AssignToListenGroup()
	return self._gui_controller_listengroup
end

function CLASS:Create()
	self._gui_controller_listengroup = g_gui_controller_listengroup
	g_gui_controller_listengroup = (g_gui_controller_listengroup % 2 ^ 30) + 1

	self:SetGlobalVar("gui_controller_listengroup", self._gui_controller_listengroup)

	BASE.Create(self)

	self.loadedAt = 0
	self.visuallyReadyAt = 0
	self.isReady = false
	self.isLoading = false

	self.Layout.AllowCursor = true

	self.Cursor = self:CreateListener({
		Pos = Vector(0, 0, 0),
	}, function()
		self:CallHook("CursorChangedInternal")
		self:CallHook("OnCursorChanged")
	end)

	if CLIENT then
		self.Tooltip = self:AddPanelByClassname("tooltip")
		self.Tooltip:SetPos(0, 0)
		self.Tooltip:SetSize(1, 1)
		self.Tooltip:SetName("tooltip")
		self.Tooltip:SetNWName("tip")
		self.Tooltip:SetSkinIdentifyer("tooltip")
		self.Tooltip:SetText("")
		self.Tooltip:SetZPos(1000)
		self.Tooltip:Close()
	end

	self._Skin = StreamRadioLib.CreateOBJ("skin_controller")

	self._Skin.AssignToListenGroup = function()
		return self:AssignToListenGroup()
	end

	self._Skin.OnUpdateSkin = function(this, skindata)
		if not IsValid(self) then return end
		self:SetSkinInternal(skindata)
	end

	self.SkinMap["color"] = nil;

	self.SkinMap["color_cursor"] = {
		set = "SetCursorColor",
		get = "GetCursorColor",
	}

	self.SkinMap["color_border"] = {
		set = "SetColor",
		get = "GetColor",
	}

	self.SkinAble = true

	if SERVER then return end

	self.Colors.Cursor = Color(255, 255, 255)

	self.Layout.CornerSize = 16
	self.Layout.BorderWidth = 10

	self._RT = StreamRadioLib.CreateOBJ("rendertarget")
	if not IsValid(self._RT) then return end

	self._RT.AssignToListenGroup = function()
		return self:AssignToListenGroup()
	end

	local ResizeRT = function()
		local x = self:GetPos()
		local w, h = self:GetSize()

		self._RT:SetPos(x, x)
		self._RT:SetSize(w, h)

		self:InvalidateLayout()
	end

	local CalcSize = function()
		local w, h = self:GetSize()

		local sqmax, sqmin = math.max(w, h), math.min(w, h)
		local csq = math.min(sqmax * 0.06125, sqmin * 0.25)

		self:SetCursorSize(csq, csq)

		if IsValid(self.Tooltip) then
			self.Tooltip:SetMaxWidth(w / 3)
		end
	end

	self.Size = self.Size + ResizeRT + CalcSize
	self.Pos = self.Pos + ResizeRT

	self._RT.OnRender = function()
		render.PushFilterMin(TEXFILTER.NONE)
		render.PushFilterMag(TEXFILTER.NONE)

		catchAndErrorNoHaltWithStack(self._RenderInternal, self)

		render.PopFilterMag()
		render.PopFilterMin()
	end

	self._RT.OnRendertargetRemove = function()
		self:InvalidateLayout()
	end

	self._RT.OnRendertargetCreate = function()
		self:InvalidateLayout()
	end

	ResizeRT()
	CalcSize()

	self.CanListen = true
	self:StartListen()

	if CLIENT then
		self:StartFastThink()
	end
end

function CLASS:Remove()
	if IsValid(self._RT) then
		self._RT:Remove()
	end

	if IsValid(self._Skin) then
		self._Skin:Remove()
	end

	if IsValid(self._Debug) then
		self._Debug:Remove()
	end

	BASE.Remove(self)
end

function CLASS:HasRendertarget()
	if not IsValid(self._RT) then
		return false
	end

	return self._RT:HasRendertarget()
end

function CLASS:GetRendertargetSize()
	if not self:HasRendertarget() then
		return -1, -1
	end

	return self._RT:GetSize()
end

function CLASS:GetRenderPos()
	if self:HasRendertarget() then
		return 0, 0
	end

	local getpos = self.GetClientPos or self.GetPos
	local x, y = getpos(self)

	return x, y
end

function CLASS:GetTooltipPanel()
	return self.Tooltip
end

function CLASS:UpdateTooltip(text)
	if SERVER then return end
	if not IsValid(self.Tooltip) then return end
	if not self.Tooltip:IsVisibleSimple() then return end

	text = tostring(text or "")
	self.Tooltip:SetText(text)

	if text == "" then
		self.Tooltip:Close()
	end

	return self.Tooltip
end

function CLASS:OpenTooltip(text)
	if SERVER then return end
	if not IsValid(self.Tooltip) then return end

	text = tostring(text or "")
	self.Tooltip:SetText(text)

	if text ~= "" then
		self.Tooltip:Open()
		self:PosTooltipToCursor(true)
	else
		self.Tooltip:Close()
	end

	return self.Tooltip
end

function CLASS:CloseTooltip(text)
	if SERVER then return end
	if not IsValid(self.Tooltip) then return end

	self.Tooltip:Close()
end

function CLASS:PosTooltipToCursor(force)
	if SERVER then return end
	if not IsValid(self.Tooltip) then return end
	if not force and not self.Tooltip:IsVisibleSimple() then return end

	local x, y = self:GetPos()

	local cx, cy = self:GetCursor()
	local _, ch = self:GetCursorSize()
	local pw, ph = self:GetClientSize()
	local tw, th = self.Tooltip:GetSize()

	cx = cx - x
	cy = cy - y

	local tx, ty = 0, 0

	tx = cx - tw / 2
	ty = cy - th * 1.5

	if ty < 0 then
		ty = cy + ch * 1.5
	end

	tx = math.Clamp(tx, 0, pw - tw)
	ty = math.Clamp(ty, 0, ph - th)

	self.Tooltip:SetPos(tx, ty)
end

function CLASS:OpenTooltipDelay(text, delay, callback)
	if SERVER then return end
	if not IsValid(self.Tooltip) then return end

	self:TimerOnce("tooltip", delay or 3, function()
		callback = self:GetFunction(callback)
		if not callback then return end
		if not callback(self) then return end

		self:OpenTooltip(text)
	end)
end

function CLASS:GetPanelByName(name)
	name = StreamRadioLib.GetHierarchy(name)

	local firstname = name[1] or ""

	if firstname ~= self:GetName() then
		return nil
	end

	if #name <= 1 then
		return self
	end

	table.remove(name, 1)
	return BASE.GetPanelByName(self, name)
end

function CLASS:IsSkinAble()
	if not self.SkinAble then return false end
	return true
end

function CLASS:RenderSystem()
	if SERVER then return end
	if not self.Valid then return end

	self:ProfilerStart("Render")
	self._isseen = true

	render.PushFilterMin(TEXFILTER.NONE)
	render.PushFilterMag(TEXFILTER.NONE)

	local now = RealTime()
	local currentRenderAlpha = surface.GetAlphaMultiplier()
	local drawAlpha = self:GetDrawAlpha()
	local alpha = drawAlpha * currentRenderAlpha
	local isTransparent = drawAlpha < 1
	local ready = self.isReady and self.visuallyReadyAt < now

	local oldtune = render.GetToneMappingScaleLinear( )
	render.SetToneMappingScaleLinear(tune_nohdr) -- Turns off hdr

	if isTransparent then
		surface.SetAlphaMultiplier(alpha)
	end

	catchAndErrorNoHaltWithStack(self.DrawBorder, self)

	if isTransparent then
		surface.SetAlphaMultiplier(currentRenderAlpha)
	end

	if ready then
		if self:HasRendertarget() then
			surface.SetDrawColor(255, 255, 255, alpha * 255)

			catchAndErrorNoHaltWithStack(self._RT.Render, self._RT)

			surface.SetDrawColor(255, 255, 255, 255)
			self.FrameTime = self._RT:ProfilerTime("Render")
		else
			self:ProfilerStart("Render_rtfallback")

			if isTransparent then
				surface.SetAlphaMultiplier(alpha)
			end

			catchAndErrorNoHaltWithStack(self._RenderInternal, self)

			if isTransparent then
				surface.SetAlphaMultiplier(currentRenderAlpha)
			end

			self.FrameTime = self:ProfilerEnd("Render_rtfallback")
		end

		if isTransparent then
			surface.SetAlphaMultiplier(alpha)
		end
	end

	if ready then
		catchAndErrorNoHaltWithStack(self.DrawCursor, self)
	else
		catchAndErrorNoHaltWithStack(self.RenderLoader, self)
	end

	if isTransparent then
		surface.SetAlphaMultiplier(currentRenderAlpha)
	end

	render.SetToneMappingScaleLinear(oldtune) -- Resets hdr

	render.PopFilterMag()
	render.PopFilterMin()

	self:ProfilerEnd("Render")
end

function CLASS:SetCursorSize(w, h)
	self.Cursor_w = w or 0
	self.Cursor_h = h or 0
end

function CLASS:GetCursorSize()
	return self.Cursor_w, self.Cursor_h
end

function CLASS:DrawCursor()
	if not self:GetAllowCursor() then return end
	if not self:IsCursorInBounds() then return end

	local _, _, ax2, ay2 = self:GetArea()

	local cx, cy = self:GetCursor()
	local cw, ch = self:GetCursorSize()
	local colCursor = self.Colors.Cursor or color_white

	local cu = ((cx + cw) - ax2) / cw
	local cv = ((cy + ch) - ay2) / ch

	cu = math.Clamp(1 - cu, 0, 1)
	cv = math.Clamp(1 - cv, 0, 1)

	surface.SetMaterial(CursorMat)
	surface.SetDrawColor(colCursor:Unpack())
	surface.DrawTexturedRectUV(cx, cy, cw * cu, ch * cv, 0, 0, cu, cv)
end

function CLASS:RenderLoader()
	local color = self.Colors.Cursor

	local x, y = self:GetRenderPos()
	local p = self:GetPadding()
	x = x + p
	y = y + p

	local w, h = self:GetClientSize()

	local sqmax, sqmin = math.max(w, h), math.min(w, h)
	local isq = math.min(sqmax * 0.5, sqmin * 0.5)

	StreamRadioLib.Surface.Loading( x + (w - isq) / 2, y + (h - isq) / 2, isq, isq, color, 8)
end

function CLASS:DrawBorder()
	local borderw = self.Layout.BorderWidth or 0
	if borderw <= 0 then return end

	local x, y = self:GetPos()
	local w, h = self:GetSize()

	x = x - borderw
	y = y - borderw
	w = w + borderw * 2
	h = h + borderw * 2

	draw.RoundedBox(self.Layout.CornerSize, x, y, w, h, self.Colors.Main)
end

function CLASS:OnContentChanged()
	self._renderupdate = true
end

function CLASS:PollLoading()
	if not self.isLoading then
		return
	end

	local now = RealTime()
	local loadedAt = self.loadedAt or 0

	if loadedAt > now then
		return
	end

	self.loadedAt = now
	self.isLoading = false

	self:CallHook("OnLoadDone")

	if not self.isReady then
		self.isReady = true
		self.visuallyReadyAt = now + g_visuallyReadyAtDelay

		self:CallHook("OnReady")
	end
end

function CLASS:Think()
	self.thinkRate = 0.5

	self:PollLoading()

	if SERVER then
		return
	end

	if not IsValid(self._RT) then return end
	if not self:IsSeen() then return end

	self.thinkRate = 0.1

	self._RT:SetFramerate(StreamRadioLib.GetRenderTargetFPS())
	self._RT:SetEnabled(StreamRadioLib.IsRenderTarget())

	self:PosTooltipToCursor()
end

if CLIENT then
	function CLASS:FastThink()
		local isReady = self.isReady

		self.fastThinkRate = isReady and 0.1 or 0.5

		local isSeen = self:IsSeen()
		local change = isSeen ~= self._isseen

		isSeen = self._isseen
		self._isseen = false

		self.isseen = isSeen

		if change then
			if isSeen then
				self:StartListenRecursive()
			else
				if not self.isReady then
					-- make sure the gui controller never stops thinking if not maked as ready yet.
					self.CanListen = true
					self:StartListen()
				else
					self:StopListenRecursive()
				end
			end
		end

		if not IsValid(self._RT) then return end
		if not isSeen then return end

		self.fastThinkRate = 0

		if not self._renderupdate then return end
		if not self._RT:Update() then return end

		self._renderupdate = false
	end
end

function CLASS:GetAllowCursor()
	return self.Layout.AllowCursor or false
end

function CLASS:SetAllowCursor( bool )
	self.Layout.AllowCursor = bool or false
end

function CLASS:GetFrametime()
	return self.FrameTime or 0
end

function CLASS:SetCursorGlobal(x, y)
	self:SetCursor(x, y)
end

function CLASS:SetCursor(x, y)
	x = math.floor(x or -1)
	y = math.floor(y or -1)

	local x1, y1, x2, y2 = self:GetArea()

	if x < x1 then
		x = -1
		y = -1
	end

	if y < y1 then
		x = -1
		y = -1
	end

	if x > x2 then
		x = -1
		y = -1
	end

	if y > y2 then
		x = -1
		y = -1
	end

	self.Cursor.Pos = Vector(x, y, 0)
end

function CLASS:_GetCursorInternal()
	return math.floor(self.Cursor.Pos.x or -1), math.floor(self.Cursor.Pos.y or -1)
end

function CLASS:GetCursor()
	return self:_GetCursorInternal()
end

function CLASS:GetCornerSize()
	return self.Layout.CornerSize or 0
end

function CLASS:SetCornerSize(size)
	self.Layout.CornerSize = size or 0
end

function CLASS:GetBorderWidth()
	return self.Layout.BorderWidth or 0
end

function CLASS:SetBorderWidth(size)
	self.Layout.BorderWidth = size or 0
end

function CLASS:IsSeen()
	return SERVER or (self.isseen and self.isReady)
end

function CLASS:SetDebug(allowdebug)
	if SERVER then return end
	allowdebug = allowdebug and true or false

	if self:GetDebug() == allowdebug then
		return
	end

	if not allowdebug then
		self._Debug:Remove()
		self._Debug = nil
		self:InvalidateLayout()
		return
	end

	self._Debug = self:AddPanelByClassname("debug")
	self._Debug:SetName("debug")
	self._Debug:SetNWName("debug")
	self:InvalidateLayout()
end

function CLASS:GetDebug()
	if not IsValid(self._Debug) then
		return false
	end

	return true
end

function CLASS:SetSkin(...)
	if not IsValid(self._Skin) then
		return
	end

	return self._Skin:SetSkin(...)
end

function CLASS:SetSkinInternal(...)
	return BASE.SetSkin(self, ...)
end

function CLASS:GetSkin(...)
	if not IsValid(self._Skin) then
		return {}
	end

	return self._Skin:GetSkin(...)
end

function CLASS:SetSkinProperty(...)
	if not IsValid(self._Skin) then
		return
	end

	return self._Skin:SetProperty(...)
end

function CLASS:SetSkinOnServer(...)
	if not IsValid(self._Skin) then
		return
	end

	return self._Skin:SetSkinOnServer(...)
end

function CLASS:SetSkinPropertyOnServer(...)
	if not IsValid(self._Skin) then
		return
	end

	return self._Skin:SetPropertyOnServer(...)
end

function CLASS:SetCursorColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.Cursor = color
end

function CLASS:GetCursorColor()
	if SERVER then return end

	local col = self.Colors.Cursor
	return col
end

function CLASS:SetName(...)
	BASE.SetName(self, ...)

	local name = self:GetName()
	local nwname = self:GetName()

	if IsValid(self._Skin) then
		self._Skin:SetName(name .. "/skin")
		self._Skin:SetNWName(nwname .. "/sk")
	end

	if IsValid(self._RT) then
		self._RT:SetName(name .. "/rendertarget")
		self._RT:SetNWName(nwname .. "/rt")
	end
end

function CLASS:SetEntity(...)
	BASE.SetEntity(self, ...)

	if IsValid(self._Skin) then
		self._Skin:SetEntity(...)
	end
end

function CLASS:LoadToDupe(dupeTable)
	if not SERVER then return end
	if not istable(dupeTable) then return end

	self:LoadToDupeInternal(dupeTable)

	self:ForEachChildRecursive(function(this, child)
		child:LoadToDupeInternal(dupeTable)
	end)

	if IsValid(self._Skin) then
		self._Skin:LoadToDupeInternal(dupeTable)
	end
end

function CLASS:LoadFromDupe(dupeTable)
	if not SERVER then return end
	if not istable(dupeTable) then return end

	self:LoadFromDupeInternal(dupeTable)

	self:ForEachChildRecursive(function(this, child)
		child:LoadFromDupeInternal(dupeTable)
	end)

	if IsValid(self._Skin) then
		self._Skin:LoadFromDupeInternal(dupeTable)
	end
end

function CLASS:AddToNwRegister(nwRegister)
	if not istable(nwRegister) then return end

	self:AddToNwRegisterInternal(nwRegister)

	self:ForEachChildRecursive(function(this, child)
		child:AddToNwRegisterInternal(nwRegister)
	end)

	if IsValid(self._Skin) then
		self._Skin:AddToNwRegisterInternal(nwRegister)
	end
end

function CLASS:RemoveFromNwRegister(nwRegister)
	if not istable(nwRegister) then return end

	self:RemoveFromNwRegisterInternal(nwRegister)

	self:ForEachChildRecursive(function(this, child)
		child:RemoveFromNwRegisterInternal(nwRegister)
	end)

	if IsValid(self._Skin) then
		self._Skin:RemoveFromNwRegisterInternal(nwRegister)
	end
end

function CLASS:ActivateNetworkedMode()
	BASE.ActivateNetworkedMode(self)

	if not IsValid(self._Skin) then return end
	self._Skin:ActivateNetworkedMode(self)
end

function CLASS:OnModelSetup(setup)
	BASE.OnModelSetup(self, setup)

	if setup.cornersize then
		self:SetCornerSize(setup.cornersize)
	end

	if setup.borderwidth then
		self:SetBorderWidth(setup.borderwidth)
	end
end

function CLASS:OnPanelElementLoaded()
	self.loadedAt = RealTime() + g_loadedAtDelay
	self.isLoading = true
end

function CLASS:IsLoading()
	return self.isLoading or false
end

function CLASS:IsReady()
	return self.isReady or false
end

return true


--PATH lua/streamradio_core/classes/ui/text.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()
local changehooks = {
	Text = "OnTextChange",
	Font = "OnFontChange",
	AlignX = "OnAlignChange",
	AlignY = "OnAlignChange",
}

function CLASS:Create()
	BASE.Create(self)

	self.Clickable = false

	self.Lines = {}
	self.TextData = self:CreateListener({
		Text = "",
		Font = "DermaDefault",

		AlignX = TEXT_ALIGN_LEFT,
		AlignY = TEXT_ALIGN_TOP,
		StartLine = 1,
	}, function(this, k, v)
		self:InvalidateLayout()

		if k == "Text" then
			self:QueueCall("BuildLines")
		end

		if k == "Font" then
			self:QueueCall("BuildLines")
		end

		local hookname = changehooks[k]
		if not hookname then return end

		self:CallHook(hookname)
	end)

	if CLIENT then
		self.Size = self.Size + function(this, k, v)
			if k ~= "w" then return end
			self:QueueCall("BuildLines")
		end

		self.Colors.Main = Color(0, 0, 0)
	end

	self:SetSkinAble(false)
end

function CLASS:PerformLayout(...)
	BASE.PerformLayout(self, ...)

	self:DelCacheValue("GetTextSize")
	self:DelCacheValue("GetVisibleLines")
	self:DelCacheValue("GetTotalTextSize")
end

function CLASS:BuildLines(force)
	if SERVER then return end

	self:DelCacheValue("GetTextSize")
	self:DelCacheValue("GetVisibleLines")
	self:DelCacheValue("GetTotalTextSize")

	local font = self.TextData.Font
	local text = self.TextData.Text
	local w = self:GetSize()

	self:GetWidth()

	self.Lines = {}

	local line = {}
	local linew = 0

	surface.SetFont( font )
	local checksize = {"W", "M", "L", "I", "i", "l", ".", "g", "|", "_"}

	for k, v in ipairs(checksize) do
		local tsw = surface.GetTextSize(v)

		if tsw >= w then
			self:InvalidateLayout()
			return
		end
	end

	if text == "" then
		self:InvalidateLayout()
		return
	end

	text = string.gsub(text, "\r[\n]?", "\n")

	local function newline()
		local text = table.concat(line, "")
		table.insert(self.Lines, text)

		line = {}
		linew = 0
	end

	local function addtoline(text)
		text = text or ""
		local count = #line

		if count <= 0 then
			text = string.TrimLeft(text)
		end

		if text == "" then
			return
		end

		local tsw = surface.GetTextSize( text )
		local newlinew = linew + tsw

		-- Word to long, seperate it
		if tsw > w then
			for i = 1, #text do
				addtoline(text[i])
			end

			return
		end

		-- Line length reached, insert a new line
		if newlinew > w then
			newline()
			addtoline(text)
			return
		end

		line[count + 1] = text
		linew = newlinew
	end

	for n, s, w, p in string.gmatch( text, "([\n]?)([^%w%p_\n]*)([%w_]*)([%p]*)" ) do
		if n == "\n" then
			newline()
		end

		addtoline(s)
		addtoline(w .. p)
	end

	newline()

	self:InvalidateLayout()
	self:CallHook("OnBuildLines")
end

function CLASS:DrawText( text, x, y, w, h, tsw, tsh )
	text = text or ""
	if text == "" then return end

	local tx, ty = x, y
	local xalign, yalign = self.TextData.AlignX, self.TextData.AlignY

	if ( xalign == TEXT_ALIGN_CENTER ) then
		tx = x + w / 2 - tsw / 2
	elseif ( xalign == TEXT_ALIGN_RIGHT ) then
		tx = x + w - tsw
	end

	if ( yalign == TEXT_ALIGN_CENTER ) then
		ty = y + h / 2 - tsh / 2
	elseif ( yalign == TEXT_ALIGN_BOTTOM ) then
		ty = y + h - tsh
	end

	surface.SetTextPos( math.ceil( tx ), math.ceil( ty ) )
	surface.DrawText( text )
end

function CLASS:Render()
	BASE.Render(self)

	local x, y = self:GetRenderPos()
	local w, h = self:GetSize()

	local col = self.Colors.Main or color_black
	local font = self.TextData.Font

	surface.SetFont( font )
	surface.SetTextColor( col:Unpack() )

	local lines = self:GetVisibleLines()
	local _, texth = self:GetTextSize()

	for i, v in ipairs(lines) do
		local text = v.text
		local ox = v.x
		local oy = v.y
		local ow = v.w

		self:DrawText(text, x + ox, y + oy, w, h, ow, texth)
	end
end

function CLASS:SetTextColor(...)
	return self:SetColor(...)
end

function CLASS:GetTextColor(...)
	return self:GetColor(...)
end

function CLASS:SetText(text)
	self.TextData.Text = tostring(text or "")
end

function CLASS:GetText()
	return self.TextData.Text or ""
end

function CLASS:GetTotalTextSize()
	if SERVER then return 0, 0 end

	local chtextw, chtextw = self:GetCacheValues("GetTotalTextSize")
	if chtextw then return chtextw, chtextw end

	local textw = 0
	local texth = 0
	local count = self:GetLineCount()

	surface.SetFont(self.TextData.Font)

	for i = 1, count do
		local text = self.Lines[i] or ""
		local tsw, tsh = surface.GetTextSize( text )

		if textw < tsw then
			textw = tsw
		end

		local newlineh = texth + tsh + 1
		texth = newlineh
	end

	return self:SetCacheValues("GetTotalTextSize", textw, texth)
end

function CLASS:FitToText(minw, maxw)
	self:SetWidth(maxw)
	self:BuildLines()

	local w, h = self:GetTotalTextSize()
	w = math.Clamp(w, minw, maxw)

	self:SetSize(w, h)
end

function CLASS:GetTextSize()
	if SERVER then return 0, 0 end

	local chtextw, chtextw = self:GetCacheValues("GetTextSize")
	if chtextw then return chtextw, chtextw end

	local w, h = self:GetSize()

	local textw = 0
	local texth = 0

	local count = self:GetLineCount()
	local startline = self:GetStartLine()

	surface.SetFont(self.TextData.Font)

	for i = startline, count do
		local text = self.Lines[i] or ""
		local tsw, tsh = surface.GetTextSize( text )

		if textw < tsw then
			textw = tsw
		end

		local newlineh = texth + tsh + 1
		if newlineh > h then
			break
		end

		texth = newlineh
	end

	if textw > w then
		textw = w
	end

	if texth > h then
		texth = h
	end

	return self:SetCacheValues("GetTextSize", textw, texth)
end

function CLASS:GetVisibleLines()
	if SERVER then return end

	local chlines = self:GetCacheValue("GetVisibleLines")
	if chlines then return chlines end

	local liney = 0
	local _, texth = self:GetTextSize()

	local startline = self:GetStartLine()

	local lines = {}

	surface.SetFont(self.TextData.Font)

	local i = startline
	while (true) do
		local text = self.Lines[i] or ""
		local tsw, tsh = surface.GetTextSize( text )

		local newliney = liney + tsh + 1
		if newliney > texth then
			break
		end

		local data = {
			text = text,
			w = tsw,
			h = tsh,
			x = 0,
			y = liney,
		}

		table.insert(lines, data)
		liney = newliney
		i = i + 1
	end

	return self:SetCacheValue("GetVisibleLines", lines)
end

function CLASS:SetFont(font)
	if SERVER then return end
	self.TextData.Font = font or ""
end

function CLASS:GetFont()
	if SERVER then return end
	return self.TextData.Font or ""
end

function CLASS:SetAlign(alignX, alignY)
	if SERVER then return end
	self.TextData.AlignX = alignX or self.TextData.AlignX or TEXT_ALIGN_LEFT
	self.TextData.AlignY = alignY or self.TextData.AlignY or TEXT_ALIGN_TOP
end

function CLASS:GetAlign()
	if SERVER then return end
	return self.TextData.AlignX or TEXT_ALIGN_LEFT, self.TextData.AlignY or TEXT_ALIGN_TOP
end

function CLASS:SetStartLine(startline)
	if SERVER then return end
	self.TextData.StartLine = startline or 1
end

function CLASS:GetStartLine()
	if SERVER then return end

	local count = self:GetLineCount()
	local startline = math.Clamp(self.TextData.StartLine, 1, count)

	return startline
end

function CLASS:GetLineCount()
	if SERVER then return end
	return #self.Lines
end

function CLASS:OnModelSetup(setup)
	BASE.OnModelSetup(self, setup)

	if setup.font then
		self:SetFont(setup.font)
	end
end

return true


--PATH lua/streamradio_core/classes/ui/progressbar.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

function CLASS:Create()
	BASE.Create(self)

	self.Progress = self:CreateListener({
		Fraction = 0,
		AllowEdit = false,
	}, function(this, k, v)
		if k == "Fraction" then
			if v > 1 then
				self.Progress.Fraction = 1
				return
			end

			if v < 0 then
				self.Progress.Fraction = 0
				return
			end

			self:CallHook("OnFractionChange", v)
			self:UpdateText()

			self:SetNWFloat("Fraction", v)
			self:InvalidateLayout(true)
		end

		if k == "AllowEdit" then
			self:SetNWBool(k, v)
			self:InvalidateLayout()
		end
	end)

	self.SkinMap["color_hover"] = {
		set = "SetHoverColor",
		get = "GetHoverColor",
	}

	self.SkinMap["color_disabled"] = {
		set = "SetDisabledColor",
		get = "GetDisabledColor",
	}

	self.SkinMap["color_foreground_hover"] = {
		set = "SetTextHoverColor",
		get = "GetTextHoverColor",
	}

	self.SkinMap["color_foreground_disabled"] = {
		set = "SetTextDisabledColor",
		get = "GetTextDisabledColor",
	}

	if not SERVER then
		self.Colors.Disabled = Color(128,128,128)
		self.Colors.DisabledText = Color(255,255,255)
		self.Colors.DisabledIcon = Color(255,255,255)

		self.Colors.Hover = Color(192,192,192)
		self.Colors.HoverText = Color(0,0,0)
		self.Colors.HoverIcon = Color(255,255,255)

		self.Colors.NoHover = Color(255,255,255)
		self.Colors.NoHoverText = Color(0,0,0)
		self.Colors.NoHoverIcon = Color(255,255,255)

		self.Colors = self.Colors + function(this, k, v)
			if k == "Main" then
				self.Colors.Secondary = Color(
					v.r * 0.65,
					v.g * 0.65,
					v.b * 0.65,
					v.a * 0.75
				)

				return
			end

			if k == "Secondary" then
				return
			end
	
			self:QueueCall("UpdateColor")
		end
	end

	self.CanHaveLabel = true
	self.SkinAble = true
	self:SetAlign(TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

	self:QueueCall("UpdateText")
	self:InvalidateLayout()
end

function CLASS:PerformLayout(...)
	BASE.PerformLayout(self, ...)

	self:QueueCall("UpdateColor")
end

function CLASS:CursorChangedInternal()
	BASE.CursorChangedInternal(self)

	if SERVER then return end
	self:UpdateColor()
end

function CLASS:UpdateColor()
	if SERVER then return end

	if self:IsDisabled() then
		self.Colors.Main = self.Colors.Disabled

		if IsValid(self.TextPanel) then
			self.TextPanel:SetColor(self.Colors.DisabledText)
		end

		return
	end

	if self.Progress.AllowEdit and self:IsCursorOnPanel() then
		self.Colors.Main = self.Colors.Hover

		if IsValid(self.TextPanel) then
			self.TextPanel:SetColor(self.Colors.HoverText)
		end

		return
	end

	self.Colors.Main = self.Colors.NoHover

	if IsValid(self.TextPanel) then
		self.TextPanel:SetColor(self.Colors.NoHoverText)
	end
end

function CLASS:Render()
	local x, y = self:GetRenderPos()
	local w, h = self:GetSize()
	local shadowWidth = self:GetShadowWidth()

	local col1 = self.Colors.Main or color_white
	local col2 = self.Colors.Secondary or color_white

	local fraction1 = self.Progress.Fraction

	if shadowWidth <= 0 then
		surface.SetDrawColor(col1:Unpack())
		surface.DrawRect(x, y, w, h)

		surface.SetDrawColor(col2:Unpack())
		surface.DrawRect(x, y, w * fraction1, h)

		return
	end

	local colShadow = self.Colors.Shadow or color_black

	local sx, sy = x + shadowWidth, y + shadowWidth
	local sw, sh = w - shadowWidth, h - shadowWidth

	surface.SetDrawColor(colShadow:Unpack())
	surface.DrawRect(sx, sy, sw, sh)
	surface.SetDrawColor(col1:Unpack())
	surface.DrawRect(x, y, sw, sh)
	surface.SetDrawColor(col2:Unpack())
	surface.DrawRect(x, y, sw * fraction1, sh)
end

function CLASS:DoEditProgress(force)
	if self:IsDisabled() then
		return
	end

	if not self.Progress.AllowEdit then
		return
	end

	if CLIENT and self.Network.Active then
		return
	end

	BASE.CursorChangedInternal(self)

	local cx = self:GetCursorRelative()
	local w = self:GetClientSize()

	local fraction = 0
	if w > 0 then
		fraction = math.Clamp(cx / w, 0, 1)
	end

	fraction = self:CallHook("OnFractionChangeEdit", fraction) or fraction

	self:SetFraction(fraction)
end

function CLASS:CursorChangedInternal()
	BASE.CursorChangedInternal(self)

	if not self.IsPressed then return end
	self:DoEditProgress()
end

function CLASS:DoClick()
	self:DoEditProgress()
end

function CLASS:OnMouseReleased()
	self:DoEditProgress()
end

function CLASS:UpdateText()
	local text = tostring(self:CallHook("FractionChangeText", self.Progress.Fraction) or "")
	self:SetText(text)
end

function CLASS:FractionChangeText(fraction)
	return math.Round(fraction * 100) .. "%"
end

function CLASS:SetFraction(fraction)
	self.Progress.Fraction = fraction or 0
end

function CLASS:GetFraction()
	return self.Progress.Fraction or 0
end

function CLASS:SetAllowFractionEdit(bool)
	self.Progress.AllowEdit = bool or false
end

function CLASS:GetAllowFractionEdit()
	return self.Progress.AllowEdit or false
end


function CLASS:SetColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.NoHover = color
end

function CLASS:GetColor()
	if SERVER then return end

	local col = self.Colors.NoHover
	return col
end

function CLASS:SetHoverColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.Hover = color
end

function CLASS:GetHoverColor()
	if SERVER then return end

	local col = self.Colors.Hover
	return col
end

function CLASS:SetDisabledColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.Disabled = color
end

function CLASS:GetDisabledColor()
	if SERVER then return end

	local col = self.Colors.Disabled
	return col
end

function CLASS:SetTextColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.NoHoverText = color
end

function CLASS:GetTextColor()
	if SERVER then return end

	local col = self.Colors.NoHoverText
	return col
end

function CLASS:SetTextHoverColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.HoverText = color
end

function CLASS:GetTextHoverColor()
	if SERVER then return end

	local col = self.Colors.HoverText
	return col
end

function CLASS:SetTextDisabledColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.DisabledText = color
end

function CLASS:GetTextDisabledColor()
	if SERVER then return end

	local col = self.Colors.DisabledText
	return col
end


function CLASS:ActivateNetworkedMode()
	BASE.ActivateNetworkedMode(self)

	if SERVER then
		self:SetNWFloat("Fraction", self:GetFraction())
		self:SetNWBool("AllowEdit", self:GetAllowFractionEdit())
		return
	end

	self:SetNWVarCallback("Fraction", "Float", function(this, nwkey, oldvar, newvar)
		self:SetFraction(newvar)
	end)

	self:SetNWVarCallback("AllowEdit", "Bool", function(this, nwkey, oldvar, newvar)
		self:SetAllowFractionEdit(newvar)
	end)

	self:SetFraction(self:GetNWFloat("Fraction", 0))
	self:SetAllowFractionEdit(self:GetNWBool("AllowEdit", false))
end

function CLASS:PreDupe()
	local data = {}

	data.Fraction = self:GetFraction()
	data.AllowEdit = self:GetAllowFractionEdit()

	return data
end

function CLASS:PostDupe(data)
	self:SetFraction(data.Fraction)
	self:SetAllowFractionEdit(data.AllowEdit)
end

return true


--PATH lua/streamradio_core/properties.lua:
return gluapack()()
--PATH lua/streamradio_core/client/cl_surface.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Surface = StreamRadioLib.Surface or {}

local LIB = StreamRadioLib.Surface
table.Empty(LIB)

local g_font_template = {
	font = "Arial",
	size = 0,
	weight = 0,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false
}

local LoadingMat = StreamRadioLib.GetCustomPNG("loading")

local pi = math.pi
local color_white = color_white

function LIB.Loading( x, y, w, h, color, cycles )
	surface.SetMaterial( LoadingMat )
	color = color or color_white
	cycles = math.floor( cycles or 0 )

	if cycles < 5 then
		cycles = 5
	end

	local time = RealTime( )
	local midw = w / 2
	local midh = h / 2
	local cw = w / cycles * 2
	local ch = h / cycles * 2

	for i = 1, cycles do
		--local posang = pi * 2 / cycles * i + time
		local cx = math.cos( pi * 2 / cycles * i + time ) * ( midw - cw / 2 ) + x - cw / 2 + midw
		local cy = math.sin( pi * 2 / cycles * i + time ) * ( midh - cw / 2 ) + y - ch / 2 + midh
		surface.SetDrawColor( color:Unpack() )
		surface.DrawTexturedRect( cx, cy, cw, ch )
	end
end

LIB._CreatedFonts = LIB._CreatedFonts or {}

function LIB.AddFont(size, weight, baseFontName, additionalData)
	local ft = g_font_template

	size = tonumber(size) or ft.size
	weight = tonumber(weight) or ft.weight
	baseFontName = tostring(baseFontName or ft.font)
	additionalData = additionalData or {}

	local additionalDataName = {}
	local additionalDataNameEmpty = true

	for k, v in SortedPairs(additionalData or {}) do
		if v == g_font_template[k] then
			continue
		end

		local name = string.format("[%s=%s]", tostring(k), tostring(v))
		table.insert(additionalDataName, name)

		additionalDataNameEmpty = false
	end

	if additionalDataNameEmpty then
		additionalDataName = ""
	else
		additionalDataName = table.concat(additionalDataName)
		additionalDataName = util.MD5(additionalDataName)
	end

	local ID = string.format("3DStreamRadio_Font_[%s][%d][%d][%s]", baseFontName, size, weight, additionalDataName)

	if LIB._CreatedFonts[ID] then
		return ID
	end

	local font = table.Copy(ft)

	for k, v in pairs(additionalData or {}) do
		font[k] = v
	end

	font.size = size
	font.weight = weight
	font.font = base

	surface.CreateFont(ID, font)

	LIB._CreatedFonts[ID] = true
	return ID
end

return true


--PATH lua/streamradio_core/interfaces/file.lua:
local RADIOIFACE = RADIOIFACE
if not istable( RADIOIFACE ) then
	StreamRadioLib.Interface.Load()
	return
end

RADIOIFACE.name = "File"
RADIOIFACE.priority = 100000
RADIOIFACE.download = false
RADIOIFACE.online = false
RADIOIFACE.cache = false

RADIOIFACE.downloadTimeout = 0
RADIOIFACE.downloadFirst = false
RADIOIFACE.allowCaching = false

local LIBUrl = StreamRadioLib.Url
local LIBString = StreamRadioLib.String
local LIBError = StreamRadioLib.Error

function RADIOIFACE:CheckURL(url)
	if not LIBUrl.IsOfflineURL(url) then
		return false
	end

	return true
end

function RADIOIFACE:ParseURL(url)
	local _, filepath = LIBUrl.SplittProtocolAndPath(url)

	local urlResult = "sound/" .. filepath
	urlResult = LIBString.NormalizeSlashes(urlResult)

	return urlResult
end

function RADIOIFACE:Convert(url, callback)
	if LIBUrl.IsDriveLetterOfflineURL(url) then
		callback(self, true, "", LIBError.STREAM_ERROR_BAD_DRIVE_LETTER_PATH)
		return
	end

	local path = self:ParseURL(url)

	callback(self, true, path)
end

return true


--PATH lua/autorun/swm_mortar_runner.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/language/sh_english.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/language/sh_german.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/language/sh_polish.lua:
--[[-------------------------------------------

    Talk Modes - whisper/talk/yell 

    Licensed to 76561198327810923
	Version: 1.1.1

	By: SaturdaysHeroes & Djuk
	Special thanks to CupCakeR

--]]-------------------------------------------
local LANGUAGE = {}
LANGUAGE["General"] = "Oglne"
LANGUAGE["Theme"] = "Motyw"
LANGUAGE["Modes"] = "Tryby"
LANGUAGE["Whisper"] = "Szept"
LANGUAGE["Whisper_Desc"] = "Jaki zasig powinien mie szept?"
LANGUAGE["Yell"] = "Krzyk"
LANGUAGE["Yell_Desc"] = "Jaki zasig powinien mie krzyk?"
LANGUAGE["Talk"] = "Rozmowa" 
LANGUAGE["Talk_Desc"] = "Jaki zasig powinna mie rozmowa?"
LANGUAGE["3D Voice"] = "Dzwik 3D"
LANGUAGE["3D Voice_Desc"] = "Czy dwik 3D powinien by aktywny?"
LANGUAGE["Language"] = "Jzyk"
LANGUAGE["Language_Desc"] = "Ktry jzyk powinien by aktywny?"
LANGUAGE["Selection Key"] = "Klawisz Wyboru"
LANGUAGE["Selection Key_Desc"] = "Ktry klawisz powinien otwiera panel?"
LANGUAGE["Talking Dead"] = "Gadajce Trupy"
LANGUAGE["Talking Dead_Desc"] = "Czy nieywi gracze powinni mc mwi?"
LANGUAGE["Selection Menu Position"] = "Pozycja Menu"
LANGUAGE["Selection Menu Position_Desc"] = "Gdzie powinno si znajdowa menu wyboru?"
LANGUAGE["Save"] = "Zapisz"
LANGUAGE["Reset"] = "Zresetuj"
LANGUAGE["Preview"] = "Podgld"
LANGUAGE["PreviewHeader"] = "PRZYCINIJ [%s] ABY ZAKOCZY PODGLD"
LANGUAGE["PreviewText"] = "OBECNIE POKAZYWANY JEST ZASIG: %s JEDNOSTEK"
LANGUAGE["Background"] = "Kolor Ta"
LANGUAGE["Background_Desc"] = "Ktry kolor powinien by uywany jako kolor ta?"
LANGUAGE["Foreground"] = "Kolor Pierwszoplanowy"
LANGUAGE["Foreground_Desc"] = "Ktry kolor powinien by uywany jako kolor pierwszoplanowy?"
LANGUAGE["Hover"] = "Akcent"
LANGUAGE["Hover_Desc"] = "Ktry kolor powinien by uywany jako kolor akcentu?"
LANGUAGE["White"] = "Biay"
LANGUAGE["White_Desc"] = "Ktry kolor powinien by uywany jako kolor biay?"
LANGUAGE["Gray"] = "Szary"
LANGUAGE["Gray_Desc"] = "Ktry kolor powinien by uywany jako kolor szary?"
LANGUAGE["WelcomeMessage"] = "Ten serwer korzysta ze skryptu Talk Modes, przytrzymaj %s aby wybra swj tryb mwienia!"
LANGUAGE["Turn Off"] = "Wycz"
LANGUAGE["Using Mode"] = "Aktywny tryb"
LANGUAGE["Auto-Hide"] = "Automatyczne Ukrywanie"
LANGUAGE["Auto-Hide_Desc"] = "Czy menu wyboru powinno samo si chowa, jeeli jest nieuywane?"
LANGUAGE["Mode Change Message"] = "Powiadomienie o zmianie"
LANGUAGE["Mode Change Message_Desc"] = "Czy gracz powinien otrzymywa powiadomienie o zmianie trybu?"

TalkModes.Languages:Register("Polski", LANGUAGE)
--PATH addons/[chat] talk-modes/lua/talk_modes/language/sh_russian.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_base.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_general.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_navbar.lua:
local THEME = TalkModes.Client.ActiveTheme

local PANEL = {}
AccessorFunc(PANEL, "page", "Page")
AccessorFunc(PANEL, "button_text", "ButtonText")
AccessorFunc(PANEL, "mat", "Mat")
AccessorFunc(PANEL, "active", "Active", FORCE_BOOL)

function PANEL:Init()
    self.base = self:GetParent():GetParent()
    self.nav = self:GetParent()
    self:Dock(TOP)
    self:DockMargin(0, 8, 0, 0)
    self:SetHeight(42)
    self:SetText("")
    self.intOffset = 0
    self.colActive = Color(255, 255, 255)
end

function PANEL:Paint(intW, intH)
    self.intOffset = Lerp(FrameTime() * 8, self.intOffset, (self:IsHovered() || self:GetActive()) && 12 || 0)
    self.colActive.r = Lerp(FrameTime() * 16, self.colActive.r, (self:IsHovered() || self:GetActive()) && THEME["Hover"].r || THEME["White"].r )
    self.colActive.g = Lerp(FrameTime() * 16, self.colActive.g, (self:IsHovered() || self:GetActive()) && THEME["Hover"].g || THEME["White"].g )
    self.colActive.b = Lerp(FrameTime() * 16, self.colActive.b, (self:IsHovered() || self:GetActive()) && THEME["Hover"].b || THEME["White"].b )
    
    surface.SetDrawColor(Color(self.colActive.r, self.colActive.g, self.colActive.b))
    surface.SetMaterial(self:GetMat())
    surface.DrawTexturedRect(self.intOffset + 18, (42-32)/2, 32, 32)
    draw.SimpleText(TalkModes.Languages:GetPhrase(self:GetButtonText()), "TalkModes:Medium", self.intOffset + 18 + 32 + 12, intH/2, THEME["White"], TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
end

function PANEL:DoClick()
    if (self:GetActive() or self.base.docker.bChanging) then return end
    for _,btn in ipairs(self.nav.tblButtons) do
        btn:SetActive(false)
    end
    self:SetActive(true)
    self.base.docker:ChangePage(self:GetPage(), true)
end
vgui.Register("TalkModes.NavbarButton", PANEL, "DButton")

local PANEL = {}
function PANEL:Init()
    self.tblButtons = {}
end
function PANEL:Paint(intW, intH)
    draw.RoundedBoxEx(8, 0, 0, intW, intH, THEME["Background"], false, false, true, false)
end

function PANEL:AddButton(strPage, mMat, strText)
    self.btn = self:Add("TalkModes.NavbarButton")
    self.btn:SetPage(strPage)
    self.btn:SetMat(mMat)
    self.btn:SetButtonText(strText)

    self.tblButtons[#self.tblButtons + 1] = self.btn
    if (self.tblButtons[1] == self.btn) then
        self.btn:SetActive(true)
    end
end
vgui.Register("TalkModes.Navbar", PANEL, "DPanel")


--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/libs/cl_circles.lua:
local _R = debug.getregistry()
if (_R.Circles) then return _R.Circles end

local BlurMat = Material("pp/blurscreen")

local rad = math.rad
local cos = math.cos
local sin = math.sin
local min = math.min
local max = math.max

local CIRCLE = {}
CIRCLE.__index = CIRCLE

CIRCLE_FILLED = 0
CIRCLE_OUTLINED = 1
CIRCLE_BLURRED = 2

local function New(type, radius, x, y, ...)
	local circle = setmetatable({}, CIRCLE)

	circle:SetType(tonumber(type))
	circle:SetRadius(tonumber(radius))
	circle:SetPos(tonumber(x), tonumber(y))

	if (type == CIRCLE_OUTLINED) then
		local outline_width = ({...})[1]
		circle:SetOutlineWidth(tonumber(outline_width))
	elseif (type == CIRCLE_BLURRED) then
		local blur_density, blur_quality = unpack({...})
		circle:SetBlurDensity(tonumber(blur_density))
		circle:SetBlurQuality(tonumber(blur_quality))
	end

	return circle
end

local function RotateVertices(vertices, ox, oy, rotation, rotate_uv)
	rotation = rad(rotation)

	local c = cos(rotation)
	local s = sin(rotation)

	for i = 1, #vertices do
		local vertex = vertices[i]
		local vx, vy = vertex.x, vertex.y

		vx = vx - ox
		vy = vy - oy

		vertex.x = ox + (vx * c - vy * s)
		vertex.y = oy + (vx * s + vy * c)

		if (not rotate_uv) then
			local u, v = vertex.u, vertex.v
			u, v = u - 0.5, v - 0.5

			vertex.u = 0.5 + (u * c - v * s)
			vertex.v = 0.5 + (u * s + v * c)
		end
	end
end

local function CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv)
	x = tonumber(x) or 0
	y = tonumber(y) or 0
	radius = tonumber(radius) or 16
	rotation = tonumber(rotation) or 0
	start_angle = tonumber(start_angle) or 0
	end_angle = tonumber(end_angle) or 360
	distance = tonumber(distance) or 10

	if (start_angle > end_angle) then
		local tmp = start_angle
		start_angle = end_angle
		end_angle = tmp
	end

	local vertices = {}
	local step = (distance * 360) / (2 * math.pi * radius)

	for a = start_angle, end_angle + step, step do
		a = max(start_angle, min(end_angle, a))
		a = rad(a)

		local c = cos(a)
		local s = sin(a)

		local vertex = {
			x = x + c * radius,
			y = y + s * radius,

			u = 0.5 + c / 2,
			v = 0.5 + s / 2,
		}

		table.insert(vertices, vertex)
	end

	if (end_angle - start_angle ~= 360) then
		table.insert(vertices, 1, {
			x = x, y = y,
			u = 0.5, v = 0.5,
		})
	else
		table.remove(vertices)
	end

	if (rotation ~= 0) then
		RotateVertices(vertices, x, y, rotation, rotate_uv)
	end

	return vertices
end

function CIRCLE:__tostring()
	return string.format("Circle: %p", self)
end

function CIRCLE:Copy()
	return table.Copy(self)
end

function CIRCLE:Calculate()
	local rotate_uv = self:GetRotateMaterial()
	local x, y = self:GetPos()
	local radius = self:GetRadius()
	local rotation = self:GetRotation()
	local start_angle = self:GetStartAngle()
	local end_angle = self:GetEndAngle()
	local distance = self:GetDistance()

	self:SetVertices(CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv))

	if (self:GetType() == CIRCLE_OUTLINED) then
		local inner = self:GetChildCircle() or self:Copy()

		inner:SetType(CIRCLE_FILLED)
		inner:SetRadius(self:GetRadius() - self:GetOutlineWidth())
		inner:SetAngles(0, 360)

		inner:SetColor(false)
		inner:SetMaterial(false)
		inner:SetDisableClipping(false)

		self:SetChildCircle(inner)
	end

	self:SetDirty(false)
end

function CIRCLE:__call()
	if (self:GetDirty()) then
		self:Calculate()
	end

	if (IsColor(self:GetColor())) then surface.SetDrawColor(self:GetColor()) end
	if (TypeID(self:GetMaterial()) == TYPE_MATERIAL) then surface.SetMaterial(self:GetMaterial()) end

	local clip = self:GetDisableClipping()
	if (clip) then surface.DisableClipping(true) end

	if (self:GetType() == CIRCLE_OUTLINED) then
		render.ClearStencil()

		render.SetStencilEnable(true)
			render.SetStencilTestMask(0xFF)
			render.SetStencilWriteMask(0xFF)
			render.SetStencilReferenceValue(0x01)

			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			self:GetChildCircle()()

			render.SetStencilCompareFunction(STENCIL_GREATER)
			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)

			surface.DrawPoly(self:GetVertices())
		render.SetStencilEnable(false)
	elseif (self:GetType() == CIRCLE_BLURRED) then
		render.ClearStencil()

		render.SetStencilEnable(true)
			render.SetStencilTestMask(0xFF)
			render.SetStencilWriteMask(0xFF)
			render.SetStencilReferenceValue(0x01)

			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			surface.DrawPoly(self:GetVertices())

			render.SetStencilCompareFunction(STENCIL_LESSEQUAL)
			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)

			surface.SetMaterial(BlurMat)

			local sw, sh = ScrW(), ScrH()

			for i = 1, self:GetBlurQuality() do
				BlurMat:SetFloat("$blur", (i / self:GetBlurQuality()) * self:GetBlurDensity())
				BlurMat:Recompute()

				render.UpdateScreenEffectTexture()
				surface.DrawTexturedRect(0, 0, sw, sh)
			end
		render.SetStencilEnable(false)
	else
		surface.DrawPoly(self:GetVertices())
	end

	if (clip) then surface.DisableClipping(false) end
end

function CIRCLE:Translate(x, y)
	self.m_X = self:GetX() + x
	self.m_Y = self:GetY() + y

	if (self:GetDirty()) then return end

	x = tonumber(x) or 0
	y = tonumber(y) or 0

	for i, v in ipairs(self:GetVertices()) do
		v.x = v.x + x
		v.y = v.y + y
	end

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Translate(x, y)
	end
end

function CIRCLE:Scale(scale)
	self.m_Radius = self:GetRadius() * scale

	if (self:GetDirty()) then return end

	local x, y = self:GetPos()
	scale = tonumber(scale) or 1

	for i, vertex in ipairs(self:GetVertices()) do
		vertex.x = x + ((vertex.x - x) * scale)
		vertex.y = y + ((vertex.y - y) * scale)
	end

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Scale(scale)
	end
end

function CIRCLE:Rotate(degrees)
	self.m_Rotation = self:GetRotation() + degrees

	if (self:GetDirty()) then return end

	local vertices = self:GetVertices()
	local x, y = self:GetPos()
	local rotate_uv = self:GetRotateMaterial()
	degrees = tonumber(degrees) or 0

	RotateVertices(vertices, x, y, degrees, rotate_uv)

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Rotate(degrees)
	end
end

do
	local function AccessorFunc(name, default, dirty, callback)
		local varname = "m_" .. name

		CIRCLE["Get" .. name] = function(self)
			return self[varname]
		end

		CIRCLE["Set" .. name] = function(self, value)
			if (default ~= nil and value == nil) then
				value = default
			end

			if (self[varname] ~= value) then
				if (dirty) then
					self[dirty] = true
				end

				if (isfunction(callback)) then
					value = callback(self, self[varname], value) or value
				end
			end

			self[varname] = value
		end

		CIRCLE[varname] = default
	end

	local function OffsetVerticesX(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		for i, vertex in ipairs(circle:GetVertices()) do
			vertex.x = 0 - old + new + old
		end

		if (circle:GetType() == CIRCLE_OUTLINED) then
			OffsetVerticesX(circle:GetChildCircle(), old, new)
		end
	end

	local function OffsetVerticesY(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		for i, vertex in ipairs(circle:GetVertices()) do
			vertex.y = 0 - old + new + old
		end

		if (circle:GetType() == CIRCLE_OUTLINED) then
			OffsetVerticesY(circle:GetChildCircle(), old, new)
		end
	end

	local function UpdateRotation(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		local vertices = circle:GetVertices()
		local x, y = circle:GetPos()
		local rotation = new - old
		local rotate_uv = circle:GetRotateMaterial()

		RotateVertices(vertices, x, y, rotation, rotate_uv)

		if (circle:GetType() == CIRCLE_OUTLINED) then
			UpdateRotation(circle:GetChildCircle(), old, new)
		end
	end

	-- These are set internally. Only use them if you know what you're doing.
	AccessorFunc("Dirty", true)
	AccessorFunc("Vertices", false)
	AccessorFunc("ChildCircle", false)

	AccessorFunc("Color", false)						-- The colour you want the circle to be. If set to false then surface.SetDrawColor's can be used.
	AccessorFunc("Material", false)						-- The material you want the circle to render. If set to false then surface.SetMaterial can be used.
	AccessorFunc("RotateMaterial", true)				-- Sets whether or not the circle's UV points should be rotated with the vertices.
	AccessorFunc("DisableClipping", false)				-- Sets whether or not to disable clipping when the circle is rendered. Useful for circles that go out of the render bounds.

	AccessorFunc("Type", CIRCLE_FILLED, "m_Dirty") 		-- The circle's type.
	AccessorFunc("X", 0, false, OffsetVerticesX) 		-- The circle's X position relative to the top left of the screen.
	AccessorFunc("Y", 0, false, OffsetVerticesY) 		-- The circle's Y position relative to the top left of the screen.
	AccessorFunc("Radius", 8, "m_Dirty") 				-- The circle's radius.
	AccessorFunc("Rotation", 0, false, UpdateRotation)	-- The circle's rotation, measured in degrees.
	AccessorFunc("StartAngle", 0, "m_Dirty") 			-- The circle's start angle, measured in degrees.
	AccessorFunc("EndAngle", 360, "m_Dirty")			-- The circle's end angle, measured in degrees.
	AccessorFunc("Distance", 10, "m_Dirty")				-- The maximum distance between each of the circle's vertices. Set to false to use segments instead. This should typically be used for large circles in 3D2D.

	AccessorFunc("BlurDensity", 3)						-- The circle's blur density if Type is set to CIRCLE_BLURRED.
	AccessorFunc("BlurQuality", 2)						-- The circle's blur quality if Type is set to CIRCLE_BLURRED.
	AccessorFunc("OutlineWidth", 10, "m_Dirty")			-- The circle's outline width if Type is set to CIRCLE_OUTLINED.

	function CIRCLE:SetPos(x, y)
		self:SetX(x)
		self:SetY(y)
	end

	function CIRCLE:SetAngles(s, e)
		self:SetStartAngle(s)
		self:SetEndAngle(e)
	end

	function CIRCLE:GetPos()
		return self:GetX(), self:GetY()
	end

	function CIRCLE:GetAngles()
		return self:GetStartAngle(), self:GetEndAngle()
	end
end

_R.Circles = {
	New = New,
	RotateVertices = RotateVertices,
	CalculateVertices = CalculateVertices,
}

return _R.Circles

--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_slider.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_theme.lua:
local PANEL = {}
function PANEL:Init()
    self:SetPageName("UI")
    self.tblDefaultSettings = {
        ["Background"] = {
            strDesc = "Background_Desc",
            strType = "tColor",
        },
        ["Foreground"] = {
            strDesc = "Foreground_Desc",
            strType = "tColor"
        },
        ["Hover"] = {
            strDesc = "Hover_Desc",
            strType = "tColor"
        },
        ["White"] = {
            strDesc = "White_Desc",
            strType = "tColor"
        },
        ["Gray"] = {
            strDesc = "Gray_Desc",
            strType = "tColor"
        },
    }
    self:RefreshSettings()
end
vgui.Register("TalkModes.ThemesSettings", PANEL, "TalkModes.SettingsBase")
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/libs/cl_circles.lua:
return gluapack()()
--PATH lua/autorun/tarkin.lua:
player_manager.AddValidModel( "navy tarkin", 		"models/navy/gnavytarkin.mdl" );
list.Set( "PlayerOptionsModel", "navy tarkin", 	"models/navy/gnavytarkin.mdl" );
--PATH lua/textscreens_config.lua:
return gluapack()()
--PATH lua/textscreens_config.lua:
textscreenFonts = {}

local function addFont(font, t)
	if CLIENT then
		t.size = 100
		surface.CreateFont(font, t)
		t.size = 50
		surface.CreateFont(font .. "_MENU", t)
	end

	table.insert(textscreenFonts, font)
end

--[[
---------------------------------------------------------------------------
Custom fonts - requires server restart to take affect -- "Screens_" will be removed from the font name in spawnmenu
---------------------------------------------------------------------------
--]]

-- Default textscreens font
addFont("Coolvetica outlined", {
	font = "coolvetica",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Coolvetica", {
	font = "coolvetica",
	weight = 400,
	antialias = false,
	outline = false
})

-- Trebuchet
addFont("Screens_Trebuchet outlined", {
	font = "Trebuchet MS",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Screens_Trebuchet", {
	font = "Trebuchet MS",
	weight = 400,
	antialias = false,
	outline = false
})

-- Arial
addFont("Screens_Arial outlined", {
	font = "Arial",
	weight = 600,
	antialias = false,
	outline = true
})

addFont("Screens_Arial", {
	font = "Arial",
	weight = 600,
	antialias = false,
	outline = false
})

-- Roboto Bk
addFont("Screens_Roboto outlined", {
	font = "Roboto Bk",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Screens_Roboto", {
	font = "Roboto Bk",
	weight = 400,
	antialias = false,
	outline = false
})

-- Helvetica
addFont("Screens_Helvetica outlined", {
	font = "Helvetica",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Screens_Helvetica", {
	font = "Helvetica",
	weight = 400,
	antialias = false,
	outline = false
})

-- akbar
addFont("Screens_Akbar outlined", {
	font = "akbar",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Screens_Akbar", {
	font = "akbar",
	weight = 400,
	antialias = false,
	outline = false
})

-- csd
addFont("Screens_csd outlined", {
	font = "csd",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Screens_csd", {
	font = "csd",
	weight = 400,
	antialias = false,
	outline = false
})

if CLIENT then

	local function addFonts(path)
		local files, folders = file.Find("resource/fonts/" .. path .. "*", "MOD")

		for k, v in ipairs(files) do
			if string.GetExtensionFromFilename(v) == "ttf" then
				local font = string.StripExtension(v)
				if table.HasValue(textscreenFonts, "Screens_" .. font) then continue end
print("-- "  .. font .. "\n" .. [[
addFont("Screens_ ]] .. font .. [[", {
	font = font,
	weight = 400,
	antialias = false,
	outline = true
})
				]])
			end
		end

		for k, v in ipairs(folders) do
			addFonts(path .. v .. "/")
		end
	end

	concommand.Add("get_fonts", function(ply)
		addFonts("")
	end)

end

--PATH lua/tfa/modules/tfa_data.lua:
-- This file is holding seamless translation of older versions of data to newer
-- versions of data

TFA.LatestDataVersion = 1

TFA.DataVersionMapping = {
	[0] = {
		{
			old_path = "DrawCrosshairIS",
			new_path = "DrawCrosshairIronSights",
		},

		{
			old_path = "FiresUnderwater",
			new_path = "Primary.FiresUnderwater",
		},

		{
			old_path = "PenetrationMaterials",
			new_path = "Primary.PenetrationMaterials",
		},

		{
			old_path = "MaxPenetrationCounter",
			new_path = "Primary.MaxSurfacePenetrationCount",
		},

		{
			old_path = "MaxPenetration",
			new_path = "Primary.MaxSurfacePenetrationCount",
		},

		{
			old_path = "IronRecoilMultiplier",
			new_path = "Primary.IronRecoilMultiplier",
		},

		{
			old_path = "MoveSpeed",
			new_path = "RegularMoveSpeedMultiplier",
		},

		{
			old_path = "IronSightsMoveSpeed",
			new_path = "AimingDownSightsSpeedMultiplier",
		},

		{
			old_path = "Shotgun",
			new_path = "LoopedReload",
		},

		{
			old_path = "ShellTime",
			new_path = "LoopedReloadInsertTime",
		},

		{
			old_path = "CrouchPos",
			new_path = "CrouchViewModelPosition",
		},

		{
			old_path = "CrouchAng",
			new_path = "CrouchViewModelAngle",
		},

		{
			old_path = "data.ironsights",
			new_path = "Secondary.IronSightsEnabled",
			upgrade = function(value) return value == 1 end,
			downgrade = function(value) return value and 1 or 0 end,
		},

		{
			old_path = "Secondary.IronFOV",
			new_path = "Secondary.OwnerFOV",
		},

		{
			old_path = "IronViewModelFOV",
			new_path = "Secondary.ViewModelFOV",
		},

		{
			old_path = "DoProceduralReload",
			new_path = "IsProceduralReloadBased",
		},

		{
			old_path = "ProceduralReloadEnabled",
			new_path = "IsProceduralReloadBased",
		},

		{
			old_path = "Akimbo",
			new_path = "IsAkimbo",
		},

		{
			old_path = "AkimboHUD",
			new_path = "EnableAkimboHUD",
		},

		{
			old_path = "IronInSound",
			new_path = "Secondary.IronSightsInSound",
		},

		{
			old_path = "IronOutSound",
			new_path = "Secondary.IronSightsOutSound",
		},

		{
			old_path = "DisableChambering",
			new_path = "Primary.DisableChambering",
		},

		{
			old_path = "DisplayFalloff",
			new_path = "Primary.DisplayFalloff",
		},

		{
			old_path = "SpreadBiasYaw",
			new_path = "Primary.SpreadBiasYaw",
		},

		{
			old_path = "SpreadBiasPitch",
			new_path = "Primary.SpreadBiasPitch",
		},

		{
			old_path = "VMPos",
			new_path = "ViewModelPosition",
		},

		{
			old_path = "VMAng",
			new_path = "ViewModelAngle",
		},

		{
			old_path = "VMPos_Additive",
			new_path = "AdditiveViewModelPosition",
		},

		{
			old_path = "RunSightsPos",
			new_path = "SprintViewModelPosition",
		},

		{
			old_path = "RunSightsAng",
			new_path = "SprintViewModelAngle",
		},

		{
			old_path = "IronSightsPos",
			new_path = "IronSightsPosition",
		},

		{
			old_path = "IronSightsAng",
			new_path = "IronSightsAngle",
		},

		{
			old_path = "Bodygroups_V",
			new_path = "ViewModelBodygroups",
		},

		{
			old_path = "Bodygroups_W",
			new_path = "WorldModelBodygroups",
		},

		{
			old_path = "CenteredPos",
			new_path = "CenteredViewModelPosition",
		},

		{
			old_path = "CenteredAng",
			new_path = "CenteredViewModelAngle",
		},

		{
			old_path = "Offset",
			new_path = "WorldModelOffset",
		},

		{
			old_path = "ProceduralHolsterPos",
			new_path = "ProceduralHolsterPosition",
		},

		{
			old_path = "ProceduralHolsterAng",
			new_path = "ProceduralHolsterAngle",
		},

		{
			old_path = "VElements",
			new_path = "ViewModelElements",
		},

		{
			old_path = "WElements",
			new_path = "WorldModelElements",
		},
	}
}

local function identity(...) return ... end

for version = 0, #TFA.DataVersionMapping do
	for i, data in ipairs(TFA.DataVersionMapping[version]) do
		if not isfunction(data.upgrade) then data.upgrade = identity end
		if not isfunction(data.downgrade) then data.downgrade = identity end
	end
end

TFA.PathParseCache = {}
TFA.PathParseCacheTR = {}
TFA.StatPathRemapCache = {}
TFA.PathParseCacheDirect = {}
TFA.PathParseChildren = {}

local PathParseCache = TFA.PathParseCache
local PathParseCacheTR = TFA.PathParseCacheTR
local PathParseCacheDirect = TFA.PathParseCacheDirect
local StatPathRemapCache = TFA.StatPathRemapCache
local PathParseChildren = TFA.PathParseChildren
local string_Explode = string.Explode
local ipairs = ipairs
local pairs = pairs
local string_sub = string.sub
local tonumber = tonumber
local table_Copy = table.Copy
local table_concat = table.concat
local istable = istable
local string_format = string.format

local function doDowngrade(path, migrations)
	for i, data in ipairs(migrations) do
		if data.new_path == path then
			return data.old_path, data.upgrade
		elseif path:StartWith(data.new_path) and path[#data.new_path + 1] == '.' then
			return data.old_path .. path:sub(#data.new_path + 1), data.upgrade
		end
	end

	return path
end

local function doUpgrade(path, migrations)
	for i, data in ipairs(migrations) do
		if data.old_path == path then
			return data.new_path, data.downgrade
		elseif path:StartWith(data.old_path) and path[#data.old_path + 1] == '.' then
			return data.new_path .. path:sub(#data.old_path + 1), data.downgrade
		end
	end

	return path
end

function TFA.RemapStatPath(path, path_version, structure_version)
	local cache_path = path

	if path_version == nil then path_version = 0 end
	if structure_version == nil then structure_version = 0 end

	-- version do not match
	if path_version ~= structure_version then
		cache_path = string_format("%d_%d_%s", path_version, structure_version, path)
	end

	local get_cache = StatPathRemapCache[cache_path]
	if get_cache ~= nil then return get_cache end

	if cache_path ~= path then
		-- downgrade path
		if path_version > structure_version then
			for version = path_version, structure_version, -1 do
				local mapping = TFA.DataVersionMapping[version]

				if istable(mapping) then
					path = doDowngrade(path, mapping)
				end
			end
		else -- upgrade path
			for version = path_version, structure_version do
				local mapping = TFA.DataVersionMapping[version]

				if istable(mapping) then
					path = doUpgrade(path, mapping)
				end
			end
		end
	end

	StatPathRemapCache[cache_path] = path
	return StatPathRemapCache[cache_path]
end

function TFA.GetStatPathChildren(path, path_version, structure_version)
	-- version do not match
	if path_version ~= structure_version then
		path = TFA.RemapStatPath(path, path_version, structure_version)
	end

	if not PathParseChildren[path] then
		TFA.GetStatPath(path, path_version, structure_version)
	end

	return PathParseChildren[path].list
end

local function concat_to(tab, to)
	local str = tab[1]

	for i = 2, to do
		str = str .. '.' .. tab[i]
	end

	return str
end

local function concat_from(tab, from)
	local str = tab[from]

	for i = from + 1, #tab do
		str = str .. '.' .. tab[i]
	end

	return str
end

function TFA.GetStatPath(path, path_version, structure_version, no_translate)
	local cache_path = path

	if path_version == nil then path_version = 0 end
	if structure_version == nil then structure_version = 0 end

	-- version do not match
	if path_version ~= structure_version then
		cache_path = string_format("%d_%d_%s", path_version, structure_version, path)
	end

	local _PathParseCache = no_translate and PathParseCacheTR or PathParseCache
	local get_cache = _PathParseCache[cache_path]
	if get_cache ~= nil then return get_cache[1], get_cache[2], get_cache[3] end

	local fn, fnGet

	if cache_path ~= path then
		-- downgrade
		if path_version > structure_version then
			for version = path_version, structure_version, -1 do
				local mapping = TFA.DataVersionMapping[version]

				if istable(mapping) then
					path, fnGet = doDowngrade(path, mapping)

					if fnGet and fnGet ~= identity then
						if not fn then
							fn = fnGet
						else
							local _fn = fn
							function fn(...) return fnGet(_fn(...)) end
						end
					end
				end
			end
		else -- upgrade
			for version = path_version, structure_version do
				local mapping = TFA.DataVersionMapping[version]

				if istable(mapping) then
					path, fnGet = doUpgrade(path, mapping)

					if fnGet and fnGet ~= identity then
						if not fn then
							fn = fnGet
						else
							local _fn = fn
							function fn(...) return fnGet(_fn(...)) end
						end
					end
				end
			end
		end
	end

	get_cache = string_Explode(".", path, false)

	do
		local children = PathParseChildren[get_cache[1]]

		if not children then
			children = {
				list = {get_cache[1]},
				children = {}
			}

			PathParseChildren[get_cache[1]] = children
		end

		local childrens = {children}

		for i = 2, #get_cache do
			local obj = get_cache[i]
			local path2 = concat_to(get_cache, i)

			for i3 = 1, #childrens do
				local list = childrens[i3].list
				local hit = false

				for i2 = 1, #list do
					if list[i2] == path2 then
						hit = true
						break
					end
				end

				if not hit then
					table.insert(list, path2)
				end
			end

			if not children.children[obj] then
				children.children[obj] = {
					list = {path2},
					children = {}
				}
			end

			if not PathParseChildren[path2] then
				PathParseChildren[path2] = {
					list = {path2},
					children = {}
				}
			end

			children = children.children[obj]
			table.insert(childrens, children)
			table.insert(childrens, PathParseChildren[path2])
		end
	end

	if not no_translate then
		if get_cache[1] == "Primary" then
			get_cache[1] = "Primary_TFA"
		elseif get_cache[1] == "Secondary" then
			get_cache[1] = "Secondary_TFA"
		end
	end

	for k, v in ipairs(get_cache) do
		get_cache[k] = tonumber(v) or v
	end

	_PathParseCache[cache_path] = {get_cache, path, fn or identity}
	return get_cache, path, fn or identity
end

function TFA.GetStatPathRaw(path)
	local get_cache = PathParseCacheDirect[path]
	if get_cache ~= nil then return get_cache end

	local t_stbl = string_Explode(".", path, false)

	for k, v in ipairs(t_stbl) do
		t_stbl[k] = tonumber(v) or v
	end

	PathParseCacheDirect[path] = t_stbl
	return t_stbl
end

local GetStatPathRaw = TFA.GetStatPathRaw

do
	local function get(self, path)
		local value = self[path[1]]

		for i = 2, #path do
			if not istable(value) then return end
			value = value[path[i]]
		end

		return value
	end

	local function set(self, path, val)
		if #path == 1 then
			if self[path[1]] == nil then
				self[path[1]] = val
			end

			return
		end

		local value = self[path[1]]

		if value == nil then
			self[path[1]] = {}
			value = self[path[1]]
		end

		for i = 2, #path - 1 do
			if not istable(value) then return end
			if value[path[i]] == nil then value[path[i]] = {} end
			value = value[path[i]]
		end

		if istable(value) and value[path[#path]] == nil then
			value[path[#path]] = val
		elseif not istable(value) then
			print('[TFA Base] unable to fill gap for older version in meta structure of ' .. table_concat(path, '.'))
		end
	end

	function TFA.FillMissingMetaValues(SWEP)
		for version = TFA.LatestDataVersion, 0, -1 do
			local mapping = TFA.DataVersionMapping[version]

			if istable(mapping) then
				for i, data in ipairs(mapping) do
					local getVal = get(SWEP, GetStatPathRaw(data.new_path))

					if getVal ~= nil then
						set(SWEP, GetStatPathRaw(data.old_path), data.downgrade(getVal))
					end
				end
			end
		end
	end
end

if CLIENT then
	concommand.Add("cl_tfa_data_translatestat", function(ply, cmd, args, argStr)
		if #args <= 0 then
			print("Usage: " .. cmd .. " <stat name>")

			return
		end

		for _, arg in ipairs(args) do
			if string.StartsWith(arg, "SWEP.") or string.StartsWith(arg, "self.") then
				arg = string.sub(arg, 6)
			end

			local _, path, _ = TFA.GetStatPath(arg, 0, TFA.LatestDataVersion)
			if path then
				print("SWEP." .. arg .. " => SWEP." .. path .. " (at data version " .. TFA.LatestDataVersion .. ")")
			else
				print("Unable to lookup updated stat path for " .. arg)
			end
		end
	end)
end

--PATH lua/tfa/modules/tfa_bodygroups.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_bodygroups.lua:
local sp = game.SinglePlayer()

hook.Add("PlayerSwitchWeapon", "TFA_Bodygroups_PSW", function(ply, oldwep, wep)
	if not IsValid(wep) or not wep.IsTFAWeapon then return end

	timer.Simple(0, function()
		if not IsValid(ply) or ply:GetActiveWeapon() ~= wep then return end

		wep:ApplyViewModelModifications()

		if sp then
			wep:CallOnClient("ApplyViewModelModifications")
		end
	end)
end)

--PATH lua/tfa/modules/tfa_netcode.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_small_entities.lua:
-- This file contain aliases/slight modifications which do not deserve their own Lua file

weapons.Register({
	Base = "tfa_nade_base",
	AllowUnderhanded = true,
}, "tfa_cssnade_base")

weapons.Register({
	Base = "tfa_gun_base",
	Shotgun = true,
}, "tfa_shotty_base")

weapons.Register({
	Base = "tfa_gun_base",
}, "tfa_akimbo_base")

if SERVER then
	AddCSLuaFile("tfa/3dscoped_base.lua")
end

local SWEP_ = include("tfa/3dscoped_base.lua")
local SWEP = table.Copy(SWEP_)
SWEP.Secondary = {}

SWEP.Secondary.UseACOG = false
SWEP.Secondary.UseMilDot = false
SWEP.Secondary.UseSVD = false
SWEP.Secondary.UseParabolic = false
SWEP.Secondary.UseElcan = false
SWEP.Secondary.UseGreenDuplex = false
SWEP.RTScopeFOV = 6
SWEP.RTScopeAttachment = 3 --Anchor the scope shadow to this
SWEP.Scoped = false
SWEP.BoltAction = false
SWEP.ScopeLegacyOrientation = false --used to align with eyeangles instead of vm angles
SWEP.ScopeAngleTransforms = {}
--{"P",1} --Pitch, 1
--{"Y",1} --Yaw, 1
--{"R",1} --Roll, 1
SWEP.ScopeOverlayTransforms = {0, 0}
SWEP.ScopeOverlayTransformMultiplier = 0.8
SWEP.RTMaterialOverride = 1
SWEP.IronSightsSensitivity = 1
SWEP.ScopeShadow = nil
SWEP.ScopeReticule = nil
SWEP.ScopeDirt = nil
SWEP.ScopeReticule_CrossCol = false
SWEP.ScopeReticule_Scale = {1, 1}
--[[End of Tweakable Parameters]]--
SWEP.Scoped_3D = true
SWEP.BoltAction_3D = false

SWEP.Base = "tfa_bash_base"

weapons.Register(SWEP, "tfa_3dbash_base")

SWEP = table.Copy(SWEP_)
SWEP.Secondary = {}

SWEP.Secondary.UseACOG = false
SWEP.Secondary.UseMilDot = false
SWEP.Secondary.UseSVD = false
SWEP.Secondary.UseParabolic = false
SWEP.Secondary.UseElcan = false
SWEP.Secondary.UseGreenDuplex = false
SWEP.RTScopeFOV = 6
SWEP.RTScopeAttachment = 3
SWEP.Scoped = false
SWEP.BoltAction = false
SWEP.ScopeLegacyOrientation = false --used to align with eyeangles instead of vm angles
SWEP.ScopeAngleTransforms = {}
--{"P",1} --Pitch, 1
--{"Y",1} --Yaw, 1
--{"R",1} --Roll, 1
SWEP.ScopeOverlayTransforms = {0, 0}
SWEP.ScopeOverlayTransformMultiplier = 0.8
SWEP.RTMaterialOverride = 1
SWEP.IronSightsSensitivity = 1
SWEP.ScopeShadow = nil
SWEP.ScopeReticule = nil
SWEP.ScopeDirt = nil
SWEP.ScopeReticule_CrossCol = false
SWEP.ScopeReticule_Scale = {1, 1}
--[[End of Tweakable Parameters]]--
SWEP.Scoped_3D = true
SWEP.BoltAction_3D = false

SWEP.Base = "tfa_gun_base"

weapons.Register(SWEP, "tfa_3dscoped_base")

weapons.Register({
	Base = "tfa_gun_base",

	Secondary = {
		UseACOG = false,
		UseMilDot = false,
		UseSVD = false,
		UseParabolic = false,
		UseElcan = false,
		UseGreenDuplex = false,
	},

	Scoped = true,
	BoltAction = false,
}, "tfa_scoped_base")

local ammo = {
	["357"] = {
		Type = "anim",
		Base = "tfa_ammo_base",
		PrintName = "357",
		Category = "TFA Ammunition",
		Spawnable = true,
		AdminSpawnable = true,
		Class = "",
		MyModel = "models/Items/357ammo.mdl",
		AmmoCount = 25,
		AmmoType = "357",
		DrawText = true,
		TextColor = Color(225, 225, 225, 255),
		TextPosition = Vector(5, 0, 7.5),
		TextAngles = Vector(42, 90, 0),
		ShouldDrawShadow = true,
		ImpactSound = "Default.ImpactSoft",
		Damage = 50,
	},

	ar2 = {
		Type = "anim",
		Base = "tfa_ammo_base",
		PrintName = "Assault Ammo",
		Category = "TFA Ammunition",
		Spawnable = true,
		AdminSpawnable = true,
		Class = "",
		MyModel = "models/Items/BoxMRounds.mdl",
		AmmoCount = 100,
		AmmoType = "ar2",
		DrawText = true,
		TextColor = Color(5, 5, 5, 255),
		TextPosition = Vector(2, 1.5, 13.4),
		TextAngles = Vector(90, 90, 90),
		ShouldDrawShadow = true,
		ImpactSound = "Default.ImpactSoft",
		Damage = 35,
		Text = "Assault Ammo",
	},

	buckshot = {
		Type = "anim",
		Base = "tfa_ammo_base",
		PrintName = "Buckshot",
		Category = "TFA Ammunition",
		Spawnable = true,
		AdminSpawnable = true,
		Class = "",
		MyModel = "models/Items/BoxBuckshot.mdl",
		AmmoCount = 20,
		AmmoType = "buckshot",
		DrawText = true,
		TextColor = Color(225, 225, 225, 255),
		TextPosition = Vector(2, 3.54, 3),
		TextAngles = Vector(0, 90, 90),
		ShouldDrawShadow = true,
		ImpactSound = "Default.ImpactSoft",
		Damage = 40,
		Text = "Buckshot",
	},

	pistol = {
		Type = "anim",
		Base = "tfa_ammo_base",
		PrintName = "Pistol Rounds",
		Category = "TFA Ammunition",
		Spawnable = true,
		AdminSpawnable = true,
		Class = "",
		MyModel = "models/Items/BoxSRounds.mdl",
		AmmoCount = 100,
		AmmoType = "pistol",
		DrawText = true,
		TextColor = Color(255, 255, 255, 255),
		TextPosition = Vector(2, 1.5, 11.6),
		TextAngles = Vector(90, 90, 90),
		ShouldDrawShadow = true,
		ImpactSound = "Default.ImpactSoft",
		Damage = 40,
		Text = "Pistol Rounds",
	},

	smg = {
		Type = "anim",
		Base = "tfa_ammo_base",
		PrintName = "SMG Rounds",
		Category = "TFA Ammunition",
		Spawnable = true,
		AdminSpawnable = true,
		Class = "",
		MyModel = "models/Items/BoxSRounds.mdl",
		AmmoCount = 100,
		AmmoType = "smg1",
		DrawText = true,
		TextColor = Color(255, 255, 255, 255),
		TextPosition = Vector(2, 1.5, 11.6),
		TextAngles = Vector(90, 90, 90),
		ShouldDrawShadow = true,
		ImpactSound = "Default.ImpactSoft",
		Damage = 20,
		Text = "SMG Rounds",
	},

	smg1_grenade = {
		Type = "anim",
		Base = "tfa_ammo_base",
		PrintName = "SMG Grenade",
		Category = "TFA Ammunition",

		Spawnable = true,
		AdminSpawnable = true,

		MyModel = "models/items/tfa/ar2_grenade.mdl",

		AmmoType = "SMG1_Grenade",
		AmmoCount = 1,

		DamageThreshold = 15,
	},

	smg1_grenade_large = {
		Type = "anim",
		Base = "tfa_ammo_base",
		PrintName = "SMG Grenades",
		Category = "TFA Ammunition",

		Spawnable = true,
		AdminSpawnable = true,

		MyModel = "models/items/tfa/boxar2grenades.mdl",

		AmmoType = "SMG1_Grenade",
		AmmoCount = 5,

		DamageThreshold = 55,
	},

	sniper_rounds = {
		Type = "anim",
		Base = "tfa_ammo_base",
		PrintName = "Sniper Ammo",
		Category = "TFA Ammunition",
		Spawnable = true,
		AdminSpawnable = true,
		Class = "",
		MyModel = "models/Items/sniper_round_box.mdl",
		AmmoCount = 30,
		AmmoType = "SniperPenetratedRound",
		DrawText = true,
		TextColor = Color(185, 25, 25, 255),
		TextPosition = Vector(1, -1.45, 2.1),
		TextAngles = Vector(90, 0, 0),
		ShouldDrawShadow = true,
		ImpactSound = "Default.ImpactSoft",
		Damage = 80,
		Text = "Sniper Rounds",
		TextScale = 0.5,
	},

	winchester = {
		Type = "anim",
		Base = "tfa_ammo_base",
		PrintName = "Winchester Ammo",
		Category = "TFA Ammunition",
		Spawnable = true,
		AdminSpawnable = true,
		Class = "",
		MyModel = "models/Items/sniper_round_box.mdl",
		AmmoCount = 50,
		AmmoType = "AirboatGun",
		DrawText = true,
		TextColor = Color(185, 25, 25, 255),
		TextPosition = Vector(1, -1.45, 1.5),
		TextAngles = Vector(90, 0, 0),
		ShouldDrawShadow = true,
		ImpactSound = "Default.ImpactSoft",
		Damage = 30,
		Text = ".308",
	}
}

for ammoclass, ENT in pairs(ammo) do
	scripted_ents.Register(ENT, "tfa_ammo_" .. ammoclass)
end

--PATH lua/tfa/modules/tfa_snd_timescale.lua:
return gluapack()()
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1, band(rshift(state, 22), 1) == 0 and 0 or 1, band(rshift(state, 23), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1, band(rshift(state, 22), 1) == 0 and 0 or 1, band(rshift(state, 23), 1) == 0 and 0 or 1, band(rshift(state, 24), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1, band(rshift(state, 22), 1) == 0 and 0 or 1, band(rshift(state, 23), 1) == 0 and 0 or 1, band(rshift(state, 24), 1) == 0 and 0 or 1, band(rshift(state, 25), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1, band(rshift(state, 22), 1) == 0 and 0 or 1, band(rshift(state, 23), 1) == 0 and 0 or 1, band(rshift(state, 24), 1) == 0 and 0 or 1, band(rshift(state, 25), 1) == 0 and 0 or 1, band(rshift(state, 26), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1, band(rshift(state, 22), 1) == 0 and 0 or 1, band(rshift(state, 23), 1) == 0 and 0 or 1, band(rshift(state, 24), 1) == 0 and 0 or 1, band(rshift(state, 25), 1) == 0 and 0 or 1, band(rshift(state, 26), 1) == 0 and 0 or 1, band(rshift(state, 27), 1) == 0 and 0 or 1		end
	
--PATH lua/tfa/modules/cl_tfa_models.lua:
return gluapack()()
--PATH lua/tfa/modules/cl_tfa_projtex.lua:
return gluapack()()
--PATH lua/tfa/modules/cl_tfa_rendertarget.lua:
return gluapack()()
--PATH lua/tfa/modules/cl_tfa_vm_blur.lua:
return gluapack()()
--PATH lua/tfa/att/base.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end

-- ATTACHMENT.TFADataVersion = 1 -- Uncomment this in your attachment file
-- If it is undefined, if fallback to 0 and WeaponTable gets migrated like SWEPs do

ATTACHMENT.Name = "Base Attachment"
ATTACHMENT.ShortName = nil --Abbreviation, 5 chars or less please
ATTACHMENT.Description = {} --TFA.Attachments.Colors["+"], "Does something good", TFA.Attachments.Colors["-"], "Does something bad" }
ATTACHMENT.Icon = nil --Revers to label, please give it an icon though!  This should be the path to a png, like "entities/tfa_ammo_match.png"
ATTACHMENT.WeaponTable = {} --put replacements for your SWEP talbe in here e.g. ["Primary"] = {}

ATTACHMENT.DInv2_GridSizeX = nil -- DInventory/2 Specific. Determines attachment's width in grid.
ATTACHMENT.DInv2_GridSizeY = nil -- DInventory/2 Specific. Determines attachment's height in grid.
ATTACHMENT.DInv2_Volume = nil -- DInventory/2 Specific. Determines attachment's volume in liters.
ATTACHMENT.DInv2_Mass = nil -- DInventory/2 Specific. Determines attachment's mass in kilograms.
ATTACHMENT.DInv2_StackSize = nil -- DInventory/2 Specific. Determines attachment's maximal stack size.

ATTACHMENT.TFADataVersion = nil -- TFA.LatestDataVersion, specifies version of TFA Weapon Data this attachment utilize in `WeaponTable`
-- 0 is original, M9K-like data, and is the fallback if `TFADataVersion` is undefined

function ATTACHMENT:CanAttach(wep)
	return true --can be overridden per-attachment
end

function ATTACHMENT:Attach(wep)
end

function ATTACHMENT:Detach(wep)
end

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end

--PATH lua/tfa/att/blue_stun.lua:
return gluapack()()
--PATH lua/autorun/tfa_comm_sw_magnaguard.lua:
return gluapack()()
--PATH lua/autorun/tfa_srv_rp_utils.lua:
return gluapack()()
--PATH lua/autorun/tfa_srv_rp_utils.lua:
--[[
Coded by TFA ( http://steamcommunity.com/profiles/76561198161775645 )
Commissioned by Servius ( http://steamcommunity.com/profiles/76561198036188853/ )
Written: 1/19/2017
Begun: 9:52 PM CDT
Draft 1 Finished: 11:49 PM CDT
]]--

--[[Documentation]]--

--[[Stunning]]--

--For GENERAL USAGE, use TFA_RP_Stun( ply, duration, effect )
--ply is the player to stun, duration is the length to stun, and effect is the Lua effect to use
--Leaving the effect to nil will give it a pronounced lightning effect.  Or, setting it to "BGOLightning" will give it a nice lightning effect which lasts for a set length of 5 seconds.
--Example: TFA_RP_Stun( Entity(1), 5, "TeslaHitBoxes" )

--For SWEPs, use TFA_RP_StunEasy( a,b,c, length, effect )
--This function is easily placed in a bullet callback; length and effect are optional, but not required.  Length will default to 3.
--TFA Base example:
--SWEP.CustomBulletCallback = function(a,b,c)
--	TFA_RP_StunEasy(a,b,c)
--end

--[[Melting]]--

--For GENERAL USAGE, use TFA_RP_Melt( ent, fade, duration, recovery, fx, snd, col  )
--ent is the entity to melt ( please use carefully ), fade is the "fade-in" of the melting animation, duration is the recovery to remain melted, and recovery is the "fade-out" of the melting animation
--optionally: fx is the Lua effect to use, snd is the melt sound, and col is the melt color ( defined as a Color(r,g,b,a) )
--Example:  TFA_RP_Melt( Entity(1):GetEyeTrace().Entity, 1, 15, 1, "Explosion", "misc/bomb.wav", Color(255,0,0,255)  )

--For SWEPs, use TFA_RP_MeltEasy( a,b,c, duration, fx, snd, col )
--This function is easily placed in a bullet callback; Duration is optional, but not required, and will default to 15.
--TFA Base example:
--SWEP.CustomBulletCallback = function(a,b,c)
--	TFA_RP_MeltEasy(a,b,c)
--end

--[[ Important Funcs/Vars ]]--

local wrongsound = "common/warning.wav" --Error sound for easy SWEP accessors
local MeltColor = Color( 0,0,0, 255 ) --Default melt color

function TFA_RP_StunEasy( a,b,c, length, effect )
	if IsValid(b.Entity) and b.Entity:IsPlayer() then
		TFA_RP_Stun( b.Entity, length or 3, effect or "BGOLightning" )
	elseif IsValid(b.Entity) and ( not b.Entity:IsWorld() ) and surface then
		surface.PlaySound( wrongsound )
	end
end

function TFA_RP_Stun( ent, duration, effect )
	ent:SetNW2Float("TFA_RP_StunEnd", CurTime() + duration )
	if ent.GetActiveWeapon and IsValid( ent:GetActiveWeapon() ) then
		local wep = ent:GetActiveWeapon()
		wep:SetNextPrimaryFire( math.max( wep:GetNextPrimaryFire(), CurTime() + duration ) )
		wep:SetNextSecondaryFire(wep:GetNextPrimaryFire() )
	end
	effect = effect or "TeslaHitBoxes"
	if effect == "BGOLightning" then
		ent.NextBGOLightning = ent.NextBGOLightning  or 0
		if CurTime() > ent.NextBGOLightning then
			ParticleEffectAttach("tfa_lightning_model", PATTACH_ABSORIGIN_FOLLOW, ent, 0)
			ent.NextBGOLightning  = CurTime() + 1
		end
		ent:SetNW2String("TFA_RP_StunFX","")
	else
		local fx = EffectData()
		fx:SetOrigin( ent:GetShootPos() )
		fx:SetNormal( Vector(0,0,1) )
		fx:SetEntity(ent)
		fx:SetScale(1)
		fx:SetMagnitude(1)
		util.Effect(effect,fx)
		ent:SetNW2String("TFA_RP_StunFX",effect)
	end
end

function TFA_RP_MeltEasy( a,b,c, duration, ... )
	duration = duration or 15
	if IsValid(b.Entity) and b.Entity:GetClass() == "prop_physics" then
		TFA_RP_Melt( b.Entity, 1, duration, 1, ... )
	elseif IsValid(b.Entity) and ( not b.Entity:IsWorld() ) and b.Entity:GetClass() ~= "prop_physics" and surface then
		surface.PlaySound( wrongsound )
	end
end

function TFA_RP_Melt( ent, fade, duration, recovery, fx, snd, col  )
	if not SERVER then return end
	local ct = CurTime()
	ent.Melt_FadeStart = ent.Melt_FadeStart or ct
	local fade2 = fade - ( ct - ent.Melt_FadeStart )
	ent.Melt_PreMeltColor = ent.Melt_PreMeltColor or ent:GetColor()
	ent.Melt_HideStart = ct + fade2
	ent.Melt_RecoverStart = ct + fade2 + duration
	ent.Melt_RecoverEnd = ct + fade2 + duration + recovery
	ent.Melt_FinishEffect = fx or "ManhackSparks"
	ent.Melt_FinishSound = snd or "Explosion"
	ent.Melt_FinishColor = col or MeltColor
	local hkid = ent:EntIndex() .. "melt"
	hook.Add("Tick",hkid, function()
		local mt = TFA_RP_MeltThink(ent)
		if not mt then
			hook.Remove( "Tick", hkid )
		end
	end)
end

--[[ Acid ]]--

local l_Lerp = Lerp
local l_Clamp = math.Clamp
local tmpcol = Color(0,0,0,255)

local function MixCol(fac, from, to)
	tmpcol.r = l_Lerp(fac, from.r, to.r)
	tmpcol.g = l_Lerp(fac, from.g, to.g)
	tmpcol.b = l_Lerp(fac, from.b, to.b)
	tmpcol.a = l_Lerp(fac, from.a, to.a)

	return tmpcol
end

local function CalcFac( t, startv, endv )
	return l_Clamp( ( t - startv ) / ( endv - startv ), 0, 1 )
end

local upvec = Vector(0,0,1)

local function MeltEnt( ent )
	if not IsValid(ent) then return end
	if ent.IsMelted then return end
	ent.IsMelted = true
	local fx = EffectData()
	fx:SetOrigin(ent:GetPos())
	fx:SetEntity(ent)

	util.Effect( ent.Melt_FinishEffect or "ManhackSparks", fx)
	fx:SetScale(0.1)
	fx:SetMagnitude(0.1)
	fx:SetNormal( upvec )
	if ent.Melt_FinishSound and ent.Melt_FinishSound == "Explosion" then
		util.Effect("Explosion", fx)
	elseif ent.Melt_FinishSound then
		ent:EmitSound( ent.Melt_FinishSound )
	end
	if not ent.GetPhysicsObject then return end
	local phys = ent:GetPhysicsObject()

	if IsValid(phys) and IsValid(ent) then
		ent.Melt_OldMotion = ent.Melt_OldMotion or phys:IsMotionEnabled()
		ent.Melt_OldCollisions = ent.Melt_OldCollisions or phys:IsCollisionEnabled()
		ent.Melt_OldCollisionGroup = ent.Melt_OldCollisionGroup or ent:GetCollisionGroup()
		phys:EnableMotion(false)
		phys:EnableCollisions(false)
		ent:SetCollisionGroup(COLLISION_GROUP_DEBRIS)

		ent.Melt_OldRenderMode = ent.Melt_OldRenderMode or ent:GetRenderMode()
		ent:SetRenderMode(RENDERMODE_TRANSALPHA)
	end
end

local function UnMeltEnt( ent )
	if not IsValid(ent) then return end
	if not ent.IsMelted then return end
	if not ent.GetPhysicsObject then return end
	local phys = ent:GetPhysicsObject()
	if IsValid(phys) then
		phys:EnableMotion( ent.Melt_OldMotion )
		phys:EnableCollisions( ent.Melt_OldCollisions )
		ent:SetCollisionGroup( ent.Melt_OldCollisionGroup or COLLISION_GROUP_NONE)
		ent:SetRenderMode( ent.Melt_OldRenderMode or RENDERMODE_NORMAL)
		ent.Melt_OldCollisions = nil
		ent.Melt_OldCollisionGroup = nil
		ent.Melt_OldRenderMode = nil
		ent.Melt_OldMotion = nil
	end
	ent.IsMelted = false
end

function TFA_RP_MeltThink( ent )
	if not IsValid(ent) then return false end
	if not ent.Melt_FadeStart then return false end
	if not ent.Melt_HideStart then return false end
	if not ent.Melt_RecoverStart then return false end
	if not ent.Melt_RecoverEnd then return false end
	local color_begin = ent.Melt_PreMeltColor or color_white
	local color_end = ent.Melt_FinishColor or MeltColor
	local ct = CurTime()
	if ct > ent.Melt_RecoverEnd then
		ent.Melt_FadeStart = nil
		ent.Melt_HideStart = nil
		ent.Melt_RecoverStart = nil
		ent.Melt_RecoverEnd = nil
		ent.Melt_PreMeltColor = nil
		ent.IsMelted = false
		ent:SetColor( color_begin )
	elseif ct > ent.Melt_RecoverStart then
		local fac = CalcFac( CurTime(), ent.Melt_RecoverStart, ent.Melt_RecoverEnd )
		ent:SetColor( MixCol( fac, color_end, color_begin ) )
		UnMeltEnt( ent )
	elseif ct > ent.Melt_HideStart then
		MeltEnt( ent )
		ent:SetColor( ColorAlpha( color_end, 50 ) )
	elseif ct > ent.Melt_FadeStart then
		local fac = CalcFac( CurTime(), ent.Melt_FadeStart, ent.Melt_HideStart )
		ent:SetColor( MixCol( fac, color_begin, color_end ) )
	end
	return true
end

--[[ Stunning! ]]--

game.AddParticles("particles/sv_tfa_lightningfx.pcf")
PrecacheParticleSystem("tfa_lightning_model")

hook.Add("Move","TFA_RPStun_Move",function(ent,mv,cmd) end)
hook.Add("SetupMove","TFA_RPStun_Move",function(ent,mv,cmd)
	if CurTime() < ( ent:GetNW2Float("TFA_RP_StunEnd",-1) or -1 ) then
		mv:SetMaxSpeed(0.01)
		mv:SetMaxClientSpeed(0.01)
		mv:SetButtons(0)
		cmd:RemoveKey( IN_ATTACK )
		cmd:RemoveKey( IN_ATTACK2 )
		cmd:RemoveKey( IN_ZOOM )
		--if SERVER then
		local str = ent:GetNW2String("TFA_RP_StunFX")
		if str and str ~= "" then
			local fx = EffectData()
			fx:SetOrigin( ent:GetShootPos() )
			fx:SetNormal( Vector(0,0,1) )
			fx:SetEntity(ent)
			fx:SetScale(1)
			fx:SetMagnitude(1)
			util.Effect(str,fx)
		end
		--end
	end
end)
hook.Add("PlayerSwitchWeapon","TFA_RPStun_PSW",function(ply,owp,nwp)
	if CurTime() < ( ply:GetNW2Float("TFA_RP_StunEnd",-1) or -1 ) then
		return true
	end
end)
--PATH lua/autorun/vj_controls.lua:
return gluapack()()
--PATH lua/autorun/vj_files_particles.lua:
return gluapack()()
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/extensions/wos_aoc.lua:
return gluapack()()
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/core/sh_holdtypes.lua:
-- "addons\\wosanim_fixes\\lua\\wos\\anim_extension\\core\\sh_holdtypes.lua"
-- Retrieved by https://github.com/lewisclark/glua-steal
--[[-------------------------------------------------------------------
	wiltOS Hold Type Register:
		The core files needed to make your own hold types
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.HoldTypes = wOS.AnimExtension.HoldTypes or {}
wOS.AnimExtension.TranslateHoldType = wOS.AnimExtension.TranslateHoldType or {}

wOS.AnimExtension.ActIndex = {
	[ "pistol" ] 		= ACT_HL2MP_IDLE_PISTOL,
	[ "smg" ] 			= ACT_HL2MP_IDLE_SMG1,
	[ "grenade" ] 		= ACT_HL2MP_IDLE_GRENADE,
	[ "ar2" ] 			= ACT_HL2MP_IDLE_AR2,
	[ "shotgun" ] 		= ACT_HL2MP_IDLE_SHOTGUN,
	[ "rpg" ]	 		= ACT_HL2MP_IDLE_RPG,
	[ "physgun" ] 		= ACT_HL2MP_IDLE_PHYSGUN,
	[ "crossbow" ] 		= ACT_HL2MP_IDLE_CROSSBOW,
	[ "melee" ] 		= ACT_HL2MP_IDLE_MELEE,
	[ "slam" ] 			= ACT_HL2MP_IDLE_SLAM,
	[ "normal" ]		= ACT_HL2MP_IDLE,
	[ "fist" ]			= ACT_HL2MP_IDLE_FIST,
	[ "melee2" ]		= ACT_HL2MP_IDLE_MELEE2,
	[ "passive" ]		= ACT_HL2MP_IDLE_PASSIVE,
	[ "knife" ]			= ACT_HL2MP_IDLE_KNIFE,
	[ "duel" ]			= ACT_HL2MP_IDLE_DUEL,
	[ "camera" ]		= ACT_HL2MP_IDLE_CAMERA,
	[ "magic" ]			= ACT_HL2MP_IDLE_MAGIC,
	[ "revolver" ]		= ACT_HL2MP_IDLE_REVOLVER
}

function wOS.AnimExtension:RegisterHoldtype( data )

	self.TranslateHoldType[ data.HoldType ] = data
    self.HoldTypeMeta:CreateMetaType( self.TranslateHoldType[ data.HoldType ] )
	
	if data.BaseHoldType then
		if prone then
			if prone.animations then
				if prone.animations.WeaponAnims then
					prone.animations.WeaponAnims.moving[ data.HoldType ] = prone.animations.WeaponAnims.moving[ data.BaseHoldType ]
					prone.animations.WeaponAnims.idle[ data.HoldType ] = prone.animations.WeaponAnims.idle[ data.BaseHoldType ]
				end
			end
		end
	end

	print( "[wOS] Registered new Hold Type: " .. data.Name )
	
end

local meta = FindMetaTable( "Player" )
local ENTITY = FindMetaTable( "Entity" )

local AttackTable = {
[ ACT_MP_ATTACK_STAND_PRIMARYFIRE  ] = true,
[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE  ] = true,
[ ACT_MP_ATTACK_STAND_SECONDARYFIRE  ] = true,
[ ACT_MP_ATTACK_CROUCH_SECONDARYFIRE  ] = true,
}

local _TranslateWeaponActivity = meta.TranslateWeaponActivity
function meta:TranslateWeaponActivity( act )

	if AttackTable[ act ] then
		local wep = self:GetActiveWeapon()
		if IsValid( wep ) then  
			local holdtype = wep:GetHoldType()
			if wOS.AnimExtension.TranslateHoldType[ holdtype ] then
				local ATTACK_DATA = wOS.AnimExtension.TranslateHoldType[ holdtype ]:GetActData( act )
				if ATTACK_DATA then
					local anim = self:LookupSequence( ATTACK_DATA.Sequence )
					self:AddVCDSequenceToGestureSlot( GESTURE_SLOT_VCD, anim, 0, true ) //Figure out weight to make it balanced!
					self:AnimSetGestureWeight( GESTURE_SLOT_VCD, ATTACK_DATA.Weight or 1 )
				end
			end
		end
	end
	
	return _TranslateWeaponActivity( self, act )

end


-- local _DoAnimationEvent = meta.DoAnimationEvent
-- function meta:DoAnimationEvent( ply, event, data )

-- 	local act = _DoAnimationEvent( self, ply, event, data )
-- 	print( act )
-- 	local wep = self:GetActiveWeapon()
-- 	if IsValid( wep ) then  
-- 		local holdtype = wep:GetHoldType()
-- 		if wOS.AnimExtension.TranslateHoldType[ holdtype ] then
-- 			local result = wOS.AnimExtension.TranslateHoldType[ holdtype ][ act ]
-- 			if result then
-- 				if istable( result ) then
-- 					result = table.Random( result )
-- 				end
-- 				if isstring( result ) then
-- 					local anim = ply:LookupSequence( result )	
-- 					ply.ActOverrider = act
-- 					ply.SequenceTime = CurTime() + ply:SequenceDuration( anim )
-- 				end
-- 			end
-- 		end
-- 	end
	
-- 	return act
-- end

hook.Add( "DoAnimationEvent", "wOS.AnimExtension.CustomTriggers", function( ply, event, data ) 

	local wep = ply:GetActiveWeapon()
	if !IsValid( wep ) then return end
	local holdtype = wep:GetHoldType()
	if !wOS.AnimExtension.TranslateHoldType[ holdtype ] then return end

	local act = 9999
	local crouch = ply:Crouching()
	if event == PLAYERANIMEVENT_RELOAD then
		act = ( crouch and ACT_MP_RELOAD_CROUCH ) or ACT_MP_RELOAD_STAND
	elseif event == PLAYERANIMEVENT_ATTACK_SECONDARY then
		act = ( crouch and ACT_MP_ATTACK_CROUCH_SECONDARYFIRE ) or ACT_MP_ATTACK_STAND_SECONDARYFIRE
	end

	local ATTACK_DATA = wOS.AnimExtension.TranslateHoldType[ holdtype ]:GetActData( act )
	if !ATTACK_DATA then return end

	local anim = ply:LookupSequence( ATTACK_DATA.Sequence )
	ply:AddVCDSequenceToGestureSlot( GESTURE_SLOT_VCD, anim, 0, true ) //Figure out weight to make it balanced!
	ply:AnimSetGestureWeight( GESTURE_SLOT_VCD, ATTACK_DATA.Weight or 1 )

	return ACT_INVALID
end )

hook.Add( "Initialize", "wOS.AnimExtension.CustomSequenceHoldtypes", function()

	local _CalcMainActivity = GAMEMODE.CalcMainActivity
	function GAMEMODE:CalcMainActivity( ply, vel )
		
		local act, seq = _CalcMainActivity( self, ply, vel )
		local pr = false
		if prone then
			if ply.IsProne then
				pr = ply:IsProne()
			end
		end

		if not pr then
			local wep = ply:GetActiveWeapon()
			if IsValid( wep ) then  
				local holdtype = wep:GetHoldType()
				if wOS.AnimExtension.TranslateHoldType[ holdtype ] then
					local ATTACK_DATA = wOS.AnimExtension.TranslateHoldType[ holdtype ]:GetActData( act )
					if act == ACT_MP_RUN and ply:KeyDown( IN_SPEED ) then
						ATTACK_DATA = wOS.AnimExtension.TranslateHoldType[ holdtype ]:GetActData( ACT_MP_SPRINT ) or ATTACK_DATA
					end
					if ATTACK_DATA then
						seq = ply:LookupSequence( ATTACK_DATA.Sequence )
					end
				end
			end

			
			if act != ply.LastAct then
				ply:SetCycle( 0 )
			end
		end
		
		ply.LastAct = act
		
		return act, seq
		
	end
	
end )

if SERVER then return end

concommand.Add( "wos_base_help", function( ply, cmd, args )
	MsgC( Color( 255, 255, 255 ), "------------------ ", Color( 133, 173, 219 ), "wiltOS HELP PRINT", Color( 255, 255, 255 ), " ----------------------\n" )
	MsgC( Color( 255, 255, 255 ), "Addon Path Check: " )
	LocalPlayer():ConCommand( "whereis models/m_anm.mdl" )
	timer.Simple( 0.01, function()
	
		MsgC( color_white, "\nPlease ensure the addon path above points to ", Color( 0, 255, 0 ), "'[wOS] Animation Extension - Base'\n")
		MsgC( color_white, "If it does not, unsubscribe to the addon it does point to and get the Animation Base\n")
		print("\n")

		local seq = LocalPlayer():LookupSequence( "_base_wiltos_enabled_" )
		local resp = ( seq >= 0 and Color( 0, 255, 0 ) ) or Color( 255, 0, 0 )
		MsgC( color_white, "Sequence Check: ", resp, "\t", seq, "\n" )
		MsgC( color_white, "If the above sequence check is ", Color( 255, 0, 0 ), -1, color_white, " and the addon above points to the correct location,\nensure your model is a ", Color( 0, 255, 0 ), "PLAYER MODEL", color_white, " and not an ", Color( 255, 0, 0 ), "NPC MODEL\n" )
		MsgC( color_white, "Run this commmand again as a default GMod player model. If it still prints ", Color( 255, 0, 0 ), -1, color_white, " your Animation Base may be outdated\n" )

		print( "\n" )
		MsgC( color_white, "You can find the link here: https://steamcommunity.com/sharedfiles/filedetails/?id=757604550\n")
		MsgC( Color( 255, 255, 255 ), "-----------------------------------------------------------\n" )
	end )
end )
--PATH lua/wos/anim_extension/holdtypes/a_combo4.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/form2.lua:

local DATA = {}
DATA.Name = "form2"
DATA.HoldType = "form2_holdtype"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 
DATA.Translations[ ACT_MP_STAND_IDLE ] = "mak2_idle"
DATA.Translations[ ACT_MP_JUMP ] = "balanced_jump"
DATA.Translations[ ACT_MP_WALK ] = "dooka_walk"
DATA.Translations[ ACT_MP_RUN ] = "dooka_run"
wOS.AnimExtension:RegisterHoldtype( DATA )

--PATH lua/wos/anim_extension/holdtypes/form3.lua:

local DATA = {}
DATA.Name = "form3"
DATA.HoldType = "form3_holdtype"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 
DATA.Translations[ ACT_MP_STAND_IDLE ] = "sore_idle"
DATA.Translations[ ACT_MP_WALK ] = "sore_run"
DATA.Translations[ ACT_MP_RUN ] = "run_shichoo"
wOS.AnimExtension:RegisterHoldtype( DATA )

--PATH lua/wos/anim_extension/holdtypes/form5.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/g_combo2.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "g_combo2"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "combo2" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "combo2" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH lua/wos/anim_extension/holdtypes/g_combo32.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "g_combo32"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "combo32" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "combo32" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH lua/wos/anim_extension/holdtypes/g_rollleft.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "g_rollleft"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "rollleft" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "rollleft" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "wos_judge_a_idle"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/greaterer_melee.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/leap.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/lscs_holdtypes.lua:

local DATA = {}
DATA.Name = "[LSCS] HoldType Butterfly"
DATA.HoldType = "lscs_butterfly"
DATA.BaseHoldType = "melee"
DATA.Translations = {} 
DATA.Translations[ ACT_MP_STAND_IDLE ] = "vanguard_f_idle"
DATA.Translations[ ACT_MP_WALK ] = "walk_knife"
DATA.Translations[ ACT_MP_RUN ] = "run_knife"
wOS.AnimExtension:RegisterHoldtype( DATA )

--PATH lua/wos/anim_extension/holdtypes/makashi2_holdtype.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/makashi2_holdtype.lua:

local DATA = {}
DATA.Name = "[LSCS] HoldType Makashi 2"
DATA.HoldType = "makashi2_holdtype"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 
DATA.Translations[ ACT_MP_STAND_IDLE ] = "mak2_idle"
DATA.Translations[ ACT_MP_WALK ] = "mak_run"
DATA.Translations[ ACT_MP_RUN ] = "mak_run"
wOS.AnimExtension:RegisterHoldtype( DATA )

--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/melee2greater.lua:
local DATA = {}
DATA.Name = "melee4"
DATA.HoldType = "wos-meleeheavier-type"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "judge_b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "judge_b_idle", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "balanced_jump", Weight = 1 },
}


wOS.AnimExtension:RegisterHoldtype( DATA )
--=====================================================================
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/saber_staff.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/slashup.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "slashup"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "slashup" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "slashup" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH lua/wos/dynabase/core/cl_net.lua:
wOS = wOS or {}
wOS.DynaBase = wOS.DynaBase or {}

net.Receive( "wOS.DynaBase.SendAllRegisters", function()
	wOS.DynaBase.EnforceCount = net.ReadUInt( 32 )
	for i=1, wOS.DynaBase.EnforceCount do
		local name = net.ReadString()
		local tbl = wOS.DynaBase:GetSource( name )
		if not tbl then wOS.DynaBase:RegisterSource({Name = name, ServerValid = true}) return end
		tbl.ServerValid = true
	end
end )

net.Receive( "wOS.DynaBase.SendRegister", function()
	local name = net.ReadString()
	local tbl = wOS.DynaBase:GetSource( name )
	if not tbl then wOS.DynaBase:RegisterSource({Name = name, ServerValid = true}) return end
	tbl.ServerValid = true
	wOS.DynaBase.EnforceCount = wOS.DynaBase.EnforceCount + 1
end )

net.Receive( "wOS.DynaBase.ForceMountCallback", function()
	local tbl = cvars.GetConVarCallbacks( "wos_dynabase_mountorder" ) or {}

	local oldval = net.ReadString()
	local newval = net.ReadString()

	for _, func in ipairs( tbl ) do
		func( "wos_dynabase_mountorder", oldval, newval )
	end
end )
--PATH lua/wos/dynabase/core/cl_core.lua:
return gluapack()()
--PATH lua/wos/dynabase/core/cl_core.lua:
wOS = wOS or {}
wOS.DynaBase = wOS.DynaBase or {}
wOS.DynaBase.UserMounts = {}

hook.Add( "RenderScene", "wOS.DynaBase.PreventDataAccess", function()
	if wOS.DynaBase.ResumeRendering and wOS.DynaBase.ResumeRendering >= CurTime() then return true end
	if not wOS.DynaBase.ReloadModelBool then return end
	wOS.DynaBase.DataCachePass = wOS.DynaBase.DataCachePass + 1
	return true
end )

hook.Add( "PostRender", "wOS.DynaBase.PreventDataAccess", function()
	if not wOS.DynaBase.ReloadModelBool then return end
	wOS.DynaBase.ReloadModelBool = false
	local val = wOS.DynaBase.DataCachePass
	wOS.DynaBase.DataCachePass = 0
	if not val or val < WOS_DYNABASE.MAXCACHE then
		chat.AddText( Color( 255, 0, 0 ), "[wOS-Dynabase] Can not apply animation selection due to conflicting addons. Please let us know on the Workshop Page or Discord!" )
		return
	end
	RunConsoleCommand( "r_flushlod" )
	hook.Call( "PostLoadAnimations" )
	wOS.DynaBase.ResumeRendering = CurTime() + 0.3
	if not wOS.DynaBase.FIRST_TIME_LOADED then wOS.DynaBase.FIRST_TIME_LOADED = true return end
	chat.AddText( Color( 0, 255, 0 ), "[wOS-Dynabase] Successfully applied animation selection to models!" )
end )

concommand.Add( "wos_dynabase_reloadmodels", function()
	wOS.DynaBase.LIVE_RELOAD = true
	wOS.DynaBase:ReloadAnimations()
	wOS.DynaBase.LIVE_RELOAD = false
end )

///////////////////////////////////////////////////////////////////////////////////////////////////
// Credits to Starlight (Oliver) for the code snippet and also giving it to me every time
// I asked, for the last 3 years
local function FindPotentialBases()

	for _ ,addon in pairs( engine.GetAddons() ) do
		local modelFound = file.Find("models/m_anm.mdl", addon.title)
		if #modelFound != 0 then
			MsgC( Color( 255, 0, 255 ), "\n\tAddon: " .. addon.title .. "\n" )
			MsgC( Color( 255, 0, 255 ), "\tLink: https://steamcommunity.com/sharedfiles/filedetails/?id=" .. addon.wsid .. "\n" )
			return true
		end 
	end

	return false
end
///////////////////////////////////////////////////////////////////////////////////////////////////

concommand.Add( "wos_dynabase_help", function( ply, cmd, args )
	MsgC( Color( 255, 255, 255 ), "------------------ ", Color( 133, 173, 219 ), "wiltOS HELP PRINT", Color( 255, 255, 255 ), " ----------------------\n" )
	MsgC( Color( 255, 255, 255 ), "Installed Animation Base\n" )
	timer.Simple( 0.01, function()
		local found = FindPotentialBases()
		if not found then
			MsgC( Color( 255, 0, 255 ), "\n\tNo Animation Bases found! You must get the Dynamic Animation Manager\n" )
			MsgC( Color( 255, 0, 255 ), "\tWorkshop Link: https://steamcommunity.com/sharedfiles/filedetails/?id=2916561591\n" )
		end
		MsgC( color_white, "\nPlease ensure that the only addon above is ", Color( 0, 255, 0 ), "'[wOS] DynaBase - The Dynamic Animation Manager'\n")
		MsgC( color_white, "If there are more addons, unsubscribe from them and install the Dynamic Animation Manager.\n")
		print("\n")

		local seq = LocalPlayer():LookupSequence( "_dynamic_wiltos_enabled_" )
		local resp = ( seq >= 0 and Color( 0, 255, 0 ) ) or Color( 255, 0, 0 )
		MsgC( color_white, "Sequence Check: ", resp, "\t", seq, "\n" )
		MsgC( color_white, "If the above sequence check is ", Color( 255, 0, 0 ), -1, color_white, " and the addon above points to the correct location,\nensure your model is a ", Color( 0, 255, 0 ), "PLAYER MODEL", color_white, " and not an ", Color( 255, 0, 0 ), "NPC MODEL\n" )
		MsgC( color_white, "Run this commmand again as a default GMod player model. If it still prints ", Color( 255, 0, 0 ), -1, color_white, " your Animation Base may be outdated\n" )

		print( "\n" )
		MsgC( color_white, "Make can find the Dynamic Animation Manager workshop page here: https://steamcommunity.com/sharedfiles/filedetails/?id=2916561591\n")
		MsgC( Color( 255, 255, 255 ), "-----------------------------------------------------------\n" )
	end )
end )

///////////////////////////////////////////////////////////////////////////////////////////////////

concommand.Add( "wos_dynabase_openconfig", function( ply, cmd, args )
	wOS.DynaBase:OpenConfigMenu()
end )

list.Add( "DesktopWindows", {
	icon = "wos/dynabase/widget.png",
	title = "DynaBase Menu",
	init = function() wOS.DynaBase:OpenConfigMenu() end,
})
--PATH lua/wos/dynabase/core/cl_config_menu.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/dynabase/registers/vader_stance_register.lua:
return gluapack()()
--PATH lua/autorun/xeninui_load.lua:
XeninUI = XeninUI || {}
XeninUI.ORM = XeninUI.ORM || {}
XeninUI.Players = XeninUI.Players || {}

function XeninUI:CreateFont(name, size, weight, mergeTbl)
	local tbl = {
		font = "Montserrat Medium",

		size = size + 2,
		weight = weight or 500,
		extended = true
	}

	if mergeTbl then
		table.Merge(tbl, mergeTbl)
	end

	surface.CreateFont(name, tbl)
end

function XeninUI:IncludeClient(path)
	if CLIENT then
		include("xeninui/" .. path .. ".lua")
	end

	if SERVER then
		AddCSLuaFile("xeninui/" .. path .. ".lua")
	end
end

function XeninUI:IncludeServer(path)
	if SERVER then
		include("xeninui/" .. path .. ".lua")
	end
end

function XeninUI:IncludeShared(path)
	XeninUI:IncludeServer(path)
	XeninUI:IncludeClient(path)
end

XeninUI:IncludeShared("settings/settings")
hook.Run("XeninUI.PostLoadSettings")
XeninUI:IncludeShared("libs/loader")

XeninUI.Loader():setName("Xenin Framework"):setAcronym("Xenin"):setDirectory("xeninui"):setColor(XeninUI.Theme.Red):load("libs", XENINUI_CLIENT, false, {
	ignoreFiles = {
	loader = true
	},
	overwriteRealm = {
		essentials_sh = XENINUI_SHARED,
		v0n_sh = XENINUI_SHARED,
		promises = XENINUI_SHARED,
		permissions = XENINUI_SHARED
	}
}):load("libs/network", XENINUI_SHARED):loadFile("server/orm/table_constraint", XENINUI_SERVER):load("server", XENINUI_SERVER, true):load("libs/languages", XENINUI_SHARED):load("libs/languages/network", {
	client = XENINUI_CLIENT,
	server = XENINUI_SERVER
}):load("libs/scripts", XENINUI_SHARED):load("libs/scripts/network", {
	client = XENINUI_CLIENT,
	server = XENINUI_SERVER
}):load("libs/configurator", XENINUI_SHARED):load("libs/configurator/classes", XENINUI_SHARED, false, {
overwriteRealm = {
database = XENINUI_SERVER
}
}):load("libs/configurator/network", {
	client = XENINUI_CLIENT,
	server = XENINUI_SERVER
}):load("libs/configurator/ui", XENINUI_CLIENT, true):load("libs/config", XENINUI_SHARED):load("libs/config/network", {
	client = XENINUI_CLIENT,
	server = XENINUI_SERVER
}):load("libs/players", XENINUI_SHARED, false, {
overwriteRealm = {
database = XENINUI_SERVER
}
}):load("libs/players/ui", XENINUI_CLIENT, true):load("libs/players/network", {
	shared = XENINUI_SHARED,
	client = XENINUI_CLIENT,
	server = XENINUI_SERVER
}):load("elements", XENINUI_CLIENT):load("core/ui", XENINUI_CLIENT):load("libs/units", XENINUI_SHARED, true):done()

XeninUI.Version = "2.1.0"

hook.Run("XeninUI.PreLoadAddons")
hook.Run("XeninUI.Loaded")
hook.Run("XeninUI.PostLoadAddons")

--PATH lua/xeninui/libs/animations.lua:
local PNL = FindMetaTable("Panel")

function PNL:LerpColor(var, to, duration, callback)
	if (!duration) then duration = XeninUI.TransitionTime end

	local color = self[var]
	local anim = self:NewAnimation(duration)
	anim.Color = to
	anim.Think = function(anim, pnl, fract)
		local newFract = XeninUI:Ease(fract, 0, 1, 1)

		if (!anim.StartColor) then
			anim.StartColor = color
		end

		local newColor = XeninUI:LerpColor(newFract, anim.StartColor, anim.Color)
		self[var] = newColor
	end
	anim.OnEnd = function()
		if callback then
			callback(self)
		end
	end
end

function PNL:LerpVector(var, to, duration, callback)
	if (!duration) then duration = XeninUI.TransitionTime end

	local vector = self[var]
	local anim = self:NewAnimation(duration)
	anim.Vector = to
	anim.Think = function(anim, pnl, fract)
		local newFract = XeninUI:Ease(fract, 0, 1, 1)

		if (!anim.StartVector) then
			anim.StartVector = vector
		end

		local newColor = XeninUI:LerpVector(newFract, anim.StartVector, anim.Vector)
		self[var] = newColor
	end
	anim.OnEnd = function()
		if callback then
			callback(self)
		end
	end
end

function PNL:LerpAngle(var, to, duration, callback)
	if (!duration) then duration = XeninUI.TransitionTime end

	local angle = self[var]
	local anim = self:NewAnimation(duration)
	anim.Angle = to
	anim.Think = function(anim, pnl, fract)
		local newFract = XeninUI:Ease(fract, 0, 1, 1)

		if (!anim.StartAngle) then
			anim.StartAngle = angle
		end

		local newColor = XeninUI:LerpAngle(newFract, anim.StartAngle, anim.Angle)
		self[var] = newColor
	end
	anim.OnEnd = function()
		if callback then
			callback(self)
		end
	end
end

function PNL:EndAnimations()
	for i, v in pairs(self.m_AnimList or {}) do
		if v.OnEnd then v:OnEnd(self)end
		self.m_AnimList[i] = nil
	end
end

function PNL:Lerp(var, to, duration, callback)
	if (!duration) then duration = XeninUI.TransitionTime end

	local varStart = self[var]
	local anim = self:NewAnimation(duration)
	anim.Goal = to
	anim.Think = function(anim, pnl, fract)
		local newFract = XeninUI:Ease(fract, 0, 1, 1)

		if (!anim.Start) then
			anim.Start = varStart
		end

		local new = Lerp(newFract, anim.Start, anim.Goal)
		self[var] = new
	end
	anim.OnEnd = function()
		if callback then
			callback(self)
		end
	end
end

function PNL:LerpMove(x, y, duration, callback)
	if (!duration) then duration = XeninUI.TransitionTime end

	local anim = self:NewAnimation(duration)
	anim.Pos = Vector(x, y)
	anim.Think = function(anim, pnl, fract)
		local newFract = XeninUI:Ease(fract, 0, 1, 1)

		if (!anim.StartPos) then
			anim.StartPos = Vector(pnl.x, pnl.y, 0)
		end

		local new = LerpVector(newFract, anim.StartPos, anim.Pos)
		self:SetPos(new.x, new.y)
	end
	anim.OnEnd = function()
		if callback then
			callback(self)
		end
	end
end

function PNL:LerpMoveY(y, duration, callback)
	if (!duration) then duration = XeninUI.TransitionTime end

	local anim = self:NewAnimation(duration)
	anim.Pos = y
	anim.Think = function(anim, pnl, fract)
		local newFract = XeninUI:Ease(fract, 0, 1, 1)

		if (!anim.StartPos) then
			anim.StartPos = pnl.y
		end

		local new = Lerp(newFract, anim.StartPos, anim.Pos)
		self:SetPos(pnl.x, new)
	end
	anim.OnEnd = function()
		if callback then
			callback(self)
		end
	end
end

function PNL:LerpMoveX(x, duration, callback)
	if (!duration) then duration = XeninUI.TransitionTime end

	local anim = self:NewAnimation(duration)
	anim.Pos = x
	anim.Think = function(anim, pnl, fract)
		local newFract = XeninUI:Ease(fract, 0, 1, 1)

		if (!anim.StartPos) then
			anim.StartPos = pnl.x
		end

		local new = Lerp(newFract, anim.StartPos, anim.Pos)
		self:SetPos(new, pnl.y)
	end
	anim.OnEnd = function()
		if callback then
			callback(self)
		end
	end
end

function PNL:LerpHeight(height, duration, callback, easeFunc)
	if (!duration) then duration = XeninUI.TransitionTime end
	if (!easeFunc) then easeFunc = function(a, b, c, d)
			return XeninUI:Ease(a, b, c, d)end end

	local anim = self:NewAnimation(duration)
	anim.Height = height
	anim.Think = function(anim, pnl, fract)
		local newFract = easeFunc(fract, 0, 1, 1)

		if (!anim.StartHeight) then
			anim.StartHeight = pnl:GetTall()
		end

		local new = Lerp(newFract, anim.StartHeight, anim.Height)
		self:SetTall(new)
	end
	anim.OnEnd = function()
		if callback then
			callback(self)
		end
	end
end

function PNL:LerpWidth(width, duration, callback, easeFunc)
	if (!duration) then duration = XeninUI.TransitionTime end
	if (!easeFunc) then easeFunc = function(a, b, c, d)
			return XeninUI:Ease(a, b, c, d)end end

	local anim = self:NewAnimation(duration)
	anim.Width = width
	anim.Think = function(anim, pnl, fract)
		local newFract = easeFunc(fract, 0, 1, 1)

		if (!anim.StartWidth) then
			anim.StartWidth = pnl:GetWide()
		end

		local new = Lerp(newFract, anim.StartWidth, anim.Width)
		self:SetWide(new)
	end
	anim.OnEnd = function()
		if callback then
			callback(self)
		end
	end
end

function PNL:LerpSize(w, h, duration, callback)
	if (!duration) then duration = XeninUI.TransitionTime end

	local anim = self:NewAnimation(duration)
	anim.Size = Vector(w, h)
	anim.Think = function(anim, pnl, fract)
		local newFract = XeninUI:Ease(fract, 0, 1, 1)

		if (!anim.StartSize) then
			anim.StartSize = Vector(pnl:GetWide(), pnl:GetWide(), 0)
		end

		local new = LerpVector(newFract, anim.StartSize, anim.Size)
		self:SetSize(new.x, new.y)
	end
	anim.OnEnd = function()
		if callback then
			callback()
		end
	end
end

--PATH lua/xeninui/libs/debug.lua:
return gluapack()()
--PATH lua/xeninui/libs/shadows.lua:
local scrW, scrH = ScrW(), ScrH()

local function Load()
	BSHADOWS = {}

	local resStr = scrW .. "" .. scrH

	BSHADOWS.RenderTarget = GetRenderTarget("bshadows_original_" .. resStr, scrW, scrH)


	BSHADOWS.RenderTarget2 = GetRenderTarget("bshadows_shadow_" .. resStr, scrW, scrH)


	BSHADOWS.ShadowMaterial = CreateMaterial("bshadows", "UnlitGeneric", {
		["$translucent"] = 1,
		["$vertexalpha"] = 1,
		["alpha"] = 1
	})



	BSHADOWS.ShadowMaterialGrayscale = CreateMaterial("bshadows_grayscale", "UnlitGeneric", {
		["$translucent"] = 1,
		["$vertexalpha"] = 1,
		["$alpha"] = 1,
		["$color"] = "0 0 0",
		["$color2"] = "0 0 0"
	})


	BSHADOWS.BeginShadow = function()


		render.PushRenderTarget(BSHADOWS.RenderTarget)


		render.OverrideAlphaWriteEnable(true, true)
		render.Clear(0, 0, 0, 0)
		render.OverrideAlphaWriteEnable(false, false)


		cam.Start2D()


	end


	BSHADOWS.EndShadow = function(intensity, spread, blur, opacity, direction, distance, _shadowOnly)


		opacity = opacity or 255
		direction = direction or 0
		distance = distance or 0
		_shadowOnly = _shadowOnly or false


		render.CopyRenderTargetToTexture(BSHADOWS.RenderTarget2)


		if blur > 0 then
			render.OverrideAlphaWriteEnable(true, true)
			render.BlurRenderTarget(BSHADOWS.RenderTarget2, spread, spread, blur)
			render.OverrideAlphaWriteEnable(false, false)
		end


		render.PopRenderTarget()


		BSHADOWS.ShadowMaterial:SetTexture('$basetexture', BSHADOWS.RenderTarget)


		BSHADOWS.ShadowMaterialGrayscale:SetTexture('$basetexture', BSHADOWS.RenderTarget2)


		local xOffset = math.sin(math.rad(direction)) * distance
		local yOffset = math.cos(math.rad(direction)) * distance


		BSHADOWS.ShadowMaterialGrayscale:SetFloat("$alpha", opacity / 255)
		render.SetMaterial(BSHADOWS.ShadowMaterialGrayscale)
		for i = 1, math.ceil(intensity) do
			render.DrawScreenQuadEx(xOffset, yOffset, scrW, scrH)
		end

		if not _shadowOnly then

			BSHADOWS.ShadowMaterial:SetTexture('$basetexture', BSHADOWS.RenderTarget)
			render.SetMaterial(BSHADOWS.ShadowMaterial)
			render.DrawScreenQuad()
		end

		cam.End2D()
	end


	BSHADOWS.DrawShadowTexture = function(texture, intensity, spread, blur, opacity, direction, distance, shadowOnly)


		opacity = opacity or 255
		direction = direction or 0
		distance = distance or 0
		shadowOnly = shadowOnly or false


		render.CopyTexture(texture, BSHADOWS.RenderTarget2)


		if blur > 0 then
			render.PushRenderTarget(BSHADOWS.RenderTarget2)
			render.OverrideAlphaWriteEnable(true, true)
			render.BlurRenderTarget(BSHADOWS.RenderTarget2, spread, spread, blur)
			render.OverrideAlphaWriteEnable(false, false)
			render.PopRenderTarget()
		end


		BSHADOWS.ShadowMaterialGrayscale:SetTexture('$basetexture', BSHADOWS.RenderTarget2)


		local xOffset = math.sin(math.rad(direction)) * distance
		local yOffset = math.cos(math.rad(direction)) * distance


		BSHADOWS.ShadowMaterialGrayscale:SetFloat("$alpha", opacity / 255)
		render.SetMaterial(BSHADOWS.ShadowMaterialGrayscale)
		for i = 1, math.ceil(intensity) do
			render.DrawScreenQuadEx(xOffset, yOffset, scrW, scrH)
		end
		if not shadowOnly then

			BSHADOWS.ShadowMaterial:SetTexture('$basetexture', texture)
			render.SetMaterial(BSHADOWS.ShadowMaterial)
			render.DrawScreenQuad()
		end
	end
end

Load()

timer.Create("XeninUI.BShadows.ResolutionCheck", 1, 0, function()
	if (ScrW() != scrW or ScrH() != scrH) then
		scrW = ScrW()
		scrH = ScrH()

		Load()
	end
end)

--PATH lua/xeninui/libs/languages/core.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/network/client.lua:
local Network
do
  local _class_0
  local _parent_0 = XeninUI.Network
  local _base_0 = {
    __name = "Network",
    __base = XeninUI.Network.__base,
    receiveSettings = function(self, ply)
      local script = net.ReadString()
      local size = net.ReadUInt(12)
      XeninUI.Configurator:PrintMessage("Received settings for the addon '" .. tostring(script) .. "', size: " .. tostring(size))
      local controller = XeninUI.Configurator:FindControllerByScriptName(script)
      for i = 1, size do
        local id = net.ReadString()
        local val = self:read()

        controller:set(id, val)
      end
    end,
    sendSaveSettings = function(self, script, tbl)
      local __laux_type = (istable(script) and script.__type and script:__type()) or type(script)
      assert(__laux_type == "string", "Expected parameter `script` to be type `string` instead of `" .. __laux_type .. "`")
      local __laux_type = (istable(tbl) and tbl.__type and tbl:__type()) or type(tbl)
      assert(__laux_type == "table", "Expected parameter `tbl` to be type `table` instead of `" .. __laux_type .. "`")
      self:send("SaveSettings", function(self)
        local size = table.Count(tbl)
        net.WriteString(script)
        net.WriteUInt(size, 12)
        for i, v in pairs(tbl) do
          net.WriteString(i)
          self:write(v)
        end
      end)
    end,
    sendSaveSetting = function(self, script, id, val)
      local __laux_type = (istable(script) and script.__type and script:__type()) or type(script)
      assert(__laux_type == "string", "Expected parameter `script` to be type `string` instead of `" .. __laux_type .. "`")
      local __laux_type = (istable(id) and id.__type and id:__type()) or type(id)
      assert(__laux_type == "string", "Expected parameter `id` to be type `string` instead of `" .. __laux_type .. "`")
      self:send("SaveSetting", function(self)
        net.WriteString(script)
        net.WriteString(id)
        self:write(val)
      end)
    end,
    sendGetEntities = function(self, entity, limit, offset, search)
      if limit == nil then limit = 10
      end
      if offset == nil then offset = 0
      end
      if search == nil then search = ""
      end
      local __laux_type = (istable(entity) and entity.__type and entity:__type()) or type(entity)
      assert(__laux_type == "XeninUI.Configurator.Entity", "Expected parameter `entity` to be type `XeninUI.Configurator.Entity` instead of `" .. __laux_type .. "`")
      local ent = entity:getDatabaseEntity()

      self:send("GetEntities", function(self)
        net.WriteString(ent)
        net.WriteUInt(limit, 16)
        net.WriteUInt(offset, 16)
        net.WriteString(search)
      end)
    end,
    sendSaveEntity = function(self, entity)
      self:send("SaveEntity", function(self)
        net.WriteString(entity:getDatabaseEntity())
        entity:onNetworkSend()
      end)
    end,
    sendCreateEntity = function(self, entity)
      self:send("CreateEntity", function(self)
        net.WriteString(entity:getDatabaseEntity())
        entity:onNetworkSend()
      end)
    end,
    sendDeleteEntity = function(self, entity)
      self:send("DeleteEntity", function(self)
        net.WriteString(entity:getDatabaseEntity())
        entity:onNetworkSend()
      end)
    end,
    receiveCreateEntity = function(self, entity)
      local entity = net.ReadString()
      local ent = XeninUI.Configurator.Entities:create(entity)
      ent:onNetworkReceive()
      ent:save()

      hook.Run("XeninUI.Configurator.CreatedEntity", ent)
    end,
    receiveEntity = function(self, ply)
      local entity = net.ReadString()
      local ent = XeninUI.Configurator.Entities:create(entity)
      ent:onNetworkReceive()
      ent:save()
    end,
    receiveGetEntities = function(self, ply)
      local size = net.ReadUInt(16)
      local tbl = {}
      for i = 1, size do
        local entity = net.ReadString()
        local ent = XeninUI.Configurator.Entities:create(entity)
        ent:onNetworkReceive()

        table.insert(tbl, ent)
      end

      hook.Run("XeninUI.Configurator.GetEntities", tbl)
    end,
    __type = function(self)
      return "XeninUI.Configurator.Network"end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__index)
  _class_0 = setmetatable({
    __init = function(self)
      Network.__parent.__init(self)

      self:setPrefix("XeninUI.Configuator.")

      self:receiver("Settings", self.receiveSettings)
      self:receiver("Entity", self.receiveEntity)
      self:receiver("GetEntities", self.receiveGetEntities)
      self:receiver("CreateEntity", self.receiveCreateEntity)
    end,
    __base = _base_0,
    __parent = _parent_0
  }, {
    __index = function(cls, parent)
      local val = rawget(_base_0, parent)
      if val == nil then local _parent = rawget(cls, "__parent")
        if _parent then return _parent[parent]
        end
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0)
  end
  Network = _class_0
end

XeninUI.Configurator.Network = Network()

--PATH lua/xeninui/libs/configurator/ui/settings.lua:
local PANEL = {}

XeninUI:CreateFont("Xenin.Configurator.Admin.Panel.Title", 40)
XeninUI:CreateFont("Xenin.Configurator.Admin.Panel.Navbar", 24)
XeninUI:CreateFont("Xenin.Configurator.Admin.Panel.Setting", 18)
XeninUI:CreateFont("Xenin.Configurator.Admin.Panel.Setting.Italic", 18, nil, {
italic = true
})
XeninUI:CreateFont("Xenin.Configurator.Admin.Panel.Category", 22)
XeninUI:CreateFont("Xenin.Configurator.Admin.Panel.Selectbox", 18)
XeninUI:CreateFont("Xenin.Configurator.Admin.Panel.Save", 24)

AccessorFunc(PANEL, "m_networkId", "NetworkId")

function PANEL:OnSearch() end

function PANEL:Init()
  self.Categories = {}
  self.Settings = {}

  self:DockPadding(16, 16, 16, 16)

  self:SetNetworkId("settings")

  self.Navbar = self:Add("XeninUI.Navbar")
  self.Navbar:Dock(TOP)
  self.Navbar.accent = XeninUI.Theme.Purple
  self.Navbar.textActive = color_white
  self.Navbar.font = "Xenin.Configurator.Admin.Panel.Navbar"
  self.Navbar.padding = 40
  self.Navbar.startHeight = 50
  self.Navbar.dockLeft = 0
  self.Navbar.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBoxEx(6, 0, 0, w, h, XeninUI.Theme.Primary, true, true, false, false)
  end
  self.Navbar:SetBody(self)

  self.Bottom = self:Add("Panel")
  self.Bottom:Dock(BOTTOM)
  self.Bottom:DockMargin(0, 16, 0, 0)
  self.Bottom:SetTall(32)

  self.Save = self.Bottom:Add("XeninUI.ButtonV2")
  self.Save:Dock(RIGHT)
  self.Save:SetText("Save")
  self.Save:SetFont("Xenin.Configurator.Admin.Panel.Save")
  self.Save:SetRoundness(6)
  self.Save:SetSolidColor(XeninUI.Theme.Accent)
  self.Save:SetHoverColor(XeninUI.Theme.Green)
  self.Save:SetTextColor(color_white)
  self.Save:SizeToContentsX(24)
  self.Save.DoClick = function(pnl)
    local id = self:GetNetworkId()
    local settings = {}
    for tabName, tab in pairs(self.Navbar.panels) do
      for i, v in ipairs(tab.Settings) do
        if (!v:IsVisible()) then continue end

        local id = v.Data.id
        local val = v.Input:GetSettingValue()

        self.ctr:set(id, val)
        settings[id] = val
      end
    end

    XeninUI.Configurator.Network:sendSaveSettings(self.script, settings)
  end
  XeninUI:AddRippleClickEffect(self.Save, color_black)
end

function PANEL:PerformLayout(w, h)
  self.Navbar:SetTall(self.Navbar.startHeight)
end

function PANEL:SetTitle(title) end

function PANEL:CreateCategory(name)
  local panel = self.Body:Add("DPanel")
  panel:Dock(TOP)
  panel:DockPadding(0, 36, 0, 40)
  panel.Name = name
  panel.Paint = function(pnl, w, h)

    draw.SimpleText(pnl.Name, "Xenin.Configurator.Admin.Panel.Category", 8, 32 / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end
  panel.PerformLayout = function(pnl, w, h)
    pnl:SizeToChildren(false, true)
  end

  return panel
end

function PANEL:GetCategories()
  return self.Categories
end

function PANEL:GetCategory(cat)
  return self.Categories[cat]
end

function PANEL:SetController(ctr)
  local tabs = self.ctr:getSettingTabs()
  local settings = self.ctr:getSettingsByCategory()
  for i, v in ipairs(tabs) do
    self.Navbar:AddTab(v.name, "Xenin.Configurator.Admin.Panel.Setting", settings[v.name])
  end
  if tabs[1] then
    self.Navbar:SetActive(tabs[1].name)
  end
end

function PANEL:SetSettings(tbl)
  self.settings = tbl

  for i, v in ipairs(tbl) do
    self:AddSetting(v)
  end
end

function PANEL:SetScript(script)
  self.script = script
  self.ctr = XeninUI.Configurator:FindControllerByScriptName(script)
end

function PANEL:SetData(data)
  self:SetTitle(data.name)
  self:SetController(self.ctr)
end

vgui.Register("Xenin.Configurator.Admin.Panel", PANEL, "XeninUI.Panel")


local PANEL = {}

function PANEL:Init()
  self.Categories = {}
  self.Settings = {}

  self.Top = self:Add("Panel")
  self.Top:Dock(TOP)
  self.Top.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBoxEx(6, 0, 0, w, h, XeninUI.Theme.Navbar, false, false, true, true)
  end

  self.Navbar = self.Top:Add("DPanel")
  self.Navbar:Dock(FILL)
  self.Navbar.Paint = function() end
  self.Navbar.SetActive = function(pnl, id)
    local active = pnl.Active
    pnl.Active = id

    local btn = pnl.Buttons[active]
    if IsValid(btn) then
      btn:LerpColor("TextColor", Color(145, 145, 145))
    end

    btn = pnl.Buttons[id]
    if (!IsValid(btn)) then return end

    if active then
      btn:LerpColor("TextColor", color_white)
      local cat = self:GetCategory(btn:GetText())
      if ispanel(cat) then
        self.Scroll:ScrollToChild(cat)
      end
    else
      btn.TextColor = color_white
    end
  end
  self.Navbar.Buttons = {}
  self.Navbar.AddButton = function(pnl, name)
    local btn = pnl:Add("DButton")
    btn:Dock(LEFT)
    btn:SetText(name)
    btn:SetFont("Xenin.Configurator.Admin.Panel.Setting.Navbar")
    btn:SizeToContentsX(24)
    btn:SizeToContentsY()
    btn.TextColor = Color(145, 145, 145)
    btn.Paint = function(pnl, w, h)
      pnl:SetTextColor(pnl.TextColor)
    end
    btn.OnCursorEntered = function(pnl)
      pnl:LerpColor("TextColor", color_white)
    end
    btn.OnCursorExited = function()
      if (pnl.Active == btn.Id) then return end

      btn:LerpColor("TextColor", Color(145, 145, 145))
    end
    btn.DoClick = function()
      pnl:SetActive(btn.Id)
    end

    local id = table.insert(pnl.Buttons, btn)
    pnl.Buttons[id].Id = id
  end
  self.Navbar.SetActiveButtonByName = function(pnl, name)
    for i, v in ipairs(pnl.Buttons) do
      if (v:GetText() != name) then continue end

      v:LerpColor("TextColor", color_white)
      pnl:SetActive(v.Id)
    end
  end

  self.Scroll = self:Add("XeninUI.Scrollpanel.Wyvern")
  self.Scroll:Dock(FILL)
  self.Scroll:DockMargin(0, 16, 0, 0)

  self.Body = self.Scroll:Add("Panel")

  self:SetActive(1)
end

function PANEL:SetData(data)
  if (!istable(data)) then return end

  self.settings = data
  for i, v in ipairs(data) do
    self:AddSetting(v)
  end
  self:SetActive(1)
end

function PANEL:CreateCategory(name)
  local panel = self.Body:Add("DPanel")
  panel:Dock(TOP)
  panel:DockPadding(0, 28, 0, 20)
  panel.Name = name
  panel.Paint = function(pnl, w, h)

    draw.SimpleText(pnl.Name, "Xenin.Configurator.Admin.Panel.Category", 8, 32 / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end
  panel.PerformLayout = function(pnl, w, h)
    pnl:SizeToChildren(false, true)
  end

  return panel
end

function PANEL:GetCategory(cat)
  return self.Categories[cat]
end

function PANEL:HighlightSetting(cat, id)
  for catId, catPnl in pairs(self.Categories) do
    if (catId != cat) then continue end

    for i, v in ipairs(catPnl:GetChildren()) do
      if (v.Data.id != id) then continue end

      v:Highlight()

      return v, i
    end
  end
end

function PANEL:AddSetting(tbl)
  if (!self.Categories[tbl.subCategory]) then
    local foundCat
    for i, v in pairs(self.Navbar.Buttons) do
      if (v:GetText() != tbl.subCategory) then continue end

      foundCat = true
      break
    end
    if (!foundCat) then
      self:AddButton(tbl.subCategory)
    end
    self.Categories[tbl.subCategory] = self:CreateCategory(tbl.subCategory)
  end

  local input = XeninUI.Configurator:CreateInputPanel(tbl.type, self, tbl)
  if input.SetData then
    input:SetData(tbl.data)
  end
  if input.SetInput then
    input:SetInput(tbl.value)
  end

  local panel = self.Categories[tbl.subCategory]:Add("DPanel")
  input:SetParent(panel)
  panel:Dock(TOP)
  panel.Data = tbl
  panel.Height = input.Height or 48
  panel:SetTall(input.Height or 48)
  panel.Input = input
  panel.Markup = markup.Parse("<font=Xenin.Configurator.Admin.Panel.Setting><color=145,145,145>" .. tostring(tbl.name) .. "</color></font>")
  panel.Paint = function(pnl, w, h)
    local x = 0
    if tbl.onPaint then x = x + tbl.onPaint(pnl, w, h)
    end
    surface.SetDrawColor(100, 100, 100)
    surface.DrawRect(0, h - 1, w, 1)

    pnl.Markup:Draw(x + 8, 48 / 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end
  panel.FlashAlpha = 0
  panel.PaintOver = function(pnl, w, h)
    local alpha = pnl.FlashAlpha
    if (alpha <= 1) then return end

    surface.SetDrawColor(ColorAlpha(XeninUI.Theme.Green, alpha / (255 / 50)))
    surface.DrawRect(0, 0, w, h)

    XeninUI:MaskInverse(function()
      surface.DrawRect(1, 1, w - 2, h - 2)
    end, function()
      surface.SetDrawColor(ColorAlpha(XeninUI.Theme.Green, alpha))
      surface.DrawRect(0, 0, w, h)
    end)
  end
  panel.Highlight = function(pnl)
    pnl:EndAnimations()

    pnl:Lerp("FlashAlpha", 255, 0.7, function()
      timer.Simple(0.2, function()
        if (!IsValid(pnl)) then return end

        pnl:Lerp("FlashAlpha", 0, 0.5)
      end)
    end)
  end

  if tbl.func then
    tbl.func(input, panel)
  end
  if (tbl.onChange or tbl.data.onChange) then
    input.onChange = tbl.onChange or tbl.data.onChange
  end
  if tbl.data.postInit then
    tbl.data.postInit(input, panel)
  end
  if tbl.data.hidden then
    panel:SetVisible(false)
  end
  panel.PerformLayout = function(pnl, w, h)
    local l, t, r, b = pnl.Input:GetDockMargin()
    pnl.Input:SetTall(h - t - b)
    pnl.Input:SetPos(w - l - pnl.Input:GetWide() - r, t)
  end

  table.insert(self.Settings, panel)
end

function PANEL:SetActive(id)
  self.Navbar:SetActive(id)
end

function PANEL:AddButton(name)
  self.Navbar:AddButton(name)
end

function PANEL:PerformLayout(w, h)
  self.Top:SetTall(38)

  if IsValid(self.Body) then
    self.Body:SetWide(math.min(600, w - 56))
    self.Body:SizeToContentsY()
    self.Body:Center()
    self.Body:SizeToChildren(false, true)
  end

  for i, v in ipairs(self.Settings) do
    v:SetTall(v.Height or 48)
  end
end

XeninUI:CreateFont("Xenin.Configurator.Admin.Panel.Setting.Navbar", 18)

vgui.Register("Xenin.Configurator.Admin.Panel.Setting", PANEL, "XeninUI.Panel")

--PATH lua/xeninui/libs/configurator/ui/sidebar.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/top.lua:
local PANEL = {}

XeninUI:CreateFont("Xenin.Configurator.Admin.Title", 26)
XeninUI:CreateFont("Xenin.Configurator.Admin.Subtitle", 14)

function PANEL:Init()
	self.CloseBtn = self:Add("DButton")
	self.CloseBtn:Dock(RIGHT)
	self.CloseBtn:SetText("")
	self.CloseBtn.CloseButton = Color(100, 100, 100)
	self.CloseBtn.Alpha = 0
	self.CloseBtn.DoClick = function(pnl)
		self:GetParent():Remove()
	end
	self.CloseBtn.Paint = function(pnl, w, h)
		draw.RoundedBox(h / 2, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Red, pnl.Alpha))

		surface.SetDrawColor(pnl.CloseButton)
		surface.SetMaterial(XeninUI.Materials.CloseButton)
		surface.DrawTexturedRect(12, 12, w - 24, h - 24)
	end
	self.CloseBtn.OnCursorEntered = function(pnl)
		pnl:Lerp("Alpha", 255)
		pnl:LerpColor("CloseButton", Color(255, 255, 255))
	end
	self.CloseBtn.OnCursorExited = function(pnl)
		pnl:Lerp("Alpha", 0)
		pnl:LerpColor("CloseButton", Color(100, 100, 100))
	end

	self.Name = self:Add("DPanel")
	self.Name:Dock(LEFT)
	self.Name.Paint = function(pnl, w, h)
		local text = self.Text
		if isstring(text) then
			XeninUI:DrawShadowText(text, "Xenin.Configurator.Admin.Title", 0, h / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 2, 150)
		elseif istable(text) then
			XeninUI:DualText({
				text[1],
				"Xenin.Configurator.Admin.Title",
				color_white,
				TEXT_ALIGN_LEFT,
				2,
				150
			}, {
				text[2],
				"Xenin.Configurator.Admin.Subtitle",
				Color(145, 145, 145),
				TEXT_ALIGN_LEFT,
				0,
				0
			}, 0, -2, w, h)
		end
	end

	self.Search = self:Add("Xenin.Configurator.Admin.SearchBar")
	self.Search:Dock(FILL)
	self.Search:DockMargin(36, 0, 250, 0)
	self.Search:SetPlaceholder("Search for anything")
	self.Search:SetIcon(XeninUI.Materials.Search, true)
end

function PANEL:SetText(text)
	self.Text = text
end

function PANEL:PerformLayout(w, h)
	self.CloseBtn:SetWide(h)

	local text = self.Text
	local nW
	if istable(text) then
		surface.SetFont("Xenin.Configurator.Admin.Title")
		local tW = surface.GetTextSize(text[1])
		surface.SetFont("Xenin.Configurator.Admin.Subtitle")
		local sW = surface.GetTextSize(text[2])
		nW = math.max(tW, sW)
	else
		surface.SetFont("Xenin.Configurator.Admin.Title")
		local tW = surface.GetTextSize(text)
		nW = math.max(tW, 170)
	end

	self.Name:SetWide(nW)
end

function PANEL:SetScript(script, ctr)
	self.script = script
	self.ctr = ctr

	self.Search:SetScript(script, ctr)
end

vgui.Register("Xenin.Configurator.Admin.Top", PANEL)

--PATH lua/xeninui/libs/configurator/ui/entities/entity_list_row.lua:
local PANEL = {}

function PANEL:OnDelete() end
function PANEL:DoClick() end

function PANEL:SetEntity(entity, template, isList)
  local __lauxi0 = template.getListView(entity, isList)
  assert(__lauxi0 ~= nil, "cannot destructure nil value")
  local display, title, subtitle = __lauxi0.display, __lauxi0.title, __lauxi0.subtitle

  self.Entity = entity
  self.Title = markup.Parse("<font=Xenin.Configurator.Row.Title><color=255,255,255>" .. tostring(title) .. "</color></font>")
  self.Subtitle = markup.Parse("<font=Xenin.Configurator.Row.Subtitle><color=174,174,174>" .. tostring(subtitle) .. "</color></font>")
  self:SetDisplay(display)
end

function PANEL:Init()
  self.Edit = self:Add("XeninUI.ButtonV2")
  self.Edit:SetText("Edit")
  self.Edit:SetFont("Xenin.Configurator.Row.Title")
  self.Edit:SetSolidColor(XeninUI.Theme.GreenDark)
  self.Edit:SetRoundness(6)
  self.Edit.DoClick = function(pnl)
    self:DoClick()
  end

  self.Delete = self:Add("XeninUI.ButtonV2")
  self.Delete:SetVisible(false)
  self.Delete:SetText("")
  self.Delete:SetSolidColor(XeninUI.Theme.Red)
  self.Delete:SetRoundness(6)
  self.Delete.DoClick = function(pnl)
    self:OnDelete()
  end
  self.Delete.PaintOver = function(pnl, w, h)
    local size = h / 2
    surface.SetMaterial(XeninUI.Materials.CloseButton)
    surface.SetDrawColor(color_white)
    surface.DrawTexturedRect(w / 2 - size / 2 + 1, h / 2 - size / 2, size, size)
  end
end

function PANEL:Think()
  if (self.DeleteDisabled) then return end

  self.Delete:SetVisible(self:IsHovered() or self:IsChildHovered())
end

function PANEL:SetDisplay(display)
  if (!display) then return end
  if (IsValid(self.Display)) then return end

  self.Display = self:Add("SpawnIcon")
  self.Display:Dock(LEFT)
  self.Display:SetWide(56)
  self.Display.Model = display
  self.Display:SetMouseInputEnabled(false)


  timer.Simple(0, function()
    self.Display:SetModel(self.Display.Model)
  end)
end

function PANEL:Paint(w, h)
  XeninUI:DrawRoundedBox(6, 0, 0, w, h, XeninUI.Theme.Navbar)

  local x = h + 4

  self.Title:Draw(x, h / 2 + 1, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
  self.Subtitle:Draw(x, h / 2 + 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
end

function PANEL:PerformLayout(w, h)
  self.Edit:SizeToContentsX(24)
  self.Edit:SizeToContentsY(8)
  self.Edit:AlignRight(12)
  self.Edit:CenterVertical()

  self.Delete:SetSize(self.Edit:GetTall(), self.Edit:GetTall())
  self.Delete:AlignRight(w - self.Edit.x + 12)
  self.Delete:CenterVertical()
end

vgui.Register("Xenin.Configurator.Admin.EntityList.Row", PANEL)

--PATH lua/xeninui/libs/configurator/ui/inputs/selectbox.lua:
local x

--PATH lua/xeninui/libs/players/ui/notifications/hud.lua:
return gluapack()()
--PATH lua/xeninui/libs/players/ui/notifications/row.lua:
return gluapack()()
--PATH lua/xeninui/elements/breadcrumbs.lua:
local PANEL = {}

XeninUI:CreateFont("XeninUI.Breadcrumbs", 22)

local matArrow = Material("xenin/next.png", "smooth")

function PANEL:Init()
  self.Buttons = {}
end

function PANEL:SetBreadcrumbs(tbl)
  self.Location = tbl
  for i, v in ipairs(self.Buttons) do
    v:Remove()
    self.Buttons[i] = nil
  end

  for i, v in ipairs(tbl) do
    self:CreateBreadcrumb(v, i)
  end

  self:InvalidateLayout(true)
end

function PANEL:CreateBreadcrumb(data, index)
  local size = #self.Location
  local isLast = size == index
  local name = istable(data) and data.name or data
  local onClick = istable(data) and data.onClick or function()
    return true end

  local btn = self:Add("DButton")
  btn:Dock(LEFT)
  btn:DockMargin(0, 0, 16, 0)
  btn:SetText(name)
  btn:SetExpensiveShadow(1)
  btn:SetFont("XeninUI.Breadcrumbs")
  btn:SizeToContentsX(10)
  btn.TextColor = isLast and XeninUI.Theme.Accent or Color(185, 185, 185)
  btn.IsActive = isLast
  btn.Alpha = 0
  btn.Paint = function(pnl, w, h)
    pnl:SetTextColor(pnl.TextColor)

    if (pnl.Alpha > 0) then
      XeninUI:DrawRoundedBox(6, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Accent, pnl.Alpha))
    end
  end
  btn.OnCursorEntered = function(pnl)
    pnl:LerpColor("TextColor", color_white)
    pnl:Lerp("Alpha", 255)
  end
  btn.OnCursorExited = function(pnl)
    pnl:LerpColor("TextColor", pnl.IsActive and XeninUI.Theme.Accent or Color(185, 185, 185))
    pnl:Lerp("Alpha", 0)
  end
  btn.DoClick = function(pnl)
    local close = onClick(pnl.IsActive, pnl)

    if close then
      self:RemoveTo(pnl:GetText())
    end
  end

  table.insert(self.Buttons, btn)

  self:CorrectColors()
end

function PANEL:CorrectColors()
  local size = #self.Buttons
  for i, v in ipairs(self.Buttons) do
    local isHovered = v:IsHovered()
    local isActive = i == size
    if (isHovered and isActive) then continue end

    v.IsActive = i == size
    v.TextColor = i == size and XeninUI.Theme.Accent or Color(185, 185, 185)
  end
end

function PANEL:AddBreadcrumb(name, onClick)
  local breadcrumb = onClick and {
    name = name,
    onClick = onClick
  } or name
  local id = table.insert(self.Location, breadcrumb)

  self:CreateBreadcrumb(breadcrumb, id)
  self:InvalidateLayout()
end

function PANEL:RemoveTo(removeToName)
  for i = #self.Location, 1, -1 do
    local breadcrumb = self.Location[i]
    local name = istable(breadcrumb) and breadcrumb.name or breadcrumb

    if (name == removeToName) then
      self.Buttons[i].IsActive = true

      break
    end

    table.remove(self.Location, i)
    if IsValid(self.Buttons[i]) then
      self.Buttons[i]:Remove()
      self.Buttons[i] = nil
    end
  end

  self:CorrectColors()
  self:InvalidateLayout()
end

function PANEL:PerformLayout(w, h)
  self:SizeToContentsX()
end

function PANEL:Paint(w, h)
  local x = 0
  local size = #self.Buttons
  for i, v in ipairs(self.Buttons) do
    if (i == size) then continue end

    surface.SetFont(v:GetFont())
    local tw = surface.GetTextSize(v:GetText())
    x = x + tw + 10 + 16

    surface.SetDrawColor(i == (size - 1) and XeninUI.Theme.Accent or Color(185, 185, 185))
    surface.SetMaterial(matArrow)
    surface.DrawTexturedRect(x - 12, h / 2 - h / 5 + 2, h / 2.5, h / 2.5)
  end
end

function PANEL:SizeToContentsX()
  local w = 0

  surface.SetFont("XeninUI.Breadcrumbs")
  local size = #self.Buttons
  for i, v in ipairs(self.Buttons) do
    local tw = surface.GetTextSize(v:GetText())
    tw = tw + 10

    if (i != size) then
      tw = tw + 16
    end

    w = w + tw
  end

  self:SetWide(w)
end

vgui.Register("XeninUI.Breadcrumbs", PANEL)

--PATH lua/xeninui/elements/sidebar_v2.lua:
local PANEL = {}
AccessorFunc(PANEL, "m_body", "Body")

XeninUI:CreateFont("XeninUI.SidebarV2.Name", 20)
XeninUI:CreateFont("XeninUI.SidebarV2.Desc", 16)
XeninUI:CreateFont("XeninUI.SidebarV2.DescSmall", 14)

function PANEL:Init()
  self.Scroll = self:Add("XeninUI.ScrollPanel")
  self.Scroll:Dock(FILL)
  self.Scroll.VBar:SetWide(0)

  self.Sidebar = {}
  self.Panels = {}
end

function PANEL:CreateDivider(startCol, endCol)
  startCol = startCol or Color(164, 43, 115)
  endCol = endCol or Color(198, 66, 110)

  local divider = self.Scroll:Add("DPanel")
  divider:Dock(TOP)
  divider:SetTall(10)
  divider.Paint = function(pnl, w, h)
    local aX, aY = pnl:LocalToScreen()

    draw.SimpleLinearGradient(aX + 4, aY + 4, w - 8, h - 8, startCol, endCol, true)
  end
end

function PANEL:CreatePanel(name, desc, panelClass, icon, tbl)
  tbl = tbl or {}
  tbl.colors = tbl.colors or {}
  local startCol = tbl.colors[1] or Color(158, 53, 210)
  local endCol = tbl.colors[2] or Color(109, 77, 213)

  local btn = self.Scroll:Add("DButton")
  btn:Dock(TOP)
  btn.Name = name
  btn.Desc = desc or ""
  btn.Icon = icon
  btn.Tbl = tbl
  btn.PanelClass = panelClass
  btn:SetTall(tbl.Height or 64)
  btn:SetText("")
  btn.GradientAlpha = 0
  btn.SmallFont = btn.Desc:len() > 20
  btn.DescFont = !btn.SmallFont and "XeninUI.SidebarV2.Desc" or "XeninUI.SidebarV2.DescSmall"
  XeninUI:DownloadIcon(btn, icon)
  btn.Paint = function(pnl, w, h)
    XeninUI:Mask(function()
      XeninUI:DrawRoundedBox(0, 0, 0, w, h, color_white)
    end, function()
      local aX, aY = pnl:LocalToScreen()
      draw.SimpleLinearGradient(aX, aY, w, h, ColorAlpha(startCol, pnl.GradientAlpha), ColorAlpha(endCol, pnl.GradientAlpha), true)
    end)

    local x = icon and h or 12
    XeninUI:DrawIcon(16, 16, h - 32, h - 32, pnl)

    XeninUI:DrawShadowText(name, "XeninUI.SidebarV2.Name", x, h / 2 + (pnl.SmallFont and 1 or 0), color_white, TEXT_ALIGN_LEFT, desc and TEXT_ALIGN_BOTTOM or TEXT_ALIGN_CENTER, 1, 125)
    if desc then
      XeninUI:DrawShadowText(desc, pnl.DescFont, x, h / 2 + (pnl.SmallFont and 1 or 0), Color(171, 171, 171), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, 125)
    end
  end
  btn.OnCursorEntered = function(pnl)
    if (self.Active == btn.Id) then return end

    pnl:Lerp("GradientAlpha", 127.5)
  end
  btn.OnCursorExited = function(pnl)
    if (self.Active == btn.Id) then return end

    pnl:Lerp("GradientAlpha", 0)
  end
  btn.DoClick = function(pnl)
    self:SetActive(pnl.Id)
  end

  if (!IsValid(self:GetBody())) then
    Error("Failed to find body for panel " .. tostring(panelClass))
  end
  local body = self:GetBody():Add(panelClass or "DPanel")
  if (!IsValid(body)) then
    Error("Failed to create panel for " .. tostring(panelClass))
  end
  body:Dock(FILL)
  body.Data = tbl
  body:SetVisible(false)
  if body.SetData then
    body:SetData(tbl)
  end

  local bodyId = table.insert(self.Panels, body)
  self.Panels[bodyId].Id = bodyId

  local id = table.insert(self.Sidebar, btn)
  self.Sidebar[id].Id = id
end

function PANEL:SetActive(id)
  local active = self.Active
  self.Active = id

  if IsValid(self.Sidebar[active]) then
    self.Sidebar[active]:OnCursorExited()

    if IsValid(self.Panels[active]) then
      self.Panels[active]:SetVisible(false)
    end
  end

  if IsValid(self.Sidebar[id]) then
    self.Sidebar[id]:Lerp("GradientAlpha", 255)

    if IsValid(self.Panels[id]) then
      if (self.Panels[id].Data.recreateOnSwitch and id != active) then
        local tempData = self.Panels[id].Data
        local tempId = self.Panels[id].Id
        self.Panels[id]:Remove()

        self.Panels[id] = self:GetBody():Add(self.Sidebar[id].PanelClass or "DPanel")
        self.Panels[id]:Dock(FILL)
        self.Panels[id].Data = tempData
        self.Panels[id].Id = tempId
      else
        self.Panels[id]:SetVisible(true)
      end

      if self.Panels[id].OnSwitchedTo then
        self.Panels[id]:OnSwitchedTo(self.Panels[id].Data)
      end
    end
  end
end

function PANEL:SetActiveByName(name)
  for i, v in ipairs(self.Sidebar) do
    if (v.Name == name) then
      self:SetActive(i)

      break
    end
  end
end

function PANEL:Paint(w, h)
  XeninUI:DrawRoundedBoxEx(6, 0, 0, w, h, XeninUI.Theme.Primary, false, false, true, false)
end

vgui.Register("XeninUI.SidebarV2", PANEL)

--PATH lua/xeninui/elements/tooltip.lua:
surface.CreateFont("XeninUI.Tooltip", {
  font = "Montserrat",
  size = 18,
  weight = 500
})

local PanelMeta = FindMetaTable("Panel")

function PanelMeta:RemoveCooltip()
  if IsValid(self.Tooltip) then
    self.Tooltip:Hide()
  end

  self.EnableTooltip = false
end

function PanelMeta:SetCooltip(str, delay, offsetX, offsetY)
  self.EnableTooltip = true
  self.CursorEntered = 0
  self.ActivateTooltip = true
  self.TooltipStr = str
  self.TooltipDelay = delay or 0.2

  if self.Tooltip then
    self.Tooltip.Str = str

    surface.SetFont("XeninUI.Tooltip")
    local x, y = self:LocalToScreen(offsetX or 0, offsetY or 0)
    local width, height = surface.GetTextSize(self.TooltipStr)

    self.Tooltip:SetSize(width + 32, height + 24)
    self.Tooltip:SetPos(x + self:GetWide() / 2 - self.Tooltip:GetWide() / 2, y - self.Tooltip:GetTall() - 4)

    self.Tooltip:Show()
    return
  end

  local oldCursorEntered = self.OnCursorEntered
  self.OnCursorEntered = function(pnl)
    if oldCursorEntered then oldCursorEntered(pnl)end

    pnl.CursorEntered = CurTime() + pnl.TooltipDelay
  end

  local oldCursorExited = self.OnCursorExited
  self.OnCursorExited = function(pnl)
    if oldCursorExited then oldCursorExited(pnl)end

    pnl.CursorEntered = 0

    if IsValid(pnl.Tooltip) then
      pnl.Tooltip:Remove()
      pnl.Tooltip = nil
    end
  end

  local oldThink = self.Think
  self.Think = function(pnl)
    if oldThink then oldThink(pnl)end

    if (pnl.CursorEntered < CurTime() and !IsValid(pnl.Tooltip) and pnl:IsHovered() and pnl.EnableTooltip) then
      local x, y = pnl:LocalToScreen(offsetX or 0, offsetY or 0)
      local w = pnl:GetWide()

      surface.SetFont("XeninUI.Tooltip")
      local width, height = surface.GetTextSize(self.TooltipStr)

      pnl.Tooltip = vgui.Create("XeninUI.Tooltip")
      pnl.Tooltip:SetAlpha(0)
      pnl.Tooltip:SetDrawOnTop(true)
      pnl.Tooltip:SetSize(width + 32, height + 24)
      pnl.Tooltip:SetPos(x + self:GetWide() / 2 - pnl.Tooltip:GetWide() / 2, y - pnl.Tooltip:GetTall() - 4)
      pnl.Tooltip:AlphaTo(255, 0.15)
      pnl.Tooltip.Str = str
    end
  end

  local oldRemove = self.OnRemove
  self.OnRemove = function(pnl)
    if oldRemove then oldRemove(pnl)end

    if IsValid(pnl.Tooltip) then
      pnl.Tooltip:Remove()
    end
  end
end

function PanelMeta:SetCooltipString(str)
  self.TooltipStr = str
  if (!IsValid(self.Tooltip)) then return end
  self.Tooltip.Str = str

  local x, y = self:LocalToScreen(0, 0)
  local w = self:GetWide()

  surface.SetFont("XeninUI.Tooltip")
  local width, height = surface.GetTextSize(self.TooltipStr)

  self.Tooltip:SetSize(width + 32, height + 24)
  self.Tooltip:SetPos(x + self:GetWide() / 2 - self.Tooltip:GetWide() / 2, y - self.Tooltip:GetTall() - 4)
end

local PANEL = {}

function PANEL:Paint(w, h)
  local x, y = self:LocalToScreen(0, 0)

  BSHADOWS.BeginShadow()
  draw.RoundedBox(6, x, y, w, h - 8, color_white)
  draw.SimpleText(self.Str, "XeninUI.Tooltip", x + w / 2, y + (h - 8) / 2, Color(0, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
  BSHADOWS.EndShadow(2, 1, 1, 255, 0, 0)

  local tbl = {
    {
      x = w / 2 - 8,
      y = h - 8
    },
    {
      x = w / 2 + 8,
      y = h - 8
    },
    {
      x = w / 2,
      y = h
    },
    {
      x = w / 2 - 8,
      y = h - 8
    }
  }

  draw.NoTexture()
  surface.SetDrawColor(color_white)
  surface.DrawPoly(tbl)
end

vgui.Register("XeninUI.Tooltip", PANEL, "EditablePanel")

--PATH lua/autorun/yularen.lua:
return gluapack()()
--PATH lua/autorun/zyg_pitboss.lua:
return gluapack()()
--PATH lua/autorun/zyg_pitboss.lua:
player_manager.AddValidModel( "Zygerrian Empire Pit Boss", "models/player/zygerrian/zygerrian_pitboss.mdl" );
list.Set( "PlayerOptionsModel",  "Zygerrian Empire Pit Boss", "models/player/zygerrian/zygerrian_pitboss.mdl" );


--PATH lua/autorun/zyg_slave_lord_addon.lua:
player_manager.AddValidModel( "Zygerrian Empire Slaver Lord", "models/player/zygerrian/zygerrian_slave_lord.mdl" );
list.Set( "PlayerOptionsModel",  "Zygerrian Empire Slaver Lord", "models/player/zygerrian/zygerrian_slave_lord.mdl" );


--PATH lua/autorun/client/advdupe2_cl_init.lua:
AdvDupe2 = {
	Version = "1.1.0",
	Revision = 51,
	InfoText = {},
	DataFolder = "advdupe2",
	FileRenameTryLimit = 256,
	ProgressBar = {}
}

if(!file.Exists(AdvDupe2.DataFolder, "DATA"))then
	file.CreateDir(AdvDupe2.DataFolder)
end

include( "advdupe2/file_browser.lua" )
include( "advdupe2/sh_codec.lua" )
include( "advdupe2/cl_file.lua" )
include( "advdupe2/cl_ghost.lua" )

function AdvDupe2.Notify(msg,typ,dur)
	surface.PlaySound(typ == 1 and "buttons/button10.wav" or "ambient/water/drip1.wav")
	GAMEMODE:AddNotify(msg, typ or NOTIFY_GENERIC, dur or 5)
	//if not game.SinglePlayer() then
		print("[AdvDupe2Notify]\t"..msg)
	//end
end

net.Receive("AdvDupe2Notify", function()
	AdvDupe2.Notify(net.ReadString(), net.ReadUInt(8), net.ReadFloat())
end)

--PATH lua/advdupe2/cl_file.lua:
local function AdvDupe2_ReceiveFile(len, ply)
	local AutoSave = net.ReadUInt(8) == 1

	net.ReadStream(nil, function(data)
		AdvDupe2.RemoveProgressBar()
		if(!data)then
			AdvDupe2.Notify("File was not saved!",NOTIFY_ERROR,5)
			return
		end
		local path
		if AutoSave then
			if(LocalPlayer():GetInfo("advdupe2_auto_save_overwrite")~="0")then
				path = AdvDupe2.GetFilename(AdvDupe2.AutoSavePath, true)
			else
				path = AdvDupe2.GetFilename(AdvDupe2.AutoSavePath)
			end
		else
			path = AdvDupe2.GetFilename(AdvDupe2.SavePath)
		end

		local dupefile = file.Open(path, "wb", "DATA")
		if(!dupefile)then
			AdvDupe2.Notify("File was not saved!",NOTIFY_ERROR,5)
			return
		end
		dupefile:Write(data)
		dupefile:Close()
		
		local errored = false
		if(LocalPlayer():GetInfo("advdupe2_debug_openfile")=="1")then
			if(not file.Exists(path, "DATA"))then AdvDupe2.Notify("File does not exist", NOTIFY_ERROR) return end
			
			local readFile = file.Open(path, "rb", "DATA")
			if not readFile then AdvDupe2.Notify("File could not be read", NOTIFY_ERROR) return end
			local readData = readFile:Read(readFile:Size())
			readFile:Close()
			local success,dupe,info,moreinfo = AdvDupe2.Decode(readData)
			if(success)then
				AdvDupe2.Notify("DEBUG CHECK: File successfully opens. No EOF errors.")
			else
				AdvDupe2.Notify("DEBUG CHECK: " .. dupe, NOTIFY_ERROR)
				errored = true
			end
		end
		
		local filename = string.StripExtension(string.GetFileFromFilename( path ))
		if(AutoSave)then
			if(IsValid(AdvDupe2.FileBrowser.AutoSaveNode))then
				local add = true
				for i=1, #AdvDupe2.FileBrowser.AutoSaveNode.Files do
					if(filename==AdvDupe2.FileBrowser.AutoSaveNode.Files[i].Label:GetText())then
						add=false
						break
					end
				end
				if(add)then
					AdvDupe2.FileBrowser.AutoSaveNode:AddFile(filename)
					AdvDupe2.FileBrowser.Browser.pnlCanvas:Sort(AdvDupe2.FileBrowser.AutoSaveNode)
				end
			end
		else
			AdvDupe2.FileBrowser.Browser.pnlCanvas.ActionNode:AddFile(filename)
			AdvDupe2.FileBrowser.Browser.pnlCanvas:Sort(AdvDupe2.FileBrowser.Browser.pnlCanvas.ActionNode)
		end
		if(!errored)then
			AdvDupe2.Notify("File successfully saved!",NOTIFY_GENERIC, 5)
		end
	end)
end
net.Receive("AdvDupe2_ReceiveFile", AdvDupe2_ReceiveFile)

local uploading = nil
function AdvDupe2.UploadFile(ReadPath, ReadArea)
	if uploading then AdvDupe2.Notify("Already opening file, please wait.", NOTIFY_ERROR) return end
	if(ReadArea==0)then
		ReadPath = AdvDupe2.DataFolder.."/"..ReadPath..".txt"
	elseif(ReadArea==1)then
		ReadPath = AdvDupe2.DataFolder.."/-Public-/"..ReadPath..".txt"
	else
		ReadPath = "adv_duplicator/"..ReadPath..".txt"
	end
	
	if(not file.Exists(ReadPath, "DATA"))then AdvDupe2.Notify("File does not exist", NOTIFY_ERROR) return end
	
	local read = file.Read(ReadPath)
	if not read then AdvDupe2.Notify("File could not be read", NOTIFY_ERROR) return end
	local name = string.Explode("/", ReadPath)
	name = name[#name]
	name = string.sub(name, 1, #name-4)
	
	local success, dupe, info, moreinfo = AdvDupe2.Decode(read)
	if(success)then
		net.Start("AdvDupe2_ReceiveFile")
		net.WriteString(name)
		uploading = net.WriteStream(read, function()
			uploading = nil
			AdvDupe2.File = nil
			AdvDupe2.RemoveProgressBar()
		end)
		net.SendToServer()
		
		AdvDupe2.LoadGhosts(dupe, info, moreinfo, name)
	else
		AdvDupe2.Notify("File could not be decoded. ("..dupe..") Upload Canceled.", NOTIFY_ERROR)
	end
end

--PATH lua/advdupe2/cl_ghost.lua:
function AdvDupe2.LoadGhosts(dupe, info, moreinfo, name, preview)
	AdvDupe2.RemoveGhosts()
	AdvDupe2.Ghosting = true
	AdvDupe2.GhostToSpawn = {}
	local count = 0
	local time, desc, date, creator

	if(info.ad1) then
		local z = dupe.HeadEnt.Z
		local Pos, Ang

		time    = moreinfo.Time    or ""
		desc    = info.Description or ""
		date    = info.Date        or ""
		creator = info.Creator     or ""

		AdvDupe2.HeadEnt = dupe.HeadEnt.Index
		AdvDupe2.HeadPos = dupe.HeadEnt.Pos
		AdvDupe2.HeadZPos = z
		AdvDupe2.HeadPos.Z = AdvDupe2.HeadPos.Z + z

		for k, v in pairs(dupe.Entities) do
			if(v.SavedParentIdx) then
				if(not v.BuildDupeInfo) then v.BuildDupeInfo = {} end
				v.BuildDupeInfo.DupeParentID = v.SavedParentIdx
				Pos = v.LocalPos
				Ang = v.LocalAngle
			else
				Pos, Ang = nil, nil
			end

			for i, p in pairs(v.PhysicsObjects) do
				p.Pos        = Pos or p.LocalPos
				p.Pos.Z      = p.Pos.Z - z
				p.Angle      = Ang or p.LocalAngle
				p.LocalPos   = nil
				p.LocalAngle = nil
			end

			v.LocalPos = nil
			v.LocalAngle = nil
			AdvDupe2.GhostToSpawn[count] =
			{
				Model          = v.Model,
				PhysicsObjects = v.PhysicsObjects
			}

			if(AdvDupe2.HeadEnt == k) then
				AdvDupe2.HeadEnt = count
			end

			count = count + 1
		end

		AdvDupe2.HeadOffset = AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt].PhysicsObjects[0].Pos
		AdvDupe2.HeadAngle  = AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt].PhysicsObjects[0].Angle
	else
		time    = info.time        or ""
		desc    = dupe.Description or ""
		date    = info.date        or ""
		creator = info.name        or ""

		AdvDupe2.HeadEnt    = dupe.HeadEnt.Index
		AdvDupe2.HeadZPos   = dupe.HeadEnt.Z
		AdvDupe2.HeadPos    = dupe.HeadEnt.Pos
		AdvDupe2.HeadOffset = dupe.Entities[AdvDupe2.HeadEnt].PhysicsObjects[0].Pos
		AdvDupe2.HeadAngle  = dupe.Entities[AdvDupe2.HeadEnt].PhysicsObjects[0].Angle

		for k, v in pairs(dupe.Entities) do
			AdvDupe2.GhostToSpawn[count] =
			{
				Model          = v.Model,
				PhysicsObjects = v.PhysicsObjects
			}

			if(AdvDupe2.HeadEnt == k) then
				AdvDupe2.HeadEnt = count
			end

			count = count + 1
		end
	end

	if(not preview) then
		AdvDupe2.Info.File:SetText("File: "..name)
		AdvDupe2.Info.Creator:SetText("Creator: "..creator)
		AdvDupe2.Info.Date:SetText("Date: "..date)
		AdvDupe2.Info.Time:SetText("Time: "..time)
		AdvDupe2.Info.Size:SetText("Size: "..string.NiceSize(tonumber(info.size) or 0))
		AdvDupe2.Info.Desc:SetText("Desc: "..(desc or ""))
		AdvDupe2.Info.Entities:SetText("Entities: "..table.Count(dupe.Entities))
		AdvDupe2.Info.Constraints:SetText("Constraints: "..table.Count(dupe.Constraints))
	end

	AdvDupe2.StartGhosting()
	AdvDupe2.Preview = preview
end

function AdvDupe2.RemoveGhosts()
	if(AdvDupe2.Ghosting) then
		hook.Remove("Tick", "AdvDupe2_SpawnGhosts")
		AdvDupe2.Ghosting = false

		if(not AdvDupe2.BusyBar) then
			AdvDupe2.RemoveProgressBar()
		end
	end

	if(AdvDupe2.GhostEntities) then
		for k, v in pairs(AdvDupe2.GhostEntities) do
			if(IsValid(v))then
				v:Remove()
			end
		end
	end

	if(IsValid(AdvDupe2.HeadGhost))then
		AdvDupe2.HeadGhost:Remove()
	end

	AdvDupe2.CurrentGhost  = 1
	AdvDupe2.HeadGhost     = nil
	AdvDupe2.GhostEntities = nil
	AdvDupe2.Preview       = false
end

--Creates a ghost from the given entity's table
local function MakeGhostsFromTable(EntTable)

	if(not EntTable) then return end
	if(not EntTable.Model or EntTable.Model:sub(-4,-1) ~= ".mdl") then
		EntTable.Model = "models/error.mdl"
	end

	local GhostEntity = ClientsideModel(EntTable.Model, RENDERGROUP_TRANSLUCENT)

	-- If there are too many entities we might not spawn..
	if not IsValid(GhostEntity) then
		AdvDupe2.RemoveGhosts()
		AdvDupe2.Notify("Too many entities to spawn ghosts!", NOTIFY_ERROR)
		return
	end

	GhostEntity:SetRenderMode( RENDERMODE_TRANSALPHA )	--Was broken, making ghosts invisible
	GhostEntity:SetColor( Color(255, 255, 255, 150) )
	GhostEntity.Phys = EntTable.PhysicsObjects[0]

	if util.IsValidRagdoll(EntTable.Model) then
		local ref, parents, angs = {}, {}, {}

		GhostEntity:SetupBones()
		for k, v in pairs(EntTable.PhysicsObjects) do
			local bone = GhostEntity:TranslatePhysBoneToBone(k)
			local bonp = GhostEntity:GetBoneParent(bone)
			if bonp == -1 then
				ref[bone] = GhostEntity:GetBoneMatrix(bone):GetInverseTR()
			else
				bonp = GhostEntity:TranslatePhysBoneToBone(GhostEntity:TranslateBoneToPhysBone(bonp))
				parents[bone] = bonp
				ref[bone] = GhostEntity:GetBoneMatrix(bone):GetInverseTR() * GhostEntity:GetBoneMatrix(bonp)
			end

			local m = Matrix() m:SetAngles(v.Angle)
			angs[bone] = m
		end

		for bone, ang in pairs( angs ) do
			if parents[bone] and angs[parents[bone]] then
				local localrotation = angs[parents[bone]]:GetInverseTR() * ang
				local m = ref[bone] * localrotation
				GhostEntity:ManipulateBoneAngles(bone, m:GetAngles())
			else
				local pos = GhostEntity:GetBonePosition(bone)
				GhostEntity:ManipulateBonePosition(bone, -pos)
				GhostEntity:ManipulateBoneAngles(bone, ref[bone]:GetAngles())
			end
		end
	end

	return GhostEntity
end

local function SpawnGhosts()

	if AdvDupe2.CurrentGhost == AdvDupe2.HeadEnt then AdvDupe2.CurrentGhost = AdvDupe2.CurrentGhost + 1 end

	local g = AdvDupe2.GhostToSpawn[AdvDupe2.CurrentGhost]
	if g and AdvDupe2.CurrentGhost / AdvDupe2.TotalGhosts * 100 <= GetConVar("advdupe2_limit_ghost"):GetFloat() then
		AdvDupe2.GhostEntities[AdvDupe2.CurrentGhost] = MakeGhostsFromTable(g)
		if(not AdvDupe2.BusyBar) then
			AdvDupe2.ProgressBar.Percent = AdvDupe2.CurrentGhost / AdvDupe2.TotalGhosts * 100
		end

		AdvDupe2.CurrentGhost = AdvDupe2.CurrentGhost + 1
		AdvDupe2.UpdateGhosts(true)
	else
		AdvDupe2.Ghosting = false
		hook.Remove("Tick", "AdvDupe2_SpawnGhosts")

		if(not AdvDupe2.BusyBar) then
			AdvDupe2.RemoveProgressBar()
		end
	end
end

net.Receive("AdvDupe2_SendGhosts", 	function(len, ply, len2)
	AdvDupe2.RemoveGhosts()
	AdvDupe2.GhostToSpawn = {}
	AdvDupe2.HeadEnt  = net.ReadInt(16)
	AdvDupe2.HeadZPos = net.ReadFloat()
	AdvDupe2.HeadPos  = net.ReadVector()

	local cache = {}
	for i = 1, net.ReadInt(16) do
		cache[i] = net.ReadString()
	end

	for i = 1, net.ReadInt(16) do
		AdvDupe2.GhostToSpawn[i] =
		{
			Model = cache[net.ReadInt(16)],
			PhysicsObjects = {}
		}

		for k = 0, net.ReadInt(8) do
			AdvDupe2.GhostToSpawn[i].PhysicsObjects[k] =
			{
				Angle = net.ReadAngle(),
				Pos   = net.ReadVector()
			}
		end
	end

	AdvDupe2.CurrentGhost  = 1
	AdvDupe2.GhostEntities = {}
	AdvDupe2.HeadGhost     = MakeGhostsFromTable(AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt])
	AdvDupe2.HeadOffset    = AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt].PhysicsObjects[0].Pos
	AdvDupe2.HeadAngle     = AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt].PhysicsObjects[0].Angle
	AdvDupe2.GhostEntities[AdvDupe2.HeadEnt] = AdvDupe2.HeadGhost
	AdvDupe2.TotalGhosts   = #AdvDupe2.GhostToSpawn

	if(AdvDupe2.TotalGhosts > 1) then
		AdvDupe2.Ghosting = true

		if(not AdvDupe2.BusyBar) then
			AdvDupe2.InitProgressBar("Ghosting: ")
			AdvDupe2.BusyBar = false
		end

		hook.Add("Tick", "AdvDupe2_SpawnGhosts", SpawnGhosts)
	else
		AdvDupe2.Ghosting = false
	end
end)

net.Receive("AdvDupe2_AddGhost", function(len, ply, len2)
	local ghost = {Model = net.ReadString(), PhysicsObjects = {}}
	for k = 0, net.ReadInt(8) do
		ghost.PhysicsObjects[k] = {Angle = net.ReadAngle(), Pos = net.ReadVector()}
	end

	AdvDupe2.GhostEntities[AdvDupe2.CurrentGhost] = MakeGhostsFromTable(ghost)
	AdvDupe2.CurrentGhost = AdvDupe2.CurrentGhost + 1
end)

function AdvDupe2.StartGhosting()
	AdvDupe2.RemoveGhosts()
	if(not AdvDupe2.GhostToSpawn) then return end
	AdvDupe2.CurrentGhost  = 1
	AdvDupe2.GhostEntities = {}
	AdvDupe2.Ghosting      = true
	AdvDupe2.HeadGhost     = MakeGhostsFromTable(AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt])
	AdvDupe2.GhostEntities[AdvDupe2.HeadEnt] = AdvDupe2.HeadGhost
	AdvDupe2.TotalGhosts   = #AdvDupe2.GhostToSpawn

	if AdvDupe2.TotalGhosts > 1 then
		if not AdvDupe2.BusyBar then
			AdvDupe2.InitProgressBar("Ghosting: ")
			AdvDupe2.BusyBar = false
		end
		hook.Add("Tick", "AdvDupe2_SpawnGhosts", SpawnGhosts)
	else
		AdvDupe2.Ghosting = false
	end
end
net.Receive("AdvDupe2_StartGhosting", function()
	AdvDupe2.StartGhosting()
end)

net.Receive("AdvDupe2_RemoveGhosts", AdvDupe2.RemoveGhosts)

--Update the ghost's postion and angles based on where the player is looking and the offsets
local Lheadpos, Lheadang = Vector(), Angle()
function AdvDupe2.UpdateGhosts(force)
	if not IsValid(AdvDupe2.HeadGhost) then
		AdvDupe2.RemoveGhosts()
		AdvDupe2.Notify("Invalid ghost parent!", NOTIFY_ERROR)
		return
	end

	local trace = LocalPlayer():GetEyeTrace()
	if (not trace.Hit) then return end

	local originpos, originang, headpos, headang
	local worigin = GetConVar("advdupe2_offset_world"):GetBool()
	if(GetConVar("advdupe2_original_origin"):GetBool())then
		originang  = Angle()
		originpos  = Vector(AdvDupe2.HeadPos)
		headpos = AdvDupe2.HeadPos + AdvDupe2.HeadOffset
		headang = AdvDupe2.HeadAngle
	else
		local hangle = worigin and Angle(0,0,0) or AdvDupe2.HeadAngle
		local pz = math.Clamp(AdvDupe2.HeadZPos + GetConVar("advdupe2_offset_z"):GetFloat() or 0, -16000, 16000)
		local ap = math.Clamp(GetConVar("advdupe2_offset_pitch"):GetFloat() or 0, -180, 180)
		local ay = math.Clamp(GetConVar("advdupe2_offset_yaw"  ):GetFloat() or 0, -180, 180)
		local ar = math.Clamp(GetConVar("advdupe2_offset_roll" ):GetFloat() or 0, -180, 180)
		originang = Angle(ap, ay, ar)
		originpos = Vector(trace.HitPos); originpos.z = originpos.z + pz
		headpos, headang = LocalToWorld(AdvDupe2.HeadOffset, hangle, originpos, originang)
	end

	if math.abs(Lheadpos.x - headpos.x) > 0.01 or
	   math.abs(Lheadpos.y - headpos.y) > 0.01 or
	   math.abs(Lheadpos.z - headpos.z) > 0.01 or
	   math.abs(Lheadang.p - headang.p) > 0.01 or
	   math.abs(Lheadang.y - headang.y) > 0.01 or
	   math.abs(Lheadang.r - headang.r) > 0.01 or force then

		Lheadpos = headpos
		Lheadang = headang

		AdvDupe2.HeadGhost:SetPos(headpos)
		AdvDupe2.HeadGhost:SetAngles(headang)

		for k, ghost in ipairs(AdvDupe2.GhostEntities) do
			local phys = ghost.Phys
			local pos, ang = LocalToWorld(phys.Pos, phys.Angle, originpos, originang)
			ghost:SetPos(pos)
			ghost:SetAngles(ang)
		end

	end
end

--PATH addons/[technik] darkrp-city-worker/lua/autorun/client/cityworker_client.lua:
CITYWORKER = CITYWORKER or {}

/*
    Action Display
    HUD that displays the progress of the player's current action.
*/

local MAT_WRENCH = Material( "cityworker/wrench.png" )

net.Receive( "CITYWORKER.StartAction", function()
    local desc = net.ReadString()
    local time = net.ReadUInt( 8 )

    local startTime = CurTime()
    local targetTime = CurTime() + time
    local deltaTime = targetTime - startTime

    hook.Add( "HUDPaint", "CITYWORKER.Action.HUDPaint", function()
        local x, y, w, h = ScrW() / 2 - ScrW() / 6, ScrH() / 4, ScrW() / 3, 60 * ( ScrH() / 1080 )
    
        surface.SetDrawColor( 0, 0, 0, 200 )
        surface.DrawRect( x, y, w, h )
    
        surface.SetDrawColor( 20, 150, 200 )
        surface.DrawRect( x + 5, y + 5, ( w - 10 ) * ( ( CurTime() - startTime ) / ( deltaTime ) ), h - 10 )
    
        draw.SimpleText( desc, "Trebuchet24", x + ( w / 2 ), y + ( h / 2 ) - 10, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        draw.SimpleText( CITYWORKER.Config.Language["CANCEL"], "Trebuchet18", x + ( w / 2 ), y + ( h / 2 ) + 12, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    end )

    timer.Create( "CITYWORKER.Action.Timer", time, 1, function()
        hook.Remove( "HUDPaint", "CITYWORKER.Action.HUDPaint" )
    end )
end )

net.Receive( "CITYWORKER.StopAction", function()
    hook.Remove( "HUDPaint", "CITYWORKER.Action.HUDPaint" )

    if timer.Exists( "CITYWORKER.Action.Timer" ) then
        timer.Remove( "CITYWORKER.Action.Timer" )
    end
end )

/*
    Task Notification
    HUD that displays the position of their next task.
*/

net.Receive( "CITYWORKER.NotifyTask", function()
    local pos = net.ReadVector()

    hook.Add( "HUDPaint", "CITYWORKER.Task.HUDPaint", function()
        local screenPos = pos:ToScreen()

        surface.SetDrawColor( 255, 255, 255 )
        surface.SetMaterial( MAT_WRENCH )
        surface.DrawTexturedRect( screenPos.x - 16, screenPos.y - 16, 32, 32 )

        draw.SimpleTextOutlined( math.ceil( ( LocalPlayer():GetPos():Distance( pos ) / 16 ) / 3.28084 ).."m", "Trebuchet24", screenPos.x, screenPos.y + 16, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, Color( 0, 0, 0 ) )
    end )
end )

net.Receive( "CITYWORKER.RemoveTask", function()
    hook.Remove( "HUDPaint", "CITYWORKER.Task.HUDPaint" )
end )
--PATH lua/permaprops/cl_drawent.lua:
/*
   ____          _          _   ____          __  __       _ _                     
  / ___|___   __| | ___  __| | | __ ) _   _  |  \/  | __ _| | |__   ___  _ __ ___  
 | |   / _ \ / _` |/ _ \/ _` | |  _ \| | | | | |\/| |/ _` | | '_ \ / _ \| '__/ _ \ 
 | |__| (_) | (_| |  __/ (_| | | |_) | |_| | | |  | | (_| | | |_) | (_) | | | (_) |
  \____\___/ \__,_|\___|\__,_| |____/ \__, | |_|  |_|\__,_|_|_.__/ \___/|_|  \___/ 
                                      |___/                                        
*/

local function PermaPropsViewer()

	if not LocalPlayer().DrawPPEnt or not istable(LocalPlayer().DrawPPEnt) then return end

    local pos = LocalPlayer():EyePos() + LocalPlayer():EyeAngles():Forward() * 10
    local ang = LocalPlayer():EyeAngles()

    ang = Angle(ang.p + 90, ang.y, 0)

    for k, v in pairs(LocalPlayer().DrawPPEnt) do

    	if not v or not v:IsValid() then LocalPlayer().DrawPPEnt[k] = nil continue end

	    render.ClearStencil()
	    render.SetStencilEnable(true)
	        render.SetStencilWriteMask(255)
	        render.SetStencilTestMask(255)
	        render.SetStencilReferenceValue(15)
	        render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	        render.SetStencilZFailOperation(STENCILOPERATION_REPLACE)
	        render.SetStencilPassOperation(STENCILOPERATION_KEEP)
	        render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_ALWAYS)
	        render.SetBlend(0)
	        v:DrawModel()
	        render.SetBlend(1)
	        render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	        cam.Start3D2D(pos, ang, 1)
	                surface.SetDrawColor(255, 0, 0, 255)
	                surface.DrawRect(-ScrW(), -ScrH(), ScrW() * 2, ScrH() * 2)
	        cam.End3D2D()
	        v:DrawModel()
	    render.SetStencilEnable(false)

	end

end
hook.Add("PostDrawOpaqueRenderables", "PermaPropsViewer", PermaPropsViewer)
--PATH lua/autorun/client/lvs_vehicle_tab.lua:
return gluapack()()
--PATH lua/autorun/client/morematerials.lua:
return gluapack()()
--PATH lua/autorun/client/vj_menu_plugins.lua:
/*--------------------------------------------------
	=============== VJ Base Plugins ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

---------------------------------------------------------------------------------------------------------------------------------------------
local function VJ_PLUGINS(Panel)
	local numPlugins = #VJ.Plugins
	
	Panel:AddControl("Label", {Text = "#vjbase.menu.plugins.label"})
	Panel:ControlHelp(language.GetPhrase("#vjbase.menu.plugins.version").." "..VJBASE_VERSION) -- Main Number / Version / Patches
	Panel:ControlHelp(language.GetPhrase("#vjbase.menu.plugins.totalplugins").." "..numPlugins)
	
	local CheckList = vgui.Create("DListView")
	CheckList:SetTooltip(false)
	//CheckList:Center() -- No need since Size does it already
	CheckList:SetSize(100, 300) -- Size
	CheckList:SetMultiSelect(false)
	CheckList:AddColumn("#vjbase.menu.plugins.header1") -- Add column
	CheckList:AddColumn("#vjbase.menu.plugins.header2"):SetFixedWidth(50) -- Add column
	//Panel:SetName("Test") -- Renames the blue label
	if VJ.Plugins != nil then
		for _,v in SortedPairsByMemberValue(VJ.Plugins, "Name") do
			CheckList:AddLine(v.Name, v.Type)
		end
	else
		CheckList:AddLine("#vjbase.menu.plugins.notfound", "")
	end
	CheckList.OnRowSelected = function()
		surface.PlaySound(Sound("vj_misc/illuminati_confirmed.mp3"))
		chat.AddText(Color(255,255,0),"-=-=-=-=-=-=-=-=- ", Color(255,100,0), "VJ Base", Color(255,255,0)," -=-=-=-=-=-=-=-=-")
		chat.AddText(Color(0,255,0), language.GetPhrase("#vjbase.menu.plugins.version").." "..VJBASE_VERSION)
		chat.AddText(Color(0,255,0), language.GetPhrase("#vjbase.menu.plugins.totalplugins").." "..numPlugins)
	end
	Panel:AddItem(CheckList)
	
	-- Changelog for VJ Base
	local changelog = vgui.Create("DButton")
	changelog:SetFont("TargetID")
	changelog:SetText("#vjbase.menu.plugins.changelog")
	changelog:SetSize(150, 25)
	changelog:SetColor(Color(0, 102, 0))
	changelog:SetFont("VJFont_Trebuchet24_SmallMedium")
	changelog.DoClick = function(x)
		gui.OpenURL("https://github.com/DrVrej/VJ-Base/releases")
	end
	Panel:AddPanel(changelog)
	
	-- Github Wiki
	local github = vgui.Create("DButton")
	github:SetFont("TargetID")
	github:SetText("#vjbase.menu.plugins.makeaddon")
	github:SetSize(150, 25)
	github:SetColor(Color(0, 0, 102))
	github:SetFont("VJFont_Trebuchet24_SmallMedium")
	github.DoClick = function(x)
		gui.OpenURL("https://github.com/DrVrej/VJ-Base/wiki")
	end
	Panel:AddPanel(github)
	
	-- Tutorial Video
	local tutorialVid = vgui.Create("DButton")
	tutorialVid:SetFont("TargetID")
	tutorialVid:SetText("#tool.vjstool.menu.tutorialvideo")
	tutorialVid:SetSize(150, 25)
	tutorialVid:SetColor(Color(0, 0, 102))
	tutorialVid:SetFont("VJFont_Trebuchet24_SmallMedium")
	tutorialVid.DoClick = function(x)
		gui.OpenURL("https://www.youtube.com/watch?v=dGoqEpFZ5_M")
	end
	Panel:AddPanel(tutorialVid)
	
	-- *insert lenny face*
	if (LocalPlayer():SteamID() == "STEAM_0:0:22688298") then
		local lennyface = vgui.Create("DButton")
		lennyface:SetFont("TargetID")
		lennyface:SetText("HELLO")
		lennyface:SetSize(150, 25)
		lennyface:SetColor(Color(0, 0, 102))
		lennyface:SetFont("VJFont_Trebuchet24_SmallMedium")
		lennyface.DoClick = function(x)
			net.Start("vj_meme")
			net.SendToServer()
		end
		Panel:AddPanel(lennyface)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateToolMenu", "VJ_ADDTOMENU_INSTALLATIONS", function()
	spawnmenu.AddToolMenuOption("DrVrej", "Main Menu", "Installed Plugins", "#vjbase.menu.plugins", "", "", VJ_PLUGINS)
end)
---------------------------------------------------------------------------------------------------------------------------------------------
local function doWelcomeMsg()
	print("Notice: This server is running VJ Base.")

	local amt = #VJ.Plugins
    if amt <= 9 then
		amt = "0"..tostring(amt)
	else
		amt = tostring(amt)
	end
    local dashes = "----------------------------"
	
    chat.AddText(Color(255,215,0),"|"..dashes..">", Color(0,255,255), " VJ Base ", Color(30,200,255), VJBASE_VERSION.." ", Color(255,215,0), "<"..dashes.."|")
    chat.AddText(Color(255,215,0),"|- ", Color(255,255,0),"NOTICE! ", Color(255,255,255), "To configure ", Color(0,255,255), "VJ Base ", Color(255,255,255), "click on ", Color(0,255,255), "DrVrej", Color(255,255,255)," in the spawn menu! ", Color(255,215,0),"-|")
    //chat.AddText(Color(255,215,0),"|"..dashes..">", Color(30,200,255), " "..amt, Color(0,255,255), " VJ Plugins ", Color(255,215,0), "<"..dashes.."|")
end
concommand.Add("vj_welcome_msg", doWelcomeMsg)
net.Receive("vj_welcome_msg", doWelcomeMsg)
---------------------------------------------------------------------------------------------------------------------------------------------
concommand.Add("vj_iamhere", function(ply,cmd,args)
	net.Start("vj_meme")
	net.SendToServer()
end)
--PATH addons/xeon-drm-dll/lua/autorun/client/xeon-drm-auth.lua:
return gluapack()()
--PATH lua/vgui/bvgui/columnlayout.lua:
local PANEL = {}

bVGUI.COLUMN_LAYOUT_COLUMN_GROW = 0
bVGUI.COLUMN_LAYOUT_COLUMN_SHRINK = 1
bVGUI.COLUMN_LAYOUT_COLUMN_GROW_COLUMN = 2

function PANEL:Init()
	self.Columns = {}
	self.Rows = {}
	self.ColumnPadding = 0
	self.RowPadding = 0

	function self.pnlCanvas:PerformLayout()
		self:GetParent():ColumnLayout()
		self:InvalidateParent(true)
	end
end

function PANEL:SetPaddings(column_padding, row_padding)
	self.ColumnPadding = column_padding
	self.RowPadding = row_padding
end

function PANEL:SetColumns(...)
	self.Columns = {...}
	self.GrowColumnCount = 0
	for _,v in ipairs(self.Columns) do
		if (v == bVGUI.COLUMN_LAYOUT_COLUMN_GROW or v == bVGUI.COLUMN_LAYOUT_COLUMN_GROW_COLUMN) then
			self.GrowColumnCount = self.GrowColumnCount + 1
		end
	end
end

function PANEL:AddRow(...)
	local i = table.insert(self.Rows, {...})
	self.pnlCanvas:InvalidateLayout(true)
	return i
end

function PANEL:RemoveRow(row_index)
	for _,element in ipairs(self.Rows[row_index]) do
		element:Remove()
	end
	table.remove(self.Rows, row_index)
	self.pnlCanvas:InvalidateLayout(true)
end

function PANEL:ColumnLayout()
	local column_widths = {}
	local row_heights = {}
	for row_i, elements in ipairs(self.Rows) do
		for column_i, element in ipairs(elements) do
			if (self.Columns[column_i] == bVGUI.COLUMN_LAYOUT_COLUMN_SHRINK) then
				local element_w = element:GetWide()
				local column_w = column_widths[column_i]
				if (not column_w or element_w > column_w) then
					column_widths[column_i] = element_w
				end
			end
			local element_h = element:GetTall()
			local row_h = row_heights[row_i]
			if (not row_h or element_h > row_h) then
				row_heights[row_i] = element_h
			end
		end
	end
	local grow_column_width = 0
	for i,v in pairs(column_widths) do
		grow_column_width = grow_column_width - v - self.ColumnPadding
	end
	grow_column_width = ((grow_column_width + self:GetWide()) / self.GrowColumnCount) - 4

	local row_y = 0
	for row_i, elements in ipairs(self.Rows) do
		local column_x = 0
		for column_i, element in ipairs(elements) do
			local column_sizing = self.Columns[column_i]
			if (column_sizing == bVGUI.COLUMN_LAYOUT_COLUMN_SHRINK) then
				element:SetWide(column_widths[column_i])
				element:SetPos(column_x, row_y)
				column_x = column_x + column_widths[column_i] + self.ColumnPadding
			elseif (column_sizing == bVGUI.COLUMN_LAYOUT_COLUMN_GROW or column_sizing == bVGUI.COLUMN_LAYOUT_COLUMN_GROW_COLUMN) then
				if (bVGUI.COLUMN_LAYOUT_COLUMN_GROW_COLUMN) then
					element:SetWide(grow_column_width)
				else
					element:SetSize(grow_column_width, row_heights[row_i])
				end
				element:SetPos(column_x, row_y)
				column_x = column_x + grow_column_width + self.ColumnPadding
			end
		end
		row_y = row_y + row_heights[row_i] + self.RowPadding
	end
end

derma.DefineControl("bVGUI.ColumnLayout", nil, PANEL, "bVGUI.ScrollPanel")
--PATH lua/vgui/bvgui/combobox.lua:
return gluapack()()
--PATH lua/vgui/bvgui/gauge.lua:
return gluapack()()
--PATH lua/vgui/bvgui/header.lua:
local PANEL = {}

function PANEL:Init()
	self:SetTall(24)
	self:DockPadding(5,5,5,5)

	self.Label = vgui.Create("DLabel", self)
	self.Label:SetTextColor(bVGUI.COLOR_BLACK)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "BOLD", 14))
	self.Label:Dock(FILL)
	self.Label:SetContentAlignment(5)

	self:SetText("Header")
	self:SetColor(bVGUI.COLOR_GMOD_BLUE)
end

function PANEL:SetText(text)
	self.Text = text
	self.Label:SetText(self.Text)
end
function PANEL:SetColor(color)
	self.Color = color
	self.Label:SetTextColor(bVGUI.TextColorContrast(color))
end

function PANEL:SetIcon(icon)
	if (icon == false) then
		if (IsValid(self.IconLeft)) then
			self.IconLeft:Remove()
		end
		if (IsValid(self.IconRight)) then
			self.IconRight:Remove()
		end
	else
		if (IsValid(self.IconLeft)) then
			self.IconLeft:SetImage(icon)
		else
			self.IconLeft = vgui.Create("DImage", self)
			self.IconLeft:SetSize(16,16)
			self.IconLeft:SetImage(icon)
		end

		if (IsValid(self.IconRight)) then
			self.IconRight:SetImage(icon)
		else
			self.IconRight = vgui.Create("DImage", self)
			self.IconRight:SetSize(16,16)
			self.IconRight:SetImage(icon)
		end
	end
end

function PANEL:PerformLayout()
	if (IsValid(self.IconLeft)) then
		self.IconLeft:AlignLeft(5)
		self.IconLeft:CenterVertical()
	end
	if (IsValid(self.IconRight)) then
		self.IconRight:AlignRight(5)
		self.IconRight:CenterVertical()
	end
end

function PANEL:Paint(w,h)
	surface.SetDrawColor(self.Color)
	surface.DrawRect(0,0,w,h)

	surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT)
	surface.DrawTexturedRect(0,0,w,h)
end
function PANEL:PaintOver(w,h)
	surface.SetDrawColor(0,0,0,200)
	surface.DrawRect(0,h - 1,w,1)
end

derma.DefineControl("bVGUI.Header", nil, PANEL, "DPanel")
--PATH lua/vgui/bvgui/mouseinfo_tooltip.lua:
if (IsValid(bVGUI.MouseInfoTooltip)) then
	if (IsValid(bVGUI.MouseInfoTooltip.Label)) then
		bVGUI.PlayerTooltip.Label:Remove()
	end
end

bVGUI.MouseInfoTooltip = {}
bVGUI.MouseInfoTooltip.Create = function(text)
	if (IsValid(bVGUI.MouseInfoTooltip.Label)) then
		bVGUI.MouseInfoTooltip.Label:Remove()
	end
	bVGUI.MouseInfoTooltip.Label = vgui.Create("DLabel")
	bVGUI.MouseInfoTooltip.Label:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "BOLD", 12))
	bVGUI.MouseInfoTooltip.Label:SetText(text)
	bVGUI.MouseInfoTooltip.Label:SizeToContents()
	bVGUI.MouseInfoTooltip.Label:SetContentAlignment(5)

	bVGUI.MouseInfoTooltip.Label.CurrentTextColor = Color(255, 255, 255, 255)
	bVGUI.MouseInfoTooltip.Label.CurrentY = 15

	bVGUI.MouseInfoTooltip.Label:SetTextColor(bVGUI.MouseInfoTooltip.Label.CurrentTextColor)
	bVGUI.MouseInfoTooltip.Label:SetPos(gui.MouseX(), bVGUI.MouseInfoTooltip.Label.CurrentY)

	bVGUI.MouseInfoTooltip.Label:SetZPos(32767)
	bVGUI.MouseInfoTooltip.Label:MakePopup()
	bVGUI.MouseInfoTooltip.Label:MoveToFront()
	bVGUI.MouseInfoTooltip.Label:SetMouseInputEnabled(false)
	bVGUI.MouseInfoTooltip.Label:SetKeyBoardInputEnabled(false)

	bVGUI.MouseInfoTooltip.Label.SysTime = SysTime()
	bVGUI.MouseInfoTooltip.Label.SysTimeEnd = SysTime() + 5
	function bVGUI.MouseInfoTooltip.Label:Think()
		self.CurrentTextColor.a = Lerp(FrameTime() * 10, self.CurrentTextColor.a, 0)
		self.CurrentY = Lerp(FrameTime() * 10, self.CurrentY, 20)

		self:SetTextColor(self.CurrentTextColor)
		self:SetPos(gui.MouseX() - (self:GetWide() / 2) + 5, gui.MouseY() + self:GetTall() + self.CurrentY)

		if (self.CurrentTextColor.a <= 1) then
			self:Remove()
		end
	end
end
--PATH lua/vgui/bvgui/numberwang.lua:
local PANEL = {}

function PANEL:Init()
	self.NumberWang = vgui.Create("DNumberWang", self)
	self.NumberWang:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
end

function PANEL:CorrectSizing()
	local y = 0
	y = y + self.NumberWang:GetTall()
	if (IsValid(self.Label)) then
		y = y + 10 + self.Label:GetTall()
		self.NumberWang:AlignTop(10 + self.Label:GetTall())
	end
	if (IsValid(self.HelpLabel)) then
		y = y + 10 + self.HelpLabel:GetTall()
		self.HelpLabel:AlignTop(10 + self.Label:GetTall() + self.NumberWang:GetTall() + 10)
	end
	self:SetTall(y)
end

function PANEL:SetText(text)
	self.Label = vgui.Create("DLabel", self)
	self.Label:SetContentAlignment(4)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetText(text)
	self.Label:SizeToContents()

	self:CorrectSizing()
end

function PANEL:SetHelpText(text)
	self.HelpLabel = vgui.Create("DLabel", self)
	self.HelpLabel:SetTextColor(Color(200,200,200))
	self.HelpLabel:SetAutoStretchVertical(true)
	self.HelpLabel:SetWrap(true)
	self.HelpLabel:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
	self.HelpLabel:SetText(text)
	local this = self
	function self.HelpLabel:PerformLayout()
		this:CorrectSizing()
	end
	self:CorrectSizing()
end

function PANEL:PerformLayout()
	if (IsValid(self.HelpLabel)) then
		self.HelpLabel:SetWide(self:GetWide() - 10)
	end
end

derma.DefineControl("bVGUI.NumberWang", nil, PANEL, "bVGUI.BlankPanel")
--PATH lua/vgui/bvgui/permissions_selector.lua:
local PANEL = {}

function PANEL:Init()
	self.Rows = {}
	self.Headers = {}
	self.Categories = {}
	self.Permissions = {}
end

function PANEL:NormalCheckboxes()
	self.UseNormalCheckboxes = true
end

function PANEL:Clear()
	for i,v in ipairs(table.Merge(self.Rows, self.Headers)) do
		v:Remove()
	end
	self.Rows = {}
	self.Headers = {}
	self.Categories = {}
	self.Permissions = {}
	self:InvalidateLayout(true)
end

function PANEL:AddPermission(permission)
	table.insert(self.Permissions, permission)
end

function PANEL:AddHeader(header_text, header_col)
	local header = vgui.Create("bVGUI.Header", self)
	header.HeaderIndex = table.insert(self.Headers, header)
	header:Dock(TOP)
	header:SetText(header_text)
	header:SetColor(header_col)
end

function PANEL:AddPermissionGroup(header_text, header_col, rows, header_val)
	self:AddHeader(header_text, header_col)

	self.Categories[header_val or header_text] = {}

	for _,v in ipairs(rows) do
		local row = vgui.Create("bVGUI.PermissionsSelector_Row", self)
		row.RowIndex = table.insert(self.Rows, row)
		row.CategoryIndex = table.insert(self.Categories[header_val or header_text], row)
		row.Category = header_val or header_text
		row:Dock(TOP)
		row:SetText(v.text)
		row:SetTextColor(v.text_col)
		row:SetControlsAll(v.controls_all or false)
		row.PermissionValue = v.value
		if (v.checked) then
			row:SetChecks(v.checked)
		end
	end
end

function PANEL:AddSuperGroup(text, text_col)
	local row = vgui.Create("bVGUI.PermissionsSelector_Row", self)
	row.RowIndex = table.insert(self.Rows, row)
	row:Dock(TOP)
	row:SetText(text)
	row:SetTextColor(text_col)
	row:SetSuperGroup(true)
	self.SuperGroupRow = row
end

function PANEL:AddRow(header_val, v, header_text)
	local i = 0
	local last_row
	local found = false
	for row_i, row in pairs(self.Rows) do
		i = i + 1
		if (row.Category == (header_val or header_text)) then
			last_row = row
			found = true
		elseif (found) then
			break
		end
	end
	local row = vgui.Create("bVGUI.PermissionsSelector_Row", self)
	row.RowIndex = table.insert(self.Rows, i, row)
	row.CategoryIndex = table.insert(self.Categories[header_val or header_text], row)
	row.Category = header_val or header_text
	row:Dock(TOP)
	row:MoveToAfter(last_row)
	row:SetText(v.text)
	row:SetTextColor(v.text_col)
	row:SetControlsAll(v.controls_all or false)
	row.PermissionValue = v.value
	if (v.checked) then
		row:SetChecks(v.checked)
	end
end

function PANEL:GetPermissions()
	local permissions = {}
	if (self.SuperGroupRow) then
		for checkbox_i, checkbox in ipairs(self.SuperGroupRow.Checkboxes) do
			if (self.UseNormalCheckboxes) then
				if (checkbox:GetChecked() ~= false) then
					permissions["*"] = {}
					permissions["*"][checkbox_i] = true
					return permissions
				end
			else
				if (checkbox:GetChecked() ~= 0) then
					permissions["*"] = {}
					permissions["*"][checkbox_i] = checkbox:GetChecked()
					return permissions
				end
			end
		end
	end
	for category_i, rows in pairs(self.Categories) do
		permissions[category_i] = {}
		for row_i, row in ipairs(rows) do
			if (row.ControlsAll == true) then
				for checkbox_i, checkbox in ipairs(table.Reverse(row.Checkboxes)) do
					if (checkbox:GetChecked() ~= 0) then
						permissions[category_i]["*"] = permissions[category_i]["*"] or {}
						permissions[category_i]["*"][checkbox_i] = checkbox:GetChecked()
					end
				end
				if (permissions[category_i]["*"]) then
					if (table.Count(permissions[category_i]["*"]) == #row.Checkboxes) then
						break
					end
				end
			else
				permissions[category_i][row.PermissionValue or row.Label:GetText()] = {}
				for checkbox_i, checkbox in ipairs(table.Reverse(row.Checkboxes)) do
					if (checkbox:GetChecked() ~= 0) then
						permissions[category_i][row.PermissionValue or row.Label:GetText()][checkbox_i] = checkbox:GetChecked()
					end
				end
			end
		end
		if (permissions[category_i]["*"] and table.Count(permissions[category_i]) > 1) then
			permissions[category_i]["*"] = nil
		end
	end
	return permissions
end

function PANEL:UpdateCheckboxes()
	--[[
	local super_merges = {}
	local merges = {}
	for category_i, rows in pairs(self.Categories) do
		merges[category_i] = {}
		for row_i, row in ipairs(rows) do
			if (row.ControlsAll) then continue end
			for checkbox_i, checkbox in ipairs(row.Checkboxes) do
				if (super_merges[checkbox_i] == nil) then
					super_merges[checkbox_i] = checkbox:GetChecked()
				elseif (super_merges[checkbox_i] ~= false and super_merges[checkbox_i] ~= checkbox:GetChecked()) then
					super_merges[checkbox_i] = false
				end
				if (merges[category_i][checkbox_i] == nil) then
					merges[category_i][checkbox_i] = checkbox:GetChecked()
				elseif (merges[category_i][checkbox_i] ~= false and merges[category_i][checkbox_i] ~= checkbox:GetChecked()) then
					merges[category_i][checkbox_i] = false
				end
			end
		end
	end
	for category_i, checkboxes in pairs(merges) do
		for checkbox_i, checked in ipairs(checkboxes) do
			if (not self.Categories[category_i][1].ControlsAll) then continue end
			self.Categories[category_i][1].Checkboxes[checkbox_i]:SetChecked(checked or 0)
		end
	end
	if (IsValid(self.SuperGroupRow)) then
		for checkbox_i, checked in ipairs(super_merges) do
			self.SuperGroupRow.Checkboxes[checkbox_i]:SetChecked(checked or 0)
		end
	end
	]]
end

derma.DefineControl("bVGUI.PermissionsSelector", nil, PANEL, "bVGUI.LoadingScrollPanel")

local PANEL = {}

function PANEL:Init()
	local this = self
	self.PermissionsSelector = self:GetParent():GetParent()

	self:Dock(TOP)
	self:DockPadding(5,0,5,0)

	self.Label = vgui.Create("DLabel", self)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:Dock(LEFT)

	self.Checkboxes = {}
	for i,v in ipairs(table.Reverse(self.PermissionsSelector.Permissions)) do
		local checkbox
		if (self.PermissionsSelector.UseNormalCheckboxes) then
			checkbox = vgui.Create("bVGUI.Checkbox", self)
		else
			checkbox = vgui.Create("bVGUI.Checkbox_Crossable", self)
		end
		checkbox.CheckboxIndex = table.insert(self.Checkboxes, checkbox)
		checkbox:Dock(RIGHT)
		checkbox:SetTooltip(v)
		checkbox:DockMargin(0,3.5,5,3.5)
		function checkbox:OnChange()
			if (this.PermissionsSelector.SuperGroupRow) then
				local super_checkbox = this.PermissionsSelector.SuperGroupRow.Checkboxes[self.CheckboxIndex]
				if (self:GetChecked() ~= super_checkbox:GetChecked()) then
					if (this.PermissionsSelector.UseNormalCheckboxes) then
						super_checkbox:SetChecked(false)
					else
						super_checkbox:SetChecked(0)
					end
				end
			end
			if (self:GetParent().IsSuperGroup == true) then
				for category_i, rows in pairs(this.PermissionsSelector.Categories) do
					for row_i, row in ipairs(rows) do
						row.Checkboxes[self.CheckboxIndex]:SetChecked(self:GetChecked())
					end
				end
			else
				for i,v in ipairs(this.PermissionsSelector.Categories[self:GetParent().Category]) do
					if (v.ControlsAll) then
						local controls_all_checkbox = v.Checkboxes[self.CheckboxIndex]
						if (self:GetChecked() ~= controls_all_checkbox:GetChecked()) then
							if (this.PermissionsSelector.UseNormalCheckboxes) then
								controls_all_checkbox:SetChecked(false)
							else
								controls_all_checkbox:SetChecked(0)
							end
						end
						break
					end
				end

				if (self:GetParent().ControlsAll == true) then
					for i,v in ipairs(this.PermissionsSelector.Categories[self:GetParent().Category]) do
						if (v.ControlsAll) then continue end
						v.Checkboxes[self.CheckboxIndex]:SetChecked(self:GetChecked())
					end
				end

				this.PermissionsSelector:UpdateCheckboxes()
			end
			if (this.PermissionsSelector.OnPermissionsChanged) then
				this.PermissionsSelector:OnPermissionsChanged()
			end
		end
	end
end

function PANEL:Paint(w,h)
	if (self.RowIndex % 2 == 0) then
		surface.SetDrawColor(31, 35, 43)
	else
		surface.SetDrawColor(33, 37, 45)
	end
	surface.DrawRect(0,0,w,h)
end

function PANEL:SetText(text)
	self.Label:SetText(text)
	self.Label:SizeToContents()
end

function PANEL:SetTextColor(text_col)
	self.Label:SetTextColor(text_col)
end

function PANEL:SetControlsAll(controls_all)
	self.ControlsAll = controls_all
end

function PANEL:SetSuperGroup(supergroup)
	self.IsSuperGroup = supergroup
end

function PANEL:SetChecks(checked)
	for i,v in ipairs(table.Reverse(self.Checkboxes)) do
		if (checked[i]) then
			v:SetChecked(checked[i])
		end
	end
end

derma.DefineControl("bVGUI.PermissionsSelector_Row", nil, PANEL, "DPanel")
--PATH lua/vgui/bvgui/toolbarbutton.lua:
return gluapack()()
--PATH lua/vgui/cl_fframe.lua:
local PANEL = {}

AccessorFunc( PANEL, "m_bIsMenuComponent",	"IsMenu",			FORCE_BOOL )
AccessorFunc( PANEL, "m_bDraggable",		"Draggable",		FORCE_BOOL )
AccessorFunc( PANEL, "m_bSizable",			"Sizable",			FORCE_BOOL )
AccessorFunc( PANEL, "m_bScreenLock",		"ScreenLock",		FORCE_BOOL )
AccessorFunc( PANEL, "m_bDeleteOnClose",	"DeleteOnClose",	FORCE_BOOL )
AccessorFunc( PANEL, "m_bPaintShadow",		"PaintShadow",		FORCE_BOOL )

AccessorFunc( PANEL, "m_iMinWidth",			"MinWidth",			FORCE_NUMBER )
AccessorFunc( PANEL, "m_iMinHeight",		"MinHeight",		FORCE_NUMBER )

AccessorFunc( PANEL, "m_bBackgroundBlur",	"BackgroundBlur",	FORCE_BOOL )

function PANEL:Init()

	self:SetFocusTopLevel( true )

	--self:SetCursor( "sizeall" )

	self:SetPaintShadow( true )
    self:SetColor(Color(0,0,0))
	self:SetDraggable( false )
	self:SetSizable( false )
	self:SetScreenLock( false )
	self:SetDeleteOnClose( true )
	self:SetTitle( "" )

	self:SetMinWidth( 1 )
	self:SetMinHeight( 1 )

	-- This turns off the engine drawing
	self:SetPaintBackgroundEnabled( false )
	self:SetPaintBorderEnabled( false )

	self.m_fCreateTime = SysTime()

	self:DockPadding( 0, 0, 0, 0 )

end

function PANEL:ShowCloseButton( bShow )

	self.Close:SetVisible( bShow )

end

function PANEL:SetTitle( strTitle )

end

function PANEL:SetColor( color )
    self.c = color
end
function PANEL:GetColor( color )
    return self.c
end

function PANEL:Close()

	self:SetVisible( false )

	if ( self:GetDeleteOnClose() ) then
		self:Remove()
	end

	self:OnClose()

end

function PANEL:OnClose()
end

function PANEL:CloseIF()
	return false
end

function PANEL:Center()

	self:InvalidateLayout( true )
	self:CenterVertical()
	self:CenterHorizontal()

end

function PANEL:IsActive()

	if ( self:HasFocus() ) then return true end
	if ( vgui.FocusedHasParent( self ) ) then return true end

	return false

end

function PANEL:SetIcon( str )

	if ( !str && IsValid( self.imgIcon ) ) then
		return self.imgIcon:Remove() -- We are instructed to get rid of the icon, do it and bail.
	end

	if ( !IsValid( self.imgIcon ) ) then
		self.imgIcon = vgui.Create( "DImage", self )
	end

	if ( IsValid( self.imgIcon ) ) then
		self.imgIcon:SetMaterial( Material( str ) )
	end

end

function PANEL:Blur(check)
	self.blur = check
end

function PANEL:SlideIn(x,y,time,center)
    time = time or 0
    delay = delay or 0
    if center ~= true then
        self:MoveTo(x,y,time,delay,-0.00001)
    else
        self:MoveTo(ScrW()/2 - self:GetWide()/2,ScrH()/2 - self:GetTall()/2,time,delay,-1)
    end
end
function PANEL:Slide(side,time,delay)
    time = time or 1
    delay = delay or 0
    if side == TOP then
        self:MoveTo(self:GetX(),-self:GetTall(),time,delay,-0.00001)
    elseif side == BOTTOM then
        self:MoveTo(self:GetX(),ScrH() + self:GetTall(),time,delay,-0.00001)
    elseif side == LEFT then
        self:MoveTo(-self:GetWide(),self:GetY(),time,delay,-0.00001)
    else
        self:MoveTo(ScrW() + self:GetWide(),self:GetY(),time,delay,-0.00001)
    end


    timer.Simple(time+delay,function()
        if IsValid(self) then
            self:Remove()
        end
    end)
end
function PANEL:FadeOut(time,delay)
    local alpha = self:GetAlpha()
    local anim = self:NewAnimation( time, delay, -1, function( anim, pnl )
        if IsValid(self) then
            self:Remove()
        end
    end )

    anim.Think = function( anim, pnl, fraction )
        pnl:SetAlpha(alpha *(1 - fraction))
    end

end
function PANEL:FadeHide(time,delay)
    local alpha = self:GetAlpha()
    local anim = self:NewAnimation( time, delay, -1, function( anim, pnl )
    end )

    anim.Think = function( anim, pnl, fraction )
        pnl:SetAlpha(math.max(alpha *(1 - fraction),1))
    end

end
function PANEL:FadeIn(time,alpha)
    alpha = alpha or 255
    local anim = self:NewAnimation( time, delay, -1, function( anim, pnl )
    end )

    anim.Think = function( anim, pnl, fraction )
        pnl:SetAlpha(alpha * fraction)
    end

end
function PANEL:TVLIKE(time)
    local w,h = self:GetWide(),self:GetTall()
    local x,y = self:GetX() + w/2,self:GetY() + h/2
    alpha = alpha or 255
    self:SetSize(0,0)
    self:SizeTo(5,5,0.8,0,-1)
    self:SetPos(x,y)
    self:SizeTo(w,5,time,0.8,-1)
    self:SizeTo(w,h,time,1.5 + 1,-1)
    local anim = self:NewAnimation( time+1.5 +1.6+time, 0, -1, function( anim, pnl )
    end )

    anim.Think = function( anim, pnl, fraction )
        pnl:SetPos(x-self:GetWide()/2,y-self:GetTall()/2)
    end
    

end

function PANEL:Think()
	if self:CloseIF() == true then
		self:FadeOut(0.2)
	end
	local mousex = math.Clamp( gui.MouseX(), 1, ScrW() - 1 )
	local mousey = math.Clamp( gui.MouseY(), 1, ScrH() - 1 )

	if ( self.Dragging ) then

		local x = mousex - self.Dragging[1]
		local y = mousey - self.Dragging[2]

		-- Lock to screen bounds if screenlock is enabled
		if ( self:GetScreenLock() ) then

			x = math.Clamp( x, 0, ScrW() - self:GetWide() )
			y = math.Clamp( y, 0, ScrH() - self:GetTall() )

		end

		self:SetPos( x, y )

	end

	if ( self.Sizing ) then

		local x = mousex - self.Sizing[1]
		local y = mousey - self.Sizing[2]
		local px, py = self:GetPos()

		if ( x < self.m_iMinWidth ) then x = self.m_iMinWidth elseif ( x > ScrW() - px && self:GetScreenLock() ) then x = ScrW() - px end
		if ( y < self.m_iMinHeight ) then y = self.m_iMinHeight elseif ( y > ScrH() - py && self:GetScreenLock() ) then y = ScrH() - py end

		self:SetSize( x, y )
		self:SetCursor( "sizenwse" )
		return

	end

	local screenX, screenY = self:LocalToScreen( 0, 0 )

	if ( self.Hovered && self.m_bSizable && mousex > ( screenX + self:GetWide() - 20 ) && mousey > ( screenY + self:GetTall() - 20 ) ) then

		self:SetCursor( "sizenwse" )
		return

	end

	if ( self.Hovered && self:GetDraggable() && mousey < ( screenY + 24 ) ) then
		self:SetCursor( "sizeall" )
		return
	end

	self:SetCursor( "arrow" )

	-- Don't allow the frame to go higher than 0
	--if ( self.y < 0 ) then
		--self:SetPos( self.x, 0 )
	--end

end
local blur = Material( "pp/blurscreen" )
function BlurMenu( panel, layers, density, alpha )
	-- Its a scientifically proven fact that blur improves a script
	local x, y = panel:LocalToScreen( 0, 0 )

	surface.SetDrawColor( 255, 255, 255, alpha )
	surface.SetMaterial( blur )

	for i = 1, 5 do
		blur:SetFloat( "$blur", ( i / 4 ) * 6 )
		blur:Recompute()

		render.UpdateScreenEffectTexture()
		surface.DrawTexturedRect( -x, -y, ScrW(), ScrH() )
	end
end
function PANEL:Paint( w, h )

	if ( self.m_bBackgroundBlur ) then
		Derma_DrawBackgroundBlur( self, self.m_fCreateTime )
	end
	
	if self.blur == true then
		BlurMenu( self, 5, 5, 255 )
		return true
	end
	surface.SetDrawColor(self:GetColor())
    surface.DrawRect(0,0,w,h)
	return true

end

function PANEL:OnMousePressed()

	local screenX, screenY = self:LocalToScreen( 0, 0 )

	if ( self.m_bSizable && gui.MouseX() > ( screenX + self:GetWide() - 20 ) && gui.MouseY() > ( screenY + self:GetTall() - 20 ) ) then
		self.Sizing = { gui.MouseX() - self:GetWide(), gui.MouseY() - self:GetTall() }
		self:MouseCapture( true )
		return
	end

	if ( self:GetDraggable() && gui.MouseY() < ( screenY + 24 ) ) then
		self.Dragging = { gui.MouseX() - self.x, gui.MouseY() - self.y }
		self:MouseCapture( true )
		return
	end

end

function PANEL:OnMouseReleased()

	self.Dragging = nil
	self.Sizing = nil
	self:MouseCapture( false )

end

function PANEL:PerformLayout()

	local titlePush = 0

	if ( IsValid( self.imgIcon ) ) then

		self.imgIcon:SetPos( 5, 5 )
		self.imgIcon:SetSize( 16, 16 )
		titlePush = 16

	end

end

derma.DefineControl( "FFrame", "Main Window", PANEL, "EditablePanel" )
--PATH lua/vgui/gas_circles.lua:
/*
	https://github.com/Sneaky-Squid/Circles
	MIT License
*/

local blur = Material("pp/blurscreen")

CIRCLE_FILLED = 0
CIRCLE_OUTLINED = 1
CIRCLE_BLURRED = 2

local CIRCLE = {}
CIRCLE.__index = CIRCLE

CIRCLE.m_iType = CIRCLE_FILLED

CIRCLE.m_iX = 0
CIRCLE.m_iY = 0
CIRCLE.m_iR = 0

CIRCLE.m_iRotation = 0
CIRCLE.m_iThickness = 1
CIRCLE.m_iQuality = 2
CIRCLE.m_iDensity = 3

CIRCLE.m_iStartAngle = 0
CIRCLE.m_iEndAngle = 360

CIRCLE.m_bRotateMat = true

AccessorFunc(CIRCLE, "m_iType", "Type", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_iR", "Radius", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_iVertices", "Vertices", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_iRotation", "Rotation", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_iThickness", "Thickness", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_iQuality", "Quality", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_iDensity", "Density", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_bRotateMat", "RotateMaterial", FORCE_BOOL)

function CIRCLE:__tostring()
	return string.format("Circle: %p", self)
end

function CIRCLE:SetRadius(r)
	if (self.m_iR == r) then return end

	self.m_iR = r
	self.m_tVertices = nil
	self.m_cInnerCircle = nil
end

function CIRCLE:SetVertices(vertices)
	vertices = math.Clamp(vertices, 3, 360)

	if (self.m_iVertices == vertices) then return end

	self.m_iVertices = vertices
	self.m_iSteps = 360 / vertices

	self.m_tVertices = nil
	self.m_cInnerCircle = nil
end

function CIRCLE:SetRotation(rotation)
	if (self.m_iRotation == rotation) then return end

	self.m_iRotation = rotation
	self.m_tVertices = nil
	self.m_cInnerCircle = nil
end

function CIRCLE:SetThickness(thicc)
	if (self.m_iThickness == thicc) then return end

	self.m_iThickness = thicc
	self.m_cInnerCircle = nil
end

function CIRCLE:SetPos(x, y)
	if (self.m_iX == x and self.m_iY == Y) then return end

	self.m_iX = x
	self.m_iY = y

	self.m_tVertices = nil
	self.m_cInnerCircle = nil
end

function CIRCLE:SetAngles(start, finish)
	if (self.m_iStartAngle == start and self.m_iEndAngle == finish) then return end

	self.m_iStartAngle = math.min(start, finish)
	self.m_iEndAngle = math.max(start, finish)

	self.m_tVertices = nil
	self.m_cInnerCircle = nil
end

function CIRCLE:OffsetVertices(x, y)
	if (not self.m_tVertices) then
		self:Calculate()
	end

	x = x or 0
	y = y or 0

	self.m_iX = self.m_iX + x
	self.m_iY = self.m_iY + y

	for i, v in ipairs(self.m_tVertices) do
		v.x = v.x + x
		v.y = v.y + y
	end

	if (self.m_cInnerCircle) then
		self.m_cInnerCircle:OffsetVertices(x, y)
	end
end

function CIRCLE:Copy()
	return table.Copy(self)
end

function CIRCLE:Calculate()
	local r = self.m_iR
	local x, y = self.m_iX, self.m_iY
	local start, finish = self.m_iStartAngle, self.m_iEndAngle

	local verts, dist = {}, math.Clamp(self.m_iSteps or math.max(8, 360 / (r * math.pi)), 1, 120)

	if (finish - start ~= 360) then
		table.insert(verts, {
			x = x,
			y = y,

			u = 0.5,
			v = 0.5,
		})

		finish = finish + dist
	else
		finish = finish - dist
	end

	for a = start, finish, dist do
		a = math.Clamp(a, start, self.m_iEndAngle)

		local rad = math.rad(a)
		local rot = math.rad(self.m_iRotation)

		table.insert(verts, {
			x = x + math.cos(rad + rot) * r,
			y = y + math.sin(rad + rot) * r,

			u = math.cos(self.m_bRotateMat and rad - rot or rad) / 2 + 0.5,
			v = math.sin(self.m_bRotateMat and rad - rot or rad) / 2 + 0.5,
		})
	end

	self.m_tVertices = verts
end

function CIRCLE:__call(colour, material)
	if (not self.m_tVertices) then
		self:Calculate()
	end

	if (IsColor(colour)) then surface.SetDrawColor(colour) end
	if (TypeID(material) == TYPE_MATERIAL) then surface.SetMaterial(material) elseif (material) then draw.NoTexture() end

	if (self.m_iType == CIRCLE_OUTLINED) then
		if (not self.m_cInnerCircle) then
			local inner = self:Copy()

			inner:SetType(CIRCLE_FILLED)
			inner:SetRadius(self.m_iR - self.m_iThickness)

			self.m_cInnerCircle = inner
		end

		render.ClearStencil()

		render.SetStencilEnable(true)
			render.SetStencilReferenceValue(1)
			render.SetStencilWriteMask(1)
			render.SetStencilTestMask(1)

			render.SetStencilPassOperation(STENCIL_KEEP)
			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			self.m_cInnerCircle()

			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)
			render.SetStencilCompareFunction(STENCIL_GREATER)

			surface.DrawPoly(self.m_tVertices)
		render.SetStencilEnable(false)
	elseif (self.m_iType == CIRCLE_BLURRED) then
		render.ClearStencil()

		render.SetStencilEnable(true)
			render.SetStencilReferenceValue(1)
			render.SetStencilWriteMask(1)
			render.SetStencilTestMask(1)

			render.SetStencilPassOperation(STENCIL_KEEP)
			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			surface.DrawPoly(self.m_tVertices)

			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)
			render.SetStencilCompareFunction(STENCIL_LESSEQUAL)

			surface.SetMaterial(blur)

			local sw, sh = ScrW(), ScrH()

			for i = 1, self.m_iQuality do
				blur:SetFloat("$blur", (i / self.m_iQuality) * self.m_iDensity)
				blur:Recompute()

				render.UpdateScreenEffectTexture()
				surface.DrawTexturedRect(0, 0, sw, sh)
			end
		render.SetStencilEnable(false)
	else
		surface.DrawPoly(self.m_tVertices)
	end
end

debug.getregistry()["Circle"] = CIRCLE

function GAS_NewCircle(type)
	return setmetatable({m_iType = tonumber(type)}, CIRCLE)
end
--PATH lua/vgui/openpermissions_listview.lua:
local PANEL = {}

function PANEL:Init()
	self.CurrentOffset = 0
	self.TargetOffset = 0
	self.StartTime = 0
	self.EndTime = 0

	self.VBar:SetHideButtons(true)
	self.VBar:SetWide(5)
	self.VBar:DockMargin(3,3,3,3)

	function self.VBar:Paint() end
	function self.VBar.btnGrip:Paint(w,h)
		surface.SetDrawColor(0,0,0,150)
		surface.DrawRect(0,0,w,h)
	end

	self.VBar.CurrentY = 0
	self.VBar.TargetY = 0
	function self.VBar:PerformLayout()

		local Wide = self:GetWide()
		local BtnHeight = Wide
		if ( self:GetHideButtons() ) then BtnHeight = 0 end
		local Scroll = self:GetScroll() / self.CanvasSize
		local BarSize = math.max( self:BarScale() * ( self:GetTall() - ( BtnHeight * 2 ) ), 10 )
		local Track = self:GetTall() - ( BtnHeight * 2 ) - BarSize
		Track = Track + 1

		Scroll = Scroll * Track

		self.TargetY = BtnHeight + Scroll
		self.btnGrip:SetSize( Wide, BarSize )

		if ( BtnHeight > 0 ) then
			self.btnUp:SetPos( 0, 0, Wide, Wide )
			self.btnUp:SetSize( Wide, BtnHeight )

			self.btnDown:SetPos( 0, self:GetTall() - BtnHeight )
			self.btnDown:SetSize( Wide, BtnHeight )
			
			self.btnUp:SetVisible( true )
			self.btnDown:SetVisible( true )
		else
			self.btnUp:SetVisible( false )
			self.btnDown:SetVisible( false )
			self.btnDown:SetSize( Wide, BtnHeight )
			self.btnUp:SetSize( Wide, BtnHeight )
		end

	end

	function self.VBar:Think()
		self.CurrentY = Lerp(FrameTime() * 10, self.CurrentY, self.TargetY)
		self.btnGrip:SetPos(0, math.Round(self.CurrentY))
	end

	self.pnlCanvas.CurrentOffset = 0
	self.pnlCanvas.TargetOffset = 0
	function self.pnlCanvas:Think()
		self.CurrentOffset = Lerp(FrameTime() * 10, self.CurrentOffset, self.TargetOffset)
		self:SetPos(0, math.Round(self.CurrentOffset + self:GetParent():GetHeaderHeight()))
	end
end

function PANEL:OnVScroll(offset)
	self.pnlCanvas.TargetOffset = offset
end

function PANEL:PerformLayout()

	-- Do Scrollbar
	local Wide = self:GetWide()
	local YPos = 0

	if ( IsValid( self.VBar ) ) then

		self.VBar:SetPos( self:GetWide() - 5 - 3, 3 )
		self.VBar:SetSize( 5, self:GetTall() - 6 )
		self.VBar:SetUp( self.VBar:GetTall() - self:GetHeaderHeight(), self.pnlCanvas:GetTall() )
		YPos = self.VBar:GetOffset()

		if ( self.VBar.Enabled ) then Wide = Wide - 5 end

	end

	if ( self.m_bHideHeaders ) then
		self.pnlCanvas:SetPos( 0, YPos )
	else
		self.pnlCanvas:SetPos( 0, YPos + self:GetHeaderHeight() )
	end

	self.pnlCanvas:SetSize( Wide + self.VBar:GetWide(), self.pnlCanvas:GetTall() )

	self:FixColumnsLayout()

	--
	-- If the data is dirty, re-layout
	--
	if ( self:GetDirty() ) then

		self:SetDirty( false )
		local y = self:DataLayout()
		self.pnlCanvas:SetTall( y )

		-- Layout again, since stuff has changed..
		self:InvalidateLayout( true )

	end

end

derma.DefineControl("OpenPermissions.ListView", nil, PANEL, "DListView")
--PATH lua/vgui/openpermissions_tooltip.lua:
local bg_color = Color(43,48,58,255)

local PANEL = {}

function PANEL:Init()
	self:SetDrawOnTop(true)

	self.Label = vgui.Create("DLabel", self)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.Label:SetText("Tooltip")
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetContentAlignment(5)
	self.Label:SetWrap(true)

	self.Arrow = {
		{x = 0, y = 0},
		{x = 0, y = 0},
		{x = 0, y = 0}
	}
end

function PANEL:Paint(w,h)
	draw.RoundedBox(4, 0, 0, w, h, self.BackgroundColor or bg_color)
	surface.DisableClipping(true)

	surface.SetDrawColor(self.BackgroundColor or bg_color)
	draw.NoTexture()

	self.Arrow[1].x = w / 2 - 7
	self.Arrow[1].y = h

	self.Arrow[2].x = w / 2 + 7
	self.Arrow[2].y = h

	self.Arrow[3].x = w / 2
	self.Arrow[3].y = h + 7

	surface.DrawPoly(self.Arrow)

	surface.DisableClipping(false)
end

function PANEL:Think()
	local x,y = self.Label:GetSize()
	self:SetSize(x + 15, y + 7)
	self.Label:Center()
	local x,y = gui.MousePos()
	self:SetPos(x - self:GetWide() / 2, y - self:GetTall() - 14 - 5)

	if (not system.HasFocus()) then
		self:Remove()
	elseif (self.VGUI_Element) then
		if (not IsValid(self.VGUI_Element)) then
			self:Remove()
		elseif (vgui.GetHoveredPanel() ~= self.VGUI_Element) then
			if (self.HoverFrameNumber) then
				if (FrameNumber() > self.HoverFrameNumber) then
					self:Remove()
				end
			else
				self.HoverFrameNumber = FrameNumber() + 1
			end
		end
	end
end

function PANEL:SetText(text)
	self.Label:SetText(text)
	self.Label:SetWrap(false)
	self.Label:SizeToContentsX()
	if (self.Label:GetWide() >= 200) then
		self.Label:SetWide(200)
		self.Label:SetWrap(true)
		self.Label:SetAutoStretchVertical(true)
	end
end

derma.DefineControl("OpenPermissions.Tooltip", nil, PANEL, "DPanel")
--PATH gamemodes/starwarsrp/gamemode/libraries/interfaceloader.lua:
module("DarkRP", package.seeall)

MetaName = "DarkRP"

-- Variables that maintain the existing stubs and hooks
local stubs = {}
local hookStubs = {}

-- Contains the functions that the hooks call by default
hooks = {}

-- Delay the calling of methods until the functions are implemented
local delayedCalls = {}

local returnsLayout, isreturns
local parameterLayout, isparameters
local isdeprecated
local checkStub

local hookLayout

local realm -- State variable to manage the realm of the stubs

--[[---------------------------------------------------------------------------
Methods that check whether certain fields are valid
---------------------------------------------------------------------------]]
isreturns = function(tbl)
    if not istable(tbl) then return false end
    for _, v in pairs(tbl) do
        if not checkStub(v, returnsLayout) then return false end
    end
    return true
end

isparameters = function(tbl)
    if not istable(tbl) then return false end
    for _, v in pairs(tbl) do
        if not checkStub(v, parameterLayout) then return false end
    end
    return true
end

isdeprecated = function(val)
    return val == nil or isstring(val)
end

--[[---------------------------------------------------------------------------
The layouts of stubs
---------------------------------------------------------------------------]]
local stubLayout = {
    name = isstring,
    description = isstring,
    deprecated = isdeprecated,
    parameters = isparameters, -- the parameters of a method
    returns = isreturns, -- the return values of a method
    metatable = istable -- DarkRP, Player, Entity, Vector, ...
}

hookLayout = {
    name = isstring,
    description = isstring,
    deprecated = isdeprecated,
    parameters = isreturns, -- doesn't have the 'optional' field
    returns = isreturns,
}

returnsLayout = {
    name = isstring,
    description = isstring,
    type = isstring
}

parameterLayout = {
    name = isstring,
    description = isstring,
    type = isstring,
    optional = isbool
}

--[[---------------------------------------------------------------------------
Check the validity of a stub
---------------------------------------------------------------------------]]
checkStub = function(tbl, stub)
    if not istable(tbl) then return false, "table" end

    for name, check in pairs(stub) do
        if not check(tbl[name]) then
            return false, name
        end
    end

    return true
end

--[[---------------------------------------------------------------------------
When a stub is called, the calling of the method is delayed
---------------------------------------------------------------------------]]
local function notImplemented(name, args, thisFunc)
    if stubs[name] and stubs[name].metatable[name] ~= thisFunc then -- when calling the not implemented function after the function was implemented
        return stubs[name].metatable[name](unpack(args))
    end
    table.insert(delayedCalls, {name = name, args = args})

    return nil -- no return value because the method is not implemented
end

--[[---------------------------------------------------------------------------
Generate a stub
---------------------------------------------------------------------------]]
function stub(tbl)
    local isStub, field = checkStub(tbl, stubLayout)
    if not isStub then
        error("Invalid DarkRP method stub! Field \"" .. field .. "\" is invalid!", 2)
    end

    tbl.realm = tbl.realm or realm
    stubs[tbl.name] = tbl

    local function retNotImpl(...)
        return notImplemented(tbl.name, {...}, retNotImpl)
    end

    return retNotImpl
end

--[[---------------------------------------------------------------------------
Generate a hook stub
---------------------------------------------------------------------------]]
function hookStub(tbl)
    local isStub, field = checkStub(tbl, hookLayout)
    if not isStub then
        error("Invalid DarkRP hook! Field \"" .. field .. "\" is invalid!", 2)
    end

    tbl.realm = tbl.realm or realm
    hookStubs[tbl.name] = tbl
end

--[[---------------------------------------------------------------------------
Retrieve the stubs
---------------------------------------------------------------------------]]
function getStubs()
    return table.Copy(stubs)
end

--[[---------------------------------------------------------------------------
Retrieve the hooks
---------------------------------------------------------------------------]]
function getHooks()
    return table.Copy(hookStubs)
end

--[[---------------------------------------------------------------------------
Call the cached methods
---------------------------------------------------------------------------]]
function finish()
    local calls = table.Copy(delayedCalls) -- Loop through a copy, so the notImplemented function doesn't get called again
    for _, tbl in ipairs(calls) do
        local name = tbl.name

        if not stubs[name] then ErrorNoHalt("Calling non-existing stub \"" .. name .. "\"") continue end

        stubs[name].metatable[name](unpack(tbl.args))
    end

    delayedCalls = {}
end

--[[---------------------------------------------------------------------------
Load the interface files
---------------------------------------------------------------------------]]
local function loadInterfaces()
    local root = GM.FolderName .. "/gamemode/modules"

    local _, folders = file.Find(root .. "/*", "LUA")

    ENTITY = FindMetaTable("Entity")
    PLAYER = FindMetaTable("Player")
    VECTOR = FindMetaTable("Vector")

    for _, folder in SortedPairs(folders, true) do
        local interfacefile = string.format("%s/%s/%s_interface.lua", root, folder, "%s")
        local client = string.format(interfacefile, "cl")
        local shared = string.format(interfacefile, "sh")
        local server = string.format(interfacefile, "sv")

        if file.Exists(shared, "LUA") then
            if SERVER then AddCSLuaFile(shared) end
            realm = "Shared"
            include(shared)
        end

        if SERVER and file.Exists(client, "LUA") then
            AddCSLuaFile(client)
        end

        if SERVER and file.Exists(server, "LUA") then
            realm = "Server"
            include(server)
        end

        if CLIENT and file.Exists(client, "LUA") then
            realm = "Client"
            include(client)
        end
    end

    ENTITY, PLAYER, VECTOR = nil, nil, nil
end
loadInterfaces()

--PATH gamemodes/starwarsrp/gamemode/modules/doorsystem/cl_interface.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/base/sh_interface.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/animations/sh_interface.lua:
DarkRP.addPlayerGesture = DarkRP.stub{
    name = "addPlayerGesture",
    description = "Add a player gesture to the DarkRP animations menu (the one that opens with the keys weapon.). Note: This function must be called BOTH serverside AND clientside!",
    parameters = {
        {
            name = "anim",
            description = "The gesture enumeration.",
            type = "number",
            optional = false
        },
        {
            name = "text",
            description = "The textual description of the animation. This is what players see on the button in the menu.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removePlayerGesture = DarkRP.stub{
    name = "removePlayerGesture",
    description = "Removes a player gesture from the DarkRP animations menu (the one that opens with the keys weapon.). Note: This function must be called BOTH serverside AND clientside!",
    parameters = {
        {
            name = "anim",
            description = "The gesture enumeration.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

--PATH gamemodes/starwarsrp/gamemode/libraries/modificationloader.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/libraries/modificationloader.lua:
-- Modification loader.
-- Dependencies:
--     - fn
--     - simplerr

--[[---------------------------------------------------------------------------
Disabled defaults
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults = {}
DarkRP.disabledDefaults["modules"] = {
    ["afk"]              = true,
    ["chatsounds"]       = false,
    ["events"]           = false,
    ["fpp"]              = false,
    ["hitmenu"]          = false,
    ["hud"]              = false,
    ["hungermod"]        = true,
    ["playerscale"]      = false,
    ["sleep"]            = false,
}

DarkRP.disabledDefaults["agendas"]          = {}
DarkRP.disabledDefaults["ammo"]             = {}
DarkRP.disabledDefaults["demotegroups"]     = {}
DarkRP.disabledDefaults["doorgroups"]       = {}
DarkRP.disabledDefaults["entities"]         = {}
DarkRP.disabledDefaults["food"]             = {}
DarkRP.disabledDefaults["groupchat"]        = {}
DarkRP.disabledDefaults["hitmen"]           = {}
DarkRP.disabledDefaults["jobs"]             = {}
DarkRP.disabledDefaults["shipments"]        = {}
DarkRP.disabledDefaults["vehicles"]         = {}
DarkRP.disabledDefaults["workarounds"]      = {}

-- The client cannot use simplerr.runLuaFile because of restrictions in GMod.
local doInclude = CLIENT and include or fc{simplerr.wrapError, simplerr.wrapLog, simplerr.runFile}

if file.Exists("darkrp_config/disabled_defaults.lua", "LUA") then
    if SERVER then AddCSLuaFile("darkrp_config/disabled_defaults.lua") end
    doInclude("darkrp_config/disabled_defaults.lua")
end

--[[---------------------------------------------------------------------------
Config
---------------------------------------------------------------------------]]
local configFiles = {
    "darkrp_config/settings.lua",
    "darkrp_config/licenseweapons.lua",
}

for _, File in pairs(configFiles) do
    if not file.Exists(File, "LUA") then continue end

    if SERVER then AddCSLuaFile(File) end
    doInclude(File)
end
if SERVER and file.Exists("darkrp_config/mysql.lua", "LUA") then doInclude("darkrp_config/mysql.lua") end

--[[---------------------------------------------------------------------------
Modules
---------------------------------------------------------------------------]]
local function loadModules()
    local fol = "darkrp_modules/"

    local _, folders = file.Find(fol .. "*", "LUA")

    for _, folder in SortedPairs(folders, true) do
        if folder == "." or folder == ".." or GAMEMODE.Config.DisabledCustomModules[folder] then continue end
        -- Sound but incomplete way of detecting the error of putting addons in the darkrpmod folder
        if file.Exists(fol .. folder .. "/addon.txt", "LUA") or file.Exists(fol .. folder .. "/addon.json", "LUA") then
            DarkRP.errorNoHalt("Addon detected in the darkrp_modules folder.", 2, {
                "This addon is not supposed to be in the darkrp_modules folder.",
                "It is supposed to be in garrysmod/addons/ instead.",
                "Whether a mod is to be installed in darkrp_modules or addons is the author's decision.",
                "Please read the readme of the addons you're installing next time."
            },
            "<darkrpmod addon>/lua/darkrp_modules/" .. folder, -1)
            continue
        end

        for _, File in SortedPairs(file.Find(fol .. folder .. "/sh_*.lua", "LUA"), true) do
            if SERVER then
                AddCSLuaFile(fol .. folder .. "/" .. File)
            end

            if File == "sh_interface.lua" then continue end
            doInclude(fol .. folder .. "/" .. File)
        end

        if SERVER then
            for _, File in SortedPairs(file.Find(fol .. folder .. "/sv_*.lua", "LUA"), true) do
                if File == "sv_interface.lua" then continue end
                doInclude(fol .. folder .. "/" .. File)
            end
        end

        for _, File in SortedPairs(file.Find(fol .. folder .. "/cl_*.lua", "LUA"), true) do
            if File == "cl_interface.lua" then continue end

            if SERVER then
                AddCSLuaFile(fol .. folder .. "/" .. File)
            else
                doInclude(fol .. folder .. "/" .. File)
            end
        end
    end
end

local function loadLanguages()
    local fol = "darkrp_language/"

    local files, _ = file.Find(fol .. "*", "LUA")
    for _, File in pairs(files) do
        if SERVER then AddCSLuaFile(fol .. File) end
        doInclude(fol .. File)
    end
end

local customFiles = {
    "darkrp_customthings/jobs.lua",
    "darkrp_customthings/shipments.lua",
    "darkrp_customthings/entities.lua",
    "darkrp_customthings/vehicles.lua",
    "darkrp_customthings/food.lua",
    "darkrp_customthings/ammo.lua",
    "darkrp_customthings/groupchats.lua",
    "darkrp_customthings/categories.lua",
    "darkrp_customthings/agendas.lua", -- has to be run after jobs.lua
    "darkrp_customthings/doorgroups.lua", -- has to be run after jobs.lua
    "darkrp_customthings/demotegroups.lua", -- has to be run after jobs.lua
}
local function loadCustomDarkRPItems()
    for _, File in pairs(customFiles) do
        if not file.Exists(File, "LUA") then continue end
        if File == "darkrp_customthings/food.lua" and DarkRP.disabledDefaults["modules"]["hungermod"] then continue end

        if SERVER then AddCSLuaFile(File) end
        doInclude(File)
    end
end


function GM:DarkRPFinishedLoading()
    -- GAMEMODE gets set after the last statement in the gamemode files is run. That is not the case in this hook
    GAMEMODE = GAMEMODE or GM

    loadLanguages()
    loadModules()
    loadCustomDarkRPItems()
    hook.Call("loadCustomDarkRPItems", self)
    hook.Call("postLoadCustomDarkRPItems", self)
end

--PATH gamemodes/starwarsrp/gamemode/modules/playerscale/cl_playerscale.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/language/sh_language.lua:
local rp_languages = {}
local selectedLanguage = GetConVar("gmod_language"):GetString() -- Switch language by setting gmod_language to another language

cvars.AddChangeCallback("gmod_language", function(cv, old, new)
    selectedLanguage = new
end)

-- Some server owners experience that the language is not set correctly on
-- startup. This provides a failsafe in case that happens.
timer.Simple(0, function()
    local gmodLanguage = GetConVar("gmod_language"):GetString()
    if gmodLanguage ~= "" and selectedLanguage ~= gmodLanguage then
        selectedLanguage = gmodLanguage
    end
end)

function DarkRP.addLanguage(name, tbl)
    local old = rp_languages[name] or {}
    rp_languages[name] = tbl

    -- Merge the language with the translations added by DarkRP.addPhrase
    for k, v in pairs(old) do
        if rp_languages[name][k] then continue end
        rp_languages[name][k] = v
    end
    LANGUAGE = rp_languages[name] -- backwards compatibility
end

function DarkRP.addPhrase(lang, name, phrase)
    rp_languages[lang] = rp_languages[lang] or {}
    rp_languages[lang][name] = phrase
end

function DarkRP.getPhrase(name, ...)
    local langTable = rp_languages[selectedLanguage] or rp_languages.en

    return (langTable[name] or rp_languages.en[name]) and string.format(langTable[name] or rp_languages.en[name], ...) or nil
end

function DarkRP.getPhraseLocalized(ply, name, ...)
    local lang = ply:GetInfo("gmod_language") or selectedLanguage
    local langTable = rp_languages[lang] or rp_languages.en

    return (langTable[name] or rp_languages.en[name]) and string.format(langTable[name] or rp_languages.en[name], ...) or nil
end

function DarkRP.getMissingPhrases(lang)
    lang = lang or selectedLanguage
    local res = {}
    local format = "%s = \"%s\","

    for k, v in pairs(rp_languages.en) do
        if rp_languages[lang][k] then continue end
        table.insert(res, string.format(format, k, v))
    end

    return table.IsEmpty(res) and "No language strings missing!" or table.concat(res, "\n")
end

local function getMissingPhrases(ply, cmd, args)
    if not args[1] then print("Please run the command with a language code e.g. darkrp_getphrases \"en\"") return end
    local lang = rp_languages[args[1]]
    if not lang then print("This language does not exist! Make sure the casing is right.")
        print("Available languages:")
        for k in pairs(rp_languages) do print(k) end
        return
    end

    print(DarkRP.getMissingPhrases(args[1]))
end
if CLIENT then concommand.Add("darkrp_getphrases", getMissingPhrases) end

--[[---------------------------------------------------------------------------
Chat command translating
---------------------------------------------------------------------------]]
local chatCmdDescriptions = {}
function DarkRP.addChatCommandsLanguage(lang, tbl)
    chatCmdDescriptions[lang] = chatCmdDescriptions[lang] or {}

    table.Merge(chatCmdDescriptions[lang], tbl)
end

function DarkRP.getChatCommandDescription(name)
    local cmd = DarkRP.getChatCommand(name)
    return chatCmdDescriptions[selectedLanguage] and chatCmdDescriptions[selectedLanguage][name] or
        cmd and cmd.description or
        nil
end

local function getMissingCmdTranslations()
    local cmds = DarkRP.getSortedChatCommands()

    -- No commands have been translated
    if not chatCmdDescriptions[selectedLanguage] then return cmds end

    -- Remove translated commands and maintain keys
    local count = #cmds
    for i = 1, count do
        if chatCmdDescriptions[selectedLanguage][cmds[i].command] then
            cmds[i] = nil
        end
    end

    cmds = table.ClearKeys(cmds)

    return cmds
end

local function printMissingChatTranslations()
    local cmds = getMissingCmdTranslations()
    local text = {}

    local maxCmdLength = 0
    for _, v in pairs(cmds) do maxCmdLength = math.Max(maxCmdLength, string.len(v.command)) end

    for k, v in pairs(cmds) do
        text[k] = string.format([=[["%s"]%s=    "%s",]=], v.command, string.rep(' ', 4 + maxCmdLength - string.len(v.command)), v.description)
    end

    MsgC(Color(0, 255, 0), string.format("%s untranslated chat command descriptions!\n", #cmds))

    text = table.concat(text, "\n    ")
    SetClipboardText(text)

    MsgC(Color(0, 255, 0), "text copied to clipboard!\n")
end
if CLIENT then concommand.Add("darkrp_translateChatCommands", printMissingChatTranslations) end

--PATH gamemodes/starwarsrp/gamemode/modules/hud/sh_chatcommands.lua:
DarkRP.declareChatCommand{
    command = "admintell",
    description = "Send a private, very intimidating message to someone.",
    delay = 1.5,
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "admintellall",
    description = "Send a very intimidating message to everyone.",
    delay = 1.5
}

--PATH gamemodes/starwarsrp/gamemode/modules/fspectate/cl_init.lua:
FSpectate = {}

local stopSpectating, startFreeRoam
local isSpectating = false
local specEnt
local thirdperson = true
local isRoaming = false
local roamPos -- the position when roaming free
local roamVelocity = Vector(0)
local thirdPersonDistance = 100

/*---------------------------------------------------------------------------
Retrieve the current spectated player
---------------------------------------------------------------------------*/
function FSpectate.getSpecEnt()
    if isSpectating and not isRoaming then
        return IsValid(specEnt) and specEnt or nil
    else
        return nil
    end
end

/*---------------------------------------------------------------------------
startHooks
FAdmin tab buttons
---------------------------------------------------------------------------*/
hook.Add("Initialize", "FSpectate", function()
    surface.CreateFont("UiBold", {
        size = 16,
        weight = 800,
        antialias = true,
        shadow = false,
        font = "Verdana"})

    if not FAdmin then return end
    FAdmin.StartHooks["zzSpectate"] = function()
        FAdmin.Commands.AddCommand("Spectate", nil, "<Player>")

        -- Right click option
        FAdmin.ScoreBoard.Main.AddPlayerRightClick("Spectate", function(ply)
            if not IsValid(ply) then return end
            RunConsoleCommand("FSpectate", ply:UserID())
        end)

        local canSpectate = false
        local function calcAccess()
            CAMI.PlayerHasAccess(LocalPlayer(), "FSpectate", function(b, _)
                canSpectate = b
            end)
        end

        -- Spectate option in player menu
        FAdmin.ScoreBoard.Player:AddActionButton("Spectate", "fadmin/icons/spectate", Color(0, 200, 0, 255), function(ply) calcAccess() return canSpectate and ply ~= LocalPlayer() end, function(ply)
            if not IsValid(ply) then return end
            RunConsoleCommand("FSpectate", ply:UserID())
        end)
    end
end)

/*---------------------------------------------------------------------------
Get the thirdperson position
---------------------------------------------------------------------------*/
local function getThirdPersonPos(ent)
    local aimvector = LocalPlayer():GetAimVector()
    local startPos = ent:IsPlayer() and ent:GetShootPos() or ent:LocalToWorld(ent:OBBCenter())
    local endpos = startPos - aimvector * thirdPersonDistance

    local tracer = {
        start = startPos,
        endpos = endpos,
        filter = specEnt
    }

    local trace = util.TraceLine(tracer)

    return trace.HitPos + trace.HitNormal * 10
end

/*---------------------------------------------------------------------------
Get the CalcView table
---------------------------------------------------------------------------*/
local view = {}
local function getCalcView()
    if not isRoaming then
        if thirdperson then
            view.origin = getThirdPersonPos(specEnt)
            view.angles = LocalPlayer():EyeAngles()
        else
            view.origin = specEnt:IsPlayer() and specEnt:GetShootPos() or specEnt:LocalToWorld(specEnt:OBBCenter())
            view.angles = specEnt:IsPlayer() and specEnt:EyeAngles() or specEnt:GetAngles()
        end

        roamPos = view.origin
        view.drawviewer = false

        return view
    end

    view.origin = roamPos
    view.angles = LocalPlayer():EyeAngles()
    view.drawviewer = true

    return view
end

/*---------------------------------------------------------------------------
specCalcView
Override the view for the player to look through the spectated player's eyes
---------------------------------------------------------------------------*/
local function specCalcView(ply, origin, angles, fov)
    if not IsValid(specEnt) and not isRoaming then
        startFreeRoam()
        return
    end

    view = getCalcView()

    if IsValid(specEnt) then
        specEnt:SetNoDraw(not thirdperson)
    end

    return view
end

/*---------------------------------------------------------------------------
Find the right player to spectate
---------------------------------------------------------------------------*/
local function findNearestObject()
    local aimvec = LocalPlayer():GetAimVector()

    local fromPos = not isRoaming and IsValid(specEnt) and specEnt:EyePos() or roamPos

    local lookingAt = util.QuickTrace(fromPos, aimvec * 5000, LocalPlayer())
    local ent = lookingAt.Entity

    if IsValid(ent) then return ent end

    local foundPly, foundDot = nil, 0

    for _, ply in ipairs(player.GetAll()) do
        if not IsValid(ply) or ply == LocalPlayer() then continue end

        local pos = ply:GetShootPos()
        local dot = (pos - fromPos):GetNormalized():Dot(aimvec)

        -- Discard players you're not looking at
        if dot < 0.97 then continue end
        -- not a better alternative
        if dot < foundDot then continue end

        local trace = util.QuickTrace(fromPos, pos - fromPos, ply)

        if trace.Hit then continue end

        foundPly, foundDot = ply, dot
    end

    return foundPly
end

/*---------------------------------------------------------------------------
Spectate the person you're looking at while you're roaming
---------------------------------------------------------------------------*/
local function spectateLookingAt()
    local obj = findNearestObject()

    if not IsValid(obj) then return end

    isRoaming = false
    specEnt = obj

    net.Start("FSpectateTarget")
        net.WriteEntity(obj)
    net.SendToServer()
end

/*---------------------------------------------------------------------------
specBinds
Change binds to perform spectate specific tasks
---------------------------------------------------------------------------*/
-- Manual keysDown table, so I can return true in plyBindPress and still detect key presses
local keysDown = {}
local function specBinds(ply, bind, pressed)
    local key = input.LookupBinding(bind)

    if bind == "+jump" then
        stopSpectating()
        return true
    elseif bind == "+reload" and pressed then
        local pos = getCalcView().origin - Vector(0, 0, 64)
        RunConsoleCommand("FTPToPos", string.format("%d, %d, %d", pos.x, pos.y, pos.z),
            string.format("%d, %d, %d", roamVelocity.x, roamVelocity.y, roamVelocity.z))
        stopSpectating()
    elseif bind == "+attack" and pressed then
        if not isRoaming then
            startFreeRoam()
        else
            spectateLookingAt()
        end
        return true
    elseif bind == "+attack2" and pressed then
        if isRoaming then
            roamPos = roamPos + LocalPlayer():GetAimVector() * 500
            return true
        end
        thirdperson = not thirdperson

        return true
    elseif isRoaming and not LocalPlayer():KeyDown(IN_USE) then
        local keybind = string.upper(string.match(bind, "+([a-z A-Z 0-9]+)") or "")
        if not keybind or keybind == "USE" or keybind == "SHOWSCORES" or string.find(bind, "messagemode") then return end

        keysDown[keybind] = pressed

        return true
    elseif not isRoaming and thirdperson and (key == "MWHEELDOWN" or key == "MWHEELUP") then
        thirdPersonDistance = thirdPersonDistance + 10 * (key == "MWHEELDOWN" and 1 or -1)
    end
    -- Do not return otherwise, spectating admins should be able to move to avoid getting detected
end

/*---------------------------------------------------------------------------
Scoreboardshow
Set to main view when roaming, open on a player when spectating
---------------------------------------------------------------------------*/
local function fadminmenushow()
    if isRoaming then
        FAdmin.ScoreBoard.ChangeView("Main")
    elseif IsValid(specEnt) and specEnt:IsPlayer() then
        FAdmin.ScoreBoard.ChangeView("Main")
        FAdmin.ScoreBoard.ChangeView("Player", specEnt)
    end
end


/*---------------------------------------------------------------------------
RenderScreenspaceEffects
Draws the lines from players' eyes to where they are looking
---------------------------------------------------------------------------*/
local LineMat = Material("cable/new_cable_lit")
local linesToDraw = {}
local function lookingLines()
    if not linesToDraw[0] then return end

    render.SetMaterial(LineMat)

    cam.Start3D(view.origin, view.angles)
        for i = 0, #linesToDraw, 3 do
            render.DrawBeam(linesToDraw[i], linesToDraw[i + 1], 4, 0.01, 10, linesToDraw[i + 2])
        end
    cam.End3D()
end

/*---------------------------------------------------------------------------
gunpos
Gets the position of a player's gun
---------------------------------------------------------------------------*/
local function gunpos(ply)
    local wep = ply:GetActiveWeapon()
    if not IsValid(wep) then return ply:EyePos() end
    local att = wep:GetAttachment(1)
    if not att then return ply:EyePos() end
    return att.Pos
end

/*---------------------------------------------------------------------------
Spectate think
Free roaming position updates
---------------------------------------------------------------------------*/
local function specThink()
    local ply = LocalPlayer()

    -- Update linesToDraw
    local pls = player.GetAll()
    local lastPly = 0
    local skip = 0
    for i = 0, #pls - 1 do
        local p = pls[i + 1]
        if not IsValid(p) then continue end
        if not isRoaming and p == specEnt and not thirdperson then skip = skip + 3 continue end

        local tr = p:GetEyeTrace()
        local sp = gunpos(p)

        local pos = i * 3 - skip

        linesToDraw[pos] = tr.HitPos
        linesToDraw[pos + 1] = sp
        linesToDraw[pos + 2] = team.GetColor(p:Team())
        lastPly = i
    end

    -- Remove entries from linesToDraw that don't match with a player anymore
    for i = #linesToDraw, lastPly * 3 + 3, -1 do linesToDraw[i] = nil end

    if not isRoaming or keysDown["USE"] then return end

    local roamSpeed = 1000
    local aimVec = ply:GetAimVector()
    local direction
    local frametime = RealFrameTime()

    if keysDown["FORWARD"] then
        direction = aimVec
    elseif keysDown["BACK"] then
        direction = -aimVec
    end

    if keysDown["MOVELEFT"] then
        local right = aimVec:Angle():Right()
        direction = direction and (direction - right):GetNormalized() or -right
    elseif keysDown["MOVERIGHT"] then
        local right = aimVec:Angle():Right()
        direction = direction and (direction + right):GetNormalized() or right
    end

    if keysDown["SPEED"] then
        roamSpeed = 2500
    elseif keysDown["WALK"] or keysDown["DUCK"] then
        roamSpeed = 300
    end

    roamVelocity = (direction or Vector(0, 0, 0)) * roamSpeed

    roamPos = roamPos + roamVelocity * frametime
end

/*---------------------------------------------------------------------------
Draw help on the screen
---------------------------------------------------------------------------*/
local uiForeground, uiBackground = Color(240, 240, 255, 255), Color(20, 20, 20, 120)
local red = Color(255, 0, 0, 255)
local function drawHelp()
    local scrHalfH = math.floor(ScrH() / 2)
    draw.WordBox(2, 10, scrHalfH, "Left click: (Un)select player to spectate", "UiBold", uiBackground, uiForeground)
    draw.WordBox(2, 10, scrHalfH + 20, isRoaming and "Right click: quickly move forwards" or "Right click: toggle thirdperson", "UiBold", uiBackground, uiForeground)
    draw.WordBox(2, 10, scrHalfH + 40, "Jump: Stop spectating", "UiBold", uiBackground, uiForeground)
    draw.WordBox(2, 10, scrHalfH + 60, "Reload: Stop spectating and teleport", "UiBold", uiBackground, uiForeground)

    if FAdmin then
        draw.WordBox(2, 10, scrHalfH + 80, "Opening FAdmin's menu while spectating a player", "UiBold", uiBackground, uiForeground)
        draw.WordBox(2, 10, scrHalfH + 100, "\twill open their page!", "UiBold", uiBackground, uiForeground)
    end


    local target = findNearestObject()
    local pls = player.GetAll()
    for i = 1, #pls do
        local ply = pls[i]
        if not IsValid(ply) then continue end
        if not isRoaming and ply == specEnt then continue end

        local pos = ply:GetShootPos():ToScreen()
        if not pos.visible then continue end

        local x, y = pos.x, pos.y

        draw.RoundedBox(2, x, y - 6, 12, 12, team.GetColor(ply:Team()))
        draw.WordBox(2, x, y - 66, ply:Nick(), "UiBold", uiBackground, uiForeground)
        draw.WordBox(2, x, y - 46, "Health: " .. ply:Health(), "UiBold", uiBackground, uiForeground)
        draw.WordBox(2, x, y - 26, ply:GetUserGroup(), "UiBold", uiBackground, uiForeground)
    end

    if not isRoaming then return end

    if not IsValid(target) then return end

    local center = target:LocalToWorld(target:OBBCenter())
    local eyeAng = EyeAngles()
    local rightUp = eyeAng:Right() * 16 + eyeAng:Up() * 36
    local topRight = (center + rightUp):ToScreen()
    local bottomLeft = (center - rightUp):ToScreen()

    draw.RoundedBox(12, bottomLeft.x, bottomLeft.y, math.max(20, topRight.x - bottomLeft.x), topRight.y - bottomLeft.y, red)
    draw.WordBox(2, bottomLeft.x, bottomLeft.y + 12, "Left click to spectate!", "UiBold", uiBackground, uiForeground)
end

/*---------------------------------------------------------------------------
Start roaming free, rather than spectating a given player
---------------------------------------------------------------------------*/
startFreeRoam = function()
    roamPos = isSpectating and roamPos or LocalPlayer():GetShootPos()

    if IsValid(specEnt) then
        if specEnt:IsPlayer() then
            roamPos = thirdperson and getThirdPersonPos(specEnt) or specEnt:GetShootPos()
        end
        specEnt:SetNoDraw(false)
    end

    specEnt = nil
    isRoaming = true
    keysDown = {}
end

/*---------------------------------------------------------------------------
specEnt
Spectate a player
---------------------------------------------------------------------------*/
local function startSpectate(um)
    isRoaming = net.ReadBool()
    specEnt = net.ReadEntity()
    specEnt = IsValid(specEnt) and specEnt or nil

    if isRoaming then
        startFreeRoam()
    end

    isSpectating = true
    keysDown = {}

    hook.Add("CalcView", "FSpectate", specCalcView)
    hook.Add("PlayerBindPress", "FSpectate", specBinds)
    hook.Add("ShouldDrawLocalPlayer", "FSpectate", function() return isRoaming or thirdperson end)
    hook.Add("Think", "FSpectate", specThink)
    hook.Add("HUDPaint", "FSpectate", drawHelp)
    hook.Add("FAdmin_ShowFAdminMenu", "FSpectate", fadminmenushow)
    hook.Add("RenderScreenspaceEffects", "FSpectate", lookingLines)

    timer.Create("FSpectatePosUpdate", 0.5, 0, function()
        if not isRoaming then return end

        RunConsoleCommand("_FSpectatePosUpdate", roamPos.x, roamPos.y, roamPos.z)
    end)
end
net.Receive("FSpectate", startSpectate)

/*---------------------------------------------------------------------------
stopSpectating
Stop spectating a player
---------------------------------------------------------------------------*/
stopSpectating = function()
    hook.Remove("CalcView", "FSpectate")
    hook.Remove("PlayerBindPress", "FSpectate")
    hook.Remove("ShouldDrawLocalPlayer", "FSpectate")
    hook.Remove("Think", "FSpectate")
    hook.Remove("HUDPaint", "FSpectate")
    hook.Remove("FAdmin_ShowFAdminMenu", "FSpectate")
    hook.Remove("RenderScreenspaceEffects", "FSpectate")

    timer.Remove("FSpectatePosUpdate")

    if IsValid(specEnt) then
        specEnt:SetNoDraw(false)
    end

    RunConsoleCommand("FSpectate_StopSpectating")
    isSpectating = false
end

--PATH gamemodes/starwarsrp/gamemode/modules/deathpov/cl_init.lua:
local view = {
    origin = Vector(0, 0, 0),
    angles = Angle(0, 0, 0),
    fov = 90,
    znear = 1
}

local deathpov = gmod.GetGamemode().Config.deathpov
hook.Add("CalcView", "rp_deathPOV", function(ply, origin, angles, fov)
    -- Entity:Alive() is being slow as hell, we might actually see ourselves from third person for frame or two
    if not deathpov or ply:Health() > 0 then return end

    local Ragdoll = ply:GetRagdollEntity() or ply:GetNWEntity("playerRagdoll")
    if not IsValid(Ragdoll) then return end

    local head = Ragdoll:LookupAttachment("eyes")
    head = Ragdoll:GetAttachment(head)
    if not head or not head.Pos then return end

    if not Ragdoll.BonesRattled then
        Ragdoll.BonesRattled = true

        Ragdoll:InvalidateBoneCache()
        Ragdoll:SetupBones()

        local matrix

        for bone = 0, (Ragdoll:GetBoneCount() or 1) do
            if Ragdoll:GetBoneName(bone):lower():find("head") then
                matrix = Ragdoll:GetBoneMatrix(bone)
                break
            end
        end

        if IsValid(matrix) then
            matrix:SetScale(Vector(0, 0, 0))
        end
    end

    view.origin = head.Pos + head.Ang:Up() * 8
    view.angles = head.Ang

    return view
end)

--PATH gamemodes/starwarsrp/gamemode/modules/chat/cl_chatlisteners.lua:
--[[---------------------------------------------------------------------------
This module finds out for you who can see you talk or speak through the microphone
---------------------------------------------------------------------------]]

--[[---------------------------------------------------------------------------
Variables
---------------------------------------------------------------------------]]
local receivers
local currentChatText = {}
local receiverConfigs = {}
local currentConfig = {text = "", hearFunc = fn.Id} -- Default config is not loaded yet

--[[---------------------------------------------------------------------------
addChatReceiver
Add a chat command with specific receivers

prefix: the chat command itself ("/pm", "/ooc", "/me" are some examples)
text: the text that shows up when it says "Some people can hear you X"
hearFunc: a function(ply, splitText) that decides whether this player can or cannot hear you.
    return true if the player can hear you
           false if the player cannot
           nil if you want to prevent the text from showing up temporarily
---------------------------------------------------------------------------]]
function DarkRP.addChatReceiver(prefix, text, hearFunc)
    receiverConfigs[prefix] = {
        text = text,
        hearFunc = hearFunc
    }
end

--[[---------------------------------------------------------------------------
removeChatReceiver
Remove a chat command.

prefix: the command, like in addChatReceiver
---------------------------------------------------------------------------]]
function DarkRP.removeChatReceiver(prefix)
    receiverConfigs[prefix] = nil
end

--[[---------------------------------------------------------------------------
Draw the results to the screen
---------------------------------------------------------------------------]]
local function drawChatReceivers()
    if not receivers then return end

    local fontHeight = draw.GetFontHeight("DarkRPHUD1")
    local x, y = chat.GetChatBoxPos()
    y = y - fontHeight - 4

    local receiversCount = #receivers
    -- No one hears you
    if receiversCount == 0 then
        draw.WordBox(2, x, y, DarkRP.getPhrase("hear_noone", currentConfig.text), "DarkRPHUD1", Color(0,0,0,160), Color(255,0,0,255))
        return
    -- Everyone hears you
    elseif receiversCount == player.GetCount() - 1 then
        draw.WordBox(2, x, y, DarkRP.getPhrase("hear_everyone"), "DarkRPHUD1", Color(0,0,0,160), Color(0,255,0,255))
        return
    end

    draw.WordBox(2, x, y - (receiversCount * (fontHeight + 4)), DarkRP.getPhrase("hear_certain_persons", currentConfig.text), "DarkRPHUD1", Color(0,0,0,160), Color(0,255,0,255))
    for i = 1, receiversCount, 1 do
        if not IsValid(receivers[i]) then
            receivers[i] = receivers[#receivers]
            receivers[#receivers] = nil
            continue
        end

        draw.WordBox(2, x, y - (i - 1) * (fontHeight + 4), receivers[i]:Nick(), "DarkRPHUD1", Color(0, 0, 0, 160), color_white)
    end
end

--[[---------------------------------------------------------------------------
Find out who could hear the player if they were to speak now
---------------------------------------------------------------------------]]
local function chatGetRecipients()
    if not currentConfig then return end

    receivers = {}
    for _, ply in ipairs(player.GetAll()) do
        local hidePly = hook.Run("chatHideRecipient", ply)
        if not IsValid(ply) or ply == LocalPlayer() or ply:GetNoDraw() or hidePly then continue end

        local val = currentConfig.hearFunc(ply, currentChatText)

        -- Return nil to disable the chat recipients temporarily.
        if val == nil then
            receivers = nil
            return
        elseif val == true then
            table.insert(receivers, ply)
        end
    end
end

--[[---------------------------------------------------------------------------
Called when the player starts typing
---------------------------------------------------------------------------]]
local function startFind()
    local shouldDraw = hook.Call("HUDShouldDraw", GAMEMODE, "DarkRP_ChatReceivers")
    if shouldDraw == false then return end

    currentConfig = receiverConfigs[""]
    hook.Add("Think", "DarkRP_chatRecipients", chatGetRecipients)
    hook.Add("HUDPaint", "DarkRP_DrawChatReceivers", drawChatReceivers)
end
hook.Add("StartChat", "DarkRP_StartFindChatReceivers", startFind)

--[[---------------------------------------------------------------------------
Called when the player stops typing
---------------------------------------------------------------------------]]
local function stopFind()
    hook.Remove("Think", "DarkRP_chatRecipients")
    hook.Remove("HUDPaint", "DarkRP_DrawChatReceivers")
end
hook.Add("FinishChat", "DarkRP_StopFindChatReceivers", stopFind)

--[[---------------------------------------------------------------------------
Find out which chat command the user is typing
---------------------------------------------------------------------------]]
local function findConfig(text)
    local split = string.Explode(' ', text)
    local prefix = string.lower(split[1])

    currentChatText = split

    currentConfig = receiverConfigs[prefix] or receiverConfigs[""]
end
hook.Add("ChatTextChanged", "DarkRP_FindChatRecipients", findConfig)


--[[---------------------------------------------------------------------------
Default chat receievers. If you want to add your own ones, don't add them to this file. Add them to a clientside module file instead.
---------------------------------------------------------------------------]]
-- Load after the custom languages have been loaded
local function loadChatReceivers()
    -- Default talk chat receiver has no prefix
    DarkRP.addChatReceiver("", DarkRP.getPhrase("talk"), function(ply)
        if GAMEMODE.Config.alltalk then return nil end

        return LocalPlayer():GetPos():DistToSqr(ply:GetPos()) <
            GAMEMODE.Config.talkDistance * GAMEMODE.Config.talkDistance
    end)

    DarkRP.addChatReceiver("/ooc", DarkRP.getPhrase("speak_in_ooc"), function(ply) return true end)
    DarkRP.addChatReceiver("//", DarkRP.getPhrase("speak_in_ooc"), function(ply) return true end)
    DarkRP.addChatReceiver("/a", DarkRP.getPhrase("speak_in_ooc"), function(ply) return true end)
    DarkRP.addChatReceiver("/w", DarkRP.getPhrase("whisper"), function(ply) return LocalPlayer():GetPos():DistToSqr(ply:GetPos()) < GAMEMODE.Config.whisperDistance * GAMEMODE.Config.whisperDistance end)
    DarkRP.addChatReceiver("/y", DarkRP.getPhrase("yell"), function(ply) return LocalPlayer():GetPos():DistToSqr(ply:GetPos()) < GAMEMODE.Config.yellDistance * GAMEMODE.Config.yellDistance end)
    DarkRP.addChatReceiver("/me", DarkRP.getPhrase("perform_your_action"), function(ply) return LocalPlayer():GetPos():DistToSqr(ply:GetPos()) < GAMEMODE.Config.meDistance * GAMEMODE.Config.meDistance end)
    DarkRP.addChatReceiver("/g", DarkRP.getPhrase("talk_to_your_group"), function(ply)
        for _, func in pairs(GAMEMODE.DarkRPGroupChats) do
            if func(LocalPlayer()) and func(ply) then
                return true
            end
        end
        return false
    end)


    DarkRP.addChatReceiver("/pm", "PM", function(ply, text)
        if not isstring(text[2]) then return false end
        text[2] = string.lower(tostring(text[2]))

        return string.find(string.lower(ply:Nick()), text[2], 1, true) ~= nil or
            string.find(string.lower(ply:SteamName()), text[2], 1, true) ~= nil or
            string.lower(ply:SteamID()) == text[2]
    end)

    --[[---------------------------------------------------------------------------
        Voice chat receivers
        ---------------------------------------------------------------------------]]
    local voiceDistance = GM.Config.voiceDistance * GM.Config.voiceDistance
    DarkRP.addChatReceiver("speak", DarkRP.getPhrase("speak"), function(ply)
        if not LocalPlayer().DRPIsTalking then return nil end
        if LocalPlayer():GetPos():DistToSqr(ply:GetPos()) > voiceDistance then return false end

        return not GAMEMODE.Config.dynamicvoice or ply:isInRoom()
    end)
end
hook.Add("loadCustomDarkRPItems", "loadChatListeners", loadChatReceivers)

--[[---------------------------------------------------------------------------
Called when the player starts using their voice
---------------------------------------------------------------------------]]
local function startFindVoice(ply)
    if ply ~= LocalPlayer() then return end

    local shouldDraw = hook.Call("HUDShouldDraw", GAMEMODE, "DarkRP_ChatReceivers")
    if shouldDraw == false then return end

    currentConfig = receiverConfigs["speak"]
    hook.Add("Think", "DarkRP_chatRecipients", chatGetRecipients)
    hook.Add("HUDPaint", "DarkRP_DrawChatReceivers", drawChatReceivers)
end
hook.Add("PlayerStartVoice", "DarkRP_VoiceChatReceiverFinder", startFindVoice)

--[[---------------------------------------------------------------------------
Called when the player stops using their voice
---------------------------------------------------------------------------]]
local function stopFindVoice(ply)
    if ply ~= LocalPlayer() then return end

    stopFind()
end
hook.Add("PlayerEndVoice", "DarkRP_VoiceChatReceiverFinder", stopFindVoice)

--PATH gamemodes/starwarsrp/gamemode/modules/base/sh_createitems.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/base/sh_checkitems.lua:
--[[
The base elements are shared by every custom item
]]
local baseSchema = tc.checkTable{
    buttonColor =
        tc.addHint(
            tc.optional(tc.tableOf(isnumber)),
            "The buttonColor must be a Color value."
        ),

    category =
        tc.addHint(
            tc.optional(isstring),
            "The category must be the name of an existing category!"
        ),

    customCheck =
        tc.addHint(
            tc.optional(isfunction),
            "The customCheck must be a function."
        ),

    CustomCheckFailMsg =
        tc.addHint(
            tc.optional(isstring, isfunction),
            "The CustomCheckFailMsg must be either a string or a function."
        ),

    sortOrder =
        tc.addHint(
            tc.optional(isnumber),
            "The sortOrder must be a number."
        ),

    label =
        tc.addHint(
            tc.optional(isstring),
            "The label must be a valid string."
        ),
}

--[[
Properties shared by anything buyable
]]
local buyableSchema = fn.FAnd{baseSchema, tc.checkTable{
    allowed =
        tc.addHint(
            tc.optional(tc.tableOf(isnumber), isnumber),
            "The allowed field must be either an existing team or a table of existing teams.",
            {"Is there a job here that doesn't exist (anymore)?"}
        ),

    getPrice =
        tc.addHint(
            tc.optional(isfunction),
            "The getPrice must be a function."
        ),

    model =
        tc.addHint(
            isstring,
            "The model must be valid."
        ),

    price =
        tc.addHint(
            function(v, tbl) return isnumber(v) or isfunction(tbl.getPrice) end,
            "The price must be an existing number or (for advanced users) the getPrice field must be a function."
        ),

    spawn =
        tc.addHint(
            tc.optional(isfunction),
            "The spawn must be a function."
        ),
    allowPurchaseWhileDead =
        tc.addHint(
            tc.default(false),
            "The allowPurchaseWhileDead must be either true or false"
        )
}}

-- The command of an entity must be unique
local uniqueEntity = function(cmd, tbl)
    for _, v in pairs(DarkRPEntities) do
        if v.cmd ~= cmd then continue end

        return
            false,
            "This entity does not have a unique command.",
            {
                "There must be some other entity that has the same thing for 'cmd'.",
                "Fix this by changing the 'cmd' field of your entity to something else."
            }
    end

    return true
end

-- The command of a job must be unique
local uniqueJob = function(v, tbl)
    local job = DarkRP.getJobByCommand(v)

    if not job then return true end

    return
        false,
        "This job does not have a unique command.",
        {
            "There must be some other job that has the same command.",
            "Fix this by changing the 'command' of your job to something else."
        }
end

--[[
Validate jobs
]]
DarkRP.validateJob = fn.FAnd{baseSchema, tc.checkTable{
    name =
        tc.addHint(
            isstring,
            "The name must be a valid string."
        ),

    color =
        tc.addHint(
            tc.tableOf(isnumber),
            "The color must be a Color value.",
            {"Color values look like this: Color(r, g, b, a), where r, g, b and a are numbers between 0 and 255."}
        ),

    model =
        tc.addHint(
            fn.FOr{isstring, tc.nonEmpty(tc.tableOf(isstring))},
            "The model must either be a table of correct model strings or a single correct model string.",
            {
                "This error could happens when the model does not exist on the server.",
                "Are you sure the model path is right?",
                "Is the model from an addon that is not properly installed?"
            }
        ),

    description =
        tc.addHint(
            isstring,
            "The description must be a string."
        ),

    weapons =
        tc.addHint(
            tc.optional(tc.tableOf(isstring)),
            "The weapons must be a valid table of strings.",
            {"Example: weapons = {\"med_kit\", \"weapon_bugbait\"},"}
        ),

    command =
        fn.FAnd
        {
            tc.addHint(
                isstring,
                "The command must be a string."
            ),
            uniqueJob
        },

    max =
        tc.addHint(
            fn.FAnd{isnumber, fp{fn.Lte, 0}},
            "The max must be a number greater than or equal to zero.",
            {
                "Zero means infinite.",
                "A decimal between 0 and 1 is seen as a percentage."
            }
        ),

    salary =
        tc.addHint(
            fn.FAnd{isnumber, fp{fn.Lte, 0}},
            "The salary must be a number and it must be greater than zero."
        ),

    admin =
        tc.default(0,
            tc.addHint(
                fn.FAnd{isnumber, fp{fn.Lte, 0}, fp{fn.Gte, 2}},
                "The admin value must be a number and it must be greater than or equal to zero and smaller than three."
            )
        ),

    vote =
        tc.addHint(
            tc.optional(isbool),
            "The vote must be either true or false."
        ),

    ammo =
        tc.addHint(
            tc.optional(tc.tableOf(isnumber)),
            "The ammo must be a table containing numbers.",
            {"See example on https://darkrp.miraheze.org/wiki/DarkRP:CustomJobFields"}
        ),

    hasLicense =
        tc.addHint(
            tc.optional(isbool),
            "The hasLicense must be either true or false."
        ),

    NeedToChangeFrom =
        tc.addHint(
            tc.optional(tc.tableOf(isnumber), isnumber),
            "The NeedToChangeFrom must be either an existing team or a table of existing teams",
            {"Is there a job here that doesn't exist (anymore)?"}
        ),

    modelScale =
        tc.addHint(
            tc.optional(isnumber),
            "The modelScale must be a number."
        ),

    maxpocket =
        tc.addHint(
            tc.optional(isnumber),
            "The maxPocket must be a number."
        ),

    maps =
        tc.addHint(
            tc.optional(tc.tableOf(isstring)),
            "The maps value must be a table of valid map names."
        ),

    candemote =
        tc.default(true,
            tc.addHint(
                isbool,
                "The candemote value must be either true or false."
            )
        ),

    mayor =
        tc.addHint(
            tc.optional(isbool),
            "The mayor value must be either true or false."
        ),

    chief =
        tc.addHint(
            tc.optional(isbool),
            "The chief value must be either true or false."
        ),

    medic =
        tc.addHint(
            tc.optional(isbool),
            "The medic value must be either true or false."
        ),

    cook =
        tc.addHint(
            tc.optional(isbool),
            "The cook value must be either true or false."
        ),

    hobo =
        tc.addHint(
            tc.optional(isbool),
            "The hobo value must be either true or false."
        ),

    playerClass =
        tc.addHint(
            tc.optional(isstring),
            "The playerClass must be a valid string."
        ),

    CanPlayerSuicide =
        tc.addHint(
            tc.optional(isfunction),
            "The CanPlayerSuicide must be a function."
        ),

    PlayerCanPickupWeapon =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerCanPickupWeapon must be a function."
        ),

    PlayerDeath =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerDeath must be a function."
        ),

    PlayerLoadout =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerLoadout must be a function."
        ),

    PlayerSelectSpawn =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerSelectSpawn must be a function."
        ),

    PlayerSetModel =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerSetModel must be a function."
        ),

    PlayerSpawn =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerSpawn must be a function."
        ),

    PlayerSpawnProp =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerSpawnProp must be a function."
        ),

    RequiresVote =
        tc.addHint(
            tc.optional(isfunction),
            "The RequiresVote must be a function."
        ),

    ShowSpare1 =
        tc.addHint(
            tc.optional(isfunction),
            "The ShowSpare1 must be a function."
        ),

    ShowSpare2 =
        tc.addHint(
            tc.optional(isfunction),
            "The ShowSpare2 must be a function."
        ),

    canStartVote =
        tc.addHint(
            tc.optional(isfunction),
            "The canStartVote must be a function."
        ),

    canStartVoteReason =
        tc.addHint(
            tc.optional(isstring, isfunction),
            "The canStartVoteReason must be either a string or a function."
        ),
}}

--[[
Validate shipments
]]
DarkRP.validateShipment = fn.FAnd{buyableSchema, tc.checkTable{
    name =
        tc.addHint(
            isstring,
            "The name must be a valid string."
        ),

    entity =
        tc.addHint(
            isstring, "The entity of the shipment must be a string."
        ),

    amount =
        tc.addHint(
            fn.FAnd{isnumber, fp{fn.Lte, 0}}, "The amount must be a number and it must be greater than zero."
        ),

    separate =
        tc.addHint(
            tc.optional(isbool), "the separate field must be either true or false."
        ),

    pricesep =
        tc.addHint(
            function(v, tbl) return not tbl.separate or isnumber(v) and v >= 0 end,
            "The pricesep must be a number and it must be greater than or equal to zero."
        ),

    noship =
        tc.addHint(
            tc.optional(isbool),
            "The noship must be either true or false."
        ),

    shipmodel =
        tc.addHint(
            tc.optional(isstring),
            "The shipmodel must be a valid model."
        ),

    weight =
        tc.addHint(
            tc.optional(isnumber),
            "The weight must be a number."
        ),

    spareammo =
        tc.addHint(
            tc.optional(isnumber),
            "The spareammo must be a number."
        ),

    clip1 =
        tc.addHint(
            tc.optional(isnumber),
            "The clip1 must be a number."
        ),

    clip2 =
        tc.addHint(
            tc.optional(isnumber),
            "The clip2 must be a number."
        ),

    shipmentClass =
        tc.addHint(
            tc.optional(isstring),
            "The shipmentClass must be a string."
        ),

    onBought =
        tc.addHint(
            tc.optional(isfunction),
            "The onBought must be a function."
        ),

}}

--[[
Validate vehicles
]]
DarkRP.validateVehicle = fn.FAnd{buyableSchema, tc.checkTable{
    name =
        tc.addHint(
            isstring,
            "The name of the vehicle must be a string."
        ),

    distance =
        tc.addHint(
            tc.optional(isnumber),
            "The distance must be a number."
        ),

    angle =
        tc.addHint(
            tc.optional(isangle),
            "The distance must be a valid Angle."
        ),
}}

--[[
Validate Entities
]]
DarkRP.validateEntity = fn.FAnd{buyableSchema, tc.checkTable{
    ent =
        tc.addHint(
            isstring,
            "The ent field must be a string."
        ),

    max =
        tc.addHint(
            function(v, tbl) return isnumber(v) or isfunction(tbl.getMax) end,
            "The max must be an existing number or (for advanced users) the getMax field must be a function."
        ),

    cmd =
        fn.FAnd
        {
            tc.addHint(isstring, "The cmd must be a valid string."),
            uniqueEntity
        },

    name =
        tc.addHint(
            isstring,
            "The name must be a valid string."
        ),

    allowTools =
        tc.default(false,
            tc.addHint(
                tc.optional(isbool),
                "The allowTools must be either true or false."
            )
        ),

    delay =
        tc.addHint(
            tc.optional(isnumber),
            "The delay must be a number."
        ),
}}


-- Checks whether a team already has an agenda assigned.
-- Jobs cannot have multiple agendas.

local overlappingAgendaCheck = function(t, tbl)
    local agenda = DarkRP.getAgendas()[t]

    -- Team being -1 means the job is disabled
    if agenda == nil or t == -1 then return true end

    local teamName = team.GetName(t)
    local err = "At least one job has multiple agendas assigned to them"
    local hints = {
        string.format([[The problem lies with the job called "%s"]], teamName),
        string.format([[It is assigned to agendas "%s" and "%s"]], agenda.Title or "unknown", tbl.Title or "unknown"),
        [[A job can only have ONE agenda. Otherwise things would become confusing, since only ONE agenda is always drawn on the screen.]]
    }

    if agenda.Title == tbl.Title then
        table.insert(hints, "The titles of the two agendas are the same. It looks like perhaps you've made the same agenda more than once.")
        table.insert(hints, "Removing one of them should get rid of this error.")
    end

    return false, err, hints
end

--[[
Validate Agendas
]]
local managerNumberCheck = tc.addHint(
    isnumber,
    "The Manager must either be a single team or a non-empty table of existing teams.",
    {"Is there a job here that doesn't exist (anymore)?"}
)

DarkRP.validateAgenda = tc.checkTable{
    Title =
        tc.addHint(
            isstring,
            "The title must be a string."
        ),

    -- Custom function to ensure the right error message is thrown
    Manager = function(manager, tbl)
            -- Check whether the manager is an existing team
            -- that does not already have an agenda assigned
            if isnumber(manager) then
                return fn.FAnd{overlappingAgendaCheck}(manager, tbl)

            -- Check whether the manager is a table of existing teams
            -- and that none of the teams already have agendas assigned
            elseif istable(manager) then
                return tc.nonEmpty(
                    tc.tableOf(
                        fn.FAnd{managerNumberCheck, overlappingAgendaCheck}
                    )
                )(manager, tbl)
            end

            return managerNumberCheck(manager, tbl)
        end,
    Listeners =
        tc.default({}, -- Default to empty table
            -- Checks for a table of valid teams that do not already have an
            -- agenda assigned
            fn.FAnd{
                tc.addHint(
                    tc.tableOf(isnumber),
                    "The Listeners must be a table of existing teams.",
                    {
                        "Is there a job here that doesn't exist (anymore)?",
                        "Are you trying to have multiple manager jobs in this agenda? In that case you must put the list of manager jobs in curly braces.",
                        [[Like so: DarkRP.createAgenda("Some agenda", {TEAM_MANAGER1, TEAM_MANAGER2}, {TEAM_LISTENER1, TEAM_LISTENER2})]]
                    }
                ),
                tc.tableOf(overlappingAgendaCheck)
            }
        )
}

--[[
Validate Categories
]]
DarkRP.validateCategory = tc.checkTable{
    name =
        tc.addHint(
            isstring,
            "The name must be a string."
        ),

    categorises =
        tc.addHint(
            tc.oneOf{"jobs", "entities", "shipments", "weapons", "vehicles", "ammo"},
            [[The categorises must be one of "jobs", "entities", "shipments", "weapons", "vehicles", "ammo"]],
            {
                "Mind that this is case sensitive.",
                "Also mind the quotation marks."
            }
        ),

    startExpanded =
        tc.addHint(
            isbool,
            "The startExpanded must be either true or false."
        ),

    color =
        tc.addHint(
            tc.tableOf(isnumber),
            "The color must be a Color value."
        ),

    canSee =
        tc.addHint(
            tc.optional(isfunction),
            "The canSee must be a function."
        ),

    sortOrder =
        tc.addHint(
            tc.optional(isnumber),
            "The sortOrder must be a number."
        ),
}

--PATH gamemodes/starwarsrp/gamemode/modules/base/cl_util.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/base/cl_gamemode_functions.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/base/cl_gamemode_functions.lua:
local GUIToggled = false
local mouseX, mouseY = ScrW() / 2, ScrH() / 2
function GM:ShowSpare1()
    local jobTable = LocalPlayer():getJobTable()

    -- We need to check for the existance of jobTable here, because in very rare edge cases, the player's team isn't set, when the getJobTable-function is called here.
    if jobTable and jobTable.ShowSpare1 then
        return jobTable.ShowSpare1(LocalPlayer())
    end

    GUIToggled = not GUIToggled

    if GUIToggled then
        gui.SetMousePos(mouseX, mouseY)
    else
        mouseX, mouseY = gui.MousePos()
    end
    gui.EnableScreenClicker(GUIToggled)
end

function GM:ShowSpare2()
    local jobTable = LocalPlayer():getJobTable()

    -- We need to check for the existance of jobTable here, because in very rare edge cases, the player's team isn't set, when the getJobTable-function is called here.
    if jobTable and jobTable.ShowSpare2 then
        return jobTable.ShowSpare2(LocalPlayer())
    end

    DarkRP.toggleF4Menu()
end

function GM:PlayerStartVoice(ply)
    if ply == LocalPlayer() then
        ply.DRPIsTalking = true
        return -- Not the original rectangle for yourself! ugh!
    end
    self.Sandbox.PlayerStartVoice(self, ply)
end

function GM:PlayerEndVoice(ply)
    if ply == LocalPlayer() then
        ply.DRPIsTalking = false
        return
    end

    self.Sandbox.PlayerEndVoice(self, ply)
end

function GM:OnPlayerChat()
end

local FKeyBinds = {
    ["gm_showhelp"] = "ShowHelp",
    ["gm_showteam"] = "ShowTeam",
    ["gm_showspare1"] = "ShowSpare1",
    ["gm_showspare2"] = "ShowSpare2"
}

function GM:PlayerBindPress(ply, bind, pressed)
    self.Sandbox.PlayerBindPress(self, ply, bind, pressed)

    local bnd = string.match(string.lower(bind), "gm_[a-z]+[12]?")
    if bnd and FKeyBinds[bnd] then
        hook.Call(FKeyBinds[bnd], GAMEMODE)
    end

    if not self.Config.deadvoice and not ply:Alive() and string.find(string.lower(bind), "voicerecord") then return true end
end

function GM:InitPostEntity()
    hook.Call("teamChanged", GAMEMODE, GAMEMODE.DefaultTeam, GAMEMODE.DefaultTeam)
end

function GM:teamChanged(before, after)
end

local function OnChangedTeam(um)
    local oldTeam, newTeam = um:ReadShort(), um:ReadShort()
    hook.Call("teamChanged", GAMEMODE, oldTeam, newTeam) -- backwards compatibility
    hook.Call("OnPlayerChangedTeam", GAMEMODE, LocalPlayer(), oldTeam, newTeam)
end
usermessage.Hook("OnChangedTeam", OnChangedTeam)

timer.Simple(0, function() GAMEMODE.ShowTeam = DarkRP.openKeysMenu end)

--PATH gamemodes/starwarsrp/gamemode/modules/base/cl_drawfunctions.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/config/jobrelated.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/config/addentities.lua:
DarkRP.createShipment("Desert eagle", {
    model = "models/weapons/w_pist_deagle.mdl",
    entity = "weapon_deagle2",
    price = 215,
    amount = 10,
    separate = true,
    pricesep = 215,
    noship = true,
    allowed = {TEAM_GUN},
    category = "Pistols",
})

DarkRP.createShipment("Fiveseven", {
    model = "models/weapons/w_pist_fiveseven.mdl",
    entity = "weapon_fiveseven2",
    price = 0,
    amount = 10,
    separate = true,
    pricesep = 205,
    noship = true,
    allowed = {TEAM_GUN},
    category = "Pistols",
})

DarkRP.createShipment("Glock", {
    model = "models/weapons/w_pist_glock18.mdl",
    entity = "weapon_glock2",
    price = 0,
    amount = 10,
    separate = true,
    pricesep = 160,
    noship = true,
    allowed = {TEAM_GUN},
    category = "Pistols",
})

DarkRP.createShipment("P228", {
    model = "models/weapons/w_pist_p228.mdl",
    entity = "weapon_p2282",
    price = 0,
    amount = 10,
    separate = true,
    pricesep = 185,
    noship = true,
    allowed = {TEAM_GUN},
    category = "Pistols",
})

DarkRP.createShipment("AK47", {
    model = "models/weapons/w_rif_ak47.mdl",
    entity = "weapon_ak472",
    price = 2450,
    amount = 10,
    separate = false,
    pricesep = nil,
    noship = false,
    allowed = {TEAM_GUN},
    category = "Rifles",
})

DarkRP.createShipment("MP5", {
    model = "models/weapons/w_smg_mp5.mdl",
    entity = "weapon_mp52",
    price = 2200,
    amount = 10,
    separate = false,
    pricesep = nil,
    noship = false,
    allowed = {TEAM_GUN},
    category = "Rifles",
})

DarkRP.createShipment("M4", {
    model = "models/weapons/w_rif_m4a1.mdl",
    entity = "weapon_m42",
    price = 2450,
    amount = 10,
    separate = false,
    pricesep = nil,
    noship = false,
    allowed = {TEAM_GUN},
    category = "Rifles",
})

DarkRP.createShipment("Mac 10", {
    model = "models/weapons/w_smg_mac10.mdl",
    entity = "weapon_mac102",
    price = 2150,
    amount = 10,
    separate = false,
    pricesep = nil,
    noship = false,
    allowed = {TEAM_GUN}
})

DarkRP.createShipment("Pump shotgun", {
    model = "models/weapons/w_shot_m3super90.mdl",
    entity = "weapon_pumpshotgun2",
    price = 1750,
    amount = 10,
    separate = false,
    pricesep = nil,
    noship = false,
    allowed = {TEAM_GUN},
    category = "Shotguns",
})

DarkRP.createShipment("Sniper rifle", {
    model = "models/weapons/w_snip_g3sg1.mdl",
    entity = "ls_sniper",
    price = 3750,
    amount = 10,
    separate = false,
    pricesep = nil,
    noship = false,
    allowed = {TEAM_GUN},
    category = "Snipers",
})

DarkRP.createEntity("Drug lab", {
    ent = "drug_lab",
    model = "models/props_lab/crematorcase.mdl",
    price = 400,
    max = 3,
    cmd = "buydruglab",
    allowed = {TEAM_GANG, TEAM_MOB}
})

DarkRP.createEntity("Money printer", {
    ent = "money_printer",
    model = "models/props_c17/consolebox01a.mdl",
    price = 1000,
    max = 2,
    cmd = "buymoneyprinter"
})

DarkRP.createEntity("Tip Jar", {
    ent = "darkrp_tip_jar",
    model = "models/props_lab/jar01a.mdl",
    price = 0,
    max = 2,
    cmd = "tipjar",
    allowTools = true,
})

DarkRP.createEntity("Gun lab", {
    ent = "gunlab",
    model = "models/props_c17/TrapPropeller_Engine.mdl",
    price = 500,
    max = 1,
    cmd = "buygunlab",
    allowed = TEAM_GUN
})

if not DarkRP.disabledDefaults["modules"]["hungermod"] then
    DarkRP.createEntity("Microwave", {
        ent = "microwave",
        model = "models/props/cs_office/microwave.mdl",
        price = 400,
        max = 1,
        cmd = "buymicrowave",
        allowed = TEAM_COOK
    })
end

DarkRP.createCategory{
    name = "Other",
    categorises = "entities",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 255,
}

DarkRP.createCategory{
    name = "Other",
    categorises = "shipments",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 255,
}

DarkRP.createCategory{
    name = "Rifles",
    categorises = "shipments",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 100,
}

DarkRP.createCategory{
    name = "Shotguns",
    categorises = "shipments",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 101,
}

DarkRP.createCategory{
    name = "Snipers",
    categorises = "shipments",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 102,
}

DarkRP.createCategory{
    name = "Pistols",
    categorises = "weapons",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 100,
}

DarkRP.createCategory{
    name = "Other",
    categorises = "weapons",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 255,
}

DarkRP.createCategory{
    name = "Other",
    categorises = "vehicles",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 255,
}

--PATH addons/!jobs/lua/darkrp_language/chatcommands.lua:
--[[---------------------------------------------------------------------------
English (example) Chat command translation file
---------------------------------------------------------------------------

This file contains translations for chat command descriptions.
On the left side you see the chat command, on the right side you see the description.
When translating these descriptions, make sure to leave the quotation marks (" ") and commas intact!

= Warning =
Sometimes when DarkRP is updated, new chat commands are added, changed and/or removed.
By default, chat commands that aren't translated will use the English description.
Chat command translations that don't exist are ignored.


= How to translate missing chat commands =
1. Start the server
2. Join it
3. In your console, enter the following command:
    darkrp_translateChatCommands
4. Come back to this file
5. Paste where it says "-- Add new chat command translations under this line:"

= Note =
Make sure the language code is right at the bottom of this file

= Using a language =
Make sure the convar gmod_language is set to your language code. You can do that in a server CFG file.
---------------------------------------------------------------------------]]

local descriptions = {
    ["/"]                     = "Global server chat.",
    ["a"]                     = "Global server chat.",
    ["addjailpos"]            = "Add a jail position where you're standing.",
    ["addlaw"]                = "Add a law to the laws board.",
    ["addowner"]              = "Invite someone to co-own the door you're looking at.",
    ["addspawn"]              = "Add a spawn position for some job (use the command name of the job as argument)",
    ["addzombie"]             = "Add a zombie spawn pos.",
    ["advert"]                = "Advertise something to everyone in the server.",
    ["agenda"]                = "Set the agenda.",
    ["ao"]                    = "Invite someone to co-own the door you're looking at.",
    ["broadcast"]             = "Broadcast something as a mayor.",
    ["buy"]                   = "Buy a pistol",
    ["buyammo"]               = "Purchase ammo",
    ["buydruglab"]            = "Purchase a Drug lab",
    ["buygunlab"]             = "Purchase a Gun lab",
    ["buymoneyprinter"]       = "Purchase a Money printer",
    ["buyshipment"]           = "Buy a shipment",
    ["buyvehicle"]            = "Buy a vehicle",
    ["channel"]               = "Tune into a radio channel.",
    ["check"]                 = "Write a cheque for a specific person.",
    ["cheque"]                = "Write a cheque for a specific person.",
    ["chief"]                 = "Become Civil Protection Chief.",
    ["citizen"]               = "Become Citizen.",
    ["cp"]                    = "Become Civil Protection and skip the vote.",
    ["cr"]                    = "Cry for help, the police will come (hopefully)!",
    ["credits"]               = "Send the DarkRP credits to someone.",
    ["demote"]                = "Demote a player from their job",
    ["demotelicense"]         = "Start a vote to get someone's license revoked.",
    ["disablestorm"]          = "Disable meteor storms.",
    ["disablezombie"]         = "Disable zombie mod.",
    ["dropmoney"]             = "Drop money on the floor.",
    ["enablestorm"]           = "Enable meteor storms.",
    ["enablezombie"]          = "Enable zombie mod.",
    ["g"]                     = "Group chat.",
    ["gangster"]              = "Become Gangster.",
    ["give"]                  = "Give money to the player you're looking at.",
    ["givelicense"]           = "Give someone a gun license",
    ["gundealer"]             = "Become Gun Dealer.",
    ["hitprice"]              = "Set the price of your hits",
    ["hobo"]                  = "Become Hobo.",
    ["jailpos"]               = "Reset jail positions and create a new one at your position.",
    ["job"]                   = "Change your job name",
    ["jobswitch"]             = "Switch jobs with the player you're looking at",
    ["lockdown"]              = "Start a lockdown. Everyone will have to stay inside",
    ["lottery"]               = "Start a lottery",
    ["makeshipment"]          = "Create a shipment from a dropped weapon.",
    ["maxzombie"]             = "Set the maximum amount of zombies that can be in a level.",
    ["maxzombies"]            = "Set the maximum amount of zombies that can be in a level.",
    ["mayor"]                 = "Become Mayor and skip the vote.",
    ["me"]                    = "Chat roleplay to say you're doing things that you can't show otherwise.",
    ["medic"]                 = "Become Medic.",
    ["mobboss"]               = "Become Mob boss.",
    ["moneydrop"]             = "Drop money on the floor.",
    ["name"]                  = "Set your RP name",
    ["nick"]                  = "Set your RP name",
    ["ooc"]                   = "Global server chat.",
    ["placelaws"]             = "Place a laws board.",
    ["pm"]                    = "Send a private message to someone.",
    ["price"]                 = "Set the price of the microwave or gunlab you're looking at",
    ["radio"]                 = "Say something through the radio.",
    ["removelaw"]             = "Remove a law from the laws board.",
    ["removeletters"]         = "Remove all of your letters.",
    ["removeowner"]           = "Remove an owner from the door you're looking at.",
    ["removespawn"]           = "Remove a spawn position for some job (use the command name of the job as argument)",
    ["removezombie"]          = "Remove a zombie spawn pos by id (get id with /showzombie).",
    ["requesthit"]            = "Request a hit from the player you're looking at",
    ["requestlicense"]        = "Request a gun license.",
    ["ro"]                    = "Remove an owner from the door you're looking at.",
    ["rpname"]                = "Set your RP name",
    ["setprice"]              = "Set the price of the microwave or gunlab you're looking at",
    ["setspawn"]              = "Reset the spawn position for some job and place a new one at your position (use the command name of the job as argument)",
    ["showzombie"]            = "Show zombie spawn positions.",
    ["sleep"]                 = "Go to sleep or wake up",
    ["splitshipment"]         = "Split the shipment you're looking at.",
    ["switchjob"]             = "Switch jobs with the player you're looking at",
    ["switchjobs"]            = "Switch jobs with the player you're looking at",
    ["teamban"]               = "Ban someone from getting a certain job",
    ["teamunban"]             = "Undo a teamban",
    ["title"]                 = "Set the title of the door you're looking at.",
    ["togglegroupownable"]    = "Set this door group ownable.",
    ["toggleown"]             = "Own or unown the door you're looking at.",
    ["toggleownable"]         = "Toggle ownability status on this door.",
    ["toggleteamownable"]     = "Toggle this door ownable by a given team.",
    ["type"]                  = "Type a letter.",
    ["unlockdown"]            = "Stop a lockdown",
    ["unownalldoors"]         = "Sell all of your doors.",
    ["unwanted"]              = "Remove a player's wanted status.",
    ["votecp"]                = "Vote to become Civil Protection.",
    ["votemayor"]             = "Vote to become Mayor.",
    ["w"]                     = "Say something in whisper voice.",
    ["wake"]                  = "Go to sleep or wake up",
    ["wakeup"]                = "Go to sleep or wake up",
    ["wanted"]                = "Make a player wanted. This is needed to get them arrested.",
    ["warrant"]               = "Get a search warrant for a certain player. With this warrant you can search their house",
    ["write"]                 = "Write a letter.",
    ["y"]                     = "Yell something out loud.",
    ["zombiemax"]             = "Set the maximum amount of zombies that can be in a level.",

    -- Add new chat command translations under this line:

}

--
DarkRP.addChatCommandsLanguage("en", descriptions)

--PATH addons/!jobs/lua/darkrp_modules/weaponsettings/sh_weaponsettings.lua:
return gluapack()()
--PATH addons/!jobs/lua/darkrp_customthings/doorgroups.lua:
--[[---------------------------------------------------------------------------
Door groups
---------------------------------------------------------------------------
The server owner can set certain doors as owned by a group of people, identified by their jobs.


HOW TO MAKE A DOOR GROUP:
AddDoorGroup("NAME OF THE GROUP HERE, you will see this when looking at a door", Team1, Team2, team3, team4, etc.)
---------------------------------------------------------------------------]]


-- Example: AddDoorGroup("Cops and Mayor only", TEAM_CHIEF, TEAM_POLICE, TEAM_MAYOR)
-- Example: AddDoorGroup("Gundealer only", TEAM_GUN)

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_customize_ui_bench.lua:

local ARC9ScreenScale = ARC9.ScreenScale

-- given fov and distance solve apparent size
local function solvetriangle(angle, dist)
    local a = angle / 2
    local b = dist
    return b * math.tan(a) * 2
end

local hits_1 = {}
local hits_3 = {}

local function rollhit(radius)
    local anglerand = math.Rand(0, 360)
    local dist = math.Rand(0, radius)

    local hit_x = math.sin(anglerand) * dist
    local hit_y = math.cos(anglerand) * dist

    return {x = hit_x, y = hit_y}
end

local function rollallhits(self, range_3, range_1)

    hits_1 = {}
    hits_3 = {}

    local ang = self:GetValue("Spread") * 10 / 360

    local radius_1 = solvetriangle(ang, range_1)
    local radius_3 = solvetriangle(ang, range_3)

    local hitcount = math.Clamp(math.max(math.Round(self:GetCapacity(self:GetUBGL()) / 4), math.Round(self:GetValue("Num") * 2)), 10, 20)

    for i = 1, hitcount do
        table.insert(hits_1, rollhit(radius_1))
    end

    for i = 1, hitcount do
        table.insert(hits_3, rollhit(radius_3))
    end
end

-- local recoil_hits = {}

-- function SWEP:RollRecoilHit(shot, lastx, lasty)
--     local dir = self:GetRecoilPatternDirection(shot)

--     dir = math.rad(dir)

--     recoilup = math.sin(dir)
--     recoilside = math.cos(dir)

--     local randomrecoilup = math.Rand(-1, 0)
--     local randomrecoilside = math.Rand(-1, 1)

--     recoilup = recoilup * self:GetProcessedValue("RecoilUp")
--     recoilside = recoilside * self:GetProcessedValue("RecoilSide")

--     randomrecoilup = randomrecoilup * self:GetProcessedValue("RecoilRandomUp")
--     randomrecoilside = randomrecoilside * self:GetProcessedValue("RecoilRandomSide")

--     recoilup = recoilup + randomrecoilup
--     recoilside = recoilside + randomrecoilside

--     recoilup = recoilup * self:GetProcessedValue("Recoil")
--     recoilside = recoilside * self:GetProcessedValue("Recoil")

--     recoil_hits[shot] = {
--         x = recoilup + randomrecoilup + lastx,
--         y = recoilside + randomrecoilside + lasty
--     }
-- end

-- function SWEP:RollRecoil()
--     recoil_hits = {}

--     recoil_hits[1] = {
--         x = 0,
--         y = 0,
--     }

--     for i = 2, math.min(self:GetMaxClip1(), 100) do
--         local lastx = recoil_hits[i - 1].x
--         local lasty = recoil_hits[i - 1].y

--         self:RollRecoilHit(i, lastx, lasty)
--     end
-- end

local bullseye = Material("arc9/bullseye.png", "mips smooth")
local target_ipsc = Material("arc9/target_ipsc.png", "mips smooth")
local mat_hit = Material("arc9/hit.png", "mips smooth")
local mat_hit_dot = Material("arc9/hit_dot.png", "mips smooth")
local ranger_range = 0

local mat_body = Material("arc9/body.png", "mips smooth")
local mat_body_arms = Material("arc9/body_arms.png", "mips smooth")
local mat_body_head = Material("arc9/body_head.png", "mips smooth")
local mat_body_chest = Material("arc9/body_chest.png", "mips smooth")
local mat_body_stomach = Material("arc9/body_stomach.png", "mips smooth")
local mat_body_legs = Material("arc9/body_legs.png", "mips smooth")

local stk_clr = {
    [1] = Color(75, 25, 25),
    [2] = Color(40, 20, 20),
    [3] = Color(50, 50, 50),
    [4] = Color(75, 75, 75),
    [5] = Color(100, 100, 100),
    [6] = Color(120, 120, 120),
    [7] =  Color(140, 140, 140),
    [8] = Color(160, 160, 160),
    [9] = Color(200, 200, 200),
}

local function getstkcolor(stk)
    if stk_clr[stk] then
        return stk_clr[stk]
    else
        return stk_clr[9]
    end
end

function SWEP:CreateHUD_Bench()
    local bg = self.CustomizeHUD
	local imperial = GetConVar("arc9_imperial"):GetBool()

    self:ClearTabPanel()

    self:CreateHUD_Stats()

    if !self:GetProcessedValue("PrimaryBash", true) and !self:GetProcessedValue("Throwable", true) and !self:GetProcessedValue("ShootEnt") then -- no ballistics
        local tp = vgui.Create("DScrollPanel", bg)
        local width = math.min(ARC9ScreenScale(550), ScrW())
        tp:SetSize(width, ARC9ScreenScale(100))
        tp:SetPos(ScrW()*0.5 - width*0.5, ScrH()-ARC9ScreenScale(275))
        tp:SetAlpha(0)
        tp:AlphaTo(255, 0.2, 0, nil)

        local cornercut = ARC9ScreenScale(3.5)

        tp.Paint = function(self2, w, h)
            surface.SetDrawColor(ARC9.GetHUDColor("bg_menu", 200))
            -- surface.DrawRect(0, 0, w, h)
            draw.NoTexture()
            surface.DrawPoly({{x = cornercut, y = h},{x = 0, y = h-cornercut}, {x = 0, y = cornercut},{x = cornercut, y = 0}, {x = w-cornercut, y = 0},{x = w, y = cornercut}, {x = w, y = h-cornercut}, {x = w-cornercut, y = h}})
        end

        -- local scroll_preset = tp:GetVBar()
        -- scroll_preset.Paint = function() end
        -- scroll_preset.btnUp.Paint = function(span, w, h)
        -- end
        -- scroll_preset.btnDown.Paint = function(span, w, h)
        -- end
        -- scroll_preset.btnGrip.Paint = PaintScrollBar

        self.TabPanel = tp

        -- self:RollRecoil()

        -- local recoilchart = vgui.Create("DButton", tp)
        -- recoilchart:SetSize(ARC9ScreenScale(220), ARC9ScreenScale(220))
        -- recoilchart:SetPos(ARC9ScreenScale(310), ARC9ScreenScale(0))
        -- recoilchart:SetText("")
        -- recoilchart.DoClick = function(self2)
        --     self:RollRecoil()
        -- end
        -- recoilchart.Paint = function(self2, w, h)
        --     surface.SetDrawColor(ARC9.GetHUDColor("bg", 50))
        --     surface.DrawRect(0, 0, w, h)

        --     surface.SetMaterial(target_ipsc)
        --     surface.SetDrawColor(ARC9.GetHUDColor("fg", 75))
        --     surface.DrawTexturedRect(0, 0, w, h)

        --     local scale = ARC9ScreenScale(8)

        --     for i = 1, math.min(self:GetMaxClip1(), 100) do
        --         local hit = recoil_hits[i]
        --         local x = -hit.x * scale + (w / 2)
        --         local y = -hit.y * scale + (h / 2)

        --         local s = ARC9ScreenScale(12)

        --         surface.SetMaterial(mat_hit)
        --         surface.SetDrawColor(ARC9.GetHUDColor("fg", 75))
        --         if i == 1 then
        --             surface.SetDrawColor(Color(255, 0, 0, 75))
        --         end
        --         surface.DrawTexturedRect(x - (s / 2), y - (s / 2), s, s)

        --         if i < math.min(self:GetMaxClip1(), 100) then
        --             local hit2 = recoil_hits[i + 1]
        --             local x2 = -hit2.x * scale + (w / 2)
        --             local y2 = -hit2.y * scale + (h / 2)

        --             surface.DrawLine(x, y, x2, y2)
        --         end
        --     end

        --     local txt_bottom = "ARCTIC SYSTEMS RECOIL TEST"
        --     surface.SetFont("ARC9_6")
        --     local tbw = surface.GetTextSize(txt_bottom)
        --     surface.SetTextColor(ARC9.GetHUDColor("fg"))
        --     surface.SetTextPos((w - tbw) / 2, h - ARC9ScreenScale(12))
        --     surface.DrawText(txt_bottom)
        -- end

        local dmgpanel = vgui.Create("DPanel", tp)
        dmgpanel:SetSize(ARC9ScreenScale(100), ARC9ScreenScale(100))
        dmgpanel:SetPos(0, 0)
        dmgpanel.Paint = function(span, w, h)
            if !IsValid(self) then return end

            surface.SetDrawColor(ARC9.GetHUDColor("bg"))
            -- surface.DrawRect(0, 0, w, h)
            draw.NoTexture()
            surface.DrawPoly({{x = cornercut, y = h},{x = 0, y = h-cornercut}, {x = 0, y = cornercut},{x = cornercut, y = 0}, {x = w-cornercut, y = 0},{x = w, y = cornercut}, {x = w, y = h-cornercut}, {x = w-cornercut, y = h}})

            local dmgv = self:GetDamageAtRange(ranger_range)

            if self:GetProcessedValue("DistributeDamage") then
                dmgv = dmgv
            end

            local bodydamage = self:GetProcessedValue("BodyDamageMults")

            local dmg_head = dmgv * self:GetProcessedValue("HeadshotDamage") * (bodydamage[HITGROUP_HEAD] or 2)
            local dmg_chest = dmgv * self:GetProcessedValue("ChestDamage") * (bodydamage[HITGROUP_CHEST] or 1)
            local dmg_stomach = dmgv * self:GetProcessedValue("StomachDamage") * (bodydamage[HITGROUP_STOMACH] or 1)
            local dmg_legs = dmgv * self:GetProcessedValue("LegDamage") * ((bodydamage[HITGROUP_LEFTLEG] or 0.25) + (bodydamage[HITGROUP_RIGHTLEG] or 0.25)) / 2
            local dmg_arms = dmgv * self:GetProcessedValue("ArmDamage") * ((bodydamage[HITGROUP_LEFTARM] or 0.25) + (bodydamage[HITGROUP_RIGHTARM] or 0.25)) / 2

            local stk_head = math.ceil(100 / dmg_head)
            local stk_chest = math.ceil(100 / dmg_chest)
            local stk_stomach = math.ceil(100 / dmg_stomach)
            local stk_legs = math.ceil(100 / dmg_legs)
            local stk_arms = math.ceil(100 / dmg_arms)

            -- draw the body

            local body_w = ARC9ScreenScale(30)
            local body_h = ARC9ScreenScale(80)
            local body_x = (w - body_w) / 2
            local body_y = (h - body_h) / 2

            surface.SetDrawColor(Color(150, 150, 150, 255))
            surface.SetMaterial(mat_body)
            surface.DrawTexturedRect(body_x, body_y, body_w, body_h)

            local txt_dmg_head = tostring(math.Round(dmg_head, 0)) .. " " .. ARC9:GetPhrase("unit.dmg")
            local txt_dmg_chest = tostring(math.Round(dmg_chest, 0)) .. " " .. ARC9:GetPhrase("unit.dmg")
            local txt_dmg_stomach = tostring(math.Round(dmg_stomach, 0)) .. " " .. ARC9:GetPhrase("unit.dmg")
            local txt_dmg_legs = tostring(math.Round(dmg_legs, 0)) .. " " .. ARC9:GetPhrase("unit.dmg")
            local txt_dmg_arms = tostring(math.Round(dmg_arms, 0)) .. " " .. ARC9:GetPhrase("unit.dmg")

            surface.SetDrawColor(getstkcolor(stk_head))
            surface.SetMaterial(mat_body_head)
            surface.DrawTexturedRect(body_x, body_y, body_w, body_h)

            surface.SetDrawColor(getstkcolor(stk_chest))
            surface.SetMaterial(mat_body_chest)
            surface.DrawTexturedRect(body_x, body_y, body_w, body_h)

            surface.SetDrawColor(getstkcolor(stk_stomach))
            surface.SetMaterial(mat_body_stomach)
            surface.DrawTexturedRect(body_x, body_y, body_w, body_h)

            surface.SetDrawColor(getstkcolor(stk_legs))
            surface.SetMaterial(mat_body_legs)
            surface.DrawTexturedRect(body_x, body_y, body_w, body_h)

            surface.SetDrawColor(getstkcolor(stk_arms))
            surface.SetMaterial(mat_body_arms)
            surface.DrawTexturedRect(body_x, body_y, body_w, body_h)

            surface.SetFont("ARC9_6")
            surface.SetTextColor(ARC9.GetHUDColor("fg"))
            surface.SetDrawColor(ARC9.GetHUDColor("fg"))

            surface.SetTextPos(ARC9ScreenScale(4), ARC9ScreenScale(12))
            surface.DrawText(txt_dmg_head)

            surface.DrawLine(ARC9ScreenScale(4), ARC9ScreenScale(18), ARC9ScreenScale(38+8), ARC9ScreenScale(18))

            surface.SetTextPos(ARC9ScreenScale(4), ARC9ScreenScale(25))
            surface.DrawText(txt_dmg_chest)

            surface.DrawLine(ARC9ScreenScale(4), ARC9ScreenScale(25 + 6), ARC9ScreenScale(35+8), ARC9ScreenScale(25 + 6))

            surface.SetTextPos(ARC9ScreenScale(4), ARC9ScreenScale(35))
            surface.DrawText(txt_dmg_stomach)

            surface.DrawLine(ARC9ScreenScale(4), ARC9ScreenScale(35 + 6), ARC9ScreenScale(40+8), ARC9ScreenScale(35 + 6))

            surface.SetTextPos(ARC9ScreenScale(4), ARC9ScreenScale(50))
            surface.DrawText(txt_dmg_arms)

            surface.DrawLine(ARC9ScreenScale(4), ARC9ScreenScale(50 + 6), ARC9ScreenScale(27+8), ARC9ScreenScale(50 + 6))

            surface.SetTextPos(ARC9ScreenScale(4), ARC9ScreenScale(70))
            surface.DrawText(txt_dmg_legs)

            surface.DrawLine(ARC9ScreenScale(4), ARC9ScreenScale(70 + 6), ARC9ScreenScale(30+8), ARC9ScreenScale(70 + 6))

            local txt_tr = tostring(self:GetProcessedValue("Num")) .. "x " .. ARC9:GetPhrase("unit.projectiles")
            local trw = surface.GetTextSize(txt_tr)
            surface.SetTextPos(w - trw - ARC9ScreenScale(2), ARC9ScreenScale(10))
            surface.DrawText(txt_tr)

            local txt_corner = ARC9:GetPhrase("customize.bench.dummy") or ""
            local tw = surface.GetTextSize(txt_corner)
            surface.SetTextPos((w - tw) / 2, ARC9ScreenScale(1))
            surface.DrawText(txt_corner)

			local impm = imperial and "yard" or "meter"
			local impv = imperial and 1.0936 or 1

            local txt_bottom = (ARC9:GetPhrase("customize.bench.effect") or "") .. " " .. tostring(math.Round(ARC9.HUToM * impv * ranger_range, 0)) .. ARC9:GetPhrase("unit." .. impm)
            local tbw = surface.GetTextSize(txt_bottom)
            surface.SetTextPos((w - tbw) / 2, h - ARC9ScreenScale(8))
            surface.DrawText(txt_bottom)
        end

        local ranger = vgui.Create("DPanel", tp)
        local width2 = math.min(ARC9ScreenScale(200), ScrW() / 3)
        ranger:SetSize(width2, ARC9ScreenScale(100))
        ranger:SetPos(ARC9ScreenScale(100) + width / 22, 0)
        ranger.Paint = function(self2, w, h)
            if !IsValid(self) then return end

            surface.SetDrawColor(ARC9.GetHUDColor("bg"))
            -- surface.DrawRect(0, 0, w, h)
            draw.NoTexture()
            surface.DrawPoly({{x = cornercut, y = h},{x = 0, y = h-cornercut}, {x = 0, y = cornercut},{x = cornercut, y = 0}, {x = w-cornercut, y = 0},{x = w, y = cornercut}, {x = w, y = h-cornercut}, {x = w-cornercut, y = h}})

            local sweetspot = self:GetProcessedValue("SweetSpot", true)

            local range_min = self:GetValue("RangeMin")
            local range_max = self:GetValue("RangeMax")
			
            -- local range_min = imperial and (self:GetValue("RangeMin")) or self:GetValue("RangeMin")
            -- local range_max = imperial and (self:GetValue("RangeMax")) or self:GetValue("RangeMax")
            local range_sweet = self:GetValue("SweetSpotRange")

            local dmg_max = self:GetDamageAtRange(range_min)
            local dmg_min = self:GetDamageAtRange(range_max)
            local dmg_sweet = self:GetValue("SweetSpotDamage")

            surface.SetDrawColor(ARC9.GetHUDColor("fg", 75))

            ranger_range = range_min

            local dmg_diff = math.abs(dmg_max - dmg_min)
            local actual_minimum_damage = math.min(dmg_min, dmg_max)
            if sweetspot then
                dmg_diff = math.max(dmg_diff, math.abs(dmg_max - dmg_sweet), math.abs(dmg_min - dmg_sweet))
                actual_minimum_damage = math.min(actual_minimum_damage, dmg_sweet)
            end

            local range_min_x = (w / 5)
            local range_max_x = 4 * (w / 5)
            local range_sweetspot_x = 0

            local range_min_y = 3 * h / 4
            local range_max_y = 3 * h / 4

            local dmg_scale = h / 100
            if dmg_diff > 0 then
                dmg_scale = h * 0.5 / dmg_diff
            end

            if sweetspot and dmg_sweet > dmg_max and dmg_sweet > dmg_min then
                -- sweet spot is top of scale
                if dmg_max > dmg_min then
                    -- max range (right) is bottom of scale
                    range_min_y = h * 0.75 - dmg_scale * (dmg_max - dmg_min)
                elseif dmg_max < dmg_min then
                    -- min range (left) is bottom of scale
                    range_max_y = h * 0.75 - dmg_scale * (dmg_min - dmg_max)
                end
            elseif sweetspot and dmg_sweet < dmg_max and dmg_sweet < dmg_min then
                -- sweet spot is bottom of scale
                range_min_y = h * 0.75 - dmg_scale * (dmg_max - dmg_sweet)
                range_max_y = h * 0.75 - dmg_scale * (dmg_min - dmg_sweet)
            else
                -- sweet spot doesn't exist or is in the middle. scale is unaffected
                if dmg_max > dmg_min then
                    range_min_y = h / 4
                elseif dmg_max < dmg_min then
                    range_max_y = h / 4
                end
            end

            if range_min == 0 then
                range_min_x = 0
            end

            surface.DrawLine(range_min_x, 0, range_min_x, h)
            surface.DrawLine(range_max_x, 0, range_max_x, h)
            if sweetspot then
                range_sweetspot_x = Lerp((range_sweet - range_min) / (range_max - range_min), range_min_x, range_max_x)
                surface.DrawLine(range_sweetspot_x, 0, range_sweetspot_x, h)
            end

            surface.SetDrawColor(ARC9.GetHUDColor("fg"))

            -- Draw range line
            surface.DrawLine(0, range_min_y, range_min_x, range_min_y)
            surface.DrawLine(range_max_x, range_max_y, w, range_max_y)
            -- if sweetspot and dmg_max != dmg_min then
            --     local f = h * Lerp((math.max(dmg_max, dmg_min) - math.min(dmg_max, dmg_min)) / math.max(dmg_max, dmg_min, dmg_sweet), 0.75, 0.25)
            --     if dmg_max > dmg_min then
            --         surface.DrawLine(0, f, range_min_x, f)
            --         surface.DrawLine(range_max_x, range_max_y, w, range_max_y)
            --     elseif dmg_max < dmg_min then
            --         local f = h * Lerp((dmg_max - dmg_min) / math.max(dmg_min, dmg_sweet), 0.25, 0.75)
            --         surface.DrawLine(0, range_min_y, range_min_x, range_min_y)
            --         surface.DrawLine(range_max_x, f, w, f)
            --     end
            -- else
            --     surface.DrawLine(0, range_min_y, range_min_x, range_min_y)
            --     surface.DrawLine(range_max_x, range_max_y, w, range_max_y)
            -- end

            local segments = 50

            local dmg_values = {
                [0] = dmg_max
            }

            for i = 1, segments do
                local range_at_i = Lerp(i / segments, range_min, range_max)
                local dmg_at_i = self:GetDamageAtRange(range_at_i)
                dmg_values[i] = dmg_at_i
            end

            for i = 1, segments do
                local dmg_at_i = dmg_values[i - 1]
                local dmg_at_i2 = dmg_values[i]

                if dmg_at_i then
                    local x1 = Lerp((i - 1) / segments, range_min_x, range_max_x)
                    local x2 = Lerp(i / segments, range_min_x, range_max_x)

                    local y1 = 3 * (h / 4) - (dmg_scale * (dmg_at_i - actual_minimum_damage))
                    local y2 = 3 * (h / 4) - (dmg_scale * (dmg_at_i2 - actual_minimum_damage))

                    surface.DrawLine(x1, y1, x2, y2)
                end
            end

            local mouse_x, mouse_y = input.GetCursorPos()
            mouse_x, mouse_y = self2:ScreenToLocal(mouse_x, mouse_y)

            local draw_rangetext = true

            if mouse_x > 0 and mouse_x < w then
                if mouse_y > 0 and mouse_y < h then
                    local range = 0

                    local range_m_x = 0

                    if mouse_x < range_min_x then
                        range = range_min
                        range_m_x = range_min_x
                    elseif mouse_x > range_max_x then
                        range = range_max
                        range_m_x = range_max_x
                    else
                        local d = (mouse_x - range_min_x) / (range_max_x - range_min_x)
                        range = Lerp(d, range_min, range_max)
                        range_m_x = mouse_x
                    end

                    ranger_range = range

                    local dmg = self:GetDamageAtRange(range)

                    local txt_dmg1 = tostring(math.Round(dmg)) .. " " .. ARC9:GetPhrase("unit.dmg")

                    if self:GetValue("Num") > 1 then
                        txt_dmg1 = math.Round(dmg * self:GetValue("Num")) .. "-" .. txt_dmg1
                    end

                    surface.SetTextColor(ARC9.GetHUDColor("fg"))
                    surface.DrawLine(range_m_x, 0, range_m_x, h)

                    surface.SetFont("ARC9_8")
                    surface.SetTextColor(ARC9.GetHUDColor("fg"))
                    local txt_dmg1_w = surface.GetTextSize(txt_dmg1)
                    surface.SetTextPos((w / 5) - txt_dmg1_w - (ARC9ScreenScale(2)), ARC9ScreenScale(1))
                    surface.DrawText(txt_dmg1)

                    local txt_range1 = self:RangeUnitize(range)

                    local txt_range1_w = surface.GetTextSize(txt_range1)
                    surface.SetTextPos((w / 5) - txt_range1_w - (ARC9ScreenScale(2)), ARC9ScreenScale(1 + 8))
                    surface.DrawText(txt_range1)

                    draw_rangetext = false
                end
            end


            if draw_rangetext then
                local txt_dmg1 = tostring(math.Round(dmg_max)) .. " " .. ARC9:GetPhrase("unit.dmg")

                if self:GetValue("Num") > 1 then
                    txt_dmg1 = math.Round(dmg_max * self:GetValue("Num")) .. "-" .. txt_dmg1
                end

                surface.SetFont("ARC9_8")
                surface.SetTextColor(ARC9.GetHUDColor("fg"))
                local txt_dmg1_w = surface.GetTextSize(txt_dmg1)
                surface.SetTextPos((w / 5) - txt_dmg1_w - (ARC9ScreenScale(2)), ARC9ScreenScale(1))
                surface.DrawText(txt_dmg1)

                local txt_range1 = self:RangeUnitize(range_min)

                local txt_range1_w = surface.GetTextSize(txt_range1)
                surface.SetTextPos((w / 5) - txt_range1_w - (ARC9ScreenScale(2)), ARC9ScreenScale(1 + 8))
                surface.DrawText(txt_range1)

                local txt_dmg2 = tostring(math.Round(dmg_min)) .. " " .. ARC9:GetPhrase("unit.dmg")

                if self:GetValue("Num") > 1 then
                    txt_dmg2 = math.Round(dmg_min * self:GetValue("Num")) .. "-" .. txt_dmg2
                end

                surface.SetTextPos(4 * (w / 5) + (ARC9ScreenScale(2)), ARC9ScreenScale(1))
                surface.DrawText(txt_dmg2)

                local txt_range2 = self:RangeUnitize(range_max)

                surface.SetTextPos(4 * (w / 5) + (ARC9ScreenScale(2)), ARC9ScreenScale(1 + 8))
                surface.DrawText(txt_range2)

                if sweetspot then
                    local txt_dmg3 = tostring(math.Round(dmg_sweet)) .. " " .. ARC9:GetPhrase("unit.dmg")
                    if self:GetValue("Num") > 1 then
                        txt_dmg3 = math.Round(dmg_sweet * self:GetValue("Num")) .. "-" .. txt_dmg3
                    end
                    local txt_dmg3_w = surface.GetTextSize(txt_dmg3)
                    local txt_range3 = self:RangeUnitize(range_sweet)
                    local txt_range3_w = surface.GetTextSize(txt_range3)

                    surface.SetFont("ARC9_8")
                    surface.SetTextColor(ARC9.GetHUDColor("fg"))
                    if range_sweetspot_x < w * 0.5 then
                        surface.SetTextPos(range_sweetspot_x + (ARC9ScreenScale(2)), ARC9ScreenScale(1))
                        surface.DrawText(txt_dmg3)
                        surface.SetTextPos(range_sweetspot_x + (ARC9ScreenScale(2)), ARC9ScreenScale(1 + 8))
                        surface.DrawText(txt_range3)
                    else
                        surface.SetTextPos(range_sweetspot_x - txt_dmg3_w - (ARC9ScreenScale(2)), ARC9ScreenScale(1))
                        surface.DrawText(txt_dmg3)
                        surface.SetTextPos(range_sweetspot_x - txt_range3_w - (ARC9ScreenScale(2)), ARC9ScreenScale(1 + 8))
                        surface.DrawText(txt_range3)
                    end
                end
            end

            local txt_corner = ARC9:GetPhrase("customize.bench.ballistics") or ""
            surface.SetFont("ARC9_6")
            local tw = surface.GetTextSize(txt_corner)
            surface.SetTextColor(ARC9.GetHUDColor("fg"))
            surface.SetTextPos((w - tw) / 2, h - ARC9ScreenScale(8))
            surface.DrawText(txt_corner)
        end

        local range_3 = math.max(math.Round(self:GetValue("RangeMax") / 25) * 25, 50) --self.Range * self:GetBuff_Mult("Mult_Range")
        local range_1 = math.max(math.Round(range_3 / 3 / 25) * 25, 15) --(self.RangeMin or 0) * self:GetBuff_Mult("Mult_RangeMin")

        if range_1 == 0 then
            range_1 = range_3 * 0.5
        end

        rollallhits(self, range_3, range_1)

        local ballisticchart = vgui.Create("DButton", tp)
        ballisticchart:SetSize(ARC9ScreenScale(200), ARC9ScreenScale(100))
        ballisticchart:SetPos(tp:GetWide()-ARC9ScreenScale(200), ARC9ScreenScale(0))
        ballisticchart:SetText("")
        ballisticchart.DoClick = function(self2)
            rollallhits(self, range_3, range_1)
        end
        ballisticchart.Paint = function(self2, w, h)
            if !IsValid(self) then return end

            local col = ARC9.GetHUDColor("bg")
            if self2:IsHovered() then
                self.CustomizeHints["customize.hint.select"] = "customize.hint.recalculate"
                col = ARC9.GetHUDColor("hi", 70)
            end

            surface.SetDrawColor(col)
            -- surface.DrawRect(0, 0, w, h)
            draw.NoTexture()
            surface.DrawPoly({{x = cornercut, y = h},{x = 0, y = h-cornercut}, {x = 0, y = cornercut},{x = cornercut, y = 0}, {x = w-cornercut, y = 0},{x = w, y = cornercut}, {x = w, y = h-cornercut}, {x = w-cornercut, y = h}})

            local s = w / 2
            local s2 = ARC9ScreenScale(10)

            local range_1_txt = self:RangeUnitize(range_1)
            local range_3_txt = self:RangeUnitize(range_3)

            surface.SetMaterial(bullseye)
            surface.SetDrawColor(ARC9.GetHUDColor("fg", 50))
            surface.DrawTexturedRect(0, 0, s, s)

            local r_1_x, r_1_y = self2:LocalToScreen(0, 0)

            render.SetScissorRect(r_1_x, r_1_y, r_1_x + s, r_1_y + s, true)

            for _, hit in ipairs(hits_1) do
                if self:GetValue("Num") > 1 then
                    surface.SetMaterial(mat_hit_dot)
                else
                    surface.SetMaterial(mat_hit)
                end
                surface.SetDrawColor(ARC9.GetHUDColor("fg"))
                surface.DrawTexturedRect((s / 2) + (hit.x * s) - (s2 / 2), (s / 2) + (hit.y * s) - (s2 / 2), s2, s2)
            end

            render.SetScissorRect(r_1_x, r_1_y, r_1_x + s, r_1_y + s, false)

            surface.SetFont("ARC9_10")
            -- local range_1_txtw = surface.GetTextSize(range_1_txt)

            surface.SetTextColor(ARC9.GetHUDColor("fg"))
            surface.SetTextPos(ARC9ScreenScale(4), h - ARC9ScreenScale(16))
            surface.DrawText(range_1_txt)

            surface.SetMaterial(bullseye)
            surface.SetDrawColor(ARC9.GetHUDColor("fg", 50))
            surface.DrawTexturedRect(s, 0, s, s)

            render.SetScissorRect(r_1_x + s, r_1_y, r_1_x + (s * 2), r_1_y + s, true)

            for _, hit in ipairs(hits_3) do
                if self:GetValue("Num") > 1 then
                    surface.SetMaterial(mat_hit_dot)
                else
                    surface.SetMaterial(mat_hit)
                end
                surface.SetDrawColor(ARC9.GetHUDColor("fg"))
                surface.DrawTexturedRect(s + (s / 2) + (hit.x * s) - (s2 / 2), (s / 2) + (hit.y * s) - (s2 / 2), s2, s2)
            end

            render.SetScissorRect(r_1_x, r_1_y, r_1_x + s, r_1_y + s, false)

            surface.SetFont("ARC9_10")
            local range_3_txtw = surface.GetTextSize(range_3_txt)

            surface.SetTextPos(w - range_3_txtw - ARC9ScreenScale(2), h - ARC9ScreenScale(16))
            surface.DrawText(range_3_txt)

            local txt_corner = ARC9:GetPhrase("customize.bench.precision")
            surface.SetFont("ARC9_6")
            local tw = surface.GetTextSize(txt_corner)
            surface.SetTextPos((w - tw) / 2, h - ARC9ScreenScale(8))
            surface.DrawText(txt_corner)
        end
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_customize_ui_presets.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_drawmodel.lua:
function SWEP:ShouldLOD()
    local owner = self:GetOwner()
    if LocalPlayer() == owner then return 0 end

    local dsquared

    if IsValid(owner) then
        dsquared = EyePos():DistToSqr(owner:GetPos())
    else
        dsquared = EyePos():DistToSqr(self:GetPos()) * 2 -- make lod appear sooner on dropped gunss
    end

    if dsquared >= 800000 then
        return 2
    elseif dsquared >= 400000 then
        return 1.5
    elseif dsquared >= 200000 then -- middle value for tpik lod
        return 1
    else
        return 0
    end
end

function SWEP:DrawCustomModel(wm, custompos, customang)
    local owner = self:GetOwner()

    if !wm and !IsValid(owner) then return end
    if !wm and owner:IsNPC() then return end
    if wm and ARC9.RTScopeRender then return end
    if custompos then wm = true end

    local mdl = self.VModel
    local lod = 0

    if wm then
        if custompos then
            mdl = self.CModel
        else
            mdl = self.WModel
            lod = self:ShouldLOD()

            if mdl and mdl[1]:IsValid() then
                mdl[1]:SetMaterial(self:GetProcessedValue("Material", true))

                for ind = 0, 31 do
                    local val = self:GetProcessedValue("SubMaterial" .. ind, true)
                    if val then
                        mdl[1]:SetSubMaterial(ind, val)
                    end
                end
            end
        end

        if lod >= 2 then
            self:DrawModel()
            return
        end
    end

    if !mdl then
        self:KillModel()
        self:SetupModel(wm, lod, !!custompos)

        mdl = self.VModel

        if wm then
            mdl = self.WModel
            if custompos then
                mdl = self.CModel
            end
        end
    end

    local onground = wm and !IsValid(owner)

    local hidebones = self:GetHiddenBones(wm)

    if lod < 2 then
        for _, model in ipairs(mdl or {}) do
            if model.IsAnimationProxy then continue end
            local slottbl = model.slottbl
            local atttbl = self:GetFinalAttTable(slottbl)

            if !IsValid(model) then self:KillModel() return end

            if !onground or model.OptimizPrevWMPos != self:GetPos() then -- mega optimiz
                model.OptimizPrevWMPos = onground and self:GetPos() or nil

                if ARC9.RTScopeRender and atttbl.RTScope then continue end -- dont draw scope model while drawing vm from scope position

                if model.charmparent then
                    continue
                else
                    if hidebones[slottbl.Bone or -1] then
                        continue
                    end

                    if model.Duplicate then
                        local duplitbl = (slottbl.DuplicateModels or {})[model.Duplicate]

                        if hidebones[(duplitbl or {}).Bone or -1] then
                            continue
                        end
                    end

                    local apos, aang = self:GetAttachmentPos(slottbl, wm, false, false, custompos, customang or angle_zero, model.Duplicate)
                    model:SetPos(apos)
                    model:SetAngles(aang)
                    model:SetRenderOrigin(apos)
                    model:SetRenderAngles(aang)
                    model:SetupBones()

                    if model.charmmdl then
                        local bpos, bang

                        local bonename = atttbl.CharmBone
                        if bonename then
                            local boneindex = model:LookupBone(bonename)

                            local bonemat = model:GetBoneMatrix(boneindex)
                            if bonemat then
                                bpos = bonemat:GetTranslation()
                                bang = bonemat:GetAngles()
                            end

                            if bpos and bang then
                                local coffset = atttbl.CharmOffset or Vector(0, 0, 0)
                                local cangle = atttbl.CharmAngle or Angle(0, 0, 0)

                                bpos = bpos + bang:Forward() * coffset.y
                                bpos = bpos + bang:Up() * coffset.z
                                bpos = bpos + bang:Right() * coffset.x

                                local up, right, forward = bang:Up(), bang:Right(), bang:Forward()

                                bang:RotateAroundAxis(up, cangle.p)
                                bang:RotateAroundAxis(right, cangle.y)
                                bang:RotateAroundAxis(forward, cangle.r)

                                model.charmmdl:SetPos(bpos)
                                model.charmmdl:SetAngles(bang)
                                model.charmmdl:SetupBones()
                                model.charmmdl:DrawModel()
                            end
                        end
                    end
                end

                -- if !wm and atttbl.HoloSight then
                --     self:DoHolosight(model, atttbl)
                -- end

                if !ARC9.PresetCam and !ARC9.RTScopeRender then
                    if !wm and atttbl.RTScope then
                        local active = slottbl.Address == self:GetActiveSightSlotTable().Address
                        self:DoRTScope(model, atttbl, active)
                    elseif wm and atttbl.RTScope then
                        self:DoRTScope(model, atttbl, false)
                    end
                end
            end

            model.CustomCamoTexture = self:GetProcessedValue("CustomCamoTexture", true)
            model.CustomCamoScale = self:GetProcessedValue("CustomCamoScale", true)
            model.CustomBlendFactor = self:GetProcessedValue("CustomBlendFactor", true)


            if !model.NoDraw then
                model:DrawModel()
            end

            if atttbl.DrawFunc then
                atttbl.DrawFunc(self, model, wm)
            end

        --     -- if model.Flare and !self:GetCustomize() then
        --     --     if model.Flare.Attachment then
        --     --         local attpos = model:GetAttachment(model.Flare.Attachment)

        --     --         if attpos then
        --     --             self:DrawLightFlare(attpos.Pos, -attpos.Ang:Right(), model.Flare.Color, model.Flare.Size, model.Flare.Focus)
        --     --         else
        --     --             self:DrawLightFlare(apos, aang:Forward(), model.Flare.Color, model.Flare.Size, model.Flare.Focus)
        --     --         end
        --     --     else
        --     --         self:DrawLightFlare(apos, aang:Forward(), model.Flare.Color, model.Flare.Size, model.Flare.Focus)
        --     --     end
        --     -- end
        end
    end
end

function SWEP:GetActiveSightSlotTable()
    local sight = self:GetSight() or {}

    return sight.slottbl or {}
end

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_hud.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_sight_autosolve.lua:
function SWEP:GenerateAutoSight(sight, slottbl)
    local pos, ang = self:GetAttachmentPos(slottbl, false, true)
    local scale = slottbl.Scale or 1

    pos = pos - (ang:Right() * sight.Pos.x * scale)
    pos = pos - (ang:Forward() * sight.Pos.y * scale)
    pos = pos - (ang:Up() * sight.Pos.z * scale)

    ang:RotateAroundAxis(ang:Right(), sight.Ang.p)
    ang:RotateAroundAxis(ang:Up(), sight.Ang.y)
    ang:RotateAroundAxis(ang:Forward(), sight.Ang.r)

    debugoverlay.Axis(pos, ang, 16, 1, true)

    local s_pos = Vector(0, self:GetProcessedValue("AdditionalSightDistance", true), 0)
    local s_ang = Angle(0, 0, 0)

    local up, forward, right = s_ang:Up(), s_ang:Forward(), s_ang:Right()

    s_pos = s_pos + (right * pos.x)
    s_pos = s_pos + (forward * pos.y)
    s_pos = s_pos + (up * -pos.z)

    return {
        Pos = s_pos,
        Ang = -ang + (slottbl.CorrectiveAng or angle_zero),
        -- ExtraPos = Vector(0, pos.y + self.IronSights.Pos.y, 0),
        Magnification = sight.Magnification or 1,
        ExtraSightDistance = (self.ExtraSightDistanceNoRT and sight.RTScopeFOV) and 0 or slottbl.ExtraSightDistance,
        GeneratedSight = true,
        -- ExtraAng = ang
        ShadowPos = sight.ShadowPos,
        Reticle = sight.Reticle,
        RTScopeFOV = sight.RTScopeFOV
    }
end

SWEP.MultiSightIndex = 1

function SWEP:GetSightPositions()
    local s = self:GetSight()
    return s.Pos, s.Ang
end

function SWEP:GetExtraSightPositions()
    local s = self:GetSight()
    local se = s.ExtraPos or Vector(0, 0, 0)
    se.y = se.y + (s.ExtraSightDistance or 0)
    -- return Vector(0, 0, 0), Angle(0, 0, 0)
    return se, s.ExtraAng or Angle(0, 0, 0)
end

local arc9_cheapscopes = GetConVar("arc9_cheapscopes")
local arc9_compensate_sens = GetConVar("arc9_compensate_sens")
local fov_desired = GetConVar("fov_desired")

function SWEP:GetMagnification()
    local sight = self:GetSight()

    local target = sight.Magnification or 1

    if arc9_cheapscopes:GetBool() and !sight.Disassociate then
        local atttbl = sight.atttbl

        if sight.BaseSight then
            atttbl = self:GetTable()
        end

        if atttbl and atttbl.RTScope and !atttbl.RTCollimator then
            -- target = (self:GetOwner():GetFOV() / self:GetRTScopeFOV())

            local realfov = self:GetOwner():GetFOV()
            local screenamt = ((ScrW() - ScrH()) / ScrW()) * (atttbl.ScopeScreenRatio or 0.5) * 2
            target = (realfov / (self:GetRTScopeFOV() or realfov)) * screenamt

            target = math.max(target, 1)
        end
    end

    return target
end

local aa = GetConVar("arc9_aimassist")
local aac = GetConVar("arc9_aimassist_cl")
local aai = GetConVar("arc9_aimassist_intensity")
local aams = GetConVar("arc9_aimassist_multsens")
local sensmult = GetConVar("arc9_mult_sens")

function SWEP:AdjustMouseSensitivity()
	if self:GetOwner().ARC9_AATarget != nil and (!self:GetProcessedValue("NoAimAssist", true) and aa:GetBool() and aac:GetBool()) then
		aamult = aams:GetFloat() / aai:GetFloat()
	else
		aamult = 1
	end

	local gsa = self:GetSightAmount()
	
    if !self:GetInSights() then 
	-- if gsa <= 0.01 then -- Active if "Sight amount" is over 1%. Experimental.
		local amt = 1
		amt = math.sqrt(amt)
		
		return amt * aamult
	else
		if !arc9_compensate_sens:GetBool() then return end

		local magdef = self.IronSights.Magnification
		local mag = self:GetMagnification()
		local fov = fov_desired:GetFloat()

		local sight = self:GetSight()
		local atttbl = sight.atttbl
		
		if sight.BaseSight then
			atttbl = self:GetTable()
		end

		if atttbl and atttbl.RTScope and !sight.Disassociate and !sight.NoSensAdjustment and !atttbl.RTCollimator then
			mag = mag + (fov / (self:GetRTScopeFOV() or 90))
		end

		if self.Peeking then
			mag = magdef
		end

		if mag > 0 then
			local amt = 1 / (1 - (self:GetSightAmount() * (1 - mag)))

			amt = math.sqrt(amt)

			-- return amt * aamult * ( 1 - math.Clamp( gsa, 0, math.Clamp(sensmult:GetFloat(), 0, 0.99) ) ) -- Gradually reduces sensitivity. Experimental.
			return amt * sensmult:GetFloat() * aamult

		end
	end

end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_deploy.lua:

function SWEP:Deploy()
    local owner = self:GetOwner()

    if self:GetOwner():IsNPC() then
        return
    end
    owner:SetSaveValue("m_flNextAttack", 0)

    self:ClientDeploy()

    self:InvalidateCache()

    self:SetBaseSettings()

    self:SetNextPrimaryFire(0)
    self:SetNextSecondaryFire(0)
    self:SetAnimLockTime(0)
    self:SetLastMeleeTime(0)
    self:SetRecoilAmount(0)
    self:SetRecoilUp(0)
    self:SetRecoilSide(0)
    self:SetPrimedAttack(false)
    self:SetReloading(false)
    self:SetCycleFinishTime(0)
    self:SetRequestReload(false)
    self:SetEmptyReload(false)
    self:SetLeanState(0)

    owner:SetCanZoom(false)
    -- self:SetTraversalSprint(false)
    -- self:SetLastPressedWTime(0)

    -- self:SetBlindFire(false)
    -- self:SetBlindFireDirection(0)

    self:SetHolster_Entity(NULL)
    self:SetHolsterTime(0)

    self:SetFreeAimAngle(Angle(0, 0, 0))
    self:SetLastAimAngle(Angle(0, 0, 0))

    if self:GetProcessedValue("AutoReload", true) then
        self:RestoreClip(math.huge)
    end


    self:SetBurstCount(0)
    self:SetSightAmount(0)
    self:SetCustomize(false)
    self:SetBreath(100)
    self:SetInspecting(false)
    self:SetLoadedRounds(self:Clip1())
    self:SetGrenadeRecovering(false)
    self:SetUBGL(false)
    self:SetLeanAmount(0)
    
    self.StartedFixingJam = nil

    timer.Simple(0.4, function() -- fixing dum eror
        if IsValid(self) then
            if self:LookupPoseParameter("sights") != -1 then self.HasSightsPoseparam = true end
            if self:LookupPoseParameter("firemode") != -1 then self.HasFiremodePoseparam = true end
        end
    end)

    self:SetGrenadePrimed(false)

    self:SetBipod(false)

    self:SetTriggerDown(owner:KeyDown(IN_ATTACK))

    local holsteredtime = CurTime() - self:GetLastHolsterTime()

    self:ThinkHeat(holsteredtime)

    self:DoDeployAnimation()

    if self:GetValue("AnimDraw") then
        self:DoPlayerAnimationEvent(self:GetValue("AnimDraw"))
    end

    if game.SinglePlayer() then
        self:CallOnClient("RecalculateIKGunMotionOffset")
    end

    if SERVER then
        self:CreateShield()

        -- self:NetworkWeapon()
        self:SetTimer(0.25, function()
            self:SendWeapon()
        end)
        if IsValid(owner:GetHands()) then
            owner:GetHands():SetLightingOriginEntity(owner:GetViewModel())
        end
    end

    self:SetShouldHoldType()

    self:RunHook("Hook_Deploy")

    return true
end

function SWEP:ClientDeploy()
    if SERVER then return end

    if game.SinglePlayer() then
        self:CallOnClient("ClientDeploy")
    end

    self:KillModel()
end

function SWEP:InitialDefaultClip()
    -- self:SetClip1(self:GetValue("ClipSize"))
    -- self:GetOwner():GiveAmmo(self:GetValue("ClipSize") * 2, self:GetValue("Ammo"))

        -- arccw code winning again
    local ammmmmo = self:GetValue("Ammo")
    if !ammmmmo then return end
    if engine.ActiveGamemode() == "darkrp" then return end -- DarkRP is god's second biggest mistake after gmod

    if self:GetOwner() and self:GetOwner():IsPlayer() then
        if self.ForceDefaultAmmo then
            self:GetOwner():GiveAmmo(self.ForceDefaultAmmo, ammmmmo)
        else
            self:GetOwner():GiveAmmo(self:GetValue("ClipSize") * GetConVar("arc9_mult_defaultammo"):GetInt(), ammmmmo)
        end
    end
end

local v0 = Vector(0, 0, 0)
local v1 = Vector(1, 1, 1)
local a0 = Angle(0, 0, 0)

function SWEP:ClientHolster()
    if SERVER then return end

    if game.SinglePlayer() then
        self:CallOnClient("ClientHolster")
    end

    self:KillModel()

    local vm = self:GetVM()

    vm:SetSubMaterial()
    vm:SetMaterial()

    for i = 0, vm:GetBoneCount() do
        vm:ManipulateBoneScale(i, v1)
        vm:ManipulateBoneAngles(i, a0)
        vm:ManipulateBonePosition(i, v0)
    end
end

function SWEP:Holster(wep)
    -- May cause issues? But will fix HL2 weapons playing a wrong animation on ARC9 holster
    if !IsValid(self) then return end
    local vm = self:GetVM()
    if !IsValid(vm) then return end
    if game.SinglePlayer() and CLIENT then vm:ResetSequenceInfo() return end

    local owner = self:GetOwner()

    if CLIENT and owner != LocalPlayer() then return end

    if owner:IsNPC() then
        return
    end

    if self:GetReloading() then
        self:CancelReload()
    end

    self:SetCustomize(false)

    if self:GetHolsterTime() > CurTime() then return false end

    if self.NoHolsterOnPrimed and self:GetGrenadePrimed() then return false end

    if self:GetGrenadeRecovering() then -- insta holster if grenade recovering
        self:SetHolsterTime(CurTime())
        self:SetHolster_Entity(wep)

        if SERVER and self:GetProcessedValue("Disposable", true) and self:Clip1() == 0 and self:Ammo1() == 0 and !IsValid(self:GetDetonatorEntity()) then
            self:Remove()
        end

        self:SetLastHolsterTime(CurTime())
        self:DoPlayerModelLean(true)

        return true 
    end

    if (self:GetHolsterTime() != 0 and self:GetHolsterTime() <= CurTime()) or !IsValid(wep) then
        -- Do the final holster request
        -- Picking up props try to switch to NULL, by the way
        self:SetHolsterTime(0)
        self:SetHolster_Entity(NULL)

        self:KillTimers()
        owner:SetFOV(0, 0)
        owner:SetCanZoom(true)
        self:EndLoop()

        self:ClientHolster()

        if game.SinglePlayer() then
            game.SetTimeScale(1)
        end

        -- if self.SetBreathDSP then
        --     self:GetOwner():SetDSP(0)
        --     self.SetBreathDSP = false
        -- end

        self:RunHook("Hook_Holster")

        if SERVER then
            self:KillShield()
        end

        if SERVER and self:GetProcessedValue("Disposable", true) and self:Clip1() == 0 and self:Ammo1() == 0 and !IsValid(self:GetDetonatorEntity()) then
            self:Remove()
        end

        self:SetLastHolsterTime(CurTime())

        self:DoPlayerModelLean(true)

        return true
    else
        -- Prepare the holster and set up the timer
        self:KillTimer("ejectat")
        self:SetHolster_Entity(wep)
        if self.QuickSwapTo and wep.SetDoAFastDraw then wep:SetDoAFastDraw(true) end
        if wep.QuickSwapTo then self:SetDoAFastDraw(true) end
        local fdraw = self:GetDoAFastDraw()
        local specialholsterlogic = self:RunHook( "Hook_SpecialHolsterLogic" )
        if !specialholsterlogic then
            local hasqh = self:HasAnimation("holster_quick")
            local selectholsteranimation = self:RunHook( "Hook_SelectHolsterAnimation" ) or (wep.QuickSwapTo and hasqh and "holster_quick") or "holster"
            if self:HasAnimation(selectholsteranimation) then
                local unsatmult = (fdraw and ((hasqh and 1) or (!hasqh and 0.5)) or 1)
                local animation = self:PlayAnimation(selectholsteranimation, self:GetProcessedValue("DeployTime", true, 1) * unsatmult, true, false, nil, nil, true) or 0
                local aentry = self:GetAnimationEntry(self:TranslateAnimation(selectholsteranimation))
                local alength = aentry.MinProgress or animation
                alength = alength * (aentry.Mult or 1)
                self:SetHolsterTime(CurTime() + alength * unsatmult)
            else
                self:SetHolsterTime(CurTime() + (self:GetProcessedValue("DeployTime", true, 1)))
            end
        end

        local animdrwa = self:GetValue("AnimDraw")

        if animdrwa then
            self:DoPlayerAnimationEvent(animdrwa)
        end

        -- self:ToggleBlindFire(false)
        self:SetInSights(false)
        self:ToggleUBGL(false)
        self:SetCycleFinishTime(0)
    end
end

local holsteranticrash = false

hook.Add("StartCommand", "ARC9_Holster", function(ply, ucmd)
    local wep = ply:GetActiveWeapon()

    if IsValid(wep) and wep.ARC9 then
        if wep:GetHolsterTime() != 0 and wep:GetHolsterTime() <= CurTime() then
            if IsValid(wep:GetHolster_Entity()) then
                wep:SetHolsterTime(-math.huge) -- Pretty much force it to work

                if !holsteranticrash then
                    holsteranticrash = true
                    ucmd:SelectWeapon(wep:GetHolster_Entity()) -- Call the final holster request
                    holsteranticrash = false
                end
            end
        end
    end
end)

local arc9_never_ready = GetConVar("arc9_never_ready")
local arc9_dev_always_ready = GetConVar("arc9_dev_always_ready")

function SWEP:DoDeployAnimation()
    if self.IsQuickGrenade then self:QuicknadeDeploy() return end
    if !arc9_never_ready:GetBool() and (arc9_dev_always_ready:GetBool() or !self:GetReady()) and self:HasAnimation("ready") then
        local t, min = self:PlayAnimation("ready", self:GetProcessedValue("DeployTime", true, 1), true)

        self:SetReadyTime(CurTime() + (t * min))
        self:SetReady(true)
    else
        if self:GetDoAFastDraw() then
            if self:HasAnimation("draw_quick") then
                self:PlayAnimation("draw_quick", self:GetProcessedValue("DeployTime", true, 1), true)
            else
                self:PlayAnimation("draw", self:GetProcessedValue("DeployTime", true, 1) * 0.65, true, true) -- + delayedidle
            end
        else
            self:PlayAnimation("draw", self:GetProcessedValue("DeployTime", true, 1), true)
        end
        self:SetDoAFastDraw(false)
        self:SetReady(true)
    end
end

function SWEP:QuicknadeDeploy()
    local owner = self:GetOwner()
    self.ViewModelPos = Vector(0, 0, 0)
    self.ViewModelAng = Angle(0, 0, 0)

    owner.ARC9LastSelectedGrenade = self:GetClass()

    local WasDrawnByBind = owner:KeyDown(IN_GRENADE1) or owner.ARC9QuickthrowPls
    owner.ARC9QuickthrowPls = nil 
    
    local anim, det = "draw", self:GetProcessedValue("Detonator", true) and IsValid(self:GetDetonatorEntity())
    if WasDrawnByBind and self:HasAnimation("quicknade") then anim = "quicknade" end
    if det then anim = self:HasAnimation(anim .. "_detonator") and anim .. "_detonator" or self:HasAnimation("draw_detonator") and "draw_detonator" or "draw" end

    if WasDrawnByBind then
        self.WasThrownByBind = true
        self:PlayAnimation(anim, 1, true)

        if !det then
            self:SetGrenadePrimed(true)
            self:SetGrenadePrimedTime(CurTime())
            self:SetGrenadeTossing(owner:KeyDown(IN_ATTACK2))
        else
            self:TouchOff()
        end
    else
        self:PlayAnimation(anim, self:GetProcessedValue("DeployTime", true, 1), true)
        self:SetReady(true)
    end
end

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_mergeslots.lua:
function SWEP:BuildMergeSlots(tree)
    for i, slot in pairs(tree or {}) do
        if slot.MergeSlots then
            slot.MergeSlotAddresses = {}

            for _, merge in pairs(slot.MergeSlots) do
                local mergeslot = tree[merge]

                if !mergeslot then continue end

                mergeslot.MergeSlots = {i}
                mergeslot.MergeSlotAddresses = {slot.Address}

                table.insert(slot.MergeSlotAddresses, mergeslot.Address)
            end
        else
            slot.MergeSlotAddresses = nil
        end

        self:BuildMergeSlots(slot.SubAttachments)
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_shoot.lua:
local cancelmults = ARC9.CancelMultipliers[engine.ActiveGamemode()] or ARC9.CancelMultipliers[1]

function SWEP:StillWaiting()
    local time = CurTime()

    if self:GetNextPrimaryFire() > time then return true end
    if self:GetNextSecondaryFire() > time then return true end
    if self:GetAnimLockTime() > time then return true end
    if self:GetCycleFinishTime() > time then return true end
    if self:GetPrimedAttack() then return true end
    if self:GetHolsterTime() > 0 then return true end

    return false
end

function SWEP:SprintLock()
    if self:GetSprintAmount() > 0 then return true end
    -- if self:GetTraversalSprintAmount() > 0 then retur    n true end
    -- if self:GetIsSprinting() then return true end
    if self:GetIsNearWall() then return true end

    return false
end

local dryfireSoundTab = {
    name = "dryfire",
    sound = "",
    level = 75,
    pitch = 100,
    volume = 1,
}

function SWEP:DryFire()
    local nthShot = self:GetNthShot()

    local delay = self:GetProcessedValue("DryFireDelay", true)

    if delay then
        self:PlayAnimation("dryfire", 1, false)
        self:SetNextPrimaryFire(CurTime() + delay)
    else
        self:PlayAnimation("dryfire", 1, true)
    end
    self:SetBurstCount(0)
    self:SetNeedTriggerPress(true)

    if nthShot > 0 and self:GetProcessedValue("DryFireSingleAction", true) then return end

    dryfireSoundTab.channel = ARC9.CHAN_FIDDLE
    dryfireSoundTab.sound = self:RandomChoice(self:GetProcessedValue("DryFireSound", true))
    self:PlayTranslatedSound(dryfireSoundTab)

    self:SetNthShot(nthShot + 1)
end

local lsstr = "ShootSound"
local lsslr = "LayerSound"
local ldsstr = "DistantShootSound"

local sstrSilenced = "ShootSoundSilenced" -- made cuz it'll just pointless to concate.
local sslrSilenced = "LayerSoundSilenced"
local dsstrSilenced = "DistantShootSoundSilenced"

local soundtab1 = {
    name = "shootsound"
}

local soundtab2 = {
    name = "shootlayer"
}

local soundtab3 = {
    name = "shootdistant"
}

local soundtab4 = {
    name = "shootsoundindoor"
}

local soundtab5 = {
    name = "shootlayerindoor"
}

local soundtab6 = {
    name = "shootdistantindoor"
}

function SWEP:DoShootSounds()
    local pvar = self:GetProcessedValue("ShootPitchVariation", true)
    local pvrand = util.SharedRandom("ARC9_sshoot", -pvar, pvar)

    local sstr = lsstr
    local sslr = lsslr
    local dsstr = ldsstr

    local silenced = self:GetProcessedValue("Silencer", true) and !self:GetUBGL()
    local indoor = self:GetIndoor()

    local indoormix = 1 - indoor
    local havedistant = self:GetProcessedValue(dsstr, true)

    if silenced and self:GetProcessedValue(sstrSilenced, true) then
        sstr = sstrSilenced
    end

    if silenced and self:GetProcessedValue(sslrSilenced, true) then
        sslr = sslrSilenced
    end

    if havedistant and silenced and self:GetProcessedValue(dsstrSilenced, true) then
        dsstr = dsstrSilenced
    end

    do
        local burstCountZero = self:GetBurstCount() == 0
        local sstrFirst = "First" .. sstr
        local dsstrFirst = "First" .. dsstr

        if burstCountZero and self:GetProcessedValue(sstrFirst, true) then
            sstr = sstrFirst
        end

        if havedistant and burstCountZero and self:GetProcessedValue(dsstrFirst, true) then
            dsstr = dsstrFirst
        end
    end

    local ss = self:RandomChoice(self:GetProcessedValue(sstr, true))
    local sl = self:RandomChoice(self:GetProcessedValue(sslr, true))
    local dss

    if havedistant then
        dss = self:RandomChoice(self:GetProcessedValue(dsstr, true))
    end

    local svolume, spitch, svolumeactual = self:GetProcessedValue("ShootVolume", true), self:GetProcessedValue("ShootPitch", true) + pvrand, self:GetProcessedValue("ShootVolumeActual", true) or 1
    local dvolume, dpitch, dvolumeactual

    if havedistant then
        dvolume, dpitch, dvolumeactual = math.min(149, (self:GetProcessedValue("DistantShootVolume", true) or svolume) * 2), (self:GetProcessedValue("DistantShootPitch", true) or spitch) + pvrand, self:GetProcessedValue("DistantShootVolumeActual", true) or svolumeactual or 1
    end

    local volumeMix = svolumeactual * indoormix

    local hardcutoff = self.IndoorSoundHardCutoff and self.IndoorSoundHardCutoffRatio < indoor

    if hardcutoff then
        indoormix = 0
        indoor = 1
    elseif self.IndoorSoundHardCutoff then
        indoormix = 1
        indoor = 0
    end

    if indoormix > 0 then

        -- doing this cuz it uses only 1 cached table and it works way faster
        do
            soundtab1.sound = ss or ""
            soundtab1.level = svolume
            soundtab1.pitch = spitch
            soundtab1.volume = volumeMix
            soundtab1.channel = ARC9.CHAN_WEAPON
        end

        self:PlayTranslatedSound(soundtab1)

        do
            soundtab2.sound = sl or ""
            soundtab2.level = svolume
            soundtab2.pitch = spitch
            soundtab2.volume = volumeMix
            soundtab2.channel = ARC9.CHAN_LAYER + 4
        end

        self:PlayTranslatedSound(soundtab2)

        if havedistant then
            do
                soundtab3.sound = dss or ""
                soundtab3.level = dvolume
                soundtab3.pitch = dpitch
                soundtab3.volume = dvolume * indoormix
                soundtab3.channel = ARC9.CHAN_DISTANT
            end

            self:PlayTranslatedSound(soundtab3)
        end
    end

    if indoor > 0 then
        local ssIN = self:RandomChoice(self:GetProcessedValue(sstr .. "Indoor", true))
        local slIN = self:RandomChoice(self:GetProcessedValue(sslr .. "Indoor", true))
        local dssIN = havedistant and self:RandomChoice(self:GetProcessedValue(dsstr .. "Indoor", true))
        local indoorVolumeMix = svolumeactual * indoor


        do
            soundtab4.sound = ssIN or ""
            soundtab4.level = svolume
            soundtab4.pitch = spitch
            soundtab4.volume = indoorVolumeMix
            soundtab4.channel = ARC9.CHAN_INDOOR
        end

        self:PlayTranslatedSound(soundtab4)

        do
            soundtab5.sound = slIN or ""
            soundtab5.level = svolume
            soundtab5.pitch = spitch
            soundtab5.volume = indoorVolumeMix
            soundtab5.channel = ARC9.CHAN_INDOOR + 7
        end

        self:PlayTranslatedSound(soundtab5)

        if havedistant then
            do
                soundtab6.sound = dssIN or ""
                soundtab6.level = dvolume
                soundtab6.pitch = dpitch
                soundtab6.volume = indoor
                soundtab6.channel = ARC9.CHAN_INDOORDISTANT
            end

            self:PlayTranslatedSound(soundtab6)
        end
    end

    self:StartLoop()
end

function SWEP:PrimaryAttack()
    if self.NotAWeapon then return end

    local owner = self:GetOwner()
    local processedValue = self.GetProcessedValue

    if owner:IsNPC() then
        self:NPC_PrimaryAttack()
        return
    end

    if processedValue(self,"Throwable", true) then
        return
    end

    if processedValue(self,"PrimaryBash", true) then
        return
    end

    if processedValue(self,"UBGLInsteadOfSights", true) then
        self:ToggleUBGL(false)
    end

    if self:GetSafe() then
        self:ToggleSafety(false)
        self:SetNeedTriggerPress(true)
        return
    end

    if self:GetNeedTriggerPress() then return end

    if self:GetNeedsCycle() then return end


    if self:GetCustomize() then return end

    if processedValue(self,"Bash", true) and owner:KeyDown(IN_USE) and !self:GetInSights() then
		if self:GetIsSprinting() and !self.ShootWhileSprint then return end
        self:MeleeAttack()
        self:SetNeedTriggerPress(true)
        return
    end

    if self:SprintLock() then return end

    if self:HasAmmoInClip() then
        if processedValue(self,"TriggerDelay") then
            local primedAttack = self:GetPrimedAttack()
            local time = CurTime()

            if self:GetBurstCount() == 0 and !primedAttack and !self:StillWaiting() then
                self:SetTriggerDelay(time + processedValue(self,"TriggerDelayTime"))
                local isEmpty = self:Clip1() == processedValue(self, "AmmoPerShot")
                local anim = "trigger"
                if processedValue(self,"TriggerStartFireAnim", true) then
                    anim = "fire"
                end
                if self:HasAnimation(anim .. "_empty") and isEmpty then
                    anim = anim .. "_empty"
                end
                self:PlayAnimation(anim)
                self:SetPrimedAttack(true)
                return
            elseif primedAttack and (self:GetTriggerDelay() <= time and (!processedValue(self, "TriggerDelayReleaseToFire", true) or !owner:KeyDown(IN_ATTACK))) then
                self:SetPrimedAttack(false)
            end
        end
    elseif !processedValue(self,"TriggerDelay") or !processedValue(self, "TriggerDelayReleaseToFire", true) or !owner:KeyDown(IN_ATTACK) then
        self:SetPrimedAttack(false)
    end

    if self:GetReloading() then
        self:SetEndReload(true)
    end

    self:DoPrimaryAttack()
		
	if self.RecentMelee then
		self.RecentMelee = nil
	end

end

function SWEP:DoPrimaryAttack()

    local processedValue = self.GetProcessedValue

    if self:StillWaiting() then return end
    if self.NoFireDuringSighting and (self:GetInSights() and self:GetSightAmount() < 0.8 or false) then return end

    local currentFiremode = self:GetCurrentFiremode()
    local burstCount = self:GetBurstCount()

    if currentFiremode > 0 and burstCount >= currentFiremode then return end

    local clip = self:GetLoadedClip()

    if processedValue(self,"BottomlessClip", true) then
        self:RestoreClip(math.huge)
    end

    if !self:HasAmmoInClip() then
        if self:GetUBGL() and !processedValue(self,"UBGLInsteadOfSights", true) then
            if self:CanReload() then 
                self:Reload()
            else
                self:ToggleUBGL(false)
                self:SetNeedTriggerPress(true)
                self:ExitSights()
            end

            return
        else
            self:DryFire()
            return
        end
    end

    if !processedValue(self,"CanFireUnderwater", true) then
        if bit.band(util.PointContents(self:GetShootPos()), CONTENTS_WATER) == CONTENTS_WATER then
            self:DryFire()
            return
        end
    end

    self:SetBaseSettings()

    if self:RunHook("HookP_BlockFire") then return end

    if self:GetJammed() or self:GetHeatLockout() then
        self:DryFire()
        return
    end

    self:RunHook("Hook_PrimaryAttack")

    self:SetEmptyReload(false)
    self:TakeAmmo()

    local triggerStartFireAnim = processedValue(self,"TriggerStartFireAnim", true)
    local nthShot = self:GetNthShot()

    if processedValue(self,"DoFireAnimation", true) and !triggerStartFireAnim then
        local anim = "fire"

        if processedValue(self,"Akimbo", true) then
            if processedValue(self, "AkimboBoth", true) then
                anim = "fire_both"
            elseif nthShot % 2 == 0 then
                anim = "fire_right"
            else
                anim = "fire_left"
            end
        end

        local banim = anim

        if !self.SuppressCumulativeShoot then
            for i = 1, burstCount + 1 do
                if self:HasAnimation(anim .. "_" .. i) then
                    banim = anim .. "_" .. i
                end
            end
        end

        self:PlayAnimation(banim, 1, false, true)
    end

    local clip1 = self:Clip1()

    self:SetLoadedRounds(clip1)

    local manualaction = processedValue(self,"ManualAction")

    if !processedValue(self,"NoShellEject") and !(manualaction and !processedValue(self,"ManualActionEjectAnyway", true)) then
        local ejectdelay = processedValue(self,"EjectDelay", true)

        if ejectdelay == 0 then
            self:DoEject()
        else
            self:SetTimer(ejectdelay, function()
                self:DoEject()
            end)
        end
    end

    self:SetAfterShot(true)

    self:DoShootSounds()

    self:DoPlayerAnimationEvent(processedValue(self,"AnimShoot", true))

    local delay = 60 / processedValue(self, "RPM")
    local time = CurTime()

    local curatt = self:GetNextPrimaryFire()
    local diff = time - curatt

    if diff > engine.TickInterval() or diff < 0 then
        curatt = time
    end

    self:SetNextPrimaryFire(curatt + delay)

    self:SetNthShot(nthShot + 1)

    self:DoEffects()

    if self:HoldingBreath() then
        self:SetBreath(self:GetBreath() - self:GetValue("HoldBreathTime", true)/20)
    end

    -- ewww
    if processedValue(self, "AkimboBoth", true) then
        self:SetNthShot(nthShot + 2)
        self:DoEffects()
        if !processedValue(self,"NoShellEject") and !(manualaction and !processedValue(self,"ManualActionEjectAnyway", true)) then
            local ejectdelay = processedValue(self,"EjectDelay", true)
            if ejectdelay == 0 then
                self:DoEject()
            else
                self:SetTimer(ejectdelay, function()
                    self:DoEject()
                end)
            end
        end
        self:SetNthShot(nthShot + 1)
    end

    if game.SinglePlayer() then
        if SERVER then
            self:CallOnClient("SInputRumble")
        end
    else
        if CLIENT then
            self:SInputRumble()
        end
    end

    local spread = processedValue(self,"Spread")

    spread = math.Max(spread, 0)

    local sp, sa = self:GetShootPos()

    if IsValid(self:GetLockOnTarget()) and self:GetLockedOn() and processedValue(self,"LockOnAutoaim", true) then
        sa = (self:GetLockOnTarget():EyePos() - sp):Angle()
    end

    self:DoProjectileAttack(sp, sa, spread)

    self:ApplyRecoil()
    self:DoVisualRecoil()

    if burstCount == 0 and currentFiremode > 1 and processedValue(self,"RunawayBurst", true) then
        if !processedValue(self,"AutoBurst") then
            self:SetNeedTriggerPress(true)
        end
    end

    if manualaction then
        nthShot = nthShot + 1
        if clip1 > 0 or !processedValue(self,"ManualActionNoLastCycle", true) then
            if nthShot % processedValue(self,"ManualActionChamber", true) == 0 then
                self:SetNeedsCycle(true)
            end
        end
    end
    -- print("shot = " .. nthShot)

    if currentFiremode == 1 or clip == 0 then
        self:SetNeedTriggerPress(true)
    end

    self:DoHeat()

    if !self:GetUBGL() then
        if !manualaction or manualaction and !self.MalfunctionCycle then
            self:RollJam()
        end
    end

    if clip1 == 0 then
        self:SetNthShot(0)
    end

    if processedValue(self,"TriggerDelayRepeat", true) and self:GetOwner():KeyDown(IN_ATTACK) and currentFiremode != 1 then
        self:SetTriggerDelay(time + processedValue(self,"TriggerDelayTime"))
        if triggerStartFireAnim then
            self:PlayAnimation("fire")
        else
            self:PlayAnimation("trigger")
        end
        self:SetPrimedAttack(true)
    end

    self:SetBurstCount(burstCount + 1)
end

if CLIENT then
    local cl_rumble = GetConVar("arc9_controller_rumble")

    function SWEP:SInputRumble()
        if !sinput then return false end
        if !cl_rumble:GetBool() then return false end

        local P1 = sinput.GetControllerForGamepadIndex(0)

        sinput.TriggerVibration(P1, self.RumbleHeavy, self.RumbleLight)
        sinput.SetLEDColor(P1, 255, 255, 255, false)

        timer.Remove( "SInput_ARC9_Rumble" )
        timer.Create( "SInput_ARC9_Rumble", self.RumbleDuration, 1, function()
            sinput.TriggerVibration(P1, 0, 0)
            sinput.SetLEDColor(P1, 255, 255, 255, true)
        end )
    end
end

local bulletPhysics = GetConVar("ARC9_bullet_physics")
local fireBullets = {}
local black = Color(0,0,0) -- if anything, let's just safe ourselves.

function SWEP:DoProjectileAttack(pos, ang, spread)
    if self:GetProcessedValue("ShootEnt", true) then
        self:ShootRocket()
    else
        local shouldtracer = self:ShouldTracer()

        local bullettbl = {}

        if !shouldtracer then
            bullettbl.Color = black
        end

        local tr = 0

        if shouldtracer then
            tr = 1
        end

        bullettbl.Size = self:GetProcessedValue("TracerSize", true)

        local ang2 = Angle(ang)
        local numm = self:GetProcessedValue("Num")
        if numm > 0 then
            if (bulletPhysics:GetBool() or self:GetProcessedValue("AlwaysPhysBullet", true)) and !self:GetProcessedValue("NeverPhysBullet", true) then
                if SERVER or (CLIENT and IsFirstTimePredicted()) then
                    if self:GetProcessedValue("UseDispersion", true) then 
                        local seed = 1337 + self:EntIndex() + engine.TickCount()
                        local a = util.SharedRandom("arc9_physbullet3", 0, 360, seed)
                        local angleRand = Angle(math.sin(a), math.cos(a), 0)
                        angleRand:Mul(self:GetProcessedValue("DispersionSpread") * util.SharedRandom("arc9_physbullet4", 0, 45, seed) * 1.4142135623730)
                        ang:Add(angleRand)
                    end

                    for i = 1, numm do
                        ang2:Set(ang)

                        -- trig stuff to ensure the spread is a circle of the right size
                        local seed = i + self:EntIndex() + engine.TickCount()
                        local a = util.SharedRandom("arc9_physbullet", 0, 360, seed)
                        local angleRand = Angle(math.sin(a), math.cos(a), 0)
                        angleRand:Mul(spread * util.SharedRandom("arc9_physbullet2", 0, 45, seed) * 1.4142135623730)

                        ang2:Add(angleRand)

                        local vec = ang2:Forward()
                        vec:Mul(self:GetProcessedValue("PhysBulletMuzzleVelocity", true))

                        ARC9:ShootPhysBullet(self, pos, vec, bullettbl)
                    end
                end
            else
                local owner = self:GetOwner()

                if owner:IsPlayer() then
                    owner:LagCompensation(true)
                end

                -- local tr = self:GetProcessedValue("TracerNum")

                local veh = NULL

                if owner:IsPlayer() then
                    veh = owner:GetVehicle()
                end


                if self:GetProcessedValue("UseDispersion", true) then
                    local seed = 1337 + self:EntIndex() + engine.TickCount()
                    local a = util.SharedRandom("arc9_physbullet3", 0, 360, seed)
                    local angleRand = Angle(math.sin(a), math.cos(a), 0)
                    angleRand:Mul(self:GetProcessedValue("DispersionSpread") * util.SharedRandom("arc9_physbullet4", 0, 45, seed) * 1.4142135623730)
                    ang:Add(angleRand)
                end

                local distance = self:GetProcessedValue("Distance")

                fireBullets.Damage = self:GetProcessedValue("DamageMax")
                fireBullets.Force = self:GetProcessedValue("ImpactForce", true)
                fireBullets.Tracer = tr
                fireBullets.TracerName = self:GetProcessedValue("TracerEffect", true)
                fireBullets.Num = numm
                fireBullets.Dir = ang:Forward()
                fireBullets.Src = pos
                fireBullets.Spread = Vector(spread, spread, spread)
                fireBullets.IgnoreEntity = veh
                fireBullets.Distance = distance
                fireBullets.Callback = function(att, btr, dmg)
                    local range = btr.Fraction * distance

                    self.Penned = 0
                    self:AfterShotFunction(btr, dmg, range, self:GetProcessedValue("Penetration", true), {})

                    if ARC9.Dev(2) then
                        if SERVER then
                            debugoverlay.Cross(btr.HitPos, 4, 5, Color(255, 0, 0), false)
                        else
                            debugoverlay.Cross(btr.HitPos, 4, 5, Color(255, 255, 255), false)
                        end
                    end
                end

                owner:FireBullets(fireBullets)

                if owner:IsPlayer() then
                    owner:LagCompensation(false)
                end
            end
        end
    end
end

local runHook = {}
local bodyDamageCancel = GetConVar("arc9_mod_bodydamagecancel")
local arc9_npc_equality = GetConVar("arc9_npc_equality")

local soundTab2 = {
    name = "impact"
}

function SWEP:AfterShotFunction(tr, dmg, range, penleft, alreadypenned, secondary)
    if !IsFirstTimePredicted() and !game.SinglePlayer() then return end

    local lastsecondary = self:GetUBGL()

    self:SetUBGL(secondary)

    dmg:SetDamageType(self:GetProcessedValue("DamageType", true) or DMG_BULLET)

    local dmgv = self:GetDamageAtRange(range)
    local dmgvoriginal = dmgv

    runHook.tr = tr
    runHook.dmg = dmg
    runHook.range = range
    runHook.penleft = penleft
    runHook.alreadypenned = alreadypenned
    runHook.dmgv = dmgv

    self:RunHook("Hook_BulletImpact", runHook)

    -- Penetration
    local pen = self:GetProcessedValue("Penetration", true)
    local pendeltaval = self:GetProcessedValue("PenetrationDelta", true)
    if pen > 0 then
        local pendelta = penleft / pen
        pendelta = Lerp(pendelta, pendeltaval, 1) -- it arleady clamps inside
        dmgv = dmgv * pendelta
    end

    -- NPC damage nerf
    local owner = self:GetOwner()
    if owner:IsNPC() and !arc9_npc_equality:GetBool() then
        dmgv = dmgv * 0.25
    end

    -- Limb multipliers
    local traceEntity = tr.Entity
    local hitGroup = tr.HitGroup
    
    if !ARC9.NoBodyPartsDamageMults then
        local bodydamage = self:GetProcessedValue("BodyDamageMults", true)

        if bodydamage[hitGroup] then
            dmgv = dmgv * bodydamage[hitGroup]
        end
        if hitGroup == HITGROUP_HEAD then
            dmgv = dmgv * self:GetProcessedValue("HeadshotDamage", true)
        elseif hitGroup == HITGROUP_CHEST then
            dmgv = dmgv * self:GetProcessedValue("ChestDamage", true)
        elseif hitGroup == HITGROUP_STOMACH then
            dmgv = dmgv * self:GetProcessedValue("StomachDamage", true)
        elseif hitGroup == HITGROUP_LEFTARM or hitGroup == HITGROUP_RIGHTARM then
            dmgv = dmgv * self:GetProcessedValue("ArmDamage", true)
        elseif hitGroup == HITGROUP_LEFTLEG or hitGroup == HITGROUP_RIGHTLEG then
            dmgv = dmgv * self:GetProcessedValue("LegDamage", true)
        end
    end

    -- Armor piercing (done after weapon's limb multipliers but BEFORE body damage cancel)
    local ap = math.Clamp(self:GetProcessedValue("ArmorPiercing", true), 0, 1)
    if ap > 0 and !alreadypenned[traceEntity] then
        if traceEntity:GetClass() == "npc_helicopter" then
            local apdmg = DamageInfo()
            apdmg:SetDamage(dmgv * ap)
            apdmg:SetDamageType(DMG_AIRBOAT)
            apdmg:SetInflictor(dmg:GetInflictor())
            apdmg:SetAttacker(dmg:GetAttacker())

            traceEntity:TakeDamageInfo(apdmg)
        elseif traceEntity:GetClass() == "npc_gunship" or traceEntity:GetClass() == "npc_strider" then
            local apdmg = DamageInfo()
            apdmg:SetDamage(dmgv * ap)
            apdmg:SetDamageType(DMG_BLAST)
            apdmg:SetInflictor(dmg:GetInflictor())
            apdmg:SetAttacker(dmg:GetAttacker())

            traceEntity:TakeDamageInfo(apdmg)
        elseif traceEntity:IsPlayer() then
            if !ARC9.NoArmorPiercing then -- dumbass
                local apdmg = math.ceil(dmgv * ap)
                -- Delay health removal so that we can confirm the damage actually applied before removing health
                dmg:SetDamageCustom(ARC9.DMG_CUST_AP)
                traceEntity.ARC9APDamage = apdmg
                -- traceEntity:SetHealth(traceEntity:Health() - apdmg)
                dmgv = math.max(1, dmgv - apdmg)
            else
                ARC9.LastArmorPiercedPlayer = traceEntity
                ARC9.LastArmorPierceValue = ap
                ARC9.LastArmorPiercedTime = CurTime()

                traceEntity.ARC9APPower = pen
                traceEntity.ARC9APDelta = pendeltaval
                traceEntity.ARC9APRangeMult = dmgvoriginal / self:GetProcessedValue("DamageMax", true)
            end
        end
    end

    -- Cancel out sandbox/ttt limb damage multipliers. Done last since AP damage does not go through this
    -- Lambda Players call ScalePlayerDamage and cancel out hitgroup damage... except on the head
    if bodyDamageCancel:GetBool() and cancelmults[hitGroup] and (!traceEntity.IsLambdaPlayer or hitgroup == HITGROUP_HEAD) then
        dmgv = dmgv / cancelmults[hitGroup]
    end

    dmg:SetDamage(dmgv)

    local hitPos = tr.HitPos
    local hitNormal = tr.HitNormal

    if self:GetProcessedValue("ImpactDecal", true) then
        util.Decal(self:GetProcessedValue("ImpactDecal", true), tr.StartPos, hitPos - (hitNormal * 2), owner)
    end

    if self:GetProcessedValue("ImpactEffect", true) then
        local fx = EffectData()
        fx:SetOrigin(hitPos)
        fx:SetNormal(hitNormal)
        util.Effect(self:GetProcessedValue("ImpactEffect", true), fx, true)
    end

    if self:GetProcessedValue("ImpactSound", true) then
        soundTab2.sound = self:GetProcessedValue("ImpactSound", true)

        soundTab2 = self:RunHook("HookP_TranslateSound", soundTab2) or soundTab2

        sound.Play(soundTab2.sound, hitPos, soundTab2.level, soundTab2.pitch, soundTab2.volume)
    end

    if self:GetProcessedValue("ExplosionDamage") > 0 then
        util.BlastDamage(self, owner, hitPos, self:GetProcessedValue("ExplosionRadius", true), self:GetProcessedValue("ExplosionDamage"))
    end

    if self:GetProcessedValue("ExplosionEffect", true) then
        local fx = EffectData()
        fx:SetOrigin(hitPos)
        fx:SetNormal(hitNormal)
        fx:SetAngles(tr.HitNormal:Angle())

        if bit.band(util.PointContents(hitPos), CONTENTS_WATER) == CONTENTS_WATER then
            util.Effect("WaterSurfaceExplosion", fx, true)
        else
            util.Effect(self:GetProcessedValue("ExplosionEffect", true), fx, true)
        end
    end

    if traceEntity and alreadypenned[traceEntity] then
        dmg:SetDamage(0)
    elseif traceEntity then
        alreadypenned[traceEntity] = true
    end

    self:Penetrate(tr, range, penleft, alreadypenned)

    self:SetUBGL(lastsecondary)
end

function SWEP:ShouldTracer()
    local tracerNum = self:GetProcessedValue("TracerNum", true)

    if tracerNum <= 0 then return false end

    local shouldtracer = self:GetNthShot() % tracerNum == 0

    if self:Clip1() <= self:GetProcessedValue("TracerFinalMag", true) then
        shouldtracer = true
    end

    return shouldtracer
end

function SWEP:GetDamageDeltaAtRange(range)
    local d = 1

    local r_min = self:GetProcessedValue("RangeMin", true)
    local r_max = self:GetProcessedValue("RangeMax", true)

    if range <= r_min then
        d = 0
    elseif range >= r_max then
        d = 1
    else
        d = (range - r_min) / (r_max - r_min)
    end

    if self:GetProcessedValue("CurvedDamageScaling", true) then
        d = math.cos((d + 1) * math.pi) / 2 + 0.5
    end

    return d
end

function SWEP:GetSweetSpotDeltaAtRange(range)
    if !self:GetProcessedValue("SweetSpot", true) then return 0 end

    local ss_range = self:GetProcessedValue("SweetSpotRange", true)
    local ss_width = self:GetProcessedValue("SweetSpotWidth", true)
    local ss_peak = self:GetProcessedValue("SweetSpotPeak", true)
    local ss_size = ss_width + ss_peak

    if range <= ss_range + ss_size / 2 and range >= ss_range - ss_size / 2 then
        if range <= ss_range + ss_peak / 2 and range >= ss_range - ss_peak / 2 then
            return 1
        else
            local f = 0
            if range > ss_range then
                f = 1 - math.Clamp(math.abs((ss_range + ss_peak / 2) - range) / (ss_width / 2), 0, 1)
            else
                f = 1 - math.Clamp(math.abs((ss_range - ss_peak / 2) - range) / (ss_width / 2), 0, 1)
            end
            if self:GetProcessedValue("CurvedDamageScaling", true) then
                f = math.cos((f + 1) * math.pi) / 2 + 0.5
            end
            return f
        end
    end

    return 0
end

local damageAtRangeHook = {}
local emptyTable = {}

function SWEP:GetDamageAtRange(range)
    local damagelut = self:GetProcessedValue("DamageLookupTable", true)

    local dmgMin = self:GetProcessedValue("DamageMin")

    local num = self:GetProcessedValue("Num")
    if num <= 0 then
        return 0 -- avoid divide-by-zero
    end

    local dmgv = dmgMin

    if damagelut then
        for i, tbl in ipairs(damagelut) do
            if range < tbl[1] then
                if self:GetProcessedValue("CurvedDamageScaling", true) and i > 1 then
                    local tbl2 = damagelut[i - 1]
                    dmgv = Lerp(1 - math.Clamp((tbl[1] - range) / (tbl[1] - tbl2[1]), 0, 1), tbl2[2], tbl[2])
                else
                    dmgv = tbl[2]
                end
                break
            end
        end
    else
        local d = self:GetDamageDeltaAtRange(range)
        dmgv = Lerp(d, self:GetProcessedValue("DamageMax"), dmgMin)
        dmgv = self:GetProcessedValue("Damage", nil, dmgv)
    end

    local sweetspot_d = self:GetSweetSpotDeltaAtRange(range)
    if sweetspot_d > 0 then
        dmgv = Lerp(sweetspot_d, dmgv, self:GetProcessedValue("SweetSpotDamage", true))
    end

    if self:GetProcessedValue("DistributeDamage", true) then
        dmgv = dmgv / num
    elseif self:GetProcessedValue("NormalizeNumDamage", true) then
        dmgv = dmgv / (num / self.Num)
    end

    damageAtRangeHook.dmg = dmgv
    damageAtRangeHook.range = range
    damageAtRangeHook.d = d

    local data = self:RunHook("Hook_GetDamageAtRange", damageAtRangeHook) or emptyTable

    dmgv = data.dmg or dmgv

    return dmgv
end

function SWEP:GetShootPos()
    local owner = self:GetOwner()

    if !IsValid(owner) then return Vector(), Angle() end

    if SERVER and owner:IsNPC() then
        return owner:GetShootPos()
    end

    local pos = owner:EyePos()

    local ang = self:GetShootDir()
    local height = ang:Up()

    height:Mul(self:GetProcessedValue("HeightOverBore", true))
    pos:Add(height)

    --pos = pos + (owner:EyeAngles():Right() * self:GetLeanOffset())

    local rightVec = owner:EyeAngles():Right()
    rightVec:Mul(self:GetLeanOffset())

    pos:Add(rightVec)

    local shootposoffset = self:GetProcessedValue("ShootPosOffset", true)

    local angRight = ang:Right()
    local angForward = ang:Forward()
    local angUp = ang:Up()

    angRight:Mul(shootposoffset[1])
    angForward:Mul(shootposoffset[2])
    angUp:Mul(shootposoffset[3])

    pos:Add(angRight)
    pos:Add(angForward)
    pos:Add(angUp)

    pos, ang = self:GetRecoilOffset(pos, ang)

    return pos, ang
end

function SWEP:GetShootDir()
    local owner = self:GetOwner()
    if !owner:IsValid() then return self:GetAngles() end
    local dir = owner:EyeAngles()
    local shootangoffset = self:GetProcessedValue("ShootAngOffset", true)

    dir:RotateAroundAxis(dir:Right(), shootangoffset[1])
    dir:RotateAroundAxis(dir:Up(), shootangoffset[2])
    dir:RotateAroundAxis(dir:Forward(), shootangoffset[3])

    dir:Add(self:GetFreeAimOffset())

    local fswayang = self:GetFreeSwayAngles()

    if fswayang then dir:Add(fswayang) end

    if self.InertiaEnabled then dir:Add(self:GetInertiaSwayAngles()) end

    return dir
end

function SWEP:ShootRocket()
    if CLIENT then return end

    local owner = self:GetOwner()

    local src = self:GetShootPos()
    local dir = self:GetShootDir()

    local num = self:GetProcessedValue("Num")
    local ent = self:GetProcessedValue("ShootEnt", true)

    local spread

    if owner:IsNPC() then
        spread = self:GetNPCBulletSpread()
    else
        spread = self:GetProcessedValue("Spread")
    end

    spread = math.max(spread, 0)

    for i = 1, num do
        local dispersion = Angle(math.Rand(-1, 1), math.Rand(-1, 1), 0)
        dispersion:Mul(spread * 36)
        dispersion:Add(dir)
        local rocket = ents.Create(ent)
        if !IsValid(rocket) then return end

        rocket:SetOwner(owner)
        rocket:SetPos(src)
        rocket:SetAngles(dispersion)
        rocket:Spawn()
        rocket.Owner = owner
        rocket.Weapon = self

        rocket.ShootEntData = table.Copy(self:GetProcessedValue("ShootEntData", true) or {})
        rocket.ShootEntData.Target = IsValid(self:GetLockOnTarget()) and self:GetLockedOn() and self:GetLockOnTarget()
        rocket.ShootEntData = self:RunHook("Hook_GetShootEntData", rocket.ShootEntData)
        rocket.ARC9Projectile = true

        if self:GetProcessedValue("Detonator", true) then
            self:SetDetonatorEntity(rocket)
        end

        local phys = rocket:GetPhysicsObject()

        if phys:IsValid() then
            local vec = dispersion:Forward()
            vec:Mul(self:GetProcessedValue("ShootEntForce"))

            phys:AddVelocity(vec)
            if self:GetProcessedValue("ShootEntInheritPlayerVelocity", true) then
                phys:AddVelocity(owner:GetVelocity())
            end
        end
    end
end

function SWEP:FireAnimationEvent( pos, ang, event, options )
    return true
end

hook.Add("PostEntityTakeDamage", "ARC9_AP", function(ent, dmginfo, took)
    -- AP health removal only triggers if entity actually took damage. Avoids situation where you strip health from godmode players etc.
    if dmginfo:GetDamage() > 0 and took and bit.band(dmginfo:GetDamageCustom(), ARC9.DMG_CUST_AP) != 0 and ent:Health() > 0 and (ent.ARC9APDamage or 0) > 0 then
        ent:SetHealth(ent:Health() - ent.ARC9APDamage)
        if ent:Health() <= 0 then
            -- Apply damage again since setting health doesn't kill a player/npc
            -- This won't cause an infinite loop cause AP flag is removed
            dmginfo:SetDamageCustom(bit.band(dmginfo:GetDamageCustom(), bit.bnot(ARC9.DMG_CUST_AP)))
            dmginfo:SetDamage(-ent:Health() + 1)
            ent:TakeDamageInfo(dmginfo)
        end
        ent.ARC9APDamage = nil
    end
end)
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_sprint.lua:
function SWEP:GetSprintToFireTime()
    local owner = self:GetOwner()
    local slidingmult = (owner.GetSliding and owner:GetSliding()) and 0.66 or 1
    return self:GetProcessedValue("SprintToFireTime", true) * slidingmult -- Incorrectly uses a time as a multiplier! Preserved for legacy behavior
end

function SWEP:GetTraverseSprintToFireTime()
    return self:GetProcessedValue("SprintToFireTime") * 1.5
end

-- local cachedissprinting = false
-- local cachedsprinttime = 0

function SWEP:GetIsSprinting()
    -- if cachedsprinttime == CurTime() then
    --     return cachedissprinting
    -- end

    -- cachedsprinttime = CurTime()
    -- cachedissprinting = self:GetIsSprintingCheck()

    return self:GetIsSprintingCheck()
end

function SWEP:GetIsWalking()
    local owner = self:GetOwner()

    if !owner:IsValid() or owner:IsNPC() then
        return false
    end

    if owner:KeyDown(IN_SPEED) then return false end
    if !owner:KeyDown(IN_FORWARD + IN_BACK + IN_MOVELEFT + IN_MOVERIGHT) then return false end

    local curspeed = owner:GetVelocity():LengthSqr()
    if curspeed <= 0 then return false end

    return true
end

function SWEP:GetIsSprintingCheck()
    local owner = self:GetOwner()

    if !owner:IsValid() or owner:IsNPC() then
        return false
    end
    if owner:KeyDown(IN_ATTACK2) then return end
    if self:GetInSights() then return false end
    if self:GetCustomize() then return false end
    -- if self:GetIsNearWall() then return true end
    if !owner:KeyDown(IN_SPEED) then return false end
    if !owner:OnGround() or owner:GetMoveType() == MOVETYPE_NOCLIP then return false end
    if !owner:KeyDown(IN_FORWARD + IN_BACK + IN_MOVELEFT + IN_MOVERIGHT) then return false end

    if (self:GetAnimLockTime() > CurTime()) and self:GetProcessedValue("NoSprintWhenLocked", true) then
        return false
    end

    if self:GetProcessedValue("ShootWhileSprint", true) and owner:KeyDown(IN_ATTACK) then
        return false
    end

    if self:GetGrenadePrimed() then
        return false
    end

    if owner.GetSliding and owner:GetSliding() then return false end

    if owner:Crouching() then return false end

    return true
end

function SWEP:GetSprintDelta()
    return self:GetSprintAmount()
end

function SWEP:EnterSprint()
    self:SetShouldHoldType()

    if !self:GetProcessedValue("ReloadWhileSprint", true) then
        self:CancelReload()
    end

    if !self:StillWaiting() then
        if self:GetProcessedValue("InstantSprintIdle", true) then
            self:PlayAnimation("idle")
        else
            local anim = self:TranslateAnimation("enter_sprint")
            local mult = self:GetSprintToFireTime()
            if self:GetAnimationEntry(anim).NoStatAffectors then
                mult = 1
            end
            self:PlayAnimation(anim, mult, nil, nil, nil, true)
        end
    end
end

function SWEP:ExitSprint()
    self:SetShouldHoldType()

    if !self:StillWaiting() then
        if self:GetProcessedValue("InstantSprintIdle", true) then
            self:PlayAnimation("idle")
        else
            local anim = self:TranslateAnimation("exit_sprint")
            local mult = self:GetSprintToFireTime()
            if self:GetAnimationEntry(anim).NoStatAffectors then
                mult = 1
            end
            self:PlayAnimation(anim, mult, nil, nil, nil, true)
        end
    end
end

function SWEP:ThinkSprint()

    local sprinting = self:GetSafe() or self:GetIsSprinting()

    if self:GetSightAmount() >= 1 or (self:GetProcessedValue("ReloadNoSprintPos", true) and self:GetReloading() or self:StillWaiting()) then
        sprinting = false
    end

    local amt = self:GetSprintAmount()
    -- local ts_amt = self:GetTraversalSprintAmount()
    local lastwassprinting = self:GetLastWasSprinting()

    if lastwassprinting and !sprinting then
        self:ExitSprint()
    elseif !lastwassprinting and sprinting then
        self:EnterSprint()
    end

    self:SetLastWasSprinting(sprinting)

    if sprinting and !self:GetPrimedAttack() then
        if amt < 1 then
            amt = math.Approach(amt, 1, FrameTime() / self:GetSprintToFireTime())
        end
        -- if self:GetTraversalSprint() then
        --     ts_amt = math.Approach(ts_amt, 1, FrameTime() / (self:GetTraverseSprintToFireTime()))
        -- end
    else
        if amt > 0 then
            amt = math.Approach(amt, 0, FrameTime() / self:GetSprintToFireTime())
        end
    end

    -- if !self:GetTraversalSprint() then
    --     ts_amt = math.Approach(ts_amt, 0, FrameTime() / (self:GetTraverseSprintToFireTime()))
    -- end

    -- self:SetTraversalSprintAmount(ts_amt)
    self:SetSprintAmount(amt)

    -- if self:GetOwner():KeyDown(IN_FORWARD) and self:GetOwner():KeyPressed(IN_SPEED) then
    --     if self:GetLastPressedWTime() >= (CurTime() - 0.33) then
    --         self:SetTraversalSprint(true)
    --     else
    --         self:SetLastPressedWTime(CurTime())
    --     end
    -- end

    -- if self:GetTraversalSprint() then
    --     if !sprinting then
    --         self:SetTraversalSprint(false)
    --     end

    --     if !self:GetOwner():KeyDown(IN_FORWARD) then
    --         self:SetTraversalSprint(false)
    --     end

    --     if self:GetSprintAmount() <= 0 then
    --         self:SetTraversalSprint(false)
    --     end
    -- end
end
--PATH lua/weapons/arccw_base/cl_scope.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/cl_scope.lua:
function SWEP:AdjustMouseSensitivity()
    if self:GetState() != ArcCW.STATE_SIGHTS then return end

    local threshold = ArcCW.ConVars["adjustsensthreshold"]:GetFloat()

    local irons = self:GetActiveSights() or {}

    local tmag = ((irons.Magnification or 1) + (irons.ScopeMagnification or 0))

    if tmag < threshold then return end

    return 1 / tmag
end

function SWEP:Scroll(var)
    local irons = self:GetActiveSights()

    if irons.ScrollFunc == ArcCW.SCROLL_ZOOM then
        if !irons.ScopeMagnificationMin then return end
        if !irons.ScopeMagnificationMax then return end

        local old = irons.ScopeMagnification

        local minus = var < 0

        var = math.abs(irons.ScopeMagnificationMax - irons.ScopeMagnificationMin)

        var = var / (irons.ZoomLevels or 5)

        if minus then
            var = var * -1
        end

        irons.ScopeMagnification = irons.ScopeMagnification - var

        irons.ScopeMagnification = math.Clamp(irons.ScopeMagnification, irons.ScopeMagnificationMin, irons.ScopeMagnificationMax)

        self.SightMagnifications[irons.Slot or 0] = irons.ScopeMagnification

        if old != irons.ScopeMagnification then
            self:MyEmitSound(irons.ZoomSound or "", 75, math.Rand(95, 105), 1, CHAN_ITEM)
        end

        -- if !irons.MinZoom then return end
        -- if !irons.MaxZoom then return end

        -- local old = irons.Magnification

        -- irons.Magnification = irons.Magnification - var

        -- irons.Magnification = math.Clamp(irons.Magnification, irons.MinZoom, irons.MaxZoom)

        -- if old != irons.Magnification then
        --     self:MyEmitSound(irons.ZoomSound or "", 75, 100, 1, CHAN_ITEM)
        -- end
    end

end

local ang0 = Angle(0, 0, 0)

SWEP.ViewPunchAngle = Angle(ang0)
SWEP.ViewPunchVelocity = Angle(ang0)

function SWEP:OurViewPunch(angle)
    self.ViewPunchVelocity:Add(angle)
    for i = 1, 3 do self.ViewPunchVelocity[i] = math.Clamp(self.ViewPunchVelocity[i], -180, 180) end
end

function SWEP:GetOurViewPunchAngles()
    local a = self:GetOwner():GetViewPunchAngles()
    for i = 1, 3 do a[i] = a[i] + self.ViewPunchAngle[i] * 10 end
    return a
end

local function lensqr(ang)
    return (ang[1] ^ 2) + (ang[2] ^ 2) + (ang[3] ^ 2)
end

-- scraped from source SDK 2013, just like this viewpunch damping code
local PUNCH_DAMPING = 9
local PUNCH_SPRING_CONSTANT = 120

function SWEP:DoOurViewPunch()
    -- if ( player->m_Local.m_vecPunchAngle->LengthSqr() > 0.001 || player->m_Local.m_vecPunchAngleVel->LengthSqr() > 0.001 )

    local vpa = self.ViewPunchAngle
    local vpv = self.ViewPunchVelocity

    if lensqr(vpa) + lensqr(vpv) > 0.000001 then
        -- {
        --     player->m_Local.m_vecPunchAngle += player->m_Local.m_vecPunchAngleVel * gpGlobals->frametime;
        --     float damping = 1 - (PUNCH_DAMPING * gpGlobals->frametime);

        local ft = FrameTime()

        vpa = vpa + (vpv * ft)
        local damping = 1 - (PUNCH_DAMPING * ft)

        --     if ( damping < 0 )
        --     {
        --         damping = 0;
        --     }

        if damping < 0 then damping = 0 end

        --     player->m_Local.m_vecPunchAngleVel *= damping;

        vpv = vpv * damping

        --     // torsional spring
        --     // UNDONE: Per-axis spring constant?
        --     float springForceMagnitude = PUNCH_SPRING_CONSTANT * gpGlobals->frametime;
        local springforcemagnitude = PUNCH_SPRING_CONSTANT * ft
        --     springForceMagnitude = clamp(springForceMagnitude, 0.f, 2.f );
        springforcemagnitude = math.Clamp(springforcemagnitude, 0, 2)
        --     player->m_Local.m_vecPunchAngleVel -= player->m_Local.m_vecPunchAngle * springForceMagnitude;
        vpv = vpv - (vpa * springforcemagnitude)

        --     // don't wrap around
        --     player->m_Local.m_vecPunchAngle.Init(
        --         clamp(player->m_Local.m_vecPunchAngle->x, -89.f, 89.f ),
        --         clamp(player->m_Local.m_vecPunchAngle->y, -179.f, 179.f ),
        --         clamp(player->m_Local.m_vecPunchAngle->z, -89.f, 89.f ) );
        -- }

        vpa[1] = math.Clamp(vpa[1], -89.9, 89.9)
        vpa[2] = math.Clamp(vpa[2], -179.9, 179.9)
        vpa[3] = math.Clamp(vpa[3], -89.9, 89.9)

        self.ViewPunchAngle = vpa
        self.ViewPunchVelocity = vpv
    else
        self.ViewPunchAngle = Angle(ang0)
        self.ViewPunchVelocity = Angle(ang0)
    end
end

-- viewbob during reload and firing shake
SWEP.ProceduralViewOffset = Angle(ang0)
local procedural_spdlimit = 5
local oldangtmp
local mzang_fixed,mzang_fixed_last
local mzang_velocity = Angle(ang0)
local progress = 0
local targint,targbool

function SWEP:CoolView(ply, pos, ang, fov)
    if !ang then return end
    if ply != LocalPlayer() then return end
    if ply:ShouldDrawLocalPlayer() then return end
    local vm = ply:GetViewModel()
    if !IsValid(vm) then return end
    local ftv = FrameTime()

    local gunbone, gbslot = self:GetBuff_Override("LHIK_CamDriver")
    local lhik_anim_model = gbslot and self.Attachments[gbslot].GodDriver and self.Attachments[gbslot].GodDriver.Model
    if IsValid(lhik_anim_model) and lhik_anim_model:GetAttachment(gunbone) then
        local catang = lhik_anim_model:GetAttachment(gunbone).Ang

        catang:Sub( Angle( 0, 90, 90 ) )
        catang.y = -catang.y
        local r = catang.r
        catang.r = -catang.p
        catang.p = -r

        ang:RotateAroundAxis( ang:Right(),		catang.x )
        ang:RotateAroundAxis( ang:Up(),			catang.y )
        ang:RotateAroundAxis( ang:Forward(),	catang.z )

    end

    -- Cam_Offset_Ang might not always be assigned properly. Try not to use it if it's nil, or it'll tilt the player's view.
    local att = self:GetBuff_Override("Override_CamAttachment", self.CamAttachment) or -1
    if vm:GetAttachment(att) and self.Cam_Offset_Ang then
        local attang = vm:WorldToLocalAngles(vm:GetAttachment(att).Ang)
        attang:Sub(self.Cam_Offset_Ang)
        ang:Add(attang)
        return
    end

    local viewbobintensity = self.ProceduralViewBobIntensity or 0.3

    if viewbobintensity == 0 then return end

    oldpostmp = pos * 1
    oldangtmp = ang * 1

    targbool = self:GetNextPrimaryFire() - .1 > CurTime()
    targint = targbool and 1 or 0
    targint = math.min(targint, 1-math.pow( vm:GetCycle(), 2 ) )
    progress = Lerp(ftv * 15, progress, targint)

    local angpos = vm:GetAttachment(self.ProceduralViewBobAttachment or self.MuzzleEffectAttachment or 1)

    if angpos and self:GetReloading() then
        mzang_fixed = vm:WorldToLocalAngles(angpos.Ang)
        mzang_fixed:Normalize()
    else return
    end

    self.ProceduralViewOffset:Normalize()

    if mzang_fixed_last then
        local delta = mzang_fixed - mzang_fixed_last
        delta:Normalize()
        mzang_velocity = mzang_velocity + delta * 2
        mzang_velocity.p = math.Approach(mzang_velocity.p, -self.ProceduralViewOffset.p * 2, ftv * 20)
        mzang_velocity.p = math.Clamp(mzang_velocity.p, -procedural_spdlimit, procedural_spdlimit)
        self.ProceduralViewOffset.p = self.ProceduralViewOffset.p + mzang_velocity.p * ftv
        self.ProceduralViewOffset.p = math.Clamp(self.ProceduralViewOffset.p, -90, 90)
        mzang_velocity.y = math.Approach(mzang_velocity.y, -self.ProceduralViewOffset.y * 2, ftv * 20)
        mzang_velocity.y = math.Clamp(mzang_velocity.y, -procedural_spdlimit, procedural_spdlimit)
        self.ProceduralViewOffset.y = self.ProceduralViewOffset.y + mzang_velocity.y * ftv
        self.ProceduralViewOffset.y = math.Clamp(self.ProceduralViewOffset.y, -90, 90)
        mzang_velocity.r = math.Approach(mzang_velocity.r, -self.ProceduralViewOffset.r * 2, ftv * 20)
        mzang_velocity.r = math.Clamp(mzang_velocity.r, -procedural_spdlimit, procedural_spdlimit)
        self.ProceduralViewOffset.r = self.ProceduralViewOffset.r + mzang_velocity.r * ftv
        self.ProceduralViewOffset.r = math.Clamp(self.ProceduralViewOffset.r, -90, 90)
    end

    self.ProceduralViewOffset.p = math.Approach(self.ProceduralViewOffset.p, 0, (1 - progress) * ftv * -self.ProceduralViewOffset.p)
    self.ProceduralViewOffset.y = math.Approach(self.ProceduralViewOffset.y, 0, (1 - progress) * ftv * -self.ProceduralViewOffset.y)
    self.ProceduralViewOffset.r = math.Approach(self.ProceduralViewOffset.r, 0, (1 - progress) * ftv * -self.ProceduralViewOffset.r)
    mzang_fixed_last = mzang_fixed
    local ints = 3 * ArcCW.ConVars["vm_coolview_mult"]:GetFloat() * -viewbobintensity
    ang:RotateAroundAxis(ang:Right(), Lerp(progress, 0, -self.ProceduralViewOffset.p) * ints)
    ang:RotateAroundAxis(ang:Up(), Lerp(progress, 0, self.ProceduralViewOffset.y / 2) * ints)
    ang:RotateAroundAxis(ang:Forward(), Lerp(progress, 0, self.ProceduralViewOffset.r / 3) * ints)

    ang = LerpAngle(0, ang, oldangtmp)
end

function SWEP:CalcView(ply, pos, ang, fov)
    if !CLIENT then return end

    if ArcCW.ConVars["vm_coolview"]:GetBool() then
        self:CoolView(ply, pos, ang, fov)
    end

    if ArcCW.ConVars["shake"]:GetBool() and !engine.IsRecordingDemo() then
        local de = (0.2 + (self:GetSightDelta()*0.8))
        ang = ang + (AngleRand() * self.RecoilAmount * 0.006 * de)
    end

    ang = ang + (self.ViewPunchAngle * 10)

    return pos, ang, fov
end

function SWEP:ShouldGlint()
    return self:GetBuff_Override("ScopeGlint") and self:GetState() == ArcCW.STATE_SIGHTS
end

function SWEP:DoScopeGlint()
end
--PATH lua/weapons/arccw_base/sh_customize.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/sh_grenade.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/sh_timers.lua:
local tbl     = table
local tbl_ins = tbl.insert

local tick = 0

function SWEP:InitTimers()
    self.ActiveTimers = {} -- { { time, id, func } }
end

function SWEP:SetTimer(time, callback, id)
    if !IsFirstTimePredicted() then return end

    tbl_ins(self.ActiveTimers, { time + CurTime(), id or "", callback })
end

function SWEP:TimerExists(id)
    for _, v in pairs(self.ActiveTimers) do
        if v[2] == id then return true end
    end

    return false
end

function SWEP:KillTimer(id)
    local keeptimers = {}

    for _, v in pairs(self.ActiveTimers) do
        if v[2] != id then tbl_ins(keeptimers, v) end
    end

    self.ActiveTimers = keeptimers
end

function SWEP:KillTimers()
    self.ActiveTimers = {}
end

function SWEP:ProcessTimers()
    local keeptimers, UCT = {}, CurTime()

    if CLIENT and UCT == tick then return end

    if !self.ActiveTimers then self:InitTimers() end

    for _, v in pairs(self.ActiveTimers) do
        if v[1] <= UCT then v[3]() end
    end

    for _, v in pairs(self.ActiveTimers) do
        if v[1] > UCT then tbl_ins(keeptimers, v) end
    end

    self.ActiveTimers = keeptimers
end

local function DoShell(wep, data)
    if !(IsValid(wep) and IsValid(wep:GetOwner())) then return end

    local att = data.att or wep:GetBuff_Override("Override_CaseEffectAttachment") or wep.CaseEffectAttachment or 2

    if !att then return end

    local getatt = wep:GetAttachment(att)

    if !getatt then return end

    local pos, ang = getatt.Pos, getatt.Ang

    local ed = EffectData()
    ed:SetOrigin(pos)
    ed:SetAngles(ang)
    ed:SetAttachment(att)
    ed:SetScale(1)
    ed:SetEntity(wep)
    ed:SetNormal(ang:Forward())
    ed:SetMagnitude(data.mag or 100)

    util.Effect(data.e, ed)
end

function SWEP:PlaySoundTable(soundtable, mult, start, key)
    --if CLIENT and game.SinglePlayer() then return end

    local owner = self:GetOwner()

    start = start or 0
    mult  = 1 / (mult or 1)

    for _, v in pairs(soundtable) do
        if table.IsEmpty(v) then continue end

        local ttime
        if v.t then
            ttime = (v.t * mult) - start
        else
            continue
        end
        if ttime < 0 then continue end
        if !(IsValid(self) and IsValid(owner)) then continue end

        local jhon = CurTime() + ttime

        --[[if game.SinglePlayer() then
            if SERVER then
                net.Start("arccw_networksound")
                v.ntttime = ttime
                net.WriteTable(v)
                net.WriteEntity(self)
                net.Send(owner)
            end
        end]]

        -- i may go fucking insane
        if !self.EventTable[1] then self.EventTable[1] = {} end

        for i, de in ipairs(self.EventTable) do
            if de[jhon] then
                if !self.EventTable[i + 1] then
                    --[[print(CurTime(), "Occupier at " .. i .. ", creating " .. i+1)]]
                    self.EventTable[i + 1] = {}
                    continue
                end
            else
                self.EventTable[i][jhon] = table.Copy(v)
                self.EventTable[i][jhon].StartTime = CurTime()
                self.EventTable[i][jhon].AnimKey = key
                -- print(CurTime(), "Clean at " .. i)
            end
        end
    end
end

function SWEP:PlayEvent(v)
    if !v or !istable(v) then error("no event to play") end
    v = self:GetBuff_Hook("Hook_PrePlayEvent", v) or v
    if v.e and IsFirstTimePredicted() then
        DoShell(self, v)
    end

    if v.s then
        if v.s_km then
            self:StopSound(v.s)
        end
        self:MyEmitSound(v.s, v.l, v.p, v.v, v.c or CHAN_AUTO)
    end

    if v.bg then
        self:SetBodygroupTr(v.ind or 0, v.bg)
    end

    if v.pp then
        local vm = self:GetOwner():GetViewModel()

        vm:SetPoseParameter(pp, ppv)
    end

    v = self:GetBuff_Hook("Hook_PostPlayEvent", v) or v
end


if CLIENT then
    net.Receive("arccw_networksound", function(len)
        local v = net.ReadTable()
        local wep = net.ReadEntity()

        wep.EventTable[CurTime() + v.ntttime] = v
    end)
end
--PATH lua/weapons/arccw_base/sh_util.lua:
return gluapack()()
--PATH lua/weapons/arccw_base_nade/shared.lua:
SWEP.Base = "arccw_base"

SWEP.Throwing = true
SWEP.Singleton = false -- for grenades, means that weapons ARE ammo; hold one, use one.

SWEP.NotForNPCs = true

SWEP.Delay = 1
SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "NADE"
    },
}

SWEP.MuzzleVelocity = 1000
SWEP.MuzzleVelocityAlt = nil -- Throwing with alt-fire will use this velocity if exists

SWEP.PullPinTime = 0.25
SWEP.FuseTime = 3.5

SWEP.WindupTime = 0.5 -- Time to reach max velocity (does not apply for altfire)
SWEP.WindupMinimum = 0.25 -- Velocity fraction if released without windup

SWEP.ShootEntityDelay = 0.25 -- Delay between Throw() call and projectile existing

SWEP.ThrowInertia = nil -- override default throw intertia settings

SWEP.CookPrimFire = true
SWEP.CookAltFire = true

SWEP.ChamberSize = 0

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "slam"
SWEP.HoldtypeSights = "grenade"
SWEP.HoldtypeCustomize = "slam"

SWEP.Primary.ClipSize = 1
SWEP.Primary.Ammo = "grenade"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE
SWEP.AnimShootAlt = ACT_HL2MP_GESTURE_RANGE_ATTACK_SLAM

-- By default, grenades with no ammo will be stripped. Set true to prevent
SWEP.KeepIfEmpty = false

SWEP.Animations = {
    -- ["draw"] = {
    --     Source = "draw",
    --     Time = 0.5,
    -- },
    -- ["ready"] = {
    --     Source = "draw",
    --     Time = 0.5,
    -- },
    -- ["pre_throw"] = {
    --     Source = "pullpin",
    --     Time = 0.5,
    -- },
    -- ["throw"] = {
    --     Source = "throw",
    --     Time = 0.5
    -- }
}

SWEP.BashPreparePos = Vector(2.187, -7.117, -1)
SWEP.BashPrepareAng = Angle(5, -3.652, -19.039)

SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)

SWEP.HolsterPos = Vector(0.532, -1, 0)
SWEP.HolsterAng = Angle(-10, 0, 0)

SWEP.IronSightStruct = false

SWEP.MeleeSwingSound = "weapons/arccw/m249/m249_draw.wav"
SWEP.MeleeHitSound = "weapons/arccw/knife/knife_hitwall1.wav"
SWEP.MeleeHitNPCSound = "physics/body/body_medium_break2.wav"

SWEP.ShootWhileSprint = true

SWEP.SpeedMult = 1

SWEP.Secondary.Automatic = true

function SWEP:SecondaryAttack()
    self:PrimaryAttack()
end

function SWEP:OnRemove()
    if engine.ActiveGamemode() != "terrortown" then return end
    if CLIENT and IsValid(self:GetOwner()) and self:GetOwner() == LocalPlayer() and self:GetOwner():Alive() then
        RunConsoleCommand("use", "weapon_ttt_unarmed")
    end
end
--PATH lua/weapons/arccw_dual_bx_e5.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "[ ArcCW ] CIS TFA Weapons"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Dual E-5 BX"
SWEP.Trivia_Class = "CIS Dual Blaster Carbine"
SWEP.Trivia_Desc = "High tech compact Dual E-5 BX Blaster Carbine."
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel = "models/arccw/weapons/synbf3/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dual_e5bx.png"

SWEP.DefaultBodygroups = "000000000000"
SWEP.NoHideLeftHandInCustomization = true

SWEP.Damage = 38
SWEP.RangeMin = 150
SWEP.DamageMin = 22
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 1.4
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 380
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },    
}

SWEP.AccuracyMOA = 0.75 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 800 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/e5.wav"

SWEP.MuzzleFlashColor = Color(255, 0, 0, 50)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1.2,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -4)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)

SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(0, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)
SWEP.DrawCrosshair = true

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"e5", "e5+"}

SWEP.AttachmentElements = {
    ["e5"] = {
        VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "LeftHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(4, -1.5, -1),
                    ang = Angle(-4, -2, 90)
                }
            }
        },
    },
    ["e5+"] = {
         VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "RightHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),                
                Offset = {
                    pos = Vector(-4, 1.5, 1),
                    ang = Angle(-4, 178, 90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(40.5, 10, 20.75),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-40, 230, -25),
                    ang = Angle(180, -180, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-12, -4, 2.5),
            vang = Angle(170, 0, 0),
        },
    },    
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    }
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_lw", "shoot_rw"},
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_a274su.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_a620su.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_bryar.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Bryar Extended"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The Bryar pistol was a type of blaster pistol. Models of Bryar pistol included the K-16 Bryar Pistol and MW-20 Bryar pistol"
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/bryar.png"

-- Base
SWEP.DefaultBodygroups = "011000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_bryar.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 38
SWEP.DamageMin =22
SWEP.RangeMin = 0
SWEP.Range = 260
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(192, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_purple"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 1
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 0.9

SWEP.Delay = 60 / 260
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_BRYAR"
SWEP.ShootSound = "ArcCW_Kraken.SW_BRYAR"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_purple"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(192, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.04, -11.296, 1),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.01, -2.2, -2.5),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.9, -1.4, 3),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.4, -0.5, -3.9),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.5, -1.6, -2.5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_bryar_extended.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_cr2s.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_cyclerobrez.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17_akimbo.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Dual DC-17"
SWEP.Trivia_Class = "Hand Blaster"
SWEP.Trivia_Desc = "The DC-17 repeater hand blaster, also known more simply as the DC-17 hand blaster or DC-17 blaster pistol, was a model of heavy blaster pistol and the Grand Army of the Republic's standard-issue sidearm. Produced by BlasTech Industries, the DC-17 was usually given to weapon teams, the crews of vehicles, and officers. The weapon was one of the most reliable and toughest models of blaster pistols created, as well as having remarkable stopping power in its small design. The weapon was also well balanced, possessed a respectable rate of fire, and lightweight."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc17_dual.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"

SWEP.MirrorVMWM = false
SWEP.NoHideLeftHandInCustomization = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc17_akimbo.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 65

SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 2
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = true

SWEP.InfiniteAmmo = true
SWEP.BottomlessClip = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 22
SWEP.DamageMin = 19
SWEP.RangeMin = 0
SWEP.Range = 180
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.Recoil = 0.9
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.55

SWEP.Delay = 60 / 250
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC17"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC17"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = nil
SWEP.MuzzleFlashColor = nil

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(0,0,0),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = "duel"
SWEP.HoltypeCustomize = "normal"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(0, -10, -10)
SWEP.SprintAng = Angle(25, 0, 0)

SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(0, -5.226, 1)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(0, -4, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"dc17"}
SWEP.AttachmentElements = {
    ["dc17"] = {
        WMElements = {
            {
                Model = "models/arccw/kraken/republic/v_dc17.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1,1,1),
                Offset = {
                    pos = Vector(-170, 50, -65),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/kraken/republic/v_dc17.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1,1,1),
                Offset = {
                    pos = Vector(-265, 275, -120),
                    ang = Angle(180, -180, 2)
                }
            },
        },   
    }
}
WMOverride = "models/arccw/kraken/republic/v_dc17.mdl"

SWEP.Attachments = {
    {
        PrintName = "Energization",
        DefaultAttName = "Standard",
        Slot = {"ammo"}
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_pistol"},
    },   
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    }, 
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "bash",
    },
    ["idle_iron"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = {"shoot_l", "shoot_r"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot_l", "shoot_r"},
        Mult = 2,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 25/30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["enter_inspect"] = {
        Source = "lookat01",
        Mult = 2,
    },
    ["idle_inspect"] = {
        Source = "lookat01",
        Mult = 2,
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17s_dual.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dl44_akimbo.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dl44_akimbo.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DL-44 Akimbo"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DL-44 heavy blaster pistol, also known more simply as a DL-44 blaster pistol, was a type of heavy blaster pistol produced by BlasTech Industries that was used during the years of the Galactic Republic and the Age of the Empire. It was considered one of the most powerful blaster pistols in the galaxy, delivering massive damage at close range; however, it overheated quickly. This pistol can also be reconfigure into a blaster rifle by including an extended barrel with the existing flash-suppressor and an attachable stock. This version was used by Tobias Beckett in the trenches of Mimban before he deconstructed his DL-44 and gave it to Han Solo, who used it for the rest of his life."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/dl44_akimbo.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_akimbo_dl44.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.NoHideLeftHandInCustomization = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 62
SWEP.DamageMin = 45
SWEP.RangeMin = 0
SWEP.Range = 250
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 1
SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0.6

SWEP.Delay = 60 / 260
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DH17"
SWEP.ShootSound = "ArcCW_Kraken.SW_DH17"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = false
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(0, 0, 0),
    Ang = Angle(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = "duel"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -4, -17)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.ReloadPos = Vector(0, -5, -0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(10, 0, 0)

-- Attachments
SWEP.DefaultElements = {"dl44dual"}
SWEP.AttachmentElements = {
    ["dl44dual"] = {
        WMElements = {
            {
                Model = "models/arccw/kraken/galactic/v_dl44.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                ModelBodygroups = "001000000000",
                Offset = {
                    pos = Vector(-200, 70, -65),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/kraken/galactic/v_dl44.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                ModelBodygroups = "001000000000",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-300, 290, -110),
                    ang = Angle(180, -180, 2)
                }
            },
        },   
    }
}WMOverride = "models/arccw/kraken/galactic/v_dl44.mdl"

SWEP.Attachments = {
    {
        PrintName = "Energization",
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    }, 
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "bash",
    },
    ["idle_iron"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = {"shoot_l", "shoot_r"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot_l", "shoot_r"},
        Mult = 2,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 20 / 30},
            {s = "ArcCW_Kraken.Grab", t = 35 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 20 / 30},
            {s = "ArcCW_Kraken.Grab", t = 35 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["enter_inspect"] = {
        Source = "lookat01",
        Mult = 2,
    },
    ["idle_inspect"] = {
        Source = "lookat01",
        Mult = 2,
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dlt16.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dlt19.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dlt19h.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DLT-19h"
SWEP.Trivia_Class = "Prototype Heavy Rifle"
SWEP.Trivia_Desc = "Before the DLT-19, the DLT-16 existed as a prototype of a Heavy Rifle for Infantry usage. This weapon, like many others, continued to use bullet casings, however, it had a special system that when they were hammered, the explosion of the tibanna gas was compressed and transformed into a blaster projectile. The DLT-19 heavy blaster rifle was a model of heavy blaster rifle manufactured by BlasTech Industries. They were used by regular stormtroopers and Heavy Weapons Stormtroopers of the Galactic Empire, but they also saw use by other parties, including the Alliance to Restore the Republic and certain bounty hunters."
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.IconOverride = "entities/kraken/galactic/dlt19h.png"

-- Base
SWEP.DefaultBodygroups = "010010000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_dlt19.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-1, 1, -2.4),
    ang = Angle(-5, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 75
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 44
SWEP.DamageMin = 29
SWEP.RangeMin = 0
SWEP.Range = 400
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 150

SWEP.Recoil = 0.79
SWEP.RecoilSide = 0.34
SWEP.RecoilRise = 0.98
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 600
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.86
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DLT16"
SWEP.ShootSound = "ArcCW_Kraken.SW_DLT16"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.65, -2, 1.3),
    Ang = Angle(1.8, 0.3 , 4.25),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-2, 2, -0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(8, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.HolsterPos = Vector(4, -3, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 3, bg = 3}},
    },
    ["laser_attach"] = {
        VMBodygroups = {{ind = 6, bg = 1}},
    },
    ["grip_attach"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "j_lever",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(2.5, -0.5, -0),
            vang = Angle(180, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "tag_attachments",
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(36, -0.05, 0),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "tag_attachments",
        InstalledEles = {"laser_attach"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(27, 1, 0),
            vang = Angle(0, 0, -90),
        },
    },
    {
        PrintName = "Foregrip", 
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "tag_attachments",
        InstalledEles = {"grip_attach"},
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(15.8, 0, -0.8),
            vang = Angle(0, -0, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(0.2, 0.1, -2.3),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(0.45, -0.65, -2.5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/dlt19/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
    },
    ["reload"] = {
        Source = "jam_fix",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
        SoundTable = {
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_start.ogg", t = 0.1/30},
            {s = "ArcCW_Kraken.Overheat", t = 12/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_boltopen_01.ogg", t = 12/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_boltclose_01.ogg", t = 24/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 24/30},
            {s = path .. "wfoly_plr_lm_mgolf34_reload_fast_end.ogg", t = 24/30},
        },
    },
    ["ready"] = {
        Source = "draw",
        LHIK = true,
		MinProgress = 0.7,
        SoundTable = {
            {s = path .. "wfoly_plr_lm_mgolf34_raise_first_pull.ogg", t = 0.1/30},
            {s = path .. "wfoly_plr_lm_mgolf34_raise_first_start.ogg", t = 6/30},
			{s = path .. "wfoly_plr_lm_mgolf34_raise_first_boltopen_01.ogg", t = 31/30},
			{s = path .. "wfoly_plr_lm_mgolf34_raise_first_boltclose_01.ogg", t = 40/30},
			{s = path .. "wfoly_plr_lm_mgolf34_raise_first_end.ogg", t = 56/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
        LHIK = true,
		MinProgress = 0.5,
        SoundTable = {
            {s = path .. "wfoly_plr_lm_mgolf34_raise_up.ogg", t = 10/30},
            {s = path .. "wfoly_plr_lm_mgolf34_raise_settle.ogg", t = 34/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_plr_lm_mgolf34_reload_raise.ogg", t = 0.1/30},
            {s = path .. "wfoly_plr_lm_mgolf34_reload_open.ogg", t = 10/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["exit_inspect"] = {
        Source = "lookat01",
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_lm_mgolf34_inspect_01.ogg", t = 0.1/30},
			{s = path .. "wfoly_lm_mgolf34_inspect_02.ogg", t = 54/30},
			{s = path .. "wfoly_lm_mgolf34_inspect_03.ogg", t = 120/30},
        },
    },
    ["bash"] = {
        LHIK = true,
        Source = {"melee","melee2","melee3"},
    },
    ["fix"] = {
        Mult = 2,
        LHIK = true,
        Source = "jam",
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 0.1/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 10/30},
            {s = "ArcCW_Kraken.Grab", t = 11 / 30},
        },
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}

--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dp23c.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DP-23c"
SWEP.Trivia_Class = "Blaster Shotgun"
SWEP.Trivia_Desc = "The DP-23 was a type of blaster that could pierce through enemy defenses. It was used by the Grand Army of the Republic's clone troopers during the Clone Wars between the Galactic Republic and the Confederacy of Independent Systems. The DP-23 fired blue blaster bolts, and had a ridged barrel with a pointed muzzle, a black stock, and a small foregrip."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dp23c.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000100000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_dp23c.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-8, 3.5, -4),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 2
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 1
SWEP.HeatFix = true

SWEP.NoRandSpread = true
SWEP.CanBash = true

SWEP.ShotgunSpreadPattern = {
    [1] = Angle(0, 0, 0),
    [2] = Angle(0, 1, 0),
    [3] = Angle(0, -1, 0),
    [4] = Angle(2.1, 0, 0),
    [5] = Angle(-2.1, 0, 0),
    [6] = Angle(1.4, 1.2, 0),
    [7] = Angle(-1.4, 1.2, 0),
    [8] = Angle(1.4, -1.2, 0),
    [9] = Angle(-1.4, -1.2, 0),
}

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 15
SWEP.DamageMin = 7
SWEP.RangeMin = 0
SWEP.Range = 170
SWEP.Penetration = 8
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 2
SWEP.RecoilSide = 1
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.5
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 140
SWEP.Num = 9
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 75
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DP23"
SWEP.ShootSound = "ArcCW_Kraken.SW_DP23"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.008, -7.68, 0.097),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "shotgun"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(-1, 2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4, -3, -2)
SWEP.SprintAng = Angle(0, 30, -15)

SWEP.CustomizePos = Vector(15, 0, 5)
SWEP.CustomizeAng = Angle(0, 40, 30)

SWEP.HolsterPos = Vector(4, -3, -2)
SWEP.HolsterAng = Angle(0, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}, {ind = 3, bg = 0}, {ind = 2, bg = 2}},
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "DC_15X_Rifle",
               Scale = Vector(0, 0, 0),                
               Offset = {
                pos = Vector(0, 15, 0),
                ang = Angle(-90, -90, 0)
               },
               IsMuzzleDevice = true
           }
        }
    }
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "DC-15 Holosight",
        Slot = {"optic"},
        Bone = "DC_15X_Rifle",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(-0.07, 1, 2.8),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        Bone = "DC_15X_Rifle",
        Offset = {
            vpos = Vector(-1, 16, 0.5),
            vang = Angle(0, -90, -90),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC_15X_Rifle",
        Offset = {
            vpos = Vector(-0.09, 20, 0.55),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        Bone = "DC_15X_Rifle",
        Offset = {
            vpos = Vector(-0.05, 8, -1.22),
            vang = Angle(90, -90, -90),   
        }, 
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode"},
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC_15X_Rifle",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(1.15, -5.1, -0.1),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC_15X_Rifle",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(1.15, -8, 0.25),
            vang = Angle(0, -90, 0),
        },
    },
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = "fire"
    },
    ["idle_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        Mult = 1.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "arccw/kraken/empire/dlt19/handling/magrelease.wav", t = 0.2 },
            {s = "arccw/kraken/empire/dlt19/handling/magout.wav", t = 0.4 },
            {s = "arccw/kraken/empire/dlt19/handling/mag_fetch.wav", t = 0.6 },   
            {s = "arccw/kraken/empire/dlt19/handling/magin.wav", t = 1.4 },   
            {s = "arccw/kraken/empire/dlt19/handling/boltback.wav", t = 1.6 },   
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 2.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_e5s.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_ee3s.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "EE-3s"
SWEP.Trivia_Class = "Blaster Long-Range Carabine"
SWEP.Trivia_Desc = "Blaster Long-Range Carabine designed originally for military purposes, now modernized and being used by many Bounty Hunters, Civillians and even Mercenaries or Military Corporations in the galaxy."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/ee3s.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_ee3.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 16
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 39
SWEP.DamageMin = 28
SWEP.RangeMin = 0
SWEP.Range = 350
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.7
SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0.6

SWEP.Delay = 60 / 400
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_EE3"
SWEP.ShootSound = "ArcCW_Kraken.SW_EE3"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.027, 0, 1.503),
    Ang = Vector(0, 0, -2.878),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 16, -2),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.06, 1, 1.65),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.8, 8.5, 0.5),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.5, 1.5, 1.5),
        WMScale = Vector(1.5, 1.5, 1.5),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0, 13, 0.4),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Foregrip", 
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(-0., 6, -0.6),
            vang = Angle(5, -90, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.5, -1.1, -1),
            vang = Angle(-20, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.2, 4, 0.4),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_iqa11e.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_kyd21.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "KYD-21 Blaster"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "Blaster Pistol designed originally for military purposes, now modernized and being used by many Bounty Hunters, Civillians and even Mercenaries or Military Corporations in the galaxy."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/kyd21.png"

-- Base
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_kyd21.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18.5, 6, -5.4),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.NoRandSpread = true
SWEP.CanBash = true

SWEP.ShotgunSpreadPattern = {
    [1] = Angle(0, 0, 0),
    [2] = Angle(0, 1, 0),
    [3] = Angle(0, -1, 0),
    [4] = Angle(2.1, 0, 0),
    [5] = Angle(-2.1, 0, 0),
    [6] = Angle(1.4, 1.2, 0),
    [7] = Angle(-1.4, 1.2, 0),
    [8] = Angle(1.4, -1.2, 0),
    [9] = Angle(-1.4, -1.2, 0),
}

SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 21
SWEP.DamageMin = 21
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(172, 83, 255)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_purple"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 18

SWEP.Recoil = 1.5
SWEP.RecoilSide = 1
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.5
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 180
SWEP.Num = 9
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_KYD21"
SWEP.ShootSound = "ArcCW_Kraken.SW_KYD21"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_purple"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(172, 83, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.0, -11.296, 1.5),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.05, -2, -5),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA",
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(0.05, -1.45, 2.3),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.3, -1.5, 0.9),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.5, -0.2, -3.4),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.7, -0.65, -5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_launcher_hh12_empire.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Slot = 3

SWEP.Category = "[ArcCW] Kraken's Explosives - Rocket Launchers"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Empire HH-12"
SWEP.Trivia_Class = "Rocket Launcher"
SWEP.Trivia_Desc = "The HH-12 rocket launcher was a model of black-colored missile launcher used by the Special Forces of the Alliance to Restore the Republic during the Galactic Civil War against the Galactic Empire."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Rocket"
SWEP.Trivia_Country = "Galactic Republic, Galactic Empire, Rebel Alliance"
SWEP.IconOverride = "entities/kraken/explosives/hh12_imperio.png"

-- Base
SWEP.DefaultBodygroups = "0000000000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_hh12_empire.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-1, 1.3, -2.2),
    ang = Angle(0, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1.5
}

-- Damage & Tracer
SWEP.ShootEntity = "rocket_hh12"

SWEP.MuzzleVelocity = 12000

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.Recoil = 4.5
SWEP.RecoilSide = 0.550
SWEP.RecoilRise = 0.5
SWEP.RecoilPunch = 2.5
SWEP.RecoilVMShake = 1.5
SWEP.VisualRecoilMult = 0.7

SWEP.Delay = 60 / 60
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 500

-- Speed Mult
SWEP.SpeedMult = 0.825
SWEP.SightedSpeedMult = 0.85
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "RPG_Round"
SWEP.ShootVol = 120
SWEP.ShootPitch = 95
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/launchers/rps/weap_rpapa7_fire_plr_01.ogg"
SWEP.ShootSound = "kraken/launchers/rps/weap_rpapa7_fire_plr_01.ogg"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "muzzleflash_m79"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 146, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-1.04, -5, 0.31),
    Ang = Vector(16, 0, -4),
     Magnification = 4,
     SwitchToSound = "kraken/launchers/rps/wfoly_la_rpapa7_ads_up.ogg",
     SwitchFromSound = "kraken/launchers/rps/wfoly_la_rpapa7_ads_down.ogg",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "rpg"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(8, 1, 0)

SWEP.SprintPos = Vector(1, 0, -2.5)
SWEP.SprintAng = Angle(0, -2, 0)

SWEP.CrouchPos = Vector(-1, -0.5, -1)
SWEP.CrouchAng = Angle(0, 0, -5)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.Attachments = {
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_launcher_offset",
        Offset = {
            vpos = Vector(9, -1.8, 0.95),
            vang = Angle(0, 0, 90),
        },
    }, 
    {
        PrintName = "Ammunition",
        DefaultAttName = "Rocket",
        Slot = {"k_rocket_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "tag_launcher_offset",
        Offset = {
            vpos = Vector(2, -1.45, 2),
            vang = Angle(0, 0, 25),
        },
    },
}

-- Animations!
local path = "kraken/launchers/hh12/"

SWEP.Animations = {
	["enter_sights"] = {
		Source = "idle",

	},
    ["fire"] = {
        Source = "shoot1",
    },
    ["dryfire"] = {
        Source = "firemode",
		MinProgress = 0.01,
		FireASAP = true,
    },
    ["reload"] = {
        Source = "reload",
		MinProgress = 0.95,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
			{s = path .. "wfoly_la_kgolf_reload_raise.ogg", t = 0/30},
			{s = path .. "wfoly_la_kgolf_reload_raise.ogg", t = 15/30},
			{s = path .. "wfoly_la_kgolf_reload_rotate.ogg", t = 45/30},
			{s = path .. "wfoly_la_kgolf_reload_breechopen.ogg", t = 52/30},
			{s = path .. "wfoly_la_kgolf_reload_shellout.ogg", t = 65/30},
			{s = path .. "wfoly_la_kgolf_reload_shelldrop.ogg", t = 77/30},
			{s = path .. "wfoly_la_kgolf_reload_raise.ogg", t = 102/30},
			{s = path .. "wfoly_la_kgolf_reload_shellin.ogg", t = 132/30},
			{s = path .. "wfoly_la_kgolf_reload_breechclose.ogg", t = 147/30},
			{s = path .. "wfoly_la_kgolf_reload_breechclose2.ogg", t = 152/30},
			{s = path .. "wfoly_la_kgolf_reload_end.ogg", t = 157/30},
        },
    },
    ["ready"] = {
        Source = {"draw"},
        SoundTable = {
            {s = path .. "wfoly_plr_la_kgolf_raise_first_up.ogg", t = 3/30},
			{s = path .. "wfoly_plr_la_kgolf_raise_first_settle.ogg", t = 20/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
		MinProgress = 0.4,
        SoundTable = {
            {s = path .. "wfoly_plr_la_kgolf_raise_up.ogg", t = 7/30},
			{s = path .. "wfoly_plr_la_kgolf_raise_settle.ogg", t = 24/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_la_kgolf_drop_rattle.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["inspect"] = {
        Source = "lookat01",
        SoundTable = {
            {s = path .. "wfoly_la_kgolf_inspect_01.ogg", t = 1/30},
			{s = path .. "wfoly_la_kgolf_inspect_02.ogg", t = 88/30},
			{s = path .. "wfoly_la_kgolf_inspect_03.ogg", t = 135/30},
			{s = path .. "wfoly_la_kgolf_reload_raise.ogg", t = 3.25},
			{s = path .. "wfoly_la_kgolf_reload_breechopen.ogg", t = 4.21},
			{s = path .. "wfoly_la_kgolf_reload_breechclose2.ogg", t = 6.17},
			{s = path .. "wfoly_la_kgolf_reload_end.ogg", t = 6.62},
        },
    },
    ["bash"] = {
        Source = "melee_01",
    },
}


--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_launcher_plx1.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_explosives_base"
SWEP.Spawnable = true

SWEP.Slot = 3

SWEP.Category = "[ArcCW] Kraken's Explosives - Rocket Launchers"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Republic PLX-1"
SWEP.Trivia_Class = "Rocket Launcher"
SWEP.Trivia_Desc = "The Merr-Sonn PLX, or Plex, was a powerful missile launcher that was in service almost from the beginning of the Clone Wars and continued to be used in different militaries well after the conclusion of that cataclysmic conflict."
SWEP.Trivia_Manufacturer = "Merr-Sonn Munitions, Inc."
SWEP.Trivia_Calibre = "Rocket"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/kraken/explosives/plx1.png"

-- Base
SWEP.DefaultBodygroups = "0010000000000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.NoHideLeftHandInCustomization = false
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_plx1_republic.mdl"
SWEP.MirrorWorldModel = "models/arccw/kraken/sw/explosives/v_plx1_republic_mirror.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-3, 1.3, -6),
    ang = Angle(0, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.ShootEntity = "rocket_plx1"
SWEP.MuzzleVelocity = 12000

SWEP.Recoil = 4.3
SWEP.RecoilSide = 0.550
SWEP.RecoilRise = 2
SWEP.RecoilPunch = 2.5
SWEP.RecoilVMShake = 1.5
SWEP.VisualRecoilMult = 0.7

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.Delay = 60 / 180
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = -1,
        PrintName = "TOP",
        TopAttack = true
    },
    {
        Mode = -1,
        PrintName = "TOP",
        TopAttack = false
    },
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 500

-- Speed Mult
SWEP.SpeedMult = 0.65
SWEP.SightedSpeedMult = 0.64
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.62

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "RPG_Round"
SWEP.ShootVol = 120
SWEP.ShootPitch = 95
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/explosives/heat_ignite.ogg"
SWEP.ShootSound = "kraken/explosives/heat_ignite.ogg"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "muzzleflash_m79"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 192, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(3, -6, 4),
    Ang = Angle(8, 0, 19),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "rpg"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(3, -2, 4)
SWEP.ActiveAng = Angle(8, 0, 19)

SWEP.SprintPos = Vector(0, 3, -0)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(6, 4, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Attachments
SWEP.Attachments = {
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "tag_launcher_offset",
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Offset = {
            vpos = Vector(14, -4.5, -1),
            vang = Angle(0, 0, 90),
        },
    },
    {
        PrintName = "Ammunition",
        DefaultAttName = "Rocket",
        Slot = {"k_rocket_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "tag_launcher_offset",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(5, -4.5, -1),
            vang = Angle(0, 0, 0),
        },
    },
}


---- LOCK-IN FUNCTIONS
SWEP.Hook_GetShootEntData = function(self, data)
    local tracktime = math.Clamp((CurTime() - self.StartTrackTime) / self.LockTime, 0, 1)

    if tracktime >= 1 and self.TargetEntity and IsValid(self.TargetEntity) then
        data.Target = self.TargetEntity
    end
end

SWEP.Hook_DrawHUD = function(self)
local TrackingIndicator = Material("VGUI/lockon.png")
    if self:GetNWState() == ArcCW.STATE_SIGHTS and self:Clip1() > 0 then
        if self.TargetEntity and IsValid(self.TargetEntity) and self:Clip1() > 0 then
             local toscreen = self.TargetEntity:WorldSpaceCenter():ToScreen()
             local tracktime = math.Clamp((CurTime() - self.StartTrackTime) / self.LockTime, 0, 2)
             
             if tracktime >= 1 then
                surface.SetMaterial(TrackingIndicator)
                surface.SetDrawColor(0,250,0,200)
                surface.DrawTexturedRect(toscreen.x - 30, toscreen.y - 30, 60, 60) 
             else
                surface.SetMaterial(TrackingIndicator)
                surface.SetDrawColor(255,0,0,200)
                surface.DrawTexturedRect(toscreen.x - 30, toscreen.y - 30, 60, 60) 
             end
        end
    end
end


SWEP.NextBeepTime = 0
SWEP.TargetEntity = nil
SWEP.StartTrackTime = 0
SWEP.LockTime = 2

SWEP.Hook_Think = function(self)

    if self:Clip1() > 0 and self:GetNWState() == ArcCW.STATE_SIGHTS then

        if self.NextBeepTime > CurTime() then return end

        local tracktime = math.Clamp((CurTime() - self.StartTrackTime) / self.LockTime, 0, 2)

        -- if CLIENT then
        if tracktime >= 1 and self.TargetEntity then
            if CLIENT then
                self:EmitSound("kraken/explosives/reticle_locked2.ogg", 75, 100)
            end
            self.NextBeepTime = CurTime() + 0.15
        elseif tracktime >= 0 and self.TargetEntity then
            if CLIENT then
                self:EmitSound("kraken/explosives/reticle_tracking2.ogg", 75, 100)
            end
            self.NextBeepTime = CurTime() + 0.4
        else
            if CLIENT then
                self:EmitSound("", 75, 100)
            end
            self.NextBeepTime = CurTime() + 0.4
        end
        -- end
        
        local Radius = 14000
        local closest = Radius 

        local targets = ents.FindInSphere(self:GetPos(), Radius)

        local best = nil
        local targetscore = 0

        for _, ent in ipairs(targets) do
            if ent:IsWorld() then continue end
            if ent == self:GetOwner() then continue end
            if ent.IsProjectile then continue end
            if ent.UnTrackable then continue end
            if ent:GetClass():find("prop_") then continue end
			
            local aa, bb = ent:GetRotatedAABB(ent:OBBMins(), ent:OBBMaxs())
            local vol = math.abs(bb.x - aa.x) * math.abs(bb.y - aa.y) * math.abs(bb.z - aa.z)
			if vol <= 20000 then continue end

            local dot = (ent:GetPos() - self:GetShootPos()):GetNormalized():Dot(self:GetShootDir():Forward())
            local entscore = 1
            if ent:IsPlayer() then entscore = entscore + 5 end
            if ent:IsNPC() or ent:IsNextBot() then entscore = entscore + 2 end
            if ent:IsVehicle() or ent.LVS then entscore = entscore + 10 end
            if ent:Health() > 0 then entscore = entscore + 5 end

            entscore = entscore + dot * 5

            entscore = entscore + (ent.ARC9TrackingScore or 0)

            if entscore > targetscore then
                local tr = util.TraceLine({
                    start = self:GetShootPos(),
                    endpos = ent:WorldSpaceCenter(),
                    filter = self:GetOwner(),
                    mask = MASK_SHOT
                })
                if tr.Entity == ent then
                best = ent
                bestang = dot
                targetscore = entscore
                end
            end
        end

        if !best then self.TargetEntity = nil return end

        if !self.TargetEntity then
            self.StartTrackTime = CurTime()
        end

        self.TargetEntity = best
    else
        self.TargetEntity = nil
    end
end

-- Animations!
local path = "kraken/launchers/plx1/"

SWEP.Animations = {
	["enter_sights"] = {
		Source = "idle",
	},
    ["fire"] = {
        Source = "shoot1",
    },
    ["dryfire"] = {
        Source = "firemode",
		MinProgress = 0.01,
		FireASAP = true,
    },
    ["reload"] = {
        Source = "reload",
		MinProgress = 0.95,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
			{s = path .. "wfoly_plr_la_gromeo_reload_start.ogg", t = 0/30},
			{s = path .. "wfoly_plr_la_gromeo_reload_rotate.ogg", t = 22/30},
			{s = path .. "wfoly_plr_la_gromeo_reload_rockettip_01.ogg", t = 38/30},
			{s = path .. "wfoly_plr_la_gromeo_reload_grabrocket.ogg", t = 78/30},
			{s = path .. "wfoly_plr_la_gromeo_reload_load_01.ogg", t = 82/30},
			{s = path .. "wfoly_plr_la_gromeo_reload_flipup.ogg", t = 102/30},
			{s = path .. "wfoly_plr_la_gromeo_reload_arm.ogg", t = 128/30},
			{s = path .. "wfoly_plr_la_gromeo_reload_end.ogg", t = 152/30},
        },
    },
    ["ready"] = {
        Source = "draw",
        SoundTable = {
            {s = path .. "wfoly_plr_la_gromeo_raise_first_up.ogg", t = 3/30},
			{s = path .. "wfoly_plr_la_gromeo_raise_first_settle.ogg", t = 18/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
		MinProgress = 0.4,
        SoundTable = {
            {s = path .. "wfoly_plr_la_gromeo_raise_up.ogg", t = 7/30},
			{s = path .. "wfoly_plr_la_gromeo_raise_settle.ogg", t = 22/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_plr_la_gromeo_drop.ogg", t = 0/30},
            {s = path .. "wfoly_plr_la_gromeo_drop_mech.ogg", t = 5/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "melee_miss",
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_m45x.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_antitankmine.lua:
AddCSLuaFile()

SWEP.Base = "arccw_k_nade_base"
SWEP.Spawnable = true

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Explosives - Grenades"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Anti-Tank Mine"
SWEP.Trivia_Class = "Mine"
SWEP.Trivia_Desc = "A powerful anti-tank mine to destroy or disable enemy vehicles."
SWEP.Trivia_Manufacturer = "Holowan Laboratories"
SWEP.Trivia_Calibre = "High Explosive"
SWEP.Trivia_Mechanism = "Explosive"
SWEP.Trivia_Country = "Universal"
SWEP.IconOverride = "entities/kraken/explosives/at_mine.png"

-- Base
SWEP.DefaultBodygroups = "0000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_antitankmine.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-10, 5, -4),
    ang = Angle(-10, 0, -180),
    scale = 0.9,
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.ShootEntity = "nade_k_thrown_antitankmine"

SWEP.MuzzleVelocity = 800
SWEP.MuzzleVelocityAlt = 700

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.FuseTime = 3.5
SWEP.PullPinTime = 0.5

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
}



-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "slam"
SWEP.HoldtypeSights = "slam"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SLAM

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0,0,0)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4.5, -2, -1)
SWEP.CrouchAng = Angle(0, 0, -29)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    -- ["idle_primed"] = {
        -- Source = "idle_primed"
    -- },
    ["draw"] = {
        Source = "deploy",
        EventTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        EventTable = {
            {s = "ArcCW_Kraken.Explosives.Holster", t = 0.1/30},
        },
    },
    ["throw"] = {
        Source = "throw",
        EventTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.4
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"}
    },
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_blaststick.lua:
AddCSLuaFile()

SWEP.Base = "arccw_k_nade_base"
SWEP.Spawnable = true

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Explosives - Grenades"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Blast Stick"
SWEP.Trivia_Class = "Hand Grenade"
SWEP.Trivia_Desc = "When thrown, anti-vehicle grenades begin a 3 second fuse, and bounce off any surfaces they contact. Anti-vehicle grenades can stick to vehicles and will do so to the first appropriate unit they contact, including to friendlies. Anti-vehicle grenades do not deal any additional damage if stuck to a target, as compared to exploding within range."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "High Explosive Anti-Vehicle"
SWEP.Trivia_Mechanism = "Explosive"
SWEP.Trivia_Country = "Galactic Empire"
SWEP.IconOverride = "entities/kraken/explosives/blaststick.png"

-- Base
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_blaststick.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 56

SWEP.WorldModelOffset = {
    pos = Vector(2, 1, -7),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.ShootEntity = "nade_k_thrown_blaststick"

SWEP.MuzzleVelocity = 1200
SWEP.MuzzleVelocityAlt = 900

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.FuseTime = 3.5
SWEP.PullPinTime = 0.5

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
}

-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "grenade"
SWEP.HoldtypeSights = "grenade"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE

SWEP.ActivePos = Vector(0, 9, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -1, -0.3)
SWEP.SprintAng = Angle(3, -5, 0)

SWEP.CrouchPos = Vector(-0.5, -0, -1)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_primed"] = {
        Source = "idle_primed"
    },
    ["quicknade"] = {
        Source = "quick_pullout",
        MinProgress = 0.3,
        FireASAP = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["draw"] = {
        Source = "draw",
        MinProgress = 0.3,
        FireASAP = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["ready"] = {
        Source = "draw",
        MinProgress = 0.3,
        FireASAP = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Holster", t = 0.1/30},
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        MinProgress = 0.666,
		Mult = 1.5,
        FireASAP = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.PreThrow", t = 0.1/30},
        },
    },
    ["throw"] = {
        Source = "throw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.52
    },
    ["throw_alt"] = {
        Source = "throw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.52
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
		Mult = 3,
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
		Mult = 3,
    },
    ["bash"] = {
        Source = {"melee_hit01","melee_hit02","melee_hit03"},
    },
}

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_plasmagrenade.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_sequencecharger.lua:
AddCSLuaFile()

SWEP.Base = "arccw_k_nade_base"
SWEP.Spawnable = true

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Explosives - Grenades"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Sequencer Charge"
SWEP.Trivia_Class = "Mine"
SWEP.Trivia_Desc = "Sequencer Charges are military mines specially developed by Holowan Laboratories to destroy ships and facilities by targeting the vulnerable power structure. When placed precisely at key exhaust ports and power junctions, the Sequencer Charge interrupts critical regulating processes which can destabilize the core in a cascade of system failures, resulting in a catastrophic explosion. These charges can be planted offensively by raiding parties conducting boarding actions, or defensively to prevent facilities and wrecks from being captured. The intensity of the detonation can be useful for a variety of other tactical purposes as well, and these mines are frequently deployed as breaching charges to blast holes in reinforced doors or duracrete walls."
SWEP.Trivia_Manufacturer = "Holowan Laboratories"
SWEP.Trivia_Calibre = "High Explosive"
SWEP.Trivia_Mechanism = "Explosive"
SWEP.Trivia_Country = "Universal"
SWEP.IconOverride = "entities/kraken/explosives/sequence_charger.png"

-- Base
SWEP.DefaultBodygroups = "0000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_sequencecharge.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-10, 5, -4),
    ang = Angle(-10, 0, -180),
    scale = 0.9,
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.ShootEntity = "nade_k_thrown_sequencecharger"

SWEP.MuzzleVelocity = 800
SWEP.MuzzleVelocityAlt = 700

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.FuseTime = 3.5
SWEP.PullPinTime = 0.5

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
}



-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "slam"
SWEP.HoldtypeSights = "slam"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SLAM

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0,0,0)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4.5, -2, -1)
SWEP.CrouchAng = Angle(0, 0, -29)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    -- ["idle_primed"] = {
        -- Source = "idle_primed"
    -- },
    ["draw"] = {
        Source = "deploy",
        EventTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        EventTable = {
            {s = "ArcCW_Kraken.Explosives.Holster", t = 0.1/30},
        },
    },
    ["throw"] = {
        Source = "throw",
        EventTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.4
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"}
    },
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_sonar.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_nt242.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_s5.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_sb2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "SB-2"
SWEP.Trivia_Class = "Blaster Heavy Shotgun"
SWEP.Trivia_Desc = "The SB-2 was a type of blaster that could pierce through enemy defenses. It was used by the Grand Army of the Republic's clone troopers during the Clone Wars between the Galactic Republic and the Confederacy of Independent Systems. The DP-23 fired blue blaster bolts, and had a ridged barrel with a pointed muzzle, a black stock, and a small foregrip."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/sb2.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0000000000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_sb2.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.MirrorWorldModel = "models/arccw/kraken/republic/v_sb2_mirror.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-2, 3.5, -4),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.NoRandSpread = true
SWEP.CanBash = true

SWEP.ShotgunReload = true
SWEP.ManualAction = true

SWEP.ShotgunSpreadPattern = {
    [1] = Angle(0, 0, 0),
    [2] = Angle(0, 1, 0),
    [3] = Angle(0, -1, 0),
    [4] = Angle(2.1, 0, 0),
    [5] = Angle(-2.1, 0, 0),
    [6] = Angle(1.4, 1.2, 0),
    [7] = Angle(-1.4, 1.2, 0),
    [8] = Angle(1.4, -1.2, 0),
    [9] = Angle(-1.4, -1.2, 0),
}

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 22
SWEP.DamageMin = 9
SWEP.RangeMin = 0
SWEP.Range = 170
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 12

SWEP.Recoil = 4
SWEP.RecoilSide = 1
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.5
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 312
SWEP.Num = 9
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 75
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_SB2"
SWEP.ShootSound = "ArcCW_Kraken.SW_SB2"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.5, 0, 0.6),
    Ang = Angle(-0.25, 0.1, 0),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(1, 3, 0.25)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4, -3, -2)
SWEP.SprintAng = Angle(0, 30, -15)

SWEP.CustomizePos = Vector(15, 3, -2)
SWEP.CustomizeAng = Angle(15, 40, 20)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Iron Sights",
        Slot = {"optic", "optic_lp"},
        Bone = "tag_weapon", 
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(6, 0, 3.35), 
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    }, 
    {
        PrintName = "Internal Compression",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
    },
    {
        PrintName = "Tactical",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.95, 0.95, 0.95),
        WMScale = Vector(0.95, 0.95, 0.95),
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(12.5, -0.7, 2.87),
            vang = Angle(0, 0, 120),
        },
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode_rifle"},
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"}
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "tag_weapon",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(1.8, -0.55, 1.5), 
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "tag_weapon",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(5, -0.55, 1.5), 
            vang = Angle(0, 0, 0),
        },
    },
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
        Time = 1 / 35,
    },
    ["draw"] = {
        Source = "draw",
        Time = 1,
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 1,
    },
    ["holster"] = {
        Source = "holster",
        Time = 0.75,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0.2,
    },
    ["ready"] = {
        Source = "first_draw",
        Time = 2,
        SoundTable = {
            {s = "arccw/kraken/republic/sb2/back_870.wav", t = 14 / 30},
            {s = "arccw/kraken/republic/sb2/fwd_870.wav", t = 21 / 30}
        },
    },
    ["fire"] = {
        Source = {
            "fire",
        },
        Time = 3 / 10,
        ShellEjectAt = false,
    },
    ["fire_iron"] = {
        Source = {
            "fire_ads",
        },
        Time = 3 / 10,
        ShellEjectAt = false,
    },
    ["cycle"] = {
        Source = {
            "pump",
        },
        Time = 20 / 35,
        --ShellEjectAt = 0.3,
        SoundTable = {
            {s = "arccw/kraken/republic/sb2/back_870.wav", t = 2 / 30},
            {s = "arccw/kraken/republic/sb2/fwd_870.wav", t = 7 / 30},
        },
    },
    ["cycle_iron"] = {
        Source = {
            "pump_ads",
        },
        Time = 20 / 35,
        --ShellEjectAt = 0.3,
        SoundTable = {
            {s = "arccw/kraken/republic/sb2/back_870.wav", t = 2 / 30},
            {s = "arccw/kraken/republic/sb2/fwd_870.wav", t = 7 / 30},
        },
    },

    --RELOADS
    ["sgreload_start"] = {
        Source = "reload_in",
        Time = 40 / 30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        RestoreAmmo = 1, -- loads a shell since the first reload has a shell in animation
        MinProgress = 1,
        SoundTable = {
            {s = "ArcCW_Kraken.ShotgunLoad", t = 21 / 30},
        },
    },
    ["sgreload_insert"] = {
        Source = "reload_loop",
        Time = 26 / 30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        TPAnimStartTime = 0.3,
        MinProgress = 15 / 30,
        SoundTable = {
            {s = "ArcCW_Kraken.ShotgunLoad", t = 10 / 30},
        },
    },
    ["sgreload_finish"] = {
        Source = "reload_out",
        Time = 30 / 30,
        SoundTable = {
            {s = "arccw/kraken/republic/sb2/back_870.wav", t = 8 / 30},
            {s = "arccw/kraken/republic/sb2/fwd_870.wav", t = 12 / 30},
        },
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_smuggler.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_stw48.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "ST-W48"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The ST-W48 blaster was a blaster used by the Sith troopers of the Sith Eternal army, including the trooper ST-I4191. The weapon could be used in a blaster rifle configuration or a blaster carbine configuration where the stock was removed for use in confined spaces. Each ST-W48 had a quarrel-bolt launcher installed below its barrel that used enhanced bowcaster technology for a powerful explosive attack. The rifle's power cell cartridge was located around the mid-point of the weapon's length, above the trigger. The weapon had an auto fire mode that provided a high rate of fire."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/stw48.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "01000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_stw48.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 41
SWEP.DamageMin = 26
SWEP.RangeMin = 0
SWEP.Range = 500
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 35

SWEP.Recoil = 1.1
SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0.65

SWEP.Delay = 60 / 340
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_STW48"
SWEP.ShootSound = "ArcCW_Kraken.SW_STW48"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.15, 0, -0.3),
    Ang = Vector(0, 0, -3.2),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 8, 0),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 0}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        InstalledEles = {"scope_attach"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.06, -1.8, 1.6),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.6, 4, 0.5),
            vang = Angle(-100, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        InstalledEles = {"muzzle_attach"},
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0, 6.5, 0.4),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Foregrip", 
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(-0., 3, -0.95),
            vang = Angle(5, -90, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.03, 0, -0.1),
            vang = Angle(5, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.05, -3.9, -0.2),
            vang = Angle(5, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_stw48c.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_westar35_akimbo.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_dlt34.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_ee4.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_shortfirepuncher.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_tl40.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Empire"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "TL-40"
SWEP.Trivia_Class = "Blaster Heavy Repeater"
SWEP.Trivia_Desc = "The TL-40 Heavy Repeater was a model of heavy repeating blaster rifle that was manufactured for the special forces of the Galactic Empire. In addition to sending storms of blaster bolts from its multiple barrels, the rifle could gather its energy into a powerful concussion blast. It could also be modified with an extended barrel for reduced spread and with a power cell for increased cooling power. During the Galactic Civil War against the Rebel Alliance, Commander Iden Versio of the Empire's elite Inferno Squad carried a TL-40 Heavy Repeater."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/tl40.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "001000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_tl50.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-9, 5, -5.75),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 37
SWEP.DamageMin = 29
SWEP.RangeMin = 0
SWEP.Range = 400
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 35

SWEP.Recoil = 0.55
SWEP.RecoilSide = 0.55
SWEP.RecoilRise = 0.90
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 0.9
SWEP.RecoilVMShake = 1

SWEP.Delay = 60 / 450
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/tl50.wav"
SWEP.ShootSound = "kraken/sops/tl50.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.86, 0, 0.921),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 3)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt34",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, -2, 20),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.13, -4.9, 10),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-1.2, -3.4, 19.5),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.9, -2.3, 5),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.65, -3.3, 3),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.3,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 110 / 30},
            {s = "ArcCW_Kraken.Grab", t = 115 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_dca4.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-A4"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The DC-A4 is a powerful blaster rifle, designed for both military and civilian use. Known for its high-impact energy shots, it delivers exceptional range and stopping power, making it ideal for both combat and personal defense."
SWEP.Trivia_Manufacturer = "Concordian Crescent Technologies"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/dca4.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_dca4.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-11, 5, -1.5),
    ang = Angle(-15, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 22
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 37
SWEP.DamageMin = 23
SWEP.RangeMin = 0
SWEP.Range = 600
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 36

SWEP.Recoil = 0.7
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.45
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 0.7

SWEP.Delay = 60 / 400
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/dca4.wav"
SWEP.ShootSound = "kraken/sops/dca4.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.13, 0, 0.75),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 0)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 0)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dc15s",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-0.25, 0, 22),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dc15s",
        VMScale = Vector(0.9,0.9,0.9),
        WMScale = Vector(0.9,0.9,0.9),
        Offset = {
            vpos = Vector(-0.12, -1.9, 2),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dc15s",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.7, -1, 11),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "dc15s",
        Offset = {
            vpos = Vector(0.4, -0.7, -4.59),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dc15s",
        Offset = {
            vpos = Vector(0.35, 0.3, 0.4),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 1.1,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 1.4,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 80 / 30},
            {s = "ArcCW_Kraken.Grab", t = 85 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_deathwatchblaster.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_dg29.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_dt40.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_emprifle.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_emprifle.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "EMP Rifle"
SWEP.Trivia_Desc = "The electromagnetic pulse (EMP) launcher was a devastating weapon when used against the battle droid forces of the Confederacy of Independent Systems as they were able to both deactivate droids by shorting out electronics and destroy their interior circuitry with powerful EMP waves. Clone jet troopers used these as their primary weapon."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/emprifle.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_emp_rifle.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-9, 5, -5.75),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 1
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 305
SWEP.DamageMin = 7
SWEP.RangeMin = 0
SWEP.Range = 250
SWEP.Penetration = 10
SWEP.DamageType = DMG_BLAST
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "nio_tracer"
SWEP.HullSize = 1

SWEP.InfiniteAmmo = true
SWEP.BottomlessClip = true

SWEP.Recoil = 4
SWEP.RecoilSide = 0.45
SWEP.RecoilRise = 1
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1.5
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 50
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/emp.wav"
SWEP.ShootSound = "kraken/sops/emp.wavq"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.83, -4, 2.),
    Ang = Vector(2.6, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 1)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt34",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, -1, 28),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.9, -1., 16),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(1.12, 1, 11.2),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(1.1, -0.5, 0),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 1.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 310 / 30},
            {s = "ArcCW_Kraken.Grab", t = 310 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_galaar15c.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "GALAAR-15c"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "The GALAAR-15 blaster carbine was a popular blaster carbine manufactured by the Mandalorian arms giant Concordian Crescent Technologies. It was named after the galaar, a common bird of prey that was native to the planet Mandalore. It was a sleek, short-barreled rifle constructed from high-quality materials and was covered in shock-resistant polycarbonate. And while relatively rare, the GALAAR-15 was a frequent item that appeared on the black market. Due to its high-quality design, the rifle became a popular weapon among bounty hunters and other professional killers. Its popularity allowed arms dealers to charge a premium for the GALAAR-15, with even used weapons going above their standard value.[1] Similar in appearance to the smaller WESTAR-35 blaster pistol, the GALAAR-15 featured a angular design that made it blocky and squarish. It was mainly light grey with additional darker grey pieces and was known to fire yellow, blue or red blaster bolts, seeming dependent on the political allegiance of the user."
SWEP.Trivia_Manufacturer = "Concordian Crescent Technologies"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/galaar15c.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "001000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_galaar15.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-9, 5, -5.75),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 37
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 400
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 171, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_orange"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 32

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.55
SWEP.RecoilRise = 0.95
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 500
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 3,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/galaar.wav"
SWEP.ShootSound = "kraken/sops/galaar.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 171, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.744, -2.648, 2.368),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 3)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt34",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, -1, 25),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(-0.03, -2.8, 6),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        InstalledEles = {"muzzle_attach"},
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.4,1.4,1.4),
        WMScale = Vector(1.4,1.4,1.4),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.01, -1.55, 26.5),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-1.2, -1.3, 19.5),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(1.05, -1, 9),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(1.17, -1.25, 5.5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.3,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.6,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 110 / 30},
            {s = "ArcCW_Kraken.Grab", t = 115 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_iondisruptor.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "T-7 Ion Disruptor"
SWEP.Trivia_Class = "Ion Disruptor"
SWEP.Trivia_Desc = "The T-7 ion disruptor rifle was a model of high-powered disruptor rifle designed to disable starships and take out multiple enemies at one time. The rifles would also have destructive effects when used on organic lifeforms. The rifles were responsible for the near-extinction of the Lasat species, and their destructive powers led the Imperial Senate to ban their use within the Galactic Empire. The rebel crew of the Ghost later stole a shipment of T-7 ion disruptors and destroyed them before they could fall into the hands of the Empire."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/iondisruptor.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_ion_disruptor.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-9, 5, -5.75),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 5
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 105
SWEP.DamageMin = 27
SWEP.RangeMin = 0
SWEP.Range = 250
SWEP.Penetration = 10
SWEP.DamageType = DMG_DISSOLVE
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "vp_binary_tracer"
SWEP.HullSize = 1

SWEP.InfiniteAmmo = true
SWEP.BottomlessClip = true

SWEP.Recoil = 0.7
SWEP.RecoilSide = 0.45
SWEP.RecoilRise = 0.90
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 50
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/disruptor_fire.wav"
SWEP.ShootSound = "kraken/sops/disruptor_fire.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.87, -2.648, 2.),
    Ang = Vector(2, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 3)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt34",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, -1, 28),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(0.35, -2.55, 5.3),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.9, -1.1, 19.5),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(1.13, -0.3, 12.9),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.9, -1, 1),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.3,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },

    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 110 / 30},
            {s = "ArcCW_Kraken.Grab", t = 115 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}

SWEP.Hook_BulletHit = function(wep, data)
    local ent = data.tr.Entity
    util.BlastDamage(wep, wep:GetOwner(), data.tr.HitPos, 96, wep:GetDamage(data.range))
    if ent:IsValid() and ent:GetClass() == "npc_helicopter" then
        data.dmgtype = DMG_AIRBOAT
    end
end
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_mandorifle.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_mandorifle.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Amban Pulse Rifle"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The Amban phase-pulse blaster, also known as an Amban sniper rifle, was a type of disruptor sniper rifle used by the Mandalorian bounty hunter Din Djarin. The weapon was capable of electrocuting opponents as well as completely disintegrating targets. It was also capable of listening to conversations at least a house away. Djarin used the deadly weapon to great effect during his bounty hunting career."
SWEP.IconOverride = "entities/kraken/sops/mandorifle.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_mandalorianrifle.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-6, 5, -3.5),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1.2,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 204
SWEP.DamageMin = 55
SWEP.RangeMin = 0
SWEP.Range = 900
SWEP.Penetration = 10
SWEP.DamageType = DMG_DISSOLVE
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "nio_tracer"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.Recoil = 2
SWEP.RecoilSide = 2
SWEP.RecoilRise = 1.5
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 2
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/mandorifle/mandorifle.wav"
SWEP.ShootSound = "kraken/sops/mandorifle/mandorifle.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.398, 0, 0.938),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.SprintPos = Vector(2, -1, 0)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.Attachments = {     
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "weapon",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Offset = {
            vpos = Vector(20, -1.4, 0.2),
            vang = Angle(0, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "weapon",
        Offset = {
            vpos = Vector(2.3, -1.2, -0.55),
            vang = Angle(0, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "weapon",
        Offset = {
            vpos = Vector(9.5, -1.5, -0.5),
            vang = Angle(0, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot"},
        Mult = 2,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0,
		SoundTable = {
                        {s = "ArcCW_Kraken.Overheat", t = 0.50 },
						{s = "weapons/blast_martini-henry/draw.wav", t = 0},
						{s = "weapons/blast_martini-henry/leverdown_i.wav", t = 0.48},
						{s = "weapons/blast_martini-henry/insert_i.wav", t = 0.83},
                        {s = "ArcCW_Kraken.OverheatReplenished", t = 2 },
						{s = "weapons/blast_martini-henry/leverup_i.wav", t = 1.7},
					},
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "kraken/sops/mandorifle/draw.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_mw20.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "MW-20"
SWEP.Trivia_Class = "Blaster Revolver"
SWEP.Trivia_Desc = "Heavy-Powered blaster revolver produced by BlastTech Industries for the galactic citizens."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/mw20.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_mw20.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-14, 6.7, -7.65),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 6
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 67
SWEP.DamageMin = 45
SWEP.RangeMin = 0
SWEP.Range = 120
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 11

SWEP.Recoil = 1.25
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 0.9

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/mw20.wav"
SWEP.ShootSound = "kraken/sops/mw20.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardcCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.869, -1.859, 3.601),
    Ang = Vector(0, 0.884, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -5, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "a180",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0.25, 2, 8.5),
                   ang = Angle(90, 0, -90),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "a180",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(0.31, -1.7, 4),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "a180",
        Offset = {
            vpos = Vector(0.25, -0.92, 8.5),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "a180",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.35, 0, 6),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.8, 0.6, 7.3),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.9, -0.39, 5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        Mult = 1.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_republic_773firepuncher_short.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Republic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Republic '773 Short-puncher"
SWEP.Trivia_Class = "Blaster-Experimental Sniper Rifle"
SWEP.Trivia_Desc = "The 773 Firepuncher rifle, also known as the 773 Firepuncher, was a model of sniper rifle manufactured by Merr-Sonn Munitions, Inc. that featured ablative coating and a wide-beam 'burning' mode."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/shortypuncher_republica.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "01110000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_firepuncher_republic.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-3, 7.4, -9.5),
    ang = Angle(-30, 50, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 97
SWEP.DamageMin = 67
SWEP.RangeMin = 0
SWEP.Range = 320
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 1.05
SWEP.RecoilSide = 0.55
SWEP.RecoilRise = 0.90
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1.45
SWEP.RecoilVMShake = 1.5

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 120
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/firepuncher/firepuncher.wav"
SWEP.ShootSound = "kraken/sops/firepuncher/firepuncher.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-1.59, 0, 0.1),
    Ang = Vector(3.062, 0.5, 7.4),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.SprintPos = Vector(2.019, 0, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 0)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(0, 3, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "Crossair_rifle",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0.1, 10, 1.6),
                   ang = Angle(0, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "Crossair_rifle",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(0.1, 2.4, 2.76),
            vang = Angle(0, -90, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 180, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        VMScale = Vector(1.5, 1.5, 1.5),
        WMScale = Vector(1.5, 1.5, 1.5),
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        InstalledEles = {"muzzle_attach"},
        Bone = "Crossair_rifle",
        Offset = {
            vpos = Vector(0.1, 9, 1.6),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "Crossair_rifle",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.9, 2, 1),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "Crossair_rifle",
        Offset = {
            vpos = Vector(1.1, -5, 1.4),
            vang = Angle(90, -90, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "Crossair_rifle",
        Offset = {
            vpos = Vector(1.2, 0, 1.2),
            vang = Angle(90, -90, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = {"fire"},
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 1.1,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 25 / 30},
            {s = "kraken/sops/firepuncher/reload.wav", t = 0.1 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH lua/weapons/carkeys.lua:
SWEP.PrintName = "Vehicle Keys"
SWEP.Category = "Durians Weapons"
SWEP.Spawnable = true

SWEP.Author = "Durian"
SWEP.Instructions = ""

SWEP.Slot = 1 
SWEP.SlotPos = 1 
SWEP.DrawAmmo = false 

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.ViewModelFOV = 70
SWEP.UseHands = false
SWEP.ViewModel = "models/weapons/Hl2/c_fists.mdl"
SWEP.WorldModel = ""


function SWEP:SetupDataTables()
    self:NetworkVar("Bool", 0, "IsLocked")
end

function SWEP:PrimaryAttack()
    if CLIENT then return end

    local ply = self.Owner
    local ent = ply:GetEyeTrace().Entity

    if not IsValid(ent) then return false end
    if not ent.LVS and not ent.LFS then return end

    local vehOwner = ent:GetNWEntity("owner")
    
    if vehOwner == NULL then
        vehOwner = ply
        ent:SetNWEntity("owner", ply)
    end

    if vehOwner:UniqueID() == ply:UniqueID() then
        if self:GetIsLocked() then
            ply:PrintMessage( HUD_PRINTCENTER, "Vehicle Already Locked" )
        else
            ent:Lock()
            self:SetIsLocked(true)
            ply:PrintMessage( HUD_PRINTCENTER, "Vehicle Locked" )
        end
    else
        ply:PrintMessage( HUD_PRINTCENTER , "Vehicle Not Yours")
    end
end

function SWEP:SecondaryAttack()
    if CLIENT then return end

    local ply = self.Owner
    local ent = ply:GetEyeTrace().Entity

    if not IsValid(ent) then return false end
    if not ent.LVS and not ent.LFS then return end

    local vehOwner = ent:GetNWEntity("owner")
    
    if vehOwner == NULL then
        vehOwner = ply
        ent:SetNWEntity("owner", ply)
    end

    if vehOwner:UniqueID() == ply:UniqueID() then
        if not self:GetIsLocked() then
            ply:PrintMessage( HUD_PRINTCENTER, "Vehicle Already Unlocked" )
        else
            ent:UnLock()
            self:SetIsLocked(false)
            ply:PrintMessage( HUD_PRINTCENTER, "Vehicle Unlocked" )
        end
    else
        ply:PrintMessage( HUD_PRINTCENTER , "Vehicle Not Yours")
        
    end
end

tkccooldown = 0.25


local lastReloadTime = 0

function SWEP:Reload()
    if (os.time() - lastReloadTime) > tkccooldown then
        if CLIENT then return end

        local ply = self.Owner
        local ent = ply:GetEyeTrace().Entity

        if not IsValid(ent) then return false end
        if not ent.LVS and not ent.LFS then return end

        local vehOwner = ent:GetNWEntity("owner")

        if vehOwner == NULL then
            local vehOwner = ply
            ent:SetNWEntity("owner", ply)
            ply:PrintMessage( HUD_PRINTCENTER, "This Now Your Vehicle")
            ent:SetNWEntity("owner", ply)
        elseif vehOwner:UniqueID() == ply:UniqueID() then
            ply:PrintMessage( HUD_PRINTCENTER , "This is No Longer Your Vehicle")
            ent:SetNWEntity("owner", NULL)
        else
            ply:PrintMessage(HUD_PRINTCENTER , "This Vehicle is Already Owned")
        end
        lastReloadTime = os.time()
    end
end
--PATH lua/weapons/f187cutter.lua:
return gluapack()()
--PATH addons/[gas] gmodadminsuite-logging-2.4.8/lua/weapons/gas_log_scanner/shared.lua:
return gluapack()()
--PATH lua/weapons/gas_weapon_hands.lua:
return gluapack()()
--PATH lua/weapons/gmod_tool/stools/bossbartool.lua:
return gluapack()()
--PATH lua/weapons/gmod_tool/stools/imagetool.lua:
return gluapack()()
--PATH gamemodes/sandbox/entities/weapons/gmod_tool/stools/lvsturret.lua:
TOOL.Category		= "LVS"
TOOL.Name		= "#tool.lvsturret.name"
TOOL.Command		= nil
TOOL.ConfigName		= ""

cleanup.Register( "lvsturret" )
CreateConVar("sbox_maxlvsturret", 1, "FCVAR_NOTIFY")

TOOL.ClientConVar[ "delay" ] 		= "0.05"
TOOL.ClientConVar[ "damage" ] 		= "15"
TOOL.ClientConVar[ "speed" ] 		= "30000"
TOOL.ClientConVar[ "size" ] 		= "1"
TOOL.ClientConVar[ "spread" ] 		= "0"
TOOL.ClientConVar[ "penetration" ] 	= "10"
TOOL.ClientConVar[ "splashdamage" ] = "0"
TOOL.ClientConVar[ "splashradius" ] 	= "0"
TOOL.ClientConVar[ "tracer" ] 		= "lvs_tracer_orange"
TOOL.ClientConVar[ "splasheffect" ] 	= "lvs_bullet_impact"

if CLIENT then
	language.Add( "tool.lvsturret.name", "Projectile Turret" )
	language.Add( "tool.lvsturret.desc", "A Tool used to spawn Turrets" )
	language.Add( "tool.lvsturret.0", "Left click to spawn or update a turret" )
	language.Add( "tool.lvsturret.1", "Left click to spawn or update a turret" )
	
	language.Add( "Cleanup_lvsturret", "[LVS] Projectile Turret" )
	language.Add( "Cleaned_lvsturret", "Cleaned up all [LVS] Projectile Turrets" )

	language.Add( "SBoxLimit_lvsturret", "You've reached the Projectile Turret limit!" )
end

function TOOL:LeftClick( trace )

	if CLIENT then return true end
	
	local ply = self:GetOwner()

	if not istable( WireLib ) then
		ply:PrintMessage( HUD_PRINTTALK, "[LVS]: WIREMOD REQUIRED" )
		ply:SendLua( "gui.OpenURL( 'https://steamcommunity.com/sharedfiles/filedetails/?id=160250458' )") 
	end
	
	if IsValid( trace.Entity ) and trace.Entity:GetClass():lower() == "lvs_turret" then 
		self:UpdateTurret( trace.Entity )
	else
		local turret = self:MakeTurret( ply, trace.HitPos + trace.HitNormal * 5 )
		
		undo.Create("Turret")
			undo.AddEntity( turret )
			undo.SetPlayer( ply )
		undo.Finish()
	end
	
	return true
end

function TOOL:RightClick( trace )
	return false
end

if SERVER then
	function TOOL:UpdateTurret( ent )
		if not IsValid( ent ) then return end

		ent:SetShootDelay( self:GetClientNumber( "delay" ) )
		ent:SetDamage( math.Clamp( self:GetClientNumber( "damage" ), 0, 1000 ) )
		ent:SetSpeed( math.Clamp( self:GetClientNumber( "speed" ), 10000, 100000 ) )
		ent:SetSize( math.Clamp( self:GetClientNumber( "size" ), 0, 50 ) )
		ent:SetSpread( math.Clamp( self:GetClientNumber( "spread" ), 0, 1 ) )
		ent:SetPenetration( math.Clamp( self:GetClientNumber( "penetration" ), 0, 500 ) )
		ent:SetSplashDamage( math.Clamp( self:GetClientNumber( "splashdamage" ), 0, 1000 ) )
		ent:SetSplashDamageRadius( math.Clamp( self:GetClientNumber( "splashradius" ), 0, 750 ) )
		ent:SetTracer( self:GetClientInfo( "tracer" ) )
		ent:SetSplashDamageType( self:GetClientInfo( "splasheffect" ) )
	end

	function TOOL:MakeTurret( ply, Pos, Ang )

		if not ply:CheckLimit( "lvsturret" ) then return NULL end

		local turret = ents.Create( "lvs_turret" )
		
		if not IsValid( turret )  then return NULL end

		turret:SetPos( Pos )
		turret:SetAngles( Angle(0,0,0) )
		turret:Spawn()

		turret.Attacker = ply

		self:UpdateTurret( turret )

		ply:AddCount( "lvsturret", turret )
		ply:AddCleanup( "lvsturret", turret )

		return turret
	end
end

local ConVarsDefault = TOOL:BuildConVarList()
function TOOL.BuildCPanel( CPanel )
	CPanel:AddControl( "ComboBox", { MenuButton = 1, Folder = "lvs_turrets", Options = { [ "#preset.default" ] = ConVarsDefault }, CVars = table.GetKeys( ConVarsDefault ) } )

	CPanel:AddControl( "Header", { Text = "#tool.lvsturret.name", Description	= "#tool.lvsturret.desc" }  )

	local TracerEffect = {Label = "Tracer Effect", MenuButton = 0, Options={}, CVars = {}}
	local TracerOptions = {
		["LaserBlue"] = "lvs_laser_blue",
		["LaserRed"] = "lvs_laser_red",
		["LaserGreen"] = "lvs_laser_green",
		["TracerGreen"] = "lvs_tracer_green",
		["TracerOrange"] = "lvs_tracer_orange",
		["TracerWhite"] = "lvs_tracer_white",
		["TracerYellow"] = "lvs_tracer_yellow",
		["AutoCannon"] = "lvs_tracer_autocannon",
		["Cannon"] = "lvs_tracer_cannon",
	}
	for id, name in pairs( TracerOptions ) do
		if not file.Exists( "effects/"..name..".lua", "LUA" ) then continue end
		TracerEffect["Options"][id]	= { lvsturret_tracer = name }
	end
	CPanel:AddControl("ComboBox", TracerEffect )

	CPanel:AddControl( "Slider", { Label = "Shoot Delay", Type = "Float", Min = 0, Max = 2.0, Command = "lvsturret_delay" } )

	CPanel:AddControl( "Slider", { Label = "Damage", Type = "Float", Min = 0, Max = 1000, Command = "lvsturret_damage" } )

	CPanel:AddControl( "Slider", { Label = "Bullet Speed", Type = "Float", Min = 10000, Max = 100000, Command = "lvsturret_speed" } )

	CPanel:AddControl( "Slider", { Label = "Bullet Spread", Type = "Float", Min = 0, Max = 1, Command = "lvsturret_spread" } )

	CPanel:AddControl( "Slider", { Label = "Hull Size", Type = "Float", Min = 0, Max = 50, Command = "lvsturret_size" } )

	CPanel:AddControl( "Slider", { Label = "Armor Penetration (mm)", Type = "Float", Min = 0, Max = 500, Command = "lvsturret_penetration" } )

	CPanel:AddControl( "Slider", { Label = "Splash Damage", Type = "Float", Min = 0, Max = 1000, Command = "lvsturret_splashdamage" } )

	CPanel:AddControl( "Slider", { Label = "Splash Radius", Type = "Float", Min = 0, Max = 750, Command = "lvsturret_splashradius" } )

	local SplashType = {Label = "Splash Type", MenuButton = 0, Options={}, CVars = {}}
	SplashType["Options"][ "Shrapnel" ] = { lvsturret_splasheffect = "lvs_bullet_impact" }
	SplashType["Options"][ "Explosive" ] = { lvsturret_splasheffect =  "lvs_bullet_impact_explosive" }
	CPanel:AddControl("ComboBox", SplashType )
end

--PATH lua/weapons/gmod_tool/stools/permaprops.lua:
/*
	PermaProps
	Created by Entoros, June 2010
	Facepunch: http://www.facepunch.com/member.php?u=180808
	Modified By Malboro 28 / 12 / 2012
	
	Ideas:
		Make permaprops cleanup-able
		
	Errors:
		Errors on die

	Remake:
		By Malboro the 28/12/2012
*/

TOOL.Category		=	"Props Tool"
TOOL.Name			=	"PermaProps"
TOOL.Command		=	nil
TOOL.ConfigName		=	""

if CLIENT then
	language.Add("Tool.permaprops.name", "PermaProps")
	language.Add("Tool.permaprops.desc", "Save a props permanently")
	language.Add("Tool.permaprops.0", "LeftClick: Add RightClick: Remove Reload: Update")

	surface.CreateFont("PermaPropsToolScreenFont", { font = "Arial", size = 40, weight = 1000, antialias = true, additive = false })
	surface.CreateFont("PermaPropsToolScreenSubFont", { font = "Arial", size = 30, weight = 1000, antialias = true, additive = false })
end

function TOOL:LeftClick(trace)

	if CLIENT then return true end

	local ent = trace.Entity
	local ply = self:GetOwner()

	if not PermaProps then ply:ChatPrint( "ERROR: Lib not found" ) return end
	
	if !PermaProps.HasPermission( ply, "Save") then return end

	if not ent:IsValid() then ply:ChatPrint( "That is not a valid entity !" ) return end
	if ent:IsPlayer() then ply:ChatPrint( "That is a player !" ) return end
	if ent.PermaProps then ply:ChatPrint( "That entity is already permanent !" ) return end

	local content = PermaProps.PPGetEntTable(ent)
	if not content then return end

	local max = tonumber(sql.QueryValue("SELECT MAX(id) FROM permaprops;"))
	if not max then max = 1 else max = max + 1 end

	local new_ent = PermaProps.PPEntityFromTable(content, max)
	if !new_ent or !new_ent:IsValid() then return end

	PermaProps.SparksEffect( ent )

	PermaProps.SQL.Query("INSERT INTO permaprops (id, map, content) VALUES(NULL, ".. sql.SQLStr(game.GetMap()) ..", ".. sql.SQLStr(util.TableToJSON(content)) ..");")
	ply:ChatPrint("You saved " .. ent:GetClass() .. " with model ".. ent:GetModel() .. " to the database.")

	ent:Remove()

	return true

end

function TOOL:RightClick(trace)

	if CLIENT then return true end

	local ent = trace.Entity
	local ply = self:GetOwner()

	if not PermaProps then ply:ChatPrint( "ERROR: Lib not found" ) return end

	if !PermaProps.HasPermission( ply, "Delete") then return end

	if not ent:IsValid() then ply:ChatPrint( "That is not a valid entity !" ) return end
	if ent:IsPlayer() then ply:ChatPrint( "That is a player !" ) return end
	if not ent.PermaProps then ply:ChatPrint( "That is not a PermaProp !" ) return end
	if not ent.PermaProps_ID then ply:ChatPrint( "ERROR: ID not found" ) return end

	PermaProps.SQL.Query("DELETE FROM permaprops WHERE id = ".. ent.PermaProps_ID ..";")

	ply:ChatPrint("You erased " .. ent:GetClass() .. " with a model of " .. ent:GetModel() .. " from the database.")

	ent:Remove()

	return true

end

function TOOL:Reload(trace)

	if CLIENT then return true end

	if not PermaProps then self:GetOwner():ChatPrint( "ERROR: Lib not found" ) return end

	if (not trace.Entity:IsValid() and PermaProps.HasPermission( self:GetOwner(), "Update")) then self:GetOwner():ChatPrint( "You have reload all PermaProps !" ) PermaProps.ReloadPermaProps() return false end

	if trace.Entity.PermaProps then

		local ent = trace.Entity
		local ply = self:GetOwner()

		if !PermaProps.HasPermission( ply, "Update") then return end

		if ent:IsPlayer() then ply:ChatPrint( "That is a player !" ) return end
		
		local content = PermaProps.PPGetEntTable(ent)
		if not content then return end

		PermaProps.SQL.Query("UPDATE permaprops set content = ".. sql.SQLStr(util.TableToJSON(content)) .." WHERE id = ".. ent.PermaProps_ID .." AND map = ".. sql.SQLStr(game.GetMap()) .. ";")

		local new_ent = PermaProps.PPEntityFromTable(content, ent.PermaProps_ID)
		if !new_ent or !new_ent:IsValid() then return end

		PermaProps.SparksEffect( ent )

		ply:ChatPrint("You updated the " .. ent:GetClass() .. " in the database.")

		ent:Remove()


	else

		return false

	end

	return true

end

function TOOL.BuildCPanel(panel)

	panel:AddControl("Header",{Text = "PermaProps", Description = "PermaProps\n\nSaves entities across map changes\n"})
	panel:AddControl("Button",{Label = "Open Configuration Menu", Command = "pp_cfg_open"})

end

function TOOL:DrawToolScreen(width, height)

	if SERVER then return end

	surface.SetDrawColor(17, 148, 240, 255)
	surface.DrawRect(0, 0, 256, 256)

	surface.SetFont("PermaPropsToolScreenFont")
	local w, h = surface.GetTextSize(" ")
	surface.SetFont("PermaPropsToolScreenSubFont")
	local w2, h2 = surface.GetTextSize(" ")

	draw.SimpleText("PermaProps", "PermaPropsToolScreenFont", 128, 100, Color(224, 224, 224, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, Color(17, 148, 240, 255), 4)
	draw.SimpleText("By Malboro", "PermaPropsToolScreenSubFont", 128, 128 + (h + h2) / 2 - 4, Color(224, 224, 224, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, Color(17, 148, 240, 255), 4)

end

--PATH lua/weapons/gmod_tool/stools/streamradio_gui_color_global.lua:
TOOL.Category = "Stream Radio"
TOOL.Name = "#Tool." .. TOOL.Mode .. ".name"

TOOL.Information = {
	{ name = "left" },
	{ name = "right" },
	{ name = "reload" },
}

TOOL.SkinColorsVars = {
	cursor = {
		hierarchies = {
			"",
		},

		colors = {
			color_cursor = {
				default = Color(255, 255, 255, 255),
				order = 1,
			},
		},

		order = 1,
	},

	main = {
		hierarchies = {
			"main",
		},

		colors = {
			color = {
				default = Color(0, 0, 64, 255),
				order = 1,
			},
		},

		order = 2,
	},

	border = {
		hierarchies = {
			"",
		},

		colors = {
			color_border = {
				default = Color(0, 64, 128, 255),
				order = 1,
			},
		},

		order = 3,
	},

	header = {
		hierarchies = {
			"main/browser/header",
			"main/player/header",
		},

		colors = {
			color = {
				default = Color(0, 100, 0, 255),
				order = 1,
			},

			color_foreground = {
				default = Color(255, 255, 255, 255),
				order = 2,
			},

			color_shadow = {
				default = Color(40, 40, 40, 255),
				order = 99,
			},
		},

		order = 4,
	},

	button = {
		hierarchies = {
			"main/browser/sidebutton",
			"main/browser/list/button",
			"main/browser/error/button",
			"main/browser/list/scrollbar/bar",
			"main/browser/list/scrollbar/button",
			"main/browser/error/textbox/scrollbar/bar",
			"main/browser/error/textbox/scrollbar/button",

			"main/player/button",
			"main/player/controls/button",
			"main/player/controls/progressbar",
			"main/player/spectrum/error/button",
			"main/player/spectrum/error/textbox/scrollbar/bar",
			"main/player/spectrum/error/textbox/scrollbar/button",
		},

		colors = {
			color = {
				default = Color(0, 128, 128, 255),
				order = 1,
			},

			color_foreground = {
				default = Color(255, 255, 255, 255),
				order = 2,
			},

			color_icon = {
				default = Color(255, 255, 255, 255),
				order = 3,
			},


			color_hover = {
				default = Color(150, 150, 150, 255),
				order = 4,
			},

			color_foreground_hover = {
				default = Color(0, 0, 0, 255),
				order = 5,
			},

			color_icon_hover = {
				default = Color(255, 255, 255, 255),
				order = 6,
			},


			color_disabled = {
				default = Color(100, 100, 100, 255),
				order = 7,
			},

			color_foreground_disabled = {
				default = Color(255, 255, 255, 255),
				order = 8,
			},

			color_icon_disabled = {
				default = Color(255, 255, 255, 255),
				order = 9,
			},


			color_shadow = {
				default = Color(40, 40, 40, 255),
				order = 99,
			},
		},

		order = 5,
	},

	error = {
		hierarchies = {
			"main/browser/error/textbox",
			"main/player/spectrum/error/textbox",
		},

		colors = {
			color = {
				default = Color(128, 32, 0, 255),
				order = 1,
			},

			color_foreground = {
				default = Color(255, 255, 255, 255),
				order = 2,
			},

			color_shadow = {
				default = Color(40, 40, 40, 255),
				order = 99,
			},
		},

		order = 6,
	},

	spectrum = {
		hierarchies = {
			"main/player/spectrum",
		},

		colors = {
			color = {
				default = Color(64, 32, 0, 255),
				order = 1,
			},

			color_foreground = {
				default = Color(192, 0, 0, 255),
				order = 2,
			},

			color_icon = {
				default = Color(255, 255, 255, 255),
				order = 3,
			},

			color_shadow = {
				default = Color(40, 40, 40, 255),
				order = 99,
			},
		},

		order = 7,
	},
}

TOOL.SkinVars = {}
local count = 0

for areaname, colvars in SortedPairsByMemberValue(TOOL.SkinColorsVars, "order") do
	local hierarchies = colvars.hierarchies or {}

	for colname, colvar in SortedPairsByMemberValue(colvars.colors or {}, "order") do
		local color = colvar.default or Color(255, 255, 255, 255)
		local varname = areaname .. "_" .. colname

		TOOL.ClientConVar[varname .. "_t"] = "1"
		TOOL.ClientConVar[varname .. "_r"] = color.r
		TOOL.ClientConVar[varname .. "_g"] = color.g
		TOOL.ClientConVar[varname .. "_b"] = color.b
		TOOL.ClientConVar[varname .. "_a"] = color.a

		local order = count + 1
		local skinvar = {}

		skinvar.default = color
		skinvar.hierarchies = hierarchies
		skinvar.areaname = areaname
		skinvar.name = colname
		skinvar.order = order

		TOOL.SkinVars[varname] = skinvar
		count = order
	end
end

if StreamRadioLib and StreamRadioLib.Loaded then
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "LeftClick")
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "RightClick")
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "Reload")
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "Holster")

	StreamRadioLib.Tool.AddLocale(TOOL, "name", "Radio Colorer (Global)")
	StreamRadioLib.Tool.AddLocale(TOOL, "desc", "Change colors of radio GUI skins")

	StreamRadioLib.Tool.AddLocale(TOOL, "left", "Apply colors of radio GUI skins")
	StreamRadioLib.Tool.AddLocale(TOOL, "right", "Copy the colors from radio GUI skins")
	StreamRadioLib.Tool.AddLocale(TOOL, "reload", "Reset the skin of the radio to default")

	StreamRadioLib.Tool.AddLocale(TOOL, "list", "List of changeable colors:")
	StreamRadioLib.Tool.AddLocale(TOOL, "color", "Selected color:")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.common.active.desc", "If checked the color will be applied on left click.\nUncheck this if you don't want to change this color on the GUI.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.main_color", "Background")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.main_color.desc", "Color of the main background.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.border_color_border", "Border")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.border_color_border.desc", "Color of the surrounding border.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.header_color", "Header Background")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.header_color_foreground", "Header Text")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.header_color_shadow", "Header Shadow")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.header_color.desc", "Color of the header background.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.header_color_foreground.desc", "Color of the header text.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.header_color_shadow.desc", "Color of the header shadow.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color", "Button Background")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_foreground", "Button Text")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_icon", "Button Icon")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color.desc", "Color of all button backgrounds.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_foreground.desc", "Color of all button texts.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_icon.desc", "Color of all button icons.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_hover", "Button Hover Background")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_foreground_hover", "Button Hover Text")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_icon_hover", "Button Hover Icon")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_hover.desc", "Color of all hovered button backgrounds.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_foreground_hover.desc", "Color of all hovered button texts.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_icon_hover.desc", "Color of all hovered button icons.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_disabled", "Button Disabled Background")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_foreground_disabled", "Button Disabled Text")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_icon_disabled", "Button Disabled Icon")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_disabled.desc", "Color of all disabled button backgrounds.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_foreground_disabled.desc", "Color of all disabled button texts.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_icon_disabled.desc", "Color of all disabled button icons.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_shadow", "Button Shadow")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.button_color_shadow.desc", "Color of all button Shadow.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.error_color", "Error Background")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.error_color_foreground", "Error Text")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.error_color_shadow", "Error Shadow")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.error_color.desc", "Color of the error box background.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.error_color_foreground.desc", "Color of the error box text.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.error_color_shadow.desc", "Color of the error box shadow.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.spectrum_color", "Spectrum Background")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.spectrum_color_foreground", "Spectrum Foreground")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.spectrum_color_icon", "Spectrum Icon")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.spectrum_color_shadow", "Spectrum Shadow")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.spectrum_color.desc", "Color of the spectrum box background.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.spectrum_color_foreground.desc", "Color of the spectrum box foreground.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.spectrum_color_icon.desc", "Color of the spectrum box icons.")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.spectrum_color_shadow.desc", "Color of the spectrum box shadow.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.cursor_color_cursor", "Cursor")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.cursor_color_cursor.desc", "Color of the Cursor.")

	StreamRadioLib.Tool.Setup(TOOL)
else
	TOOL.Information = nil

	if CLIENT then
		local StreamRadioLib = StreamRadioLib or {}
		local _mode = TOOL.Mode

		language.Add("Tool." .. _mode .. ".name", "Radio Colorer (Global)")
		language.Add("Tool." .. _mode .. ".desc", "Change colors of radio GUI skins")
		language.Add("Tool." .. _mode .. ".0", "This tool could not be loaded.")

		function TOOL.BuildCPanel(CPanel)
			if StreamRadioLib.Loader_CreateErrorPanel then
				StreamRadioLib.Loader_CreateErrorPanel(CPanel, "This tool could not be loaded.")
			end
		end
	end
end

function TOOL:IsValid()
	return IsValid(self:GetSWEP())
end

function TOOL:GetColors(forceall)
	local data = {}

	for varname, v in pairs(self.SkinVars) do
		if not forceall then
			local ticked = self:GetClientBool(varname .. "_t")
			if not ticked then continue end
		end

		local r = self:GetClientNumber(varname .. "_r")
		local g = self:GetClientNumber(varname .. "_g")
		local b = self:GetClientNumber(varname .. "_b")
		local a = self:GetClientNumber(varname .. "_a")

		data[varname] = Color(r, g, b, a)
	end

	return data
end

function TOOL:SetColors(data)
	data = data or {}

	for varname, v in pairs(self.SkinVars) do
		local color = data[varname] or v.default or Color(255, 255, 255, 255)

		self:SetClientNumber(varname .. "_r", color.r)
		self:SetClientNumber(varname .. "_g", color.g)
		self:SetClientNumber(varname .. "_b", color.b)
		self:SetClientNumber(varname .. "_a", color.a)
	end
end

function TOOL:AddModeList( panel )
	local listpanel = vgui.Create( "DListView" )
	panel:AddPanel(listpanel)

	listpanel:SetMultiSelect(false)

	local col1 = listpanel:AddColumn("No.")
	listpanel:AddColumn("Item")
	local col3 = listpanel:AddColumn("Color")
	local col4 = listpanel:AddColumn("Active")

	col1:SetFixedWidth(30)
	col3:SetMinWidth(40)
	col3:SetMaxWidth(70)
	col4:SetFixedWidth(40)

	local lines = {}

	listpanel.NextConVarCheck = 0

	local update = function()
		if not IsValid(self) then return end
		if not IsValid(listpanel) then return end

		local data = self:GetColors(true)
		local changed = false

		if input.IsMouseDown(MOUSE_LEFT) then return end
		if listpanel.NextConVarCheck > RealTime() then return end

		listpanel.NextConVarCheck = RealTime() + 0.2

		for varname, line in pairs(lines) do
			if not self.SkinVars[varname] then continue end
			if not IsValid(line) then continue end

			local colortile = line.Columns[line._colorindex]
			if not IsValid(colortile) then continue end

			local activecheckbox = line.Columns[line._activeindex]
			if not IsValid(activecheckbox) then continue end

			local color = data[varname]
			if not color then continue end

			local oldcolor = colortile:GetColor()
			if color == oldcolor then continue end

			colortile:SetColor(color)
			line:SetSortValue(line._colorindex, tostring(color))
			changed = true
		end

		if changed and listpanel.OnColorUpdate then
			listpanel:OnColorUpdate(data)
		end
	end

	local data = self:GetColors(true)

	for varname, color in pairs(data) do
		local colortile = vgui.Create( "DColorButton" )
		local activecheckbox = vgui.Create( "DCheckBoxLabel" )
		if not self.SkinVars[varname] then continue end

		activecheckbox:SetText("")
		activecheckbox:SetConVar(self.Mode .. "_" .. varname  .. "_t")
		activecheckbox:SetIndent(12)
		activecheckbox:SetTooltip(StreamRadioLib.Tool.GetLocaleTranslation(self, "list.common.active.desc"))

		local order = self.SkinVars[varname].order or 0

		local line = listpanel:AddLine(order, StreamRadioLib.Tool.GetLocaleTranslation(self, "list." .. varname), colortile, activecheckbox)
		colortile.DoClick = function()
			listpanel:ClearSelection()
			listpanel:SelectItem(line)
		end

		line:SetTooltip(StreamRadioLib.Tool.GetLocaleTranslation(self, "list." .. varname .. ".desc"))
		line:SetSortValue(1, order)

		line._colorindex = 3
		line._activeindex = 4

		activecheckbox.OnChange = function(this, value)
			local sort = value and 1 or 0
			sort = sort * 1000 - order

			line:SetSortValue(line._activeindex, sort)
		end

		line._varname = varname
		lines[varname] = line
	end

	listpanel:SetTall(230)
	listpanel:SortByColumn(1)

	listpanel.Think = function()
		update()
	end

	update()

	return listpanel
end


function TOOL:BuildToolPanel( CPanel )
	self:AddLabel(CPanel, "list")

	local listpanel = self:AddModeList(CPanel)
	local colorpanel = nil
	local selectedline = nil

	listpanel.OnRowSelected = function(this, LineID, Line)
		selectedline = Line
		if not IsValid(selectedline) then return end
		if not IsValid(colorpanel) then return end
		if not selectedline._varname then return end

		local precmd = self.Mode .. "_" .. selectedline._varname

		colorpanel:SetConVarR(precmd .. "_r")
		colorpanel:SetConVarG(precmd .. "_g")
		colorpanel:SetConVarB(precmd .. "_b")
		colorpanel:SetConVarA(precmd .. "_a")
		colorpanel.txtA:SetConVar(precmd .. "_a")

		local colortile = selectedline.Columns[selectedline._colorindex]
		if not IsValid(colortile) then return end
		colorpanel:SetColor(colortile:GetColor())
	end

	listpanel.DoDoubleClick = function(this, LineID, Line)
		if not IsValid(Line) then return end
		if not IsValid(colorpanel) then return end

		local activecheckbox = selectedline.Columns[selectedline._activeindex]
		if not IsValid(activecheckbox) then return end
		activecheckbox:Toggle()
	end

	listpanel.OnColorUpdate = function(this, data)
		this:OnRowSelected(selectedline:GetID(), selectedline)
	end

	self:AddLabel(CPanel, "color")
	colorpanel = self:AddColorMixer(CPanel)

	listpanel:SelectFirstItem()
end

function TOOL:GetAimedGui(trace)
	if not self.ToolLibLoaded then return end

	trace = trace or self:GetFallbackTrace()

	if not trace then return end
	if not trace.Hit then return end

	local ent = trace.Entity

	if not self:IsValidGUIRadio(ent) then return end

	local entgui = ent:GetGUI()
	if not IsValid(entgui) then return end

	return entgui, ent
end

function TOOL:LeftClick(trace)
	if not self.ToolLibLoaded then return end

	local entgui = self:GetAimedGui(trace)
	if not IsValid(entgui) then return false end

	if CLIENT then return true end

	StreamRadioLib.Tool.CallClientToolHook(self, "LeftClick")
	return true
end

function TOOL:RightClick(trace)
	if not self.ToolLibLoaded then return end

	local entgui = self:GetAimedGui(trace)
	if not IsValid(entgui) then return false end

	if CLIENT then return true end

	StreamRadioLib.Tool.CallClientToolHook(self, "RightClick")
	return true
end

function TOOL:LeftClickClient()
	if not self.ToolLibLoaded then return end

	local entgui = self:GetAimedGui()
	if not IsValid(entgui) then return end

	local data = self:GetColors()

	for varname, color in pairs(data) do
		local skinvar = self.SkinVars[varname] or {}
		local hierarchies = skinvar.hierarchies or {}
		local hrvarname = skinvar.name

		for _, skinhierarchy in pairs(hierarchies) do
			entgui:SetSkinPropertyOnServer(skinhierarchy, hrvarname, color)
		end
	end
end

function TOOL:RightClickClient()
	if not self.ToolLibLoaded then return end

	local entgui = self:GetAimedGui()
	if not IsValid(entgui) then return end

	local skindata = {}

	for varname, skinvar in pairs(self.SkinVars) do
		local hierarchies = skinvar.hierarchies or {}
		local hrvarname = skinvar.name
		local value = nil

		for _, skinhierarchy in pairs(hierarchies) do
			local panels = entgui:GetPanelsBySkinIdentifyer(skinhierarchy)

			for _, panel in pairs(panels) do
				if not IsValid(panel) then continue end
				value = panel:GetSkinValue(hrvarname)

				if value then break end
			end

			if value then break end
		end

		skindata[varname] = value
	end

	self:SetColors(skindata)
end

function TOOL:Reload(trace)
	if not self.ToolLibLoaded then return end

	local entgui = self:GetAimedGui()
	if not IsValid(entgui) then return false end

	if CLIENT then return true end

	StreamRadioLib.Tool.CallClientToolHook(self, "Reload")
	return true
end

function TOOL:ReloadClient()
	if not self.ToolLibLoaded then return end

	local entgui = self:GetAimedGui()
	if not IsValid(entgui) then return end

	entgui:SetSkinOnServer(StreamRadioLib.Skin.GetDefaultSkin(), false)
end

function TOOL:Holster()
	if not self.ToolLibLoaded then return end

	self:Clear()
	StreamRadioLib.Tool.CallClientToolHook(self, "Holster")
end

function TOOL:HolsterClient()
	if not self.ToolLibLoaded then return end
	self:Clear()
end

function TOOL:Clear()

end

function TOOL:Think()
	if SERVER then return end
end

--PATH lua/weapons/gmod_tool/stools/textscreen.lua:
return gluapack()()
--PATH lua/weapons/gmod_tool/stools/turbolaser.lua:
-- Why hello there!

TOOL.Category		= "Vanilla"
TOOL.Name			= "Vanilla's Turbolaser Tool"
TOOL.Command		= nil
TOOL.ConfigName		= ""

TOOL.AdminOnly		= true

if ( CLIENT ) then
    language.Add( "Tool.turbolaser.name", "Vanilla's Turbolaser Tool" )
    language.Add( "Tool.turbolaser.desc", "Shoot turbolasers" )
    language.Add( "Tool.turbolaser.left", "Shoot a turbolaser from the sky")
    language.Add( "Tool.turbolaser.right", "Shoot a turbolaser from the toolgun")
    language.Add( "Tool.turbolaser.reload", "Creates a turbolaser spawner at your location")
end

TOOL.Information = {

	{ name = "left" },
    { name = "right" },
    { name = "reload"}

}

TOOL.ClientConVar[ "force" ] = "1000"
TOOL.ClientConVar[ "damage" ] = "150"
TOOL.ClientConVar[ "magnitude" ] = "100"
TOOL.ClientConVar["colour"] = "Blue"
TOOL.ClientConVar[ "shots" ] = "3"
TOOL.ClientConVar[ "delay" ] = "0.5"
TOOL.ClientConVar[ "spread" ] = "0"

function TOOL:TurboLaser( trace )
    if CLIENT then return true end

	local Force = self:GetClientNumber("force")
	local Damage = self:GetClientNumber("damage")
	local Magnitude = self:GetClientNumber("magnitude")
    local Colour = self:GetClientInfo("colour")

	if Force < 10 || Force > 10000
	|| Damage < 10 || Damage > 1000
	|| Magnitude < 10 || Magnitude > 500 then
		ply:PrintMessage(HUD_PRINTTALK,"Invalid values")
		return false
	end

	local ent = ents.Create("turbolaser")
	ent:SetKeyValue("Force", Force)
	ent:SetKeyValue("Damage", Damage)
	ent:SetKeyValue("Magnitude", Magnitude)
    ent:SetKeyValue("Colour", Colour)

	return true, ent
end

function TOOL:LeftClick( trace )
	if (!trace.HitPos) then return false end
	if (CLIENT) then return true end
	local Return, ent = self:TurboLaser( trace )
	if not Return then return false end
	local pos = trace.HitPos
	local tracedata = {}
	tracedata.start = pos
	tracedata.endpos = pos+( Vector( 0, 0, 1 ) * 5000 )
	tracedata.filter = self:GetOwner()
	local traceB = util.TraceLine(tracedata)
	ent:SetPos( traceB.HitPos + traceB.HitNormal * 16 )
	ent:SetAngles( Vector( 0, 0, -1 ):Angle() )
	ent:Spawn()
	ent:Activate()

    undo.Create( "Turbolaser" )
        undo.AddEntity( ent )
        undo.SetPlayer( self:GetOwner() )
        undo.SetCustomUndoText("Undone Turbolaser")
    undo.Finish()
end

function TOOL:RightClick( trace )
	local Return, ent = self:TurboLaser( trace )
	if (CLIENT) then return false end
	if not Return then return false end
	ent:SetOwner( self:GetOwner() )
	ent:SetPos( self:GetOwner():GetShootPos() )
	ent:SetAngles( self:GetOwner():GetAngles())
	ent:Spawn()
	ent:Activate()

    undo.Create( "Turbolaser" )
        undo.AddEntity( ent )
        undo.SetPlayer( self:GetOwner() )
        undo.SetCustomUndoText("Undone Turbolaser")
    undo.Finish()
end

function TOOL:Reload( trace )
    local spawner = ents.Create("turbolaserspawner")
    spawner:SetPos(self:GetOwner():GetShootPos())
    spawner:SetAngles(self:GetOwner():GetAngles())
    spawner:SetKeyValue("Delay",self:GetClientNumber("delay"))
    spawner:SetKeyValue("Shots",self:GetClientNumber("shots"))
    spawner:SetKeyValue("Force",self:GetClientNumber("force"))
    spawner:SetKeyValue("Damage",self:GetClientNumber("damage"))
    spawner:SetKeyValue("Magnitude",self:GetClientNumber("magnitude"))
    spawner:SetKeyValue("Colour",self:GetClientInfo("colour"))
    spawner:SetKeyValue("Spread",self:GetClientNumber("spread"))
    spawner:Spawn()
    spawner:Activate()

    undo.Create("Spawner")
        undo.AddEntity(spawner)
        undo.SetPlayer(self:GetOwner())
        undo.SetCustomUndoText("Undone Turbolaser Spawner")
    undo.Finish()
end

function TOOL:Think()
end

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel(CPanel)
    CPanel:SetName("Vanilla's Turbolaser Tool")

    CPanel:Help("Version 1.6")

    CPanel:AddControl( "ComboBox", { MenuButton = 1, Folder = "turbolaser", Options = { [ "#preset.default" ] = ConVarsDefault }, CVars = table.GetKeys( ConVarsDefault ) } )

    CPanel:NumSlider("Speed","turbolaser_force","10","10000","0")
    CPanel:ControlHelp("Sets the speed of the turbolaser.")

    CPanel:NumSlider("Damage","turbolaser_damage","10","1000","0")
    CPanel:ControlHelp("Sets the damage of the turbolaser.")

    CPanel:NumSlider("Damage Radius","turbolaser_magnitude","10","500","0")
    CPanel:ControlHelp("Sets the radius of the turbolaser's explosion.")

    local Colour = CPanel:ComboBox("Colour", "turbolaser_colour")
    Colour:AddChoice("Blue")
    Colour:AddChoice("Red")
    Colour:AddChoice("Green")
    Colour:AddChoice("Orange")
    Colour:AddChoice("Yellow")
    Colour:AddChoice("Pink")
    Colour:AddChoice("Black")
    CPanel:ControlHelp("Sets the colour of the turbolaser.")

    CPanel:NumSlider("Number of Shots","turbolaser_shots","1","50","0")
    CPanel:ControlHelp("Sets the number of shots for the turbolaser spawner.")

    CPanel:NumSlider("Delay between Shots","turbolaser_delay","0.1","5","1")
    CPanel:ControlHelp("Sets the delay between shots for the turbolaser spawner. (In seconds)")

    CPanel:NumSlider("Spread","turbolaser_spread","0","10","1")
    CPanel:ControlHelp("Sets spread of the turbolasers spawned from the turbolaser spawner.")
end

--PATH lua/weapons/gmod_tool/stools/vjstool_healthmodifier.lua:
return gluapack()()
--PATH lua/weapons/gmod_tool/stools/vjstool_notarget.lua:
return gluapack()()
--PATH lua/weapons/jet_mk2.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/keys/shared.lua:
AddCSLuaFile()

if SERVER then
    AddCSLuaFile("cl_menu.lua")
end

if CLIENT then
    SWEP.Slot = 1
    SWEP.SlotPos = 1
    SWEP.DrawAmmo = false
    SWEP.DrawCrosshair = false

    include("cl_menu.lua")
end

SWEP.PrintName = "Keys"
SWEP.Author = "DarkRP Developers"
SWEP.Instructions = "Left click to lock\nRight click to unlock\nReload for door settings or animation menu"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.IsDarkRPKeys = true

SWEP.WorldModel = ""

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = "rpg"

SWEP.UseHands = true

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "DarkRP (Utility)"
SWEP.Sound = "doors/door_latch3.wav"

SWEP.Primary.Delay = 0.3
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.Delay = 0.3
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

function SWEP:Initialize()
    self:SetHoldType("normal")
end

function SWEP:Deploy()
    if CLIENT or not IsValid(self:GetOwner()) then return true end
    self:GetOwner():DrawWorldModel(false)
    return true
end

function SWEP:Holster()
    return true
end

function SWEP:PreDrawViewModel()
    return true
end

local function lookingAtLockable(ply, ent, hitpos)
    local eyepos = ply:EyePos()
    return IsValid(ent)
        and ent:isKeysOwnable()
        and (
            ent:isDoor() and eyepos:DistToSqr(hitpos) < 2000
            or
            ent:IsVehicle() and eyepos:DistToSqr(hitpos) < 4000
        )
end

local function lockUnlockAnimation(ply, snd)
    ply:EmitSound("npc/metropolice/gear" .. math.random(1, 6) .. ".wav")
    timer.Simple(0.9, function() if IsValid(ply) then ply:EmitSound(snd) end end)

    umsg.Start("anim_keys")
        umsg.Entity(ply)
        umsg.String("usekeys")
    umsg.End()

    ply:AnimRestartGesture(GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_GMOD_GESTURE_ITEM_PLACE, true)
end

local function doKnock(ply, sound)
    ply:EmitSound(sound, 100, math.random(90, 110))

    umsg.Start("anim_keys")
        umsg.Entity(ply)
        umsg.String("knocking")
    umsg.End()

    ply:AnimRestartGesture(GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_HL2MP_GESTURE_RANGE_ATTACK_FIST, true)
end

function SWEP:PrimaryAttack()
    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    local trace = Owner:GetEyeTrace()

    local ent = trace.Entity

    if not lookingAtLockable(Owner, ent, trace.HitPos) then return end

    self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)

    if CLIENT then return end

    if Owner:canKeysLock(ent) then
        ent:keysLock() -- Lock the door immediately so it won't annoy people
        lockUnlockAnimation(Owner, self.Sound)
    elseif ent:IsVehicle() then
        DarkRP.notify(Owner, 1, 3, DarkRP.getPhrase("do_not_own_ent"))
    else
        doKnock(Owner, "physics/wood/wood_crate_impact_hard2.wav")
    end
end

function SWEP:SecondaryAttack()
    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    local trace = Owner:GetEyeTrace()

    local ent = trace.Entity

    if not lookingAtLockable(Owner, ent, trace.HitPos) then return end

    self:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)

    if CLIENT then return end

    if Owner:canKeysUnlock(ent) then
        ent:keysUnLock() -- Unlock the door immediately so it won't annoy people
        lockUnlockAnimation(Owner, self.Sound)
    elseif ent:IsVehicle() then
        DarkRP.notify(Owner, 1, 3, DarkRP.getPhrase("do_not_own_ent"))
    else
        doKnock(Owner, "physics/wood/wood_crate_impact_hard3.wav")
    end
end

function SWEP:Reload()
    local trace = self:GetOwner():GetEyeTrace()

    local ent = trace.Entity

    if not IsValid(ent) or ((not ent:isDoor() and not ent:IsVehicle()) or self:GetOwner():EyePos():DistToSqr(trace.HitPos) > 40000) then
        if CLIENT and not DarkRP.disabledDefaults["modules"]["animations"] then RunConsoleCommand("_DarkRP_AnimationMenu") end
        return
    end
    if SERVER then
        umsg.Start("KeysMenu", self:GetOwner())
        umsg.End()
    end
end

--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15a_heavy.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15a_train.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Training DC-15a"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The DC-15A blaster rifle, known simply as the DC-15 blaster rifle, was a heavy blaster rifle manufactured by BlasTech Industries, as part of the DC-15 family. It was one of the standard-issue weapons of the Galactic Republic's clone troopers, an army of cloned soldiers in the Grand Army of the Republic, during the Clone Wars against the Confederacy of Independent Systems."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15a_training.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.NoHideLeftHandInCustomization = true
SWEP.ViewModel = "models/servius/weapons/viewmodels/c_dc15a.mdl"
SWEP.WorldModel = "models/servius/weapons/worldmodels/w_dc-15a.mdl"
SWEP.ViewModelFOV = 56

SWEP.DefaultBodygroups = "010"
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 1
SWEP.RangeMin = 243
SWEP.DamageMin = 1
SWEP.Range = 510
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_orange"
SWEP.TracerCol = Color(250, 146, 0)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 55

SWEP.Recoil = 0.43
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.63
SWEP.Delay = 60 / 324
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
		Mode = -2
	},
    {
        Mode = 0
    },            
}

SWEP.AccuracyMOA = 0.50
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 50

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc15.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_orange"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(255, 157, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.66, -12.75, 2.529),
    Ang = Angle(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 2, 3)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(15, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true 
SWEP.BipodDispersion = 1
SWEP.BipodRecoil = 1 

-- Attachments
SWEP.DefaultElements = {"dc15"}
SWEP.AttachmentElements = {
    ["dc15"] = {
        WMElements = {
            {
                Model = "models/servius/weapons/worldmodels/w_dc-15a.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                WBodygroups = {{ind = 0, bg = 0}},
                Offset = {
                    pos = Vector(-550, 0, 470),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(4150, 0, -1100),
                    ang = Angle(-15, 0, 100)
                },
                IsMuzzleDevice = true
            },
        },
    },
}
WMOverride = "models/servius/weapons/worldmodels/w_dc-15a.mdl"

SWEP.Attachments = {
    {
        PrintName = "Sight",
        DefaultAttName = "Standard", 
        Slot = "optic", 
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(0.110, -3.771, 2.1),
            vang = Angle(0, -90, 0),
            wpos = Vector(420, 50, -450),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },          
    {
        PrintName = "Magazine Capacity",
        DefaultAttName = "Standard",
        Slot = {"dc15a_magazine_75"},
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(0, -3.7, 0.5),
            vang = Angle(0, 0, 90),
            wpos = Vector(550, 115, -250),
            wang = Angle(-15, -90, -90)
        },
    },      
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },   
    {
        PrintName = "Ammo", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(1.3, -6.739, 0.504),
            vang = Angle(0, -90, 0),
            wpos = Vector(115, 180, -125),
            wang = Angle(-10 , 0, 180)
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(1.1, -9, 0.7),
            vang = Angle(0, -90, 0),
            wpos = Vector(-100, 180, -75),
            wang = Angle(-15 , 0, 180)
        },
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Neutral"
    },
    ["fire"] = {
        Time = 2.3,
        Source = {"shoot", "shoot2"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_lgequip.wav",
                p = 100, 
                v = 75,
                t = 0, 
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_medequip.wav",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "dc15a_reload1", t = 2 / 10},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_03.mp3", t = 2 },
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 2 / 30},
        },
    },


sound.Add({
    name =          "dc15a_reload1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "armas/misc/dc17s_reload.wav"
    }),
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15s.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-15s"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "The DC-15A blaster carbine, also referred to as the DC-15S blaster, was a blaster carbine model used by the Grand Army of the Republic. It was part of the DC-15 family. While smaller than the larger DC-15A blaster rifle, both could be referred to as blaster rifles. It was one of the most common weapons issued to clone troopers during the Clone Wars and were used during many battles."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15s.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/servius/starwars/c_dc15s.mdl"
SWEP.WorldModel = "models/servius/starwars/w_dc15s.mdl"
SWEP.ViewModelFOV = 58
SWEP.WorldModelOffset = {
    pos = Vector(-9, 3.5, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.6,
    [HITGROUP_CHEST] = 1.2,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 37
SWEP.RangeMin = 198
SWEP.DamageMin = 21
SWEP.Range = 399
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 34

SWEP.Recoil = 0.67
SWEP.RecoilSide = 0.34
SWEP.RecoilRise = 0.53
SWEP.Delay = 60 / 255

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.5 
SWEP.HipDispersion = 490
SWEP.MoveDispersion = 60

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc15s.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.837, 0.619, 1.656),
    Ang = Angle(0, 0, 0),
     Magnification = 1.3,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1

SWEP.ActivePos = Vector(0, 2, 0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, 0)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC15",
        Offset = {
            vpos = Vector(0, -1.6, -0.5),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Grip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "DC15",
        Offset = {
            vpos = Vector(-0.101, 2.378, 6.164),
            vang = Angle(90, 0, -90),
        },
        SlideAmount = {
        vmin = Vector(-0.2, 0, 5.100),
        vmax = Vector(-0.2, 0, 9),
        },          
    },
    {
        PrintName = "Stock",
        DefaultAttName = "None",
        Bone = "DC15",
        Slot = "stock",
        Offset = {
            vpos = Vector(0, 0.5, -9.1),
            vang = Angle(0, 0, -90),
        },
    }, 
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC15", 
        Offset = {
            vpos = Vector(0.8, -0.5, 10),
            vang = Angle(90, 0, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.1, -0.442, 11.638),
            vang = Angle(90, 0, -90),

        },
    },    
    {
        PrintName = "Ammo",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.9, -0.7, 5.7),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.8, -0.2, -5),
            vang = Angle(90, 0, -90),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3",
                p = 100, 
                v = 75, 
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "dc15s_1", t = 1.68 / 60},
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_manualcooling_var_02.mp3", t = 0.1},
        },
    },

sound.Add({
    name =          "dc15s_1",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armasclasicas/wpn_empire_medreload.wav"
    }),

}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15s_stun.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15x.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number


-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-15x"
SWEP.Trivia_Class = "Blaster Sniper Rifle"
SWEP.Trivia_Desc = "The DC-15x sniper rifle was a sniper rifle manufactured for the clone snipers of the Galactic Republic through extensive modifications of the standard-issue DC-15A blaster rifle."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15x.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.NoHideLeftHandInCustomization = true

SWEP.ViewModel = "models/ser/starwars/c_dc15x.mdl"
SWEP.WorldModel = "models/ser/starwars/w_dc15x.mdl"

SWEP.ViewModelFOV = 50
SWEP.WorldModelOffset = {
    pos = Vector(8, 1., -3.5),
    ang = Angle(-5, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1.2
}

SWEP.DefaultBodygroups = "111"
SWEP.DefaultWMBodygroups = "111"

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 139
SWEP.RangeMin = 433
SWEP.DamageMin = 54
SWEP.Range = 1075
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 11

SWEP.Recoil = 1.78
SWEP.RecoilSide = 0.36
SWEP.RecoilRise = 0.76

SWEP.Delay = 60 / 70
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.47
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 76

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.83
SWEP.SightTime = 0.35

-- Ammo, Sounds & MuzzleEffect
SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc15x.wav"
SWEP.ShootSoundSilenced = "armas/disparos/silenced_sniper.mp3"

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.941, -6.442, 1.307),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(1, 3, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true
SWEP.BipodDispersion = 1
SWEP.BipodRecoil = 1

-- Attachments 
SWEP.Attachments = {
	{
		PrintName = "Sight", 
		DefaultAttName = "Standard",
		Slot = "optic",
		Bone = "optic",
		Offset = {
            vpos = Vector(0.02, 0, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 0.8, -4.6),
            wang = Angle(-7, 0, 180),
        },
	},
    {
        PrintName = "Tactical", 
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        Bone = "optic",
        Offset = {
            vpos = Vector(0.8, 1, 15),
            vang = Angle(90, 0, -0),
            wpos = Vector(24, 1.4, -5),
            wang = Angle(-5, 0, -90),
        },
    },
    {
        PrintName = "Grip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "optic",
        Offset = {
            vpos = Vector(0, 2, 15),
            vang = Angle(90, 0, -90),    
            wang = Angle(-3, 0, 180)     
        },
        SlideAmount = {
        vmin = Vector(-0.2, 2.6, 6),
        vmax = Vector(-0.2, 2.6, 12),
        wmin = Vector(15, 0.6, -2.3), 
        wmax = Vector(15, 0.6, -2.3)
        },         
    }, 
    {
        PrintName = "Muzzle",
        DefaultAttName = "None", 
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "optic", 
        Offset = {
            vpos = Vector(0, 1, 20),
            vang = Angle(90, 0, -90),
            wpos = Vector(26, 0.75, -5.25),
            wang = Angle(-5, 0.5, 180)
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "Standard Energization",
        Slot = "ammo",
    },  
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    }, 
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "optic",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(1, 1.6, -3.8),
            vang = Angle(90, 0, -90),
            wpos = Vector(2.3, 1.8, -2.3),
            wang = Angle(0, 0, 180)
        },
    },       
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "optic",
        Offset = {
            vpos = Vector(1, 1.350, -6),
            vang = Angle(90, 0, -90),
            wpos = Vector(-2, 1.8, -2.3),
            wang = Angle(-5, 0, 180)
        },
    },      
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/sw01_characters_gunfoley_draw_blaster_var14.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "dc15x-1", t = 0.1 }, --s sound file
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 0.1 },
            {s = "everfall/weapons/handling/reload_heavy/mag_load/023d-000000ae.mp3", t = 0.9 }, --s sound file
        },
    },

sound.Add({
    name =          "dc15x-1",
    channel =       CHAN_ITEM,
    volume =        1.1,
    sound =             "everfall/weapons/handling/reload_heavy/mag_eject/023d-00000628.mp3"
    }),
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc17_stun.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Stun DC-17"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DC-17 hand blaster, also known as DC-17 blaster pistol, was a heavy blaster pistol wielded by the clone troopers of the Grand Army of the Galactic Republic during the Clone Wars. An advanced firearm, it was fielded to elite soldiers in the army, most notably Advanced Recon Commandos, clone trooper commanders, and clone jet troopers."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc17_stun.png"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = true

SWEP.ViewModel = "models/venator/weapons/viewmodels/c_dc17.mdl"
SWEP.WorldModel = "models/venator/weapons/worldmodels/w_dc-17.mdl"
SWEP.ViewModelFOV = 58
SWEP.WorldModelOffset = {
    pos = Vector(-11.3, 4.3, -3),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 29
SWEP.RangeMin = 102
SWEP.DamageMin = 23
SWEP.Range = 299
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.98
SWEP.RecoilPunch = 0.8
SWEP.RecoilSide = 0.17
SWEP.RecoilRise = 0.24

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
		Mode = -2
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 
SWEP.HipDispersion = 530
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

---- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.922, -4.125, 0.237),
    Ang = Vector(0.158, -3.961, 0),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

SWEP.Primary.Ammo = "ar2"

-- Sound & Holdtype
SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "armas/disparos/dc17_2.wav"
SWEP.ShootSound = "armas/disparos/dc17_1.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(1, 6, 1)
SWEP.ActiveAng = Angle(-3.2, -3, 0)

SWEP.SprintPos = Vector(1, -6, -10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(10, 0, -1.08)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Attachments 
SWEP.AttachmentElements = {
    ["dc17_powerpack"] = {
        VMBodygroups = {
            {ind = 4, bg = 1},
        },
    },
    ["dc17_cooling"] = {
        VMBodygroups = {
            {ind = 3, bg = 1},
        },
    },
}


SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0, -2.3, 0),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(9, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        WMScale = Vector(0.7, 0.7, 0.7),
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0, -0.3, 2.7),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Muzzle", 
        DefaultAttName = "None", 
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0, -1.2, 3.442),
            vang = Angle(90, 0, -90),
        },
    }, 
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },        
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "sw_ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Cooling System",
        DefaultAttName = "None",
        Slot = "dc17_cooling",
    },
    {
        PrintName = "Powerpack",
        DefaultAttName = "None",
        Slot = "dc17_powerpack",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7,0.7,0.7),
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0.7, -0.848, 0.184),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0.7, -0.848, -3),
            vang = Angle(90, 0, -90),
        },
    },   
}


SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        SoundTable = {
            {s = "dc17_1", t = 1 / 60}, --s sound file
        },
    },


sound.Add({
    name =          "dc17_1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "armasclasicas/wpn_wristrocket_reload.wav"
    }),
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc17s.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dual_dc17ext.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Dual DC-17 Extended"
SWEP.Trivia_Class = "Dual Blaster Pistol"
SWEP.Trivia_Desc = "The DC-17s hand blaster, also known as DC-17s blaster pistol, was a heavy blaster pistol wielded by the clone troopers of the Grand Army of the Galactic Republic during the Clone Wars. An advanced firearm, it was fielded to elite soldiers in the army, most notably Advanced Recon Commandos, clone trooper commanders, and clone jet troopers. This one version is a powerful one."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2024
SWEP.IconOverride = "entities/masita/dual_dc17ext.png"

SWEP.Slot = 1

SWEP.UseHands = true
SWEP.NoHideLeftHandInCustomization = true
SWEP.DefaultBodygroups = "001100000110000"
SWEP.HideViewmodel = false

SWEP.ViewModel = "models/arccw/kraken/republic/v_akimbo_dc17.mdl"
SWEP.WorldModel = "models/venator/weapons/worldmodels/w_dc-17.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_STOMACH] = 1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.9,
    [HITGROUP_RIGHTLEG] = 0.9,
}

SWEP.Damage = 39
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 320
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 4000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 0

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 45

SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0.6
SWEP.Recoil = 0.7

SWEP.Delay = 60 / 320
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 3,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 1
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 125 
SWEP.SightsDispersion = 0 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 1.1
SWEP.SightedSpeedMult = 0.77
SWEP.ShootSpeedMult = 1

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "armas/disparos/dc17_1.wav"
SWEP.ShootSound = "armas/disparos/dc17_2.wav"
SWEP.ShootSoundSilenced = "weapons/silenced.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = false
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 90,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.MovingPos = Vector(0, -1.5, -0.8)
SWEP.MovingAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(0, -1.5, -1)
SWEP.CrouchAng = Angle(0, 0, -5)

SWEP.SprintPos = Vector(-1, 0, -1)
SWEP.SprintAng = Angle(0, 0, -5)

SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

--SWEP.Attachments 
SWEP.DefaultElements = {"dc17"}
SWEP.AttachmentElements = {
    ["dc17"] = {
        WMElements = {
            {
                Model = "models/venator/weapons/worldmodels/w_dc-17.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                ModelBodygroups = "01111",
                Offset = {
                    pos = Vector(-45, 15, 10),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/venator/weapons/worldmodels/w_dc-17.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                ModelBodygroups = "01111",
                Offset = {
                    pos = Vector(-135, 230, -35),
                    ang = Angle(180, -180, 2)
                }
            },
        },   
    }
}
WMOverride = "models/venator/weapons/worldmodels/w_dc-17.mdl"

SWEP.Attachments = {   
    [1] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    }
}


local path = "kraken/republic/dc17/"

SWEP.Animations = {
    ["fire"] = {
        Source = {"fire_right", "fire_left"}
    },
    ["reload"] = {
        Source = "reload_short",
		MinProgress = 0.725,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
			{s = path .. "wfoly_pi_mike1911_reload_empty_lift.ogg", t = 0/30},
			{s = path .. "wfoly_pi_mike1911_fast_reload_empty_lift.ogg", t = 4/30},
			{s = path .. "wfoly_pi_mike1911_reload_empty_magout_01.ogg", t = 6/30},
			{s = path .. "wfoly_pi_mike1911_fast_reload_empty_magout_01.ogg", t = 10/30},
			{s = path .. "wfoly_pi_mike1911_reload_empty_magin_v2_01.ogg", t = 49/30},
			{s = path .. "wfoly_pi_mike1911_reload_empty_magin_v2_01.ogg", t = 52/30},
			{s = path .. "wfoly_pi_mike1911_reload_empty_magin_v2_02.ogg", t = 54/30},
			{s = path .. "wfoly_pi_mike1911_fast_reload_magin_01.ogg", t = 54/30},
			{s = path .. "wfoly_pi_mike1911_reload_end.ogg", t = 62/30},
			{s = path .. "wfoly_pi_mike1911_fast_reload_end.ogg", t = 62/30},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
		MinProgress = 0.8,
        SoundTable = {
			{s = path .. "wfoly_pi_mike1911_reload_empty_lift.ogg", t = 0/30},
			{s = path .. "wfoly_pi_mike1911_fast_reload_empty_lift.ogg", t = 5/30},
			{s = path .. "wfoly_pi_mike1911_reload_empty_magout_01.ogg", t = 7/30},
			{s = path .. "wfoly_pi_mike1911_fast_reload_empty_magout_01.ogg", t = 12/30},
			{s = path .. "wfoly_pi_mike1911_reload_empty_magin_v2_01.ogg", t = 52/30},
			{s = path .. "wfoly_pi_mike1911_fast_reload_empty_magin_01.ogg", t = 54/30},
			{s = path .. "wfoly_pi_mike1911_reload_empty_end.ogg", t = 60/30},
			{s = path .. "wfoly_pi_mike1911_reload_empty_end.ogg", t = 61/30},
			{s = path .. "wfoly_pi_mike1911_reload_empty_chamber_01.ogg", t = 73/30},
			{s = path .. "wfoly_pi_mike1911_reload_empty_chamber_01.ogg", t = 76/30},
        },
    },
    ["ready"] = {
        Source = "draw_first",
        SoundTable = {
            {s = path .. "wfoly_pi_mike1911_first_raise_lift.ogg", t = 0/30},
            {s = path .. "wfoly_pi_mike1911_first_raise_slide_pull.ogg", t = 24/30},
			{s = path .. "wfoly_pi_mike1911_first_raise_slide_release.ogg", t = 25/30},
			{s = path .. "wfoly_pi_mike1911_first_raise_chamber_end.ogg", t = 28/30},
        },
    },
    ["draw"] = {
        Source = "draw",
		MinProgress = 0.3,
        FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_pi_mike1911_raise.ogg", t = 0/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_pi_mike1911_reload_empty_end.ogg", t = 0/30},
            {s = path .. "wfoly_pi_mike1911_fast_reload_end.ogg", t = 5/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
		Time = 0.25,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
		Time = 0.25,
    },
    ["enter_inspect"] = {
        Source = "lookat01",
		MinProgress = 0.1,
		FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_pi_mike1911_inspect_01.ogg", t = 0/30},
			{s = path .. "wfoly_pi_mike1911_inspect_02.ogg", t = 36/30},
			{s = path .. "wfoly_pi_mike1911_inspect_03.ogg", t = 61/30},
			{s = path .. "wfoly_pi_mike1911_inspect_04.ogg", t = 112/30},
        },
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"},
    },
}

--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_nt242.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "NT-242"
SWEP.Trivia_Class = "Blaster Sniper Rifle"
SWEP.Trivia_Desc = "The NT-242 was a type of sniper rifle. The NT-242 was considered a tank buster by many users and was one of the heaviest longblasters. The NT-242 was powerful at range, and could be modified to have a disruptor shot which could engage vehicles."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/nt242.png"

SWEP.UseHands = true

SWEP.ViewModel = "models/everfall/weapons/viewmodels/c_nt242.mdl"
SWEP.WorldModel = "models/everfall/weapons/worldmodels/w_nt242.mdl"
SWEP.ViewModelFOV = 55
SWEP.MirrorVMWM = true
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(-11.5, 4, -5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.DefaultWMBodygroups = "02"
SWEP.DefaultBodygroups = "02"

-- Properties
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.3,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 176
SWEP.RangeMin = 273
SWEP.DamageMin = 69
SWEP.Range = 1072

SWEP.Penetration = 1.3
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TracerNum = 1
SWEP.Tracer = "tracer_purple"
SWEP.TracerCol = Color(247, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 18

SWEP.Recoil = 1.4
SWEP.RecoilSide = 0.3
SWEP.RecoilRise = 0.19

SWEP.Delay = 60 / 98
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.1
SWEP.HipDispersion = 300

SWEP.MoveDispersion = 60
SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_purple"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(247, 0, 255)

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "armas/disparos/nt242.mp3"
SWEP.ShootSoundSilenced = "armas/disparos/silenced_sniper.mp3"
SWEP.IronSightStruct = {
    Pos = Vector(-3.71, -5.549, 1.526),
    Ang = Angle(0, 0, 0),
     Magnification = 2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true
SWEP.BipodDispersion = 1
SWEP.BipodRecoil = 1

SWEP.AttachmentElements = {
    ["242_barrel_extended"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
        NameChange = "Extended NT-242",
        AttPosMods = {
            [3] = {
                vpos = Vector(0.007, 0.98, 47.5),
            },
        }
    },
}

SWEP.Attachments = {
    [1] = {
        PrintName = "Sight",
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "nt242", 
        Offset = {
            vpos = Vector(0, -1.1, 4.93),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    [2] = {
        PrintName = "Barrel", 
        DefaultAttName = "Standard",
        Slot = "242_barrel",
    },  
    [3] = {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "nt242",
        Offset = {
            vpos = Vector(0.007, 0.98, 40.043),
            vang = Angle(90, 0, 0),
        },
    },
    [4] = {
        PrintName = "Grip",
        DefaultAttName = "None",
        Slot = {"foregrip", "bipod"},
        Bone = "nt242", 
        Offset = {
            vpos = Vector(0, 2.253, 15.001),
            vang = Angle(90, 0, -90),
        },
        SlideAmount = {
            vmin = Vector(0, 2, 15),
            vmax = Vector(0, 2, 25),
        },  
    }, 
    [5] = {
        PrintName = "Tactical", 
        DefaultAttName = "None",
        Slot = {"tactical","tac_pistol"},
        Bone = "nt242", 
        Offset = {
            vpos = Vector(0.939, 0.982, 14.303),
            vang = Angle(90, 0, 0),
        },
    },    
    [6] = {
        PrintName = "Ammo", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },  
    [7] = {
        PrintName = "Perk", 
        DefaultAttName = "Standard",
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charm", 
        DefaultAttName = "None", 
        Slot = {"charm"},
        Bone = "nt242", 
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.931, 1.174, 0),
            vang = Angle(90, 0, -90),
        },
    },    
    [9] = {
        PrintName = "Killcounter", 
        DefaultAttName = "None", 
        Slot = {"killcounter"},
        VMScale = Vector(0.9, 0.9, 0.9),
        Bone = "nt242", 
        Offset = {
            vpos = Vector(0.931, 1.174, 5),
            vang = Angle(90, 0, -90),
        },
    },          
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = "shoot"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.1,
        SoundTable = {
            {s = "everfall/weapons/handling/reload_heavy/locknload/023d-00000f08.mp3", t = 1}
        },
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
        SoundTable = {
            {s = "nt242_r1", t = 3 / 30}, --s sound file
            {s = "everfall/weapons/handling/reload_heavy/locknload/023d-00000f08.mp3", t = 2.2}
        },
    },


sound.Add({
    name =          "nt242_r1",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armasclasicas/wpn_republic_medreload.wav"
    }),
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_westarm5_alpha.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 

SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita/Meeks"
SWEP.PrintName = "Westar M-5 Alpha"
SWEP.Trivia_Class = "Modular Blaster"
SWEP.Trivia_Desc = "The WESTAR-M5 blaster rifle was a blaster rifle used during the Clone Wars by the Grand Army of the Republic. They were mainly used by the Alpha-class Advanced Recon Commandos during the later years of the conflict."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/westarm5_alpha.png"

SWEP.ViewModel = "models/ser/starwars/c_westarm5.mdl"
SWEP.WorldModel = "models/ser/starwars/w_westarm5.mdl"
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "111"
SWEP.DefaultWMBodygroups = "111"
SWEP.DefaultSkin = 3
SWEP.DefaultWMSkin = 3

SWEP.NoHideLeftHandInCustomization = false

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.7,
    [HITGROUP_CHEST] = 1.5,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 47
SWEP.DamageMin = 22 -- damage done at maximum range
SWEP.RangeMin = 172 -- how far bullets will retain their maximum damage for
SWEP.Range = 340 -- in METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false

SWEP.MuzzleVelocity = 472

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 3
SWEP.TracerNum = 1 
SWEP.TracerFinalMag = 0 
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 47, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 50 -- DefaultClip is automatically set.

SWEP.AmmoPerShot = 1

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.Recoil = 0.2
SWEP.RecoilSide = 0.1
SWEP.RecoilRise = 0
SWEP.MaxRecoilBlowback = 1
SWEP.VisualRecoilMult = 1

SWEP.RecoilDirection = Angle(0.2, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1.1, 0)

SWEP.Delay = 60 / 580 
SWEP.Num = 1 
SWEP.Firemode = 2 
SWEP.Firemodes = {
	{
		Mode = 2,
   	},
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.NotForNPCS = true
SWEP.NPCWeaponType = nil

SWEP.AccuracyMOA = 5 
SWEP.HipDispersion = 410 
SWEP.MoveDispersion = 65
SWEP.SightsDispersion = 150 
SWEP.JumpDispersion = 200

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125 
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "armas/disparos/westar_1.wav"
SWEP.ShootSound = "armas/disparos/westar_2.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"


SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false 

SWEP.MuzzleEffectAttachment = 1 
SWEP.ProceduralViewBobAttachment = 1
SWEP.MuzzleFlashColor = Color(0, 102, 255)

SWEP.SpeedMult = 0.87
SWEP.SightedSpeedMult = 0.77
SWEP.ShootSpeedMult = 1

SWEP.IronSightStruct = {
    Pos = Vector(-3.05, -0, 2.1),
    Ang = Angle(0, 0, 0),
    Midpoint = {
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
    },
    Magnification = 1.2,
    SwitchToSound = "armasclasicas/wpn_cis_medequip.wav",
    CrosshairInSights = false,
}


SWEP.SightTime = 0.13
SWEP.SprintTime = 0


SWEP.Malfunction = false
SWEP.MalfunctionJam = true 
SWEP.MalfunctionTakeRound = true 
SWEP.MalfunctionWait = 0.5 
SWEP.MalfunctionMean = nil 
SWEP.MalfunctionVariance = 0.25
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoldtypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2
SWEP.CanBash = true
SWEP.MeleeDamage = 27
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2
SWEP.SprintPos = Vector(.5, -6, -12)
SWEP.SprintAng = Angle(40, 0, 0)
SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)
SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)
SWEP.ActivePos = Vector(0, 3, 1)
SWEP.ActiveAng = Angle(0, 0, 0)
SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.CustomizePos = Vector(6.824, -7, 4.897)
SWEP.CustomizeAng = Angle(12.149, 45.547, 45)
SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.SightPlusOffset = true

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        WMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(15, 0.5, -8),
                    ang = Angle(0, 0, 0)
                },
                IsMuzzleDevice = true
            }
        }, 
    },
}

SWEP.Attachments = {
	{
		PrintName = "Sight",
		DefaultAttName = "Standard",
		Slot = "optic",
		Bone = "weapon",
		Offset = {
            vpos = Vector(0.02, -2.4, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 1, -7),
            wang = Angle(-10, 2, 180)
        },
	},
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
		Bone = "weapon",
        Offset = {
            vpos = Vector(0.8, -0.8, 4),
            vang = Angle(90, 0, -0),
            wpos = Vector(7, 2, -5.5),
            wang = Angle(-10, 5, -90)
        },
    },
    {
        PrintName = "Charms", 
        DefaultAttName = "None",
        Slot = {"charm"},
		Bone = "weapon",
        Offset = {
            vpos = Vector(1, -1, -3.2),
            vang = Angle(90, 0, -90),
            wpos = Vector(1.2, 2.2, -4.5),
            wang = Angle(0, 0, 180)
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "No Attachment", 
        Slot = "foregrip",
        Bone = "weapon",
        Offset = {
            vpos = Vector(0, 2.2, 2.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(9, .5, -1.5),
            wang = Angle(0, 0, 180)            
        },
        NoWM = true,
        NoVM = true,    
    },
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk", 
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
		Bone = "weapon",
        Offset = {
            vpos = Vector(0, -0.9, 8.1),
            vang = Angle(90, 0, 0),
            wpos = Vector(16, .5, -7.2),
            wang = Angle(-10, 0, -90)
        },
    },                              
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = "fire",
    },
	["idle_sights"] = {
        Source = "idle",
        Mult = 10000,
    },
	["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
		SoundTable = {
	        {s = "armas/misc/westar_reload.mp3", t = 0.1 }
        },
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_02.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "everfall/weapons/handling/023d-00000d8c.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
}
--PATH lua/weapons/rw_ammo_distributor.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/common/bullet.lua:
local vector_origin = Vector()
local angle_zero = Angle()

local l_mathClamp = math.Clamp
local Lerp = Lerp
SWEP.MainBullet = {}
SWEP.MainBullet.Spread = Vector()

local function DisableOwnerDamage(a, b, c)
	if b.Entity == a and c then
		c:ScaleDamage(0)
	end
end

local ballistics_distcv = GetConVar("sv_tfa_ballistics_mindist")

local function BallisticFirebullet(ply, bul, ovr, angPreserve)
	local wep = ply:GetActiveWeapon()

	if TFA.Ballistics and TFA.Ballistics:ShouldUse(wep) then
		if ballistics_distcv:GetInt() == -1 or util.QuickTrace(ply:GetShootPos(), ply:GetAimVector() * 0x7fff, ply).HitPos:Distance(ply:GetShootPos()) > (ballistics_distcv:GetFloat() * TFA.Ballistics.UnitScale) then
			bul.SmokeParticle = bul.SmokeParticle or wep.BulletTracer or wep.TracerBallistic or wep.BallisticTracer or wep.BallisticsTracer

			if ovr then
				TFA.Ballistics:FireBullets(wep, bul, angPreserve or angle_zero, true)
			else
				TFA.Ballistics:FireBullets(wep, bul, angPreserve)
			end
		else
			ply:FireBullets(bul)
		end
	else
		ply:FireBullets(bul)
	end
end

--[[
Function Name:  ShootBulletInformation
Syntax: self:ShootBulletInformation().
Returns:   Nothing.
Notes:  Used to generate a self.MainBullet table which is then sent to self:ShootBullet, and also to call shooteffects.
Purpose:  Bullet
]]
--
local sv_tfa_damage_multiplier = GetConVar("sv_tfa_damage_multiplier")
local sv_tfa_damage_multiplier_npc = GetConVar("sv_tfa_damage_multiplier_npc")
local cv_dmg_mult_min = GetConVar("sv_tfa_damage_mult_min")
local cv_dmg_mult_max = GetConVar("sv_tfa_damage_mult_max")
local sv_tfa_recoil_legacy = GetConVar("sv_tfa_recoil_legacy")
local dmg, con, rec

function SWEP:ShootBulletInformation()
	--self:CalculateRatios()
	self:UpdateConDamage()

	self.lastbul = nil
	self.lastbulnoric = false
	self.ConDamageMultiplier = self:GetOwner():IsNPC() and sv_tfa_damage_multiplier_npc:GetFloat() or sv_tfa_damage_multiplier:GetFloat()

	if not IsFirstTimePredicted() then return end

	con, rec = self:CalculateConeRecoil()

	local tmpranddamage = util.SharedRandom("TFA_Bullet_RandomDamageMult" .. CurTime(), cv_dmg_mult_min:GetFloat(), cv_dmg_mult_max:GetFloat(), self:EntIndex())
	local basedamage = self.ConDamageMultiplier * self:GetStatL("Primary.Damage")
	dmg = basedamage * tmpranddamage

	local ns = self:GetStatL("Primary.NumShots")
	local clip = (self:GetStatL("Primary.ClipSize") == -1) and self:Ammo1() or self:Clip1()

	ns = math.Round(ns, math.min(clip / self:GetStatL("Primary.NumShots"), 1))

	self:ShootBullet(dmg, rec, ns, con)
end

function SWEP:PreSpawnProjectile(ent)
	-- override
end

function SWEP:PostSpawnProjectile(ent)
	-- override
end

--[[
Function Name:  ShootBullet
Syntax: self:ShootBullet(damage, recoil, number of bullets, spray cone, disable ricochet, override the generated self.MainBullet table with this value if you send it).
Returns:   Nothing.
Notes:  Used to shoot a self.MainBullet.
Purpose:  Bullet
]]
--
local TracerName
local cv_forcemult = GetConVar("sv_tfa_force_multiplier")
local cv_knockbackmult = GetConVar("sv_tfa_knockback_multiplier")
local sv_tfa_bullet_penetration_power_mul = GetConVar("sv_tfa_bullet_penetration_power_mul")
local sv_tfa_bullet_randomseed = GetConVar("sv_tfa_bullet_randomseed")

local randomseed = "tfa_" .. tostring({})

SWEP.Primary.SpreadBiasYaw = 1
SWEP.Primary.SpreadBiasPitch = 1

-- Default ComputeBulletDeviation implementation
-- Custom implementations should return two numbers
-- Yaw (X) and Pitch (Y) deviation
function SWEP:ComputeBulletDeviation(bulletNum, totalBullets, aimcone)
	local sharedRandomSeed

	if sv_tfa_bullet_randomseed:GetBool() then
		sharedRandomSeed = randomseed .. CurTime()
	else
		sharedRandomSeed = "TFA_ShootBullet" .. CurTime()
	end

	return
		-- Yaw
		util.SharedRandom(sharedRandomSeed, -aimcone * 45 * self:GetStatL("Primary.SpreadBiasYaw"), aimcone * 45 * self:GetStatL("Primary.SpreadBiasYaw"), totalBullets + 1 + bulletNum),
		-- Pitch
		util.SharedRandom(sharedRandomSeed, -aimcone * 45 * self:GetStatL("Primary.SpreadBiasPitch"), aimcone * 45 * self:GetStatL("Primary.SpreadBiasPitch"), bulletNum)
end

function SWEP:ShootBullet(damage, recoil, num_bullets, aimcone, disablericochet, bulletoverride)
	if not IsFirstTimePredicted() and not game.SinglePlayer() then return end
	num_bullets = num_bullets or 1
	aimcone = aimcone or 0

	self:SetLastGunFire(CurTime())

	local owner = self:GetOwner()

	if self:GetStatL("Primary.Projectile") then
		if CLIENT then return end

		for i = 1, num_bullets do
			local ent = ents.Create(self:GetStatL("Primary.Projectile"))

			local ang = self:GetAimAngle()

			local dYaw, dPitch = self:ComputeBulletDeviation(i, num_bullets, aimcone)
			ang:RotateAroundAxis(ang:Up(), dYaw)
			ang:RotateAroundAxis(ang:Right(), dPitch)

			ent:SetPos(owner:GetShootPos())
			ent:SetOwner(owner)
			ent:SetAngles(ang)
			ent.damage = self:GetStatL("Primary.Damage")
			ent.mydamage = self:GetStatL("Primary.Damage")

			if self:GetStatL("Primary.ProjectileModel") then
				ent:SetModel(self:GetStatL("Primary.ProjectileModel"))
			end

			self:PreSpawnProjectile(ent)

			ent:Spawn()

			local dir = ang:Forward()
			dir:Mul(self:GetStatL("Primary.ProjectileVelocity"))

			ent:SetVelocity(dir)
			local phys = ent:GetPhysicsObject()

			if IsValid(phys) then
				phys:SetVelocity(dir)
			end

			if self.ProjectileModel then
				ent:SetModel(self:GetStatL("Primary.ProjectileModel"))
			end

			self:PostSpawnProjectile(ent)
		end
		-- Source
		-- Dir of self.MainBullet
		-- Aim Cone X
		-- Aim Cone Y
		-- Show a tracer on every x bullets
		-- Amount of force to give to phys objects

		return
	end

	if self.Tracer == 1 then
		TracerName = "Ar2Tracer"
	elseif self.Tracer == 2 then
		TracerName = "AirboatGunHeavyTracer"
	else
		TracerName = "Tracer"
	end

	self.MainBullet.PCFTracer = nil

	if self:GetStatL("TracerName") and self:GetStatL("TracerName") ~= "" then
		if self:GetStatL("TracerPCF") then
			TracerName = nil
			self.MainBullet.PCFTracer = self:GetStatL("TracerName")
			self.MainBullet.Tracer = 0
		else
			TracerName = self:GetStatL("TracerName")
		end
	end

	self.MainBullet.Attacker = owner
	self.MainBullet.Inflictor = self
	self.MainBullet.Src = owner:GetShootPos()

	self.MainBullet.Dir = self:GetAimVector()
	self.MainBullet.HullSize = self:GetStatL("Primary.HullSize") or 0
	self.MainBullet.Spread.x = 0
	self.MainBullet.Spread.y = 0

	self.MainBullet.Num = 1

	if num_bullets == 1 then
		local dYaw, dPitch = self:ComputeBulletDeviation(1, 1, aimcone)

		local ang = self.MainBullet.Dir:Angle()
		local up, right = ang:Up(), ang:Right()

		ang:RotateAroundAxis(up, dYaw)
		ang:RotateAroundAxis(right, dPitch)

		self.MainBullet.Dir = ang:Forward()
	end

	self.MainBullet.Wep = self

	if self.TracerPCF then
		self.MainBullet.Tracer = 0
	else
		self.MainBullet.Tracer = self:GetStatL("TracerCount") or 3
	end

	self.MainBullet.TracerName = TracerName
	self.MainBullet.PenetrationCount = 0
	self.MainBullet.PenetrationPower = self:GetStatL("Primary.PenetrationPower") * sv_tfa_bullet_penetration_power_mul:GetFloat(1)
	self.MainBullet.InitialPenetrationPower = self.MainBullet.PenetrationPower
	self.MainBullet.AmmoType = self:GetPrimaryAmmoType()
	self.MainBullet.Force = self:GetStatL("Primary.Force") * cv_forcemult:GetFloat() * self:GetAmmoForceMultiplier()
	self.MainBullet.Damage = damage
	self.MainBullet.InitialDamage = damage
	self.MainBullet.InitialForce = self.MainBullet.Force
	self.MainBullet.InitialPosition = Vector(self.MainBullet.Src)
	self.MainBullet.HasAppliedRange = false

	if self.CustomBulletCallback then
		self.MainBullet.Callback2 = self.CustomBulletCallback
	else
		self.MainBullet.Callback2 = nil
	end

	if num_bullets > 1 then
		local ang_ = self.MainBullet.Dir:Angle()
		local up, right = ang_:Up(), ang_:Right()

		-- single callback per multiple bullets fix
		for i = 1, num_bullets do
			local bullet = table.Copy(self.MainBullet)

			local ang = Angle(ang_)

			local dYaw, dPitch = self:ComputeBulletDeviation(i, num_bullets, aimcone)
			ang:RotateAroundAxis(up, dYaw)
			ang:RotateAroundAxis(right, dPitch)

			bullet.Dir = ang:Forward()

			function bullet.Callback(attacker, trace, dmginfo)
				if not IsValid(self) then return end

				dmginfo:SetInflictor(self)
				dmginfo:SetDamage(dmginfo:GetDamage() * bullet:CalculateFalloff(trace.HitPos))

				if bullet.Callback2 then
					bullet.Callback2(attacker, trace, dmginfo)
				end

				self:CallAttFunc("CustomBulletCallback", attacker, trace, dmginfo)

				bullet:Penetrate(attacker, trace, dmginfo, self, {})
				self:PCFTracer(bullet, trace.HitPos or vector_origin)
			end

			BallisticFirebullet(owner, bullet, nil, ang)
		end

		return
	end

	function self.MainBullet.Callback(attacker, trace, dmginfo)
		if not IsValid(self) then return end

		dmginfo:SetInflictor(self)
		dmginfo:SetDamage(dmginfo:GetDamage() * self.MainBullet:CalculateFalloff(trace.HitPos))

		if self.MainBullet.Callback2 then
			self.MainBullet.Callback2(attacker, trace, dmginfo)
		end

		self:CallAttFunc("CustomBulletCallback", attacker, trace, dmginfo)

		self.MainBullet:Penetrate(attacker, trace, dmginfo, self, {})
		self:PCFTracer(self.MainBullet, trace.HitPos or vector_origin)
	end

	BallisticFirebullet(owner, self.MainBullet, nil, self.MainBullet.Dir:Angle())
end

local sp = game.SinglePlayer()

function SWEP:TFAMove(ply, movedata)
	local velocity = self:GetQueuedRecoil()

	if velocity:Length() ~= 0 then
		movedata:SetVelocity(movedata:GetVelocity() + velocity)
		self:SetQueuedRecoil(vector_origin)
	end
end

hook.Add("Move", "TFAMove", function(self, movedata)
	local weapon = self:GetActiveWeapon()

	if IsValid(weapon) and weapon.IsTFAWeapon then
		weapon:TFAMove(self, movedata)
	end
end)

local sv_tfa_recoil_mul_p = GetConVar("sv_tfa_recoil_mul_p")
local sv_tfa_recoil_mul_p_npc = GetConVar("sv_tfa_recoil_mul_p_npc")
local sv_tfa_recoil_mul_y = GetConVar("sv_tfa_recoil_mul_y")
local sv_tfa_recoil_mul_y_npc = GetConVar("sv_tfa_recoil_mul_y_npc")

local sv_tfa_recoil_viewpunch_mul = GetConVar("sv_tfa_recoil_viewpunch_mul")
local sv_tfa_recoil_eyeangles_mul = GetConVar("sv_tfa_recoil_eyeangles_mul")

function SWEP:SetRecoilVector(vector)
	if self:GetOwner():IsPlayer() then
		self:SetQueuedRecoil(vector)
	else
		self:GetOwner():SetVelocity(vector)
	end
end

function SWEP:QueueRecoil(vector)
	if self:GetOwner():IsPlayer() then
		self:SetQueuedRecoil(vector + self:GetQueuedRecoil())
	else
		self:GetOwner():SetVelocity(vector)
	end
end

function SWEP:Recoil(recoil, ifp)
	if sp and type(recoil) == "string" then
		local _, CurrentRecoil = self:CalculateConeRecoil()
		self:Recoil(CurrentRecoil, true)

		return
	end

	local owner = self:GetOwner()
	local isplayer = owner:IsPlayer()

	self:SetSpreadRatio(l_mathClamp(self:GetSpreadRatio() + self:GetStatL("Primary.SpreadIncrement"), 1, self:GetStatL("Primary.SpreadMultiplierMax")))
	self:QueueRecoil(-owner:GetAimVector() * self:GetStatL("Primary.Knockback") * cv_knockbackmult:GetFloat() * recoil / 5)

	local seed = self:GetSeed() + 1

	local kickP = util.SharedRandom("TFA_KickDown", self:GetStatL("Primary.KickDown"), self:GetStatL("Primary.KickUp"), seed) * recoil * -1
	local kickY = util.SharedRandom("TFA_KickHorizontal", -self:GetStatL("Primary.KickHorizontal"), self:GetStatL("Primary.KickHorizontal"), seed) * recoil

	if isplayer then
		kickP, kickY = kickP * sv_tfa_recoil_mul_p:GetFloat(), kickY * sv_tfa_recoil_mul_y:GetFloat()
	else
		kickP, kickY = kickP * sv_tfa_recoil_mul_p_npc:GetFloat(), kickY * sv_tfa_recoil_mul_y_npc:GetFloat()
	end

	local factor = 1 - self:GetStatL("Primary.StaticRecoilFactor")

	if self:GetIronSights() then
		factor = factor * Lerp(self:GetIronSightsProgress(), 1, self:GetStatL("Primary.IronRecoilMultiplier", 0.5))
	end

	factor = factor * Lerp(self:GetCrouchingRatio(), 1, self:GetStatL("CrouchAccuracyMultiplier", 0.5))

	local punchY = kickY * factor
	local deltaP = 0
	local deltaY = 0

	if self:HasRecoilLUT() then
		local ang = self:GetRecoilLUTAngle()

		if self:GetPrevRecoilAngleTime() < CurTime() then
			self:SetPrevRecoilAngleTime(CurTime() + 0.1)
			self:SetPrevRecoilAngle(ang)
		end

		local prev_recoil_angle = self:GetPrevRecoilAngle()
		deltaP = ang.p - prev_recoil_angle.p
		deltaY = ang.y - prev_recoil_angle.y
		self:SetPrevRecoilAngle(ang)
	end

	if isplayer then
		local maxdist = math.min(math.max(0, 89 + owner:EyeAngles().p - math.abs(owner:GetViewPunchAngles().p * 2)), 88.5)
		local punchP = l_mathClamp((kickP + deltaP * self:GetStatL("Primary.RecoilLUT_ViewPunchMult")) * factor, -maxdist, maxdist)

		owner:ViewPunch(Angle(punchP * sv_tfa_recoil_viewpunch_mul:GetFloat(), (punchY + deltaY * self:GetStatL("Primary.RecoilLUT_ViewPunchMult")) * sv_tfa_recoil_viewpunch_mul:GetFloat()))
	end

	if (not isplayer or not sv_tfa_recoil_legacy:GetBool()) and not self:HasRecoilLUT() then
		local maxdist2 = l_mathClamp(30 - math.abs(self:GetViewPunchP()), 0, 30)
		local punchP2 = l_mathClamp(kickP, -maxdist2, maxdist2) * factor

		self:SetViewPunchP(self:GetViewPunchP() + punchP2 * 1.5)
		self:SetViewPunchY(self:GetViewPunchY() + punchY * 1.5)
		self:SetViewPunchBuild(math.min(3, self:GetViewPunchBuild() + math.sqrt(math.pow(punchP2, 2) + math.pow(punchY, 2)) / 3) + 0.2)
	end

	if isplayer and ((game.SinglePlayer() and SERVER) or (CLIENT and ifp)) then
		local neweyeang = owner:EyeAngles()

		local ap, ay = (kickP + deltaP * self:GetStatL("Primary.RecoilLUT_AnglePunchMult")) * self:GetStatL("Primary.StaticRecoilFactor") * sv_tfa_recoil_eyeangles_mul:GetFloat(),
						(kickY + deltaY * self:GetStatL("Primary.RecoilLUT_AnglePunchMult")) * self:GetStatL("Primary.StaticRecoilFactor") * sv_tfa_recoil_eyeangles_mul:GetFloat()

		neweyeang.p = neweyeang.p + ap
		neweyeang.y = neweyeang.y + ay
		--neweyeang.p = l_mathClamp(neweyeang.p, -90 + math.abs(owner:GetViewPunchAngles().p), 90 - math.abs(owner:GetViewPunchAngles().p))
		owner:SetEyeAngles(neweyeang)
	end
end

--[[
Function Name:  GetAmmoRicochetMultiplier
Syntax: self:GetAmmoRicochetMultiplier().
Returns:  The ricochet multiplier for our ammotype.  More is more chance to ricochet.
Notes:  Only compatible with default ammo types, unless you/I mod that.  BMG ammotype is detected based on name and category.
Purpose:  Utility
]]
--
function SWEP:GetAmmoRicochetMultiplier()
	local am = string.lower(self:GetStatL("Primary.Ammo"))

	if (am == "pistol") then
		return 1.25
	elseif (am == "357") then
		return 0.75
	elseif (am == "smg1") then
		return 1.1
	elseif (am == "ar2") then
		return 0.9
	elseif (am == "buckshot") then
		return 2
	elseif (am == "slam") then
		return 1.5
	elseif (am == "airboatgun") then
		return 0.8
	elseif (am == "sniperpenetratedround") then
		return 0.5
	else
		return 1
	end
end

--[[
Function Name:  GetMaterialConcise
Syntax: self:GetMaterialConcise().
Returns:  The string material name.
Notes:  Always lowercase.
Purpose:  Utility
]]
--
function SWEP:GetAmmoForceMultiplier()
	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
	--AR2=Rifle ~= Caliber>.308
	--SMG1=SMG ~= Small/Medium Calber ~= 5.56 or 9mm
	--357=Revolver ~= .357 through .50 magnum
	--Pistol = Small or Pistol Bullets ~= 9mm, sometimes .45ACP but rarely.  Generally light.
	--Buckshot = Buckshot = Light, barely-penetrating sniper bullets.
	--Slam = Medium Shotgun Round
	--AirboatGun = Heavy, Penetrating Shotgun Round
	--SniperPenetratedRound = Heavy Large Rifle Caliber ~= .50 Cal blow-yer-head-off
	local am = string.lower(self:GetStatL("Primary.Ammo"))

	if (am == "pistol") then
		return 0.4
	elseif (am == "357") then
		return 0.6
	elseif (am == "smg1") then
		return 0.475
	elseif (am == "ar2") then
		return 0.6
	elseif (am == "buckshot") then
		return 0.5
	elseif (am == "slam") then
		return 0.5
	elseif (am == "airboatgun") then
		return 0.7
	elseif (am == "sniperpenetratedround") then
		return 1
	else
		return 1
	end
end

--[[
Function Name:  GetPenetrationMultiplier
Syntax: self:GetPenetrationMultiplier( concise material name).
Returns:  The multilier for how much you can penetrate through a material.
Notes:  Should be used with GetMaterialConcise.
Purpose:  Utility
]]
--
SWEP.Primary.PenetrationMaterials = {
	[MAT_DEFAULT] = 1,
	[MAT_VENT] = 0.4, --Since most is aluminum and stuff
	[MAT_METAL] = 0.6, --Since most is aluminum and stuff
	[MAT_WOOD] = 0.2,
	[MAT_PLASTIC] = 0.23,
	[MAT_FLESH] = 0.48,
	[MAT_CONCRETE] = 0.87,
	[MAT_GLASS] = 0.16,
	[MAT_SAND] = 1,
	[MAT_SLOSH] = 1,
	[MAT_DIRT] = 0.95, --This is plaster, not dirt, in most cases.
	[MAT_FOLIAGE] = 0.9
}

local fac

function SWEP:GetPenetrationMultiplier(mat)
	fac = self.Primary.PenetrationMaterials[mat or MAT_DEFAULT] or self.Primary.PenetrationMaterials[MAT_DEFAULT]

	return fac * (self:GetStatL("Primary.PenetrationMultiplier") and self:GetStatL("Primary.PenetrationMultiplier") or 1)
end

local decalbul = {
	Num = 1,
	Spread = vector_origin,
	Tracer = 0,
	TracerName = "",
	Force = 0,
	Damage = 0,
	Distance = 40
}

local maxpen
local penetration_max_cvar = GetConVar("sv_tfa_penetration_hardlimit")
local penetration_cvar = GetConVar("sv_tfa_bullet_penetration")
local ricochet_cvar = GetConVar("sv_tfa_bullet_ricochet")
local cv_rangemod = GetConVar("sv_tfa_range_modifier")
local cv_decalbul = GetConVar("sv_tfa_fx_penetration_decal")
local atype
local develop = GetConVar("developer")
local sv_tfa_debug = GetConVar("sv_tfa_debug")

function SWEP:SetBulletTracerName(nm)
	self.BulletTracerName = nm or self.BulletTracerName or ""
end

local debugcolors = {
	Color(166, 91, 236),
	Color(91, 142, 236),
	Color(29, 197, 208),
	Color(61, 232, 109),
	Color(194, 232, 61),
	Color(232, 178, 61),
	Color(232, 61, 129),
	Color(128, 31, 109),
}

local nextdebugcol = -1
local debugsphere1 = Color(149, 189, 230)
local debugsphere2 = Color(34, 43, 53)
local debugsphere3 = Color(255, 255, 255)
local debugsphere4 = Color(0, 0, 255)
local debugsphere5 = Color(12, 255, 0)

local IsInWorld, IsInWorld2

do
	local tr = {collisiongroup = COLLISION_GROUP_WORLD}

	function IsInWorld2(pos)
		tr.start = pos
		tr.endpos = pos
		return not util.TraceLine(tr).AllSolid
	end
end

if CLIENT then
	IsInWorld = IsInWorld2
else
	IsInWorld = util.IsInWorld
end

local MAX_CORRECTION_ITERATIONS = 20

-- bullettable can be nil
function SWEP:CalculateFalloff(InitialPosition, HitPos, bullettable)
	local dist = InitialPosition:Distance(HitPos)

	if not self.Primary.RangeFalloffLUTBuilt then return 1 end

	local target = self.Primary.RangeFalloffLUTBuilt

	if dist <= target[1][1] then
		return target[1][2]
	end

	if dist >= target[#target][1] then
		return target[#target][2]
	end

	for i = 1, #target - 1 do
		local a, b = target[i], target[i + 1]

		if a[1] <= dist and b[1] >= dist then
			return Lerp((dist - a[1]) / (b[1] - a[1]), a[2], b[2])
		end
	end

	return target[#target][2] -- wtf?
end

function SWEP.MainBullet:CalculateFalloff(HitPos)
	return self.Wep:CalculateFalloff(self.InitialPosition, HitPos, self)
end

local function shouldDisplayDebug()
	return SERVER and sv_tfa_debug:GetBool() and develop:GetBool() and DLib
end

function SWEP.MainBullet:Penetrate(ply, traceres, dmginfo, weapon, penetrated, previousStartPos)
	if hook.Run("TFA_Bullet_Penetrate", weapon, ply, traceres, dmginfo, penetrated, previousStartPos) == false then return end

	--debugoverlay.Sphere( self.Src, 5, 5, color_white, true)

	DisableOwnerDamage(ply, traceres, dmginfo)

	if self.TracerName and self.TracerName ~= "" then
		weapon.BulletTracerName = self.TracerName

		if game.SinglePlayer() then
			weapon:CallOnClient("SetBulletTracerName", weapon.BulletTracerName)
		end
	end

	if not IsValid(weapon) then return end

	local hitent = traceres.Entity

	self:HandleDoor(ply, traceres, dmginfo, weapon)

	atype = weapon:GetStatL("Primary.DamageType")
	dmginfo:SetDamageType(atype)

	if SERVER and IsValid(ply) and ply:IsPlayer() and IsValid(hitent) and (hitent:IsPlayer() or hitent:IsNPC() or type(hitent) == "NextBot") then
		weapon:SendHitMarker(ply, traceres, dmginfo)
	end

	if IsValid(traceres.Entity) and traceres.Entity:GetClass() == "npc_sniper" then
		traceres.Entity.TFAHP = (traceres.Entity.TFAHP or 100) - dmginfo:GetDamage()

		if traceres.Entity.TFAHP <= 0 then
			traceres.Entity:Fire("SetHealth", "", -1)
		end
	end

	local cl = hitent:GetClass()

	if cl == "npc_helicopter" then
		dmginfo:SetDamageType(bit.bor(dmginfo:GetDamageType(), DMG_AIRBOAT))
	end

	-- custom damage checks
	if atype ~= DMG_BULLET then
		--[[if cl == "npc_strider" and (dmginfo:IsDamageType(DMG_SHOCK) or dmginfo:IsDamageType(DMG_BLAST)) and traceres.Hit and IsValid(hitent) and hitent.Fire then
			hitent:SetHealth(math.max(hitent:Health() - dmginfo:GetDamage(), 2))

			if hitent:Health() <= 3 then
				hitent:Extinguish()
				hitent:Fire("sethealth", "-1", 0.01)
				dmginfo:ScaleDamage(0)
			end
		end]]

		if dmginfo:IsDamageType(DMG_BURN) and weapon.Primary.DamageTypeHandled and traceres.Hit and IsValid(hitent) and not traceres.HitWorld and not traceres.HitSky and dmginfo:GetDamage() > 1 and hitent.Ignite then
			hitent:Ignite(dmginfo:GetDamage() / 2, 1)
		end

		if dmginfo:IsDamageType(DMG_BLAST) and weapon.Primary.DamageTypeHandled and traceres.Hit and not traceres.HitSky then
			local tmpdmg = dmginfo:GetDamage()
			dmginfo:SetDamageForce(dmginfo:GetDamageForce() / 2)
			util.BlastDamageInfo(dmginfo, traceres.HitPos, weapon:GetStatL("Primary.BlastRadius") or (tmpdmg / 2)  )
			--util.BlastDamage(weapon, weapon:GetOwner(), traceres.HitPos, tmpdmg / 2, tmpdmg)
			local fx = EffectData()
			fx:SetOrigin(traceres.HitPos)
			fx:SetNormal(traceres.HitNormal)

			if weapon:GetStatL("Primary.ImpactEffect") then
				TFA.Effects.Create(weapon:GetStatL("Primary.ImpactEffect"), fx)
			elseif tmpdmg > 90 then
				TFA.Effects.Create("HelicopterMegaBomb", fx)
				TFA.Effects.Create("Explosion", fx)
			elseif tmpdmg > 45 then
				TFA.Effects.Create("cball_explode", fx)
			else
				TFA.Effects.Create("MuzzleEffect", fx)
			end

			dmginfo:ScaleDamage(0.15)
		end
	end

	if self:Ricochet(ply, traceres, dmginfo, weapon) then
		if shouldDisplayDebug() then
			DLib.debugoverlay.Text(traceres.HitPos - Vector(0, 0, 12), 'ricochet', 10)
		end

		return
	end

	if penetration_cvar and not penetration_cvar:GetBool() then return end
	if self.PenetrationCount > math.min(penetration_max_cvar:GetInt(100), weapon:GetStatL("Primary.MaxSurfacePenetrationCount", math.huge)) then return end
	-- source engine quirk - if bullet is fired too close to brush surface
	-- it is assumed to be fired right in front of it, rather than exact
	-- position you specified.
	if previousStartPos and previousStartPos:Distance(traceres.HitPos) < 0.05 then return end
	local oldTraceResHitPos = Vector(traceres.HitPos)

	local mult = weapon:GetPenetrationMultiplier(traceres.MatType)
	local newdir = (traceres.HitPos - traceres.StartPos):GetNormalized()
	local desired_length = l_mathClamp(self.PenetrationPower / mult, 0, l_mathClamp(sv_tfa_bullet_penetration_power_mul:GetFloat() * 100, 1000, 8000))
	local penetrationoffset = newdir * desired_length

	local pentrace = {
		start = traceres.HitPos,
		endpos = traceres.HitPos + penetrationoffset,
		mask = MASK_SHOT,
		filter = penetrated
	}

	local isent = IsValid(traceres.Entity)
	local startpos, decalstartpos

	if isent then
		table.insert(penetrated, traceres.Entity)
	else
		pentrace.start:Add(traceres.Normal)
		pentrace.start:Add(traceres.Normal)
		pentrace.collisiongroup = COLLISION_GROUP_WORLD
		pentrace.filter = NULL
	end

	local pentraceres = util.TraceLine(pentrace)
	local pentraceres2, pentrace2
	local loss
	local realstartpos

	if not isent then
		local acc_length = pentraceres.HitPos:Distance(pentraceres.StartPos)

		local ostart = pentrace.start
		local FractionLeftSolid = pentraceres.FractionLeftSolid
		local iter = 0

		local cond = (pentraceres.AllSolid or not IsInWorld2(pentraceres.HitPos)) and acc_length < desired_length

		while (pentraceres.AllSolid or not IsInWorld2(pentraceres.HitPos)) and acc_length <= desired_length and iter < MAX_CORRECTION_ITERATIONS do
			iter = iter + 1

			pentrace.start = pentraceres.HitPos + newdir * 8

			if shouldDisplayDebug() then
				DLib.debugoverlay.Cross(pentrace.start, 8, 10, Color(iter / MAX_CORRECTION_ITERATIONS * 255, iter / MAX_CORRECTION_ITERATIONS * 255, iter / MAX_CORRECTION_ITERATIONS * 255), true)
			end

			pentraceres = util.TraceLine(pentrace)
			acc_length = acc_length + pentraceres.HitPos:Distance(pentraceres.StartPos) + 8
		end

		if cond and not (pentraceres.AllSolid or not IsInWorld2(pentraceres.HitPos)) then
			pentraceres.FractionLeftSolid = ostart:Distance(pentrace.start) / ostart:Distance(pentrace.endpos) + pentraceres.FractionLeftSolid + 0.02
			pentrace.start = ostart
			pentraceres.StartPos = ostart
		else
			pentraceres.FractionLeftSolid = FractionLeftSolid
			pentrace.start = ostart
			pentraceres.StartPos = ostart
		end
	end

	if isent then
		startpos = pentraceres.HitPos - newdir
		local ent = traceres.Entity

		pentrace2 = {
			start = startpos,
			endpos = pentrace.start,
			mask = MASK_SHOT,
			ignoreworld = true,
			filter = function(ent2)
				return ent2 == ent
			end
		}

		pentraceres2 = util.TraceLine(pentrace2)
		loss = pentraceres2.HitPos:Distance(pentrace.start) * mult

		if pentraceres2.HitPos:Distance(pentrace.start) < 0.01 then
			-- bullet stuck in
			loss = self.PenetrationPower
		end

		decalstartpos = pentraceres2.HitPos + newdir * 3

		if shouldDisplayDebug() then
			nextdebugcol = (nextdebugcol + 1) % #debugcolors
			DLib.debugoverlay.Line(pentrace.start, pentrace.endpos, 10, debugcolors[nextdebugcol + 1], true)
			DLib.debugoverlay.Cross(pentrace.start, 8, 10, debugsphere1, true)
			DLib.debugoverlay.Cross(pentraceres2.HitPos, 8, 10, debugsphere2, true)
		end

		if self.IsBallistics then
			startpos = decalstartpos
		end

		realstartpos = decalstartpos
	else
		startpos = LerpVector(pentraceres.FractionLeftSolid, pentrace.start, pentrace.endpos) + newdir * 4
		realstartpos = startpos
		decalstartpos = startpos + newdir * 2
		loss = startpos:Distance(pentrace.start) * mult

		if shouldDisplayDebug() then
			nextdebugcol = (nextdebugcol + 1) % #debugcolors
			DLib.debugoverlay.Line(pentrace.start, pentrace.endpos, 10, debugcolors[nextdebugcol + 1], true)
			DLib.debugoverlay.Cross(pentrace.start, 8, 10, debugsphere1, true)
			DLib.debugoverlay.Cross(startpos, 8, 10, debugsphere2, true)
		end

		if pentraceres.AllSolid then
			return
		elseif not IsInWorld(pentraceres.HitPos) then
			return
		end

		if not IsInWorld2(startpos) then
			for i = 1, 10 do
				startpos = LerpVector(pentraceres.FractionLeftSolid, pentrace.start, pentrace.endpos) + newdir * ((4 - i) * 3)

				if IsInWorld2(startpos) then break end

				startpos = LerpVector(pentraceres.FractionLeftSolid, pentrace.start, pentrace.endpos) + newdir * ((4 + i) * 3)

				if IsInWorld2(startpos) then break end
			end

			if not IsInWorld2(startpos) then
				return
			end
		end
	end

	if self.PenetrationPower - loss <= 0 then
		if shouldDisplayDebug() then
			DLib.debugoverlay.Text(startpos, string.format('Lost penetration power %.3f %.3f', self.PenetrationPower, loss), 10)
		end

		return
	end

	self.PenetrationCount = self.PenetrationCount + 1
	local prev = self.PenetrationPower
	self.PenetrationPower = self.PenetrationPower - loss

	local mfac = self.PenetrationPower / self.InitialPenetrationPower

	if shouldDisplayDebug() and weapon.Primary.RangeFalloffLUTBuilt then
		DLib.debugoverlay.Text(traceres.HitPos + Vector(0, 0, 12), string.format('NEW Damage falloff final %.3f %.3f %.3f %.3f', self.InitialPosition:Distance(traceres.HitPos), self:CalculateFalloff(traceres.HitPos), mfac * self.InitialDamage * self:CalculateFalloff(traceres.HitPos), mfac), 12)
	end

	local Damage = self.InitialDamage * self:CalculateFalloff(realstartpos) * mfac

	local bul = {
		PenetrationPower = self.PenetrationPower,
		PenetrationCount = self.PenetrationCount,
		InitialPenetrationPower = self.InitialPenetrationPower,
		InitialDamage = self.InitialDamage,
		InitialForce = self.InitialForce,
		CalculateFalloff = self.CalculateFalloff,
		InitialPosition = self.InitialPosition,
		Src = startpos,
		Dir = newdir,
		Tracer = 1,
		TracerName = self.TracerName,
		IgnoreEntity = traceres.Entity,

		Num = 1,
		Force = self.InitialForce * mfac,
		Damage = Damage,
		Penetrate = self.Penetrate,
		MakeDoor = self.MakeDoor,
		HandleDoor = self.HandleDoor,
		Ricochet = self.Ricochet,
		Spread = vector_origin,
		Wep = weapon,
	}

	if shouldDisplayDebug()  then
		DLib.debugoverlay.Text(startpos, string.format('penetrate %.3f->%.3f %d %.3f', prev, self.PenetrationPower, self.PenetrationCount, mfac), 10)
	end

	function bul.Callback(attacker, trace, dmginfo2)
		if shouldDisplayDebug()  then
			DLib.debugoverlay.Cross(trace.HitPos, 8, 10, debugsphere3, true)
			DLib.debugoverlay.Text(trace.HitPos - Vector(0, 0, 7), string.format('hit %.3f %d', mfac, bul.PenetrationCount, bul.PenetrationPower), 10)
		end

		dmginfo2:SetInflictor(IsValid(bul.Wep) and bul.Wep or IsValid(ply) and ply or Entity(0))

		bul.Damage = self.InitialDamage * self:CalculateFalloff(trace.HitPos) * mfac
		dmginfo2:SetDamage(bul.Damage)

		hook.Run("TFA_BulletPenetration", bul, attacker, trace, dmginfo2)

		-- TODO: User died while bullet make penetration
		-- handle further penetrations even when user is dead
		if IsValid(bul.Wep) then
			bul:Penetrate(attacker, trace, dmginfo2, bul.Wep, penetrated, oldTraceResHitPos)
		end
	end

	decalbul.Dir = -newdir
	decalbul.Src = decalstartpos
	decalbul.Callback = DisableOwnerDamage
	decalbul.IgnoreEntity = bul.IgnoreEntity

	if shouldDisplayDebug()  then
		DLib.debugoverlay.Cross(decalbul.Src, 8, 10, debugsphere4, true)
		DLib.debugoverlay.Cross(decalbul.Src + decalbul.Dir * decalbul.Distance, 8, 10, debugsphere5, true)
	end

	if self.PenetrationCount <= 1 and IsValid(weapon) then
		weapon:PCFTracer(self, pentraceres.HitPos or traceres.HitPos, true)
	end

	local fx = EffectData()
	fx:SetOrigin(bul.Src)
	fx:SetNormal(bul.Dir)

	fx:SetMagnitude((bul.PenetrationCount + 1) * 1000)
	fx:SetEntity(weapon)

	if IsValid(pentraceres.Entity) and pentraceres.Entity.EntIndex then
		fx:SetScale(pentraceres.Entity:EntIndex())
	end

	fx:SetRadius(bul.Damage / 32)
	TFA.Effects.Create("tfa_penetrate", fx)

	if cv_decalbul:GetBool() then
		ply:FireBullets(decalbul)
	end

	BallisticFirebullet(ply, bul, true)
end

local RicochetChanceEnum = {
	[MAT_GLASS] = 0,
	[MAT_PLASTIC] = 0.01,
	[MAT_DIRT] = 0.01,
	[MAT_GRASS] = 0.01,
	[MAT_SAND] = 0.01,
	[MAT_CONCRETE] = 0.15,
	[MAT_METAL] = 0.7,
	[MAT_DEFAULT] = 0.5,
	[MAT_FLESH] = 0.0
}

function SWEP.MainBullet:Ricochet(ply, traceres, dmginfo, weapon)
	if ricochet_cvar and not ricochet_cvar:GetBool() then return end
	maxpen = math.min(penetration_max_cvar and penetration_max_cvar:GetInt() - 1 or 1, weapon:GetStatL("Primary.MaxSurfacePenetrationCount", math.huge))
	if self.PenetrationCount > maxpen then return end
	local ricochetchance = RicochetChanceEnum[traceres.MatType] or RicochetChanceEnum[MAT_DEFAULT]
	local dir = traceres.HitPos - traceres.StartPos
	dir:Normalize()
	local dp = dir:Dot(traceres.HitNormal * -1)
	ricochetchance = ricochetchance * weapon:GetAmmoRicochetMultiplier()
	local riccbak = ricochetchance / 0.7
	local ricothreshold = 0.6
	ricochetchance = l_mathClamp(ricochetchance * ( 1 + l_mathClamp(1 - (dp + ricothreshold), 0, 1) ), 0, 1)
	if dp <= ricochetchance and math.Rand(0, 1) < ricochetchance then
		local ric = {}
		ric.Ricochet = self.Ricochet
		ric.Penetrate = self.Penetrate
		ric.MakeDoor = self.MakeDoor
		ric.HandleDoor = self.HandleDoor
		ric.Damage = self.Damage * 0.5
		ric.Force = self.Force * 0.5
		ric.Num = 1
		ric.Spread = vector_origin
		ric.Tracer = 0
		ric.Src = traceres.HitPos
		ric.Dir = ((2 * traceres.HitNormal * dp) + traceres.Normal) + (VectorRand() * 0.02)
		ric.PenetrationCount = self.PenetrationCount + 1
		self.PenetrationCount = self.PenetrationCount + 1

		if TFA.GetRicochetEnabled() then
			local fx = EffectData()
			fx:SetOrigin(ric.Src)
			fx:SetNormal(ric.Dir)
			fx:SetMagnitude(riccbak)
			TFA.Effects.Create("tfa_ricochet", fx)
		end

		BallisticFirebullet(ply, ric, true)

		return true
	end
end

local defaultdoorhealth = 250
local cv_doorres = GetConVar("sv_tfa_door_respawn")

function SWEP.MainBullet:MakeDoor(ent, dmginfo)
	local dir = dmginfo:GetDamageForce():GetNormalized()
	local force = dir * math.max(math.sqrt(dmginfo:GetDamageForce():Length() / 1000), 1) * 1000
	local pos = ent:GetPos()
	local ang = ent:GetAngles()
	local mdl = ent:GetModel()
	local ski = ent:GetSkin()
	ent:SetNotSolid(true)
	ent:SetNoDraw(true)
	local prop = ents.Create("prop_physics")
	prop:SetPos(pos + dir * 16)
	prop:SetAngles(ang)
	prop:SetModel(mdl)
	prop:SetSkin(ski or 0)
	prop:Spawn()
	prop:SetVelocity(force)
	prop:GetPhysicsObject():ApplyForceOffset(force, dmginfo:GetDamagePosition())
	prop:SetPhysicsAttacker(dmginfo:GetAttacker())
	prop:EmitSound("physics/wood/wood_furniture_break" .. tostring(math.random(1, 2)) .. ".wav", 110, math.random(90, 110))

	if cv_doorres and cv_doorres:GetInt() ~= -1 then
		timer.Create("TFA_DoorRespawner_" .. ent:EntIndex(), cv_doorres:GetFloat(), 1, function()
			if IsValid(prop) then
				prop:Remove()
			end

			if IsValid(ent) then
				ent.TFADoorHealth = defaultdoorhealth
				ent:SetNotSolid(false)
				ent:SetNoDraw(false)
			end
		end)
	end
end

local cv_doordestruction = GetConVar("sv_tfa_bullet_doordestruction")
local sv_tfa_bullet_doordestruction_keep = GetConVar("sv_tfa_bullet_doordestruction_keep")

function SWEP.MainBullet:HandleDoor(ply, traceres, dmginfo, wep)
	-- Don't do anything if door desstruction isn't enabled
	if not cv_doordestruction:GetBool() then return end
	local ent = traceres.Entity
	if not IsValid(ent) then return end
	if not IsValid(ply) then return end
	if not ents.Create then return end
	if not ply.SetName then return end
	if ent.TFADoorUntouchable and ent.TFADoorUntouchable > CurTime() then return end
	ent.TFADoorHealth = ent.TFADoorHealth or defaultdoorhealth
	if ent:GetClass() ~= "func_door_rotating" and ent:GetClass() ~= "prop_door_rotating" then return end
	local realDamage = dmginfo:GetDamage() * self.Num
	ent.TFADoorHealth = l_mathClamp(ent.TFADoorHealth - realDamage, 0, defaultdoorhealth)
	if ent.TFADoorHealth > 0 then return end
	ply:EmitSound("ambient/materials/door_hit1.wav", 100, math.random(90, 110))

	if not sv_tfa_bullet_doordestruction_keep:GetBool() and self.Damage * self.Num > 100 then
		self:MakeDoor(ent, dmginfo)
		ent.TFADoorUntouchable = CurTime() + 0.5

		return
	end

	ply.oldname = ply:GetName()
	ply:SetName("bashingpl" .. ply:EntIndex())
	ent:Fire("unlock", "", .01)
	ent:SetKeyValue("Speed", "500")
	ent:SetKeyValue("Open Direction", "Both directions")
	ent:SetKeyValue("opendir", "0")
	ent:Fire("openawayfrom", "bashingpl" .. ply:EntIndex(), .01)

	timer.Simple(0.02, function()
		if IsValid(ply) then
			ply:SetName(ply.oldname)
		end
	end)

	timer.Simple(0.3, function()
		if IsValid(ent) then
			ent:SetKeyValue("Speed", "100")
		end
	end)

	timer.Simple(5, function()
		if IsValid(ent) then
			ent.TFADoorHealth = defaultdoorhealth
		end
	end)

	ent.TFADoorUntouchable = CurTime() + 5
end
--PATH lua/weapons/tfa_gun_base/common/nzombies.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/common/viewmodel.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/common/viewmodel.lua:
local vector_origin = Vector()
local angle_zero = Angle()

SWEP.WeaponLength = 0

SWEP.NearWallVector = Vector(0.091287083923817, -0.4564354121685, -0.18257416784763)
SWEP.NearWallVectorADS = Vector(0, 0, 0)

SWEP.ViewModelPunchPitchMultiplier = 0.5
SWEP.ViewModelPunchPitchMultiplier_IronSights = 0.09

SWEP.ViewModelPunch_MaxVertialOffset = 3
SWEP.ViewModelPunch_MaxVertialOffset_IronSights = 1.95
SWEP.ViewModelPunch_VertialMultiplier = 1
SWEP.ViewModelPunch_VertialMultiplier_IronSights = 0.25

SWEP.ViewModelPunchYawMultiplier = 0.6
SWEP.ViewModelPunchYawMultiplier_IronSights = 0.25

local onevec = Vector(1, 1, 1)

local function RBP(vm)
	local bc = vm:GetBoneCount()
	if not bc or bc <= 0 then return end

	for i = 0, bc do
		vm:ManipulateBoneScale(i, onevec)
		vm:ManipulateBoneAngles(i, angle_zero)
		vm:ManipulateBonePosition(i, vector_origin)
	end
end

function SWEP:ApplyViewModelModifications()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return end

	local vm = self2.OwnerViewModel

	local bgcount = #(vm:GetBodyGroups() or {})
	local ViewModelBodygroups = self2.GetStatRawL(self, "ViewModelBodygroups")
	local bgt = ViewModelBodygroups or self2.Bodygroups or {}

	for i = 0, bgcount - 1 do
		vm:SetBodygroup(i, bgt[i] or 0)
	end

	local skinind = self2.GetStatL(self, "Skin")

	if skinind and isnumber(skinind) then
		vm:SetSkin(skinind)
		self:SetSkin(skinind)
	end

	self2.ClearMaterialCache(self)
end

function SWEP:ResetViewModelModifications()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return end

	local vm = self2.OwnerViewModel

	RBP(vm)

	vm:SetSkin(0)

	local matcount = #(vm:GetMaterials() or {})

	for i = 0, matcount do
		vm:SetSubMaterial(i, "")
	end

	for i = 0, #(vm:GetBodyGroups() or {}) - 1 do
		vm:SetBodygroup(i, 0)
	end
end

--PATH lua/weapons/tfa_gun_base/client/hud.lua:
if IsValid(TFA.INSPECTIONPANEL) then TFA.INSPECTIONPANEL:Remove() end

local l_CT = CurTime

local CMIX_MULT = 1
local c1t = {}
local c2t = {}

local function ColorMix(c1, c2, fac, t)
	c1 = c1 or color_white
	c2 = c2 or color_white
	c1t.r = c1.r
	c1t.g = c1.g
	c1t.b = c1.b
	c1t.a = c1.a
	c2t.r = c2.r
	c2t.g = c2.g
	c2t.b = c2.b
	c2t.a = c2.a

	for k, v in pairs(c1t) do
		if t == CMIX_MULT then
			c1t[k] = Lerp(fac, v, (c1t[k] / 255 * c2t[k] / 255) * 255)
		else
			c1t[k] = Lerp(fac, v, c2t[k])
		end
	end

	return Color(c1t.r, c1t.g, c1t.b, c1t.a)
end



local cv_red_r, cv_red_g, cv_red_b = GetConVar("cl_tfa_hud_crosshair_color_enemy_r"), GetConVar("cl_tfa_hud_crosshair_color_enemy_g"), GetConVar("cl_tfa_hud_crosshair_color_enemy_b")
local c_red = Color(cv_red_r:GetInt(), cv_red_g:GetInt(), cv_red_b:GetInt(), 255)

local function UpdateEnemyTeamColor()
	c_red.r = cv_red_r:GetInt()
	c_red.g = cv_red_g:GetInt()
	c_red.b = cv_red_b:GetInt()
end
cvars.AddChangeCallback(cv_red_r:GetName(), UpdateEnemyTeamColor, "c_red")
cvars.AddChangeCallback(cv_red_g:GetName(), UpdateEnemyTeamColor, "c_red")
cvars.AddChangeCallback(cv_red_b:GetName(), UpdateEnemyTeamColor, "c_red")



local cv_grn_r, cv_grn_g, cv_grn_b = GetConVar("cl_tfa_hud_crosshair_color_friendly_r"), GetConVar("cl_tfa_hud_crosshair_color_friendly_g"), GetConVar("cl_tfa_hud_crosshair_color_friendly_b")
local c_grn = Color(cv_grn_r:GetInt(), cv_grn_g:GetInt(), cv_grn_b:GetInt(), 255)

local function UpdateFriendlyTeamColor()
	c_grn.r = cv_grn_r:GetInt()
	c_grn.g = cv_grn_g:GetInt()
	c_grn.b = cv_grn_b:GetInt()
end
cvars.AddChangeCallback(cv_grn_r:GetName(), UpdateFriendlyTeamColor, "c_grn")
cvars.AddChangeCallback(cv_grn_g:GetName(), UpdateFriendlyTeamColor, "c_grn")
cvars.AddChangeCallback(cv_grn_b:GetName(), UpdateFriendlyTeamColor, "c_grn")



local cl_xhair_teamcolorcvar, sv_xhair_showplayercvar, sv_xhair_showplayerteamcvar

local GetNPCDisposition = TFA.GetNPCDisposition
local GameModeTeamBased = GAMEMODE.TeamBased

function SWEP:GetTeamColor(ent)
	if not cl_xhair_teamcolorcvar then
		cl_xhair_teamcolorcvar = GetConVar("cl_tfa_hud_crosshair_color_team")
	end

	if not sv_xhair_showplayercvar then
		sv_xhair_showplayercvar = GetConVar("sv_tfa_crosshair_showplayer")
	end

	if not sv_xhair_showplayerteamcvar then
		sv_xhair_showplayerteamcvar = GetConVar("sv_tfa_crosshair_showplayerteam")
	end

	if not cl_xhair_teamcolorcvar:GetBool() then return color_white end

	local ply = LocalPlayer()
	if not IsValid(ply) then return color_white end

	if ent:IsPlayer() then
		if not sv_xhair_showplayercvar:GetBool() then return color_white end

		if GameModeTeamBased and sv_xhair_showplayerteamcvar:GetBool() then
			if ent:Team() == ply:Team() then
				return c_grn
			else
				return c_red
			end
		end

		return c_red
	end

	if ent:IsNPC() then
		local disp = GetNPCDisposition(ent) or ent:GetNW2Int("tfa_disposition", -1)

		if disp > 0 then
			if disp == (D_FR or 2) or disp == (D_HT or 1) then
				return c_red
			else
				return c_grn
			end
		end

		if IsFriendEntityName(ent:GetClass()) then
			return c_grn
		else
			return c_red
		end
	end

	return color_white
end

--[[
local function RoundDecimals(number, decimals)
	local decfactor = math.pow(10, decimals)

	return math.Round(tonumber(number) * decfactor) / decfactor
end
]]
--
--[[
Function Name:  DoInspectionDerma
Syntax: self:DoInspectionDerma().
Returns:  Nothing.
Notes:  Used to manage our Derma.
Purpose:  Used to manage our Derma.
]]
--
local TFA_INSPECTIONPANEL
local spacing = 64

local ScaleH = TFA.ScaleH

local DrawTextShadowed = TFA.DrawTextShadowed
local function TextShadowPaint(myself, w, h)
	if not myself.TextColor then
		myself.TextColor = ColorAlpha(color_white, 0)
	end

	DrawTextShadowed(myself.Text, myself.Font, myself.TextPosX or 0, myself.TextPosY or 0, myself.TextColor, ScaleH(2))
end
SWEP.TextShadowPaintFunc = TextShadowPaint

local cv_bars_exp = GetConVar("cl_tfa_inspect_newbars")
function SWEP:PaintStatPanel(w, h)
	if not IsValid(self) then return end
	if not IsValid(TFA_INSPECTIONPANEL) then return end
	if not IsValid(self.Weapon) then return end
	if not self.StatTable then return end

	if self.StatTable.bar then
		local bar = math.Clamp(self.StatTable.bar(self.Weapon), 0, 1)

		local xx, ww, blockw, padw
		xx = w - ScaleH(120)
		ww = w - xx

		local bgcol = ColorAlpha(TFA_INSPECTIONPANEL.BackgroundColor or color_white, (TFA_INSPECTIONPANEL.Alpha or 0) / 2)

		if cv_bars_exp and cv_bars_exp:GetBool() then
			draw.RoundedBox(4, xx + 1, 1, ww - 2, h - 2, bgcol)

			local w1, h1 = self:LocalToScreen(xx + 2, 2)
			local w2, h2 = self:LocalToScreen(xx - 2 + ww * bar, h - 2)

			render.SetScissorRect(w1, h1, w2, h2, true)
			draw.RoundedBox(4, xx + 2, 2, ww - 4, h - 4, TFA_INSPECTIONPANEL.SecondaryColor or color_white)
			render.SetScissorRect(0, 0, 0, 0, false)

			if self.StatTable.text then
				DrawTextShadowed(self.StatTable.text(self.Weapon), self.Font, 0, 0, TFA_INSPECTIONPANEL.SecondaryColor, ScaleH(2))
			end

			return
		end

		blockw = math.floor(ww / 15)
		padw = math.floor(ww / 10)

		self.Bars = math.Clamp(math.Round(bar * 10), 0, 10)

		surface.SetDrawColor(bgcol)
		for _ = 0, 9 do
			surface.DrawRect(xx, 2, blockw, h - 5)
			xx = math.floor(xx + padw)
		end

		xx = w - ScaleH(120)
		surface.SetDrawColor(TFA_INSPECTIONPANEL.BackgroundColor or color_white)

		for _ = 0, self.Bars - 1 do
			surface.DrawRect(xx + 1, 3, blockw, h - 5)
			xx = math.floor(xx + padw)
		end

		xx = w - ScaleH(120)
		surface.SetDrawColor(TFA_INSPECTIONPANEL.SecondaryColor or color_white)

		for _ = 0, self.Bars - 1 do
			surface.DrawRect(xx, 2, blockw, h - 5)
			xx = math.floor(xx + padw)
		end
	end

	if self.StatTable.text then
		DrawTextShadowed(self.StatTable.text(self.Weapon), self.Font, 0, 0, TFA_INSPECTIONPANEL.SecondaryColor, ScaleH(2))
	end
end

local function WrapTextLines(textlines, maxwidth, font)
	if type(textlines) == "string" then
		textlines = string.Split(textlines, "\n")
	end

	local lines = {}

	surface.SetFont(font)

	for _, text in ipairs(textlines) do
		local w, _ = surface.GetTextSize(text)

		if w > maxwidth then
			local line = ""

			for _, word in ipairs(string.Explode(" ", text)) do
				local added = line == "" and word or line .. " " .. word
				w, _ = surface.GetTextSize(added)

				if w > maxwidth then
					table.insert(lines, line)
					line = word
				else
					line = added
				end
			end

			if line ~= "" then
				table.insert(lines, line)
			end
		else
			table.insert(lines, text)
		end
	end

	return lines
end

local pad = 4
local infotextpad = "\t"
local INSPECTION_BACKGROUND = TFA.Attachments.Colors["background"]
local INSPECTION_ACTIVECOLOR = TFA.Attachments.Colors["active"]
local INSPECTION_PRIMARYCOLOR = TFA.Attachments.Colors["primary"]
local INSPECTION_SECONDARYCOLOR = TFA.Attachments.Colors["secondary"]


SWEP.AmmoTypeStrings = {
	["pistol"] = "tfa.ammo.pistol",
	["smg1"] = "tfa.ammo.smg1",
	["ar2"] = "tfa.ammo.ar2",
	["buckshot"] = "tfa.ammo.buckshot",
	["357"] = "tfa.ammo.357",
	["SniperPenetratedRound"] = "tfa.ammo.sniperpenetratedround"
}

SWEP.WeaponTypeStrings = {
	["weapon"] = "tfa.weptype.generic",
	["pistol"] = "tfa.weptype.pistol",
	["machine pistol"] = "tfa.weptype.machpistol",
	["revolver"] = "tfa.weptype.revolver",
	["sub-machine gun"] = "tfa.weptype.smg",
	["rifle"] = "tfa.weptype.rifle",
	["carbine"] = "tfa.weptype.carbine",
	["light machine gun"] = "tfa.weptype.lmg",
	["shotgun"] = "tfa.weptype.shotgun",
	["designated marksman rifle"] = "tfa.weptype.dmr",
	["sniper rifle"] = "tfa.weptype.sniper",
	["grenade"] = "tfa.weptype.grenade",
	["launcher"] = "tfa.weptype.launcher",
	["dual pistols"] = "tfa.weptype.pistol.dual",
	["dual revolvers"] = "tfa.weptype.revolver.dual",
	["dual sub-machine guns"] = "tfa.weptype.smg.dual",
	["dual guns"] = "tfa.weptype.generic.dual",
} -- if you have more generalized (and widely used) types that could be localized please let us know so that we can add them here!

local att_enabled_cv = GetConVar("sv_tfa_attachments_enabled")

SWEP.VGUIPaddingW = 32
SWEP.VGUIPaddingH = 80

function SWEP:InspectionVGUISideBars(mainpanel)
	local barleft = vgui.Create("DPanel", mainpanel)
	barleft:SetWidth(ScaleH(self.VGUIPaddingW))
	barleft:Dock(LEFT)

	barleft.Paint = function(myself, w, h)
		local mycol = mainpanel.SecondaryColor

		if not mycol then return end

		surface.SetDrawColor(mycol)
		surface.SetTexture(mainpanel.SideBar or 1)
		surface.DrawTexturedRect(0, 0, w, h)
	end

	local barright = vgui.Create("DPanel", mainpanel)
	barright:SetWidth(ScaleH(self.VGUIPaddingW))
	barright:Dock(RIGHT)

	barright.Paint = function(myself, w, h)
		local mycol = mainpanel.SecondaryColor

		if not mycol then return end

		surface.SetDrawColor(mycol)
		surface.SetTexture(mainpanel.SideBar or 1)
		surface.DrawTexturedRectUV(0, 0, w, h, 1, 0, 0, 1)
	end
end

function SWEP:InspectionVGUIMainInfo(contentpanel)
	if hook.Run("TFA_InspectVGUI_InfoStart", self, contentpanel) ~= false then
		local mainpanel = contentpanel:GetParent()

		local infopanel = contentpanel:Add("DSizeToContents")
		infopanel:SetName("Main Weapon Info")

		infopanel:SetSize(0, 0)
		infopanel:Dock(TOP)
		infopanel.Paint = function() end

		local titletext = infopanel:Add("DPanel")
		titletext:SetName("Name")
		titletext.Text = self.PrintName or "TFA Weapon"

		titletext.Think = function(myself)
			myself.TextColor = mainpanel.PrimaryColor
		end

		titletext.Font = "TFA_INSPECTION_TITLE"
		titletext:Dock(TOP)
		titletext:SetSize(ScrW() * .5, TFA.Fonts.InspectionHeightTitle)
		titletext.Paint = TextShadowPaint

		local typetext = infopanel:Add("DPanel")
		typetext:SetName("Type")

		local weptype = self:GetStatL("Type_Displayed") or self:GetType()
		typetext.Text = language.GetPhrase(self.WeaponTypeStrings[weptype:lower()] or weptype)

		typetext.Think = function(myself)
			myself.TextColor = mainpanel.PrimaryColor
		end

		typetext.Font = "TFA_INSPECTION_DESCR"
		typetext:Dock(TOP)
		typetext:SetSize(ScrW() * .5, TFA.Fonts.InspectionHeightDescription)
		typetext.Paint = TextShadowPaint

		--Space things out for block1
		local spacer = infopanel:Add("DPanel")
		spacer:SetName("Spacer")
		spacer:Dock(TOP)
		spacer:SetSize(ScrW() * .5, TFA.Fonts.InspectionHeightDescription)
		spacer.Paint = function() end

		--First stat block
		local categorytext = infopanel:Add("DPanel")
		categorytext:SetName("Category")
		categorytext.Text = self.Category or self.Base

		categorytext.Think = function(myself)
			myself.TextColor = mainpanel.SecondaryColor
		end

		categorytext.Font = "TFA_INSPECTION_SMALL"
		categorytext:Dock(TOP)
		categorytext:SetSize(ScrW() * .5, TFA.Fonts.InspectionHeightSmall)
		categorytext.Paint = TextShadowPaint

		if self.Author and string.Trim(self.Author) ~= "" then
			local authortext = infopanel:Add("DPanel")
			authortext:SetName("Author")
			authortext.Text = infotextpad .. language.GetPhrase("tfa.inspect.creator"):format(self.Author)

			authortext.Think = function(myself)
				myself.TextColor = mainpanel.SecondaryColor
			end

			authortext.Font = "TFA_INSPECTION_SMALL"
			authortext:Dock(TOP)
			authortext:SetSize(ScrW() * .5, TFA.Fonts.InspectionHeightSmall)
			authortext.Paint = TextShadowPaint
		end

		if self.Manufacturer and string.Trim(self.Manufacturer) ~= "" then
			local makertext = infopanel:Add("DPanel")
			makertext:SetName("Manufacturer")
			makertext.Text = infotextpad .. language.GetPhrase("tfa.inspect.manufacturer"):format(self.Manufacturer)

			makertext.Think = function(myself)
				myself.TextColor = mainpanel.SecondaryColor
			end

			makertext.Font = "TFA_INSPECTION_SMALL"
			makertext:Dock(TOP)
			makertext:SetSize(ScrW() * .5, TFA.Fonts.InspectionHeightSmall)
			makertext.Paint = TextShadowPaint
		end

		local clip = self:GetStatL("Primary.ClipSize")

		if clip > 0 then
			local capacitytext = infopanel:Add("DPanel")
			capacitytext:SetName("Capacity")
			capacitytext.Text = infotextpad .. language.GetPhrase("tfa.inspect.capacity"):format(clip .. (self:CanChamber() and (self:GetStatL("IsAkimbo") and " + 2" or " + 1") or ""))

			capacitytext.Think = function(myself)
				myself.TextColor = mainpanel.SecondaryColor
			end

			capacitytext.Font = "TFA_INSPECTION_SMALL"
			capacitytext:Dock(TOP)
			capacitytext:SetSize(ScrW() * .5, TFA.Fonts.InspectionHeightSmall)
			capacitytext.Paint = TextShadowPaint
		end

		local an = game.GetAmmoName(self:GetPrimaryAmmoType())

		if an and an ~= "" and string.len(an) > 1 then
			local ammotypetext = infopanel:Add("DPanel")
			ammotypetext:SetName("Ammo Type")
			ammotypetext.Text = infotextpad .. language.GetPhrase("tfa.inspect.ammotype"):format(language.GetPhrase(self.AmmoTypeStrings[an:lower()] or (an .. "_ammo")))

			ammotypetext.Think = function(myself)
				myself.TextColor = mainpanel.SecondaryColor
			end

			ammotypetext.Font = "TFA_INSPECTION_SMALL"
			ammotypetext:Dock(TOP)
			ammotypetext:SetSize(ScrW() * .5, TFA.Fonts.InspectionHeightSmall)
			ammotypetext.Paint = TextShadowPaint
		end

		local maxlinewidth = ScrW() * .5 - ScaleH(self.VGUIPaddingW) * 4

		if self.Purpose and string.Trim(self.Purpose) ~= "" then
			local lines = WrapTextLines(language.GetPhrase("tfa.inspect.purpose"):format(language.GetPhrase(self.Purpose)), maxlinewidth, "TFA_INSPECTION_SMALL")

			for _, line in pairs(lines) do
				local purposeline = infopanel:Add("DPanel")
				purposeline:SetName("Purpose")
				purposeline.Text = infotextpad .. line

				purposeline.Think = function(myself)
					myself.TextColor = mainpanel.SecondaryColor
				end

				purposeline.Font = "TFA_INSPECTION_SMALL"
				purposeline:Dock(TOP)
				purposeline:SetSize(ScrW() * .5, TFA.Fonts.InspectionHeightSmall)
				purposeline.Paint = TextShadowPaint
			end
		end

		if self.Description and string.Trim(self.Description) ~= "" then
			local lines = WrapTextLines(language.GetPhrase(self.Description), maxlinewidth, "TFA_INSPECTION_SMALL")

			for _, line in ipairs(lines) do
				local descline = infopanel:Add("DPanel")
				descline:SetName("Description")
				descline.Text = infotextpad .. line

				descline.Think = function(myself)
					myself.TextColor = mainpanel.SecondaryColor
				end

				descline.Font = "TFA_INSPECTION_SMALL"
				descline:Dock(TOP)
				descline:SetSize(ScrW() * .5, TFA.Fonts.InspectionHeightSmall)
				descline.Paint = TextShadowPaint
			end
		end

		hook.Run("TFA_InspectVGUI_InfoFinish", self, contentpanel, infopanel)
	end
end

local cv_display_moa = GetConVar("cl_tfa_inspect_spreadinmoa")
local sv_tfa_weapon_weight = GetConVar("sv_tfa_weapon_weight")

local AccuracyToDegrees = 1 / TFA.DegreesToAccuracy
local AccuracyToMOA = 1 / TFA.DegreesToAccuracy * 60

SWEP.InspectionVGUI_BestDamage = 100
SWEP.InspectionVGUI_BestRPM = 1200
SWEP.InspectionVGUI_WorstAccuracy = 0.045
SWEP.InspectionVGUI_WorstMove = 0.8
SWEP.InspectionVGUI_WorstRecoil = 1

SWEP.InspectionVGUIStatsTable = {
	{
		name = "bash",
		cond = function(wep) return wep.BashBase and wep:GetStatL("Secondary.CanBash") ~= false end,
		text = function(wep) return language.GetPhrase("tfa.inspect.stat.bashdamage"):format(math.Round(wep:GetStatL("Secondary.BashDamage", 0))) end,
		bar = function(wep) return wep:GetStatL("Secondary.BashDamage") / wep.InspectionVGUI_BestDamage end
	},
	{
		name = "stability",
		cond = function(wep) return true end,
		text = function(wep) return language.GetPhrase("tfa.inspect.stat.stability"):format(math.Clamp(math.Round((1 - math.abs(wep:GetStatL("Primary.KickUp") + wep:GetStatL("Primary.KickDown")) / 2 / 1) * 100), 0, 100)) end,
		bar = function(wep) return (1 - math.abs(wep:GetStatL("Primary.KickUp") + wep:GetStatL("Primary.KickDown")) / 2 / wep.InspectionVGUI_WorstRecoil) end
	},
	{
		name = "damage",
		cond = function(wep) return true end,
		text = function(wep)
			local dmgstr = language.GetPhrase("tfa.inspect.stat.damage"):format(math.Round(wep:GetStatL("Primary.Damage")))

			if wep:GetStatL("Primary.NumShots") ~= 1 then
				dmgstr = dmgstr .. "x" .. math.Round(wep:GetStatL("Primary.NumShots"))
			end

			return dmgstr
		end,
		bar = function(wep) return (wep:GetStatL("Primary.Damage") * math.Round(wep:GetStatL("Primary.NumShots") * 0.75)) / wep.InspectionVGUI_BestDamage end
	},
	{
		name = "mobility",
		cond = function(wep) return sv_tfa_weapon_weight:GetBool() end,
		text = function(wep) return language.GetPhrase("tfa.inspect.stat.mobility"):format(math.Round(wep:GetStatL("RegularMoveSpeedMultiplier") * 100)) end,
		bar = function(wep) return (wep:GetStatL("RegularMoveSpeedMultiplier") - wep.InspectionVGUI_WorstMove) / (1 - wep.InspectionVGUI_WorstMove) end
	},
	{
		name = "firerate",
		cond = function(wep) return true end,
		text = function(wep) return language.GetPhrase("tfa.inspect.stat.rpm"):format(wep:GetStatL("Primary.RPM_Displayed") or wep:GetStatL("Primary.RPM")) end,
		bar = function(wep) return (wep:GetStatL("Primary.RPM_Displayed") or wep:GetStatL("Primary.RPM")) / wep.InspectionVGUI_BestRPM end
	},
	{
		name = "spread_hip",
		cond = function(wep) return wep:GetStatL("Secondary.DisplaySpread", true) end,
		text = function(wep)
			local spread = wep:GetStatL("Primary.Spread")

			local spreadtext
			if cv_display_moa and cv_display_moa:GetBool() then
				spreadtext = language.GetPhrase("tfa.inspect.val.moa"):format(spread * AccuracyToMOA)
			else
				spreadtext = language.GetPhrase("tfa.inspect.val.degrees"):format(spread * AccuracyToDegrees)
			end

			return language.GetPhrase("tfa.inspect.stat.accuracy.hip"):format(spreadtext)
		end,
		bar = function(wep) return 1 - wep:GetStatL("Primary.Spread") / wep.InspectionVGUI_WorstAccuracy end
	},
	{
		name = "spread_iron",
		cond = function(wep) return wep:GetStatL("Secondary.IronSightsEnabled", false) and wep:GetStatL("Secondary.DisplayIronSpread", true) end,
		text = function(wep)
			local spread = wep:GetStatL("Primary.IronAccuracy")

			local spreadtext
			if cv_display_moa and cv_display_moa:GetBool() then
				spreadtext = language.GetPhrase("tfa.inspect.val.moa"):format(spread * AccuracyToMOA)
			else
				spreadtext = language.GetPhrase("tfa.inspect.val.degrees"):format(spread * AccuracyToDegrees)
			end

			return language.GetPhrase("tfa.inspect.stat.accuracy"):format(spreadtext)
		end,
		bar = function(wep) return 1 - wep:GetStatL("Primary.IronAccuracy") / wep.InspectionVGUI_WorstAccuracy end
	},
	{
		name = "condition",
		cond = function(wep) return wep:CanBeJammed() end,
		text = function(wep) return language.GetPhrase("tfa.inspect.condition"):format(math.Clamp(math.Round((1 - wep:GetJamFactor() * .01) * 100), 0, 100)) end,
		bar = function(wep) return 1 - wep:GetJamFactor() * .01 end
	},
}

function SWEP:InspectionVGUIStats(contentpanel)
	if hook.Run("TFA_InspectVGUI_StatsStart", self, contentpanel) ~= false then
		local mainpanel = contentpanel:GetParent()

		local statspanel = contentpanel:Add("DPanel")
		statspanel:SetName("Weapon Stats Container")

		local preferredWidth = math.min(ScaleH(400), ScrW() * .4)

		statspanel:SetSize(0, 0)
		statspanel:Dock(BOTTOM)
		statspanel:DockMargin(0, 0, ScrW() - preferredWidth - ScaleH(self.VGUIPaddingW) * 4, 0)
		statspanel.Paint = function() end

		statspanel.stats = {}
		for _, tbl in ipairs(self.InspectionVGUIStatsTable) do
			if not tbl.name or not tbl.text or not tbl.bar or statspanel.stats[tbl.name] then continue end
			if tbl.cond and not tbl.cond(self) then continue end

			statspanel:SetTall(statspanel:GetTall() + TFA.Fonts.InspectionHeightSmall)

			local statpanel = statspanel:Add("DPanel")

			statpanel:SetName("Stat Panel - " .. tbl.name)
			statpanel:SetSize(preferredWidth, TFA.Fonts.InspectionHeightSmall)

			statpanel.StatTable = tbl
			statpanel.Weapon = self
			statpanel.Font = "TFA_INSPECTION_SMALL"

			statpanel.Paint = self.PaintStatPanel
			statpanel:Dock(BOTTOM)

			statspanel.stats[tbl.name] = statpanel
		end

		hook.Run("TFA_InspectVGUI_StatsFinish", self, contentpanel, statspanel)
	end
end

function SWEP:InspectionVGUIAttachments(contentpanel)
	local mainpanel = contentpanel:GetParent()
	local scrollpanel, vbar

	if att_enabled_cv:GetBool() and hook.Run("TFA_InspectVGUI_AttachmentsStart", self, contentpanel) ~= false then
		if self.Attachments then
			scrollpanel = mainpanel:Add("DScrollPanel")
			scrollpanel:SetName("Attachments Container")

			scrollpanel:SetSize(ScrW() * .5 - ScaleH(self.VGUIPaddingW) * 2, mainpanel:GetTall() - ScaleH(self.VGUIPaddingH) * 2)
			scrollpanel:SetPos(ScrW() * .5, ScaleH(self.VGUIPaddingH))

			vbar = scrollpanel:GetVBar()

			vbar.Paint = function(myself, w, h)
				if not mainpanel or not mainpanel.BackgroundColor then return end
				surface.SetDrawColor(mainpanel.BackgroundColor.r, mainpanel.BackgroundColor.g, mainpanel.BackgroundColor.b, mainpanel.BackgroundColor.a / 2)
				surface.DrawRect(w * .65, 0, w * .35, h)
			end

			vbar.btnUp.Paint = function(myself, w, h)
				if not mainpanel or not mainpanel.PrimaryColor then return end
				surface.SetDrawColor(mainpanel.PrimaryColor.r, mainpanel.PrimaryColor.g, mainpanel.PrimaryColor.b, mainpanel.PrimaryColor.a)
				surface.DrawRect(w * .65, 0, w * .35, h)
			end

			vbar.btnDown.Paint = function(myself, w, h)
				if not mainpanel or not mainpanel.PrimaryColor then return end
				surface.SetDrawColor(mainpanel.PrimaryColor.r, mainpanel.PrimaryColor.g, mainpanel.PrimaryColor.b, mainpanel.PrimaryColor.a)
				surface.DrawRect(w * .65, 0, w * .35, h)
			end

			vbar.btnGrip.Paint = function(myself, w, h)
				if not mainpanel or not mainpanel.PrimaryColor then return end
				surface.SetDrawColor(mainpanel.PrimaryColor.r, mainpanel.PrimaryColor.g, mainpanel.PrimaryColor.b, mainpanel.PrimaryColor.a)
				surface.DrawRect(w * .65, 0, w * .35, h)
			end
		end

		self:GenerateVGUIAttachmentTable()
		local i = 0
		local prevCat
		local lineY = 0
		local scrollWide = scrollpanel:GetWide() - (IsValid(vbar) and vbar:GetTall() or 0)
		local lastTooltipPanel

		local iconsize = math.Round(ScaleH(TFA.Attachments.IconSize))
		local catspacing = math.Round(ScaleH(TFA.Attachments.CategorySpacing))
		local padding = math.Round(ScaleH(TFA.Attachments.UIPadding))

		for k, v in pairs(self.VGUIAttachments) do
			if k ~= "BaseClass" then
				if prevCat then
					local isContinuing = prevCat == (v.cat or k)
					lineY = lineY + (isContinuing and iconsize + padding or catspacing)

					if not isContinuing then
						lastTooltipPanel = nil
					end
				end

				prevCat = v.cat or k
				local testpanel = mainpanel:Add("TFAAttachmentPanel")
				testpanel:SetName("Attachment Category Container")
				testpanel:SetParent(scrollpanel)
				testpanel:SetContentPanel(scrollpanel)
				i = i + 1
				testpanel:SetWeapon(self)
				testpanel:SetAttachment(k)
				testpanel:SetCategory(v.cat or k)
				testpanel:Initialize()
				lastTooltipPanel = lastTooltipPanel or testpanel:InitializeTooltip()
				testpanel:SetupTooltip(lastTooltipPanel)
				testpanel:PopulateIcons()
				testpanel:SetPos(scrollWide - testpanel:GetWide(), lineY)
			end
		end

		hook.Run("TFA_InspectVGUI_AttachmentsFinish", self, contentpanel, scrollpanel)
	end

	if self.Primary.RangeFalloffLUTBuilt and self:GetStatL("Primary.DisplayFalloff") and hook.Run("TFA_InspectVGUI_FalloffStart", self, contentpanel) ~= false then
		local falloffpanel = vgui.Create("EditablePanel", mainpanel)
		falloffpanel:SetSize(ScrW() * .5 - ScaleH(self.VGUIPaddingW) * 2, mainpanel:GetTall() * 0.2)
		falloffpanel:SetPos(ScrW() * .5, mainpanel:GetTall() - falloffpanel:GetTall() - ScaleH(self.VGUIPaddingH))
		falloffpanel:SetName("Damage Falloff Graph")

		if scrollpanel then
			scrollpanel:SetTall(scrollpanel:GetTall() - falloffpanel:GetTall())
			falloffpanel:SetPos(ScrW() * .5, ScaleH(self.VGUIPaddingH) + scrollpanel:GetTall())
		end

		falloffpanel:NoClipping(true)

		local self2 = self
		local shadow_color = Color(0, 0, 0)

		-- it differ from function above
		local function shadowed_text(text, font, x, y, color, ...)
			draw.SimpleText(text, font, x + 2, y + 2, shadow_color, ...)
			draw.SimpleText(text, font, x, y, color, ...)
		end

		local function shadowed_line(x, y, x2, y2, color, color2)
			surface.SetDrawColor(color2)
			surface.DrawLine(x + 1, y + 1, x2 + 1, y2 + 1)
			surface.SetDrawColor(color)
			surface.DrawLine(x, y, x2, y2)
		end

		function falloffpanel.Paint(myself, w, h)
			if not IsValid(self2) or not IsValid(mainpanel) then return end

			local lut = self2.Primary.RangeFalloffLUTBuilt
			if not lut then return end
			local wepdmg = self2.Primary.Damage

			shadow_color.a = mainpanel.SecondaryColor.a

			shadowed_text("#tfa.inspect.damagedrop", "TFASleekSmall", 0, ScaleH(pad), mainpanel.SecondaryColor, TEXT_ALIGN_LEFT)

			local ax, ay = 0, TFA.Fonts.SleekHeightSmall + ScaleH(pad) * 2

			surface.SetDrawColor(mainpanel.SecondaryColor)

			local range = 0
			local div = 1

			for i, data in ipairs(lut) do
				if data[1] > range then
					range = data[1]
				end

				if data[2] > div then
					div = data[2]
				end
			end

			range = range * 1.337

			local rightpadding = 18

			for pos = 1, 4 do
				shadowed_line(ax + pos * (w - rightpadding) / 4, h - 2 - ay, ax + pos * (w - rightpadding) / 4, h - 12 - ay, mainpanel.SecondaryColor, mainpanel.BackgroundColor)
				shadowed_text(string.format("%dm", range * 0.0254 * pos / 4), "TFASleekSmall", ax + pos * (w - rightpadding) / 4, h - ay, mainpanel.SecondaryColor, TEXT_ALIGN_CENTER)
			end

			shadowed_line(ax + 1, ay + 1, 1, h - 2 - ay, mainpanel.SecondaryColor, mainpanel.BackgroundColor)
			shadowed_line(ax + 1, h - 2 - ay, w - rightpadding, h - 2 - ay, mainpanel.SecondaryColor, mainpanel.BackgroundColor)

			local lx, ly = myself:LocalToScreen(ax, 0)
			local mx, my = input.GetCursorPos()
			local rmx, rmy = mx, my
			mx = mx - lx
			my = my - ly

			local px, py

			local cirX, cirY, dmg, drange

			local progression = mx / (w - ax - rightpadding)

			for i, data in ipairs(lut) do
				local x, y = ax + data[1] / range * (w - ax - rightpadding), ay + (div - data[2]) * (h - ay * 2) / div

				if not px then
					px, py = x, y
				end

				shadowed_line(px, py, x, y, mainpanel.PrimaryColor, mainpanel.BackgroundColor)

				if x > mx and px < mx then
					local t = (mx - px) / (x - px)
					cirX, cirY = Lerp(t, px, x), Lerp(t, py, y)
					local ndmg = lut[i + 1] and lut[i + 1][2] or data[2]
					local deltadmg = ndmg - data[2]
					dmg = deltadmg * t + data[2]
				end

				px, py = x, y
			end

			shadowed_line(px, py, w - ax - 18, py, mainpanel.PrimaryColor, mainpanel.BackgroundColor)

			if mx > px and (w - ax - 18) > mx then
				cirX, cirY = mx, py
				dmg = lut[#lut][2]
			end

			if mx > 0 and my > 0 and mx < w and my < h and dmg then
				shadowed_line(mx, ay, mx, h - ay, mainpanel.PrimaryColor, mainpanel.BackgroundColor)

				if cirX then
					local Xsize = ScaleH(8)

					surface.SetDrawColor(mainpanel.BackgroundColor)
					surface.DrawLine(cirX - Xsize + 1, cirY - Xsize + 1, cirX + Xsize + 1, cirY + Xsize + 1)
					surface.DrawLine(cirX + Xsize + 1, cirY - Xsize + 1, cirX - Xsize + 1, cirY + Xsize + 1)

					surface.SetDrawColor(mainpanel.PrimaryColor)
					surface.DrawLine(cirX - Xsize, cirY - Xsize, cirX + Xsize, cirY + Xsize)
					surface.DrawLine(cirX + Xsize, cirY - Xsize, cirX - Xsize, cirY + Xsize)
				end

				shadowed_text(string.format("%dm", math.Round(range * progression * 0.0254)), "TFASleekSmall", mx - ScaleH(pad), my - TFA.Fonts.SleekHeightSmall, mainpanel.SecondaryColor, TEXT_ALIGN_RIGHT)
				shadowed_text(string.format("%ddmg", dmg * wepdmg), "TFASleekSmall", mx + ScaleH(pad), my - TFA.Fonts.SleekHeightSmall, mainpanel.SecondaryColor, TEXT_ALIGN_LEFT)
			end
		end

		hook.Run("TFA_InspectVGUI_FalloffFinish", self, contentpanel, falloffpanel)
	end
end

local cl_tfa_inspect_hide_in_screenshots = GetConVar("cl_tfa_inspect_hide_in_screenshots")
local cl_tfa_inspect_hide_hud = GetConVar("cl_tfa_inspect_hide_hud")
local cl_tfa_inspect_hide = GetConVar("cl_tfa_inspect_hide")
local cl_drawhud = GetConVar("cl_drawhud")

local blacklist = {
	CHudAmmo = false,
	CHudBattery = false,
	CHudHealth = false,
}

local function HUDShouldDraw(_, elem)
	return blacklist[elem]
end

function SWEP:GenerateInspectionDerma()
	if hook.Run("TFA_InspectVGUI_Start", self) == false then return end
	if cl_tfa_inspect_hide:GetBool() then return end

	TFA_INSPECTIONPANEL = vgui.Create("DPanel")
	TFA_INSPECTIONPANEL:SetSize(ScrW(), ScrH())
	TFA_INSPECTIONPANEL:DockPadding(ScaleH(self.VGUIPaddingW), ScaleH(self.VGUIPaddingH), ScaleH(self.VGUIPaddingW), ScaleH(self.VGUIPaddingH))
	TFA_INSPECTIONPANEL:SetRenderInScreenshots(not cl_tfa_inspect_hide_in_screenshots:GetBool())
	TFA_INSPECTIONPANEL:SetName("TFA Base Inspection Panel")

	TFA.INSPECTIONPANEL = TFA_INSPECTIONPANEL

	local function update_visible(status)
		if not cl_tfa_inspect_hide_hud:GetBool() or not DLib then return end

		if status then
			hook.DisableHook("HUDPaint")
			hook.DisableHook("HUDPaintBackground")
			hook.DisableHook("PreDrawHUD")
			hook.DisableHook("PostDrawHUD")
			hook.DisableHook("DrawDeathNotice")

			hook.Add("HUDShouldDraw", TFA_INSPECTIONPANEL, HUDShouldDraw)
		else
			hook.EnableHook("HUDPaint")
			hook.EnableHook("HUDPaintBackground")
			hook.EnableHook("PreDrawHUD")
			hook.EnableHook("PostDrawHUD")
			hook.EnableHook("DrawDeathNotice")

			hook.Remove("HUDShouldDraw", TFA_INSPECTIONPANEL, HUDShouldDraw)
		end
	end

	if not cl_drawhud:GetBool() then
		TFA_INSPECTIONPANEL:SetVisible(false)
	else
		update_visible(true)
	end

	cvars.AddChangeCallback("cl_drawhud", function()
		if not IsValid(TFA_INSPECTIONPANEL) then return end
		TFA_INSPECTIONPANEL:Think()
		if not IsValid(TFA_INSPECTIONPANEL) then return end
		TFA_INSPECTIONPANEL:SetVisible(cl_drawhud:GetBool())
		update_visible(cl_drawhud:GetBool())
	end, "TFA_INSPECTIONPANEL")

	local lastcustomizing = true

	function TFA_INSPECTIONPANEL.Think(myself, w, h)
		local ply = LocalPlayer()

		if not IsValid(ply) then
			myself:Remove()

			return
		end

		local wep = ply:GetActiveWeapon()

		if not IsValid(wep) or not wep.IsTFAWeapon or wep:GetInspectingProgress() <= 0.01 then
			myself:Remove()

			return
		end

		if cl_tfa_inspect_hide_hud:GetBool() and DLib then
			local customizing = wep:GetCustomizing()

			if customizing ~= lastcustomizing then
				lastcustomizing = customizing
				update_visible(customizing)
			end
		end

		myself.Player = ply
		myself.Weapon = wep
	end

	function TFA_INSPECTIONPANEL.OnRemove(myself)
		update_visible(false)
	end

	function TFA_INSPECTIONPANEL.Paint(myself, w, h)
		local wep = self

		if IsValid(wep) then
			myself.Alpha = wep:GetInspectingProgress() * 255
			myself.PrimaryColor = ColorAlpha(INSPECTION_PRIMARYCOLOR, TFA_INSPECTIONPANEL.Alpha)
			myself.SecondaryColor = ColorAlpha(INSPECTION_SECONDARYCOLOR, TFA_INSPECTIONPANEL.Alpha)
			myself.BackgroundColor = ColorAlpha(INSPECTION_BACKGROUND, TFA_INSPECTIONPANEL.Alpha)
			myself.ActiveColor = ColorAlpha(INSPECTION_ACTIVECOLOR, TFA_INSPECTIONPANEL.Alpha)

			if not myself.SideBar then
				myself.SideBar = surface.GetTextureID("vgui/inspectionhud/sidebar")
			end
		end
	end

	self:InspectionVGUISideBars(TFA_INSPECTIONPANEL)

	local contentpanel = vgui.Create("DPanel", TFA_INSPECTIONPANEL)
	contentpanel:Dock(FILL)
	local spad = ScaleH(pad)
	contentpanel:DockPadding(spad, spad, spad, spad)
	contentpanel:SetName("Inspection Content Panel")

	function contentpanel.Paint() end

	-- Top block (gun name and info)
	self:InspectionVGUIMainInfo(contentpanel)

	-- Bottom block (stats)
	self:InspectionVGUIStats(contentpanel)

	-- Attachments
	self:InspectionVGUIAttachments(contentpanel)

	hook.Run("TFA_InspectVGUI_Finish", self, TFA_INSPECTIONPANEL, contentpanel)
end

function SWEP:DoInspectionDerma()
	if not IsValid(TFA_INSPECTIONPANEL) and self:GetInspectingProgress() > 0.01 then
		self:GenerateInspectionDerma()
	end

	if not IsValid(TFA_INSPECTIONPANEL) then return end
	if not self:OwnerIsValid() then return end
end

cvars.AddChangeCallback("gmod_language", function(convar, oldvalue, newvalue)
	if oldvalue == newvalue then return end

	if IsValid(TFA_INSPECTIONPANEL) then
		TFA_INSPECTIONPANEL:Remove()
	end
end, "TFA_INSPECTIONPANEL_LANGCHECK")

local crosscol = Color(255, 255, 255, 255)
local crossa_cvar = GetConVar("cl_tfa_hud_crosshair_color_a")
local outa_cvar = GetConVar("cl_tfa_hud_crosshair_outline_color_a")
local crosscustomenable_cvar = GetConVar("cl_tfa_hud_crosshair_enable_custom")
local crossr_cvar = GetConVar("cl_tfa_hud_crosshair_color_r")
local crossg_cvar = GetConVar("cl_tfa_hud_crosshair_color_g")
local crossb_cvar = GetConVar("cl_tfa_hud_crosshair_color_b")
local crosslen_cvar = GetConVar("cl_tfa_hud_crosshair_length")
local crosshairwidth_cvar = GetConVar("cl_tfa_hud_crosshair_width")
local drawdot_cvar = GetConVar("cl_tfa_hud_crosshair_dot")
local clen_usepixels = GetConVar("cl_tfa_hud_crosshair_length_use_pixels")
local outline_enabled_cvar = GetConVar("cl_tfa_hud_crosshair_outline_enabled")
local outr_cvar = GetConVar("cl_tfa_hud_crosshair_outline_color_r")
local outg_cvar = GetConVar("cl_tfa_hud_crosshair_outline_color_g")
local outb_cvar = GetConVar("cl_tfa_hud_crosshair_outline_color_b")
local outlinewidth_cvar = GetConVar("cl_tfa_hud_crosshair_outline_width")
local hudenabled_cvar = GetConVar("cl_tfa_hud_enabled")
local hudfallback_cvar = GetConVar("cl_tfa_hud_fallback_enabled")
local cgapscale_cvar = GetConVar("cl_tfa_hud_crosshair_gap_scale")
local tricross_cvar = GetConVar("cl_tfa_hud_crosshair_triangular")

--[[
Function Name:  DrawHUD
Syntax: self:DrawHUD().
Returns:  Nothing.
Notes:  Used to draw the HUD.  Can you read?
Purpose:  HUD
]]
--
function SWEP:DrawHUD()
	-- Inspection Derma
	self:DoInspectionDerma()
	-- 3D2D Ammo
	self:DrawHUDAmmo() --so it's swappable easily

	self:DrawKeyBindHints()
end

function SWEP:DrawHUDBackground()
	--Scope Overlay
	if self:GetIronSightsProgress() > self:GetStatL("ScopeOverlayThreshold") and self:GetStatL("Scoped") then
		self:DrawScopeOverlay()
	end
end

function SWEP:DrawHUD3D2D()
end

local draw = draw
local cam = cam
local surface = surface
local render = render
local Vector = Vector
local Matrix = Matrix
local TFA = TFA
local math = math

local function ColorAlpha(color_in, new_alpha)
	if color_in.a == new_alpha then return color_in end
	return Color(color_in.r, color_in.g, color_in.b, new_alpha)
end

local targ, lactive = 0, -1
local targbool = false
local hudhangtime_cvar = GetConVar("cl_tfa_hud_hangtime")
local hudfade_cvar = GetConVar("cl_tfa_hud_ammodata_fadein")
local lfm, fm = 0, 0

SWEP.CLAmmoProgress = 0
SWEP.TextCol = Color(255, 255, 255, 255) --Primary text color
SWEP.TextColContrast = Color(32, 32, 32, 255) --Secondary Text Color (used for shadow)

local TFAHudHide = {
	CHudAmmo = true,
	CHudSecondaryAmmo = true
}

function SWEP:HUDShouldDraw(name)
	if (TFAHudHide[name] and hudenabled_cvar:GetBool()) then
		return false
	end
end

function SWEP:DrawFallbackHUD()
	if not hudfallback_cvar:GetBool() or hook.Run("HUDShouldDraw", "TFA_HUDFallback") == false then return end
	if self:GetMaxClip1() <= 0 then return end

	local fmn = string.upper(self:GetFireModeName() .. (#self:GetStatL("FireModes") > 2 and " | +" or ""))

	surface.SetFont("TFASleekSmall")
	local w, h = surface.GetTextSize(fmn)

	DrawTextShadowed(fmn, "TFASleekSmall", ScrW() * .5 - w * .5, ScaleH(1017), self.TextCol, ScaleH(2))
end

function SWEP:DrawHUDAmmo()
	local self2 = self:GetTable()
	local stat = self2.GetStatus(self)

	if self2.GetStatL(self, "BoltAction") then
		if stat == TFA.Enum.STATUS_SHOOTING then
			if not self2.LastBoltShoot then
				self2.LastBoltShoot = l_CT()
			end
		elseif self2.LastBoltShoot then
			self2.LastBoltShoot = nil
		end
	end

	if not hudenabled_cvar:GetBool() or hook.Run("HUDShouldDraw", "TFA_HUDAmmo") == false then
		self:DrawFallbackHUD()
		return
	end

	fm = self:GetFireMode()
	targbool = (not TFA.Enum.HUDDisabledStatus[stat]) or fm ~= lfm
	targbool = targbool or (stat == TFA.Enum.STATUS_SHOOTING and self2.LastBoltShoot and l_CT() > self2.LastBoltShoot + self2.GetStatL(self, "BoltTimerOffset"))
	targbool = targbool or (self2.GetStatL(self, "PumpAction") and (stat == TFA.Enum.STATUS_PUMP or (stat == TFA.Enum.STATUS_SHOOTING and self:Clip1() == 0)))
	targbool = targbool or (stat == TFA.Enum.STATUS_FIDGET)

	targ = targbool and 1 or 0
	lfm = fm

	if targ == 1 then
		lactive = RealTime()
	elseif RealTime() < lactive + hudhangtime_cvar:GetFloat() then
		targ = 1
	elseif self:GetOwner():KeyDown(IN_RELOAD) then
		targ = 1
	end

	self2.CLAmmoProgress = math.Approach(self2.CLAmmoProgress, targ, (targ - self2.CLAmmoProgress) * RealFrameTime() * 2 / hudfade_cvar:GetFloat())

	local myalpha = 225 * self2.CLAmmoProgress
	if myalpha < 1 then return end
	local amn = self2.GetStatL(self, "Primary.Ammo")
	if not amn then return end
	if amn == "none" or amn == "" then return end
	local mzpos = self:GetMuzzlePos()

	if self2.GetStatL(self, "IsAkimbo") then
		self2.MuzzleAttachmentRaw = self2.MuzzleAttachmentRaw2 or 1
	end

	if self2.GetHidden(self) then return end

	local xx, yy

	if mzpos and mzpos.Pos then
		local pos = mzpos.Pos
		local textsize = self2.textsize and self2.textsize or 1
		local pl = IsValid(self:GetOwner()) and self:GetOwner() or LocalPlayer()
		local ang = pl:EyeAngles() --(angpos.Ang):Up():Angle()
		ang:RotateAroundAxis(ang:Right(), 90)
		ang:RotateAroundAxis(ang:Up(), -90)
		ang:RotateAroundAxis(ang:Forward(), 0)
		pos = pos + ang:Right() * (self2.textupoffset and self2.textupoffset or -2 * (textsize / 1))
		pos = pos + ang:Up() * (self2.textfwdoffset and self2.textfwdoffset or 0 * (textsize / 1))
		pos = pos + ang:Forward() * (self2.textrightoffset and self2.textrightoffset or -1 * (textsize / 1))
		cam.Start3D()
		local postoscreen = pos:ToScreen()
		cam.End3D()
		xx = postoscreen.x
		yy = postoscreen.y
	else -- fallback to pseudo-3d if no muzzle
		xx, yy = ScrW() * .65, ScrH() * .6
	end

	local v, newx, newy, newalpha = hook.Run("TFA_DrawHUDAmmo", self, xx, yy, myalpha)
	if v ~= nil then
		if v then
			xx = newx or xx
			yy = newy or yy
			myalpha = newalpha or myalpha
		else
			return
		end
	end

	if self:GetInspectingProgress() < 0.01 and self2.GetStatL(self, "Primary.Ammo") ~= "" and self2.GetStatL(self, "Primary.Ammo") ~= 0 then
		local str, clipstr

		if self2.GetStatL(self, "Primary.ClipSize") and self2.GetStatL(self, "Primary.ClipSize") ~= -1 then
			clipstr = language.GetPhrase("tfa.hud.ammo.clip1")

			if self2.GetStatL(self, "IsAkimbo") and self2.GetStatL(self, "EnableAkimboHUD") ~= false then
				if self2.Akimbo_Inverted then
					str = clipstr:format(math.ceil(self:Clip1() / 2))

					if (self:Clip1() > self2.GetStatL(self, "Primary.ClipSize")) then
						str = clipstr:format(math.ceil(self:Clip1() / 2) - 1 .. " + " .. (math.ceil(self:Clip1() / 2) - math.ceil(self2.GetStatL(self, "Primary.ClipSize") / 2)))
					end
				else
					str = clipstr:format(math.floor(self:Clip1() / 2))

					if (math.floor(self:Clip1() / 2) > math.floor(self2.GetStatL(self, "Primary.ClipSize") / 2)) then
						str = clipstr:format(math.floor(self:Clip1() / 2) - 1 .. " + " .. (math.floor(self:Clip1() / 2) - math.floor(self2.GetStatL(self, "Primary.ClipSize") / 2)))
					end
				end
			else
				str = clipstr:format(self:Clip1())

				if (self:Clip1() > self2.GetStatL(self, "Primary.ClipSize")) then
					str = clipstr:format(self2.GetStatL(self, "Primary.ClipSize") .. " + " .. (self:Clip1() - self2.GetStatL(self, "Primary.ClipSize")))
				end
			end

			draw.DrawText(str, "TFASleek", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
			draw.DrawText(str, "TFASleek", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
			str = language.GetPhrase("tfa.hud.ammo.reserve1"):format(self2.Ammo1(self))
			yy = yy + TFA.Fonts.SleekHeight
			xx = xx - TFA.Fonts.SleekHeight / 3
			draw.DrawText(str, "TFASleekMedium", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
			draw.DrawText(str, "TFASleekMedium", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
			yy = yy + TFA.Fonts.SleekHeightMedium
			xx = xx - TFA.Fonts.SleekHeightMedium / 3
		else
			str = language.GetPhrase("tfa.hud.ammo1"):format(self2.Ammo1(self))
			draw.DrawText(str, "TFASleek", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
			draw.DrawText(str, "TFASleek", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
			yy = yy + TFA.Fonts.SleekHeightMedium
			xx = xx - TFA.Fonts.SleekHeightMedium / 3
		end

		str = string.upper(self:GetFireModeName() .. (#self2.GetStatL(self, "FireModes") > 2 and " | +" or ""))

		if self:IsJammed() then
			str = str .. "\n" .. language.GetPhrase("tfa.hud.jammed")
		end

		draw.DrawText(str, "TFASleekSmall", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
		draw.DrawText(str, "TFASleekSmall", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
		yy = yy + TFA.Fonts.SleekHeightSmall
		xx = xx - TFA.Fonts.SleekHeightSmall / 3

		if self2.GetStatL(self, "IsAkimbo") and self2.GetStatL(self, "EnableAkimboHUD") ~= false then
			local angpos2 = self:GetOwner():ShouldDrawLocalPlayer() and self:GetAttachment(2) or self2.OwnerViewModel:GetAttachment(2)

			if angpos2 then
				local pos2 = angpos2.Pos
				local ts2 = pos2:ToScreen()

				xx, yy = ts2.x, ts2.y
			else
				xx, yy = ScrW() * .35, ScrH() * .6
			end

			if self2.GetStatL(self, "Primary.ClipSize") and self2.GetStatL(self, "Primary.ClipSize") ~= -1 then
				clipstr = language.GetPhrase("tfa.hud.ammo.clip1")

				if self2.Akimbo_Inverted then
					str = clipstr:format(math.floor(self:Clip1() / 2))

					if (math.floor(self:Clip1() / 2) > math.floor(self2.GetStatL(self, "Primary.ClipSize") / 2)) then
						str = clipstr:format(math.floor(self:Clip1() / 2) - 1 .. " + " .. (math.floor(self:Clip1() / 2) - math.floor(self2.GetStatL(self, "Primary.ClipSize") / 2)))
					end
				else
					str = clipstr:format(math.ceil(self:Clip1() / 2))

					if (self:Clip1() > self2.GetStatL(self, "Primary.ClipSize")) then
						str = clipstr:format(math.ceil(self:Clip1() / 2) - 1 .. " + " .. (math.ceil(self:Clip1() / 2) - math.ceil(self2.GetStatL(self, "Primary.ClipSize") / 2)))
					end
				end

				draw.DrawText(str, "TFASleek", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
				draw.DrawText(str, "TFASleek", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
				str = language.GetPhrase("tfa.hud.ammo.reserve1"):format(self2.Ammo1(self))
				yy = yy + TFA.Fonts.SleekHeight
				xx = xx - TFA.Fonts.SleekHeight / 3
				draw.DrawText(str, "TFASleekMedium", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
				draw.DrawText(str, "TFASleekMedium", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
				yy = yy + TFA.Fonts.SleekHeightMedium
				xx = xx - TFA.Fonts.SleekHeightMedium / 3
			else
				str = language.GetPhrase("tfa.hud.ammo1"):format(self2.Ammo1(self))
				draw.DrawText(str, "TFASleek", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
				draw.DrawText(str, "TFASleek", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
				yy = yy + TFA.Fonts.SleekHeightMedium
				xx = xx - TFA.Fonts.SleekHeightMedium / 3
			end

			str = string.upper(self:GetFireModeName() .. (#self2.FireModes > 2 and " | +" or ""))
			draw.DrawText(str, "TFASleekSmall", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
			draw.DrawText(str, "TFASleekSmall", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
		end

		if self2.GetStatL(self, "Secondary.Ammo") and self2.GetStatL(self, "Secondary.Ammo") ~= "" and self2.GetStatL(self, "Secondary.Ammo") ~= "none" and self2.GetStatL(self, "Secondary.Ammo") ~= 0 and not self2.GetStatL(self, "IsAkimbo") then
			if self2.GetStatL(self, "Secondary.ClipSize") and self2.GetStatL(self, "Secondary.ClipSize") ~= -1 then
				clipstr = language.GetPhrase("tfa.hud.ammo.clip2")
				str = (self:Clip2() > self2.GetStatL(self, "Secondary.ClipSize")) and clipstr:format(self2.GetStatL(self, "Secondary.ClipSize") .. " + " .. (self:Clip2() - self2.GetStatL(self, "Primary.ClipSize"))) or clipstr:format(self:Clip2())
				draw.DrawText(str, "TFASleekSmall", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
				draw.DrawText(str, "TFASleekSmall", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
				str = language.GetPhrase("tfa.hud.ammo.reserve2"):format(self2.Ammo2(self))
				yy = yy + TFA.Fonts.SleekHeightSmall
				xx = xx - TFA.Fonts.SleekHeightSmall / 3
				draw.DrawText(str, "TFASleekSmall", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
				draw.DrawText(str, "TFASleekSmall", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
			else
				str = language.GetPhrase("tfa.hud.ammo2"):format(self2.Ammo2(self))
				draw.DrawText(str, "TFASleekSmall", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
				draw.DrawText(str, "TFASleekSmall", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
			end
		end
	end
end

local sv_tfa_recoil_legacy = GetConVar("sv_tfa_recoil_legacy")
local cl_tfa_hud_crosshair_pump = GetConVar("cl_tfa_hud_crosshair_pump")
local sv_tfa_fixed_crosshair = GetConVar("sv_tfa_fixed_crosshair")

local crosshairMatrix = Matrix()
local crosshairMatrixLeft = Matrix()
local crosshairMatrixRight = Matrix()
local crosshairRotation = Angle()

local pixelperfectshift = Vector(-0.5)

function SWEP:CalculateCrosshairConeRecoil()
	return self:GetStatL("CrosshairConeRecoilOverride", false) or self:CalculateConeRecoil()
end

function SWEP:DoDrawCrosshair()
	local self2 = self:GetTable()
	local x, y

	if not self2.ratios_calc or not self2.DrawCrosshairDefault then return true end
	if self2.GetHolding(self) then return true end

	local stat = self2.GetStatus(self)

	if not crosscustomenable_cvar:GetBool() then
		return TFA.Enum.ReloadStatus[stat] or math.min(1 - (self2.IronSightsProgressUnpredicted2 or self:GetIronSightsProgress()), 1 - self:GetSprintProgress(), 1 - self:GetInspectingProgress()) <= 0.5
	end

	self2.clrelp = self2.clrelp or 0
	self2.clrelp = math.Approach(
		self2.clrelp,
		TFA.Enum.ReloadStatus[stat] and 0 or 1,
		((TFA.Enum.ReloadStatus[stat] and 0 or 1) - self2.clrelp) * RealFrameTime() * 7)

	local crossa = crossa_cvar:GetFloat() *
		math.pow(math.min(1 - (((self2.IronSightsProgressUnpredicted2 or self:GetIronSightsProgress()) and
			not self2.GetStatL(self, "DrawCrosshairIronSights")) and (self2.IronSightsProgressUnpredicted2 or self:GetIronSightsProgress()) or 0),
			1 - self:GetSprintProgress(),
			1 - self:GetInspectingProgress(),
			self2.clrelp),
		2)

	local outa = outa_cvar:GetFloat() *
		math.pow(math.min(1 - (((self2.IronSightsProgressUnpredicted2 or self:GetIronSightsProgress()) and
			not self2.GetStatL(self, "DrawCrosshairIronSights")) and (self2.IronSightsProgressUnpredicted2 or self:GetIronSightsProgress()) or 0),
			1 - self:GetSprintProgress(),
			1 - self:GetInspectingProgress(),
			self2.clrelp),
		2)

	local ply = LocalPlayer()
	if not ply:IsValid() or self:GetOwner() ~= ply then return false end

	if not ply.interpposx then
		ply.interpposx = ScrW() / 2
	end

	if not ply.interpposy then
		ply.interpposy = ScrH() / 2
	end

	local tr = {}
	tr.start = ply:GetShootPos()
	tr.endpos = tr.start + ply:GetAimVector() * 0x7FFF
	tr.filter = ply
	tr.mask = MASK_SHOT
	local traceres = util.TraceLine(tr)
	local targent = traceres.Entity

	-- If we're drawing the local player, draw the crosshair where they're aiming
	-- instead of in the center of the screen.
	if self:GetOwner():ShouldDrawLocalPlayer() and not ply:GetNW2Bool("ThirtOTS", false) then
		local coords = traceres.HitPos:ToScreen()
		coords.x = math.Clamp(coords.x, 0, ScrW())
		coords.y = math.Clamp(coords.y, 0, ScrH())
		ply.interpposx = math.Approach(ply.interpposx, coords.x, (ply.interpposx - coords.x) * RealFrameTime() * 7.5)
		ply.interpposy = math.Approach(ply.interpposy, coords.y, (ply.interpposy - coords.y) * RealFrameTime() * 7.5)
		x, y = ply.interpposx, ply.interpposy
		-- Center of screen
	elseif sv_tfa_fixed_crosshair:GetBool() then
		x, y = ScrW() / 2, ScrH() / 2
	else
		tr.endpos = tr.start + self:GetAimAngle():Forward() * 0x7FFF
		local pos = util.TraceLine(tr).HitPos:ToScreen()
		x, y = pos.x, pos.y
	end

	TFA.LastCrosshairPosX, TFA.LastCrosshairPosY = x, y

	local v = hook.Run("TFA_DrawCrosshair", self, x, y)

	if v ~= nil then
		return v
	end

	local s_cone = self:CalculateCrosshairConeRecoil()

	if not self2.selftbl then
		self2.selftbl = {ply, self}
	end

	local crossr, crossg, crossb, crosslen, crosshairwidth, drawdot, teamcol
	teamcol = self2.GetTeamColor(self, targent)
	crossr = crossr_cvar:GetFloat()
	crossg = crossg_cvar:GetFloat()
	crossb = crossb_cvar:GetFloat()
	crosslen = crosslen_cvar:GetFloat() * 0.01
	crosscol.r = crossr
	crosscol.g = crossg
	crosscol.b = crossb
	crosscol.a = crossa
	crosscol = ColorMix(crosscol, teamcol, 1, CMIX_MULT)
	crossr = crosscol.r
	crossg = crosscol.g
	crossb = crosscol.b
	crossa = crosscol.a
	crosshairwidth = crosshairwidth_cvar:GetFloat()
	drawdot = drawdot_cvar:GetBool()
	local scale = (s_cone * 90) / self:GetOwner():GetFOV() * ScrH() / 1.44 * cgapscale_cvar:GetFloat()

	if self:GetSprintProgress() >= 0.1 and not self:GetStatL("AllowSprintAttack", false) then
		scale = scale * (1 + TFA.Cubic(self:GetSprintProgress() - 0.1) * 6)
	end

	if self2.clrelp < 0.9 then
		scale = scale * Lerp(TFA.Cubic(0.9 - self2.clrelp) * 1.111, 1, 8)
	end

	local gap = math.Round(scale / 2) * 2
	local length

	if not clen_usepixels:GetBool() then
		length = gap + ScrH() * 1.777 * crosslen
	else
		length = gap + crosslen * 100
	end

	local extraRotation = 0
	local cPos = Vector(x, y)

	if stat == TFA.Enum.STATUS_PUMP and cl_tfa_hud_crosshair_pump:GetBool() then
		if tricross_cvar:GetBool() then
			extraRotation =  TFA.Quintic(self:GetStatusProgress(true))
			local mul = 360
			extraRotation = extraRotation * mul
		else
			extraRotation = TFA.Quintic(TFA.Cosine(self:GetStatusProgress(true)))
			local mul = -180

			if extraRotation < 0.5 then
				extraRotation = extraRotation * mul
			else
				extraRotation = (1 - extraRotation) * mul
			end
		end
	end

	extraRotation = extraRotation - EyeAngles().r

	crosshairMatrix:Identity()
	crosshairMatrix:Translate(cPos)
	crosshairRotation.y = extraRotation
	crosshairMatrix:Rotate(crosshairRotation)

	if tricross_cvar:GetBool() then
		crosshairMatrixLeft:Identity()
		crosshairMatrixRight:Identity()

		crosshairMatrixLeft:Translate(cPos)
		crosshairMatrixRight:Translate(cPos)

		crosshairRotation.y = extraRotation + 135
		crosshairMatrixRight:SetAngles(crosshairRotation)
		crosshairRotation.y = extraRotation - 135
		crosshairMatrixLeft:SetAngles(crosshairRotation)

		if crosshairwidth % 2 ~= 0 then
			crosshairMatrixLeft:Translate(pixelperfectshift)
			crosshairMatrixRight:Translate(pixelperfectshift)
		end
	end

	DisableClipping(true)

	render.PushFilterMag(TEXFILTER.ANISOTROPIC)
	render.PushFilterMin(TEXFILTER.ANISOTROPIC)

	--Outline
	if outline_enabled_cvar:GetBool() then
		local outr, outg, outb, outlinewidth
		outr = outr_cvar:GetFloat()
		outg = outg_cvar:GetFloat()
		outb = outb_cvar:GetFloat()
		outlinewidth = outlinewidth_cvar:GetFloat()

		cam.PushModelMatrix(crosshairMatrix)
		surface.SetDrawColor(outr, outg, outb, outa)

		local tHeight = math.Round(length - gap + outlinewidth * 2) + crosshairwidth

		local tX, tY, tWidth =
			math.Round(-outlinewidth) - crosshairwidth / 2,
			-gap * self:GetStatL("Primary.SpreadBiasPitch") - tHeight + outlinewidth,
			math.Round(outlinewidth * 2) + crosshairwidth

		-- Top
		surface.DrawRect(tX, tY, tWidth, tHeight)
		cam.PopModelMatrix()

		if tricross_cvar:GetBool() then
			tY = -gap - tHeight

			cam.PushModelMatrix(crosshairMatrixLeft)
			surface.DrawRect(tX, tY + outlinewidth, tWidth, tHeight)
			cam.PopModelMatrix()

			cam.PushModelMatrix(crosshairMatrixRight)
			surface.DrawRect(tX, tY + outlinewidth, tWidth, tHeight)
			cam.PopModelMatrix()
		else
			cam.PushModelMatrix(crosshairMatrix)

			local width = math.Round(length - gap + outlinewidth * 2) + crosshairwidth
			local realgap = math.Round(gap * self:GetStatL("Primary.SpreadBiasYaw") - outlinewidth) - crosshairwidth / 2

			-- Left
			surface.DrawRect(
				-realgap - width,
				math.Round(-outlinewidth) - crosshairwidth / 2,
				width,
				math.Round(outlinewidth * 2) + crosshairwidth)

			-- Right
			surface.DrawRect(
				realgap,
				math.Round(-outlinewidth) - crosshairwidth / 2,
				width,
				math.Round(outlinewidth * 2) + crosshairwidth)

			-- Bottom
			surface.DrawRect(
				math.Round(-outlinewidth) - crosshairwidth / 2,
				math.Round(gap * self:GetStatL("Primary.SpreadBiasPitch") - outlinewidth) - crosshairwidth / 2,
				math.Round(outlinewidth * 2) + crosshairwidth,
				math.Round(length - gap + outlinewidth * 2) + crosshairwidth)

			cam.PopModelMatrix()
		end

		if drawdot then
			cam.PushModelMatrix(crosshairMatrix)
			surface.DrawRect(-math.Round((crosshairwidth - 1) / 2) - math.Round(outlinewidth), -math.Round((crosshairwidth - 1) / 2) - math.Round(outlinewidth), math.Round(outlinewidth * 2) + crosshairwidth, math.Round(outlinewidth * 2) + crosshairwidth) --dot
			cam.PopModelMatrix()
		end
	end

	--Main Crosshair
	cam.PushModelMatrix(crosshairMatrix)
	surface.SetDrawColor(crossr, crossg, crossb, crossa)

	local tHeight = math.Round(length - gap) + crosshairwidth

	local tX, tY, tWidth =
		-crosshairwidth / 2,
		math.Round(-gap * self:GetStatL("Primary.SpreadBiasPitch") - tHeight),
		crosshairwidth

	-- Top
	surface.DrawRect(tX, tY, tWidth, tHeight)
	cam.PopModelMatrix()

	if tricross_cvar:GetBool() then
		local xhl = math.Round(length - gap) + crosshairwidth

		tY = math.Round(-gap - tHeight)

		cam.PushModelMatrix(crosshairMatrixLeft)
		surface.DrawRect(tX, tY, tWidth, tHeight)
		cam.PopModelMatrix()

		cam.PushModelMatrix(crosshairMatrixRight)
		surface.DrawRect(tX, tY, tWidth, tHeight)
		cam.PopModelMatrix()
	else
		cam.PushModelMatrix(crosshairMatrix)

		local width = math.Round(length - gap) + crosshairwidth
		local realgap = math.Round(gap * self:GetStatL("Primary.SpreadBiasYaw")) - crosshairwidth / 2

		-- Left
		surface.DrawRect(
			-realgap - width,
			-crosshairwidth / 2,
			width,
			crosshairwidth)

		-- Right
		surface.DrawRect(
			realgap,
			-crosshairwidth / 2,
			width,
			crosshairwidth)

		-- Bottom
		surface.DrawRect(
			-crosshairwidth / 2,
			math.Round(gap * self:GetStatL("Primary.SpreadBiasPitch")) - crosshairwidth / 2,
			crosshairwidth,
			math.Round(length - gap) + crosshairwidth)

		cam.PopModelMatrix()
	end

	render.PopFilterMag()
	render.PopFilterMin()

	if drawdot then
		cam.PushModelMatrix(crosshairMatrix)
		surface.DrawRect(-math.Round((crosshairwidth - 1) / 2), -math.Round((crosshairwidth - 1) / 2), crosshairwidth, crosshairwidth) --dot
		cam.PopModelMatrix()
	end

	DisableClipping(false)

	return true
end

function SWEP:DrawScopeOverlay()
	if hook.Run("TFA_DrawScopeOverlay", self) == true then return end
	local self2 = self:GetTable()

	local tbl

	if self2.GetStatL(self, "Secondary.UseACOG") then
		tbl = TFA_SCOPE_ACOG
	end

	if self2.GetStatL(self, "Secondary.UseMilDot") then
		tbl = TFA_SCOPE_MILDOT
	end

	if self2.GetStatL(self, "Secondary.UseSVD") then
		tbl = TFA_SCOPE_SVD
	end

	if self2.GetStatL(self, "Secondary.UseParabolic") then
		tbl = TFA_SCOPE_PARABOLIC
	end

	if self2.GetStatL(self, "Secondary.UseElcan") then
		tbl = TFA_SCOPE_ELCAN
	end

	if self2.GetStatL(self, "Secondary.UseGreenDuplex") then
		tbl = TFA_SCOPE_GREENDUPLEX
	end

	if self2.GetStatL(self, "Secondary.UseAimpoint") then
		tbl = TFA_SCOPE_AIMPOINT
	end

	if self2.GetStatL(self, "Secondary.UseMatador") then
		tbl = TFA_SCOPE_MATADOR
	end

	if self2.GetStatL(self, "Secondary.ScopeTable") then
		tbl = self2.GetStatL(self, "Secondary.ScopeTable")
	end

	if not tbl then
		tbl = TFA_SCOPE_MILDOT
	end

	local w, h = ScrW(), ScrH()

	for k, v in pairs(tbl) do
		local dimension = h

		if k == "ScopeBorder" then
			if istable(v) then
				surface.SetDrawColor(v)
			else
				surface.SetDrawColor(color_black)
			end

			surface.DrawRect(0, 0, w / 2 - dimension / 2, dimension)
			surface.DrawRect(w / 2 + dimension / 2, 0, w / 2 - dimension / 2, dimension)
		elseif k == "ScopeMaterial" then
			surface.SetMaterial(v)
			surface.SetDrawColor(255, 255, 255, 255)
			surface.DrawTexturedRect(w / 2 - dimension / 2, (h - dimension) / 2, dimension, dimension)
		elseif k == "ScopeOverlay" then
			surface.SetMaterial(v)
			surface.SetDrawColor(255, 255, 255, 255)
			surface.DrawTexturedRect(0, 0, w, h)
		elseif k == "ScopeCrosshair" then
			local t = type(v)

			if t == "IMaterial" then
				surface.SetMaterial(v)
				surface.SetDrawColor(255, 255, 255, 255)
				surface.DrawTexturedRect(w / 2 - dimension / 4, h / 2 - dimension / 4, dimension / 2, dimension / 2)
			elseif t == "table" then
				if not v.cached then
					v.cached = true
					v.r = v.r or v.x or v[1] or 0
					v.g = v.g or v.y or v[2] or v[1] or 0
					v.b = v.b or v.z or v[3] or v[1] or 0
					v.a = v.a or v[4] or 255
					v.s = v.Scale or v.scale or v.s or 0.25
				end

				surface.SetDrawColor(v.r, v.g, v.b, v.a)

				if v.Material then
					surface.SetMaterial(v.Material)
					surface.DrawTexturedRect(w / 2 - dimension * v.s / 2, h / 2 - dimension * v.s / 2, dimension * v.s, dimension * v.s)
				elseif v.Texture then
					surface.SetTexture(v.Texture)
					surface.DrawTexturedRect(w / 2 - dimension * v.s / 2, h / 2 - dimension * v.s / 2, dimension * v.s, dimension * v.s)
				else
					surface.DrawRect(w / 2 - dimension * v.s / 2, h / 2, dimension * v.s, 1)
					surface.DrawRect(w / 2, h / 2 - dimension * v.s / 2, 1, dimension * v.s)
				end
			end
		else
			if k == "scopetex" then
				dimension = dimension * self:GetStatL("ScopeScale") ^ 2 * TFA_SCOPE_SCOPESCALE
			elseif k == "reticletex" then
				dimension = dimension * (self:GetStatL("ReticleScale") and self:GetStatL("ReticleScale") or 1) ^ 2 * (TFA_SCOPE_RETICLESCALE and TFA_SCOPE_RETICLESCALE or 1)
			else
				dimension = dimension * self:GetStatL("ReticleScale") ^ 2 * TFA_SCOPE_DOTSCALE
			end

			surface.SetDrawColor(255, 255, 255, 255)
			surface.SetTexture(v)
			surface.DrawTexturedRect(w / 2 - dimension / 2, (h - dimension) / 2, dimension, dimension)
		end
	end
end

SWEP.KeyNameOverrides = {
	["MOUSE1"] = "tfa.keys.lmb",
	["MOUSE2"] = "tfa.keys.rmb",
	["MOUSE3"] = "tfa.keys.mmb",
}

function SWEP:GetKeyBind(binds, altbind)
	if type(binds) == "string" then
		binds = {binds}
	end

	if altbind then
		local cvar = GetConVar("cl_tfa_keys_" .. altbind)

		if cvar and cvar:GetInt() > 0 then
			local key = input.GetKeyName(cvar:GetInt())

			return language.GetPhrase(self.KeyNameOverrides[key] or key:upper())
		end
	end

	local result = {}
	for _,bind in ipairs(binds) do
		local binding = input.LookupBinding(bind, true) or input.LookupBinding(bind)

		table.insert(result, binding and language.GetPhrase(self.KeyNameOverrides[binding] or binding:upper()) or bind)
	end

	return result
end

local cv_cm = GetConVar("sv_tfa_cmenu")
local cv_cm_key = GetConVar("sv_tfa_cmenu_key")
local cv_ironsights = GetConVar("sv_tfa_ironsights_enabled")

function SWEP:PrePopulateKeyBindHints(keys)
	return keys
end

function SWEP:PostPopulateKeyBindHints(keys)
	return keys
end

function SWEP:PopulateKeyBindHints(keys)
	keys = keys or {}

	keys = self:PrePopulateKeyBindHints(keys) or keys

	local CanAim = cv_ironsights:GetInt() and self:GetStatL("Secondary.IronSightsEnabled")
	if CanAim then
		table.insert(keys, {
			label = language.GetPhrase("tfa.hint.keys.ironsights"),
			keys = {self:GetKeyBind({"+attack2"})}
		})
	end

	if self.BashBase then
		if self:GetStatL("Secondary.CanBash") ~= false then
			table.insert(keys, {
				label = language.GetPhrase("tfa.hint.keys.meleebash"),
				keys = {CanAim and self:GetKeyBind({"+zoom"}, "bash") or self:GetKeyBind("+attack2")}
			})
		end
	elseif self.AltAttack then
		table.insert(keys, {
			label = language.GetPhrase("tfa.hint.keys.altattack"),
			keys = {CanAim and self:GetKeyBind({"+zoom"}, "bash") or self:GetKeyBind("+attack2")}
		})
	end

	if cv_cm:GetBool() and cv_cm_key:GetInt() ~= 0 then
		local kcode = cv_cm_key:GetInt()
		table.insert(keys, {
			label = language.GetPhrase("tfa.hint.keys.customize"),
			keys = {kcode > 0 and language.GetPhrase(input.GetKeyName(kcode)):upper() or self:GetKeyBind({"+menu_context"}, "customize")}
		})
	end

	if self:GetActivityEnabled(ACT_VM_FIDGET) or self.InspectionActions then
		table.insert(keys, {
			label = language.GetPhrase("tfa.hint.keys.inspect"),
			keys = {self:GetKeyBind({"+reload"}, "inspect")}
		})
	end

	if self:GetStatL("SelectiveFire") then
		table.insert(keys, {
			label = language.GetPhrase("tfa.hint.keys.firemode"),
			keys = {self:GetKeyBind({"+use", "+reload"}, "firemode")}
		})
	end

	if not self.IsMelee and not self.IsBow and not self.IsKnife then
		table.insert(keys, {
			label = language.GetPhrase("tfa.hint.keys.safety"),
			keys = {self:GetKeyBind({"+speed"}), self:GetKeyBind({"+use", "+reload"}, "firemode")}
		})
	end

	if self:GetStatL("FlashlightAttachmentName") ~= nil or self:GetStatL("FlashlightAttachment", 0) > 0 then
		table.insert(keys, {
			label = language.GetPhrase("tfa.hint.keys.flashlight"),
			keys = {self:GetKeyBind({"impulse 100"})}
		})
	end

	if self:GetStatRawL("CanBeSilenced") then
		table.insert(keys, {
			label = language.GetPhrase("tfa.hint.keys.silencer"),
			keys = {self:GetKeyBind({"+use", "+attack"}, "silencer")}
		})
	end

	keys = self:PostPopulateKeyBindHints(keys) or keys
	keys = hook.Run("TFA_PopulateKeyBindHints", self, keys) or keys

	if #keys > 0 then
		table.insert(keys, {
			label = language.GetPhrase("tfa.hint.keys.showkeys"),
			keys = {self:GetKeyBind({"+showscores"})}
		})
	end

	return keys
end

local GradientMaterial = Material("gui/gradient")
-- SWEP.KeyBindHintAlphaLastUpdate = -1

local lastwep_kb
function SWEP:ResetKeyBindHintAlpha(force)
	if (not force or force == "") and lastwep_kb == self then return end
	lastwep_kb = self

	self.KeyBindHintAlphaLastUpdate = CurTime()
end

local cv_hint_enabled = GetConVar("cl_tfa_hud_keybindhints_enabled")
local cv_hint_solidtime = GetConVar("cl_tfa_hud_keybindhints_solidtime")
local cv_hint_fadeintime = GetConVar("cl_tfa_hud_keybindhints_fadeintime")
local cv_hint_fadeouttime = GetConVar("cl_tfa_hud_keybindhints_fadeouttime")

local HintAlpha = 0
function SWEP:DrawKeyBindHints()
	if self:GetOwner():KeyDown(IN_SCORE) or not self.KeyBindHintAlphaLastUpdate then
		self:ResetKeyBindHintAlpha(true)
	end

	local fadeout =  CurTime() >= self.KeyBindHintAlphaLastUpdate + cv_hint_solidtime:GetFloat()
	HintAlpha = math.Clamp(HintAlpha + (fadeout and FrameTime() * -1000 / cv_hint_fadeouttime:GetFloat() or FrameTime() * 1000 / cv_hint_fadeintime:GetFloat()), 0, 255)

	if not cv_hint_enabled:GetBool() or cv_hint_solidtime:GetFloat() <= 0 then return end

	local a = HintAlpha
	if self:GetInspectingProgress() > 0 then
		a = a * (1 - self:GetInspectingProgress())
	end

	if a <= 0 then return end

	local maincol, bgcol = ColorAlpha(INSPECTION_PRIMARYCOLOR, a), INSPECTION_BACKGROUND
	local textfont = "TFA_INSPECTION_SMALL"
	local textheight = TFA.Fonts.InspectionHeightSmall

	local x, y = ScrW() - ScaleH(80), ScrH() * .5
	local bgpad = ScaleH(8)

	local keystbl = self:PopulateKeyBindHints({})
	if #keystbl <= 0 then return end

	local keystr = {}
	local TargetWidth = 0
	surface.SetFont(textfont)
	for _, tbl in ipairs(keystbl) do
		local key = ""
		for k, v in ipairs(tbl.keys) do
			tbl.keys[k] = type(v) == "table" and table.concat(v, " + ") or v
		end

		local keytext = string.format("[%s] - %s", table.concat(tbl.keys, " + "), tbl.label)

		local tw, _ = surface.GetTextSize(keytext)
		TargetWidth = math.max(tw, TargetWidth)

		table.insert(keystr, keytext)
	end
	x = x - TargetWidth
	y = y - textheight * #keystr * .5

	if hook.Run("TFA_PreDrawKeyBindHint", self, x, y, a, keystbl, keystr) == true then return end

	surface.SetDrawColor(bgcol.r, bgcol.g, bgcol.b, a)
	surface.SetMaterial(GradientMaterial)
	surface.DrawTexturedRectUV(x - bgpad, y - bgpad, TargetWidth + bgpad * 2, textheight * #keystr + bgpad * 2, 1, 0, 0, 1)

	for i, key in ipairs(keystr) do
		TextShadowPaint({Text = key, Font = textfont, TextColor = maincol, TextPosX = x, TextPosY = y + (i - 1) * textheight})
	end

	hook.Run("TFA_PostDrawKeyBindHint", self, x, y, a, keystbl, keystr)
end


local fsin, icon
local matcache = {}

function SWEP:DrawWeaponSelection(x, y, wide, tall, alpha)
	local self2 = self:GetTable()

	surface.SetDrawColor(255, 255, 255, alpha)

	icon = self2.GetStatL(self, "WepSelectIcon_Override", self2.WepSelectIcon)

	if not icon then
		self2.IconFix(self)

		return
	end

	local ticon = type(icon)

	if ticon == "IMaterial" then
		surface.SetMaterial(icon)
	elseif ticon == "string" then
		if not matcache[icon] then
			matcache[icon] = Material(icon, "smooth noclamp")
		end

		surface.SetMaterial(matcache[icon])
	else
		surface.SetTexture(icon)
	end

	fsin = self2.BounceWeaponIcon and math.sin( RealTime() * 10 ) * 5 or 0

	-- Borders
	y = y + 10
	x = x + 10
	wide = wide - 20

	surface.DrawTexturedRect(x + fsin, y - fsin, wide - fsin * 2, wide / 2 + fsin)

	self2.PrintWeaponInfo(self, x + wide + 20, y + tall * 0.95, alpha)
end

--PATH lua/weapons/tfa_gun_base/client/laser.lua:
local vector_origin = Vector()

local att, angpos, attname, elemname, targetent
local col = Color(255, 0, 0, 255)
local pc
local laserline
local laserdot
local laserFOV = 1.5
local traceres

local render = render
local Material = Material
local ProjectedTexture = ProjectedTexture
local math = math

SWEP.LaserDistance = 12 * 50 -- default 50 feet
SWEP.LaserDistanceVisual = 12 * 4 --default 4 feet

local function IsHolstering(wep)
	if IsValid(wep) and TFA.Enum.HolsterStatus[wep:GetStatus()] then return true end

	return false
end

function SWEP:DrawLaser(is_vm)
	local self2 = self:GetTable()

	if not laserline then
		laserline = Material(self2.LaserLine or "cable/smoke")
	end

	if not laserdot then
		laserdot = Material(self2.LaserDot or "effects/tfalaserdot")
	end

	local ply = self:GetOwner()
	if not IsValid(ply) then return end

	if ply:IsPlayer() then
		local f = ply.GetNW2Vector or ply.GetNWVector
		pc = f(ply, "TFALaserColor", vector_origin)
		col.r = pc.x
		col.g = pc.y
		col.b = pc.z
	else
		col.r = 255
		col.g = 0
		col.b = 0
	end

	if is_vm then
		if not self2.VMIV(self) then
			self:CleanLaser()

			return
		end

		targetent = self2.OwnerViewModel
		elemname = self2.GetStatL(self, "LaserSight_VElement", self2.GetStatL(self, "LaserSight_Element"))

		local ViewModelElements = self:GetStatRaw("ViewModelElements", TFA.LatestDataVersion)

		if elemname and ViewModelElements[elemname] and IsValid(ViewModelElements[elemname].curmodel) then
			targetent = ViewModelElements[elemname].curmodel
		end

		att = self2.GetStatL(self, "LaserSightAttachment")
		attname = self2.GetStatL(self, "LaserSightAttachmentName")

		if attname then
			att = targetent:LookupAttachment(attname)
		end

		if (not att) or att <= 0 then
			self:CleanLaser()

			return
		end

		angpos = targetent:GetAttachment(att)

		if not angpos then
			self:CleanLaser()

			return
		end

		if self2.LaserDotISMovement and self2.CLIronSightsProgress > 0 then
			local isang = self2.GetStatL(self, "IronSightsAngle")
			angpos.Ang:RotateAroundAxis(angpos.Ang:Right(), isang.y * (self2.ViewModelFlip and -1 or 1) * self2.CLIronSightsProgress)
			angpos.Ang:RotateAroundAxis(angpos.Ang:Up(), -isang.x * self2.CLIronSightsProgress)
		end

		local localProjAng = select(2, WorldToLocal(vector_origin, angpos.Ang, vector_origin, EyeAngles()))
		localProjAng.p = localProjAng.p * ply:GetFOV() / self2.ViewModelFOV
		localProjAng.y = localProjAng.y * ply:GetFOV() / self2.ViewModelFOV
		local wsProjAng = select(2, LocalToWorld(vector_origin, localProjAng, vector_origin, EyeAngles())) --reprojection for trace angle
		traceres = util.QuickTrace(ply:GetShootPos(), wsProjAng:Forward() * 999999, ply)

		if not IsValid(ply.TFALaserDot) and not IsHolstering(self) then
			local lamp = ProjectedTexture()
			ply.TFALaserDot = lamp
			lamp:SetTexture(laserdot:GetString("$basetexture"))
			lamp:SetFarZ(self2.LaserDistance) -- How far the light should shine
			lamp:SetFOV(laserFOV)
			lamp:SetPos(angpos.Pos)
			lamp:SetAngles(angpos.Ang)
			lamp:SetBrightness(5)
			lamp:SetNearZ(1)
			lamp:SetEnableShadows(false)
			lamp:Update()
		end

		local lamp = ply.TFALaserDot

		if IsValid(lamp) then
			local lamppos = EyePos() + EyeAngles():Up() * 4
			local ang = (traceres.HitPos - lamppos):Angle()
			self2.laserpos_old = traceres.HitPos
			ang:RotateAroundAxis(ang:Forward(), math.Rand(-180, 180))
			lamp:SetPos(lamppos)
			lamp:SetAngles(ang)
			lamp:SetColor(col)
			lamp:SetFOV(laserFOV * math.Rand(0.9, 1.1))
			lamp:Update()
		end

		return
	end

	targetent = self

	elemname = self2.GetStatL(self, "LaserSight_WElement", self2.GetStatL(self, "LaserSight_Element"))

	local WorldModelElements = self:GetStatRaw("WorldModelElements", TFA.LatestDataVersion)

	if elemname and WorldModelElements[elemname] and IsValid(WorldModelElements[elemname].curmodel) then
		targetent = WorldModelElements[elemname].curmodel
	end

	att = self2.GetStatL(self, "LaserSightAttachmentWorld", self2.GetStatL(self, "LaserSightAttachment"))

	attname = self2.GetStatL(self, "LaserSightAttachmentWorldName", self2.GetStatL(self, "LaserSightAttachmentName"))

	if attname then
		att = targetent:LookupAttachment(attname)
	end

	if (not att) or att <= 0 then
		self:CleanLaser()

		return
	end

	angpos = targetent:GetAttachment(att)

	if not angpos then
		angpos = targetent:GetAttachment(1)
	end

	if not angpos then
		self:CleanLaser()

		return
	end

	if not IsValid(ply.TFALaserDot) and not IsHolstering(self) then
		local lamp = ProjectedTexture()
		ply.TFALaserDot = lamp
		lamp:SetTexture(laserdot:GetString("$basetexture"))
		lamp:SetFarZ(self2.LaserDistance) -- How far the light should shine
		lamp:SetFOV(laserFOV)
		lamp:SetPos(angpos.Pos)
		lamp:SetAngles(angpos.Ang)
		lamp:SetBrightness(5)
		lamp:SetNearZ(1)
		lamp:SetEnableShadows(false)
		lamp:Update()
	end

	local lamp = ply.TFALaserDot

	if IsValid(lamp) then
		local ang = angpos.Ang
		ang:RotateAroundAxis(ang:Forward(), math.Rand(-180, 180))
		lamp:SetPos(angpos.Pos)
		lamp:SetAngles(ang)
		lamp:SetColor(col)
		lamp:SetFOV(laserFOV * math.Rand(0.9, 1.1))
		lamp:Update()
	end

	traceres = util.QuickTrace(angpos.Pos, angpos.Ang:Forward() * self2.LaserDistance, ply)
	local hpos = traceres.StartPos + angpos.Ang:Forward() * math.min(traceres.HitPos:Distance(angpos.Pos), self2.LaserDistanceVisual )
	render.SetMaterial(laserline)
	render.SetColorModulation(1, 1, 1)
	render.StartBeam(2)
	col.r = math.sqrt(col.r / 255) * 255
	col.g = math.sqrt(col.g / 255) * 255
	col.b = math.sqrt(col.b / 255) * 255
	render.AddBeam(angpos.Pos, self2.LaserBeamWidth or 0.25, 0, col)
	col.a = 0
	render.AddBeam(hpos, 0, 0, col)
	render.EndBeam()
end

function SWEP:CleanLaser()
	local ply = self:GetOwner()

	if IsValid(ply) and IsValid(ply.TFALaserDot) then
		ply.TFALaserDot:Remove()
	end
end
--PATH lua/weapons/tfa_melee_base/shared.lua:
DEFINE_BASECLASS("tfa_bash_base")
SWEP.DrawCrosshair = true
SWEP.SlotPos = 72
SWEP.Slot = 0
SWEP.WeaponLength = 8
SWEP.Secondary.IronSightsEnabled = false
SWEP.Secondary.DisplaySpread = false
SWEP.Primary.Directional = false
SWEP.Primary.Attacks = {}
--[[{
{
["act"] = ACT_VM_HITLEFT, -- Animation; ACT_VM_THINGY, ideally something unique per-sequence
["len"] = 8 * 4.5, -- Trace distance
["src"] = Vector(20,10,0), -- Trace source; X ( +right, -left ), Y ( +forward, -back ), Z ( +up, -down )
["dir"] = Vector(-40,30,0), -- Trace direction/length; X ( +right, -left ), Y ( +forward, -back ), Z ( +up, -down )
["dmg"] = 60, --Damage
["dmgtype"] = DMG_SLASH, --DMG_SLASH,DMG_CRUSH, etc.
["delay"] = 0.2, --Delay
["spr"] = true, --Allow attack while sprinting?
["snd"] = "Swing.Sound", -- Sound ID
["viewpunch"] = Angle(1,-10,0), --viewpunch angle
["end"] = 1, --time before next attack
["hull"] = 10, --Hullsize
["direction"] = "L", --Swing direction
["combotime"] = 0.2 --If you hold attack down, attack this much earlier
},
{
["act"] = ACT_VM_HITRIGHT, -- Animation; ACT_VM_THINGY, ideally something unique per-sequence
["len"] = 8 * 4.5, -- Trace distance
["src"] = Vector(-10,10,0), -- Trace source; X ( +right, -left ), Y ( +forward, -back ), Z ( +up, -down )
["dir"] = Vector(40,30,0), -- Trace direction/length; X ( +right, -left ), Y ( +forward, -back ), Z ( +up, -down )
["dmg"] = 60, --Damage
["dmgtype"] = DMG_SLASH, --DMG_SLASH,DMG_CRUSH, etc.
["delay"] = 0.2, --Delay
["spr"] = true, --Allow attack while sprinting?
["snd"] = "Swing.Sound", -- Sound ID
["viewpunch"] = Angle(1,10,0), --viewpunch angle
["end"] = 1, --time before next attack
["hull"] = 10, --Hullsize
["direction"] = "R", --Swing direction
["combotime"] = 0.2 --If you hold attack down, attack this much earlier
}
}

SWEP.Secondary.Attacks = {
{
["act"] = ACT_VM_MISSCENTER, -- Animation; ACT_VM_THINGY, ideally something unique per-sequence
["src"] = Vector(0,5,0), -- Trace source; X ( +right, -left ), Y ( +forward, -back ), Z ( +up, -down )
["dir"] = Vector(0,50,0), -- Trace direction/length; X ( +right, -left ), Y ( +forward, -back ), Z ( +up, -down )
["dmg"] = 60, --Damage
["dmgtype"] = DMG_SLASH, --DMG_SLASH,DMG_CRUSH, etc.
["delay"] = 0.2, --Delay
["spr"] = true, --Allow attack while sprinting?
["snd"] = "Swing.Sound", -- Sound ID
["viewpunch"] = Angle(5,0,0), --viewpunch angle
["end"] = 1, --time before next attack
["callback"] = function(tbl,wep,tr) end,
["kickback"] = nil--Recoil if u hit something with this activity
}
}
]]
--
SWEP.IsMelee = true
SWEP.Precision = 9 --Traces to use per attack
SWEP.Primary.MaxCombo = 3 --Max amount of times you'll attack by simply holding down the mouse; -1 to unlimit
SWEP.Secondary.MaxCombo = 3 --Max amount of times you'll attack by simply holding down the mouse; -1 to unlimit
SWEP.CanBlock = false

SWEP.BlockAnimation = {
	["in"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_DEPLOY, --Number for act, String/Number for sequence
		["transition"] = true
	},
	--Inward transition
	["loop"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_IDLE_DEPLOYED, --Number for act, String/Number for sequence
		["is_idle"] = true
	},
	--looping animation
	["hit"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_DEPLOYED, --Number for act, String/Number for sequence
		["is_idle"] = true
	},
	--when you get hit and block it
	["out"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_UNDEPLOY, --Number for act, String/Number for sequence
		["transition"] = true
	}
}

--Outward transition
SWEP.BlockDamageTypes = {DMG_SLASH, DMG_CLUB}
SWEP.BlockCone = 135 --Think of the player's view direction as being the middle of a sector, with the sector's angle being this
SWEP.BlockDamageMaximum = 0.1 --Multiply damage by this for a maximumly effective block
SWEP.BlockDamageMinimum = 0.4 --Multiply damage by this for a minimumly effective block
SWEP.BlockTimeWindow = 0.5 --Time to absorb maximum damage
SWEP.BlockTimeFade = 1 --Time for blocking to do minimum damage.  Does not include block window
SWEP.BlockDamageCap = 100
SWEP.BlockSound = ""
SWEP.BlockFadeOut = nil --Override the length of the ["out"] block animation easily
SWEP.BlockFadeOutEnd = 0.2 --In absense of BlockFadeOut, shave this length off of the animation time
SWEP.BlockHoldType = "magic"
SWEP.BlockCanDeflect = true --Can "bounce" bullets off a perfect parry?
SWEP.Secondary.Directional = true
SWEP.Primary.Automatic = true
SWEP.Secondary.Automatic = true
SWEP.ImpactDecal = "ManhackCut"
SWEP.Secondary.CanBash = false
SWEP.Secondary.PrimaryFallback = true
SWEP.DefaultComboTime = 0.2
SWEP.AllowSprintAttack = true
SWEP.Primary.SplitDamage = true
SWEP.Secondary.SplitDamage = true

--[[ START OF BASE CODE ]]
--
SWEP.Primary.ClipSize = -1
SWEP.Primary.Ammo = ""
SWEP.Seed = 0
SWEP.AttackSoundTime = -1
SWEP.VoxSoundTime = -1

SWEP.Primary.DisplayFalloff = false

SWEP.CrosshairConeRecoilOverride = .05

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables(self)

	self:NetworkVarTFA("Bool", "VP")
	self:NetworkVarTFA("Bool", "BashImpulse")

	self:NetworkVarTFA("Float", "VPTime")
	self:NetworkVarTFA("Float", "VPPitch")
	self:NetworkVarTFA("Float", "VPYaw")
	self:NetworkVarTFA("Float", "VPRoll")

	self:NetworkVarTFA("Int", "ComboCount")
	self:NetworkVarTFA("Int", "MelAttackID")

	self:SetMelAttackID(1)
	self:SetVP(false)
	self:SetVPPitch(0)
	self:SetVPYaw(0)
	self:SetVPRoll(0)
	self:SetVPTime(-1)
	self:SetComboCount(0)
end

function SWEP:Deploy()
	self:SetMelAttackID(1)
	self:SetVP(false)
	self:SetVPPitch(0)
	self:SetVPYaw(0)
	self:SetVPRoll(0)
	self:SetVPTime(-1)
	self.up_hat = false
	self:SetComboCount(0)
	self:AddNZAnimations()

	return BaseClass.Deploy(self)
end

function SWEP:AddNZAnimations()
	if self.Primary.Attacks then
		for _, v in pairs(self.Primary.Attacks) do
			if v.act then
				self.DTapActivities[v.act] = true
			end
		end
	end

	if self.Secondary.Attacks then
		for _, v in pairs(self.Secondary.Attacks) do
			if v.act then
				self.DTapActivities[v.act] = true
			end
		end
	end
end

function SWEP:CanInterruptShooting()
	return false
end

local att = {}
local tr = {}
local traceres = {}
local pos, ang, mdl, ski, prop
local fwd, eang, scl, dirv
local strikedir = Vector()
SWEP.hpf = false
SWEP.hpw = false
local lim_up_vec = Vector(1, 1, 0.05)

function SWEP:ApplyForce(ent, force, posv)
	if not IsValid(ent) or not ent.GetPhysicsObjectNum then return end
	if hook.Run("TFAMeleeApplyForce", ent) ~= false then return end

	if ent.GetRagdollEntity and IsValid(ent:GetRagdollEntity()) and ent ~= ent:GetRagdollEntity() then
		ent = ent:GetRagdollEntity()

		timer.Simple(0, function()
			if IsValid(self) and self:OwnerIsValid() and IsValid(ent) then
				self:ApplyForce(ent, force, posv, false)
			end
		end)

		return
	end

	if not IsValid(ent) then return end

	if ent:IsPlayer() or ent:IsNPC() then
		ent:SetVelocity(force * 0.1 * lim_up_vec)
	end

	if ent:GetPhysicsObjectCount() > 1 then
		for i = 0, ent:GetPhysicsObjectCount() - 1 do
			local phys = ent:GetPhysicsObjectNum(i)

			if IsValid(phys) then
				phys:ApplyForceOffset(force / ent:GetPhysicsObjectCount(), posv)
			end
		end
	else
		local phys = ent:GetPhysicsObjectNum(0)

		if IsValid(phys) then
			phys:ApplyForceOffset(force, posv)
		end
	end
end

function SWEP:ApplyDamage(trace, dmginfo, attk)
	local dam, force = dmginfo:GetBaseDamage(), dmginfo:GetDamageForce()
	dmginfo:SetDamagePosition(trace.HitPos)
	dmginfo:SetReportedPosition(trace.StartPos)
	trace.Entity:DispatchTraceAttack(dmginfo, trace, fwd)
	dmginfo:SetDamage(dam)
	dmginfo:SetDamageForce(force)
	-- dmginfo:SetAttacker( self:GetOwner() )
	self:ApplyForce(trace.Entity, dmginfo:GetDamageForce(), trace.HitPos)
	dmginfo:SetDamage(dam)
	dmginfo:SetDamageForce(force)
	-- dmginfo:SetAttacker( self:GetOwner() )
end

function SWEP:SmackEffect(trace, dmg)
	local vSrc = trace.StartPos
	local bFirstTimePredicted = IsFirstTimePredicted()
	local bHitWater = bit.band(util.PointContents(vSrc), MASK_WATER) ~= 0
	local bEndNotWater = bit.band(util.PointContents(trace.HitPos), MASK_WATER) == 0

	local trSplash = bHitWater and bEndNotWater and util.TraceLine({
		start = trace.HitPos,
		endpos = vSrc,
		mask = MASK_WATER
	}) or not (bHitWater or bEndNotWater) and util.TraceLine({
		start = vSrc,
		endpos = trace.HitPos,
		mask = MASK_WATER
	})

	if (trSplash and bFirstTimePredicted) then
		local data = EffectData()
		data:SetOrigin(trSplash.HitPos)
		data:SetScale(1)

		if (bit.band(util.PointContents(trSplash.HitPos), CONTENTS_SLIME) ~= 0) then
			data:SetFlags(1) --FX_WATER_IN_SLIME
		end

		util.Effect("watersplash", data)
	end

	local dam, force, dt = dmg:GetBaseDamage(), dmg:GetDamageForce(), dmg:GetDamageType()

	if (trace.Hit and bFirstTimePredicted and (not trSplash) and self:DoImpactEffect(trace, dt) ~= true) then
		local data = EffectData()
		data:SetOrigin(trace.HitPos)
		data:SetStart(vSrc)
		data:SetSurfaceProp(trace.SurfaceProps)
		data:SetDamageType(dt)
		data:SetHitBox(trace.HitBox)
		data:SetEntity(trace.Entity)
		util.Effect("Impact", data)
	end

	dmg:SetDamage(dam)
	dmg:SetDamageForce(force)
	-- dmg:SetAttacker( self:GetOwner() )
end

local defaultdoorhealth = 250
local cv_doorres = GetConVar("sv_tfa_door_respawn")

function SWEP:MakeDoor(ent, dmginfo)
	pos = ent:GetPos()
	ang = ent:GetAngles()
	mdl = ent:GetModel()
	ski = ent:GetSkin()
	ent:SetNotSolid(true)
	ent:SetNoDraw(true)
	prop = ents.Create("prop_physics")
	prop:SetPos(pos)
	prop:SetAngles(ang)
	prop:SetModel(mdl)
	prop:SetSkin(ski or 0)
	prop:Spawn()
	prop:SetVelocity(dmginfo:GetDamageForce() * 48)
	prop:GetPhysicsObject():ApplyForceOffset(dmginfo:GetDamageForce() * 48, dmginfo:GetDamagePosition())
	if IsValid(dmginfo:GetAttacker()) then
		prop:SetPhysicsAttacker(dmginfo:GetAttacker())
	end
	prop:EmitSound("physics/wood/wood_furniture_break" .. tostring(math.random(1, 2)) .. ".wav", 110, math.random(90, 110))

	if cv_doorres and cv_doorres:GetInt() ~= -1 then
		timer.Create("TFA_DoorRespawner_" .. ent:EntIndex(), cv_doorres:GetFloat(), 1, function()
			if IsValid(prop) then
				prop:Remove()
			end

			if IsValid(ent) then
				ent.TFADoorHealth = defaultdoorhealth
				ent:SetNotSolid(false)
				ent:SetNoDraw(false)
			end
		end)
	end
end

local cv_doordestruction = GetConVar("sv_tfa_melee_doordestruction")

function SWEP:BurstDoor(ent, dmginfo)
	if not ents.Create then return end

	if not cv_doordestruction:GetBool() then return end

	if dmginfo:GetDamage() > 60 and (dmginfo:IsDamageType(DMG_CRUSH) or dmginfo:IsDamageType(DMG_CLUB)) and (ent:GetClass() == "func_door_rotating" or ent:GetClass() == "prop_door_rotating") then
		if dmginfo:GetDamage() > 150 then
			local ply = self:GetOwner()
			self:MakeDoor(ent, dmginfo)
			ply:EmitSound("ambient/materials/door_hit1.wav", 100, math.random(90, 110))
		else
			local ply = self:GetOwner()
			ply:EmitSound("ambient/materials/door_hit1.wav", 100, math.random(90, 110))
			ply.oldname = ply:GetName()
			ply:SetName("bashingpl" .. ply:EntIndex())
			ent:SetKeyValue("Speed", "500")
			ent:SetKeyValue("Open Direction", "Both directions")
			ent:SetKeyValue("opendir", "0")
			ent:Fire("unlock", "", .01)
			ent:Fire("openawayfrom", "bashingpl" .. ply:EntIndex(), .01)

			timer.Simple(0.02, function()
				if IsValid(ply) then
					ply:SetName(ply.oldname)
				end
			end)

			timer.Simple(0.3, function()
				if IsValid(ent) then
					ent:SetKeyValue("Speed", "100")
				end
			end)
		end
	end
end

function SWEP:ThinkNPC()
	local ow = self:GetOwner()
	if ow:IsCurrentSchedule(SCHED_CHASE_ENEMY) then return end
	if ow:IsCurrentSchedule(SCHED_MELEE_ATTACK1) then return end
	if not self.Range then
		local _, t = self:ChoosePrimaryAttack()
		if t and t.range then
			self.Range = t.src:Length() + t.dir:Length()
		else
			self.Range = 80
		end
	end
	local en = ow:GetEnemy()
	if IsValid(en) and en:GetPos():Distance(self:GetPos()) <= self.Range and CurTime() > self:GetNextPrimaryFire() then
		self:PrimaryAttack()
	else
		self:GetOwner():SetSchedule( SCHED_CHASE_ENEMY )
	end
end

function SWEP:Think2(...)
	if not self:VMIV() then return end

	if (not self:GetOwner():KeyDown(IN_ATTACK)) and (not self:GetOwner():KeyDown(IN_ATTACK2)) then
		self:SetComboCount(0)
	end

	if self:GetVP() and CurTime() > self:GetVPTime() then
		self:SetVP(false)
		self:SetVPTime(-1)
		self:GetOwner():ViewPunch(Angle(self:GetVPPitch(), self:GetVPYaw(), self:GetVPRoll()))
	end

	if self.CanBlock then
		local stat = self:GetStatus()

		if self:GetBashImpulse() and TFA.Enum.ReadyStatus[stat] and not self:GetOwner():KeyDown(IN_USE) then
			self:SetStatus(TFA.Enum.STATUS_BLOCKING, math.huge)

			if self.BlockAnimation["in"] then
				self:PlayAnimation(self.BlockAnimation["in"])
			elseif self.BlockAnimation["loop"] then
				self:PlayAnimation(self.BlockAnimation["loop"])
			end

			self.BlockStart = CurTime()
		elseif stat == TFA.Enum.STATUS_BLOCKING and not self:GetBashImpulse() then
			local _, tanim, ttype

			if self.BlockAnimation["out"] then
				_, tanim, ttype = self:PlayAnimation(self.BlockAnimation["out"])
			else
				_, tanim, ttype = self:ChooseIdleAnim()
			end

			self:ScheduleStatus(TFA.Enum.STATUS_BLOCKING_END, self.BlockFadeOut or (self:GetActivityLength(tanim, false, ttype) - self.BlockFadeOutEnd))
		elseif stat == TFA.Enum.STATUS_BLOCKING and CurTime() > self:GetNextIdleAnim() then
			self:ChooseIdleAnim()
		end
	end

	self:StrikeThink()
	BaseClass.Think2(self, ...)
end

function SWEP:ProcessHoldType(...)
	if self:GetStatus() == TFA.Enum.STATUS_BLOCKING then
		self:SetHoldType(self.BlockHoldType or "magic")

		return self.BlockHoldType or "magic"
	else
		return BaseClass.ProcessHoldType(self, ...)
	end
end

function SWEP:GetBlockStart()
	return self.BlockStart or -1
end

function SWEP:ChooseBlockAnimation()
	if self.BlockAnimation["hit"] then
		self:PlayAnimation(self.BlockAnimation["hit"])
	elseif self.BlockAnimation["in"] then
		self:PlayAnimation(self.BlockAnimation["in"])
	end
end

function SWEP:ChooseIdleAnim(...)
	if self.CanBlock and self:GetStatus() == TFA.Enum.STATUS_BLOCKING and self.BlockAnimation["loop"] then
		return self:PlayAnimation(self.BlockAnimation["loop"])
	else
		return BaseClass.ChooseIdleAnim(self, ...)
	end
end

function SWEP:StrikeThink()
	if self:GetSprinting() and not self:GetStatL("AllowSprintAttack", false) then
		self:SetComboCount(0)
		--return
	end

	if self:IsSafety() then
		self:SetComboCount(0)

		return
	end

	if not IsFirstTimePredicted() then return end
	if self:GetStatus() ~= TFA.Enum.STATUS_SHOOTING then return end
	if self.up_hat then return end

	local ind = self:GetMelAttackID() or 1
	local srctbl = ind >= 0 and "Primary" or "Secondary"
	local attackstbl = self:GetStatL(srctbl .. ".Attacks")
	local attack = attackstbl[math.abs(ind)]

	if self.AttackSoundTime ~= -1 and CurTime() > self.AttackSoundTime then
		self:EmitSound(attack.snd)

		if self:GetOwner().Vox then
			self:GetOwner():Vox("bash", 4)
		end

		self.AttackSoundTime = -1
	end

	if self:GetOwner().Vox and self.VoxSoundTime ~= -1 and CurTime() > self.VoxSoundTime - self:GetOwner():Ping() * 0.001 then
		if self:GetOwner().Vox then
			self:GetOwner():Vox("bash", 4)
		end

		self.VoxSoundTime = -1
	end

	if CurTime() > self:GetStatusEnd() then
		self.DamageType = attack.dmgtype
		--Just attacked, so don't do it again
		self.up_hat = true
		self:SetStatus(TFA.Enum.STATUS_IDLE, math.huge)

		if self:GetComboCount() > 0 then
			self:SetNextPrimaryFire(self:GetNextPrimaryFire() - (attack.combotime or 0))
			self:SetNextSecondaryFire(self:GetNextSecondaryFire() - (attack.combotime or 0))
		end

		self:Strike(attack, self.Precision)
	end
end

local function TraceHitFlesh(b)
	return b.MatType == MAT_FLESH or b.MatType == MAT_ALIENFLESH or (IsValid(b.Entity) and b.Entity.IsNPC and (b.Entity:IsNPC() or b.Entity:IsPlayer() or b.Entity:IsRagdoll()))
end

local cv_dmg_mult = GetConVar("sv_tfa_damage_multiplier")
local cv_dmg_mult_npc = GetConVar("sv_tfa_damage_multiplier_npc")
local cv_dmg_mult_min = GetConVar("sv_tfa_damage_mult_min")
local cv_dmg_mult_max = GetConVar("sv_tfa_damage_mult_max")

function SWEP:Strike(attk, precision)
	local hitWorld, hitNonWorld, hitFlesh, needsCB
	local distance, direction, maxhull
	local ow = self:GetOwner()
	if not IsValid(ow) then return end
	distance = attk.len
	direction = attk.dir
	maxhull = attk.hull
	eang = ow:EyeAngles()
	fwd = ow:EyeAngles():Forward()
	tr.start = ow:GetShootPos()
	scl = direction:Length() / precision / 2
	tr.maxs = Vector(scl, scl, scl)
	tr.mins = -tr.maxs
	tr.mask = MASK_SHOT
	tr.filter = {self, ow}

	hitWorld = false
	hitNonWorld = false
	hitFlesh = false

	if attk.callback then
		needsCB = true
	else
		needsCB = false
	end

	if maxhull then
		tr.maxs.x = math.min(tr.maxs.x, maxhull / 2)
		tr.maxs.y = math.min(tr.maxs.y, maxhull / 2)
		tr.maxs.z = math.min(tr.maxs.z, maxhull / 2)
		tr.mins = -tr.maxs
	end

	strikedir:Zero()
	strikedir:Add(direction.x * eang:Right())
	strikedir:Add(direction.y * eang:Forward())
	strikedir:Add(direction.z * eang:Up())
	local strikedirfull = strikedir * 1

	if ow:IsPlayer() and ow:IsAdmin() and GetConVarNumber("developer") > 0 then
		local spos, epos = tr.start + Vector(0, 0, -1) + fwd * distance / 2 - strikedirfull / 2, tr.start + Vector(0, 0, -1) + fwd * distance / 2 + strikedirfull / 2
		debugoverlay.Line(spos, epos, 5, Color(255, 0, 0))
		debugoverlay.Cross(spos, 8, 5, Color(0, 255, 0), true)
		debugoverlay.Cross(epos, 4, 5, Color(0, 255, 255), true)
	end

	if SERVER and not game.SinglePlayer() and ow:IsPlayer() then
		ow:LagCompensation(true)
	end

	local totalResults = {}
	for i = 1, precision do
		dirv = LerpVector((i - 0.5) / precision, -direction / 2, direction / 2)
		strikedir:Zero()
		strikedir:Add(dirv.x * eang:Right())
		strikedir:Add(dirv.y * eang:Forward())
		strikedir:Add(dirv.z * eang:Up())
		tr.endpos = tr.start + distance * fwd + strikedir
		traceres = util.TraceLine(tr)
		table.insert(totalResults, traceres)
	end

	if SERVER and not game.SinglePlayer() and ow:IsPlayer() then
		ow:LagCompensation(false)
	end

	local basedmg = attk.dmg

	local ind = self:GetMelAttackID() or 1
	local srctbl = ind >= 0 and "Primary" or "Secondary"
	if not self:GetStatL(srctbl .. ".SplitDamage") or not basedmg then
		basedmg = self:GetStatL(srctbl .. ".Damage")
	end

	local dmg = basedmg * util.SharedRandom("TFA_Melee_RandomDamageMult" .. CurTime(), cv_dmg_mult_min:GetFloat(), cv_dmg_mult_max:GetFloat(), self:EntIndex())
	if ow:IsNPC() then
		dmg = dmg * cv_dmg_mult_npc:GetFloat()
	else
		dmg = dmg * cv_dmg_mult:GetFloat()
	end

	local forcevec = strikedirfull:GetNormalized() * (attk.force or basedmg / 4) * 128
	local damage = DamageInfo()
	damage:SetAttacker(self:GetOwner())
	damage:SetInflictor(self)
	damage:SetDamage(dmg)
	damage:SetDamageType(attk.dmgtype or DMG_SLASH)
	damage:SetDamageForce(forcevec)
	local fleshHits = 0

	--Handle flesh
	for _, v in ipairs(totalResults) do
		if v.Hit and IsValid(v.Entity) and TraceHitFlesh(v) and (not v.Entity.TFA_HasMeleeHit) then
			self:ApplyDamage(v, damage, attk)
			self:SmackEffect(v, damage)
			v.Entity.TFA_HasMeleeHit = true
			fleshHits = fleshHits + 1
			if fleshHits >= (attk.maxhits or 3) then break end

			if attk.hitflesh and not hitFlesh then
				self:EmitSoundNet(attk.hitflesh)
			end

			if attk.callback and needsCB then
				attk.callback(attk, self, v)
				needsCB = false
			end

			hitFlesh = true
		end
		--debugoverlay.Sphere( v.HitPos, 5, 5, color_white )
	end

	--Handle non-world
	for _, v in ipairs(totalResults) do
		if v.Hit and (not TraceHitFlesh(v)) and (not v.Entity.TFA_HasMeleeHit) then
			self:ApplyDamage(v, damage, attk)
			v.Entity.TFA_HasMeleeHit = true

			if not hitNonWorld then
				self:SmackEffect(v, damage)

				if attk.hitworld and not hitFlesh then
					self:EmitSoundNet(attk.hitworld)
				end

				if attk.callback and needsCB then
					attk.callback(attk, self, v)
					needsCB = false
				end

				self:BurstDoor(v.Entity, damage)
				hitNonWorld = true
			end
		end
	end

	-- Handle world
	if not hitNonWorld and not hitFlesh then
		for _, v in ipairs(totalResults) do
			if v.Hit and v.HitWorld and not hitWorld then
				hitWorld = true

				if attk.hitworld then
					self:EmitSoundNet(attk.hitworld)
				end

				self:SmackEffect(v, damage)

				if attk.callback and needsCB then
					attk.callback(attk, self, v)
					needsCB = false
				end
			end
		end
	end

	--Handle empty + cleanup
	for _, v in ipairs(totalResults) do
		if needsCB then
			attk.callback(attk, self, v)
			needsCB = false
		end

		if IsValid(v.Entity) then
			v.Entity.TFA_HasMeleeHit = false
		end
	end

	if attk.kickback and (hitFlesh or hitNonWorld or hitWorld) then
		self:SendViewModelAnim(attk.kickback)
	end
end

function SWEP:PlaySwing(act)
	self:SendViewModelAnim(act)

	return true, act
end

local lvec = Vector(0, 0, 0)
function SWEP:ChooseAttack(tblName)
	local attacks = self:GetStatL(tblName .. ".Attacks")
	if not attacks or #attacks <= 0 then return -1 end

	local keys = table.GetKeys(attacks)
	table.RemoveByValue(keys, "BaseClass")
	if #keys <= 0 then return -1 end

	local ply = self:GetOwner()
	local isdir = self:GetStatL(tblName .. ".Directional") and IsValid(ply) and ply:IsPlayer()
	local founddir = false
	local foundkeys = {}

	if isdir then
		lvec.x = 0
		lvec.y = 0

		if ply:KeyDown(IN_MOVERIGHT) then
			lvec.y = lvec.y - 1
		end

		if ply:KeyDown(IN_MOVELEFT) then
			lvec.y = lvec.y + 1
		end

		if ply:KeyDown(IN_FORWARD) or ply:KeyDown(IN_JUMP) then
			lvec.x = lvec.x + 1
		end

		if ply:KeyDown(IN_BACK) or ply:KeyDown(IN_DUCK) then
			lvec.x = lvec.x - 1
		end

		local targ = ""
		if lvec.y > 0.3 then
			targ = "L"
		elseif lvec.y < -0.3 then
			targ = "R"
		elseif lvec.x > 0.5 then
			targ = "F"
		elseif lvec.x < -0.1 then
			targ = "B"
		end

		for k, v in pairs(attacks) do
			if (not self:GetSprinting() or v.spr) and v.direction and string.find(v.direction, targ) then
				founddir = true

				table.insert(foundkeys, k)
			end
		end
	end

	if not isdir or #foundkeys <= 0 or not founddir then
		for k, v in pairs(attacks) do
			if (not self:GetSprinting() or v.spr) and v.dmg then
				table.insert(foundkeys, k)
			end
		end
	end

	if #foundkeys <= 0 then return 0 end
	local key = foundkeys[self:SharedRandom(1, #foundkeys, tblName .. "Attack")]
	if not key then return 0 end

	return key, attacks[key]
end

function SWEP:ChoosePrimaryAttack()
	return self:ChooseAttack("Primary")
end

function SWEP:ChooseSecondaryAttack()
	return self:ChooseAttack("Secondary")
end

function SWEP:PrimaryAttack()
	local ow = self:GetOwner()

	if IsValid(ow) and ow:IsNPC() then
		local _, attk = self:ChoosePrimaryAttack()
		if not attk then return end
		local owv = self:GetOwner()

		timer.Simple(0.5, function()
			if IsValid(self) and IsValid(owv) and owv:IsCurrentSchedule(SCHED_MELEE_ATTACK1) then
				self:Strike(attk, 5)
			end
		end)

		self:SetNextPrimaryFire(CurTime() + attk["end"] or 1)

		timer.Simple(self:GetNextPrimaryFire() - CurTime(), function()
			if IsValid(owv) then
				owv:ClearSchedule()
			end
		end)

		self:GetOwner():SetSchedule(SCHED_MELEE_ATTACK1)
		return
	end

	if self:GetSprinting() and not self:GetStatL("AllowSprintAttack", false) then return end
	if self:IsSafety() then return end
	if not self:VMIV() then return end
	if CurTime() <= self:GetNextPrimaryFire() then return end
	if not TFA.Enum.ReadyStatus[self:GetStatus()] then return end

	local maxcombo = self:GetStatL("Primary.MaxCombo", 0)
	if maxcombo > 0 and self:GetComboCount() >= maxcombo then return end

	local ind, attack = self:ChoosePrimaryAttack()
	if not attack then return end

	--We have attack isolated, begin attack logic
	self:PlaySwing(attack.act)

	if not attack.snd_delay or attack.snd_delay <= 0 then
		if IsFirstTimePredicted() then
			self:EmitSound(attack.snd)

			if self:GetOwner().Vox then
				self:GetOwner():Vox("bash", 4)
			end
		end

		self:GetOwner():ViewPunch(attack.viewpunch)
	elseif attack.snd_delay then
		if IsFirstTimePredicted() then
			self.AttackSoundTime = CurTime() + attack.snd_delay / self:GetAnimationRate(attack.act)
			self.VoxSoundTime = CurTime() + attack.snd_delay / self:GetAnimationRate(attack.act)
		end

		--[[
		timer.Simple(attack.snd_delay, function()
			if IsValid(self) and self:IsValid() and SERVER then
				self:EmitSound(attack.snd)

				if self:OwnerIsValid() and self:GetOwner().Vox then
					self:GetOwner():Vox("bash", 4)
				end
			end
		end)
		]]
		--
		self:SetVP(true)
		self:SetVPPitch(attack.viewpunch.p)
		self:SetVPYaw(attack.viewpunch.y)
		self:SetVPRoll(attack.viewpunch.r)
		self:SetVPTime(CurTime() + attack.snd_delay / self:GetAnimationRate(attack.act))
		self:GetOwner():ViewPunch(-Angle(attack.viewpunch.p / 2, attack.viewpunch.y / 2, attack.viewpunch.r / 2))
	end

	self.up_hat = false
	self:ScheduleStatus(TFA.Enum.STATUS_SHOOTING, attack.delay / self:GetAnimationRate(attack.act))
	self:SetMelAttackID(ind)
	self:SetNextPrimaryFire(CurTime() + attack["end"] / self:GetAnimationRate(attack.act))
	self:GetOwner():SetAnimation(PLAYER_ATTACK1)
	self:SetComboCount(self:GetComboCount() + 1)
end

function SWEP:SecondaryAttack()
	if self:GetSprinting() and not self:GetStatL("AllowSprintAttack", false) then return end
	if self:IsSafety() then return end
	if not self:VMIV() then return end
	if CurTime() <= self:GetNextPrimaryFire() then return end
	if not TFA.Enum.ReadyStatus[self:GetStatus()] then return end

	local maxcombo = self:GetStatL("Secondary.MaxCombo", 0)
	if maxcombo > 0 and self:GetComboCount() >= maxcombo then return end

	local ind, attack = self:ChooseSecondaryAttack()
	if attack then
		ind = -ind
	elseif ind < 0 and self:GetStatL("Secondary.PrimaryFallback") then
		ind, attack = self:ChoosePrimaryAttack()
	end
	if not attack then return end

	--We have attack isolated, begin attack logic
	self:PlaySwing(attack.act)

	if not attack.snd_delay or attack.snd_delay <= 0 then
		if IsFirstTimePredicted() then
			self:EmitSound(attack.snd)

			if self:GetOwner().Vox then
				self:GetOwner():Vox("bash", 4)
			end
		end

		self:GetOwner():ViewPunch(attack.viewpunch)
	elseif attack.snd_delay then
		if IsFirstTimePredicted() then
			self.AttackSoundTime = CurTime() + attack.snd_delay / self:GetAnimationRate(attack.act)
			self.VoxSoundTime = CurTime() + attack.snd_delay / self:GetAnimationRate(attack.act)
		end

		--[[
		timer.Simple(attack.snd_delay, function()
			if IsValid(self) and self:IsValid() and SERVER then
				self:EmitSound(attack.snd)

				if self:OwnerIsValid() and self:GetOwner().Vox then
					self:GetOwner():Vox("bash", 4)
				end
			end
		end)
		]]
		--
		self:SetVP(true)
		self:SetVPPitch(attack.viewpunch.p)
		self:SetVPYaw(attack.viewpunch.y)
		self:SetVPRoll(attack.viewpunch.r)
		self:SetVPTime(CurTime() + attack.snd_delay / self:GetAnimationRate(attack.act))
		self:GetOwner():ViewPunch(-Angle(attack.viewpunch.p / 2, attack.viewpunch.y / 2, attack.viewpunch.r / 2))
	end

	self.up_hat = false
	self:ScheduleStatus(TFA.Enum.STATUS_SHOOTING, attack.delay / self:GetAnimationRate(attack.act))
	self:SetMelAttackID(ind)
	self:SetNextPrimaryFire(CurTime() + attack["end"] / self:GetAnimationRate(attack.act))
	self:GetOwner():SetAnimation(PLAYER_ATTACK1)
	self:SetComboCount(self:GetComboCount() + 1)
end

function SWEP:AltAttack()
	if self.CanBlock then
		if self:GetStatL("Secondary.CanBash") and self.CanBlock and self:GetOwner():KeyDown(IN_USE) then
			BaseClass.AltAttack(self)

			return
		end
	else
		if not self:VMIV() then return end
		if not TFA.Enum.ReadyStatus[self:GetStatus()] then return end
		if not self:GetStatL("Secondary.CanBash") then return end
		if self:IsSafety() then return end

		return BaseClass.AltAttack(self)
	end
end

function SWEP:Reload(released, ovr, ...)
	if not self:VMIV() then return end
	if ovr then return BaseClass.Reload(self, released, ...) end

	if self:GetOwner().GetInfoNum and self:GetOwner():GetInfoNum("cl_tfa_keys_inspect", 0) > 0 then
		return
	end

	if (self.SequenceEnabled[ACT_VM_FIDGET] or self.InspectionActions) and self:GetStatus() == TFA.Enum.STATUS_IDLE then
		local _, tanim, ttype = self:ChooseInspectAnim()
		self:ScheduleStatus(TFA.Enum.STATUS_FIDGET, self:GetActivityLength(tanim, false, ttype))
	end
end

function SWEP:CycleSafety()
end

TFA.FillMissingMetaValues(SWEP)

--PATH lua/weapons/tfa_nade_base.lua:
if SERVER then
	AddCSLuaFile()
end

local CurTime = CurTime
local sp = game.SinglePlayer()

DEFINE_BASECLASS("tfa_gun_base")
SWEP.DrawCrosshair = true
SWEP.Type = "Grenade"
SWEP.IsGrenade = true
SWEP.MuzzleFlashEffect = ""
SWEP.Secondary.IronSightsEnabled = false
SWEP.Delay = 0.3 -- Delay to fire entity
SWEP.Delay_Underhand = 0.3 -- Delay to fire entity when underhand
SWEP.Primary.Round = "" -- Nade Entity
SWEP.Velocity = 550 -- Entity Velocity
SWEP.Underhanded = false
SWEP.DisableIdleAnimations = true
SWEP.IronSightsPosition = Vector(5,0,0)
SWEP.IronSightsAngle = Vector(0,0,0)
SWEP.Callback = {}

SWEP.AllowUnderhanded = true

SWEP.AllowSprintAttack = true

local nzombies = nil

function SWEP:Initialize()
	if nzombies == nil then
		nzombies = engine.ActiveGamemode() == "nzombies"
	end

	self.ProjectileEntity = self.ProjectileEntity or self.Primary.Round -- Entity to shoot
	self.ProjectileVelocity = self.Velocity or 550  -- Entity to shoot's velocity
	self.ProjectileModel = nil                                          -- Entity to shoot's model

	self:SetNW2Bool("Underhanded", false)

	BaseClass.Initialize(self)
end

local cl_defaultweapon = GetConVar("cl_defaultweapon")

function SWEP:SwitchToPreviousWeapon()
	local wep = LocalPlayer():GetPreviousWeapon()

	if IsValid(wep) and wep:IsWeapon() and wep:GetOwner() == LocalPlayer() then
		input.SelectWeapon(wep)
	else
		wep = LocalPlayer():GetWeapon(cl_defaultweapon:GetString())

		if IsValid(wep) then
			input.SelectWeapon(wep)
		else
			local _
			_, wep = next(LocalPlayer():GetWeapons())

			if IsValid(wep) then
				input.SelectWeapon(wep)
			end
		end
	end
end

function SWEP:Deploy()
	if self:Clip1() <= 0 then
		if self:Ammo1() <= 0 then
			if self:GetOwner():IsPlayer() then
				if CLIENT and not sp then
					self:SwitchToPreviousWeapon()
				elseif SERVER and not nzombies then
					if sp then
						self:CallOnClient("SwitchToPreviousWeapon", "")
						local ply = self:GetOwner()
						local classname = self:GetClass()
						timer.Simple(0, function() ply:StripWeapon(classname) end)
					else
						self:GetOwner():StripWeapon(self:GetClass())
						return
					end
				end
			end
		else
			self:TakePrimaryAmmo(1, true)
			self:SetClip1(1)
		end
	end

	self:SetNW2Bool("Underhanded", false)

	self.oldang = self:GetOwner():EyeAngles()
	self.anga = Angle()
	self.angb = Angle()
	self.angc = Angle()

	self:CleanParticles()

	return BaseClass.Deploy(self)
end

function SWEP:ChoosePullAnim()
	if not self:OwnerIsValid() then return end

	if self.Callback.ChoosePullAnim then
		self.Callback.ChoosePullAnim(self)
	end

	if self:GetOwner():IsPlayer() then
		self:GetOwner():SetAnimation(PLAYER_RELOAD)
	end

	self:SendViewModelAnim(ACT_VM_PULLPIN)

	if sp then
		self:CallOnClient("AnimForce", ACT_VM_PULLPIN)
	end

	return true, ACT_VM_PULLPIN
end

function SWEP:ChooseShootAnim()
	if not self:OwnerIsValid() then return end

	if self.Callback.ChooseShootAnim then
		self.Callback.ChooseShootAnim(self)
	end

	if self:GetOwner():IsPlayer() then
		self:GetOwner():SetAnimation(PLAYER_ATTACK1)
	end

	local tanim = self:GetNW2Bool("Underhanded", false) and self.SequenceEnabled[ACT_VM_RELEASE] and ACT_VM_RELEASE or ACT_VM_THROW
	self:SendViewModelAnim(tanim)

	if sp then
		self:CallOnClient("AnimForce", tanim)
	end

	return true, tanim
end

function SWEP:ThrowStart()
	if self:Clip1() <= 0 then return end

	local success, tanim, animType = self:ChooseShootAnim()

	local delay = self:GetNW2Bool("Underhanded", false) and self.Delay_Underhand or self.Delay
	self:ScheduleStatus(TFA.Enum.STATUS_GRENADE_THROW, delay)

	if success then
		self.LastNadeAnim = tanim
		self.LastNadeAnimType = animType
		self.LastNadeDelay = delay
	end
end

function SWEP:Throw()
	if self:Clip1() <= 0 then return end
	self.ProjectileVelocity = (self:GetNW2Bool("Underhanded", false) and self.Velocity_Underhand) or ((self.Velocity or 550) / 1.5)

	self:TakePrimaryAmmo(1)
	self:ShootBulletInformation()

	if self.LastNadeAnim then
		local len = self:GetActivityLength(self.LastNadeAnim, true, self.LastNadeAnimType)
		self:ScheduleStatus(TFA.Enum.STATUS_GRENADE_THROW_WAIT, len - (self.LastNadeDelay or len))
	end
end

function SWEP:Think2(...)
	if not self:OwnerIsValid() then return end

	local stat = self:GetStatus()

	-- This is the best place to do this since Think2 is called inside FinishMove
	self:SetNW2Bool("Underhanded", self.AllowUnderhanded and self:KeyDown(IN_ATTACK2))

	local statusend = CurTime() >= self:GetStatusEnd()

	if stat == TFA.Enum.STATUS_GRENADE_PULL and statusend then
		stat = TFA.Enum.STATUS_GRENADE_READY
		self:SetStatus(stat, math.huge)
	end

	if stat == TFA.Enum.STATUS_GRENADE_READY and (self:GetOwner():IsNPC() or not self:KeyDown(IN_ATTACK2) and not self:KeyDown(IN_ATTACK)) then
		self:ThrowStart()
	end

	if stat == TFA.Enum.STATUS_GRENADE_THROW and statusend then
		self:Throw()
	end

	if stat == TFA.Enum.STATUS_GRENADE_THROW_WAIT and statusend then
		self:Deploy()
	end

	return BaseClass.Think2(self, ...)
end

function SWEP:PrimaryAttack()
	if self:Clip1() <= 0 or not self:OwnerIsValid() or not self:CanFire() then return end

	local _, tanim = self:ChoosePullAnim()

	self:ScheduleStatus(TFA.Enum.STATUS_GRENADE_PULL, self:GetActivityLength(tanim))
	self:SetNW2Bool("Underhanded", false)
end

function SWEP:SecondaryAttack()
	self:PrimaryAttack()
	self:SetNW2Bool("Underhanded", self.AllowUnderhanded)
end

function SWEP:Reload()
	if self:Clip1() <= 0 and self:OwnerIsValid() and self:CanFire() then
		self:Deploy()
	end
end

function SWEP:CanFire() -- what
	if not self:CanPrimaryAttack() then return false end
	return true
end

function SWEP:ChooseIdleAnim(...)
	if self:GetStatus() == TFA.Enum.STATUS_GRENADE_READY then return end
	return BaseClass.ChooseIdleAnim(self, ...)
end

SWEP.CrosshairConeRecoilOverride = .05

TFA.FillMissingMetaValues(SWEP)

--PATH gamemodes/starwarsrp/entities/weapons/unarrest_stick/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.Slot = 1
    SWEP.SlotPos = 3
end

DEFINE_BASECLASS("stick_base")

SWEP.Instructions = "Left click to unarrest\nRight click to switch batons"
SWEP.IsDarkRPUnarrestStick = true

SWEP.PrintName = "Unarrest Baton"
SWEP.Spawnable = true
SWEP.Category = "DarkRP (Utility)"

SWEP.StickColor = Color(0, 255, 0)

DarkRP.hookStub{
    name = "canUnarrest",
    description = "Whether someone can unarrest another player.",
    parameters = {
        {
            name = "unarrester",
            description = "The player trying to unarrest someone.",
            type = "Player"
        },
        {
            name = "unarrestee",
            description = "The player being unarrested.",
            type = "Player"
        }
    },
    returns = {
        {
            name = "canUnarrest",
            description = "A yes or no as to whether the player can unarrest the other player.",
            type = "boolean"
        },
        {
            name = "message",
            description = "The message that is shown when they can't unarrest the player.",
            type = "string"
        }
    },
    realm = "Server"
}

-- Default for canUnarrest hook
local hookCanUnarrest = {canUnarrest = fp{fn.Id, true}}

function SWEP:Deploy()
    self.Switched = true
    return BaseClass.Deploy(self)
end

function SWEP:PrimaryAttack()
    BaseClass.PrimaryAttack(self)

    if CLIENT then return end

    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    Owner:LagCompensation(true)
    local trace = util.QuickTrace(Owner:EyePos(), Owner:GetAimVector() * 90, {Owner})
    Owner:LagCompensation(false)

    local ent = trace.Entity
    if IsValid(ent) and ent.onUnArrestStickUsed then
        ent:onUnArrestStickUsed(Owner)
        return
    end

    ent = Owner:getEyeSightHitEntity(nil, nil, function(p) return p ~= Owner and p:IsPlayer() and p:Alive() and p:IsSolid() end)
    if not ent then return end

    local stickRange = self.stickRange * self.stickRange
    if not IsValid(ent) or not ent:IsPlayer() or (Owner:EyePos():DistToSqr(ent:GetPos()) > stickRange) or not ent:getDarkRPVar("Arrested") then
        return
    end

    local canUnarrest, message = hook.Call("canUnarrest", hookCanUnarrest, Owner, ent)
    if not canUnarrest then
        if message then DarkRP.notify(Owner, 1, 5, message) end
        return
    end

    ent:unArrest(Owner)
    DarkRP.notify(ent, 0, 4, DarkRP.getPhrase("youre_unarrested_by", Owner:Nick()))

    if Owner.SteamName then
        DarkRP.log(Owner:Nick() .. " (" .. Owner:SteamID() .. ") unarrested " .. ent:Nick(), Color(0, 255, 255))
    end
end

function SWEP:startDarkRPCommand(usrcmd)
    if game.SinglePlayer() and CLIENT then return end
    if usrcmd:KeyDown(IN_ATTACK2) then
        if not self.Switched and self:GetOwner():HasWeapon("arrest_stick") then
            usrcmd:SelectWeapon(self:GetOwner():GetWeapon("arrest_stick"))
        end
    else
        self.Switched = false
    end
end

--PATH gamemodes/starwarsrp/entities/weapons/weapon_ak472/shared.lua:
return gluapack()()
--PATH addons/[bronie] kajdanki/lua/weapons/weapon_cuff_shackles.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- weapon_cuff_shackles.lua SHARED --
--                                 --
-- Strongest handcuffs available.  --
-------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_cuff_base"

SWEP.Category = "Handcuffs"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Strong metal shackles."

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.AdminSpawnable = true

SWEP.Slot = 3
SWEP.PrintName = "Shackles"

//
// Handcuff Vars
SWEP.CuffTime = 1.0 // Seconds to handcuff
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "phoenix_storms/cube"
SWEP.CuffRope = "cable/cable2"
SWEP.CuffStrength = 1.4
SWEP.CuffRegen = 0.8
SWEP.RopeLength = 0
SWEP.CuffReusable = false

SWEP.CuffBlindfold = false
SWEP.CuffGag = false

SWEP.CuffStrengthVariance = 0.4 // Randomise strangth
SWEP.CuffRegenVariance = 0.1 // Randomise regen

--PATH gamemodes/starwarsrp/entities/weapons/weapon_deagle2/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.Author = "DarkRP Developers"
    SWEP.Slot = 1
    SWEP.SlotPos = 1
    SWEP.IconLetter = "f"

    killicon.AddFont("weapon_deagle2", "CSKillIcons", SWEP.IconLetter, Color(255, 80, 0, 255))
end

SWEP.Base = "weapon_cs_base2"

SWEP.PrintName = "Deagle"
SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.Category = "DarkRP (Weapon)"

SWEP.ViewModel = "models/weapons/cstrike/c_pist_deagle.mdl"
SWEP.WorldModel = "models/weapons/w_pist_deagle.mdl"

SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.HoldType = "pistol"
SWEP.LoweredHoldType = "normal"

SWEP.Primary.Sound = Sound("Weapon_Deagle.Single")
SWEP.Primary.Recoil = 5.1
SWEP.Primary.Damage = 25
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0.01
SWEP.Primary.ClipSize = 7
SWEP.Primary.Delay = 0.3
SWEP.Primary.DefaultClip = 7
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "pistol"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.IronSightsPos = Vector(-6.35, -7.5, 2.02)
SWEP.IronSightsAng = Vector(0.51, 0, 0)

--PATH lua/weapons/weapon_extinguisher_infinite.lua:

SWEP.PrintName = "Extinguisher (Infinite)"
SWEP.Author = "Robotboy655"
SWEP.Category = "Robotboy655's Weapons"
SWEP.Contact = "http://steamcommunity.com/profiles/76561197996891752"
SWEP.Purpose = "To extinguish fire!"
SWEP.Instructions = "Shoot into a fire, to extinguish it."
SWEP.AdminOnly = true
SWEP.Base = "weapon_extinguisher"

SWEP.SlotPos = 36
SWEP.IsInfinite = true
SWEP.Spawnable = true

SWEP.Primary.Ammo = "none"

function SWEP:Ammo1()
	return 500
end

if ( SERVER ) then return end

SWEP.WepSelectIcon = Material( "icons/rb655_extinguisher_icon_inf.png" )

function SWEP:CustomAmmoDisplay()
	return { Draw = false }
end

--PATH lua/weapons/weapon_grapplehook.lua:
AddCSLuaFile()

CreateConVar("grapple_distance", -1, bit.bor(FCVAR_GAMEDLL, FCVAR_NOTIFY, FCVAR_SERVER_CAN_EXECUTE),"max distance which its allowed to fire")
CreateConVar("grapple_latch_speed", 5000, bit.bor(FCVAR_GAMEDLL, FCVAR_NOTIFY, FCVAR_SERVER_CAN_EXECUTE),"speed at which the rope flies to its target")
CreateConVar("grapple_speed", 100, bit.bor(FCVAR_GAMEDLL, FCVAR_NOTIFY, FCVAR_SERVER_CAN_EXECUTE),"speed at which the player gets pulled to the destination")
CreateConVar("grapple_damage_min", 15, bit.bor(FCVAR_GAMEDLL, FCVAR_NOTIFY, FCVAR_SERVER_CAN_EXECUTE),"how much damage should it do minimal to hooked objects")
CreateConVar("grapple_damage_max", 25, bit.bor(FCVAR_GAMEDLL, FCVAR_NOTIFY, FCVAR_SERVER_CAN_EXECUTE),"how much damage should it do maximal to hooked objects")
CreateConVar("grapple_damage_enable", 1, bit.bor(FCVAR_GAMEDLL, FCVAR_NOTIFY, FCVAR_SERVER_CAN_EXECUTE),"should hooked objects take damage?")
CreateConVar("grapple_play_sounds", 1, bit.bor(FCVAR_GAMEDLL, FCVAR_NOTIFY, FCVAR_SERVER_CAN_EXECUTE),"should hooked objects and the weapon make sounds?")
CreateConVar("grapple_ignore_sky", 1, bit.bor(FCVAR_GAMEDLL, FCVAR_NOTIFY, FCVAR_SERVER_CAN_EXECUTE),"can the grapple hook onto the sky?")

if CLIENT then
	SWEP.DrawWeaponInfoBox	= false
	SWEP.BounceWeaponIcon	= false 

	killicon.Add("weapon_grapplehook","effects/killicons/weapon_grapplehook",Color(255,255,255))
	SWEP.WepSelectIcon	= surface.GetTextureID("hud/swepicons/weapon_grapplehook/icon")
else -- SERVER
	resource.AddWorkshop("1696595790") -- download tf2 crap to morons that dont own it
end

SWEP.Author			= ""
SWEP.Contact		= ""
SWEP.Purpose		= "A Grappling Hook"
SWEP.Instructions	= "Left click to fire"

SWEP.Category			= "Team Fortress 2"
SWEP.PrintName			= "Grappling Hook"
SWEP.Slot				= 3
SWEP.SlotPos			= 2
SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= true
SWEP.ViewModelFOV = 70
SWEP.ViewModelFlip = false
SWEP.UseHands = true
SWEP.ViewModel = "models/weapons/c_pistol.mdl"
SWEP.WorldModel = "models/weapons/w_pistol.mdl"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = true

SWEP.HoldType			= "pistol"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true
SWEP.AdminOnly          = false

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

local sndGrappleHit		= Sound("weapons/grappling_hook_impact_default.wav")
local sndGrappleHitFlesh= Sound("weapons/grappling_hook_impact_flesh.wav")
local sndGrappleShoot	= Sound("weapons/grappling_hook_shoot.wav")
local sndGrappleReel	= Sound("weapons/grappling_hook_reel_start.wav")
local sndGrappleAbort	= Sound("weapons/grappling_hook_reel_stop.wav")

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(9.892, -0.811, 2.532), angle = Angle(-10.782, -7.685, 14.444) },
	["ValveBiped.square"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.clip"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, -30), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["v_element"] = { type = "Model", model = "models/weapons/c_models/c_grappling_hook/c_grappling_hook.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.032, 1.476, -1.58), angle = Angle(0, 0, 177.921), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["v_element2"] = { type = "Model", model = "models/props_c17/pulleywheels_large01.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(9.571, 3.808, -1.502), angle = Angle(-1.657, 89.515, 0), size = Vector(0.09, 0.15, 0.15), color = Color(255, 255, 255, 255), surpresslightning = false, material = "mm_materials/zinc01_low2", skin = 0, bodygroup = {} },
	["v_element3"] = { type = "Model", model = "models/props_c17/pulleywheels_large01.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(9.571, 3.808, -1.502), angle = Angle(-1.657, 89.515, 45), size = Vector(0.09, 0.15, 0.15), color = Color(255, 255, 255, 255), surpresslightning = false, material = "mm_materials/zinc01_low2", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["w_element"] = { type = "Model", model = "models/weapons/c_models/c_grappling_hook/c_grappling_hook.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.709, 1.886, -2), angle = Angle(0, 0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

function SWEP:Initialize()
	nextshottime = CurTime()
	self:SetHoldType(self.HoldType)
	self:SetWeaponHoldType(self.HoldType)
	self.zoomed = false
	self.initialhit = false
	self.Tr = nil
	
	self.Idle = 0
	self.IdleTimer = CurTime() + 1
	
	if CLIENT then
	
		-- Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )
        self:SetWeaponHoldType( self.HoldType )
		
		self:CreateModels(self.VElements) -- create viewmodels
		self:CreateModels(self.WElements) -- create worldmodels
		
		-- init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				-- Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					-- we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					-- ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					-- however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end

end

----------------------------------------------------
if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			-- when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			

			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r -- Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				-- make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			-- !! WORKAROUND !! --
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			-- !! ----------- !! --
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				-- !! WORKAROUND !! --
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				-- !! ----------- !! --
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end


	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v)
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end
----------------------------------------------------

function SWEP:Deploy()
	self:SendWeaponAnim(ACT_VM_DRAW)
	
	self.Idle = 0
	self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
	return true
end

function SWEP:Think()
	if (!self.Owner || self.Owner == NULL) then return end
	
	if ( self.Owner:KeyPressed( IN_ATTACK ) ) then
		self:StartAttack()
		self.VElements["v_element"].material = "models/weapons/c_items/c_grappling_hook_alphatest"
	elseif ( self.Owner:KeyDown( IN_ATTACK ) && inRange ) then
		self:UpdateAttack()
	elseif ( self.Owner:KeyReleased( IN_ATTACK ) && inRange ) then
		self:EndAttack( true )
		self.VElements["v_element"].material = "models/weapons/c_items/c_grappling_hook2"
	end
	
	if self.Idle == 0 and self.IdleTimer <= CurTime() then
		if SERVER then
			self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
		end
		self.Idle = 1
	end
end

function SWEP:DoTrace( endpos )
	local trace = {}
	trace.start = self.Owner:GetShootPos()
	trace.endpos = trace.start + (self.Owner:GetAimVector() * 32768) --14096 is length modifier.
	trace.mins = Vector(-2,-2,-2)
	trace.maxs = Vector(2,2,2)
	if(endpos) then trace.endpos = (endpos - self.Tr.HitNormal * 7) end
	trace.filter = { self.Owner, self.Weapon }
		
	self.Tr = nil
	self.Tr = util.TraceHull( trace )
end

function SWEP:StartAttack()
	-- Get begining and end poins of trace.
	local gunPos = self.Owner:GetShootPos() -- Start of distance trace.
	local disTrace = self.Owner:GetEyeTrace() -- Store all results of a trace in disTrace.
	local hitPos = disTrace.HitPos -- Stores Hit Position of disTrace.
	
	-- Calculate Distance
	-- Thanks to rgovostes for this code.
	local x = (gunPos.x - hitPos.x)^2;
	local y = (gunPos.y - hitPos.y)^2;
	local z = (gunPos.z - hitPos.z)^2;
	local distance = math.sqrt(x + y + z);
	
	-- Only latches if distance is less than distance CVAR, or CVAR negative
	local distanceCvar = GetConVarNumber("grapple_distance")
	inRange = false
	if distanceCvar < 0 or distance <= distanceCvar then
		inRange = true
	end
	
	if inRange then
		if (SERVER) then
			if (!self.Beam) then -- If the beam does not exist, draw the beam.
				-- grapple_beam
				self.Beam = ents.Create( "trace2" )
					self.Beam:SetPos( self.Owner:GetShootPos() )
				self.Beam:Spawn()
			end
			self.Beam:SetParent( self.Owner )
			self.Beam:SetOwner( self.Owner )
		end
		
		self:DoTrace()
		self.speed = GetConVarNumber("grapple_latch_speed") -- Rope latch speed. Was 3000.
		self.startTime = CurTime()
		self.endTime = CurTime() + self.speed
		self.dt = -1
		
		if (SERVER && self.Beam) then
			self.Beam:GetTable():SetEndPos( self.Tr.HitPos )
		end
		
		self:UpdateAttack()
		
		if GetConVarNumber("grapple_play_sounds") == 1 then
			self.Weapon:EmitSound( sndGrappleShoot )
		end
	else
		if GetConVarNumber("grapple_play_sounds") == 1 then
			self.Weapon:EmitSound( sndGrappleAbort,70 )
		end
	end
end

function SWEP:UpdateAttack()
	if self.Tr == nil then return false end
	if !endpos then endpos = self.Tr.HitPos end

	if GetConVarNumber("grapple_ignore_sky") == 1 then
		if self.Tr.HitSky then self:EndAttack( false ) return false end
	end
	
	if (SERVER && self.Beam) then
		self.Beam:GetTable():SetEndPos( endpos )
	end

	lastpos = endpos
	
	if IsValid(self.Tr.Entity) then
		endpos = self.Tr.Entity:NearestPoint(self.Tr.HitPos)
		if SERVER then
			self.Beam:GetTable():SetEndPos( endpos )
			if GetConVarNumber("grapple_damage_enable") == 1 then
				if self.dt == 0 then
					if timer.TimeLeft( "hurtent" .. self:EntIndex() ) == nil then
						if self.Tr.Entity:IsPlayer() then
							if !self.Tr.Entity:Alive() then
								self:DoTrace()
							end
						end
						
						if self.Tr.Entity:IsNPC() then
							if self.Tr.Entity:Health() < 0 then
								self:DoTrace()
							end
						end
						
						local dmgInfo = DamageInfo()
						dmgInfo:SetAttacker(self.Owner)
						dmgInfo:SetInflictor(self)
						dmgInfo:SetDamageType(DMG_SLASH)
						dmgInfo:SetDamage(math.random(GetConVarNumber("grapple_damage_min"),GetConVarNumber("grapple_damage_max")))
						dmgInfo:SetDamagePosition(self.Tr.HitPos)
						dmgInfo:SetDamageForce(self.Owner:GetAimVector()*-5000)
						self.Tr.Entity:TakeDamageInfo(dmgInfo)
						if GetConVarNumber("grapple_play_sounds") == 1 then
							self.Tr.Entity:EmitSound( "weapons/xbow_hit2.wav",75 ,math.random(95,105) ,1 )
							if self.Tr.Entity:IsPlayer() or self.Tr.Entity:IsNPC() or self.Tr.Entity.Type == "nextbot" then
								self.Tr.Entity:EmitSound( sndGrappleHitFlesh,75 ,math.random(95,105) ,1 )
							end
						end
						if self.Tr.Entity:GetPhysicsObject() then
							local hitphys = self.Tr.Entity:GetPhysicsObject()
							if IsValid(hitphys) then

								if self.initialhit == false then
									hitphys:AddVelocity(self.Owner:GetAimVector()*50000/hitphys:GetMass())
								else
									hitphys:AddVelocity(self.Owner:GetAimVector()*-50000/hitphys:GetMass())
								end
								self.initialhit = true
							end
						end
						timer.Create( "hurtent" .. self:EntIndex(), 0.5, 1, function() end )
					end
				end
			end
		end	
	end
			
	local vVel = (endpos - self.Owner:GetShootPos())
	local Distance = endpos:Distance(self.Owner:GetShootPos())
	local et = (self.startTime + (Distance/self.speed))
	
	if self.dt != 0 then
		self.dt = (et - CurTime()) / (et - self.startTime)
		self.VElements["v_element2"].angle = Angle(-1.657, 89.516, -270*CurTime())
		self.VElements["v_element3"].angle = Angle(-1.657, 89.516, 45-270*CurTime())
	end
	if self.dt < 0 then
		if GetConVarNumber("grapple_play_sounds") == 1 then
			self.Weapon:EmitSound( sndGrappleHit )
			sound.Play(sndGrappleHit, self.Tr.HitPos)
		end
		self.dt = 0
	end
			
	if self.dt == 0 then
		self.VElements["v_element2"].angle = Angle(-1.657, 89.516, 0.8*Distance)
		self.VElements["v_element3"].angle = Angle(-1.657, 89.516, 45+0.8*Distance)
		if GetConVarNumber("grapple_play_sounds") == 1 then
			self.ReelIn = CreateSound(self.Owner, "weapons/grappling_hook_reel_start.wav")
			self.ReelIn:Play()
		end
		zVel = self.Owner:GetVelocity().z
		vVel = vVel:GetNormalized()*(math.Clamp(Distance,0,GetConVarNumber("grapple_speed")))
		if SERVER then
			local gravity = GetConVarNumber("sv_Gravity")
			vVel:Add(Vector(0,0,(gravity/100)*1.5)) -- Player speed. DO NOT MESS WITH THIS VALUE!
			if zVel < 0 then
				vVel:Sub(Vector(0,0,zVel/10))
			end
			
			self.Owner:SetVelocity(vVel)
		end
	end
	endpos = nil
end

function SWEP:EndAttack( shutdownsound )
	if ( shutdownsound ) then
		if GetConVarNumber("grapple_play_sounds") == 1 then
			self.Weapon:EmitSound( sndGrappleAbort,70 )
			if self.ReelIn then
				self.ReelIn:Stop()
			end
		end
	end

	self.initialhit = false
	
	if ( CLIENT ) then return end
	if ( !self.Beam ) then return end
	
	self.Beam:Remove()
	self.Beam = nil
end

function SWEP:Holster()
	self:EndAttack( false )
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	return true
end

function SWEP:OnRemove()
	self:EndAttack( false )
	return true
end

function SWEP:OnDrop()
	self:Holster()
end

function SWEP:PrimaryAttack()
	self.Weapon:SendWeaponAnim(ACT_VM_RELOAD)
	self.Owner:SetAnimation(PLAYER_ATTACK1)
	
	self.Idle = 0
	self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:SecondaryAttack()
end
--PATH lua/weapons/weapon_hl2hook/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_hl2pan/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Pan"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing"
SWEP.Category				= "HL2 Melee Pack"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_pan.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_pan.mdl" )
SWEP.ViewModelFOV			= 62
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 40
SWEP.HitInclination		= 0.2
SWEP.HitPushback		= 300
SWEP.HitRate			= 1.00
SWEP.MinDamage			= 12
SWEP.MaxDamage			= 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Metal_Box.ImpactHard" )
local HitSoundBody = Sound( "Flesh.ImpactHard" )

function SWEP:Initialize()

	self:SetHoldType( "melee" )
end

function SWEP:PrimaryAttack()

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	local vm = self.Owner:GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay", 0.2, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay" )

end

function SWEP:SecondaryAttack()
	
	return true
end

function SWEP:OnDrop()

	
end

function SWEP:Hitscan()

//This function calculate the trajectory

	for i=0, 170 do

	local tr = util.TraceLine( {
		start = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)),
		endpos = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)) + ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.7 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) ),
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

//This if shot the bullets

	if ( tr.Hit ) then
		
		local strikevector = ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.5 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) )

		bullet = {}
		bullet.Num    = 1
		bullet.Src    = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 15))
		bullet.Dir    = strikevector:GetNormalized()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force  = 10
		bullet.Hullsize = 0
		bullet.Distance = self.HitDistance * 1.5
		bullet.Damage = math.random( 12, 18 )
		self.Owner:FireBullets(bullet)

		//local vPoint = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10))
		//local effectdata = EffectData()
		//effectdata:SetOrigin( vPoint )
		//util.Effect( "BloodImpact", effectdata )

		self:EmitSound( SwingSound )

		//vm:SendViewModelMatchingSequence( vm:LookupSequence( "hitcenter1" ) )

		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") then
			self:EmitSound( HitSoundBody )
			tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * self.HitPushback )
		else
			self:EmitSound( HitSoundWorld )
		end
//if break
		break
//if end
		//else vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )
		end
end

end

function SWEP:Deploy()

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()

	timer.Remove("hitdelay")
	return true
end
--PATH gamemodes/starwarsrp/entities/weapons/weapon_keypadchecker/cl_init.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs/sh_animations.lua:

function SWEP:SetGestureTime( time )
	self:SetNWGestureTime( time )
	self.f_NextGesture = time
end

function SWEP:GetGestureTime()
	if SERVER then
		return self:GetNWGestureTime()
	else
		local ply = self:GetOwner()
		if IsValid( ply ) and ply == LocalPlayer() then
			return (self.f_NextGesture or 0)
		else
			return self:GetNWGestureTime()
		end
	end
end

function SWEP:PlayAnimation( anim, start )
	if not start then
		start = 0
	end

	local ply = self:GetOwner()

	if not IsValid( ply ) then return end

	if game.SinglePlayer() then

		ply:AddVCDSequenceToGestureSlot( GESTURE_SLOT_ATTACK_AND_RELOAD, ply:LookupSequence( anim ), start, true )

		return
	end

	ply.s_vcd_anim = anim

	if SERVER then
		net.Start( "lscs_animations" )
			net.WriteEntity( ply )
			net.WriteBool( true )
			net.WriteString( anim )
			net.WriteString( tostring(start) )
		net.Broadcast()
	end

	ply:AddVCDSequenceToGestureSlot( GESTURE_SLOT_ATTACK_AND_RELOAD, ply:LookupSequence( anim ), start, true )
end

function SWEP:StopAnimation()
	local ply = self:GetOwner()

	if not IsValid( ply ) then return end

	ply.s_vcd_anim = nil

	self:SetGestureTime( CurTime() )

	ply:AnimResetGestureSlot( GESTURE_SLOT_ATTACK_AND_RELOAD )
end
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs/sh_stance_override.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_electrodual.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_spear.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/weapon_p2282/shared.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_vibrosword.lua:
return gluapack()()
--PATH lua/weapons/weapon_vj_ak47/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Base 						= "weapon_vj_base"
SWEP.PrintName					= "AK-47"
SWEP.Author 					= "DrVrej"
SWEP.Contact					= "http://steamcommunity.com/groups/vrejgaming"
SWEP.Purpose					= "This weapon is made for Players and NPCs"
SWEP.Instructions				= "Controls are like a regular weapon."
SWEP.Category					= "VJ Base"
	-- Client Settings ---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
SWEP.Slot						= 2 -- Which weapon slot you want your SWEP to be in? (1 2 3 4 5 6)
SWEP.SlotPos					= 4 -- Which part of that slot do you want the SWEP to be in? (1 2 3 4 5 6)
SWEP.SwayScale 					= 1 -- Default is 1, The scale of the viewmodel sway
SWEP.UseHands					= true
end
	-- Main Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.ViewModel					= "models/weapons/cstrike/c_rif_ak47.mdl"
SWEP.WorldModel					= "models/vj_weapons/w_csgo_ak47.mdl"
SWEP.WorldModel_UseCustomPosition = true -- Should the gun use custom position? This can be used to fix guns that are in the crotch
SWEP.WorldModel_CustomPositionAngle = Vector(-8, 90, 180)
SWEP.WorldModel_CustomPositionOrigin = Vector(-3.4, -1, -0.5)
SWEP.HoldType 					= "ar2"
SWEP.ViewModelFlip				= false -- Flip the model? Usally used for CS:S models
SWEP.Spawnable					= true
SWEP.AdminSpawnable				= false
	-- Primary Fire ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Primary.Damage				= 5 -- Damage
SWEP.Primary.PlayerDamage		= "Double" -- Only applies for players | "Same" = Same as self.Primary.Damage, "Double" = Double the self.Primary.Damage OR put a number to be different from self.Primary.Damage
SWEP.Primary.Force				= 5 -- Force applied on the object the bullet hits
SWEP.Primary.ClipSize			= 30 -- Max amount of bullets per clip
SWEP.Primary.Recoil				= 0.3 -- How much recoil does the player get?
SWEP.Primary.Delay				= 0.1 -- Time until it can shoot again
SWEP.Primary.Automatic			= true -- Is it automatic?
SWEP.Primary.Ammo				= "SMG1" -- Ammo type
SWEP.Primary.Sound				= {"vj_weapons/ak47/ak47_single.wav"}
SWEP.Primary.DistantSound		= {"vj_weapons/ak47/ak47_single_dist.wav"}
SWEP.PrimaryEffects_MuzzleAttachment = 1
SWEP.PrimaryEffects_ShellAttachment = 2
SWEP.PrimaryEffects_ShellType = "VJ_Weapon_RifleShell1"
	-- Reload Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Reload_TimeUntilAmmoIsSet	= 1.8 -- Time until ammo is set to the weapon
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnFireAnimationEvent(pos, ang, event, options)
	if event == 5001 then return true end -- Asiga hose vor shtke gedervadz flash-e
end
--PATH lua/weapons/weapon_vj_blaster/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Base 						= "weapon_vj_base"
SWEP.PrintName					= "Blaster"
SWEP.Author 					= "DrVrej"
SWEP.Contact					= "http://steamcommunity.com/groups/vrejgaming"
SWEP.Purpose					= "This weapon is made for Players and NPCs"
SWEP.Instructions				= "Controls are like a regular weapon."
SWEP.Category					= "VJ Base"
	-- Client Settings ---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
SWEP.Slot						= 2 -- Which weapon slot you want your SWEP to be in? (1 2 3 4 5 6) 
SWEP.SlotPos					= 4 -- Which part of that slot do you want the SWEP to be in? (1 2 3 4 5 6)
SWEP.UseHands					= true
end
	-- NPC Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.NPC_NextPrimaryFire 		= 0.3 -- Next time it can use primary fire
SWEP.NPC_ReloadSound			= {"vj_weapons/blaster/blaster_reload.wav"} -- Sounds it plays when the base detects the SNPC playing a reload animation
	-- Main Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.ViewModel					= "models/vj_weapons/c_e5.mdl"
SWEP.WorldModel					= "models/vj_weapons/w_e5.mdl"
SWEP.HoldType 					= "ar2"
SWEP.Spawnable					= true
SWEP.AdminSpawnable				= false
	-- Primary Fire ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Primary.Damage				= 10 -- Damage
SWEP.Primary.Force				= 5 -- Force applied on the object the bullet hits
SWEP.Primary.ClipSize			= 30 -- Max amount of bullets per clip
SWEP.Primary.Recoil				= 0.6 -- How much recoil does the player get?
SWEP.Primary.Delay				= 0.3 -- Time until it can shoot again
SWEP.Primary.TracerType			= "VJ_Laserrod_Red" -- Tracer type (Examples: AR2, laster, 9mm)
SWEP.Primary.Automatic			= true -- Is it automatic?
SWEP.Primary.Ammo				= "SMG1" -- Ammo type
SWEP.Primary.Sound				= {"vj_weapons/blaster/blaster_fire.wav"} -- npc/roller/mine/rmine_explode_shock1.wav
SWEP.Primary.HasDistantSound	= false -- Does it have a distant sound when the gun is shot?
//SWEP.Primary.DisableBulletCode	= true -- The bullet won't spawn, this can be used when creating a projectile-based weapon
SWEP.PrimaryEffects_MuzzleParticles = {"vj_rifle_smoke","vj_rifle_smoke_dark","vj_rifle_smoke_flash","vj_rifle_sparks2"}
SWEP.PrimaryEffects_MuzzleParticlesAsOne = true -- If set to true, the base will spawn all the given particles instead of picking one
SWEP.PrimaryEffects_MuzzleAttachment = "muzzle"
SWEP.PrimaryEffects_SpawnShells = false
SWEP.PrimaryEffects_DynamicLightColor = Color(255, 0, 0)
	-- Reload Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.HasReloadSound				= true -- Does it have a reload sound? Remember even if this is set to false, the animation sound will still play!
SWEP.ReloadSound				= {"vj_weapons/blaster/blaster_reload.wav"}
SWEP.Reload_TimeUntilAmmoIsSet	= 0.8 -- Time until ammo is set to the weapon
---------------------------------------------------------------------------------------------------------------------------------------------
/*function SWEP:CustomOnPrimaryAttack_BeforeShoot()
	if CLIENT then return end
	local SpawnBlaserRod = ents.Create("obj_vj_blasterrod")
	local OwnerPos = self:GetOwner():GetShootPos()
	local OwnerAng = self:GetOwner():GetAimVector():Angle()
	OwnerPos = OwnerPos + OwnerAng:Forward()*-33 + OwnerAng:Up()*-5 + OwnerAng:Right()*6
	if self:GetOwner():IsPlayer() then SpawnBlaserRod:SetPos(OwnerPos) else SpawnBlaserRod:SetPos(self:GetAttachment(self:LookupAttachment("muzzle")).Pos) end
	if self:GetOwner():IsPlayer() then SpawnBlaserRod:SetAngles(OwnerAng) else SpawnBlaserRod:SetAngles(self:GetOwner():GetAngles()) end
	SpawnBlaserRod:SetOwner(self:GetOwner())
	SpawnBlaserRod:Activate()
	SpawnBlaserRod:Spawn()
	
	local phy = SpawnBlaserRod:GetPhysicsObject()
	if phy:IsValid() then
		if self:GetOwner():IsPlayer() then
		phy:ApplyForceCenter(self:GetOwner():GetAimVector() * 4000) else //200000
		phy:ApplyForceCenter((self:GetOwner():GetEnemy():GetPos() - self:GetOwner():GetPos()) * 4000)
		end
	end
end*/
--PATH lua/weapons/weapon_vj_glock17/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Base 						= "weapon_vj_base"
SWEP.PrintName					= "Glock 17"
SWEP.Author 					= "DrVrej"
SWEP.Contact					= "http://steamcommunity.com/groups/vrejgaming"
SWEP.Purpose					= "This weapon is made for Players and NPCs"
SWEP.Instructions				= "Controls are like a regular weapon."
SWEP.Category					= "VJ Base"
	-- Client Settings ---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
SWEP.Slot						= 1 -- Which weapon slot you want your SWEP to be in? (1 2 3 4 5 6) 
SWEP.SlotPos					= 1 -- Which part of that slot do you want the SWEP to be in? (1 2 3 4 5 6)
SWEP.SwayScale 					= 2 -- Default is 1, The scale of the viewmodel sway
end
	-- NPC Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.NPC_NextPrimaryFire 		= 0.25 -- Next time it can use primary fire
SWEP.NPC_CustomSpread	 		= 0.8 -- This is added on top of the custom spread that's set inside the SNPC! | Starting from 1: Closer to 0 = better accuracy, Farther than 1 = worse accuracy
	-- Main Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.ViewModel					= "models/vj_weapons/v_glock.mdl"
SWEP.WorldModel					= "models/vj_weapons/w_glock.mdl"
SWEP.HoldType 					= "pistol"
SWEP.ViewModelFOV				= 70 -- Player FOV for the view model
SWEP.Spawnable					= true
SWEP.AdminSpawnable				= false
	-- Primary Fire ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Primary.AllowFireInWater = true -- If true, you will be able to use primary fire in water
SWEP.Primary.Damage = 25 -- Damage
SWEP.Primary.PlayerDamage = 15 -- Only applies for players | "Same" = Same as self.Primary.Damage, "Double" = Double the self.Primary.Damage OR put a number to be different from self.Primary.Damage
SWEP.Primary.Force = 5 -- Force applied on the object the bullet hits
SWEP.Primary.ClipSize = 17 -- Max amount of bullets per clip
SWEP.Primary.Recoil = 0.3 -- How much recoil does the player get?
SWEP.Primary.Cone = 5 -- How accurate is the bullet? (Players)
SWEP.Primary.Delay = 0.25 -- Time until it can shoot again
SWEP.Primary.Automatic = true -- Is it automatic?
SWEP.Primary.Ammo = "Pistol" -- Ammo type
SWEP.Primary.Sound = {"vj_weapons/glock_17/glock17_single.wav"}
SWEP.Primary.DistantSound = {"vj_weapons/glock_17/glock17_single_dist.wav"}
SWEP.PrimaryEffects_MuzzleAttachment = 1
SWEP.PrimaryEffects_ShellAttachment = "ejectbrass"
SWEP.PrimaryEffects_ShellType = "VJ_Weapon_PistolShell1"
	-- ====== Secondary Fire Variables ====== --
SWEP.Secondary.Automatic = true -- Is it automatic?
SWEP.Secondary.Ammo = "Pistol" -- Ammo type
	-- Deployment Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.AnimTbl_Deploy = {ACT_VM_IDLE_TO_LOWERED}
	-- Reload Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.HasReloadSound = true -- Does it have a reload sound? Remember even if this is set to false, the animation sound will still play!
SWEP.ReloadSound = "vj_weapons/glock_17/reload.wav"
SWEP.Reload_TimeUntilAmmoIsSet = 1.5 -- Time until ammo is set to the weapon
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnSecondaryAttack()
	self.Primary.Delay = 0.175
	self.Primary.Cone = 20
	self:PrimaryAttack()
	self.Primary.Delay = 0.25
	self.Primary.Cone = 5
	
	self:SetNextSecondaryFire(CurTime() + 0.175)
	return false
end
--PATH lua/weapons/weapon_vj_smg1/shared.lua:
return gluapack()()
--PATH lua/entities/arc170.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/arc9_smoke_cloud.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Smoke Cloud"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

local smokeimages = {"particle/smokesprites_0002", "particle/smokesprites_0003", "particle/smokesprites_0004", "particle/smokesprites_0005", "particle/smokesprites_0006", "particle/smokesprites_0007", "particle/smokesprites_0008", "particle/smokesprites_0009", "particle/smokesprites_0010", "particle/smokesprites_0011", "particle/smokesprites_0012", "particle/smokesprites_0013", "particle/smokesprites_0014", "particle/smokesprites_0015", "particle/smokesprites_0016"}

local function GetSmokeImage()
    return smokeimages[math.random(#smokeimages)]
end

ENT.Particles = nil
ENT.SmokeRadius = 256
ENT.SmokeColor = Color(150, 150, 150)
ENT.BillowTime = 1
ENT.Life = 15

ENT.ARC9Smoke = true
ENT.ArcCWSmoke = true

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( "models/weapons/w_eq_smokegrenade_thrown.mdl" )
        self:SetMoveType( MOVETYPE_NONE )
        self:SetSolid( SOLID_NONE )
        self:DrawShadow( false )
    else
        local emitter = ParticleEmitter(self:GetPos())

        self.Particles = {}

        local amt = 20

        for i = 1, amt do
            local smoke = emitter:Add(GetSmokeImage(), self:GetPos())
            smoke:SetVelocity( VectorRand() * 8 + (Angle(0, i * (360 / amt), 0):Forward() * 400) )
            smoke:SetStartAlpha( 0 )
            smoke:SetEndAlpha( 255 )
            smoke:SetStartSize( 0 )
            smoke:SetEndSize( self.SmokeRadius )
            smoke:SetRoll( math.Rand(-180, 180) )
            smoke:SetRollDelta( math.Rand(-0.2,0.2) )
            smoke:SetColor( self.SmokeColor.r, self.SmokeColor.g, self.SmokeColor.b )
            smoke:SetAirResistance( 75 )
            smoke:SetPos( self:GetPos() )
            smoke:SetCollide( true )
            smoke:SetBounce( 0.2 )
            smoke:SetLighting( false )
            smoke:SetNextThink( CurTime() + FrameTime() )
            smoke.bt = CurTime() + self.BillowTime
            smoke.dt = CurTime() + self.BillowTime + self.Life
            smoke.ft = CurTime() + self.BillowTime + self.Life + math.Rand(2.5, 5)
            smoke:SetDieTime(smoke.ft)
            smoke.life = self.Life
            smoke.billowed = false
            smoke.radius = self.SmokeRadius
            smoke:SetThinkFunction( function(pa)
                if !pa then return end

                local prog = 1
                local alph = 0

                if pa.ft < CurTime() then
                    pa:SetDieTime(0)
                    return
                elseif pa.dt < CurTime() then
                    local d = (CurTime() - pa.dt) / (pa.ft - pa.dt)

                    alph = 1 - d
                elseif pa.bt < CurTime() then
                    alph = 1
                else
                    local d = math.Clamp(pa:GetLifeTime() / (pa.bt - CurTime()), 0, 1)

                    prog = (-d ^ 2) + (2 * d)

                    alph = d
                end

                pa:SetEndSize( pa.radius * prog )
                pa:SetStartSize( pa.radius * prog )

                pa:SetStartAlpha(255 * alph)
                pa:SetEndAlpha(255 * alph)

                pa:SetNextThink( CurTime() + FrameTime() )
            end )

            table.insert(self.Particles, smoke)
        end

        emitter:Finish()
    end

    self.dt = CurTime() + self.Life + self.BillowTime
end

function ENT:Think()

    if SERVER then
        local targets = ents.FindInSphere(self:GetPos(), 256)
        for _, k in pairs(targets) do
            if k:IsNPC() then
                k:SetSchedule(SCHED_STANDOFF)
            end
        end
    end

    if self.dt < CurTime() then
        if SERVER then
            SafeRemoveEntity(self)
        end
    end
end

function ENT:Draw()
    return false
end
--PATH lua/entities/arccw_ammo_pistol_large.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"

ENT.PrintName                 = "Pistol Ammo (Large)"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/pistol_ammo.mdl"
ENT.Scale = 1.5

ENT.AmmoType = "pistol"
ENT.AmmoCount = 200

ENT.DetonationDamage = 10
ENT.DetonationRadius = 256
ENT.DetonationSound = "weapons/pistol/pistol_fire3.wav"
--PATH lua/entities/arccw_ammo_sniper_large.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/entities/arccw_nade_launcher17m/shared.lua:
ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.PrintName = "Grenade Launcher Rocket"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/tfa_starwars/w_thermal.mdl"
ENT.FuseTime = 4
ENT.ArmTime = 1
ENT.ImpactFuse = true

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
		ParticleEffectAttach( "astw2_halo_reach_grenade_launcher_trail", PATTACH_POINT_FOLLOW, self, 1 )
		util.SpriteTrail( self, 0, Color(255,185,20,185), false, 16, 4, 0.22, 0.01, "effects/halo3/trail/basic_trail" )
		util.SpriteTrail( self, 0, Color(255,155,20,155), false, 12, 4, 0.25, 0.01, "effects/halo3/trail/flaming_trail" )
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
			phys:SetMass(1)
            phys:SetBuoyancyRatio(0)
            phys:EnableGravity( true )
        end

        self.kt = CurTime() + self.FuseTime
        self.motorsound = CreateSound( self, "weapons/masita_extras/cw/wpn_rep_unit_lockon_lp.wav")
		self.motorsound:Play()
    end
	if CLIENT then
	ParticleEffectAttach( "astw2_halo_reach_grenade_launcher_trail", PATTACH_POINT_FOLLOW, self, 1 )
	end
    self.at = CurTime() + self.ArmTime
    self.Armed = false
end

function ENT:OnRemove()
    if SERVER then
        self.motorsound:Stop()
    end
end


function ENT:PhysicsCollide(data, physobj)
if SERVER then
		if data.Speed > 25 then
            self:EmitSound(Sound("weapons/grenades/wpn_fraggrenade_1p_hardsurface_bounce_01_lr_v" .. math.random(1,2) .. ".wav"))
		end
		end
	if self.at <= CurTime() and self.ImpactFuse then
            self:Detonate()


        end
		local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        util.Effect( "StunstickImpact", effectdata)
end

function ENT:Arm()
    if SERVER then
        
    end
end

function ENT:Think()



    if CurTime() >= self.at and !self.Armed then
        self:Arm()
        self.Armed = true
    end

    if SERVER then

        if self.Armed then
            local phys = self:GetPhysicsObject()
        end
	
	if CurTime() >= self.at then
            local targets = ents.FindInSphere(self:GetPos(), 16)
            for _, k in pairs(targets) do
                if k:IsPlayer() or k:IsNPC() then
                    if self:Visible( k ) and k:Health() > 0 then
                        self:Detonate()
                    end
                elseif (k:IsValid() and scripted_ents.IsBasedOn( k:GetClass(), "base_nextbot" )) then
                    self:Detonate()
                end
            end
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    end

    if CLIENT then
        -- if self:IsValid() then
            -- local emitter = ParticleEmitter(self:GetPos())

            -- if !self:IsValid() or self:WaterLevel() > 2 then return end

	-- local smoke = emitter:Add("effects/halo3/muzzle_magnum", self:GetPos())
        -- smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
        -- smoke:SetVelocity( self:GetAngles():Forward() * 100 )
        -- smoke:SetDieTime( math.Rand(0.1,0.15) )
        -- smoke:SetStartAlpha( 255 )
        -- smoke:SetEndAlpha( 0 )
        -- smoke:SetStartSize( 3 )
        -- smoke:SetEndSize( 0 )
        -- smoke:SetRoll( math.Rand(-180, 180) )
        -- smoke:SetRollDelta( math.Rand(-0.2,0.2) )
        -- smoke:SetColor( 255, 125, 55 )
        -- smoke:SetAirResistance( 2 )
        -- smoke:SetPos( self:GetPos() )
        -- smoke:SetLighting( false )
		
        -- emitter:Finish()
        -- end
    end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_halo_3_frag_explosion", self:GetPos(), self:GetAngles() )
	-- sound.Play( "halo/halo_reach/weapons/grenade_launcher_expl" .. math.random(1,3) .. ".ogg",  self:GetPos(), 100, 100 )
	self:EmitSound("grenades/gren_expl" .. math.random(1,4) .. "_close.ogg", 120, 100, 1, CHAN_AUTO)
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end
	local targets = ents.FindInSphere(self:GetPos(), 300)
        for _, k in pairs(targets) do
            if k != self and k:GetPos().z < self:GetPos().z + 64 then
                local damage = DamageInfo()
                damage:SetAttacker( self:GetOwner() )
                damage:SetDamage( 5 )
                damage:SetDamageType( DMG_SHOCK )
                damage:SetInflictor( self )
                k:TakeDamageInfo( damage )
            end
        end
	util.Decal( "astw2_halo_reach_impact_soft_terrain_explosion", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
         util.BlastDamage(self, attacker, self:GetPos(), 300, 250)
	 util.ScreenShake(self:GetPos(),4500,100,0.6,1024)
	 
        self:Remove()
    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()

        if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/halo3/8pt_ringed_star_flare") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(25, 50), math.random(30, 55), Color(255, 200, 150) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
        end
    end
end
--PATH addons/[bronie] republic-essentials-v2d/lua/entities/arccw_thr.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cargo4/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cargo4/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "NEU (team 0) | Cargo 4"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/star_wars/the_clone_wars/vehicles/cis_fly_vcarrier.mdl"
ENT.AITEAM 					= 0

ENT.Mass 					= 700

ENT.HealthVal 				= 100000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/9799_fire.mp3")

ENT.PRIMARYDAMAGE			= 80
ENT.SHOOTDELAY1 			= 0.6
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{
	[1] = Vector(0,0,875),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(0,180,0),
}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 0},
	{forward = 700, right = 0, up = 0},
	{forward = 0, right = 0, up = 0},
	{forward = -300, right = 0, up = 0},
}
--PATH lua/entities/aura_lvs_cargo6/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cargo7/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cargo7/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cargo8/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_cr90_rep/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_gozanti/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_munificent_mk2/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_rtt04/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_satellite_neu_1/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_satellite_rep_1/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_satellite_rep_1/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_satellite_rep_1/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_satellite_rep_2/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_satellite_rep_2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "REP | Defense Platform"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/cod_iw/misc/air_thor/platform.mdl"
ENT.AITEAM 					= 2

ENT.Mass 					= 700

ENT.HealthVal 				= 20000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_blue_laser"
ENT.SHOOTSOUND				= Sound("weapons/mega_turbolaser.mp3")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 2
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{
	[1] = Vector(72,0,-25),
	[2] = Vector(-72,0,-25),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(-90,180,0),
	[2] = Angle(-90,0,0),
}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 0},
}
--PATH lua/entities/base_streamradio.lua:
AddCSLuaFile()

DEFINE_BASECLASS("base_anim")

local StreamRadioLib = StreamRadioLib

local LIBNetwork = StreamRadioLib.Network
local LIBWire = StreamRadioLib.Wire
local LIBUtil = StreamRadioLib.Util
local LIBHook = StreamRadioLib.Hook

local WireLib = WireLib

local g_isLoaded = StreamRadioLib and StreamRadioLib.Loaded
local g_isWiremodLoaded = g_isLoaded and LIBWire.HasWiremod()

ENT.__IsRadio = true

ENT.Editable = false
ENT.Spawnable = false
ENT.AdminOnly = false

ENT.WireDebugName = "Stream Radio"

function ENT:AddDTNetworkVar(datatype, name, ...)
	if not g_isLoaded then
		return
	end

	return LIBNetwork.AddDTNetworkVar(self:GetTable(), datatype, name, ...)
end

function ENT:SetDTVarCallback(name, callback)
	if not g_isLoaded then
		return
	end

	LIBNetwork.SetDTVarCallback(self:GetTable(), name, function(...)
		if not IsValid(self) then
			return
		end

		callback(...)
	end)
end

function ENT:SetupDataTables()
	if not g_isLoaded then
		return
	end

	StreamRadioLib.RegisterRadio(self)
	LIBNetwork.SetupDataTables(self)

	self:AddDTNetworkVar( "Entity", "RadioOwner" )
	self:AddDTNetworkVar( "Entity", "LastUser" )
	self:AddDTNetworkVar( "Entity", "LastUsingEntity" )
end

function ENT:SetAnim( Animation, Frame, Rate )
	if not self.Animated or not self.AutomaticFrameAdvance then
		-- This must be run once on entities that will be animated
		self.Animated = true
		self:SetAutomaticFrameAdvance(true)
	end

	self:ResetSequence( Animation or 0 )
	self:SetCycle( Frame or 0 )
	self:SetPlaybackRate( Rate or 1 )
end

function ENT:EmitSoundIfExist( name, ... )
	name = name or ""
	if ( name == "" ) then
		return
	end

	self:EmitSound( name, ... )
end

function ENT:RegisterDupePose( name )
	self.DupePoses = self.DupePoses or {}
	self.DupePoses[name] = true
end

function ENT:GetDupePoses()
	self.DupePoses = self.DupePoses or {}

	local PoseParameter = {}
	for name, value in pairs( self.DupePoses ) do
		if ( not value ) then continue end
		PoseParameter[name] = self:GetPoseParameter( name )
	end

	return PoseParameter
end

function ENT:SetDupePoses( PoseParameter )
	PoseParameter = PoseParameter or {}

	for name, value in pairs( PoseParameter ) do
		if ( not value ) then continue end
		self:SetPoseParameter( name, value )
	end
end

function ENT:AddObjToNwRegister(obj)
	if not IsValid(obj) then return end

	obj:AddToNwRegister(self._3dstraemradio_classobjs_nw_register)
end

function ENT:GetOrCreateStream()
	if not g_isLoaded then
		if IsValid(self.StreamObj) then
			self.StreamObj:Remove()
		end

		self.StreamObj = nil
		return nil
	end

	if IsValid(self.StreamObj) then
		return self.StreamObj
	end

	self.StreamObj = nil

	local stream = StreamRadioLib.CreateOBJ("stream")
	if not IsValid( stream ) then
		return nil
	end

	self.StreamObj = stream

	local function call(name, ...)
		if not IsValid( self ) then
			return
		end

		local func = self[name]

		if not isfunction(func) then
			return nil
		end

		return func(self, ...)
	end

	stream.OnConnect = function( ... )
		return call("StreamOnConnect", ...)
	end

	stream.OnError = function( ... )
		return call("StreamOnError", ...)
	end

	stream.OnClose = function( ... )
		return call("StreamOnClose", ...)
	end

	stream.OnRetry = function( ... )
		return call("StreamOnRetry", ...)
	end

	stream.OnSearch = function( ... )
		return call("StreamOnSearch", ...)
	end

	stream.CanSkipUrlChecks = function( ... )
		return call("StreamCanSkipUrlChecks", ...)
	end

	stream.CanBypassUrlBlock = function( ... )
		return call("StreamCanBypassUrlBlock", ...)
	end

	stream.OnMute = function( ... )
		return call("StreamOnMute", ...)
	end

	stream.OnTrackEnd = function( ... )
		return call("StreamOnTrackEnd", ...)
	end

	stream:SetEvent("OnPlayModeChange", tostring(self) .. "_base", function(...)
		return call("StreamOnPlayModeChange", ...)
	end)

	stream:SetName("stream")
	stream:SetNWName("str")
	stream:SetEntity(self)

	self:AddObjToNwRegister(stream)

	stream:ActivateNetworkedMode()
	stream:OnClose()

	return stream
end

function ENT:StreamOnConnect()
	self:CheckTransmitState()

	return true
end

function ENT:StreamOnSearch()
	self:CheckTransmitState()

	return true
end

function ENT:StreamCanSkipUrlChecks()
	return false
end

function ENT:StreamCanBypassUrlBlock(blockedByHook)
	if blockedByHook then
		-- was blocked by external code
		return false
	end

	if not StreamRadioLib.IsUrlWhitelistAdminRadioTrusted() then
		return false
	end

	local owner = self:GetRealRadioOwner()
	if LIBUtil.IsAdmin(owner) then
		-- Admins are allowed to bypass built-in whitelisting for better UX.
		return true
	end

	return false
end

function ENT:StreamOnRetry()
	self:CheckTransmitState()

	return true
end

function ENT:StreamOnError()
	self:CheckTransmitState()
end

function ENT:StreamOnClose()
	self:CheckTransmitState()
end

function ENT:StreamOnPlayModeChange()
	self:CheckTransmitState()
end

function ENT:IsStreaming()
	if not IsValid( self.StreamObj ) then
		return false
	end

	if not IsValid( self.StreamObj:GetChannel() ) then
		return false
	end

	return true
end

function ENT:HasStream()
	if not IsValid( self.StreamObj ) then
		return false
	end

	return true
end

function ENT:GetStreamObject()
	if not self:HasStream() then
		return nil
	end

	return self.StreamObj
end

function ENT:SetSoundPosAngOffset(pos, ang)
	self.SoundPosOffset = pos
	self.SoundAngOffset = ang
end

function ENT:GetSoundPosAngOffset()
	return self.SoundPosOffset, self.SoundAngOffset
end

local ang_zero = Angle()
local vec_zero = Vector()

function ENT:CalcSoundPosAngWorld()
	local pos = self:GetPos()
	local ang = self:GetAngles()

	local spos, sang = LocalToWorld(self.SoundPosOffset or vec_zero, self.SoundAngOffset or ang_zero, pos, ang)

	self.SoundPos = spos
	self.SoundAng = sang

	return spos, sang
end

function ENT:DistanceToEntity(ent, pos1, pos2)
	if not g_isLoaded then
		return 0
	end

	if not pos1 then
		pos1 = self.SoundPos
	end

	if not pos1 then
		return 0
	end

	if pos2 then
		return pos2:Distance(pos1)
	end

	pos2 = StreamRadioLib.GetCameraPos(ent)

	if not pos2 then
		return 0
	end

	return pos2:Distance(pos1)
end

function ENT:DistToSqrToEntity(ent, pos1, pos2)
	if not g_isLoaded then
		return 0
	end

	if not pos1 then
		pos1 = self.SoundPos
	end

	if not pos1 then
		return 0
	end

	if pos2 then
		return pos2:DistToSqr(pos1)
	end

	pos2 = StreamRadioLib.GetCameraPos(ent)

	if not pos2 then
		return 0
	end

	return pos2:DistToSqr(pos1)
end

function ENT:CheckDistanceToEntity(ent, maxDist, pos1, pos2)
	local maxDistSqr = maxDist * maxDist
	local distSqr = self:DistToSqrToEntity(ent, pos1, pos2)

	if distSqr > maxDistSqr then
		return false
	end

	return true
end

function ENT:GetRealRadioOwner()
	local getCPPIOwner = self.CPPIGetOwner
	if isfunction(getCPPIOwner) then
		local owner = getCPPIOwner(self)

		if isentity(owner) and IsValid(owner) then
			return owner
		end
	end

	local getRadioOwner = self.GetRadioOwner
	if isfunction(getRadioOwner) then
		local owner = getRadioOwner(self)

		if IsValid(owner) then
			return owner
		end
	end

	return nil
end

function ENT:Initialize()
	if g_isLoaded then
		StreamRadioLib.RegisterRadio(self)
	end

	self._3dstraemradio_classobjs_nw_register = {}

	if SERVER then
		self._WireOutputCache = {}
	end

	self:GetOrCreateStream()
	self:CheckTransmitState()
end

function ENT:OnTakeDamage( dmg )
	self:TakePhysicsDamage( dmg )
end

function ENT:OnReloaded()
	if CLIENT then return end
	self:Remove()
end

function ENT:IsMutedForPlayer(ply)
	if not g_isLoaded then
		return true
	end

	if not IsValid(ply) and CLIENT then
		ply = LocalPlayer()
	end

	if not IsValid(ply) then return true end
	if not ply:IsPlayer() then return true end
	if ply:IsBot() then return true end

	if StreamRadioLib.IsMuted(ply, self:GetRealRadioOwner()) then
		return true
	end

	local mutedist = math.min(self:GetRadius() + 1000, StreamRadioLib.GetMuteDistance(ply))
	local camPos = nil

	if CLIENT then
		camPos = StreamRadioLib.GetCameraViewPos(ply)
	end

	if not self:CheckDistanceToEntity(ply, mutedist, nil, camPos) then
		return true
	end

	return false
end

function ENT:IsMutedForAll()
	if not g_isLoaded then
		return true
	end

	if self:GetSVMute() then
		return true
	end

	local allplayers = player.GetHumans()

	for k, v in pairs(allplayers) do
		if not IsValid(v) then continue end

		local muted = self:IsMutedForPlayer(v)
		if muted then continue end

		return false
	end

	return true
end

function ENT:CheckTransmitState()
	if CLIENT then return end

	self._TransmitCheck = true
	self._LastTransmitCheck = CurTime()
end

function ENT:UpdateTransmitState()
	local stream = self.StreamObj

	if not IsValid(stream) then
		return TRANSMIT_PVS
	end

	if stream:IsStopMode() then return TRANSMIT_PVS end
	if stream:GetURL() == "" then return TRANSMIT_PVS end
	if self:IsMutedForAll() then return TRANSMIT_PVS end

	return TRANSMIT_ALWAYS
end

function ENT:PostFakeRemove( )
	if not g_isLoaded then
		return
	end

	StreamRadioLib.RegisterRadio(self)
end

function ENT:OnRemove()
	local Stream = self.StreamObj
	local creationID = self:GetCreationID()

	local classobjs_data = self._3dstreamradio_classobjs_data
	local classobjs_nw_register = self._3dstraemradio_classobjs_nw_register

	-- We run it in a timer to ensure the entity is actually gone
	timer.Simple( 0.05, function()
		if IsValid(self) then
			self:PostFakeRemove()
			return
		end

		if IsValid(Stream) then
			Stream:Remove()
			Stream = nil
		end

		if g_isLoaded then
			StreamRadioLib.UnregisterRadio(creationID)

			LIBUtil.EmptyTableSafe(classobjs_data)
			LIBUtil.EmptyTableSafe(classobjs_nw_register)
		end
	end)

	if SERVER then
		self:StopStreamInternal()

		if g_isWiremodLoaded then
			WireLib.Remove(self)
		end
	end

	BaseClass.OnRemove(self)
end

function ENT:NWOverflowKill()
	self:SetNoDraw(true)

	if SERVER then
		self:Remove()
	end
end

function ENT:NonDormantThink()
	-- Override me
end

function ENT:FastThink()
	local pos, ang = self:CalcSoundPosAngWorld()

	if SERVER then
		if g_isWiremodLoaded then
			self:WiremodThink()
		end
	else
		local stream = self.StreamObj

		if CLIENT and self:ShowDebug() then
			local channeltext = "no sound"

			if stream then
				channeltext = tostring(stream)
			end

			channeltext = string.format("Sound pos, channel: %s", channeltext)

			debugoverlay.Axis(pos, ang, 5, 0.05, color_white)
			debugoverlay.EntityTextAtPosition(pos, 1, channeltext, 0.05, color_white)
		end

		if IsValid(stream) then
			stream:Set3DPosition(pos, ang:Forward())
		end
	end
end

function ENT:Think()
	BaseClass.Think(self)

	local curtime = CurTime()

	if g_isLoaded then
		self:InternalThink()
	end

	if SERVER then
		self:NextThink(curtime + 0.1)
		return true
	end

	return true
end

function ENT:InternalThink()
	local now = CurTime()

	self._nextSlowThink = self._nextSlowThink or 0

	if self._nextSlowThink < now then
		self:InternalSlowThink()
		self._nextSlowThink = now + 0.20
	end
end

function ENT:InternalSlowThink()
	local now = CurTime()

	StreamRadioLib.RegisterRadio(self)

	self._beingLookedAtCache = nil
	self._showDebugCache = nil

	if SERVER then
		if self._TransmitCheck then
			self:AddEFlags(EFL_FORCE_CHECK_TRANSMIT)
			self._TransmitCheck = nil
		end

		local nextTransmitCheck = (self._LastTransmitCheck or 0) + 2.5
		if now >= nextTransmitCheck then
			self:CheckTransmitState()
		end
	else
		if g_isWiremodLoaded then
			if now >= (self._NextRBUpdate or 0) then
				Wire_UpdateRenderBounds(self)
				self._NextRBUpdate = now + math.random(30, 100) / 10
			end
		end
	end
end

function ENT:StopStreamInternal()
	if not SERVER then return end
	if not IsValid(self.StreamObj) then return end

	self.StreamObj:Stop()
	self.StreamObj:SetURL("")
	self.StreamObj:SetStreamName("")
end

function ENT:PlayStreamInternal(url, name)
	if not SERVER then return end
	if not IsValid(self.StreamObj) then return end

	url = string.Trim(tostring(url or ""))
	name = string.Trim(tostring(name or ""))

	if url == "" then
		self:StopStreamInternal()
		return
	end

	if name == "" then
		name = url
	end

	self.StreamObj:RemoveChannel(true)
	self.StreamObj:SetURL(url)
	self.StreamObj:SetStreamName(name)
	self.StreamObj:Play(true)

	self:OnPlayStreamInternal(url, name)
end

function ENT:OnPlayStreamInternal(url, name)
	local owner = self:GetRealRadioOwner()
	local lastUser = self:GetLastUser()

	if not IsValid(lastUser) then
		lastUser = owner
	end

	LIBHook.RunCustom("OnPlayStream", url, name, self, lastUser)
end

function ENT:GetStreamURL()
	if not IsValid(self.StreamObj) then return "" end
	return self.StreamObj:GetURL()
end

function ENT:GetStreamName()
	if not IsValid(self.StreamObj) then return "" end
	return self.StreamObj:GetStreamName()
end

if SERVER then
	function ENT:SetStreamURL(...)
		if not IsValid(self.StreamObj) then return end
		self.StreamObj:SetURL(...)
	end

	function ENT:SetStreamName(...)
		if not IsValid(self.StreamObj) then return end
		self.StreamObj:SetStreamName(...)
	end
end

function ENT:ShowDebug()
	if self._showDebugCache ~= nil then
		return self._showDebugCache
	end

	self._showDebugCache = false

	if not LIBUtil.IsDebug() then
		return false
	end

	if CLIENT and not self:IsBeingLookedAt() then
		return false
	end

	self._showDebugCache = true
	return true
end

if CLIENT then
	function ENT:DrawTranslucent(flags)
		self:DrawModel(flags)

		if not g_isWiremodLoaded then return end
		Wire_Render(self)
	end

	function ENT:BeingLookedAtByLocalPlayer()
		local ply = LocalPlayer()
		if not IsValid( ply ) then
			return false
		end

		if not self:CheckDistanceToEntity(ply, 256) then
			return false
		end

		local tr = StreamRadioLib.Trace(ply)
		if not tr then
			return false
		end

		return tr.Entity == self
	end

	function ENT:IsBeingLookedAt()
		if self._beingLookedAtCache ~= nil then
			return self._beingLookedAtCache
		end

		local beingLookedAt = self:BeingLookedAtByLocalPlayer()
		self._beingLookedAtCache = beingLookedAt

		return beingLookedAt
	end

	return
else
	function ENT:WiremodThink()
		-- Override me
	end

	function ENT:AddWireInput(name, ptype, desc)
		if not g_isWiremodLoaded then return end

		name = string.Trim(tostring(name or ""))
		ptype = string.upper(string.Trim(tostring(ptype or "NORMAL")))
		desc = string.Trim(tostring(desc or ""))

		self._wireports = self._wireports or {}
		local wireports = self._wireports

		wireports.In = wireports.In or {}
		local inputs = wireports.In

		inputs.names = inputs.names or {}
		inputs.types = inputs.types or {}
		inputs.descs = inputs.descs or {}

		inputs.once = inputs.once or {}
		if inputs.once[name] then return end

		inputs.names[#inputs.names + 1] = name
		inputs.types[#inputs.types + 1] = ptype
		inputs.descs[#inputs.descs + 1] = desc
		inputs.once[name] = true
	end

	function ENT:AddWireOutput(name, ptype, desc)
		if not g_isWiremodLoaded then return end

		name = string.Trim(tostring(name or ""))
		ptype = string.upper(string.Trim(tostring(ptype or "NORMAL")))
		desc = string.Trim(tostring(desc or ""))

		self._wireports = self._wireports or {}
		local wireports = self._wireports

		wireports.Out = wireports.Out or {}
		local outputs = wireports.Out

		outputs.names = outputs.names or {}
		outputs.types = outputs.types or {}
		outputs.descs = outputs.descs or {}

		outputs.once = outputs.once or {}
		if outputs.once[name] then return end

		outputs.names[#outputs.names + 1] = name
		outputs.types[#outputs.types + 1] = ptype
		outputs.descs[#outputs.descs + 1] = desc
		outputs.once[name] = true
	end

	function ENT:InitWirePorts()
		if not g_isWiremodLoaded then return end

		if not self._wireports then return end

		if self._wireports.In then
			self.Inputs = WireLib.CreateSpecialInputs(self, self._wireports.In.names, self._wireports.In.types, self._wireports.In.descs)
		end

		if self._wireports.Out then
			self.Outputs = WireLib.CreateSpecialOutputs(self, self._wireports.Out.names, self._wireports.Out.types, self._wireports.Out.descs)
		end

		self._wireports = nil
	end

	function ENT:IsConnectedInputWire(name)
		if not g_isWiremodLoaded then return false end

		local wireinputs = self.Inputs
		if not istable(wireinputs) then return false end

		local wireinput = wireinputs[name]
		if not istable(wireinput) then return false end
		if not IsValid(wireinput.Src) then return false end

		return true
	end

	function ENT:IsConnectedOutputWire(name)
		if not g_isWiremodLoaded then return false end

		local wireoutputs = self.Outputs
		if not istable(wireoutputs) then return false end

		local wireoutput = wireoutputs[name]
		if not istable(wireoutput) then return false end
		if not istable(wireoutput.Connected) then return false end
		if not istable(wireoutput.Connected[1]) then return false end
		if not IsValid(wireoutput.Connected[1].Entity) then return false end

		return true
	end

	function ENT:HasWirelink(name)
		if not g_isWiremodLoaded then return false end

		local wireoutputs = self.Outputs
		if not istable(wireoutputs) then return false end

		local wireoutput = wireoutputs[name]
		if not istable(wireoutput) then return false end

		local value = wireoutput.Value
		if not isentity(value) then return false end
		if not IsValid(value) then return false end

		return true
	end

	local g_wirelinkName = "wirelink"

	function ENT:IsConnectedWirelink()
		if not g_isWiremodLoaded then return false end

		if not self.extended then
			-- wirelink had not been created yet
			return false
		end

		if self:HasWirelink(g_wirelinkName) then
			-- wirelink had been triggered via E2 code
			return true
		end

		if self:IsConnectedOutputWire(g_wirelinkName) then
			-- wirelink had been connected via Wire Tool
			return true
		end

		return false
	end

	function ENT:TriggerWireOutput(name, value)
		if not g_isWiremodLoaded then return end

		if isbool(value) or value == nil then
			value = value and 1 or 0
		end

		if value == self._WireOutputCache[name] and not istable(value) then return end
		self._WireOutputCache[name] = value

		WireLib.TriggerOutput(self, name, value)
	end

	function ENT:TriggerInput(name, value, ext)
		local wired = self:IsConnectedInputWire(name) or self:IsConnectedWirelink() or istable(ext) and ext.wirelink
		self:OnWireInputTrigger(name, value, wired)
	end

	function ENT:OnWireInputTrigger(name, value, wired)
		-- Override me
	end

	function ENT:OnRestore()
		if not g_isWiremodLoaded then return end

		WireLib.Restored( self )
	end

	function ENT:SetDupeData(key, value)
		self.DupeData = self.DupeData or {}
		self.DupeData[key] = table.Copy(value)
	end

	function ENT:GetDupeData(key)
		self.DupeData = self.DupeData or {}
		return self.DupeData[key]
	end

	function ENT:PermaPropSave()
		return {}
	end

	function ENT:PermaPropLoad(data)
		return true
	end

	function ENT:OnEntityCopyTableFinish(data)
		local done = {}

		-- Filter out all variables/members with an storable values
		-- to avoid any abnormal, invalid or unexpectedly shared entity stats on duping (especially for Garry-Dupe)
		local function recursive_filter(tab, newtable)
			if done[tab] then return tab end
			done[tab] = true

			if newtable then
				for k, v in pairs(tab) do
					if isfunction(k) or isfunction(v) then
						continue
					end

					if isentity(k) or isentity(v) then
						continue
					end

					if istable(k) then
						k = recursive_filter(k, {})
					end

					if istable(v) then
						newtable[k] = recursive_filter(v, {})
						continue
					end

					newtable[k] = v
				end

				return newtable
			end

			for k, v in pairs(tab) do
				if isfunction(k) or isfunction(v) then
					tab[k] = nil
					continue
				end

				if isentity(k) or isentity(v) then
					tab[k] = nil
					continue
				end

				if istable(k) then
					tab[k] = nil
					continue
				end

				if istable(v) then
					tab[k] = recursive_filter(v, {})
					continue
				end

				tab[k] = v
			end

			return tab
		end

		local EntityMods = data.EntityMods
		local PhysicsObjects = data.PhysicsObjects

		data.StreamObj = nil
		data._3dstreamradio_classobjs_data = nil
		data._3dstraemradio_classobjs_nw_register = nil
		data.StreamRadioDT = nil
		data.pl = nil
		data.Owner = nil

		data.Inputs = nil
		data.Outputs = nil

		data.BaseClass = nil
		data.OnDieFunctions = nil
		data.PhysicsObjects = nil
		data.EntityMods = nil

		data.old = nil

		if self.OnSetupCopyData then
			self:OnSetupCopyData(data)
		end

		-- Filter out all variables/members with an underscore in the beginning
		-- to avoid any abnormal, invalid or unexpectedly shared entity stats on duping (especially for Garry-Dupe)
		for k, v in pairs(data) do
			if isstring(k) and #k > 0 and k[1] == "_" then
				data[k] = nil
				continue
			end
		end

		recursive_filter(data)
		data.EntityMods = EntityMods
		data.PhysicsObjects = PhysicsObjects
	end

	function ENT:PreEntityCopy()
		if g_isWiremodLoaded then
			self:SetDupeData("Wire", WireLib.BuildDupeInfo(self))
		end

		local classsystem_classobjs_data = {}

		self:PreClasssystemCopy(classsystem_classobjs_data)

		self:SetDupeData("Classsystem", classsystem_classobjs_data)

		self:SetDupeData("Skin", {
			Color = self:GetColor(),
			Skin = self:GetSkin(),
		})

		self:SetDupeData("DupePoses", self:GetDupePoses())

		if self.OnPreEntityCopy then
			self:OnPreEntityCopy()
		end

		duplicator.StoreEntityModifier(self, "DupeData", self.DupeData)
	end

	function ENT:PostEntityPaste( ply, ent, CreatedEntities )
		if not IsValid(ent) then return end
		if not ent.EntityMods then return end

		local dupeData = table.Copy(ent.EntityMods.DupeData or {})

		local WireData = dupeData.Wire
		dupeData.Wire = nil

		if g_isWiremodLoaded and WireData then
			WireLib.ApplyDupeInfo(ply, ent, WireData, function(id, default)
				if id == nil then return default end
				if id == 0 then return game.GetWorld() end

				local ident = CreatedEntities[id]

				if not IsValid(ident) then
					if isnumber(id) then
						ident = ents.GetByIndex(id)
					end
				end

				if not IsValid(ident) then
					ident = default
				end

				return ident
			end)

			WireData = nil
		end

		local classobjs_data = dupeData.Classsystem
		dupeData.Classsystem = nil

		ent._3dstreamradio_classobjs_data = classobjs_data

		ent:PostClasssystemPaste(classobjs_data)

		if dupeData.Skin then
			ent:SetSkin(dupeData.Skin.Skin or 0)
			ent:SetColor(dupeData.Skin.Color or color_white)
		end

		dupeData.Skin = nil

		ent:SetDupePoses(dupeData.DupePoses)
		dupeData.DupePoses = nil

		if not ent.DupeDataApply then return end

		for key, value in pairs(dupeData) do
			ent:DupeDataApply(key, value)
		end
	end

	function ENT:ReapplyClasssystemPaste()
		local data = self._3dstreamradio_classobjs_data

		if not data then
			return
		end

		self:PostClasssystemPaste(data)
	end

	function ENT:PostClasssystemPaste(data)
		if not IsValid(self.StreamObj) then
			return
		end

		self.StreamObj:LoadFromDupe(data)
	end

	function ENT:PreClasssystemCopy(data)
		if not IsValid(self.StreamObj) then
			return
		end

		self.StreamObj:LoadToDupe(data)
	end

	function ENT:OnSetupCopyData(data)
		-- override me
	end

	function ENT:OnPreEntityCopy()
		-- override me
	end

	function ENT:DupeDataApply(key, value)
		-- override me
	end
end

--PATH addons/[miecze] moce i hilty/lua/entities/boulder/shared.lua:
return gluapack()()
--PATH lua/entities/cannon_blast.lua:
return gluapack()()
--PATH addons/[technik] darkrp-city-worker/lua/entities/cityworker_rubble/cl_init.lua:
include( "shared.lua" )
--PATH addons/!jobs/lua/entities/custom_moneyprinter/cl_init.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/darkrp_billboard/cl_init.lua:
include("shared.lua")

ENT.DrawPos = Vector(1, -111, 58)

ENT.Width = 558
ENT.Height = 290

ENT.HeaderMargin = 10
ENT.BodyMargin = 10

ENT.HeaderFont = "Trebuchet48"
ENT.BodyFont = "DermaLarge"

function ENT:Draw()
    self:DrawModel()

    local DrawPos = self:LocalToWorld(self.DrawPos)

    local DrawAngles = self:GetAngles()
    DrawAngles:RotateAroundAxis(self:GetAngles():Forward(), 90)
    DrawAngles:RotateAroundAxis(self:GetAngles():Up(), 90)

    local backgroundColor = self:GetBackgroundColor() * 255
    local barColor = self:GetBarColor() * 255
    local topText = DarkRP.textWrap(self:GetTopText(), self.HeaderFont, self.Width - self.BodyMargin * 2)

    local bottomText = string.gsub(string.gsub(self:GetBottomText() or "", "//", "\n"), "\\n", "\n")
    bottomText = DarkRP.textWrap(string.Replace(bottomText, "\\n", "\n"), self.BodyFont, self.Width - self.BodyMargin * 2)

    if not self.HeaderFontHeight then self.HeaderFontHeight = draw.GetFontHeight(self.HeaderFont) end

    local barHeight = 1
    for _ in string.gmatch(topText, "\n") do barHeight = barHeight + 1 end
    barHeight = self.HeaderMargin * 2 + barHeight * self.HeaderFontHeight

    local centerX = self.Width / 2

    render.EnableClipping(true)
    local normal = self:GetUp()
    render.PushCustomClipPlane(normal, normal:Dot(DrawPos - normal * self.Height * 0.4))

    cam.Start3D2D(DrawPos, DrawAngles, 0.4)

        surface.SetDrawColor(backgroundColor.x, backgroundColor.y, backgroundColor.z, 255)
        surface.DrawRect(0, 0, self.Width, self.Height)

        draw.RoundedBox(0, 0, 0, self.Width, barHeight, Color(barColor.x, barColor.y, barColor.z))

        draw.DrawText(topText, self.HeaderFont, centerX, self.HeaderMargin, color_white, TEXT_ALIGN_CENTER)
        draw.DrawText(bottomText, self.BodyFont, centerX, barHeight + self.BodyMargin, color_white, TEXT_ALIGN_CENTER)

    cam.End3D2D()

    render.PopCustomClipPlane()
    render.EnableClipping(false)
end

language.Add("Cleaned_advert_billboards", "Cleaned up Advert Billboards")
language.Add("Cleanup_advert_billboards", "Advert Billboards")
language.Add("Undone_advert_billboard", "Undone Advert Billboard")

--PATH gamemodes/starwarsrp/entities/entities/darkrp_cheque/cl_init.lua:
include("shared.lua")

ENT.TextColors = {
    OtherToSelf = Color(0, 255, 0, 255),
    SelfToSelf = Color(255, 255, 0, 255),
    SelfToOther = Color(0, 0, 255, 255),
    OtherToOther = Color(255, 0, 0, 255)
}

function ENT:Draw()
    self:DrawModel()

    local owner = self:Getowning_ent()
    local recipient = self:Getrecipient()
    local ownerplayer = owner:IsPlayer()
    local recipientplayer = recipient:IsPlayer()
    local localplayer = LocalPlayer()

    local Pos = self:GetPos()
    local Ang = self:GetAngles()
    local Up = Ang:Up()
    Up:Mul(0.9)
    Pos:Add(Up)

    surface.SetFont("ChatFont")
    local text = DarkRP.getPhrase("cheque_pay", recipientplayer and recipient:Nick() or DarkRP.getPhrase("unknown")) .. "\n" .. DarkRP.formatMoney(self:Getamount()) .. "\n" .. DarkRP.getPhrase("signed", ownerplayer and owner:Nick() or DarkRP.getPhrase("unknown"))

    cam.Start3D2D(Pos, Ang, 0.1)
        draw.DrawNonParsedText(text, "ChatFont", surface.GetTextSize(text) * -0.5, -25, localplayer:IsValid() and (ownerplayer and localplayer == owner and (recipientplayer and localplayer == recipient and self.TextColors.SelfToSelf or self.TextColors.SelfToOther) or recipientplayer and localplayer == recipient and self.TextColors.OtherToSelf) or self.TextColors.OtherToOther, 0)
    cam.End3D2D()
end
--PATH addons/[opt] decals/lua/entities/decal/cl_init.lua:
local decalsEnabled = CreateClientConVar( "decals_enabled", 1, true, false )

include "shared.lua"

AccessorFunc( ENT, "Editing", "Editing", FORCE_BOOL )
AccessorFunc( ENT, "Decal", "Decal" )
AccessorFunc( ENT, "Loaded", "Loaded", FORCE_BOOL )

AccessorFunc( ENT, "EditURL", "EditURL" )
AccessorFunc( ENT, "EditScale", "EditScale" )
AccessorFunc( ENT, "EditOpacity", "EditOpacity" )
AccessorFunc( ENT, "EditColor", "EditColor" )

function ENT:Initialize()
    self:SetEditing( false )
    self:SetLoaded( false )

    self:SetDecal( Material "icon16/error.png" )

    self:ResetEditing()
end

function ENT:ResetEditing()
    self:SetEditURL( self:GetURL() )
    self:SetEditScale( self:GetScale() )
    self:SetEditOpacity( self:GetOpacity() )
    self:SetEditColor( self:GetDecalColor() )
end

function ENT:Load()
    local url = self:GetEditing() and self:GetEditURL() or self:GetURL()

    Decals.Load.URL( url, function( mat )
        if mat then
            self:SetDecal( mat )

            self:SetLoaded( true )
        end
    end )
end

function ENT:Think()
    if !self:GetLoaded() and self:GetDecal():GetName() == "icon16/error" then
        self:Load()
    end
end

function ENT:Draw()
end

function ENT:Render()
	if EyePos():DistToSqr( self:GetPos() ) > Decals.cfg.RenderDistance ^ 2 then return end

    local scale = self:GetScale()
    local opacity = self:GetOpacity()
    local col = ColorAlpha( self:GetDecalColor():ToColor(), opacity )

    if self:GetEditing() then
        scale = self:GetEditScale()
        opacity = self:GetEditOpacity()
        col = ColorAlpha( self:GetEditColor():ToColor(), opacity )
    end

    local ang = self:GetAngles()
    ang:RotateAroundAxis( ang:Up(), 90 )

    local w, h = scale.x, scale.y

    cam.Start3D2D( self:GetPos(), ang, .05 )
        surface.SetMaterial( self:GetDecal() )
        surface.SetDrawColor( col )
        surface.DrawTexturedRect( -w / 2, -h / 2, w, h )
    cam.End3D2D()
end
--PATH lua/entities/decs_loader/shared.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/dioxis_spawned/cl_init.lua:
include("shared.lua")

local gasEntities = {}

function ENT:Initialize()
    table.insert(gasEntities, self)
end

function ENT:OnRemove()
    table.RemoveByValue(gasEntities, self)
end

function ENT:Draw(flags)
    self:DrawShadow(false)
end 

function ENT:DrawPukeVision()
    if (!IsValid(GetViewEntity())) then
        return
    end

    local dist = GetViewEntity():NearestPoint(self:GetPos()):DistToSqr(self:GetPos()) - (64 * 64)
    
    if (dist > self.GasRadius * self.GasRadius) then
        return
    end
        
    local delta = 1 - (dist / (self.GasRadius * self.GasRadius))
    local time = self:GetCreationTime() + self.LifeTime
    local fadeout = math.Clamp(time - CurTime(), 0, 0.5) * 2
    local fadein = math.Clamp(math.abs(CurTime() - self:GetCreationTime()), 0, 1)
        
    delta = delta * fadein
    delta = delta * fadeout

    surface.SetDrawColor(117, 143, 53, 200 * delta)
    surface.DrawRect(0, 0, ScrW(), ScrH())
end
hook.Add("HUDPaintBackground", "COD2019_GasVision", function()
    for _, e in pairs(gasEntities) do
        e:DrawPukeVision()
    end
end)
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/dioxis_spawned/shared.lua:
ENT.Base = "base_entity"
ENT.Type = "anim"

ENT.GasRadius = 250
ENT.LifeTime = 30

PrecacheParticleSystem("AC_nade_gas_dust")
PrecacheParticleSystem("AC_nade_gas_explode")

sound.Add({
    name = "Kraken_Explosives.DioxisLoop",
    channel = CHAN_BODY, 
    volume = 0.25, 
    level = 75,
    pitch = {95, 105},
    sound = {"kraken/explosives/dioxis/loop.wav"}
}) 

sound.Add({
    name = "Kraken_Explosives.DioxisExplode",
    channel = CHAN_ITEM,
    volume = 1, 
    level = 100,
    pitch = {95, 105},
    sound = {
        "kraken/explosives/dioxis/start1.wav",
        "kraken/explosives/dioxis/start2.wav",
        "kraken/explosives/dioxis/start3.wav",
        "kraken/explosives/dioxis/start4.wav",
}
}) 
--PATH gamemodes/starwarsrp/entities/entities/drug/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Drugs"
ENT.Author = "Rickster"
ENT.Spawnable = false

function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "price")
    self:NetworkVar("Entity", 1, "owning_ent")
end

hook.Add("Move", "DruggedPlayer", function(ply, mv)
    if not ply.isDrugged then return end

    mv:SetMaxSpeed(mv:GetMaxSpeed() * 2)
    mv:SetMaxClientSpeed(mv:GetMaxClientSpeed() * 2)

    if ply:IsOnGround() and mv:KeyPressed(IN_JUMP) then
        local vec = mv:GetVelocity()
        vec.z = 100 -- Adds on to the jump power
        mv:SetVelocity(vec)
    end
end)

--PATH lua/entities/ent_rw_rocket/shared.lua:
ENT.Type 			= "anim"  
ENT.PrintName			= "CW Rocket"  
ENT.Spawnable			= false
ENT.AdminSpawnable		= false

local rSound = Sound("Missile.Accelerate")

if SERVER then

AddCSLuaFile( "shared.lua" )

function ENT:Initialize()   

self.flightvector = self.Entity:GetForward() * ((30*15.5)/5)
self.timeleft = CurTime() + 15
self.Owner = self:GetOwner()
self.Entity:SetModel( "models/sw_battlefront/weapons/rocketprojectile.mdl" )
self.Entity:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,  	
self.Entity:SetMoveType( MOVETYPE_NONE )   --after all, gmod is a physics  	
self.Entity:SetSolid( SOLID_VPHYSICS )        -- CHEESECAKE!    >:3     
self.Entity:EmitSound(rSound, 75, 100)

--self.Entity:SetColor(Color(128 255 0,255))

Glow = ents.Create("env_sprite")
Glow:SetKeyValue("rendercolor","255, 255, 255")
Glow:SetKeyValue("scale","1")
Glow:SetPos(self.Entity:GetPos())
Glow:SetParent(self.Entity)
Glow:Spawn()
Glow:Activate()
self.Entity:SetNWBool("smoke", 10, true)

end   

 function ENT:Think()

		if self.timeleft < CurTime() then
		self.Entity:Remove()
		end

	Table	={} 			//Table name is table name
	Table[1]	=self.Owner 		//The person holding the gat
	Table[2]	=self.Entity 		//The cap

	local trace = {}
		trace.start = self.Entity:GetPos()
		trace.endpos = self.Entity:GetPos() + self.flightvector
		trace.filter = Table
	local tr = util.TraceLine( trace )
	

		if tr.HitSky then
			self.Entity:Remove()
			return true
		end
	
		if tr.Hit then
				local effectdata = EffectData()
					effectdata:SetOrigin(tr.HitPos)			// Where is hits
					effectdata:SetNormal(tr.HitNormal)		// Direction of particles
					effectdata:SetEntity(self.Entity)		// Who done it?
					effectdata:SetScale(2)			        // Size of explosion
					effectdata:SetRadius(tr.MatType)		// What texture it hits
					effectdata:SetMagnitude(18)			    // Length of explosion trails
					util.Effect( "rw_rocket_explosion", effectdata )
					util.BlastDamage(self.Entity, self:OwnerGet(), tr.HitPos, 450, 1000)
					util.Decal("Scorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)
					self.Entity:SetNWBool("smoke", false)
					
			self:Explosion()
			self.Entity:Remove()	
		end
	
	self.Entity:SetPos(self.Entity:GetPos() + self.flightvector)
	self.flightvector = self.flightvector - (self.flightvector/1500)  + Vector(math.Rand(-0.2,0.2), math.Rand(-0.2,0.2),math.Rand(-0.2,0.2)) + Vector(0,0,-0.05)
	self.Entity:SetAngles(self.flightvector:Angle() + Angle(0,0,0))
	self.Entity:NextThink( CurTime() )
	return true
	
end
 
 function ENT:Explosion()

	self:EmitSound("BaseExplosionEffect.Sound", 500, 100)	
	self.Entity:StopSound(rSound)

	local shake = ents.Create("env_shake")
		shake:SetOwner(self.Owner)
		shake:SetPos(self.Entity:GetPos())
		shake:SetKeyValue("amplitude", "2000")	// Power of the shake
		shake:SetKeyValue("radius", "900")		// Radius of the shake
		shake:SetKeyValue("duration", "2.5")	// Time of shake
		shake:SetKeyValue("frequency", "1225")	// How har should the screenshake be
		shake:SetKeyValue("spawnflags", "4")	// Spawnflags(In Air)
		shake:Spawn()
		shake:Activate()
		shake:Fire("StartShake", "", 0)
	
	local ar2Explo = ents.Create("env_fire")
		ar2Explo:SetOwner(self.Owner)
		ar2Explo:SetPos(self.Entity:GetPos())
		ar2Explo:Spawn()
		ar2Explo:Activate()
		ar2Explo:Fire("Explode", "", 0)

end

function ENT:OwnerGet()
	if IsValid(self.Owner) then
		return self.Owner
	else
		return self.Entity
	end
end

end

if CLIENT then
 function ENT:Draw()             
 	self.Entity:DrawModel()       // Draw the model.   
 end
 
   function ENT:Initialize()
	pos = self:GetPos()
	self.emitter = ParticleEmitter( pos )
 end
 
 function ENT:Think()
	if (self.Entity:GetNWBool("smoke")) then
	pos = self:GetPos()
		for i=1, (1) do
			local particle = self.emitter:Add( "particle/smokesprites_000"..math.random(1,9), pos + (self:GetForward() * -10 * i))
			if (particle) then
				particle:SetVelocity((self:GetForward() * -400)+(VectorRand()* 10) )
				particle:SetDieTime( math.Rand( 10, 5 ) )
				particle:SetStartAlpha( math.Rand( 85, 115 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand( 10, 1 ) )
				particle:SetEndSize( 1 )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-1, 1) )
				particle:SetColor( 115 , 115 , 115 ) 
 				particle:SetAirResistance( 200 ) 
 				particle:SetGravity( Vector( 100, 0, 0 ) ) 	
			end
		
		end
	end
end
end
--PATH addons/[tfres] frest_levels/lua/entities/f_leaderboard/shared.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/fadmin_jail/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "fadmin_jail"
ENT.Author = "FPtje"
ENT.Spawnable = false

function ENT:CanTool()
    return false
end

function ENT:PhysgunPickup(ply)
    return false
end

--PATH gamemodes/starwarsrp/entities/entities/food/shared.lua:
return gluapack()()
--PATH lua/entities/gb_rp_sign_wire/shared.lua:
return gluapack()()
--PATH lua/entities/gmod_contr_spawner/cl_init.lua:
include( "shared.lua" )

function ENT:Draw()
	self.BaseClass.Draw(self)
	self.Entity:DrawModel()
end

--PATH lua/entities/gmod_contr_spawner/shared.lua:
ENT.Type 			= "anim"
ENT.Base			= WireLib and "base_wire_entity" or "base_gmodentity"
ENT.PrintName		= "Contraption Spawner"
ENT.Author			= "TB"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

--PATH lua/entities/heart_turbolaser/cl_init.lua:
include("shared.lua");
util.PrecacheModel("models/heart/turbolaser_bolt.mdl");
util.PrecacheModel("models/heart/turbolaser_glow.mdl");

function ENT:Initialize()
	self.model = ClientsideModel("models/heart/turbolaser_bolt.mdl");
	self.model:SetModelScale(self:GetScale(), 0);

	self.glow = ClientsideModel("models/heart/turbolaser_glow.mdl");
	self.glow:SetModelScale(self:GetScale(), 0);
	self.glow:SetColor(Color(self:GetColR(),self:GetColG(),self:GetColB()));
end

function ENT:Draw()
end

function ENT:Think()
	if not self:IsValid() then
		self.model:Remove();
		self.glow:Remove();
	end

	self.model:SetPos(self:GetPos());
	self.model:SetAngles(self:GetAngles());

	self.glow:SetPos(self:GetPos());
	self.glow:SetAngles(self:GetAngles());
end

function ENT:OnRemove()
	self.model:Remove();
	self.glow:Remove();
end

language.Add("heart_turbolaser", "Turbolaser");
--PATH lua/entities/heart_turbolaser_spawner/cl_init.lua:
include("shared.lua");

function ENT:Initialize()
end

function ENT:Draw()
end

function ENT:Think()
end

function ENT:OnRemove()
end

--PATH lua/entities/intercom/client.lua:
local COL_WHT = Color(255, 255, 255)
local COL_2 = Color(255,0,0)

local COL_1 = Color(0,0,0,180)

local w, h = 0, 0
local W2, H2 = 0, 0

function ENT:Draw()
    self:DrawModel()
    
    local EYE = LocalPlayer():GetEyeTrace()

    if EYE and IsValid(EYE.Entity) and EYE.Entity == self then
        local ang = self:LocalToWorldAngles(Angle(0, -90, 90))
        local CENTER = self:OBBCenter()

        local ACCENT = RDV.LIBRARY.GetConfigOption("INT_entOverhead")

        cam.Start3D2D(self:LocalToWorld(Vector(0, CENTER.y, self:OBBMaxs().z)) + Vector(0, 0, 10), ang, 0.1)
            draw.RoundedBox(0, -( w / 2 ), 0, w, h, COL_1)
            draw.RoundedBox(0, -( w / 2), h - (h / 12), w, (h / 12), ACCENT)

            if self:GetIntercomUsing() then
                w, h = draw.SimpleText(RDV.LIBRARY.GetLang(nil, "INTERCOM_Title"), "RD_FONTS_CORE_OVERHEAD", 0, 0, COL_WHT, TEXT_ALIGN_CENTER)
                W2, H2 = draw.SimpleText(RDV.LIBRARY.GetLang(nil, "INTERCOM_Live"), "RD_FONTS_CORE_OVERHEAD", 0, 30, COL_2, TEXT_ALIGN_CENTER)
            else
                w, h = draw.SimpleText(RDV.LIBRARY.GetLang(nil, "INTERCOM_Title"), "RD_FONTS_CORE_OVERHEAD", 0, 0, COL_WHT, TEXT_ALIGN_CENTER)
                W2, H2 = 0, 0
            end

        cam.End3D2D()

        w = w + W2 + 10
        h = h + H2 + 10
    end
end

net.Receive("RDV.INTERCOM.TOGGLE", function()
    local ENABLED = net.ReadBool()

    if ENABLED then
        local SOUND = RDV.LIBRARY.GetConfigOption("INT_soundStart")

        surface.PlaySound(SOUND)
    else
        local SOUND = RDV.LIBRARY.GetConfigOption("INT_soundEnd")

        surface.PlaySound(SOUND)
    end
end)
--PATH lua/entities/kingpommes_swv_patroltransport_rep.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/kraken_proj_base.lua:
AddCSLuaFile()

ENT.Type                     = "anim"
ENT.Base                     = "base_entity"
ENT.RenderGroup              = RENDERGROUP_TRANSLUCENT

ENT.PrintName                = "Base Projectile"
ENT.Category                 = ""

ENT.Spawnable                = false
ENT.Model                    = ""

local smokeimages = {"particle/particle_smokegrenade"}
local function GetSmokeImage()
    return smokeimages[math.random(#smokeimages)]
end

game.AddParticles("particles/mw2019_rockettrail.pcf")
PrecacheParticleSystem("rockettrail")

ENT.Material = false -- custom material
ENT.IsRocket = false -- projectile has a booster and will not drop.
ENT.Sticky = false -- projectile sticks on impact

ENT.InstantFuse = true -- projectile is armed immediately after firing.
ENT.TimeFuse = false -- projectile will arm after this amount of time
ENT.RemoteFuse = false -- allow this projectile to be triggered by remote detonator.
ENT.ImpactFuse = false -- projectile explodes on impact.
ENT.StickyFuse = false -- projectile becomes timed after sticking.
ENT.NoBounce = false -- projectile doesn't bounce.
ENT.BounceWall = false -- projectile doesn't detonate until it hits the ground

ENT.RemoveOnImpact = false
ENT.ExplodeOnImpact = false
ENT.ExplodeOnDamage = false -- projectile explodes when it takes damage.
ENT.ExplodeUnderwater = false -- projectile explodes when it enters water

ENT.Defusable = false -- press E on the projectile to defuse it
ENT.DefuseOnDamage = false

ENT.ImpactDamage = 25
ENT.ImpactDamageSpeed = 1000

ENT.Delay = 5 -- after being triggered and this amount of time has passed, the projectile will explode.
ENT.Armed = false

ENT.RocketTrailParticle = "rockettrail"  -- name of the particle effect
ENT.RocketTrail = false -- leaves trail of a particle effct
ENT.SmokeTrail = false -- leaves trail of smoke
ENT.SmokeColor = Color(255, 165, 0)
ENT.Flare = true
ENT.FlareColor = nil
ENT.FlareSizeMin = 50
ENT.FlareSizeMax = 100

ENT.AudioLoop = nil
ENT.BounceSounds = nil
ENT.CollisionSphere = nil

ENT.GunshipWorkaround = true

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "Weapon")
end

function ENT:Initialize()
    if SERVER then
        self:SetModel(self.Model)
        self:SetMaterial(self.Material or "")
        if self.CollisionSphere then
            self:PhysicsInitSphere(self.CollisionSphere)
        else
            self:PhysicsInit(SOLID_VPHYSICS)
        end
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)

        self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)
        if self.Defusable then
            self:SetUseType(SIMPLE_USE)
        end

        local phys = self:GetPhysicsObject()
        if !phys:IsValid() then
            self:Remove()
            return
        end

        phys:EnableDrag(false)
        phys:SetDragCoefficient(0)
        phys:SetBuoyancyRatio(0)
        phys:Wake()

        if self.IsRocket then
            phys:EnableGravity(false)
			phys:SetMass(5)
        end
    end

    self.SpawnTime = CurTime()

    self.NPCDamage = IsValid(self:GetOwner()) and self:GetOwner():IsNPC() and self:GetOwner():IsNextBot()

    if self.AudioLoop then
        self.LoopSound = CreateSound(self, self.AudioLoop)
        self.LoopSound:Play()
	   if self:GetNWBool("HasDetonated") then
       self.LoopSound:Stop()
       end
    end

    if self.InstantFuse then
        self.ArmTime = CurTime()
        self.Armed = true
    end
	
    if self.RocketTrail then
	   ParticleEffectAttach(self.RocketTrailParticle, PATTACH_ABSORIGIN_FOLLOW, self, 0)
	   if self:GetNWBool("HasDetonated") then
       self.RocketTrail = false
       end
    end
	
	self.HitSkybox = false
    self:OnInitialize()
end

function ENT:OnRemove()
    if self.LoopSound then
        self.LoopSound:Stop()
    end
	self:StopParticles()
end

function ENT:OnTakeDamage(dmg)
    if self.Detonated then return end

    -- self:TakePhysicsDamage(dmg)

    if self.ExplodeOnDamage then
        if IsValid(self:GetOwner()) and IsValid(dmg:GetAttacker()) then self:SetOwner(dmg:GetAttacker())
        else self.Attacker = dmg:GetAttacker() or self.Attacker end
        self:PreDetonate(data)
    elseif self.DefuseOnDamage and dmg:GetDamageType() != DMG_BLAST then
        self:EmitSound("physics/plastic/plastic_box_break" .. math.random(1, 2) .. ".wav", 70, math.Rand(95, 105))
        local fx = EffectData()
        fx:SetOrigin(self:GetPos())
        fx:SetNormal(self:GetAngles():Forward())
        fx:SetAngles(self:GetAngles())
        util.Effect("ManhackSparks", fx)
        self.Detonated = true
        self:Remove()
    end
end

function ENT:PhysicsCollide(data, collider, physobj)
    if IsValid(data.HitEntity) and data.HitEntity:GetClass() == "func_breakable_surf" then
        self:FireBullets({
            Attacker = self:GetOwner(),
            Inflictor = self,
            Damage = 0,
            Distance = 32,
            Tracer = 0,
            Src = self:GetPos(),
            Dir = data.OurOldVelocity:GetNormalized(),
	        })
        local pos, ang, vel = self:GetPos(), self:GetAngles(), data.OurOldVelocity
        self:SetAngles(ang)
        self:SetPos(pos)
        self:GetPhysicsObject():SetVelocityInstantaneous(vel * 0.5)
        return
    end
	
    -- local theirProps = util.GetSurfaceData(data.TheirSurfaceProps)
    -- if (theirProps != nil && theirProps.material == MAT_DEFAULT) then
    -- timer.Simple(0, function() self:Remove() end)
    -- return
    -- end
	
    if self.BounceWall then
        local ang = data.HitNormal:Angle()
        ang.p = math.abs( ang.p )
        ang.y = math.abs( ang.y )
        ang.r = math.abs( ang.r )
	
        if ang.p > 90 or ang.p < 60 then
        --self:EmitSound(Sound("GlassBottle.ImpactHard"))
		self:SetNWBool("HasDetonated",true)

        local impulse = (data.OurOldVelocity - 2 * data.OurOldVelocity:Dot(data.HitNormal) * data.HitNormal)*0.25
        collider:ApplyForceCenter(impulse)
        else
        self:PreDetonate(data)
        end
    end
	
    if self.ImpactFuse and !self.Armed then
        self.ArmTime = CurTime()
        self.Armed = true

        if self:Impact(data, collider) then
            return
        end

        if self.Delay == 0 or self.ExplodeOnImpact then
            self:PreDetonate(data)
        end
    elseif self.ImpactDamage > 0 and IsValid(data.HitEntity) and (engine.ActiveGamemode() != "terrortown" or !data.HitEntity:IsPlayer()) then
        local dmg = DamageInfo()
        dmg:SetAttacker(IsValid(self:GetOwner()) and self:GetOwner() or self.Attacker)
        dmg:SetInflictor(self)
        dmg:SetDamage(Lerp((data.OurOldVelocity:Length() - 0.6 * self.ImpactDamageSpeed) / 0.4 * self.ImpactDamageSpeed, self.ImpactDamage / 5, self.ImpactDamage))
        dmg:SetDamageType(DMG_CRUSH + DMG_CLUB)
        dmg:SetDamageForce(data.OurOldVelocity)
        dmg:SetDamagePosition(data.HitPos)
        data.HitEntity:TakeDamageInfo(dmg)
    elseif !self.ImpactFuse then
        self:Impact(data, collider)
    end

    if self.Sticky then
        self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
        self:SetPos(data.HitPos)
        self:SetAngles(self:GetAngles())
        self.Attacker = self:GetOwner()
        self:SetOwner(NULL)

        if data.HitEntity:IsWorld() or data.HitEntity:GetSolid() == SOLID_BSP then
            self:SetMoveType(MOVETYPE_NONE)
            self:SetPos(data.HitPos)
        else
            self:SetPos(data.HitPos)
            self:SetParent(data.HitEntity)
        end

        self:EmitSound("weapons/cod2019/shared/blt_imp_flesh_plr_04.ogg",75, 100, 1, CHAN_AUTO)

        if self.StickyFuse and !self.Armed then
            self.ArmTime = CurTime()
            self.Armed = true
        end

        self:Stuck()
		self:SetNWBool("HasDetonated",true)
    end
	
    if self.NoBounce then
	  timer.Simple(0, function()
       self:SetPos(self:GetPos())
	   self:GetPhysicsObject():SetVelocityInstantaneous(data.OurNewVelocity * 0.1)
	  end)
	  self:SetNWBool("HasDetonated",true)
    end

    if data.DeltaTime < 0.1 then return end
    if !self.BounceSounds then return end

    local s = table.Random(self.BounceSounds)
    self:EmitSound(s)
end

function ENT:OnThink()
end

function ENT:OnInitialize()
end

function ENT:DoSmokeTrail()
    if CLIENT and self.SmokeTrail then
        local emitter = ParticleEmitter(self:GetPos())

        local smoke = emitter:Add(GetSmokeImage(), self:GetPos())

        smoke:SetStartAlpha(50)
        smoke:SetEndAlpha(0)

        smoke:SetStartSize(10)
        smoke:SetEndSize(math.Rand(50, 75))

        smoke:SetRoll(math.Rand(-180, 180))
        smoke:SetRollDelta(math.Rand(-1, 1))

        smoke:SetPos(self:GetPos())
        smoke:SetVelocity(-self:GetAngles():Forward() * 400 + (VectorRand() * 10))

        smoke:SetColor(self.SmokeColor)
        smoke:SetLighting(true)

        smoke:SetDieTime(math.Rand(0.75, 1.25))

        smoke:SetGravity(Vector(0, 0, 0))

        emitter:Finish()
		
       if self:GetNWBool("HasDetonated") then
          self.SmokeTrail = false
       end
    end
end

function ENT:Think()
    if self.Defused then return end

    if self.SpawnTime + self.LifeTime < CurTime() then
        self:Detonate()
        return
    end

    if self:WaterLevel() > 0 then
        self:Detonate()
        return
    end

    local drunk = false

    if self.FireAndForget or self.SemiActive then
        if self.SemiActive then
            if IsValid(self.Weapon) then
                self.ShootEntData = self.Weapon:RunHook("Hook_GetShootEntData", {})
            end
        end

        if self.ShootEntData.Target and IsValid(self.ShootEntData.Target) then
            local target = self.ShootEntData.Target
            if target.UnTrackable then self.ShootEntData.Target = nil end

            -- if self.TopAttack then
            --     local tpos = target:GetPos() + Vector(0, 0, 5000)
            --     if self.SpawnTime + self.TopAttackTime - 1 < CurTime() or self.TopAttackReached then
            --         tpos = target:GetPos()
            --     end
            --     local dir = (tpos - self:GetPos()):GetNormalized()
            --     local dist = (tpos - self:GetPos()):Length()
            --     local ang = dir:Angle()

            --     local p = self:GetAngles().p
            --     local y = self:GetAngles().y

            --     p = math.ApproachAngle(p, ang.p, FrameTime() * self.SteerSpeed)
            --     y = math.ApproachAngle(y, ang.y, FrameTime() * self.SteerSpeed)

            --     self:SetAngles(Angle(p, y, 0))

            --     if dist <= 1024 then
            --         self.TopAttackReached = true
            --     end
            -- else
            local tpos = target:EyePos()
            if self.TopAttack and !self.TopAttackReached then
                tpos = tpos + Vector(0, 0, self.TopAttackHeight)

                local dist = (tpos - self:GetPos()):Length()

                if dist <= 2000 then
                    self.TopAttackReached = true
                    self.SuperSteerTime = CurTime() + self.SuperSteerBoostTime
                end
            end
            local dir = (tpos - self:GetPos()):GetNormalized()
            local dot = dir:Dot(self:GetAngles():Forward())
            local ang = dir:Angle()

            if self.SuperSeeker or dot >= self.SeekerAngle or !self.TopAttackReached or (self.SuperSteerTime and self.SuperSteerTime >= CurTime()) then
                local p = self:GetAngles().p
                local y = self:GetAngles().y

                p = math.ApproachAngle(p, ang.p, FrameTime() * self.SteerSpeed)
                y = math.ApproachAngle(y, ang.y, FrameTime() * self.SteerSpeed)

                self:SetAngles(Angle(p, y, 0))
                -- self:SetVelocity(dir * 15000)
            elseif self.NoReacquire then
                self.ShootEntData.Target = nil
                drunk = true
            end
            -- end
        else
            drunk = true
        end
    elseif self.SACLOS then
        if self:GetOwner():IsValid() then
            local tpos = self:GetOwner():GetEyeTrace().HitPos
            local dir = (tpos - self:GetPos()):GetNormalized()
            local dot = dir:Dot(self:GetAngles():Forward())
            local ang = dir:Angle()

            if dot >= self.SeekerAngle then
                local p = self:GetAngles().p
                local y = self:GetAngles().y

                p = math.ApproachAngle(p, ang.p, FrameTime() * self.SteerSpeed)
                y = math.ApproachAngle(y, ang.y, FrameTime() * self.SteerSpeed)

                self:SetAngles(Angle(p, y, 0))
            else
                drunk = true
            end
        else
            drunk = true
        end
    end

    if drunk then
        self:SetAngles(self:GetAngles() + (AngleRand() * FrameTime() * 1000 / 360))
    end

    self:GetPhysicsObject():AddVelocity(Vector(0, 0, self.Lift) + self:GetForward() * self.Boost)

    -- Gunships have no physics collection, periodically trace to try and blow up in their face
    if self.GunshipWorkaround and (self.GunshipCheck or 0 < CurTime()) then
        self.GunshipCheck = CurTime() + 0.33
        local tr = util.TraceLine({
            start = self:GetPos(),
            endpos = self:GetPos() + (self:GetVelocity() * 6 * engine.TickInterval()),
            filter = self,
            mask = MASK_SHOT
        })
        if IsValid(tr.Entity) and gunship[tr.Entity:GetClass()] then
            self:SetPos(tr.HitPos)
            self:Detonate()
        end
    end
end


function ENT:Think(data)
    if !IsValid(self) or self:GetNoDraw() then return end

    if !self.SpawnTime then
        self.SpawnTime = CurTime()
    end

    if !self.Armed and isnumber(self.TimeFuse) and self.SpawnTime + self.TimeFuse < CurTime() then
        self.ArmTime = CurTime()
        self.Armed = true
    end

    if self.Armed and self.ArmTime + self.Delay < CurTime() then
        self:PreDetonate(data)
    end
	
    if self.ExplodeUnderwater and self:WaterLevel() > 0 then
        self:PreDetonate(data)
		elseif self:WaterLevel() > 0 then
		local phys = self:GetPhysicsObject()
	    if phys:IsValid() then
		   phys:EnableGravity(true)
		   phys:EnableMotion(true)
		   phys:EnableDrag(false)
		   phys:SetMass(10)
	    end
		self:SetNWBool("HasDetonated",true)
		self:StopParticles()
    end
	
	if (self:WaterLevel() > 0) then
		self:StopParticles()
	end
	
    local gunship = {["npc_combinegunship"] = true,["npc_combinedropship"] = true}

    if SERVER and self.GunshipWorkaround and (self.GunshipCheck or 0 < CurTime()) then
            self.GunshipCheck = CurTime() + 0.33
            local tr = util.TraceLine({
                start = self:GetPos(),
                endpos = self:GetPos() + (self:GetVelocity() * 6 * engine.TickInterval()),
                filter = {self:GetOwner(), self},
                mask = MASK_SHOT_PORTAL,
                collisiongroup = COLLISION_GROUP_PROJECTILE,
            })
        if IsValid(tr.Entity) and gunship[tr.Entity:GetClass()] then
           self:SetPos(tr.HitPos)
           self:PreDetonate(data)
        end
    end

    self:DoSmokeTrail()
    self:OnThink()
end

function ENT:Use(ply)
    if !self.Defusable then return end

    self:EmitSound("TacRP/weapons/rifle_jingle-1.wav")

    if self.PickupAmmo then
        ply:GiveAmmo(1, self.PickupAmmo, true)
    end

    self:Remove()
end

function ENT:RemoteDetonate()
    self:EmitSound("TacRP/weapons/c4/relay_switch-1.wav")

    self.ArmTime = CurTime()
    self.Armed = true
end

function ENT:PreDetonate(data)
    if CLIENT then return end

    if !self.Detonated then
        self.Detonated = true

        if !IsValid(self.Attacker) and !IsValid(self:GetOwner()) then self.Attacker = game.GetWorld() end

        self:Detonate(data)
		self:SetNWBool("HasDetonated",true)
  end
end

function ENT:Detonate(data)
    -- fill this in :)
end

function ENT:Impact()
end

function ENT:Stuck()

end

function ENT:DrawTranslucent()
    self:Draw()
end

local mat = Material("mw19/flair_sprite_01")

function ENT:Draw()
    self:DrawModel()
   if self.Flare then
    if self.FlareColor then
        local mult = self.SafetyFuse and math.Clamp((CurTime() - (self.SpawnTime + self.SafetyFuse)) / self.SafetyFuse, 0.1, 1) or 1
        render.SetMaterial(mat)
        render.DrawSprite(self:GetPos() + (self:GetAngles():Forward() * -20), mult * math.Rand(self.FlareSizeMin, self.FlareSizeMax), mult * math.Rand(self.FlareSizeMin, self.FlareSizeMax), self.FlareColor)
    end
	 if self:GetNWBool("HasDetonated") then
     self.Flare = false
     end
   end
end

hook.Add("EntityTakeDamage", "cod2019_proj_collision", function(ent, dmginfo)
    if IsValid(dmginfo:GetInflictor())
            and scripted_ents.IsBasedOn(dmginfo:GetInflictor():GetClass(), "arc9_cod2019_proj_base")
            and dmginfo:GetDamageType() == DMG_CRUSH then dmginfo:SetDamage(0) return true end
end)
--PATH lua/entities/laat_detonator/shared.lua:
return gluapack()()
--PATH lua/entities/landspeeder.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "speeder_base"
ENT.Type = "vehicle"

ENT.PrintName = "X-34 Landspeeder"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Other"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.Vehicle = "Speeder";
ENT.EntModel = "models/SGG/Starwars/landspeeder.mdl";
ENT.StartHealth = 1000;
list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then

ENT.NextUse = {Use = CurTime(),Fire = CurTime()};
ENT.FireSound = Sound("weapons/xwing_shoot.wav");


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("landspeeder");
	e:SetPos(tr.HitPos + Vector(0,0,10));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw+270,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()
	self.SeatClass = "phx_seat2";
	self.BaseClass.Initialize(self);
	local driverPos = self:GetPos()+self:GetUp()*20+self:GetRight()*50+self:GetForward()*-10;
	local driverAng = self:GetAngles();
	local passPos = self:GetPos()+self:GetUp()*25+self:GetRight()*40+self:GetForward()*20;
	self:SpawnChairs(driverPos,driverAng,true,passPos,driverAng);
	
	self.ForwardSpeed = -650;
	self.BoostSpeed = -1000
	self.AccelSpeed = 6;
	self.HoverMod = 3;
	self.CanBack = true;
	self.StartHover = 55;
	self.StandbyHoverAmount = 50;

end


function ENT:OnTakeDamage(dmg) --########## Shuttle's aren't invincible are they? @RononDex

	local health=self:GetNetworkedInt("Health")-(dmg:GetDamage()/2)

	self:SetNWInt("Health",health);
	
	if(health<100) then
		self.CriticalDamage = true;
		self:SetNWBool("CriticalDamage",true);
	end
	
	
	if((health)<=0) then
		self:Bang() -- Go boom
	end
end

local ZAxis = Vector(0,0,1);
function ENT:PhysicsSimulate( phys, deltatime )
	self.BackPos = self:GetPos()+self:GetUp()*20+self:GetRight()*120+self:GetForward()*5;
	self.FrontPos = self:GetPos()+self:GetUp()*20+self:GetRight()*-120+self:GetForward()*5;
	self.MiddlePos = self:GetPos()+self:GetUp()*20+self:GetForward()*5;
	if(self.Inflight) then
		local UP = ZAxis;
		self.RightDir = self.Entity:GetForward();
		self.FWDDir = self.Entity:GetForward():Cross(UP):GetNormalized();	
		

		
		self:RunTraces();

		self.ExtraRoll = Angle(self.YawAccel / 2*-1,0,0);
		if(!self.WaterTrace.Hit) then
			if(self.FrontTrace.HitPos.z >= self.BackTrace.HitPos.z) then
				self.PitchMod = Angle(0,0,math.Clamp((self.BackTrace.HitPos.z - self.FrontTrace.HitPos.z),-45,45)/2*-1)
			else
				self.PitchMod = Angle(0,0,math.Clamp(-(self.FrontTrace.HitPos.z - self.BackTrace.HitPos.z),-45,45)/2*-1)
			end
		end
	end

	
	self.BaseClass.PhysicsSimulate(self,phys,deltatime);
	

end

end

if CLIENT then
	ENT.Sounds={
		Engine=Sound("vehicles/landspeeder/t47_fly2.wav"),
	}
	
	local Health = 0;
	function ENT:Think()
		self.BaseClass.Think(self);
		local p = LocalPlayer();
		local Flying = p:GetNWBool("Flying"..self.Vehicle);
		if(Flying) then
			Health = self:GetNWInt("Health");
			local EnginePos = {
				Left = 	self:GetPos()+self:GetRight()*85+self:GetForward()*-64+self:GetUp()*30,
				Middle = self:GetPos()+self:GetUp()*61+self:GetRight()*150+self:GetForward()*4,
				Right = self:GetPos()+self:GetRight()*85+self:GetForward()*75+self:GetUp()*32,
			}
			self:Effects(EnginePos,true);
		end
		
	end
    
	ENT.HasCustomCalcView = true;	
    local View = {}
	function CalcView()
		
		local p = LocalPlayer();
		local self = p:GetNWEntity("Speeder", NULL)
		local DriverSeat = p:GetNWEntity("DriverSeat",NULL);
		local PassengerSeat = p:GetNWEntity("PassengerSeat",NULL);

		if(IsValid(self)) then

			if(IsValid(DriverSeat)) then
				if(DriverSeat:GetThirdPersonMode()) then
					local pos = self:GetPos()+LocalPlayer():GetAimVector():GetNormal()*-400+self:GetUp()*100;
					//local pos = self:GetPos()+self:GetRight()*250+self:GetUp()*100;
					//local face = self:GetAngles() + Angle(0,-90,0);
					local face = ((self:GetPos() + Vector(0,0,100))- pos):Angle();
						View.origin = pos;
						View.angles = face;
					return View;
				end
			elseif(IsValid(PassengerSeat)) then
				if(PassengerSeat:GetThirdPersonMode()) then
					local pos = self:GetPos()+LocalPlayer():GetAimVector():GetNormal()*-400+self:GetUp()*100;
					//local pos = self:GetPos()+self:GetRight()*250+self:GetUp()*100;
					//local face = self:GetAngles() + Angle(0,-90,0);
					local face = ((self:GetPos() + Vector(0,0,100))- pos):Angle();
						View.origin = pos;
						View.angles = face;
					return View;
				end
			end
		end
	end
	hook.Add("CalcView", "SpeederView", CalcView)
	
	hook.Add( "ShouldDrawLocalPlayer", "SpeederDrawPlayerModel", function( p )
		local self = p:GetNWEntity("Speeder", NULL);
		local DriverSeat = p:GetNWEntity("DriverSeat",NULL);
		local PassengerSeat = p:GetNWEntity("PassengerSeat",NULL);
		if(IsValid(self)) then
			if(IsValid(DriverSeat)) then
				if(DriverSeat:GetThirdPersonMode()) then
					return true;
				end
			elseif(IsValid(PassengerSeat)) then
				if(PassengerSeat:GetThirdPersonMode()) then
					return true;
				end
			end
		end
	end);
	
	function X47SpeederHUD()
	
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingSpeeder");
		local self = p:GetNWEntity("Speeder");
		if(Flying and IsValid(self)) then

			SW_Speeder_DrawHull(1000)
			SW_Speeder_DrawSpeedometer()

		end
	end
	hook.Add("HUDPaint", "X47SpeederHUD", X47SpeederHUD)
	
end
--PATH addons/[miecze] moce i hilty/lua/entities/lscs_crystal_base.lua:
AddCSLuaFile()

ENT.Base = "lscs_pickupable"
DEFINE_BASECLASS( "lscs_pickupable" )

ENT.Spawnable       = false
ENT.AdminSpawnable  = false

ENT.PickupSound = "physics/metal/metal_grenade_impact_hard1.wav"
ENT.ImpactHardSound = "Rock.ImpactHard"
ENT.ImpactSoftSound = "Rock.ImpactSoft"

if SERVER then
	function ENT:Initialize()
		self:SetModel( "models/props_junk/rock001a.mdl" )

		self:SetMaterial("lights/white")
		self:SetColor( LSCS:GetBlade( self.ID ).color_core )
		self:DrawShadow( false )

		self:SetModelScale( 0.5 )

		BaseClass.Initialize( self )
	end
else
	local mat = Material( "sprites/light_glow02_add" )
	function ENT:DrawTranslucent()
		self:DrawModel()

		if not self.col then
			self.col = LSCS:GetBlade( self.ID ).color_blur
		end

		render.SetMaterial( mat )
		render.DrawSprite( self:GetPos(), 64, 64, self.col )
	end

	function ENT:Draw()
	end
end
--PATH addons/[miecze] moce i hilty/lua/entities/lscs_force_base.lua:
return gluapack()()
--PATH lua/entities/lvs_armor_penetrate.lua:
return gluapack()()
--PATH lua/entities/lvs_av7/shared.lua:
ENT.Type = "anim"
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "AV-7"
ENT.Author = "Dec"
ENT.Information = ""
ENT.Category = "[LVS] SW-Vehicles"

ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.RotorPos = Vector( 338, 0, 214 )

ENT.MDL = "models/helios/vehicles/av7/av7.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}


ENT.AITEAM = 2

ENT.MaxVelocityY = 0
ENT.BoostAddVelocityY = 0

ENT.ForceAngleMultiplier = 4
ENT.ForceAngleDampingMultiplier = 4

ENT.ForceLinearMultiplier = 0
ENT.ForceLinearRate = 0

ENT.MaxVelocityZ = 0
ENT.BoostAddVelocityZ = 0

ENT.MaxHealth = 2500
ENT.MaxShield = 0
ENT.MaxVelocityX = 0
ENT.BoostAddVelocitX = 0
ENT.IgnoreWater = false

ENT.MaxTurnRate = 1

ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

function ENT:InitWeapons()

	self.perst = 0

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 45
	weapon.Delay = 1.2
	weapon.HeatRateUp = 0.6
	weapon.HeatRateDown = 0.3
	weapon.Attack = function( ent )

		if self:GetBodygroup(1) == 1 then return end

		local veh = ent:GetVehicle()
		local Driver = ent:GetDriver()
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		for i = 1, 1 do
			timer.Simple( (i / 2) * 0.2, function()
				if not IsValid( ent ) then return end
				
				if ent:GetAmmo() <= 0 then ent:SetHeat( 1 ) return end
	
				ent:TakeAmmo()

				local ID_1 = self:LookupAttachment( "muzzle" )
				local Muzzle1 = self:GetAttachment( ID_1 )
				
				local Pos = Muzzle1.Pos				
				local Dir =  (Muzzle1.Ang):Up()
				
				local trace = ent:GetEyeTrace()

				local projectile = ents.Create( "lvs_fall_missel" )
				projectile:SetPos(Pos)
				projectile:SetAngles(Dir:Angle())
				projectile:SetParent()
				projectile:Spawn()
				projectile:Activate()
				projectile.GetTarget = function( missile ) return missile end
				projectile.GetTargetPos = function( missile )
					return missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-10,10) )
				end
				projectile:SetAttacker( IsValid( Driver ) and Driver or self )
				projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
				projectile:Enable()
				projectile:EmitSound( "vehicle/starwars/av7/av7fire.wav" )

				util.ScreenShake(self:GetPos(), 100, 40, 1, 2000, true )
				for i=1,10 do
					local effectdata = EffectData()
					effectdata:SetOrigin( self:GetPos() )
					effectdata:SetRadius(500 * 500)
					effectdata:SetScale(24 * 20)
					util.Effect( "ThumperDust", effectdata, true, true )
				end
				self:SetPos(self:GetPos() - self:GetForward() * 1.5)
				timer.Simple(1.5, function()
					if IsValid(self) then
						self:SetPos(self:GetPos() + self:GetForward() * 1.5)
					end
				end)
			end)
		end
	end
	weapon.OnThink = function( ent, active )
		self.perst = self.perst + 1

		if self.perst == 4 then
			self.perst = 0
		end

		if self.perst == 0 then
			local Driver = self:GetDriver()

			if self:GetAI() or IsValid( Driver ) then		
				local EyeAngles = Driver:EyeAngles()
				local Yawn =  EyeAngles.y

				local Pitch =  EyeAngles.x
			
				if Pitch > 20 then 
					Pitch = 20
				end

				if Pitch < -50 then 
					Pitch = -50
				end
			
				local Pitch =  Pitch
			
				self:ManipulateBoneAngles(self:LookupBone("gun"), Angle(0, 0, Pitch))
		
			end
		end
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 30) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
	end
	self:AddWeapon( weapon )

	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 25
	weapon.Delay = 0.9
	weapon.HeatRateUp = 0.6
	weapon.HeatRateDown = 0.3
	weapon.Attack = function( ent )

		if self:GetBodygroup(1) == 1 then return end

		local veh = ent:GetVehicle()
		local Driver = ent:GetDriver()

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		for i = 1, 1 do
			timer.Simple( (i / 2) * 0.2, function()
				if not IsValid( ent ) then return end

				if ent:GetAmmo() <= 0 then ent:SetHeat( 1 ) return end
	
				ent:TakeAmmo()
				local ID_1 = self:LookupAttachment( "muzzle" )
				local Muzzle1 = self:GetAttachment( ID_1 )
				
				local Pos = Muzzle1.Pos
				local Dir =  (Muzzle1.Ang):Up()
			
				local projectile = ents.Create( "lvs_protontorpedo" )
				projectile:SetPos(Pos)
				projectile:SetAngles(Dir:Angle())
				projectile:SetParent()
				projectile:Spawn()
				projectile:SetDamage( 550 )
				projectile:SetRadius( 350 )
				projectile:Activate()
				projectile.GetTarget = function( missile ) return missile end
				projectile.GetTargetPos = function( missile )
					return missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-1,1) )
				end
				projectile:SetAttacker( IsValid( Driver ) and Driver or self )
				projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
				projectile:Enable()
				projectile:EmitSound( "vehicle/starwars/av7/av7fire.wav" )

				util.ScreenShake(self:GetPos(), 100, 40, 1, 2000, true )
				for i=1,10 do
					local effectdata = EffectData()
					effectdata:SetOrigin( self:GetPos() )
					effectdata:SetRadius(500 * 500)
					effectdata:SetScale(24 * 20)
					util.Effect( "ThumperDust", effectdata, true, true )
				end
				self:SetPos(self:GetPos() - self:GetForward() * 1.5)
				timer.Simple(1.5, function()
					if IsValid(self) then
						self:SetPos(self:GetPos() + self:GetForward() * 1.5)
					end
				end)
			end)
		end
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 30) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnThink = function( ent, active )
		--[[local Driver = self:GetDriver()
		
		if not IsValid( Driver ) then return end
	
		local EyeAngles = Driver:EyeAngles()
	
		local Pitch =  EyeAngles.x
	
		if Pitch > 20 then 
			Pitch = 20
		end
	
		local Pitch =  -Pitch
	
		self:ManipulateBoneAngles(self:LookupBone("gun"), Angle(0, Pitch, 0))]]--
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_reardoor.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function( ent )
		if self:GetAI() == true then return end 
		if (self.gateDown) then
			self.gateDown = false
			self:SetBodygroup(1, 0)
			ent.MaxVelocityY = 0
			ent.BoostAddVelocityY = 0
			ent.MaxVelocityX = 0
			ent.BoostAddVelocitX = 0
			ent.ForceLinearMultiplier = 0
			ent.ForceLinearRate = 0
		else
			self:SetBodygroup(1, 1)
			self.gateDown = true
			ent.MaxVelocityY = 100
			ent.BoostAddVelocityY = 150
			ent.MaxVelocityX = 200
			ent.BoostAddVelocitX = 300	
			ent.ForceLinearMultiplier = 2
			ent.ForceLinearRate = 0.8
		end

		self:EmitSound("lvs/vehicles/laat/door_large_open.wav")
	end
	self:AddWeapon( weapon )
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/iftx/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/iftx/loop_hi.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/iftx/dist.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 90,
	},
}

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-240,0,-120) -- position offset
ENT.LAATC_PICKUP_Angle = Angle(0,180,0) -- angle offset

--PATH lua/entities/lvs_base/cl_effects.lua:

function ENT:StartWindSounds()
	if not LVS.ShowEffects then return end

	self:StopWindSounds()

	if LocalPlayer():lvsGetVehicle() ~= self then return end

	local EntTable = self:GetTable()

	EntTable._WindSFX = CreateSound( self, "LVS.Physics.Wind" )
	EntTable._WindSFX:PlayEx(0,100)

	EntTable._WaterSFX = CreateSound( self, "LVS.Physics.Water" )
	EntTable._WaterSFX:PlayEx(0,100)
end

function ENT:StopWindSounds()
	local EntTable = self:GetTable()

	if EntTable._WindSFX then
		EntTable._WindSFX:Stop()
		EntTable._WindSFX = nil
	end

	if EntTable._WaterSFX then
		EntTable._WaterSFX:Stop()
		EntTable._WaterSFX = nil
	end
end

ENT.DustEffectSurfaces = {
	["sand"] = true,
	["dirt"] = true,
	["grass"] = true,
}

ENT.GroundEffectsMultiplier = 1

function ENT:DoVehicleFX()
	local EntTable = self:GetTable()

	if EntTable.GroundEffectsMultiplier <= 0 or not LVS.ShowEffects then self:StopWindSounds() return end

	local Vel = self:GetVelocity():Length() * EntTable.GroundEffectsMultiplier

	if EntTable._WindSFX then EntTable._WindSFX:ChangeVolume( math.Clamp( (Vel - 1200) / 2800,0,1 ), 0.25 ) end

	if Vel < 1500 then
		if EntTable._WaterSFX then EntTable._WaterSFX:ChangeVolume( 0, 0.25 ) end

		return
	end

	if (EntTable.nextFX or 0) < CurTime() then
		EntTable.nextFX = CurTime() + 0.05

		local LCenter = self:OBBCenter()
		LCenter.z = self:OBBMins().z

		local CenterPos = self:LocalToWorld( LCenter )

		local trace = util.TraceLine( {
			start = CenterPos + Vector(0,0,25),
			endpos = CenterPos - Vector(0,0,450),
			filter = self:GetCrosshairFilterEnts(),
		} )

		local traceWater = util.TraceLine( {
			start = CenterPos + Vector(0,0,25),
			endpos = CenterPos - Vector(0,0,450),
			filter = self:GetCrosshairFilterEnts(),
			mask = MASK_WATER,
		} )

		if EntTable._WaterSFX then EntTable._WaterSFX:ChangePitch( math.Clamp((Vel / 1000) * 50,80,150), 0.5 ) end

		if traceWater.Hit and trace.HitPos.z < traceWater.HitPos.z then 
			local effectdata = EffectData()
				effectdata:SetOrigin( traceWater.HitPos )
				effectdata:SetEntity( self )
			util.Effect( "lvs_physics_water", effectdata )

			if EntTable._WaterSFX then EntTable._WaterSFX:ChangeVolume( 1 - math.Clamp(traceWater.Fraction,0,1), 0.5 ) end
		else
			if EntTable._WaterSFX then EntTable._WaterSFX:ChangeVolume( 0, 0.25 ) end
		end

		if trace.Hit and EntTable.DustEffectSurfaces[ util.GetSurfacePropName( trace.SurfaceProps ) ] then
			local effectdata = EffectData()
				effectdata:SetOrigin( trace.HitPos )
				effectdata:SetEntity( self )
			util.Effect( "lvs_physics_dust", effectdata )
		end
	end
end

function ENT:GetParticleEmitter( Pos )
	local EntTable = self:GetTable()

	local T = CurTime()

	if IsValid( EntTable.Emitter ) and (EntTable.EmitterTime or 0) > T then
		return EntTable.Emitter
	end

	self:StopEmitter()

	EntTable.Emitter = ParticleEmitter( Pos, false )
	EntTable.EmitterTime = T + 2

	return EntTable.Emitter
end

function ENT:StopEmitter()
	if IsValid( self.Emitter ) then
		self.Emitter:Finish()
	end
end
--PATH lua/entities/lvs_base_doorhandler.lua:
return gluapack()()
--PATH lua/entities/lvs_base_fakehover/sh_camera_eyetrace.lua:

function ENT:GetEyeTrace( trace_forward )
	local startpos = self:LocalToWorld( self:OBBCenter() )

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( pod:OBBCenter() )
	end

	local AimVector = trace_forward and self:GetForward() or self:GetAimVector()

	local data = {
		start = startpos,
		endpos = (startpos + AimVector * 50000),
		filter = self:GetCrosshairFilterEnts(),
	}

	local trace = util.TraceLine( data )

	return trace
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetAIAimVector()
	end

	local Driver = self:GetDriver()

	if not IsValid( Driver ) then return self:GetForward() end

	if SERVER then
		local pod = self:GetDriverSeat()

		if not IsValid( pod ) then return Driver:EyeAngles():Forward() end

		return pod:WorldToLocalAngles( Driver:EyeAngles() ):Forward()
	else
		return Driver:EyeAngles():Forward()
	end
end

--PATH lua/entities/lvs_base_fakehover/cl_camera.lua:

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	return pos, angles, fov
end

function ENT:CalcViewDriver( ply, pos, angles, fov, pod )
	local view = {}
	view.origin = pos
	view.fov = fov
	view.drawviewer = true
	view.angles = ply:EyeAngles()

	if not pod:GetThirdPersonMode() then

		view.drawviewer = false

		return view
	end

	local radius = 550
	radius = radius + radius * pod:GetCameraDistance()

	local TargetOrigin = view.origin - view.angles:Forward() * radius  + view.angles:Up() * (radius * 0.2 + radius * pod:GetCameraHeight())
	local WallOffset = 4

	local tr = util.TraceHull( {
		start = view.origin,
		endpos = TargetOrigin,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.origin = tr.HitPos

	if tr.Hit and not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

function ENT:CalcViewPassenger( ply, pos, angles, fov, pod )
	return LVS:CalcView( self, ply, pos, angles, fov, pod )
end

function ENT:LVSCalcView( ply, original_pos, original_angles, original_fov, pod )
	local pos, angles, fov = self:CalcViewOverride( ply, original_pos, original_angles, original_fov, pod )

	if self:GetDriverSeat() == pod then
		return self:CalcViewDriver( ply, pos, angles, fov, pod )
	else
		return self:CalcViewPassenger( ply, pos, angles, fov, pod )
	end
end
--PATH lua/entities/lvs_base_starfighter/sh_camera_eyetrace.lua:

function ENT:GetEyeTrace( trace_forward )
	local startpos = self:LocalToWorld( self:OBBCenter() )

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( pod:OBBCenter() )
	end

	local AimVector = trace_forward and self:GetForward() or self:GetAimVector()

	local data = {
		start = startpos,
		endpos = (startpos + AimVector * 50000),
		filter = self:GetCrosshairFilterEnts(),
	}

	local trace = util.TraceLine( data )

	return trace
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetAIAimVector()
	end

	local Driver = self:GetDriver()

	if not IsValid( Driver ) then return self:GetForward() end

	if not Driver:lvsMouseAim() then
		if Driver:lvsKeyDown( "FREELOOK" ) then
			local pod = self:GetDriverSeat()

			if not IsValid( pod ) then return Driver:EyeAngles():Forward() end

			if pod:GetThirdPersonMode() then
				return -self:GetForward()
			else
				return Driver:GetAimVector()
			end
		else
			return self:GetForward()
		end
	end

	if SERVER then
		local pod = self:GetDriverSeat()

		if not IsValid( pod ) then return Driver:EyeAngles():Forward() end

		return pod:WorldToLocalAngles( Driver:EyeAngles() ):Forward()
	else
		return Driver:EyeAngles():Forward()
	end
end

--PATH lua/entities/lvs_base_turret/cl_init.lua:
include("shared.lua")
include("cl_camera.lua")
include("sh_camera_eyetrace.lua")
include("cl_hud.lua")
include("cl_deathsound.lua")

DEFINE_BASECLASS( "lvs_base" )

function ENT:Think()
	BaseClass.Think( self )

	self.EFxScale = self.EFxScale and (self.EFxScale - self.EFxScale * RealFrameTime()) or 0

	self:CalcOnThrottle()
end

function ENT:CalcOnThrottle()--[[
	if not self:GetEngineActive() then 
		self._oldOnTHR = nil

		return
	end

	local Throttle = self:GetThrottle()

	if self._oldOnTHR ~= Throttle then
		if self._oldOnTHR == 0 and Throttle > 0 then
			self._IsAccelerating = true
		end

		if Throttle > (self._oldOnTHR or 0) then
			self._IsAccelerating = true
		else
			self._IsAccelerating = false
		end

		if self._oldOnTHR == 1 then
			self:StopBoost()
		end

		self._oldOnTHR = Throttle
	end

	if self._oldAccelerating ~= self._IsAccelerating then
		self._oldAccelerating = self._IsAccelerating

		if not self._IsAccelerating then return end

		self:StartBoost()
	end]]
end

function ENT:StartBoost()--[[
	local T = CurTime()

	if (self._NextSND or 0) > T then return end

	self._NextSND = T + 1

	self.EFxScale = 100

	self:OnStartBoost()]]
end

function ENT:StopBoost()--[[
	local T = CurTime()

	if (self._NextSND or 0) > T then return end

	self._NextSND = T + 1

	self:OnStopBoost()]]
end

function ENT:GetBoost()
	--return (self.EFxScale or 0)
end

function ENT:OnStartBoost()
end

function ENT:OnStopBoost()
end
--PATH lua/entities/lvs_base_turret/cl_deathsound.lua:

function ENT:OnDestroyed()
	if not self.DeathSound then return end

	if self:GetVelocity():Length() <= self.MaxVelocity * 0.5 then return end

	self._sndDeath = CreateSound( self, self.DeathSound )
	self._sndDeath:SetSoundLevel( 125 )
	self._sndDeath:PlayEx( 1, 50 + 50 * self:CalcDoppler( LocalPlayer() ) )
end

function ENT:StopDeathSound()
	if not self._sndDeath then return end

	self._sndDeath:Stop()
end


--PATH lua/entities/lvs_cisprotonbomb.lua:
return gluapack()()
--PATH lua/entities/lvs_concussionmissile.lua:
AddCSLuaFile()

ENT.Base = "lvs_protontorpedo"

ENT.Type            = "anim"

ENT.PrintName = "Concussion Missile"
ENT.Author = "Luna"
ENT.Information = "sprengt dir ein zweites arschloch"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= true

ENT.ExplosionEffect = "lvs_concussion_explosion"
ENT.GlowColor = Color( 255, 40, 100, 255 )

if SERVER then
	function ENT:GetDamage() return
		(self._dmg or 400)
	end

	function ENT:GetRadius() 
		return (self._radius or 150)
	end

	return
end

ENT.GlowMat = Material( "sprites/light_glow02_add" )

function ENT:Enable()	
	if self.IsEnabled then return end

	self.IsEnabled = true

	self.snd = CreateSound(self, "npc/combine_gunship/gunship_crashing1.wav")
	self.snd:SetSoundLevel( 80 )
	self.snd:Play()

	local effectdata = EffectData()
		effectdata:SetOrigin( self:GetPos() )
		effectdata:SetEntity( self )
	util.Effect( "lvs_concussion_trail", effectdata )
end

function ENT:Draw()
	if not self:GetActive() then return end

	self:DrawModel()

	render.SetMaterial( self.GlowMat )

	local pos = self:GetPos()
	local dir = self:GetForward()

	for i = 0, 30 do
		local Size = ((30 - i) / 30) ^ 2 * 128

		render.DrawSprite( pos - dir * i * 7, Size, Size, self.GlowColor )
	end
end
--PATH lua/entities/lvs_fakehover_barc/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_fakehover_barc/shared.lua:
ENT.Type = "anim"
DEFINE_BASECLASS( "lunasflightschool_basescript_gunship" )
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Republic BARC Speeder"
ENT.Author = "Codexx"
ENT.Information = "BARC brr "
ENT.Category = "[LVS] Republic Vehicle"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/barc/barc.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxHealth = 2700

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 950
ENT.MaxVelocityY = 950

ENT.MaxTurnRate = 0.8

ENT.BoostAddVelocityX = 260
ENT.BoostAddVelocityY = 260

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)


function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "BTLFire" )
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:GetAimAngles()
	local trace = self:GetEyeTrace()

	local AimAnglesR = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(-60,-51,43) ) ):GetNormalized():Angle() )
	local AimAnglesL = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(-60,51,43) ) ):GetNormalized():Angle() )

	return AimAnglesR, AimAnglesL
end

function ENT:WeaponsInRange()
	if self:GetIsCarried() then return false end

	local AimAnglesR, AimAnglesL = self:GetAimAngles()

	return not ((AimAnglesR.p >= 10 and AimAnglesL.p >= 10) or (AimAnglesR.p <= -25 and AimAnglesL.p <= -25) or (math.abs(AimAnglesL.y) + math.abs(AimAnglesL.y)) >= 30)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 400
	weapon.Delay = 0.25
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_blue_short"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 40
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld( Vector(95,-15 * i,4) )
			
			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,50,255) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )

		end

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	

end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/barc/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 205,
	},
	{
		sound = "lvs/vehicles/barc/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/barc/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 90,
	},
}

--PATH lua/entities/lvs_fall_missel_cis.lua:
AddCSLuaFile()

ENT.Base = "lvs_fall_missel_base"

ENT.Type            = "anim"

ENT.PrintName = "Proton Torpedo"
ENT.Author = "Luna"
ENT.Information = "geht ab wie'n zpfchen"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= true

ENT.ExplosionEffect = "lvs_explosion"
ENT.GlowColor = Color( 255, 0, 0, 255 )

if SERVER then
	function ENT:GetDamage() return
		(self._dmg or 8500)
	end

	function ENT:GetRadius() 
		return (self._radius or 250)
	end

	return
end

ENT.GlowMat = Material( "sprites/light_glow02_add" )

function ENT:Enable()	
	if self.IsEnabled then return end

	self.IsEnabled = true

	self.snd = CreateSound(self, "npc/combine_gunship/gunship_crashing1.wav")
	self.snd:SetSoundLevel( 80 )
	self.snd:Play()

	local effectdata = EffectData()
		effectdata:SetOrigin( self:GetPos() )
		effectdata:SetEntity( self )
	util.Effect( "lvs_concussion_trail", effectdata )
end

function ENT:Draw()
	if not self:GetActive() then return end

	self:DrawModel()

	render.SetMaterial( self.GlowMat )

	local pos = self:GetPos()
	local dir = self:GetForward()

	for i = 0, 30 do
		local Size = ((30 - i) / 30) ^ 2 * 128

		render.DrawSprite( pos - dir * i * 7, Size, Size, self.GlowColor )
	end
end
--PATH lua/entities/lvs_gunship_hmp/shared.lua:

ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "HMP Droid Gunship"
ENT.Author = "Salty"
ENT.Information = "Droid HMP Gunship of the Trade Federation"
ENT.Category = "[LVS] - Star Wars"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/salty/cis-hmp-gunship.mdl"
ENT.GibModels = {
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
	"models/salty/hmpgib1.mdl",
	"models/salty/hmpgib2.mdl",
}


ENT.AITEAM = 1

ENT.MaxVelocity = 2235
ENT.MaxThrust = 2235

ENT.ThrustVtol = 100
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1.25

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 4000
ENT.MaxShield = 850

function ENT:OnSetupDataTables()
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Entity", "ThirdGunnerSeat" )
end

function ENT:GetAimAngles( ent )
    local trace = ent:GetEyeTrace()
    local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(100,300,30) ) ):GetNormalized():Angle() )

    return AimAngles
end

function ENT:WeaponsInRange( ent )
    local AimAngles = self:GetAimAngles( ent )

    return not (AimAngles.p >= 35 or AimAngles.p <= -35)
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(652.69,-1.53,37.35),
		Vector(-88.78,-512.76,133.99),
		Vector(-88.78,512.76,133.99),
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 1500
	weapon.Delay = 0.10
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 40
		bullet.Damage	= 35
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 125 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 1500
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.30 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.30
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.04

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( -0.54, (ent._swapMissile and -298.55 or 298.55), 170 )

		local Driver = self:GetDriver()

		local projectile = ents.Create( "hmp_concussionmissile" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 95000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "hmp/simple_oneshot_juggernaut_rocketlauncher_close_var_04.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.04

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
	
	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)

local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.10
	weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()
		
		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 65 then return true end
		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
		
		local bullet = {}
		bullet.Src = veh:LocalToWorld( ent.SwapTopBottom and Vector(457.33,241.02,59.64) or Vector(423.75,266.36,60.54) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255, 0, 0) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		if not IsValid( base ) then 
			return LVS:CalcView( ent, ply, pos, angles, fov, pod )
		end

		if pod:GetThirdPersonMode() then
			pos = pos + base:GetUp() * 100
		end

		return LVS:CalcView( base, ply, pos, angles, fov, pod )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 65) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.10
	weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()
		
		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 65 then return true end
		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
		
		local bullet = {}
		bullet.Src = veh:LocalToWorld( ent.SwapTopBottom and Vector(422.77,-265.56,59.79) or Vector(454.37,-242.29,59.55) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255, 0, 0) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		if not IsValid( base ) then 
			return LVS:CalcView( ent, ply, pos, angles, fov, pod )
		end

		if pod:GetThirdPersonMode() then
			pos = pos + base:GetUp() * 100
		end

		return LVS:CalcView( base, ply, pos, angles, fov, pod )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 65) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 3 )
end

ENT.FlyByAdvance = 0
ENT.FlyBySound = "LVS.VULTURE.FLYBY" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "hmp/hmp_gunship_engineidleing.wav",
		Pitch = 250,
		PitchMin = 0,
		PitchMax = 105,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--PATH lua/entities/lvs_hoverchair/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_hoverchair/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_laatle_patrolgunship_imp/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_missile.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Missile"
ENT.Author = "Luna"
ENT.Information = "LVS Missile"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= true

ENT.ExplosionEffect = "lvs_explosion_small"

ENT.lvsProjectile = true

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "Active" )
	self:NetworkVar( "Entity", 0, "NWTarget" )
end

if SERVER then
	util.AddNetworkString( "lvs_missile_hud" )

	function ENT:GetAvailableTargets()
		local targets = {
			[1] = player.GetAll(),
			[2] = LVS:GetVehicles(),
			[3] = LVS:GetNPCs(),
		}

		return targets
	end

	function ENT:FindTarget( pos, forward, cone_ang, cone_len )
		local targets = self:GetAvailableTargets()

		local Attacker = self:GetAttacker()
		local Parent = self:GetParent()
		local Owner = self:GetOwner()
		local Target = NULL
		local DistToTarget = 0

		for _, tbl in ipairs( targets ) do
			for _, ent in pairs( tbl ) do
				if not IsValid( ent ) or ent == Parent or ent == Owner or Target == ent or Attacker == ent then continue end

				local pos_ent = ent:GetPos()
				local dir = (pos_ent - pos):GetNormalized()
				local ang = math.deg( math.acos( math.Clamp( forward:Dot( dir ) ,-1,1) ) )

				if ang > cone_ang then continue end

				local dist, _, _ = util.DistanceToLine( pos, pos + forward * cone_len, pos_ent )

				if not IsValid( Target ) then
					Target = ent
					DistToTarget = dist

					continue
				end

				if dist < DistToTarget then
					Target = ent
					DistToTarget = dist
				end
			end
		end

		self:SetTarget( Target )

		local ply = self:GetAttacker()

		if not IsValid( ply ) or not ply:IsPlayer() then return end

		net.Start( "lvs_missile_hud", true )
			net.WriteEntity( self )
		net.Send( ply )
	end

	function ENT:SetEntityFilter( filter )
		if not istable( filter ) then return end

		self._FilterEnts = {}

		for _, ent in pairs( filter ) do
			self._FilterEnts[ ent ] = true
		end
	end
	function ENT:SetTarget( ent ) self:SetNWTarget( ent ) end
	function ENT:SetDamage( num ) self._dmg = num end
	function ENT:SetForce( num ) self._force = num end
	function ENT:SetThrust( num ) self._thrust = num end
	function ENT:SetSpeed( num ) self._speed = num end
	function ENT:SetTurnSpeed( num ) self._turnspeed = num end
	function ENT:SetRadius( num ) self._radius = num end
	function ENT:SetAttacker( ent ) self._attacker = ent end

	function ENT:GetAttacker() return self._attacker or NULL end
	function ENT:GetDamage() return (self._dmg or 100) end
	function ENT:GetForce() return (self._force or 4000) end
	function ENT:GetRadius() return (self._radius or 250) end
	function ENT:GetSpeed() return (self._speed or 4000) end
	function ENT:GetTurnSpeed() return (self._turnspeed or 1) * 100 end
	function ENT:GetThrust() return (self._thrust or 500) end
	function ENT:GetTarget()
		if IsValid( self:GetNWTarget() ) then
			local Pos = self:GetPos()
			local tPos = self:GetTargetPos()

			local Sub = tPos - Pos
			local Len = Sub:Length()
			local Dir = Sub:GetNormalized()
			local Forward = self:GetForward()

			local AngToTarget = math.deg( math.acos( math.Clamp( Forward:Dot( Dir ) ,-1,1) ) )

			local LooseAng = math.min( Len / 100, 90 )

			if AngToTarget > LooseAng then
				self:SetNWTarget( NULL )
			end
		end

		return self:GetNWTarget()
	end
	function ENT:GetTargetPos()
		local Target = self:GetNWTarget()

		if not IsValid( Target ) then return Vector(0,0,0) end

		if isfunction( Target.GetMissileOffset ) then
			return Target:LocalToWorld( Target:GetMissileOffset() )
		end

		return Target:GetPos()
	end

	function ENT:SpawnFunction( ply, tr, ClassName )

		local ent = ents.Create( ClassName )
		ent:SetPos( ply:GetShootPos() )
		ent:SetAngles( ply:EyeAngles() )
		ent:Spawn()
		ent:Activate()
		ent:SetAttacker( ply )
		ent:Enable()

		return ent
	end

	function ENT:Initialize()	
		self:SetModel( "models/weapons/w_missile_launch.mdl" )
		self:SetMoveType( MOVETYPE_NONE )
		self:SetRenderMode( RENDERMODE_TRANSALPHA )
	end

	function ENT:Enable()
		if self.IsEnabled then return end

		local Parent = self:GetParent()

		if IsValid( Parent ) then
			self:SetOwner( Parent )
			self:SetParent( NULL )
		end

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetCollisionGroup( COLLISION_GROUP_NONE )
		self:PhysWake()

		self.IsEnabled = true

		local pObj = self:GetPhysicsObject()
		
		if not IsValid( pObj ) then
			self:Remove()

			print("LVS: missing model. Missile terminated.")

			return
		end

		pObj:SetMass( 1 ) 
		pObj:EnableGravity( false ) 
		pObj:EnableMotion( true )
		pObj:EnableDrag( false )

		self:SetTrigger( true )

		self:StartMotionController()

		self:PhysWake()

		self.SpawnTime = CurTime()

		self:SetActive( true )
	end

	function ENT:PhysicsSimulate( phys, deltatime )
		phys:Wake()

		local Thrust = self:GetThrust()
		local Speed = self:GetSpeed()
		local Pos = self:GetPos()
		local velL = self:WorldToLocal( Pos + self:GetVelocity() )

		local ForceLinear = (Vector( Speed * Thrust,0,0) - velL) * deltatime

		local Target = self:GetTarget()

		if not IsValid( Target ) then
			return (-phys:GetAngleVelocity() * 250 * deltatime), ForceLinear, SIM_LOCAL_ACCELERATION
		end

		local AngForce = -self:WorldToLocalAngles( (self:GetTargetPos() - Pos):Angle() )

		local ForceAngle = (Vector(AngForce.r,-AngForce.p,-AngForce.y) * self:GetTurnSpeed() - phys:GetAngleVelocity() * 5 ) * 250 * deltatime

		return ForceAngle, ForceLinear, SIM_LOCAL_ACCELERATION
	end

	function ENT:Think()	
		local T = CurTime()

		self:NextThink( T + 1 )

		if not self.SpawnTime then return true end

		if (self.SpawnTime + 12) < T then
			self:Detonate()
		end

		return true
	end

	ENT.IgnoreCollisionGroup = {
		[COLLISION_GROUP_NONE] = true,
		[COLLISION_GROUP_WORLD] =  true,
		[COLLISION_GROUP_INTERACTIVE_DEBRIS] = true,
	}

	function ENT:StartTouch( entity )
		if entity == self:GetAttacker() then return end

		if istable( self._FilterEnts ) and self._FilterEnts[ entity ] then return end

		if entity.GetCollisionGroup and self.IgnoreCollisionGroup[ entity:GetCollisionGroup() ] then return end

		if entity.lvsProjectile then return end

		self:Detonate( entity )
	end

	function ENT:EndTouch( entity )
	end

	function ENT:Touch( entity )
	end

	function ENT:PhysicsCollide( data )
		if istable( self._FilterEnts ) and self._FilterEnts[ data.HitEntity ] then return end

		self:Detonate( data.HitEntity )
	end

	function ENT:OnTakeDamage( dmginfo )	
	end

	function ENT:Detonate( target )
		if not self.IsEnabled or self.IsDetonated then return end

		self.IsDetonated = true

		local Pos =  self:GetPos() 

		local effectdata = EffectData()
			effectdata:SetOrigin( Pos )
		util.Effect( self.ExplosionEffect, effectdata )

		local attacker = self:GetAttacker()

		LVS:BlastDamage( Pos, self:GetForward(), IsValid( attacker ) and attacker or game.GetWorld(), self, self:GetDamage(), DMG_BLAST, self:GetRadius(), self:GetForce() )

		SafeRemoveEntityDelayed( self, FrameTime() )
	end
else
	function ENT:Initialize()	
	end

	function ENT:Enable()
		if self.IsEnabled then return end

		self.IsEnabled = true

		self.snd = CreateSound(self, "weapons/rpg/rocket1.wav")
		self.snd:SetSoundLevel( 80 )
		self.snd:Play()

		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
			effectdata:SetEntity( self )
		util.Effect( "lvs_missiletrail", effectdata )
	end

	function ENT:CalcDoppler()
		local Ent = LocalPlayer()

		local ViewEnt = Ent:GetViewEntity()

		if Ent:lvsGetVehicle() == self then
			if ViewEnt == Ent then
				Ent = self
			else
				Ent = ViewEnt
			end
		else
			Ent = ViewEnt
		end

		local sVel = self:GetVelocity()
		local oVel = Ent:GetVelocity()

		local SubVel = oVel - sVel
		local SubPos = self:GetPos() - Ent:GetPos()

		local DirPos = SubPos:GetNormalized()
		local DirVel = SubVel:GetNormalized()

		local A = math.acos( math.Clamp( DirVel:Dot( DirPos ) ,-1,1) )

		return (1 + math.cos( A ) * SubVel:Length() / 13503.9)
	end

	function ENT:Draw()
		if not self:GetActive() then return end

		self:DrawModel()
	end

	function ENT:Think()
		if self.snd then
			self.snd:ChangePitch( 100 * self:CalcDoppler() )
		end

		if self.IsEnabled then return end

		if self:GetActive() then
			self:Enable()
		end
	end

	function ENT:SoundStop()
		if self.snd then
			self.snd:Stop()
		end
	end

	function ENT:OnRemove()
		self:SoundStop()
	end

	local function DrawDiamond( X, Y, radius, angoffset )
		angoffset = angoffset or 0

		local segmentdist = 90
		local radius2 = radius + 1

		for ang = 0, 360, segmentdist do
			local a = ang + angoffset
			surface.DrawLine( X + math.cos( math.rad( a ) ) * radius, Y - math.sin( math.rad( a ) ) * radius, X + math.cos( math.rad( a + segmentdist ) ) * radius, Y - math.sin( math.rad( a + segmentdist ) ) * radius )
			surface.DrawLine( X + math.cos( math.rad( a ) ) * radius2, Y - math.sin( math.rad( a ) ) * radius2, X + math.cos( math.rad( a + segmentdist ) ) * radius2, Y - math.sin( math.rad( a + segmentdist ) ) * radius2 )
		end
	end

	local color_red = Color(255,0,0,255)
	local HudTargets = {}
	hook.Add( "HUDPaint", "!!!!lvs_missile_hud", function()
		local T = CurTime()

		local Index = 0

		surface.SetDrawColor( 255, 0, 0, 255 )

		for ID, _ in pairs( HudTargets ) do
			local Missile = Entity( ID )

			if not IsValid( Missile ) then
				HudTargets[ ID ] = nil

				continue
			end

			local Target = Missile:GetNWTarget()

			if not IsValid( Target ) then
				HudTargets[ ID ] = nil

				continue
			end

			local MissilePos = Missile:GetPos():ToScreen()
			local TargetPos = Target:LocalToWorld( Target:OBBCenter() ):ToScreen()

			Index =  Index + 1

			if not TargetPos.visible then continue end

			DrawDiamond( TargetPos.x, TargetPos.y, 40, ID * 1337 - T * 100 )

			draw.DrawText("LOCK", "LVS_FONT", TargetPos.x + 20, TargetPos.y + 20, color_red, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )

			if not MissilePos.visible then continue end

			DrawDiamond( MissilePos.x, MissilePos.y, 16, ID * 1337 - T * 100 )
			draw.DrawText( Index, "LVS_FONT", MissilePos.x + 10, MissilePos.y + 10, color_red, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
		
			surface.DrawLine( MissilePos.x, MissilePos.y, TargetPos.x, TargetPos.y )
		end
	end )

	net.Receive( "lvs_missile_hud", function( len )
		local ent = net.ReadEntity()

		if not IsValid( ent ) then return end

		HudTargets[ ent:EntIndex() ] = true
	end )
end
--PATH lua/entities/lvs_pro/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_repulsorlift_gunship/sh_ballturret_left.lua:
return gluapack()()
--PATH lua/entities/lvs_repulsorlift_gunship/sh_ballturret_left.lua:

function ENT:SetPosBTL()
	local BTL = self:GetBTPodL()

	if not IsValid( BTL ) then return end

	local ID = self:LookupAttachment( "muzzle_ballturret_left" )
	local Muzzle = self:GetAttachment( ID )

	if Muzzle then
		local PosL = self:WorldToLocal( Muzzle.Pos + Muzzle.Ang:Right() * 28 - Muzzle.Ang:Up() * 65 )
		BTL:SetLocalPos( PosL )
	end
end

function ENT:TraceBTL()
	local ID = self:LookupAttachment( "muzzle_ballturret_left" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:SetPoseParameterBTL( weapon )
	if not IsValid( weapon:GetDriver() ) and not weapon:GetAI() then return end

	local AimAng = weapon:WorldToLocal( weapon:GetPos() + weapon:GetAimVector() ):Angle()
	AimAng:Normalize()

	self:SetPoseParameter("ballturret_left_pitch", AimAng.p )
	self:SetPoseParameter("ballturret_left_yaw", AimAng.y )
end

function ENT:InitWeaponBTL()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.3
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if not base._CanUseBT then return end

		local trace = base:TraceBTL()

		base:BallturretDamage( trace.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - ent:GetPos()):GetNormalized() )
	end
	weapon.StartAttack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if not base._CanUseBT then return end

		base:SetBTLFire( true )

		if not IsValid( self.sndBTL ) then return end

		self.sndBTL:Play()
		self.sndBTL:EmitSound( "lvs/vehicles/laat/ballturret_fire.mp3", 110 )
	end
	weapon.FinishAttack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetBTLFire( false )

		if not IsValid( self.sndBTL ) then return end

		self.sndBTL:Stop()
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetPoseParameterBTL( ent )
		base:SetPosBTL()

		if not ent:GetAI() then return end

		local ID = base:LookupAttachment( "muzzle_ballturret_left" )
		local Muzzle = base:GetAttachment( ID )
		if not Muzzle then return end

		if ent:AngleBetweenNormal(Muzzle.Ang:Up(),ent:GetAimVector()) > 5 then
			ent:SetHeat( 1 )
			ent:SetOverheated( true )
		end
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local ID = base:LookupAttachment( "muzzle_ballturret_left" )
		local Muzzle = base:GetAttachment( ID )

		if Muzzle then
			local Pos,Ang = LocalToWorld( Vector(0,25,-45), Angle(270,0,-90), Muzzle.Pos, Muzzle.Ang )

			view.origin = Pos
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceBTL().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 3 )
end
--PATH lua/entities/lvs_repulsorlift_gunship/sh_wingturret.lua:

function ENT:SetNextRearGunFire( delay )
	self._NextRGFire = CurTime() + delay
end

function ENT:CanFireRearGun()
	return (self._NextRGFire or 0) < CurTime()
end

function ENT:GetRearGunInRange( ent )
	return ent:AngleBetweenNormal( ent:GetAimVector(), -ent:GetForward() ) < 35
end

function ENT:HandleRearGun( ent, ShouldFire )
	local trace = ent:GetEyeTrace()

	local Pos,Ang = WorldToLocal( Vector(0,0,0), (trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,180,0) ) )

	if not self:GetRearGunInRange( ent ) then 
		self:SetPoseParameter("reargun_yaw", 0 )

		return false
	end

	self:SetPoseParameter("reargun_pitch", -Ang.p )
	self:SetPoseParameter("reargun_yaw", -Ang.y )

	if not ShouldFire or not self:CanFireRearGun() then self:GetRearGunInRange( ent ) return end

	local ID = self:LookupAttachment( "muzzle_reargun" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return self:GetRearGunInRange( ent ) end

	self:SetNextRearGunFire( 0.3 )

	local bullet = {}
	bullet.Src 	= Muzzle.Pos
	bullet.Dir 	= (trace.HitPos - Muzzle.Pos):GetNormalized()
	bullet.Spread 	= Vector( 0.03,  0.03, 0.03 )
	bullet.TracerName = "lvs_laser_green"
	bullet.Force	= 10
	bullet.HullSize 	= 25
	bullet.Damage	= 65
	bullet.Velocity = 30000
	bullet.Attacker 	= ent:GetDriver()
	bullet.Callback = function(att, tr, dmginfo)
		local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) ) 
			effectdata:SetOrigin( tr.HitPos )
			effectdata:SetNormal( tr.HitNormal )
		util.Effect( "lvs_laser_impact", effectdata )
	end
	ent:LVSFireBullet( bullet )

	local NewHeat = ent:GetHeat() + 0.4


	ent:SetHeat( NewHeat )
	if NewHeat >= 1 then
		ent:SetOverheated( true )
	end

	if not IsValid( self.SNDTail ) then return end

	self.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
end

function ENT:InitWeaponGunner()
	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)
	local MaxRange = 60
	local MaxTailRange = 35

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function( ent )
		ent.ShouldFire = true
	end
	weapon.FinishAttack = function( ent )
		ent.ShouldFire = false

		local base = ent:GetVehicle()

		local snd = {
			[-1] = base.WingLeftSND,
			[1] = base.WingRightSND,
		}

		for _, sound in pairs( snd ) do
			if not IsValid( sound ) then continue end

			sound:Stop()
		end
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		local ShouldFire = (ent.ShouldFire == true) and ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) < MaxRange
	
		if base:HandleRearGun( ent, ent.ShouldFire ) then
			ShouldFire = false
		end

		if base:SetWingTurretFire() ~= ShouldFire then
			base:SetWingTurretFire( ShouldFire ) 
		end

		local snd = {
			[-1] = base.WingLeftSND,
			[1] = base.WingRightSND,
		}

		if ent._oldShouldFire ~= ShouldFire then
			ent._oldShouldFire = ShouldFire
			if ShouldFire then
				for _, sound in pairs( snd ) do
					if not IsValid( sound ) then continue end

					sound:EmitSound( "lvs/vehicles/laat/ballturret_fire.mp3", 110 )
				end
			end
		end

		if not ShouldFire then
			for _, sound in pairs( snd ) do
				if not IsValid( sound ) then continue end
				sound:Stop()
			end

			ent:SetHeat( ent:GetHeat() - FrameTime() )

			return
		end
	
		if not active then
			return
		end

		local trace = ent:GetEyeTrace()
		local DesEndPos = trace.HitPos

		base:SetWingTurretTarget( DesEndPos )

		if not base:GetWingTurretFire() then return end

		local DesStartPos

		if base:WorldToLocal( DesEndPos ).z < 0 then
			DesStartPos = Vector(-172.97,334.04,93.25)
		else
			DesStartPos = Vector(-174.79,350.05,125.98)
		end

		local NewHeat = ent:GetHeat()

		for i = -1,1,2 do
			local StartPos = self:LocalToWorld( DesStartPos * Vector(1,i,1) )
			local beam = util.TraceLine( { start = StartPos, endpos = DesEndPos} )

			self:BallturretDamage( beam.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - StartPos):GetNormalized() )

			if not IsValid( snd[i] ) then continue end

			if beam.Entity ~= base then
				snd[i]:Play()
				NewHeat = NewHeat + FrameTime() * 0.25
			else
				snd[i]:Stop()
			end
		end

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local radius = 800
		radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )

		local StartPos = base:LocalToWorld( base:OBBCenter() ) + clamped_angles :Up() * (250 + radius * pod:GetCameraHeight())
		local EndPos = StartPos - clamped_angles:Forward() * radius

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "player" ) and not e.LVS
				
				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.drawviewer = true
		view.origin = tr.HitPos

		if tr.Hit and not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local WingInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= MaxRange
		local RearGunInRange = not base:GetRearGunInRange( ent )

		local Col = (WingInRange and RearGunInRange) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end
--PATH lua/entities/lvs_starfighter_hyenabomber/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Hyena-Class Bomber"
ENT.Author = "Salty"
ENT.Information = "Droid Hyena Bomber of the Trade Federation"
ENT.Category = "[LVS] - Star Wars"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/salty/hyenaclassbomber.mdl"
ENT.GibModels = {
	"models/Salty/HyenaGib1.mdl",
	"models/Salty/HyenaGib2.mdl",
	"models/Salty/HyenaGib3.mdl",
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",

}


ENT.AITEAM = 1

ENT.MaxVelocity = 2235
ENT.MaxThrust = 2235

ENT.ThrustVtol = 100
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1.25

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 950
ENT.MaxShield = 250

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(78.22,-7.97,76.47),
		Vector(78.22,7.97,76.47),
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 1500
	weapon.Delay = 0.16
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 40
		bullet.Damage	= 40
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 95 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 100
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.3 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.35

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector(53.12,41.35,57.04)

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/hyena/protonfire.wav", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.25

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
	
		local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 150
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.3 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.9
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.15
		
		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( 30,(ent._swapMissile and 200 or -200), 100 )

			local projectile = ents.Create( "lvs_cisprotonbomb" )
			projectile:SetPos( ent:LocalToWorld( Vector(52.39,41.86,57.27) ) )
			projectile:SetAngles( Angle(90, by, bz) )
			projectile:SetParent( ent )
			projectile:Spawn()
			projectile:Activate()
			projectile:SetAttacker( IsValid( Driver ) and Driver or self )
			projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
			projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.01 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/hyena/SD_Jericho_Fire.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.19

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
end

sound.Add( {
	name = "LVS.VULTURE.FLYBY",
	sound = {"lvs/vehicles/vulturedroid/flyby.wav","lvs/vehicles/vulturedroid/flyby_a.wav","lvs/vehicles/vulturedroid/flyby_b.wav","lvs/vehicles/vulturedroid/flyby_c.wav"}
} )

ENT.FlyByAdvance = 0
ENT.FlyBySound = "LVS.VULTURE.FLYBY" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/hyena/hyenaidlesound.wav",
		Pitch = 100,
		PitchMin = 0,
		PitchMax = 105,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = false,
	},
}
--PATH lua/entities/lvs_starfighter_n1/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-95,143.87,30.93), 0, 20, 2, 2500, 150 )
	self:RegisterTrail( Vector(-95,-143.87,30.93), 0, 20, 2, 2500, 150 )

	self:CreateBonePoseParameter( "cabin", 1, Angle(0,0,0), Angle(0,0,0), Vector(0,0,0), Vector(0,0,50) )
end

function ENT:OnFrame()
	self:EngineEffects()
	self:AnimAstromech()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost()

	render.SetMaterial( self.EngineGlow )

	for i = -1,1,2 do
		local pos = self:LocalToWorld( Vector(20,143.87 * i,30.93) )
		render.DrawSprite( pos, Size, Size, Color( 0, 127, 255, 255) )
	end
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for i = -1,1,2 do
		local vOffset = self:LocalToWorld( Vector(41,143.87 * i,30.93) )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/select_ring", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (1000 + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.05 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( 20 )
		particle:SetEndSize( 20 )
		particle:SetAngles( vNormal:Angle() )
		particle:SetColor( math.Rand( 10, 100 ), math.Rand( 100, 220 ), math.Rand( 240, 255 ) )
	end
end

function ENT:AnimAstromech()
	local T = CurTime()

	if (self.nextAstro or 0) < T then
		self.nextAstro = T + math.Rand(0.5,2)
		self.AstroAng = math.Rand(-180,180)

		local HasShield = self:GetShield() > 0

		if self.OldShield == true and not HasShield then
			self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/astromech/shieldsdown"..math.random(1,2)..".ogg", 100 )
		else
			if math.random(0,4) == 3 then
				self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/astromech/"..math.random(1,11)..".ogg", 70 )
			end
		end
		
		self.OldShield = HasShield
	end

	self.smastro = self.smastro and (self.smastro + ((self.AstroAng or 0) - self.smastro) * RealFrameTime() * 10) or 0

	self:ManipulateBoneAngles( 2, Angle(self.smastro,0,0) )
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/brake.wav", 85 )
end

--PATH lua/entities/lvs_starfighter_vwing/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_turbo_laser/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_turret.lua:
return gluapack()()
--PATH lua/entities/lvs_turret_ai_red/shared.lua:
ENT.Base = "lvs_base_turret"

ENT.PrintName = "Anti-Infantry Turret"
ENT.Author = "Luna"
ENT.Information = "Infantry Problem? Rotary laser cannon says 'Not Anymore.'"
ENT.Category = "[LVS] - Turrets (CIS)"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/antiinfantryturret/Anti-InfantryTurret.mdl"

ENT.AITEAM = 1

ENT.MaxVelocity = 3000
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

ENT.MaxHealth = 4800

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Float", "TurretPitch" )
	self:AddDT( "Float", "TurretYaw" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:TraceTurret()
	local ID = self:LookupAttachment( "muzzle" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:GetAimAngles( ent )
    local trace = ent:GetEyeTrace()
    local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,60) ) ):GetNormalized():Angle() )

    return AimAngles
end

function ENT:WeaponsInRange( ent )
    local AimAngles = self:GetAimAngles( ent )

    return not (AimAngles.p >= 19 or AimAngles.p <= -24)
end

function ENT:InitWeapons()
	local weapon = {}
    weapon.Icon = Material("lvs/weapons/mg.png")
    weapon.Delay = 0.08
    weapon.HeatRateUp = .2
    weapon.HeatRateDown = .3
    weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local base = ent:GetVehicle()

		local ID = self:LookupAttachment( "muzzle" )
		local Muzzle = self:GetAttachment( ID )

		if not Muzzle then return end	

		local Pos = Muzzle.Pos
		local Dir = Muzzle.Ang:Up()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.015,  0.015, 0.015 )
		bullet.TracerName = "lvs_laser_red_short"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 20000
		bullet.SplashDamage	= 20
		bullet.SplashDamageRadius	= 120
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		base.PrimarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )
		ent:LVSFireBullet( bullet )
		
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )	
		if ent:GetVehicle():GetIsCarried( ent ) then
			self:SetPoseParameter("turret_pitch", 0 )
			self:SetPoseParameter("turret_yaw", 0 )
		end
		
		local AimAngles = self:GetAimAngles( ent )

		self:SetPoseParameter("turret_pitch", AimAngles.p )
		self:SetPoseParameter("turret_yaw", AimAngles.y )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"
--PATH lua/entities/lvs_vehicle_repair.lua:
return gluapack()()
--PATH lua/entities/lvs_vehicle_repair.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Maintenance Station"
ENT.Author = "Luna"
ENT.Information = "Repairs Vehicles"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal )
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:Initialize()	
		self:SetModel( "models/props_vehicles/generatortrailer01.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:DrawShadow( false )
		self:SetTrigger( true )
		self:SetCollisionGroup( COLLISION_GROUP_WORLD )
	end

	function ENT:Refil( entity )
		if not IsValid( entity ) then return end

		if not entity.LVS then return end

		local Repaired = false

		if entity:GetHP() ~= entity:GetMaxHP() then
			entity:SetHP( entity:GetMaxHP() )

			Repaired = true
		end

		if entity:OnArmorMaintenance() then
			Repaired = true
		end

		if Repaired then
			entity:EmitSound("npc/dog/dog_servo2.wav")
		end

		if entity:WeaponRestoreAmmo() then
			entity:EmitSound("items/ammo_pickup.wav")
		end

		entity:OnMaintenance()
	end

	function ENT:StartTouch( entity )
		self:Refil( entity )
	end

	function ENT:EndTouch( entity )
		self:Refil( entity )
	end

	function ENT:Touch( entity )
	end

	function ENT:Think()
		return false
	end
end

if CLIENT then
	local WhiteList = {
		["weapon_physgun"] = true,
		["weapon_physcannon"] = true,
		["gmod_tool"] = true,
	}

	local mat = Material( "models/wireframe" )
	local FrameMat = Material( "lvs/3d2dmats/frame.png" )
	local RepairMat = Material( "lvs/3d2dmats/repair.png" )
	function ENT:Draw()
		local ply = LocalPlayer()
		local Small = false

		if IsValid( ply ) and not IsValid( ply:lvsGetVehicle() ) then
			self:DrawModel()

			Small = true

			if GetConVarNumber( "cl_draweffectrings" ) == 0 then return end

			local ply = LocalPlayer()
			local wep = ply:GetActiveWeapon()

			if not IsValid( wep ) then return end

			local weapon_name = wep:GetClass()

			if not WhiteList[ weapon_name ] then
				return
			end
		end

		local Pos = self:GetPos()

		for i = 0, 180, 180 do
			cam.Start3D2D( self:LocalToWorld( Vector(0,0, self:OBBMins().z + 2 ) ), self:LocalToWorldAngles( Angle(i,90,0) ), 0.25 )
				surface.SetDrawColor( 255, 150, 0, 255 )

				surface.SetMaterial( FrameMat )
				surface.DrawTexturedRect( -512, -512, 1024, 1024 )

				surface.SetMaterial( RepairMat )
				if Small then
					surface.DrawTexturedRect( -256, 0, 512, 512 )
				else
					surface.DrawTexturedRect( -512, -512, 1024, 1024 )
				end
			cam.End3D2D()
		end
	end
end
--PATH lua/entities/lvs_walker_atrt_flamethrower/cl_camera.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atrt_rotary/cl_init.lua:
include("shared.lua")
include( "cl_ikfunctions.lua" )
include( "cl_camera.lua" )
include( "cl_legs.lua" )

function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		if self:GetIsRagdoll() then
			if math.random(0,45) < 3 then
				if math.random(1,2) == 1 then
					local Pos = self:LocalToWorld( Vector(0,0,20) + VectorRand() * 80 )
					local effectdata = EffectData()
						effectdata:SetOrigin( Pos )
					util.Effect( "cball_explode", effectdata, true, true )
					
					sound.Play( "lvs/vehicles/atte/spark"..math.random(1,4)..".ogg", Pos, 75 )
				end
			end
		end

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(0,0,100) ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(0,20,80) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(1,3) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(0,-20,80) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(1,3) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

local zoom = 0
local zoom_mat = Material( "vgui/zoom" )

local white = Color(255,255,255,255)
local red = Color(255,0,0,255)

function ENT:PaintZoom( X, Y, ply )
	local TargetZoom = ply:lvsKeyDown( "ZOOM" ) and 1 or 0

	zoom = zoom + (TargetZoom - zoom) * RealFrameTime() * 10

	X = X * 0.5
	Y = Y * 0.5

	surface.SetDrawColor( Color(255,255,255,255 * zoom) )
	surface.SetMaterial(zoom_mat ) 
	surface.DrawTexturedRectRotated( X + X * 0.5, Y * 0.5, X, Y, 0 )
	surface.DrawTexturedRectRotated( X + X * 0.5, Y + Y * 0.5, Y, X, 270 )
	surface.DrawTexturedRectRotated( X * 0.5, Y * 0.5, Y, X, 90 )
	surface.DrawTexturedRectRotated( X * 0.5, Y + Y * 0.5, X, Y, 180 )
end

ENT.IconEngine = Material( "lvs/engine.png" )

function ENT:LVSHudPaintInfoText( X, Y, W, H, ScrX, ScrY, ply )
	local Vel = self:GetVelocity():Length()
	local kmh = math.Round(Vel * 0.09144,0)

	draw.DrawText( "km/h ", "LVS_FONT", X + 72, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( kmh, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, color_white, TEXT_ALIGN_LEFT )

	if ply ~= self:GetDriver() then return end

	local hX = X + W - H * 0.5
	local hY = Y + H * 0.25 + H * 0.25

	surface.SetMaterial( self.IconEngine )
	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawTexturedRectRotated( hX + 4, hY + 1, H * 0.5, H * 0.5, 0 )
	surface.SetDrawColor( color_white )
	surface.DrawTexturedRectRotated( hX + 2, hY - 1, H * 0.5, H * 0.5, 0 )

	if self:GetIsCarried() then
		draw.SimpleText( "X" , "LVS_FONT",  hX, hY, Color(0,0,0,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	else
		local Throttle = Vel / 150
		self:LVSDrawCircle( hX, hY, H * 0.35, math.min( Throttle, 1 ) )
	end
end



function ENT:RemoveLight()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end
end


local spotlight = Material( "effects/lfs_base/spotlight_projectorbeam" )
local glow_spotlight = Material( "sprites/light_glow02_add" )

function ENT:Draw()
	self:DrawModel()
	
	if not self:GetFlashlightStatus(false) then 
		self:RemoveLight()

		return
	end
	
	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 20 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( false ) 
		thelamp:SetFarZ( 2500 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 80 )
		self.projector = thelamp
	end

	local StartPos = self:LocalToWorld( Vector(45,0,85) )
	local Dir = self:GetForward()

	render.SetMaterial( glow_spotlight )
	render.DrawSprite( StartPos + Dir * -10 , 120, 20, Color( 255, 255, 255, 255) )


	render.SetMaterial( spotlight )
	render.DrawBeam(  StartPos - Dir * 5,  StartPos + Dir * 200, 150, 0, 0.99, Color( 255, 255, 255, 10) ) 
	
	if IsValid( self.projector ) then
		self.projector:SetPos( StartPos )
		self.projector:SetAngles( Dir:Angle() )
		self.projector:Update()
	end
end
--PATH lua/entities/lvs_walker_atrt_rotary/cl_camera.lua:

function ENT:CalcViewDriver( ply, pos, angles, fov, pod )
	if pod:GetThirdPersonMode() then
			local view = {}
			view.origin = pos
			view.angles = angles
			view.fov = fov
			view.drawviewer = true
	
		local mn = self:OBBMins()
		local mx = self:OBBMaxs()
		local radius = ( mn - mx ):Length()
		local radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )

		local StartPos = self:LocalToWorld( self:OBBCenter() ) + clamped_angles:Up() * 40
		local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * (radius * 0.2 + radius * pod:GetCameraHeight())

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.angles = angles + Angle(5,0,0)
		view.origin = tr.HitPos
		view.drawviewer = true

		if tr.Hit and  not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
end

function ENT:LVSCalcView( ply, pos, angles, fov, pod )

	local view = {}
	view.origin = pos
	view.angles = angles
	view.fov = fov
	view.drawviewer = false
	--view.origin = self:LocalToWorld( Vector(0,0,0) )
		
	if pod:GetThirdPersonMode() then
		return self:CalcViewDriver( ply, pos, angles, fov, pod )
	else 
		return view
	end
end
--PATH lua/entities/lvs_walker_atrt_standart/cl_ikfunctions.lua:

function ENT:OnRemoved()
	self:LegClearAll()
	self:RemoveLight()
end

local debugred = Color(255,0,0,255)
local debugblue = Color(0,0,255,255)
local debuggreen = Color(0,255,0,255)

function ENT:LegClearAll()
	if istable( self.IK_Joints ) then 
		for _, tab in pairs( self.IK_Joints ) do
			for _,prop in pairs( tab ) do
				if IsValid( prop ) then
					prop:Remove()
				end
			end
		end
		
		self.IK_Joints = nil
	end
end

function ENT:GetLegEnts( index, L1, L2, JOINTANG, STARTPOS, ENDPOS, ATTACHMENTS )
	if not istable( self.IK_Joints ) then self.IK_Joints = {} end

	if self.IK_Joints[ index ] then
		if IsValid( self.IK_Joints[ index ].LegBaseRot ) and IsValid( self.IK_Joints[ index ].LegRotCalc ) then
			if (self.IK_Joints[ index ].LegBaseRot:GetPos() - STARTPOS):Length() > 1 or (self.IK_Joints[ index ].LegRotCalc:GetPos() - STARTPOS):Length() > 1 then
				for k, v in pairs( self.IK_Joints[ index ] ) do
					if IsValid( v ) then
						v:Remove()
					end
				end
				self.IK_Joints[ index ] = nil
			end
		end
	end

	if not self.IK_Joints[ index ] then
		self.IK_Joints[ index ] = {}

		local BaseProp = ents.CreateClientProp()
		BaseProp:SetPos( STARTPOS )
		BaseProp:SetAngles( JOINTANG )
		BaseProp:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		BaseProp:SetParent( self )
		BaseProp:Spawn()

		local LegRotCalc = ents.CreateClientProp()
		LegRotCalc:SetPos( STARTPOS )
		LegRotCalc:SetAngles( JOINTANG )
		LegRotCalc:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		LegRotCalc:SetParent( self )
		LegRotCalc:Spawn()

		local prop1 = ents.CreateClientProp()
		prop1:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 * 0.5) ) )
		prop1:SetAngles( JOINTANG )
		prop1:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop1:SetParent( self )
		prop1:Spawn()

		local prop2 = ents.CreateClientProp()
		prop2:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 + L2 * 0.22 ) ) )
		prop2:SetAngles( JOINTANG )
		prop2:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop2:SetParent( self )
		prop2:Spawn()

		local prop3 = ents.CreateClientProp()
		prop3:SetPos( STARTPOS )
		prop3:SetAngles( JOINTANG )
		prop3:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop3:SetParent( LegRotCalc )
		prop1:SetParent( prop3 )
		prop3:Spawn()

		local prop4 = ents.CreateClientProp()
		prop4:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 * 0.7) ) )
		prop4:SetAngles( JOINTANG )
		prop4:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop4:SetParent( prop1 )
		prop2:SetParent( prop4 )
		prop4:Spawn()
		
		self.IK_Joints[ index ].LegBaseRot = BaseProp
		self.IK_Joints[ index ].LegRotCalc = LegRotCalc
		self.IK_Joints[ index ].LegEnt1 = prop1
		self.IK_Joints[ index ].LegEnt2 = prop2
		self.IK_Joints[ index ].LegEnt3 = prop3
		self.IK_Joints[ index ].LegEnt4 = prop4

		for _, v in pairs( self.IK_Joints[ index ] ) do
			v:SetColor( Color( 0, 0, 0, 0 ) )
			v:SetRenderMode( RENDERMODE_TRANSALPHA )
		end

		if ATTACHMENTS then
			if ATTACHMENTS.Leg1 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop3:LocalToWorld( ATTACHMENTS.Leg1.Pos ) )
				prop:SetAngles( prop3:LocalToWorldAngles( ATTACHMENTS.Leg1.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg1.MDL )
				prop:SetParent( prop3 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment1 = prop
			end
			if ATTACHMENTS.Leg2 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop4:LocalToWorld( ATTACHMENTS.Leg2.Pos ) )
				prop:SetAngles( prop4:LocalToWorldAngles( ATTACHMENTS.Leg2.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg2.MDL )
				prop:SetParent( prop4 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment2 = prop
			end
			if ATTACHMENTS.Foot then
				local prop = ents.CreateClientProp()
				prop:SetModel( ATTACHMENTS.Foot.MDL )
				prop:SetParent( prop2 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment3 = prop
			end
		end
	end

	if not IsValid( self.IK_Joints[ index ].LegRotCalc ) or not IsValid( self.IK_Joints[ index ].LegBaseRot ) or not IsValid( self.IK_Joints[ index ].LegEnt1 ) or not IsValid( self.IK_Joints[ index ].LegEnt2 ) or not IsValid( self.IK_Joints[ index ].LegEnt3 ) or not IsValid( self.IK_Joints[ index ].LegEnt4 ) then
		self:LegClearAll()

		return
	end

	self.IK_Joints[ index ].LegRotCalc:SetAngles(self.IK_Joints[ index ].LegBaseRot:LocalToWorldAngles( self.IK_Joints[ index ].LegBaseRot:WorldToLocal( ENDPOS ):Angle() ) )

	local LegRotCalcPos = self.IK_Joints[ index ].LegRotCalc:GetPos()

	local Dist = math.min( (LegRotCalcPos - ENDPOS ):Length(), L1 + L2)
	local Angle1 = 90 - math.deg( math.acos( (Dist ^ 2 + L1 ^ 2 - L2 ^ 2) / (2 * Dist * L1) ) )
	local Angle2 = math.deg( math.acos( (Dist ^ 2 + L2 ^ 2 - L1 ^ 2) / (2 * Dist * L2) ) ) + 90

	self.IK_Joints[ index ].LegEnt3:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle1,180,180) ) )
	self.IK_Joints[ index ].LegEnt4:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle2,180,180) ) )
	
	if self.IK_Joints[ index ].Attachment3 then
		self.IK_Joints[ index ].Attachment3:SetAngles( self:LocalToWorldAngles( ATTACHMENTS.Foot.Ang ) )
		self.IK_Joints[ index ].Attachment3:SetPos(self.IK_Joints[ index ].LegEnt2:GetPos() + self:GetForward() * ATTACHMENTS.Foot.Pos.x  + self:GetRight() * ATTACHMENTS.Foot.Pos.y + self:GetUp() * ATTACHMENTS.Foot.Pos.z )
	end


	--debug code
	local RFT = RealFrameTime()
	debugoverlay.Cross( self.IK_Joints[ index ].LegBaseRot:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegRotCalc:GetPos(), self.IK_Joints[ index ].LegEnt4:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt4:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegEnt4:GetPos(), self.IK_Joints[ index ].LegEnt2:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt2:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt1:GetPos(), 4, RFT, debugblue, true )
	debugoverlay.Sphere( self.IK_Joints[ index ].LegEnt3:GetPos(), 10, RFT, debugblue, true )
end

--PATH lua/entities/lvs_walker_atrt_standart/cl_legs.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atte/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atte/cl_ikfunctions.lua:

function ENT:OnRemoved()
	self:LegClearAll()
end

local debugred = Color(255,0,0,255)
local debugblue = Color(0,0,255,255)
local debuggreen = Color(0,255,0,255)

function ENT:LegClearAll()
	if istable( self.IK_Joints ) then 
		for _, tab in pairs( self.IK_Joints ) do
			for _,prop in pairs( tab ) do
				if IsValid( prop ) then
					prop:Remove()
				end
			end
		end
		
		self.IK_Joints = nil
	end
end

function ENT:GetLegEnts( index, L1, L2, JOINTANG, STARTPOS, ENDPOS, ATTACHMENTS )
	if not istable( self.IK_Joints ) then self.IK_Joints = {} end

	if self.IK_Joints[ index ] then
		if IsValid( self.IK_Joints[ index ].LegBaseRot ) and IsValid( self.IK_Joints[ index ].LegRotCalc ) then
			if (self.IK_Joints[ index ].LegBaseRot:GetPos() - STARTPOS):Length() > 1 or (self.IK_Joints[ index ].LegRotCalc:GetPos() - STARTPOS):Length() > 1 then
				for k, v in pairs( self.IK_Joints[ index ] ) do
					if IsValid( v ) then
						v:Remove()
					end
				end
				self.IK_Joints[ index ] = nil
			end
		end
	end

	if not self.IK_Joints[ index ] then
		self.IK_Joints[ index ] = {}

		local BaseProp = ents.CreateClientProp()
		BaseProp:SetPos( STARTPOS )
		BaseProp:SetAngles( JOINTANG )
		BaseProp:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		BaseProp:SetParent( self )
		BaseProp:Spawn()

		local LegRotCalc = ents.CreateClientProp()
		LegRotCalc:SetPos( STARTPOS )
		LegRotCalc:SetAngles( JOINTANG )
		LegRotCalc:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		LegRotCalc:SetParent( self )
		LegRotCalc:Spawn()

		local prop1 = ents.CreateClientProp()
		prop1:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 * 0.5) ) )
		prop1:SetAngles( JOINTANG )
		prop1:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop1:SetParent( self )
		prop1:Spawn()

		local prop2 = ents.CreateClientProp()
		prop2:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 + L2) ) )
		prop2:SetAngles( JOINTANG )
		prop2:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop2:SetParent( self )
		prop2:Spawn()

		local prop3 = ents.CreateClientProp()
		prop3:SetPos( STARTPOS )
		prop3:SetAngles( JOINTANG )
		prop3:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop3:SetParent( LegRotCalc )
		prop1:SetParent( prop3 )
		prop3:Spawn()

		local prop4 = ents.CreateClientProp()
		prop4:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1) ) )
		prop4:SetAngles( JOINTANG )
		prop4:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop4:SetParent( prop1 )
		prop2:SetParent( prop4 )
		prop4:Spawn()
		
		self.IK_Joints[ index ].LegBaseRot = BaseProp
		self.IK_Joints[ index ].LegRotCalc = LegRotCalc
		self.IK_Joints[ index ].LegEnt1 = prop1
		self.IK_Joints[ index ].LegEnt2 = prop2
		self.IK_Joints[ index ].LegEnt3 = prop3
		self.IK_Joints[ index ].LegEnt4 = prop4

		for _, v in pairs( self.IK_Joints[ index ] ) do
			v:SetColor( Color( 0, 0, 0, 0 ) )
			v:SetRenderMode( RENDERMODE_TRANSALPHA )
		end

		if ATTACHMENTS then
			if ATTACHMENTS.Leg1 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop3:LocalToWorld( ATTACHMENTS.Leg1.Pos ) )
				prop:SetAngles( prop3:LocalToWorldAngles( ATTACHMENTS.Leg1.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg1.MDL )
				prop:SetParent( prop3 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment1 = prop
			end
			if ATTACHMENTS.Leg2 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop4:LocalToWorld( ATTACHMENTS.Leg2.Pos ) )
				prop:SetAngles( prop4:LocalToWorldAngles( ATTACHMENTS.Leg2.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg2.MDL )
				prop:SetParent( prop4 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment2 = prop
			end
			if ATTACHMENTS.Foot then
				local prop = ents.CreateClientProp()
				prop:SetModel( ATTACHMENTS.Foot.MDL )
				prop:SetParent( prop2 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment3 = prop
			end
		end
	end

	if not IsValid( self.IK_Joints[ index ].LegRotCalc ) or not IsValid( self.IK_Joints[ index ].LegBaseRot ) or not IsValid( self.IK_Joints[ index ].LegEnt1 ) or not IsValid( self.IK_Joints[ index ].LegEnt2 ) or not IsValid( self.IK_Joints[ index ].LegEnt3 ) or not IsValid( self.IK_Joints[ index ].LegEnt4 ) then
		self:LegClearAll()

		return
	end

	self.IK_Joints[ index ].LegRotCalc:SetAngles(self.IK_Joints[ index ].LegBaseRot:LocalToWorldAngles( self.IK_Joints[ index ].LegBaseRot:WorldToLocal( ENDPOS ):Angle() ) )

	local LegRotCalcPos = self.IK_Joints[ index ].LegRotCalc:GetPos()

	local Dist = math.min( (LegRotCalcPos - ENDPOS ):Length(), L1 + L2)
	local Angle1 = 90 - math.deg( math.acos( (Dist ^ 2 + L1 ^ 2 - L2 ^ 2) / (2 * Dist * L1) ) )
	local Angle2 = math.deg( math.acos( (Dist ^ 2 + L2 ^ 2 - L1 ^ 2) / (2 * Dist * L2) ) ) + 90

	self.IK_Joints[ index ].LegEnt3:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle1,180,180) ) )
	self.IK_Joints[ index ].LegEnt4:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle2,180,180) ) )

	if self.IK_Joints[ index ].Attachment3 then
		self.IK_Joints[ index ].Attachment3:SetAngles( self:LocalToWorldAngles( ATTACHMENTS.Foot.Ang ) )
		self.IK_Joints[ index ].Attachment3:SetPos(self.IK_Joints[ index ].LegEnt2:GetPos() + self:GetForward() * ATTACHMENTS.Foot.Pos.x  + self:GetRight() * ATTACHMENTS.Foot.Pos.y + self:GetUp() * ATTACHMENTS.Foot.Pos.z )
	end


	--debug code
	local RFT = RealFrameTime()
	debugoverlay.Cross( self.IK_Joints[ index ].LegBaseRot:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegRotCalc:GetPos(), self.IK_Joints[ index ].LegEnt4:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt4:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegEnt4:GetPos(), self.IK_Joints[ index ].LegEnt2:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt2:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt1:GetPos(), 4, RFT, debugblue, true )
	debugoverlay.Sphere( self.IK_Joints[ index ].LegEnt3:GetPos(), 10, RFT, debugblue, true )
end

--PATH lua/entities/lvs_walker_atte/sh_turret.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atte/sh_gunner.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_hsd/cl_init.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/money_printer/cl_init.lua:
return gluapack()()
--PATH lua/entities/mortar_bomb_shell/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end
--PATH lua/entities/mortar_bomb_shell/shared.lua:
ENT.Type			=	"anim"
ENT.Base			=	"base_entity"
ENT.PrintName		=	"[DU] Mortar Bomb Shell"
ENT.Spawnable		=	false
ENT.Category 		=   "DolUnity"
--PATH addons/[mrs] mc_quests/lua/entities/mqs_npc/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.MQSNPC = true
	self.names = 0
end

function ENT:Draw()
	self:DrawModel()

	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > MQS.Config.QuestEntDrawDist ^ 2 then return end

	local Pos = self:EyePos() or self:GetPos()
	Pos = Pos + Vector(0, 0, 10)
	local Ang = self:GetAngles()
	local eyepos = EyePos()
	local planeNormal = Ang:Up()
	Ang:RotateAroundAxis(Ang:Forward(), 90)

	local relativeEye = eyepos - Pos
	local relativeEyeOnPlane = relativeEye - planeNormal * relativeEye:Dot(planeNormal)
	local textAng = relativeEyeOnPlane:AngleEx(planeNormal)

	textAng:RotateAroundAxis(textAng:Up(), 90)
	textAng:RotateAroundAxis(textAng:Forward(), 90)

	cam.Start3D2D(Pos - Ang:Right() * (8 + math.sin(CurTime()) * 0.9), textAng, 0.1)
		draw.RoundedBox(8, -self.names / 2 - 10, 0, self.names + 20, 35, MSD.Theme["d"])
		self.names = draw.SimpleTextOutlined(self:GetNamer(), "MSDFont.32", 0, 0, color_white, TEXT_ALIGN_CENTER, 0, 1, color_black)
	cam.End3D2D()
end
--PATH lua/entities/mvp_simpledefcons_manager.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "DEFCON Manager"
ENT.Author = "Kot @ Multiverse Project"

ENT.Spawnable = true
ENT.AdminOnly = false
ENT.Category = "MVP - Simple Defcons"

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

ENT.CanDrag = false

function ENT:Initialize()
    if SERVER then
        self:SetModel(mvp.config.Get("simpledefcons.entityManagerModel") or "models/reizer_props/alysseum_project/medicine_obj/med_table_01/med_table_01.mdl")
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)

        self:SetUseType(SIMPLE_USE)
    end
end

function ENT:Use(activator, caller, useType, value)
    local canAccess = mvp.package.Get("simpledefcons").manage.CheckPermissions(activator)

    if (not canAccess) then
        mvp.q.NotifyError(mvp.q.Lang("simpledefcons.managerEntity"), mvp.q.Lang("general.no_permission"), nil, activator)
        return
    end

    net.Start("mvp.simpledefcons.Open")
    net.Send(activator)
end

if (CLIENT) then
    function ENT:Draw()
        self:DrawModel()

        mvp.utils.DrawEntityDisplay(self, mvp.q.Lang("simpledefcons.managerEntity"), mvp.q.Lang("simpledefcons.managerEntity.description"), true)
    end
end

--PATH lua/entities/n-1.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "fighter_base"
ENT.Type = "vehicle"

ENT.PrintName = "N-1 Starfighter"
ENT.Author = "Liam0102, Syphadias"
ENT.Category = "Star Wars Vehicles: Republic"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.EntModel = "models/starwars/syphadias/ships/n1/n1-hull.mdl"
ENT.Vehicle = "N1v2"
ENT.StartHealth = 1500;
ENT.Allegiance = "Republic";
list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then

ENT.FireSound = Sound("weapons/xwing_shoot.wav");
ENT.NextUse = {Wings = CurTime(),Use = CurTime(),Fire = CurTime(),};


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("n-1");
	e:SetPos(tr.HitPos + Vector(0,0,10));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()


	self:SetNWInt("Health",self.StartHealth);
	
	self.WeaponLocations = {
		Left = self:GetPos()+self:GetForward()*150+self:GetUp()*50+self:GetRight()*-20,
		Right = self:GetPos()+self:GetForward()*150+self:GetUp()*50+self:GetRight()*20,
	}
	self.WeaponsTable = {};
	self.BoostSpeed = 2250;
	self.ForwardSpeed = 1500;
	self.UpSpeed = 550;
	self.AccelSpeed = 9;
	self.CanStandby = true;
	self.CanBack = true;
	self.CanRoll = true;
	self.Cooldown = 2;
	self.HasLookaround = true;
	self.CanShoot = true;
	self.Bullet = CreateBulletStructure(75,"green");
	self.FireDelay = 0.15;
	self.AlternateFire = true;
	self.FireGroup = {"Left","Right",};
	//self.CurrentDroid = self.DroidModels[math.random(1,3)];
	//self.ExitModifier = {x=0,y=225,z=100};
	
	self:SpawnCockpit();
	self:SpawnR2Unit();
	self:SpawnEngines();
	self:SpawnWindow();
	
	self.PilotVisible = true;
	self.PilotPosition = {x=0,y=-45,z=33.5};
	self.PilotAnim = "drive_jeep";
	
	self.BaseClass.Initialize(self);
end

//Attachments Below
function ENT:SpawnCockpit()

	local e = ents.Create("prop_physics");
	e:SetModel("models/starwars/syphadias/ships/n1/n1-cockpit.mdl");
	e:SetAngles(self:GetAngles());
	e:SetPos(self:GetPos());
	e:Spawn();
	e:Activate();
	e:SetParent(self);
	//e:GetPhysicsObject():EnableMotion(false);
	//e:GetPhysicsObject():EnableCollisions(false);
	self.Cockpit = e;
end

function ENT:SpawnR2Unit()

	local e = ents.Create("prop_physics");
	e:SetModel("models/starwars/syphadias/ships/n1/n1-r2.mdl");
	e:SetAngles(self:GetAngles());
	e:SetPos(self:GetPos());
	e:Spawn();
	e:Activate();
	e:SetParent(self);
	//e:GetPhysicsObject():EnableMotion(false);
	//e:GetPhysicsObject():EnableCollisions(false);
	self.R2Unit = e;
end

function ENT:SpawnEngines()

	local e = ents.Create("prop_physics");
	e:SetModel("models/starwars/syphadias/ships/n1/n1-engines.mdl");
	e:SetAngles(self:GetAngles());
	e:SetPos(self:GetPos());
	e:Spawn();
	e:Activate();
	e:SetParent(self);
	//e:GetPhysicsObject():EnableMotion(false);
	//e:GetPhysicsObject():EnableCollisions(false);
	self.Engines = e;
end

function ENT:SpawnWindow()

	local e = ents.Create("prop_physics");
	e:SetModel("models/starwars/syphadias/ships/n1/n1-window.mdl");
	e:SetAngles(self:GetAngles());
	e:SetPos(self:GetPos()+self:GetForward()*44);
	e:Spawn();
	e:Activate();
	e:SetParent(self);
	//e:GetPhysicsObject():EnableMotion(false);
	//e:GetPhysicsObject():EnableCollisions(false);
	self.Window = e;
end

function ENT:Enter(p)

	if(IsValid(self.Window)) then
		self.Window:SetPos(self:GetPos()+self:GetForward()*0);
	end
	self.BaseClass.Enter(self,p);
end

function ENT:Exit(kill)

	if(IsValid(self.Window)) then
		self.Window:SetPos(self:GetPos()+self:GetForward()*44);
	end
	self.BaseClass.Exit(self,kill);
end

function ENT:Think()

	if(self.Inflight) then
		if(IsValid(self.Pilot)) then
			if(self.Pilot:KeyDown(IN_ATTACK2)) then
				local pos = self:GetPos()+self:GetForward()*220+self:GetUp()*20;
				self:FireBlast(pos,false,8,600,false,20);
			end
		end
	end
	self.BaseClass.Think(self);
end

end

if CLIENT then
	
	ENT.CanFPV = true;
	ENT.Sounds={
		Engine=Sound("ambient/atmosphere/ambience_base.wav"),
	}
	
	function ENT:Initialize()
		self.Emitter = ParticleEmitter(self:GetPos());
		self.BaseClass.Initialize(self);
	end
	
    ENT.ViewDistance = 575;
    ENT.ViewHeight = 125;
    ENT.FPVPos = Vector(-31,0,67.5);
	
	function ENT:Effects()
	

		local p = LocalPlayer();
		local roll = math.Rand(-45,45);
		local normal = (self.Entity:GetRight() * -1):GetNormalized();
		local FWD = self:GetRight();
		local id = self:EntIndex();
		for k,v in pairs(self.EnginePos) do

			local heatwv = self.Emitter:Add("sprites/heatwave",v+FWD*25);
			heatwv:SetVelocity(normal*2);
			heatwv:SetDieTime(0.1);
			heatwv:SetStartAlpha(255);
			heatwv:SetEndAlpha(255);
			heatwv:SetStartSize(25);
			heatwv:SetEndSize(20);
			heatwv:SetColor(255,255,255);
			heatwv:SetRoll(roll);
			
			local blue = self.FXEmitter:Add("sprites/bluecore",v+FWD*25)
			blue:SetVelocity(normal)
			blue:SetDieTime(0.05)
			blue:SetStartAlpha(255)
			blue:SetEndAlpha(100)
			blue:SetStartSize(25)
			blue:SetEndSize(15)
			blue:SetRoll(roll)
			blue:SetColor(255,255,255)
			
			local dynlight = DynamicLight(id + 4096 * k);
			dynlight.Pos = v+FWD*25;
			dynlight.Brightness = 5;
			dynlight.Size = 150;
			dynlight.Decay = 1024;
			dynlight.R = 100;
			dynlight.G = 100;
			dynlight.B = 255;
			dynlight.DieTime = CurTime()+1;

		end
	end
	
	function ENT:Think()
	
		
		
		local p = LocalPlayer();
		local Flying = self:GetNWBool("Flying".. self.Vehicle);
		local TakeOff = self:GetNWBool("TakeOff");
		local Land = self:GetNWBool("Land");
		if(Flying) then
			if(!TakeOff and !Land) then
				self.EnginePos = {
					self:GetPos()+self:GetRight()*-169.2+self:GetUp()*32.5+self:GetForward()*36,
					self:GetPos()+self:GetRight()*119.2+self:GetUp()*32.5+self:GetForward()*36,
				}
				self:Effects();
			end
		end
		self.BaseClass.Think(self)
	end
	
	local HUD = surface.GetTextureID("vgui/tie_cockpit");
	function N1v2Reticle()
		
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingN1v2");
		local self = p:GetNWEntity("N1v2");
		if(Flying and IsValid(self)) then
			SW_HUD_DrawHull(1500);
			SW_WeaponReticles(self);
			SW_HUD_DrawOverheating(self);
			SW_BlastIcon(self);

			local pos = self:GetPos()+self:GetUp()*58+self:GetForward()*-10+self:GetRight()*6.75;
			local x,y = SW_XYIn3D(pos);
			
			SW_HUD_Compass(self,x,y); // Draw the compass/radar
			SW_HUD_DrawSpeedometer();
		end
	end
	hook.Add("HUDPaint", "N1v2Reticle", N1v2Reticle)

end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_c25.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_flash/shared.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "arc9_nade_base"
ENT.PrintName = "Flashbang"
ENT.Spawnable = false
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE
ENT.Model = "models/arccw/kraken/sw/explosives/world/w_grenade_flash.mdl"
ENT.PhysBoxSize = false
ENT.SphereSize = false
ENT.PhysMat = "grenade"
ENT.LifeTime = 1.5
ENT.ExplodeOnImpact = false
ENT.SmokeTrail = false


ENT.BounceSound = "kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"
ENT.ExplosionSounds = "ArcCW_Kraken.Explosives.Explosion"

function ENT:EntityFacingFactor(theirent)
    local dir = theirent:EyeAngles():Forward()
    local facingdir = (self:GetPos() - (theirent.GetShootPos and theirent:GetShootPos() or theirent:GetPos())):GetNormalized()

    return (facingdir:Dot(dir) + 1) / 2
end

function ENT:EntityFacingUs(theirent)
    local dir = theirent:EyeAngles():Forward()
    local facingdir = (self:GetPos() - (theirent.GetShootPos and theirent:GetShootPos() or theirent:GetPos())):GetNormalized()
    if facingdir:Dot(dir) > -0.25 then return true end
end

function ENT:Detonate()
    local tr = {}
    tr.start = self:GetPos()
    tr.mask = MASK_SOLID

    for _, v in ipairs(player.GetAll()) do
        tr.endpos = v:GetShootPos()

        tr.filter = {self, v, v:GetActiveWeapon()}

        local traceres = util.TraceLine(tr)

        if not traceres.Hit or traceres.Fraction >= 1 or traceres.Fraction <= 0 then
            v:SetNWFloat("ARC9_GSR_LastFlash", CurTime())
            v:SetNWEntity("ARC9_GSR_LastFlashBy", self:GetOwner())
            v:SetNWFloat("ARC9_GSR_FlashDistance", v:GetShootPos():Distance(self:GetPos()))
            v:SetNWFloat("ARC9_GSR_FlashFactor", self:EntityFacingFactor(v))

            if v:GetNWFloat("ARC9_GSR_FlashDistance", v:GetShootPos():Distance(self:GetPos())) < 1500 and v:GetNWFloat("FlashFactor", self:EntityFacingFactor(v)) < tr.endpos:Distance(self:GetPos(v)) then
                if v:GetNWFloat("ARC9_GSR_FlashDistance", v:GetShootPos():Distance(self:GetPos())) < 1000 then
                    v:SetDSP(37, false)
                elseif v:GetNWFloat("ARC9_GSR_FlashDistance", v:GetShootPos():Distance(self:GetPos())) < 800 then
                    v:SetDSP(36, false)
                elseif v:GetNWFloat("ARC9_GSR_FlashDistance", v:GetShootPos():Distance(self:GetPos())) < 600 then
                    v:SetDSP(35, false)
                end
            end
        end
    end

    if self:WaterLevel() > 0 then
        local tr = util.TraceLine({
            start = self:GetPos(),
            endpos = self:GetPos() + Vector(0, 0, 1) * 1024,
            filter = self,
        })

        local tr2 = util.TraceLine({
            start = tr.HitPos,
            endpos = self:GetPos(),
            filter = self,
            mask = MASK_WATER
        })

        ParticleEffect("explosion_water", tr2.HitPos + Vector(0, 0, 8), Angle(0, 0, 0), nil)
        self:EmitSound("weapons/underwater_explode3.wav", 100)
    else
        ParticleEffect("bumpmine_detonate", self:GetPos(), Angle(0, 0, 0), nil)
        ParticleEffect("weapon_decoy_ground_effect_shot", self:GetPos(), Angle(0, 0, 0), nil)
        ParticleEffect("explosion_hegrenade_brief", self:GetPos(), Angle(0, 0, 0), nil)
        self:EmitSound("kraken/explosives/flashbang/flashbang_explode1.wav")
    end

    for _, v in ipairs(ents.GetAll()) do
        if v:IsNPC() and self:EntityFacingUs(v) then
            tr.endpos = v.GetShootPos and v:GetShootPos() or v:GetPos()

            tr.filter = {self, v, v.GetActiveWeapon and v:GetActiveWeapon() or v}

            local traceres = util.TraceLine(tr)

            if not traceres.Hit or traceres.Fraction >= 1 or traceres.Fraction <= 0 then
                local flashdistance = tr.endpos:Distance(self:GetPos())
                local flashtime = CurTime()
                local distancefac = 1 - math.Clamp((flashdistance - gsr_flashdistance + gsr_flashdistancefade) / gsr_flashdistancefade, 0, 1)
                local intensity = 1 - math.Clamp(((CurTime() - flashtime) / distancefac - gsr_flashtime + gsr_flashfade) / gsr_flashfade, 0, 1)

                if intensity > 0.2 then
                    v:SetEnemy(nil)
                    v:SetNPCState(NPC_STATE_PLAYDEAD)

                    timer.Simple(intensity * gsr_flashtime * 2, function()
                        if not IsValid(v) then return end
                        v:SetNPCState(NPC_STATE_IDLE)
                    end)

                    if v.ClearEnemyMemory then
                        v:ClearEnemyMemory()
                    end
                end
            end
        end
    end

    if SERVER then
        local dir = self.HitVelocity or self:GetVelocity()

        self:FireBullets({
            Attacker = self,
            Damage = 0,
            Tracer = 0,
            Distance = 256,
            Dir = dir,
            Src = self:GetPos(),
            Callback = function(att, tr, dmg)
                if self.Scorch then
                    util.Decal("Scorch", tr.StartPos, tr.HitPos - (tr.HitNormal * 16), self)
                end
            end
        })
    end

    local dlight = EffectData()
    dlight:SetOrigin(self:GetPos())
    dlight:SetEntity(self.Owner) --i dunno, just use it!
    util.Effect("arc9_flashbang_light", dlight)
    self.deactivated = true
    self:Remove()
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_sequencecharger/shared.lua:
AddCSLuaFile()

ENT.Base = "arc9_gsr_plantable"
ENT.PrintName = "Sequencer Charge"

ENT.Model = "models/arccw/kraken/sw/explosives/world/w_sequencer_charge.mdl"
ENT.WeaponClass = "arc9_go_nade_landmines"
ENT.Bury = 3
ENT.DetectionRange = 96
ENT.ArmDelay = 3


function ENT:OnPlant()
    self:EmitSound("kraken/shared/beeps2.wav", 75, 100, 1, CHAN_AUTO)
end

function ENT:Think()
    if SERVER and self:GetArmed() then
        for _, i in ipairs(ents.FindInSphere(self:GetPos(), self.DetectionRange)) do
            if IsValid(i) and ((i:IsPlayer() and i:GetVelocity():Length2DSqr() >= 22500) or i:IsNPC() or i:IsNextBot()) then
                self:Detonate()
                break
            end
        end
        
        for k, v in ipairs(ents.FindInSphere(self:GetPos(), self.DetectionRange)) do
            if IsValid(v) and (v.LFS or v.LVS) then
                if v.LFS then
					v:StopEngine()
					v:SetShield(0)
					v:SetHP( v:GetHP()/10 )
                    self:Detonate()
				end
				if v.LVS then
					v:StopEngine()
					v:SetShield(0)
					v:SetHP( v:GetHP()/10 )
                    self:Detonate()
				end
                self:Detonate()
                break
            end
        end

        self:NextThink(CurTime() + 0.15)
        return true
    end
end

function ENT:Detonate()
    if SERVER then
        if not self:IsValid() then return end
        local pos = self:GetPos() + self:GetUp() * 6
        local effectdata = EffectData()
        effectdata:SetOrigin(pos)

        if self:WaterLevel() >= 1 then
            util.Effect("WaterSurfaceExplosion", effectdata)
            self:EmitSound("weapons/underwater_explode3.wav", 120, 100, 1, CHAN_AUTO)
        else
            ParticleEffect("zeala_burst", pos, self:GetAngles(), nil)
            local spos = pos

            local trs = util.TraceLine({
                start = spos + Vector(0, 0, 64),
                endpos = spos + Vector(0, 0, -32),
                filter = self
            })

            util.Decal("Scorch", trs.HitPos + trs.HitNormal, trs.HitPos - trs.HitNormal)
            self:EmitSound("kraken/explosives/seismiccharge/close" .. math.random(1,3) .. ".wav", 120, 100, 1, CHAN_AUTO)
        end

        local oldowner = self.Attacker or self:GetOwner()
        if not IsValid(oldowner) then
            oldowner = self
        end

        util.ScreenShake(self:GetPos(), 25, self.DetectionRange * 20, 7, self.DetectionRange * 20)
        self:EmitSound("ArcCW_Kraken.Explosives.Explosion")

        local d = Lerp(self:GetUp():Dot(Vector(0, 0, 1)), 0.25, 1)

        self:SetOwner(NULL)
        util.BlastDamage(oldowner, oldowner, pos, 650, 1200 * d)
        util.BlastDamage(oldowner, oldowner, pos, 225, 356 * d)

        self:Remove()
    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()
        local pos = self:GetPos() + self:GetUp() * 5

        if self:GetArmed() and math.sin(CurTime() * 1) >= 0.75 then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
            render.SetMaterial(Material("effects/blueflare1")) -- Tell render what material we want, in this case the flash from the gravgun
            render.DrawSprite(pos, 16, 16, Color(255, 0, 0)) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            self:EmitSound("kraken/shared/beeps1.wav", 75, 100, 1, CHAN_AUTO)
            cam.End3D()
        end
    end
end
--PATH lua/entities/npc_nightsister_undead/cl_init.lua:
include('shared.lua')

language.Add("npc_nightsister_undead", "Undead Nightsister")
killicon.Add("npc_nightsister_undead","HUD/killicons/default",Color ( 255, 80, 0, 255 ) )

function ENT:Initialize()	
end

function ENT:Draw()	
	--self:SetModelScale( Vector(5,5,5) )
	self.Entity:DrawModel()
end
--PATH lua/entities/npc_nightsister_undead/shared.lua:
ENT.Base = "base_ai"
ENT.Type = "ai"

ENT.PrintName = "CGI Dathomir Warriors"
ENT.Author = "Xystus234-base, OkFellow Designer"
ENT.Contact = ""
ENT.Information		= ""
ENT.Category		= "SNPCs"

ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.AutomaticFrameAdvance = true


/*---------------------------------------------------------
Name: PhysicsCollide
Desc: Called when physics collides. The table contains
data on the collision
//-------------------------------------------------------*/
function ENT:PhysicsCollide( data, physobj )
end
 
 
/*---------------------------------------------------------
Name: PhysicsUpdate
Desc: Called to update the physics .. or something.
//-------------------------------------------------------*/
function ENT:PhysicsUpdate( physobj )
end
  
/*---------------------------------------------------------
Name: SetAutomaticFrameAdvance
Desc: If you're not using animation you should turn this
off - it will save lots of bandwidth.
//-------------------------------------------------------*/
function ENT:SetAutomaticFrameAdvance( bUsingAnim )

self.AutomaticFrameAdvance = bUsingAnim

end 
--PATH lua/entities/npc_vj_battle_droid_swrc/shared.lua:
return gluapack()()
--PATH lua/entities/npc_vj_creature_base/shared.lua:
return gluapack()()
--PATH lua/entities/npc_vj_droideka_droid_swrc/shared.lua:
return gluapack()()
--PATH lua/entities/npc_vj_sbdnew_wounded/shared.lua:
return gluapack()()
--PATH lua/entities/npc_vj_tank_base/shared.lua:
return gluapack()()
--PATH lua/entities/npc_vj_test_aerial/shared.lua:
ENT.Base 			= "npc_vj_creature_base"
ENT.Type 			= "ai"
ENT.PrintName 		= "Aerial NPC"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "Spawn it and fight with it!"
ENT.Instructions 	= "Click on the spawnicon to spawn it."
ENT.Category		= "VJ Base"
--PATH lua/entities/obj_vj_bonefollower.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_blackjack_panel/shared.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_blackjack_panel/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Blackjack Panel"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = false
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar("Entity", 0, "User")
	self:NetworkVar("Int", 0, "Stage")
	self:NetworkVar("Int", 1, "Hand")
end

function ENT:GetCurrentPad(pos)
	if self:GetStage() == 2 then return end -- There is nothing to do on stage 2 but wait.

	if not self.padCache then
		self.padCache = {}
		self.padCache[1] = {} -- The stage for placing bets
		self.padCache[3] = {} -- The stage for choosing an action

		-- Stage 1
		-- Lower bet
		self.padCache[1]["bet_lower"] = {
			boundsA = {x = -6.7, y = -7.7},
			boundsB = {x = -11.7, y = -3.9},
		}
		-- Raise bet
		self.padCache[1]["bet_raise"] = {
			boundsA = {x = 11.7, y = -7.7},
			boundsB = {x = 6.7, y = -3.9},
		}
		-- Place bet
		self.padCache[1]["bet_place"] = {
			boundsA = {x = 11.7, y = -11.7},
			boundsB = {x = -11.7, y = -8},
		}

		-- Stage 3
		self.padCache[3]["action_double"] = {
			boundsA = {x = -0.2, y = -7.7},
			boundsB = {x = -11.7, y = -3.9},
		}
		self.padCache[3]["action_hit"] = {
			boundsA = {x = -0.2, y = -11.7},
			boundsB = {x = -11.7, y = -8},
		}
		self.padCache[3]["action_stand"] = {
			boundsA = {x = 11.7, y = -11.7},
			boundsB = {x = 0.2, y = -8},
		}
		self.padCache[3]["action_split"] = {
			boundsA = {x = 11.7, y = -7.7},
			boundsB = {x = 0.2, y = -3.9},
		}
	end

	if not self.padCache[self:GetStage()] then return false end

	for k, v in pairs(self.padCache[self:GetStage()]) do
		if (pos.x < v.boundsA.x) and (pos.x > v.boundsB.x) and (pos.y > v.boundsA.y) and (pos.y < v.boundsB.y) then
			return k, v
		end
	end

	return false
end
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_chair/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Sign Plaque"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false


PerfectCasino.Core.RegisterEntity("pcasino_chair", {
},
"models/freeman/owain_casino_stool.mdl")
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_roulette_table/cl_init.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_roulette_table/shared.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_sign_interior_standing/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Sign Interior Standing"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false

PerfectCasino.Core.RegisterEntity("pcasino_sign_interior_standing", {
	-- General data
	general = {
		text = {d = "Welcome to the Cool Casino. We hope you enjoy your stay!", t = "string"} -- The text to show
	}
},
"models/freeman/owain_interiorsign_standing.mdl")
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_wheel_slot_machine/shared.lua:
return gluapack()()
--PATH lua/entities/pfx1_08.lua:
return gluapack()()
--PATH lua/entities/pfx1_08__l.lua:
return gluapack()()
--PATH lua/entities/pfx1_08_l.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Fire [Green]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_large_campfire_green"
--PATH lua/entities/pfx1_08~_l.lua:
return gluapack()()
--PATH lua/entities/pfx1_0a.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Cigarette/Pipe smoke"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]cig_smoke*"
--PATH lua/entities/pfx1_0d.lua:
return gluapack()()
--PATH lua/entities/pfx1_0e.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire [Default]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]fireplace_default"
--PATH lua/entities/pfx1_0e_l.lua:
return gluapack()()
--PATH lua/entities/pfx1_0e_l.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Fire [Default]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_large_campfire"
--PATH lua/entities/pfx2_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Sparkle 1"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]sparkle1"

--PATH lua/entities/pfx2_03.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Ground Acid"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]acid_ground"
--PATH lua/entities/pfx3_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Cherry Tree Petals"
ENT.Category         = "PPE: Nature"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[3]sakura_env"


--PATH lua/entities/pfx4_04_s.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Purple Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_v_s"
--PATH lua/entities/pfx4_04~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Purple Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_v*"
--PATH lua/entities/pfx4_06_2.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Red Energy Rod"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]energy_rod_r"
--PATH lua/entities/pfx4_09.lua:
return gluapack()()
--PATH lua/entities/pfx5_00_alt_s.lua:
return gluapack()()
--PATH lua/entities/pfx7_03.lua:
return gluapack()()
--PATH lua/entities/pfx8_00.lua:
return gluapack()()
--PATH lua/entities/pfx8_01.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Red Vortex"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]red_vortex"
--PATH lua/entities/pfx8_02.lua:
return gluapack()()
--PATH lua/entities/pfx8_04.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Core"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]core_1"
--PATH lua/entities/pfx_test.lua:
-- CAT** PlaceableFX::[Fire, Smoke, Weather, Tech, Nature, Other]
-- ENT** PFX:[*]
AddCSLuaFile()     
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"
ENT.PrintName		= "light_test"
ENT.Author			= "npc_teslacybertruck_driver"
ENT.Information		= ""
ENT.Category		= "PPE: Dev"
ENT.Spawnable		= false
ENT.AdminOnly		= false
if SERVER then
    function ENT:Initialize()
	    self:SetModel("models/hunter/blocks/cube025x025x025.mdl")
	    self:SetNoDraw(true)
	    self:DrawShadow(false)
	    self:PhysicsInit( SOLID_VPHYSICS )
	    self:SetMoveType( MOVETYPE_VPHYSICS )
	    self:SetSolid( SOLID_VPHYSICS )
        ParticleEffectAttach( "[~]light_test", 1, self, 1 )
    end
end



--PATH lua/entities/rep_rocket/shared.lua:
return gluapack()()
--PATH lua/entities/republic_speeder.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "speeder_base"
ENT.Type = "vehicle"

ENT.PrintName = "BARC Speeder"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Republic"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.Vehicle = "BARC";
ENT.EntModel = "models/barc/barc1.mdl";
list.Set("SWVehicles", ENT.PrintName, ENT);

local classes = {
	"speeder_bike",
	"stap",
	"rep_tank",
	"aat",
	"republic_speeder",
	"podracer",
	"landspeeder",
	"imp_speeder",
}
function IsSWSpeeder(class)
	
	for k,v in pairs(classes) do
		if(v == class) then
			return true;
		end
	end
	return false;

end
ENT.StartHealth = 1000;
if SERVER then

ENT.NextUse = {Use = CurTime(),Fire = CurTime()};
ENT.FireSound = Sound("vehicles/speeder_shoot.wav");


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("republic_speeder");
	e:SetPos(tr.HitPos + Vector(0,0,10));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw+180,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()
	self.BaseClass.Initialize(self);
	local driverPos = self:GetPos()+self:GetUp()*19+self:GetForward()*28;
	local driverAng = self:GetAngles()+Angle(0,90,0);
	self.SeatClass = "phx_seat3"
	self:SpawnChairs(driverPos,driverAng,false)
	
	self.ForwardSpeed = -550;
	self.BoostSpeed = -850
	self.AccelSpeed = 8;
	self.HoverMod = 0.1;
	self.StartHover = 50;
	self.WeaponLocations = {
		self:GetPos()+self:GetForward()*-100+self:GetUp()*10+self:GetRight()*-10,
		self:GetPos()+self:GetForward()*-100+self:GetUp()*10+self:GetRight()*10,
	}
	self.Bullet = CreateBulletStructure(50,"blue");
	self.WeaponDir = self:GetAngles():Forward()*-1;
	self:SpawnWeapons();
	self.StandbyHoverAmount = 40;
	self.CanShoot = true;

end

local ZAxis = Vector(0,0,1);

function ENT:PhysicsSimulate( phys, deltatime )
	self.BackPos = self:GetPos()+self:GetForward()*80+self:GetUp()*15
	self.FrontPos = self:GetPos()+self:GetForward()*-100+self:GetUp()*15
	self.MiddlePos = self:GetPos()+self:GetUp()*15;		
	if(self.Inflight) then
		local UP = ZAxis;
		self.RightDir = self.Entity:GetForward():Cross(UP):GetNormalized();
		self.FWDDir = self.Entity:GetForward();	
		

		self:RunTraces();

		self.ExtraRoll = Angle(0,0,self.YawAccel / 2);
		if(!self.WaterTrace.Hit) then
			if(self.FrontTrace.HitPos.z >= self.BackTrace.HitPos.z) then
				self.PitchMod = Angle(math.Clamp((self.BackTrace.HitPos.z - self.FrontTrace.HitPos.z),-45,45)/2*-1,0,0)
			else
				self.PitchMod = Angle(math.Clamp(-(self.FrontTrace.HitPos.z - self.BackTrace.HitPos.z),-45,45)/2*-1,0,0)
			end
		end
	end

	
	self.BaseClass.PhysicsSimulate(self,phys,deltatime);
end

end

if CLIENT then
	ENT.Sounds={
		Engine=Sound("landspeeder_fly.wav"),
	}
	
	local Health = 0;
	local Speed = 0;
	function ENT:Think()
		self.BaseClass.Think(self);
		local p = LocalPlayer();
		local Flying = p:GetNWBool("Flying"..self.Vehicle);
		if(Flying) then
			Health = self:GetNWInt("Health");
			Speed = self:GetNWInt("Speed");
		end
		
	end
    ENT.HasCustomCalcView = true;
	local View = {}
	function CalcView()
		
		local p = LocalPlayer();
		local self = p:GetNWEntity("BARC", NULL)
		local DriverSeat = p:GetNWEntity("DriverSeat",NULL);
		local PassengerSeat = p:GetNWEntity("PassengerSeat",NULL);
		if(IsValid(self)) then

			if(IsValid(DriverSeat)) then
				if(DriverSeat:GetThirdPersonMode()) then
					local pos = self:GetPos()+self:GetForward()*270+self:GetUp()*100;
					//local face = self:GetAngles() + Angle(0,180,0);
					local face = ((self:GetPos() + Vector(0,0,100))- pos):Angle();
						View.origin = pos;
						View.angles = face;
					return View;
				end
			end
		end
	end
	hook.Add("CalcView", "BARCView", CalcView)

	
	hook.Add( "ShouldDrawLocalPlayer", "BARCDrawPlayerModel", function( p )
		local self = p:GetNWEntity("BARC", NULL);
		local DriverSeat = p:GetNWEntity("DriverSeat",NULL);
		local PassengerSeat = p:GetNWEntity("PassengerSeat",NULL);
		if(IsValid(self)) then
			if(IsValid(DriverSeat)) then
				if(DriverSeat:GetThirdPersonMode()) then
					return true;
				end
			elseif(IsValid(PassengerSeat)) then
				if(PassengerSeat:GetThirdPersonMode()) then
					return true;
				end
			end
		end
	end);
	
	function BARCReticle()
	
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingBARC");
		local self = p:GetNWEntity("BARC");
		if(Flying and IsValid(self)) then
			local WeaponsPos = {self:GetPos()};
			
			SW_Speeder_Reticles(self,WeaponsPos)
			SW_Speeder_DrawHull(1000)
			SW_Speeder_DrawSpeedometer()

		end
	end
	hook.Add("HUDPaint", "BARCReticle", BARCReticle)
	
	
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/rocket_hh12.lua:
AddCSLuaFile()

ENT.Type 				= "anim"
ENT.Base 				= "base_entity"
ENT.PrintName 			= "RPG-7 Round"
ENT.Author 				= ""
ENT.Information 		= ""

ENT.Model = "models/items/ar2_grenade.mdl"
ENT.Ticks = 0

ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE

ENT.GrenadeDamage = false
ENT.GrenadeRadius = 0
ENT.FuseTime = 10

ENT.DragCoefficient = 0.45

ENT.DetonateOnImpact = true
ENT.ExplosionEffect = true

ENT.Scorch = "Scorch"
ENT.SmokeTrail = true
if SERVER then
    function ENT:Initialize()
        local pb_vert = 1
        local pb_hor = 1
        self:SetModel(self.Model)
        self:PhysicsInitBox(Vector(-pb_vert, -pb_hor, -pb_hor), Vector(pb_vert, pb_hor, pb_hor))
        local phys = self:GetPhysicsObject()

        if phys:IsValid() then
            phys:Wake()
            phys:SetDragCoefficient(self.DragCoefficient)
            phys:SetBuoyancyRatio(0.1)
        end

        self.SpawnTime = CurTime()
    end

    function ENT:Think()
        if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
            self:Detonate()
        end
    end
else
    function ENT:Think()
        if self.SmokeTrail then
            if self.Ticks % 5 == 0 then
                local emitter = ParticleEmitter(self:GetPos())
                if not self:IsValid() or self:WaterLevel() > 2 then return end
                if not IsValid(emitter) then return end
                local smoke = emitter:Add("particle/particle_smokegrenade", self:GetPos())
                smoke:SetVelocity(VectorRand() * 25)
                smoke:SetGravity(Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)))
                smoke:SetDieTime(math.Rand(1.5, 2.0))
                smoke:SetStartAlpha(255)
                smoke:SetEndAlpha(0)
                smoke:SetStartSize(0)
                smoke:SetEndSize(100)
                smoke:SetRoll(math.Rand(-180, 180))
                smoke:SetRollDelta(math.Rand(-0.2, 0.2))
                smoke:SetColor(20, 20, 20)
                smoke:SetAirResistance(5)
                smoke:SetPos(self:GetPos())
                smoke:SetLighting(false)
                emitter:Finish()
            end
            self.Ticks = self.Ticks + 1
        end
    end
end
    
function ENT:Detonate()
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
    
        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
            self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
        else
            util.Effect( "Explosion", effectdata)
            self:EmitSound("ArcCW_Kraken.Explosives.RocketImpact")
        end
    
        local attacker = self
    
        if self.Owner:IsValid() then
            attacker = self.Owner
        end
    
        util.BlastDamage(self, attacker, self:GetPos(), 550, 110)
    
        self:FireBullets({
            Attacker = attacker,
            Damage = 650,
            Tracer = 0,
            Src = src,
            Dir = dir,
            HullSize = 16,
            Distance = 128,
            IgnoreEntity = self,
            Callback = function(atk, btr, dmginfo)
                if IsValid(btr.Entity) and btr.Entity.LVS then
                    dmginfo:ScaleDamage(5)
                    dmginfo:SetDamageType(DMG_AIRBOAT + DMG_SNIPER + DMG_BLAST)
                    dmginfo:SetDamageForce(self:GetForward() * 20000)
                end
            end,
        })

        local fx = EffectData()
        fx:SetOrigin(self:GetPos())
        fx:SetStart(self:GetPos() + self:GetUp())
        fx:SetRadius(400)
        fx:SetEntity(self)
        if self:WaterLevel() > 0 then
            util.Effect("WaterSurfaceExplosion", fx)
        else
            util.Effect("cod2019_grenade_explosion", fx)
            self:EmitSound("ArcCW_Kraken.Explosives.RocketImpact")
        end
        
        for i, e in pairs(ents.FindInSphere(self:GetPos(), 32)) do
            if (e:GetClass() == "npc_strider") then
                e:Fire("Explode")
            end 
        end
    
        self:Remove()
    end
    
    function ENT:PhysicsCollide(colData, collider)
        self:Detonate()
    end
    
    function ENT:Draw()
        cam.Start3D() -- Start the 3D function so we can draw onto the screen.
            render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
            render.DrawSprite( self:GetPos(), math.random(100, 200), math.random(100, 200), Color(255, 175, 150) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
        cam.End3D()
    end
--PATH lua/entities/rw_sw_dispencer_allammo/cl_init.lua:
return gluapack()()
--PATH lua/entities/rw_sw_dispencer_health/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

local dispencer_health = GetConVar("rw_sw_dispenser_health"):GetInt()
ENT.BaseHealth = dispencer_health

ENT.PrintName		= "Health Dispenser"
ENT.Author			= "ChanceSphere574"
ENT.Category		= "StarWars Reworked Armory"
ENT.Spawnable 		= true
ENT.AdminSpawnable	= false

ENT.UseTimer = CurTime()
ENT.Status   = 0

ENT.LoadingSkin = 3
ENT.CurSkin = 1
--PATH lua/entities/sammyservers_textscreen/cl_init.lua:
include("shared.lua")

local render_convar_range = CreateClientConVar("ss_render_range", 1500, true, false, "Determines the render range for Textscreens. Default 1500")
local render_rainbow = CreateClientConVar("ss_render_rainbow", 1, true, false, "Determines if rainbow screens are rendered. If disabled (0), will render as solid white. Default enabled (1)", 0, 1)
local render_range = render_convar_range:GetInt() * render_convar_range:GetInt() --We multiply this is that we can use DistToSqr instead of Distance so we don't need to workout the square root all the time
local rainbow_enabled = cvars.Number("ss_enable_rainbow", 1)
local textscreenFonts = textscreenFonts
local screenInfo = {}
local shouldDrawBoth = false

-- Numbers used in conjunction with text width to work out the render bounds
local widthBoundsDivider = 7.9
local heightBoundsDivider = 12.4

-- ENUM type things for faster table indexing
local FONT = 1
local TEXT = 2
local POSX = 3
local POSY = 4
local COL = 5
local LEN = 6
local SIZE = 7
local CAMSIZE = 8
local RAINBOW = 9

-- Make ply:ShouldDrawLocalPlayer() never get called more than once a frame
hook.Add("Think", "ss_should_draw_both_sides", function()
	shouldDrawBoth = LocalPlayer():ShouldDrawLocalPlayer()
end)

local function ValidFont(f)
	if textscreenFonts[f] ~= nil then
		return textscreenFonts[f]
	elseif table.HasValue(textscreenFonts, f) then
		return f
	else
		return false
	end
end

cvars.AddChangeCallback("ss_render_range", function(convar_name, value_old, value_new)
	render_range = tonumber(value_new) * tonumber(value_new)
end, "3D2DScreens")

cvars.AddChangeCallback("ss_render_rainbow", function(convar_name, value_old, value_new)
	render_rainbow = tonumber(value_new)
end, "3D2DScreens")

-- TODO: https://github.com/Facepunch/garrysmod-issues/issues/3740
-- cvars.AddChangeCallback("ss_enable_rainbow", function(convar_name, value_old, value_new)
-- 	print('ss_enable_rainbow changed: '.. value_new)
-- 	rainbow_enabled = tonumber(value_new)
-- end, "3D2DScreens")

function ENT:Initialize()
	self:SetMaterial("models/effects/vol_light001")
	self:SetRenderMode(RENDERMODE_NONE)
	net.Start("textscreens_download")
	net.WriteEntity(self)
	net.SendToServer()
end

local product
local function IsInFront(entPos, plyShootPos, direction)
	product = (entPos.x - plyShootPos.x) * direction.x +
		(entPos.y - plyShootPos.y) * direction.y +
		(entPos.z - plyShootPos.z) * direction.z
	return product < 0
end


-- Draws the 3D2D text with the given positions, angles and data(text/font/col)
local function Draw3D2D(ang, pos, camangle, data)

	for i = 1, data[LEN] do
		if not data[i] or not data[i][TEXT] then continue end

		cam.Start3D2D(pos, camangle, data[i][CAMSIZE] )
			render.PushFilterMin(TEXFILTER.ANISOTROPIC)
			-- Font
			surface.SetFont(data[i][FONT])
			-- Position
			surface.SetTextPos(data[i][POSX], data[i][POSY])
			-- Rainbow
			if data[i][RAINBOW] ~= nil and data[i][RAINBOW] ~= 0 then
				local j = 0
				for _, code in utf8.codes(data[i][TEXT]) do
					j = j + 1
					--Color
					if rainbow_enabled == 1 and render_rainbow ~= 0 then
						surface.SetTextColor(HSVToColor((CurTime() * 60 + (j * 5)) % 360, 1, 1))
					else
						-- Render as solid white if ss_render_rainbow is disabled or server disabled via ss_enable_rainbow
						surface.SetTextColor(255, 255, 255)
					end
					--Text
					surface.DrawText(utf8.char(code))
				end
			else
				--Color
				surface.SetTextColor(data[i][COL])
				--Text
				surface.DrawText(data[i][TEXT])
			end

			render.PopFilterMin()
		cam.End3D2D()
	end

end

local plyShootPos, ang, pos, camangle, showFront, data -- Less variables being created each frame
function ENT:DrawTranslucent()
	-- Cache the shoot pos for this frame
	plyShootPos = LocalPlayer():GetShootPos()

	if screenInfo[self] ~= nil and self:GetPos():DistToSqr(plyShootPos) < render_range then
		ang = self:GetAngles()
		pos = self:GetPos() + ang:Up()
		camangle = Angle(ang.p, ang.y, ang.r)
		data = screenInfo[self]

		-- Should we draw both screens? (Third person/calview drawing fix)
		if shouldDrawBoth then
			Draw3D2D(ang, pos, camangle, data)
			camangle:RotateAroundAxis(camangle:Right(), 180)
			Draw3D2D(ang, pos, camangle, data)
		else
			-- Is the front of the screen facing us or the back?
			showFront = IsInFront(pos, plyShootPos, ang:Up())

			-- Draw the front of the screen
			if showFront then
				Draw3D2D(ang, pos, camangle, data)
			else
			-- Draw the back of the screen
				camangle:RotateAroundAxis(camangle:Right(), 180)
				Draw3D2D(ang, pos, camangle, data)
			end
		end
	end
end

local function AddDrawingInfo(ent, rawData)
	local drawData = {}
	local textSize = {}

	local totalHeight = 0
	local maxWidth = 0
	local currentHeight = 0

	for i = 1, #rawData do
		-- Setup tables
		if not rawData[i] or not rawData[i].text then continue end
		drawData[i] = {}
		textSize[i] = {}
		-- Text
		drawData[i][TEXT] = rawData[i].text
		-- Font
		drawData[i][FONT] = (ValidFont(rawData[i].font) or textscreenFonts[1])
		-- Text size
		surface.SetFont(drawData[i][FONT])
		textSize[i][1], textSize[i][2] = surface.GetTextSize(drawData[i][TEXT])
		textSize[i][2] = rawData[i].size
		-- Workout max width for render bounds
		maxWidth = maxWidth > textSize[i][1] and maxWidth or textSize[i][1]
		-- Position
		totalHeight = totalHeight + textSize[i][2]
		-- Colour
		drawData[i][COL] = Color(rawData[i].color.r, rawData[i].color.g, rawData[i].color.b, 255)
		-- Size
		drawData[i][SIZE] = rawData[i]["size"]
		-- Remove text if text is empty so we don't waste performance
		if string.len(drawData[i][TEXT]) == 0 or string.len(string.Replace( drawData[i][TEXT], " ", "" )) == 0 then drawData[i][TEXT] = nil end
		--Rainbow
		drawData[i][RAINBOW] = rawData[i]["rainbow"] or 0
	end

	-- Sort out heights
	for i = 1, #rawData do
		if not rawData[i] then continue end
		-- The x position at which to draw the text relative to the text screen entity
		drawData[i][POSX] = math.ceil(-textSize[i][1] / 2)
		-- The y position at which to draw the text relative to the text screen entity
		drawData[i][POSY] = math.ceil(-(totalHeight / 2) + currentHeight)
		-- Calculate the cam.Start3D2D size based on the size of the font
		drawData[i][CAMSIZE] = (0.25 * drawData[i][SIZE]) / 100
		-- Use the CAMSIZE to "scale" the POSY
		drawData[i][POSY] = (0.25 / drawData[i][CAMSIZE] * drawData[i][POSY])
		-- Highest line to lowest, so that everything is central
		currentHeight = currentHeight + textSize[i][2]
	end

	-- Cache the number of lines/length
	drawData[LEN] = #drawData
	-- Add the new data to our text screen list
	screenInfo[ent] = drawData

	-- Calculate the render bounds
	local x = maxWidth / widthBoundsDivider
	local y = currentHeight / heightBoundsDivider + 13 -- Text is above the centre

	-- Setup the render bounds
	ent:SetRenderBounds(Vector(-x, -y, -1.75), Vector(x, y, 1.75))
end

net.Receive("textscreens_update", function(len)
	local ent = net.ReadEntity()

	if IsValid(ent) and ent:GetClass() == "sammyservers_textscreen" then

		local t = net.ReadTable()

		ent.lines = t -- Incase an addon or something wants to read the information.

		AddDrawingInfo(ent, t)
	end
end)

-- Auto refresh
if IsValid(LocalPlayer()) then
	local screens = ents.FindByClass("sammyservers_textscreen")
	for k, v in ipairs(screens) do
		if screenInfo[v] == nil and v.lines ~= nil then
			AddDrawingInfo(v, v.lines)
		end
	end
end

--PATH lua/entities/sent_bactagrenade/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Impulse Grenade"
ENT.Author = "randomscripter"
ENT.Contact = "..."
ENT.Purpose = "..."
ENT.Instructions = "you shouldnt be reading this" 

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

function ENT:SetupModel()

	self.Entity:SetModel( "models/items/grenadeAmmo.mdl" )

end
--PATH lua/entities/sent_vj_fireplace.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/entities/sf_rock/shared.lua:
return gluapack()()
--PATH lua/entities/shuffle_shield.lua:
AddCSLuaFile()

ENT.PrintName		= 'Shuffle Shield'
ENT.Base			= 'base_gmodentity'
ENT.Type			= 'anim'
ENT.Model			= 'models/hunter/misc/sphere2x2.mdl'
ENT.RenderGroup		= RENDERGROUP_TRANSLUCENT
ENT.Radius			= 48									-- Sphere radius, 48 is default (Do not change this value!)
ENT.DamageCapacity	= 500									-- The amount of damage gets absorbed
ENT.RechargeTime	= 150									-- Recharge time, in seconds
ENT.DamageEffect	= false									-- Emit lightup effect on the sphere when is damaged
ENT.Spawnable		= false


local wepoffset = Vector(0,0,36)




function ENT:SetupDataTables()
	self:NetworkVar('Entity',0,'ShieldOwner')
	self:NetworkVar('Bool',0,'Active')
	self:NetworkVar('Bool',1,'Damaged')
	self:NetworkVar('Int',0,'ActiveOffset')
end




if SERVER then

	function ENT:Initialize(owner)
		if !IsValid(owner) then return end
		local owwep = owner:GetWeapon('weapon_shield_activator')
		if !IsValid(owwep) then return end
		self:SetModel(self.Model)
		--self:PhysicsInitSphere(self.Radius,'no_decal')
		--self:PhysicsInit(SOLID_NONE)
		--self:SetModelScale(self.Radius/48)
		self:SetMoveType(MOVETYPE_NONE)
		self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
		self:PhysWake()
		self:Activate()
		self:AddEffects(EF_NOSHADOW)
		self:SetShieldOwner(owner)
		owner:SetNWEntity('CShield',self)
		self:SetOwner(owner)
		self:SetPos(owner:GetPos()+wepoffset)
		self:SetParent(owwep)
		self:SetMaxHealth(self.DamageCapacity)
		self:SetHealth(self.DamageCapacity)
		self.SoundLoop = CreateSound(self,'ambient/machines/combine_shield_loop3.wav')
		self.SoundLoop:SetSoundLevel(60)
		self:ToggleShield(true)
	end

	function ENT:ToggleShield(bool)
		if bool and self:GetDamaged() then return end
		self:SetActive(bool)
		self:SetActiveOffset(bool and 0 or CurTime()+self.RechargeTime)
		self:SetNoDraw(!bool)
		self:SetSolid(bool and SOLID_BSP or SOLID_NONE)
		local owner = self:GetShieldOwner()
		if IsValid(owner) then
			--owner:SetNWEntity('CShield',bool and self or NULL)
			if bool then
				owner:ScreenFade(SCREENFADE.IN,Color(255,255,255,32),0.4,0)
			end
		end
		if bool then
			self.SoundLoop:PlayEx(0.32,64)
			self:EmitSound('ambient/machines/thumper_hit.wav',60,64,.64,CHAN_ITEM)
		else
			self.SoundLoop:Stop()
			self:EmitSound('ambient/machines/thumper_shutdown1.wav',60,100,.64,CHAN_ITEM)
		end
	end

	function ENT:OnTakeDamage(dmg)
		if !self:GetActive() then return end
		self:SetHealth(self:Health()-dmg:GetDamage())
		if self:Health() <= 0 then
			self:SetDamaged(true)
			self:ToggleShield(false)
			return
		end
		local ed = EffectData()
		ed:SetOrigin(dmg:GetDamagePosition())
		ed:SetNormal((dmg:GetDamagePosition()-self:GetPos()):GetNormalized())
		ed:SetRadius(1)
		util.Effect('cball_bounce',ed)
		util.Effect('AR2Explosion',ed)
		self:EmitSound(('ambient/energy/weld%s.wav'):format(math.random(1,2)),75,math.random(144,192),.64,CHAN_ITEM)
	end

	function ENT:Think()
		if self:Health() <= 0 and !self:GetActive() and self:GetActiveOffset() <= CurTime() then
			self:SetHealth(self.DamageCapacity)
			self:SetDamaged(false)
			self:ToggleShield(true)
		end
	end

end




if CLIENT then

	local rendmat = Material('models/props_combine/stasisshield_sheet')
	local startalpha = 16

	function ENT:DrawTranslucent()
		if !self:GetActive() then return end
		local owner = self:GetShieldOwner()
		if owner == LocalPlayer() and !LocalPlayer():ShouldDrawLocalPlayer() then return end
		local rendcol = HSVToColor(180+5*math.sin(SysTime()*4),1,1)
		rendcol.a = startalpha+16*(math.sin(SysTime()*4)+1)/2
		render.SetColorMaterial()
		render.DrawSphere(owner:GetPos()+wepoffset,self.Radius,16,16,rendcol)
		render.SetMaterial(rendmat)
		render.OverrideBlend(true,2,4,BLENDFUNC_ADD)
		render.DrawSphere(owner:GetPos()+wepoffset,self.Radius,16,16,rendcol)
		render.OverrideBlend(false,2,4,BLENDFUNC_ADD)
	end

end
--PATH gamemodes/starwarsrp/entities/entities/spawned_shipment/cl_init.lua:
include("shared.lua")

local matBallGlow = Material("models/props_combine/tpballglow")
function ENT:Draw()
    self.height = self.height or 0
    self.colr = self.colr or 1
    self.colg = self.colg or 0
    self.StartTime = self.StartTime or CurTime()

    if GAMEMODE.Config.shipmentspawntime > 0 and self.height < self:OBBMaxs().z then
        self:drawSpawning()
    else
        self:DrawModel()
    end

    self:drawFloatingGun()
    self:drawInfo()
end

net.Receive("DarkRP_shipmentSpawn", function()
    local ent = net.ReadEntity()
    if not IsValid(ent) or not ent.IsSpawnedShipment then return end

    ent.height = 0
    ent.StartTime = CurTime()
end)

function ENT:drawSpawning()
    render.MaterialOverride(matBallGlow)

    render.SetColorModulation(self.colr, self.colg, 0)

    self:DrawModel()

    render.MaterialOverride()
    self.colr = 1 - ((CurTime() - self.StartTime) / GAMEMODE.Config.shipmentspawntime)
    self.colg = (CurTime() - self.StartTime) / GAMEMODE.Config.shipmentspawntime

    render.SetColorModulation(1, 1, 1)

    render.MaterialOverride()

    local normal = - self:GetAngles():Up()
    local pos = self:LocalToWorld(Vector(0, 0, self:OBBMins().z + self.height))
    local distance = normal:Dot(pos)
    self.height = self:OBBMaxs().z * ((CurTime() - self.StartTime) / GAMEMODE.Config.shipmentspawntime)
    render.EnableClipping(true)
    render.PushCustomClipPlane(normal, distance)

    self:DrawModel()

    render.PopCustomClipPlane()
end

function ENT:drawFloatingGun()
    local contents = CustomShipments[self:Getcontents() or ""]
    if not contents or not IsValid(self:GetgunModel()) then return end
    self:GetgunModel():SetNoDraw(true)

    local pos = self:GetPos()
    local ang = self:GetAngles()

    -- Position the gun
    local gunPos = self:GetAngles():Up() * 40 + ang:Up() * (math.sin(CurTime() * 3) * 8)
    self:GetgunModel():SetPos(pos + gunPos)


    -- Make it dance
    ang:RotateAroundAxis(ang:Up(), (CurTime() * 180) % 360)
    self:GetgunModel():SetAngles(ang)

    -- Draw the model
    if self:Getgunspawn() < CurTime() - 2 then
        self:GetgunModel():DrawModel()
        return
    elseif self:Getgunspawn() < CurTime() then -- Not when a gun just spawned
        return
    end

    -- Draw the spawning effect
    local delta = self:Getgunspawn() - CurTime()
    local min, max = self:GetgunModel():OBBMins(), self:GetgunModel():OBBMaxs()
    min, max = self:GetgunModel():LocalToWorld(min), self:GetgunModel():LocalToWorld(max)

    -- Draw the ghosted weapon
    render.MaterialOverride(matBallGlow)
    render.SetColorModulation(1 - delta, delta, 0) -- From red to green
    self:GetgunModel():DrawModel()
    render.MaterialOverride()
    render.SetColorModulation(1, 1, 1)

    -- Draw the cut-off weapon
    render.EnableClipping(true)
    -- The clipping plane only draws objects that face the plane
    local normal = -self:GetgunModel():GetAngles():Forward()
    local cutPosition = LerpVector(delta, max, min) -- Where it cuts
    local cutDistance = normal:Dot(cutPosition) -- Project the vector onto the normal to get the shortest distance between the plane and origin

    -- Activate the plane
    render.PushCustomClipPlane(normal, cutDistance);
    -- Draw the partial model
    self:GetgunModel():DrawModel()
    -- Remove the plane
    render.PopCustomClipPlane()

    render.EnableClipping(false)
end

local color_red = Color(140, 0, 0, 100)
local color_white = color_white

function ENT:drawInfo()
    local Pos = self:GetPos()
    local Ang = self:GetAngles()

    local content = self:Getcontents() or ""
    local contents = CustomShipments[content]
    if not contents then return end
    contents = contents.name

    surface.SetFont("HUDNumber5")
    local text = DarkRP.getPhrase("contents")
    local TextWidth = surface.GetTextSize(text)
    local TextWidth2 = surface.GetTextSize(contents)

    cam.Start3D2D(Pos + Ang:Up() * 25, Ang, 0.2)
        draw.WordBox(2, -TextWidth * 0.5 + 5, -30, text, "HUDNumber5", color_red, color_white)
        draw.WordBox(2, -TextWidth2 * 0.5 + 5, 18, contents, "HUDNumber5", color_red, color_white)
    cam.End3D2D()

    Ang:RotateAroundAxis(Ang:Forward(), 90)

    text = DarkRP.getPhrase("amount")
    TextWidth = surface.GetTextSize(text)
    TextWidth2 = surface.GetTextSize(self:Getcount())

    cam.Start3D2D(Pos + Ang:Up() * 17, Ang, 0.14)
        draw.WordBox(2, -TextWidth * 0.5 + 5, -150, text, "HUDNumber5", color_red, color_white)
        draw.WordBox(2, -TextWidth2 * 0.5 + 0, -102, self:Getcount(), "HUDNumber5", color_red, color_white)
    cam.End3D2D()
end

--[[---------------------------------------------------------------------------
Create a shipment from a spawned_weapon
---------------------------------------------------------------------------]]
properties.Add("splitShipment",
{
    MenuLabel   =   DarkRP.getPhrase("splitshipment"),
    Order       =   2004,
    MenuIcon    =   "icon16/arrow_divide.png",

    Filter      =   function(self, ent, ply)
                        if not IsValid(ent) then return false end
                        return ent.IsSpawnedShipment
                    end,

    Action      =   function(self, ent)
                        if not IsValid(ent) then return end
                        RunConsoleCommand("darkrp", "splitshipment", ent:EntIndex())
                    end
})

--PATH gamemodes/starwarsrp/entities/entities/spawned_weapon/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Spawned Weapon"
ENT.Author = "Rickster"
ENT.Spawnable = false
ENT.IsSpawnedWeapon = true

function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "amount")
    self:NetworkVar("String", 0, "WeaponClass")
end

--PATH addons/[miecze] moce i hilty/lua/entities/star_metor/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Meteor"
ENT.Author = ""
ENT.Contact = ""
ENT.Spawnable = false

--PATH lua/entities/tfa_csgo_fire_2/shared.lua:
return gluapack()()
--PATH lua/entities/tfa_exp_timed.lua:
AddCSLuaFile()

ENT.Base = "tfa_exp_base"
ENT.PrintName = "Timed Explosive"

ENT.BounceSound = Sound("HEGrenade.Bounce")

function ENT:PhysicsCollide(data, phys)
	if data.Speed > 60 then
		if self.BounceSound then
			self:EmitSoundNet(self.BounceSound)
		end

		local impulse = (data.OurOldVelocity - 2 * data.OurOldVelocity:Dot(data.HitNormal) * data.HitNormal) * 0.25
		phys:ApplyForceCenter(impulse)
	end
end
--PATH lua/entities/tfbow_arrow/cl_init.lua:
include("shared.lua")
local cv_ht = GetConVar("host_timescale")

function ENT:Draw()
	local ang, tmpang
	tmpang = self:GetAngles()
	ang = tmpang

	if not self.roll then
		self.roll = 0
	end

	local phobj = self:GetPhysicsObject()

	if IsValid(phobj) then
		self.roll = self.roll + phobj:GetVelocity():Length() / 3600 * cv_ht:GetFloat()
	end

	ang:RotateAroundAxis(ang:Forward(), self.roll)
	self:SetAngles(ang)
	self:DrawModel() -- Draw the model.
	self:SetAngles(tmpang)
end

--PATH lua/entities/tfbow_arrow_stuck/shared.lua:
return gluapack()()
--PATH lua/entities/tfbow_arrow_stuck_clientside/shared.lua:
return gluapack()()
--PATH lua/entities/tie_advanced.lua:
return gluapack()()
--PATH lua/entities/tie_fighter.lua:

ENT.RenderGroup = RENDERGROUP_OPAQUE
ENT.Base = "fighter_base"
ENT.Type = "vehicle"

ENT.PrintName = "TIE Fighter"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Empire"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.EntModel = "models/tie2/tie2.mdl"
ENT.Vehicle = "Tie"
ENT.StartHealth = 3000;
ENT.Allegiance = "Empire";
list.Set("SWVehicles", ENT.PrintName, ENT);

if SERVER then

ENT.FireSound = Sound("weapons/tie_shoot.wav");
ENT.NextUse = {Wings = CurTime(),Use = CurTime(),Fire = CurTime(),Torpedos = CurTime()};


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("tie_fighter");
	e:SetPos(tr.HitPos + Vector(0,0,10));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()


	self:SetNWInt("Health",self.StartHealth);
	
	self.WeaponLocations = {
		Right = self:GetPos()+self:GetForward()*150+self:GetUp()*137+self:GetRight()*-6,
		Left = self:GetPos()+self:GetForward()*150+self:GetUp()*137+self:GetRight()*-24,
	}
	self.WeaponsTable = {};
	self.BoostSpeed = 2500;
	self.ForwardSpeed = 1500;
	self.UpSpeed = 500;
	self.AccelSpeed = 9;
	self.CanBack = true;
	
	self.CanShoot = true;
	self.CanStrafe = true;
	self.CanRoll = false;
	self.ExitModifier = {x=0,y=160,z=40};
	self.HasLookaround = true;
	self.Cooldown = 2;
	self.Overheat = 0;
	self.Overheated = false;
	self.FireDelay = 0.2;
	self.Bullet = CreateBulletStructure(65,"green");
	self.NextUse.Torpedos = CurTime();
	

	self.BaseClass.Initialize(self);
end

function ENT:IonTorpedos()

	if(self.NextUse.Torpedos < CurTime()) then
		local pos = self:GetPos()+self:GetForward()*150+self:GetUp()*137+self:GetRight()*-16
		local e = self:FindTarget();
		if(e == self) then
			e = NULL;
		end
		self:FireTorpedo(pos,e,1500,300,Color(255,255,255,255),15,true);
		self.NextUse.Torpedos = CurTime()+30;
		self:SetNWInt("FireBlast",self.NextUse.Torpedos)
	end
end

function ENT:Think()
	

	if(self.Inflight) then
		if(IsValid(self.Pilot)) then
			if(self.Pilot:KeyDown(IN_ATTACK2)) then
				self:IonTorpedos();
			end
		end
		
	end
	self.BaseClass.Think(self);
end
end

if CLIENT then

	function ENT:Draw() self:DrawModel() end
	
	ENT.EnginePos = {}
	ENT.Sounds={
		//Engine=Sound("ambient/atmosphere/ambience_base.wav"),
		Engine=Sound("vehicles/tie/tie_fly3.wav"),
	}
    
	ENT.CanFPV = true;
	ENT.ViewDistance = 700;
    ENT.ViewHeight = 300;
    ENT.FPVPos = Vector(30.6,15,180);

	function TieReticle()
		
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingTie");
		local self = p:GetNWEntity("Tie");
		if(Flying and IsValid(self)) then

			SW_WeaponReticles(self);
			SW_HUD_DrawOverheating(self);
			SW_HUD_DrawHull(3000);
			
			local pos = self:GetPos()+self:GetUp()*186+self:GetForward()*45+self:GetRight()*-15;
			local x,y = SW_XYIn3D(pos);
			
			SW_HUD_Compass(self,x,y);
			
			
			x = ScrW()/4*1.35;
			y = ScrH()/4*3.6;
			
			SW_HUD_DrawSpeedometer();
			SW_BlastIcon(self,30)
		end
	end
	hook.Add("HUDPaint", "TieReticle", TieReticle)

end
--PATH lua/entities/trace2/shared.lua:
return gluapack()()
--PATH lua/entities/trace2/shared.lua:
ENT.Type = "anim"

function ENT:SetEndPos( endpos )

	self.Entity:SetNetworkedVector( 0, endpos )	
	self.Entity:SetCollisionBoundsWS( self.Entity:GetPos(), endpos, Vector() * 0.25 )
	
end

function ENT:GetEndPos()
	return self.Entity:GetNetworkedVector( 0 )
end

--PATH lua/entities/training_orb/shared.lua:
return gluapack()()
--PATH lua/entities/turbolaser2/shared.lua:
return gluapack()()
--PATH lua/entities/turbolaserspawner/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
end

function ENT:Think()
end

function ENT:OnRemove()
end

--PATH lua/entities/tx-ex/cl_init.lua:
return gluapack()()
--PATH lua/entities/unity_smoke.lua:
return gluapack()()
--PATH lua/entities/unitys-lvs-tx-2112/cl_lights.lua:
ENT.LightMaterial = Material("effects/lvs/laat_spotlight")
ENT.GlowMaterial = Material("sprites/light_glow02_add")

function ENT:OnRemoved()
    self:RemoveLight()
end

function ENT:RemoveLight()
    if IsValid(self.projector_L) then
        self.projector_L:Remove()
        self.projector_L = nil
    end

    if IsValid(self.projector_R) then
        self.projector_R:Remove()
        self.projector_R = nil
    end
end

function ENT:PostDrawTranslucent()
    local HP = self:GetHP()
    local MaxHP = self:GetMaxHP()

    if not self:GetLightsActive() or HP <= MaxHP * 0.5 then
        self:RemoveLight()

        return
    end

    if not IsValid(self.projector_L) then
        local thelamp = ProjectedTexture()
        thelamp:SetBrightness(10)
        thelamp:SetTexture("effects/flashlight/soft")
        thelamp:SetColor(Color(255,255,255))
        thelamp:SetEnableShadows(false)
        thelamp:SetFarZ(5000)
        thelamp:SetNearZ(75)
        thelamp:SetFOV(40)
        self.projector_L = thelamp
    end

    if not IsValid(self.projector_R) then
        local thelamp = ProjectedTexture()
        thelamp:SetBrightness(10)
        thelamp:SetTexture("effects/flashlight/soft")
        thelamp:SetColor(Color(255,255,255))
        thelamp:SetEnableShadows(false)
        thelamp:SetFarZ(5000)
        thelamp:SetNearZ(75)
        thelamp:SetFOV(40)
        self.projector_R = thelamp
    end


    local StartPos = self:LocalToWorld(Vector(144,-60,67))
    local Dir = self:GetAngles():Forward()

    render.SetMaterial(self.GlowMaterial)
    render.DrawSprite(StartPos + Dir * 20, 100, 100, Color(255, 255, 255, 255))

    render.SetMaterial(self.LightMaterial)
    render.DrawBeam(StartPos - Dir * 10,  StartPos + Dir * 1500, 80, 0, 0.99, Color(255, 255, 255, 10))

    if IsValid(self.projector_L) then
        self.projector_L:SetPos(StartPos)
        self.projector_L:SetAngles(Dir:Angle())
        self.projector_L:Update()
    end

    StartPos = self:LocalToWorld(Vector(144,60,67))
    Dir = self:GetAngles():Forward()

    render.SetMaterial(self.GlowMaterial)
    render.DrawSprite(StartPos + Dir * 20, 100, 100, Color(255, 255, 255, 255))

    render.SetMaterial(self.LightMaterial)
    render.DrawBeam(StartPos - Dir * 10,  StartPos + Dir * 1500, 80, 0, 0.99, Color(255, 255, 255, 10))

    if IsValid(self.projector_R) then
        self.projector_R:SetPos(StartPos)
        self.projector_R:SetAngles(Dir:Angle())
        self.projector_R:Update()
    end
end

--PATH lua/entities/vox_e60r_rocket/cl_init.lua:
 include('shared.lua')     
 //[[---------------------------------------------------------     
 //Name: Draw     Purpose: Draw the model in-game.     
 //Remember, the things you render first will be underneath!  
 //-------------------------------------------------------]]  
 function ENT:Draw()      
 // self.BaseClass.Draw(self)  
 -- We want to override rendering, so don't call baseclass.                                   
 // Use this when you need to add to the rendering.        
 self.Entity:DrawModel()       // Draw the model.   
 end
 
   function ENT:Initialize()
	pos = self:GetPos()
	self.emitter = ParticleEmitter( pos )
 end
 
 function ENT:Think()
	
	pos = self:GetPos()
		for i=0, (10) do
			local particle = self.emitter:Add( "particle/smokesprites_000"..math.random(1,9), pos + (self:GetForward() * -100 * i))
			if (particle) then
				particle:SetVelocity((self:GetForward() * -2000) )
				particle:SetDieTime( math.Rand( 1.5, 3 ) )
				particle:SetStartAlpha( math.Rand( 5, 8 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand( 40, 50 ) )
				particle:SetEndSize( math.Rand( 130, 150 ) )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-1, 1) )
				particle:SetColor( 200 , 200 , 200 ) 
 				particle:SetAirResistance( 200 ) 
 				particle:SetGravity( Vector( 100, 0, 0 ) ) 	
			end
		
		end
end

--PATH lua/effects/arc9_tracer.lua:
return gluapack()()
--PATH lua/effects/astw2_muzzleflash_swrc_tran_shotgun/init.lua:
return gluapack()()
--PATH lua/effects/astw2_swrc_conc_rifle_explosion/init.lua:
return gluapack()()
--PATH lua/effects/astw2_swrc_dc17aa_explosion/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 85
            light.g = 155
            light.b = 200
            light.Brightness = 8
            light.Decay = 10
            light.Size = 512
            light.DieTime = CurTime() + 0.3
        end
    local particle = emitter:Add("effects/swrc/explosion", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.7 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(50,75) )
    particle:SetEndSize( math.Rand(200,350) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(-3,3) )
    particle:SetColor( 255, 255, 255 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )

    for i = 0,5 do
        particle = emitter:Add( "effects/swrc/DirtCloud_V2" , self.Origin )

        particle:SetVelocity( 750 * VectorRand() )
        particle:SetDieTime( math.Rand(0.5, 1.5) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(100,200) )
        particle:SetEndSize( math.Rand(250,300) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 155,155,155 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( true )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
    end

    particle = emitter:Add( "effects/swrc/p_shockwave", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.25, 0.3) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(300,375) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 200,255,100 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/atrt_flamethrower_flame/init.lua:
--Main function
local FlameMat = {}
FlameMat[1] = "effects/muzzleflash2"
FlameMat[2] = "effects/muzzleflash3"

function EFFECT:Init(data)
	local StartPos = data:GetStart()
	local HitPos = data:GetOrigin()

	if (not IsValid(data:GetEntity())) or (not StartPos) or (not HitPos) then return end

	local FlameEmitter = ParticleEmitter(StartPos)
	for i = 0, 8 do
		if not FlameEmitter then return end
		local FlameParticle = FlameEmitter:Add(FlameMat[math.random(1, 2)], StartPos)
		if FlameParticle then
			FlameParticle:SetVelocity(((HitPos - StartPos):GetNormal() * math.random(1720, 1820)) + (VectorRand() * math.random(142, 172)))
			FlameParticle:SetLifeTime(0)
			FlameParticle:SetDieTime(0.52)
			FlameParticle:SetStartAlpha(math.random(92, 132))
			FlameParticle:SetEndAlpha(0)
			FlameParticle:SetStartSize(math.random(4, 6))
			FlameParticle:SetEndSize(math.random(32, 52))
			FlameParticle:SetRoll(math.Rand(-360, 360))
			FlameParticle:SetRollDelta(math.Rand(-7.2, 7.2))
			FlameParticle:SetAirResistance(math.random(128, 256))
			FlameParticle:SetCollide(true)
			FlameParticle:SetGravity(Vector(0, 0, 64))
		end
	end

	FlameEmitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/cod2019_725_smoke/init.lua:
return gluapack()()
--PATH lua/effects/cod2019_grenade_explosion.lua:
AddCSLuaFile()

game.AddParticles("particles/fas_explosions.pcf")
PrecacheParticleSystem("explosion_grenade")

function EFFECT:GetImpactPoint(data)
    return data:GetOrigin()
end

function EFFECT:GetImpactStart(data)
    return data:GetStart()
end

function EFFECT:GetImpactNormal(data)
    return (self:GetImpactPoint(data) - self:GetImpactStart(data)):GetNormalized()
end

function EFFECT:Init(data)
    local tr = util.TraceLine({
		start = self:GetImpactStart(data),
		endpos = self:GetImpactStart(data) + self:GetImpactNormal(data) * 10,
        filter = {data:GetEntity()}
	})

    local dlight = DynamicLight(data:GetEntity():EntIndex())
    
    if (dlight) then
        dlight.pos = tr.HitPos
        dlight.r = 255
        dlight.g = 75
        dlight.b = 0
        dlight.brightness = 5
        dlight.Decay = 500
        dlight.Size = 512
        dlight.DieTime = CurTime() + 6
    end

    if (bit.band(util.PointContents(tr.HitPos), CONTENTS_WATER) == CONTENTS_WATER) then
        ed = EffectData()
        ed:SetOrigin(self:GetPos())
        util.Effect("WaterSurfaceExplosion", ed)
    else
        ParticleEffect("explosion_grenade", tr.HitPos, (tr.HitNormal * -1):Angle() + Angle(270, 0, 0))
    end
    --util.Decal("Scorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal, data:GetEntity())
    
    local shakeRadius = data:GetRadius() * data:GetRadius()
    local startDist = EyePos():DistToSqr(tr.HitPos)
    startDist = startDist - shakeRadius
    local shakeDelta = 1 - math.min(startDist / shakeRadius, 1)
    util.ScreenShake(tr.HitPos, 10 * shakeDelta, 40, 1, data:GetRadius())

	local ed = EffectData()
	ed:SetScale(5000)
	ed:SetOrigin(tr.HitPos)
	ed:SetRadius(data:GetRadius())
	ed:SetMagnitude(1000)
	ed:SetEntity(data:GetEntity())
	util.Effect("ShakeRopes", ed)

    self:SetNoDraw(true)
end

function EFFECT:Think()
    return false
end
--PATH lua/effects/cod2019_muzzle_he/init.lua:
return gluapack()()
--PATH lua/effects/cod2019_muzzle_he/init.lua:
function EFFECT:Init(data, weapon, dmgInfo, tr)
    local pos = data:GetOrigin()
    local ang = data:GetAngles()
    ParticleEffect("muzzleflash_slug", pos, ang, nil)
    sound.Play("COD2019.HE_ExplosiveHit", pos, SNDLVL_75dB, 100, 1)
    local dynlight = DynamicLight(0)
    dynlight.Pos = pos
    dynlight.Size = 64
    dynlight.Decay = 20
    dynlight.R = 255
    dynlight.G = 150
    dynlight.B = 0
    dynlight.Brightness = 5
    dynlight.DieTime = CurTime() + 0.1
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/corruptor_tracer.lua:
return gluapack()()
--PATH lua/effects/csgo_muzzle_para_negev/init.lua:
return gluapack()()
--PATH lua/effects/csgo_muzzle_pistol/init.lua:
local ang

EFFECT.WeaponEnt = nil

local lighconvar = GetConVar("arc9_muzzle_light")
local otherconvar = GetConVar("arc9_muzzle_others")

EFFECT.ParticleName = "weapon_muzzle_flash_pistol"

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	
    if !otherconvar:GetBool() and LocalPlayer() != self.WeaponEnt:GetOwner() then
        self:Remove()
        return
    end	

	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if not self.WeaponEnt:IsFirstPerson() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	
	if !self.WeaponEnt:GetProcessedValue("Silencer") and !self.WeaponEnt:GetProcessedValue("NoFlash", true) and lighconvar:GetBool() then
		local dlight = DynamicLight(self.WeaponEnt:EntIndex())
		if (dlight) then
			dlight.pos = self.Position + self.Angle:Up() * 3 + self.Angle:Right() * -2
			dlight.r = 255
			dlight.g = 192
			dlight.b = 64
			dlight.brightness = 5
			dlight.Size = math.Rand(32, 64)
			dlight.Decay = math.Rand(32, 64) / 0.05
			dlight.DieTime = CurTime() + 0.05
		end
	end

	local pcf = CreateParticleSystem(self.WeaponEnt, self.ParticleName, PATTACH_POINT_FOLLOW, self.Attachment)
	if IsValid(pcf) then
		pcf:StartEmission()
	end
	timer.Simple(3.0, function()
		if IsValid(pcf) then
			pcf:StopEmissionAndDestroyImmediately()
		end
	end)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/csgo_muzzle_taser/init.lua:
local ang

EFFECT.WeaponEnt = nil

local lighconvar = GetConVar("arc9_muzzle_light")
local otherconvar = GetConVar("arc9_muzzle_others")

EFFECT.ParticleName = "weapon_muzzle_flash_taser"

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	
    if !otherconvar:GetBool() and LocalPlayer() != self.WeaponEnt:GetOwner() then
        self:Remove()
        return
    end	

	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if not self.WeaponEnt:IsFirstPerson() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	
	if !self.WeaponEnt:GetProcessedValue("Silencer") and !self.WeaponEnt:GetProcessedValue("NoFlash", true) and lighconvar:GetBool() then
		local dlight = DynamicLight(self.WeaponEnt:EntIndex())
		if (dlight) then
			dlight.pos = self.Position + self.Angle:Up() * 3 + self.Angle:Right() * -2
			dlight.r = 255
			dlight.g = 192
			dlight.b = 64
			dlight.brightness = 5
			dlight.Size = math.Rand(32, 64)
			dlight.Decay = math.Rand(32, 64) / 0.05
			dlight.DieTime = CurTime() + 0.05
		end
	end

	local pcf = CreateParticleSystem(self.WeaponEnt, self.ParticleName, PATTACH_POINT_FOLLOW, self.Attachment)
	if IsValid(pcf) then
		pcf:StartEmission()
	end
	timer.Simple(3.0, function()
		if IsValid(pcf) then
			pcf:StopEmissionAndDestroyImmediately()
		end
	end)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/csgo_muzzle_trail/init.lua:
local ang

EFFECT.ParticleName = "weapon_muzzle_trail"

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if not self.WeaponEnt:IsFirstPerson() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()

	local pcf = CreateParticleSystem(self.WeaponEnt, self.ParticleName, PATTACH_POINT_FOLLOW, self.Attachment)
	if IsValid(pcf) then
		pcf:StartEmission()
	end
	timer.Simple(3.0, function()
		if IsValid(pcf) then
			pcf:StopEmissionAndDestroyImmediately()
		end
	end)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/effect_astw2_swrc_elite_laser_beam/init.lua:
return gluapack()()
--PATH lua/effects/effect_astw2_swrc_elite_laser_beam_impact/init.lua:
return gluapack()()
--PATH lua/effects/effect_astw2_swrc_impact/init.lua:
return gluapack()()
--PATH lua/effects/effect_astw2_swrc_laser_yellow/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 32;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/swrc/Blaster_Bolt_Orange" );
local MaterialFront			= Material( "effects/swrc/a_FLASHORANGE" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 5, 0, 1, color_white );
	
end

--PATH lua/effects/effect_bactanade/init.lua:
//Main function
function EFFECT:Init(data)

	//Create particle emitter
	local emitter = ParticleEmitter(data:GetOrigin())

		//Amount of particles to create
		for i=0, 64 do

			local Pos = (data:GetOrigin() + Vector( math.Rand(-32,32), math.Rand(-32,32), math.Rand(-32,32) ) + Vector(0,0,42))

			local particle = emitter:Add( "particle/particle_smokegrenade", Pos )
			if (particle) then

				particle:SetVelocity(VectorRand() * math.Rand(1920,2142))

				particle:SetLifeTime(0)
				particle:SetDieTime(math.Rand(6,8))

				local rand = math.random(242,255)
				if math.random(1,12) == 12 then rand = math.random(210,232) end
				particle:SetColor(0,150,255)

				particle:SetStartAlpha(math.Rand(142,162)) //Old values, 142, 162
				particle:SetEndAlpha(0)

				local Size = math.Rand(112,132)
				particle:SetStartSize(Size)
				particle:SetEndSize(Size)

				particle:SetRoll(math.Rand(-360, 360))
				particle:SetRollDelta(math.Rand(-0.7, 0.7))

				particle:SetAirResistance(math.Rand(520,620))

				particle:SetGravity( Vector(0, 0, math.Rand(-32, -64)) )

				particle:SetCollide(true)
				particle:SetBounce(0.42)

				particle:SetLighting(false)
				
				
				

			end
			local dlight = DynamicLight( LocalPlayer():EntIndex() )
	if ( dlight ) then
		dlight.pos = Pos
		dlight.r = 0
		dlight.g = 255
		dlight.b = 255
		dlight.brightness = 5
		dlight.Decay = 450
		dlight.Size = 256
		dlight.DieTime = CurTime() + 3
	end
			
			local particle = emitter:Add( "sprites/orangecore1", Pos )
			if (particle) then

				particle:SetVelocity(VectorRand() * math.Rand(1920,2142))

				particle:SetLifeTime(0)
				particle:SetDieTime(math.Rand(.3,1))

				local rand = math.random(242,255)
				if math.random(1,12) == 12 then rand = math.random(210,232) end
				particle:SetColor(0,150,255)

				particle:SetStartAlpha(math.Rand(192,255)) //Old values, 142, 162
				particle:SetEndAlpha(0)

				local Size = math.Rand(112,132)
				particle:SetStartSize(Size)
				particle:SetEndSize(Size*.1)

				particle:SetRoll(math.Rand(-360, 360))
				particle:SetRollDelta(math.Rand(-0.21, 0.21))

				particle:SetAirResistance(math.Rand(120,350))

				particle:SetGravity( Vector(0, 0, math.Rand(-32, -64)) )

				particle:SetCollide(true)
				particle:SetBounce(0.42)

				particle:SetLighting(false)
				
				

			end

		end

	//We're done with this emitter
	emitter:Finish()

end

//Kill effect
function EFFECT:Think()
return false
end

//Not used
function EFFECT:Render()
end
--PATH lua/effects/effect_sw_laser_blue/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_green_akimbo/init.lua:
TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 6500
EFFECT.Length				= 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72

local MaterialMain			= Material( "effects/sw_laser_green_main" )
local MaterialFront			= Material( "effects/sw_laser_green_front" )

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		local att = 2 - entity.AnimCycle or data:GetAttachment()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(att)

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--PATH lua/effects/effect_sw_laser_green_old/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_green_old/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_green_main" );
local MaterialFront			= Material( "effects/sw_laser_green_front" );

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--PATH lua/effects/effect_sw_laser_purple/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_red_akimbo/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_red_sniper/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_yellow_old/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 6500
EFFECT.Length				= 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72

local MaterialMain			= Material( "effects/sw_laser_yellow_main" )
local MaterialFront			= Material( "effects/sw_laser_yellow_front" )

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--PATH lua/effects/effect_zeus_muzzleflash/init.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_effects.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_lightning.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_lightning.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

function EFFECT:Init( data )
	self.Ent = data:GetEntity()

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	if IsValid( self.Ent ) then
		local Dir = self.Ent:GetAimVector()
		local StartPos = self.Ent:GetShootPos() - Dir * 25
		local EndPos = StartPos + Dir * 625
		self:SetRenderBoundsWS( StartPos, EndPos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid( self.Ent ) then 
		return false
	end

	return true
end

local BeamMat = Material( "trails/electric" )
local mat = Material( "sprites/light_glow02_add" )

function EFFECT:Render()
	if IsValid( self.Ent ) then

		local boneID = self.Ent:LookupBone( "ValveBiped.Bip01_L_Hand" )

		if boneID then
			local T = CurTime() * 10

			local X = math.cos( T ) * math.cos( T * 10 ) * 4
			local Y = math.sin( T ) * math.cos( T * 10 ) * 4
			local pos, ang = self.Ent:GetBonePosition( boneID )
			local StartPos = pos + ang:Up() * 2 + ang:Forward() * 5 + ang:Right() * 2

			if not self.TargetPos then
				self.TargetPos = self.Ent:GetEyeTrace().HitPos
	
				local dlight = DynamicLight( self.Ent:EntIndex() + math.random(0,99) )
				if dlight then
					dlight.pos = StartPos
					dlight.r = 255
					dlight.g = 255
					dlight.b = 255
					dlight.brightness = 3
					dlight.Decay = 2000
					dlight.Size = 150
					dlight.DieTime = CurTime() + 0.1
				end
			end


			local Dir = ((self.TargetPos - StartPos):Angle() + Angle(X,Y,0)):Forward()
			local EndPos = StartPos + Dir * math.random(600,1000)

			local trace = util.TraceLine( { start = StartPos, endpos = EndPos, filter = self.Ent} )

			if (self.HitFX or 0) < CurTime() then
				self.HitFX = CurTime() + 0.01

				if trace.Hit then
					local effectdata = EffectData()
						effectdata:SetOrigin( trace.HitPos + trace.HitNormal )
						effectdata:SetNormal( -trace.HitNormal )
					util.Effect( "force_lightning_hit", effectdata )

					if math.random(1,3) == 3 then

						local dlight = DynamicLight( self.Ent:EntIndex() + math.random(100,9999) )
						if dlight then
							dlight.pos = trace.HitPos + trace.HitNormal
							dlight.r = 255
							dlight.g = 150
							dlight.b = 255
							dlight.brightness = 3
							dlight.Decay = 2000
							dlight.Size = 100
							dlight.DieTime = CurTime() + 0.01
						end

						self:EmitSound("lscs/force/lightninghit"..math.random(1,3)..".mp3")
					end
				end
			end

			render.SetMaterial( mat )
			render.DrawSprite( StartPos, 64, 64, Color( 0, 50, 255, 255) )
			render.DrawSprite( StartPos, 16, 16, Color( 255, 255, 255, 255) )

			local BeamStart = StartPos
			local BeamPrevious = BeamStart
			local BeamEnd = trace.HitPos
			local BeamSub = BeamEnd - BeamStart
			local BeamDir = BeamSub:GetNormalized()
			local BeamDistance = (BeamSub):Length()
			local SegmentLength = 50

			render.SetMaterial( BeamMat )

			render.DrawBeam( BeamStart, BeamEnd, 18, 0, 1, Color( 255, 255, 255, 255 ) )

			for SegmentStart = 0, BeamDistance, SegmentLength do
				local SegmentEnd = BeamPrevious + (BeamDir:Angle() + Angle(math.Rand(-8,8),math.Rand(-8,8),0)):Forward() * SegmentLength

				local Width = (SegmentStart / BeamDistance)
				if SegmentStart + SegmentLength >= BeamDistance then
					SegmentEnd = BeamEnd
				end

				render.DrawBeam( BeamPrevious, SegmentEnd, 16 * (1 - Width), Width, Width + 0.15, Color( 255, 150 + 155 * Width, 255, 255 ) )

				local BranchEnd1 = SegmentEnd + (BeamDir:Angle() + Angle(math.Rand(-20,20),math.Rand(-20,20),0)):Forward() * SegmentLength * 0.5

				render.DrawBeam( SegmentEnd, BranchEnd1, math.Rand(8,16) * (1 - Width), 0, 0.2, Color( 255, 255, 255, 255 ) )
				render.DrawBeam( BranchEnd1, BranchEnd1 + (BeamDir:Angle() + Angle(math.Rand(-6,6),math.Rand(-6,6),0)):Forward() * SegmentLength * 1.5, math.Rand(4,8) * (1 - Width), 0, 1.5, Color( 255, 255, 255, 255 ) )

				BeamPrevious = SegmentEnd
			end
		end
	end
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_lightningi_hit.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_lightningii_hit.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_lightningii_hit.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

local DecalMat = Material( util.DecalMaterial( "FadingScorch" ) )
function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.mat = Material( "sprites/light_glow02_add" )
	
	self.LifeTime = 0.5
	self.DieTime = CurTime() + self.LifeTime
	self.DieTimeGlow = CurTime() + 0.2

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()
	
	local emitter = ParticleEmitter( Pos, false )

	local trace = util.TraceLine( {
		start = Pos - Dir * 5,
		endpos = Pos + Dir * 5,
	} )

	if trace.Hit and not trace.HitNonWorld then
		util.DecalEx( DecalMat, trace.Entity, trace.HitPos + trace.HitNormal, trace.HitNormal, Color(255,255,255,255), math.Rand(0.4,0.8), math.Rand(0.4,0.8) )
	end

	for i = 0, 3 do
		local particle = emitter:Add( "sprites/rico1", Pos )
		
		local vel = VectorRand() * 100 + Dir * math.Rand(120,140)
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(1,2) )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 1 )
			particle:SetEndSize( 0.5 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 255, 255, 255 )
			particle:SetGravity( Vector(0,0,-600) )
		end
	end

	self.Emitter = emitter
end

function EFFECT:Think()
	if self.DieTime < CurTime() then 
		if self.Emitter then
			self.Emitter:Finish()
		end

		if self.snd then
			self.snd:Stop()
		end

		return false
	end

	return true
end

local Mat = Material("particle/particle_glow_05_addnofog")
function EFFECT:Render()
	local Scale = (self.DieTimeGlow - CurTime()) / 0.2
	if Scale > 0 then
		render.SetMaterial( self.mat )
		render.DrawSprite( self.Pos, 24 * Scale, 24 * Scale, Color( 111, 0, 255, 255) ) -- DETRLECEK RENK
	end
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_lightningiv.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_lightningiv_hit.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

local DecalMat = Material( util.DecalMaterial( "FadingScorch" ) )
function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.mat = Material( "sprites/light_glow02_add" )
	
	self.LifeTime = 0.5
	self.DieTime = CurTime() + self.LifeTime
	self.DieTimeGlow = CurTime() + 0.2

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()
	
	local emitter = ParticleEmitter( Pos, false )

	local trace = util.TraceLine( {
		start = Pos - Dir * 5,
		endpos = Pos + Dir * 5,
	} )

	if trace.Hit and not trace.HitNonWorld then
		util.DecalEx( DecalMat, trace.Entity, trace.HitPos + trace.HitNormal, trace.HitNormal, Color(255,255,255,255), math.Rand(0.4,0.8), math.Rand(0.4,0.8) )
	end

	for i = 0, 3 do
		local particle = emitter:Add( "sprites/rico1", Pos )
		
		local vel = VectorRand() * 100 + Dir * math.Rand(120,140)
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(1,2) )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 1 )
			particle:SetEndSize( 0.5 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 255, 255, 255 )
			particle:SetGravity( Vector(0,0,-600) )
		end
	end

	self.Emitter = emitter
end

function EFFECT:Think()
	if self.DieTime < CurTime() then 
		if self.Emitter then
			self.Emitter:Finish()
		end

		if self.snd then
			self.snd:Stop()
		end

		return false
	end

	return true
end

local Mat = Material("particle/particle_glow_05_addnofog")
function EFFECT:Render()
	local Scale = (self.DieTimeGlow - CurTime()) / 0.2
	if Scale > 0 then
		render.SetMaterial( self.mat )
		render.DrawSprite( self.Pos, 24 * Scale, 24 * Scale, Color( 208, 0, 255, 255) ) -- DETRLECEK RENK
	end
end

--PATH lua/effects/gravrifle_hit.lua:

EFFECT.Mat = Material( "effects/gravrifle_impact" )
EFFECT.Refract = Material( "particle/warp_celest" )

function EFFECT:Init( data )

	local size = 4
	self:SetCollisionBounds( Vector( -size, -size, -size ), Vector( size, size, size ) )

	local Pos = data:GetOrigin() + data:GetNormal() * 2

	self:SetPos( Pos )

	self:SetAngles( data:GetNormal():Angle() + Angle( 0.01, 0.01, 0.01 ) )

	self.Pos = data:GetOrigin()
	self.Normal = data:GetNormal()

	self.Speed = 0.25
	self.Size = size
	self.Alpha = 255

	self.Life = 0.5

end

function EFFECT:Think()

	self.Alpha = self.Alpha - FrameTime() * 255 * 5 * self.Speed
	self.Size = self.Size + FrameTime() * 128 * self.Speed

	if ( self.Alpha < 0 ) then return false end
	return true

end

function EFFECT:Render()

	if ( self.Alpha < 1 ) then return end
	
	render.SetMaterial( self.Refract )
	render.DrawQuadEasy( self:GetPos(), self:GetAngles():Forward(), self.Size * 3, self.Size * 3, Color( 255, 255, 255, self.Alpha * 0.75 ) )

	render.SetMaterial( self.Mat )
	render.DrawQuadEasy( self:GetPos(), self:GetAngles():Forward(), self.Size, self.Size, Color( 255, 255, 255, self.Alpha ) )
	
	local scale = self.Alpha / 255
	
	self.Mat:SetFloat( "$time", scale )
	self.Mat:SetFloat( "$emissiveBlendStrength", 16 * scale * scale )

end

--PATH lua/effects/green_tracer_fx.lua:
return gluapack()()
--PATH lua/effects/lvs_bullet_impact.lua:

EFFECT.SmokeMat = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.DustMat = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local scale = data:GetMagnitude()

	sound.Play( "physics/flesh/flesh_strider_impact_bullet"..math.random(1,3)..".wav", pos, 85, math.random(180,200) + 55 * math.max(1 - scale,0), 0.75 )
	sound.Play( "ambient/materials/rock"..math.random(1,5)..".wav", pos, 75, 180, 1 )

	local emitter = ParticleEmitter( pos, false )

	local VecCol = (render.GetLightColor( pos + dir ) * 0.5 + Vector(0.2,0.18,0.15)) * 255

	local DieTime = math.Rand(0.8,1.6)

	if dir.z > 0.85 then
		for i = 1, 10 do
			for n = 0,6 do
				local particle = emitter:Add( self.DustMat[ math.random(1,#self.DustMat) ] , pos )

				if not particle then continue end

				particle:SetVelocity( (dir * 50 * i + VectorRand() * 25) * scale )
				particle:SetDieTime( (i / 8) * DieTime )
				particle:SetAirResistance( 10 ) 
				particle:SetStartAlpha( 255 )
				particle:SetStartSize( 10 * scale )
				particle:SetEndSize( 20 * i * scale )
				particle:SetRollDelta( math.Rand(-1,1) )
				particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
				particle:SetGravity( Vector(0,0,-600) * scale )
				particle:SetCollide( false )
			end
		end

		for i = 1, 10 do
			local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ] , pos )

			if not particle then continue end

			particle:SetVelocity( (dir * 50 * i + VectorRand() * 40) * scale )
			particle:SetDieTime( (i / 8) * DieTime )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 * scale )
			particle:SetEndSize( 20 * i * scale )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,-600) * scale )
			particle:SetCollide( false )
		end
	end

	for i = 1,12 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ] , pos )
		
		if particle then
			local ang = i * 30
			local X = math.cos( math.rad(ang) )
			local Y = math.sin( math.rad(ang) )

			local Vel = Vector(X,Y,0) * math.Rand(200,1600) + Vector(0,0,50)
			Vel:Rotate( dir:Angle() + Angle(90,0,0) )

			particle:SetVelocity( Vel * scale )
			particle:SetDieTime( DieTime )
			particle:SetAirResistance( 500 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 40 * scale )
			particle:SetEndSize( 200 * scale )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,60) * scale )
			particle:SetCollide( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH lua/effects/lvs_hover_water.lua:

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Ent = data:GetEntity()
	self.Size = data:GetMagnitude()

	if not IsValid( Ent ) then return end

	self.LifeTime = math.Rand(1.5,3)
	self.DieTime = CurTime() + self.LifeTime

	self.Splash = {
		Pos = Pos,
		Mat = Material("effects/splashwake1"),
		RandomAng = math.random(0,360),
	}

	local emitter = Ent:GetParticleEmitter( Ent:GetPos() )

	if emitter and emitter.Add then
		local particle = emitter:Add( "effects/splash4", Pos )
		if not particle then return end

		local Vel = Ent:GetVelocity():Length()

		particle:SetVelocity( Vector(0,0,math.Clamp(Vel / 2,100,250)) )
		particle:SetDieTime( 0.25 + math.min(Vel / 200,0.35) )
		particle:SetAirResistance( 60 ) 
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( self.Size * 0.2 )
		particle:SetEndSize(  self.Size * 2 )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 255,255,255 )
		particle:SetGravity( Vector( 0, 0, -600 ) )
		particle:SetCollide( false )
	end
end


function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	end
	return true
end

function EFFECT:Render()
	if self.Splash and self.LifeTime then
		local Scale = ((self.DieTime - self.LifeTime - CurTime()) / self.LifeTime)
		local S =  self.Size * 5 + (self.Size * 5) * Scale
		local Alpha = 100 + 100 * Scale

		cam.Start3D2D( self.Splash.Pos + Vector(0,0,1), Angle(0,0,0), 1 )
			surface.SetMaterial( self.Splash.Mat )
			surface.SetDrawColor( 255, 255, 255 , Alpha )
			surface.DrawTexturedRectRotated( 0, 0, S , S, self.Splash.RandomAng )
		cam.End3D2D()
	end
end
--PATH lua/effects/lvs_laser_explosion_aat.lua:


EFFECT.HeatWaveMat = Material( "particle/warp1_warp" )
EFFECT.GlowMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	self.Pos = Pos

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime
	self.DieTimeGlow = CurTime() + 0.2

	sound.Play( "LVS.AAT.LASER_EXPLOSION", Pos )
	self:Explosion( Pos )
end

function EFFECT:Explosion( pos )
	local emitter = ParticleEmitter( pos, false )
	
	if not emitter then return end

	for i = 0, 15 do
		local particle = emitter:Add( "sprites/light_glow02_add", pos )
		
		local vel = VectorRand() * 450
		
		if not particle then continue end

		particle:SetVelocity( vel )
		particle:SetAngles( vel:Angle() + Angle(0,90,0) )
		particle:SetDieTime( math.Rand(1,1.6) )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(12,15) )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand(-100,100) )
		particle:SetRollDelta( math.Rand(-100,100) )
		particle:SetColor( 255,0,0 )
		particle:SetGravity( Vector(0,0,-600) )

		particle:SetAirResistance( 0 )
		
		particle:SetCollide( true )
		particle:SetBounce( 0.5 )
	end

	for i = 0, 5 do
		local particle = emitter:Add( "sprites/rico1", pos )
		
		local vel = VectorRand() * 1000
		
		if not particle then continue end

		particle:SetVelocity( vel )
		particle:SetAngles( vel:Angle() + Angle(0,90,0) )
		particle:SetDieTime( math.Rand(0.5,0.8) )
		particle:SetStartAlpha( math.Rand( 200, 255 ) )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(10,20) )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand(-100,100) )
		particle:SetRollDelta( math.Rand(-100,100) )
		particle:SetColor( 255, 0, 0 )
		particle:SetGravity( -vel:GetNormalized() * math.random(1250,1750) )
		particle:SetCollide( true )
		particle:SetBounce( 0.5 )

		particle:SetAirResistance( 200 )
	end

	for i = 0, 20 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )
		
		if not particle then continue end

		particle:SetVelocity( VectorRand(-1,1) * 500 )
		particle:SetDieTime( 0.14 )
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 10 )
		particle:SetEndSize( math.Rand(30,60) )
		particle:SetEndAlpha( 100 )
		particle:SetRoll( math.Rand( -1, 1 ) )
		particle:SetColor( 200,150,150 )
		particle:SetCollide( false )
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = math.max((self.DieTime - self.LifeTime + 0.3 - CurTime()) / 0.3,0)
	render.SetMaterial( self.HeatWaveMat )
	render.DrawSprite( self.Pos, 300 * Scale, 300 * Scale, Color( 255, 255, 255, 255) )

	render.SetMaterial( self.GlowMat )
	render.DrawSprite( self.Pos, 1000 * Scale, 1000 * Scale, Color( 255, 100, 50, 255) )

	local Scale = (self.DieTimeGlow - CurTime()) / 0.2
	if Scale > 0 then
		render.SetMaterial( self.GlowMat )
		render.DrawSprite( self.Pos, 100 * Scale, 100 * Scale, Color( 250, 0, 0, 255) )
		render.DrawSprite( self.Pos, 25 * Scale, 25 * Scale, Color( 255, 255, 255, 255) )
	end

	local Scale = (self.DieTime - self.LifeTime + 0.25 - CurTime()) / 0.25
	local InvScale = 1 - Scale
	if Scale > 0 then
		render.SetColorMaterial()
		render.DrawSphere( self.Pos, -180 * InvScale, 30,30, Color( 255, 0, 0, 255 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, -190 * InvScale, 30,30, Color( 255, 0, 0, 150 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, -200 * InvScale, 30,30, Color( 255, 0, 0, 50 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, 210 * InvScale, 30,30, Color( 255, 0, 0, 50 * (Scale ^ 2) ) )
	end
end

--PATH lua/effects/lvs_laser_red_short.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 300 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 2, endpos + dir * len * 2, 200, 1, 0, Color( 255, 0, 0, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 255, 0, 0, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--PATH lua/effects/lvs_muzzle_colorable.lua:
return gluapack()()
--PATH lua/effects/lvs_physics_dust.lua:
return gluapack()()
--PATH lua/effects/lvs_physics_impact.lua:
return gluapack()()
--PATH lua/effects/m9k_gdcw_cinematicboom/init.lua:

					//Sound,Impact

					// 1        2       3      4      5
					//Dirt, Concrete, Metal, Glass, Flesh

					// 1     2     3      4      5      6      7      8         9
					//Dust, Dirt, Sand, Metal, Smoke, Wood,  Glass, Blood, YellowBlood
local mats={				
	[MAT_ALIENFLESH]		={5,9},
	[MAT_ANTLION]			={5,9},
	[MAT_BLOODYFLESH]		={5,8},
	[45]				={5,8},	// Metrocop heads are a source glitch, they have no enumeration
	[MAT_CLIP]			={3,5},
	[MAT_COMPUTER]			={4,5},
	[MAT_FLESH]			={5,8},
	[MAT_GRATE]			={3,4},
	[MAT_METAL]			={3,4},
	[MAT_PLASTIC]			={2,5},
	[MAT_SLOSH]			={5,5},
	[MAT_VENT]			={3,4},
	[MAT_FOLIAGE]			={1,5},
	[MAT_TILE]			={2,5},
	[MAT_CONCRETE]			={2,1},
	[MAT_DIRT]			={1,2},
	[MAT_SAND]			={1,3},
	[MAT_WOOD]			={2,6},
	[MAT_GLASS]			={4,7},
}

local sounds={
	[1]={"Bullet.Dirt",},
	[2]={"Bullet.Concrete",},
	[3]={"Bullet.Metal",},
	[4]={"Bullet.Glass",},
	[5]={"Bullet.Flesh",},
}

function EFFECT:Init(data)
self.Entity 		= data:GetEntity()		// Entity determines what is creating the dynamic light			//
self.Pos 		= data:GetOrigin()		// Origin determines the global position of the effect			//
self.Scale 		= data:GetScale()		// Scale determines how large the effect is				//
self.Radius 		= data:GetRadius() or 1		// Radius determines what type of effect to create, default is Concrete	//
self.DirVec 		= data:GetNormal()		// Normal determines the direction of impact for the effect		//
self.PenVec 		= data:GetStart()		// PenVec determines the direction of the round for penetrations	//
self.Particles 		= data:GetMagnitude()		// Particles determines how many puffs to make, primarily for "trails"	//
self.Angle 		= self.DirVec:Angle()		// Angle is the angle of impact from Normal				//
self.DebrizzlemyNizzle 	= 10+data:GetScale()		// Debrizzle my Nizzle is how many "trails" to make			//
self.Size 		= 5*self.Scale			// Size is exclusively for the explosion "trails" size			//
self.Emitter 		= ParticleEmitter( self.Pos )	// Emitter must be there so you don't get an error			//
	

			if self.Scale<1.2 then
			sound.Play( "ambient/explosions/explode_" .. math.random(1, 4) .. ".wav", self.Pos, 100, 100 )
			else
			sound.Play( "Explosion.Boom", self.Pos)
			sound.Play( "ambient/explosions/explode_" .. math.random(1, 4) .. ".wav", self.Pos, 100, 100 )
			end


	self.Mat=math.ceil(self.Radius)


 
	if     mats[self.Mat][2]==1 then	self:Dust()	
	elseif mats[self.Mat][2]==2 then	self:Dirt()
	elseif mats[self.Mat][2]==3 then	self:Sand()
	elseif mats[self.Mat][2]==4 then	self:Metal()
	elseif mats[self.Mat][2]==5 then	self:Smoke()
	elseif mats[self.Mat][2]==6 then	self:Wood()
	elseif mats[self.Mat][2]==7 then	self:Glass()
	elseif mats[self.Mat][2]==8 then	self:Blood()
	elseif mats[self.Mat][2]==9 then	self:YellowBlood()
	else 					self:Smoke()
	end

end
 
 function EFFECT:Dust()

		for i=1,5 do 
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*300 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=1, 20*self.Scale do
		local Dust = self.Emitter:Add( "particle/particle_composite", self.Pos )	
		if (Dust) then
		Dust:SetVelocity( self.DirVec * math.random( 100,400)*self.Scale + ((VectorRand():GetNormalized()*300)*self.Scale) )
		Dust:SetDieTime( math.Rand( 2 , 3 ) )
		Dust:SetStartAlpha( 230 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( (50*self.Scale) )
		Dust:SetEndSize( (100*self.Scale) )
		Dust:SetRoll( math.Rand(150, 360) )
		Dust:SetRollDelta( math.Rand(-1, 1) )			
		Dust:SetAirResistance( 150 ) 			 
		Dust:SetGravity( Vector( 0, 0, math.Rand(-100, -400) ) ) 			
		Dust:SetColor( 80,80,80 )
		end
		end

		for i=1, 15*self.Scale do
		local Dust = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Dust) then
		Dust:SetVelocity( self.DirVec * math.random( 100,400)*self.Scale + ((VectorRand():GetNormalized()*400)*self.Scale) )
		Dust:SetDieTime( math.Rand( 1 , 5 )*self.Scale )
		Dust:SetStartAlpha( 50 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( (80*self.Scale) )
		Dust:SetEndSize( (100*self.Scale) )
		Dust:SetRoll( math.Rand(150, 360) )
		Dust:SetRollDelta( math.Rand(-1, 1) )			
		Dust:SetAirResistance( 250 ) 			 
		Dust:SetGravity( Vector( math.Rand( -200 , 200 ), math.Rand( -200 , 200 ), math.Rand( 10 , 100 ) ) )		
		Dust:SetColor( 90,85,75 )
		end
		end

		for i=1, 25*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(0,700)*self.Scale + VectorRand():GetNormalized() * math.random(0,700)*self.Scale )
		Debris:SetDieTime( math.random( 1, 2) * self.Scale )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(5,10)*self.Scale)
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 40 ) 			 			
		Debris:SetColor( 60,60,60 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 	
		end
		end

		local Angle = self.DirVec:Angle()
		for i = 1, self.DebrizzlemyNizzle do 					/// This part makes the trailers ///
		Angle:RotateAroundAxis(Angle:Forward(), (360/self.DebrizzlemyNizzle))
		local DustRing = Angle:Up()
		local RanVec = self.DirVec*math.Rand(1, 5) + (DustRing*math.Rand(2, 5))

			for k = 3, self.Particles do
			local Rcolor = math.random(-20,20)
			local particle1 = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )				
			particle1:SetVelocity((VectorRand():GetNormalized()*math.Rand(1, 2) * self.Size) + (RanVec*self.Size*k*3.5))	
			particle1:SetDieTime( math.Rand( 0.5, 4 )*self.Scale )	
			particle1:SetStartAlpha( math.Rand( 90, 100 ) )			
			particle1:SetEndAlpha(0)	
			particle1:SetGravity((VectorRand():GetNormalized()*math.Rand(5, 10)* self.Size) + Vector(0,0,-50))
			particle1:SetAirResistance( 200+self.Scale*20 ) 		
			particle1:SetStartSize( (5*self.Size)-((k/self.Particles)*self.Size*3) )	
			particle1:SetEndSize( (20*self.Size)-((k/self.Particles)*self.Size) )
			particle1:SetRoll( math.random( -500, 500 )/100 )	
			particle1:SetRollDelta( math.random( -0.5, 0.5 ) )	
			particle1:SetColor( 90+Rcolor,87+Rcolor,80+Rcolor )
			end
		end
 end
 
function EFFECT:Dirt()

		for i=1,5 do 
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*300 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=1, 20*self.Scale do
		local Dust = self.Emitter:Add( "particle/particle_composite", self.Pos )	
		if (Dust) then
		Dust:SetVelocity( self.DirVec * math.random( 100,400)*self.Scale + ((VectorRand():GetNormalized()*300)*self.Scale) )
		Dust:SetDieTime( math.Rand( 2 , 3 ) )
		Dust:SetStartAlpha( 230 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( (50*self.Scale) )
		Dust:SetEndSize( (100*self.Scale) )
		Dust:SetRoll( math.Rand(150, 360) )
		Dust:SetRollDelta( math.Rand(-1, 1) )			
		Dust:SetAirResistance( 150 ) 			 
		Dust:SetGravity( Vector( 0, 0, math.Rand(-100, -400) ) ) 			
		Dust:SetColor( 90,83,68 )
		end
		end

		for i=1, 15*self.Scale do
		local Dust = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Dust) then
		Dust:SetVelocity( self.DirVec * math.random( 100,400)*self.Scale + ((VectorRand():GetNormalized()*400)*self.Scale) )
		Dust:SetDieTime( math.Rand( 1 , 5 )*self.Scale )
		Dust:SetStartAlpha( 50 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( (80*self.Scale) )
		Dust:SetEndSize( (100*self.Scale) )
		Dust:SetRoll( math.Rand(150, 360) )
		Dust:SetRollDelta( math.Rand(-1, 1) )			
		Dust:SetAirResistance( 250 ) 			 
		Dust:SetGravity( Vector( math.Rand( -200 , 200 ), math.Rand( -200 , 200 ), math.Rand( 10 , 100 ) ) )		
		Dust:SetColor( 90,83,68 )
		end
		end

		for i=1, 25*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(0,700)*self.Scale + VectorRand():GetNormalized() * math.random(0,700)*self.Scale )
		Debris:SetDieTime( math.random( 1, 2) * self.Scale )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(5,10)*self.Scale)
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 40 ) 			 			
		Debris:SetColor( 50,53,45 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 	
		end
		end

		local Angle = self.DirVec:Angle()
		for i = 1, self.DebrizzlemyNizzle do 					/// This part makes the trailers ///
		Angle:RotateAroundAxis(Angle:Forward(), (360/self.DebrizzlemyNizzle))
		local DustRing = Angle:Up()
		local RanVec = self.DirVec*math.Rand(2, 6) + (DustRing*math.Rand(1, 4))	

			for k = 3, self.Particles do
			local Rcolor = math.random(-20,20)
			local particle1 = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )				
			particle1:SetVelocity((VectorRand():GetNormalized()*math.Rand(1, 2) * self.Size) + (RanVec*self.Size*k*3.5))	
			particle1:SetDieTime( math.Rand( 0.5, 4 )*self.Scale )	
			particle1:SetStartAlpha( math.Rand( 90, 100 ) )			
			particle1:SetEndAlpha(0)	
			particle1:SetGravity((VectorRand():GetNormalized()*math.Rand(5, 10)* self.Size) + Vector(0,0,-50))
			particle1:SetAirResistance( 200+self.Scale*20 ) 		
			particle1:SetStartSize( (5*self.Size)-((k/self.Particles)*self.Size*3) )	
			particle1:SetEndSize( (20*self.Size)-((k/self.Particles)*self.Size) )
			particle1:SetRoll( math.random( -500, 500 )/100 )	
			particle1:SetRollDelta( math.random( -0.5, 0.5 ) )	
			particle1:SetColor( 90+Rcolor,83+Rcolor,68+Rcolor )
			end
		end
 end

 function EFFECT:Sand()

		for i=0, 45*self.Scale do		// This is the main plume
		local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( self.DirVec * math.random( 50,1000*self.Scale) + VectorRand():GetNormalized()*300*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 5 )*self.Scale )
		Smoke:SetStartAlpha( math.Rand( 100, 120 ) )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 50*self.Scale )
		Smoke:SetEndSize( 120*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-1, 1) )			
		Smoke:SetAirResistance( 200 ) 			 
		Smoke:SetGravity( Vector( 0, 0, math.Rand(-100, -400) ) ) 			
		Smoke:SetColor( 90,83,68 )
		end
		end

		for i=0, 20*self.Scale do		// This is the dirt kickup
		local Dust = self.Emitter:Add( "particle/particle_composite", self.Pos )
		if (Dust) then
		Dust:SetVelocity( self.DirVec * math.random( 100,700)*self.Scale + VectorRand():GetNormalized()*250*self.Scale )
		Dust:SetDieTime( math.Rand( 0.5 , 1,5 ) )
		Dust:SetStartAlpha( 200 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( 60*self.Scale )
		Dust:SetEndSize( 90*self.Scale )
		Dust:SetRoll( math.Rand(150, 360) )
		Dust:SetRollDelta( math.Rand(-1, 1) )			
		Dust:SetAirResistance( 200 ) 			 
		Dust:SetGravity( Vector( 0, 0, math.Rand(-100, -400) ) ) 			
		Dust:SetColor( 90,83,68 )
		end
		end

		for i=0, 25*self.Scale do		// Chunkage
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(50,900)*self.Scale + VectorRand():GetNormalized() * math.random(0,700)*self.Scale )
		Debris:SetDieTime( math.random( 1, 2) * self.Scale )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(5,8)*self.Scale )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 40 ) 			 			
		Debris:SetColor( 53,50,45 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 		
		end
		end

		for i=0, 25*self.Scale do		// Shrapnel
		local Shrapnel = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos+self.DirVec )
		if (Shrapnel) then
		Shrapnel:SetVelocity ( (self.DirVec*700*self.Scale) + (VectorRand():GetNormalized() * 1000*self.Scale) )
		Shrapnel:SetDieTime( math.random( 0.3, 0.5) * self.Scale )
		Shrapnel:SetStartAlpha( 255 )
		Shrapnel:SetEndAlpha( 0 )
		Shrapnel:SetStartSize( math.random(4,7)*self.Scale )
		Shrapnel:SetRoll( math.Rand(0, 360) )
		Shrapnel:SetRollDelta( math.Rand(-5, 5) )			
		Shrapnel:SetAirResistance( 10 ) 			 			
		Shrapnel:SetColor( 53,50,45 )
		Shrapnel:SetGravity( Vector( 0, 0, -600) ) 
		Shrapnel:SetCollide( true )
		Shrapnel:SetBounce( 0.8 )			
		end
		end

		for i=1,5 do 				// Blast flash
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.10 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*200 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=0, 10*self.Scale do		
		local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( self.DirVec * math.random( 30,120*self.Scale) + VectorRand():GetNormalized() * math.random( 50,100*self.Scale) )
		Smoke:SetDieTime( math.Rand( 0.5 , 1 )*self.Scale  )
		Smoke:SetStartAlpha( math.Rand( 80, 100 ) )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 10*self.Scale )
		Smoke:SetEndSize( 30*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 100 ) 			 
		Smoke:SetGravity( Vector( math.random(-20,20)*self.Scale, math.random(-20,20)*self.Scale, 250 ) ) 			
		Smoke:SetColor( 90,83,68 )
		end
		end
		
	
		for i=0, 5*self.Scale do
		local Whisp = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Whisp) then
		Whisp:SetVelocity(VectorRand():GetNormalized() * math.random( 300,600*self.Scale) )
		Whisp:SetDieTime( math.Rand( 4 , 10 )*self.Scale/2  )
		Whisp:SetStartAlpha( math.Rand( 30, 40 ) )
		Whisp:SetEndAlpha( 0 )
		Whisp:SetStartSize( 70*self.Scale )
		Whisp:SetEndSize( 100*self.Scale )
		Whisp:SetRoll( math.Rand(150, 360) )
		Whisp:SetRollDelta( math.Rand(-2, 2) )			
		Whisp:SetAirResistance( 300 ) 			 
		Whisp:SetGravity( Vector( math.random(-40,40)*self.Scale, math.random(-40,40)*self.Scale, 0 ) ) 			
		Whisp:SetColor( 150,150,150 )
		end
		end


				local Density = 40*self.Scale					/// This part is for the dust ring ///
				local Angle = self.DirVec:Angle()
				for i=0, Density do	
				Angle:RotateAroundAxis(Angle:Forward(), (360/Density))
				local ShootVector = Angle:Up()
				local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
				if (Smoke) then
				Smoke:SetVelocity( ShootVector * math.Rand(50,700*self.Scale) )
				Smoke:SetDieTime( math.Rand( 1 , 4 )*self.Scale  )
				Smoke:SetStartAlpha( math.Rand( 90, 120 ) )
				Smoke:SetEndAlpha( 0 )
				Smoke:SetStartSize( 40*self.Scale )
				Smoke:SetEndSize( 70*self.Scale )
				Smoke:SetRoll( math.Rand(0, 360) )
				Smoke:SetRollDelta( math.Rand(-1, 1) )			
				Smoke:SetAirResistance( 200 ) 			 
				Smoke:SetGravity( Vector( math.Rand( -200 , 200 ), math.Rand( -200 , 200 ), math.Rand( 10 , 100 ) ) )			
				Smoke:SetColor( 90,83,68 )
				end	
				end
 end

 function EFFECT:Metal()
			sound.Play( "Bullet.Impact", self.Pos)

		for i=1,5 do 				// Blast flash
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*200 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=0, 30*self.Scale do
		local Whisp = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Whisp) then
		Whisp:SetVelocity(VectorRand():GetNormalized() * math.random( 200,1000*self.Scale) )
		Whisp:SetDieTime( math.Rand( 4 , 10 )*self.Scale/2  )
		Whisp:SetStartAlpha( math.Rand( 50, 70 ) )
		Whisp:SetEndAlpha( 0 )
		Whisp:SetStartSize( 70*self.Scale )
		Whisp:SetEndSize( 100*self.Scale )
		Whisp:SetRoll( math.Rand(150, 360) )
		Whisp:SetRollDelta( math.Rand(-2, 2) )			
		Whisp:SetAirResistance( 300 ) 			 
		Whisp:SetGravity( Vector( math.random(-40,40)*self.Scale, math.random(-40,40)*self.Scale, 0 ) ) 			
		Whisp:SetColor( 120,120,120 )
		end
		end

 		for i=0, 30*self.Scale do 
 		local Sparks = self.Emitter:Add( "effects/spark", self.Pos ) 
 		if (Sparks) then 
 		Sparks:SetVelocity( ((self.DirVec*0.75)+VectorRand()) * math.Rand(200, 600)*self.Scale ) 
 		Sparks:SetDieTime( math.Rand(0.3, 1) ) 				 
 		Sparks:SetStartAlpha( 255 )  				 
 		Sparks:SetStartSize( math.Rand(7, 15)*self.Scale ) 
 		Sparks:SetEndSize( 0 ) 				 
 		Sparks:SetRoll( math.Rand(0, 360) ) 
 		Sparks:SetRollDelta( math.Rand(-5, 5) ) 				 
 		Sparks:SetAirResistance( 20 ) 
 		Sparks:SetGravity( Vector( 0, 0, -600 ) ) 
 		end 	
		end 

 		for i=0, 10*self.Scale do 
 		local Sparks = self.Emitter:Add( "effects/yellowflare", self.Pos ) 
 		if (Sparks) then 
 		Sparks:SetVelocity( VectorRand() * math.Rand(200, 600)*self.Scale ) 
 		Sparks:SetDieTime( math.Rand(1, 1.7) ) 				 
 		Sparks:SetStartAlpha( 200 )  				 
 		Sparks:SetStartSize( math.Rand(10, 13)*self.Scale ) 
 		Sparks:SetEndSize( 0 ) 				 
 		Sparks:SetRoll( math.Rand(0, 360) ) 
 		Sparks:SetRollDelta( math.Rand(-5, 5) ) 				 
 		Sparks:SetAirResistance( 100 ) 
 		Sparks:SetGravity( Vector( 0, 0, -60 ) ) 
 		end 	
		end 

end


 function EFFECT:Smoke()
				sound.Play( "Bullet.Impact", self.Pos)

		for i=1,5 do 				// Blast flash
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*200 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=0, 30*self.Scale do
		local Whisp = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Whisp) then
		Whisp:SetVelocity(VectorRand():GetNormalized() * math.random( 200,1200*self.Scale) )
		Whisp:SetDieTime( math.Rand( 4 , 10 )*self.Scale/2  )
		Whisp:SetStartAlpha( math.Rand( 35, 50 ) )
		Whisp:SetEndAlpha( 0 )
		Whisp:SetStartSize( 70*self.Scale )
		Whisp:SetEndSize( 100*self.Scale )
		Whisp:SetRoll( math.Rand(150, 360) )
		Whisp:SetRollDelta( math.Rand(-2, 2) )			
		Whisp:SetAirResistance( 300 ) 			 
		Whisp:SetGravity( Vector( math.random(-40,40)*self.Scale, math.random(-40,40)*self.Scale, 0 ) ) 			
		Whisp:SetColor( 120,120,120 )
		end
		end


		for i=1, 25*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_tile"..math.random(1,2), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(100,600)*self.Scale + VectorRand():GetNormalized() * math.random(100,1200)*self.Scale )
		Debris:SetDieTime( math.random( 1, 3) * self.Scale )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(5,10)*self.Scale)
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 40 ) 			 			
		Debris:SetColor( 70,70,70 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 	
		end
		end

		local Angle = self.DirVec:Angle()
		for i = 1, self.DebrizzlemyNizzle do 					/// This part makes the trailers ///
		Angle:RotateAroundAxis(Angle:Forward(), (360/self.DebrizzlemyNizzle))
		local DustRing = Angle:Up()
		local RanVec = self.DirVec*math.Rand(1, 4) + (DustRing*math.Rand(3, 4))

			for k = 3, self.Particles do
			local Rcolor = math.random(-20,20)
			local particle1 = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )				
			particle1:SetVelocity((VectorRand():GetNormalized()*math.Rand(1, 2) * self.Size) + (RanVec*self.Size*k*3.5))	
			particle1:SetDieTime( math.Rand( 0, 3 )*self.Scale )	
			particle1:SetStartAlpha( math.Rand( 90, 100 ) )			
			particle1:SetEndAlpha(0)	
			particle1:SetGravity((VectorRand():GetNormalized()*math.Rand(5, 10)* self.Size) + Vector(0,0,-50))
			particle1:SetAirResistance( 200+self.Scale*20 ) 		
			particle1:SetStartSize( (5*self.Size)-((k/self.Particles)*self.Size*3) )	
			particle1:SetEndSize( (20*self.Size)-((k/self.Particles)*self.Size) )
			particle1:SetRoll( math.random( -500, 500 )/100 )	
			particle1:SetRollDelta( math.random( -0.5, 0.5 ) )	
			particle1:SetColor( 90+Rcolor,85+Rcolor,75+Rcolor )
			end
		end
end

 function EFFECT:Wood()

		for i=1,5 do 				
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*200 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=0, 30*self.Scale do
		local Whisp = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Whisp) then
		Whisp:SetVelocity(VectorRand():GetNormalized() * math.random( 200,1000)*self.Scale )
		Whisp:SetDieTime( math.Rand( 4 , 10 )*self.Scale/2  )
		Whisp:SetStartAlpha( math.Rand( 70, 90 ) )
		Whisp:SetEndAlpha( 0 )
		Whisp:SetStartSize( 70*self.Scale )
		Whisp:SetEndSize( 100*self.Scale )
		Whisp:SetRoll( math.Rand(150, 360) )
		Whisp:SetRollDelta( math.Rand(-2, 2) )			
		Whisp:SetAirResistance( 300 ) 			 
		Whisp:SetGravity( Vector( math.random(-40,40)*self.Scale, math.random(-40,40)*self.Scale, 0 ) ) 			
		Whisp:SetColor( 90,85,75 )
		end
		end

		for i=0, 20*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_wood"..math.random(1,2), self.Pos+self.DirVec )
		if (Debris) then
		Debris:SetVelocity( self.DirVec * math.random(50,500)*self.Scale + VectorRand():GetNormalized() * math.random(200,900)*self.Scale )
		Debris:SetDieTime( math.random( 0.75, 2) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(10,15)*self.Scale )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 70 ) 			 			
		Debris:SetColor( 90,85,75 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 		
		end
		end
end

 function EFFECT:Glass()

		for i=1,5 do 				// Blast flash
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*200 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=0, 30*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_glass"..math.random(1,3), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( VectorRand():GetNormalized() * math.random(100,600)*self.Scale )
		Debris:SetDieTime( math.random( 1, 2.5) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(3,7)*self.Scale )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-15, 15) )			
		Debris:SetAirResistance( 50 ) 			 			
		Debris:SetColor( 200,200,200 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 
		Debris:SetCollide( true )
		Debris:SetBounce( 0.5 )				
		end
		end


		for i=0, 30*self.Scale do
		local Whisp = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Whisp) then
		Whisp:SetVelocity(VectorRand():GetNormalized() * math.random( 200,800*self.Scale) )
		Whisp:SetDieTime( math.Rand( 4 , 10 )*self.Scale/2  )
		Whisp:SetStartAlpha( math.Rand( 35, 50 ) )
		Whisp:SetEndAlpha( 0 )
		Whisp:SetStartSize( 70*self.Scale )
		Whisp:SetEndSize( 100*self.Scale )
		Whisp:SetRoll( math.Rand(150, 360) )
		Whisp:SetRollDelta( math.Rand(-2, 2) )			
		Whisp:SetAirResistance( 300 ) 			 
		Whisp:SetGravity( Vector( math.random(-40,40)*self.Scale, math.random(-40,40)*self.Scale, 0 ) ) 			
		Whisp:SetColor( 150,150,150 )
		end
		end
		
end

 function EFFECT:Blood()
		for i=0, 30*self.Scale do		// If you recieve over 50,000 joules of energy, you become red mist.
		local Smoke = self.Emitter:Add( "particle/particle_composite", self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.random(100,600)*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 2 ) )
		Smoke:SetStartAlpha( 80 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 30*self.Scale )
		Smoke:SetEndSize( 100*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(0, -200) ) ) 			
		Smoke:SetColor( 70,35,35 )
		end
		end

		for i=0, 20*self.Scale do		// Add some finer details....
		local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.random(200,600)*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 4 ) )
		Smoke:SetStartAlpha( 120 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 30*self.Scale )
		Smoke:SetEndSize( 100*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(-50, -300) ) ) 			
		Smoke:SetColor( 70,35,35 )
		end
		end

		for i=1,5 do 				// Into the flash!
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*300 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=1, 20*self.Scale do		// Chunkage NOT contained
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos-(self.DirVec*5) )
		if (Debris) then
		Debris:SetVelocity ( VectorRand():GetNormalized() * 400*self.Scale )
		Debris:SetDieTime( math.random( 0.3, 0.6) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( 8 )
		Debris:SetEndSize( 9 )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 30 ) 			 			
		Debris:SetColor( 70,35,35 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 
		Debris:SetCollide( true )
		Debris:SetBounce( 0.2 )			
		end
		end

end

 function EFFECT:YellowBlood()
		for i=0, 30*self.Scale do		// If you recieve over 50,000 joules of energy, you become red mist.
		local Smoke = self.Emitter:Add( "particle/particle_composite", self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.random(100,600)*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 2 ) )
		Smoke:SetStartAlpha( 80 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 30*self.Scale )
		Smoke:SetEndSize( 100*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(0, -200) ) ) 			
		Smoke:SetColor( 120,120,0 )
		end
		end

		for i=0, 20*self.Scale do		// Add some finer details....
		local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.random(200,600)*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 4 ) )
		Smoke:SetStartAlpha( 120 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 30*self.Scale )
		Smoke:SetEndSize( 100*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(-50, -300) ) ) 			
		Smoke:SetColor( 120,120,0 )
		end
		end

		for i=1,5 do 				// Into the flash!
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*300 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=1, 20*self.Scale do		// Chunkage NOT contained
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos-(self.DirVec*5) )
		if (Debris) then
		Debris:SetVelocity ( VectorRand():GetNormalized() * 400*self.Scale )
		Debris:SetDieTime( math.random( 0.3, 0.6) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( 8 )
		Debris:SetEndSize( 9 )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 30 ) 			 			
		Debris:SetColor( 120,120,0 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 
		Debris:SetCollide( true )
		Debris:SetBounce( 0.2 )			
		end
		end
end
 

function EFFECT:Think( )
return false
end

function EFFECT:Render()
end
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/moby_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

function EFFECT:Think()

	util.ParticleTracerEx( 
		"moby_tracer", 	--particle system
		self.StartPos, 	--startpos
		self.EndPos, 	--endpos
		true, 			--do whiz effect
		-1, 			--entity index
		-1  			--attachment
	)
	
	return false
	
end
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/rb655_extinguisher_effect.lua:
return gluapack()()
--PATH lua/effects/red_tracer.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/repulse_charge.lua:
return gluapack()()
--PATH lua/effects/rw_sw_dual_laser_red.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("effects/sw_laser_red_main")
local MaterialFront 		= Material("effects/sw_laser_red_front")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 0
			dlight.b = 0
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--PATH lua/effects/rw_sw_impact_grey.lua:
return gluapack()()
--PATH lua/effects/rw_sw_impact_yellow.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_yellow" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(400, 900));
			particle_s:SetDieTime(math.Rand(2.1, 2.7));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(8, 16));
			particle_s:SetEndSize(math.Rand(0, 4));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(110, 130);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--PATH lua/effects/rw_sw_laser_black.lua:

TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD 			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("effects/sw_l/rw_sw_laser_m_black")
local MaterialFront 		= Material("effects/sw_l/rw_sw_laser_f_black")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end
		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()
			if (IsValid(pl)) then
				local vm = pl:GetViewModel()
				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end
	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed 	--self.LifeTime = (diff:Length() - (self.Length/2) ) / self.Speed
	local weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 0
			dlight.b = 0
			dlight.brightness = 2
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--PATH lua/effects/rw_sw_laser_white.lua:
return gluapack()()
--PATH lua/effects/rw_sw_muzzleflash_purple.lua:
return gluapack()()
--PATH lua/effects/rw_sw_muzzleflash_redpink.lua:
return gluapack()()
--PATH lua/effects/rw_sw_stunwave_blue.lua:
return gluapack()()
--PATH lua/effects/rw_sw_stunwave_blue.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4500;
EFFECT.Length				= 64;

local MaterialFront			= Material( "cs574/stun_tracers/sw_stunwave_blue" );

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

EFFECT.WaveSize = 0

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if (self.WaveSize < 45) then
		self.WaveSize = self.WaveSize + 1
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(startPos, 1 + self.WaveSize, 1 + self.WaveSize, color_white)
end

--PATH lua/effects/rw_sw_stunwave_red.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/saber_hit.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.Dir = data:GetNormal()

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	self:Spark( self.Pos, self.Dir )
	self:Smoke( self.Pos, self.Dir )
end


function EFFECT:Smoke( pos, dir )
	local emitter = ParticleEmitter( pos, false )
	
	for i = 0,10 do
		local particle = emitter:Add( Materials[ math.random(1,table.Count( Materials )) ], pos )
		
		local vel = VectorRand() * math.Rand(200,600)
		
		if particle then			
			particle:SetVelocity( vel )
			particle:SetDieTime( math.Rand(0.5,1.5) )
			particle:SetAirResistance( 1000 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 0 )
			particle:SetEndSize( math.Rand(50,120) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 40,40,40 )
			particle:SetGravity( Vector(0,0,200) )
			particle:SetCollide( false )
		end
	end
	
	emitter:Finish()
end

function EFFECT:Spark( pos, dir )
	local emitter = ParticleEmitter( pos, false )
	
	for i = 0, 20 do
		local particle = emitter:Add( "sprites/light_glow02_add", pos )
		
		local vel = VectorRand() * 100 + dir * 40
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(2,4) )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(2,4) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetColor( 255,100,0 )
			particle:SetGravity( Vector(0,0,-600) )

			particle:SetAirResistance( 0 )
			
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
		end
	end
	
	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end
	
	return true
end

local mat = Material( "sprites/light_glow02_add" )

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( mat )
	render.DrawSprite( self.Pos + self.Dir, 150 * Scale, 150 * Scale, Color( 255, 150, 50, 255) ) 
end

--PATH lua/effects/shk_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.Speed	= 9200
EFFECT.Length	= 512

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )
	
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
	ParticleEffect( "tbolt_tracer", endPos, Angle( 0, 0, 0 ), self.Entity )
	
	local dlight = DynamicLight( self.Entity:EntIndex() )
	if ( dlight ) then
		dlight.pos = endPos
		dlight.r = 150
		dlight.g = 145
		dlight.b = 255
		dlight.brightness = 2
		dlight.Decay = 2048
		dlight.Size = 256
		dlight.DieTime = CurTime() + 0.5
	end

end
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/spectra_tracer.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/spr_tracer_noattach.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/swep_flamethrower_flame2/init.lua:
return gluapack()()
--PATH lua/effects/tbolt_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

function EFFECT:Think()

	util.ParticleTracerEx( 
		"tbolt_tracer", 	--particle system
		self.StartPos, 	--startpos
		self.EndPos, 	--endpos
		true, 			--do whiz effect
		-1, 			--entity index
		-1  			--attachment
	)
	
	return false
	
end

--PATH lua/effects/tfa_muzzle_smoketrail/init.lua:
return gluapack()()
--PATH lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false
EFFECT.UseDynamicLight = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()

	local dlight
	if self.UseDynamicLight then
		dlight = DynamicLight(ownerent:EntIndex())

		if (dlight) then
			dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
			dlight.r = self.Color.r
			dlight.g = self.Color.g
			dlight.b = self.Color.b
			dlight.brightness = 4.5
			dlight.decay = 200 / self.Life
			dlight.size = self.FlashSize * 96
			dlight.dietime = CurTime() + self.Life
		end
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/effects/tfa_muzzleflash_rifle/init.lua:
return gluapack()()
--PATH lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false
EFFECT.UseDynamicLight = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()

	local dlight
	if self.UseDynamicLight then
		dlight = DynamicLight(ownerent:EntIndex())

		if (dlight) then
			dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
			dlight.r = self.Color.r
			dlight.g = self.Color.g
			dlight.b = self.Color.b
			dlight.brightness = 4.5
			dlight.decay = 200 / self.Life
			dlight.size = self.FlashSize * 96
			dlight.dietime = CurTime() + self.Life
		end
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/effects/tfa_muzzleflash_shotgun/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.125
EFFECT.XFlashSize = 0
EFFECT.FlashSize = 1.3
EFFECT.SmokeSize = 2
EFFECT.SparkSize = 1.5
EFFECT.HeatSize = 2
EFFECT.Color = Color(255, 225, 128)
EFFECT.ColorSprites = false

--PATH lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false
EFFECT.UseDynamicLight = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()

	local dlight
	if self.UseDynamicLight then
		dlight = DynamicLight(ownerent:EntIndex())

		if (dlight) then
			dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
			dlight.r = self.Color.r
			dlight.g = self.Color.g
			dlight.b = self.Color.b
			dlight.brightness = 4.5
			dlight.decay = 200 / self.Life
			dlight.size = self.FlashSize * 96
			dlight.dietime = CurTime() + self.Life
		end
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/effects/tfa_muzzlesmoke/init.lua:
local ang
local limit_particle_cv = GetConVar("cl_tfa_fx_muzzlesmoke_limited")
local SMOKEDELAY = 1.5

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.WeaponEntOG = self.WeaponEnt
	if limit_particle_cv:GetBool() and self.WeaponEnt:GetOwner() ~= LocalPlayer() then return end
	self.Attachment = data:GetAttachment()
	local smokepart = "smoke_trail_tfa"
	local delay = self.WeaponEnt.GetStatL and self.WeaponEnt:GetStatL("SmokeDelay") or self.WeaponEnt.SmokeDelay

	if self.WeaponEnt.SmokeParticle then
		smokepart = self.WeaponEnt.SmokeParticle
	elseif self.WeaponEnt.SmokeParticles then
		smokepart = self.WeaponEnt.SmokeParticles[self.WeaponEnt.DefaultHoldType or self.WeaponEnt.HoldType] or smokepart
	end

	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if not self.WeaponEnt:IsFirstPerson() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	if TFA.GetMZSmokeEnabled == nil or TFA.GetMZSmokeEnabled() then
		local e = self.WeaponEnt
		local w = self.WeaponEntOG
		local a = self.Attachment
		local tn = "tfasmokedelay_" .. w:EntIndex() .. "_" .. a
		local sp = smokepart

		if timer.Exists(tn) then
			timer.Remove(tn)
		end

		e.SmokePCF = e.SmokePCF or {}
		local _a = w:GetStatL("IsAkimbo") and a or 1

		if IsValid(e.SmokePCF[_a]) then
			e.SmokePCF[_a]:StopEmission()
		end

		timer.Create(tn, delay or SMOKEDELAY, 1, function()
			if not IsValid(e) then return end
			e.SmokePCF[_a] = CreateParticleSystem(e, sp, PATTACH_POINT_FOLLOW, a)

			if IsValid(e.SmokePCF[_a]) then
				e.SmokePCF[_a]:StartEmission()
			end
		end)
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/tfa_tracer_cryo/init.lua:
return gluapack()()
--PATH lua/effects/tfa_tracer_cryo/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Col1 = Color(255, 255, 255, 255) --Color(225,225,225,225)
EFFECT.Col2 = Color(65, 128, 255, 200)
EFFECT.Speed = 1024*3
EFFECT.TracerLength = 128

--[[---------------------------------------------------------
Init( data table )
-----------------------------------------------------------]]
function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
	self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.Length = (self.EndPos - self.StartPos):Length()
	--self.Alpha = 255
	self.Life = 0
	self.MaxLife = self.Length / self.Speed
	self:SetRenderBoundsWS(self.StartPos, self.EndPos, Vector(1000,1000,1000))
	self.CurPos = self.StartPos
end

--[[---------------------------------------------------------
THINK
-----------------------------------------------------------]]
function EFFECT:Think()
	self.Life = self.Life + FrameTime() * (1 / self.MaxLife)
	--self.Alpha = 255 * ( 1 - self.Life )

	return self.Life < 1
end

--[[---------------------------------------------------------
Draw the effect
-----------------------------------------------------------]]
local lerpedcol = Color(225, 225, 225, 225)

function EFFECT:Render()
render.SetMaterial(self.Mat)
lerpedcol.r = Lerp(self.Life, self.Col1.r, self.Col2.r)
lerpedcol.g = Lerp(self.Life, self.Col1.g, self.Col2.g)
lerpedcol.b = Lerp(self.Life, self.Col1.b, self.Col2.b)
lerpedcol.a = Lerp(self.Life, self.Col1.a, self.Col2.a)
local startbeampos = LerpVector(self.Life, self.StartPos, self.EndPos)
local endbeampos = LerpVector(self.Life + self.TracerLength / self.Length, self.StartPos, self.EndPos)
render.DrawBeam(startbeampos, endbeampos, 8, 0, 1, lerpedcol)
end

--PATH lua/effects/tfa_tracer_fubar_light_aq/init.lua:
return gluapack()()
--PATH lua/effects/tfa_tracer_incendiary/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Col1 = Color(255, 90, 25, 200) --Color(225,225,225,225)
EFFECT.Col2 = Color(225, 25, 25, 200)
EFFECT.Speed = 8192
EFFECT.TracerLength = 128

--[[---------------------------------------------------------
Init( data table )
-----------------------------------------------------------]]
function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
	self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.Length = (self.EndPos - self.StartPos):Length()
	--self.Alpha = 255
	self.Life = 0
	self.MaxLife = self.Length / self.Speed
	self:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.CurPos = self.StartPos
end

--[[---------------------------------------------------------
THINK
-----------------------------------------------------------]]
function EFFECT:Think()
	self.Life = self.Life + FrameTime() * (1 / self.MaxLife)
	--self.Alpha = 255 * ( 1 - self.Life )

	return self.Life < 1
end

--[[---------------------------------------------------------
Draw the effect
-----------------------------------------------------------]]
local lerpedcol = Color(225, 225, 225, 225)

function EFFECT:Render()
	render.SetMaterial(self.Mat)
	lerpedcol.r = Lerp(self.Life, self.Col1.r, self.Col2.r)
	lerpedcol.g = Lerp(self.Life, self.Col1.g, self.Col2.g)
	lerpedcol.b = Lerp(self.Life, self.Col1.b, self.Col2.b)
	lerpedcol.a = Lerp(self.Life, self.Col1.a, self.Col2.a)
	local startbeampos = Lerp(self.Life, self.StartPos, self.EndPos)
	local endbeampos = Lerp(self.Life + self.TracerLength / self.Length, self.StartPos, self.EndPos)
	render.DrawBeam(startbeampos, endbeampos, 8, 0, 1, lerpedcol)
end

--PATH lua/effects/tfa_tracer_plasma/init.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tracer_red/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(255, 0, 0)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(255, 0, 0)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 255
        dlight.g = 0
        dlight.b = 0
        dlight.brightness = 7
        dlight.Decay = 1000
        dlight.Size = 500
        dlight.DieTime = CurTime() + 3
    end
end
end
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tracer_yellow/init.lua:
return gluapack()()
--PATH lua/effects/vh_tracer.lua:
return gluapack()()
--PATH lua/effects/vj_medium_dust1/init.lua:
return gluapack()()
--PATH addons/[tfres] datapad/lua/tfres/datapad/apps/areszty.lua:
local APP = {}

APP.Name = "Areszty"                   -- Nazwa
APP.Restricted = true               -- Dosownie nic nie zmienia
APP.Category = {["Gwardia Coruscant"] = true, ["RSB"] = true}     -- Kategoria joba ktra ma dostp

APP.Derma = function(parent)
    local x, y = parent:GetWide(), parent:GetTall()
    local pan = vgui.Create("DPanel", parent)
    pan:SetSize(x, y)
    pan:Dock(FILL)
    pan:SetBackgroundColor(Color(0, 0, 0))

    local html = vgui.Create("DHTML", pan)
    html:Dock(FILL)

    local steamMap = {} -- steamID64 -> player

    -- Funkcja do odbierania danych z JS
    html:AddFunction("datapad", "receive", function(json)
        local data = util.JSONToTable(json)
        if not data or not data.aresztowany then return end

        local target = steamMap[data.aresztowany]
        if not IsValid(target) then
            print("[ArrestPanel] Nieprawidowy cel:", data.aresztowany)
            return
        end

        tfres.Global:NetServer("Datapad_arrest",data)

    end)

    -- adujemy HTML po dodaniu funkcji
    html:SetHTML([[
<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>Panel Aresztowania</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(to bottom, #c13535, #891d1d);
            background-repeat: no-repeat;
            background-size: cover;
            background-attachment: fixed;
            color: white;
            text-align: center;
            position: relative;
            overflow-x: hidden;
            box-sizing: border-box;
        }

        *, *::before, *::after {
            box-sizing: inherit;
        }

        body::before {
            content: "";
            background-image: url("https://static.wikia.nocookie.net/starwars/images/4/4c/Senate_seal.svg/revision/latest?cb=20080220004246");
            background-size: 100%;
            background-position: center;
            background-repeat: no-repeat;
            position: absolute;
            opacity: 0.3;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 500px;
            margin: 40px auto;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
        }

        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 10px;
            margin-bottom: 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            box-sizing: border-box;
        }

        .input-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .half-input {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .label {
            text-align: left;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .note {
            font-size: 12px;
            margin-bottom: 10px;
        }

        #confirmBtn {
            background: linear-gradient(to bottom, #6cff4c, #40cc2e);
            border: none;
            color: black;
            font-size: 20px;
            padding: 10px 40px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #confirmBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px #4aff00;
        }

        #errorMessage {
            color: #ff9999;
            font-size: 14px;
            margin-top: -15px;
            margin-bottom: 15px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Aresztowany</h2>
        <select id="aresztowany">
            <option value="">-- Wybierz osob --</option>
        </select>

        <h2>Zarzuty</h2>
        <input type="text" id="zarzuty">

        <div class="input-row">
            <div class="half-input">
                <div class="label">Czas</div>
                <input type="number" id="czas" placeholder="1 = minuta">
            </div>
            <div class="half-input">
                <div class="label">Grzywna</div>
                <input type="number" id="grzywna">
            </div>
        </div>

        <div id="errorMessage"></div>

        <p class="note">
            Ja, niej podpisany, potwierdzam, e zarzuty postawione wobec osoby aresztowanej s prawdziwe, a czas aresztu oraz wysoko grzywny s zgodne z obowizujcym taryfikatorem.
        </p>

        <input type="text" id="nick" placeholder="Podpisz si">

        <br><br>
        <button id="confirmBtn" onclick="zatwierdz()">Zatwierd</button>
    </div>

    <script>
        function zatwierdz() {
            const czas = parseInt(document.getElementById('czas').value);

            if (czas > 30) {
                const msg = document.getElementById('errorMessage');
                msg.textContent = "Nie mona ustawi czasu wicej ni 30 minut. Jeli uwaasz e powinno by inaczej postj sam 30 minut w miejscu i nic nie rb lub napisz do Troy na discordzie.";
                msg.style.display = 'block';
                setTimeout(() => msg.style.display = 'none', 10000);
                return;
            }

            const dane = {
                aresztowany: document.getElementById('aresztowany').value,
                zarzuty: document.getElementById('zarzuty').value,
                czas: czas,
                grzywna: parseInt(document.getElementById('grzywna').value),
                nick: document.getElementById('nick').value
            };

            if (!dane.nick || !dane.aresztowany) {
                alert("Wypenij wszystkie pola.");
                return;
            }

            if (window.gmod) {
                datapad.receive(JSON.stringify(dane));
            } else {
                alert("Brak gmod");
            }
        }

        function zaladujAresztowanych(tablica) {
            const select = document.getElementById('aresztowany');
            select.innerHTML = '<option value="">-- Wybierz osob --</option>';
            for (let i = 0; i < tablica.length; i++) {
                const entry = tablica[i];
                const opt = document.createElement('option');
                opt.value = entry.id;
                opt.textContent = entry.nick;
                select.appendChild(opt);
            }
        }

        window.gmod = {
            provideList: zaladujAresztowanych
        };
    </script>
</body>
</html>
    ]])

    -- Czekamy chwil i wstrzykujemy dane
    timer.Simple(0.2, function()
        if not IsValid(html) then return end

        html:Call("document.getElementById('nick').value = " .. string.format("%q", LocalPlayer():Nick()))

        local list = {}
        for _, ply in ipairs(ents.FindInSphere(LocalPlayer():GetPos(), 300)) do
            if ply:IsPlayer() and ply:HasWeapon("weapon_handcuffed") then
                local sid = ply:SteamID64()
                table.insert(list, { nick = ply:Nick(), id = sid })
                steamMap[sid] = ply
            end
        end

        local json = util.TableToJSON(list)
        json = string.Replace(json, "\\", "\\\\")
        json = string.Replace(json, "\"", "\\\"")

        html:Call("gmod.provideList(JSON.parse(\"" .. json .. "\"))")
    end)
end

return APP

--PATH addons/!whitelist/lua/tfres/ranks/ranksandhide.lua:
local dev = {
    name = "Developer",
    color = Color(105, 222, 194),
    ["76561198835351406"] = true, -- Antek
    ["76561199111330809"] = true, -- Santo
    ["76561198327810923"] = true, -- Mexico
    ["76561198930387092"] = true, -- Grzechu
    ["76561198320730426"] = true, -- Frosti
}
local zarzad = {
    name = "Zarzd",
    color = Color(255,0,0),
    ["76561198146699133"] = true, -- Troy
    ["76561198196280105"] = true, -- House
    ["76561198799155972"] = true, -- Panda
    ["76561198988563123"] = true, -- Peluge
}
tfres.CustomRanks = {}
table.insert(tfres.CustomRanks,dev)
table.insert(tfres.CustomRanks,zarzad)

function CustomRank(client)
    if client and client.IsValid and client:IsValid() then
        for k,v in ipairs(tfres.CustomRanks) do
            if v[client:SteamID64()] then
               return v.name, v.color
            end
        end
    end
end

hook.Add("onyx.scoreboard.ShouldHidePlayer","hidecustomrank",function(ply)
	    local customrank, customcolor = CustomRank(ply)
        if !customrank then return end
        return ply:GetNWBool("HideCustom")
end)
if SERVER then
    tfres.Global:RegisterNetwork("HideScoreboard",function(data,ply)
        local customrank, customcolor = CustomRank(ply)
        if !customrank then return end
        ply:SetNWBool("HideCustom",!ply:GetNWBool("HideCustom",false))
    end)
end